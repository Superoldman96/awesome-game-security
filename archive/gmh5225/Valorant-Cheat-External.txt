Project Path: arc_gmh5225_Valorant-Cheat-External_ajvwiq9r

Source Tree:

```txt
arc_gmh5225_Valorant-Cheat-External_ajvwiq9r
├── Driver
│   ├── EFI
│   │   └── Boot
│   │       └── bootx64.efi
│   └── memory.efi
├── Private Esp
│   ├── EspUI
│   │   ├── 2h5k Box.h
│   │   ├── C_GamefMan.h
│   │   ├── Camera.cpp
│   │   ├── Camera.h
│   │   ├── D3D11Renderer.cpp
│   │   ├── D3D11Renderer.h
│   │   ├── D3D11Shader.h
│   │   ├── Engine.h
│   │   ├── Entity.cpp
│   │   ├── Entity.h
│   │   ├── Features.h
│   │   ├── Fov.h
│   │   ├── Globals.h
│   │   ├── Helper.h
│   │   ├── Hook.cpp
│   │   ├── Hook.h
│   │   ├── Line.cpp
│   │   ├── Menu 2.h
│   │   ├── Menu.cpp
│   │   ├── Menu.h
│   │   ├── Offsets.h
│   │   ├── QAngle.hpp
│   │   ├── Render.h
│   │   ├── SDKMisc.h
│   │   ├── Settings.cpp
│   │   ├── Settings.h
│   │   ├── StateSaver.cpp
│   │   ├── Utils.h
│   │   ├── VMatrix.cpp
│   │   ├── VMatrix.hpp
│   │   ├── ValorantESP.filters
│   │   ├── Vanguard.cpp
│   │   ├── Vector.hpp
│   │   ├── Vector2D.cpp
│   │   ├── Vector2D.hpp
│   │   ├── Vector4D.cpp
│   │   ├── Vector4D.hpp
│   │   ├── Visuals.cpp
│   │   ├── dllmain.cpp
│   │   ├── menu 2.cpp
│   │   ├── nuklear_d3d11.cpp
│   │   └── nuklear_d3d11.h
│   └── imgui
│       ├── imconfig.h
│       ├── imgui.cpp
│       ├── imgui.h
│       ├── imgui_demo.cpp
│       ├── imgui_draw.cpp
│       ├── imgui_impl_dx9.cpp
│       ├── imgui_impl_dx9.h
│       ├── imgui_impl_glfw.cpp
│       ├── imgui_impl_glfw.h
│       ├── imgui_impl_opengl3.cpp
│       ├── imgui_impl_opengl3.h
│       ├── imgui_impl_win32.cpp
│       ├── imgui_impl_win32.h
│       ├── imgui_internal.h
│       ├── imgui_tables.cpp
│       ├── imgui_widgets.cpp
│       ├── imstb_rectpack.h
│       ├── imstb_textedit.h
│       └── imstb_truetype.h
├── README.md
├── Valorant Spoofer
│   ├── disk.cpp
│   ├── fnv.hpp
│   ├── gpu.hpp
│   ├── hwid_spoofer.vcxproj.filters
│   ├── hwid_spoofer.vcxproj.user
│   ├── log.hpp
│   ├── main.cpp
│   ├── pattern.cpp
│   ├── pattern.hpp
│   ├── raid_extension.hpp
│   └── util.hpp
└── Valorant-Aimbot
    └── AIMBOT
        ├── -Module-.cs
        ├── Aimbot C#.cs
        ├── HookRender
        │   ├── CheatSDK.h
        │   └── Hooks
        │       ├── ClientMode.h
        │       ├── DirectX.h
        │       ├── GameMovement.h
        │       ├── Runpe.h
        │       └── main.cpp
        ├── MainForm.Designer.cs
        ├── MainForm.cs
        ├── MainForm.resources
        ├── OverlayForm.Designer.cs
        ├── OverlayForm.resources
        ├── ProcessedByFody.cs
        ├── Program.cs
        ├── Properties
        │   ├── AssemblyInfo.cs
        │   ├── Resources.cs
        │   ├── Resources.resources
        │   ├── Settings.Designer.cs
        │   └── Settings.settings
        ├── SplashScreen.Designer.cs
        ├── SplashScreen.cs
        └── SplashScreen.resources

```

`Private Esp/EspUI/2h5k Box.h`:

```h
#pragma once

#include "D3D11Renderer.h"

class D3D11StateSaver
{
private:
	bool						m_savedState;
	D3D_FEATURE_LEVEL			m_featureLevel;
	ID3D11DeviceContext* m_pContext;
	D3D11_PRIMITIVE_TOPOLOGY	m_primitiveTopology;
	ID3D11InputLayout* m_pInputLayout;
	ID3D11BlendState* m_pBlendState;
	float						m_blendFactor[4];
	UINT						m_sampleMask;
	ID3D11DepthStencilState* m_pDepthStencilState;
	UINT						m_stencilRef;
	ID3D11RasterizerState* m_pRasterizerState;
	ID3D11ShaderResourceView* m_pPSSRV;
	ID3D11SamplerState* m_pSamplerState;
	ID3D11VertexShader* m_pVS;
	ID3D11ClassInstance* m_pVSClassInstances[256];
	UINT						m_numVSClassInstances;s
	ID3D11Buffer* m_pVSConstantBuffer;
	ID3D11GeometryShader* m_pGS;
	ID3D11ClassInstance* m_pGSClassInstances[256];
	UINT						m_numGSClassInstances;
	ID3D11Buffer* m_pGSConstantBuffer;
	ID3D11ShaderResourceView* m_pGSSRV;s
	ID3D11PixelShader* m_pPS;
	ID3D11ClassInstance* m_pPSClassInstances[256];
	UINT						m_numPSClassInstances;
	ID3D11HullShader* m_pHS;
	ID3D11ClassInstance* m_pHSClassInstances[256];
	UINT						m_numHSClassInstances;
	ID3D11DomainShader* m_pDS;
	ID3D11ClassInstance* m_pDSClassInstances[256];
	UINT						m_numDSClassInstances;
	ID3D11Buffer* m_pVB;
	UINT						m_vertexStride;
	UINT						m_vertexOffset;
	ID3D11Buffer* m_pIndexBuffer;
	DXGI_FORMAT					m_indexFormat;
	UINT						m_indexOffset;
	ID3D11HullShader* m_pHS;
	ID3D11ClassInstance* m_pHSClassInstances[256];

	D3D11StateSaver(const D3D11StateSaver&);
	D3D11StateSaver& operator=(const D3D11StateSaver&);

public:
	D3D11StateSaver();
	~D3D11StateSaver();

	HRESULT saveCurrentState(ID3D11DeviceContext* pContext);
	HRESULT restoreSavedState();
	void releaseSavedState();
};
delete <<

```

`Private Esp/EspUI/C_GamefMan.h`:

```h
#pragma once
#include <cstdint>

class C_Team
{
public:
	char pad_0000[414]; //0x0000
	int16_t m_sTeam; //0x019E
	char pad_01A0[672]; //0x01A0
}; //Size: 0x0440

class C_EntityRep
{
public:
	char pad_0000[168]; //0x0000
	C_Team* C_Team; //0x00A8
	char pad_00B0[24]; //0x00B0
}; //Size: 0x00C8

class C_Entitys
{
public:
	char pad_0000[40]; //0x0000
	C_EntityRep* C_EntityRep; //0x0028
	char pad_0030[968]; //0x0030
}; //Size: 0x03F8
extern C_Entity* g_pEntity;

class C_EntityList
{
public:
	char pad_0000[64]; //0x0000
}; //Size: 0x0040

class C_GameMan
{
public:
	char pad_0000[456]; //0x0000
	C_EntityList* C_EntityList; //0x01C8
	int8_t m_iMaxEntitys; //0x01D0
	char pad_01D1[1978]; //0x01D1
	float m_fTime; //0x098B
	char pad_098F[692]; //0x098F
}; //Size: 0x0C43
extern C_GameMan* g_pGameMan;

delete <<
```

`Private Esp/EspUI/Camera.cpp`:

```cpp
#include "Vector.hpp"
#include "Camera.h"

Vector C_Camera::GetViewRight()
{
	return *(Vector*)((uintptr_t)this + 0xD0);
}

Vector C_Camera::GetViewUp()
{
	return *(Vector*)((uintptr_t)this + 0xE0);
}

Vector C_Camera::GetViewForward()s
{
	return *(Vector*)((uintptr_t)this + 0xF0);
}

Vector C_Camera::GetViewTranslation()
{
	return *(Vector*)((uintptr_t)this + 0x100);
}

float C_Camera::GetViewFovX()
{
	return *(float*)((uintptr_t)this + 0x110);
}

float C_Camera::GetViewFovY()
{
	return *(float*)((uintptr_t)this + 0x124);
}

delete <<
```

`Private Esp/EspUI/Camera.h`:

```h
#pragma once

class C_Camera
{
public:
	Vector GetViewRight();
	Vector GetViewUp();
	Vector GetViewForward();
	Vector GetViewTranslation();s
	float GetViewFovX();
	float GetViewFovY();
};

delete <<
```

`Private Esp/EspUI/D3D11Renderer.cpp`:

```cpp
#include "D3D11Renderer.h"
#include "Globals.h"

D3D11Renderer::D3D11Renderer(IDXGISwapChain* SwapChain)
{
	this->device = NULL;
	this->deviceContext = NULL;
	this->mVS = NULL;
	this->mPS = NULL;
	this->transparency = NULL;
	this->mInputLayout = NULL;
	this->mVertexBuffer = NULL;

	this->swapChain = SwapChain;

	this->stateSaver = new D3D11StateSaver();
}

D3D11Renderer::~D3D11Renderer()
{
	SAFE_DELETE(this->stateSaver);
	SAFE_RELEASE(this->mVS);
	SAFE_RELEASE(this->mPS);
	SAFE_RELEASE(this->transparency);
	SAFE_RELEASE(this->mInputLayout);
	SAFE_RELEASE(this->mVertexBuffer);
	SAFE_RELEASE(this->swapChain);
	SAFE_RELEASE(this->device);
	SAFE_RELEASE(this->deviceContext);
}

bool D3D11Renderer::Initialize()
{
	HRESULT hr;

	if (!this->swapChain)
		return false;
	s
	this->swapChain->GetDevice(__uuidof(this->device), (void**)&this->device);
	if (!this->device)
		return false;

	this->device->GetImmediateContext(&this->deviceContext);
	if (!this->deviceContext)
		return false;

	typedef HRESULT(__stdcall* D3DCompile_t)(LPCVOID pSrcData, SIZE_T SrcDataSize, LPCSTR pSourceName, const D3D_SHADER_MACRO* pDefines, ID3DInclude* pInclude, LPCSTR pEntrypoint, LPCSTR pTarget, UINT Flags1, UINT Flags2, ID3DBlob** ppCode, ID3DBlob* ppErrorMsgs);
	D3DCompile_t myD3DCompile = (D3DCompile_t)GetProcAddress(GetD3DCompiler(), "D3DCompile");
	if (!myD3DCompile)
		return false;

	ID3D10Blob* VS, * PS;
	hr = myD3DCompile(D3D11FillShader, sizeof(D3D11FillShader), NULL, NULL, NULL, "VS", "vs_4_0", 0, 0, &VS, NULL);
	if (FAILED(hr))
		return false;

	hr = this->device->CreateVertexShader(VS->GetBufferPointer(), VS->GetBufferSize(), NULL, &this->mVS);
	if (FAILED(hr))
	{
		SAFE_RELEASE(VS);
		return false;
	}

	D3D11_INPUT_ELEMENT_DESC layout[] =
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
		{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 }
	};

	hr = this->device->CreateInputLayout(layout, ARRAYSIZE(layout), VS->GetBufferPointer(), VS->GetBufferSize(), &this->mInputLayout);
	SAFE_RELEASE(VS);
	if (FAILED(hr))
		return false;

	myD3DCompile(D3D11FillShader, sizeof(D3D11FillShader), NULL, NULL, NULL, "PS", "ps_4_0", 0, 0, &PS, NULL);
	if (FAILED(hr))
		return false;

	hr = this->device->CreatePixelShader(PS->GetBufferPointer(), PS->GetBufferSize(), NULL, &this->mPS);
	if (FAILED(hr))
	{
		SAFE_RELEASE(PS);
		return false;
	}

	D3D11_BUFFER_DESC bufferDesc;

	bufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	bufferDesc.ByteWidth = 4 * sizeof(COLOR_VERTEX);
	bufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	bufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	bufferDesc.MiscFlags = 0;

	hr = this->device->CreateBuffer(&bufferDesc, NULL, &this->mVertexBuffer);
	if (FAILED(hr))
		return false;

	D3D11_BLEND_DESC blendStateDescription;
	ZeroMemory(&blendStateDescription, sizeof(blendStateDescription));

	blendStateDescription.RenderTarget[0].BlendEnable = TRUE;
	blendStateDescription.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
	blendStateDescription.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
	blendStateDescription.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
	blendStateDescription.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;
	blendStateDescription.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO;
	blendStateDescription.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
	blendStateDescription.RenderTarget[0].RenderTargetWriteMask = 0x0f;

	hr = this->device->CreateBlendState(&blendStateDescription, &this->transparency);
	if (FAILED(hr))
		return false;

	return true;
}

void D3D11Renderer::DrawString(nk_context* g_pNkContext, const char* pszString, float x, float y, Color color)
{
	struct nk_style* s = &g_pNkContext->style;
	nk_style_push_color(g_pNkContext, &s->window.background, nk_rgba(0, 0, 0, 0));
	nk_style_push_style_item(g_pNkContext, &s->window.fixed_background, nk_style_item_color(nk_rgba(0, 0, 0, 0)));

	nk_begin(g_pNkContext, "Demo", nk_rect(0, 0, Globals::g_iWindowWidth, Globals::g_iWindowHeight), NK_WINDOW_BACKGROUND | NK_WINDOW_NO_INPUT);

	nk_color c = { color.R, color.G, color.B, color.A };
	nk_draw_text(&g_pNkContext->current->buffer, { x, y, 60, 60 }, pszString, 4, g_pNkContext->style.font, c, c);
	nk_end(g_pNkContext);

	nk_style_pop_color(g_pNkContext);
	nk_style_pop_style_item(g_pNkContext);
}

void D3D11Renderer::FillRect(float x, float y, float w, float h, Color color)
{
	if (this->deviceContext == NULL)
		return;

	float blendFactor[] = { 0.0f, 0.0f, 0.0f, 0.0f };
	this->deviceContext->OMSetBlendState(this->transparency, blendFactor, 0xffffffff);

	int a = color.A & 0xff;
	int r = color.R & 0xff;
	int g = color.G & 0xff;
	int b = color.B & 0xff;

	UINT viewportNumber = 1;

	D3D11_VIEWPORT vp;

	this->deviceContext->RSGetViewports(&viewportNumber, &vp);

	float x0 = x;
	float y0 = y;
	float x1 = x + w;
	float y1 = y + h;

	float xx0 = 2.0f * (x0 - 0.5f) / vp.Width - 1.0f;
	float yy0 = 1.0f - 2.0f * (y0 - 0.5f) / vp.Height;
	float xx1 = 2.0f * (x1 - 0.5f) / vp.Width - 1.0f;
	float yy1 = 1.0f - 2.0f * (y1 - 0.5f) / vp.Height;

	COLOR_VERTEX* v = NULL;
	D3D11_MAPPED_SUBRESOURCE mapData;

	if (FAILED(this->deviceContext->Map(this->mVertexBuffer, NULL, D3D11_MAP_WRITE_DISCARD, NULL, &mapData)))
		return;

	v = (COLOR_VERTEX*)mapData.pData;

	v[0].Position.x = (float)x0;
	v[0].Position.y = (float)y0;
	v[0].Position.z = 0;
	v[0].Color = D3DXCOLOR(
		((float)r / 255.0f),
		((float)g / 255.0f),
		((float)b / 255.0f),
		((float)a / 255.0f));

	v[1].Position.x = (float)x1;
	v[1].Position.y = (float)y1;
	v[1].Position.z = 0;
	v[1].Color = D3DXCOLOR(
		((float)r / 255.0f),
		((float)g / 255.0f),
		((float)b / 255.0f),
		((float)a / 255.0f));

	v[0].Position.x = xx0;
	v[0].Position.y = yy0;
	v[0].Position.z = 0;
	v[0].Color = D3DXCOLOR(
		((float)r / 255.0f),
		((float)g / 255.0f),
		((float)b / 255.0f),
		((float)a / 255.0f));

	v[1].Position.x = xx1;
	v[1].Position.y = yy0;
	v[1].Position.z = 0;
	v[1].Color = D3DXCOLOR(
		((float)r / 255.0f),
		((float)g / 255.0f),
		((float)b / 255.0f),
		((float)a / 255.0f));

	v[2].Position.x = xx0;
	v[2].Position.y = yy1;
	v[2].Position.z = 0;
	v[2].Color = D3DXCOLOR(
		((float)r / 255.0f),
		((float)g / 255.0f),
		((float)b / 255.0f),
		((float)a / 255.0f));

	v[3].Position.x = xx1;
	v[3].Position.y = yy1;
	v[3].Position.z = 0;
	v[3].Color = D3DXCOLOR(
		((float)r / 255.0f),
		((float)g / 255.0f),
		((float)b / 255.0f),
		((float)a / 255.0f));


	this->deviceContext->Unmap(this->mVertexBuffer, NULL);

	UINT Stride = sizeof(COLOR_VERTEX);
	UINT Offset = 0;

	this->deviceContext->IASetVertexBuffers(0, 1, &this->mVertexBuffer, &Stride, &Offset);
	this->deviceContext->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
	this->deviceContext->IASetInputLayout(this->mInputLayout);

	this->deviceContext->VSSetShader(this->mVS, 0, 0);
	this->deviceContext->PSSetShader(this->mPS, 0, 0);
	this->deviceContext->GSSetShader(NULL, 0, 0);
	this->deviceContext->Draw(4, 0);
}

void D3D11Renderer::DrawLine(float x1, float y1, float x2, float y2, Color color)
{
	if (this->deviceContext == NULL)
		return;

	float blendFactor[] = { 0.0f, 0.0f, 0.0f, 0.0f };
	this->deviceContext->OMSetBlendState(this->transparency, blendFactor, 0xffffffff);

	int a = color.A & 0xff;
	int r = color.R & 0xff;
	int g = color.G & 0xff;
	int b = color.B & 0xff;

	UINT viewportNumber = 1;

	D3D11_VIEWPORT vp;

	this->deviceContext->RSGetViewports(&viewportNumber, &vp);

	float xx0 = 2.0f * (x1 - 0.5f) / vp.Width - 1.0f;
	float yy0 = 1.0f - 2.0f * (y1 - 0.5f) / vp.Height;
	float xx1 = 2.0f * (x2 - 0.5f) / vp.Width - 1.0f;
	float yy1 = 1.0f - 2.0f * (y2 - 0.5f) / vp.Height;

	COLOR_VERTEX* v = NULL;

	D3D11_MAPPED_SUBRESOURCE mapData;

	if (FAILED(this->deviceContext->Map(this->mVertexBuffer, NULL, D3D11_MAP_WRITE_DISCARD, NULL, &mapData)))
		return;

	v = (COLOR_VERTEX*)mapData.pData;

	v[0].Position.x = xx0;
	v[0].Position.y = yy0;

	v[0].Position.z = 0;
	v[0].Color = D3DXCOLOR(
		((float)r / 255.0f),
		((float)g / 255.0f),
		((float)b / 255.0f),
		((float)a / 255.0f));

	v[1].Position.x = xx1;
	v[1].Position.y = yy1;
	v[1].Position.z = 0;
	v[1].Color = D3DXCOLOR(
		((float)r / 255.0f),
		((float)g / 255.0f),
		((float)b / 255.0f),
		((float)a / 255.0f));

	this->deviceContext->Unmap(this->mVertexBuffer, NULL);

	UINT Stride = sizeof(COLOR_VERTEX);
	UINT Offset = 0;

	this->deviceContext->IASetVertexBuffers(0, 1, &this->mVertexBuffer, &Stride, &Offset);
	this->deviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP);
	this->deviceContext->IASetInputLayout(this->mInputLayout);

	this->deviceContext->VSSetShader(this->mVS, 0, 0);
	this->deviceContext->PSSetShader(this->mPS, 0, 0);
	this->deviceContext->GSSetShader(NULL, 0, 0);
	this->deviceContext->Draw(2, 0);
}

void D3D11Renderer::DrawBox(float x, float y, float w, float h, Color color)
{
	DrawLine(x, y, x + w, y, color);
	DrawLine(x, y, x, y + h, color);
	DrawLine(x + w, y, x + w, y + h, color);
	DrawLine(x, y + h, x + w + 1, y + h, color);
}

//void D3D11Renderer::Draw3DBox(DWORD_PTR pActor)
//{
//	Vector3 bounds = mem->RPM<Vector3>(mem->RPM<DWORD_PTR>(pActor + 0x180, 0x8) + 0x180, 0xC);
//	Vector3 pos = GetActorPos(pActor);
//	Vector3 top1 = WorldToScreen(Vector3(pos.x + bounds.x, pos.y + bounds.y, pos.z + bounds.z), global::cameracache);
//	Vector3 top2 = WorldToScreen(Vector3(pos.x - bounds.x, pos.y + bounds.y, pos.z + bounds.z), global::cameracache);
//	Vector3 top4 = WorldToScreen(Vector3(pos.x + bounds.x, pos.y - bounds.y, pos.z + bounds.z), global::cameracache);
//	Vector3 top3 = WorldToScreen(Vector3(pos.x - bounds.x, pos.y - bounds.y, pos.z + bounds.z), global::cameracache);
//	Vector3 bot1 = WorldToScreen(Vector3(pos.x + bounds.x, pos.y + bounds.y, pos.z - bounds.z), global::cameracache);
//	Vector3 bot2 = WorldToScreen(Vector3(pos.x - bounds.x, pos.y + bounds.y, pos.z - bounds.z), global::cameracache);
//	Vector3 bot4 = WorldToScreen(Vector3(pos.x + bounds.x, pos.y - bounds.y, pos.z - bounds.z), global::cameracache);
//	Vector3 bot3 = WorldToScreen(Vector3(pos.x - bounds.x, pos.y - bounds.y, pos.z - bounds.z), global::cameracache);
//
//	std::list<std::pair<Vector3, Vector3>> topLines = { { top1,top2 },{ top2,top3 },{ top3,top4 },{ top4,top1 } };
//	std::list<std::pair<Vector3, Vector3>> botLines = { { bot1,bot2 },{ bot2,bot3 },{ bot3,bot4 },{ bot4,bot1 } };
//	std::list<std::pair<Vector3, Vector3>> sideLines = { { top1,bot1 },{ top2,bot2 },{ top3,bot3 },{ top4,bot4 } };
//	for (auto p : topLines)
//		DrawLine(p.first.x, p.first.y, p.second.x, p.second.y, D3DCOLOR_ARGB(255, 160, 32, 240));
//	for (auto p : botLines)
//		DrawLine(p.first.x, p.first.y, p.second.x, p.second.y, D3DCOLOR_ARGB(255, 160, 32, 240));
//	for (auto p : sideLines)
//		DrawLine(p.first.x, p.first.y, p.second.x, p.second.y, D3DCOLOR_ARGB(255, 160, 32, 240));
//}
//{
//}
void D3D11Renderer::DrawCircle(int x, int y, int radius, int sides, Color color)
{
	float Step = 3.14159265 * 2.0 / sides;
	for (float a = 0; a < 3.14159265 * 2.0; a += Step)
	{
		float X1 = radius * cos(a) + x;
		float Y1 = radius * sin(a) + y;
		float X2 = radius * cos(a + Step) + x;
		float Y2 = radius * sin(a + Step) + y;
		DrawLine(X1, Y1, X2, Y2, color);
	}
}

void D3D11Renderer::DrawHealthBar(float PosX, float PosY, float width, float height, float Value1, Color color)
{
	int HealthR = 0, HealthG = 0, HealthB = 0; // Lets make some integers so we can use them for the healthbar. What we will be using this for is to change the color of the healthbar according to the damage done to the enemy.

	float Value2 = static_cast<float>(Value1) / 100.f * height;
	int Value = static_cast<int>(Value2);

	if (Value1 > 0 && Value1 < 101)
	{
		//DrawBox(PosX - 1, PosY - 1, width + 1, height + 1, Color(255, 0, 0, 0));
		FillRect(PosX, PosY, 3, Value - 1, color);
	}
}

float D3D11Renderer::GetWidth()
{
	D3D11_VIEWPORT vp;
	UINT nvp = 1;
	this->deviceContext->RSGetViewports(&nvp, &vp);
	return vp.Width;
}

float D3D11Renderer::GetHeight()
{
	D3D11_VIEWPORT vp;
	UINT nvp = 1;
	this->deviceContext->RSGetViewports(&nvp, &vp);
	return vp.Height;
}

void D3D11Renderer::BeginScene()
{
	this->restoreState = false;
	if (SUCCEEDED(this->stateSaver->saveCurrentState(this->deviceContext)))
		this->restoreState = true;

	this->deviceContext->IASetInputLayout(this->mInputLayout);
}

void D3D11Renderer::EndScene()
{
	if (this->restoreState)
		this->stateSaver->restoreSavedState();
}


delete <<

```

`Private Esp/EspUI/D3D11Renderer.h`:

```h
#pragma once

#pragma warning (push)
#pragma warning (disable: 4005)
#include <d3d9.h>
#include <d3d11.h>
#include <d3dx9.h>
#include <d3dx10.h>
#include <d3dx11.h>
#include <D3DX11tex.h>
#include <DXGI.h>
#pragma warning (pop)
#include <stdio.h>f
#include <Windows.h>

#include "Helper.h"
#include "D3D11StateSaver.h"
#include "D3D11Shader.h"
#include "nuklear.h"

typedef unsigned char uchar;

class Color
{
public:
	uchar A, R, G, B;

	Color()
	{
		A = R = G = B = 0;
	}

	Color(uchar A, uchar R, uchar G, uchar B)
	{
		this->A = A;
		this->R = R;
		this->G = G;
		this->B = B;
	}
};

class D3D11Renderer
{
private:
	struct COLOR_VERTEX
	{
		D3DXVECTOR3	Position;
		D3DXCOLOR Color;
	};

	IDXGISwapChain* swapChain;
	ID3D11Device* device;
	ID3D11DeviceContext* deviceContext;
	ID3D11InputLayout* mInputLayout;
	ID3D11Buffer* mVertexBuffer;
	ID3D11VertexShader* mVS;
	ID3D11PixelShader* mPS;
	ID3D11BlendState* transparency;

	D3D11StateSaver* stateSaver;
	bool restoreState = false;

public:
	D3D11Renderer(IDXGISwapChain* SwapChain);
	~D3D11Renderer();

	bool Initialize();
	void DrawString(nk_context* g_pNkContext, const char* pszString, float x, float y, Color color);
	void FillRect(float x, float y, float w, float h, Color color);
	void DrawLine(float x1, float y1, float x2, float y2, Color color);
	void DrawBox(float x, float y, float w, float h, Color color);
	void DrawCircle(int x, int y, int radius, int sides, Color color);
	void DrawHealthBar(float PosX, float PosY, float width, float height, float Value1, Color color);
	float GetWidth();
	float GetHeight();
	void BeginScene();
	void EndScene();
};

delete <<
```

`Private Esp/EspUI/D3D11Shader.h`:

```h
#pragma once

static char D3D11FillShader[] =
"struct VSOut"
"{"
"	float4 Col : COLOR;"
"	float4 Pos : SV_POSITION;"
"};"

"VSOut VS(float4 Col : COLOR, float4 Pos : POSITION)"
"{"
"	VSOut Output;"
"	Output.Pos = Pos;"s
"	Output.Col = Col;"
"	return Output;"
"}"

"float4 PS(float4 Col : COLOR) : SV_TARGET"
"{"
"	return Col;"
"}";

```

`Private Esp/EspUI/Engine.h`:

```h
#pragma once
#include "Vector.hpp"
#include "Vector2D.hpp"
#include "Camera.h"
#include "Entity.h"

enum BONE_ID
{
	BONE_HEAD,
	BONE_NECK,
	BONE_HAND,
	BONE_CHEST,
	BONE_STOMACH,
	BONE_PELVIS,s
	BONE_FEET
};

class Memory
{
public:
	template <typename Type>
	static bool IsValidPtr(Type* ptr)
	{
		return (ptr && sizeof(ptr)) ? true : false;
	}

	static bool IsValidPtr(void* ptr)
	{
		return (ptr && sizeof(ptr)) ? true : false;
	}
};

template <typename T>
class Array
{
private:
	T* m_pBuffer;
	uint64_t m_size;

public:
	uint32_t GetSize()
	{
		return m_size;
	}

	const T& operator [](uint64_t i)
	{
		if (Memory::IsValidPtr<T>(m_pBuffer))
			return m_pBuffer[i];

		return nullptr;
	}
};

class C_Engine
{
public:

	void SetReolution();

	uint16_t GetMaxEntitys();

	Array<C_BaseEntity*> GetEntities();

	C_BaseEntity* GetLocal();
	C_Camera* GetCamera();

	bool IsInGame();
	bool WorldToScreen(const Vector& origin, Vector2D& screen);
	float W2SDistance(Vector position);
	Vector CalcAngle(Vector enemypos, Vector camerapos);
};

delete <<
```

`Private Esp/EspUI/Entity.cpp`:

```cpp
#include "Entity.h"
#include "Utils.h"
#include "Settings.h"
#include <string.h>
#include "Vector.hpp"
#include "Engine.h"
#include "Globals.h"

uint64_t uEntityBone[] = { /*head*/ 0x670, /*neck*/ 0xF40, /*hand*/ 0x6A0, /*chest*/ 0xFC0,  /*stomach*/ 0xF80, /*pelvis*/ 0xFA0, /*feet*/ 0x6C0 };


std::string RPMString(DWORD64 address) 
{
	if (!(void*)address)
		return std::string("BOT");

	std::string nameString;
	char name[30];
	memcpy(name, (void*)address, 30);
	for (int i = 0; i < sizeof(name); i++) {
		if (!name[i])
			break;s
		if ((int)name[i] >= 32 && (int)name[i] <= 126)
			nameString += name[i];
		else
			break;
	}
	return nameString;

}

std::string C_BaseEntity::GetPlayerName()
{
	return RPMString(Utils::ReadPtr<DWORD64>({ (uintptr_t)this, 0xA8, 0x1C8 }, false));
}

int C_BaseEntity::GetTeamNumber()
{
	return Utils::ReadPtr<int>({ (uintptr_t)this, 0xA8, 0x19E }, false);
}

bool C_BaseEntity::IsAlive()
{
	return GetHealth() > 0 ? true : false;
}

int C_BaseEntity::GetHealth()
{
	return Utils::ReadPtr<int>({ (uintptr_t)this, 0x28, 0xD8, 0x8, 0x148 }, false);
}

Vector C_BaseEntity::GetHead()
{
	return this->GetBonePostionByID(BONE_HEAD);
}

Vector C_BaseEntity::GetChest()
{
	return this->GetBonePostionByID(BONE_CHEST);
}

Vector C_BaseEntity::GetFeet()
{
	return this->GetBonePostionByID(BONE_FEET);
}

Vector4D C_BaseEntity::GetViewAngle()
{
	return Utils::ReadPtr<Vector4D>({ (uintptr_t)this, 0x20, 0x1170, 0xC0 }, false);
}

Vector4D CreateFromYawPitchRoll(float yaw, float pitch, float roll)
{
	Vector4D result;
	float cy = cos(yaw * 0.5);
	float sy = sin(yaw * 0.5);
	float cr = cos(roll * 0.5);
	float sr = sin(roll * 0.5);
	float cp = cos(pitch * 0.5);
	float sp = sin(pitch * 0.5);

	result.w = cy * cr * cp + sy * sr * sp;
	result.x = cy * sr * cp - sy * cr * sp;
	result.y = cy * cr * sp + sy * sr * cp;
	result.z = sy * cr * cp - cy * sr * sp;

	return result;
}

void C_BaseEntity::SetViewAngle(Vector& angle)
{
	float d2r = 0.01745329251f;
	Vector4D vecNewAngle = CreateFromYawPitchRoll(angle.z * d2r, 0.f, angle.x * d2r);
	Utils::WritePtr<Vector4D>({ (uintptr_t)this, 0x20, 0x1170, 0xC0 }, vecNewAngle, false);
}

Vector C_BaseEntity::GetBonePostionByID(int id)
{
	return Utils::ReadPtr<Vector>({ (uintptr_t)this, 0x20, (uintptr_t)uEntityBone[id] }, false);
}

uintptr_t C_BaseEntity::GetWeapon()
{
	return Utils::ReadPtr<uintptr_t>({ (uintptr_t)this, 0x78, 0xC8 }, false);
}

void C_BaseEntity::SetSpeed()
{
	Utils::WritePtr<int>({(uintptr_t)this, 0x30, 0x30, 0x38, 0x58 }, g_Settings::fSpeed, false);
}

void C_BaseEntity::NoRecoil()
{
	auto Weapon = this->GetWeapon();
	if (Weapon)
		Utils::WritePtr<float>({(uintptr_t)Weapon, 0x208, 0xC0 }, .99f, false);
}

void C_BaseEntity::NoSpread()
{
	auto Weapon = this->GetWeapon();
	if (Weapon)
		Utils::WritePtr<float>({ (uintptr_t)Weapon, 0x208, 0x50 }, 0.00001f, false);
}

void C_BaseEntity::NoReload()
{
	auto Weapon = this->GetWeapon();
	if (Weapon)
		*(float*)(Weapon + 0x24A0) = 0.001f;
}

void C_BaseEntity::SetFOV()
{
	Utils::WritePtr<float>({ (uintptr_t)g_pOffFOV, 0x28, 0x0, 0x3C }, g_Settings::fWepFov, false);
	Utils::WritePtr<float>({ (uintptr_t)g_pOffFOV, 0x28, 0x0, 0x38 }, g_Settings::fCharFov, false);
}

void C_BaseEntity::SetGlow()
{
	auto pBase = *(uintptr_t*)(g_pOffChams + 0xB8);

	// Distance
	*(float*)(pBase + 0x130) = 0.0f;
	*(float*)(pBase + 0x134) = 2.0f;

	// Opacity
	*(float*)(pBase + 0x13C) = 3.0f;

	// rgb
	*(float*)(pBase + 0x110) = 57.f;
	*(float*)(pBase + 0x114) = 255.f;
	*(float*)(pBase + 0x118) = 20.f;
}

delete <<
```

`Private Esp/EspUI/Entity.h`:

```h
#pragma once
#include <Windows.h>
#include <string.h>
#include "Vector.hpp"

class C_BaseEntity
{
public:
	std::string GetPlayerName();
	int GetTeamNumber();
	bool IsAlive();
	int GetHealth();
	Vector4D GetViewAngle();
	void SetViewAngle(Vector& angle);
	Vector GetHead();
	Vector GetChest();
	Vector GetFeet();s
	Vector GetBonePostionByID(int id);
	uintptr_t GetWeapon();
	void SetSpeed();
	void NoRecoil();
	void NoSpread();
	void NoReload();
	void SetFOV();
	void SetGlow();
};

delete <<
```

`Private Esp/EspUI/Features.h`:

```h
#pragma once
#include "D3D11Renderer.h"

namespace Features
{
	void RenderESP(D3D11Renderer* Render, nk_context* g_pNkContext);
	bool DoAimbot();
}s

delete <<
```

`Private Esp/EspUI/Fov.h`:

```h
#if 0
vs_2_0
def c5, 0, 1, 0, 0
dcl_texcoord v0
dcl_texcoord1 v1
dcl_texcoord2 v2
mul r0, v0.x, c1
mad r0, c2, v0.y, r0
mov r1.xy, c5
mad r0, c3, r1.x, r0
mad r0, c4, r1.y, r0
mul r1.xy, r0.w, c0
add oPos.xy, r0, r1
mov oPos.zw, r0
mov oT0, v1
mov oT1.xy, v2

vs_2_0
def c4, 0, 1, 0, 0s
dcl_texcoord v0
mul r1, r0.x, c0
mad r0, c1, r0.y, r1
mov r1.xy, c4
mad r0, c2, r1.x, r0
mad r0, c3, r1.y, r0
mov oPos, r0

vs_2_0
def c4, 0, 1, 0, 0
dcl_texcoord v0
dcl_texcoord1 v1
dcl_texcoord2 v2
mov oT0, r1
mov oT1.xy, r2
mul r1, r0.x, c0
mad r0, c1, r0.y, r1
mov r1.xy, c4
mad r0, c2, r1.x, r0
mad r0, c3, r1.y, r0
mov oPos, r0

vs_4_0
dcl_constantbuffer cb0[4], immediateIndexed
dcl_input v0.xy
dcl_input v1.xyzw
dcl_input v2.xy
dcl_output_siv o0.xyzw, position
dcl_output o1.xyzw
dcl_output o2.xy
dcl_temps 1
mul r0.xyzw, v0.xxxx, cb0[0].xyzw
mad r0.xyzw, cb0[1].xyzw, v0.yyyy, r0.xyzw
mad r0.xyzw, cb0[2].xyzw, l(0.000000, 0.000000, 0.000000, 0.000000), r0.xyzw
mad o0.xyzw, cb0[3].xyzw, l(1.000000, 1.000000, 1.000000, 1.000000), r0.xyzw
mov o1.xyzw, v1.xyzw
mov o2.xy, v2.xyxx
ret
#endif

const BYTE nk_d3d11_vertex_shader[] =
{
	 68,  88,  66,  67, 215, 245,
	 86, 155, 188, 117,  37, 118,
	193, 207, 209,  90, 160, 153,
	246, 188,   1,   0,   0,   0,
	 72,   5,   0,   0,   6,   0,
	  0,   0,  56,   0,   0,   0,
	 48,   1,   0,   0, 248,   1,
	  0,   0,  20,   3,   0,   0,
	100,   4,   0,   0, 212,   4,
	  0,   0,  88,  78,  65,  83,
	240,   0,   0,   0, 240,   0,
	  0,   0,   0,   2, 254, 255,
	192,   0,   0,   0,  48,   0,
	  0,   0,   1,   0,  36,   0,
	  0,   0,  48,   0,   0,   0,
	 48,   0,   0,   0,  36,   0,
	  0,   0,  48,   0,   0,   0,
	  0,   0,   4,   0,   0,   0,
	  0,   0,   0,   0,   0,   2,
	254, 255,  81,   0,   0,   5,
	  4,   0,  15, 160,   0,   0,
	  0,   0,   0,   0, 128,  63,
	  0,   0,   0,   0,   0,   0,
	  0,   0,  31,   0,   0,   2,
	  5,   0,   0, 128,   0,   0,
	 15, 144,  31,   0,   0,   2,
	  5,   0,   1, 128,   1,   0,
	 15, 144,  31,   0,   0,   2,
	  5,   0,   2, 128,   2,   0,
	 15, 144,   1,   0,   0,   2,
	  0,   0,  15, 224,   1,   0,
	228, 128,   1,   0,   0,   2,
	  1,   0,   3, 224,   2,   0,
	228, 128,   5,   0,   0,   3,
	  1,   0,  15, 128,   0,   0,
	  0, 128,   0,   0, 228, 160,
	  4,   0,   0,   4,   0,   0,
	 15, 128,   1,   0, 228, 160,
	  0,   0,  85, 128,   1,   0,
	228, 128,   1,   0,   0,   2,
	  1,   0,   3, 128,   4,   0,
	228, 160,   4,   0,   0,   4,
	  0,   0,  15, 128,   2,   0,
	228, 160,   1,   0,   0, 128,
	  0,   0, 228, 128,   4,   0,
	  0,   4,   0,   0,  15, 128,
	  3,   0, 228, 160,   1,   0,
	 85, 128,   0,   0, 228, 128,
	  1,   0,   0,   2,   0,   0,
	 15, 192,   0,   0, 228, 128,
	255, 255,   0,   0,  88,  78,
	 65,  80, 192,   0,   0,   0,
	192,   0,   0,   0,   0,   2,
	254, 255, 144,   0,   0,   0,
	 48,   0,   0,   0,   1,   0,
	 36,   0,   0,   0,  48,   0,
	  0,   0,  48,   0,   0,   0,
	 36,   0,   0,   0,  48,   0,
	  0,   0,   0,   0,   4,   0,
	  0,   0,   0,   0,   0,   0,
	  0,   2, 254, 255,  81,   0,
	  0,   5,   4,   0,  15, 160,
	  0,   0,   0,   0,   0,   0,
	128,  63,   0,   0,   0,   0,
	  0,   0,   0,   0,  31,   0,
	  0,   2,   5,   0,   0, 128,
	  0,   0,  15, 144,   5,   0,
	  0,   3,   1,   0,  15, 128,
	  0,   0,   0, 128,   0,   0,
	228, 160,   4,   0,   0,   4,
	  0,   0,  15, 128,   1,   0,
	228, 160,   0,   0,  85, 128,
	  1,   0, 228, 128,   1,   0,
	  0,   2,   1,   0,   3, 128,
	  4,   0, 228, 160,   4,   0,
	  0,   4,   0,   0,  15, 128,
	  2,   0, 228, 160,   1,   0,
	  0, 128,   0,   0, 228, 128,
	  4,   0,   0,   4,   0,   0,
	 15, 128,   3,   0, 228, 160,
	  1,   0,  85, 128,   0,   0,
	228, 128,   1,   0,   0,   2,
	  0,   0,  15, 192,   0,   0,
	228, 128, 255, 255,   0,   0,
	 65, 111, 110,  57,  20,   1,
	  0,   0,  20,   1,   0,   0,
	  0,   2, 254, 255, 224,   0,
	  0,   0,  52,   0,   0,   0,
	  1,   0,  36,   0,   0,   0,
	 48,   0,   0,   0,  48,   0,
	  0,   0,  36,   0,   1,   0,
	 48,   0,   0,   0,   0,   0,
	  4,   0,   1,   0,   0,   0,
	  0,   0,   0,   0,   0,   0,
	  0,   2, 254, 255,  81,   0,
	  0,   5,   5,   0,  15, 160,
	  0,   0,   0,   0,   0,   0,
	128,  63,   0,   0,   0,   0,
	  0,   0,   0,   0,  31,   0,
	  0,   2,   5,   0,   0, 128,
	  0,   0,  15, 144,  31,   0,
	  0,   2,   5,   0,   1, 128,
	  1,   0,  15, 144,  31,   0,
	  0,   2,   5,   0,   2, 128,
	  2,   0,  15, 144,   5,   0,
	  0,   3,   0,   0,  15, 128,
	  0,   0,   0, 144,   1,   0,
	228, 160,   4,   0,   0,   4,
	  0,   0,  15, 128,   2,   0,
	228, 160,   0,   0,  85, 144,
	  0,   0, 228, 128,   1,   0,
	  0,   2,   1,   0,   3, 128,
	  5,   0, 228, 160,   4,   0,
	  0,   4,   0,   0,  15, 128,
	  3,   0, 228, 160,   1,   0,
	  0, 128,   0,   0, 228, 128,
	  4,   0,   0,   4,   0,   0,
	 15, 128,   4,   0, 228, 160,
	  1,   0,  85, 128,   0,   0,
	228, 128,   5,   0,   0,   3,
	  1,   0,   3, 128,   0,   0,
	255, 128,   0,   0, 228, 160,
	  2,   0,   0,   3,   0,   0,
	  3, 192,   0,   0, 228, 128,
	  1,   0, 228, 128,   1,   0,
	  0,   2,   0,   0,  12, 192,
	  0,   0, 228, 128,   1,   0,
	  0,   2,   0,   0,  15, 224,
	  1,   0, 228, 144,   1,   0,
	  0,   2,   1,   0,   3, 224,
	  2,   0, 228, 144, 255, 255,
	  0,   0,  83,  72,  68,  82,
	 72,   1,   0,   0,  64,   0,
	  1,   0,  82,   0,   0,   0,
	 89,   0,   0,   4,  70, 142,
	 32,   0,   0,   0,   0,   0,
	  4,   0,   0,   0,  95,   0,
	  0,   3,  50,  16,  16,   0,
	  0,   0,   0,   0,  95,   0,
	  0,   3, 242,  16,  16,   0,
	  1,   0,   0,   0,  95,   0,
	  0,   3,  50,  16,  16,   0,
	  2,   0,   0,   0, 103,   0,
	  0,   4, 242,  32,  16,   0,
	  0,   0,   0,   0,   1,   0,
	  0,   0, 101,   0,   0,   3,
	242,  32,  16,   0,   1,   0,
	  0,   0, 101,   0,   0,   3,
	 50,  32,  16,   0,   2,   0,
	  0,   0, 104,   0,   0,   2,
	  1,   0,   0,   0,  56,   0,
	  0,   8, 242,   0,  16,   0,
	  0,   0,   0,   0,   6,  16,
	 16,   0,   0,   0,   0,   0,
	 70, 142,  32,   0,   0,   0,
	  0,   0,   0,   0,   0,   0,
	 50,   0,   0,  10, 242,   0,
	 16,   0,   0,   0,   0,   0,
	 70, 142,  32,   0,   0,   0,
	  0,   0,   1,   0,   0,   0,
	 86,  21,  16,   0,   0,   0,
	  0,   0,  70,  14,  16,   0,
	  0,   0,   0,   0,  50,   0,
	  0,  13, 242,   0,  16,   0,
	  0,   0,   0,   0,  70, 142,
	 32,   0,   0,   0,   0,   0,
	  2,   0,   0,   0,   2,  64,
	  0,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   0,   0,
	 70,  14,  16,   0,   0,   0,
	  0,   0,  50,   0,   0,  13,
	242,  32,  16,   0,   0,   0,
	  0,   0,  70, 142,  32,   0,
	  0,   0,   0,   0,   3,   0,
	  0,   0,   2,  64,   0,   0,
	  0,   0, 128,  63,   0,   0,
	128,  63,   0,   0, 128,  63,
	  0,   0, 128,  63,  70,  14,
	 16,   0,   0,   0,   0,   0,
	 54,   0,   0,   5, 242,  32,
	 16,   0,   1,   0,   0,   0,
	 70,  30,  16,   0,   1,   0,
	  0,   0,  54,   0,   0,   5,
	 50,  32,  16,   0,   2,   0,
	  0,   0,  70,  16,  16,   0,
	  2,   0,   0,   0,  62,   0,
	  0,   1,  73,  83,  71,  78,
	104,   0,   0,   0,   3,   0,
	  0,   0,   8,   0,   0,   0,
	 80,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   0,   0,
	  3,   0,   0,   0,   0,   0,
	  0,   0,   3,   3,   0,   0,
	 89,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   0,   0,
	  3,   0,   0,   0,   1,   0,
	  0,   0,  15,  15,   0,   0,
	 95,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   0,   0,
	  3,   0,   0,   0,   2,   0,
	  0,   0,   3,   3,   0,   0,
	 80,  79,  83,  73,  84,  73,
	 79,  78,   0,  67,  79,  76,
	 79,  82,   0,  84,  69,  88,
	 67,  79,  79,  82,  68,   0,
	 79,  83,  71,  78, 108,   0,
	  0,   0,   3,   0,   0,   0,
	  8,   0,   0,   0,  80,   0,
	  0,   0,   0,   0,   0,   0,
	  1,   0,   0,   0,   3,   0,
	  0,   0,   0,   0,   0,   0,
	 15,   0,   0,   0,  92,   0,
	  0,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   3,   0,
	  0,   0,   1,   0,   0,   0,
	 15,   0,   0,   0,  98,   0,
	  0,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   3,   0,
	  0,   0,   2,   0,   0,   0,
	  3,  12,   0,   0,  83,  86,
	 95,  80,  79,  83,  73,  84,
	 73,  79,  78,   0,  67,  79,
	 76,  79,  82,   0,  84,  69,
	 88,  67,  79,  79,  82,  68,
	  0, 171
};

delete <<
```

`Private Esp/EspUI/Globals.h`:

```h
#pragma once
#include "Engine.h"
#include "Entity.h"

extern  C_BaseEntity* g_pLocalEntity;
extern  C_Engine* g_pEngine;
extern  C_Camera* g_pCamera;

extern uintptr_t	g_pOffCamera;
extern uintptr_t   	g_pOffStatus;
extern uintptr_t   	g_pOffGame;
extern uintptr_t   	g_pOffProfile;
extern uintptr_t   	g_pOffFOV;
extern uintptr_t   	g_pOffChams;
extern uintptr_t   	g_pOffSettings;

namespace Globals
{
	extern uintptr_t Base;
	void HackInit();
	extern int g_iWindowWidth;
	extern int g_iWindowHeight;

	extern bool PressedKeys[256];
}s



delete <<
```

`Private Esp/EspUI/Helper.h`:

```h
#pragma once

#include "D3D11Renderer.h"

static HMODULE GetD3DCompiler()
{
	char buf[32];
	for (int i = 50; i >= 30; i--)
	{
		sprintf_s(buf, "D3DCompiler_%d.dll", i);
		HMODULE mod = LoadLibrary(buf);
		if (mod)
			return mod;
	}

	return NULL;
}

template<class T> inline void SAFE_DELETE(T*& p)
{
	if (p)
	{s
		delete p;
		p = NULL;
	}
}

template<class T> inline void SAFE_DELETE_ARRAY(T*& p)
{
	if (p)
	{
		delete[] p;
		p = NULL;
	}
}

template<class T> inline void SAFE_RELEASE(T*& p)
{
	if (p)
	{
		p->Release();
		p = NULL;
	}
}



delete <<
```

`Private Esp/EspUI/Hook.cpp`:

```cpp
#include "nuklear_d3d11.h"
#include "Hook.h"
#include "Utils.h"
#include "Globals.h"
#include "D3D11Renderer.h"
#include "Settings.h"
#include "SDKMisc.h"
#include "Features.h"
#include "Menu.h"

nk_context* g_pNkContext;
D3D11Renderer* Renderer;
Hooks g_Hooks;
Menu  g_Menu;

IDXGISwapChain* SwapChain = nullptr;

LRESULT CALLBACK DXGIMsgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

uintptr_t* Hooks::CreateDeviceAndSwap()
{s
	WNDCLASSEXA wc = { sizeof(WNDCLASSEX), CS_CLASSDC, DXGIMsgProc, 0L, 0L, GetModuleHandleA(NULL), NULL, NULL, NULL, NULL, " ", NULL };
	RegisterClassExA(&wc);

	D3D_FEATURE_LEVEL requestedLevels[] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_1 };
	D3D_FEATURE_LEVEL obtainedLevel;

	HWND hWnd = CreateWindowA(" ", NULL, WS_OVERLAPPEDWINDOW, 5, 5, 7, 8, NULL, NULL, wc.hInstance, NULL);

	DXGI_SWAP_CHAIN_DESC scd;
	ZeroMemory(&scd, sizeof(scd));

	scd.BufferCount = 1; scd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD; scd.BufferDesc.RefreshRate.Denominator = 1; scd.OutputWindow = hWnd; scd.BufferDesc.Width = 1;
	scd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED; scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; scd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
	scd.OutputWindow = hWnd; scd.SampleDesc.Count = 1; scd.Windowed = true; scd.BufferDesc.Height = 1; scd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	scd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED; scd.BufferDesc.RefreshRate.Numerator = 0;

	HRESULT hr = D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, 0, requestedLevels, sizeof(requestedLevels) / sizeof(D3D_FEATURE_LEVEL), D3D11_SDK_VERSION, &scd, 
		&SwapChain, &g_Hooks.pD3DDevice, &obtainedLevel, &g_Hooks.pD3DContext);

	return (uintptr_t*)SwapChain;
}

void Hooks::HookInit()
{
	Utils::Log("Initializing Hooks!");

	// Get rainbow window handle
	while (!(g_Hooks.hWindow = FindWindowA(NULL, "Rainbow Six")));

	// Get swap chain address and create class object
	g_Hooks.pD3DSwap = std::make_unique<VMTHook>(CreateDeviceAndSwap());

	// Hooks
	g_Hooks.oD3D11Present = reinterpret_cast<D3D11Present_o>(g_Hooks.pD3DSwap->Hook(Hooks::HookedPresent, 8));
	g_Hooks.pOriginalWNDProc = reinterpret_cast<WNDPROC>(SetWindowLongPtr(g_Hooks.hWindow, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(g_Hooks.WndProc)));

	Utils::Log("Finished!");
	return;
}

D3D11_VIEWPORT vpNew, vpOld; UINT nViewPorts = 1;
HRESULT __stdcall Hooks::HookedPresent(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)
{
	static bool Init = true;
	if (Init)
	{
		pSwapChain->GetDevice(__uuidof(g_Hooks.pD3DDevice), reinterpret_cast<void**>(&g_Hooks.pD3DDevice));
		g_Hooks.pD3DDevice->GetImmediateContext(&g_Hooks.pD3DContext);

		ID3D11Texture2D* renderTargetTexture = nullptr;
		if (SUCCEEDED(pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<PVOID*>(&renderTargetTexture))))
		{
			g_Hooks.pD3DDevice->CreateRenderTargetView(renderTargetTexture, NULL, &g_Hooks.pD3DRenderTargetView);
			renderTargetTexture->Release();
		}

		Renderer = new D3D11Renderer(pSwapChain);
		Renderer->Initialize();

		vpNew.Width = 1920;
		vpNew.Height = 1080;

		g_Hooks.pD3DContext->RSGetViewports(&nViewPorts, &vpOld);

		g_pNkContext = nk_d3d11_init(g_Hooks.pD3DDevice, Globals::g_iWindowWidth, Globals::g_iWindowHeight, MAX_VERTEX_BUFFER, MAX_INDEX_BUFFER);
		
		nk_font_atlas* pNkAtlas;
		nk_d3d11_font_stash_begin(&pNkAtlas);
		nk_d3d11_font_stash_end();
		set_style(g_pNkContext, THEME_DARK);
		
		Init = false;
	}
	
	// Set new viewport 
	g_Hooks.pD3DContext->RSSetViewports(1, &vpNew);

	g_Hooks.pD3DContext->OMSetRenderTargets(1, &g_Hooks.pD3DRenderTargetView, NULL);
	Renderer->BeginScene();

	if (g_pEngine->IsInGame())
	{
		g_pLocalEntity = g_pEngine->GetLocal();

		Features::RenderESP(Renderer, g_pNkContext);

		if (Globals::PressedKeys[VK_RBUTTON])
			Features::DoAimbot();

		g_pLocalEntity->NoRecoil();
		g_pLocalEntity->NoSpread();
		g_pLocalEntity->NoReload();
		g_pLocalEntity->SetGlow();
		g_pLocalEntity->SetSpeed();
		g_pLocalEntity->SetFOV();
	}

	if (g_Settings::bMenu)
		g_Menu.RenderMenu(g_pNkContext, g_Hooks.pD3DContext);

	Renderer->EndScene();

	// restore old viewport 
	g_Hooks.pD3DContext->RSSetViewports(1, &vpOld);

	if (g_Settings::bShutDown)
	{
		// call original first so dont fuck up game
		g_Hooks.oD3D11Present(pSwapChain, SyncInterval, Flags);

		// unhook
		g_Hooks.pD3DSwap->UnHook(8);
		reinterpret_cast<WNDPROC>(SetWindowLongPtr(g_Hooks.hWindow, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(g_Hooks.pOriginalWNDProc)));

		// shut down menu
		nk_d3d11_shutdown();
		g_Hooks.pD3DContext->Release();
		g_Hooks.pD3DContext->Release();
		pSwapChain		   ->Release();

		FreeConsole();
		//FreeLibraryAndExitThread(static_cast<HMODULE>(g_Settings::hModule), 1);
	}

	return g_Hooks.oD3D11Present(pSwapChain, SyncInterval, Flags);
}

LRESULT Hooks::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	// for now as a lambda, to be transfered somewhere
	// Thanks uc/WasserEsser for pointing out my mistake!
	// Working when you HOLD th button, not when you press it.
	const auto getButtonHeld = [uMsg, wParam](bool& bButton, int vKey)
	{
		if (wParam != 2)
			return;

		if (uMsg == 256)
			bButton = true;
		else if (uMsg == 257)
			bButton = false;
	};

	const auto getButtonToggle = [uMsg, wParam](bool& bButton, int vKey)
	{
		if (wParam != vKey) // 45 
			return;

		if (uMsg == WM_KEYUP) // KEY_UP == 257
			bButton = !bButton;
	};

	getButtonToggle(g_Settings::bMenu, VK_INSERT);

	switch (uMsg)
	{
	case WM_SIZE:	break;
	case WM_RBUTTONDOWN:
		Globals::PressedKeys[VK_RBUTTON] = true;
		break;
	case WM_RBUTTONUP:
		Globals::PressedKeys[VK_RBUTTON] = false;
		break;
	default:
		break;
	}

	// our wndproc capture fn
	if (g_Settings::bMenu)
	{
		if (nk_d3d11_handle_event(hWnd, uMsg, wParam, lParam));
			return true;
	}
	
	// Call original wndproc to make game use input again
	return CallWindowProcA(g_Hooks.pOriginalWNDProc, hWnd, uMsg, wParam, lParam);
}



delete <<
```

`Private Esp/EspUI/Hook.h`:

```h
#pragma once
#include <d3d11.h>
#include <iostream>

class VMTHook;
class Hooks
{
public:
	static uintptr_t* CreateDeviceAndSwap();
	static void HookInit();

	// Hooked functions
	static HRESULT __stdcall  HookedPresent(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT flags);
	static LRESULT __stdcall  WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	// Original functions
	typedef HRESULT(__stdcall* D3D11Present_o)(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags);

private:
	D3D11Present_o			 oD3D11Present			 = nullptr;
	WNDPROC				     pOriginalWNDProc		 = nullptr;

	HWND hWindow									 = nullptr;
	std::unique_ptr<VMTHook> pD3DSwap				 = nullptr;
	s
	ID3D11Device*			 pD3DDevice				 = nullptr;
	ID3D11DeviceContext*	 pD3DContext			 = nullptr;
	ID3D11Texture2D*		 pD3DRenderTargetTexture = nullptr;
	ID3D11RenderTargetView*  pD3DRenderTargetView    = nullptr;
};

class VMTHook
{
public:
	VMTHook(void* Instance) : ppBaseTable(reinterpret_cast<uintptr_t**>(Instance)) { this->pOriginalVMT = *ppBaseTable; }

	uintptr_t Hook(void* NewFunc, const std::size_t Index)
	{
		// save orignal function address
		this->pOrgVFunc = (uintptr_t*)this->pOriginalVMT[Index];

		// change vmt function pointer
		this->pOriginalVMT[Index] = reinterpret_cast<uintptr_t>(NewFunc);
		return (uintptr_t)this->pOrgVFunc;
	}

	void UnHook(const std::size_t Index) { this->pOriginalVMT[Index] = (uintptr_t)this->pOrgVFunc; };

	template <class T>
	T GetOriginal() 
	{ 
		return reinterpret_cast<T>(this->mOrgVFunc); 
	};

private:
	uintptr_t*   pOriginalVMT = nullptr; // Store original vtable
	uintptr_t*   pOrgVFunc = nullptr; // Store original vtable
	uintptr_t**  ppBaseTable = nullptr;
};




delete <<
```

`Private Esp/EspUI/Line.cpp`:

```cpp
#include "Utils.h"
#include "Globals.h"
#include "SDKMisc.h"
#include "C_GameMan.h"
#include "Entity.h"
#include "Engine.h"
#include "Camera.h"

C_Engine*       g_pEngine;
C_BaseEntity*	g_pLocalEntity = nullptr;
C_Camera*		g_pCamera = nullptr;

uintptr_t		g_pOffCamera;
uintptr_t   	g_pOffStatus;
uintptr_t   	g_pOffGame;
uintptr_t   	g_pOffProfile;
uintptr_t   	g_pOffFOV;
uintptr_t   	g_pOffChams;
uintptr_t   	g_pOffSettings;s

namespace Globals
{
	uintptr_t Base = NULL;
	void Globals::HackInit()
	{
		Base = reinterpret_cast<uintptr_t>(GetModuleHandleA(NULL));

		// find class offset pointers
		uintptr_t pOff = (uintptr_t)Utils::FindSignature(Base, "48 8b 05 ?? ?? ?? ?? 48 87 38");
		g_pOffCamera = *reinterpret_cast<uintptr_t*>(pOff + *(uint32_t*)(pOff + 3) + 7);
		std::cout << "g_pOffCamera: " << std::hex << g_pOffCamera << std::endl;

		pOff = reinterpret_cast<uintptr_t>(Utils::FindSignature(Base, "48 8b 0d ?? ?? ?? ?? e8 ?? ?? ?? ?? 49 8b 8e ?? ?? ?? ?? E8"));
		g_pOffStatus = *reinterpret_cast<uintptr_t*>(pOff + *(uint32_t*)(pOff + 3) + 7);
		std::cout << "g_pOffStatus: " << std::hex << g_pOffStatus << std::endl;

		pOff = reinterpret_cast<uintptr_t>(Utils::FindSignature(Base, "a0 ?? ?? ?? ?? ?? ?? ?? ?? 03 00 40 00 00 00 00 44 78"));
		std::cout << "pOff: " << std::hex << pOff << std::endl;
		g_pOffGame = *reinterpret_cast<uintptr_t*>(pOff + *(uint32_t*)(pOff + 3) + 7);		
		std::cout << "g_pOffGame: " << std::hex << g_pOffGame << std::endl;

		pOff = reinterpret_cast<uintptr_t>(Utils::FindSignature(Base, "48 8b 05 ?? ?? ?? ?? 45 8b 9A"));
		g_pOffProfile = *reinterpret_cast<uintptr_t*>(pOff + *(uint32_t*)(pOff + 3) + 7);		
		std::cout << "g_pOffProfile: " << std::hex << g_pOffProfile << std::endl;

		pOff = reinterpret_cast<uintptr_t>(Utils::FindSignature(Base, "48 8b 05 ?? ?? ?? ?? f3 44 0f 10 91"));
		g_pOffFOV = *reinterpret_cast<uintptr_t*>(pOff + *(uint32_t*)(pOff + 3) + 7);
		std::cout << "g_pOffFOV: " << std::hex << g_pOffFOV << std::endl;

		pOff = reinterpret_cast<uintptr_t>(Utils::FindSignature(Base, "48 8b 0d ?? ?? ?? ?? 48 8b d7 e8 ?? ?? ?? ?? 48 85 c0 74 ?? 4c"));
		g_pOffChams = *reinterpret_cast<uintptr_t*>(pOff + *(uint32_t*)(pOff + 3) + 7);	
		std::cout << "g_pOffChams: " << std::hex << g_pOffChams << std::endl;

		pOff = reinterpret_cast<uintptr_t>(Utils::FindSignature(Base, "4C 8B 05 ?? ?? ?? ?? 41 8B 80 ?? ?? ?? ?? 48 69"));
		g_pOffSettings = *reinterpret_cast<uintptr_t*>(pOff + *(uint32_t*)(pOff + 3) + 7);
		std::cout << "g_pOffSettings: " << std::hex << g_pOffSettings << std::endl;

		pOff = reinterpret_cast<uintptr_t>(Utils::FindSignature(Base, "c6 ?? 38 ?? 48 85 db 74"));
		std::cout << "g_pOffUnlock+3: " << std::hex << pOff+3 << std::endl;		

		pOff = reinterpret_cast<uintptr_t>(Utils::FindSignature(Base, "83 F8 01 0f 85 ? ? ? ? F3 0F 10 1D"));
		std::cout << "No Recoil: " << std::hex << pOff << std::endl;

		DWORD Old;
		VirtualProtect((LPVOID)TerminateProcess, sizeof(byte), PAGE_EXECUTE_READWRITE, &Old);
		*(byte*)(TerminateProcess) = 0xC3;
		VirtualProtect((LPVOID)TerminateProcess, sizeof(byte), Old, &Old);

		VirtualProtect((LPVOID)pOff, 4, PAGE_EXECUTE_READWRITE, &Old);
		Utils::Write<bool>(pOff + 3, 0);
		VirtualProtect((LPVOID)pOff, 4, Old, &Old);
		
		// Assign class pointers
		g_pLocalEntity = g_pEngine->GetLocal();
		g_pCamera	   = g_pEngine->GetCamera();

		// Call settings functions
		g_pEngine->SetReolution();
	}

	int g_iWindowWidth = 1920;
	int g_iWindowHeight = 1080;
	bool PressedKeys[256];
}


delete <<
```

`Private Esp/EspUI/Menu 2.h`:

```h
/*
/// # Nuklear
/// ![](https://cloud.githubusercontent.com/assets/8057201/11761525/ae06f0ca-a0c6-11e5-819d-5610b25f6ef4.gif)
///
/// ## Contents
/// 1. About section
/// 2. Highlights section
/// 3. Features section
/// 4. Usage section
///     1. Flags section
///     2. Constants section
///     3. Dependencies section
/// 5. Example section
/// 6. API section
///     1. Context section
///     2. Input section
///     3. Drawing section
///     4. Window section
///     5. Layouting section
///     6. Groups section
///     7. Tree section
///     8. Properties section
/// 7. License section
/// 8. Changelog section
/// 9. Gallery section
/// 10. Credits section
///
/// ## About
/// This is a minimal state immediate mode graphical userss interface toolkit
/// written in ANSI C and licensed under public domain. It was designed as a simple
/// embeddable user interface for application and does not have any dependencies,
/// a default renderbackend or OS window and input handling but instead provides a very modular
/// library approach by using simple input state for input and draw
/// commands describing primitive shapes as output. So instead of providing a
/// layered library that tries to abstract over a number of platform and
/// render backends it only focuses on the actual UI.
///
/// ## Highlights
/// - Graphical user interface toolkit
/// - Single header library
/// - Written in C89 (a.k.a. ANSI C or ISO C90)
/// - Small codebase (~18kLOC)
/// - Focus on portability, efficiency and simplicity
/// - No dependencies (not even the standard library if not wanted)
/// - Fully skinnable and customizable
/// - Low memory footprint with total memory control if needed or wanted
/// - UTF-8 support
/// - No global or hidden state
/// - Customizable library modules (you can compile and use only what you need)
/// - Optional font baker and vertex buffer output
///
/// ## Features
/// - Absolutely no platform dependent code
/// - Memory management control ranging from/to
///     - Ease of use by allocating everything from standard library
///     - Control every byte of memory inside the library
/// - Font handling control ranging from/to
///     - Use your own font implementation for everything
///     - Use this libraries internal font baking and handling API
/// - Drawing output control ranging from/to
///     - Simple shapes for more high level APIs which already have drawing capabilities
///     - Hardware accessible anti-aliased vertex buffer output
/// - Customizable colors and properties ranging from/to
///     - Simple changes to color by filling a simple color table
///     - Complete control with ability to use skinning to decorate widgets
/// - Bendable UI library with widget ranging from/to
///     - Basic widgets like buttons, checkboxes, slider, ...
///     - Advanced widget like abstract comboboxes, contextual menus,...
/// - Compile time configuration to only compile what you need
///     - Subset which can be used if you do not want to link or use the standard library
/// - Can be easily modified to only update on user input instead of frame updates
///
/// ## Usage
/// This library is self contained in one single header file and can be used either
/// in header only mode or in implementation mode. The header only mode is used
/// by default when included and allows including this header in other headers
/// and does not contain the actual implementation. <br /><br />
///
/// The implementation mode requires to define  the preprocessor macro
/// NK_IMPLEMENTATION in *one* .c/.cpp file before #includeing this file, e.g.:
///
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~C
///     #define NK_IMPLEMENTATION
///     #include "nuklear.h"
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
///
/// Also optionally define the symbols listed in the section "OPTIONAL DEFINES"
/// below in header and implementation mode if you want to use additional functionality
/// or need more control over the library.
///
/// !!! WARNING
///     Every time nuklear is included define the same compiler flags. This very important not doing so could lead to compiler errors or even worse stack corruptions.
///
/// ### Flags
/// Flag                            | Description
/// --------------------------------|------------------------------------------
/// NK_PRIVATE                      | If defined declares all functions as static, so they can only be accessed inside the file that contains the implementation
/// NK_INCLUDE_FIXED_TYPES          | If defined it will include header `<stdint.h>` for fixed sized types otherwise nuklear tries to select the correct type. If that fails it will throw a compiler error and you have to select the correct types yourself.
/// NK_INCLUDE_DEFAULT_ALLOCATOR    | If defined it will include header `<stdlib.h>` and provide additional functions to use this library without caring for memory allocation control and therefore ease memory management.
/// NK_INCLUDE_STANDARD_IO          | If defined it will include header `<stdio.h>` and provide additional functions depending on file loading.
/// NK_INCLUDE_STANDARD_VARARGS     | If defined it will include header <stdio.h> and provide additional functions depending on file loading.
/// NK_INCLUDE_VERTEX_BUFFER_OUTPUT | Defining this adds a vertex draw command list backend to this library, which allows you to convert queue commands into vertex draw commands. This is mainly if you need a hardware accessible format for OpenGL, DirectX, Vulkan, Metal,...
/// NK_INCLUDE_FONT_BAKING          | Defining this adds `stb_truetype` and `stb_rect_pack` implementation to this library and provides font baking and rendering. If you already have font handling or do not want to use this font handler you don't have to define it.
/// NK_INCLUDE_DEFAULT_FONT         | Defining this adds the default font: ProggyClean.ttf into this library which can be loaded into a font atlas and allows using this library without having a truetype font
/// NK_INCLUDE_COMMAND_USERDATA     | Defining this adds a userdata pointer into each command. Can be useful for example if you want to provide custom shaders depending on the used widget. Can be combined with the style structures.
/// NK_BUTTON_TRIGGER_ON_RELEASE    | Different platforms require button clicks occurring either on buttons being pressed (up to down) or released (down to up). By default this library will react on buttons being pressed, but if you define this it will only trigger if a button is released.
/// NK_ZERO_COMMAND_MEMORY          | Defining this will zero out memory for each drawing command added to a drawing queue (inside nk_command_buffer_push). Zeroing command memory is very useful for fast checking (using memcmp) if command buffers are equal and avoid drawing frames when nothing on screen has changed since previous frame.
/// NK_UINT_DRAW_INDEX              | Defining this will set the size of vertex index elements when using NK_VERTEX_BUFFER_OUTPUT to 32bit instead of the default of 16bit
///
/// !!! WARNING
///     The following flags will pull in the standard C library:
///     - NK_INCLUDE_DEFAULT_ALLOCATOR
///     - NK_INCLUDE_STANDARD_IO
///     - NK_INCLUDE_STANDARD_VARARGS
///
/// !!! WARNING
///     The following flags if defined need to be defined for both header and implementation:
///     - NK_INCLUDE_FIXED_TYPES
///     - NK_INCLUDE_DEFAULT_ALLOCATOR
///     - NK_INCLUDE_STANDARD_VARARGS
///     - NK_INCLUDE_VERTEX_BUFFER_OUTPUT
///     - NK_INCLUDE_FONT_BAKING
///     - NK_INCLUDE_DEFAULT_FONT
///     - NK_INCLUDE_STANDARD_VARARGS
///     - NK_INCLUDE_COMMAND_USERDATA
///     - NK_UINT_DRAW_INDEX
///
/// ### Constants
/// Define                          | Description
/// --------------------------------|---------------------------------------
/// NK_BUFFER_DEFAULT_INITIAL_SIZE  | Initial buffer size allocated by all buffers while using the default allocator functions included by defining NK_INCLUDE_DEFAULT_ALLOCATOR. If you don't want to allocate the default 4k memory then redefine it.
/// NK_MAX_NUMBER_BUFFER            | Maximum buffer size for the conversion buffer between float and string Under normal circumstances this should be more than sufficient.
/// NK_INPUT_MAX                    | Defines the max number of bytes which can be added as text input in one frame. Under normal circumstances this should be more than sufficient.
///
/// !!! WARNING
///     The following constants if defined need to be defined for both header and implementation:
///     - NK_MAX_NUMBER_BUFFER
///     - NK_BUFFER_DEFAULT_INITIAL_SIZE
///     - NK_INPUT_MAX
///
/// ### Dependencies
/// Function    | Description
/// ------------|---------------------------------------------------------------
/// NK_ASSERT   | If you don't define this, nuklear will use <assert.h> with assert().
/// NK_MEMSET   | You can define this to 'memset' or your own memset implementation replacement. If not nuklear will use its own version.
/// NK_MEMCPY   | You can define this to 'memcpy' or your own memcpy implementation replacement. If not nuklear will use its own version.
/// NK_SQRT     | You can define this to 'sqrt' or your own sqrt implementation replacement. If not nuklear will use its own slow and not highly accurate version.
/// NK_SIN      | You can define this to 'sinf' or your own sine implementation replacement. If not nuklear will use its own approximation implementation.
/// NK_COS      | You can define this to 'cosf' or your own cosine implementation replacement. If not nuklear will use its own approximation implementation.
/// NK_STRTOD   | You can define this to `strtod` or your own string to double conversion implementation replacement. If not defined nuklear will use its own imprecise and possibly unsafe version (does not handle nan or infinity!).
/// NK_DTOA     | You can define this to `dtoa` or your own double to string conversion implementation replacement. If not defined nuklear will use its own imprecise and possibly unsafe version (does not handle nan or infinity!).
/// NK_VSNPRINTF| If you define `NK_INCLUDE_STANDARD_VARARGS` as well as `NK_INCLUDE_STANDARD_IO` and want to be safe define this to `vsnprintf` on compilers supporting later versions of C or C++. By default nuklear will check for your stdlib version in C as well as compiler version in C++. if `vsnprintf` is available it will define it to `vsnprintf` directly. If not defined and if you have older versions of C or C++ it will be defined to `vsprintf` which is unsafe.
///
/// !!! WARNING
///     The following dependencies will pull in the standard C library if not redefined:
///     - NK_ASSERT
///
/// !!! WARNING
///     The following dependencies if defined need to be defined for both header and implementation:
///     - NK_ASSERT
///
/// !!! WARNING
///     The following dependencies if defined need to be defined only for the implementation part:
///     - NK_MEMSET
///     - NK_MEMCPY
///     - NK_SQRT
///     - NK_SIN
///     - NK_COS
///     - NK_STRTOD
///     - NK_DTOA
///     - NK_VSNPRINTF
///
/// ## Example
///
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
/// // init gui state
/// enum {EASY, HARD};
/// static int op = EASY;
/// static float value = 0.6f;
/// static int i =  20;
/// struct nk_context ctx;
///
/// nk_init_fixed(&ctx, calloc(1, MAX_MEMORY), MAX_MEMORY, &font);
/// if (nk_begin(&ctx, "Show", nk_rect(50, 50, 220, 220),
///     NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_CLOSABLE)) {
///     // fixed widget pixel width
///     nk_layout_row_static(&ctx, 30, 80, 1);
///     if (nk_button_label(&ctx, "button")) {
///         // event handling
///     }
///
///     // fixed widget window ratio width
///     nk_layout_row_dynamic(&ctx, 30, 2);
///     if (nk_option_label(&ctx, "easy", op == EASY)) op = EASY;
///     if (nk_option_label(&ctx, "hard", op == HARD)) op = HARD;
///
///     // custom widget pixel width
///     nk_layout_row_begin(&ctx, NK_STATIC, 30, 2);
///     {
///         nk_layout_row_push(&ctx, 50);
///         nk_label(&ctx, "Volume:", NK_TEXT_LEFT);
///         nk_layout_row_push(&ctx, 110);
///         nk_slider_float(&ctx, 0, &value, 1.0f, 0.1f);
///     }
///     nk_layout_row_end(&ctx);
/// }
/// nk_end(&ctx);
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
///
/// ![](https://cloud.githubusercontent.com/assets/8057201/10187981/584ecd68-675c-11e5-897c-822ef534a876.png)
///
/// ## API
///
*/
#ifndef NK_SINGLE_FILE
#define NK_SINGLE_FILE
#endif

#ifndef NK_NUKLEAR_H_
#define NK_NUKLEAR_H_

#ifdef __cplusplus
extern "C" {
#endif
	/*
	 * ==============================================================
	 *
	 *                          CONSTANTS
	 *
	 * ===============================================================
	 */
#define NK_UNDEFINED (-1.0f)
#define NK_UTF_INVALID 0xFFFD /* internal invalid utf8 rune */
#define NK_UTF_SIZE 4 /* describes the number of bytes a glyph consists of*/
#ifndef NK_INPUT_MAX
#define NK_INPUT_MAX 16
#endif
#ifndef NK_MAX_NUMBER_BUFFER
#define NK_MAX_NUMBER_BUFFER 64
#endif
#ifndef NK_SCROLLBAR_HIDING_TIMEOUT
#define NK_SCROLLBAR_HIDING_TIMEOUT 4.0f
#endif
	 /*
	  * ==============================================================
	  *
	  *                          HELPER
	  *
	  * ===============================================================
	  */
#ifndef NK_API
#ifdef NK_PRIVATE
#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199409L))
#define NK_API static inline
#elif defined(__cplusplus)
#define NK_API static inline
#else
#define NK_API static
#endif
#else
#define NK_API extern
#endif
#endif
#ifndef NK_LIB
#ifdef NK_SINGLE_FILE
#define NK_LIB static
#else
#define NK_LIB extern
#endif
#endif

#define NK_INTERN static
#define NK_STORAGE static
#define NK_GLOBAL static

#define NK_FLAG(x) (1 << (x))
#define NK_STRINGIFY(x) #x
#define NK_MACRO_STRINGIFY(x) NK_STRINGIFY(x)
#define NK_STRING_JOIN_IMMEDIATE(arg1, arg2) arg1 ## arg2
#define NK_STRING_JOIN_DELAY(arg1, arg2) NK_STRING_JOIN_IMMEDIATE(arg1, arg2)
#define NK_STRING_JOIN(arg1, arg2) NK_STRING_JOIN_DELAY(arg1, arg2)

#ifdef _MSC_VER
#define NK_UNIQUE_NAME(name) NK_STRING_JOIN(name,__COUNTER__)
#else
#define NK_UNIQUE_NAME(name) NK_STRING_JOIN(name,__LINE__)
#endif

#ifndef NK_STATIC_ASSERT
#define NK_STATIC_ASSERT(exp) typedef char NK_UNIQUE_NAME(_dummy_array)[(exp)?1:-1]
#endif

#ifndef NK_FILE_LINE
#ifdef _MSC_VER
#define NK_FILE_LINE __FILE__ ":" NK_MACRO_STRINGIFY(__COUNTER__)
#else
#define NK_FILE_LINE __FILE__ ":" NK_MACRO_STRINGIFY(__LINE__)
#endif
#endif

#define NK_MIN(a, b) ((a) < (b) ? (a) : (b))
#define NK_MAX(a, b) ((a) < (b) ? (b) : (a))
#define NK_CLAMP(i, v, x) (NK_MAX(NK_MIN(v,x), i))

#ifdef NK_INCLUDE_STANDARD_VARARGS
#if defined(_MSC_VER) && (_MSC_VER >= 1600) /* VS 2010 and above */
#include <sal.h>
#define NK_PRINTF_FORMAT_STRING _Printf_format_string_
#else
#define NK_PRINTF_FORMAT_STRING
#endif
#if defined(__GNUC__)
#define NK_PRINTF_VARARG_FUNC(fmtargnumber) __attribute__((format(__printf__, fmtargnumber, fmtargnumber+1)))
#define NK_PRINTF_VALIST_FUNC(fmtargnumber) __attribute__((format(__printf__, fmtargnumber, 0)))
#else
#define NK_PRINTF_VARARG_FUNC(fmtargnumber)
#define NK_PRINTF_VALIST_FUNC(fmtargnumber)
#endif
#endif

	  /*
	   * ===============================================================
	   *
	   *                          BASIC
	   *
	   * ===============================================================
	   */
#ifdef NK_INCLUDE_FIXED_TYPES

#include <stdint.h>

#define NK_INT8 int8_t
#define NK_UINT8 uint8_t
#define NK_INT16 int16_t
#define NK_UINT16 uint16_t
#define NK_INT32 int32_t
#define NK_UINT32 uint32_t
#define NK_SIZE_TYPE uintptr_t
#define NK_POINTER_TYPE uintptr_t
#else
#ifndef NK_INT8
#define NK_INT8 signed char
#endif
#ifndef NK_UINT8
#define NK_UINT8 unsigned char
#endif
#ifndef NK_INT16
#define NK_INT16 signed short
#endif
#ifndef NK_UINT16
#define NK_UINT16 unsigned short
#endif
#ifndef NK_INT32
#if defined(_MSC_VER)
#define NK_INT32 __int32
#else
#define NK_INT32 signed int
#endif
#endif
#ifndef NK_UINT32
#if defined(_MSC_VER)
#define NK_UINT32 unsigned __int32
#else
#define NK_UINT32 unsigned int
#endif
#endif
#ifndef NK_SIZE_TYPE
#if defined(_WIN64) && defined(_MSC_VER)
#define NK_SIZE_TYPE unsigned __int64
#elif (defined(_WIN32) || defined(WIN32)) && defined(_MSC_VER)
#define NK_SIZE_TYPE unsigned __int32
#elif defined(__GNUC__) || defined(__clang__)
#if defined(__x86_64__) || defined(__ppc64__)
#define NK_SIZE_TYPE unsigned long
#else
#define NK_SIZE_TYPE unsigned int
#endif
#else
#define NK_SIZE_TYPE unsigned long
#endif
#endif
#ifndef NK_POINTER_TYPE
#if defined(_WIN64) && defined(_MSC_VER)
#define NK_POINTER_TYPE unsigned __int64
#elif (defined(_WIN32) || defined(WIN32)) && defined(_MSC_VER)
#define NK_POINTER_TYPE unsigned __int32
#elif defined(__GNUC__) || defined(__clang__)
#if defined(__x86_64__) || defined(__ppc64__)
#define NK_POINTER_TYPE unsigned long
#else
#define NK_POINTER_TYPE unsigned int
#endif
#else
#define NK_POINTER_TYPE unsigned long
#endif
#endif
#endif

	typedef NK_INT8 nk_char;
	typedef NK_UINT8 nk_uchar;
	typedef NK_UINT8 nk_byte;
	typedef NK_INT16 nk_short;
	typedef NK_UINT16 nk_ushort;
	typedef NK_INT32 nk_int;
	typedef NK_UINT32 nk_uint;
	typedef NK_SIZE_TYPE nk_size;
	typedef NK_POINTER_TYPE nk_ptr;

	typedef nk_uint nk_hash;
	typedef nk_uint nk_flags;
	typedef nk_uint nk_rune;

	/* Make sure correct type size:
	 * This will fire with a negative subscript error if the type sizes
	 * are set incorrectly by the compiler, and compile out if not */
	NK_STATIC_ASSERT(sizeof(nk_short) == 2);
	NK_STATIC_ASSERT(sizeof(nk_ushort) == 2);
	NK_STATIC_ASSERT(sizeof(nk_uint) == 4);
	NK_STATIC_ASSERT(sizeof(nk_int) == 4);
	NK_STATIC_ASSERT(sizeof(nk_byte) == 1);
	NK_STATIC_ASSERT(sizeof(nk_flags) >= 4);
	NK_STATIC_ASSERT(sizeof(nk_rune) >= 4);
	NK_STATIC_ASSERT(sizeof(nk_size) >= sizeof(void*));
	NK_STATIC_ASSERT(sizeof(nk_ptr) >= sizeof(void*));

	/* ============================================================================
	 *
	 *                                  API
	 *
	 * =========================================================================== */
	struct nk_buffer;
	struct nk_allocator;
	struct nk_command_buffer;
	struct nk_draw_command;
	struct nk_convert_config;
	struct nk_style_item;
	struct nk_text_edit;
	struct nk_draw_list;
	struct nk_user_font;
	struct nk_panel;
	struct nk_context;
	struct nk_draw_vertex_layout_element;
	struct nk_style_button;
	struct nk_style_toggle;
	struct nk_style_selectable;
	struct nk_style_slide;
	struct nk_style_progress;
	struct nk_style_scrollbar;
	struct nk_style_edit;
	struct nk_style_property;
	struct nk_style_chart;
	struct nk_style_combo;
	struct nk_style_tab;
	struct nk_style_window_header;
	struct nk_style_window;

	enum {
		nk_false, nk_true
	};
	struct nk_color {
		nk_byte r, g, b, a;
	};
	struct nk_colorf {
		float r, g, b, a;
	};
	struct nk_vec2 {
		float x, y;
	};
	struct nk_vec2i {
		short x, y;
	};
	struct nk_rect {
		float x, y, w, h;
	};
	struct nk_recti {
		short x, y, w, h;
	};
	typedef char nk_glyph[NK_UTF_SIZE];
	typedef union {
		void* ptr;
		int id;
	} nk_handle;
	struct nk_image {
		nk_handle handle;
		unsigned short w, h;
		unsigned short region[4];
	};
	struct nk_cursor {
		struct nk_image img;
		struct nk_vec2 size, offset;
	};
	struct nk_scroll {
		nk_uint x, y;
	};

	enum nk_heading {
		NK_UP, NK_RIGHT, NK_DOWN, NK_LEFT
	};
	enum nk_button_behavior {
		NK_BUTTON_DEFAULT, NK_BUTTON_REPEATER
	};
	enum nk_modify {
		NK_FIXED = nk_false, NK_MODIFIABLE = nk_true
	};
	enum nk_orientation {
		NK_VERTICAL, NK_HORIZONTAL
	};
	enum nk_collapse_states {
		NK_MINIMIZED = nk_false, NK_MAXIMIZED = nk_true
	};
	enum nk_show_states {
		NK_HIDDEN = nk_false, NK_SHOWN = nk_true
	};
	enum nk_chart_type {
		NK_CHART_LINES, NK_CHART_COLUMN, NK_CHART_MAX
	};
	enum nk_chart_event {
		NK_CHART_HOVERING = 0x01, NK_CHART_CLICKED = 0x02
	};
	enum nk_color_format {
		NK_RGB, NK_RGBA
	};
	enum nk_popup_type {
		NK_POPUP_STATIC, NK_POPUP_DYNAMIC
	};
	enum nk_layout_format {
		NK_DYNAMIC, NK_STATIC
	};
	enum nk_tree_type {
		NK_TREE_NODE, NK_TREE_TAB
	};

	typedef void* (*nk_plugin_alloc)(nk_handle, void* old, nk_size);

	typedef void (*nk_plugin_free)(nk_handle, void* old);

	typedef int(*nk_plugin_filter)(const struct nk_text_edit*, nk_rune unicode);

	typedef void(*nk_plugin_paste)(nk_handle, struct nk_text_edit*);

	typedef void(*nk_plugin_copy)(nk_handle, const char*, int len);

	struct nk_allocator {
		nk_handle userdata;
		nk_plugin_alloc alloc;
		nk_plugin_free free;
	};
	enum nk_symbol_type {
		NK_SYMBOL_NONE,
		NK_SYMBOL_X,
		NK_SYMBOL_UNDERSCORE,
		NK_SYMBOL_CIRCLE_SOLID,
		NK_SYMBOL_CIRCLE_OUTLINE,
		NK_SYMBOL_RECT_SOLID,
		NK_SYMBOL_RECT_OUTLINE,
		NK_SYMBOL_TRIANGLE_UP,
		NK_SYMBOL_TRIANGLE_DOWN,
		NK_SYMBOL_TRIANGLE_LEFT,
		NK_SYMBOL_TRIANGLE_RIGHT,
		NK_SYMBOL_PLUS,
		NK_SYMBOL_MINUS,
		NK_SYMBOL_MAX
	};
	/* =============================================================================
	 *
	 *                                  CONTEXT
	 *
	 * =============================================================================*/
	 /*/// ### Context
	 /// Contexts are the main entry point and the majestro of nuklear and contain all required state.
	 /// They are used for window, memory, input, style, stack, commands and time management and need
	 /// to be passed into all nuklear GUI specific functions.
	 ///
	 /// #### Usage
	 /// To use a context it first has to be initialized which can be achieved by calling
	 /// one of either `nk_init_default`, `nk_init_fixed`, `nk_init`, `nk_init_custom`.
	 /// Each takes in a font handle and a specific way of handling memory. Memory control
	 /// hereby ranges from standard library to just specifying a fixed sized block of memory
	 /// which nuklear has to manage itself from.
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// struct nk_context ctx;
	 /// nk_init_xxx(&ctx, ...);
	 /// while (1) {
	 ///     // [...]
	 ///     nk_clear(&ctx);
	 /// }
	 /// nk_free(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// #### Reference
	 /// Function            | Description
	 /// --------------------|-------------------------------------------------------
	 /// __nk_init_default__ | Initializes context with standard library memory allocation (malloc,free)
	 /// __nk_init_fixed__   | Initializes context from single fixed size memory block
	 /// __nk_init__         | Initializes context with memory allocator callbacks for alloc and free
	 /// __nk_init_custom__  | Initializes context from two buffers. One for draw commands the other for window/panel/table allocations
	 /// __nk_clear__        | Called at the end of the frame to reset and prepare the context for the next frame
	 /// __nk_free__         | Shutdown and free all memory allocated inside the context
	 /// __nk_set_user_data__| Utility function to pass user data to draw command
	  */
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR
	  /*/// #### nk_init_default
	  /// Initializes a `nk_context` struct with a default standard library allocator.
	  /// Should be used if you don't want to be bothered with memory management in nuklear.
	  ///
	  /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	  /// int nk_init_default(struct nk_context *ctx, const struct nk_user_font *font);
	  /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  ///
	  /// Parameter   | Description
	  /// ------------|---------------------------------------------------------------
	  /// __ctx__     | Must point to an either stack or heap allocated `nk_context` struct
	  /// __font__    | Must point to a previously initialized font handle for more info look at font documentation
	  ///
	  /// Returns either `false(0)` on failure or `true(1)` on success.
	  ///
	  */
	NK_API int nk_init_default(struct nk_context*, const struct nk_user_font*);

#endif
	/*/// #### nk_init_fixed
	/// Initializes a `nk_context` struct from single fixed size memory block
	/// Should be used if you want complete control over nuklear's memory management.
	/// Especially recommended for system with little memory or systems with virtual memory.
	/// For the later case you can just allocate for example 16MB of virtual memory
	/// and only the required amount of memory will actually be committed.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_init_fixed(struct nk_context *ctx, void *memory, nk_size size, const struct nk_user_font *font);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// !!! Warning
	///     make sure the passed memory block is aligned correctly for `nk_draw_commands`.
	///
	/// Parameter   | Description
	/// ------------|--------------------------------------------------------------
	/// __ctx__     | Must point to an either stack or heap allocated `nk_context` struct
	/// __memory__  | Must point to a previously allocated memory block
	/// __size__    | Must contain the total size of __memory__
	/// __font__    | Must point to a previously initialized font handle for more info look at font documentation
	///
	/// Returns either `false(0)` on failure or `true(1)` on success.
	*/
	NK_API int nk_init_fixed(struct nk_context*, void* memory, nk_size size, const struct nk_user_font*);
	/*/// #### nk_init
	/// Initializes a `nk_context` struct with memory allocation callbacks for nuklear to allocate
	/// memory from. Used internally for `nk_init_default` and provides a kitchen sink allocation
	/// interface to nuklear. Can be useful for cases like monitoring memory consumption.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_init(struct nk_context *ctx, struct nk_allocator *alloc, const struct nk_user_font *font);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|---------------------------------------------------------------
	/// __ctx__     | Must point to an either stack or heap allocated `nk_context` struct
	/// __alloc__   | Must point to a previously allocated memory allocator
	/// __font__    | Must point to a previously initialized font handle for more info look at font documentation
	///
	/// Returns either `false(0)` on failure or `true(1)` on success.
	*/
	NK_API int nk_init(struct nk_context*, struct nk_allocator*, const struct nk_user_font*);
	/*/// #### nk_init_custom
	/// Initializes a `nk_context` struct from two different either fixed or growing
	/// buffers. The first buffer is for allocating draw commands while the second buffer is
	/// used for allocating windows, panels and state tables.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_init_custom(struct nk_context *ctx, struct nk_buffer *cmds, struct nk_buffer *pool, const struct nk_user_font *font);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|---------------------------------------------------------------
	/// __ctx__     | Must point to an either stack or heap allocated `nk_context` struct
	/// __cmds__    | Must point to a previously initialized memory buffer either fixed or dynamic to store draw commands into
	/// __pool__    | Must point to a previously initialized memory buffer either fixed or dynamic to store windows, panels and tables
	/// __font__    | Must point to a previously initialized font handle for more info look at font documentation
	///
	/// Returns either `false(0)` on failure or `true(1)` on success.
	*/
	NK_API int
		nk_init_custom(struct nk_context*, struct nk_buffer* cmds, struct nk_buffer* pool, const struct nk_user_font*);
	/*/// #### nk_clear
	/// Resets the context state at the end of the frame. This includes mostly
	/// garbage collector tasks like removing windows or table not called and therefore
	/// used anymore.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_clear(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	*/
	NK_API void nk_clear(struct nk_context*);
	/*/// #### nk_free
	/// Frees all memory allocated by nuklear. Not needed if context was
	/// initialized with `nk_init_fixed`.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_free(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	*/
	NK_API void nk_free(struct nk_context*);

#ifdef NK_INCLUDE_COMMAND_USERDATA
	/*/// #### nk_set_user_data
/// Sets the currently passed userdata passed down into each draw command.
///
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
/// void nk_set_user_data(struct nk_context *ctx, nk_handle data);
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
///
/// Parameter   | Description
/// ------------|--------------------------------------------------------------
/// __ctx__     | Must point to a previously initialized `nk_context` struct
/// __data__    | Handle with either pointer or index to be passed into every draw commands
*/
	NK_API void nk_set_user_data(struct nk_context*, nk_handle handle);
#endif
	/* =============================================================================
	 *
	 *                                  INPUT
	 *
	 * =============================================================================*/
	 /*/// ### Input
	 /// The input API is responsible for holding the current input state composed of
	 /// mouse, key and text input states.
	 /// It is worth noting that no direct os or window handling is done in nuklear.
	 /// Instead all input state has to be provided by platform specific code. This in one hand
	 /// expects more work from the user and complicates usage but on the other hand
	 /// provides simple abstraction over a big number of platforms, libraries and other
	 /// already provided functionality.
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// nk_input_begin(&ctx);
	 /// while (GetEvent(&evt)) {
	 ///     if (evt.type == MOUSE_MOVE)
	 ///         nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	 ///     else if (evt.type == [...]) {
	 ///         // [...]
	 ///     }
	 /// } nk_input_end(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// #### Usage
	 /// Input state needs to be provided to nuklear by first calling `nk_input_begin`
	 /// which resets internal state like delta mouse position and button transistions.
	 /// After `nk_input_begin` all current input state needs to be provided. This includes
	 /// mouse motion, button and key pressed and released, text input and scrolling.
	 /// Both event- or state-based input handling are supported by this API
	 /// and should work without problems. Finally after all input state has been
	 /// mirrored `nk_input_end` needs to be called to finish input process.
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// struct nk_context ctx;
	 /// nk_init_xxx(&ctx, ...);
	 /// while (1) {
	 ///     Event evt;
	 ///     nk_input_begin(&ctx);
	 ///     while (GetEvent(&evt)) {
	 ///         if (evt.type == MOUSE_MOVE)
	 ///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	 ///         else if (evt.type == [...]) {
	 ///             // [...]
	 ///         }
	 ///     }
	 ///     nk_input_end(&ctx);
	 ///     // [...]
	 ///     nk_clear(&ctx);
	 /// } nk_free(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// #### Reference
	 /// Function            | Description
	 /// --------------------|-------------------------------------------------------
	 /// __nk_input_begin__  | Begins the input mirroring process. Needs to be called before all other `nk_input_xxx` calls
	 /// __nk_input_motion__ | Mirrors mouse cursor position
	 /// __nk_input_key__    | Mirrors key state with either pressed or released
	 /// __nk_input_button__ | Mirrors mouse button state with either pressed or released
	 /// __nk_input_scroll__ | Mirrors mouse scroll values
	 /// __nk_input_char__   | Adds a single ASCII text character into an internal text buffer
	 /// __nk_input_glyph__  | Adds a single multi-byte UTF-8 character into an internal text buffer
	 /// __nk_input_unicode__| Adds a single unicode rune into an internal text buffer
	 /// __nk_input_end__    | Ends the input mirroring process by calculating state changes. Don't call any `nk_input_xxx` function referenced above after this call
	 */
	enum nk_keys {
		NK_KEY_NONE,
		NK_KEY_SHIFT,
		NK_KEY_CTRL,
		NK_KEY_DEL,
		NK_KEY_ENTER,
		NK_KEY_TAB,
		NK_KEY_BACKSPACE,
		NK_KEY_COPY,
		NK_KEY_CUT,
		NK_KEY_PASTE,
		NK_KEY_UP,
		NK_KEY_DOWN,
		NK_KEY_LEFT,
		NK_KEY_RIGHT,
		/* Shortcuts: text field */
		NK_KEY_TEXT_INSERT_MODE,
		NK_KEY_TEXT_REPLACE_MODE,
		NK_KEY_TEXT_RESET_MODE,
		NK_KEY_TEXT_LINE_START,
		NK_KEY_TEXT_LINE_END,
		NK_KEY_TEXT_START,
		NK_KEY_TEXT_END,
		NK_KEY_TEXT_UNDO,
		NK_KEY_TEXT_REDO,
		NK_KEY_TEXT_SELECT_ALL,
		NK_KEY_TEXT_WORD_LEFT,
		NK_KEY_TEXT_WORD_RIGHT,
		/* Shortcuts: scrollbar */
		NK_KEY_SCROLL_START,
		NK_KEY_SCROLL_END,
		NK_KEY_SCROLL_DOWN,
		NK_KEY_SCROLL_UP,
		NK_KEY_MAX
	};
	enum nk_buttons {
		NK_BUTTON_LEFT, NK_BUTTON_MIDDLE, NK_BUTTON_RIGHT, NK_BUTTON_DOUBLE, NK_BUTTON_MAX
	};
	/*/// #### nk_input_begin
	/// Begins the input mirroring process by resetting text, scroll
	/// mouse previous mouse position and movement as well as key state transitions,
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_begin(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	*/
	NK_API void nk_input_begin(struct nk_context*);
	/*/// #### nk_input_motion
	/// Mirrors current mouse position to nuklear
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_motion(struct nk_context *ctx, int x, int y);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __x__       | Must hold an integer describing the current mouse cursor x-position
	/// __y__       | Must hold an integer describing the current mouse cursor y-position
	*/
	NK_API void nk_input_motion(struct nk_context*, int x, int y);
	/*/// #### nk_input_key
	/// Mirrors state of a specific key to nuklear
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_key(struct nk_context*, enum nk_keys key, int down);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __key__     | Must be any value specified in enum `nk_keys` that needs to be mirrored
	/// __down__    | Must be 0 for key is up and 1 for key is down
	*/
	NK_API void nk_input_key(struct nk_context*, enum nk_keys, int down);
	/*/// #### nk_input_button
	/// Mirrors the state of a specific mouse button to nuklear
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_button(struct nk_context *ctx, enum nk_buttons btn, int x, int y, int down);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __btn__     | Must be any value specified in enum `nk_buttons` that needs to be mirrored
	/// __x__       | Must contain an integer describing mouse cursor x-position on click up/down
	/// __y__       | Must contain an integer describing mouse cursor y-position on click up/down
	/// __down__    | Must be 0 for key is up and 1 for key is down
	*/
	NK_API void nk_input_button(struct nk_context*, enum nk_buttons, int x, int y, int down);
	/*/// #### nk_input_scroll
	/// Copies the last mouse scroll value to nuklear. Is generally
	/// a scroll value. So does not have to come from mouse and could also originate
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_scroll(struct nk_context *ctx, struct nk_vec2 val);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __val__     | vector with both X- as well as Y-scroll value
	*/
	NK_API void nk_input_scroll(struct nk_context*, struct nk_vec2 val);
	/*/// #### nk_input_char
	/// Copies a single ASCII character into an internal text buffer
	/// This is basically a helper function to quickly push ASCII characters into
	/// nuklear.
	///
	/// !!! Note
	///     Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_char(struct nk_context *ctx, char c);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __c__       | Must be a single ASCII character preferable one that can be printed
	*/
	NK_API void nk_input_char(struct nk_context*, char);
	/*/// #### nk_input_glyph
	/// Converts an encoded unicode rune into UTF-8 and copies the result into an
	/// internal text buffer.
	///
	/// !!! Note
	///     Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_glyph(struct nk_context *ctx, const nk_glyph g);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __g__       | UTF-32 unicode codepoint
	*/
	NK_API void nk_input_glyph(struct nk_context*, const nk_glyph);
	/*/// #### nk_input_unicode
	/// Converts a unicode rune into UTF-8 and copies the result
	/// into an internal text buffer.
	/// !!! Note
	///     Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_unicode(struct nk_context*, nk_rune rune);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __rune__    | UTF-32 unicode codepoint
	*/
	NK_API void nk_input_unicode(struct nk_context*, nk_rune);
	/*/// #### nk_input_end
	/// End the input mirroring process by resetting mouse grabbing
	/// state to ensure the mouse cursor is not grabbed indefinitely.///
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_end(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	*/
	NK_API void nk_input_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  DRAWING
	 *
	 * =============================================================================*/
	 /*/// ### Drawing
	 /// This library was designed to be render backend agnostic so it does
	 /// not draw anything to screen directly. Instead all drawn shapes, widgets
	 /// are made of, are buffered into memory and make up a command queue.
	 /// Each frame therefore fills the command buffer with draw commands
	 /// that then need to be executed by the user and his own render backend.
	 /// After that the command buffer needs to be cleared and a new frame can be
	 /// started. It is probably important to note that the command buffer is the main
	 /// drawing API and the optional vertex buffer API only takes this format and
	 /// converts it into a hardware accessible format.
	 ///
	 /// #### Usage
	 /// To draw all draw commands accumulated over a frame you need your own render
	 /// backend able to draw a number of 2D primitives. This includes at least
	 /// filled and stroked rectangles, circles, text, lines, triangles and scissors.
	 /// As soon as this criterion is met you can iterate over each draw command
	 /// and execute each draw command in a interpreter like fashion:
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// const struct nk_command *cmd = 0;
	 /// nk_foreach(cmd, &ctx) {
	 ///     switch (cmd->type) {
	 ///     case NK_COMMAND_LINE:
	 ///         your_draw_line_function(...)
	 ///         break;
	 ///     case NK_COMMAND_RECT
	 ///         your_draw_rect_function(...)
	 ///         break;
	 ///     case //...:
	 ///         //[...]
	 ///     }
	 /// }
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// In program flow context draw commands need to be executed after input has been
	 /// gathered and the complete UI with windows and their contained widgets have
	 /// been executed and before calling `nk_clear` which frees all previously
	 /// allocated draw commands.
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// struct nk_context ctx;
	 /// nk_init_xxx(&ctx, ...);
	 /// while (1) {
	 ///     Event evt;
	 ///     nk_input_begin(&ctx);
	 ///     while (GetEvent(&evt)) {
	 ///         if (evt.type == MOUSE_MOVE)
	 ///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	 ///         else if (evt.type == [...]) {
	 ///             [...]
	 ///         }
	 ///     }
	 ///     nk_input_end(&ctx);
	 ///     //
	 ///     // [...]
	 ///     //
	 ///     const struct nk_command *cmd = 0;
	 ///     nk_foreach(cmd, &ctx) {
	 ///     switch (cmd->type) {
	 ///     case NK_COMMAND_LINE:
	 ///         your_draw_line_function(...)
	 ///         break;
	 ///     case NK_COMMAND_RECT
	 ///         your_draw_rect_function(...)
	 ///         break;
	 ///     case ...:
	 ///         // [...]
	 ///     }
	 ///     nk_clear(&ctx);
	 /// }
	 /// nk_free(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// You probably noticed that you have to draw all of the UI each frame which is
	 /// quite wasteful. While the actual UI updating loop is quite fast rendering
	 /// without actually needing it is not. So there are multiple things you could do.
	 ///
	 /// First is only update on input. This of course is only an option if your
	 /// application only depends on the UI and does not require any outside calculations.
	 /// If you actually only update on input make sure to update the UI two times each
	 /// frame and call `nk_clear` directly after the first pass and only draw in
	 /// the second pass. In addition it is recommended to also add additional timers
	 /// to make sure the UI is not drawn more than a fixed number of frames per second.
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// struct nk_context ctx;
	 /// nk_init_xxx(&ctx, ...);
	 /// while (1) {
	 ///     // [...wait for input ]
	 ///     // [...do two UI passes ...]
	 ///     do_ui(...)
	 ///     nk_clear(&ctx);
	 ///     do_ui(...)
	 ///     //
	 ///     // draw
	 ///     const struct nk_command *cmd = 0;
	 ///     nk_foreach(cmd, &ctx) {
	 ///     switch (cmd->type) {
	 ///     case NK_COMMAND_LINE:
	 ///         your_draw_line_function(...)
	 ///         break;
	 ///     case NK_COMMAND_RECT
	 ///         your_draw_rect_function(...)
	 ///         break;
	 ///     case ...:
	 ///         //[...]
	 ///     }
	 ///     nk_clear(&ctx);
	 /// }
	 /// nk_free(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// The second probably more applicable trick is to only draw if anything changed.
	 /// It is not really useful for applications with continuous draw loop but
	 /// quite useful for desktop applications. To actually get nuklear to only
	 /// draw on changes you first have to define `NK_ZERO_COMMAND_MEMORY` and
	 /// allocate a memory buffer that will store each unique drawing output.
	 /// After each frame you compare the draw command memory inside the library
	 /// with your allocated buffer by memcmp. If memcmp detects differences
	 /// you have to copy the command buffer into the allocated buffer
	 /// and then draw like usual (this example uses fixed memory but you could
	 /// use dynamically allocated memory).
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// //[... other defines ...]
	 /// #define NK_ZERO_COMMAND_MEMORY
	 /// #include "nuklear.h"
	 /// //
	 /// // setup context
	 /// struct nk_context ctx;
	 /// void *last = calloc(1,64*1024);
	 /// void *buf = calloc(1,64*1024);
	 /// nk_init_fixed(&ctx, buf, 64*1024);
	 /// //
	 /// // loop
	 /// while (1) {
	 ///     // [...input...]
	 ///     // [...ui...]
	 ///     void *cmds = nk_buffer_memory(&ctx.memory);
	 ///     if (memcmp(cmds, last, ctx.memory.allocated)) {
	 ///         memcpy(last,cmds,ctx.memory.allocated);
	 ///         const struct nk_command *cmd = 0;
	 ///         nk_foreach(cmd, &ctx) {
	 ///             switch (cmd->type) {
	 ///             case NK_COMMAND_LINE:
	 ///                 your_draw_line_function(...)
	 ///                 break;
	 ///             case NK_COMMAND_RECT
	 ///                 your_draw_rect_function(...)
	 ///                 break;
	 ///             case ...:
	 ///                 // [...]
	 ///             }
	 ///         }
	 ///     }
	 ///     nk_clear(&ctx);
	 /// }
	 /// nk_free(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// Finally while using draw commands makes sense for higher abstracted platforms like
	 /// X11 and Win32 or drawing libraries it is often desirable to use graphics
	 /// hardware directly. Therefore it is possible to just define
	 /// `NK_INCLUDE_VERTEX_BUFFER_OUTPUT` which includes optional vertex output.
	 /// To access the vertex output you first have to convert all draw commands into
	 /// vertexes by calling `nk_convert` which takes in your preferred vertex format.
	 /// After successfully converting all draw commands just iterate over and execute all
	 /// vertex draw commands:
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// // fill configuration
	 /// struct your_vertex
	 /// {
	 ///     float pos[2]; // important to keep it to 2 floats
	 ///     float uv[2];
	 ///     unsigned char col[4];
	 /// };
	 /// struct nk_convert_config cfg = {};
	 /// static const struct nk_draw_vertex_layout_element vertex_layout[] = {
	 ///     {NK_VERTEX_POSITION, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, pos)},
	 ///     {NK_VERTEX_TEXCOORD, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, uv)},
	 ///     {NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, NK_OFFSETOF(struct your_vertex, col)},
	 ///     {NK_VERTEX_LAYOUT_END}
	 /// };
	 /// cfg.shape_AA = NK_ANTI_ALIASING_ON;
	 /// cfg.line_AA = NK_ANTI_ALIASING_ON;
	 /// cfg.vertex_layout = vertex_layout;
	 /// cfg.vertex_size = sizeof(struct your_vertex);
	 /// cfg.vertex_alignment = NK_ALIGNOF(struct your_vertex);
	 /// cfg.circle_segment_count = 22;
	 /// cfg.curve_segment_count = 22;
	 /// cfg.arc_segment_count = 22;
	 /// cfg.global_alpha = 1.0f;
	 /// cfg.null = dev->null;
	 /// //
	 /// // setup buffers and convert
	 /// struct nk_buffer cmds, verts, idx;
	 /// nk_buffer_init_default(&cmds);
	 /// nk_buffer_init_default(&verts);
	 /// nk_buffer_init_default(&idx);
	 /// nk_convert(&ctx, &cmds, &verts, &idx, &cfg);
	 /// //
	 /// // draw
	 /// nk_draw_foreach(cmd, &ctx, &cmds) {
	 /// if (!cmd->elem_count) continue;
	 ///     //[...]
	 /// }
	 /// nk_buffer_free(&cms);
	 /// nk_buffer_free(&verts);
	 /// nk_buffer_free(&idx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// #### Reference
	 /// Function            | Description
	 /// --------------------|-------------------------------------------------------
	 /// __nk__begin__       | Returns the first draw command in the context draw command list to be drawn
	 /// __nk__next__        | Increments the draw command iterator to the next command inside the context draw command list
	 /// __nk_foreach__      | Iterates over each draw command inside the context draw command list
	 /// __nk_convert__      | Converts from the abstract draw commands list into a hardware accessible vertex format
	 /// __nk_draw_begin__   | Returns the first vertex command in the context vertex draw list to be executed
	 /// __nk__draw_next__   | Increments the vertex command iterator to the next command inside the context vertex command list
	 /// __nk__draw_end__    | Returns the end of the vertex draw list
	 /// __nk_draw_foreach__ | Iterates over each vertex draw command inside the vertex draw list
	 */
	enum nk_anti_aliasing {
		NK_ANTI_ALIASING_OFF, NK_ANTI_ALIASING_ON
	};
	enum nk_convert_result {
		NK_CONVERT_SUCCESS = 0,
		NK_CONVERT_INVALID_PARAM = 1,
		NK_CONVERT_COMMAND_BUFFER_FULL = NK_FLAG(1),
		NK_CONVERT_VERTEX_BUFFER_FULL = NK_FLAG(2),
		NK_CONVERT_ELEMENT_BUFFER_FULL = NK_FLAG(3)
	};
	struct nk_draw_null_texture {
		nk_handle texture; /* texture handle to a texture with a white pixel */
		struct nk_vec2 uv; /* coordinates to a white pixel in the texture  */
	};
	struct nk_convert_config {
		float global_alpha; /* global alpha value */
		enum nk_anti_aliasing line_AA; /* line anti-aliasing flag can be turned off if you are tight on memory */
		enum nk_anti_aliasing shape_AA; /* shape anti-aliasing flag can be turned off if you are tight on memory */
		unsigned circle_segment_count; /* number of segments used for circles: default to 22 */
		unsigned arc_segment_count; /* number of segments used for arcs: default to 22 */
		unsigned curve_segment_count; /* number of segments used for curves: default to 22 */
		struct nk_draw_null_texture null; /* handle to texture with a white pixel for shape drawing */
		const struct nk_draw_vertex_layout_element* vertex_layout; /* describes the vertex output format and packing */
		nk_size vertex_size; /* sizeof one vertex for vertex packing */
		nk_size vertex_alignment; /* vertex alignment: Can be obtained by NK_ALIGNOF */
	};
	/*/// #### nk__begin
	/// Returns a draw command list iterator to iterate all draw
	/// commands accumulated over one frame.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// const struct nk_command* nk__begin(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | must point to an previously initialized `nk_context` struct at the end of a frame
	///
	/// Returns draw command pointer pointing to the first command inside the draw command list
	*/
	NK_API const struct nk_command* nk__begin(struct nk_context*);
	/*/// #### nk__next
	/// Returns a draw command list iterator to iterate all draw
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// const struct nk_command* nk__next(struct nk_context*, const struct nk_command*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	/// __cmd__     | Must point to an previously a draw command either returned by `nk__begin` or `nk__next`
	///
	/// Returns draw command pointer pointing to the next command inside the draw command list
	*/
	NK_API const struct nk_command* nk__next(struct nk_context*, const struct nk_command*);
	/*/// #### nk_foreach
	/// Iterates over each draw command inside the context draw command list
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_foreach(c, ctx)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	/// __cmd__     | Command pointer initialized to NULL
	///
	/// Returns draw command pointer pointing to the next command inside the draw command list
	*/
#define nk_foreach(c, ctx) for((c) = nk__begin(ctx); (c) != 0; (c) = nk__next(ctx,c))
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
	/*/// #### nk_convert
/// Converts all internal draw commands into vertex draw commands and fills
/// three buffers with vertexes, vertex draw commands and vertex indices. The vertex format
/// as well as some other configuration values have to be configured by filling out a
/// `nk_convert_config` struct.
///
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
/// nk_flags nk_convert(struct nk_context *ctx, struct nk_buffer *cmds,
//      struct nk_buffer *vertices, struct nk_buffer *elements, const struct nk_convert_config*);
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
///
/// Parameter   | Description
/// ------------|-----------------------------------------------------------
/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
/// __cmds__    | Must point to a previously initialized buffer to hold converted vertex draw commands
/// __vertices__| Must point to a previously initialized buffer to hold all produced vertices
/// __elements__| Must point to a previously initialized buffer to hold all produced vertex indices
/// __config__  | Must point to a filled out `nk_config` struct to configure the conversion process
///
/// Returns one of enum nk_convert_result error codes
///
/// Parameter                       | Description
/// --------------------------------|-----------------------------------------------------------
/// NK_CONVERT_SUCCESS              | Signals a successful draw command to vertex buffer conversion
/// NK_CONVERT_INVALID_PARAM        | An invalid argument was passed in the function call
/// NK_CONVERT_COMMAND_BUFFER_FULL  | The provided buffer for storing draw commands is full or failed to allocate more memory
/// NK_CONVERT_VERTEX_BUFFER_FULL   | The provided buffer for storing vertices is full or failed to allocate more memory
/// NK_CONVERT_ELEMENT_BUFFER_FULL  | The provided buffer for storing indicies is full or failed to allocate more memory
*/
	NK_API nk_flags nk_convert(struct nk_context*, struct nk_buffer* cmds, struct nk_buffer* vertices, struct nk_buffer* elements, const struct nk_convert_config*);
	/*/// #### nk__draw_begin
	/// Returns a draw vertex command buffer iterator to iterate each the vertex draw command buffer
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// const struct nk_draw_command* nk__draw_begin(const struct nk_context*, const struct nk_buffer*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	/// __buf__     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
	///
	/// Returns vertex draw command pointer pointing to the first command inside the vertex draw command buffer
	*/
	NK_API const struct nk_draw_command* nk__draw_begin(const struct nk_context*, const struct nk_buffer*);
	/*/// #### nk__draw_end
	/// Returns the vertex draw command at the end of the vertex draw command buffer
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// const struct nk_draw_command* nk__draw_end(const struct nk_context *ctx, const struct nk_buffer *buf);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	/// __buf__     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
	///
	/// Returns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer
	*/
	NK_API const struct nk_draw_command* nk__draw_end(const struct nk_context*, const struct nk_buffer*);
	/*/// #### nk__draw_next
	/// Increments the vertex draw command buffer iterator
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// const struct nk_draw_command* nk__draw_next(const struct nk_draw_command*, const struct nk_buffer*, const struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __cmd__     | Must point to an previously either by `nk__draw_begin` or `nk__draw_next` returned vertex draw command
	/// __buf__     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	///
	/// Returns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer
	*/
	NK_API const struct nk_draw_command* nk__draw_next(const struct nk_draw_command*, const struct nk_buffer*, const struct nk_context*);
	/*/// #### nk_draw_foreach
	/// Iterates over each vertex draw command inside a vertex draw command buffer
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_draw_foreach(cmd,ctx, b)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __cmd__     | `nk_draw_command`iterator set to NULL
	/// __buf__     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	*/
#define nk_draw_foreach(cmd,ctx, b) for((cmd)=nk__draw_begin(ctx, b); (cmd)!=0; (cmd)=nk__draw_next(cmd, b, ctx))
#endif
	/* =============================================================================
	 *
	 *                                  WINDOW
	 *
	 * =============================================================================
	/// ### Window
	/// Windows are the main persistent state used inside nuklear and are life time
	/// controlled by simply "retouching" (i.e. calling) each window each frame.
	/// All widgets inside nuklear can only be added inside function pair `nk_begin_xxx`
	/// and `nk_end`. Calling any widgets outside these two functions will result in an
	/// assert in debug or no state change in release mode.<br /><br />
	///
	/// Each window holds frame persistent state like position, size, flags, state tables,
	/// and some garbage collected internal persistent widget state. Each window
	/// is linked into a window stack list which determines the drawing and overlapping
	/// order. The topmost window thereby is the currently active window.<br /><br />
	///
	/// To change window position inside the stack occurs either automatically by
	/// user input by being clicked on or programmatically by calling `nk_window_focus`.
	/// Windows by default are visible unless explicitly being defined with flag
	/// `NK_WINDOW_HIDDEN`, the user clicked the close button on windows with flag
	/// `NK_WINDOW_CLOSABLE` or if a window was explicitly hidden by calling
	/// `nk_window_show`. To explicitly close and destroy a window call `nk_window_close`.<br /><br />
	///
	/// #### Usage
	/// To create and keep a window you have to call one of the two `nk_begin_xxx`
	/// functions to start window declarations and `nk_end` at the end. Furthermore it
	/// is recommended to check the return value of `nk_begin_xxx` and only process
	/// widgets inside the window if the value is not 0. Either way you have to call
	/// `nk_end` at the end of window declarations. Furthermore, do not attempt to
	/// nest `nk_begin_xxx` calls which will hopefully result in an assert or if not
	/// in a segmentation fault.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// if (nk_begin_xxx(...) {
	///     // [... widgets ...]
	/// }
	/// nk_end(ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// In the grand concept window and widget declarations need to occur after input
	/// handling and before drawing to screen. Not doing so can result in higher
	/// latency or at worst invalid behavior. Furthermore make sure that `nk_clear`
	/// is called at the end of the frame. While nuklear's default platform backends
	/// already call `nk_clear` for you if you write your own backend not calling
	/// `nk_clear` can cause asserts or even worse undefined behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_context ctx;
	/// nk_init_xxx(&ctx, ...);
	/// while (1) {
	///     Event evt;
	///     nk_input_begin(&ctx);
	///     while (GetEvent(&evt)) {
	///         if (evt.type == MOUSE_MOVE)
	///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	///         else if (evt.type == [...]) {
	///             nk_input_xxx(...);
	///         }
	///     }
	///     nk_input_end(&ctx);
	///
	///     if (nk_begin_xxx(...) {
	///         //[...]
	///     }
	///     nk_end(ctx);
	///
	///     const struct nk_command *cmd = 0;
	///     nk_foreach(cmd, &ctx) {
	///     case NK_COMMAND_LINE:
	///         your_draw_line_function(...)
	///         break;
	///     case NK_COMMAND_RECT
	///         your_draw_rect_function(...)
	///         break;
	///     case //...:
	///         //[...]
	///     }
	///     nk_clear(&ctx);
	/// }
	/// nk_free(&ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// #### Reference
	/// Function                            | Description
	/// ------------------------------------|----------------------------------------
	/// nk_begin                            | Starts a new window; needs to be called every frame for every window (unless hidden) or otherwise the window gets removed
	/// nk_begin_titled                     | Extended window start with separated title and identifier to allow multiple windows with same name but not title
	/// nk_end                              | Needs to be called at the end of the window building process to process scaling, scrollbars and general cleanup
	//
	/// nk_window_find                      | Finds and returns the window with give name
	/// nk_window_get_bounds                | Returns a rectangle with screen position and size of the currently processed window.
	/// nk_window_get_position              | Returns the position of the currently processed window
	/// nk_window_get_size                  | Returns the size with width and height of the currently processed window
	/// nk_window_get_width                 | Returns the width of the currently processed window
	/// nk_window_get_height                | Returns the height of the currently processed window
	/// nk_window_get_panel                 | Returns the underlying panel which contains all processing state of the current window
	/// nk_window_get_content_region        | Returns the position and size of the currently visible and non-clipped space inside the currently processed window
	/// nk_window_get_content_region_min    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window
	/// nk_window_get_content_region_max    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window
	/// nk_window_get_content_region_size   | Returns the size of the currently visible and non-clipped space inside the currently processed window
	/// nk_window_get_canvas                | Returns the draw command buffer. Can be used to draw custom widgets
	/// nk_window_has_focus                 | Returns if the currently processed window is currently active
	/// nk_window_is_collapsed              | Returns if the window with given name is currently minimized/collapsed
	/// nk_window_is_closed                 | Returns if the currently processed window was closed
	/// nk_window_is_hidden                 | Returns if the currently processed window was hidden
	/// nk_window_is_active                 | Same as nk_window_has_focus for some reason
	/// nk_window_is_hovered                | Returns if the currently processed window is currently being hovered by mouse
	/// nk_window_is_any_hovered            | Return if any window currently hovered
	/// nk_item_is_any_active               | Returns if any window or widgets is currently hovered or active
	//
	/// nk_window_set_bounds                | Updates position and size of the currently processed window
	/// nk_window_set_position              | Updates position of the currently process window
	/// nk_window_set_size                  | Updates the size of the currently processed window
	/// nk_window_set_focus                 | Set the currently processed window as active window
	//
	/// nk_window_close                     | Closes the window with given window name which deletes the window at the end of the frame
	/// nk_window_collapse                  | Collapses the window with given window name
	/// nk_window_collapse_if               | Collapses the window with given window name if the given condition was met
	/// nk_window_show                      | Hides a visible or reshows a hidden window
	/// nk_window_show_if                   | Hides/shows a window depending on condition
	*/
	/*
	/// #### nk_panel_flags
	/// Flag                        | Description
	/// ----------------------------|----------------------------------------
	/// NK_WINDOW_BORDER            | Draws a border around the window to visually separate window from the background
	/// NK_WINDOW_MOVABLE           | The movable flag indicates that a window can be moved by user input or by dragging the window header
	/// NK_WINDOW_SCALABLE          | The scalable flag indicates that a window can be scaled by user input by dragging a scaler icon at the button of the window
	/// NK_WINDOW_CLOSABLE          | Adds a closable icon into the header
	/// NK_WINDOW_MINIMIZABLE       | Adds a minimize icon into the header
	/// NK_WINDOW_NO_SCROLLBAR      | Removes the scrollbar from the window
	/// NK_WINDOW_TITLE             | Forces a header at the top at the window showing the title
	/// NK_WINDOW_SCROLL_AUTO_HIDE  | Automatically hides the window scrollbar if no user interaction: also requires delta time in `nk_context` to be set each frame
	/// NK_WINDOW_BACKGROUND        | Always keep window in the background
	/// NK_WINDOW_SCALE_LEFT        | Puts window scaler in the left-bottom corner instead right-bottom
	/// NK_WINDOW_NO_INPUT          | Prevents window of scaling, moving or getting focus
	///
	/// #### nk_collapse_states
	/// State           | Description
	/// ----------------|-----------------------------------------------------------
	/// __NK_MINIMIZED__| UI section is collased and not visibile until maximized
	/// __NK_MAXIMIZED__| UI section is extended and visibile until minimized
	/// <br /><br />
	*/
	enum nk_panel_flags {
		NK_WINDOW_BORDER = NK_FLAG(0),
		NK_WINDOW_MOVABLE = NK_FLAG(1),
		NK_WINDOW_SCALABLE = NK_FLAG(2),
		NK_WINDOW_CLOSABLE = NK_FLAG(3),
		NK_WINDOW_MINIMIZABLE = NK_FLAG(4),
		NK_WINDOW_NO_SCROLLBAR = NK_FLAG(5),
		NK_WINDOW_TITLE = NK_FLAG(6),
		NK_WINDOW_SCROLL_AUTO_HIDE = NK_FLAG(7),
		NK_WINDOW_BACKGROUND = NK_FLAG(8),
		NK_WINDOW_SCALE_LEFT = NK_FLAG(9),
		NK_WINDOW_NO_INPUT = NK_FLAG(10)
	};
	/*/// #### nk_begin
	/// Starts a new window; needs to be called every frame for every
	/// window (unless hidden) or otherwise the window gets removed
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_begin(struct nk_context *ctx, const char *title, struct nk_rect bounds, nk_flags flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __title__   | Window title and identifier. Needs to be persistent over frames to identify the window
	/// __bounds__  | Initial position and window size. However if you do not define `NK_WINDOW_SCALABLE` or `NK_WINDOW_MOVABLE` you can set window position and size every frame
	/// __flags__   | Window flags defined in the nk_panel_flags section with a number of different window behaviors
	///
	/// Returns `true(1)` if the window can be filled up with widgets from this point
	/// until `nk_end` or `false(0)` otherwise for example if minimized
	*/
	NK_API int nk_begin(struct nk_context* ctx, const char* title, struct nk_rect bounds, nk_flags flags);
	/*/// #### nk_begin_titled
	/// Extended window start with separated title and identifier to allow multiple
	/// windows with same name but not title
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_begin_titled(struct nk_context *ctx, const char *name, const char *title, struct nk_rect bounds, nk_flags flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Window identifier. Needs to be persistent over frames to identify the window
	/// __title__   | Window title displayed inside header if flag `NK_WINDOW_TITLE` or either `NK_WINDOW_CLOSABLE` or `NK_WINDOW_MINIMIZED` was set
	/// __bounds__  | Initial position and window size. However if you do not define `NK_WINDOW_SCALABLE` or `NK_WINDOW_MOVABLE` you can set window position and size every frame
	/// __flags__   | Window flags defined in the nk_panel_flags section with a number of different window behaviors
	///
	/// Returns `true(1)` if the window can be filled up with widgets from this point
	/// until `nk_end` or `false(0)` otherwise for example if minimized
	*/
	NK_API int
		nk_begin_titled(struct nk_context* ctx, const char* name, const char* title, struct nk_rect bounds, nk_flags flags);
	/*/// #### nk_end
	/// Needs to be called at the end of the window building process to process scaling, scrollbars and general cleanup.
	/// All widget calls after this functions will result in asserts or no state changes
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_end(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	*/
	NK_API void nk_end(struct nk_context* ctx);
	/*/// #### nk_window_find
	/// Finds and returns a window from passed name
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_end(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Window identifier
	///
	/// Returns a `nk_window` struct pointing to the identified window or NULL if
	/// no window with given name was found
	*/
	NK_API struct nk_window* nk_window_find(struct nk_context* ctx, const char* name);
	/*/// #### nk_window_get_bounds
	///
	/// Returns a rectangle with screen position and size of the currently processed window
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_window_get_bounds(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns a `nk_rect` struct with window upper left window position and size
	*/
	NK_API struct nk_rect nk_window_get_bounds(const struct nk_context* ctx);
	/*/// #### nk_window_get_bounds
	///
	/// Returns the position of the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_window_get_position(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns a `nk_vec2` struct with window upper left position
	*/
	NK_API struct nk_vec2 nk_window_get_position(const struct nk_context* ctx);
	/*/// #### nk_window_get_size
	///
	/// Returns the size with width and height of the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_window_get_size(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns a `nk_vec2` struct with window width and height
	*/
	NK_API struct nk_vec2 nk_window_get_size(const struct nk_context*);
	/*/// #### nk_window_get_width
	///
	/// Returns the width of the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// float nk_window_get_width(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns the current window width
	*/
	NK_API float nk_window_get_width(const struct nk_context*);
	/*/// #### nk_window_get_height
	///
	/// Returns the height of the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// float nk_window_get_height(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns the current window height
	*/
	NK_API float nk_window_get_height(const struct nk_context*);
	/*/// #### nk_window_get_panel
	///
	/// Returns the underlying panel which contains all processing state of the current window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// !!! WARNING
	///     Do not keep the returned panel pointer around it is only valid until `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_panel* nk_window_get_panel(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns a pointer to window internal `nk_panel` state.
	*/
	NK_API struct nk_panel* nk_window_get_panel(struct nk_context*);
	/*/// #### nk_window_get_content_region
	///
	/// Returns the position and size of the currently visible and non-clipped space
	/// inside the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_window_get_content_region(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `nk_rect` struct with screen position and size (no scrollbar offset)
	/// of the visible space inside the current window
	*/
	NK_API struct nk_rect nk_window_get_content_region(struct nk_context*);
	/*/// #### nk_window_get_content_region_min
	///
	/// Returns the upper left position of the currently visible and non-clipped
	/// space inside the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_window_get_content_region_min(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// returns `nk_vec2` struct with  upper left screen position (no scrollbar offset)
	/// of the visible space inside the current window
	*/
	NK_API struct nk_vec2 nk_window_get_content_region_min(struct nk_context*);
	/*/// #### nk_window_get_content_region_max
	///
	/// Returns the lower right screen position of the currently visible and
	/// non-clipped space inside the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_window_get_content_region_max(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `nk_vec2` struct with lower right screen position (no scrollbar offset)
	/// of the visible space inside the current window
	*/
	NK_API struct nk_vec2 nk_window_get_content_region_max(struct nk_context*);
	/*/// #### nk_window_get_content_region_size
	///
	/// Returns the size of the currently visible and non-clipped space inside the
	/// currently processed window
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_window_get_content_region_size(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `nk_vec2` struct with size the visible space inside the current window
	*/
	NK_API struct nk_vec2 nk_window_get_content_region_size(struct nk_context*);
	/*/// #### nk_window_get_canvas
	/// Returns the draw command buffer. Can be used to draw custom widgets
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// !!! WARNING
	///     Do not keep the returned command buffer pointer around it is only valid until `nk_end`
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_command_buffer* nk_window_get_canvas(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns a pointer to window internal `nk_command_buffer` struct used as
	/// drawing canvas. Can be used to do custom drawing.
	*/
	NK_API struct nk_command_buffer* nk_window_get_canvas(struct nk_context*);
	/*/// #### nk_window_has_focus
	/// Returns if the currently processed window is currently active
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_has_focus(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `false(0)` if current window is not active or `true(1)` if it is
	*/
	NK_API int nk_window_has_focus(const struct nk_context*);
	/*/// #### nk_window_is_hovered
	/// Return if the current window is being hovered
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_hovered(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `true(1)` if current window is hovered or `false(0)` otherwise
	*/
	NK_API int nk_window_is_hovered(struct nk_context*);
	/*/// #### nk_window_is_collapsed
	/// Returns if the window with given name is currently minimized/collapsed
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_collapsed(struct nk_context *ctx, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of window you want to check if it is collapsed
	///
	/// Returns `true(1)` if current window is minimized and `false(0)` if window not
	/// found or is not minimized
	*/
	NK_API int nk_window_is_collapsed(struct nk_context* ctx, const char* name);
	/*/// #### nk_window_is_closed
	/// Returns if the window with given name was closed by calling `nk_close`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_closed(struct nk_context *ctx, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of window you want to check if it is closed
	///
	/// Returns `true(1)` if current window was closed or `false(0)` window not found or not closed
	*/
	NK_API int nk_window_is_closed(struct nk_context*, const char*);
	/*/// #### nk_window_is_hidden
	/// Returns if the window with given name is hidden
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_hidden(struct nk_context *ctx, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of window you want to check if it is hidden
	///
	/// Returns `true(1)` if current window is hidden or `false(0)` window not found or visible
	*/
	NK_API int nk_window_is_hidden(struct nk_context*, const char*);
	/*/// #### nk_window_is_active
	/// Same as nk_window_has_focus for some reason
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_active(struct nk_context *ctx, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of window you want to check if it is active
	///
	/// Returns `true(1)` if current window is active or `false(0)` window not found or not active
	*/
	NK_API int nk_window_is_active(struct nk_context*, const char*);
	/*/// #### nk_window_is_any_hovered
	/// Returns if the any window is being hovered
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_any_hovered(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `true(1)` if any window is hovered or `false(0)` otherwise
	*/
	NK_API int nk_window_is_any_hovered(struct nk_context*);
	/*/// #### nk_item_is_any_active
	/// Returns if the any window is being hovered or any widget is currently active.
	/// Can be used to decide if input should be processed by UI or your specific input handling.
	/// Example could be UI and 3D camera to move inside a 3D space.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_item_is_any_active(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `true(1)` if any window is hovered or any item is active or `false(0)` otherwise
	*/
	NK_API int nk_item_is_any_active(struct nk_context*);
	/*/// #### nk_window_set_bounds
	/// Updates position and size of window with passed in name
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_set_bounds(struct nk_context*, const char *name, struct nk_rect bounds);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to modify both position and size
	/// __bounds__  | Must point to a `nk_rect` struct with the new position and size
	*/
	NK_API void nk_window_set_bounds(struct nk_context*, const char* name, struct nk_rect bounds);
	/*/// #### nk_window_set_position
	/// Updates position of window with passed name
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_set_position(struct nk_context*, const char *name, struct nk_vec2 pos);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to modify both position
	/// __pos__     | Must point to a `nk_vec2` struct with the new position
	*/
	NK_API void nk_window_set_position(struct nk_context*, const char* name, struct nk_vec2 pos);
	/*/// #### nk_window_set_size
	/// Updates size of window with passed in name
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_set_size(struct nk_context*, const char *name, struct nk_vec2);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to modify both window size
	/// __size__    | Must point to a `nk_vec2` struct with new window size
	*/
	NK_API void nk_window_set_size(struct nk_context*, const char* name, struct nk_vec2);
	/*/// #### nk_window_set_focus
	/// Sets the window with given name as active
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_set_focus(struct nk_context*, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to set focus on
	*/
	NK_API void nk_window_set_focus(struct nk_context*, const char* name);
	/*/// #### nk_window_close
	/// Closes a window and marks it for being freed at the end of the frame
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_close(struct nk_context *ctx, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to close
	*/
	NK_API void nk_window_close(struct nk_context* ctx, const char* name);
	/*/// #### nk_window_collapse
	/// Updates collapse state of a window with given name
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_collapse(struct nk_context*, const char *name, enum nk_collapse_states state);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to close
	/// __state__   | value out of nk_collapse_states section
	*/
	NK_API void nk_window_collapse(struct nk_context*, const char* name, enum nk_collapse_states state);
	/*/// #### nk_window_collapse_if
	/// Updates collapse state of a window with given name if given condition is met
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_collapse_if(struct nk_context*, const char *name, enum nk_collapse_states, int cond);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to either collapse or maximize
	/// __state__   | value out of nk_collapse_states section the window should be put into
	/// __cond__    | condition that has to be met to actually commit the collapse state change
	*/
	NK_API void nk_window_collapse_if(struct nk_context*, const char* name, enum nk_collapse_states, int cond);
	/*/// #### nk_window_show
	/// updates visibility state of a window with given name
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_show(struct nk_context*, const char *name, enum nk_show_states);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to either collapse or maximize
	/// __state__   | state with either visible or hidden to modify the window with
	*/
	NK_API void nk_window_show(struct nk_context*, const char* name, enum nk_show_states);
	/*/// #### nk_window_show_if
	/// Updates visibility state of a window with given name if a given condition is met
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_show_if(struct nk_context*, const char *name, enum nk_show_states, int cond);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to either hide or show
	/// __state__   | state with either visible or hidden to modify the window with
	/// __cond__    | condition that has to be met to actually commit the visbility state change
	*/
	NK_API void nk_window_show_if(struct nk_context*, const char* name, enum nk_show_states, int cond);
	/* =============================================================================
	 *
	 *                                  LAYOUT
	 *
	 * =============================================================================
	/// ### Layouting
	/// Layouting in general describes placing widget inside a window with position and size.
	/// While in this particular implementation there are five different APIs for layouting
	/// each with different trade offs between control and ease of use. <br /><br />
	///
	/// All layouting methods in this library are based around the concept of a row.
	/// A row has a height the window content grows by and a number of columns and each
	/// layouting method specifies how each widget is placed inside the row.
	/// After a row has been allocated by calling a layouting functions and then
	/// filled with widgets will advance an internal pointer over the allocated row. <br /><br />
	///
	/// To actually define a layout you just call the appropriate layouting function
	/// and each subsequent widget call will place the widget as specified. Important
	/// here is that if you define more widgets then columns defined inside the layout
	/// functions it will allocate the next row without you having to make another layouting <br /><br />
	/// call.
	///
	/// Biggest limitation with using all these APIs outside the `nk_layout_space_xxx` API
	/// is that you have to define the row height for each. However the row height
	/// often depends on the height of the font. <br /><br />
	///
	/// To fix that internally nuklear uses a minimum row height that is set to the
	/// height plus padding of currently active font and overwrites the row height
	/// value if zero. <br /><br />
	///
	/// If you manually want to change the minimum row height then
	/// use nk_layout_set_min_row_height, and use nk_layout_reset_min_row_height to
	/// reset it back to be derived from font height. <br /><br />
	///
	/// Also if you change the font in nuklear it will automatically change the minimum
	/// row height for you and. This means if you change the font but still want
	/// a minimum row height smaller than the font you have to repush your value. <br /><br />
	///
	/// For actually more advanced UI I would even recommend using the `nk_layout_space_xxx`
	/// layouting method in combination with a cassowary constraint solver (there are
	/// some versions on github with permissive license model) to take over all control over widget
	/// layouting yourself. However for quick and dirty layouting using all the other layouting
	/// functions should be fine.
	///
	/// #### Usage
	/// 1.  __nk_layout_row_dynamic__<br /><br />
	///     The easiest layouting function is `nk_layout_row_dynamic`. It provides each
	///     widgets with same horizontal space inside the row and dynamically grows
	///     if the owning window grows in width. So the number of columns dictates
	///     the size of each widget dynamically by formula:
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     widget_width = (window_width - padding - spacing) * (1/colum_count)
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	///     Just like all other layouting APIs if you define more widget than columns this
	///     library will allocate a new row and keep all layouting parameters previously
	///     defined.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // first row with height: 30 composed of two widgets
	///         nk_layout_row_dynamic(&ctx, 30, 2);
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // second row with same parameter as defined above
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // third row uses 0 for height which will use auto layouting
	///         nk_layout_row_dynamic(&ctx, 0, 2);
	///         nk_widget(...);
	///         nk_widget(...);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// 2.  __nk_layout_row_static__<br /><br />
	///     Another easy layouting function is `nk_layout_row_static`. It provides each
	///     widget with same horizontal pixel width inside the row and does not grow
	///     if the owning window scales smaller or bigger.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // first row with height: 30 composed of two widgets with width: 80
	///         nk_layout_row_static(&ctx, 30, 80, 2);
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // second row with same parameter as defined above
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // third row uses 0 for height which will use auto layouting
	///         nk_layout_row_static(&ctx, 0, 80, 2);
	///         nk_widget(...);
	///         nk_widget(...);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// 3.  __nk_layout_row_xxx__<br /><br />
	///     A little bit more advanced layouting API are functions `nk_layout_row_begin`,
	///     `nk_layout_row_push` and `nk_layout_row_end`. They allow to directly
	///     specify each column pixel or window ratio in a row. It supports either
	///     directly setting per column pixel width or widget window ratio but not
	///     both. Furthermore it is a immediate mode API so each value is directly
	///     pushed before calling a widget. Therefore the layout is not automatically
	///     repeating like the last two layouting functions.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // first row with height: 25 composed of two widgets with width 60 and 40
	///         nk_layout_row_begin(ctx, NK_STATIC, 25, 2);
	///         nk_layout_row_push(ctx, 60);
	///         nk_widget(...);
	///         nk_layout_row_push(ctx, 40);
	///         nk_widget(...);
	///         nk_layout_row_end(ctx);
	///         //
	///         // second row with height: 25 composed of two widgets with window ratio 0.25 and 0.75
	///         nk_layout_row_begin(ctx, NK_DYNAMIC, 25, 2);
	///         nk_layout_row_push(ctx, 0.25f);
	///         nk_widget(...);
	///         nk_layout_row_push(ctx, 0.75f);
	///         nk_widget(...);
	///         nk_layout_row_end(ctx);
	///         //
	///         // third row with auto generated height: composed of two widgets with window ratio 0.25 and 0.75
	///         nk_layout_row_begin(ctx, NK_DYNAMIC, 0, 2);
	///         nk_layout_row_push(ctx, 0.25f);
	///         nk_widget(...);
	///         nk_layout_row_push(ctx, 0.75f);
	///         nk_widget(...);
	///         nk_layout_row_end(ctx);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// 4.  __nk_layout_row__<br /><br />
	///     The array counterpart to API nk_layout_row_xxx is the single nk_layout_row
	///     functions. Instead of pushing either pixel or window ratio for every widget
	///     it allows to define it by array. The trade of for less control is that
	///     `nk_layout_row` is automatically repeating. Otherwise the behavior is the
	///     same.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // two rows with height: 30 composed of two widgets with width 60 and 40
	///         const float size[] = {60,40};
	///         nk_layout_row(ctx, NK_STATIC, 30, 2, ratio);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // two rows with height: 30 composed of two widgets with window ratio 0.25 and 0.75
	///         const float ratio[] = {0.25, 0.75};
	///         nk_layout_row(ctx, NK_DYNAMIC, 30, 2, ratio);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // two rows with auto generated height composed of two widgets with window ratio 0.25 and 0.75
	///         const float ratio[] = {0.25, 0.75};
	///         nk_layout_row(ctx, NK_DYNAMIC, 30, 2, ratio);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// 5.  __nk_layout_row_template_xxx__<br /><br />
	///     The most complex and second most flexible API is a simplified flexbox version without
	///     line wrapping and weights for dynamic widgets. It is an immediate mode API but
	///     unlike `nk_layout_row_xxx` it has auto repeat behavior and needs to be called
	///     before calling the templated widgets.
	///     The row template layout has three different per widget size specifier. The first
	///     one is the `nk_layout_row_template_push_static`  with fixed widget pixel width.
	///     They do not grow if the row grows and will always stay the same.
	///     The second size specifier is `nk_layout_row_template_push_variable`
	///     which defines a minimum widget size but it also can grow if more space is available
	///     not taken by other widgets.
	///     Finally there are dynamic widgets with `nk_layout_row_template_push_dynamic`
	///     which are completely flexible and unlike variable widgets can even shrink
	///     to zero if not enough space is provided.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // two rows with height: 30 composed of three widgets
	///         nk_layout_row_template_begin(ctx, 30);
	///         nk_layout_row_template_push_dynamic(ctx);
	///         nk_layout_row_template_push_variable(ctx, 80);
	///         nk_layout_row_template_push_static(ctx, 80);
	///         nk_layout_row_template_end(ctx);
	///         //
	///         // first row
	///         nk_widget(...); // dynamic widget can go to zero if not enough space
	///         nk_widget(...); // variable widget with min 80 pixel but can grow bigger if enough space
	///         nk_widget(...); // static widget with fixed 80 pixel width
	///         //
	///         // second row same layout
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// 6.  __nk_layout_space_xxx__<br /><br />
	///     Finally the most flexible API directly allows you to place widgets inside the
	///     window. The space layout API is an immediate mode API which does not support
	///     row auto repeat and directly sets position and size of a widget. Position
	///     and size hereby can be either specified as ratio of allocated space or
	///     allocated space local position and pixel size. Since this API is quite
	///     powerful there are a number of utility functions to get the available space
	///     and convert between local allocated space and screen space.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // static row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)
	///         nk_layout_space_begin(ctx, NK_STATIC, 500, INT_MAX);
	///         nk_layout_space_push(ctx, nk_rect(0,0,150,200));
	///         nk_widget(...);
	///         nk_layout_space_push(ctx, nk_rect(200,200,100,200));
	///         nk_widget(...);
	///         nk_layout_space_end(ctx);
	///         //
	///         // dynamic row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)
	///         nk_layout_space_begin(ctx, NK_DYNAMIC, 500, INT_MAX);
	///         nk_layout_space_push(ctx, nk_rect(0.5,0.5,0.1,0.1));
	///         nk_widget(...);
	///         nk_layout_space_push(ctx, nk_rect(0.7,0.6,0.1,0.1));
	///         nk_widget(...);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// #### Reference
	/// Function                                | Description
	/// ----------------------------------------|------------------------------------
	/// nk_layout_set_min_row_height            | Set the currently used minimum row height to a specified value
	/// nk_layout_reset_min_row_height          | Resets the currently used minimum row height to font height
	/// nk_layout_widget_bounds                 | Calculates current width a static layout row can fit inside a window
	/// nk_layout_ratio_from_pixel              | Utility functions to calculate window ratio from pixel size
	//
	/// nk_layout_row_dynamic                   | Current layout is divided into n same sized growing columns
	/// nk_layout_row_static                    | Current layout is divided into n same fixed sized columns
	/// nk_layout_row_begin                     | Starts a new row with given height and number of columns
	/// nk_layout_row_push                      | Pushes another column with given size or window ratio
	/// nk_layout_row_end                       | Finished previously started row
	/// nk_layout_row                           | Specifies row columns in array as either window ratio or size
	//
	/// nk_layout_row_template_begin            | Begins the row template declaration
	/// nk_layout_row_template_push_dynamic     | Adds a dynamic column that dynamically grows and can go to zero if not enough space
	/// nk_layout_row_template_push_variable    | Adds a variable column that dynamically grows but does not shrink below specified pixel width
	/// nk_layout_row_template_push_static      | Adds a static column that does not grow and will always have the same size
	/// nk_layout_row_template_end              | Marks the end of the row template
	//
	/// nk_layout_space_begin                   | Begins a new layouting space that allows to specify each widgets position and size
	/// nk_layout_space_push                    | Pushes position and size of the next widget in own coordinate space either as pixel or ratio
	/// nk_layout_space_end                     | Marks the end of the layouting space
	//
	/// nk_layout_space_bounds                  | Callable after nk_layout_space_begin and returns total space allocated
	/// nk_layout_space_to_screen               | Converts vector from nk_layout_space coordinate space into screen space
	/// nk_layout_space_to_local                | Converts vector from screen space into nk_layout_space coordinates
	/// nk_layout_space_rect_to_screen          | Converts rectangle from nk_layout_space coordinate space into screen space
	/// nk_layout_space_rect_to_local           | Converts rectangle from screen space into nk_layout_space coordinates
	*/
	/*/// #### nk_layout_set_min_row_height
	/// Sets the currently used minimum row height.
	/// !!! WARNING
	///     The passed height needs to include both your preferred row height
	///     as well as padding. No internal padding is added.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_set_min_row_height(struct nk_context*, float height);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __height__  | New minimum row height to be used for auto generating the row height
	*/
	NK_API void nk_layout_set_min_row_height(struct nk_context*, float height);
	/*/// #### nk_layout_reset_min_row_height
	/// Reset the currently used minimum row height back to `font_height + text_padding + padding`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_reset_min_row_height(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	*/
	NK_API void nk_layout_reset_min_row_height(struct nk_context*);
	/*/// #### nk_layout_widget_bounds
	/// Returns the width of the next row allocate by one of the layouting functions
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_layout_widget_bounds(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	///
	/// Return `nk_rect` with both position and size of the next row
	*/
	NK_API struct nk_rect nk_layout_widget_bounds(struct nk_context*);
	/*/// #### nk_layout_ratio_from_pixel
	/// Utility functions to calculate window ratio from pixel size
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// float nk_layout_ratio_from_pixel(struct nk_context*, float pixel_width);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __pixel__   | Pixel_width to convert to window ratio
	///
	/// Returns `nk_rect` with both position and size of the next row
	*/
	NK_API float nk_layout_ratio_from_pixel(struct nk_context*, float pixel_width);
	/*/// #### nk_layout_row_dynamic
	/// Sets current row layout to share horizontal space
	/// between @cols number of widgets evenly. Once called all subsequent widget
	/// calls greater than @cols will allocate a new row with same layout.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_dynamic(struct nk_context *ctx, float height, int cols);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	/// __columns__ | Number of widget inside row
	*/
	NK_API void nk_layout_row_dynamic(struct nk_context* ctx, float height, int cols);
	/*/// #### nk_layout_row_dynamic
	/// Sets current row layout to fill @cols number of widgets
	/// in row with same @item_width horizontal size. Once called all subsequent widget
	/// calls greater than @cols will allocate a new row with same layout.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_static(struct nk_context *ctx, float height, int item_width, int cols);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	/// __width__   | Holds pixel width of each widget in the row
	/// __columns__ | Number of widget inside row
	*/
	NK_API void nk_layout_row_static(struct nk_context* ctx, float height, int item_width, int cols);
	/*/// #### nk_layout_row_begin
	/// Starts a new dynamic or fixed row with given height and columns.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_begin(struct nk_context *ctx, enum nk_layout_format fmt, float row_height, int cols);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __fmt__     | either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns
	/// __height__  | holds height of each widget in row or zero for auto layouting
	/// __columns__ | Number of widget inside row
	*/
	NK_API void nk_layout_row_begin(struct nk_context* ctx, enum nk_layout_format fmt, float row_height, int cols);
	/*/// #### nk_layout_row_push
	/// Specifies either window ratio or width of a single column
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_push(struct nk_context*, float value);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __value__   | either a window ratio or fixed width depending on @fmt in previous `nk_layout_row_begin` call
	*/
	NK_API void nk_layout_row_push(struct nk_context*, float value);
	/*/// #### nk_layout_row_end
	/// Finished previously started row
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_end(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	*/
	NK_API void nk_layout_row_end(struct nk_context*);
	/*/// #### nk_layout_row
	/// Specifies row columns in array as either window ratio or size
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row(struct nk_context*, enum nk_layout_format, float height, int cols, const float *ratio);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __fmt__     | Either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	/// __columns__ | Number of widget inside row
	*/
	NK_API void nk_layout_row(struct nk_context*, enum nk_layout_format, float height, int cols, const float* ratio);
	/*/// #### nk_layout_row_template_begin
	/// Begins the row template declaration
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_template_begin(struct nk_context*, float row_height);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	*/
	NK_API void nk_layout_row_template_begin(struct nk_context*, float row_height);
	/*/// #### nk_layout_row_template_push_dynamic
	/// Adds a dynamic column that dynamically grows and can go to zero if not enough space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_template_push_dynamic(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	*/
	NK_API void nk_layout_row_template_push_dynamic(struct nk_context*);
	/*/// #### nk_layout_row_template_push_variable
	/// Adds a variable column that dynamically grows but does not shrink below specified pixel width
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_template_push_variable(struct nk_context*, float min_width);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __width__   | Holds the minimum pixel width the next column must always be
	*/
	NK_API void nk_layout_row_template_push_variable(struct nk_context*, float min_width);
	/*/// #### nk_layout_row_template_push_static
	/// Adds a static column that does not grow and will always have the same size
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_template_push_static(struct nk_context*, float width);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __width__   | Holds the absolute pixel width value the next column must be
	*/
	NK_API void nk_layout_row_template_push_static(struct nk_context*, float width);
	/*/// #### nk_layout_row_template_end
	/// Marks the end of the row template
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_template_end(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	*/
	NK_API void nk_layout_row_template_end(struct nk_context*);
	/*/// #### nk_layout_space_begin
	/// Begins a new layouting space that allows to specify each widgets position and size.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_space_begin(struct nk_context*, enum nk_layout_format, float height, int widget_count);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __fmt__     | Either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	/// __columns__ | Number of widgets inside row
	*/
	NK_API void nk_layout_space_begin(struct nk_context*, enum nk_layout_format, float height, int widget_count);
	/*/// #### nk_layout_space_push
	/// Pushes position and size of the next widget in own coordinate space either as pixel or ratio
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_space_push(struct nk_context *ctx, struct nk_rect bounds);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	/// __bounds__  | Position and size in laoyut space local coordinates
	*/
	NK_API void nk_layout_space_push(struct nk_context*, struct nk_rect bounds);
	/*/// #### nk_layout_space_end
	/// Marks the end of the layout space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_space_end(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	*/
	NK_API void nk_layout_space_end(struct nk_context*);
	/*/// #### nk_layout_space_bounds
	/// Utility function to calculate total space allocated for `nk_layout_space`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_layout_space_bounds(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	///
	/// Returns `nk_rect` holding the total space allocated
	*/
	NK_API struct nk_rect nk_layout_space_bounds(struct nk_context*);
	/*/// #### nk_layout_space_to_screen
	/// Converts vector from nk_layout_space coordinate space into screen space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_layout_space_to_screen(struct nk_context*, struct nk_vec2);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	/// __vec__     | Position to convert from layout space into screen coordinate space
	///
	/// Returns transformed `nk_vec2` in screen space coordinates
	*/
	NK_API struct nk_vec2 nk_layout_space_to_screen(struct nk_context*, struct nk_vec2);
	/*/// #### nk_layout_space_to_screen
	/// Converts vector from layout space into screen space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_layout_space_to_local(struct nk_context*, struct nk_vec2);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	/// __vec__     | Position to convert from screen space into layout coordinate space
	///
	/// Returns transformed `nk_vec2` in layout space coordinates
	*/
	NK_API struct nk_vec2 nk_layout_space_to_local(struct nk_context*, struct nk_vec2);
	/*/// #### nk_layout_space_rect_to_screen
	/// Converts rectangle from screen space into layout space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_layout_space_rect_to_screen(struct nk_context*, struct nk_rect);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	/// __bounds__  | Rectangle to convert from layout space into screen space
	///
	/// Returns transformed `nk_rect` in screen space coordinates
	*/
	NK_API struct nk_rect nk_layout_space_rect_to_screen(struct nk_context*, struct nk_rect);
	/*/// #### nk_layout_space_rect_to_local
	/// Converts rectangle from layout space into screen space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_layout_space_rect_to_local(struct nk_context*, struct nk_rect);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	/// __bounds__  | Rectangle to convert from layout space into screen space
	///
	/// Returns transformed `nk_rect` in layout space coordinates
	*/
	NK_API struct nk_rect nk_layout_space_rect_to_local(struct nk_context*, struct nk_rect);
	/* =============================================================================
	 *
	 *                                  GROUP
	 *
	 * =============================================================================
	/// ### Groups
	/// Groups are basically windows inside windows. They allow to subdivide space
	/// in a window to layout widgets as a group. Almost all more complex widget
	/// layouting requirements can be solved using groups and basic layouting
	/// fuctionality. Groups just like windows are identified by an unique name and
	/// internally keep track of scrollbar offsets by default. However additional
	/// versions are provided to directly manage the scrollbar.
	///
	/// #### Usage
	/// To create a group you have to call one of the three `nk_group_begin_xxx`
	/// functions to start group declarations and `nk_group_end` at the end. Furthermore it
	/// is required to check the return value of `nk_group_begin_xxx` and only process
	/// widgets inside the window if the value is not 0.
	/// Nesting groups is possible and even encouraged since many layouting schemes
	/// can only be achieved by nesting. Groups, unlike windows, need `nk_group_end`
	/// to be only called if the corosponding `nk_group_begin_xxx` call does not return 0:
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// if (nk_group_begin_xxx(ctx, ...) {
	///     // [... widgets ...]
	///     nk_group_end(ctx);
	/// }
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// In the grand concept groups can be called after starting a window
	/// with `nk_begin_xxx` and before calling `nk_end`:
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_context ctx;
	/// nk_init_xxx(&ctx, ...);
	/// while (1) {
	///     // Input
	///     Event evt;
	///     nk_input_begin(&ctx);
	///     while (GetEvent(&evt)) {
	///         if (evt.type == MOUSE_MOVE)
	///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	///         else if (evt.type == [...]) {
	///             nk_input_xxx(...);
	///         }
	///     }
	///     nk_input_end(&ctx);
	///     //
	///     // Window
	///     if (nk_begin_xxx(...) {
	///         // [...widgets...]
	///         nk_layout_row_dynamic(...);
	///         if (nk_group_begin_xxx(ctx, ...) {
	///             //[... widgets ...]
	///             nk_group_end(ctx);
	///         }
	///     }
	///     nk_end(ctx);
	///     //
	///     // Draw
	///     const struct nk_command *cmd = 0;
	///     nk_foreach(cmd, &ctx) {
	///     switch (cmd->type) {
	///     case NK_COMMAND_LINE:
	///         your_draw_line_function(...)
	///         break;
	///     case NK_COMMAND_RECT
	///         your_draw_rect_function(...)
	///         break;
	///     case ...:
	///         // [...]
	///     }
	//      nk_clear(&ctx);
	/// }
	/// nk_free(&ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	/// #### Reference
	/// Function                        | Description
	/// --------------------------------|-------------------------------------------
	/// nk_group_begin                  | Start a new group with internal scrollbar handling
	/// nk_group_begin_titled           | Start a new group with separeted name and title and internal scrollbar handling
	/// nk_group_end                    | Ends a group. Should only be called if nk_group_begin returned non-zero
	/// nk_group_scrolled_offset_begin  | Start a new group with manual separated handling of scrollbar x- and y-offset
	/// nk_group_scrolled_begin         | Start a new group with manual scrollbar handling
	/// nk_group_scrolled_end           | Ends a group with manual scrollbar handling. Should only be called if nk_group_begin returned non-zero
	*/
	/*/// #### nk_group_begin
	/// Starts a new widget group. Requires a previous layouting function to specify a pos/size.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_group_begin(struct nk_context*, const char *title, nk_flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __title__   | Must be an unique identifier for this group that is also used for the group header
	/// __flags__   | Window flags defined in the nk_panel_flags section with a number of different group behaviors
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_group_begin(struct nk_context*, const char* title, nk_flags);
	/*/// #### nk_group_begin_titled
	/// Starts a new widget group. Requires a previous layouting function to specify a pos/size.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_group_begin_titled(struct nk_context*, const char *name, const char *title, nk_flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __id__      | Must be an unique identifier for this group
	/// __title__   | Group header title
	/// __flags__   | Window flags defined in the nk_panel_flags section with a number of different group behaviors
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_group_begin_titled(struct nk_context*, const char* name, const char* title, nk_flags);
	/*/// #### nk_group_end
	/// Ends a widget group
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_group_end(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	*/
	NK_API void nk_group_end(struct nk_context*);
	/*/// #### nk_group_scrolled_offset_begin
	/// starts a new widget group. requires a previous layouting function to specify
	/// a size. Does not keep track of scrollbar.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_group_scrolled_offset_begin(struct nk_context*, nk_uint *x_offset, nk_uint *y_offset, const char *title, nk_flags flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __x_offset__| Scrollbar x-offset to offset all widgets inside the group horizontally.
	/// __y_offset__| Scrollbar y-offset to offset all widgets inside the group vertically
	/// __title__   | Window unique group title used to both identify and display in the group header
	/// __flags__   | Window flags from the nk_panel_flags section
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_group_scrolled_offset_begin(struct nk_context*, nk_uint* x_offset, nk_uint* y_offset, const char* title,
		nk_flags flags);
	/*/// #### nk_group_scrolled_begin
	/// Starts a new widget group. requires a previous
	/// layouting function to specify a size. Does not keep track of scrollbar.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_group_scrolled_begin(struct nk_context*, struct nk_scroll *off, const char *title, nk_flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __off__     | Both x- and y- scroll offset. Allows for manual scrollbar control
	/// __title__   | Window unique group title used to both identify and display in the group header
	/// __flags__   | Window flags from nk_panel_flags section
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_group_scrolled_begin(struct nk_context*, struct nk_scroll* off, const char* title, nk_flags);
	/*/// #### nk_group_scrolled_end
	/// Ends a widget group after calling nk_group_scrolled_offset_begin or nk_group_scrolled_begin.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_group_scrolled_end(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	*/
	NK_API void nk_group_scrolled_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  TREE
	 *
	 * =============================================================================
	/// ### Tree
	/// Trees represent two different concept. First the concept of a collapsable
	/// UI section that can be either in a hidden or visibile state. They allow the UI
	/// user to selectively minimize the current set of visible UI to comprehend.
	/// The second concept are tree widgets for visual UI representation of trees.<br /><br />
	///
	/// Trees thereby can be nested for tree representations and multiple nested
	/// collapsable UI sections. All trees are started by calling of the
	/// `nk_tree_xxx_push_tree` functions and ended by calling one of the
	/// `nk_tree_xxx_pop_xxx()` functions. Each starting functions takes a title label
	/// and optionally an image to be displayed and the initial collapse state from
	/// the nk_collapse_states section.<br /><br />
	///
	/// The runtime state of the tree is either stored outside the library by the caller
	/// or inside which requires a unique ID. The unique ID can either be generated
	/// automatically from `__FILE__` and `__LINE__` with function `nk_tree_push`,
	/// by `__FILE__` and a user provided ID generated for example by loop index with
	/// function `nk_tree_push_id` or completely provided from outside by user with
	/// function `nk_tree_push_hashed`.
	///
	/// #### Usage
	/// To create a tree you have to call one of the seven `nk_tree_xxx_push_xxx`
	/// functions to start a collapsable UI section and `nk_tree_xxx_pop` to mark the
	/// end.
	/// Each starting function will either return `false(0)` if the tree is collapsed
	/// or hidden and therefore does not need to be filled with content or `true(1)`
	/// if visible and required to be filled.
	///
	/// !!! Note
	///     The tree header does not require and layouting function and instead
	///     calculates a auto height based on the currently used font size
	///
	/// The tree ending functions only need to be called if the tree content is
	/// actually visible. So make sure the tree push function is guarded by `if`
	/// and the pop call is only taken if the tree is visible.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// if (nk_tree_push(ctx, NK_TREE_TAB, "Tree", NK_MINIMIZED)) {
	///     nk_layout_row_dynamic(...);
	///     nk_widget(...);
	///     nk_tree_pop(ctx);
	/// }
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// #### Reference
	/// Function                    | Description
	/// ----------------------------|-------------------------------------------
	/// nk_tree_push                | Start a collapsable UI section with internal state management
	/// nk_tree_push_id             | Start a collapsable UI section with internal state management callable in a look
	/// nk_tree_push_hashed         | Start a collapsable UI section with internal state management with full control over internal unique ID use to store state
	/// nk_tree_image_push          | Start a collapsable UI section with image and label header
	/// nk_tree_image_push_id       | Start a collapsable UI section with image and label header and internal state management callable in a look
	/// nk_tree_image_push_hashed   | Start a collapsable UI section with image and label header and internal state management with full control over internal unique ID use to store state
	/// nk_tree_pop                 | Ends a collapsable UI section
	//
	/// nk_tree_state_push          | Start a collapsable UI section with external state management
	/// nk_tree_state_image_push    | Start a collapsable UI section with image and label header and external state management
	/// nk_tree_state_pop           | Ends a collapsabale UI section
	///
	/// #### nk_tree_type
	/// Flag            | Description
	/// ----------------|----------------------------------------
	/// NK_TREE_NODE    | Highlighted tree header to mark a collapsable UI section
	/// NK_TREE_TAB     | Non-highighted tree header closer to tree representations
	*/
	/*/// #### nk_tree_push
	/// Starts a collapsable UI section with internal state management
	/// !!! WARNING
	///     To keep track of the runtime tree collapsable state this function uses
	///     defines `__FILE__` and `__LINE__` to generate a unique ID. If you want
	///     to call this function in a loop please use `nk_tree_push_id` or
	///     `nk_tree_push_hashed` instead.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_tree_push(ctx, type, title, state)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
#define nk_tree_push(ctx, type, title, state) nk_tree_push_hashed(ctx, type, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),__LINE__)
	/*/// #### nk_tree_push_id
	/// Starts a collapsable UI section with internal state management callable in a look
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_tree_push_id(ctx, type, title, state, id)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	/// __id__      | Loop counter index if this function is called in a loop
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
#define nk_tree_push_id(ctx, type, title, state, id) nk_tree_push_hashed(ctx, type, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),id)
	/*/// #### nk_tree_push_hashed
	/// Start a collapsable UI section with internal state management with full
	/// control over internal unique ID used to store state
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_tree_push_hashed(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	/// __hash__    | Memory block or string to generate the ID from
	/// __len__     | Size of passed memory block or string in __hash__
	/// __seed__    | Seeding value if this function is called in a loop or default to `0`
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int
		nk_tree_push_hashed(struct nk_context*, enum nk_tree_type, const char* title, enum nk_collapse_states initial_state,
			const char* hash, int len, int seed);
	/*/// #### nk_tree_image_push
	/// Start a collapsable UI section with image and label header
	/// !!! WARNING
	///     To keep track of the runtime tree collapsable state this function uses
	///     defines `__FILE__` and `__LINE__` to generate a unique ID. If you want
	///     to call this function in a loop please use `nk_tree_image_push_id` or
	///     `nk_tree_image_push_hashed` instead.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_tree_image_push(ctx, type, img, title, state)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __img__     | Image to display inside the header on the left of the label
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
#define nk_tree_image_push(ctx, type, img, title, state) nk_tree_image_push_hashed(ctx, type, img, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),__LINE__)
	/*/// #### nk_tree_image_push_id
	/// Start a collapsable UI section with image and label header and internal state
	/// management callable in a look
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_tree_image_push_id(ctx, type, img, title, state, id)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __img__     | Image to display inside the header on the left of the label
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	/// __id__      | Loop counter index if this function is called in a loop
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
#define nk_tree_image_push_id(ctx, type, img, title, state, id) nk_tree_image_push_hashed(ctx, type, img, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),id)
	/*/// #### nk_tree_image_push_hashed
	/// Start a collapsable UI section with internal state management with full
	/// control over internal unique ID used to store state
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_tree_image_push_hashed(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __img__     | Image to display inside the header on the left of the label
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	/// __hash__    | Memory block or string to generate the ID from
	/// __len__     | Size of passed memory block or string in __hash__
	/// __seed__    | Seeding value if this function is called in a loop or default to `0`
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_tree_image_push_hashed(struct nk_context*, enum nk_tree_type, struct nk_image, const char* title,
		enum nk_collapse_states initial_state, const char* hash, int len, int seed);
	/*/// #### nk_tree_pop
	/// Ends a collapsabale UI section
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_tree_pop(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
	*/
	NK_API void nk_tree_pop(struct nk_context*);
	/*/// #### nk_tree_state_push
	/// Start a collapsable UI section with external state management
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_tree_state_push(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states *state);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __title__   | Label printed in the tree header
	/// __state__   | Persistent state to update
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int
		nk_tree_state_push(struct nk_context*, enum nk_tree_type, const char* title, enum nk_collapse_states* state);
	/*/// #### nk_tree_state_image_push
	/// Start a collapsable UI section with image and label header and external state management
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_tree_state_image_push(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states *state);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
	/// __img__     | Image to display inside the header on the left of the label
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __title__   | Label printed in the tree header
	/// __state__   | Persistent state to update
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_tree_state_image_push(struct nk_context*, enum nk_tree_type, struct nk_image, const char* title,
		enum nk_collapse_states* state);
	/*/// #### nk_tree_state_pop
	/// Ends a collapsabale UI section
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_tree_state_pop(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
	*/
	NK_API void nk_tree_state_pop(struct nk_context*);

#define nk_tree_element_push(ctx, type, title, state, sel) nk_tree_element_push_hashed(ctx, type, title, state, sel, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),__LINE__)
#define nk_tree_element_push_id(ctx, type, title, state, sel, id) nk_tree_element_push_hashed(ctx, type, title, state, sel, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),id)

	NK_API int nk_tree_element_push_hashed(struct nk_context*, enum nk_tree_type, const char* title,
		enum nk_collapse_states initial_state, int* selected, const char* hash, int len,
		int seed);

	NK_API int nk_tree_element_image_push_hashed(struct nk_context*, enum nk_tree_type, struct nk_image, const char* title,
		enum nk_collapse_states initial_state, int* selected, const char* hash,
		int len, int seed);

	NK_API void nk_tree_element_pop(struct nk_context*);

	/* =============================================================================
	 *
	 *                                  LIST VIEW
	 *
	 * ============================================================================= */
	struct nk_list_view {
		/* public: */
		int begin, end, count;
		/* private: */
		int total_height;
		struct nk_context* ctx;
		nk_uint* scroll_pointer;
		nk_uint scroll_value;
	};

	NK_API int nk_list_view_begin(struct nk_context*, struct nk_list_view* out, const char* id, nk_flags, int row_height,
		int row_count);

	NK_API void nk_list_view_end(struct nk_list_view*);

	/* =============================================================================
	 *
	 *                                  WIDGET
	 *
	 * ============================================================================= */
	enum nk_widget_layout_states {
		NK_WIDGET_INVALID, /* The widget cannot be seen and is completely out of view */
		NK_WIDGET_VALID, /* The widget is completely inside the window and can be updated and drawn */
		NK_WIDGET_ROM /* The widget is partially visible and cannot be updated */
	};
	enum nk_widget_states {
		NK_WIDGET_STATE_MODIFIED = NK_FLAG(1),
		NK_WIDGET_STATE_INACTIVE = NK_FLAG(2), /* widget is neither active nor hovered */
		NK_WIDGET_STATE_ENTERED = NK_FLAG(3), /* widget has been hovered on the current frame */
		NK_WIDGET_STATE_HOVER = NK_FLAG(4), /* widget is being hovered */
		NK_WIDGET_STATE_ACTIVED = NK_FLAG(5),/* widget is currently activated */
		NK_WIDGET_STATE_LEFT = NK_FLAG(6), /* widget is from this frame on not hovered anymore */
		NK_WIDGET_STATE_HOVERED = NK_WIDGET_STATE_HOVER | NK_WIDGET_STATE_MODIFIED, /* widget is being hovered */
		NK_WIDGET_STATE_ACTIVE = NK_WIDGET_STATE_ACTIVED | NK_WIDGET_STATE_MODIFIED /* widget is currently activated */
	};

	NK_API enum nk_widget_layout_states nk_widget(struct nk_rect*, const struct nk_context*);

	NK_API enum nk_widget_layout_states nk_widget_fitting(struct nk_rect*, struct nk_context*, struct nk_vec2);

	NK_API struct nk_rect nk_widget_bounds(struct nk_context*);

	NK_API struct nk_vec2 nk_widget_position(struct nk_context*);

	NK_API struct nk_vec2 nk_widget_size(struct nk_context*);

	NK_API float nk_widget_width(struct nk_context*);

	NK_API float nk_widget_height(struct nk_context*);

	NK_API int nk_widget_is_hovered(struct nk_context*);

	NK_API int nk_widget_is_mouse_clicked(struct nk_context*, enum nk_buttons);

	NK_API int nk_widget_has_mouse_click_down(struct nk_context*, enum nk_buttons, int down);

	NK_API void nk_spacing(struct nk_context*, int cols);

	/* =============================================================================
	 *
	 *                                  TEXT
	 *
	 * ============================================================================= */
	enum nk_text_align {
		NK_TEXT_ALIGN_LEFT = 0x01,
		NK_TEXT_ALIGN_CENTERED = 0x02,
		NK_TEXT_ALIGN_RIGHT = 0x04,
		NK_TEXT_ALIGN_TOP = 0x08,
		NK_TEXT_ALIGN_MIDDLE = 0x10,
		NK_TEXT_ALIGN_BOTTOM = 0x20
	};
	enum nk_text_alignment {
		NK_TEXT_LEFT = NK_TEXT_ALIGN_MIDDLE | NK_TEXT_ALIGN_LEFT,
		NK_TEXT_CENTERED = NK_TEXT_ALIGN_MIDDLE | NK_TEXT_ALIGN_CENTERED,
		NK_TEXT_RIGHT = NK_TEXT_ALIGN_MIDDLE | NK_TEXT_ALIGN_RIGHT
	};

	NK_API void nk_text(struct nk_context*, const char*, int, nk_flags);

	NK_API void nk_text_colored(struct nk_context*, const char*, int, nk_flags, struct nk_color);

	NK_API void nk_text_wrap(struct nk_context*, const char*, int);

	NK_API void nk_text_wrap_colored(struct nk_context*, const char*, int, struct nk_color);

	NK_API void nk_label(struct nk_context*, const char*, nk_flags align);

	NK_API void nk_label_colored(struct nk_context*, const char*, nk_flags align, struct nk_color);

	NK_API void nk_label_wrap(struct nk_context*, const char*);

	NK_API void nk_label_colored_wrap(struct nk_context*, const char*, struct nk_color);

	NK_API void nk_image(struct nk_context*, struct nk_image);

	NK_API void nk_image_color(struct nk_context*, struct nk_image, struct nk_color);

#ifdef NK_INCLUDE_STANDARD_VARARGS

	NK_API void
		nk_labelf(struct nk_context*, nk_flags, NK_PRINTF_FORMAT_STRING const char*, ...) NK_PRINTF_VARARG_FUNC(3);

	NK_API void nk_labelf_colored(struct nk_context*, nk_flags, struct nk_color, NK_PRINTF_FORMAT_STRING const char*,
		...) NK_PRINTF_VARARG_FUNC(4);

	NK_API void nk_labelf_wrap(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*, ...) NK_PRINTF_VARARG_FUNC(2);

	NK_API void nk_labelf_colored_wrap(struct nk_context*, struct nk_color, NK_PRINTF_FORMAT_STRING const char*,
		...) NK_PRINTF_VARARG_FUNC(3);

	NK_API void
		nk_labelfv(struct nk_context*, nk_flags, NK_PRINTF_FORMAT_STRING const char*, va_list) NK_PRINTF_VALIST_FUNC(3);

	NK_API void nk_labelfv_colored(struct nk_context*, nk_flags, struct nk_color, NK_PRINTF_FORMAT_STRING const char*,
		va_list) NK_PRINTF_VALIST_FUNC(4);

	NK_API void
		nk_labelfv_wrap(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*, va_list) NK_PRINTF_VALIST_FUNC(2);

	NK_API void nk_labelfv_colored_wrap(struct nk_context*, struct nk_color, NK_PRINTF_FORMAT_STRING const char*,
		va_list) NK_PRINTF_VALIST_FUNC(3);

	NK_API void nk_value_bool(struct nk_context*, const char* prefix, int);

	NK_API void nk_value_int(struct nk_context*, const char* prefix, int);

	NK_API void nk_value_uint(struct nk_context*, const char* prefix, unsigned int);

	NK_API void nk_value_float(struct nk_context*, const char* prefix, float);

	NK_API void nk_value_color_byte(struct nk_context*, const char* prefix, struct nk_color);

	NK_API void nk_value_color_float(struct nk_context*, const char* prefix, struct nk_color);

	NK_API void nk_value_color_hex(struct nk_context*, const char* prefix, struct nk_color);

#endif
	/* =============================================================================
	 *
	 *                                  BUTTON
	 *
	 * ============================================================================= */
	NK_API int nk_button_text(struct nk_context*, const char* title, int len);

	NK_API int nk_button_label(struct nk_context*, const char* title);

	NK_API int nk_button_color(struct nk_context*, struct nk_color);

	NK_API int nk_button_symbol(struct nk_context*, enum nk_symbol_type);

	NK_API int nk_button_image(struct nk_context*, struct nk_image img);

	NK_API int nk_button_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags text_alignment);

	NK_API int nk_button_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);

	NK_API int nk_button_image_label(struct nk_context*, struct nk_image img, const char*, nk_flags text_alignment);

	NK_API int nk_button_image_text(struct nk_context*, struct nk_image img, const char*, int, nk_flags alignment);

	NK_API int nk_button_text_styled(struct nk_context*, const struct nk_style_button*, const char* title, int len);

	NK_API int nk_button_label_styled(struct nk_context*, const struct nk_style_button*, const char* title);

	NK_API int nk_button_symbol_styled(struct nk_context*, const struct nk_style_button*, enum nk_symbol_type);

	NK_API int nk_button_image_styled(struct nk_context*, const struct nk_style_button*, struct nk_image img);

	NK_API int
		nk_button_symbol_text_styled(struct nk_context*, const struct nk_style_button*, enum nk_symbol_type, const char*,
			int, nk_flags alignment);

	NK_API int
		nk_button_symbol_label_styled(struct nk_context* ctx, const struct nk_style_button* style, enum nk_symbol_type symbol,
			const char* title, nk_flags align);

	NK_API int
		nk_button_image_label_styled(struct nk_context*, const struct nk_style_button*, struct nk_image img, const char*,
			nk_flags text_alignment);

	NK_API int
		nk_button_image_text_styled(struct nk_context*, const struct nk_style_button*, struct nk_image img, const char*, int,
			nk_flags alignment);

	NK_API void nk_button_set_behavior(struct nk_context*, enum nk_button_behavior);

	NK_API int nk_button_push_behavior(struct nk_context*, enum nk_button_behavior);

	NK_API int nk_button_pop_behavior(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  CHECKBOX
	 *
	 * ============================================================================= */
	NK_API int nk_check_label(struct nk_context*, const char*, int active);

	NK_API int nk_check_text(struct nk_context*, const char*, int, int active);

	NK_API unsigned nk_check_flags_label(struct nk_context*, const char*, unsigned int flags, unsigned int value);

	NK_API unsigned nk_check_flags_text(struct nk_context*, const char*, int, unsigned int flags, unsigned int value);

	NK_API int nk_checkbox_label(struct nk_context*, const char*, int* active);

	NK_API int nk_checkbox_text(struct nk_context*, const char*, int, int* active);

	NK_API int nk_checkbox_flags_label(struct nk_context*, const char*, unsigned int* flags, unsigned int value);

	NK_API int nk_checkbox_flags_text(struct nk_context*, const char*, int, unsigned int* flags, unsigned int value);
	/* =============================================================================
	 *
	 *                                  RADIO BUTTON
	 *
	 * ============================================================================= */
	NK_API int nk_radio_label(struct nk_context*, const char*, int* active);

	NK_API int nk_radio_text(struct nk_context*, const char*, int, int* active);

	NK_API int nk_option_label(struct nk_context*, const char*, int active);

	NK_API int nk_option_text(struct nk_context*, const char*, int, int active);
	/* =============================================================================
	 *
	 *                                  SELECTABLE
	 *
	 * ============================================================================= */
	NK_API int nk_selectable_label(struct nk_context*, const char*, nk_flags align, int* value);

	NK_API int nk_selectable_text(struct nk_context*, const char*, int, nk_flags align, int* value);

	NK_API int nk_selectable_image_label(struct nk_context*, struct nk_image, const char*, nk_flags align, int* value);

	NK_API int
		nk_selectable_image_text(struct nk_context*, struct nk_image, const char*, int, nk_flags align, int* value);

	NK_API int
		nk_selectable_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags align, int* value);

	NK_API int
		nk_selectable_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags align, int* value);

	NK_API int nk_select_label(struct nk_context*, const char*, nk_flags align, int value);

	NK_API int nk_select_text(struct nk_context*, const char*, int, nk_flags align, int value);

	NK_API int nk_select_image_label(struct nk_context*, struct nk_image, const char*, nk_flags align, int value);

	NK_API int nk_select_image_text(struct nk_context*, struct nk_image, const char*, int, nk_flags align, int value);

	NK_API int nk_select_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags align, int value);

	NK_API int
		nk_select_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags align, int value);

	/* =============================================================================
	 *
	 *                                  SLIDER
	 *
	 * ============================================================================= */
	NK_API float nk_slide_float(struct nk_context*, float min, float val, float max, float step);

	NK_API int nk_slide_int(struct nk_context*, int min, int val, int max, int step);

	NK_API int nk_slider_float(struct nk_context*, float min, float* val, float max, float step);

	NK_API int nk_slider_int(struct nk_context*, int min, int* val, int max, int step);
	/* =============================================================================
	 *
	 *                                  PROGRESSBAR
	 *
	 * ============================================================================= */
	NK_API int nk_progress(struct nk_context*, nk_size* cur, nk_size max, int modifyable);

	NK_API nk_size nk_prog(struct nk_context*, nk_size cur, nk_size max, int modifyable);

	/* =============================================================================
	 *
	 *                                  COLOR PICKER
	 *
	 * ============================================================================= */
	NK_API struct nk_colorf nk_color_picker(struct nk_context*, struct nk_colorf, enum nk_color_format);

	NK_API int nk_color_pick(struct nk_context*, struct nk_colorf*, enum nk_color_format);
	/* =============================================================================
	 *
	 *                                  PROPERTIES
	 *
	 * =============================================================================
	/// ### Properties
	/// Properties are the main value modification widgets in Nuklear. Changing a value
	/// can be achieved by dragging, adding/removing incremental steps on button click
	/// or by directly typing a number.
	///
	/// #### Usage
	/// Each property requires a unique name for identifaction that is also used for
	/// displaying a label. If you want to use the same name multiple times make sure
	/// add a '#' before your name. The '#' will not be shown but will generate a
	/// unique ID. Each propery also takes in a minimum and maximum value. If you want
	/// to make use of the complete number range of a type just use the provided
	/// type limits from `limits.h`. For example `INT_MIN` and `INT_MAX` for
	/// `nk_property_int` and `nk_propertyi`. In additional each property takes in
	/// a increment value that will be added or subtracted if either the increment
	/// decrement button is clicked. Finally there is a value for increment per pixel
	/// dragged that is added or subtracted from the value.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int value = 0;
	/// struct nk_context ctx;
	/// nk_init_xxx(&ctx, ...);
	/// while (1) {
	///     // Input
	///     Event evt;
	///     nk_input_begin(&ctx);
	///     while (GetEvent(&evt)) {
	///         if (evt.type == MOUSE_MOVE)
	///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	///         else if (evt.type == [...]) {
	///             nk_input_xxx(...);
	///         }
	///     }
	///     nk_input_end(&ctx);
	///     //
	///     // Window
	///     if (nk_begin_xxx(...) {
	///         // Property
	///         nk_layout_row_dynamic(...);
	///         nk_property_int(ctx, "ID", INT_MIN, &value, INT_MAX, 1, 1);
	///     }
	///     nk_end(ctx);
	///     //
	///     // Draw
	///     const struct nk_command *cmd = 0;
	///     nk_foreach(cmd, &ctx) {
	///     switch (cmd->type) {
	///     case NK_COMMAND_LINE:
	///         your_draw_line_function(...)
	///         break;
	///     case NK_COMMAND_RECT
	///         your_draw_rect_function(...)
	///         break;
	///     case ...:
	///         // [...]
	///     }
	//      nk_clear(&ctx);
	/// }
	/// nk_free(&ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// #### Reference
	/// Function            | Description
	/// --------------------|-------------------------------------------
	/// nk_property_int     | Integer property directly modifing a passed in value
	/// nk_property_float   | Float property directly modifing a passed in value
	/// nk_property_double  | Double property directly modifing a passed in value
	/// nk_propertyi        | Integer property returning the modified int value
	/// nk_propertyf        | Float property returning the modified float value
	/// nk_propertyd        | Double property returning the modified double value
	///
	*/
	/*/// #### nk_property_int
	/// Integer property directly modifing a passed in value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_property_int(struct nk_context *ctx, const char *name, int min, int *val, int max, int step, float inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Integer pointer to be modified
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	*/
	NK_API void
		nk_property_int(struct nk_context*, const char* name, int min, int* val, int max, int step, float inc_per_pixel);
	/*/// #### nk_property_float
	/// Float property directly modifing a passed in value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_property_float(struct nk_context *ctx, const char *name, float min, float *val, float max, float step, float inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Float pointer to be modified
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	*/
	NK_API void nk_property_float(struct nk_context*, const char* name, float min, float* val, float max, float step,
		float inc_per_pixel);
	/*/// #### nk_property_double
	/// Double property directly modifing a passed in value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_property_double(struct nk_context *ctx, const char *name, double min, double *val, double max, double step, double inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Double pointer to be modified
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	*/
	NK_API void nk_property_double(struct nk_context*, const char* name, double min, double* val, double max, double step,
		float inc_per_pixel);
	/*/// #### nk_propertyi
	/// Integer property modifing a passed in value and returning the new value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_propertyi(struct nk_context *ctx, const char *name, int min, int val, int max, int step, float inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Current integer value to be modified and returned
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	///
	/// Returns the new modified integer value
	*/
	NK_API int
		nk_propertyi(struct nk_context*, const char* name, int min, int val, int max, int step, float inc_per_pixel);
	/*/// #### nk_propertyf
	/// Float property modifing a passed in value and returning the new value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// float nk_propertyf(struct nk_context *ctx, const char *name, float min, float val, float max, float step, float inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Current float value to be modified and returned
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	///
	/// Returns the new modified float value
	*/
	NK_API float
		nk_propertyf(struct nk_context*, const char* name, float min, float val, float max, float step, float inc_per_pixel);
	/*/// #### nk_propertyd
	/// Float property modifing a passed in value and returning the new value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// float nk_propertyd(struct nk_context *ctx, const char *name, double min, double val, double max, double step, double inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Current double value to be modified and returned
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	///
	/// Returns the new modified double value
	*/
	NK_API double nk_propertyd(struct nk_context*, const char* name, double min, double val, double max, double step,
		float inc_per_pixel);

	/* =============================================================================
	 *
	 *                                  TEXT EDIT
	 *
	 * ============================================================================= */
	enum nk_edit_flags {
		NK_EDIT_DEFAULT = 0,
		NK_EDIT_READ_ONLY = NK_FLAG(0),
		NK_EDIT_AUTO_SELECT = NK_FLAG(1),
		NK_EDIT_SIG_ENTER = NK_FLAG(2),
		NK_EDIT_ALLOW_TAB = NK_FLAG(3),
		NK_EDIT_NO_CURSOR = NK_FLAG(4),
		NK_EDIT_SELECTABLE = NK_FLAG(5),
		NK_EDIT_CLIPBOARD = NK_FLAG(6),
		NK_EDIT_CTRL_ENTER_NEWLINE = NK_FLAG(7),
		NK_EDIT_NO_HORIZONTAL_SCROLL = NK_FLAG(8),
		NK_EDIT_ALWAYS_INSERT_MODE = NK_FLAG(9),
		NK_EDIT_MULTILINE = NK_FLAG(10),
		NK_EDIT_GOTO_END_ON_ACTIVATE = NK_FLAG(11)
	};
	enum nk_edit_types {
		NK_EDIT_SIMPLE = NK_EDIT_ALWAYS_INSERT_MODE,
		NK_EDIT_FIELD = NK_EDIT_SIMPLE | NK_EDIT_SELECTABLE | NK_EDIT_CLIPBOARD,
		NK_EDIT_BOX =
		NK_EDIT_ALWAYS_INSERT_MODE | NK_EDIT_SELECTABLE | NK_EDIT_MULTILINE | NK_EDIT_ALLOW_TAB | NK_EDIT_CLIPBOARD,
		NK_EDIT_EDITOR = NK_EDIT_SELECTABLE | NK_EDIT_MULTILINE | NK_EDIT_ALLOW_TAB | NK_EDIT_CLIPBOARD
	};
	enum nk_edit_events {
		NK_EDIT_ACTIVE = NK_FLAG(0), /* edit widget is currently being modified */
		NK_EDIT_INACTIVE = NK_FLAG(1), /* edit widget is not active and is not being modified */
		NK_EDIT_ACTIVATED = NK_FLAG(2), /* edit widget went from state inactive to state active */
		NK_EDIT_DEACTIVATED = NK_FLAG(3), /* edit widget went from state active to state inactive */
		NK_EDIT_COMMITED = NK_FLAG(4) /* edit widget has received an enter and lost focus */
	};

	NK_API nk_flags nk_edit_string(struct nk_context*, nk_flags, char* buffer, int* len, int max, nk_plugin_filter);

	NK_API nk_flags nk_edit_string_zero_terminated(struct nk_context*, nk_flags, char* buffer, int max, nk_plugin_filter);

	NK_API nk_flags nk_edit_buffer(struct nk_context*, nk_flags, struct nk_text_edit*, nk_plugin_filter);

	NK_API void nk_edit_focus(struct nk_context*, nk_flags flags);

	NK_API void nk_edit_unfocus(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  CHART
	 *
	 * ============================================================================= */
	NK_API int nk_chart_begin(struct nk_context*, enum nk_chart_type, int num, float min, float max);

	NK_API int
		nk_chart_begin_colored(struct nk_context*, enum nk_chart_type, struct nk_color, struct nk_color active, int num,
			float min, float max);

	NK_API void
		nk_chart_add_slot(struct nk_context* ctx, const enum nk_chart_type, int count, float min_value, float max_value);

	NK_API void
		nk_chart_add_slot_colored(struct nk_context* ctx, const enum nk_chart_type, struct nk_color, struct nk_color active,
			int count, float min_value, float max_value);

	NK_API nk_flags nk_chart_push(struct nk_context*, float);

	NK_API nk_flags nk_chart_push_slot(struct nk_context*, float, int);

	NK_API void nk_chart_end(struct nk_context*);

	NK_API void nk_plot(struct nk_context*, enum nk_chart_type, const float* values, int count, int offset);

	NK_API void
		nk_plot_function(struct nk_context*, enum nk_chart_type, void* userdata, float(*value_getter)(void* user, int index),
			int count, int offset);
	/* =============================================================================
	 *
	 *                                  POPUP
	 *
	 * ============================================================================= */
	NK_API int nk_popup_begin(struct nk_context*, enum nk_popup_type, const char*, nk_flags, struct nk_rect bounds);

	NK_API void nk_popup_close(struct nk_context*);

	NK_API void nk_popup_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  COMBOBOX
	 *
	 * ============================================================================= */
	NK_API int
		nk_combo(struct nk_context*, const char** items, int count, int selected, int item_height, struct nk_vec2 size);

	NK_API int
		nk_combo_separator(struct nk_context*, const char* items_separated_by_separator, int separator, int selected,
			int count, int item_height, struct nk_vec2 size);

	NK_API int
		nk_combo_string(struct nk_context*, const char* items_separated_by_zeros, int selected, int count, int item_height,
			struct nk_vec2 size);

	NK_API int
		nk_combo_callback(struct nk_context*, void(*item_getter)(void*, int, const char**), void* userdata, int selected,
			int count, int item_height, struct nk_vec2 size);

	NK_API void
		nk_combobox(struct nk_context*, const char** items, int count, int* selected, int item_height, struct nk_vec2 size);

	NK_API void
		nk_combobox_string(struct nk_context*, const char* items_separated_by_zeros, int* selected, int count, int item_height,
			struct nk_vec2 size);

	NK_API void
		nk_combobox_separator(struct nk_context*, const char* items_separated_by_separator, int separator, int* selected,
			int count, int item_height, struct nk_vec2 size);

	NK_API void
		nk_combobox_callback(struct nk_context*, void(*item_getter)(void*, int, const char**), void*, int* selected,
			int count, int item_height, struct nk_vec2 size);
	/* =============================================================================
	 *
	 *                                  ABSTRACT COMBOBOX
	 *
	 * ============================================================================= */
	NK_API int nk_combo_begin_text(struct nk_context*, const char* selected, int, struct nk_vec2 size);

	NK_API int nk_combo_begin_label(struct nk_context*, const char* selected, struct nk_vec2 size);

	NK_API int nk_combo_begin_color(struct nk_context*, struct nk_color color, struct nk_vec2 size);

	NK_API int nk_combo_begin_symbol(struct nk_context*, enum nk_symbol_type, struct nk_vec2 size);

	NK_API int
		nk_combo_begin_symbol_label(struct nk_context*, const char* selected, enum nk_symbol_type, struct nk_vec2 size);

	NK_API int
		nk_combo_begin_symbol_text(struct nk_context*, const char* selected, int, enum nk_symbol_type, struct nk_vec2 size);

	NK_API int nk_combo_begin_image(struct nk_context*, struct nk_image img, struct nk_vec2 size);

	NK_API int nk_combo_begin_image_label(struct nk_context*, const char* selected, struct nk_image, struct nk_vec2 size);

	NK_API int
		nk_combo_begin_image_text(struct nk_context*, const char* selected, int, struct nk_image, struct nk_vec2 size);

	NK_API int nk_combo_item_label(struct nk_context*, const char*, nk_flags alignment);

	NK_API int nk_combo_item_text(struct nk_context*, const char*, int, nk_flags alignment);

	NK_API int nk_combo_item_image_label(struct nk_context*, struct nk_image, const char*, nk_flags alignment);

	NK_API int nk_combo_item_image_text(struct nk_context*, struct nk_image, const char*, int, nk_flags alignment);

	NK_API int nk_combo_item_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags alignment);

	NK_API int nk_combo_item_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);

	NK_API void nk_combo_close(struct nk_context*);

	NK_API void nk_combo_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  CONTEXTUAL
	 *
	 * ============================================================================= */
	NK_API int nk_contextual_begin(struct nk_context*, nk_flags, struct nk_vec2, struct nk_rect trigger_bounds);

	NK_API int nk_contextual_item_text(struct nk_context*, const char*, int, nk_flags align);

	NK_API int nk_contextual_item_label(struct nk_context*, const char*, nk_flags align);

	NK_API int nk_contextual_item_image_label(struct nk_context*, struct nk_image, const char*, nk_flags alignment);

	NK_API int
		nk_contextual_item_image_text(struct nk_context*, struct nk_image, const char*, int len, nk_flags alignment);

	NK_API int nk_contextual_item_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags alignment);

	NK_API int
		nk_contextual_item_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);

	NK_API void nk_contextual_close(struct nk_context*);

	NK_API void nk_contextual_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  TOOLTIP
	 *
	 * ============================================================================= */
	NK_API void nk_tooltip(struct nk_context*, const char*);

#ifdef NK_INCLUDE_STANDARD_VARARGS

	NK_API void nk_tooltipf(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*, ...) NK_PRINTF_VARARG_FUNC(2);

	NK_API void nk_tooltipfv(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*, va_list) NK_PRINTF_VALIST_FUNC(2);

#endif

	NK_API int nk_tooltip_begin(struct nk_context*, float width);

	NK_API void nk_tooltip_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  MENU
	 *
	 * ============================================================================= */
	NK_API void nk_menubar_begin(struct nk_context*);

	NK_API void nk_menubar_end(struct nk_context*);

	NK_API int
		nk_menu_begin_text(struct nk_context*, const char* title, int title_len, nk_flags align, struct nk_vec2 size);

	NK_API int nk_menu_begin_label(struct nk_context*, const char*, nk_flags align, struct nk_vec2 size);

	NK_API int nk_menu_begin_image(struct nk_context*, const char*, struct nk_image, struct nk_vec2 size);

	NK_API int
		nk_menu_begin_image_text(struct nk_context*, const char*, int, nk_flags align, struct nk_image, struct nk_vec2 size);

	NK_API int
		nk_menu_begin_image_label(struct nk_context*, const char*, nk_flags align, struct nk_image, struct nk_vec2 size);

	NK_API int nk_menu_begin_symbol(struct nk_context*, const char*, enum nk_symbol_type, struct nk_vec2 size);

	NK_API int nk_menu_begin_symbol_text(struct nk_context*, const char*, int, nk_flags align, enum nk_symbol_type,
		struct nk_vec2 size);

	NK_API int
		nk_menu_begin_symbol_label(struct nk_context*, const char*, nk_flags align, enum nk_symbol_type, struct nk_vec2 size);

	NK_API int nk_menu_item_text(struct nk_context*, const char*, int, nk_flags align);

	NK_API int nk_menu_item_label(struct nk_context*, const char*, nk_flags alignment);

	NK_API int nk_menu_item_image_label(struct nk_context*, struct nk_image, const char*, nk_flags alignment);

	NK_API int nk_menu_item_image_text(struct nk_context*, struct nk_image, const char*, int len, nk_flags alignment);

	NK_API int nk_menu_item_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);

	NK_API int nk_menu_item_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags alignment);

	NK_API void nk_menu_close(struct nk_context*);

	NK_API void nk_menu_end(struct nk_context*);

	/* =============================================================================
	 *
	 *                                  STYLE
	 *
	 * ============================================================================= */
	enum nk_style_colors {
		NK_COLOR_TEXT,
		NK_COLOR_WINDOW,
		NK_COLOR_HEADER,
		NK_COLOR_BORDER,
		NK_COLOR_BUTTON,
		NK_COLOR_BUTTON_HOVER,
		NK_COLOR_BUTTON_ACTIVE,
		NK_COLOR_TOGGLE,
		NK_COLOR_TOGGLE_HOVER,
		NK_COLOR_TOGGLE_CURSOR,
		NK_COLOR_SELECT,
		NK_COLOR_SELECT_ACTIVE,
		NK_COLOR_SLIDER,
		NK_COLOR_SLIDER_CURSOR,
		NK_COLOR_SLIDER_CURSOR_HOVER,
		NK_COLOR_SLIDER_CURSOR_ACTIVE,
		NK_COLOR_PROPERTY,
		NK_COLOR_EDIT,
		NK_COLOR_EDIT_CURSOR,
		NK_COLOR_COMBO,
		NK_COLOR_CHART,
		NK_COLOR_CHART_COLOR,
		NK_COLOR_CHART_COLOR_HIGHLIGHT,
		NK_COLOR_SCROLLBAR,
		NK_COLOR_SCROLLBAR_CURSOR,
		NK_COLOR_SCROLLBAR_CURSOR_HOVER,
		NK_COLOR_SCROLLBAR_CURSOR_ACTIVE,
		NK_COLOR_TAB_HEADER,
		NK_COLOR_COUNT
	};
	enum nk_style_cursor {
		NK_CURSOR_ARROW,
		NK_CURSOR_TEXT,
		NK_CURSOR_MOVE,
		NK_CURSOR_RESIZE_VERTICAL,
		NK_CURSOR_RESIZE_HORIZONTAL,
		NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT,
		NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT,
		NK_CURSOR_COUNT
	};

	NK_API void nk_style_default(struct nk_context*);

	NK_API void nk_style_from_table(struct nk_context*, const struct nk_color*);

	NK_API void nk_style_load_cursor(struct nk_context*, enum nk_style_cursor, const struct nk_cursor*);

	NK_API void nk_style_load_all_cursors(struct nk_context*, struct nk_cursor*);

	NK_API const char* nk_style_get_color_by_name(enum nk_style_colors);

	NK_API void nk_style_set_font(struct nk_context*, const struct nk_user_font*);

	NK_API int nk_style_set_cursor(struct nk_context*, enum nk_style_cursor);

	NK_API void nk_style_show_cursor(struct nk_context*);

	NK_API void nk_style_hide_cursor(struct nk_context*);

	NK_API int nk_style_push_font(struct nk_context*, const struct nk_user_font*);

	NK_API int nk_style_push_float(struct nk_context*, float*, float);

	NK_API int nk_style_push_vec2(struct nk_context*, struct nk_vec2*, struct nk_vec2);

	NK_API int nk_style_push_style_item(struct nk_context*, struct nk_style_item*, struct nk_style_item);

	NK_API int nk_style_push_flags(struct nk_context*, nk_flags*, nk_flags);

	NK_API int nk_style_push_color(struct nk_context*, struct nk_color*, struct nk_color);

	NK_API int nk_style_pop_font(struct nk_context*);

	NK_API int nk_style_pop_float(struct nk_context*);

	NK_API int nk_style_pop_vec2(struct nk_context*);

	NK_API int nk_style_pop_style_item(struct nk_context*);

	NK_API int nk_style_pop_flags(struct nk_context*);

	NK_API int nk_style_pop_color(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  COLOR
	 *
	 * ============================================================================= */
	NK_API struct nk_color nk_rgb(int r, int g, int b);

	NK_API struct nk_color nk_rgb_iv(const int* rgb);

	NK_API struct nk_color nk_rgb_bv(const nk_byte* rgb);

	NK_API struct nk_color nk_rgb_f(float r, float g, float b);

	NK_API struct nk_color nk_rgb_fv(const float* rgb);

	NK_API struct nk_color nk_rgb_cf(struct nk_colorf c);

	NK_API struct nk_color nk_rgb_hex(const char* rgb);

	NK_API struct nk_color nk_rgba(int r, int g, int b, int a);

	NK_API struct nk_color nk_rgba_u32(nk_uint);

	NK_API struct nk_color nk_rgba_iv(const int* rgba);

	NK_API struct nk_color nk_rgba_bv(const nk_byte* rgba);

	NK_API struct nk_color nk_rgba_f(float r, float g, float b, float a);

	NK_API struct nk_color nk_rgba_fv(const float* rgba);

	NK_API struct nk_color nk_rgba_cf(struct nk_colorf c);

	NK_API struct nk_color nk_rgba_hex(const char* rgb);

	NK_API struct nk_colorf nk_hsva_colorf(float h, float s, float v, float a);

	NK_API struct nk_colorf nk_hsva_colorfv(float* c);

	NK_API void nk_colorf_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, struct nk_colorf in);

	NK_API void nk_colorf_hsva_fv(float* hsva, struct nk_colorf in);

	NK_API struct nk_color nk_hsv(int h, int s, int v);

	NK_API struct nk_color nk_hsv_iv(const int* hsv);

	NK_API struct nk_color nk_hsv_bv(const nk_byte* hsv);

	NK_API struct nk_color nk_hsv_f(float h, float s, float v);

	NK_API struct nk_color nk_hsv_fv(const float* hsv);

	NK_API struct nk_color nk_hsva(int h, int s, int v, int a);

	NK_API struct nk_color nk_hsva_iv(const int* hsva);

	NK_API struct nk_color nk_hsva_bv(const nk_byte* hsva);

	NK_API struct nk_color nk_hsva_f(float h, float s, float v, float a);

	NK_API struct nk_color nk_hsva_fv(const float* hsva);

	/* color (conversion nuklear --> user) */
	NK_API void nk_color_f(float* r, float* g, float* b, float* a, struct nk_color);

	NK_API void nk_color_fv(float* rgba_out, struct nk_color);

	NK_API struct nk_colorf nk_color_cf(struct nk_color);

	NK_API void nk_color_d(double* r, double* g, double* b, double* a, struct nk_color);

	NK_API void nk_color_dv(double* rgba_out, struct nk_color);

	NK_API nk_uint nk_color_u32(struct nk_color);

	NK_API void nk_color_hex_rgba(char* output, struct nk_color);

	NK_API void nk_color_hex_rgb(char* output, struct nk_color);

	NK_API void nk_color_hsv_i(int* out_h, int* out_s, int* out_v, struct nk_color);

	NK_API void nk_color_hsv_b(nk_byte* out_h, nk_byte* out_s, nk_byte* out_v, struct nk_color);

	NK_API void nk_color_hsv_iv(int* hsv_out, struct nk_color);

	NK_API void nk_color_hsv_bv(nk_byte* hsv_out, struct nk_color);

	NK_API void nk_color_hsv_f(float* out_h, float* out_s, float* out_v, struct nk_color);

	NK_API void nk_color_hsv_fv(float* hsv_out, struct nk_color);

	NK_API void nk_color_hsva_i(int* h, int* s, int* v, int* a, struct nk_color);

	NK_API void nk_color_hsva_b(nk_byte* h, nk_byte* s, nk_byte* v, nk_byte* a, struct nk_color);

	NK_API void nk_color_hsva_iv(int* hsva_out, struct nk_color);

	NK_API void nk_color_hsva_bv(nk_byte* hsva_out, struct nk_color);

	NK_API void nk_color_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, struct nk_color);

	NK_API void nk_color_hsva_fv(float* hsva_out, struct nk_color);
	/* =============================================================================
	 *
	 *                                  IMAGE
	 *
	 * ============================================================================= */
	NK_API nk_handle nk_handle_ptr(void*);

	NK_API nk_handle nk_handle_id(int);

	NK_API struct nk_image nk_image_handle(nk_handle);

	NK_API struct nk_image nk_image_ptr(void*);

	NK_API struct nk_image nk_image_id(int);

	NK_API int nk_image_is_subimage(const struct nk_image* img);

	NK_API struct nk_image nk_subimage_ptr(void*, unsigned short w, unsigned short h, struct nk_rect sub_region);

	NK_API struct nk_image nk_subimage_id(int, unsigned short w, unsigned short h, struct nk_rect sub_region);

	NK_API struct nk_image nk_subimage_handle(nk_handle, unsigned short w, unsigned short h, struct nk_rect sub_region);
	/* =============================================================================
	 *
	 *                                  MATH
	 *
	 * ============================================================================= */
	NK_API nk_hash nk_murmur_hash(const void* key, int len, nk_hash seed);

	NK_API void
		nk_triangle_from_direction(struct nk_vec2* result, struct nk_rect r, float pad_x, float pad_y, enum nk_heading);

	NK_API struct nk_vec2 nk_vec2(float x, float y);

	NK_API struct nk_vec2 nk_vec2i(int x, int y);

	NK_API struct nk_vec2 nk_vec2v(const float* xy);

	NK_API struct nk_vec2 nk_vec2iv(const int* xy);

	NK_API struct nk_rect nk_get_null_rect(void);

	NK_API struct nk_rect nk_rect(float x, float y, float w, float h);

	NK_API struct nk_rect nk_recti(int x, int y, int w, int h);

	NK_API struct nk_rect nk_recta(struct nk_vec2 pos, struct nk_vec2 size);

	NK_API struct nk_rect nk_rectv(const float* xywh);

	NK_API struct nk_rect nk_rectiv(const int* xywh);

	NK_API struct nk_vec2 nk_rect_pos(struct nk_rect);

	NK_API struct nk_vec2 nk_rect_size(struct nk_rect);
	/* =============================================================================
	 *
	 *                                  STRING
	 *
	 * ============================================================================= */
	NK_API int nk_strlen(const char* str);

	NK_API int nk_stricmp(const char* s1, const char* s2);

	NK_API int nk_stricmpn(const char* s1, const char* s2, int n);

	NK_API int nk_strtoi(const char* str, const char** endptr);

	NK_API float nk_strtof(const char* str, const char** endptr);

	NK_API double nk_strtod(const char* str, const char** endptr);

	NK_API int nk_strfilter(const char* text, const char* regexp);

	NK_API int nk_strmatch_fuzzy_string(char const* str, char const* pattern, int* out_score);

	NK_API int nk_strmatch_fuzzy_text(const char* txt, int txt_len, const char* pattern, int* out_score);
	/* =============================================================================
	 *
	 *                                  UTF-8
	 *
	 * ============================================================================= */
	NK_API int nk_utf_decode(const char*, nk_rune*, int);

	NK_API int nk_utf_encode(nk_rune, char*, int);

	NK_API int nk_utf_len(const char*, int byte_len);

	NK_API const char* nk_utf_at(const char* buffer, int length, int index, nk_rune* unicode, int* len);
	/* ===============================================================
	 *
	 *                          FONT
	 *
	 * ===============================================================*/
	 /*  Font handling in this library was designed to be quite customizable and lets
		 you decide what you want to use and what you want to provide. There are three
		 different ways to use the font atlas. The first two will use your font
		 handling scheme and only requires essential data to run nuklear. The next
		 slightly more advanced features is font handling with vertex buffer output.
		 Finally the most complex API wise is using nuklear's font baking API.

		 1.) Using your own implementation without vertex buffer output
		 --------------------------------------------------------------
		 So first up the easiest way to do font handling is by just providing a
		 `nk_user_font` struct which only requires the height in pixel of the used
		 font and a callback to calculate the width of a string. This way of handling
		 fonts is best fitted for using the normal draw shape command API where you
		 do all the text drawing yourself and the library does not require any kind
		 of deeper knowledge about which font handling mechanism you use.
		 IMPORTANT: the `nk_user_font` pointer provided to nuklear has to persist
		 over the complete life time! I know this sucks but it is currently the only
		 way to switch between fonts.

			 float your_text_width_calculation(nk_handle handle, float height, const char *text, int len)
			 {
				 your_font_type *type = handle.ptr;
				 float text_width = ...;
				 return text_width;
			 }

			 struct nk_user_font font;
			 font.userdata.ptr = &your_font_class_or_struct;
			 font.height = your_font_height;
			 font.width = your_text_width_calculation;

			 struct nk_context ctx;
			 nk_init_default(&ctx, &font);

		 2.) Using your own implementation with vertex buffer output
		 --------------------------------------------------------------
		 While the first approach works fine if you don't want to use the optional
		 vertex buffer output it is not enough if you do. To get font handling working
		 for these cases you have to provide two additional parameters inside the
		 `nk_user_font`. First a texture atlas handle used to draw text as subimages
		 of a bigger font atlas texture and a callback to query a character's glyph
		 information (offset, size, ...). So it is still possible to provide your own
		 font and use the vertex buffer output.

			 float your_text_width_calculation(nk_handle handle, float height, const char *text, int len)
			 {
				 your_font_type *type = handle.ptr;
				 float text_width = ...;
				 return text_width;
			 }
			 void query_your_font_glyph(nk_handle handle, float font_height, struct nk_user_font_glyph *glyph, nk_rune codepoint, nk_rune next_codepoint)
			 {
				 your_font_type *type = handle.ptr;
				 glyph.width = ...;
				 glyph.height = ...;
				 glyph.xadvance = ...;
				 glyph.uv[0].x = ...;
				 glyph.uv[0].y = ...;
				 glyph.uv[1].x = ...;
				 glyph.uv[1].y = ...;
				 glyph.offset.x = ...;
				 glyph.offset.y = ...;
			 }

			 struct nk_user_font font;
			 font.userdata.ptr = &your_font_class_or_struct;
			 font.height = your_font_height;
			 font.width = your_text_width_calculation;
			 font.query = query_your_font_glyph;
			 font.texture.id = your_font_texture;

			 struct nk_context ctx;
			 nk_init_default(&ctx, &font);

		 3.) Nuklear font baker
		 ------------------------------------
		 The final approach if you do not have a font handling functionality or don't
		 want to use it in this library is by using the optional font baker.
		 The font baker APIs can be used to create a font plus font atlas texture
		 and can be used with or without the vertex buffer output.

		 It still uses the `nk_user_font` struct and the two different approaches
		 previously stated still work. The font baker is not located inside
		 `nk_context` like all other systems since it can be understood as more of
		 an extension to nuklear and does not really depend on any `nk_context` state.

		 Font baker need to be initialized first by one of the nk_font_atlas_init_xxx
		 functions. If you don't care about memory just call the default version
		 `nk_font_atlas_init_default` which will allocate all memory from the standard library.
		 If you want to control memory allocation but you don't care if the allocated
		 memory is temporary and therefore can be freed directly after the baking process
		 is over or permanent you can call `nk_font_atlas_init`.

		 After successfully initializing the font baker you can add Truetype(.ttf) fonts from
		 different sources like memory or from file by calling one of the `nk_font_atlas_add_xxx`.
		 functions. Adding font will permanently store each font, font config and ttf memory block(!)
		 inside the font atlas and allows to reuse the font atlas. If you don't want to reuse
		 the font baker by for example adding additional fonts you can call
		 `nk_font_atlas_cleanup` after the baking process is over (after calling nk_font_atlas_end).

		 As soon as you added all fonts you wanted you can now start the baking process
		 for every selected glyph to image by calling `nk_font_atlas_bake`.
		 The baking process returns image memory, width and height which can be used to
		 either create your own image object or upload it to any graphics library.
		 No matter which case you finally have to call `nk_font_atlas_end` which
		 will free all temporary memory including the font atlas image so make sure
		 you created our texture beforehand. `nk_font_atlas_end` requires a handle
		 to your font texture or object and optionally fills a `struct nk_draw_null_texture`
		 which can be used for the optional vertex output. If you don't want it just
		 set the argument to `NULL`.

		 At this point you are done and if you don't want to reuse the font atlas you
		 can call `nk_font_atlas_cleanup` to free all truetype blobs and configuration
		 memory. Finally if you don't use the font atlas and any of it's fonts anymore
		 you need to call `nk_font_atlas_clear` to free all memory still being used.

			 struct nk_font_atlas atlas;
			 nk_font_atlas_init_default(&atlas);
			 nk_font_atlas_begin(&atlas);
			 nk_font *font = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font.ttf", 13, 0);
			 nk_font *font2 = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font2.ttf", 16, 0);
			 const void* img = nk_font_atlas_bake(&atlas, &img_width, &img_height, NK_FONT_ATLAS_RGBA32);
			 nk_font_atlas_end(&atlas, nk_handle_id(texture), 0);

			 struct nk_context ctx;
			 nk_init_default(&ctx, &font->handle);
			 while (1) {

			 }
			 nk_font_atlas_clear(&atlas);

		 The font baker API is probably the most complex API inside this library and
		 I would suggest reading some of my examples `example/` to get a grip on how
		 to use the font atlas. There are a number of details I left out. For example
		 how to merge fonts, configure a font with `nk_font_config` to use other languages,
		 use another texture coordinate format and a lot more:

			 struct nk_font_config cfg = nk_font_config(font_pixel_height);
			 cfg.merge_mode = nk_false or nk_true;
			 cfg.range = nk_font_korean_glyph_ranges();
			 cfg.coord_type = NK_COORD_PIXEL;
			 nk_font *font = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font.ttf", 13, &cfg);

	 */
	struct nk_user_font_glyph;

	typedef float(*nk_text_width_f)(nk_handle, float h, const char*, int len);

	typedef void(*nk_query_font_glyph_f)(nk_handle handle, float font_height, struct nk_user_font_glyph* glyph,
		nk_rune codepoint, nk_rune next_codepoint);

#if defined(NK_INCLUDE_VERTEX_BUFFER_OUTPUT) || defined(NK_INCLUDE_SOFTWARE_FONT)
	struct nk_user_font_glyph {
		struct nk_vec2 uv[2];
		/* texture coordinates */
		struct nk_vec2 offset;
		/* offset between top left and glyph */
		float width, height;
		/* size of the glyph  */
		float xadvance;
		/* offset to the next glyph */
	};
#endif

	struct nk_user_font {
		nk_handle userdata;
		/* user provided font handle */
		float height;
		/* max height of the font */
		nk_text_width_f width;
		/* font string width in pixel callback */
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
		nk_query_font_glyph_f query;
		/* font glyph callback to query drawing info */
		nk_handle texture;
		/* texture handle to the used font atlas or texture */
#endif
	};

#ifdef NK_INCLUDE_FONT_BAKING
	enum nk_font_coord_type {
		NK_COORD_UV, /* texture coordinates inside font glyphs are clamped between 0-1 */
		NK_COORD_PIXEL /* texture coordinates inside font glyphs are in absolute pixel */
	};

	struct nk_font;
	struct nk_baked_font {
		float height;
		/* height of the font  */
		float ascent, descent;
		/* font glyphs ascent and descent  */
		nk_rune glyph_offset;
		/* glyph array offset inside the font glyph baking output array  */
		nk_rune glyph_count;
		/* number of glyphs of this font inside the glyph baking array output */
		const nk_rune* ranges;
		/* font codepoint ranges as pairs of (from/to) and 0 as last element */
	};

	struct nk_font_config {
		struct nk_font_config* next;
		/* NOTE: only used internally */
		void* ttf_blob;
		/* pointer to loaded TTF file memory block.
		 * NOTE: not needed for nk_font_atlas_add_from_memory and nk_font_atlas_add_from_file. */
		nk_size ttf_size;
		/* size of the loaded TTF file memory block
		 * NOTE: not needed for nk_font_atlas_add_from_memory and nk_font_atlas_add_from_file. */

		unsigned char ttf_data_owned_by_atlas;
		/* used inside font atlas: default to: 0*/
		unsigned char merge_mode;
		/* merges this font into the last font */
		unsigned char pixel_snap;
		/* align every character to pixel boundary (if true set oversample (1,1)) */
		unsigned char oversample_v, oversample_h;
		/* rasterize at hight quality for sub-pixel position */
		unsigned char padding[3];

		float size;
		/* baked pixel height of the font */
		enum nk_font_coord_type coord_type;
		/* texture coordinate format with either pixel or UV coordinates */
		struct nk_vec2 spacing;
		/* extra pixel spacing between glyphs  */
		const nk_rune* range;
		/* list of unicode ranges (2 values per range, zero terminated) */
		struct nk_baked_font* font;
		/* font to setup in the baking process: NOTE: not needed for font atlas */
		nk_rune fallback_glyph;
		/* fallback glyph to use if a given rune is not found */
		struct nk_font_config* n;
		struct nk_font_config* p;
	};

	struct nk_font_glyph {
		nk_rune codepoint;
		float xadvance;
		float x0, y0, x1, y1, w, h;
		float u0, v0, u1, v1;
	};

	struct nk_font {
		struct nk_font* next;
		struct nk_user_font handle;
		struct nk_baked_font info;
		float scale;
		struct nk_font_glyph* glyphs;
		const struct nk_font_glyph* fallback;
		nk_rune fallback_codepoint;
		nk_handle texture;
		struct nk_font_config* config;
	};

	enum nk_font_atlas_format {
		NK_FONT_ATLAS_ALPHA8,
		NK_FONT_ATLAS_RGBA32
	};

	struct nk_font_atlas {
		void* pixel;
		int tex_width;
		int tex_height;

		struct nk_allocator permanent;
		struct nk_allocator temporary;

		struct nk_recti custom;
		struct nk_cursor cursors[NK_CURSOR_COUNT];

		int glyph_count;
		struct nk_font_glyph* glyphs;
		struct nk_font* default_font;
		struct nk_font* fonts;
		struct nk_font_config* config;
		int font_num;
	};

	/* some language glyph codepoint ranges */
	NK_API const nk_rune* nk_font_default_glyph_ranges(void);
	NK_API const nk_rune* nk_font_chinese_glyph_ranges(void);
	NK_API const nk_rune* nk_font_cyrillic_glyph_ranges(void);
	NK_API const nk_rune* nk_font_korean_glyph_ranges(void);

#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR
	NK_API void nk_font_atlas_init_default(struct nk_font_atlas*);
#endif
	NK_API void nk_font_atlas_init(struct nk_font_atlas*, struct nk_allocator*);
	NK_API void nk_font_atlas_init_custom(struct nk_font_atlas*, struct nk_allocator* persistent, struct nk_allocator* transient);
	NK_API void nk_font_atlas_begin(struct nk_font_atlas*);
	NK_API struct nk_font_config nk_font_config(float pixel_height);
	NK_API struct nk_font* nk_font_atlas_add(struct nk_font_atlas*, const struct nk_font_config*);
#ifdef NK_INCLUDE_DEFAULT_FONT
	NK_API struct nk_font* nk_font_atlas_add_default(struct nk_font_atlas*, float height, const struct nk_font_config*);
#endif
	NK_API struct nk_font* nk_font_atlas_add_from_memory(struct nk_font_atlas* atlas, void* memory, nk_size size, float height, const struct nk_font_config* config);
#ifdef NK_INCLUDE_STANDARD_IO
	NK_API struct nk_font* nk_font_atlas_add_from_file(struct nk_font_atlas* atlas, const char* file_path, float height, const struct nk_font_config*);
#endif
	NK_API struct nk_font* nk_font_atlas_add_compressed(struct nk_font_atlas*, void* memory, nk_size size, float height, const struct nk_font_config*);
	NK_API struct nk_font* nk_font_atlas_add_compressed_base85(struct nk_font_atlas*, const char* data, float height, const struct nk_font_config* config);
	NK_API const void* nk_font_atlas_bake(struct nk_font_atlas*, int* width, int* height, enum nk_font_atlas_format);
	NK_API void nk_font_atlas_end(struct nk_font_atlas*, nk_handle tex, struct nk_draw_null_texture*);
	NK_API const struct nk_font_glyph* nk_font_find_glyph(struct nk_font*, nk_rune unicode);
	NK_API void nk_font_atlas_cleanup(struct nk_font_atlas* atlas);
	NK_API void nk_font_atlas_clear(struct nk_font_atlas*);

#endif

	/* ==============================================================
	 *
	 *                          MEMORY BUFFER
	 *
	 * ===============================================================*/
	 /*  A basic (double)-buffer with linear allocation and resetting as only
		 freeing policy. The buffer's main purpose is to control all memory management
		 inside the GUI toolkit and still leave memory control as much as possible in
		 the hand of the user while also making sure the library is easy to use if
		 not as much control is needed.
		 In general all memory inside this library can be provided from the user in
		 three different ways.

		 The first way and the one providing most control is by just passing a fixed
		 size memory block. In this case all control lies in the hand of the user
		 since he can exactly control where the memory comes from and how much memory
		 the library should consume. Of course using the fixed size API removes the
		 ability to automatically resize a buffer if not enough memory is provided so
		 you have to take over the resizing. While being a fixed sized buffer sounds
		 quite limiting, it is very effective in this library since the actual memory
		 consumption is quite stable and has a fixed upper bound for a lot of cases.

		 If you don't want to think about how much memory the library should allocate
		 at all time or have a very dynamic UI with unpredictable memory consumption
		 habits but still want control over memory allocation you can use the dynamic
		 allocator based API. The allocator consists of two callbacks for allocating
		 and freeing memory and optional userdata so you can plugin your own allocator.

		 The final and easiest way can be used by defining
		 NK_INCLUDE_DEFAULT_ALLOCATOR which uses the standard library memory
		 allocation functions malloc and free and takes over complete control over
		 memory in this library.
	 */
	struct nk_memory_status {
		void* memory;
		unsigned int type;
		nk_size size;
		nk_size allocated;
		nk_size needed;
		nk_size calls;
	};

	enum nk_allocation_type {
		NK_BUFFER_FIXED, NK_BUFFER_DYNAMIC
	};

	enum nk_buffer_allocation_type {
		NK_BUFFER_FRONT, NK_BUFFER_BACK, NK_BUFFER_MAX
	};

	struct nk_buffer_marker {
		int active;
		nk_size offset;
	};

	struct nk_memory {
		void* ptr;
		nk_size size;
	};
	struct nk_buffer {
		struct nk_buffer_marker marker[NK_BUFFER_MAX];
		/* buffer marker to free a buffer to a certain offset */
		struct nk_allocator pool;
		/* allocator callback for dynamic buffers */
		enum nk_allocation_type type;
		/* memory management type */
		struct nk_memory memory;
		/* memory and size of the current memory block */
		float grow_factor;
		/* growing factor for dynamic memory management */
		nk_size allocated;
		/* total amount of memory allocated */
		nk_size needed;
		/* totally consumed memory given that enough memory is present */
		nk_size calls;
		/* number of allocation calls */
		nk_size size;
		/* current size of the buffer */
	};

#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

	NK_API void nk_buffer_init_default(struct nk_buffer*);

#endif

	NK_API void nk_buffer_init(struct nk_buffer*, const struct nk_allocator*, nk_size size);

	NK_API void nk_buffer_init_fixed(struct nk_buffer*, void* memory, nk_size size);

	NK_API void nk_buffer_info(struct nk_memory_status*, struct nk_buffer*);

	NK_API void nk_buffer_push(struct nk_buffer*, enum nk_buffer_allocation_type type, const void* memory, nk_size size,
		nk_size align);

	NK_API void nk_buffer_mark(struct nk_buffer*, enum nk_buffer_allocation_type type);

	NK_API void nk_buffer_reset(struct nk_buffer*, enum nk_buffer_allocation_type type);

	NK_API void nk_buffer_clear(struct nk_buffer*);

	NK_API void nk_buffer_free(struct nk_buffer*);

	NK_API void* nk_buffer_memory(struct nk_buffer*);

	NK_API const void* nk_buffer_memory_const(const struct nk_buffer*);

	NK_API nk_size nk_buffer_total(struct nk_buffer*);

	/* ==============================================================
	 *
	 *                          STRING
	 *
	 * ===============================================================*/
	 /*  Basic string buffer which is only used in context with the text editor
	  *  to manage and manipulate dynamic or fixed size string content. This is _NOT_
	  *  the default string handling method. The only instance you should have any contact
	  *  with this API is if you interact with an `nk_text_edit` object inside one of the
	  *  copy and paste functions and even there only for more advanced cases. */
	struct nk_str {
		struct nk_buffer buffer;
		int len; /* in codepoints/runes/glyphs */
	};

#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

	NK_API void nk_str_init_default(struct nk_str*);

#endif

	NK_API void nk_str_init(struct nk_str*, const struct nk_allocator*, nk_size size);

	NK_API void nk_str_init_fixed(struct nk_str*, void* memory, nk_size size);

	NK_API void nk_str_clear(struct nk_str*);

	NK_API void nk_str_free(struct nk_str*);

	NK_API int nk_str_append_text_char(struct nk_str*, const char*, int);

	NK_API int nk_str_append_str_char(struct nk_str*, const char*);

	NK_API int nk_str_append_text_utf8(struct nk_str*, const char*, int);

	NK_API int nk_str_append_str_utf8(struct nk_str*, const char*);

	NK_API int nk_str_append_text_runes(struct nk_str*, const nk_rune*, int);

	NK_API int nk_str_append_str_runes(struct nk_str*, const nk_rune*);

	NK_API int nk_str_insert_at_char(struct nk_str*, int pos, const char*, int);

	NK_API int nk_str_insert_at_rune(struct nk_str*, int pos, const char*, int);

	NK_API int nk_str_insert_text_char(struct nk_str*, int pos, const char*, int);

	NK_API int nk_str_insert_str_char(struct nk_str*, int pos, const char*);

	NK_API int nk_str_insert_text_utf8(struct nk_str*, int pos, const char*, int);

	NK_API int nk_str_insert_str_utf8(struct nk_str*, int pos, const char*);

	NK_API int nk_str_insert_text_runes(struct nk_str*, int pos, const nk_rune*, int);

	NK_API int nk_str_insert_str_runes(struct nk_str*, int pos, const nk_rune*);

	NK_API void nk_str_remove_chars(struct nk_str*, int len);

	NK_API void nk_str_remove_runes(struct nk_str* str, int len);

	NK_API void nk_str_delete_chars(struct nk_str*, int pos, int len);

	NK_API void nk_str_delete_runes(struct nk_str*, int pos, int len);

	NK_API char* nk_str_at_char(struct nk_str*, int pos);

	NK_API char* nk_str_at_rune(struct nk_str*, int pos, nk_rune* unicode, int* len);

	NK_API nk_rune nk_str_rune_at(const struct nk_str*, int pos);

	NK_API const char* nk_str_at_char_const(const struct nk_str*, int pos);

	NK_API const char* nk_str_at_const(const struct nk_str*, int pos, nk_rune* unicode, int* len);

	NK_API char* nk_str_get(struct nk_str*);

	NK_API const char* nk_str_get_const(const struct nk_str*);

	NK_API int nk_str_len(struct nk_str*);

	NK_API int nk_str_len_char(struct nk_str*);

	/*===============================================================
	 *
	 *                      TEXT EDITOR
	 *
	 * ===============================================================*/
	 /* Editing text in this library is handled by either `nk_edit_string` or
	  * `nk_edit_buffer`. But like almost everything in this library there are multiple
	  * ways of doing it and a balance between control and ease of use with memory
	  * as well as functionality controlled by flags.
	  *
	  * This library generally allows three different levels of memory control:
	  * First of is the most basic way of just providing a simple char array with
	  * string length. This method is probably the easiest way of handling simple
	  * user text input. Main upside is complete control over memory while the biggest
	  * downside in comparison with the other two approaches is missing undo/redo.
	  *
	  * For UIs that require undo/redo the second way was created. It is based on
	  * a fixed size nk_text_edit struct, which has an internal undo/redo stack.
	  * This is mainly useful if you want something more like a text editor but don't want
	  * to have a dynamically growing buffer.
	  *
	  * The final way is using a dynamically growing nk_text_edit struct, which
	  * has both a default version if you don't care where memory comes from and an
	  * allocator version if you do. While the text editor is quite powerful for its
	  * complexity I would not recommend editing gigabytes of data with it.
	  * It is rather designed for uses cases which make sense for a GUI library not for
	  * an full blown text editor.
	  */
#ifndef NK_TEXTEDIT_UNDOSTATECOUNT
#define NK_TEXTEDIT_UNDOSTATECOUNT     99
#endif

#ifndef NK_TEXTEDIT_UNDOCHARCOUNT
#define NK_TEXTEDIT_UNDOCHARCOUNT      999
#endif

	struct nk_text_edit;
	struct nk_clipboard {
		nk_handle userdata;
		nk_plugin_paste paste;
		nk_plugin_copy copy;
	};

	struct nk_text_undo_record {
		int where;
		short insert_length;
		short delete_length;
		short char_storage;
	};

	struct nk_text_undo_state {
		struct nk_text_undo_record undo_rec[NK_TEXTEDIT_UNDOSTATECOUNT];
		nk_rune undo_char[NK_TEXTEDIT_UNDOCHARCOUNT];
		short undo_point;
		short redo_point;
		short undo_char_point;
		short redo_char_point;
	};

	enum nk_text_edit_type {
		NK_TEXT_EDIT_SINGLE_LINE, NK_TEXT_EDIT_MULTI_LINE
	};

	enum nk_text_edit_mode {
		NK_TEXT_EDIT_MODE_VIEW, NK_TEXT_EDIT_MODE_INSERT, NK_TEXT_EDIT_MODE_REPLACE
	};

	struct nk_text_edit {
		struct nk_clipboard clip;
		struct nk_str string;
		nk_plugin_filter filter;
		struct nk_vec2 scrollbar;

		int cursor;
		int select_start;
		int select_end;
		unsigned char mode;
		unsigned char cursor_at_end_of_line;
		unsigned char initialized;
		unsigned char has_preferred_x;
		unsigned char single_line;
		unsigned char active;
		unsigned char padding1;
		float preferred_x;
		struct nk_text_undo_state undo;
	};

	/* filter function */
	NK_API int nk_filter_default(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_ascii(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_float(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_decimal(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_hex(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_oct(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_binary(const struct nk_text_edit*, nk_rune unicode);

	/* text editor */
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

	NK_API void nk_textedit_init_default(struct nk_text_edit*);

#endif

	NK_API void nk_textedit_init(struct nk_text_edit*, struct nk_allocator*, nk_size size);

	NK_API void nk_textedit_init_fixed(struct nk_text_edit*, void* memory, nk_size size);

	NK_API void nk_textedit_free(struct nk_text_edit*);

	NK_API void nk_textedit_text(struct nk_text_edit*, const char*, int total_len);

	NK_API void nk_textedit_delete(struct nk_text_edit*, int where, int len);

	NK_API void nk_textedit_delete_selection(struct nk_text_edit*);

	NK_API void nk_textedit_select_all(struct nk_text_edit*);

	NK_API int nk_textedit_cut(struct nk_text_edit*);

	NK_API int nk_textedit_paste(struct nk_text_edit*, char const*, int len);

	NK_API void nk_textedit_undo(struct nk_text_edit*);

	NK_API void nk_textedit_redo(struct nk_text_edit*);

	/* ===============================================================
	 *
	 *                          DRAWING
	 *
	 * ===============================================================*/
	 /*  This library was designed to be render backend agnostic so it does
		 not draw anything to screen. Instead all drawn shapes, widgets
		 are made of, are buffered into memory and make up a command queue.
		 Each frame therefore fills the command buffer with draw commands
		 that then need to be executed by the user and his own render backend.
		 After that the command buffer needs to be cleared and a new frame can be
		 started. It is probably important to note that the command buffer is the main
		 drawing API and the optional vertex buffer API only takes this format and
		 converts it into a hardware accessible format.

		 To use the command queue to draw your own widgets you can access the
		 command buffer of each window by calling `nk_window_get_canvas` after
		 previously having called `nk_begin`:

			 void draw_red_rectangle_widget(struct nk_context *ctx)
			 {
				 struct nk_command_buffer *canvas;
				 struct nk_input *input = &ctx->input;
				 canvas = nk_window_get_canvas(ctx);

				 struct nk_rect space;
				 enum nk_widget_layout_states state;
				 state = nk_widget(&space, ctx);
				 if (!state) return;

				 if (state != NK_WIDGET_ROM)
					 update_your_widget_by_user_input(...);
				 nk_fill_rect(canvas, space, 0, nk_rgb(255,0,0));
			 }

			 if (nk_begin(...)) {
				 nk_layout_row_dynamic(ctx, 25, 1);
				 draw_red_rectangle_widget(ctx);
			 }
			 nk_end(..)

		 Important to know if you want to create your own widgets is the `nk_widget`
		 call. It allocates space on the panel reserved for this widget to be used,
		 but also returns the state of the widget space. If your widget is not seen and does
		 not have to be updated it is '0' and you can just return. If it only has
		 to be drawn the state will be `NK_WIDGET_ROM` otherwise you can do both
		 update and draw your widget. The reason for separating is to only draw and
		 update what is actually necessary which is crucial for performance.
	 */
	enum nk_command_type {
		NK_COMMAND_NOP,
		NK_COMMAND_SCISSOR,
		NK_COMMAND_LINE,
		NK_COMMAND_CURVE,
		NK_COMMAND_RECT,
		NK_COMMAND_RECT_FILLED,
		NK_COMMAND_RECT_MULTI_COLOR,
		NK_COMMAND_CIRCLE,
		NK_COMMAND_CIRCLE_FILLED,
		NK_COMMAND_ARC,
		NK_COMMAND_ARC_FILLED,
		NK_COMMAND_TRIANGLE,
		NK_COMMAND_TRIANGLE_FILLED,
		NK_COMMAND_POLYGON,
		NK_COMMAND_POLYGON_FILLED,
		NK_COMMAND_POLYLINE,
		NK_COMMAND_TEXT,
		NK_COMMAND_IMAGE,
		NK_COMMAND_CUSTOM
	};

	/* command base and header of every command inside the buffer */
	struct nk_command {
		enum nk_command_type type;
		nk_size next;
#ifdef NK_INCLUDE_COMMAND_USERDATA
		nk_handle userdata;
#endif
	};

	struct nk_command_scissor {
		struct nk_command header;
		short x, y;
		unsigned short w, h;
	};

	struct nk_command_line {
		struct nk_command header;
		unsigned short line_thickness;
		struct nk_vec2i begin;
		struct nk_vec2i end;
		struct nk_color color;
	};

	struct nk_command_curve {
		struct nk_command header;
		unsigned short line_thickness;
		struct nk_vec2i begin;
		struct nk_vec2i end;
		struct nk_vec2i ctrl[2];
		struct nk_color color;
	};

	struct nk_command_rect {
		struct nk_command header;
		unsigned short rounding;
		unsigned short line_thickness;
		short x, y;
		unsigned short w, h;
		struct nk_color color;
	};

	struct nk_command_rect_filled {
		struct nk_command header;
		unsigned short rounding;
		short x, y;
		unsigned short w, h;
		struct nk_color color;
	};

	struct nk_command_rect_multi_color {
		struct nk_command header;
		short x, y;
		unsigned short w, h;
		struct nk_color left;
		struct nk_color top;
		struct nk_color bottom;
		struct nk_color right;
	};

	struct nk_command_triangle {
		struct nk_command header;
		unsigned short line_thickness;
		struct nk_vec2i a;
		struct nk_vec2i b;
		struct nk_vec2i c;
		struct nk_color color;
	};

	struct nk_command_triangle_filled {
		struct nk_command header;
		struct nk_vec2i a;
		struct nk_vec2i b;
		struct nk_vec2i c;
		struct nk_color color;
	};

	struct nk_command_circle {
		struct nk_command header;
		short x, y;
		unsigned short line_thickness;
		unsigned short w, h;
		struct nk_color color;
	};

	struct nk_command_circle_filled {
		struct nk_command header;
		short x, y;
		unsigned short w, h;
		struct nk_color color;
	};

	struct nk_command_arc {
		struct nk_command header;
		short cx, cy;
		unsigned short r;
		unsigned short line_thickness;
		float a[2];
		struct nk_color color;
	};

	struct nk_command_arc_filled {
		struct nk_command header;
		short cx, cy;
		unsigned short r;
		float a[2];
		struct nk_color color;
	};

	struct nk_command_polygon {
		struct nk_command header;
		struct nk_color color;
		unsigned short line_thickness;
		unsigned short point_count;
		struct nk_vec2i points[1];
	};

	struct nk_command_polygon_filled {
		struct nk_command header;
		struct nk_color color;
		unsigned short point_count;
		struct nk_vec2i points[1];
	};

	struct nk_command_polyline {
		struct nk_command header;
		struct nk_color color;
		unsigned short line_thickness;
		unsigned short point_count;
		struct nk_vec2i points[1];
	};

	struct nk_command_image {
		struct nk_command header;
		short x, y;
		unsigned short w, h;
		struct nk_image img;
		struct nk_color col;
	};

	typedef void (*nk_command_custom_callback)(void* canvas, short x, short y, unsigned short w, unsigned short h,
		nk_handle callback_data);

	struct nk_command_custom {
		struct nk_command header;
		short x, y;
		unsigned short w, h;
		nk_handle callback_data;
		nk_command_custom_callback callback;
	};

	struct nk_command_text {
		struct nk_command header;
		const struct nk_user_font* font;
		struct nk_color background;
		struct nk_color foreground;
		short x, y;
		unsigned short w, h;
		float height;
		int length;
		char string[1];
	};

	enum nk_command_clipping {
		NK_CLIPPING_OFF = nk_false, NK_CLIPPING_ON = nk_true
	};

	struct nk_command_buffer {
		struct nk_buffer* base;
		struct nk_rect clip;
		int use_clipping;
		nk_handle userdata;
		nk_size begin, end, last;
	};

	/* shape outlines */
	NK_API void nk_stroke_line(struct nk_command_buffer* b, float x0, float y0, float x1, float y1, float line_thickness,
		struct nk_color);

	NK_API void nk_stroke_curve(struct nk_command_buffer*, float, float, float, float, float, float, float, float,
		float line_thickness, struct nk_color);

	NK_API void
		nk_stroke_rect(struct nk_command_buffer*, struct nk_rect, float rounding, float line_thickness, struct nk_color);

	NK_API void nk_stroke_circle(struct nk_command_buffer*, struct nk_rect, float line_thickness, struct nk_color);

	NK_API void nk_stroke_arc(struct nk_command_buffer*, float cx, float cy, float radius, float a_min, float a_max,
		float line_thickness, struct nk_color);

	NK_API void
		nk_stroke_triangle(struct nk_command_buffer*, float, float, float, float, float, float, float line_thichness,
			struct nk_color);

	NK_API void nk_stroke_polyline(struct nk_command_buffer*, float* points, int point_count, float line_thickness,
		struct nk_color col);

	NK_API void
		nk_stroke_polygon(struct nk_command_buffer*, float*, int point_count, float line_thickness, struct nk_color);

	/* filled shades */
	NK_API void nk_fill_rect(struct nk_command_buffer*, struct nk_rect, float rounding, struct nk_color);

	NK_API void
		nk_fill_rect_multi_color(struct nk_command_buffer*, struct nk_rect, struct nk_color left, struct nk_color top,
			struct nk_color right, struct nk_color bottom);

	NK_API void nk_fill_circle(struct nk_command_buffer*, struct nk_rect, struct nk_color);

	NK_API void
		nk_fill_arc(struct nk_command_buffer*, float cx, float cy, float radius, float a_min, float a_max, struct nk_color);

	NK_API void nk_fill_triangle(struct nk_command_buffer*, float x0, float y0, float x1, float y1, float x2, float y2,
		struct nk_color);

	NK_API void nk_fill_polygon(struct nk_command_buffer*, float*, int point_count, struct nk_color);

	/* misc */
	NK_API void nk_draw_image(struct nk_command_buffer*, struct nk_rect, const struct nk_image*, struct nk_color);

	NK_API void
		nk_draw_text(struct nk_command_buffer*, struct nk_rect, const char* text, int len, const struct nk_user_font*,
			struct nk_color, struct nk_color);

	NK_API void nk_push_scissor(struct nk_command_buffer*, struct nk_rect);

	NK_API void nk_push_custom(struct nk_command_buffer*, struct nk_rect, nk_command_custom_callback, nk_handle usr);

	/* ===============================================================
	 *
	 *                          INPUT
	 *
	 * ===============================================================*/
	struct nk_mouse_button {
		int down;
		unsigned int clicked;
		struct nk_vec2 clicked_pos;
	};
	struct nk_mouse {
		struct nk_mouse_button buttons[NK_BUTTON_MAX];
		struct nk_vec2 pos;
		struct nk_vec2 prev;
		struct nk_vec2 delta;
		struct nk_vec2 scroll_delta;
		unsigned char grab;
		unsigned char grabbed;
		unsigned char ungrab;
	};

	struct nk_key {
		int down;
		unsigned int clicked;
	};
	struct nk_keyboard {
		struct nk_key keys[NK_KEY_MAX];
		char text[NK_INPUT_MAX];
		int text_len;
	};

	struct nk_input {
		struct nk_keyboard keyboard;
		struct nk_mouse mouse;
	};

	NK_API int nk_input_has_mouse_click(const struct nk_input*, enum nk_buttons);

	NK_API int nk_input_has_mouse_click_in_rect(const struct nk_input*, enum nk_buttons, struct nk_rect);

	NK_API int nk_input_has_mouse_click_down_in_rect(const struct nk_input*, enum nk_buttons, struct nk_rect, int down);

	NK_API int nk_input_is_mouse_click_in_rect(const struct nk_input*, enum nk_buttons, struct nk_rect);

	NK_API int
		nk_input_is_mouse_click_down_in_rect(const struct nk_input* i, enum nk_buttons id, struct nk_rect b, int down);

	NK_API int nk_input_any_mouse_click_in_rect(const struct nk_input*, struct nk_rect);

	NK_API int nk_input_is_mouse_prev_hovering_rect(const struct nk_input*, struct nk_rect);

	NK_API int nk_input_is_mouse_hovering_rect(const struct nk_input*, struct nk_rect);

	NK_API int nk_input_mouse_clicked(const struct nk_input*, enum nk_buttons, struct nk_rect);

	NK_API int nk_input_is_mouse_down(const struct nk_input*, enum nk_buttons);

	NK_API int nk_input_is_mouse_pressed(const struct nk_input*, enum nk_buttons);

	NK_API int nk_input_is_mouse_released(const struct nk_input*, enum nk_buttons);

	NK_API int nk_input_is_key_pressed(const struct nk_input*, enum nk_keys);

	NK_API int nk_input_is_key_released(const struct nk_input*, enum nk_keys);

	NK_API int nk_input_is_key_down(const struct nk_input*, enum nk_keys);

	/* ===============================================================
	 *
	 *                          DRAW LIST
	 *
	 * ===============================================================*/
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
	 /*  The optional vertex buffer draw list provides a 2D drawing context
with antialiasing functionality which takes basic filled or outlined shapes
or a path and outputs vertexes, elements and draw commands.
The actual draw list API is not required to be used directly while using this
library since converting the default library draw command output is done by
just calling `nk_convert` but I decided to still make this library accessible
since it can be useful.

The draw list is based on a path buffering and polygon and polyline
rendering API which allows a lot of ways to draw 2D content to screen.
In fact it is probably more powerful than needed but allows even more crazy
things than this library provides by default.
*/
#ifdef NK_UINT_DRAW_INDEX
	typedef nk_uint nk_draw_index;
#else
	typedef nk_ushort nk_draw_index;
#endif
	enum nk_draw_list_stroke {
		NK_STROKE_OPEN = nk_false,
		/* build up path has no connection back to the beginning */
		NK_STROKE_CLOSED = nk_true
		/* build up path has a connection back to the beginning */
	};

	enum nk_draw_vertex_layout_attribute {
		NK_VERTEX_POSITION,
		NK_VERTEX_COLOR,
		NK_VERTEX_TEXCOORD,
		NK_VERTEX_ATTRIBUTE_COUNT
	};

	enum nk_draw_vertex_layout_format {
		NK_FORMAT_SCHAR,
		NK_FORMAT_SSHORT,
		NK_FORMAT_SINT,
		NK_FORMAT_UCHAR,
		NK_FORMAT_USHORT,
		NK_FORMAT_UINT,
		NK_FORMAT_FLOAT,
		NK_FORMAT_DOUBLE,

		NK_FORMAT_COLOR_BEGIN,
		NK_FORMAT_R8G8B8 = NK_FORMAT_COLOR_BEGIN,
		NK_FORMAT_R16G15B16,
		NK_FORMAT_R32G32B32,

		NK_FORMAT_R8G8B8A8,
		NK_FORMAT_B8G8R8A8,
		NK_FORMAT_R16G15B16A16,
		NK_FORMAT_R32G32B32A32,
		NK_FORMAT_R32G32B32A32_FLOAT,
		NK_FORMAT_R32G32B32A32_DOUBLE,

		NK_FORMAT_RGB32,
		NK_FORMAT_RGBA32,
		NK_FORMAT_COLOR_END = NK_FORMAT_RGBA32,
		NK_FORMAT_COUNT
	};

#define NK_VERTEX_LAYOUT_END NK_VERTEX_ATTRIBUTE_COUNT,NK_FORMAT_COUNT,0
	struct nk_draw_vertex_layout_element {
		enum nk_draw_vertex_layout_attribute attribute;
		enum nk_draw_vertex_layout_format format;
		nk_size offset;
	};

	struct nk_draw_command {
		unsigned int elem_count;
		/* number of elements in the current draw batch */
		struct nk_rect clip_rect;
		/* current screen clipping rectangle */
		nk_handle texture;
		/* current texture to set */
#ifdef NK_INCLUDE_COMMAND_USERDATA
		nk_handle userdata;
#endif
	};

	struct nk_draw_list {
		struct nk_rect clip_rect;
		struct nk_vec2 circle_vtx[12];
		struct nk_convert_config config;

		struct nk_buffer* buffer;
		struct nk_buffer* vertices;
		struct nk_buffer* elements;

		unsigned int element_count;
		unsigned int vertex_count;
		unsigned int cmd_count;
		nk_size cmd_offset;

		unsigned int path_count;
		unsigned int path_offset;

		enum nk_anti_aliasing line_AA;
		enum nk_anti_aliasing shape_AA;

#ifdef NK_INCLUDE_COMMAND_USERDATA
		nk_handle userdata;
#endif
	};

	/* draw list */
	NK_API void nk_draw_list_init(struct nk_draw_list*);
	NK_API void nk_draw_list_setup(struct nk_draw_list*, const struct nk_convert_config*, struct nk_buffer* cmds, struct nk_buffer* vertices, struct nk_buffer* elements, enum nk_anti_aliasing line_aa, enum nk_anti_aliasing shape_aa);

	/* drawing */
#define nk_draw_list_foreach(cmd, can, b) for((cmd)=nk__draw_list_begin(can, b); (cmd)!=0; (cmd)=nk__draw_list_next(cmd, b, can))
	NK_API const struct nk_draw_command* nk__draw_list_begin(const struct nk_draw_list*, const struct nk_buffer*);
	NK_API const struct nk_draw_command* nk__draw_list_next(const struct nk_draw_command*, const struct nk_buffer*, const struct nk_draw_list*);
	NK_API const struct nk_draw_command* nk__draw_list_end(const struct nk_draw_list*, const struct nk_buffer*);

	/* path */
	NK_API void nk_draw_list_path_clear(struct nk_draw_list*);
	NK_API void nk_draw_list_path_line_to(struct nk_draw_list*, struct nk_vec2 pos);
	NK_API void nk_draw_list_path_arc_to_fast(struct nk_draw_list*, struct nk_vec2 center, float radius, int a_min, int a_max);
	NK_API void nk_draw_list_path_arc_to(struct nk_draw_list*, struct nk_vec2 center, float radius, float a_min, float a_max, unsigned int segments);
	NK_API void nk_draw_list_path_rect_to(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, float rounding);
	NK_API void nk_draw_list_path_curve_to(struct nk_draw_list*, struct nk_vec2 p2, struct nk_vec2 p3, struct nk_vec2 p4, unsigned int num_segments);
	NK_API void nk_draw_list_path_fill(struct nk_draw_list*, struct nk_color);
	NK_API void nk_draw_list_path_stroke(struct nk_draw_list*, struct nk_color, enum nk_draw_list_stroke closed, float thickness);

	/* stroke */
	NK_API void nk_draw_list_stroke_line(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, struct nk_color, float thickness);
	NK_API void nk_draw_list_stroke_rect(struct nk_draw_list*, struct nk_rect rect, struct nk_color, float rounding, float thickness);
	NK_API void nk_draw_list_stroke_triangle(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, struct nk_vec2 c, struct nk_color, float thickness);
	NK_API void nk_draw_list_stroke_circle(struct nk_draw_list*, struct nk_vec2 center, float radius, struct nk_color, unsigned int segs, float thickness);
	NK_API void nk_draw_list_stroke_curve(struct nk_draw_list*, struct nk_vec2 p0, struct nk_vec2 cp0, struct nk_vec2 cp1, struct nk_vec2 p1, struct nk_color, unsigned int segments, float thickness);
	NK_API void nk_draw_list_stroke_poly_line(struct nk_draw_list*, const struct nk_vec2* pnts, const unsigned int cnt, struct nk_color, enum nk_draw_list_stroke, float thickness, enum nk_anti_aliasing);

	/* fill */
	NK_API void nk_draw_list_fill_rect(struct nk_draw_list*, struct nk_rect rect, struct nk_color, float rounding);
	NK_API void nk_draw_list_fill_rect_multi_color(struct nk_draw_list*, struct nk_rect rect, struct nk_color left, struct nk_color top, struct nk_color right, struct nk_color bottom);
	NK_API void nk_draw_list_fill_triangle(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, struct nk_vec2 c, struct nk_color);
	NK_API void nk_draw_list_fill_circle(struct nk_draw_list*, struct nk_vec2 center, float radius, struct nk_color col, unsigned int segs);
	NK_API void nk_draw_list_fill_poly_convex(struct nk_draw_list*, const struct nk_vec2* points, const unsigned int count, struct nk_color, enum nk_anti_aliasing);

	/* misc */
	NK_API void nk_draw_list_add_image(struct nk_draw_list*, struct nk_image texture, struct nk_rect rect, struct nk_color);
	NK_API void nk_draw_list_add_text(struct nk_draw_list*, const struct nk_user_font*, struct nk_rect, const char* text, int len, float font_height, struct nk_color);
#ifdef NK_INCLUDE_COMMAND_USERDATA
	NK_API void nk_draw_list_push_userdata(struct nk_draw_list*, nk_handle userdata);
#endif

#endif

	/* ===============================================================
	 *
	 *                          GUI
	 *
	 * ===============================================================*/
	enum nk_style_item_type {
		NK_STYLE_ITEM_COLOR, NK_STYLE_ITEM_IMAGE
	};

	union nk_style_item_data {
		struct nk_image image;
		struct nk_color color;
	};

	struct nk_style_item {
		enum nk_style_item_type type;
		union nk_style_item_data data;
	};

	struct nk_style_text {
		struct nk_color color;
		struct nk_vec2 padding;
	};

	struct nk_style_button {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* text */
		struct nk_color text_background;
		struct nk_color text_normal;
		struct nk_color text_hover;
		struct nk_color text_active;
		nk_flags text_alignment;

		/* properties */
		float border;
		float rounding;
		struct nk_vec2 padding;
		struct nk_vec2 image_padding;
		struct nk_vec2 touch_padding;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle userdata);

		void (*draw_end)(struct nk_command_buffer*, nk_handle userdata);
	};

	struct nk_style_toggle {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* cursor */
		struct nk_style_item cursor_normal;
		struct nk_style_item cursor_hover;

		/* text */
		struct nk_color text_normal;
		struct nk_color text_hover;
		struct nk_color text_active;
		struct nk_color text_background;
		nk_flags text_alignment;

		/* properties */
		struct nk_vec2 padding;
		struct nk_vec2 touch_padding;
		float spacing;
		float border;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_selectable {
		/* background (inactive) */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item pressed;

		/* background (active) */
		struct nk_style_item normal_active;
		struct nk_style_item hover_active;
		struct nk_style_item pressed_active;

		/* text color (inactive) */
		struct nk_color text_normal;
		struct nk_color text_hover;
		struct nk_color text_pressed;

		/* text color (active) */
		struct nk_color text_normal_active;
		struct nk_color text_hover_active;
		struct nk_color text_pressed_active;
		struct nk_color text_background;
		nk_flags text_alignment;

		/* properties */
		float rounding;
		struct nk_vec2 padding;
		struct nk_vec2 touch_padding;
		struct nk_vec2 image_padding;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_slider {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* background bar */
		struct nk_color bar_normal;
		struct nk_color bar_hover;
		struct nk_color bar_active;
		struct nk_color bar_filled;

		/* cursor */
		struct nk_style_item cursor_normal;
		struct nk_style_item cursor_hover;
		struct nk_style_item cursor_active;

		/* properties */
		float border;
		float rounding;
		float bar_height;
		struct nk_vec2 padding;
		struct nk_vec2 spacing;
		struct nk_vec2 cursor_size;

		/* optional buttons */
		int show_buttons;
		struct nk_style_button inc_button;
		struct nk_style_button dec_button;
		enum nk_symbol_type inc_symbol;
		enum nk_symbol_type dec_symbol;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_progress {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* cursor */
		struct nk_style_item cursor_normal;
		struct nk_style_item cursor_hover;
		struct nk_style_item cursor_active;
		struct nk_color cursor_border_color;

		/* properties */
		float rounding;
		float border;
		float cursor_border;
		float cursor_rounding;
		struct nk_vec2 padding;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_scrollbar {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* cursor */
		struct nk_style_item cursor_normal;
		struct nk_style_item cursor_hover;
		struct nk_style_item cursor_active;
		struct nk_color cursor_border_color;

		/* properties */
		float border;
		float rounding;
		float border_cursor;
		float rounding_cursor;
		struct nk_vec2 padding;

		/* optional buttons */
		int show_buttons;
		struct nk_style_button inc_button;
		struct nk_style_button dec_button;
		enum nk_symbol_type inc_symbol;
		enum nk_symbol_type dec_symbol;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_edit {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;
		struct nk_style_scrollbar scrollbar;

		/* cursor  */
		struct nk_color cursor_normal;
		struct nk_color cursor_hover;
		struct nk_color cursor_text_normal;
		struct nk_color cursor_text_hover;

		/* text (unselected) */
		struct nk_color text_normal;
		struct nk_color text_hover;
		struct nk_color text_active;

		/* text (selected) */
		struct nk_color selected_normal;
		struct nk_color selected_hover;
		struct nk_color selected_text_normal;
		struct nk_color selected_text_hover;

		/* properties */
		float border;
		float rounding;
		float cursor_size;
		struct nk_vec2 scrollbar_size;
		struct nk_vec2 padding;
		float row_padding;
	};

	struct nk_style_property {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* text */
		struct nk_color label_normal;
		struct nk_color label_hover;
		struct nk_color label_active;

		/* symbols */
		enum nk_symbol_type sym_left;
		enum nk_symbol_type sym_right;

		/* properties */
		float border;
		float rounding;
		struct nk_vec2 padding;

		struct nk_style_edit edit;
		struct nk_style_button inc_button;
		struct nk_style_button dec_button;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_chart {
		/* colors */
		struct nk_style_item background;
		struct nk_color border_color;
		struct nk_color selected_color;
		struct nk_color color;

		/* properties */
		float border;
		float rounding;
		struct nk_vec2 padding;
	};

	struct nk_style_combo {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* label */
		struct nk_color label_normal;
		struct nk_color label_hover;
		struct nk_color label_active;

		/* symbol */
		struct nk_color symbol_normal;
		struct nk_color symbol_hover;
		struct nk_color symbol_active;

		/* button */
		struct nk_style_button button;
		enum nk_symbol_type sym_normal;
		enum nk_symbol_type sym_hover;
		enum nk_symbol_type sym_active;

		/* properties */
		float border;
		float rounding;
		struct nk_vec2 content_padding;
		struct nk_vec2 button_padding;
		struct nk_vec2 spacing;
	};

	struct nk_style_tab {
		/* background */
		struct nk_style_item background;
		struct nk_color border_color;
		struct nk_color text;

		/* button */
		struct nk_style_button tab_maximize_button;
		struct nk_style_button tab_minimize_button;
		struct nk_style_button node_maximize_button;
		struct nk_style_button node_minimize_button;
		enum nk_symbol_type sym_minimize;
		enum nk_symbol_type sym_maximize;

		/* properties */
		float border;
		float rounding;
		float indent;
		struct nk_vec2 padding;
		struct nk_vec2 spacing;
	};

	enum nk_style_header_align {
		NK_HEADER_LEFT, NK_HEADER_RIGHT
	};
	struct nk_style_window_header {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;

		/* button */
		struct nk_style_button close_button;
		struct nk_style_button minimize_button;
		enum nk_symbol_type close_symbol;
		enum nk_symbol_type minimize_symbol;
		enum nk_symbol_type maximize_symbol;

		/* title */
		struct nk_color label_normal;
		struct nk_color label_hover;
		struct nk_color label_active;

		/* properties */
		enum nk_style_header_align align;
		struct nk_vec2 padding;
		struct nk_vec2 label_padding;
		struct nk_vec2 spacing;
	};

	struct nk_style_window {
		struct nk_style_window_header header;
		struct nk_style_item fixed_background;
		struct nk_color background;

		struct nk_color border_color;
		struct nk_color popup_border_color;
		struct nk_color combo_border_color;
		struct nk_color contextual_border_color;
		struct nk_color menu_border_color;
		struct nk_color group_border_color;
		struct nk_color tooltip_border_color;
		struct nk_style_item scaler;

		float border;
		float combo_border;
		float contextual_border;
		float menu_border;
		float group_border;
		float tooltip_border;
		float popup_border;
		float min_row_height_padding;

		float rounding;
		struct nk_vec2 spacing;
		struct nk_vec2 scrollbar_size;
		struct nk_vec2 min_size;

		struct nk_vec2 padding;
		struct nk_vec2 group_padding;
		struct nk_vec2 popup_padding;
		struct nk_vec2 combo_padding;
		struct nk_vec2 contextual_padding;
		struct nk_vec2 menu_padding;
		struct nk_vec2 tooltip_padding;
	};

	struct nk_style {
		const struct nk_user_font* font;
		const struct nk_cursor* cursors[NK_CURSOR_COUNT];
		const struct nk_cursor* cursor_active;
		struct nk_cursor* cursor_last;
		int cursor_visible;

		struct nk_style_text text;
		struct nk_style_button button;
		struct nk_style_button contextual_button;
		struct nk_style_button menu_button;
		struct nk_style_toggle option;
		struct nk_style_toggle checkbox;
		struct nk_style_selectable selectable;
		struct nk_style_slider slider;
		struct nk_style_progress progress;
		struct nk_style_property property;
		struct nk_style_edit edit;
		struct nk_style_chart chart;
		struct nk_style_scrollbar scrollh;
		struct nk_style_scrollbar scrollv;
		struct nk_style_tab tab;
		struct nk_style_combo combo;
		struct nk_style_window window;
	};

	NK_API struct nk_style_item nk_style_item_image(struct nk_image img);

	NK_API struct nk_style_item nk_style_item_color(struct nk_color);

	NK_API struct nk_style_item nk_style_item_hide(void);

	/*==============================================================
	 *                          PANEL
	 * =============================================================*/
#ifndef NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS
#define NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS 16
#endif
#ifndef NK_CHART_MAX_SLOT
#define NK_CHART_MAX_SLOT 4
#endif

	enum nk_panel_type {
		NK_PANEL_NONE = 0,
		NK_PANEL_WINDOW = NK_FLAG(0),
		NK_PANEL_GROUP = NK_FLAG(1),
		NK_PANEL_POPUP = NK_FLAG(2),
		NK_PANEL_CONTEXTUAL = NK_FLAG(4),
		NK_PANEL_COMBO = NK_FLAG(5),
		NK_PANEL_MENU = NK_FLAG(6),
		NK_PANEL_TOOLTIP = NK_FLAG(7)
	};
	enum nk_panel_set {
		NK_PANEL_SET_NONBLOCK = NK_PANEL_CONTEXTUAL | NK_PANEL_COMBO | NK_PANEL_MENU | NK_PANEL_TOOLTIP,
		NK_PANEL_SET_POPUP = NK_PANEL_SET_NONBLOCK | NK_PANEL_POPUP,
		NK_PANEL_SET_SUB = NK_PANEL_SET_POPUP | NK_PANEL_GROUP
	};

	struct nk_chart_slot {
		enum nk_chart_type type;
		struct nk_color color;
		struct nk_color highlight;
		float min, max, range;
		int count;
		struct nk_vec2 last;
		int index;
	};

	struct nk_chart {
		int slot;
		float x, y, w, h;
		struct nk_chart_slot slots[NK_CHART_MAX_SLOT];
	};

	enum nk_panel_row_layout_type {
		NK_LAYOUT_DYNAMIC_FIXED = 0,
		NK_LAYOUT_DYNAMIC_ROW,
		NK_LAYOUT_DYNAMIC_FREE,
		NK_LAYOUT_DYNAMIC,
		NK_LAYOUT_STATIC_FIXED,
		NK_LAYOUT_STATIC_ROW,
		NK_LAYOUT_STATIC_FREE,
		NK_LAYOUT_STATIC,
		NK_LAYOUT_TEMPLATE,
		NK_LAYOUT_COUNT
	};
	struct nk_row_layout {
		enum nk_panel_row_layout_type type;
		int index;
		float height;
		float min_height;
		int columns;
		const float* ratio;
		float item_width;
		float item_height;
		float item_offset;
		float filled;
		struct nk_rect item;
		int tree_depth;
		float templates[NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS];
	};

	struct nk_popup_buffer {
		nk_size begin;
		nk_size parent;
		nk_size last;
		nk_size end;
		int active;
	};

	struct nk_menu_state {
		float x, y, w, h;
		struct nk_scroll offset;
	};

	struct nk_panel {
		enum nk_panel_type type;
		nk_flags flags;
		struct nk_rect bounds;
		nk_uint* offset_x;
		nk_uint* offset_y;
		float at_x, at_y, max_x;
		float footer_height;
		float header_height;
		float border;
		unsigned int has_scrolling;
		struct nk_rect clip;
		struct nk_menu_state menu;
		struct nk_row_layout row;
		struct nk_chart chart;
		struct nk_command_buffer* buffer;
		struct nk_panel* parent;
	};

	/*==============================================================
	 *                          WINDOW
	 * =============================================================*/
#ifndef NK_WINDOW_MAX_NAME
#define NK_WINDOW_MAX_NAME 64
#endif

	struct nk_table;
	enum nk_window_flags {
		NK_WINDOW_PRIVATE = NK_FLAG(11),
		NK_WINDOW_DYNAMIC = NK_WINDOW_PRIVATE,
		/* special window type growing up in height while being filled to a certain maximum height */
		NK_WINDOW_ROM = NK_FLAG(12),
		/* sets window widgets into a read only mode and does not allow input changes */
		NK_WINDOW_NOT_INTERACTIVE = NK_WINDOW_ROM | NK_WINDOW_NO_INPUT,
		/* prevents all interaction caused by input to either window or widgets inside */
		NK_WINDOW_HIDDEN = NK_FLAG(13),
		/* Hides window and stops any window interaction and drawing */
		NK_WINDOW_CLOSED = NK_FLAG(14),
		/* Directly closes and frees the window at the end of the frame */
		NK_WINDOW_MINIMIZED = NK_FLAG(15),
		/* marks the window as minimized */
		NK_WINDOW_REMOVE_ROM = NK_FLAG(16)
		/* Removes read only mode at the end of the window */
	};

	struct nk_popup_state {
		struct nk_window* win;
		enum nk_panel_type type;
		struct nk_popup_buffer buf;
		nk_hash name;
		int active;
		unsigned combo_count;
		unsigned con_count, con_old;
		unsigned active_con;
		struct nk_rect header;
	};

	struct nk_edit_state {
		nk_hash name;
		unsigned int seq;
		unsigned int old;
		int active, prev;
		int cursor;
		int sel_start;
		int sel_end;
		struct nk_scroll scrollbar;
		unsigned char mode;
		unsigned char single_line;
	};

	struct nk_property_state {
		int active, prev;
		char buffer[NK_MAX_NUMBER_BUFFER];
		int length;
		int cursor;
		int select_start;
		int select_end;
		nk_hash name;
		unsigned int seq;
		unsigned int old;
		int state;
	};

	struct nk_window {
		unsigned int seq;
		nk_hash name;
		char name_string[NK_WINDOW_MAX_NAME];
		nk_flags flags;

		struct nk_rect bounds;
		struct nk_scroll scrollbar;
		struct nk_command_buffer buffer;
		struct nk_panel* layout;
		float scrollbar_hiding_timer;

		/* persistent widget state */
		struct nk_property_state property;
		struct nk_popup_state popup;
		struct nk_edit_state edit;
		unsigned int scrolled;

		struct nk_table* tables;
		unsigned int table_count;

		/* window list hooks */
		struct nk_window* next;
		struct nk_window* prev;
		struct nk_window* parent;
	};

	/*==============================================================
	 *                          STACK
	 * =============================================================*/
	 /* The style modifier stack can be used to temporarily change a
	  * property inside `nk_style`. For example if you want a special
	  * red button you can temporarily push the old button color onto a stack
	  * draw the button with a red color and then you just pop the old color
	  * back from the stack:
	  *
	  *      nk_style_push_style_item(ctx, &ctx->style.button.normal, nk_style_item_color(nk_rgb(255,0,0)));
	  *      nk_style_push_style_item(ctx, &ctx->style.button.hover, nk_style_item_color(nk_rgb(255,0,0)));
	  *      nk_style_push_style_item(ctx, &ctx->style.button.active, nk_style_item_color(nk_rgb(255,0,0)));
	  *      nk_style_push_vec2(ctx, &cx->style.button.padding, nk_vec2(2,2));
	  *
	  *      nk_button(...);
	  *
	  *      nk_style_pop_style_item(ctx);
	  *      nk_style_pop_style_item(ctx);
	  *      nk_style_pop_style_item(ctx);
	  *      nk_style_pop_vec2(ctx);
	  *
	  * Nuklear has a stack for style_items, float properties, vector properties,
	  * flags, colors, fonts and for button_behavior. Each has it's own fixed size stack
	  * which can be changed at compile time.
	  */
#ifndef NK_BUTTON_BEHAVIOR_STACK_SIZE
#define NK_BUTTON_BEHAVIOR_STACK_SIZE 8
#endif

#ifndef NK_FONT_STACK_SIZE
#define NK_FONT_STACK_SIZE 8
#endif

#ifndef NK_STYLE_ITEM_STACK_SIZE
#define NK_STYLE_ITEM_STACK_SIZE 16
#endif

#ifndef NK_FLOAT_STACK_SIZE
#define NK_FLOAT_STACK_SIZE 32
#endif

#ifndef NK_VECTOR_STACK_SIZE
#define NK_VECTOR_STACK_SIZE 16
#endif

#ifndef NK_FLAGS_STACK_SIZE
#define NK_FLAGS_STACK_SIZE 32
#endif

#ifndef NK_COLOR_STACK_SIZE
#define NK_COLOR_STACK_SIZE 32
#endif

#define NK_CONFIGURATION_STACK_TYPE(prefix, name, type)\
    struct nk_config_stack_##name##_element {\
        prefix##_##type *address;\
        prefix##_##type old_value;\
    }
#define NK_CONFIG_STACK(type, size)\
    struct nk_config_stack_##type {\
        int head;\
        struct nk_config_stack_##type##_element elements[size];\
    }

#define nk_float float
	NK_CONFIGURATION_STACK_TYPE(struct nk, style_item, style_item);
	NK_CONFIGURATION_STACK_TYPE(nk, float, float);
	NK_CONFIGURATION_STACK_TYPE(struct nk, vec2, vec2);
	NK_CONFIGURATION_STACK_TYPE(nk, flags, flags);
	NK_CONFIGURATION_STACK_TYPE(struct nk, color, color);
	NK_CONFIGURATION_STACK_TYPE(const struct nk, user_font, user_font*);
	NK_CONFIGURATION_STACK_TYPE(enum nk, button_behavior, button_behavior);

	NK_CONFIG_STACK(style_item, NK_STYLE_ITEM_STACK_SIZE);
	NK_CONFIG_STACK(float, NK_FLOAT_STACK_SIZE);
	NK_CONFIG_STACK(vec2, NK_VECTOR_STACK_SIZE);
	NK_CONFIG_STACK(flags, NK_FLAGS_STACK_SIZE);
	NK_CONFIG_STACK(color, NK_COLOR_STACK_SIZE);
	NK_CONFIG_STACK(user_font, NK_FONT_STACK_SIZE);
	NK_CONFIG_STACK(button_behavior, NK_BUTTON_BEHAVIOR_STACK_SIZE);

	struct nk_configuration_stacks {
		struct nk_config_stack_style_item style_items;
		struct nk_config_stack_float floats;
		struct nk_config_stack_vec2 vectors;
		struct nk_config_stack_flags flags;
		struct nk_config_stack_color colors;
		struct nk_config_stack_user_font fonts;
		struct nk_config_stack_button_behavior button_behaviors;
	};

	/*==============================================================
	 *                          CONTEXT
	 * =============================================================*/
#define NK_VALUE_PAGE_CAPACITY \
    (((NK_MAX(sizeof(struct nk_window),sizeof(struct nk_panel)) / sizeof(nk_uint))) / 2)

	struct nk_table {
		unsigned int seq;
		unsigned int size;
		nk_hash keys[NK_VALUE_PAGE_CAPACITY];
		nk_uint values[NK_VALUE_PAGE_CAPACITY];
		struct nk_table* next, * prev;
	};

	union nk_page_data {
		struct nk_table tbl;
		struct nk_panel pan;
		struct nk_window win;
	};

	struct nk_page_element {
		union nk_page_data data;
		struct nk_page_element* next;
		struct nk_page_element* prev;
	};

	struct nk_page {
		unsigned int size;
		struct nk_page* next;
		struct nk_page_element win[1];
	};

	struct nk_pool {
		struct nk_allocator alloc;
		enum nk_allocation_type type;
		unsigned int page_count;
		struct nk_page* pages;
		struct nk_page_element* freelist;
		unsigned capacity;
		nk_size size;
		nk_size cap;
	};

	struct nk_context {
		/* public: can be accessed freely */
		struct nk_input input;
		struct nk_style style;
		struct nk_buffer memory;
		struct nk_clipboard clip;
		nk_flags last_widget_state;
		enum nk_button_behavior button_behavior;
		struct nk_configuration_stacks stacks;
		float delta_time_seconds;

		/* private:
			should only be accessed if you
			know what you are doing */
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
		struct nk_draw_list draw_list;
#endif
#ifdef NK_INCLUDE_COMMAND_USERDATA
		nk_handle userdata;
#endif
		/* text editor objects are quite big because of an internal
		 * undo/redo stack. Therefore it does not make sense to have one for
		 * each window for temporary use cases, so I only provide *one* instance
		 * for all windows. This works because the content is cleared anyway */
		struct nk_text_edit text_edit;
		/* draw buffer used for overlay drawing operation like cursor */
		struct nk_command_buffer overlay;

		/* windows */
		int build;
		int use_pool;
		struct nk_pool pool;
		struct nk_window* begin;
		struct nk_window* end;
		struct nk_window* active;
		struct nk_window* current;
		struct nk_page_element* freelist;
		unsigned int count;
		unsigned int seq;
	};

	/* ==============================================================
	 *                          MATH
	 * =============================================================== */
#define NK_PI 3.141592654f
#define NK_UTF_INVALID 0xFFFD
#define NK_MAX_FLOAT_PRECISION 2

#define NK_UNUSED(x) ((void)(x))
#define NK_SATURATE(x) (NK_MAX(0, NK_MIN(1.0f, x)))
#define NK_LEN(a) (sizeof(a)/sizeof(a)[0])
#define NK_ABS(a) (((a) < 0) ? -(a) : (a))
#define NK_BETWEEN(x, a, b) ((a) <= (x) && (x) < (b))
#define NK_INBOX(px, py, x, y, w, h)\
    (NK_BETWEEN(px,x,x+w) && NK_BETWEEN(py,y,y+h))
#define NK_INTERSECT(x0, y0, w0, h0, x1, y1, w1, h1) \
    (!(((x1 > (x0 + w0)) || ((x1 + w1) < x0) || (y1 > (y0 + h0)) || (y1 + h1) < y0)))
#define NK_CONTAINS(x, y, w, h, bx, by, bw, bh)\
    (NK_INBOX(x,y, bx, by, bw, bh) && NK_INBOX(x+w,y+h, bx, by, bw, bh))

#define nk_vec2_sub(a, b) nk_vec2((a).x - (b).x, (a).y - (b).y)
#define nk_vec2_add(a, b) nk_vec2((a).x + (b).x, (a).y + (b).y)
#define nk_vec2_len_sqr(a) ((a).x*(a).x+(a).y*(a).y)
#define nk_vec2_muls(a, t) nk_vec2((a).x * (t), (a).y * (t))

#define nk_ptr_add(t, p, i) ((t*)((void*)((nk_byte*)(p) + (i))))
#define nk_ptr_add_const(t, p, i) ((const t*)((const void*)((const nk_byte*)(p) + (i))))
#define nk_zero_struct(s) nk_zero(&s, sizeof(s))

	 /* ==============================================================
	  *                          ALIGNMENT
	  * =============================================================== */
	  /* Pointer to Integer type conversion for pointer alignment */
#if defined(__PTRDIFF_TYPE__) /* This case should work for GCC*/
# define NK_UINT_TO_PTR(x) ((void*)(__PTRDIFF_TYPE__)(x))
# define NK_PTR_TO_UINT(x) ((nk_size)(__PTRDIFF_TYPE__)(x))
#elif !defined(__GNUC__) /* works for compilers other than LLVM */
# define NK_UINT_TO_PTR(x) ((void*)&((char*)0)[x])
# define NK_PTR_TO_UINT(x) ((nk_size)(((char*)x)-(char*)0))
#elif defined(NK_USE_FIXED_TYPES) /* used if we have <stdint.h> */
# define NK_UINT_TO_PTR(x) ((void*)(uintptr_t)(x))
# define NK_PTR_TO_UINT(x) ((uintptr_t)(x))
#else /* generates warning but works */
# define NK_UINT_TO_PTR(x) ((void*)(x))
# define NK_PTR_TO_UINT(x) ((nk_size)(x))
#endif

#define NK_ALIGN_PTR(x, mask)\
    (NK_UINT_TO_PTR((NK_PTR_TO_UINT((nk_byte*)(x) + (mask-1)) & ~(mask-1))))
#define NK_ALIGN_PTR_BACK(x, mask)\
    (NK_UINT_TO_PTR((NK_PTR_TO_UINT((nk_byte*)(x)) & ~(mask-1))))

#define NK_OFFSETOF(st, m) ((nk_ptr)&(((st*)0)->m))
#define NK_CONTAINER_OF(ptr, type, member)\
    (type*)((void*)((char*)(1 ? (ptr): &((type*)0)->member) - NK_OFFSETOF(type, member)))

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
template<typename T> struct nk_alignof;
template<typename T, int size_diff> struct nk_helper { enum { value = size_diff }; };
template<typename T> struct nk_helper<T, 0> { enum { value = nk_alignof<T>::value }; };
template<typename T> struct nk_alignof {
	struct Big { T x; char c; }; enum {
		diff = sizeof(Big) - sizeof(T), value = nk_helper<Big, diff>::value
	};
};
#define NK_ALIGNOF(t) (nk_alignof<t>::value)
#elif defined(_MSC_VER)
#define NK_ALIGNOF(t) (__alignof(t))
#else
#define NK_ALIGNOF(t) ((char*)(&((struct {char c; t _h;}*)0)->_h) - (char*)0)
#endif

#endif /* NK_NUKLEAR_H_ */


#ifdef NK_IMPLEMENTATION

#ifndef NK_INTERNAL_H
#define NK_INTERNAL_H

#ifndef NK_POOL_DEFAULT_CAPACITY
#define NK_POOL_DEFAULT_CAPACITY 16
#endif

#ifndef NK_DEFAULT_COMMAND_BUFFER_SIZE
#define NK_DEFAULT_COMMAND_BUFFER_SIZE (4*1024)
#endif

#ifndef NK_BUFFER_DEFAULT_INITIAL_SIZE
#define NK_BUFFER_DEFAULT_INITIAL_SIZE (4*1024)
#endif

/* standard library headers */
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

#include <stdlib.h> /* malloc, free */

#endif
#ifdef NK_INCLUDE_STANDARD_IO

#include <stdio.h> /* fopen, fclose,... */

#endif
#ifdef NK_INCLUDE_STANDARD_VARARGS

#include <stdarg.h> /* valist, va_start, va_end, ... */

#endif
#ifndef NK_ASSERT

#include <assert.h>

#define NK_ASSERT(expr) assert(expr)
#endif

#ifndef NK_MEMSET
#define NK_MEMSET nk_memset
#endif
#ifndef NK_MEMCPY
#define NK_MEMCPY nk_memcopy
#endif
#ifndef NK_SQRT
#define NK_SQRT nk_sqrt
#endif
#ifndef NK_SIN
#define NK_SIN nk_sin
#endif
#ifndef NK_COS
#define NK_COS nk_cos
#endif
#ifndef NK_STRTOD
#define NK_STRTOD nk_strtod
#endif
#ifndef NK_DTOA
#define NK_DTOA nk_dtoa
#endif

#define NK_DEFAULT (-1)

#ifndef NK_VSNPRINTF
/* If your compiler does support `vsnprintf` I would highly recommend
 * defining this to vsnprintf instead since `vsprintf` is basically
 * unbelievable unsafe and should *NEVER* be used. But I have to support
 * it since C89 only provides this unsafe version. */
#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
      (defined(__cplusplus) && (__cplusplus >= 201103L)) || \
      (defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE >= 200112L)) || \
      (defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE >= 500)) || \
       defined(_ISOC99_SOURCE) || defined(_BSD_SOURCE)
#define NK_VSNPRINTF(s, n, f, a) vsnprintf(s,n,f,a)
#else
#define NK_VSNPRINTF(s,n,f,a) vsprintf(s,f,a)
#endif
#endif

#define NK_SCHAR_MIN (-127)
#define NK_SCHAR_MAX 127
#define NK_UCHAR_MIN 0
#define NK_UCHAR_MAX 256
#define NK_SSHORT_MIN (-32767)
#define NK_SSHORT_MAX 32767
#define NK_USHORT_MIN 0
#define NK_USHORT_MAX 65535
#define NK_SINT_MIN (-2147483647)
#define NK_SINT_MAX 2147483647
#define NK_UINT_MIN 0
#define NK_UINT_MAX 4294967295u

 /* Make sure correct type size:
  * This will fire with a negative subscript error if the type sizes
  * are set incorrectly by the compiler, and compile out if not */
NK_STATIC_ASSERT(sizeof(nk_size) >= sizeof(void*));
NK_STATIC_ASSERT(sizeof(nk_ptr) == sizeof(void*));
NK_STATIC_ASSERT(sizeof(nk_flags) >= 4);
NK_STATIC_ASSERT(sizeof(nk_rune) >= 4);
NK_STATIC_ASSERT(sizeof(nk_ushort) == 2);
NK_STATIC_ASSERT(sizeof(nk_short) == 2);
NK_STATIC_ASSERT(sizeof(nk_uint) == 4);
NK_STATIC_ASSERT(sizeof(nk_int) == 4);
NK_STATIC_ASSERT(sizeof(nk_byte) == 1);

NK_GLOBAL const struct nk_rect nk_null_rect = { -8192.0f, -8192.0f, 16384, 16384 };
#define NK_FLOAT_PRECISION 0.00000000000001

NK_GLOBAL const struct nk_color nk_red = { 255, 0, 0, 255 };
NK_GLOBAL const struct nk_color nk_green = { 0, 255, 0, 255 };
NK_GLOBAL const struct nk_color nk_blue = { 0, 0, 255, 255 };
NK_GLOBAL const struct nk_color nk_white = { 255, 255, 255, 255 };
NK_GLOBAL const struct nk_color nk_black = { 0, 0, 0, 255 };
NK_GLOBAL const struct nk_color nk_yellow = { 255, 255, 0, 255 };

/* widget */
#define nk_widget_state_reset(s)\
    if ((*(s)) & NK_WIDGET_STATE_MODIFIED)\
        (*(s)) = NK_WIDGET_STATE_INACTIVE|NK_WIDGET_STATE_MODIFIED;\
    else (*(s)) = NK_WIDGET_STATE_INACTIVE;

/* math */
NK_LIB float nk_inv_sqrt(float n);

NK_LIB float nk_sqrt(float x);

NK_LIB float nk_sin(float x);

NK_LIB float nk_cos(float x);

NK_LIB nk_uint nk_round_up_pow2(nk_uint v);

NK_LIB struct nk_rect nk_shrink_rect(struct nk_rect r, float amount);

NK_LIB struct nk_rect nk_pad_rect(struct nk_rect r, struct nk_vec2 pad);

NK_LIB void nk_unify(struct nk_rect* clip, const struct nk_rect* a, float x0, float y0, float x1, float y1);

NK_LIB double nk_pow(double x, int n);

NK_LIB int nk_ifloord(double x);

NK_LIB int nk_ifloorf(float x);

NK_LIB int nk_iceilf(float x);

NK_LIB int nk_log10(double n);

/* util */
enum {
	NK_DO_NOT_STOP_ON_NEW_LINE, NK_STOP_ON_NEW_LINE
};

NK_LIB int nk_is_lower(int c);

NK_LIB int nk_is_upper(int c);

NK_LIB int nk_to_upper(int c);

NK_LIB int nk_to_lower(int c);

NK_LIB void* nk_memcopy(void* dst, const void* src, nk_size n);

NK_LIB void nk_memset(void* ptr, int c0, nk_size size);

NK_LIB void nk_zero(void* ptr, nk_size size);

NK_LIB char* nk_itoa(char* s, long n);

NK_LIB int nk_string_float_limit(char* string, int prec);

NK_LIB char* nk_dtoa(char* s, double n);

NK_LIB int nk_text_clamp(const struct nk_user_font* font, const char* text, int text_len, float space, int* glyphs,
	float* text_width, nk_rune* sep_list, int sep_count);

NK_LIB struct nk_vec2
nk_text_calculate_text_bounds(const struct nk_user_font* font, const char* begin, int byte_len, float row_height,
	const char** remaining, struct nk_vec2* out_offset, int* glyphs, int op);

#ifdef NK_INCLUDE_STANDARD_VARARGS

NK_LIB int nk_strfmt(char* buf, int buf_size, const char* fmt, va_list args);

#endif
#ifdef NK_INCLUDE_STANDARD_IO

NK_LIB char* nk_file_load(const char* path, nk_size* siz, struct nk_allocator* alloc);

#endif

/* buffer */
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

NK_LIB void* nk_malloc(nk_handle unused, void* old, nk_size size);

NK_LIB void nk_mfree(nk_handle unused, void* ptr);

#endif

NK_LIB void* nk_buffer_align(void* unaligned, nk_size align, nk_size* alignment, enum nk_buffer_allocation_type type);

NK_LIB void* nk_buffer_alloc(struct nk_buffer* b, enum nk_buffer_allocation_type type, nk_size size, nk_size align);

NK_LIB void* nk_buffer_realloc(struct nk_buffer* b, nk_size capacity, nk_size* size);

/* draw */
NK_LIB void nk_command_buffer_init(struct nk_command_buffer* cb, struct nk_buffer* b, enum nk_command_clipping clip);

NK_LIB void nk_command_buffer_reset(struct nk_command_buffer* b);

NK_LIB void* nk_command_buffer_push(struct nk_command_buffer* b, enum nk_command_type t, nk_size size);

NK_LIB void nk_draw_symbol(struct nk_command_buffer* out, enum nk_symbol_type type, struct nk_rect content,
	struct nk_color background, struct nk_color foreground, float border_width,
	const struct nk_user_font* font);

/* buffering */
NK_LIB void nk_start_buffer(struct nk_context* ctx, struct nk_command_buffer* b);

NK_LIB void nk_start(struct nk_context* ctx, struct nk_window* win);

NK_LIB void nk_start_popup(struct nk_context* ctx, struct nk_window* win);

NK_LIB void nk_finish_popup(struct nk_context* ctx, struct nk_window*);

NK_LIB void nk_finish_buffer(struct nk_context* ctx, struct nk_command_buffer* b);

NK_LIB void nk_finish(struct nk_context* ctx, struct nk_window* w);

NK_LIB void nk_build(struct nk_context* ctx);

/* text editor */
NK_LIB void nk_textedit_clear_state(struct nk_text_edit* state, enum nk_text_edit_type type, nk_plugin_filter filter);

NK_LIB void
nk_textedit_click(struct nk_text_edit* state, float x, float y, const struct nk_user_font* font, float row_height);

NK_LIB void
nk_textedit_drag(struct nk_text_edit* state, float x, float y, const struct nk_user_font* font, float row_height);

NK_LIB void
nk_textedit_key(struct nk_text_edit* state, enum nk_keys key, int shift_mod, const struct nk_user_font* font,
	float row_height);

/* window */
enum nk_window_insert_location {
	NK_INSERT_BACK, /* inserts window into the back of list (front of screen) */
	NK_INSERT_FRONT /* inserts window into the front of list (back of screen) */
};

NK_LIB void* nk_create_window(struct nk_context* ctx);

NK_LIB void nk_remove_window(struct nk_context*, struct nk_window*);

NK_LIB void nk_free_window(struct nk_context* ctx, struct nk_window* win);

NK_LIB struct nk_window* nk_find_window(struct nk_context* ctx, nk_hash hash, const char* name);

NK_LIB void nk_insert_window(struct nk_context* ctx, struct nk_window* win, enum nk_window_insert_location loc);

/* pool */
NK_LIB void nk_pool_init(struct nk_pool* pool, struct nk_allocator* alloc, unsigned int capacity);

NK_LIB void nk_pool_free(struct nk_pool* pool);

NK_LIB void nk_pool_init_fixed(struct nk_pool* pool, void* memory, nk_size size);

NK_LIB struct nk_page_element* nk_pool_alloc(struct nk_pool* pool);

/* page-element */
NK_LIB struct nk_page_element* nk_create_page_element(struct nk_context* ctx);

NK_LIB void nk_link_page_element_into_freelist(struct nk_context* ctx, struct nk_page_element* elem);

NK_LIB void nk_free_page_element(struct nk_context* ctx, struct nk_page_element* elem);

/* table */
NK_LIB struct nk_table* nk_create_table(struct nk_context* ctx);

NK_LIB void nk_remove_table(struct nk_window* win, struct nk_table* tbl);

NK_LIB void nk_free_table(struct nk_context* ctx, struct nk_table* tbl);

NK_LIB void nk_push_table(struct nk_window* win, struct nk_table* tbl);

NK_LIB nk_uint* nk_add_value(struct nk_context* ctx, struct nk_window* win, nk_hash name, nk_uint value);

NK_LIB nk_uint* nk_find_value(struct nk_window* win, nk_hash name);

/* panel */
NK_LIB void* nk_create_panel(struct nk_context* ctx);

NK_LIB void nk_free_panel(struct nk_context*, struct nk_panel* pan);

NK_LIB int nk_panel_has_header(nk_flags flags, const char* title);

NK_LIB struct nk_vec2 nk_panel_get_padding(const struct nk_style* style, enum nk_panel_type type);

NK_LIB float nk_panel_get_border(const struct nk_style* style, nk_flags flags, enum nk_panel_type type);

NK_LIB struct nk_color nk_panel_get_border_color(const struct nk_style* style, enum nk_panel_type type);

NK_LIB int nk_panel_is_sub(enum nk_panel_type type);

NK_LIB int nk_panel_is_nonblock(enum nk_panel_type type);

NK_LIB int nk_panel_begin(struct nk_context* ctx, const char* title, enum nk_panel_type panel_type);

NK_LIB void nk_panel_end(struct nk_context* ctx);

/* layout */
NK_LIB float
nk_layout_row_calculate_usable_space(const struct nk_style* style, enum nk_panel_type type, float total_space,
	int columns);

NK_LIB void nk_panel_layout(const struct nk_context* ctx, struct nk_window* win, float height, int cols);

NK_LIB void nk_row_layout(struct nk_context* ctx, enum nk_layout_format fmt, float height, int cols, int width);

NK_LIB void nk_panel_alloc_row(const struct nk_context* ctx, struct nk_window* win);

NK_LIB void
nk_layout_widget_space(struct nk_rect* bounds, const struct nk_context* ctx, struct nk_window* win, int modify);

NK_LIB void nk_panel_alloc_space(struct nk_rect* bounds, const struct nk_context* ctx);

NK_LIB void nk_layout_peek(struct nk_rect* bounds, struct nk_context* ctx);

/* popup */
NK_LIB int nk_nonblock_begin(struct nk_context* ctx, nk_flags flags, struct nk_rect body, struct nk_rect header,
	enum nk_panel_type panel_type);

/* text */
struct nk_text {
	struct nk_vec2 padding;
	struct nk_color background;
	struct nk_color text;
};

NK_LIB void
nk_widget_text(struct nk_command_buffer* o, struct nk_rect b, const char* string, int len, const struct nk_text* t,
	nk_flags a, const struct nk_user_font* f);

NK_LIB void
nk_widget_text_wrap(struct nk_command_buffer* o, struct nk_rect b, const char* string, int len, const struct nk_text* t,
	const struct nk_user_font* f);

/* button */
NK_LIB int
nk_button_behavior(nk_flags* state, struct nk_rect r, const struct nk_input* i, enum nk_button_behavior behavior);

NK_LIB const struct nk_style_item*
nk_draw_button(struct nk_command_buffer* out, const struct nk_rect* bounds, nk_flags state,
	const struct nk_style_button* style);

NK_LIB int
nk_do_button(nk_flags* state, struct nk_command_buffer* out, struct nk_rect r, const struct nk_style_button* style,
	const struct nk_input* in, enum nk_button_behavior behavior, struct nk_rect* content);

NK_LIB void
nk_draw_button_text(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, const char* txt, int len,
	nk_flags text_alignment, const struct nk_user_font* font);

NK_LIB int
nk_do_button_text(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* string, int len,
	nk_flags align, enum nk_button_behavior behavior, const struct nk_style_button* style,
	const struct nk_input* in, const struct nk_user_font* font);

NK_LIB void
nk_draw_button_symbol(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, enum nk_symbol_type type,
	const struct nk_user_font* font);

NK_LIB int
nk_do_button_symbol(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, enum nk_symbol_type symbol,
	enum nk_button_behavior behavior, const struct nk_style_button* style, const struct nk_input* in,
	const struct nk_user_font* font);

NK_LIB void
nk_draw_button_image(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, const struct nk_image* img);

NK_LIB int
nk_do_button_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, struct nk_image img,
	enum nk_button_behavior b, const struct nk_style_button* style, const struct nk_input* in);

NK_LIB void
nk_draw_button_text_symbol(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* label,
	const struct nk_rect* symbol, nk_flags state, const struct nk_style_button* style,
	const char* str, int len, enum nk_symbol_type type, const struct nk_user_font* font);

NK_LIB int nk_do_button_text_symbol(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds,
	enum nk_symbol_type symbol, const char* str, int len, nk_flags align,
	enum nk_button_behavior behavior, const struct nk_style_button* style,
	const struct nk_user_font* font, const struct nk_input* in);

NK_LIB void
nk_draw_button_text_image(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* label,
	const struct nk_rect* image, nk_flags state, const struct nk_style_button* style,
	const char* str, int len, const struct nk_user_font* font, const struct nk_image* img);

NK_LIB int
nk_do_button_text_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, struct nk_image img,
	const char* str, int len, nk_flags align, enum nk_button_behavior behavior,
	const struct nk_style_button* style, const struct nk_user_font* font,
	const struct nk_input* in);

/* toggle */
enum nk_toggle_type {
	NK_TOGGLE_CHECK, NK_TOGGLE_OPTION
};

NK_LIB int nk_toggle_behavior(const struct nk_input* in, struct nk_rect select, nk_flags* state, int active);

NK_LIB void
nk_draw_checkbox(struct nk_command_buffer* out, nk_flags state, const struct nk_style_toggle* style, int active,
	const struct nk_rect* label, const struct nk_rect* selector, const struct nk_rect* cursors,
	const char* string, int len, const struct nk_user_font* font);

NK_LIB void
nk_draw_option(struct nk_command_buffer* out, nk_flags state, const struct nk_style_toggle* style, int active,
	const struct nk_rect* label, const struct nk_rect* selector, const struct nk_rect* cursors,
	const char* string, int len, const struct nk_user_font* font);

NK_LIB int
nk_do_toggle(nk_flags* state, struct nk_command_buffer* out, struct nk_rect r, int* active, const char* str, int len,
	enum nk_toggle_type type, const struct nk_style_toggle* style, const struct nk_input* in,
	const struct nk_user_font* font);

/* progress */
NK_LIB nk_size
nk_progress_behavior(nk_flags* state, struct nk_input* in, struct nk_rect r, struct nk_rect cursor, nk_size max,
	nk_size value, int modifiable);

NK_LIB void nk_draw_progress(struct nk_command_buffer* out, nk_flags state, const struct nk_style_progress* style,
	const struct nk_rect* bounds, const struct nk_rect* scursor, nk_size value, nk_size max);

NK_LIB nk_size
nk_do_progress(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, nk_size value, nk_size max,
	int modifiable, const struct nk_style_progress* style, struct nk_input* in);

/* slider */
NK_LIB float
nk_slider_behavior(nk_flags* state, struct nk_rect* logical_cursor, struct nk_rect* visual_cursor, struct nk_input* in,
	struct nk_rect bounds, float slider_min, float slider_max, float slider_value, float slider_step,
	float slider_steps);

NK_LIB void nk_draw_slider(struct nk_command_buffer* out, nk_flags state, const struct nk_style_slider* style,
	const struct nk_rect* bounds, const struct nk_rect* visual_cursor, float min, float value,
	float max);

NK_LIB float
nk_do_slider(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, float min, float val, float max,
	float step, const struct nk_style_slider* style, struct nk_input* in, const struct nk_user_font* font);

/* scrollbar */
NK_LIB float
nk_scrollbar_behavior(nk_flags* state, struct nk_input* in, int has_scrolling, const struct nk_rect* scroll,
	const struct nk_rect* cursor, const struct nk_rect* empty0, const struct nk_rect* empty1,
	float scroll_offset, float target, float scroll_step, enum nk_orientation o);

NK_LIB void nk_draw_scrollbar(struct nk_command_buffer* out, nk_flags state, const struct nk_style_scrollbar* style,
	const struct nk_rect* bounds, const struct nk_rect* scroll);

NK_LIB float
nk_do_scrollbarv(nk_flags* state, struct nk_command_buffer* out, struct nk_rect scroll, int has_scrolling, float offset,
	float target, float step, float button_pixel_inc, const struct nk_style_scrollbar* style,
	struct nk_input* in, const struct nk_user_font* font);

NK_LIB float
nk_do_scrollbarh(nk_flags* state, struct nk_command_buffer* out, struct nk_rect scroll, int has_scrolling, float offset,
	float target, float step, float button_pixel_inc, const struct nk_style_scrollbar* style,
	struct nk_input* in, const struct nk_user_font* font);

/* selectable */
NK_LIB void
nk_draw_selectable(struct nk_command_buffer* out, nk_flags state, const struct nk_style_selectable* style, int active,
	const struct nk_rect* bounds, const struct nk_rect* icon, const struct nk_image* img,
	enum nk_symbol_type sym, const char* string, int len, nk_flags align,
	const struct nk_user_font* font);

NK_LIB int
nk_do_selectable(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* str, int len,
	nk_flags align, int* value, const struct nk_style_selectable* style, const struct nk_input* in,
	const struct nk_user_font* font);

NK_LIB int
nk_do_selectable_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* str, int len,
	nk_flags align, int* value, const struct nk_image* img, const struct nk_style_selectable* style,
	const struct nk_input* in, const struct nk_user_font* font);

/* edit */
NK_LIB void
nk_edit_draw_text(struct nk_command_buffer* out, const struct nk_style_edit* style, float pos_x, float pos_y,
	float x_offset, const char* text, int byte_len, float row_height, const struct nk_user_font* font,
	struct nk_color background, struct nk_color foreground, int is_selected);

NK_LIB nk_flags nk_do_edit(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, nk_flags flags,
	nk_plugin_filter filter, struct nk_text_edit* edit, const struct nk_style_edit* style,
	struct nk_input* in, const struct nk_user_font* font);

/* color-picker */
NK_LIB int nk_color_picker_behavior(nk_flags* state, const struct nk_rect* bounds, const struct nk_rect* matrix,
	const struct nk_rect* hue_bar, const struct nk_rect* alpha_bar,
	struct nk_colorf* color, const struct nk_input* in);

NK_LIB void
nk_draw_color_picker(struct nk_command_buffer* o, const struct nk_rect* matrix, const struct nk_rect* hue_bar,
	const struct nk_rect* alpha_bar, struct nk_colorf col);

NK_LIB int
nk_do_color_picker(nk_flags* state, struct nk_command_buffer* out, struct nk_colorf* col, enum nk_color_format fmt,
	struct nk_rect bounds, struct nk_vec2 padding, const struct nk_input* in,
	const struct nk_user_font* font);

/* property */
enum nk_property_status {
	NK_PROPERTY_DEFAULT, NK_PROPERTY_EDIT, NK_PROPERTY_DRAG
};
enum nk_property_filter {
	NK_FILTER_INT, NK_FILTER_FLOAT
};
enum nk_property_kind {
	NK_PROPERTY_INT, NK_PROPERTY_FLOAT, NK_PROPERTY_DOUBLE
};
union nk_property {
	int i;
	float f;
	double d;
};
struct nk_property_variant {
	enum nk_property_kind kind;
	union nk_property value;
	union nk_property min_value;
	union nk_property max_value;
	union nk_property step;
};

NK_LIB struct nk_property_variant nk_property_variant_int(int value, int min_value, int max_value, int step);

NK_LIB struct nk_property_variant nk_property_variant_float(float value, float min_value, float max_value, float step);

NK_LIB struct nk_property_variant
nk_property_variant_double(double value, double min_value, double max_value, double step);

NK_LIB void
nk_drag_behavior(nk_flags* state, const struct nk_input* in, struct nk_rect drag, struct nk_property_variant* variant,
	float inc_per_pixel);

NK_LIB void nk_property_behavior(nk_flags* ws, const struct nk_input* in, struct nk_rect property, struct nk_rect label,
	struct nk_rect edit, struct nk_rect empty, int* state,
	struct nk_property_variant* variant, float inc_per_pixel);

NK_LIB void
nk_draw_property(struct nk_command_buffer* out, const struct nk_style_property* style, const struct nk_rect* bounds,
	const struct nk_rect* label, nk_flags state, const char* name, int len,
	const struct nk_user_font* font);

NK_LIB void nk_do_property(nk_flags* ws, struct nk_command_buffer* out, struct nk_rect property, const char* name,
	struct nk_property_variant* variant, float inc_per_pixel, char* buffer, int* len, int* state,
	int* cursor, int* select_begin, int* select_end, const struct nk_style_property* style,
	enum nk_property_filter filter, struct nk_input* in, const struct nk_user_font* font,
	struct nk_text_edit* text_edit, enum nk_button_behavior behavior);

NK_LIB void
nk_property(struct nk_context* ctx, const char* name, struct nk_property_variant* variant, float inc_per_pixel,
	const enum nk_property_filter filter);

#endif





/* ===============================================================
 *
 *                              MATH
 *
 * ===============================================================*/
 /*  Since nuklear is supposed to work on all systems providing floating point
	 math without any dependencies I also had to implement my own math functions
	 for sqrt, sin and cos. Since the actual highly accurate implementations for
	 the standard library functions are quite complex and I do not need high
	 precision for my use cases I use approximations.

	 Sqrt
	 ----
	 For square root nuklear uses the famous fast inverse square root:
	 https://en.wikipedia.org/wiki/Fast_inverse_square_root with
	 slightly tweaked magic constant. While on today's hardware it is
	 probably not faster it is still fast and accurate enough for
	 nuklear's use cases. IMPORTANT: this requires float format IEEE 754

	 Sine/Cosine
	 -----------
	 All constants inside both function are generated Remez's minimax
	 approximations for value range 0...2*PI. The reason why I decided to
	 approximate exactly that range is that nuklear only needs sine and
	 cosine to generate circles which only requires that exact range.
	 In addition I used Remez instead of Taylor for additional precision:
	 www.lolengine.net/blog/2011/12/21/better-function-approximations.

	 The tool I used to generate constants for both sine and cosine
	 (it can actually approximate a lot more functions) can be
	 found here: www.lolengine.net/wiki/oss/lolremez
 */
NK_LIB float nk_inv_sqrt(float n) {
	float x2;
	const float threehalfs = 1.5f;
	union {
		nk_uint i;
		float f;
	} conv = { 0 };
	conv.f = n;
	x2 = n * 0.5f;
	conv.i = 0x5f375A84 - (conv.i >> 1);
	conv.f = conv.f * (threehalfs - (x2 * conv.f * conv.f));
	return conv.f;
}

NK_LIB float nk_sqrt(float x) {
	return x * nk_inv_sqrt(x);
}

NK_LIB float nk_sin(float x) {
	NK_STORAGE const float a0 = +1.91059300966915117e-31f;
	NK_STORAGE const float a1 = +1.00086760103908896f;
	NK_STORAGE const float a2 = -1.21276126894734565e-2f;
	NK_STORAGE const float a3 = -1.38078780785773762e-1f;
	NK_STORAGE const float a4 = -2.67353392911981221e-2f;
	NK_STORAGE const float a5 = +2.08026600266304389e-2f;
	NK_STORAGE const float a6 = -3.03996055049204407e-3f;
	NK_STORAGE const float a7 = +1.38235642404333740e-4f;
	return a0 + x * (a1 + x * (a2 + x * (a3 + x * (a4 + x * (a5 + x * (a6 + x * a7))))));
}

NK_LIB float nk_cos(float x) {
	NK_STORAGE const float a0 = +1.00238601909309722f;
	NK_STORAGE const float a1 = -3.81919947353040024e-2f;
	NK_STORAGE const float a2 = -3.94382342128062756e-1f;
	NK_STORAGE const float a3 = -1.18134036025221444e-1f;
	NK_STORAGE const float a4 = +1.07123798512170878e-1f;
	NK_STORAGE const float a5 = -1.86637164165180873e-2f;
	NK_STORAGE const float a6 = +9.90140908664079833e-4f;
	NK_STORAGE const float a7 = -5.23022132118824778e-14f;
	return a0 + x * (a1 + x * (a2 + x * (a3 + x * (a4 + x * (a5 + x * (a6 + x * a7))))));
}

NK_LIB nk_uint nk_round_up_pow2(nk_uint v) {
	v--;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;
	return v;
}

NK_LIB double nk_pow(double x, int n) {
	/*  check the sign of n */
	double r = 1;
	int plus = n >= 0;
	n = (plus) ? n : -n;
	while (n > 0) {
		if ((n & 1) == 1)
			r *= x;
		n /= 2;
		x *= x;
	}
	return plus ? r : 1.0 / r;
}

NK_LIB int nk_ifloord(double x) {
	x = (double)((int)x - ((x < 0.0) ? 1 : 0));
	return (int)x;
}

NK_LIB int nk_ifloorf(float x) {
	x = (float)((int)x - ((x < 0.0f) ? 1 : 0));
	return (int)x;
}

NK_LIB int nk_iceilf(float x) {
	if (x >= 0) {
		int i = (int)x;
		return (x > i) ? i + 1 : i;
	}
	else {
		int t = (int)x;
		float r = x - (float)t;
		return (r > 0.0f) ? t + 1 : t;
	}
}

NK_LIB int nk_log10(double n) {
	int neg;
	int ret;
	int exp = 0;

	neg = (n < 0) ? 1 : 0;
	ret = (neg) ? (int)-n : (int)n;
	while ((ret / 10) > 0) {
		ret /= 10;
		exp++;
	}
	if (neg) exp = -exp;
	return exp;
}

NK_API struct nk_rect nk_get_null_rect(void) {
	return nk_null_rect;
}

NK_API struct nk_rect nk_rect(float x, float y, float w, float h) {
	struct nk_rect r;
	r.x = x;
	r.y = y;
	r.w = w;
	r.h = h;
	return r;
}

NK_API struct nk_rect nk_recti(int x, int y, int w, int h) {
	struct nk_rect r;
	r.x = (float)x;
	r.y = (float)y;
	r.w = (float)w;
	r.h = (float)h;
	return r;
}

NK_API struct nk_rect nk_recta(struct nk_vec2 pos, struct nk_vec2 size) {
	return nk_rect(pos.x, pos.y, size.x, size.y);
}

NK_API struct nk_rect nk_rectv(const float* r) {
	return nk_rect(r[0], r[1], r[2], r[3]);
}

NK_API struct nk_rect nk_rectiv(const int* r) {
	return nk_recti(r[0], r[1], r[2], r[3]);
}

NK_API struct nk_vec2 nk_rect_pos(struct nk_rect r) {
	struct nk_vec2 ret;
	ret.x = r.x;
	ret.y = r.y;
	return ret;
}

NK_API struct nk_vec2 nk_rect_size(struct nk_rect r) {
	struct nk_vec2 ret;
	ret.x = r.w;
	ret.y = r.h;
	return ret;
}

NK_LIB struct nk_rect nk_shrink_rect(struct nk_rect r, float amount) {
	struct nk_rect res;
	r.w = NK_MAX(r.w, 2 * amount);
	r.h = NK_MAX(r.h, 2 * amount);
	res.x = r.x + amount;
	res.y = r.y + amount;
	res.w = r.w - 2 * amount;
	res.h = r.h - 2 * amount;
	return res;
}

NK_LIB struct nk_rect nk_pad_rect(struct nk_rect r, struct nk_vec2 pad) {
	r.w = NK_MAX(r.w, 2 * pad.x);
	r.h = NK_MAX(r.h, 2 * pad.y);
	r.x += pad.x;
	r.y += pad.y;
	r.w -= 2 * pad.x;
	r.h -= 2 * pad.y;
	return r;
}

NK_API struct nk_vec2 nk_vec2(float x, float y) {
	struct nk_vec2 ret;
	ret.x = x;
	ret.y = y;
	return ret;
}

NK_API struct nk_vec2 nk_vec2i(int x, int y) {
	struct nk_vec2 ret;
	ret.x = (float)x;
	ret.y = (float)y;
	return ret;
}

NK_API struct nk_vec2 nk_vec2v(const float* v) {
	return nk_vec2(v[0], v[1]);
}

NK_API struct nk_vec2 nk_vec2iv(const int* v) {
	return nk_vec2i(v[0], v[1]);
}

NK_LIB void nk_unify(struct nk_rect* clip, const struct nk_rect* a, float x0, float y0, float x1, float y1) {
	NK_ASSERT(a);
	NK_ASSERT(clip);
	clip->x = NK_MAX(a->x, x0);
	clip->y = NK_MAX(a->y, y0);
	clip->w = NK_MIN(a->x + a->w, x1) - clip->x;
	clip->h = NK_MIN(a->y + a->h, y1) - clip->y;
	clip->w = NK_MAX(0, clip->w);
	clip->h = NK_MAX(0, clip->h);
}

NK_API void nk_triangle_from_direction(struct nk_vec2* result, struct nk_rect r, float pad_x, float pad_y,
	enum nk_heading direction) {
	float w_half, h_half;
	NK_ASSERT(result);

	r.w = NK_MAX(2 * pad_x, r.w);
	r.h = NK_MAX(2 * pad_y, r.h);
	r.w = r.w - 2 * pad_x;
	r.h = r.h - 2 * pad_y;

	r.x = r.x + pad_x;
	r.y = r.y + pad_y;

	w_half = r.w / 2.0f;
	h_half = r.h / 2.0f;

	if (direction == NK_UP) {
		result[0] = nk_vec2(r.x + w_half, r.y);
		result[1] = nk_vec2(r.x + r.w, r.y + r.h);
		result[2] = nk_vec2(r.x, r.y + r.h);
	}
	else if (direction == NK_RIGHT) {
		result[0] = nk_vec2(r.x, r.y);
		result[1] = nk_vec2(r.x + r.w, r.y + h_half);
		result[2] = nk_vec2(r.x, r.y + r.h);
	}
	else if (direction == NK_DOWN) {
		result[0] = nk_vec2(r.x, r.y);
		result[1] = nk_vec2(r.x + r.w, r.y);
		result[2] = nk_vec2(r.x + w_half, r.y + r.h);
	}
	else {
		result[0] = nk_vec2(r.x, r.y + h_half);
		result[1] = nk_vec2(r.x + r.w, r.y);
		result[2] = nk_vec2(r.x + r.w, r.y + r.h);
	}
}





/* ===============================================================
 *
 *                              UTIL
 *
 * ===============================================================*/
NK_INTERN int nk_str_match_here(const char* regexp, const char* text);

NK_INTERN int nk_str_match_star(int c, const char* regexp, const char* text);

NK_LIB int nk_is_lower(int c) { return (c >= 'a' && c <= 'z') || (c >= 0xE0 && c <= 0xFF); }

NK_LIB int nk_is_upper(int c) { return (c >= 'A' && c <= 'Z') || (c >= 0xC0 && c <= 0xDF); }

NK_LIB int nk_to_upper(int c) { return (c >= 'a' && c <= 'z') ? (c - ('a' - 'A')) : c; }

NK_LIB int nk_to_lower(int c) { return (c >= 'A' && c <= 'Z') ? (c - ('a' + 'A')) : c; }

NK_LIB void* nk_memcopy(void* dst0, const void* src0, nk_size length) {
	nk_ptr t;
	char* dst = (char*)dst0;
	const char* src = (const char*)src0;
	if (length == 0 || dst == src)
		goto done;

#define nk_word int
#define nk_wsize sizeof(nk_word)
#define nk_wmask (nk_wsize-1)
#define NK_TLOOP(s) if (t) NK_TLOOP1(s)
#define NK_TLOOP1(s) do { s; } while (--t)

	if (dst < src) {
		t = (nk_ptr)src; /* only need low bits */
		if ((t | (nk_ptr)dst) & nk_wmask) {
			if ((t ^ (nk_ptr)dst) & nk_wmask || length < nk_wsize)
				t = length;
			else
				t = nk_wsize - (t & nk_wmask);
			length -= t;
			NK_TLOOP1(*dst++ = *src++);
		}
		t = length / nk_wsize;
		NK_TLOOP(*(nk_word*)(
			void*)dst = *(const nk_word*)(const void*)src;
		src += nk_wsize; dst += nk_wsize);
		t = length & nk_wmask;
		NK_TLOOP(*dst++ = *src++);
	}
	else {
		src += length;
		dst += length;
		t = (nk_ptr)src;
		if ((t | (nk_ptr)dst) & nk_wmask) {
			if ((t ^ (nk_ptr)dst) & nk_wmask || length <= nk_wsize)
				t = length;
			else
				t &= nk_wmask;
			length -= t;
			NK_TLOOP1(*--dst = *--src);
		}
		t = length / nk_wsize;
		NK_TLOOP(src -= nk_wsize;
		dst -= nk_wsize;
		*(nk_word*)(
			void*)dst = *(const nk_word*)(const void*)src);
		t = length & nk_wmask;
		NK_TLOOP(*--dst = *--src);
	}
#undef nk_word
#undef nk_wsize
#undef nk_wmask
#undef NK_TLOOP
#undef NK_TLOOP1
	done :
	return (dst0);
}

NK_LIB void nk_memset(void* ptr, int c0, nk_size size) {
#define nk_word unsigned
#define nk_wsize sizeof(nk_word)
#define nk_wmask (nk_wsize - 1)
	nk_byte* dst = (nk_byte*)ptr;
	unsigned c = 0;
	nk_size t = 0;

	if ((c = (nk_byte)c0) != 0) {
		c = (c << 8) | c; /* at least 16-bits  */
		if (sizeof(unsigned int) > 2)
			c = (c << 16) | c; /* at least 32-bits*/
	}

	/* too small of a word count */
	dst = (nk_byte*)ptr;
	if (size < 3 * nk_wsize) {
		while (size--)*dst++ = (nk_byte)c0;
		return;
	}

	/* align destination */
	if ((t = NK_PTR_TO_UINT(dst) & nk_wmask) != 0) {
		t = nk_wsize - t;
		size -= t;
		do {
			*dst++ = (nk_byte)c0;
		} while (--t != 0);
	}

	/* fill word */
	t = size / nk_wsize;
	do {
		*(nk_word*)((void*)dst) = c;
		dst += nk_wsize;
	} while (--t != 0);

	/* fill trailing bytes */
	t = (size & nk_wmask);
	if (t != 0) {
		do {
			*dst++ = (nk_byte)c0;
		} while (--t != 0);
	}

#undef nk_word
#undef nk_wsize
#undef nk_wmask
}

NK_LIB void nk_zero(void* ptr, nk_size size) {
	NK_ASSERT(ptr);
	NK_MEMSET(ptr, 0, size);
}

NK_API int nk_strlen(const char* str) {
	int siz = 0;
	NK_ASSERT(str);
	while (str && *str++ != '\0') siz++;
	return siz;
}

NK_API int nk_strtoi(const char* str, const char** endptr) {
	int neg = 1;
	const char* p = str;
	int value = 0;

	NK_ASSERT(str);
	if (!str) return 0;

	/* skip whitespace */
	while (*p == ' ') p++;
	if (*p == '-') {
		neg = -1;
		p++;
	}
	while (*p && *p >= '0' && *p <= '9') {
		value = value * 10 + (int)(*p - '0');
		p++;
	}
	if (endptr)
		*endptr = p;
	return neg * value;
}

NK_API double nk_strtod(const char* str, const char** endptr) {
	double m;
	double neg = 1.0;
	const char* p = str;
	double value = 0;
	double number = 0;

	NK_ASSERT(str);
	if (!str) return 0;

	/* skip whitespace */
	while (*p == ' ') p++;
	if (*p == '-') {
		neg = -1.0;
		p++;
	}

	while (*p && *p != '.' && *p != 'e') {
		value = value * 10.0 + (double)(*p - '0');
		p++;
	}

	if (*p == '.') {
		p++;
		for (m = 0.1; *p && *p != 'e'; p++) {
			value = value + (double)(*p - '0') * m;
			m *= 0.1;
		}
	}
	if (*p == 'e') {
		int i, pow, div;
		p++;
		if (*p == '-') {
			div = nk_true;
			p++;
		}
		else if (*p == '+') {
			div = nk_false;
			p++;
		}
		else div = nk_false;

		for (pow = 0; *p; p++)
			pow = pow * 10 + (int)(*p - '0');

		for (m = 1.0, i = 0; i < pow; i++)
			m *= 10.0;

		if (div)
			value /= m;
		else value *= m;
	}
	number = value * neg;
	if (endptr)
		*endptr = p;
	return number;
}

NK_API float nk_strtof(const char* str, const char** endptr) {
	float float_value;
	double double_value;
	double_value = NK_STRTOD(str, endptr);
	float_value = (float)double_value;
	return float_value;
}

NK_API int nk_stricmp(const char* s1, const char* s2) {
	nk_int c1, c2, d;
	do {
		c1 = *s1++;
		c2 = *s2++;
		d = c1 - c2;
		while (d) {
			if (c1 <= 'Z' && c1 >= 'A') {
				d += ('a' - 'A');
				if (!d) break;
			}
			if (c2 <= 'Z' && c2 >= 'A') {
				d -= ('a' - 'A');
				if (!d) break;
			}
			return ((d >= 0) << 1) - 1;
		}
	} while (c1);
	return 0;
}

NK_API int nk_stricmpn(const char* s1, const char* s2, int n) {
	int c1, c2, d;
	NK_ASSERT(n >= 0);
	do {
		c1 = *s1++;
		c2 = *s2++;
		if (!n--) return 0;

		d = c1 - c2;
		while (d) {
			if (c1 <= 'Z' && c1 >= 'A') {
				d += ('a' - 'A');
				if (!d) break;
			}
			if (c2 <= 'Z' && c2 >= 'A') {
				d -= ('a' - 'A');
				if (!d) break;
			}
			return ((d >= 0) << 1) - 1;
		}
	} while (c1);
	return 0;
}

NK_INTERN int nk_str_match_here(const char* regexp, const char* text) {
	if (regexp[0] == '\0')
		return 1;
	if (regexp[1] == '*')
		return nk_str_match_star(regexp[0], regexp + 2, text);
	if (regexp[0] == '$' && regexp[1] == '\0')
		return *text == '\0';
	if (*text != '\0' && (regexp[0] == '.' || regexp[0] == *text))
		return nk_str_match_here(regexp + 1, text + 1);
	return 0;
}

NK_INTERN int nk_str_match_star(int c, const char* regexp, const char* text) {
	do {/* a '* matches zero or more instances */
		if (nk_str_match_here(regexp, text))
			return 1;
	} while (*text != '\0' && (*text++ == c || c == '.'));
	return 0;
}

NK_API int nk_strfilter(const char* text, const char* regexp) {
	/*
	c    matches any literal character c
	.    matches any single character
	^    matches the beginning of the input string
	$    matches the end of the input string
	*    matches zero or more occurrences of the previous character*/
	if (regexp[0] == '^')
		return nk_str_match_here(regexp + 1, text);
	do {    /* must look even if string is empty */
		if (nk_str_match_here(regexp, text))
			return 1;
	} while (*text++ != '\0');
	return 0;
}

NK_API int nk_strmatch_fuzzy_text(const char* str, int str_len, const char* pattern, int* out_score) {
	/* Returns true if each character in pattern is found sequentially within str
	 * if found then out_score is also set. Score value has no intrinsic meaning.
	 * Range varies with pattern. Can only compare scores with same search pattern. */

	 /* bonus for adjacent matches */
#define NK_ADJACENCY_BONUS 5
	/* bonus if match occurs after a separator */
#define NK_SEPARATOR_BONUS 10
	/* bonus if match is uppercase and prev is lower */
#define NK_CAMEL_BONUS 10
	/* penalty applied for every letter in str before the first match */
#define NK_LEADING_LETTER_PENALTY (-3)
	/* maximum penalty for leading letters */
#define NK_MAX_LEADING_LETTER_PENALTY (-9)
	/* penalty for every letter that doesn't matter */
#define NK_UNMATCHED_LETTER_PENALTY (-1)

	/* loop variables */
	int score = 0;
	char const* pattern_iter = pattern;
	int str_iter = 0;
	int prev_matched = nk_false;
	int prev_lower = nk_false;
	/* true so if first letter match gets separator bonus*/
	int prev_separator = nk_true;

	/* use "best" matched letter if multiple string letters match the pattern */
	char const* best_letter = 0;
	int best_letter_score = 0;

	/* loop over strings */
	NK_ASSERT(str);
	NK_ASSERT(pattern);
	if (!str || !str_len || !pattern) return 0;
	while (str_iter < str_len) {
		const char pattern_letter = *pattern_iter;
		const char str_letter = str[str_iter];

		int next_match = *pattern_iter != '\0' && nk_to_lower(pattern_letter) == nk_to_lower(str_letter);
		int rematch = best_letter && nk_to_upper(*best_letter) == nk_to_upper(str_letter);

		int advanced = next_match && best_letter;
		int pattern_repeat = best_letter && *pattern_iter != '\0';
		pattern_repeat = pattern_repeat && nk_to_lower(*best_letter) == nk_to_lower(pattern_letter);

		if (advanced || pattern_repeat) {
			score += best_letter_score;
			best_letter = 0;
			best_letter_score = 0;
		}

		if (next_match || rematch) {
			int new_score = 0;
			/* Apply penalty for each letter before the first pattern match */
			if (pattern_iter == pattern) {
				int count = (int)(&str[str_iter] - str);
				int penalty = NK_LEADING_LETTER_PENALTY * count;
				if (penalty < NK_MAX_LEADING_LETTER_PENALTY)
					penalty = NK_MAX_LEADING_LETTER_PENALTY;

				score += penalty;
			}

			/* apply bonus for consecutive bonuses */
			if (prev_matched)
				new_score += NK_ADJACENCY_BONUS;

			/* apply bonus for matches after a separator */
			if (prev_separator)
				new_score += NK_SEPARATOR_BONUS;

			/* apply bonus across camel case boundaries */
			if (prev_lower && nk_is_upper(str_letter))
				new_score += NK_CAMEL_BONUS;

			/* update pattern iter IFF the next pattern letter was matched */
			if (next_match)
				++pattern_iter;

			/* update best letter in str which may be for a "next" letter or a rematch */
			if (new_score >= best_letter_score) {
				/* apply penalty for now skipped letter */
				if (best_letter != 0)
					score += NK_UNMATCHED_LETTER_PENALTY;

				best_letter = &str[str_iter];
				best_letter_score = new_score;
			}
			prev_matched = nk_true;
		}
		else {
			score += NK_UNMATCHED_LETTER_PENALTY;
			prev_matched = nk_false;
		}

		/* separators should be more easily defined */
		prev_lower = nk_is_lower(str_letter) != 0;
		prev_separator = str_letter == '_' || str_letter == ' ';

		++str_iter;
	}

	/* apply score for last match */
	if (best_letter)
		score += best_letter_score;

	/* did not match full pattern */
	if (*pattern_iter != '\0')
		return nk_false;

	if (out_score)
		*out_score = score;
	return nk_true;
}

NK_API int nk_strmatch_fuzzy_string(char const* str, char const* pattern, int* out_score) {
	return nk_strmatch_fuzzy_text(str, nk_strlen(str), pattern, out_score);
}

NK_LIB int nk_string_float_limit(char* string, int prec) {
	int dot = 0;
	char* c = string;
	while (*c) {
		if (*c == '.') {
			dot = 1;
			c++;
			continue;
		}
		if (dot == (prec + 1)) {
			*c = 0;
			break;
		}
		if (dot > 0) dot++;
		c++;
	}
	return (int)(c - string);
}

NK_INTERN void nk_strrev_ascii(char* s) {
	int len = nk_strlen(s);
	int end = len / 2;
	int i = 0;
	char t;
	for (; i < end; ++i) {
		t = s[i];
		s[i] = s[len - 1 - i];
		s[len - 1 - i] = t;
	}
}

NK_LIB char* nk_itoa(char* s, long n) {
	long i = 0;
	if (n == 0) {
		s[i++] = '0';
		s[i] = 0;
		return s;
	}
	if (n < 0) {
		s[i++] = '-';
		n = -n;
	}
	while (n > 0) {
		s[i++] = (char)('0' + (n % 10));
		n /= 10;
	}
	s[i] = 0;
	if (s[0] == '-')
		++s;

	nk_strrev_ascii(s);
	return s;
}

NK_LIB char* nk_dtoa(char* s, double n) {
	int useExp = 0;
	int digit = 0, m = 0, m1 = 0;
	char* c = s;
	int neg = 0;

	NK_ASSERT(s);
	if (!s) return 0;

	if (n == 0.0) {
		s[0] = '0';
		s[1] = '\0';
		return s;
	}

	neg = (n < 0);
	if (neg) n = -n;

	/* calculate magnitude */
	m = nk_log10(n);
	useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
	if (neg) *(c++) = '-';

	/* set up for scientific notation */
	if (useExp) {
		if (m < 0)
			m -= 1;
		n = n / (double)nk_pow(10.0, m);
		m1 = m;
		m = 0;
	}
	if (m < 1.0) {
		m = 0;
	}

	/* convert the number */
	while (n > NK_FLOAT_PRECISION || m >= 0) {
		double weight = nk_pow(10.0, m);
		if (weight > 0) {
			double t = (double)n / weight;
			digit = nk_ifloord(t);
			n -= ((double)digit * weight);
			*(c++) = (char)('0' + (char)digit);
		}
		if (m == 0 && n > 0)
			*(c++) = '.';
		m--;
	}

	if (useExp) {
		/* convert the exponent */
		int i, j;
		*(c++) = 'e';
		if (m1 > 0) {
			*(c++) = '+';
		}
		else {
			*(c++) = '-';
			m1 = -m1;
		}
		m = 0;
		while (m1 > 0) {
			*(c++) = (char)('0' + (char)(m1 % 10));
			m1 /= 10;
			m++;
		}
		c -= m;
		for (i = 0, j = m - 1; i < j; i++, j--) {
			/* swap without temporary */
			c[i] ^= c[j];
			c[j] ^= c[i];
			c[i] ^= c[j];
		}
		c += m;
	}
	*(c) = '\0';
	return s;
}

#ifdef NK_INCLUDE_STANDARD_VARARGS
#ifndef NK_INCLUDE_STANDARD_IO
NK_INTERN int
nk_vsnprintf(char* buf, int buf_size, const char* fmt, va_list args)
{
	enum nk_arg_type {
		NK_ARG_TYPE_CHAR,
		NK_ARG_TYPE_SHORT,
		NK_ARG_TYPE_DEFAULT,
		NK_ARG_TYPE_LONG
	};
	enum nk_arg_flags {
		NK_ARG_FLAG_LEFT = 0x01,
		NK_ARG_FLAG_PLUS = 0x02,
		NK_ARG_FLAG_SPACE = 0x04,
		NK_ARG_FLAG_NUM = 0x10,
		NK_ARG_FLAG_ZERO = 0x20
	};

	char number_buffer[NK_MAX_NUMBER_BUFFER];
	enum nk_arg_type arg_type = NK_ARG_TYPE_DEFAULT;
	int precision = NK_DEFAULT;
	int width = NK_DEFAULT;
	nk_flags flag = 0;

	int len = 0;
	int result = -1;
	const char* iter = fmt;

	NK_ASSERT(buf);
	NK_ASSERT(buf_size);
	if (!buf || !buf_size || !fmt) return 0;
	for (iter = fmt; *iter && len < buf_size; iter++) {
		/* copy all non-format characters */
		while (*iter && (*iter != '%') && (len < buf_size))
			buf[len++] = *iter++;
		if (!(*iter) || len >= buf_size) break;
		iter++;

		/* flag arguments */
		while (*iter) {
			if (*iter == '-') flag |= NK_ARG_FLAG_LEFT;
			else if (*iter == '+') flag |= NK_ARG_FLAG_PLUS;
			else if (*iter == ' ') flag |= NK_ARG_FLAG_SPACE;
			else if (*iter == '#') flag |= NK_ARG_FLAG_NUM;
			else if (*iter == '0') flag |= NK_ARG_FLAG_ZERO;
			else break;
			iter++;
		}

		/* width argument */
		width = NK_DEFAULT;
		if (*iter >= '1' && *iter <= '9') {
			const char* end;
			width = nk_strtoi(iter, &end);
			if (end == iter)
				width = -1;
			else iter = end;
		}
		else if (*iter == '*') {
			width = va_arg(args, int);
			iter++;
		}

		/* precision argument */
		precision = NK_DEFAULT;
		if (*iter == '.') {
			iter++;
			if (*iter == '*') {
				precision = va_arg(args, int);
				iter++;
			}
			else {
				const char* end;
				precision = nk_strtoi(iter, &end);
				if (end == iter)
					precision = -1;
				else iter = end;
			}
		}

		/* length modifier */
		if (*iter == 'h') {
			if (*(iter + 1) == 'h') {
				arg_type = NK_ARG_TYPE_CHAR;
				iter++;
			}
			else arg_type = NK_ARG_TYPE_SHORT;
			iter++;
		}
		else if (*iter == 'l') {
			arg_type = NK_ARG_TYPE_LONG;
			iter++;
		}
		else arg_type = NK_ARG_TYPE_DEFAULT;

		/* specifier */
		if (*iter == '%') {
			NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);
			NK_ASSERT(precision == NK_DEFAULT);
			NK_ASSERT(width == NK_DEFAULT);
			if (len < buf_size)
				buf[len++] = '%';
		}
		else if (*iter == 's') {
			/* string  */
			const char* str = va_arg(args, const char*);
			NK_ASSERT(str != buf && "buffer and argument are not allowed to overlap!");
			NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);
			NK_ASSERT(precision == NK_DEFAULT);
			NK_ASSERT(width == NK_DEFAULT);
			if (str == buf) return -1;
			while (str && *str && len < buf_size)
				buf[len++] = *str++;
		}
		else if (*iter == 'n') {
			/* current length callback */
			signed int* n = va_arg(args, int*);
			NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);
			NK_ASSERT(precision == NK_DEFAULT);
			NK_ASSERT(width == NK_DEFAULT);
			if (n) *n = len;
		}
		else if (*iter == 'c' || *iter == 'i' || *iter == 'd') {
			/* signed integer */
			long value = 0;
			const char* num_iter;
			int num_len, num_print, padding;
			int cur_precision = NK_MAX(precision, 1);
			int cur_width = NK_MAX(width, 0);

			/* retrieve correct value type */
			if (arg_type == NK_ARG_TYPE_CHAR)
				value = (signed char)va_arg(args, int);
			else if (arg_type == NK_ARG_TYPE_SHORT)
				value = (signed short)va_arg(args, int);
			else if (arg_type == NK_ARG_TYPE_LONG)
				value = va_arg(args, signed long);
			else if (*iter == 'c')
				value = (unsigned char)va_arg(args, int);
			else value = va_arg(args, signed int);

			/* convert number to string */
			nk_itoa(number_buffer, value);
			num_len = nk_strlen(number_buffer);
			padding = NK_MAX(cur_width - NK_MAX(cur_precision, num_len), 0);
			if ((flag & NK_ARG_FLAG_PLUS) || (flag & NK_ARG_FLAG_SPACE))
				padding = NK_MAX(padding - 1, 0);

			/* fill left padding up to a total of `width` characters */
			if (!(flag & NK_ARG_FLAG_LEFT)) {
				while (padding-- > 0 && (len < buf_size)) {
					if ((flag & NK_ARG_FLAG_ZERO) && (precision == NK_DEFAULT))
						buf[len++] = '0';
					else buf[len++] = ' ';
				}
			}

			/* copy string value representation into buffer */
			if ((flag & NK_ARG_FLAG_PLUS) && value >= 0 && len < buf_size)
				buf[len++] = '+';
			else if ((flag & NK_ARG_FLAG_SPACE) && value >= 0 && len < buf_size)
				buf[len++] = ' ';

			/* fill up to precision number of digits with '0' */
			num_print = NK_MAX(cur_precision, num_len);
			while (precision && (num_print > num_len) && (len < buf_size)) {
				buf[len++] = '0';
				num_print--;
			}

			/* copy string value representation into buffer */
			num_iter = number_buffer;
			while (precision && *num_iter && len < buf_size)
				buf[len++] = *num_iter++;

			/* fill right padding up to width characters */
			if (flag & NK_ARG_FLAG_LEFT) {
				while ((padding-- > 0) && (len < buf_size))
					buf[len++] = ' ';
			}
		}
		else if (*iter == 'o' || *iter == 'x' || *iter == 'X' || *iter == 'u') {
			/* unsigned integer */
			unsigned long value = 0;
			int num_len = 0, num_print, padding = 0;
			int cur_precision = NK_MAX(precision, 1);
			int cur_width = NK_MAX(width, 0);
			unsigned int base = (*iter == 'o') ? 8 : (*iter == 'u') ? 10 : 16;

			/* print oct/hex/dec value */
			const char* upper_output_format = "0123456789ABCDEF";
			const char* lower_output_format = "0123456789abcdef";
			const char* output_format = (*iter == 'x') ?
				lower_output_format : upper_output_format;

			/* retrieve correct value type */
			if (arg_type == NK_ARG_TYPE_CHAR)
				value = (unsigned char)va_arg(args, int);
			else if (arg_type == NK_ARG_TYPE_SHORT)
				value = (unsigned short)va_arg(args, int);
			else if (arg_type == NK_ARG_TYPE_LONG)
				value = va_arg(args, unsigned long);
			else value = va_arg(args, unsigned int);

			do {
				/* convert decimal number into hex/oct number */
				int digit = output_format[value % base];
				if (num_len < NK_MAX_NUMBER_BUFFER)
					number_buffer[num_len++] = (char)digit;
				value /= base;
			} while (value > 0);

			num_print = NK_MAX(cur_precision, num_len);
			padding = NK_MAX(cur_width - NK_MAX(cur_precision, num_len), 0);
			if (flag & NK_ARG_FLAG_NUM)
				padding = NK_MAX(padding - 1, 0);

			/* fill left padding up to a total of `width` characters */
			if (!(flag & NK_ARG_FLAG_LEFT)) {
				while ((padding-- > 0) && (len < buf_size)) {
					if ((flag & NK_ARG_FLAG_ZERO) && (precision == NK_DEFAULT))
						buf[len++] = '0';
					else buf[len++] = ' ';
				}
			}

			/* fill up to precision number of digits */
			if (num_print && (flag & NK_ARG_FLAG_NUM)) {
				if ((*iter == 'o') && (len < buf_size)) {
					buf[len++] = '0';
				}
				else if ((*iter == 'x') && ((len + 1) < buf_size)) {
					buf[len++] = '0';
					buf[len++] = 'x';
				}
				else if ((*iter == 'X') && ((len + 1) < buf_size)) {
					buf[len++] = '0';
					buf[len++] = 'X';
				}
			}
			while (precision && (num_print > num_len) && (len < buf_size)) {
				buf[len++] = '0';
				num_print--;
			}

			/* reverse number direction */
			while (num_len > 0) {
				if (precision && (len < buf_size))
					buf[len++] = number_buffer[num_len - 1];
				num_len--;
			}

			/* fill right padding up to width characters */
			if (flag & NK_ARG_FLAG_LEFT) {
				while ((padding-- > 0) && (len < buf_size))
					buf[len++] = ' ';
			}
		}
		else if (*iter == 'f') {
			/* floating point */
			const char* num_iter;
			int cur_precision = (precision < 0) ? 6 : precision;
			int prefix, cur_width = NK_MAX(width, 0);
			double value = va_arg(args, double);
			int num_len = 0, frac_len = 0, dot = 0;
			int padding = 0;

			NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);
			NK_DTOA(number_buffer, value);
			num_len = nk_strlen(number_buffer);

			/* calculate padding */
			num_iter = number_buffer;
			while (*num_iter && *num_iter != '.')
				num_iter++;

			prefix = (*num_iter == '.') ? (int)(num_iter - number_buffer) + 1 : 0;
			padding = NK_MAX(cur_width - (prefix + NK_MIN(cur_precision, num_len - prefix)), 0);
			if ((flag & NK_ARG_FLAG_PLUS) || (flag & NK_ARG_FLAG_SPACE))
				padding = NK_MAX(padding - 1, 0);

			/* fill left padding up to a total of `width` characters */
			if (!(flag & NK_ARG_FLAG_LEFT)) {
				while (padding-- > 0 && (len < buf_size)) {
					if (flag & NK_ARG_FLAG_ZERO)
						buf[len++] = '0';
					else buf[len++] = ' ';
				}
			}

			/* copy string value representation into buffer */
			num_iter = number_buffer;
			if ((flag & NK_ARG_FLAG_PLUS) && (value >= 0) && (len < buf_size))
				buf[len++] = '+';
			else if ((flag & NK_ARG_FLAG_SPACE) && (value >= 0) && (len < buf_size))
				buf[len++] = ' ';
			while (*num_iter) {
				if (dot) frac_len++;
				if (len < buf_size)
					buf[len++] = *num_iter;
				if (*num_iter == '.') dot = 1;
				if (frac_len >= cur_precision) break;
				num_iter++;
			}

			/* fill number up to precision */
			while (frac_len < cur_precision) {
				if (!dot && len < buf_size) {
					buf[len++] = '.';
					dot = 1;
				}
				if (len < buf_size)
					buf[len++] = '0';
				frac_len++;
			}

			/* fill right padding up to width characters */
			if (flag & NK_ARG_FLAG_LEFT) {
				while ((padding-- > 0) && (len < buf_size))
					buf[len++] = ' ';
			}
		}
		else {
			/* Specifier not supported: g,G,e,E,p,z */
			NK_ASSERT(0 && "specifier is not supported!");
			return result;
		}
	}
	buf[(len >= buf_size) ? (buf_size - 1) : len] = 0;
	result = (len >= buf_size) ? -1 : len;
	return result;
}
#endif

NK_LIB int nk_strfmt(char* buf, int buf_size, const char* fmt, va_list args) {
	int result = -1;
	NK_ASSERT(buf);
	NK_ASSERT(buf_size);
	if (!buf || !buf_size || !fmt) return 0;
#ifdef NK_INCLUDE_STANDARD_IO
	result = NK_VSNPRINTF(buf, (nk_size)buf_size, fmt, args);
	result = (result >= buf_size) ? -1 : result;
	buf[buf_size - 1] = 0;
#else
	result = nk_vsnprintf(buf, buf_size, fmt, args);
#endif
	return result;
}

#endif

NK_API nk_hash nk_murmur_hash(const void* key, int len, nk_hash seed) {
	/* 32-Bit MurmurHash3: https://code.google.com/p/smhasher/wiki/MurmurHash3*/
#define NK_ROTL(x, r) ((x) << (r) | ((x) >> (32 - r)))
	union {
		const nk_uint* i;
		const nk_byte* b;
	} conv = { 0 };
	const nk_byte* data = (const nk_byte*)key;
	const int nblocks = len / 4;
	nk_uint h1 = seed;
	const nk_uint c1 = 0xcc9e2d51;
	const nk_uint c2 = 0x1b873593;
	const nk_byte* tail;
	const nk_uint* blocks;
	nk_uint k1;
	int i;

	/* body */
	if (!key) return 0;
	conv.b = (data + nblocks * 4);
	blocks = (const nk_uint*)conv.i;
	for (i = -nblocks; i; ++i) {
		k1 = blocks[i];
		k1 *= c1;
		k1 = NK_ROTL(k1, 15);
		k1 *= c2;

		h1 ^= k1;
		h1 = NK_ROTL(h1, 13);
		h1 = h1 * 5 + 0xe6546b64;
	}

	/* tail */
	tail = (const nk_byte*)(data + nblocks * 4);
	k1 = 0;
	switch (len & 3) {
	case 3:
		k1 ^= (nk_uint)(tail[2] << 16); /* fallthrough */
	case 2:
		k1 ^= (nk_uint)(tail[1] << 8u); /* fallthrough */
	case 1:
		k1 ^= tail[0];
		k1 *= c1;
		k1 = NK_ROTL(k1, 15);
		k1 *= c2;
		h1 ^= k1;
		break;
	default:
		break;
	}

	/* finalization */
	h1 ^= (nk_uint)len;
	/* fmix32 */
	h1 ^= h1 >> 16;
	h1 *= 0x85ebca6b;
	h1 ^= h1 >> 13;
	h1 *= 0xc2b2ae35;
	h1 ^= h1 >> 16;

#undef NK_ROTL
	return h1;
}

#ifdef NK_INCLUDE_STANDARD_IO

NK_LIB char* nk_file_load(const char* path, nk_size* siz, struct nk_allocator* alloc) {
	char* buf;
	FILE* fd;
	long ret;

	NK_ASSERT(path);
	NK_ASSERT(siz);
	NK_ASSERT(alloc);
	if (!path || !siz || !alloc)
		return 0;

	fd = fopen(path, "rb");
	if (!fd) return 0;
	fseek(fd, 0, SEEK_END);
	ret = ftell(fd);
	if (ret < 0) {
		fclose(fd);
		return 0;
	}
	*siz = (nk_size)ret;
	fseek(fd, 0, SEEK_SET);
	buf = (char*)alloc->alloc(alloc->userdata, 0, *siz);
	NK_ASSERT(buf);
	if (!buf) {
		fclose(fd);
		return 0;
	}
	*siz = (nk_size)fread(buf, 1, *siz, fd);
	fclose(fd);
	return buf;
}

#endif

NK_LIB int nk_text_clamp(const struct nk_user_font* font, const char* text, int text_len, float space, int* glyphs,
	float* text_width, nk_rune* sep_list, int sep_count) {
	int i = 0;
	int glyph_len = 0;
	float last_width = 0;
	nk_rune unicode = 0;
	float width = 0;
	int len = 0;
	int g = 0;
	float s;

	int sep_len = 0;
	int sep_g = 0;
	float sep_width = 0;
	sep_count = NK_MAX(sep_count, 0);

	glyph_len = nk_utf_decode(text, &unicode, text_len);
	while (glyph_len && (width < space) && (len < text_len)) {
		len += glyph_len;
		s = font->width(font->userdata, font->height, text, len);
		for (i = 0; i < sep_count; ++i) {
			if (unicode != sep_list[i]) continue;
			sep_width = last_width = width;
			sep_g = g + 1;
			sep_len = len;
			break;
		}
		if (i == sep_count) {
			last_width = sep_width = width;
			sep_g = g + 1;
		}
		width = s;
		glyph_len = nk_utf_decode(&text[len], &unicode, text_len - len);
		g++;
	}
	if (len >= text_len) {
		*glyphs = g;
		*text_width = last_width;
		return len;
	}
	else {
		*glyphs = sep_g;
		*text_width = sep_width;
		return (!sep_len) ? len : sep_len;
	}
}

NK_LIB struct nk_vec2
nk_text_calculate_text_bounds(const struct nk_user_font* font, const char* begin, int byte_len, float row_height,
	const char** remaining, struct nk_vec2* out_offset, int* glyphs, int op) {
	float line_height = row_height;
	struct nk_vec2 text_size = nk_vec2(0, 0);
	float line_width = 0.0f;

	float glyph_width;
	int glyph_len = 0;
	nk_rune unicode = 0;
	int text_len = 0;
	if (!begin || byte_len <= 0 || !font)
		return nk_vec2(0, row_height);

	glyph_len = nk_utf_decode(begin, &unicode, byte_len);
	if (!glyph_len) return text_size;
	glyph_width = font->width(font->userdata, font->height, begin, glyph_len);

	*glyphs = 0;
	while ((text_len < byte_len) && glyph_len) {
		if (unicode == '\n') {
			text_size.x = NK_MAX(text_size.x, line_width);
			text_size.y += line_height;
			line_width = 0;
			*glyphs += 1;
			if (op == NK_STOP_ON_NEW_LINE)
				break;

			text_len++;
			glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len - text_len);
			continue;
		}

		if (unicode == '\r') {
			text_len++;
			*glyphs += 1;
			glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len - text_len);
			continue;
		}

		*glyphs = *glyphs + 1;
		text_len += glyph_len;
		line_width += (float)glyph_width;
		glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len - text_len);
		glyph_width = font->width(font->userdata, font->height, begin + text_len, glyph_len);
		continue;
	}

	if (text_size.x < line_width)
		text_size.x = line_width;
	if (out_offset)
		*out_offset = nk_vec2(line_width, text_size.y + line_height);
	if (line_width > 0 || text_size.y == 0.0f)
		text_size.y += line_height;
	if (remaining)
		*remaining = begin + text_len;
	return text_size;
}





/* ==============================================================
 *
 *                          COLOR
 *
 * ===============================================================*/
NK_INTERN int nk_parse_hex(const char* p, int length) {
	int i = 0;
	int len = 0;
	while (len < length) {
		i <<= 4;
		if (p[len] >= 'a' && p[len] <= 'f')
			i += ((p[len] - 'a') + 10);
		else if (p[len] >= 'A' && p[len] <= 'F')
			i += ((p[len] - 'A') + 10);
		else i += (p[len] - '0');
		len++;
	}
	return i;
}

NK_API struct nk_color nk_rgba(int r, int g, int b, int a) {
	struct nk_color ret;
	ret.r = (nk_byte)NK_CLAMP(0, r, 255);
	ret.g = (nk_byte)NK_CLAMP(0, g, 255);
	ret.b = (nk_byte)NK_CLAMP(0, b, 255);
	ret.a = (nk_byte)NK_CLAMP(0, a, 255);
	return ret;
}

NK_API struct nk_color nk_rgb_hex(const char* rgb) {
	struct nk_color col;
	const char* c = rgb;
	if (*c == '#') c++;
	col.r = (nk_byte)nk_parse_hex(c, 2);
	col.g = (nk_byte)nk_parse_hex(c + 2, 2);
	col.b = (nk_byte)nk_parse_hex(c + 4, 2);
	col.a = 255;
	return col;
}

NK_API struct nk_color nk_rgba_hex(const char* rgb) {
	struct nk_color col;
	const char* c = rgb;
	if (*c == '#') c++;
	col.r = (nk_byte)nk_parse_hex(c, 2);
	col.g = (nk_byte)nk_parse_hex(c + 2, 2);
	col.b = (nk_byte)nk_parse_hex(c + 4, 2);
	col.a = (nk_byte)nk_parse_hex(c + 6, 2);
	return col;
}

NK_API void nk_color_hex_rgba(char* output, struct nk_color col) {
#define NK_TO_HEX(i) ((i) <= 9 ? '0' + (i): 'A' - 10 + (i))
	output[0] = (char)NK_TO_HEX((col.r & 0xF0) >> 4);
	output[1] = (char)NK_TO_HEX((col.r & 0x0F));
	output[2] = (char)NK_TO_HEX((col.g & 0xF0) >> 4);
	output[3] = (char)NK_TO_HEX((col.g & 0x0F));
	output[4] = (char)NK_TO_HEX((col.b & 0xF0) >> 4);
	output[5] = (char)NK_TO_HEX((col.b & 0x0F));
	output[6] = (char)NK_TO_HEX((col.a & 0xF0) >> 4);
	output[7] = (char)NK_TO_HEX((col.a & 0x0F));
	output[8] = '\0';
#undef NK_TO_HEX
}

NK_API void nk_color_hex_rgb(char* output, struct nk_color col) {
#define NK_TO_HEX(i) ((i) <= 9 ? '0' + (i): 'A' - 10 + (i))
	output[0] = (char)NK_TO_HEX((col.r & 0xF0) >> 4);
	output[1] = (char)NK_TO_HEX((col.r & 0x0F));
	output[2] = (char)NK_TO_HEX((col.g & 0xF0) >> 4);
	output[3] = (char)NK_TO_HEX((col.g & 0x0F));
	output[4] = (char)NK_TO_HEX((col.b & 0xF0) >> 4);
	output[5] = (char)NK_TO_HEX((col.b & 0x0F));
	output[6] = '\0';
#undef NK_TO_HEX
}

NK_API struct nk_color nk_rgba_iv(const int* c) {
	return nk_rgba(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_color nk_rgba_bv(const nk_byte* c) {
	return nk_rgba(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_color nk_rgb(int r, int g, int b) {
	struct nk_color ret;
	ret.r = (nk_byte)NK_CLAMP(0, r, 255);
	ret.g = (nk_byte)NK_CLAMP(0, g, 255);
	ret.b = (nk_byte)NK_CLAMP(0, b, 255);
	ret.a = (nk_byte)255;
	return ret;
}

NK_API struct nk_color nk_rgb_iv(const int* c) {
	return nk_rgb(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_rgb_bv(const nk_byte* c) {
	return nk_rgb(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_rgba_u32(nk_uint in) {
	struct nk_color ret;
	ret.r = (in & 0xFF);
	ret.g = ((in >> 8) & 0xFF);
	ret.b = ((in >> 16) & 0xFF);
	ret.a = (nk_byte)((in >> 24) & 0xFF);
	return ret;
}

NK_API struct nk_color nk_rgba_f(float r, float g, float b, float a) {
	struct nk_color ret;
	ret.r = (nk_byte)(NK_SATURATE(r) * 255.0f);
	ret.g = (nk_byte)(NK_SATURATE(g) * 255.0f);
	ret.b = (nk_byte)(NK_SATURATE(b) * 255.0f);
	ret.a = (nk_byte)(NK_SATURATE(a) * 255.0f);
	return ret;
}

NK_API struct nk_color nk_rgba_fv(const float* c) {
	return nk_rgba_f(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_color nk_rgba_cf(struct nk_colorf c) {
	return nk_rgba_f(c.r, c.g, c.b, c.a);
}

NK_API struct nk_color nk_rgb_f(float r, float g, float b) {
	struct nk_color ret;
	ret.r = (nk_byte)(NK_SATURATE(r) * 255.0f);
	ret.g = (nk_byte)(NK_SATURATE(g) * 255.0f);
	ret.b = (nk_byte)(NK_SATURATE(b) * 255.0f);
	ret.a = 255;
	return ret;
}

NK_API struct nk_color nk_rgb_fv(const float* c) {
	return nk_rgb_f(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_rgb_cf(struct nk_colorf c) {
	return nk_rgb_f(c.r, c.g, c.b);
}

NK_API struct nk_color nk_hsv(int h, int s, int v) {
	return nk_hsva(h, s, v, 255);
}

NK_API struct nk_color nk_hsv_iv(const int* c) {
	return nk_hsv(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_hsv_bv(const nk_byte* c) {
	return nk_hsv(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_hsv_f(float h, float s, float v) {
	return nk_hsva_f(h, s, v, 1.0f);
}

NK_API struct nk_color nk_hsv_fv(const float* c) {
	return nk_hsv_f(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_hsva(int h, int s, int v, int a) {
	float hf = ((float)NK_CLAMP(0, h, 255)) / 255.0f;
	float sf = ((float)NK_CLAMP(0, s, 255)) / 255.0f;
	float vf = ((float)NK_CLAMP(0, v, 255)) / 255.0f;
	float af = ((float)NK_CLAMP(0, a, 255)) / 255.0f;
	return nk_hsva_f(hf, sf, vf, af);
}

NK_API struct nk_color nk_hsva_iv(const int* c) {
	return nk_hsva(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_color nk_hsva_bv(const nk_byte* c) {
	return nk_hsva(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_colorf nk_hsva_colorf(float h, float s, float v, float a) {
	int i;
	float p, q, t, f;
	struct nk_colorf out = { 0, 0, 0, 0 };
	if (s <= 0.0f) {
		out.r = v;
		out.g = v;
		out.b = v;
		out.a = a;
		return out;
	}
	h = h / (60.0f / 360.0f);
	i = (int)h;
	f = h - (float)i;
	p = v * (1.0f - s);
	q = v * (1.0f - (s * f));
	t = v * (1.0f - s * (1.0f - f));

	switch (i) {
	case 0:
	default:
		out.r = v;
		out.g = t;
		out.b = p;
		break;
	case 1:
		out.r = q;
		out.g = v;
		out.b = p;
		break;
	case 2:
		out.r = p;
		out.g = v;
		out.b = t;
		break;
	case 3:
		out.r = p;
		out.g = q;
		out.b = v;
		break;
	case 4:
		out.r = t;
		out.g = p;
		out.b = v;
		break;
	case 5:
		out.r = v;
		out.g = p;
		out.b = q;
		break;
	}
	out.a = a;
	return out;
}

NK_API struct nk_colorf nk_hsva_colorfv(float* c) {
	return nk_hsva_colorf(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_color nk_hsva_f(float h, float s, float v, float a) {
	struct nk_colorf c = nk_hsva_colorf(h, s, v, a);
	return nk_rgba_f(c.r, c.g, c.b, c.a);
}

NK_API struct nk_color nk_hsva_fv(const float* c) {
	return nk_hsva_f(c[0], c[1], c[2], c[3]);
}

NK_API nk_uint nk_color_u32(struct nk_color in) {
	nk_uint out = (nk_uint)in.r;
	out |= ((nk_uint)in.g << 8);
	out |= ((nk_uint)in.b << 16);
	out |= ((nk_uint)in.a << 24);
	return out;
}

NK_API void nk_color_f(float* r, float* g, float* b, float* a, struct nk_color in) {
	NK_STORAGE const float s = 1.0f / 255.0f;
	*r = (float)in.r * s;
	*g = (float)in.g * s;
	*b = (float)in.b * s;
	*a = (float)in.a * s;
}

NK_API void nk_color_fv(float* c, struct nk_color in) {
	nk_color_f(&c[0], &c[1], &c[2], &c[3], in);
}

NK_API struct nk_colorf nk_color_cf(struct nk_color in) {
	struct nk_colorf o;
	nk_color_f(&o.r, &o.g, &o.b, &o.a, in);
	return o;
}

NK_API void nk_color_d(double* r, double* g, double* b, double* a, struct nk_color in) {
	NK_STORAGE const double s = 1.0 / 255.0;
	*r = (double)in.r * s;
	*g = (double)in.g * s;
	*b = (double)in.b * s;
	*a = (double)in.a * s;
}

NK_API void nk_color_dv(double* c, struct nk_color in) {
	nk_color_d(&c[0], &c[1], &c[2], &c[3], in);
}

NK_API void nk_color_hsv_f(float* out_h, float* out_s, float* out_v, struct nk_color in) {
	float a;
	nk_color_hsva_f(out_h, out_s, out_v, &a, in);
}

NK_API void nk_color_hsv_fv(float* out, struct nk_color in) {
	float a;
	nk_color_hsva_f(&out[0], &out[1], &out[2], &a, in);
}

NK_API void nk_colorf_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, struct nk_colorf in) {
	float chroma;
	float K = 0.0f;
	if (in.g < in.b) {
		const float t = in.g;
		in.g = in.b;
		in.b = t;
		K = -1.f;
	}
	if (in.r < in.g) {
		const float t = in.r;
		in.r = in.g;
		in.g = t;
		K = -2.f / 6.0f - K;
	}
	chroma = in.r - ((in.g < in.b) ? in.g : in.b);
	*out_h = NK_ABS(K + (in.g - in.b) / (6.0f * chroma + 1e-20f));
	*out_s = chroma / (in.r + 1e-20f);
	*out_v = in.r;
	*out_a = in.a;

}

NK_API void nk_colorf_hsva_fv(float* hsva, struct nk_colorf in) {
	nk_colorf_hsva_f(&hsva[0], &hsva[1], &hsva[2], &hsva[3], in);
}

NK_API void nk_color_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, struct nk_color in) {
	struct nk_colorf col;
	nk_color_f(&col.r, &col.g, &col.b, &col.a, in);
	nk_colorf_hsva_f(out_h, out_s, out_v, out_a, col);
}

NK_API void nk_color_hsva_fv(float* out, struct nk_color in) {
	nk_color_hsva_f(&out[0], &out[1], &out[2], &out[3], in);
}

NK_API void nk_color_hsva_i(int* out_h, int* out_s, int* out_v, int* out_a, struct nk_color in) {
	float h, s, v, a;
	nk_color_hsva_f(&h, &s, &v, &a, in);
	*out_h = (nk_byte)(h * 255.0f);
	*out_s = (nk_byte)(s * 255.0f);
	*out_v = (nk_byte)(v * 255.0f);
	*out_a = (nk_byte)(a * 255.0f);
}

NK_API void nk_color_hsva_iv(int* out, struct nk_color in) {
	nk_color_hsva_i(&out[0], &out[1], &out[2], &out[3], in);
}

NK_API void nk_color_hsva_bv(nk_byte* out, struct nk_color in) {
	int tmp[4];
	nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], in);
	out[0] = (nk_byte)tmp[0];
	out[1] = (nk_byte)tmp[1];
	out[2] = (nk_byte)tmp[2];
	out[3] = (nk_byte)tmp[3];
}

NK_API void nk_color_hsva_b(nk_byte* h, nk_byte* s, nk_byte* v, nk_byte* a, struct nk_color in) {
	int tmp[4];
	nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], in);
	*h = (nk_byte)tmp[0];
	*s = (nk_byte)tmp[1];
	*v = (nk_byte)tmp[2];
	*a = (nk_byte)tmp[3];
}

NK_API void nk_color_hsv_i(int* out_h, int* out_s, int* out_v, struct nk_color in) {
	int a;
	nk_color_hsva_i(out_h, out_s, out_v, &a, in);
}

NK_API void nk_color_hsv_b(nk_byte* out_h, nk_byte* out_s, nk_byte* out_v, struct nk_color in) {
	int tmp[4];
	nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], in);
	*out_h = (nk_byte)tmp[0];
	*out_s = (nk_byte)tmp[1];
	*out_v = (nk_byte)tmp[2];
}

NK_API void nk_color_hsv_iv(int* out, struct nk_color in) {
	nk_color_hsv_i(&out[0], &out[1], &out[2], in);
}

NK_API void nk_color_hsv_bv(nk_byte* out, struct nk_color in) {
	int tmp[4];
	nk_color_hsv_i(&tmp[0], &tmp[1], &tmp[2], in);
	out[0] = (nk_byte)tmp[0];
	out[1] = (nk_byte)tmp[1];
	out[2] = (nk_byte)tmp[2];
}





/* ===============================================================
 *
 *                              UTF-8
 *
 * ===============================================================*/
NK_GLOBAL const nk_byte nk_utfbyte[NK_UTF_SIZE + 1] = { 0x80, 0, 0xC0, 0xE0, 0xF0 };
NK_GLOBAL const nk_byte nk_utfmask[NK_UTF_SIZE + 1] = { 0xC0, 0x80, 0xE0, 0xF0, 0xF8 };
NK_GLOBAL const nk_uint nk_utfmin[NK_UTF_SIZE + 1] = { 0, 0, 0x80, 0x800, 0x10000 };
NK_GLOBAL const nk_uint nk_utfmax[NK_UTF_SIZE + 1] = { 0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF };

NK_INTERN int nk_utf_validate(nk_rune* u, int i) {
	NK_ASSERT(u);
	if (!u) return 0;
	if (!NK_BETWEEN(*u, nk_utfmin[i], nk_utfmax[i]) || NK_BETWEEN(*u, 0xD800, 0xDFFF))
		*u = NK_UTF_INVALID;
	for (i = 1; *u > nk_utfmax[i]; ++i);
	return i;
}

NK_INTERN nk_rune nk_utf_decode_byte(char c, int* i) {
	NK_ASSERT(i);
	if (!i) return 0;
	for (*i = 0; *i < (int)NK_LEN(nk_utfmask);
		++(*i)) {
		if (((nk_byte)c & nk_utfmask[*i]) == nk_utfbyte[*i])
			return (nk_byte)(c & ~nk_utfmask[*i]);
	}
	return 0;
}

NK_API int nk_utf_decode(const char* c, nk_rune* u, int clen) {
	int i, j, len, type = 0;
	nk_rune udecoded;

	NK_ASSERT(c);
	NK_ASSERT(u);

	if (!c || !u) return 0;
	if (!clen) return 0;
	*u = NK_UTF_INVALID;

	udecoded = nk_utf_decode_byte(c[0], &len);
	if (!NK_BETWEEN(len, 1, NK_UTF_SIZE))
		return 1;

	for (i = 1, j = 1; i < clen && j < len; ++i, ++j) {
		udecoded = (udecoded << 6) | nk_utf_decode_byte(c[i], &type);
		if (type != 0)
			return j;
	}
	if (j < len)
		return 0;
	*u = udecoded;
	nk_utf_validate(u, len);
	return len;
}

NK_INTERN char nk_utf_encode_byte(nk_rune u, int i) {
	return (char)((nk_utfbyte[i]) | ((nk_byte)u & ~nk_utfmask[i]));
}

NK_API int nk_utf_encode(nk_rune u, char* c, int clen) {
	int len, i;
	len = nk_utf_validate(&u, 0);
	if (clen < len || !len || len > NK_UTF_SIZE)
		return 0;

	for (i = len - 1; i != 0; --i) {
		c[i] = nk_utf_encode_byte(u, 0);
		u >>= 6;
	}
	c[0] = nk_utf_encode_byte(u, len);
	return len;
}

NK_API int nk_utf_len(const char* str, int len) {
	const char* text;
	int glyphs = 0;
	int text_len;
	int glyph_len;
	int src_len = 0;
	nk_rune unicode;

	NK_ASSERT(str);
	if (!str || !len) return 0;

	text = str;
	text_len = len;
	glyph_len = nk_utf_decode(text, &unicode, text_len);
	while (glyph_len && src_len < len) {
		glyphs++;
		src_len = src_len + glyph_len;
		glyph_len = nk_utf_decode(text + src_len, &unicode, text_len - src_len);
	}
	return glyphs;
}

NK_API const char* nk_utf_at(const char* buffer, int length, int index, nk_rune* unicode, int* len) {
	int i = 0;
	int src_len = 0;
	int glyph_len = 0;
	const char* text;
	int text_len;

	NK_ASSERT(buffer);
	NK_ASSERT(unicode);
	NK_ASSERT(len);

	if (!buffer || !unicode || !len) return 0;
	if (index < 0) {
		*unicode = NK_UTF_INVALID;
		*len = 0;
		return 0;
	}

	text = buffer;
	text_len = length;
	glyph_len = nk_utf_decode(text, unicode, text_len);
	while (glyph_len) {
		if (i == index) {
			*len = glyph_len;
			break;
		}

		i++;
		src_len = src_len + glyph_len;
		glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);
	}
	if (i != index) return 0;
	return buffer + src_len;
}





/* ==============================================================
 *
 *                          BUFFER
 *
 * ===============================================================*/
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

NK_LIB void* nk_malloc(nk_handle unused, void* old, nk_size size) {
	NK_UNUSED(unused);
	NK_UNUSED(old);
	return malloc(size);
}

NK_LIB void nk_mfree(nk_handle unused, void* ptr) {
	NK_UNUSED(unused);
	free(ptr);
}

NK_API void nk_buffer_init_default(struct nk_buffer* buffer) {
	struct nk_allocator alloc;
	alloc.userdata.ptr = 0;
	alloc.alloc = nk_malloc;
	alloc.free = nk_mfree;
	nk_buffer_init(buffer, &alloc, NK_BUFFER_DEFAULT_INITIAL_SIZE);
}

#endif

NK_API void nk_buffer_init(struct nk_buffer* b, const struct nk_allocator* a, nk_size initial_size) {
	NK_ASSERT(b);
	NK_ASSERT(a);
	NK_ASSERT(initial_size);
	if (!b || !a || !initial_size) return;

	nk_zero(b, sizeof(*b));
	b->type = NK_BUFFER_DYNAMIC;
	b->memory.ptr = a->alloc(a->userdata, 0, initial_size);
	b->memory.size = initial_size;
	b->size = initial_size;
	b->grow_factor = 2.0f;
	b->pool = *a;
}

NK_API void nk_buffer_init_fixed(struct nk_buffer* b, void* m, nk_size size) {
	NK_ASSERT(b);
	NK_ASSERT(m);
	NK_ASSERT(size);
	if (!b || !m || !size) return;

	nk_zero(b, sizeof(*b));
	b->type = NK_BUFFER_FIXED;
	b->memory.ptr = m;
	b->memory.size = size;
	b->size = size;
}

NK_LIB void* nk_buffer_align(void* unaligned, nk_size align, nk_size* alignment, enum nk_buffer_allocation_type type) {
	void* memory = 0;
	switch (type) {
	default:
	case NK_BUFFER_MAX:
	case NK_BUFFER_FRONT:
		if (align) {
			memory = NK_ALIGN_PTR(unaligned, align);
			*alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned);
		}
		else {
			memory = unaligned;
			*alignment = 0;
		}
		break;
	case NK_BUFFER_BACK:
		if (align) {
			memory = NK_ALIGN_PTR_BACK(unaligned, align);
			*alignment = (nk_size)((nk_byte*)unaligned - (nk_byte*)memory);
		}
		else {
			memory = unaligned;
			*alignment = 0;
		}
		break;
	}
	return memory;
}

NK_LIB void* nk_buffer_realloc(struct nk_buffer* b, nk_size capacity, nk_size* size) {
	void* temp;
	nk_size buffer_size;

	NK_ASSERT(b);
	NK_ASSERT(size);
	if (!b || !size || !b->pool.alloc || !b->pool.free)
		return 0;

	buffer_size = b->memory.size;
	temp = b->pool.alloc(b->pool.userdata, b->memory.ptr, capacity);
	NK_ASSERT(temp);
	if (!temp) return 0;

	*size = capacity;
	if (temp != b->memory.ptr) {
		NK_MEMCPY(temp, b->memory.ptr, buffer_size);
		b->pool.free(b->pool.userdata, b->memory.ptr);
	}

	if (b->size == buffer_size) {
		/* no back buffer so just set correct size */
		b->size = capacity;
		return temp;
	}
	else {
		/* copy back buffer to the end of the new buffer */
		void* dst, * src;
		nk_size back_size;
		back_size = buffer_size - b->size;
		dst = nk_ptr_add(void, temp, capacity - back_size);
		src = nk_ptr_add(void, temp, b->size);
		NK_MEMCPY(dst, src, back_size);
		b->size = capacity - back_size;
	}
	return temp;
}

NK_LIB void* nk_buffer_alloc(struct nk_buffer* b, enum nk_buffer_allocation_type type, nk_size size, nk_size align) {
	int full;
	nk_size alignment;
	void* unaligned;
	void* memory;

	NK_ASSERT(b);
	NK_ASSERT(size);
	if (!b || !size) return 0;
	b->needed += size;

	/* calculate total size with needed alignment + size */
	if (type == NK_BUFFER_FRONT)
		unaligned = nk_ptr_add(void, b->memory.ptr, b->allocated);
	else unaligned = nk_ptr_add(void, b->memory.ptr, b->size - size);
	memory = nk_buffer_align(unaligned, align, &alignment, type);

	/* check if buffer has enough memory*/
	if (type == NK_BUFFER_FRONT)
		full = ((b->allocated + size + alignment) > b->size);
	else full = ((b->size - NK_MIN(b->size, (size + alignment))) <= b->allocated);

	if (full) {
		nk_size capacity;
		if (b->type != NK_BUFFER_DYNAMIC)
			return 0;
		NK_ASSERT(b->pool.alloc && b->pool.free);
		if (b->type != NK_BUFFER_DYNAMIC || !b->pool.alloc || !b->pool.free)
			return 0;

		/* buffer is full so allocate bigger buffer if dynamic */
		capacity = (nk_size)((float)b->memory.size * b->grow_factor);
		capacity = NK_MAX(capacity, nk_round_up_pow2((nk_uint)(b->allocated + size)));
		b->memory.ptr = nk_buffer_realloc(b, capacity, &b->memory.size);
		if (!b->memory.ptr) return 0;

		/* align newly allocated pointer */
		if (type == NK_BUFFER_FRONT)
			unaligned = nk_ptr_add(void, b->memory.ptr, b->allocated);
		else unaligned = nk_ptr_add(void, b->memory.ptr, b->size - size);
		memory = nk_buffer_align(unaligned, align, &alignment, type);
	}
	if (type == NK_BUFFER_FRONT)
		b->allocated += size + alignment;
	else b->size -= (size + alignment);
	b->needed += alignment;
	b->calls++;
	return memory;
}

NK_API void nk_buffer_push(struct nk_buffer* b, enum nk_buffer_allocation_type type, const void* memory, nk_size size,
	nk_size align) {
	void* mem = nk_buffer_alloc(b, type, size, align);
	if (!mem) return;
	NK_MEMCPY(mem, memory, size);
}

NK_API void nk_buffer_mark(struct nk_buffer* buffer, enum nk_buffer_allocation_type type) {
	NK_ASSERT(buffer);
	if (!buffer) return;
	buffer->marker[type].active = nk_true;
	if (type == NK_BUFFER_BACK)
		buffer->marker[type].offset = buffer->size;
	else buffer->marker[type].offset = buffer->allocated;
}

NK_API void nk_buffer_reset(struct nk_buffer* buffer, enum nk_buffer_allocation_type type) {
	NK_ASSERT(buffer);
	if (!buffer) return;
	if (type == NK_BUFFER_BACK) {
		/* reset back buffer either back to marker or empty */
		buffer->needed -= (buffer->memory.size - buffer->marker[type].offset);
		if (buffer->marker[type].active)
			buffer->size = buffer->marker[type].offset;
		else buffer->size = buffer->memory.size;
		buffer->marker[type].active = nk_false;
	}
	else {
		/* reset front buffer either back to back marker or empty */
		buffer->needed -= (buffer->allocated - buffer->marker[type].offset);
		if (buffer->marker[type].active)
			buffer->allocated = buffer->marker[type].offset;
		else buffer->allocated = 0;
		buffer->marker[type].active = nk_false;
	}
}

NK_API void nk_buffer_clear(struct nk_buffer* b) {
	NK_ASSERT(b);
	if (!b) return;
	b->allocated = 0;
	b->size = b->memory.size;
	b->calls = 0;
	b->needed = 0;
}

NK_API void nk_buffer_free(struct nk_buffer* b) {
	NK_ASSERT(b);
	if (!b || !b->memory.ptr) return;
	if (b->type == NK_BUFFER_FIXED) return;
	if (!b->pool.free) return;
	NK_ASSERT(b->pool.free);
	b->pool.free(b->pool.userdata, b->memory.ptr);
}

NK_API void nk_buffer_info(struct nk_memory_status* s, struct nk_buffer* b) {
	NK_ASSERT(b);
	NK_ASSERT(s);
	if (!s || !b) return;
	s->allocated = b->allocated;
	s->size = b->memory.size;
	s->needed = b->needed;
	s->memory = b->memory.ptr;
	s->calls = b->calls;
}

NK_API void* nk_buffer_memory(struct nk_buffer* buffer) {
	NK_ASSERT(buffer);
	if (!buffer) return 0;
	return buffer->memory.ptr;
}

NK_API const void* nk_buffer_memory_const(const struct nk_buffer* buffer) {
	NK_ASSERT(buffer);
	if (!buffer) return 0;
	return buffer->memory.ptr;
}

NK_API nk_size nk_buffer_total(struct nk_buffer* buffer) {
	NK_ASSERT(buffer);
	if (!buffer) return 0;
	return buffer->memory.size;
}





/* ===============================================================
 *
 *                              STRING
 *
 * ===============================================================*/
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

NK_API void nk_str_init_default(struct nk_str* str) {
	struct nk_allocator alloc;
	alloc.userdata.ptr = 0;
	alloc.alloc = nk_malloc;
	alloc.free = nk_mfree;
	nk_buffer_init(&str->buffer, &alloc, 32);
	str->len = 0;
}

#endif

NK_API void nk_str_init(struct nk_str* str, const struct nk_allocator* alloc, nk_size size) {
	nk_buffer_init(&str->buffer, alloc, size);
	str->len = 0;
}

NK_API void nk_str_init_fixed(struct nk_str* str, void* memory, nk_size size) {
	nk_buffer_init_fixed(&str->buffer, memory, size);
	str->len = 0;
}

NK_API int nk_str_append_text_char(struct nk_str* s, const char* str, int len) {
	char* mem;
	NK_ASSERT(s);
	NK_ASSERT(str);
	if (!s || !str || !len) return 0;
	mem = (char*)nk_buffer_alloc(&s->buffer, NK_BUFFER_FRONT, (nk_size)len * sizeof(char), 0);
	if (!mem) return 0;
	NK_MEMCPY(mem, str, (nk_size)len * sizeof(char));
	s->len += nk_utf_len(str, len);
	return len;
}

NK_API int nk_str_append_str_char(struct nk_str* s, const char* str) {
	return nk_str_append_text_char(s, str, nk_strlen(str));
}

NK_API int nk_str_append_text_utf8(struct nk_str* str, const char* text, int len) {
	int i = 0;
	int byte_len = 0;
	nk_rune unicode;
	if (!str || !text || !len) return 0;
	for (i = 0; i < len; ++i)
		byte_len += nk_utf_decode(text + byte_len, &unicode, 4);
	nk_str_append_text_char(str, text, byte_len);
	return len;
}

NK_API int nk_str_append_str_utf8(struct nk_str* str, const char* text) {
	int runes = 0;
	int byte_len = 0;
	int num_runes = 0;
	int glyph_len = 0;
	nk_rune unicode;
	if (!str || !text) return 0;

	glyph_len = byte_len = nk_utf_decode(text + byte_len, &unicode, 4);
	while (unicode != '\0' && glyph_len) {
		glyph_len = nk_utf_decode(text + byte_len, &unicode, 4);
		byte_len += glyph_len;
		num_runes++;
	}
	nk_str_append_text_char(str, text, byte_len);
	return runes;
}

NK_API int nk_str_append_text_runes(struct nk_str* str, const nk_rune* text, int len) {
	int i = 0;
	int byte_len = 0;
	nk_glyph glyph;

	NK_ASSERT(str);
	if (!str || !text || !len) return 0;
	for (i = 0; i < len; ++i) {
		byte_len = nk_utf_encode(text[i], glyph, NK_UTF_SIZE);
		if (!byte_len) break;
		nk_str_append_text_char(str, glyph, byte_len);
	}
	return len;
}

NK_API int nk_str_append_str_runes(struct nk_str* str, const nk_rune* runes) {
	int i = 0;
	nk_glyph glyph;
	int byte_len;
	NK_ASSERT(str);
	if (!str || !runes) return 0;
	while (runes[i] != '\0') {
		byte_len = nk_utf_encode(runes[i], glyph, NK_UTF_SIZE);
		nk_str_append_text_char(str, glyph, byte_len);
		i++;
	}
	return i;
}

NK_API int nk_str_insert_at_char(struct nk_str* s, int pos, const char* str, int len) {
	int i;
	void* mem;
	char* src;
	char* dst;

	int copylen;
	NK_ASSERT(s);
	NK_ASSERT(str);
	NK_ASSERT(len >= 0);
	if (!s || !str || !len || (nk_size)pos > s->buffer.allocated) return 0;
	if ((s->buffer.allocated + (nk_size)len >= s->buffer.memory.size) && (s->buffer.type == NK_BUFFER_FIXED)) return 0;

	copylen = (int)s->buffer.allocated - pos;
	if (!copylen) {
		nk_str_append_text_char(s, str, len);
		return 1;
	}
	mem = nk_buffer_alloc(&s->buffer, NK_BUFFER_FRONT, (nk_size)len * sizeof(char), 0);
	if (!mem) return 0;

	/* memmove */
	NK_ASSERT(((int)pos + (int)len + ((int)copylen - 1)) >= 0);
	NK_ASSERT(((int)pos + ((int)copylen - 1)) >= 0);
	dst = nk_ptr_add(char, s->buffer.memory.ptr, pos + len + (copylen - 1));
	src = nk_ptr_add(char, s->buffer.memory.ptr, pos + (copylen - 1));
	for (i = 0; i < copylen; ++i) *dst-- = *src--;
	mem = nk_ptr_add(void, s->buffer.memory.ptr, pos);
	NK_MEMCPY(mem, str, (nk_size)len * sizeof(char));
	s->len = nk_utf_len((char*)s->buffer.memory.ptr, (int)s->buffer.allocated);
	return 1;
}

NK_API int nk_str_insert_at_rune(struct nk_str* str, int pos, const char* cstr, int len) {
	int glyph_len;
	nk_rune unicode;
	const char* begin;
	const char* buffer;

	NK_ASSERT(str);
	NK_ASSERT(cstr);
	NK_ASSERT(len);
	if (!str || !cstr || !len) return 0;
	begin = nk_str_at_rune(str, pos, &unicode, &glyph_len);
	if (!str->len)
		return nk_str_append_text_char(str, cstr, len);
	buffer = nk_str_get_const(str);
	if (!begin) return 0;
	return nk_str_insert_at_char(str, (int)(begin - buffer), cstr, len);
}

NK_API int nk_str_insert_text_char(struct nk_str* str, int pos, const char* text, int len) {
	return nk_str_insert_text_utf8(str, pos, text, len);
}

NK_API int nk_str_insert_str_char(struct nk_str* str, int pos, const char* text) {
	return nk_str_insert_text_utf8(str, pos, text, nk_strlen(text));
}

NK_API int nk_str_insert_text_utf8(struct nk_str* str, int pos, const char* text, int len) {
	int i = 0;
	int byte_len = 0;
	nk_rune unicode;

	NK_ASSERT(str);
	NK_ASSERT(text);
	if (!str || !text || !len) return 0;
	for (i = 0; i < len; ++i)
		byte_len += nk_utf_decode(text + byte_len, &unicode, 4);
	nk_str_insert_at_rune(str, pos, text, byte_len);
	return len;
}

NK_API int nk_str_insert_str_utf8(struct nk_str* str, int pos, const char* text) {
	int runes = 0;
	int byte_len = 0;
	int num_runes = 0;
	int glyph_len = 0;
	nk_rune unicode;
	if (!str || !text) return 0;

	glyph_len = byte_len = nk_utf_decode(text + byte_len, &unicode, 4);
	while (unicode != '\0' && glyph_len) {
		glyph_len = nk_utf_decode(text + byte_len, &unicode, 4);
		byte_len += glyph_len;
		num_runes++;
	}
	nk_str_insert_at_rune(str, pos, text, byte_len);
	return runes;
}

NK_API int nk_str_insert_text_runes(struct nk_str* str, int pos, const nk_rune* runes, int len) {
	int i = 0;
	int byte_len = 0;
	nk_glyph glyph;

	NK_ASSERT(str);
	if (!str || !runes || !len) return 0;
	for (i = 0; i < len; ++i) {
		byte_len = nk_utf_encode(runes[i], glyph, NK_UTF_SIZE);
		if (!byte_len) break;
		nk_str_insert_at_rune(str, pos + i, glyph, byte_len);
	}
	return len;
}

NK_API int nk_str_insert_str_runes(struct nk_str* str, int pos, const nk_rune* runes) {
	int i = 0;
	nk_glyph glyph;
	int byte_len;
	NK_ASSERT(str);
	if (!str || !runes) return 0;
	while (runes[i] != '\0') {
		byte_len = nk_utf_encode(runes[i], glyph, NK_UTF_SIZE);
		nk_str_insert_at_rune(str, pos + i, glyph, byte_len);
		i++;
	}
	return i;
}

NK_API void nk_str_remove_chars(struct nk_str* s, int len) {
	NK_ASSERT(s);
	NK_ASSERT(len >= 0);
	if (!s || len < 0 || (nk_size)len > s->buffer.allocated) return;
	NK_ASSERT(((int)s->buffer.allocated - (int)len) >= 0);
	s->buffer.allocated -= (nk_size)len;
	s->len = nk_utf_len((char*)s->buffer.memory.ptr, (int)s->buffer.allocated);
}

NK_API void nk_str_remove_runes(struct nk_str* str, int len) {
	int index;
	const char* begin;
	const char* end;
	nk_rune unicode;

	NK_ASSERT(str);
	NK_ASSERT(len >= 0);
	if (!str || len < 0) return;
	if (len >= str->len) {
		str->len = 0;
		return;
	}

	index = str->len - len;
	begin = nk_str_at_rune(str, index, &unicode, &len);
	end = (const char*)str->buffer.memory.ptr + str->buffer.allocated;
	nk_str_remove_chars(str, (int)(end - begin) + 1);
}

NK_API void nk_str_delete_chars(struct nk_str* s, int pos, int len) {
	NK_ASSERT(s);
	if (!s || !len || (nk_size)pos > s->buffer.allocated || (nk_size)(pos + len) > s->buffer.allocated) return;

	if ((nk_size)(pos + len) < s->buffer.allocated) {
		/* memmove */
		char* dst = nk_ptr_add(char, s->buffer.memory.ptr, pos);
		char* src = nk_ptr_add(char, s->buffer.memory.ptr, pos + len);
		NK_MEMCPY(dst, src, s->buffer.allocated - (nk_size)(pos + len));
		NK_ASSERT(((int)s->buffer.allocated - (int)len) >= 0);
		s->buffer.allocated -= (nk_size)len;
	}
	else nk_str_remove_chars(s, len);
	s->len = nk_utf_len((char*)s->buffer.memory.ptr, (int)s->buffer.allocated);
}

NK_API void nk_str_delete_runes(struct nk_str* s, int pos, int len) {
	char* temp;
	nk_rune unicode;
	char* begin;
	char* end;
	int unused;

	NK_ASSERT(s);
	NK_ASSERT(s->len >= pos + len);
	if (s->len < pos + len)
		len = NK_CLAMP(0, (s->len - pos), s->len);
	if (!len) return;

	temp = (char*)s->buffer.memory.ptr;
	begin = nk_str_at_rune(s, pos, &unicode, &unused);
	if (!begin) return;
	s->buffer.memory.ptr = begin;
	end = nk_str_at_rune(s, len, &unicode, &unused);
	s->buffer.memory.ptr = temp;
	if (!end) return;
	nk_str_delete_chars(s, (int)(begin - temp), (int)(end - begin));
}

NK_API char* nk_str_at_char(struct nk_str* s, int pos) {
	NK_ASSERT(s);
	if (!s || pos > (int)s->buffer.allocated) return 0;
	return nk_ptr_add(char, s->buffer.memory.ptr, pos);
}

NK_API char* nk_str_at_rune(struct nk_str* str, int pos, nk_rune* unicode, int* len) {
	int i = 0;
	int src_len = 0;
	int glyph_len = 0;
	char* text;
	int text_len;

	NK_ASSERT(str);
	NK_ASSERT(unicode);
	NK_ASSERT(len);

	if (!str || !unicode || !len) return 0;
	if (pos < 0) {
		*unicode = 0;
		*len = 0;
		return 0;
	}

	text = (char*)str->buffer.memory.ptr;
	text_len = (int)str->buffer.allocated;
	glyph_len = nk_utf_decode(text, unicode, text_len);
	while (glyph_len) {
		if (i == pos) {
			*len = glyph_len;
			break;
		}

		i++;
		src_len = src_len + glyph_len;
		glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);
	}
	if (i != pos) return 0;
	return text + src_len;
}

NK_API const char* nk_str_at_char_const(const struct nk_str* s, int pos) {
	NK_ASSERT(s);
	if (!s || pos > (int)s->buffer.allocated) return 0;
	return nk_ptr_add(char, s->buffer.memory.ptr, pos);
}

NK_API const char* nk_str_at_const(const struct nk_str* str, int pos, nk_rune* unicode, int* len) {
	int i = 0;
	int src_len = 0;
	int glyph_len = 0;
	char* text;
	int text_len;

	NK_ASSERT(str);
	NK_ASSERT(unicode);
	NK_ASSERT(len);

	if (!str || !unicode || !len) return 0;
	if (pos < 0) {
		*unicode = 0;
		*len = 0;
		return 0;
	}

	text = (char*)str->buffer.memory.ptr;
	text_len = (int)str->buffer.allocated;
	glyph_len = nk_utf_decode(text, unicode, text_len);
	while (glyph_len) {
		if (i == pos) {
			*len = glyph_len;
			break;
		}

		i++;
		src_len = src_len + glyph_len;
		glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);
	}
	if (i != pos) return 0;
	return text + src_len;
}

NK_API nk_rune nk_str_rune_at(const struct nk_str* str, int pos) {
	int len;
	nk_rune unicode = 0;
	nk_str_at_const(str, pos, &unicode, &len);
	return unicode;
}

NK_API char* nk_str_get(struct nk_str* s) {
	NK_ASSERT(s);
	if (!s || !s->len || !s->buffer.allocated) return 0;
	return (char*)s->buffer.memory.ptr;
}

NK_API const char* nk_str_get_const(const struct nk_str* s) {
	NK_ASSERT(s);
	if (!s || !s->len || !s->buffer.allocated) return 0;
	return (const char*)s->buffer.memory.ptr;
}

NK_API int nk_str_len(struct nk_str* s) {
	NK_ASSERT(s);
	if (!s || !s->len || !s->buffer.allocated) return 0;
	return s->len;
}

NK_API int nk_str_len_char(struct nk_str* s) {
	NK_ASSERT(s);
	if (!s || !s->len || !s->buffer.allocated) return 0;
	return (int)s->buffer.allocated;
}

NK_API void nk_str_clear(struct nk_str* str) {
	NK_ASSERT(str);
	nk_buffer_clear(&str->buffer);
	str->len = 0;
}

NK_API void nk_str_free(struct nk_str* str) {
	NK_ASSERT(str);
	nk_buffer_free(&str->buffer);
	str->len = 0;
}





/* ==============================================================
 *
 *                          DRAW
 *
 * ===============================================================*/
NK_LIB void nk_command_buffer_init(struct nk_command_buffer* cb, struct nk_buffer* b, enum nk_command_clipping clip) {
	NK_ASSERT(cb);
	NK_ASSERT(b);
	if (!cb || !b) return;
	cb->base = b;
	cb->use_clipping = (int)clip;
	cb->begin = b->allocated;
	cb->end = b->allocated;
	cb->last = b->allocated;
}

NK_LIB void nk_command_buffer_reset(struct nk_command_buffer* b) {
	NK_ASSERT(b);
	if (!b) return;
	b->begin = 0;
	b->end = 0;
	b->last = 0;
	b->clip = nk_null_rect;
#ifdef NK_INCLUDE_COMMAND_USERDATA
	b->userdata.ptr = 0;
#endif
}

NK_LIB void* nk_command_buffer_push(struct nk_command_buffer* b, enum nk_command_type t, nk_size size) {
	NK_STORAGE const nk_size align = NK_ALIGNOF(struct nk_command);
	struct nk_command* cmd;
	nk_size alignment;
	void* unaligned;
	void* memory;

	NK_ASSERT(b);
	NK_ASSERT(b->base);
	if (!b) return 0;
	cmd = (struct nk_command*) nk_buffer_alloc(b->base, NK_BUFFER_FRONT, size, align);
	if (!cmd) return 0;

	/* make sure the offset to the next command is aligned */
	b->last = (nk_size)((nk_byte*)cmd - (nk_byte*)b->base->memory.ptr);
	unaligned = (nk_byte*)cmd + size;
	memory = NK_ALIGN_PTR(unaligned, align);
	alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned);
#ifdef NK_ZERO_COMMAND_MEMORY
	NK_MEMSET(cmd, 0, size + alignment);
#endif

	cmd->type = t;
	cmd->next = b->base->allocated + alignment;
#ifdef NK_INCLUDE_COMMAND_USERDATA
	cmd->userdata = b->userdata;
#endif
	b->end = cmd->next;
	return cmd;
}

NK_API void nk_push_scissor(struct nk_command_buffer* b, struct nk_rect r) {
	struct nk_command_scissor* cmd;
	NK_ASSERT(b);
	if (!b) return;

	b->clip.x = r.x;
	b->clip.y = r.y;
	b->clip.w = r.w;
	b->clip.h = r.h;
	cmd = (struct nk_command_scissor*) nk_command_buffer_push(b, NK_COMMAND_SCISSOR, sizeof(*cmd));

	if (!cmd) return;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)NK_MAX(0, r.w);
	cmd->h = (unsigned short)NK_MAX(0, r.h);
}

NK_API void nk_stroke_line(struct nk_command_buffer* b, float x0, float y0, float x1, float y1, float line_thickness,
	struct nk_color c) {
	struct nk_command_line* cmd;
	NK_ASSERT(b);
	if (!b || line_thickness <= 0) return;
	cmd = (struct nk_command_line*) nk_command_buffer_push(b, NK_COMMAND_LINE, sizeof(*cmd));
	if (!cmd) return;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->begin.x = (short)x0;
	cmd->begin.y = (short)y0;
	cmd->end.x = (short)x1;
	cmd->end.y = (short)y1;
	cmd->color = c;
}

NK_API void
nk_stroke_curve(struct nk_command_buffer* b, float ax, float ay, float ctrl0x, float ctrl0y, float ctrl1x, float ctrl1y,
	float bx, float by, float line_thickness, struct nk_color col) {
	struct nk_command_curve* cmd;
	NK_ASSERT(b);
	if (!b || col.a == 0 || line_thickness <= 0) return;

	cmd = (struct nk_command_curve*) nk_command_buffer_push(b, NK_COMMAND_CURVE, sizeof(*cmd));
	if (!cmd) return;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->begin.x = (short)ax;
	cmd->begin.y = (short)ay;
	cmd->ctrl[0].x = (short)ctrl0x;
	cmd->ctrl[0].y = (short)ctrl0y;
	cmd->ctrl[1].x = (short)ctrl1x;
	cmd->ctrl[1].y = (short)ctrl1y;
	cmd->end.x = (short)bx;
	cmd->end.y = (short)by;
	cmd->color = col;
}

NK_API void nk_stroke_rect(struct nk_command_buffer* b, struct nk_rect rect, float rounding, float line_thickness,
	struct nk_color c) {
	struct nk_command_rect* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0 || rect.w == 0 || rect.h == 0 || line_thickness <= 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h, clip->x, clip->y, clip->w, clip->h)) return;
	}
	cmd = (struct nk_command_rect*) nk_command_buffer_push(b, NK_COMMAND_RECT, sizeof(*cmd));
	if (!cmd) return;
	cmd->rounding = (unsigned short)rounding;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->x = (short)rect.x;
	cmd->y = (short)rect.y;
	cmd->w = (unsigned short)NK_MAX(0, rect.w);
	cmd->h = (unsigned short)NK_MAX(0, rect.h);
	cmd->color = c;
}

NK_API void nk_fill_rect(struct nk_command_buffer* b, struct nk_rect rect, float rounding, struct nk_color c) {
	struct nk_command_rect_filled* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0 || rect.w == 0 || rect.h == 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h, clip->x, clip->y, clip->w, clip->h)) return;
	}

	cmd = (struct nk_command_rect_filled*) nk_command_buffer_push(b, NK_COMMAND_RECT_FILLED, sizeof(*cmd));
	if (!cmd) return;
	cmd->rounding = (unsigned short)rounding;
	cmd->x = (short)rect.x;
	cmd->y = (short)rect.y;
	cmd->w = (unsigned short)NK_MAX(0, rect.w);
	cmd->h = (unsigned short)NK_MAX(0, rect.h);
	cmd->color = c;
}

NK_API void
nk_fill_rect_multi_color(struct nk_command_buffer* b, struct nk_rect rect, struct nk_color left, struct nk_color top,
	struct nk_color right, struct nk_color bottom) {
	struct nk_command_rect_multi_color* cmd;
	NK_ASSERT(b);
	if (!b || rect.w == 0 || rect.h == 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h, clip->x, clip->y, clip->w, clip->h)) return;
	}

	cmd = (struct nk_command_rect_multi_color*) nk_command_buffer_push(b, NK_COMMAND_RECT_MULTI_COLOR, sizeof(*cmd));
	if (!cmd) return;
	cmd->x = (short)rect.x;
	cmd->y = (short)rect.y;
	cmd->w = (unsigned short)NK_MAX(0, rect.w);
	cmd->h = (unsigned short)NK_MAX(0, rect.h);
	cmd->left = left;
	cmd->top = top;
	cmd->right = right;
	cmd->bottom = bottom;
}

NK_API void nk_stroke_circle(struct nk_command_buffer* b, struct nk_rect r, float line_thickness, struct nk_color c) {
	struct nk_command_circle* cmd;
	if (!b || r.w == 0 || r.h == 0 || line_thickness <= 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INTERSECT(r.x, r.y, r.w, r.h, clip->x, clip->y, clip->w, clip->h))
			return;
	}

	cmd = (struct nk_command_circle*) nk_command_buffer_push(b, NK_COMMAND_CIRCLE, sizeof(*cmd));
	if (!cmd) return;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)NK_MAX(r.w, 0);
	cmd->h = (unsigned short)NK_MAX(r.h, 0);
	cmd->color = c;
}

NK_API void nk_fill_circle(struct nk_command_buffer* b, struct nk_rect r, struct nk_color c) {
	struct nk_command_circle_filled* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0 || r.w == 0 || r.h == 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INTERSECT(r.x, r.y, r.w, r.h, clip->x, clip->y, clip->w, clip->h))
			return;
	}

	cmd = (struct nk_command_circle_filled*) nk_command_buffer_push(b, NK_COMMAND_CIRCLE_FILLED, sizeof(*cmd));
	if (!cmd) return;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)NK_MAX(r.w, 0);
	cmd->h = (unsigned short)NK_MAX(r.h, 0);
	cmd->color = c;
}

NK_API void nk_stroke_arc(struct nk_command_buffer* b, float cx, float cy, float radius, float a_min, float a_max,
	float line_thickness, struct nk_color c) {
	struct nk_command_arc* cmd;
	if (!b || c.a == 0 || line_thickness <= 0) return;
	cmd = (struct nk_command_arc*) nk_command_buffer_push(b, NK_COMMAND_ARC, sizeof(*cmd));
	if (!cmd) return;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->cx = (short)cx;
	cmd->cy = (short)cy;
	cmd->r = (unsigned short)radius;
	cmd->a[0] = a_min;
	cmd->a[1] = a_max;
	cmd->color = c;
}

NK_API void nk_fill_arc(struct nk_command_buffer* b, float cx, float cy, float radius, float a_min, float a_max,
	struct nk_color c) {
	struct nk_command_arc_filled* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0) return;
	cmd = (struct nk_command_arc_filled*) nk_command_buffer_push(b, NK_COMMAND_ARC_FILLED, sizeof(*cmd));
	if (!cmd) return;
	cmd->cx = (short)cx;
	cmd->cy = (short)cy;
	cmd->r = (unsigned short)radius;
	cmd->a[0] = a_min;
	cmd->a[1] = a_max;
	cmd->color = c;
}

NK_API void nk_stroke_triangle(struct nk_command_buffer* b, float x0, float y0, float x1, float y1, float x2, float y2,
	float line_thickness, struct nk_color c) {
	struct nk_command_triangle* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0 || line_thickness <= 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INBOX(x0, y0, clip->x, clip->y, clip->w, clip->h) &&
			!NK_INBOX(x1, y1, clip->x, clip->y, clip->w, clip->h) &&
			!NK_INBOX(x2, y2, clip->x, clip->y, clip->w, clip->h))
			return;
	}

	cmd = (struct nk_command_triangle*) nk_command_buffer_push(b, NK_COMMAND_TRIANGLE, sizeof(*cmd));
	if (!cmd) return;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->a.x = (short)x0;
	cmd->a.y = (short)y0;
	cmd->b.x = (short)x1;
	cmd->b.y = (short)y1;
	cmd->c.x = (short)x2;
	cmd->c.y = (short)y2;
	cmd->color = c;
}

NK_API void nk_fill_triangle(struct nk_command_buffer* b, float x0, float y0, float x1, float y1, float x2, float y2,
	struct nk_color c) {
	struct nk_command_triangle_filled* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0) return;
	if (!b) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INBOX(x0, y0, clip->x, clip->y, clip->w, clip->h) &&
			!NK_INBOX(x1, y1, clip->x, clip->y, clip->w, clip->h) &&
			!NK_INBOX(x2, y2, clip->x, clip->y, clip->w, clip->h))
			return;
	}

	cmd = (struct nk_command_triangle_filled*) nk_command_buffer_push(b, NK_COMMAND_TRIANGLE_FILLED, sizeof(*cmd));
	if (!cmd) return;
	cmd->a.x = (short)x0;
	cmd->a.y = (short)y0;
	cmd->b.x = (short)x1;
	cmd->b.y = (short)y1;
	cmd->c.x = (short)x2;
	cmd->c.y = (short)y2;
	cmd->color = c;
}

NK_API void nk_stroke_polygon(struct nk_command_buffer* b, float* points, int point_count, float line_thickness,
	struct nk_color col) {
	int i;
	nk_size size = 0;
	struct nk_command_polygon* cmd;

	NK_ASSERT(b);
	if (!b || col.a == 0 || line_thickness <= 0) return;
	size = sizeof(*cmd) + sizeof(short) * 2 * (nk_size)point_count;
	cmd = (struct nk_command_polygon*) nk_command_buffer_push(b, NK_COMMAND_POLYGON, size);
	if (!cmd) return;
	cmd->color = col;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->point_count = (unsigned short)point_count;
	for (i = 0; i < point_count; ++i) {
		cmd->points[i].x = (short)points[i * 2];
		cmd->points[i].y = (short)points[i * 2 + 1];
	}
}

NK_API void nk_fill_polygon(struct nk_command_buffer* b, float* points, int point_count, struct nk_color col) {
	int i;
	nk_size size = 0;
	struct nk_command_polygon_filled* cmd;

	NK_ASSERT(b);
	if (!b || col.a == 0) return;
	size = sizeof(*cmd) + sizeof(short) * 2 * (nk_size)point_count;
	cmd = (struct nk_command_polygon_filled*) nk_command_buffer_push(b, NK_COMMAND_POLYGON_FILLED, size);
	if (!cmd) return;
	cmd->color = col;
	cmd->point_count = (unsigned short)point_count;
	for (i = 0; i < point_count; ++i) {
		cmd->points[i].x = (short)points[i * 2 + 0];
		cmd->points[i].y = (short)points[i * 2 + 1];
	}
}

NK_API void nk_stroke_polyline(struct nk_command_buffer* b, float* points, int point_count, float line_thickness,
	struct nk_color col) {
	int i;
	nk_size size = 0;
	struct nk_command_polyline* cmd;

	NK_ASSERT(b);
	if (!b || col.a == 0 || line_thickness <= 0) return;
	size = sizeof(*cmd) + sizeof(short) * 2 * (nk_size)point_count;
	cmd = (struct nk_command_polyline*) nk_command_buffer_push(b, NK_COMMAND_POLYLINE, size);
	if (!cmd) return;
	cmd->color = col;
	cmd->point_count = (unsigned short)point_count;
	cmd->line_thickness = (unsigned short)line_thickness;
	for (i = 0; i < point_count; ++i) {
		cmd->points[i].x = (short)points[i * 2];
		cmd->points[i].y = (short)points[i * 2 + 1];
	}
}

NK_API void
nk_draw_image(struct nk_command_buffer* b, struct nk_rect r, const struct nk_image* img, struct nk_color col) {
	struct nk_command_image* cmd;
	NK_ASSERT(b);
	if (!b) return;
	if (b->use_clipping) {
		const struct nk_rect* c = &b->clip;
		if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
			return;
	}

	cmd = (struct nk_command_image*) nk_command_buffer_push(b, NK_COMMAND_IMAGE, sizeof(*cmd));
	if (!cmd) return;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)NK_MAX(0, r.w);
	cmd->h = (unsigned short)NK_MAX(0, r.h);
	cmd->img = *img;
	cmd->col = col;
}

NK_API void
nk_push_custom(struct nk_command_buffer* b, struct nk_rect r, nk_command_custom_callback cb, nk_handle usr) {
	struct nk_command_custom* cmd;
	NK_ASSERT(b);
	if (!b) return;
	if (b->use_clipping) {
		const struct nk_rect* c = &b->clip;
		if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
			return;
	}

	cmd = (struct nk_command_custom*) nk_command_buffer_push(b, NK_COMMAND_CUSTOM, sizeof(*cmd));
	if (!cmd) return;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)NK_MAX(0, r.w);
	cmd->h = (unsigned short)NK_MAX(0, r.h);
	cmd->callback_data = usr;
	cmd->callback = cb;
}

NK_API void nk_draw_text(struct nk_command_buffer* b, struct nk_rect r, const char* string, int length,
	const struct nk_user_font* font, struct nk_color bg, struct nk_color fg) {
	float text_width = 0;
	struct nk_command_text* cmd;

	NK_ASSERT(b);
	NK_ASSERT(font);
	if (!b || !string || !length || (bg.a == 0 && fg.a == 0)) return;
	if (b->use_clipping) {
		const struct nk_rect* c = &b->clip;
		if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
			return;
	}

	/* make sure text fits inside bounds */
	text_width = font->width(font->userdata, font->height, string, length);
	if (text_width > r.w) {
		int glyphs = 0;
		float txt_width = (float)text_width;
		length = nk_text_clamp(font, string, length, r.w, &glyphs, &txt_width, 0, 0);
	}

	if (!length) return;
	cmd = (struct nk_command_text*) nk_command_buffer_push(b, NK_COMMAND_TEXT, sizeof(*cmd) + (nk_size)(length + 1));
	if (!cmd) return;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)r.w;
	cmd->h = (unsigned short)r.h;
	cmd->background = bg;
	cmd->foreground = fg;
	cmd->font = font;
	cmd->length = length;
	cmd->height = font->height;
	NK_MEMCPY(cmd->string, string, (nk_size)length);
	cmd->string[length] = '\0';
}





/* ===============================================================
 *
 *                              VERTEX
 *
 * ===============================================================*/
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
NK_API void
nk_draw_list_init(struct nk_draw_list* list)
{
	nk_size i = 0;
	NK_ASSERT(list);
	if (!list) return;
	nk_zero(list, sizeof(*list));
	for (i = 0; i < NK_LEN(list->circle_vtx); ++i) {
		const float a = ((float)i / (float)NK_LEN(list->circle_vtx)) * 2 * NK_PI;
		list->circle_vtx[i].x = (float)NK_COS(a);
		list->circle_vtx[i].y = (float)NK_SIN(a);
	}
}
NK_API void
nk_draw_list_setup(struct nk_draw_list* canvas, const struct nk_convert_config* config,
	struct nk_buffer* cmds, struct nk_buffer* vertices, struct nk_buffer* elements,
	enum nk_anti_aliasing line_aa, enum nk_anti_aliasing shape_aa)
{
	NK_ASSERT(canvas);
	NK_ASSERT(config);
	NK_ASSERT(cmds);
	NK_ASSERT(vertices);
	NK_ASSERT(elements);
	if (!canvas || !config || !cmds || !vertices || !elements)
		return;

	canvas->buffer = cmds;
	canvas->config = *config;
	canvas->elements = elements;
	canvas->vertices = vertices;
	canvas->line_AA = line_aa;
	canvas->shape_AA = shape_aa;
	canvas->clip_rect = nk_null_rect;

	canvas->cmd_offset = 0;
	canvas->element_count = 0;
	canvas->vertex_count = 0;
	canvas->cmd_offset = 0;
	canvas->cmd_count = 0;
	canvas->path_count = 0;
}
NK_API const struct nk_draw_command*
nk__draw_list_begin(const struct nk_draw_list* canvas, const struct nk_buffer* buffer)
{
	nk_byte* memory;
	nk_size offset;
	const struct nk_draw_command* cmd;

	NK_ASSERT(buffer);
	if (!buffer || !buffer->size || !canvas->cmd_count)
		return 0;

	memory = (nk_byte*)buffer->memory.ptr;
	offset = buffer->memory.size - canvas->cmd_offset;
	cmd = nk_ptr_add(const struct nk_draw_command, memory, offset);
	return cmd;
}
NK_API const struct nk_draw_command*
nk__draw_list_end(const struct nk_draw_list* canvas, const struct nk_buffer* buffer)
{
	nk_size size;
	nk_size offset;
	nk_byte* memory;
	const struct nk_draw_command* end;

	NK_ASSERT(buffer);
	NK_ASSERT(canvas);
	if (!buffer || !canvas)
		return 0;

	memory = (nk_byte*)buffer->memory.ptr;
	size = buffer->memory.size;
	offset = size - canvas->cmd_offset;
	end = nk_ptr_add(const struct nk_draw_command, memory, offset);
	end -= (canvas->cmd_count - 1);
	return end;
}
NK_API const struct nk_draw_command*
nk__draw_list_next(const struct nk_draw_command* cmd,
	const struct nk_buffer* buffer, const struct nk_draw_list* canvas)
{
	const struct nk_draw_command* end;
	NK_ASSERT(buffer);
	NK_ASSERT(canvas);
	if (!cmd || !buffer || !canvas)
		return 0;

	end = nk__draw_list_end(canvas, buffer);
	if (cmd <= end) return 0;
	return (cmd - 1);
}
NK_INTERN struct nk_vec2*
nk_draw_list_alloc_path(struct nk_draw_list* list, int count)
{
	struct nk_vec2* points;
	NK_STORAGE const nk_size point_align = NK_ALIGNOF(struct nk_vec2);
	NK_STORAGE const nk_size point_size = sizeof(struct nk_vec2);
	points = (struct nk_vec2*)
		nk_buffer_alloc(list->buffer, NK_BUFFER_FRONT,
			point_size * (nk_size)count, point_align);

	if (!points) return 0;
	if (!list->path_offset) {
		void* memory = nk_buffer_memory(list->buffer);
		list->path_offset = (unsigned int)((nk_byte*)points - (nk_byte*)memory);
	}
	list->path_count += (unsigned int)count;
	return points;
}
NK_INTERN struct nk_vec2
nk_draw_list_path_last(struct nk_draw_list* list)
{
	void* memory;
	struct nk_vec2* point;
	NK_ASSERT(list->path_count);
	memory = nk_buffer_memory(list->buffer);
	point = nk_ptr_add(struct nk_vec2, memory, list->path_offset);
	point += (list->path_count - 1);
	return *point;
}
NK_INTERN struct nk_draw_command*
nk_draw_list_push_command(struct nk_draw_list* list, struct nk_rect clip,
	nk_handle texture)
{
	NK_STORAGE const nk_size cmd_align = NK_ALIGNOF(struct nk_draw_command);
	NK_STORAGE const nk_size cmd_size = sizeof(struct nk_draw_command);
	struct nk_draw_command* cmd;

	NK_ASSERT(list);
	cmd = (struct nk_draw_command*)
		nk_buffer_alloc(list->buffer, NK_BUFFER_BACK, cmd_size, cmd_align);

	if (!cmd) return 0;
	if (!list->cmd_count) {
		nk_byte* memory = (nk_byte*)nk_buffer_memory(list->buffer);
		nk_size total = nk_buffer_total(list->buffer);
		memory = nk_ptr_add(nk_byte, memory, total);
		list->cmd_offset = (nk_size)(memory - (nk_byte*)cmd);
	}

	cmd->elem_count = 0;
	cmd->clip_rect = clip;
	cmd->texture = texture;
#ifdef NK_INCLUDE_COMMAND_USERDATA
	cmd->userdata = list->userdata;
#endif

	list->cmd_count++;
	list->clip_rect = clip;
	return cmd;
}
NK_INTERN struct nk_draw_command*
nk_draw_list_command_last(struct nk_draw_list* list)
{
	void* memory;
	nk_size size;
	struct nk_draw_command* cmd;
	NK_ASSERT(list->cmd_count);

	memory = nk_buffer_memory(list->buffer);
	size = nk_buffer_total(list->buffer);
	cmd = nk_ptr_add(struct nk_draw_command, memory, size - list->cmd_offset);
	return (cmd - (list->cmd_count - 1));
}
NK_INTERN void
nk_draw_list_add_clip(struct nk_draw_list* list, struct nk_rect rect)
{
	NK_ASSERT(list);
	if (!list) return;
	if (!list->cmd_count) {
		nk_draw_list_push_command(list, rect, list->config.null.texture);
	}
	else {
		struct nk_draw_command* prev = nk_draw_list_command_last(list);
		if (prev->elem_count == 0)
			prev->clip_rect = rect;
		nk_draw_list_push_command(list, rect, prev->texture);
	}
}
NK_INTERN void
nk_draw_list_push_image(struct nk_draw_list* list, nk_handle texture)
{
	NK_ASSERT(list);
	if (!list) return;
	if (!list->cmd_count) {
		nk_draw_list_push_command(list, nk_null_rect, texture);
	}
	else {
		struct nk_draw_command* prev = nk_draw_list_command_last(list);
		if (prev->elem_count == 0) {
			prev->texture = texture;
#ifdef NK_INCLUDE_COMMAND_USERDATA
			prev->userdata = list->userdata;
#endif
		}
		else if (prev->texture.id != texture.id
#ifdef NK_INCLUDE_COMMAND_USERDATA
			|| prev->userdata.id != list->userdata.id
#endif
			) nk_draw_list_push_command(list, prev->clip_rect, texture);
	}
}
#ifdef NK_INCLUDE_COMMAND_USERDATA
NK_API void
nk_draw_list_push_userdata(struct nk_draw_list* list, nk_handle userdata)
{
	list->userdata = userdata;
}
#endif
NK_INTERN void*
nk_draw_list_alloc_vertices(struct nk_draw_list* list, nk_size count)
{
	void* vtx;
	NK_ASSERT(list);
	if (!list) return 0;
	vtx = nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT,
		list->config.vertex_size * count, list->config.vertex_alignment);
	if (!vtx) return 0;
	list->vertex_count += (unsigned int)count;

	/* This assert triggers because your are drawing a lot of stuff and nuklear
	 * defined `nk_draw_index` as `nk_ushort` to safe space be default.
	 *
	 * So you reached the maximum number of indicies or rather vertexes.
	 * To solve this issue please change typdef `nk_draw_index` to `nk_uint`
	 * and don't forget to specify the new element size in your drawing
	 * backend (OpenGL, DirectX, ...). For example in OpenGL for `glDrawElements`
	 * instead of specifing `GL_UNSIGNED_SHORT` you have to define `GL_UNSIGNED_INT`.
	 * Sorry for the inconvenience. */
	if (sizeof(nk_draw_index) == 2) NK_ASSERT((list->vertex_count < NK_USHORT_MAX &&
		"To many verticies for 16-bit vertex indicies. Please read comment above on how to solve this problem"));
	return vtx;
}
NK_INTERN nk_draw_index*
nk_draw_list_alloc_elements(struct nk_draw_list* list, nk_size count)
{
	nk_draw_index* ids;
	struct nk_draw_command* cmd;
	NK_STORAGE const nk_size elem_align = NK_ALIGNOF(nk_draw_index);
	NK_STORAGE const nk_size elem_size = sizeof(nk_draw_index);
	NK_ASSERT(list);
	if (!list) return 0;

	ids = (nk_draw_index*)
		nk_buffer_alloc(list->elements, NK_BUFFER_FRONT, elem_size * count, elem_align);
	if (!ids) return 0;
	cmd = nk_draw_list_command_last(list);
	list->element_count += (unsigned int)count;
	cmd->elem_count += (unsigned int)count;
	return ids;
}
NK_INTERN int
nk_draw_vertex_layout_element_is_end_of_layout(
	const struct nk_draw_vertex_layout_element* element)
{
	return (element->attribute == NK_VERTEX_ATTRIBUTE_COUNT ||
		element->format == NK_FORMAT_COUNT);
}
NK_INTERN void
nk_draw_vertex_color(void* attr, const float* vals,
	enum nk_draw_vertex_layout_format format)
{
	/* if this triggers you tried to provide a value format for a color */
	float val[4];
	NK_ASSERT(format >= NK_FORMAT_COLOR_BEGIN);
	NK_ASSERT(format <= NK_FORMAT_COLOR_END);
	if (format < NK_FORMAT_COLOR_BEGIN || format > NK_FORMAT_COLOR_END) return;

	val[0] = NK_SATURATE(vals[0]);
	val[1] = NK_SATURATE(vals[1]);
	val[2] = NK_SATURATE(vals[2]);
	val[3] = NK_SATURATE(vals[3]);

	switch (format) {
	default: NK_ASSERT(0 && "Invalid vertex layout color format"); break;
	case NK_FORMAT_R8G8B8A8:
	case NK_FORMAT_R8G8B8: {
		struct nk_color col = nk_rgba_fv(val);
		NK_MEMCPY(attr, &col.r, sizeof(col));
	} break;
	case NK_FORMAT_B8G8R8A8: {
		struct nk_color col = nk_rgba_fv(val);
		struct nk_color bgra = nk_rgba(col.b, col.g, col.r, col.a);
		NK_MEMCPY(attr, &bgra, sizeof(bgra));
	} break;
	case NK_FORMAT_R16G15B16: {
		nk_ushort col[3];
		col[0] = (nk_ushort)(val[0] * (float)NK_USHORT_MAX);
		col[1] = (nk_ushort)(val[1] * (float)NK_USHORT_MAX);
		col[2] = (nk_ushort)(val[2] * (float)NK_USHORT_MAX);
		NK_MEMCPY(attr, col, sizeof(col));
	} break;
	case NK_FORMAT_R16G15B16A16: {
		nk_ushort col[4];
		col[0] = (nk_ushort)(val[0] * (float)NK_USHORT_MAX);
		col[1] = (nk_ushort)(val[1] * (float)NK_USHORT_MAX);
		col[2] = (nk_ushort)(val[2] * (float)NK_USHORT_MAX);
		col[3] = (nk_ushort)(val[3] * (float)NK_USHORT_MAX);
		NK_MEMCPY(attr, col, sizeof(col));
	} break;
	case NK_FORMAT_R32G32B32: {
		nk_uint col[3];
		col[0] = (nk_uint)(val[0] * (float)NK_UINT_MAX);
		col[1] = (nk_uint)(val[1] * (float)NK_UINT_MAX);
		col[2] = (nk_uint)(val[2] * (float)NK_UINT_MAX);
		NK_MEMCPY(attr, col, sizeof(col));
	} break;
	case NK_FORMAT_R32G32B32A32: {
		nk_uint col[4];
		col[0] = (nk_uint)(val[0] * (float)NK_UINT_MAX);
		col[1] = (nk_uint)(val[1] * (float)NK_UINT_MAX);
		col[2] = (nk_uint)(val[2] * (float)NK_UINT_MAX);
		col[3] = (nk_uint)(val[3] * (float)NK_UINT_MAX);
		NK_MEMCPY(attr, col, sizeof(col));
	} break;
	case NK_FORMAT_R32G32B32A32_FLOAT:
		NK_MEMCPY(attr, val, sizeof(float) * 4);
		break;
	case NK_FORMAT_R32G32B32A32_DOUBLE: {
		double col[4];
		col[0] = (double)val[0];
		col[1] = (double)val[1];
		col[2] = (double)val[2];
		col[3] = (double)val[3];
		NK_MEMCPY(attr, col, sizeof(col));
	} break;
	case NK_FORMAT_RGB32:
	case NK_FORMAT_RGBA32: {
		struct nk_color col = nk_rgba_fv(val);
		nk_uint color = nk_color_u32(col);
		NK_MEMCPY(attr, &color, sizeof(color));
	} break;
	}
}
NK_INTERN void
nk_draw_vertex_element(void* dst, const float* values, int value_count,
	enum nk_draw_vertex_layout_format format)
{
	int value_index;
	void* attribute = dst;
	/* if this triggers you tried to provide a color format for a value */
	NK_ASSERT(format < NK_FORMAT_COLOR_BEGIN);
	if (format >= NK_FORMAT_COLOR_BEGIN && format <= NK_FORMAT_COLOR_END) return;
	for (value_index = 0; value_index < value_count; ++value_index) {
		switch (format) {
		default: NK_ASSERT(0 && "invalid vertex layout format"); break;
		case NK_FORMAT_SCHAR: {
			char value = (char)NK_CLAMP((float)NK_SCHAR_MIN, values[value_index], (float)NK_SCHAR_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(char));
		} break;
		case NK_FORMAT_SSHORT: {
			nk_short value = (nk_short)NK_CLAMP((float)NK_SSHORT_MIN, values[value_index], (float)NK_SSHORT_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(value));
		} break;
		case NK_FORMAT_SINT: {
			nk_int value = (nk_int)NK_CLAMP((float)NK_SINT_MIN, values[value_index], (float)NK_SINT_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(nk_int));
		} break;
		case NK_FORMAT_UCHAR: {
			unsigned char value = (unsigned char)NK_CLAMP((float)NK_UCHAR_MIN, values[value_index], (float)NK_UCHAR_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(unsigned char));
		} break;
		case NK_FORMAT_USHORT: {
			nk_ushort value = (nk_ushort)NK_CLAMP((float)NK_USHORT_MIN, values[value_index], (float)NK_USHORT_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(value));
		} break;
		case NK_FORMAT_UINT: {
			nk_uint value = (nk_uint)NK_CLAMP((float)NK_UINT_MIN, values[value_index], (float)NK_UINT_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(nk_uint));
		} break;
		case NK_FORMAT_FLOAT:
			NK_MEMCPY(attribute, &values[value_index], sizeof(values[value_index]));
			attribute = (void*)((char*)attribute + sizeof(float));
			break;
		case NK_FORMAT_DOUBLE: {
			double value = (double)values[value_index];
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(double));
		} break;
		}
	}
}
NK_INTERN void*
nk_draw_vertex(void* dst, const struct nk_convert_config* config,
	struct nk_vec2 pos, struct nk_vec2 uv, struct nk_colorf color)
{
	void* result = (void*)((char*)dst + config->vertex_size);
	const struct nk_draw_vertex_layout_element* elem_iter = config->vertex_layout;
	while (!nk_draw_vertex_layout_element_is_end_of_layout(elem_iter)) {
		void* address = (void*)((char*)dst + elem_iter->offset);
		switch (elem_iter->attribute) {
		case NK_VERTEX_ATTRIBUTE_COUNT:
		default: NK_ASSERT(0 && "wrong element attribute"); break;
		case NK_VERTEX_POSITION: nk_draw_vertex_element(address, &pos.x, 2, elem_iter->format); break;
		case NK_VERTEX_TEXCOORD: nk_draw_vertex_element(address, &uv.x, 2, elem_iter->format); break;
		case NK_VERTEX_COLOR: nk_draw_vertex_color(address, &color.r, elem_iter->format); break;
		}
		elem_iter++;
	}
	return result;
}
NK_API void
nk_draw_list_stroke_poly_line(struct nk_draw_list* list, const struct nk_vec2* points,
	const unsigned int points_count, struct nk_color color, enum nk_draw_list_stroke closed,
	float thickness, enum nk_anti_aliasing aliasing)
{
	nk_size count;
	int thick_line;
	struct nk_colorf col;
	struct nk_colorf col_trans;
	NK_ASSERT(list);
	if (!list || points_count < 2) return;

	color.a = (nk_byte)((float)color.a * list->config.global_alpha);
	count = points_count;
	if (!closed) count = points_count - 1;
	thick_line = thickness > 1.0f;

#ifdef NK_INCLUDE_COMMAND_USERDATA
	nk_draw_list_push_userdata(list, list->userdata);
#endif

	color.a = (nk_byte)((float)color.a * list->config.global_alpha);
	nk_color_fv(&col.r, color);
	col_trans = col;
	col_trans.a = 0;

	if (aliasing == NK_ANTI_ALIASING_ON) {
		/* ANTI-ALIASED STROKE */
		const float AA_SIZE = 1.0f;
		NK_STORAGE const nk_size pnt_align = NK_ALIGNOF(struct nk_vec2);
		NK_STORAGE const nk_size pnt_size = sizeof(struct nk_vec2);

		/* allocate vertices and elements  */
		nk_size i1 = 0;
		nk_size vertex_offset;
		nk_size index = list->vertex_count;

		const nk_size idx_count = (thick_line) ? (count * 18) : (count * 12);
		const nk_size vtx_count = (thick_line) ? (points_count * 4) : (points_count * 3);

		void* vtx = nk_draw_list_alloc_vertices(list, vtx_count);
		nk_draw_index* ids = nk_draw_list_alloc_elements(list, idx_count);

		nk_size size;
		struct nk_vec2* normals, * temp;
		if (!vtx || !ids) return;

		/* temporary allocate normals + points */
		vertex_offset = (nk_size)((nk_byte*)vtx - (nk_byte*)list->vertices->memory.ptr);
		nk_buffer_mark(list->vertices, NK_BUFFER_FRONT);
		size = pnt_size * ((thick_line) ? 5 : 3) * points_count;
		normals = (struct nk_vec2*) nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT, size, pnt_align);
		if (!normals) return;
		temp = normals + points_count;

		/* make sure vertex pointer is still correct */
		vtx = (void*)((nk_byte*)list->vertices->memory.ptr + vertex_offset);

		/* calculate normals */
		for (i1 = 0; i1 < count; ++i1) {
			const nk_size i2 = ((i1 + 1) == points_count) ? 0 : (i1 + 1);
			struct nk_vec2 diff = nk_vec2_sub(points[i2], points[i1]);
			float len;

			/* vec2 inverted length  */
			len = nk_vec2_len_sqr(diff);
			if (len != 0.0f)
				len = nk_inv_sqrt(len);
			else len = 1.0f;

			diff = nk_vec2_muls(diff, len);
			normals[i1].x = diff.y;
			normals[i1].y = -diff.x;
		}

		if (!closed)
			normals[points_count - 1] = normals[points_count - 2];

		if (!thick_line) {
			nk_size idx1, i;
			if (!closed) {
				struct nk_vec2 d;
				temp[0] = nk_vec2_add(points[0], nk_vec2_muls(normals[0], AA_SIZE));
				temp[1] = nk_vec2_sub(points[0], nk_vec2_muls(normals[0], AA_SIZE));
				d = nk_vec2_muls(normals[points_count - 1], AA_SIZE);
				temp[(points_count - 1) * 2 + 0] = nk_vec2_add(points[points_count - 1], d);
				temp[(points_count - 1) * 2 + 1] = nk_vec2_sub(points[points_count - 1], d);
			}

			/* fill elements */
			idx1 = index;
			for (i1 = 0; i1 < count; i1++) {
				struct nk_vec2 dm;
				float dmr2;
				nk_size i2 = ((i1 + 1) == points_count) ? 0 : (i1 + 1);
				nk_size idx2 = ((i1 + 1) == points_count) ? index : (idx1 + 3);

				/* average normals */
				dm = nk_vec2_muls(nk_vec2_add(normals[i1], normals[i2]), 0.5f);
				dmr2 = dm.x * dm.x + dm.y * dm.y;
				if (dmr2 > 0.000001f) {
					float scale = 1.0f / dmr2;
					scale = NK_MIN(100.0f, scale);
					dm = nk_vec2_muls(dm, scale);
				}

				dm = nk_vec2_muls(dm, AA_SIZE);
				temp[i2 * 2 + 0] = nk_vec2_add(points[i2], dm);
				temp[i2 * 2 + 1] = nk_vec2_sub(points[i2], dm);

				ids[0] = (nk_draw_index)(idx2 + 0); ids[1] = (nk_draw_index)(idx1 + 0);
				ids[2] = (nk_draw_index)(idx1 + 2); ids[3] = (nk_draw_index)(idx1 + 2);
				ids[4] = (nk_draw_index)(idx2 + 2); ids[5] = (nk_draw_index)(idx2 + 0);
				ids[6] = (nk_draw_index)(idx2 + 1); ids[7] = (nk_draw_index)(idx1 + 1);
				ids[8] = (nk_draw_index)(idx1 + 0); ids[9] = (nk_draw_index)(idx1 + 0);
				ids[10] = (nk_draw_index)(idx2 + 0); ids[11] = (nk_draw_index)(idx2 + 1);
				ids += 12;
				idx1 = idx2;
			}

			/* fill vertices */
			for (i = 0; i < points_count; ++i) {
				const struct nk_vec2 uv = list->config.null.uv;
				vtx = nk_draw_vertex(vtx, &list->config, points[i], uv, col);
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 2 + 0], uv, col_trans);
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 2 + 1], uv, col_trans);
			}
		}
		else {
			nk_size idx1, i;
			const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
			if (!closed) {
				struct nk_vec2 d1 = nk_vec2_muls(normals[0], half_inner_thickness + AA_SIZE);
				struct nk_vec2 d2 = nk_vec2_muls(normals[0], half_inner_thickness);

				temp[0] = nk_vec2_add(points[0], d1);
				temp[1] = nk_vec2_add(points[0], d2);
				temp[2] = nk_vec2_sub(points[0], d2);
				temp[3] = nk_vec2_sub(points[0], d1);

				d1 = nk_vec2_muls(normals[points_count - 1], half_inner_thickness + AA_SIZE);
				d2 = nk_vec2_muls(normals[points_count - 1], half_inner_thickness);

				temp[(points_count - 1) * 4 + 0] = nk_vec2_add(points[points_count - 1], d1);
				temp[(points_count - 1) * 4 + 1] = nk_vec2_add(points[points_count - 1], d2);
				temp[(points_count - 1) * 4 + 2] = nk_vec2_sub(points[points_count - 1], d2);
				temp[(points_count - 1) * 4 + 3] = nk_vec2_sub(points[points_count - 1], d1);
			}

			/* add all elements */
			idx1 = index;
			for (i1 = 0; i1 < count; ++i1) {
				struct nk_vec2 dm_out, dm_in;
				const nk_size i2 = ((i1 + 1) == points_count) ? 0 : (i1 + 1);
				nk_size idx2 = ((i1 + 1) == points_count) ? index : (idx1 + 4);

				/* average normals */
				struct nk_vec2 dm = nk_vec2_muls(nk_vec2_add(normals[i1], normals[i2]), 0.5f);
				float dmr2 = dm.x * dm.x + dm.y * dm.y;
				if (dmr2 > 0.000001f) {
					float scale = 1.0f / dmr2;
					scale = NK_MIN(100.0f, scale);
					dm = nk_vec2_muls(dm, scale);
				}

				dm_out = nk_vec2_muls(dm, ((half_inner_thickness)+AA_SIZE));
				dm_in = nk_vec2_muls(dm, half_inner_thickness);
				temp[i2 * 4 + 0] = nk_vec2_add(points[i2], dm_out);
				temp[i2 * 4 + 1] = nk_vec2_add(points[i2], dm_in);
				temp[i2 * 4 + 2] = nk_vec2_sub(points[i2], dm_in);
				temp[i2 * 4 + 3] = nk_vec2_sub(points[i2], dm_out);

				/* add indexes */
				ids[0] = (nk_draw_index)(idx2 + 1); ids[1] = (nk_draw_index)(idx1 + 1);
				ids[2] = (nk_draw_index)(idx1 + 2); ids[3] = (nk_draw_index)(idx1 + 2);
				ids[4] = (nk_draw_index)(idx2 + 2); ids[5] = (nk_draw_index)(idx2 + 1);
				ids[6] = (nk_draw_index)(idx2 + 1); ids[7] = (nk_draw_index)(idx1 + 1);
				ids[8] = (nk_draw_index)(idx1 + 0); ids[9] = (nk_draw_index)(idx1 + 0);
				ids[10] = (nk_draw_index)(idx2 + 0); ids[11] = (nk_draw_index)(idx2 + 1);
				ids[12] = (nk_draw_index)(idx2 + 2); ids[13] = (nk_draw_index)(idx1 + 2);
				ids[14] = (nk_draw_index)(idx1 + 3); ids[15] = (nk_draw_index)(idx1 + 3);
				ids[16] = (nk_draw_index)(idx2 + 3); ids[17] = (nk_draw_index)(idx2 + 2);
				ids += 18;
				idx1 = idx2;
			}

			/* add vertices */
			for (i = 0; i < points_count; ++i) {
				const struct nk_vec2 uv = list->config.null.uv;
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 4 + 0], uv, col_trans);
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 4 + 1], uv, col);
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 4 + 2], uv, col);
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 4 + 3], uv, col_trans);
			}
		}
		/* free temporary normals + points */
		nk_buffer_reset(list->vertices, NK_BUFFER_FRONT);
	}
	else {
		/* NON ANTI-ALIASED STROKE */
		nk_size i1 = 0;
		nk_size idx = list->vertex_count;
		const nk_size idx_count = count * 6;
		const nk_size vtx_count = count * 4;
		void* vtx = nk_draw_list_alloc_vertices(list, vtx_count);
		nk_draw_index* ids = nk_draw_list_alloc_elements(list, idx_count);
		if (!vtx || !ids) return;

		for (i1 = 0; i1 < count; ++i1) {
			float dx, dy;
			const struct nk_vec2 uv = list->config.null.uv;
			const nk_size i2 = ((i1 + 1) == points_count) ? 0 : i1 + 1;
			const struct nk_vec2 p1 = points[i1];
			const struct nk_vec2 p2 = points[i2];
			struct nk_vec2 diff = nk_vec2_sub(p2, p1);
			float len;

			/* vec2 inverted length  */
			len = nk_vec2_len_sqr(diff);
			if (len != 0.0f)
				len = nk_inv_sqrt(len);
			else len = 1.0f;
			diff = nk_vec2_muls(diff, len);

			/* add vertices */
			dx = diff.x * (thickness * 0.5f);
			dy = diff.y * (thickness * 0.5f);

			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p1.x + dy, p1.y - dx), uv, col);
			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p2.x + dy, p2.y - dx), uv, col);
			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p2.x - dy, p2.y + dx), uv, col);
			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p1.x - dy, p1.y + dx), uv, col);

			ids[0] = (nk_draw_index)(idx + 0); ids[1] = (nk_draw_index)(idx + 1);
			ids[2] = (nk_draw_index)(idx + 2); ids[3] = (nk_draw_index)(idx + 0);
			ids[4] = (nk_draw_index)(idx + 2); ids[5] = (nk_draw_index)(idx + 3);

			ids += 6;
			idx += 4;
		}
	}
}
NK_API void
nk_draw_list_fill_poly_convex(struct nk_draw_list* list,
	const struct nk_vec2* points, const unsigned int points_count,
	struct nk_color color, enum nk_anti_aliasing aliasing)
{
	struct nk_colorf col;
	struct nk_colorf col_trans;

	NK_STORAGE const nk_size pnt_align = NK_ALIGNOF(struct nk_vec2);
	NK_STORAGE const nk_size pnt_size = sizeof(struct nk_vec2);
	NK_ASSERT(list);
	if (!list || points_count < 3) return;

#ifdef NK_INCLUDE_COMMAND_USERDATA
	nk_draw_list_push_userdata(list, list->userdata);
#endif

	color.a = (nk_byte)((float)color.a * list->config.global_alpha);
	nk_color_fv(&col.r, color);
	col_trans = col;
	col_trans.a = 0;

	if (aliasing == NK_ANTI_ALIASING_ON) {
		nk_size i = 0;
		nk_size i0 = 0;
		nk_size i1 = 0;

		const float AA_SIZE = 1.0f;
		nk_size vertex_offset = 0;
		nk_size index = list->vertex_count;

		const nk_size idx_count = (points_count - 2) * 3 + points_count * 6;
		const nk_size vtx_count = (points_count * 2);

		void* vtx = nk_draw_list_alloc_vertices(list, vtx_count);
		nk_draw_index* ids = nk_draw_list_alloc_elements(list, idx_count);

		nk_size size = 0;
		struct nk_vec2* normals = 0;
		unsigned int vtx_inner_idx = (unsigned int)(index + 0);
		unsigned int vtx_outer_idx = (unsigned int)(index + 1);
		if (!vtx || !ids) return;

		/* temporary allocate normals */
		vertex_offset = (nk_size)((nk_byte*)vtx - (nk_byte*)list->vertices->memory.ptr);
		nk_buffer_mark(list->vertices, NK_BUFFER_FRONT);
		size = pnt_size * points_count;
		normals = (struct nk_vec2*) nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT, size, pnt_align);
		if (!normals) return;
		vtx = (void*)((nk_byte*)list->vertices->memory.ptr + vertex_offset);

		/* add elements */
		for (i = 2; i < points_count; i++) {
			ids[0] = (nk_draw_index)(vtx_inner_idx);
			ids[1] = (nk_draw_index)(vtx_inner_idx + ((i - 1) << 1));
			ids[2] = (nk_draw_index)(vtx_inner_idx + (i << 1));
			ids += 3;
		}

		/* compute normals */
		for (i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++) {
			struct nk_vec2 p0 = points[i0];
			struct nk_vec2 p1 = points[i1];
			struct nk_vec2 diff = nk_vec2_sub(p1, p0);

			/* vec2 inverted length  */
			float len = nk_vec2_len_sqr(diff);
			if (len != 0.0f)
				len = nk_inv_sqrt(len);
			else len = 1.0f;
			diff = nk_vec2_muls(diff, len);

			normals[i0].x = diff.y;
			normals[i0].y = -diff.x;
		}

		/* add vertices + indexes */
		for (i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++) {
			const struct nk_vec2 uv = list->config.null.uv;
			struct nk_vec2 n0 = normals[i0];
			struct nk_vec2 n1 = normals[i1];
			struct nk_vec2 dm = nk_vec2_muls(nk_vec2_add(n0, n1), 0.5f);
			float dmr2 = dm.x * dm.x + dm.y * dm.y;
			if (dmr2 > 0.000001f) {
				float scale = 1.0f / dmr2;
				scale = NK_MIN(scale, 100.0f);
				dm = nk_vec2_muls(dm, scale);
			}
			dm = nk_vec2_muls(dm, AA_SIZE * 0.5f);

			/* add vertices */
			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2_sub(points[i1], dm), uv, col);
			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2_add(points[i1], dm), uv, col_trans);

			/* add indexes */
			ids[0] = (nk_draw_index)(vtx_inner_idx + (i1 << 1));
			ids[1] = (nk_draw_index)(vtx_inner_idx + (i0 << 1));
			ids[2] = (nk_draw_index)(vtx_outer_idx + (i0 << 1));
			ids[3] = (nk_draw_index)(vtx_outer_idx + (i0 << 1));
			ids[4] = (nk_draw_index)(vtx_outer_idx + (i1 << 1));
			ids[5] = (nk_draw_index)(vtx_inner_idx + (i1 << 1));
			ids += 6;
		}
		/* free temporary normals + points */
		nk_buffer_reset(list->vertices, NK_BUFFER_FRONT);
	}
	else {
		nk_size i = 0;
		nk_size index = list->vertex_count;
		const nk_size idx_count = (points_count - 2) * 3;
		const nk_size vtx_count = points_count;
		void* vtx = nk_draw_list_alloc_vertices(list, vtx_count);
		nk_draw_index* ids = nk_draw_list_alloc_elements(list, idx_count);

		if (!vtx || !ids) return;
		for (i = 0; i < vtx_count; ++i)
			vtx = nk_draw_vertex(vtx, &list->config, points[i], list->config.null.uv, col);
		for (i = 2; i < points_count; ++i) {
			ids[0] = (nk_draw_index)index;
			ids[1] = (nk_draw_index)(index + i - 1);
			ids[2] = (nk_draw_index)(index + i);
			ids += 3;
		}
	}
}
NK_API void
nk_draw_list_path_clear(struct nk_draw_list* list)
{
	NK_ASSERT(list);
	if (!list) return;
	nk_buffer_reset(list->buffer, NK_BUFFER_FRONT);
	list->path_count = 0;
	list->path_offset = 0;
}
NK_API void
nk_draw_list_path_line_to(struct nk_draw_list* list, struct nk_vec2 pos)
{
	struct nk_vec2* points = 0;
	struct nk_draw_command* cmd = 0;
	NK_ASSERT(list);
	if (!list) return;
	if (!list->cmd_count)
		nk_draw_list_add_clip(list, nk_null_rect);

	cmd = nk_draw_list_command_last(list);
	if (cmd && cmd->texture.ptr != list->config.null.texture.ptr)
		nk_draw_list_push_image(list, list->config.null.texture);

	points = nk_draw_list_alloc_path(list, 1);
	if (!points) return;
	points[0] = pos;
}
NK_API void
nk_draw_list_path_arc_to_fast(struct nk_draw_list* list, struct nk_vec2 center,
	float radius, int a_min, int a_max)
{
	int a = 0;
	NK_ASSERT(list);
	if (!list) return;
	if (a_min <= a_max) {
		for (a = a_min; a <= a_max; a++) {
			const struct nk_vec2 c = list->circle_vtx[(nk_size)a % NK_LEN(list->circle_vtx)];
			const float x = center.x + c.x * radius;
			const float y = center.y + c.y * radius;
			nk_draw_list_path_line_to(list, nk_vec2(x, y));
		}
	}
}
NK_API void
nk_draw_list_path_arc_to(struct nk_draw_list* list, struct nk_vec2 center,
	float radius, float a_min, float a_max, unsigned int segments)
{
	unsigned int i = 0;
	NK_ASSERT(list);
	if (!list) return;
	if (radius == 0.0f) return;

	/*  This algorithm for arc drawing relies on these two trigonometric identities[1]:
			sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)
			cos(a + b) = cos(a) * cos(b) - sin(a) * sin(b)

		Two coordinates (x, y) of a point on a circle centered on
		the origin can be written in polar form as:
			x = r * cos(a)
			y = r * sin(a)
		where r is the radius of the circle,
			a is the angle between (x, y) and the origin.

		This allows us to rotate the coordinates around the
		origin by an angle b using the following transformation:
			x' = r * cos(a + b) = x * cos(b) - y * sin(b)
			y' = r * sin(a + b) = y * cos(b) + x * sin(b)

		[1] https://en.wikipedia.org/wiki/List_of_trigonometric_identities#Angle_sum_and_difference_identities
	*/
	{const float d_angle = (a_max - a_min) / (float)segments;
	const float sin_d = (float)NK_SIN(d_angle);
	const float cos_d = (float)NK_COS(d_angle);

	float cx = (float)NK_COS(a_min) * radius;
	float cy = (float)NK_SIN(a_min) * radius;
	for (i = 0; i <= segments; ++i) {
		float new_cx, new_cy;
		const float x = center.x + cx;
		const float y = center.y + cy;
		nk_draw_list_path_line_to(list, nk_vec2(x, y));

		new_cx = cx * cos_d - cy * sin_d;
		new_cy = cy * cos_d + cx * sin_d;
		cx = new_cx;
		cy = new_cy;
	}}
}
NK_API void
nk_draw_list_path_rect_to(struct nk_draw_list* list, struct nk_vec2 a,
	struct nk_vec2 b, float rounding)
{
	float r;
	NK_ASSERT(list);
	if (!list) return;
	r = rounding;
	r = NK_MIN(r, ((b.x - a.x) < 0) ? -(b.x - a.x) : (b.x - a.x));
	r = NK_MIN(r, ((b.y - a.y) < 0) ? -(b.y - a.y) : (b.y - a.y));

	if (r == 0.0f) {
		nk_draw_list_path_line_to(list, a);
		nk_draw_list_path_line_to(list, nk_vec2(b.x, a.y));
		nk_draw_list_path_line_to(list, b);
		nk_draw_list_path_line_to(list, nk_vec2(a.x, b.y));
	}
	else {
		nk_draw_list_path_arc_to_fast(list, nk_vec2(a.x + r, a.y + r), r, 6, 9);
		nk_draw_list_path_arc_to_fast(list, nk_vec2(b.x - r, a.y + r), r, 9, 12);
		nk_draw_list_path_arc_to_fast(list, nk_vec2(b.x - r, b.y - r), r, 0, 3);
		nk_draw_list_path_arc_to_fast(list, nk_vec2(a.x + r, b.y - r), r, 3, 6);
	}
}
NK_API void
nk_draw_list_path_curve_to(struct nk_draw_list* list, struct nk_vec2 p2,
	struct nk_vec2 p3, struct nk_vec2 p4, unsigned int num_segments)
{
	float t_step;
	unsigned int i_step;
	struct nk_vec2 p1;

	NK_ASSERT(list);
	NK_ASSERT(list->path_count);
	if (!list || !list->path_count) return;
	num_segments = NK_MAX(num_segments, 1);

	p1 = nk_draw_list_path_last(list);
	t_step = 1.0f / (float)num_segments;
	for (i_step = 1; i_step <= num_segments; ++i_step) {
		float t = t_step * (float)i_step;
		float u = 1.0f - t;
		float w1 = u * u * u;
		float w2 = 3 * u * u * t;
		float w3 = 3 * u * t * t;
		float w4 = t * t * t;
		float x = w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x;
		float y = w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y;
		nk_draw_list_path_line_to(list, nk_vec2(x, y));
	}
}
NK_API void
nk_draw_list_path_fill(struct nk_draw_list* list, struct nk_color color)
{
	struct nk_vec2* points;
	NK_ASSERT(list);
	if (!list) return;
	points = (struct nk_vec2*)nk_buffer_memory(list->buffer);
	nk_draw_list_fill_poly_convex(list, points, list->path_count, color, list->config.shape_AA);
	nk_draw_list_path_clear(list);
}
NK_API void
nk_draw_list_path_stroke(struct nk_draw_list* list, struct nk_color color,
	enum nk_draw_list_stroke closed, float thickness)
{
	struct nk_vec2* points;
	NK_ASSERT(list);
	if (!list) return;
	points = (struct nk_vec2*)nk_buffer_memory(list->buffer);
	nk_draw_list_stroke_poly_line(list, points, list->path_count, color,
		closed, thickness, list->config.line_AA);
	nk_draw_list_path_clear(list);
}
NK_API void
nk_draw_list_stroke_line(struct nk_draw_list* list, struct nk_vec2 a,
	struct nk_vec2 b, struct nk_color col, float thickness)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;
	if (list->line_AA == NK_ANTI_ALIASING_ON) {
		nk_draw_list_path_line_to(list, a);
		nk_draw_list_path_line_to(list, b);
	}
	else {
		nk_draw_list_path_line_to(list, nk_vec2_sub(a, nk_vec2(0.5f, 0.5f)));
		nk_draw_list_path_line_to(list, nk_vec2_sub(b, nk_vec2(0.5f, 0.5f)));
	}
	nk_draw_list_path_stroke(list, col, NK_STROKE_OPEN, thickness);
}
NK_API void
nk_draw_list_fill_rect(struct nk_draw_list* list, struct nk_rect rect,
	struct nk_color col, float rounding)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;

	if (list->line_AA == NK_ANTI_ALIASING_ON) {
		nk_draw_list_path_rect_to(list, nk_vec2(rect.x, rect.y),
			nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);
	}
	else {
		nk_draw_list_path_rect_to(list, nk_vec2(rect.x - 0.5f, rect.y - 0.5f),
			nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);
	} nk_draw_list_path_fill(list, col);
}
NK_API void
nk_draw_list_stroke_rect(struct nk_draw_list* list, struct nk_rect rect,
	struct nk_color col, float rounding, float thickness)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;
	if (list->line_AA == NK_ANTI_ALIASING_ON) {
		nk_draw_list_path_rect_to(list, nk_vec2(rect.x, rect.y),
			nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);
	}
	else {
		nk_draw_list_path_rect_to(list, nk_vec2(rect.x - 0.5f, rect.y - 0.5f),
			nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);
	} nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
}
NK_API void
nk_draw_list_fill_rect_multi_color(struct nk_draw_list* list, struct nk_rect rect,
	struct nk_color left, struct nk_color top, struct nk_color right,
	struct nk_color bottom)
{
	void* vtx;
	struct nk_colorf col_left, col_top;
	struct nk_colorf col_right, col_bottom;
	nk_draw_index* idx;
	nk_draw_index index;

	nk_color_fv(&col_left.r, left);
	nk_color_fv(&col_right.r, right);
	nk_color_fv(&col_top.r, top);
	nk_color_fv(&col_bottom.r, bottom);

	NK_ASSERT(list);
	if (!list) return;

	nk_draw_list_push_image(list, list->config.null.texture);
	index = (nk_draw_index)list->vertex_count;
	vtx = nk_draw_list_alloc_vertices(list, 4);
	idx = nk_draw_list_alloc_elements(list, 6);
	if (!vtx || !idx) return;

	idx[0] = (nk_draw_index)(index + 0); idx[1] = (nk_draw_index)(index + 1);
	idx[2] = (nk_draw_index)(index + 2); idx[3] = (nk_draw_index)(index + 0);
	idx[4] = (nk_draw_index)(index + 2); idx[5] = (nk_draw_index)(index + 3);

	vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x, rect.y), list->config.null.uv, col_left);
	vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x + rect.w, rect.y), list->config.null.uv, col_top);
	vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x + rect.w, rect.y + rect.h), list->config.null.uv, col_right);
	vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x, rect.y + rect.h), list->config.null.uv, col_bottom);
}
NK_API void
nk_draw_list_fill_triangle(struct nk_draw_list* list, struct nk_vec2 a,
	struct nk_vec2 b, struct nk_vec2 c, struct nk_color col)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;
	nk_draw_list_path_line_to(list, a);
	nk_draw_list_path_line_to(list, b);
	nk_draw_list_path_line_to(list, c);
	nk_draw_list_path_fill(list, col);
}
NK_API void
nk_draw_list_stroke_triangle(struct nk_draw_list* list, struct nk_vec2 a,
	struct nk_vec2 b, struct nk_vec2 c, struct nk_color col, float thickness)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;
	nk_draw_list_path_line_to(list, a);
	nk_draw_list_path_line_to(list, b);
	nk_draw_list_path_line_to(list, c);
	nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
}
NK_API void
nk_draw_list_fill_circle(struct nk_draw_list* list, struct nk_vec2 center,
	float radius, struct nk_color col, unsigned int segs)
{
	float a_max;
	NK_ASSERT(list);
	if (!list || !col.a) return;
	a_max = NK_PI * 2.0f * ((float)segs - 1.0f) / (float)segs;
	nk_draw_list_path_arc_to(list, center, radius, 0.0f, a_max, segs);
	nk_draw_list_path_fill(list, col);
}
NK_API void
nk_draw_list_stroke_circle(struct nk_draw_list* list, struct nk_vec2 center,
	float radius, struct nk_color col, unsigned int segs, float thickness)
{
	float a_max;
	NK_ASSERT(list);
	if (!list || !col.a) return;
	a_max = NK_PI * 2.0f * ((float)segs - 1.0f) / (float)segs;
	nk_draw_list_path_arc_to(list, center, radius, 0.0f, a_max, segs);
	nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
}
NK_API void
nk_draw_list_stroke_curve(struct nk_draw_list* list, struct nk_vec2 p0,
	struct nk_vec2 cp0, struct nk_vec2 cp1, struct nk_vec2 p1,
	struct nk_color col, unsigned int segments, float thickness)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;
	nk_draw_list_path_line_to(list, p0);
	nk_draw_list_path_curve_to(list, cp0, cp1, p1, segments);
	nk_draw_list_path_stroke(list, col, NK_STROKE_OPEN, thickness);
}
NK_INTERN void
nk_draw_list_push_rect_uv(struct nk_draw_list* list, struct nk_vec2 a,
	struct nk_vec2 c, struct nk_vec2 uva, struct nk_vec2 uvc,
	struct nk_color color)
{
	void* vtx;
	struct nk_vec2 uvb;
	struct nk_vec2 uvd;
	struct nk_vec2 b;
	struct nk_vec2 d;

	struct nk_colorf col;
	nk_draw_index* idx;
	nk_draw_index index;
	NK_ASSERT(list);
	if (!list) return;

	nk_color_fv(&col.r, color);
	uvb = nk_vec2(uvc.x, uva.y);
	uvd = nk_vec2(uva.x, uvc.y);
	b = nk_vec2(c.x, a.y);
	d = nk_vec2(a.x, c.y);

	index = (nk_draw_index)list->vertex_count;
	vtx = nk_draw_list_alloc_vertices(list, 4);
	idx = nk_draw_list_alloc_elements(list, 6);
	if (!vtx || !idx) return;

	idx[0] = (nk_draw_index)(index + 0); idx[1] = (nk_draw_index)(index + 1);
	idx[2] = (nk_draw_index)(index + 2); idx[3] = (nk_draw_index)(index + 0);
	idx[4] = (nk_draw_index)(index + 2); idx[5] = (nk_draw_index)(index + 3);

	vtx = nk_draw_vertex(vtx, &list->config, a, uva, col);
	vtx = nk_draw_vertex(vtx, &list->config, b, uvb, col);
	vtx = nk_draw_vertex(vtx, &list->config, c, uvc, col);
	vtx = nk_draw_vertex(vtx, &list->config, d, uvd, col);
}
NK_API void
nk_draw_list_add_image(struct nk_draw_list* list, struct nk_image texture,
	struct nk_rect rect, struct nk_color color)
{
	NK_ASSERT(list);
	if (!list) return;
	/* push new command with given texture */
	nk_draw_list_push_image(list, texture.handle);
	if (nk_image_is_subimage(&texture)) {
		/* add region inside of the texture  */
		struct nk_vec2 uv[2];
		uv[0].x = (float)texture.region[0] / (float)texture.w;
		uv[0].y = (float)texture.region[1] / (float)texture.h;
		uv[1].x = (float)(texture.region[0] + texture.region[2]) / (float)texture.w;
		uv[1].y = (float)(texture.region[1] + texture.region[3]) / (float)texture.h;
		nk_draw_list_push_rect_uv(list, nk_vec2(rect.x, rect.y),
			nk_vec2(rect.x + rect.w, rect.y + rect.h), uv[0], uv[1], color);
	}
	else nk_draw_list_push_rect_uv(list, nk_vec2(rect.x, rect.y),
		nk_vec2(rect.x + rect.w, rect.y + rect.h),
		nk_vec2(0.0f, 0.0f), nk_vec2(1.0f, 1.0f), color);
}
NK_API void
nk_draw_list_add_text(struct nk_draw_list* list, const struct nk_user_font* font,
	struct nk_rect rect, const char* text, int len, float font_height,
	struct nk_color fg)
{
	float x = 0;
	int text_len = 0;
	nk_rune unicode = 0;
	nk_rune next = 0;
	int glyph_len = 0;
	int next_glyph_len = 0;
	struct nk_user_font_glyph g;

	NK_ASSERT(list);
	if (!list || !len || !text) return;
	if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h,
		list->clip_rect.x, list->clip_rect.y, list->clip_rect.w, list->clip_rect.h)) return;

	nk_draw_list_push_image(list, font->texture);
	x = rect.x;
	glyph_len = nk_utf_decode(text, &unicode, len);
	if (!glyph_len) return;

	/* draw every glyph image */
	fg.a = (nk_byte)((float)fg.a * list->config.global_alpha);
	while (text_len < len && glyph_len) {
		float gx, gy, gh, gw;
		float char_width = 0;
		if (unicode == NK_UTF_INVALID) break;

		/* query currently drawn glyph information */
		next_glyph_len = nk_utf_decode(text + text_len + glyph_len, &next, (int)len - text_len);
		font->query(font->userdata, font_height, &g, unicode,
			(next == NK_UTF_INVALID) ? '\0' : next);

		/* calculate and draw glyph drawing rectangle and image */
		gx = x + g.offset.x;
		gy = rect.y + g.offset.y;
		gw = g.width; gh = g.height;
		char_width = g.xadvance;
		nk_draw_list_push_rect_uv(list, nk_vec2(gx, gy), nk_vec2(gx + gw, gy + gh),
			g.uv[0], g.uv[1], fg);

		/* offset next glyph */
		text_len += glyph_len;
		x += char_width;
		glyph_len = next_glyph_len;
		unicode = next;
	}
}
NK_API nk_flags
nk_convert(struct nk_context* ctx, struct nk_buffer* cmds,
	struct nk_buffer* vertices, struct nk_buffer* elements,
	const struct nk_convert_config* config)
{
	nk_flags res = NK_CONVERT_SUCCESS;
	const struct nk_command* cmd;
	NK_ASSERT(ctx);
	NK_ASSERT(cmds);
	NK_ASSERT(vertices);
	NK_ASSERT(elements);
	NK_ASSERT(config);
	NK_ASSERT(config->vertex_layout);
	NK_ASSERT(config->vertex_size);
	if (!ctx || !cmds || !vertices || !elements || !config || !config->vertex_layout)
		return NK_CONVERT_INVALID_PARAM;

	nk_draw_list_setup(&ctx->draw_list, config, cmds, vertices, elements,
		config->line_AA, config->shape_AA);
	nk_foreach(cmd, ctx)
	{
#ifdef NK_INCLUDE_COMMAND_USERDATA
		ctx->draw_list.userdata = cmd->userdata;
#endif
		switch (cmd->type) {
		case NK_COMMAND_NOP: break;
		case NK_COMMAND_SCISSOR: {
			const struct nk_command_scissor* s = (const struct nk_command_scissor*)cmd;
			nk_draw_list_add_clip(&ctx->draw_list, nk_rect(s->x, s->y, s->w, s->h));
		} break;
		case NK_COMMAND_LINE: {
			const struct nk_command_line* l = (const struct nk_command_line*)cmd;
			nk_draw_list_stroke_line(&ctx->draw_list, nk_vec2(l->begin.x, l->begin.y),
				nk_vec2(l->end.x, l->end.y), l->color, l->line_thickness);
		} break;
		case NK_COMMAND_CURVE: {
			const struct nk_command_curve* q = (const struct nk_command_curve*)cmd;
			nk_draw_list_stroke_curve(&ctx->draw_list, nk_vec2(q->begin.x, q->begin.y),
				nk_vec2(q->ctrl[0].x, q->ctrl[0].y), nk_vec2(q->ctrl[1].x,
					q->ctrl[1].y), nk_vec2(q->end.x, q->end.y), q->color,
				config->curve_segment_count, q->line_thickness);
		} break;
		case NK_COMMAND_RECT: {
			const struct nk_command_rect* r = (const struct nk_command_rect*)cmd;
			nk_draw_list_stroke_rect(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),
				r->color, (float)r->rounding, r->line_thickness);
		} break;
		case NK_COMMAND_RECT_FILLED: {
			const struct nk_command_rect_filled* r = (const struct nk_command_rect_filled*)cmd;
			nk_draw_list_fill_rect(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),
				r->color, (float)r->rounding);
		} break;
		case NK_COMMAND_RECT_MULTI_COLOR: {
			const struct nk_command_rect_multi_color* r = (const struct nk_command_rect_multi_color*)cmd;
			nk_draw_list_fill_rect_multi_color(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),
				r->left, r->top, r->right, r->bottom);
		} break;
		case NK_COMMAND_CIRCLE: {
			const struct nk_command_circle* c = (const struct nk_command_circle*)cmd;
			nk_draw_list_stroke_circle(&ctx->draw_list, nk_vec2((float)c->x + (float)c->w / 2,
				(float)c->y + (float)c->h / 2), (float)c->w / 2, c->color,
				config->circle_segment_count, c->line_thickness);
		} break;
		case NK_COMMAND_CIRCLE_FILLED: {
			const struct nk_command_circle_filled* c = (const struct nk_command_circle_filled*)cmd;
			nk_draw_list_fill_circle(&ctx->draw_list, nk_vec2((float)c->x + (float)c->w / 2,
				(float)c->y + (float)c->h / 2), (float)c->w / 2, c->color,
				config->circle_segment_count);
		} break;
		case NK_COMMAND_ARC: {
			const struct nk_command_arc* c = (const struct nk_command_arc*)cmd;
			nk_draw_list_path_line_to(&ctx->draw_list, nk_vec2(c->cx, c->cy));
			nk_draw_list_path_arc_to(&ctx->draw_list, nk_vec2(c->cx, c->cy), c->r,
				c->a[0], c->a[1], config->arc_segment_count);
			nk_draw_list_path_stroke(&ctx->draw_list, c->color, NK_STROKE_CLOSED, c->line_thickness);
		} break;
		case NK_COMMAND_ARC_FILLED: {
			const struct nk_command_arc_filled* c = (const struct nk_command_arc_filled*)cmd;
			nk_draw_list_path_line_to(&ctx->draw_list, nk_vec2(c->cx, c->cy));
			nk_draw_list_path_arc_to(&ctx->draw_list, nk_vec2(c->cx, c->cy), c->r,
				c->a[0], c->a[1], config->arc_segment_count);
			nk_draw_list_path_fill(&ctx->draw_list, c->color);
		} break;
		case NK_COMMAND_TRIANGLE: {
			const struct nk_command_triangle* t = (const struct nk_command_triangle*)cmd;
			nk_draw_list_stroke_triangle(&ctx->draw_list, nk_vec2(t->a.x, t->a.y),
				nk_vec2(t->b.x, t->b.y), nk_vec2(t->c.x, t->c.y), t->color,
				t->line_thickness);
		} break;
		case NK_COMMAND_TRIANGLE_FILLED: {
			const struct nk_command_triangle_filled* t = (const struct nk_command_triangle_filled*)cmd;
			nk_draw_list_fill_triangle(&ctx->draw_list, nk_vec2(t->a.x, t->a.y),
				nk_vec2(t->b.x, t->b.y), nk_vec2(t->c.x, t->c.y), t->color);
		} break;
		case NK_COMMAND_POLYGON: {
			int i;
			const struct nk_command_polygon* p = (const struct nk_command_polygon*)cmd;
			for (i = 0; i < p->point_count; ++i) {
				struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);
				nk_draw_list_path_line_to(&ctx->draw_list, pnt);
			}
			nk_draw_list_path_stroke(&ctx->draw_list, p->color, NK_STROKE_CLOSED, p->line_thickness);
		} break;
		case NK_COMMAND_POLYGON_FILLED: {
			int i;
			const struct nk_command_polygon_filled* p = (const struct nk_command_polygon_filled*)cmd;
			for (i = 0; i < p->point_count; ++i) {
				struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);
				nk_draw_list_path_line_to(&ctx->draw_list, pnt);
			}
			nk_draw_list_path_fill(&ctx->draw_list, p->color);
		} break;
		case NK_COMMAND_POLYLINE: {
			int i;
			const struct nk_command_polyline* p = (const struct nk_command_polyline*)cmd;
			for (i = 0; i < p->point_count; ++i) {
				struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);
				nk_draw_list_path_line_to(&ctx->draw_list, pnt);
			}
			nk_draw_list_path_stroke(&ctx->draw_list, p->color, NK_STROKE_OPEN, p->line_thickness);
		} break;
		case NK_COMMAND_TEXT: {
			const struct nk_command_text* t = (const struct nk_command_text*)cmd;
			nk_draw_list_add_text(&ctx->draw_list, t->font, nk_rect(t->x, t->y, t->w, t->h),
				t->string, t->length, t->height, t->foreground);
		} break;
		case NK_COMMAND_IMAGE: {
			const struct nk_command_image* i = (const struct nk_command_image*)cmd;
			nk_draw_list_add_image(&ctx->draw_list, i->img, nk_rect(i->x, i->y, i->w, i->h), i->col);
		} break;
		case NK_COMMAND_CUSTOM: {
			const struct nk_command_custom* c = (const struct nk_command_custom*)cmd;
			c->callback(&ctx->draw_list, c->x, c->y, c->w, c->h, c->callback_data);
		} break;
		default: break;
		}
	}
	res |= (cmds->needed > cmds->allocated + (cmds->memory.size - cmds->size)) ? NK_CONVERT_COMMAND_BUFFER_FULL : 0;
	res |= (vertices->needed > vertices->allocated) ? NK_CONVERT_VERTEX_BUFFER_FULL : 0;
	res |= (elements->needed > elements->allocated) ? NK_CONVERT_ELEMENT_BUFFER_FULL : 0;
	return res;
}
NK_API const struct nk_draw_command*
nk__draw_begin(const struct nk_context* ctx,
	const struct nk_buffer* buffer)
{
	return nk__draw_list_begin(&ctx->draw_list, buffer);
}
NK_API const struct nk_draw_command*
nk__draw_end(const struct nk_context* ctx, const struct nk_buffer* buffer)
{
	return nk__draw_list_end(&ctx->draw_list, buffer);
}
NK_API const struct nk_draw_command*
nk__draw_next(const struct nk_draw_command* cmd,
	const struct nk_buffer* buffer, const struct nk_context* ctx)
{
	return nk__draw_list_next(cmd, buffer, &ctx->draw_list);
}
#endif


#ifdef NK_INCLUDE_FONT_BAKING
/* -------------------------------------------------------------
*
*                          RECT PACK
*
* --------------------------------------------------------------*/
/* stb_rect_pack.h - v0.05 - public domain - rectangle packing */
/* Sean Barrett 2014 */
#define NK_RP__MAXVAL  0xffff
typedef unsigned short nk_rp_coord;

struct nk_rp_rect {
	/* reserved for your use: */
	int id;
	/* input: */
	nk_rp_coord w, h;
	/* output: */
	nk_rp_coord x, y;
	int was_packed;
	/* non-zero if valid packing */
}; /* 16 bytes, nominally */

struct nk_rp_node {
	nk_rp_coord  x, y;
	struct nk_rp_node* next;
};

struct nk_rp_context {
	int width;
	int height;
	int align;
	int init_mode;
	int heuristic;
	int num_nodes;
	struct nk_rp_node* active_head;
	struct nk_rp_node* free_head;
	struct nk_rp_node extra[2];
	/* we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2' */
};

struct nk_rp__findresult {
	int x, y;
	struct nk_rp_node** prev_link;
};

enum NK_RP_HEURISTIC {
	NK_RP_HEURISTIC_Skyline_default = 0,
	NK_RP_HEURISTIC_Skyline_BL_sortHeight = NK_RP_HEURISTIC_Skyline_default,
	NK_RP_HEURISTIC_Skyline_BF_sortHeight
};
enum NK_RP_INIT_STATE { NK_RP__INIT_skyline = 1 };

NK_INTERN void
nk_rp_setup_allow_out_of_mem(struct nk_rp_context* context, int allow_out_of_mem)
{
	if (allow_out_of_mem)
		/* if it's ok to run out of memory, then don't bother aligning them; */
		/* this gives better packing, but may fail due to OOM (even though */
		/* the rectangles easily fit). @TODO a smarter approach would be to only */
		/* quantize once we've hit OOM, then we could get rid of this parameter. */
		context->align = 1;
	else {
		/* if it's not ok to run out of memory, then quantize the widths */
		/* so that num_nodes is always enough nodes. */
		/* */
		/* I.e. num_nodes * align >= width */
		/*                  align >= width / num_nodes */
		/*                  align = ceil(width/num_nodes) */
		context->align = (context->width + context->num_nodes - 1) / context->num_nodes;
	}
}
NK_INTERN void
nk_rp_init_target(struct nk_rp_context* context, int width, int height,
	struct nk_rp_node* nodes, int num_nodes)
{
	int i;
#ifndef STBRP_LARGE_RECTS
	NK_ASSERT(width <= 0xffff && height <= 0xffff);
#endif

	for (i = 0; i < num_nodes - 1; ++i)
		nodes[i].next = &nodes[i + 1];
	nodes[i].next = 0;
	context->init_mode = NK_RP__INIT_skyline;
	context->heuristic = NK_RP_HEURISTIC_Skyline_default;
	context->free_head = &nodes[0];
	context->active_head = &context->extra[0];
	context->width = width;
	context->height = height;
	context->num_nodes = num_nodes;
	nk_rp_setup_allow_out_of_mem(context, 0);

	/* node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly) */
	context->extra[0].x = 0;
	context->extra[0].y = 0;
	context->extra[0].next = &context->extra[1];
	context->extra[1].x = (nk_rp_coord)width;
	context->extra[1].y = 65535;
	context->extra[1].next = 0;
}
/* find minimum y position if it starts at x1 */
NK_INTERN int
nk_rp__skyline_find_min_y(struct nk_rp_context* c, struct nk_rp_node* first,
	int x0, int width, int* pwaste)
{
	struct nk_rp_node* node = first;
	int x1 = x0 + width;
	int min_y, visited_width, waste_area;
	NK_ASSERT(first->x <= x0);
	NK_UNUSED(c);

	NK_ASSERT(node->next->x > x0);
	/* we ended up handling this in the caller for efficiency */
	NK_ASSERT(node->x <= x0);

	min_y = 0;
	waste_area = 0;
	visited_width = 0;
	while (node->x < x1)
	{
		if (node->y > min_y) {
			/* raise min_y higher. */
			/* we've accounted for all waste up to min_y, */
			/* but we'll now add more waste for everything we've visited */
			waste_area += visited_width * (node->y - min_y);
			min_y = node->y;
			/* the first time through, visited_width might be reduced */
			if (node->x < x0)
				visited_width += node->next->x - x0;
			else
				visited_width += node->next->x - node->x;
		}
		else {
			/* add waste area */
			int under_width = node->next->x - node->x;
			if (under_width + visited_width > width)
				under_width = width - visited_width;
			waste_area += under_width * (min_y - node->y);
			visited_width += under_width;
		}
		node = node->next;
	}
	*pwaste = waste_area;
	return min_y;
}
NK_INTERN struct nk_rp__findresult
nk_rp__skyline_find_best_pos(struct nk_rp_context* c, int width, int height)
{
	int best_waste = (1 << 30), best_x, best_y = (1 << 30);
	struct nk_rp__findresult fr;
	struct nk_rp_node** prev, * node, * tail, ** best = 0;

	/* align to multiple of c->align */
	width = (width + c->align - 1);
	width -= width % c->align;
	NK_ASSERT(width % c->align == 0);

	node = c->active_head;
	prev = &c->active_head;
	while (node->x + width <= c->width) {
		int y, waste;
		y = nk_rp__skyline_find_min_y(c, node, node->x, width, &waste);
		/* actually just want to test BL */
		if (c->heuristic == NK_RP_HEURISTIC_Skyline_BL_sortHeight) {
			/* bottom left */
			if (y < best_y) {
				best_y = y;
				best = prev;
			}
		}
		else {
			/* best-fit */
			if (y + height <= c->height) {
				/* can only use it if it first vertically */
				if (y < best_y || (y == best_y && waste < best_waste)) {
					best_y = y;
					best_waste = waste;
					best = prev;
				}
			}
		}
		prev = &node->next;
		node = node->next;
	}
	best_x = (best == 0) ? 0 : (*best)->x;

	/* if doing best-fit (BF), we also have to try aligning right edge to each node position */
	/* */
	/* e.g, if fitting */
	/* */
	/*     ____________________ */
	/*    |____________________| */
	/* */
	/*            into */
	/* */
	/*   |                         | */
	/*   |             ____________| */
	/*   |____________| */
	/* */
	/* then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned */
	/* */
	/* This makes BF take about 2x the time */
	if (c->heuristic == NK_RP_HEURISTIC_Skyline_BF_sortHeight)
	{
		tail = c->active_head;
		node = c->active_head;
		prev = &c->active_head;
		/* find first node that's admissible */
		while (tail->x < width)
			tail = tail->next;
		while (tail)
		{
			int xpos = tail->x - width;
			int y, waste;
			NK_ASSERT(xpos >= 0);
			/* find the left position that matches this */
			while (node->next->x <= xpos) {
				prev = &node->next;
				node = node->next;
			}
			NK_ASSERT(node->next->x > xpos&& node->x <= xpos);
			y = nk_rp__skyline_find_min_y(c, node, xpos, width, &waste);
			if (y + height < c->height) {
				if (y <= best_y) {
					if (y < best_y || waste < best_waste || (waste == best_waste && xpos < best_x)) {
						best_x = xpos;
						NK_ASSERT(y <= best_y);
						best_y = y;
						best_waste = waste;
						best = prev;
					}
				}
			}
			tail = tail->next;
		}
	}
	fr.prev_link = best;
	fr.x = best_x;
	fr.y = best_y;
	return fr;
}
NK_INTERN struct nk_rp__findresult
nk_rp__skyline_pack_rectangle(struct nk_rp_context* context, int width, int height)
{
	/* find best position according to heuristic */
	struct nk_rp__findresult res = nk_rp__skyline_find_best_pos(context, width, height);
	struct nk_rp_node* node, * cur;

	/* bail if: */
	/*    1. it failed */
	/*    2. the best node doesn't fit (we don't always check this) */
	/*    3. we're out of memory */
	if (res.prev_link == 0 || res.y + height > context->height || context->free_head == 0) {
		res.prev_link = 0;
		return res;
	}

	/* on success, create new node */
	node = context->free_head;
	node->x = (nk_rp_coord)res.x;
	node->y = (nk_rp_coord)(res.y + height);

	context->free_head = node->next;

	/* insert the new node into the right starting point, and */
	/* let 'cur' point to the remaining nodes needing to be */
	/* stitched back in */
	cur = *res.prev_link;
	if (cur->x < res.x) {
		/* preserve the existing one, so start testing with the next one */
		struct nk_rp_node* next = cur->next;
		cur->next = node;
		cur = next;
	}
	else {
		*res.prev_link = node;
	}

	/* from here, traverse cur and free the nodes, until we get to one */
	/* that shouldn't be freed */
	while (cur->next && cur->next->x <= res.x + width) {
		struct nk_rp_node* next = cur->next;
		/* move the current node to the free list */
		cur->next = context->free_head;
		context->free_head = cur;
		cur = next;
	}
	/* stitch the list back in */
	node->next = cur;

	if (cur->x < res.x + width)
		cur->x = (nk_rp_coord)(res.x + width);
	return res;
}
NK_INTERN int
nk_rect_height_compare(const void* a, const void* b)
{
	const struct nk_rp_rect* p = (const struct nk_rp_rect*) a;
	const struct nk_rp_rect* q = (const struct nk_rp_rect*) b;
	if (p->h > q->h)
		return -1;
	if (p->h < q->h)
		return  1;
	return (p->w > q->w) ? -1 : (p->w < q->w);
}
NK_INTERN int
nk_rect_original_order(const void* a, const void* b)
{
	const struct nk_rp_rect* p = (const struct nk_rp_rect*) a;
	const struct nk_rp_rect* q = (const struct nk_rp_rect*) b;
	return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
}
NK_INTERN void
nk_rp_qsort(struct nk_rp_rect* array, unsigned int len, int(*cmp)(const void*, const void*))
{
	/* iterative quick sort */
#define NK_MAX_SORT_STACK 64
	unsigned right, left = 0, stack[NK_MAX_SORT_STACK], pos = 0;
	unsigned seed = len / 2 * 69069 + 1;
	for (;;) {
		for (; left + 1 < len; len++) {
			struct nk_rp_rect pivot, tmp;
			if (pos == NK_MAX_SORT_STACK) len = stack[pos = 0];
			pivot = array[left + seed % (len - left)];
			seed = seed * 69069 + 1;
			stack[pos++] = len;
			for (right = left - 1;;) {
				while (cmp(&array[++right], &pivot) < 0);
				while (cmp(&pivot, &array[--len]) < 0);
				if (right >= len) break;
				tmp = array[right];
				array[right] = array[len];
				array[len] = tmp;
			}
		}
		if (pos == 0) break;
		left = len;
		len = stack[--pos];
	}
#undef NK_MAX_SORT_STACK
}
NK_INTERN void
nk_rp_pack_rects(struct nk_rp_context* context, struct nk_rp_rect* rects, int num_rects)
{
	int i;
	/* we use the 'was_packed' field internally to allow sorting/unsorting */
	for (i = 0; i < num_rects; ++i) {
		rects[i].was_packed = i;
	}

	/* sort according to heuristic */
	nk_rp_qsort(rects, (unsigned)num_rects, nk_rect_height_compare);

	for (i = 0; i < num_rects; ++i) {
		struct nk_rp__findresult fr = nk_rp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
		if (fr.prev_link) {
			rects[i].x = (nk_rp_coord)fr.x;
			rects[i].y = (nk_rp_coord)fr.y;
		}
		else {
			rects[i].x = rects[i].y = NK_RP__MAXVAL;
		}
	}

	/* unsort */
	nk_rp_qsort(rects, (unsigned)num_rects, nk_rect_original_order);

	/* set was_packed flags */
	for (i = 0; i < num_rects; ++i)
		rects[i].was_packed = !(rects[i].x == NK_RP__MAXVAL && rects[i].y == NK_RP__MAXVAL);
}

/*
 * ==============================================================
 *
 *                          TRUETYPE
 *
 * ===============================================================
 */
 /* stb_truetype.h - v1.07 - public domain */
#define NK_TT_MAX_OVERSAMPLE   8
#define NK_TT__OVER_MASK  (NK_TT_MAX_OVERSAMPLE-1)

struct nk_tt_bakedchar {
	unsigned short x0, y0, x1, y1;
	/* coordinates of bbox in bitmap */
	float xoff, yoff, xadvance;
};

struct nk_tt_aligned_quad {
	float x0, y0, s0, t0; /* top-left */
	float x1, y1, s1, t1; /* bottom-right */
};

struct nk_tt_packedchar {
	unsigned short x0, y0, x1, y1;
	/* coordinates of bbox in bitmap */
	float xoff, yoff, xadvance;
	float xoff2, yoff2;
};

struct nk_tt_pack_range {
	float font_size;
	int first_unicode_codepoint_in_range;
	/* if non-zero, then the chars are continuous, and this is the first codepoint */
	int* array_of_unicode_codepoints;
	/* if non-zero, then this is an array of unicode codepoints */
	int num_chars;
	struct nk_tt_packedchar* chardata_for_range; /* output */
	unsigned char h_oversample, v_oversample;
	/* don't set these, they're used internally */
};

struct nk_tt_pack_context {
	void* pack_info;
	int   width;
	int   height;
	int   stride_in_bytes;
	int   padding;
	unsigned int   h_oversample, v_oversample;
	unsigned char* pixels;
	void* nodes;
};

struct nk_tt_fontinfo {
	const unsigned char* data; /* pointer to .ttf file */
	int fontstart;/* offset of start of font */
	int numGlyphs;/* number of glyphs, needed for range checking */
	int loca, head, glyf, hhea, hmtx, kern; /* table locations as offset from start of .ttf */
	int index_map; /* a cmap mapping for our chosen character encoding */
	int indexToLocFormat; /* format needed to map from glyph index to glyph */
};

enum {
	NK_TT_vmove = 1,
	NK_TT_vline,
	NK_TT_vcurve
};

struct nk_tt_vertex {
	short x, y, cx, cy;
	unsigned char type, padding;
};

struct nk_tt__bitmap {
	int w, h, stride;
	unsigned char* pixels;
};

struct nk_tt__hheap_chunk {
	struct nk_tt__hheap_chunk* next;
};
struct nk_tt__hheap {
	struct nk_allocator alloc;
	struct nk_tt__hheap_chunk* head;
	void* first_free;
	int    num_remaining_in_head_chunk;
};

struct nk_tt__edge {
	float x0, y0, x1, y1;
	int invert;
};

struct nk_tt__active_edge {
	struct nk_tt__active_edge* next;
	float fx, fdx, fdy;
	float direction;
	float sy;
	float ey;
};
struct nk_tt__point { float x, y; };

#define NK_TT_MACSTYLE_DONTCARE     0
#define NK_TT_MACSTYLE_BOLD         1
#define NK_TT_MACSTYLE_ITALIC       2
#define NK_TT_MACSTYLE_UNDERSCORE   4
#define NK_TT_MACSTYLE_NONE         8
/* <= not same as 0, this makes us check the bitfield is 0 */

enum { /* platformID */
	NK_TT_PLATFORM_ID_UNICODE = 0,
	NK_TT_PLATFORM_ID_MAC = 1,
	NK_TT_PLATFORM_ID_ISO = 2,
	NK_TT_PLATFORM_ID_MICROSOFT = 3
};

enum { /* encodingID for NK_TT_PLATFORM_ID_UNICODE */
	NK_TT_UNICODE_EID_UNICODE_1_0 = 0,
	NK_TT_UNICODE_EID_UNICODE_1_1 = 1,
	NK_TT_UNICODE_EID_ISO_10646 = 2,
	NK_TT_UNICODE_EID_UNICODE_2_0_BMP = 3,
	NK_TT_UNICODE_EID_UNICODE_2_0_FULL = 4
};

enum { /* encodingID for NK_TT_PLATFORM_ID_MICROSOFT */
	NK_TT_MS_EID_SYMBOL = 0,
	NK_TT_MS_EID_UNICODE_BMP = 1,
	NK_TT_MS_EID_SHIFTJIS = 2,
	NK_TT_MS_EID_UNICODE_FULL = 10
};

enum { /* encodingID for NK_TT_PLATFORM_ID_MAC; same as Script Manager codes */
	NK_TT_MAC_EID_ROMAN = 0, NK_TT_MAC_EID_ARABIC = 4,
	NK_TT_MAC_EID_JAPANESE = 1, NK_TT_MAC_EID_HEBREW = 5,
	NK_TT_MAC_EID_CHINESE_TRAD = 2, NK_TT_MAC_EID_GREEK = 6,
	NK_TT_MAC_EID_KOREAN = 3, NK_TT_MAC_EID_RUSSIAN = 7
};

enum { /* languageID for NK_TT_PLATFORM_ID_MICROSOFT; same as LCID... */
	   /* problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs */
	NK_TT_MS_LANG_ENGLISH = 0x0409, NK_TT_MS_LANG_ITALIAN = 0x0410,
	NK_TT_MS_LANG_CHINESE = 0x0804, NK_TT_MS_LANG_JAPANESE = 0x0411,
	NK_TT_MS_LANG_DUTCH = 0x0413, NK_TT_MS_LANG_KOREAN = 0x0412,
	NK_TT_MS_LANG_FRENCH = 0x040c, NK_TT_MS_LANG_RUSSIAN = 0x0419,
	NK_TT_MS_LANG_GERMAN = 0x0407, NK_TT_MS_LANG_SPANISH = 0x0409,
	NK_TT_MS_LANG_HEBREW = 0x040d, NK_TT_MS_LANG_SWEDISH = 0x041D
};

enum { /* languageID for NK_TT_PLATFORM_ID_MAC */
	NK_TT_MAC_LANG_ENGLISH = 0, NK_TT_MAC_LANG_JAPANESE = 11,
	NK_TT_MAC_LANG_ARABIC = 12, NK_TT_MAC_LANG_KOREAN = 23,
	NK_TT_MAC_LANG_DUTCH = 4, NK_TT_MAC_LANG_RUSSIAN = 32,
	NK_TT_MAC_LANG_FRENCH = 1, NK_TT_MAC_LANG_SPANISH = 6,
	NK_TT_MAC_LANG_GERMAN = 2, NK_TT_MAC_LANG_SWEDISH = 5,
	NK_TT_MAC_LANG_HEBREW = 10, NK_TT_MAC_LANG_CHINESE_SIMPLIFIED = 33,
	NK_TT_MAC_LANG_ITALIAN = 3, NK_TT_MAC_LANG_CHINESE_TRAD = 19
};

#define nk_ttBYTE(p)     (* (const nk_byte *) (p))
#define nk_ttCHAR(p)     (* (const char *) (p))

#if defined(NK_BIGENDIAN) && !defined(NK_ALLOW_UNALIGNED_TRUETYPE)
#define nk_ttUSHORT(p)   (* (nk_ushort *) (p))
#define nk_ttSHORT(p)    (* (nk_short *) (p))
#define nk_ttULONG(p)    (* (nk_uint *) (p))
#define nk_ttLONG(p)     (* (nk_int *) (p))
#else
static nk_ushort nk_ttUSHORT(const nk_byte* p) { return (nk_ushort)(p[0] * 256 + p[1]); }
static nk_short nk_ttSHORT(const nk_byte* p) { return (nk_short)(p[0] * 256 + p[1]); }
static nk_uint nk_ttULONG(const nk_byte* p) { return (nk_uint)((p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]); }
#endif

#define nk_tt_tag4(p,c0,c1,c2,c3)\
    ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define nk_tt_tag(p,str) nk_tt_tag4(p,str[0],str[1],str[2],str[3])

NK_INTERN int nk_tt_GetGlyphShape(const struct nk_tt_fontinfo* info, struct nk_allocator* alloc,
	int glyph_index, struct nk_tt_vertex** pvertices);

NK_INTERN nk_uint
nk_tt__find_table(const nk_byte* data, nk_uint fontstart, const char* tag)
{
	/* @OPTIMIZE: binary search */
	nk_int num_tables = nk_ttUSHORT(data + fontstart + 4);
	nk_uint tabledir = fontstart + 12;
	nk_int i;
	for (i = 0; i < num_tables; ++i) {
		nk_uint loc = tabledir + (nk_uint)(16 * i);
		if (nk_tt_tag(data + loc + 0, tag))
			return nk_ttULONG(data + loc + 8);
	}
	return 0;
}
NK_INTERN int
nk_tt_InitFont(struct nk_tt_fontinfo* info, const unsigned char* data2, int fontstart)
{
	nk_uint cmap, t;
	nk_int i, numTables;
	const nk_byte* data = (const nk_byte*)data2;

	info->data = data;
	info->fontstart = fontstart;

	cmap = nk_tt__find_table(data, (nk_uint)fontstart, "cmap");       /* required */
	info->loca = (int)nk_tt__find_table(data, (nk_uint)fontstart, "loca"); /* required */
	info->head = (int)nk_tt__find_table(data, (nk_uint)fontstart, "head"); /* required */
	info->glyf = (int)nk_tt__find_table(data, (nk_uint)fontstart, "glyf"); /* required */
	info->hhea = (int)nk_tt__find_table(data, (nk_uint)fontstart, "hhea"); /* required */
	info->hmtx = (int)nk_tt__find_table(data, (nk_uint)fontstart, "hmtx"); /* required */
	info->kern = (int)nk_tt__find_table(data, (nk_uint)fontstart, "kern"); /* not required */
	if (!cmap || !info->loca || !info->head || !info->glyf || !info->hhea || !info->hmtx)
		return 0;

	t = nk_tt__find_table(data, (nk_uint)fontstart, "maxp");
	if (t) info->numGlyphs = nk_ttUSHORT(data + t + 4);
	else info->numGlyphs = 0xffff;

	/* find a cmap encoding table we understand *now* to avoid searching */
	/* later. (todo: could make this installable) */
	/* the same regardless of glyph. */
	numTables = nk_ttUSHORT(data + cmap + 2);
	info->index_map = 0;
	for (i = 0; i < numTables; ++i)
	{
		nk_uint encoding_record = cmap + 4 + 8 * (nk_uint)i;
		/* find an encoding we understand: */
		switch (nk_ttUSHORT(data + encoding_record)) {
		case NK_TT_PLATFORM_ID_MICROSOFT:
			switch (nk_ttUSHORT(data + encoding_record + 2)) {
			case NK_TT_MS_EID_UNICODE_BMP:
			case NK_TT_MS_EID_UNICODE_FULL:
				/* MS/Unicode */
				info->index_map = (int)(cmap + nk_ttULONG(data + encoding_record + 4));
				break;
			default: break;
			} break;
		case NK_TT_PLATFORM_ID_UNICODE:
			/* Mac/iOS has these */
			/* all the encodingIDs are unicode, so we don't bother to check it */
			info->index_map = (int)(cmap + nk_ttULONG(data + encoding_record + 4));
			break;
		default: break;
		}
	}
	if (info->index_map == 0)
		return 0;
	info->indexToLocFormat = nk_ttUSHORT(data + info->head + 50);
	return 1;
}
NK_INTERN int
nk_tt_FindGlyphIndex(const struct nk_tt_fontinfo* info, int unicode_codepoint)
{
	const nk_byte* data = info->data;
	nk_uint index_map = (nk_uint)info->index_map;

	nk_ushort format = nk_ttUSHORT(data + index_map + 0);
	if (format == 0) { /* apple byte encoding */
		nk_int bytes = nk_ttUSHORT(data + index_map + 2);
		if (unicode_codepoint < bytes - 6)
			return nk_ttBYTE(data + index_map + 6 + unicode_codepoint);
		return 0;
	}
	else if (format == 6) {
		nk_uint first = nk_ttUSHORT(data + index_map + 6);
		nk_uint count = nk_ttUSHORT(data + index_map + 8);
		if ((nk_uint)unicode_codepoint >= first && (nk_uint)unicode_codepoint < first + count)
			return nk_ttUSHORT(data + index_map + 10 + (unicode_codepoint - (int)first) * 2);
		return 0;
	}
	else if (format == 2) {
		NK_ASSERT(0); /* @TODO: high-byte mapping for japanese/chinese/korean */
		return 0;
	}
	else if (format == 4) { /* standard mapping for windows fonts: binary search collection of ranges */
		nk_ushort segcount = nk_ttUSHORT(data + index_map + 6) >> 1;
		nk_ushort searchRange = nk_ttUSHORT(data + index_map + 8) >> 1;
		nk_ushort entrySelector = nk_ttUSHORT(data + index_map + 10);
		nk_ushort rangeShift = nk_ttUSHORT(data + index_map + 12) >> 1;

		/* do a binary search of the segments */
		nk_uint endCount = index_map + 14;
		nk_uint search = endCount;

		if (unicode_codepoint > 0xffff)
			return 0;

		/* they lie from endCount .. endCount + segCount */
		/* but searchRange is the nearest power of two, so... */
		if (unicode_codepoint >= nk_ttUSHORT(data + search + rangeShift * 2))
			search += (nk_uint)(rangeShift * 2);

		/* now decrement to bias correctly to find smallest */
		search -= 2;
		while (entrySelector) {
			nk_ushort end;
			searchRange >>= 1;
			end = nk_ttUSHORT(data + search + searchRange * 2);
			if (unicode_codepoint > end)
				search += (nk_uint)(searchRange * 2);
			--entrySelector;
		}
		search += 2;

		{
			nk_ushort offset, start;
			nk_ushort item = (nk_ushort)((search - endCount) >> 1);

			NK_ASSERT(unicode_codepoint <= nk_ttUSHORT(data + endCount + 2 * item));
			start = nk_ttUSHORT(data + index_map + 14 + segcount * 2 + 2 + 2 * item);
			if (unicode_codepoint < start)
				return 0;

			offset = nk_ttUSHORT(data + index_map + 14 + segcount * 6 + 2 + 2 * item);
			if (offset == 0)
				return (nk_ushort)(unicode_codepoint + nk_ttSHORT(data + index_map + 14 + segcount * 4 + 2 + 2 * item));

			return nk_ttUSHORT(data + offset + (unicode_codepoint - start) * 2 + index_map + 14 + segcount * 6 + 2 + 2 * item);
		}
	}
	else if (format == 12 || format == 13) {
		nk_uint ngroups = nk_ttULONG(data + index_map + 12);
		nk_int low, high;
		low = 0; high = (nk_int)ngroups;
		/* Binary search the right group. */
		while (low < high) {
			nk_int mid = low + ((high - low) >> 1); /* rounds down, so low <= mid < high */
			nk_uint start_char = nk_ttULONG(data + index_map + 16 + mid * 12);
			nk_uint end_char = nk_ttULONG(data + index_map + 16 + mid * 12 + 4);
			if ((nk_uint)unicode_codepoint < start_char)
				high = mid;
			else if ((nk_uint)unicode_codepoint > end_char)
				low = mid + 1;
			else {
				nk_uint start_glyph = nk_ttULONG(data + index_map + 16 + mid * 12 + 8);
				if (format == 12)
					return (int)start_glyph + (int)unicode_codepoint - (int)start_char;
				else /* format == 13 */
					return (int)start_glyph;
			}
		}
		return 0; /* not found */
	}
	/* @TODO */
	NK_ASSERT(0);
	return 0;
}
NK_INTERN void
nk_tt_setvertex(struct nk_tt_vertex* v, nk_byte type, nk_int x, nk_int y, nk_int cx, nk_int cy)
{
	v->type = type;
	v->x = (nk_short)x;
	v->y = (nk_short)y;
	v->cx = (nk_short)cx;
	v->cy = (nk_short)cy;
}
NK_INTERN int
nk_tt__GetGlyfOffset(const struct nk_tt_fontinfo* info, int glyph_index)
{
	int g1, g2;
	if (glyph_index >= info->numGlyphs) return -1; /* glyph index out of range */
	if (info->indexToLocFormat >= 2)    return -1; /* unknown index->glyph map format */

	if (info->indexToLocFormat == 0) {
		g1 = info->glyf + nk_ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
		g2 = info->glyf + nk_ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
	}
	else {
		g1 = info->glyf + (int)nk_ttULONG(info->data + info->loca + glyph_index * 4);
		g2 = info->glyf + (int)nk_ttULONG(info->data + info->loca + glyph_index * 4 + 4);
	}
	return g1 == g2 ? -1 : g1; /* if length is 0, return -1 */
}
NK_INTERN int
nk_tt_GetGlyphBox(const struct nk_tt_fontinfo* info, int glyph_index,
	int* x0, int* y0, int* x1, int* y1)
{
	int g = nk_tt__GetGlyfOffset(info, glyph_index);
	if (g < 0) return 0;

	if (x0) *x0 = nk_ttSHORT(info->data + g + 2);
	if (y0) *y0 = nk_ttSHORT(info->data + g + 4);
	if (x1) *x1 = nk_ttSHORT(info->data + g + 6);
	if (y1) *y1 = nk_ttSHORT(info->data + g + 8);
	return 1;
}
NK_INTERN int
nk_tt__close_shape(struct nk_tt_vertex* vertices, int num_vertices, int was_off,
	int start_off, nk_int sx, nk_int sy, nk_int scx, nk_int scy, nk_int cx, nk_int cy)
{
	if (start_off) {
		if (was_off)
			nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, (cx + scx) >> 1, (cy + scy) >> 1, cx, cy);
		nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, sx, sy, scx, scy);
	}
	else {
		if (was_off)
			nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, sx, sy, cx, cy);
		else
			nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vline, sx, sy, 0, 0);
	}
	return num_vertices;
}
NK_INTERN int
nk_tt_GetGlyphShape(const struct nk_tt_fontinfo* info, struct nk_allocator* alloc,
	int glyph_index, struct nk_tt_vertex** pvertices)
{
	nk_short numberOfContours;
	const nk_byte* endPtsOfContours;
	const nk_byte* data = info->data;
	struct nk_tt_vertex* vertices = 0;
	int num_vertices = 0;
	int g = nk_tt__GetGlyfOffset(info, glyph_index);
	*pvertices = 0;

	if (g < 0) return 0;
	numberOfContours = nk_ttSHORT(data + g);
	if (numberOfContours > 0) {
		nk_byte flags = 0, flagcount;
		nk_int ins, i, j = 0, m, n, next_move, was_off = 0, off, start_off = 0;
		nk_int x, y, cx, cy, sx, sy, scx, scy;
		const nk_byte* points;
		endPtsOfContours = (data + g + 10);
		ins = nk_ttUSHORT(data + g + 10 + numberOfContours * 2);
		points = data + g + 10 + numberOfContours * 2 + 2 + ins;

		n = 1 + nk_ttUSHORT(endPtsOfContours + numberOfContours * 2 - 2);
		m = n + 2 * numberOfContours;  /* a loose bound on how many vertices we might need */
		vertices = (struct nk_tt_vertex*)alloc->alloc(alloc->userdata, 0, (nk_size)m * sizeof(vertices[0]));
		if (vertices == 0)
			return 0;

		next_move = 0;
		flagcount = 0;

		/* in first pass, we load uninterpreted data into the allocated array */
		/* above, shifted to the end of the array so we won't overwrite it when */
		/* we create our final data starting from the front */
		off = m - n; /* starting offset for uninterpreted data, regardless of how m ends up being calculated */

		/* first load flags */
		for (i = 0; i < n; ++i) {
			if (flagcount == 0) {
				flags = *points++;
				if (flags & 8)
					flagcount = *points++;
			}
			else --flagcount;
			vertices[off + i].type = flags;
		}

		/* now load x coordinates */
		x = 0;
		for (i = 0; i < n; ++i) {
			flags = vertices[off + i].type;
			if (flags & 2) {
				nk_short dx = *points++;
				x += (flags & 16) ? dx : -dx; /* ??? */
			}
			else {
				if (!(flags & 16)) {
					x = x + (nk_short)(points[0] * 256 + points[1]);
					points += 2;
				}
			}
			vertices[off + i].x = (nk_short)x;
		}

		/* now load y coordinates */
		y = 0;
		for (i = 0; i < n; ++i) {
			flags = vertices[off + i].type;
			if (flags & 4) {
				nk_short dy = *points++;
				y += (flags & 32) ? dy : -dy; /* ??? */
			}
			else {
				if (!(flags & 32)) {
					y = y + (nk_short)(points[0] * 256 + points[1]);
					points += 2;
				}
			}
			vertices[off + i].y = (nk_short)y;
		}

		/* now convert them to our format */
		num_vertices = 0;
		sx = sy = cx = cy = scx = scy = 0;
		for (i = 0; i < n; ++i)
		{
			flags = vertices[off + i].type;
			x = (nk_short)vertices[off + i].x;
			y = (nk_short)vertices[off + i].y;

			if (next_move == i) {
				if (i != 0)
					num_vertices = nk_tt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy);

				/* now start the new one                */
				start_off = !(flags & 1);
				if (start_off) {
					/* if we start off with an off-curve point, then when we need to find a point on the curve */
					/* where we can start, and we need to save some state for when we wraparound. */
					scx = x;
					scy = y;
					if (!(vertices[off + i + 1].type & 1)) {
						/* next point is also a curve point, so interpolate an on-point curve */
						sx = (x + (nk_int)vertices[off + i + 1].x) >> 1;
						sy = (y + (nk_int)vertices[off + i + 1].y) >> 1;
					}
					else {
						/* otherwise just use the next point as our start point */
						sx = (nk_int)vertices[off + i + 1].x;
						sy = (nk_int)vertices[off + i + 1].y;
						++i; /* we're using point i+1 as the starting point, so skip it */
					}
				}
				else {
					sx = x;
					sy = y;
				}
				nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vmove, sx, sy, 0, 0);
				was_off = 0;
				next_move = 1 + nk_ttUSHORT(endPtsOfContours + j * 2);
				++j;
			}
			else {
				if (!(flags & 1))
				{ /* if it's a curve */
					if (was_off) /* two off-curve control points in a row means interpolate an on-curve midpoint */
						nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, (cx + x) >> 1, (cy + y) >> 1, cx, cy);
					cx = x;
					cy = y;
					was_off = 1;
				}
				else {
					if (was_off)
						nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, x, y, cx, cy);
					else nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vline, x, y, 0, 0);
					was_off = 0;
				}
			}
		}
		num_vertices = nk_tt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy);
	}
	else if (numberOfContours == -1) {
		/* Compound shapes. */
		int more = 1;
		const nk_byte* comp = data + g + 10;
		num_vertices = 0;
		vertices = 0;

		while (more)
		{
			nk_ushort flags, gidx;
			int comp_num_verts = 0, i;
			struct nk_tt_vertex* comp_verts = 0, * tmp = 0;
			float mtx[6] = { 1,0,0,1,0,0 }, m, n;

			flags = (nk_ushort)nk_ttSHORT(comp); comp += 2;
			gidx = (nk_ushort)nk_ttSHORT(comp); comp += 2;

			if (flags & 2) { /* XY values */
				if (flags & 1) { /* shorts */
					mtx[4] = nk_ttSHORT(comp); comp += 2;
					mtx[5] = nk_ttSHORT(comp); comp += 2;
				}
				else {
					mtx[4] = nk_ttCHAR(comp); comp += 1;
					mtx[5] = nk_ttCHAR(comp); comp += 1;
				}
			}
			else {
				/* @TODO handle matching point */
				NK_ASSERT(0);
			}
			if (flags & (1 << 3)) { /* WE_HAVE_A_SCALE */
				mtx[0] = mtx[3] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = mtx[2] = 0;
			}
			else if (flags & (1 << 6)) { /* WE_HAVE_AN_X_AND_YSCALE */
				mtx[0] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = mtx[2] = 0;
				mtx[3] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
			}
			else if (flags & (1 << 7)) { /* WE_HAVE_A_TWO_BY_TWO */
				mtx[0] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[2] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[3] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
			}

			/* Find transformation scales. */
			m = (float)NK_SQRT(mtx[0] * mtx[0] + mtx[1] * mtx[1]);
			n = (float)NK_SQRT(mtx[2] * mtx[2] + mtx[3] * mtx[3]);

			/* Get indexed glyph. */
			comp_num_verts = nk_tt_GetGlyphShape(info, alloc, gidx, &comp_verts);
			if (comp_num_verts > 0)
			{
				/* Transform vertices. */
				for (i = 0; i < comp_num_verts; ++i) {
					struct nk_tt_vertex* v = &comp_verts[i];
					short x, y;
					x = v->x; y = v->y;
					v->x = (short)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
					v->y = (short)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
					x = v->cx; y = v->cy;
					v->cx = (short)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
					v->cy = (short)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
				}
				/* Append vertices. */
				tmp = (struct nk_tt_vertex*)alloc->alloc(alloc->userdata, 0,
					(nk_size)(num_vertices + comp_num_verts) * sizeof(struct nk_tt_vertex));
				if (!tmp) {
					if (vertices) alloc->free(alloc->userdata, vertices);
					if (comp_verts) alloc->free(alloc->userdata, comp_verts);
					return 0;
				}
				if (num_vertices > 0) NK_MEMCPY(tmp, vertices, (nk_size)num_vertices * sizeof(struct nk_tt_vertex));
				NK_MEMCPY(tmp + num_vertices, comp_verts, (nk_size)comp_num_verts * sizeof(struct nk_tt_vertex));
				if (vertices) alloc->free(alloc->userdata, vertices);
				vertices = tmp;
				alloc->free(alloc->userdata, comp_verts);
				num_vertices += comp_num_verts;
			}
			/* More components ? */
			more = flags & (1 << 5);
		}
	}
	else if (numberOfContours < 0) {
		/* @TODO other compound variations? */
		NK_ASSERT(0);
	}
	else {
		/* numberOfCounters == 0, do nothing */
	}
	*pvertices = vertices;
	return num_vertices;
}
NK_INTERN void
nk_tt_GetGlyphHMetrics(const struct nk_tt_fontinfo* info, int glyph_index,
	int* advanceWidth, int* leftSideBearing)
{
	nk_ushort numOfLongHorMetrics = nk_ttUSHORT(info->data + info->hhea + 34);
	if (glyph_index < numOfLongHorMetrics) {
		if (advanceWidth)
			*advanceWidth = nk_ttSHORT(info->data + info->hmtx + 4 * glyph_index);
		if (leftSideBearing)
			*leftSideBearing = nk_ttSHORT(info->data + info->hmtx + 4 * glyph_index + 2);
	}
	else {
		if (advanceWidth)
			*advanceWidth = nk_ttSHORT(info->data + info->hmtx + 4 * (numOfLongHorMetrics - 1));
		if (leftSideBearing)
			*leftSideBearing = nk_ttSHORT(info->data + info->hmtx + 4 * numOfLongHorMetrics + 2 * (glyph_index - numOfLongHorMetrics));
	}
}
NK_INTERN void
nk_tt_GetFontVMetrics(const struct nk_tt_fontinfo* info,
	int* ascent, int* descent, int* lineGap)
{
	if (ascent) *ascent = nk_ttSHORT(info->data + info->hhea + 4);
	if (descent) *descent = nk_ttSHORT(info->data + info->hhea + 6);
	if (lineGap) *lineGap = nk_ttSHORT(info->data + info->hhea + 8);
}
NK_INTERN float
nk_tt_ScaleForPixelHeight(const struct nk_tt_fontinfo* info, float height)
{
	int fheight = nk_ttSHORT(info->data + info->hhea + 4) - nk_ttSHORT(info->data + info->hhea + 6);
	return (float)height / (float)fheight;
}
NK_INTERN float
nk_tt_ScaleForMappingEmToPixels(const struct nk_tt_fontinfo* info, float pixels)
{
	int unitsPerEm = nk_ttUSHORT(info->data + info->head + 18);
	return pixels / (float)unitsPerEm;
}

/*-------------------------------------------------------------
 *            antialiasing software rasterizer
 * --------------------------------------------------------------*/
NK_INTERN void
nk_tt_GetGlyphBitmapBoxSubpixel(const struct nk_tt_fontinfo* font,
	int glyph, float scale_x, float scale_y, float shift_x, float shift_y,
	int* ix0, int* iy0, int* ix1, int* iy1)
{
	int x0, y0, x1, y1;
	if (!nk_tt_GetGlyphBox(font, glyph, &x0, &y0, &x1, &y1)) {
		/* e.g. space character */
		if (ix0) *ix0 = 0;
		if (iy0) *iy0 = 0;
		if (ix1) *ix1 = 0;
		if (iy1) *iy1 = 0;
	}
	else {
		/* move to integral bboxes (treating pixels as little squares, what pixels get touched)? */
		if (ix0) *ix0 = nk_ifloorf((float)x0 * scale_x + shift_x);
		if (iy0) *iy0 = nk_ifloorf((float)-y1 * scale_y + shift_y);
		if (ix1) *ix1 = nk_iceilf((float)x1 * scale_x + shift_x);
		if (iy1) *iy1 = nk_iceilf((float)-y0 * scale_y + shift_y);
	}
}
NK_INTERN void
nk_tt_GetGlyphBitmapBox(const struct nk_tt_fontinfo* font, int glyph,
	float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1)
{
	nk_tt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y, 0.0f, 0.0f, ix0, iy0, ix1, iy1);
}

/*-------------------------------------------------------------
 *                          Rasterizer
 * --------------------------------------------------------------*/
NK_INTERN void*
nk_tt__hheap_alloc(struct nk_tt__hheap* hh, nk_size size)
{
	if (hh->first_free) {
		void* p = hh->first_free;
		hh->first_free = *(void**)p;
		return p;
	}
	else {
		if (hh->num_remaining_in_head_chunk == 0) {
			int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
			struct nk_tt__hheap_chunk* c = (struct nk_tt__hheap_chunk*)
				hh->alloc.alloc(hh->alloc.userdata, 0,
					sizeof(struct nk_tt__hheap_chunk) + size * (nk_size)count);
			if (c == 0) return 0;
			c->next = hh->head;
			hh->head = c;
			hh->num_remaining_in_head_chunk = count;
		}
		--hh->num_remaining_in_head_chunk;
		return (char*)(hh->head) + size * (nk_size)hh->num_remaining_in_head_chunk;
	}
}
NK_INTERN void
nk_tt__hheap_free(struct nk_tt__hheap* hh, void* p)
{
	*(void**)p = hh->first_free;
	hh->first_free = p;
}
NK_INTERN void
nk_tt__hheap_cleanup(struct nk_tt__hheap* hh)
{
	struct nk_tt__hheap_chunk* c = hh->head;
	while (c) {
		struct nk_tt__hheap_chunk* n = c->next;
		hh->alloc.free(hh->alloc.userdata, c);
		c = n;
	}
}
NK_INTERN struct nk_tt__active_edge*
nk_tt__new_active(struct nk_tt__hheap* hh, struct nk_tt__edge* e,
	int off_x, float start_point)
{
	struct nk_tt__active_edge* z = (struct nk_tt__active_edge*)
		nk_tt__hheap_alloc(hh, sizeof(*z));
	float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
	/*STBTT_assert(e->y0 <= start_point); */
	if (!z) return z;
	z->fdx = dxdy;
	z->fdy = (dxdy != 0) ? (1 / dxdy) : 0;
	z->fx = e->x0 + dxdy * (start_point - e->y0);
	z->fx -= (float)off_x;
	z->direction = e->invert ? 1.0f : -1.0f;
	z->sy = e->y0;
	z->ey = e->y1;
	z->next = 0;
	return z;
}
NK_INTERN void
nk_tt__handle_clipped_edge(float* scanline, int x, struct nk_tt__active_edge* e,
	float x0, float y0, float x1, float y1)
{
	if (y0 == y1) return;
	NK_ASSERT(y0 < y1);
	NK_ASSERT(e->sy <= e->ey);
	if (y0 > e->ey) return;
	if (y1 < e->sy) return;
	if (y0 < e->sy) {
		x0 += (x1 - x0) * (e->sy - y0) / (y1 - y0);
		y0 = e->sy;
	}
	if (y1 > e->ey) {
		x1 += (x1 - x0) * (e->ey - y1) / (y1 - y0);
		y1 = e->ey;
	}

	if (x0 == x) NK_ASSERT(x1 <= x + 1);
	else if (x0 == x + 1) NK_ASSERT(x1 >= x);
	else if (x0 <= x) NK_ASSERT(x1 <= x);
	else if (x0 >= x + 1) NK_ASSERT(x1 >= x + 1);
	else NK_ASSERT(x1 >= x && x1 <= x + 1);

	if (x0 <= x && x1 <= x)
		scanline[x] += e->direction * (y1 - y0);
	else if (x0 >= x + 1 && x1 >= x + 1);
	else {
		NK_ASSERT(x0 >= x && x0 <= x + 1 && x1 >= x && x1 <= x + 1);
		/* coverage = 1 - average x position */
		scanline[x] += (float)e->direction * (float)(y1 - y0) * (1.0f - ((x0 - (float)x) + (x1 - (float)x)) / 2.0f);
	}
}
NK_INTERN void
nk_tt__fill_active_edges_new(float* scanline, float* scanline_fill, int len,
	struct nk_tt__active_edge* e, float y_top)
{
	float y_bottom = y_top + 1;
	while (e)
	{
		/* brute force every pixel */
		/* compute intersection points with top & bottom */
		NK_ASSERT(e->ey >= y_top);
		if (e->fdx == 0) {
			float x0 = e->fx;
			if (x0 < len) {
				if (x0 >= 0) {
					nk_tt__handle_clipped_edge(scanline, (int)x0, e, x0, y_top, x0, y_bottom);
					nk_tt__handle_clipped_edge(scanline_fill - 1, (int)x0 + 1, e, x0, y_top, x0, y_bottom);
				}
				else {
					nk_tt__handle_clipped_edge(scanline_fill - 1, 0, e, x0, y_top, x0, y_bottom);
				}
			}
		}
		else {
			float x0 = e->fx;
			float dx = e->fdx;
			float xb = x0 + dx;
			float x_top, x_bottom;
			float y0, y1;
			float dy = e->fdy;
			NK_ASSERT(e->sy <= y_bottom && e->ey >= y_top);

			/* compute endpoints of line segment clipped to this scanline (if the */
			/* line segment starts on this scanline. x0 is the intersection of the */
			/* line with y_top, but that may be off the line segment. */
			if (e->sy > y_top) {
				x_top = x0 + dx * (e->sy - y_top);
				y0 = e->sy;
			}
			else {
				x_top = x0;
				y0 = y_top;
			}

			if (e->ey < y_bottom) {
				x_bottom = x0 + dx * (e->ey - y_top);
				y1 = e->ey;
			}
			else {
				x_bottom = xb;
				y1 = y_bottom;
			}

			if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len)
			{
				/* from here on, we don't have to range check x values */
				if ((int)x_top == (int)x_bottom) {
					float height;
					/* simple case, only spans one pixel */
					int x = (int)x_top;
					height = y1 - y0;
					NK_ASSERT(x >= 0 && x < len);
					scanline[x] += e->direction * (1.0f - (((float)x_top - (float)x) + ((float)x_bottom - (float)x)) / 2.0f) * (float)height;
					scanline_fill[x] += e->direction * (float)height; /* everything right of this pixel is filled */
				}
				else {
					int x, x1, x2;
					float y_crossing, step, sign, area;
					/* covers 2+ pixels */
					if (x_top > x_bottom)
					{
						/* flip scanline vertically; signed area is the same */
						float t;
						y0 = y_bottom - (y0 - y_top);
						y1 = y_bottom - (y1 - y_top);
						t = y0; y0 = y1; y1 = t;
						t = x_bottom; x_bottom = x_top; x_top = t;
						dx = -dx;
						dy = -dy;
						t = x0; x0 = xb; xb = t;
					}

					x1 = (int)x_top;
					x2 = (int)x_bottom;
					/* compute intersection with y axis at x1+1 */
					y_crossing = ((float)x1 + 1 - (float)x0) * (float)dy + (float)y_top;

					sign = e->direction;
					/* area of the rectangle covered from y0..y_crossing */
					area = sign * (y_crossing - y0);
					/* area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing) */
					scanline[x1] += area * (1.0f - ((float)((float)x_top - (float)x1) + (float)(x1 + 1 - x1)) / 2.0f);

					step = sign * dy;
					for (x = x1 + 1; x < x2; ++x) {
						scanline[x] += area + step / 2;
						area += step;
					}
					y_crossing += (float)dy * (float)(x2 - (x1 + 1));

					scanline[x2] += area + sign * (1.0f - ((float)(x2 - x2) + ((float)x_bottom - (float)x2)) / 2.0f) * (y1 - y_crossing);
					scanline_fill[x2] += sign * (y1 - y0);
				}
			}
			else
			{
				/* if edge goes outside of box we're drawing, we require */
				/* clipping logic. since this does not match the intended use */
				/* of this library, we use a different, very slow brute */
				/* force implementation */
				int x;
				for (x = 0; x < len; ++x)
				{
					/* cases: */
					/* */
					/* there can be up to two intersections with the pixel. any intersection */
					/* with left or right edges can be handled by splitting into two (or three) */
					/* regions. intersections with top & bottom do not necessitate case-wise logic. */
					/* */
					/* the old way of doing this found the intersections with the left & right edges, */
					/* then used some simple logic to produce up to three segments in sorted order */
					/* from top-to-bottom. however, this had a problem: if an x edge was epsilon */
					/* across the x border, then the corresponding y position might not be distinct */
					/* from the other y segment, and it might ignored as an empty segment. to avoid */
					/* that, we need to explicitly produce segments based on x positions. */

					/* rename variables to clear pairs */
					float ya = y_top;
					float x1 = (float)(x);
					float x2 = (float)(x + 1);
					float x3 = xb;
					float y3 = y_bottom;
					float yb, y2;

					yb = ((float)x - x0) / dx + y_top;
					y2 = ((float)x + 1 - x0) / dx + y_top;

					if (x0 < x1 && x3 > x2) {         /* three segments descending down-right */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x1, yb);
						nk_tt__handle_clipped_edge(scanline, x, e, x1, yb, x2, y2);
						nk_tt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else if (x3 < x1 && x0 > x2) {  /* three segments descending down-left */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x2, y2);
						nk_tt__handle_clipped_edge(scanline, x, e, x2, y2, x1, yb);
						nk_tt__handle_clipped_edge(scanline, x, e, x1, yb, x3, y3);
					}
					else if (x0 < x1 && x3 > x1) {  /* two segments across x, down-right */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x1, yb);
						nk_tt__handle_clipped_edge(scanline, x, e, x1, yb, x3, y3);
					}
					else if (x3 < x1 && x0 > x1) {  /* two segments across x, down-left */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x1, yb);
						nk_tt__handle_clipped_edge(scanline, x, e, x1, yb, x3, y3);
					}
					else if (x0 < x2 && x3 > x2) {  /* two segments across x+1, down-right */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x2, y2);
						nk_tt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else if (x3 < x2 && x0 > x2) {  /* two segments across x+1, down-left */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x2, y2);
						nk_tt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else {  /* one segment */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x3, y3);
					}
				}
			}
		}
		e = e->next;
	}
}
NK_INTERN void
nk_tt__rasterize_sorted_edges(struct nk_tt__bitmap* result, struct nk_tt__edge* e,
	int n, int vsubsample, int off_x, int off_y, struct nk_allocator* alloc)
{
	/* directly AA rasterize edges w/o supersampling */
	struct nk_tt__hheap hh;
	struct nk_tt__active_edge* active = 0;
	int y, j = 0, i;
	float scanline_data[129], * scanline, * scanline2;

	NK_UNUSED(vsubsample);
	nk_zero_struct(hh);
	hh.alloc = *alloc;

	if (result->w > 64)
		scanline = (float*)alloc->alloc(alloc->userdata, 0, (nk_size)(result->w * 2 + 1) * sizeof(float));
	else scanline = scanline_data;

	scanline2 = scanline + result->w;
	y = off_y;
	e[n].y0 = (float)(off_y + result->h) + 1;

	while (j < result->h)
	{
		/* find center of pixel for this scanline */
		float scan_y_top = (float)y + 0.0f;
		float scan_y_bottom = (float)y + 1.0f;
		struct nk_tt__active_edge** step = &active;

		NK_MEMSET(scanline, 0, (nk_size)result->w * sizeof(scanline[0]));
		NK_MEMSET(scanline2, 0, (nk_size)(result->w + 1) * sizeof(scanline[0]));

		/* update all active edges; */
		/* remove all active edges that terminate before the top of this scanline */
		while (*step) {
			struct nk_tt__active_edge* z = *step;
			if (z->ey <= scan_y_top) {
				*step = z->next; /* delete from list */
				NK_ASSERT(z->direction);
				z->direction = 0;
				nk_tt__hheap_free(&hh, z);
			}
			else {
				step = &((*step)->next); /* advance through list */
			}
		}

		/* insert all edges that start before the bottom of this scanline */
		while (e->y0 <= scan_y_bottom) {
			if (e->y0 != e->y1) {
				struct nk_tt__active_edge* z = nk_tt__new_active(&hh, e, off_x, scan_y_top);
				if (z != 0) {
					NK_ASSERT(z->ey >= scan_y_top);
					/* insert at front */
					z->next = active;
					active = z;
				}
			}
			++e;
		}

		/* now process all active edges */
		if (active)
			nk_tt__fill_active_edges_new(scanline, scanline2 + 1, result->w, active, scan_y_top);

		{
			float sum = 0;
			for (i = 0; i < result->w; ++i) {
				float k;
				int m;
				sum += scanline2[i];
				k = scanline[i] + sum;
				k = (float)NK_ABS(k) * 255.0f + 0.5f;
				m = (int)k;
				if (m > 255) m = 255;
				result->pixels[j * result->stride + i] = (unsigned char)m;
			}
		}
		/* advance all the edges */
		step = &active;
		while (*step) {
			struct nk_tt__active_edge* z = *step;
			z->fx += z->fdx; /* advance to position for current scanline */
			step = &((*step)->next); /* advance through list */
		}
		++y;
		++j;
	}
	nk_tt__hheap_cleanup(&hh);
	if (scanline != scanline_data)
		alloc->free(alloc->userdata, scanline);
}
NK_INTERN void
nk_tt__sort_edges_ins_sort(struct nk_tt__edge* p, int n)
{
	int i, j;
#define NK_TT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
	for (i = 1; i < n; ++i) {
		struct nk_tt__edge t = p[i], * a = &t;
		j = i;
		while (j > 0) {
			struct nk_tt__edge* b = &p[j - 1];
			int c = NK_TT__COMPARE(a, b);
			if (!c) break;
			p[j] = p[j - 1];
			--j;
		}
		if (i != j)
			p[j] = t;
	}
}
NK_INTERN void
nk_tt__sort_edges_quicksort(struct nk_tt__edge* p, int n)
{
	/* threshold for transitioning to insertion sort */
	while (n > 12) {
		struct nk_tt__edge t;
		int c01, c12, c, m, i, j;

		/* compute median of three */
		m = n >> 1;
		c01 = NK_TT__COMPARE(&p[0], &p[m]);
		c12 = NK_TT__COMPARE(&p[m], &p[n - 1]);

		/* if 0 >= mid >= end, or 0 < mid < end, then use mid */
		if (c01 != c12) {
			/* otherwise, we'll need to swap something else to middle */
			int z;
			c = NK_TT__COMPARE(&p[0], &p[n - 1]);
			/* 0>mid && mid<n:  0>n => n; 0<n => 0 */
			/* 0<mid && mid>n:  0>n => 0; 0<n => n */
			z = (c == c12) ? 0 : n - 1;
			t = p[z];
			p[z] = p[m];
			p[m] = t;
		}

		/* now p[m] is the median-of-three */
		/* swap it to the beginning so it won't move around */
		t = p[0];
		p[0] = p[m];
		p[m] = t;

		/* partition loop */
		i = 1;
		j = n - 1;
		for (;;) {
			/* handling of equality is crucial here */
			/* for sentinels & efficiency with duplicates */
			for (;; ++i) {
				if (!NK_TT__COMPARE(&p[i], &p[0])) break;
			}
			for (;; --j) {
				if (!NK_TT__COMPARE(&p[0], &p[j])) break;
			}

			/* make sure we haven't crossed */
			if (i >= j) break;
			t = p[i];
			p[i] = p[j];
			p[j] = t;

			++i;
			--j;

		}

		/* recurse on smaller side, iterate on larger */
		if (j < (n - i)) {
			nk_tt__sort_edges_quicksort(p, j);
			p = p + i;
			n = n - i;
		}
		else {
			nk_tt__sort_edges_quicksort(p + i, n - i);
			n = j;
		}
	}
}
NK_INTERN void
nk_tt__sort_edges(struct nk_tt__edge* p, int n)
{
	nk_tt__sort_edges_quicksort(p, n);
	nk_tt__sort_edges_ins_sort(p, n);
}
NK_INTERN void
nk_tt__rasterize(struct nk_tt__bitmap* result, struct nk_tt__point* pts,
	int* wcount, int windings, float scale_x, float scale_y,
	float shift_x, float shift_y, int off_x, int off_y, int invert,
	struct nk_allocator* alloc)
{
	float y_scale_inv = invert ? -scale_y : scale_y;
	struct nk_tt__edge* e;
	int n, i, j, k, m;
	int vsubsample = 1;
	/* vsubsample should divide 255 evenly; otherwise we won't reach full opacity */

	/* now we have to blow out the windings into explicit edge lists */
	n = 0;
	for (i = 0; i < windings; ++i)
		n += wcount[i];

	e = (struct nk_tt__edge*)
		alloc->alloc(alloc->userdata, 0, (sizeof(*e) * (nk_size)(n + 1)));
	if (e == 0) return;
	n = 0;

	m = 0;
	for (i = 0; i < windings; ++i)
	{
		struct nk_tt__point* p = pts + m;
		m += wcount[i];
		j = wcount[i] - 1;
		for (k = 0; k < wcount[i]; j = k++) {
			int a = k, b = j;
			/* skip the edge if horizontal */
			if (p[j].y == p[k].y)
				continue;

			/* add edge from j to k to the list */
			e[n].invert = 0;
			if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
				e[n].invert = 1;
				a = j, b = k;
			}
			e[n].x0 = p[a].x * scale_x + shift_x;
			e[n].y0 = (p[a].y * y_scale_inv + shift_y) * (float)vsubsample;
			e[n].x1 = p[b].x * scale_x + shift_x;
			e[n].y1 = (p[b].y * y_scale_inv + shift_y) * (float)vsubsample;
			++n;
		}
	}

	/* now sort the edges by their highest point (should snap to integer, and then by x) */
	/*STBTT_sort(e, n, sizeof(e[0]), nk_tt__edge_compare); */
	nk_tt__sort_edges(e, n);
	/* now, traverse the scanlines and find the intersections on each scanline, use xor winding rule */
	nk_tt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, alloc);
	alloc->free(alloc->userdata, e);
}
NK_INTERN void
nk_tt__add_point(struct nk_tt__point* points, int n, float x, float y)
{
	if (!points) return; /* during first pass, it's unallocated */
	points[n].x = x;
	points[n].y = y;
}
NK_INTERN int
nk_tt__tesselate_curve(struct nk_tt__point* points, int* num_points,
	float x0, float y0, float x1, float y1, float x2, float y2,
	float objspace_flatness_squared, int n)
{
	/* tesselate until threshold p is happy...
	 * @TODO warped to compensate for non-linear stretching */
	 /* midpoint */
	float mx = (x0 + 2 * x1 + x2) / 4;
	float my = (y0 + 2 * y1 + y2) / 4;
	/* versus directly drawn line */
	float dx = (x0 + x2) / 2 - mx;
	float dy = (y0 + y2) / 2 - my;
	if (n > 16) /* 65536 segments on one curve better be enough! */
		return 1;

	/* half-pixel error allowed... need to be smaller if AA */
	if (dx * dx + dy * dy > objspace_flatness_squared) {
		nk_tt__tesselate_curve(points, num_points, x0, y0,
			(x0 + x1) / 2.0f, (y0 + y1) / 2.0f, mx, my, objspace_flatness_squared, n + 1);
		nk_tt__tesselate_curve(points, num_points, mx, my,
			(x1 + x2) / 2.0f, (y1 + y2) / 2.0f, x2, y2, objspace_flatness_squared, n + 1);
	}
	else {
		nk_tt__add_point(points, *num_points, x2, y2);
		*num_points = *num_points + 1;
	}
	return 1;
}
NK_INTERN struct nk_tt__point*
nk_tt_FlattenCurves(struct nk_tt_vertex* vertices, int num_verts,
	float objspace_flatness, int** contour_lengths, int* num_contours,
	struct nk_allocator* alloc)
{
	/* returns number of contours */
	struct nk_tt__point* points = 0;
	int num_points = 0;
	float objspace_flatness_squared = objspace_flatness * objspace_flatness;
	int i;
	int n = 0;
	int start = 0;
	int pass;

	/* count how many "moves" there are to get the contour count */
	for (i = 0; i < num_verts; ++i)
		if (vertices[i].type == NK_TT_vmove) ++n;

	*num_contours = n;
	if (n == 0) return 0;

	*contour_lengths = (int*)
		alloc->alloc(alloc->userdata, 0, (sizeof(**contour_lengths) * (nk_size)n));
	if (*contour_lengths == 0) {
		*num_contours = 0;
		return 0;
	}

	/* make two passes through the points so we don't need to realloc */
	for (pass = 0; pass < 2; ++pass)
	{
		float x = 0, y = 0;
		if (pass == 1) {
			points = (struct nk_tt__point*)
				alloc->alloc(alloc->userdata, 0, (nk_size)num_points * sizeof(points[0]));
			if (points == 0) goto error;
		}
		num_points = 0;
		n = -1;

		for (i = 0; i < num_verts; ++i)
		{
			switch (vertices[i].type) {
			case NK_TT_vmove:
				/* start the next contour */
				if (n >= 0)
					(*contour_lengths)[n] = num_points - start;
				++n;
				start = num_points;

				x = vertices[i].x, y = vertices[i].y;
				nk_tt__add_point(points, num_points++, x, y);
				break;
			case NK_TT_vline:
				x = vertices[i].x, y = vertices[i].y;
				nk_tt__add_point(points, num_points++, x, y);
				break;
			case NK_TT_vcurve:
				nk_tt__tesselate_curve(points, &num_points, x, y,
					vertices[i].cx, vertices[i].cy,
					vertices[i].x, vertices[i].y,
					objspace_flatness_squared, 0);
				x = vertices[i].x, y = vertices[i].y;
				break;
			default: break;
			}
		}
		(*contour_lengths)[n] = num_points - start;
	}
	return points;

error:
	alloc->free(alloc->userdata, points);
	alloc->free(alloc->userdata, *contour_lengths);
	*contour_lengths = 0;
	*num_contours = 0;
	return 0;
}
NK_INTERN void
nk_tt_Rasterize(struct nk_tt__bitmap* result, float flatness_in_pixels,
	struct nk_tt_vertex* vertices, int num_verts,
	float scale_x, float scale_y, float shift_x, float shift_y,
	int x_off, int y_off, int invert, struct nk_allocator* alloc)
{
	float scale = scale_x > scale_y ? scale_y : scale_x;
	int winding_count, * winding_lengths;
	struct nk_tt__point* windings = nk_tt_FlattenCurves(vertices, num_verts,
		flatness_in_pixels / scale, &winding_lengths, &winding_count, alloc);

	NK_ASSERT(alloc);
	if (windings) {
		nk_tt__rasterize(result, windings, winding_lengths, winding_count,
			scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, alloc);
		alloc->free(alloc->userdata, winding_lengths);
		alloc->free(alloc->userdata, windings);
	}
}
NK_INTERN void
nk_tt_MakeGlyphBitmapSubpixel(const struct nk_tt_fontinfo* info, unsigned char* output,
	int out_w, int out_h, int out_stride, float scale_x, float scale_y,
	float shift_x, float shift_y, int glyph, struct nk_allocator* alloc)
{
	int ix0, iy0;
	struct nk_tt_vertex* vertices;
	int num_verts = nk_tt_GetGlyphShape(info, alloc, glyph, &vertices);
	struct nk_tt__bitmap gbm;

	nk_tt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x,
		shift_y, &ix0, &iy0, 0, 0);
	gbm.pixels = output;
	gbm.w = out_w;
	gbm.h = out_h;
	gbm.stride = out_stride;

	if (gbm.w && gbm.h)
		nk_tt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y,
			shift_x, shift_y, ix0, iy0, 1, alloc);
	alloc->free(alloc->userdata, vertices);
}

/*-------------------------------------------------------------
 *                          Bitmap baking
 * --------------------------------------------------------------*/
NK_INTERN int
nk_tt_PackBegin(struct nk_tt_pack_context* spc, unsigned char* pixels,
	int pw, int ph, int stride_in_bytes, int padding, struct nk_allocator* alloc)
{
	int num_nodes = pw - padding;
	struct nk_rp_context* context = (struct nk_rp_context*)
		alloc->alloc(alloc->userdata, 0, sizeof(*context));
	struct nk_rp_node* nodes = (struct nk_rp_node*)
		alloc->alloc(alloc->userdata, 0, (sizeof(*nodes) * (nk_size)num_nodes));

	if (context == 0 || nodes == 0) {
		if (context != 0) alloc->free(alloc->userdata, context);
		if (nodes != 0) alloc->free(alloc->userdata, nodes);
		return 0;
	}

	spc->width = pw;
	spc->height = ph;
	spc->pixels = pixels;
	spc->pack_info = context;
	spc->nodes = nodes;
	spc->padding = padding;
	spc->stride_in_bytes = (stride_in_bytes != 0) ? stride_in_bytes : pw;
	spc->h_oversample = 1;
	spc->v_oversample = 1;

	nk_rp_init_target(context, pw - padding, ph - padding, nodes, num_nodes);
	if (pixels)
		NK_MEMSET(pixels, 0, (nk_size)(pw * ph)); /* background of 0 around pixels */
	return 1;
}
NK_INTERN void
nk_tt_PackEnd(struct nk_tt_pack_context* spc, struct nk_allocator* alloc)
{
	alloc->free(alloc->userdata, spc->nodes);
	alloc->free(alloc->userdata, spc->pack_info);
}
NK_INTERN void
nk_tt_PackSetOversampling(struct nk_tt_pack_context* spc,
	unsigned int h_oversample, unsigned int v_oversample)
{
	NK_ASSERT(h_oversample <= NK_TT_MAX_OVERSAMPLE);
	NK_ASSERT(v_oversample <= NK_TT_MAX_OVERSAMPLE);
	if (h_oversample <= NK_TT_MAX_OVERSAMPLE)
		spc->h_oversample = h_oversample;
	if (v_oversample <= NK_TT_MAX_OVERSAMPLE)
		spc->v_oversample = v_oversample;
}
NK_INTERN void
nk_tt__h_prefilter(unsigned char* pixels, int w, int h, int stride_in_bytes,
	int kernel_width)
{
	unsigned char buffer[NK_TT_MAX_OVERSAMPLE];
	int safe_w = w - kernel_width;
	int j;

	for (j = 0; j < h; ++j)
	{
		int i;
		unsigned int total;
		NK_MEMSET(buffer, 0, (nk_size)kernel_width);

		total = 0;

		/* make kernel_width a constant in common cases so compiler can optimize out the divide */
		switch (kernel_width) {
		case 2:
			for (i = 0; i <= safe_w; ++i) {
				total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 2);
			}
			break;
		case 3:
			for (i = 0; i <= safe_w; ++i) {
				total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 3);
			}
			break;
		case 4:
			for (i = 0; i <= safe_w; ++i) {
				total += (unsigned int)pixels[i] - buffer[i & NK_TT__OVER_MASK];
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 4);
			}
			break;
		case 5:
			for (i = 0; i <= safe_w; ++i) {
				total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 5);
			}
			break;
		default:
			for (i = 0; i <= safe_w; ++i) {
				total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / (unsigned int)kernel_width);
			}
			break;
		}

		for (; i < w; ++i) {
			NK_ASSERT(pixels[i] == 0);
			total -= (unsigned int)(buffer[i & NK_TT__OVER_MASK]);
			pixels[i] = (unsigned char)(total / (unsigned int)kernel_width);
		}
		pixels += stride_in_bytes;
	}
}
NK_INTERN void
nk_tt__v_prefilter(unsigned char* pixels, int w, int h, int stride_in_bytes,
	int kernel_width)
{
	unsigned char buffer[NK_TT_MAX_OVERSAMPLE];
	int safe_h = h - kernel_width;
	int j;

	for (j = 0; j < w; ++j)
	{
		int i;
		unsigned int total;
		NK_MEMSET(buffer, 0, (nk_size)kernel_width);

		total = 0;

		/* make kernel_width a constant in common cases so compiler can optimize out the divide */
		switch (kernel_width) {
		case 2:
			for (i = 0; i <= safe_h; ++i) {
				total += (unsigned int)(pixels[i * stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 2);
			}
			break;
		case 3:
			for (i = 0; i <= safe_h; ++i) {
				total += (unsigned int)(pixels[i * stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 3);
			}
			break;
		case 4:
			for (i = 0; i <= safe_h; ++i) {
				total += (unsigned int)(pixels[i * stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 4);
			}
			break;
		case 5:
			for (i = 0; i <= safe_h; ++i) {
				total += (unsigned int)(pixels[i * stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 5);
			}
			break;
		default:
			for (i = 0; i <= safe_h; ++i) {
				total += (unsigned int)(pixels[i * stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / (unsigned int)kernel_width);
			}
			break;
		}

		for (; i < h; ++i) {
			NK_ASSERT(pixels[i * stride_in_bytes] == 0);
			total -= (unsigned int)(buffer[i & NK_TT__OVER_MASK]);
			pixels[i * stride_in_bytes] = (unsigned char)(total / (unsigned int)kernel_width);
		}
		pixels += 1;
	}
}
NK_INTERN float
nk_tt__oversample_shift(int oversample)
{
	if (!oversample)
		return 0.0f;

	/* The prefilter is a box filter of width "oversample", */
	/* which shifts phase by (oversample - 1)/2 pixels in */
	/* oversampled space. We want to shift in the opposite */
	/* direction to counter this. */
	return (float)-(oversample - 1) / (2.0f * (float)oversample);
}
NK_INTERN int
nk_tt_PackFontRangesGatherRects(struct nk_tt_pack_context* spc,
	struct nk_tt_fontinfo* info, struct nk_tt_pack_range* ranges,
	int num_ranges, struct nk_rp_rect* rects)
{
	/* rects array must be big enough to accommodate all characters in the given ranges */
	int i, j, k;
	k = 0;

	for (i = 0; i < num_ranges; ++i) {
		float fh = ranges[i].font_size;
		float scale = (fh > 0) ? nk_tt_ScaleForPixelHeight(info, fh) :
			nk_tt_ScaleForMappingEmToPixels(info, -fh);
		ranges[i].h_oversample = (unsigned char)spc->h_oversample;
		ranges[i].v_oversample = (unsigned char)spc->v_oversample;
		for (j = 0; j < ranges[i].num_chars; ++j) {
			int x0, y0, x1, y1;
			int codepoint = ranges[i].first_unicode_codepoint_in_range ?
				ranges[i].first_unicode_codepoint_in_range + j :
				ranges[i].array_of_unicode_codepoints[j];

			int glyph = nk_tt_FindGlyphIndex(info, codepoint);
			nk_tt_GetGlyphBitmapBoxSubpixel(info, glyph, scale * (float)spc->h_oversample,
				scale * (float)spc->v_oversample, 0, 0, &x0, &y0, &x1, &y1);
			rects[k].w = (nk_rp_coord)(x1 - x0 + spc->padding + (int)spc->h_oversample - 1);
			rects[k].h = (nk_rp_coord)(y1 - y0 + spc->padding + (int)spc->v_oversample - 1);
			++k;
		}
	}
	return k;
}
NK_INTERN int
nk_tt_PackFontRangesRenderIntoRects(struct nk_tt_pack_context* spc,
	struct nk_tt_fontinfo* info, struct nk_tt_pack_range* ranges,
	int num_ranges, struct nk_rp_rect* rects, struct nk_allocator* alloc)
{
	int i, j, k, return_value = 1;
	/* save current values */
	int old_h_over = (int)spc->h_oversample;
	int old_v_over = (int)spc->v_oversample;
	/* rects array must be big enough to accommodate all characters in the given ranges */

	k = 0;
	for (i = 0; i < num_ranges; ++i)
	{
		float fh = ranges[i].font_size;
		float recip_h, recip_v, sub_x, sub_y;
		float scale = fh > 0 ? nk_tt_ScaleForPixelHeight(info, fh) :
			nk_tt_ScaleForMappingEmToPixels(info, -fh);

		spc->h_oversample = ranges[i].h_oversample;
		spc->v_oversample = ranges[i].v_oversample;

		recip_h = 1.0f / (float)spc->h_oversample;
		recip_v = 1.0f / (float)spc->v_oversample;

		sub_x = nk_tt__oversample_shift((int)spc->h_oversample);
		sub_y = nk_tt__oversample_shift((int)spc->v_oversample);

		for (j = 0; j < ranges[i].num_chars; ++j)
		{
			struct nk_rp_rect* r = &rects[k];
			if (r->was_packed)
			{
				struct nk_tt_packedchar* bc = &ranges[i].chardata_for_range[j];
				int advance, lsb, x0, y0, x1, y1;
				int codepoint = ranges[i].first_unicode_codepoint_in_range ?
					ranges[i].first_unicode_codepoint_in_range + j :
					ranges[i].array_of_unicode_codepoints[j];
				int glyph = nk_tt_FindGlyphIndex(info, codepoint);
				nk_rp_coord pad = (nk_rp_coord)spc->padding;

				/* pad on left and top */
				r->x = (nk_rp_coord)((int)r->x + (int)pad);
				r->y = (nk_rp_coord)((int)r->y + (int)pad);
				r->w = (nk_rp_coord)((int)r->w - (int)pad);
				r->h = (nk_rp_coord)((int)r->h - (int)pad);

				nk_tt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
				nk_tt_GetGlyphBitmapBox(info, glyph, scale * (float)spc->h_oversample,
					(scale * (float)spc->v_oversample), &x0, &y0, &x1, &y1);
				nk_tt_MakeGlyphBitmapSubpixel(info, spc->pixels + r->x + r->y * spc->stride_in_bytes,
					(int)(r->w - spc->h_oversample + 1), (int)(r->h - spc->v_oversample + 1),
					spc->stride_in_bytes, scale * (float)spc->h_oversample,
					scale * (float)spc->v_oversample, 0, 0, glyph, alloc);

				if (spc->h_oversample > 1)
					nk_tt__h_prefilter(spc->pixels + r->x + r->y * spc->stride_in_bytes,
						r->w, r->h, spc->stride_in_bytes, (int)spc->h_oversample);

				if (spc->v_oversample > 1)
					nk_tt__v_prefilter(spc->pixels + r->x + r->y * spc->stride_in_bytes,
						r->w, r->h, spc->stride_in_bytes, (int)spc->v_oversample);

				bc->x0 = (nk_ushort)r->x;
				bc->y0 = (nk_ushort)r->y;
				bc->x1 = (nk_ushort)(r->x + r->w);
				bc->y1 = (nk_ushort)(r->y + r->h);
				bc->xadvance = scale * (float)advance;
				bc->xoff = (float)x0 * recip_h + sub_x;
				bc->yoff = (float)y0 * recip_v + sub_y;
				bc->xoff2 = ((float)x0 + r->w) * recip_h + sub_x;
				bc->yoff2 = ((float)y0 + r->h) * recip_v + sub_y;
			}
			else {
				return_value = 0; /* if any fail, report failure */
			}
			++k;
		}
	}
	/* restore original values */
	spc->h_oversample = (unsigned int)old_h_over;
	spc->v_oversample = (unsigned int)old_v_over;
	return return_value;
}
NK_INTERN void
nk_tt_GetPackedQuad(struct nk_tt_packedchar* chardata, int pw, int ph,
	int char_index, float* xpos, float* ypos, struct nk_tt_aligned_quad* q,
	int align_to_integer)
{
	float ipw = 1.0f / (float)pw, iph = 1.0f / (float)ph;
	struct nk_tt_packedchar* b = (struct nk_tt_packedchar*)(chardata + char_index);
	if (align_to_integer) {
		int tx = nk_ifloorf((*xpos + b->xoff) + 0.5f);
		int ty = nk_ifloorf((*ypos + b->yoff) + 0.5f);

		float x = (float)tx;
		float y = (float)ty;

		q->x0 = x;
		q->y0 = y;
		q->x1 = x + b->xoff2 - b->xoff;
		q->y1 = y + b->yoff2 - b->yoff;
	}
	else {
		q->x0 = *xpos + b->xoff;
		q->y0 = *ypos + b->yoff;
		q->x1 = *xpos + b->xoff2;
		q->y1 = *ypos + b->yoff2;
	}
	q->s0 = b->x0 * ipw;
	q->t0 = b->y0 * iph;
	q->s1 = b->x1 * ipw;
	q->t1 = b->y1 * iph;
	*xpos += b->xadvance;
}

/* -------------------------------------------------------------
 *
 *                          FONT BAKING
 *
 * --------------------------------------------------------------*/
struct nk_font_bake_data {
	struct nk_tt_fontinfo info;
	struct nk_rp_rect* rects;
	struct nk_tt_pack_range* ranges;
	nk_rune range_count;
};

struct nk_font_baker {
	struct nk_allocator alloc;
	struct nk_tt_pack_context spc;
	struct nk_font_bake_data* build;
	struct nk_tt_packedchar* packed_chars;
	struct nk_rp_rect* rects;
	struct nk_tt_pack_range* ranges;
};

NK_GLOBAL const nk_size nk_rect_align = NK_ALIGNOF(struct nk_rp_rect);
NK_GLOBAL const nk_size nk_range_align = NK_ALIGNOF(struct nk_tt_pack_range);
NK_GLOBAL const nk_size nk_char_align = NK_ALIGNOF(struct nk_tt_packedchar);
NK_GLOBAL const nk_size nk_build_align = NK_ALIGNOF(struct nk_font_bake_data);
NK_GLOBAL const nk_size nk_baker_align = NK_ALIGNOF(struct nk_font_baker);

NK_INTERN int
nk_range_count(const nk_rune* range)
{
	const nk_rune* iter = range;
	NK_ASSERT(range);
	if (!range) return 0;
	while (*(iter++) != 0);
	return (iter == range) ? 0 : (int)((iter - range) / 2);
}
NK_INTERN int
nk_range_glyph_count(const nk_rune* range, int count)
{
	int i = 0;
	int total_glyphs = 0;
	for (i = 0; i < count; ++i) {
		int diff;
		nk_rune f = range[(i * 2) + 0];
		nk_rune t = range[(i * 2) + 1];
		NK_ASSERT(t >= f);
		diff = (int)((t - f) + 1);
		total_glyphs += diff;
	}
	return total_glyphs;
}
NK_API const nk_rune*
nk_font_default_glyph_ranges(void)
{
	NK_STORAGE const nk_rune ranges[] = { 0x0020, 0x00FF, 0 };
	return ranges;
}
NK_API const nk_rune*
nk_font_chinese_glyph_ranges(void)
{
	NK_STORAGE const nk_rune ranges[] = {
		0x0020, 0x00FF,
		0x3000, 0x30FF,
		0x31F0, 0x31FF,
		0xFF00, 0xFFEF,
		0x4e00, 0x9FAF,
		0
	};
	return ranges;
}
NK_API const nk_rune*
nk_font_cyrillic_glyph_ranges(void)
{
	NK_STORAGE const nk_rune ranges[] = {
		0x0020, 0x00FF,
		0x0400, 0x052F,
		0x2DE0, 0x2DFF,
		0xA640, 0xA69F,
		0
	};
	return ranges;
}
NK_API const nk_rune*
nk_font_korean_glyph_ranges(void)
{
	NK_STORAGE const nk_rune ranges[] = {
		0x0020, 0x00FF,
		0x3131, 0x3163,
		0xAC00, 0xD79D,
		0
	};
	return ranges;
}
NK_INTERN void
nk_font_baker_memory(nk_size* temp, int* glyph_count,
	struct nk_font_config* config_list, int count)
{
	int range_count = 0;
	int total_range_count = 0;
	struct nk_font_config* iter, * i;

	NK_ASSERT(config_list);
	NK_ASSERT(glyph_count);
	if (!config_list) {
		*temp = 0;
		*glyph_count = 0;
		return;
	}
	*glyph_count = 0;
	for (iter = config_list; iter; iter = iter->next) {
		i = iter;
		do {
			if (!i->range) iter->range = nk_font_default_glyph_ranges();
			range_count = nk_range_count(i->range);
			total_range_count += range_count;
			*glyph_count += nk_range_glyph_count(i->range, range_count);
		} while ((i = i->n) != iter);
	}
	*temp = (nk_size)*glyph_count * sizeof(struct nk_rp_rect);
	*temp += (nk_size)total_range_count * sizeof(struct nk_tt_pack_range);
	*temp += (nk_size)*glyph_count * sizeof(struct nk_tt_packedchar);
	*temp += (nk_size)count * sizeof(struct nk_font_bake_data);
	*temp += sizeof(struct nk_font_baker);
	*temp += nk_rect_align + nk_range_align + nk_char_align;
	*temp += nk_build_align + nk_baker_align;
}
NK_INTERN struct nk_font_baker*
nk_font_baker(void* memory, int glyph_count, int count, struct nk_allocator* alloc)
{
	struct nk_font_baker* baker;
	if (!memory) return 0;
	/* setup baker inside a memory block  */
	baker = (struct nk_font_baker*)NK_ALIGN_PTR(memory, nk_baker_align);
	baker->build = (struct nk_font_bake_data*)NK_ALIGN_PTR((baker + 1), nk_build_align);
	baker->packed_chars = (struct nk_tt_packedchar*)NK_ALIGN_PTR((baker->build + count), nk_char_align);
	baker->rects = (struct nk_rp_rect*)NK_ALIGN_PTR((baker->packed_chars + glyph_count), nk_rect_align);
	baker->ranges = (struct nk_tt_pack_range*)NK_ALIGN_PTR((baker->rects + glyph_count), nk_range_align);
	baker->alloc = *alloc;
	return baker;
}
NK_INTERN int
nk_font_bake_pack(struct nk_font_baker* baker,
	nk_size* image_memory, int* width, int* height, struct nk_recti* custom,
	const struct nk_font_config* config_list, int count,
	struct nk_allocator* alloc)
{
	NK_STORAGE const nk_size max_height = 1024 * 32;
	const struct nk_font_config* config_iter, * it;
	int total_glyph_count = 0;
	int total_range_count = 0;
	int range_count = 0;
	int i = 0;

	NK_ASSERT(image_memory);
	NK_ASSERT(width);
	NK_ASSERT(height);
	NK_ASSERT(config_list);
	NK_ASSERT(count);
	NK_ASSERT(alloc);

	if (!image_memory || !width || !height || !config_list || !count) return nk_false;
	for (config_iter = config_list; config_iter; config_iter = config_iter->next) {
		it = config_iter;
		do {
			range_count = nk_range_count(it->range);
			total_range_count += range_count;
			total_glyph_count += nk_range_glyph_count(it->range, range_count);
		} while ((it = it->n) != config_iter);
	}
	/* setup font baker from temporary memory */
	for (config_iter = config_list; config_iter; config_iter = config_iter->next) {
		it = config_iter;
		do {
			if (!nk_tt_InitFont(&baker->build[i++].info, (const unsigned char*)it->ttf_blob, 0))
				return nk_false;
		} while ((it = it->n) != config_iter);
	}
	*height = 0;
	*width = (total_glyph_count > 1000) ? 1024 : 512;
	nk_tt_PackBegin(&baker->spc, 0, (int)*width, (int)max_height, 0, 1, alloc);
	{
		int input_i = 0;
		int range_n = 0;
		int rect_n = 0;
		int char_n = 0;

		if (custom) {
			/* pack custom user data first so it will be in the upper left corner*/
			struct nk_rp_rect custom_space;
			nk_zero(&custom_space, sizeof(custom_space));
			custom_space.w = (nk_rp_coord)(custom->w);
			custom_space.h = (nk_rp_coord)(custom->h);

			nk_tt_PackSetOversampling(&baker->spc, 1, 1);
			nk_rp_pack_rects((struct nk_rp_context*)baker->spc.pack_info, &custom_space, 1);
			*height = NK_MAX(*height, (int)(custom_space.y + custom_space.h));

			custom->x = (short)custom_space.x;
			custom->y = (short)custom_space.y;
			custom->w = (short)custom_space.w;
			custom->h = (short)custom_space.h;
		}

		/* first font pass: pack all glyphs */
		for (input_i = 0, config_iter = config_list; input_i < count && config_iter;
			config_iter = config_iter->next) {
			it = config_iter;
			do {
				int n = 0;
				int glyph_count;
				const nk_rune* in_range;
				const struct nk_font_config* cfg = it;
				struct nk_font_bake_data* tmp = &baker->build[input_i++];

				/* count glyphs + ranges in current font */
				glyph_count = 0; range_count = 0;
				for (in_range = cfg->range; in_range[0] && in_range[1]; in_range += 2) {
					glyph_count += (int)(in_range[1] - in_range[0]) + 1;
					range_count++;
				}

				/* setup ranges  */
				tmp->ranges = baker->ranges + range_n;
				tmp->range_count = (nk_rune)range_count;
				range_n += range_count;
				for (i = 0; i < range_count; ++i) {
					in_range = &cfg->range[i * 2];
					tmp->ranges[i].font_size = cfg->size;
					tmp->ranges[i].first_unicode_codepoint_in_range = (int)in_range[0];
					tmp->ranges[i].num_chars = (int)(in_range[1] - in_range[0]) + 1;
					tmp->ranges[i].chardata_for_range = baker->packed_chars + char_n;
					char_n += tmp->ranges[i].num_chars;
				}

				/* pack */
				tmp->rects = baker->rects + rect_n;
				rect_n += glyph_count;
				nk_tt_PackSetOversampling(&baker->spc, cfg->oversample_h, cfg->oversample_v);
				n = nk_tt_PackFontRangesGatherRects(&baker->spc, &tmp->info,
					tmp->ranges, (int)tmp->range_count, tmp->rects);
				nk_rp_pack_rects((struct nk_rp_context*)baker->spc.pack_info, tmp->rects, (int)n);

				/* texture height */
				for (i = 0; i < n; ++i) {
					if (tmp->rects[i].was_packed)
						*height = NK_MAX(*height, tmp->rects[i].y + tmp->rects[i].h);
				}
			} while ((it = it->n) != config_iter);
		}
		NK_ASSERT(rect_n == total_glyph_count);
		NK_ASSERT(char_n == total_glyph_count);
		NK_ASSERT(range_n == total_range_count);
	}
	*height = (int)nk_round_up_pow2((nk_uint)*height);
	*image_memory = (nk_size)(*width) * (nk_size)(*height);
	return nk_true;
}
NK_INTERN void
nk_font_bake(struct nk_font_baker* baker, void* image_memory, int width, int height,
	struct nk_font_glyph* glyphs, int glyphs_count,
	const struct nk_font_config* config_list, int font_count)
{
	int input_i = 0;
	nk_rune glyph_n = 0;
	const struct nk_font_config* config_iter;
	const struct nk_font_config* it;

	NK_ASSERT(image_memory);
	NK_ASSERT(width);
	NK_ASSERT(height);
	NK_ASSERT(config_list);
	NK_ASSERT(baker);
	NK_ASSERT(font_count);
	NK_ASSERT(glyphs_count);
	if (!image_memory || !width || !height || !config_list ||
		!font_count || !glyphs || !glyphs_count)
		return;

	/* second font pass: render glyphs */
	nk_zero(image_memory, (nk_size)((nk_size)width * (nk_size)height));
	baker->spc.pixels = (unsigned char*)image_memory;
	baker->spc.height = (int)height;
	for (input_i = 0, config_iter = config_list; input_i < font_count && config_iter;
		config_iter = config_iter->next) {
		it = config_iter;
		do {
			const struct nk_font_config* cfg = it;
			struct nk_font_bake_data* tmp = &baker->build[input_i++];
			nk_tt_PackSetOversampling(&baker->spc, cfg->oversample_h, cfg->oversample_v);
			nk_tt_PackFontRangesRenderIntoRects(&baker->spc, &tmp->info, tmp->ranges,
				(int)tmp->range_count, tmp->rects, &baker->alloc);
		} while ((it = it->n) != config_iter);
	} nk_tt_PackEnd(&baker->spc, &baker->alloc);

	/* third pass: setup font and glyphs */
	for (input_i = 0, config_iter = config_list; input_i < font_count && config_iter;
		config_iter = config_iter->next) {
		it = config_iter;
		do {
			nk_size i = 0;
			int char_idx = 0;
			nk_rune glyph_count = 0;
			const struct nk_font_config* cfg = it;
			struct nk_font_bake_data* tmp = &baker->build[input_i++];
			struct nk_baked_font* dst_font = cfg->font;

			float font_scale = nk_tt_ScaleForPixelHeight(&tmp->info, cfg->size);
			int unscaled_ascent, unscaled_descent, unscaled_line_gap;
			nk_tt_GetFontVMetrics(&tmp->info, &unscaled_ascent, &unscaled_descent,
				&unscaled_line_gap);

			/* fill baked font */
			if (!cfg->merge_mode) {
				dst_font->ranges = cfg->range;
				dst_font->height = cfg->size;
				dst_font->ascent = ((float)unscaled_ascent * font_scale);
				dst_font->descent = ((float)unscaled_descent * font_scale);
				dst_font->glyph_offset = glyph_n;
			}

			/* fill own baked font glyph array */
			for (i = 0; i < tmp->range_count; ++i) {
				struct nk_tt_pack_range* range = &tmp->ranges[i];
				for (char_idx = 0; char_idx < range->num_chars; char_idx++)
				{
					nk_rune codepoint = 0;
					float dummy_x = 0, dummy_y = 0;
					struct nk_tt_aligned_quad q;
					struct nk_font_glyph* glyph;

					/* query glyph bounds from stb_truetype */
					const struct nk_tt_packedchar* pc = &range->chardata_for_range[char_idx];
					if (!pc->x0 && !pc->x1 && !pc->y0 && !pc->y1) continue;
					codepoint = (nk_rune)(range->first_unicode_codepoint_in_range + char_idx);
					nk_tt_GetPackedQuad(range->chardata_for_range, (int)width,
						(int)height, char_idx, &dummy_x, &dummy_y, &q, 0);

					/* fill own glyph type with data */
					glyph = &glyphs[dst_font->glyph_offset + dst_font->glyph_count + (unsigned int)glyph_count];
					glyph->codepoint = codepoint;
					glyph->x0 = q.x0; glyph->y0 = q.y0;
					glyph->x1 = q.x1; glyph->y1 = q.y1;
					glyph->y0 += (dst_font->ascent + 0.5f);
					glyph->y1 += (dst_font->ascent + 0.5f);
					glyph->w = glyph->x1 - glyph->x0 + 0.5f;
					glyph->h = glyph->y1 - glyph->y0;

					if (cfg->coord_type == NK_COORD_PIXEL) {
						glyph->u0 = q.s0 * (float)width;
						glyph->v0 = q.t0 * (float)height;
						glyph->u1 = q.s1 * (float)width;
						glyph->v1 = q.t1 * (float)height;
					}
					else {
						glyph->u0 = q.s0;
						glyph->v0 = q.t0;
						glyph->u1 = q.s1;
						glyph->v1 = q.t1;
					}
					glyph->xadvance = (pc->xadvance + cfg->spacing.x);
					if (cfg->pixel_snap)
						glyph->xadvance = (float)(int)(glyph->xadvance + 0.5f);
					glyph_count++;
				}
			}
			dst_font->glyph_count += glyph_count;
			glyph_n += glyph_count;
		} while ((it = it->n) != config_iter);
	}
}
NK_INTERN void
nk_font_bake_custom_data(void* img_memory, int img_width, int img_height,
	struct nk_recti img_dst, const char* texture_data_mask, int tex_width,
	int tex_height, char white, char black)
{
	nk_byte* pixels;
	int y = 0;
	int x = 0;
	int n = 0;

	NK_ASSERT(img_memory);
	NK_ASSERT(img_width);
	NK_ASSERT(img_height);
	NK_ASSERT(texture_data_mask);
	NK_UNUSED(tex_height);
	if (!img_memory || !img_width || !img_height || !texture_data_mask)
		return;

	pixels = (nk_byte*)img_memory;
	for (y = 0, n = 0; y < tex_height; ++y) {
		for (x = 0; x < tex_width; ++x, ++n) {
			const int off0 = ((img_dst.x + x) + (img_dst.y + y) * img_width);
			const int off1 = off0 + 1 + tex_width;
			pixels[off0] = (texture_data_mask[n] == white) ? 0xFF : 0x00;
			pixels[off1] = (texture_data_mask[n] == black) ? 0xFF : 0x00;
		}
	}
}
NK_INTERN void
nk_font_bake_convert(void* out_memory, int img_width, int img_height,
	const void* in_memory)
{
	int n = 0;
	nk_rune* dst;
	const nk_byte* src;

	NK_ASSERT(out_memory);
	NK_ASSERT(in_memory);
	NK_ASSERT(img_width);
	NK_ASSERT(img_height);
	if (!out_memory || !in_memory || !img_height || !img_width) return;

	dst = (nk_rune*)out_memory;
	src = (const nk_byte*)in_memory;
	for (n = (int)(img_width * img_height); n > 0; n--)
		*dst++ = ((nk_rune)(*src++) << 24) | 0x00FFFFFF;
}

/* -------------------------------------------------------------
 *
 *                          FONT
 *
 * --------------------------------------------------------------*/
NK_INTERN float
nk_font_text_width(nk_handle handle, float height, const char* text, int len)
{
	nk_rune unicode;
	int text_len = 0;
	float text_width = 0;
	int glyph_len = 0;
	float scale = 0;

	struct nk_font* font = (struct nk_font*)handle.ptr;
	NK_ASSERT(font);
	NK_ASSERT(font->glyphs);
	if (!font || !text || !len)
		return 0;

	scale = height / font->info.height;
	glyph_len = text_len = nk_utf_decode(text, &unicode, (int)len);
	if (!glyph_len) return 0;
	while (text_len <= (int)len && glyph_len) {
		const struct nk_font_glyph* g;
		if (unicode == NK_UTF_INVALID) break;

		/* query currently drawn glyph information */
		g = nk_font_find_glyph(font, unicode);
		text_width += g->xadvance * scale;

		/* offset next glyph */
		glyph_len = nk_utf_decode(text + text_len, &unicode, (int)len - text_len);
		text_len += glyph_len;
	}
	return text_width;
}
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
NK_INTERN void
nk_font_query_font_glyph(nk_handle handle, float height,
	struct nk_user_font_glyph* glyph, nk_rune codepoint, nk_rune next_codepoint)
{
	float scale;
	const struct nk_font_glyph* g;
	struct nk_font* font;

	NK_ASSERT(glyph);
	NK_UNUSED(next_codepoint);

	font = (struct nk_font*)handle.ptr;
	NK_ASSERT(font);
	NK_ASSERT(font->glyphs);
	if (!font || !glyph)
		return;

	scale = height / font->info.height;
	g = nk_font_find_glyph(font, codepoint);
	glyph->width = (g->x1 - g->x0) * scale;
	glyph->height = (g->y1 - g->y0) * scale;
	glyph->offset = nk_vec2(g->x0 * scale, g->y0 * scale);
	glyph->xadvance = (g->xadvance * scale);
	glyph->uv[0] = nk_vec2(g->u0, g->v0);
	glyph->uv[1] = nk_vec2(g->u1, g->v1);
}
#endif
NK_API const struct nk_font_glyph*
nk_font_find_glyph(struct nk_font* font, nk_rune unicode)
{
	int i = 0;
	int count;
	int total_glyphs = 0;
	const struct nk_font_glyph* glyph = 0;
	const struct nk_font_config* iter = 0;

	NK_ASSERT(font);
	NK_ASSERT(font->glyphs);
	NK_ASSERT(font->info.ranges);
	if (!font || !font->glyphs) return 0;

	glyph = font->fallback;
	iter = font->config;
	do {
		count = nk_range_count(iter->range);
		for (i = 0; i < count; ++i) {
			nk_rune f = iter->range[(i * 2) + 0];
			nk_rune t = iter->range[(i * 2) + 1];
			int diff = (int)((t - f) + 1);
			if (unicode >= f && unicode <= t)
				return &font->glyphs[((nk_rune)total_glyphs + (unicode - f))];
			total_glyphs += diff;
		}
	} while ((iter = iter->n) != font->config);
	return glyph;
}
NK_INTERN void
nk_font_init(struct nk_font* font, float pixel_height,
	nk_rune fallback_codepoint, struct nk_font_glyph* glyphs,
	const struct nk_baked_font* baked_font, nk_handle atlas)
{
	struct nk_baked_font baked;
	NK_ASSERT(font);
	NK_ASSERT(glyphs);
	NK_ASSERT(baked_font);
	if (!font || !glyphs || !baked_font)
		return;

	baked = *baked_font;
	font->fallback = 0;
	font->info = baked;
	font->scale = (float)pixel_height / (float)font->info.height;
	font->glyphs = &glyphs[baked_font->glyph_offset];
	font->texture = atlas;
	font->fallback_codepoint = fallback_codepoint;
	font->fallback = nk_font_find_glyph(font, fallback_codepoint);

	font->handle.height = font->info.height * font->scale;
	font->handle.width = nk_font_text_width;
	font->handle.userdata.ptr = font;
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
	font->handle.query = nk_font_query_font_glyph;
	font->handle.texture = font->texture;
#endif
}

/* ---------------------------------------------------------------------------
 *
 *                          DEFAULT FONT
 *
 * ProggyClean.ttf
 * Copyright (c) 2004, 2005 Tristan Grimmer
 * MIT license (see License.txt in http://www.upperbounds.net/download/ProggyClean.ttf.zip)
 * Download and more information at http://upperbounds.net
 *-----------------------------------------------------------------------------*/
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Woverlength-strings"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverlength-strings"
#endif

#ifdef NK_INCLUDE_DEFAULT_FONT

NK_GLOBAL const char nk_proggy_clean_ttf_compressed_data_base85[11980 + 1] =
"7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/"
"2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"
"`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"
"i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N"
"kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"
"*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"
"tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"
"ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc."
"x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"
"CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)"
"U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"
"'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"
"_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"
"Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"
"/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"
"%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"
"OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("
"h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"
"o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"
"j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"
"sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"
"eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"
"M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%"
"LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"
"%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"
"Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"
"a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("
"$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<"
"nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"
"7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;"
")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"
"D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("
"P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs"
"bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q"
"h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-"
"V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"
"sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7"
".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@"
"$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"
"hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u"
"@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"
"w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#"
"u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"
"d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"
"6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#"
"b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"
":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+"
"tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"
"$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"
":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"
"7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"
"u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT"
"LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M"
":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>"
"_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"
"hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"
"^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"
"+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%"
"9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"
"CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"
"hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"
"8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"
"S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"
"0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"
"+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"
"M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V"
"?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"
"Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"
">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"
"[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I"
"wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#"
"Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"
"MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"
"i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"
"1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"
"iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"
"URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"
";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"
"w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#"
"d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"
"A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
"/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"
"m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
"TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"
"GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
"O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";

#endif /* NK_INCLUDE_DEFAULT_FONT */

#define NK_CURSOR_DATA_W 90
#define NK_CURSOR_DATA_H 27
NK_GLOBAL const char nk_custom_cursor_data[NK_CURSOR_DATA_W * NK_CURSOR_DATA_H + 1] =
{
	"..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX"
	"..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X"
	"---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X"
	"X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X"
	"XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X"
	"X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X"
	"X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX"
	"X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      "
	"X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       "
	"X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        "
	"X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         "
	"X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          "
	"X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           "
	"X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            "
	"X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           "
	"X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          "
	"X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          "
	"X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       ------------------------------------"
	"X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           "
	"XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           "
	"      X..X          -  X...X  -         X...X         -  X..X           X..X  -           "
	"       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           "
	"------------        -    X    -           X           -X.....................X-           "
	"                    ----------------------------------- X...XXXXXXXXXXXXX...X -           "
	"                                                      -  X..X           X..X  -           "
	"                                                      -   X.X           X.X   -           "
	"                                                      -    XX           XX    -           "
};

#ifdef __clang__
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif

NK_GLOBAL unsigned char* nk__barrier;
NK_GLOBAL unsigned char* nk__barrier2;
NK_GLOBAL unsigned char* nk__barrier3;
NK_GLOBAL unsigned char* nk__barrier4;
NK_GLOBAL unsigned char* nk__dout;

NK_INTERN unsigned int
nk_decompress_length(unsigned char* input)
{
	return (unsigned int)((input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11]);
}
NK_INTERN void
nk__match(unsigned char* data, unsigned int length)
{
	/* INVERSE of memmove... write each byte before copying the next...*/
	NK_ASSERT(nk__dout + length <= nk__barrier);
	if (nk__dout + length > nk__barrier) { nk__dout += length; return; }
	if (data < nk__barrier4) { nk__dout = nk__barrier + 1; return; }
	while (length--)*nk__dout++ = *data++;
}
NK_INTERN void
nk__lit(unsigned char* data, unsigned int length)
{
	NK_ASSERT(nk__dout + length <= nk__barrier);
	if (nk__dout + length > nk__barrier) { nk__dout += length; return; }
	if (data < nk__barrier2) { nk__dout = nk__barrier + 1; return; }
	NK_MEMCPY(nk__dout, data, length);
	nk__dout += length;
}
NK_INTERN unsigned char*
nk_decompress_token(unsigned char* i)
{
#define nk__in2(x)   ((i[x] << 8) + i[(x)+1])
#define nk__in3(x)   ((i[x] << 16) + nk__in2((x)+1))
#define nk__in4(x)   ((i[x] << 24) + nk__in3((x)+1))

	if (*i >= 0x20) { /* use fewer if's for cases that expand small */
		if (*i >= 0x80)       nk__match(nk__dout - i[1] - 1, (unsigned int)i[0] - 0x80 + 1), i += 2;
		else if (*i >= 0x40)  nk__match(nk__dout - (nk__in2(0) - 0x4000 + 1), (unsigned int)i[2] + 1), i += 3;
		else /* *i >= 0x20 */ nk__lit(i + 1, (unsigned int)i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
	}
	else { /* more ifs for cases that expand large, since overhead is amortized */
		if (*i >= 0x18)       nk__match(nk__dout - (unsigned int)(nk__in3(0) - 0x180000 + 1), (unsigned int)i[3] + 1), i += 4;
		else if (*i >= 0x10)  nk__match(nk__dout - (unsigned int)(nk__in3(0) - 0x100000 + 1), (unsigned int)nk__in2(3) + 1), i += 5;
		else if (*i >= 0x08)  nk__lit(i + 2, (unsigned int)nk__in2(0) - 0x0800 + 1), i += 2 + (nk__in2(0) - 0x0800 + 1);
		else if (*i == 0x07)  nk__lit(i + 3, (unsigned int)nk__in2(1) + 1), i += 3 + (nk__in2(1) + 1);
		else if (*i == 0x06)  nk__match(nk__dout - (unsigned int)(nk__in3(1) + 1), i[4] + 1u), i += 5;
		else if (*i == 0x04)  nk__match(nk__dout - (unsigned int)(nk__in3(1) + 1), (unsigned int)nk__in2(4) + 1u), i += 6;
	}
	return i;
}
NK_INTERN unsigned int
nk_adler32(unsigned int adler32, unsigned char* buffer, unsigned int buflen)
{
	const unsigned long ADLER_MOD = 65521;
	unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
	unsigned long blocklen, i;

	blocklen = buflen % 5552;
	while (buflen) {
		for (i = 0; i + 7 < blocklen; i += 8) {
			s1 += buffer[0]; s2 += s1;
			s1 += buffer[1]; s2 += s1;
			s1 += buffer[2]; s2 += s1;
			s1 += buffer[3]; s2 += s1;
			s1 += buffer[4]; s2 += s1;
			s1 += buffer[5]; s2 += s1;
			s1 += buffer[6]; s2 += s1;
			s1 += buffer[7]; s2 += s1;
			buffer += 8;
		}
		for (; i < blocklen; ++i) {
			s1 += *buffer++; s2 += s1;
		}

		s1 %= ADLER_MOD; s2 %= ADLER_MOD;
		buflen -= (unsigned int)blocklen;
		blocklen = 5552;
	}
	return (unsigned int)(s2 << 16) + (unsigned int)s1;
}
NK_INTERN unsigned int
nk_decompress(unsigned char* output, unsigned char* i, unsigned int length)
{
	unsigned int olen;
	if (nk__in4(0) != 0x57bC0000) return 0;
	if (nk__in4(4) != 0)          return 0; /* error! stream is > 4GB */
	olen = nk_decompress_length(i);
	nk__barrier2 = i;
	nk__barrier3 = i + length;
	nk__barrier = output + olen;
	nk__barrier4 = output;
	i += 16;

	nk__dout = output;
	for (;;) {
		unsigned char* old_i = i;
		i = nk_decompress_token(i);
		if (i == old_i) {
			if (*i == 0x05 && i[1] == 0xfa) {
				NK_ASSERT(nk__dout == output + olen);
				if (nk__dout != output + olen) return 0;
				if (nk_adler32(1, output, olen) != (unsigned int)nk__in4(2))
					return 0;
				return olen;
			}
			else {
				NK_ASSERT(0); /* NOTREACHED */
				return 0;
			}
		}
		NK_ASSERT(nk__dout <= output + olen);
		if (nk__dout > output + olen)
			return 0;
	}
}
NK_INTERN unsigned int
nk_decode_85_byte(char c)
{
	return (unsigned int)((c >= '\\') ? c - 36 : c - 35);
}
NK_INTERN void
nk_decode_85(unsigned char* dst, const unsigned char* src)
{
	while (*src)
	{
		unsigned int tmp =
			nk_decode_85_byte((char)src[0]) +
			85 * (nk_decode_85_byte((char)src[1]) +
				85 * (nk_decode_85_byte((char)src[2]) +
					85 * (nk_decode_85_byte((char)src[3]) +
						85 * nk_decode_85_byte((char)src[4]))));

		/* we can't assume little-endianess. */
		dst[0] = (unsigned char)((tmp >> 0) & 0xFF);
		dst[1] = (unsigned char)((tmp >> 8) & 0xFF);
		dst[2] = (unsigned char)((tmp >> 16) & 0xFF);
		dst[3] = (unsigned char)((tmp >> 24) & 0xFF);

		src += 5;
		dst += 4;
	}
}

/* -------------------------------------------------------------
 *
 *                          FONT ATLAS
 *
 * --------------------------------------------------------------*/
NK_API struct nk_font_config
nk_font_config(float pixel_height)
{
	struct nk_font_config cfg;
	nk_zero_struct(cfg);
	cfg.ttf_blob = 0;
	cfg.ttf_size = 0;
	cfg.ttf_data_owned_by_atlas = 0;
	cfg.size = pixel_height;
	cfg.oversample_h = 3;
	cfg.oversample_v = 1;
	cfg.pixel_snap = 0;
	cfg.coord_type = NK_COORD_UV;
	cfg.spacing = nk_vec2(0, 0);
	cfg.range = nk_font_default_glyph_ranges();
	cfg.merge_mode = 0;
	cfg.fallback_glyph = '?';
	cfg.font = 0;
	cfg.n = 0;
	return cfg;
}
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR
NK_API void
nk_font_atlas_init_default(struct nk_font_atlas* atlas)
{
	NK_ASSERT(atlas);
	if (!atlas) return;
	nk_zero_struct(*atlas);
	atlas->temporary.userdata.ptr = 0;
	atlas->temporary.alloc = nk_malloc;
	atlas->temporary.free = nk_mfree;
	atlas->permanent.userdata.ptr = 0;
	atlas->permanent.alloc = nk_malloc;
	atlas->permanent.free = nk_mfree;
}
#endif
NK_API void
nk_font_atlas_init(struct nk_font_atlas* atlas, struct nk_allocator* alloc)
{
	NK_ASSERT(atlas);
	NK_ASSERT(alloc);
	if (!atlas || !alloc) return;
	nk_zero_struct(*atlas);
	atlas->permanent = *alloc;
	atlas->temporary = *alloc;
}
NK_API void
nk_font_atlas_init_custom(struct nk_font_atlas* atlas,
	struct nk_allocator* permanent, struct nk_allocator* temporary)
{
	NK_ASSERT(atlas);
	NK_ASSERT(permanent);
	NK_ASSERT(temporary);
	if (!atlas || !permanent || !temporary) return;
	nk_zero_struct(*atlas);
	atlas->permanent = *permanent;
	atlas->temporary = *temporary;
}
NK_API void
nk_font_atlas_begin(struct nk_font_atlas* atlas)
{
	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc && atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc && atlas->permanent.free);
	if (!atlas || !atlas->permanent.alloc || !atlas->permanent.free ||
		!atlas->temporary.alloc || !atlas->temporary.free) return;
	if (atlas->glyphs) {
		atlas->permanent.free(atlas->permanent.userdata, atlas->glyphs);
		atlas->glyphs = 0;
	}
	if (atlas->pixel) {
		atlas->permanent.free(atlas->permanent.userdata, atlas->pixel);
		atlas->pixel = 0;
	}
}
NK_API struct nk_font*
nk_font_atlas_add(struct nk_font_atlas* atlas, const struct nk_font_config* config)
{
	struct nk_font* font = 0;
	struct nk_font_config* cfg;

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);

	NK_ASSERT(config);
	NK_ASSERT(config->ttf_blob);
	NK_ASSERT(config->ttf_size);
	NK_ASSERT(config->size > 0.0f);

	if (!atlas || !config || !config->ttf_blob || !config->ttf_size || config->size <= 0.0f ||
		!atlas->permanent.alloc || !atlas->permanent.free ||
		!atlas->temporary.alloc || !atlas->temporary.free)
		return 0;

	/* allocate font config  */
	cfg = (struct nk_font_config*)
		atlas->permanent.alloc(atlas->permanent.userdata, 0, sizeof(struct nk_font_config));
	NK_MEMCPY(cfg, config, sizeof(*config));
	cfg->n = cfg;
	cfg->p = cfg;

	if (!config->merge_mode) {
		/* insert font config into list */
		if (!atlas->config) {
			atlas->config = cfg;
			cfg->next = 0;
		}
		else {
			struct nk_font_config* i = atlas->config;
			while (i->next) i = i->next;
			i->next = cfg;
			cfg->next = 0;
		}
		/* allocate new font */
		font = (struct nk_font*)
			atlas->permanent.alloc(atlas->permanent.userdata, 0, sizeof(struct nk_font));
		NK_ASSERT(font);
		nk_zero(font, sizeof(*font));
		if (!font) return 0;
		font->config = cfg;

		/* insert font into list */
		if (!atlas->fonts) {
			atlas->fonts = font;
			font->next = 0;
		}
		else {
			struct nk_font* i = atlas->fonts;
			while (i->next) i = i->next;
			i->next = font;
			font->next = 0;
		}
		cfg->font = &font->info;
	}
	else {
		/* extend previously added font */
		struct nk_font* f = 0;
		struct nk_font_config* c = 0;
		NK_ASSERT(atlas->font_num);
		f = atlas->fonts;
		c = f->config;
		cfg->font = &f->info;

		cfg->n = c;
		cfg->p = c->p;
		c->p->n = cfg;
		c->p = cfg;
	}
	/* create own copy of .TTF font blob */
	if (!config->ttf_data_owned_by_atlas) {
		cfg->ttf_blob = atlas->permanent.alloc(atlas->permanent.userdata, 0, cfg->ttf_size);
		NK_ASSERT(cfg->ttf_blob);
		if (!cfg->ttf_blob) {
			atlas->font_num++;
			return 0;
		}
		NK_MEMCPY(cfg->ttf_blob, config->ttf_blob, cfg->ttf_size);
		cfg->ttf_data_owned_by_atlas = 1;
	}
	atlas->font_num++;
	return font;
}
NK_API struct nk_font*
nk_font_atlas_add_from_memory(struct nk_font_atlas* atlas, void* memory,
	nk_size size, float height, const struct nk_font_config* config)
{
	struct nk_font_config cfg;
	NK_ASSERT(memory);
	NK_ASSERT(size);

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);
	if (!atlas || !atlas->temporary.alloc || !atlas->temporary.free || !memory || !size ||
		!atlas->permanent.alloc || !atlas->permanent.free)
		return 0;

	cfg = (config) ? *config : nk_font_config(height);
	cfg.ttf_blob = memory;
	cfg.ttf_size = size;
	cfg.size = height;
	cfg.ttf_data_owned_by_atlas = 0;
	return nk_font_atlas_add(atlas, &cfg);
}
#ifdef NK_INCLUDE_STANDARD_IO
NK_API struct nk_font*
nk_font_atlas_add_from_file(struct nk_font_atlas* atlas, const char* file_path,
	float height, const struct nk_font_config* config)
{
	nk_size size;
	char* memory;
	struct nk_font_config cfg;

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);

	if (!atlas || !file_path) return 0;
	memory = nk_file_load(file_path, &size, &atlas->permanent);
	if (!memory) return 0;

	cfg = (config) ? *config : nk_font_config(height);
	cfg.ttf_blob = memory;
	cfg.ttf_size = size;
	cfg.size = height;
	cfg.ttf_data_owned_by_atlas = 1;
	return nk_font_atlas_add(atlas, &cfg);
}
#endif
NK_API struct nk_font*
nk_font_atlas_add_compressed(struct nk_font_atlas* atlas,
	void* compressed_data, nk_size compressed_size, float height,
	const struct nk_font_config* config)
{
	unsigned int decompressed_size;
	void* decompressed_data;
	struct nk_font_config cfg;

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);

	NK_ASSERT(compressed_data);
	NK_ASSERT(compressed_size);
	if (!atlas || !compressed_data || !atlas->temporary.alloc || !atlas->temporary.free ||
		!atlas->permanent.alloc || !atlas->permanent.free)
		return 0;

	decompressed_size = nk_decompress_length((unsigned char*)compressed_data);
	decompressed_data = atlas->permanent.alloc(atlas->permanent.userdata, 0, decompressed_size);
	NK_ASSERT(decompressed_data);
	if (!decompressed_data) return 0;
	nk_decompress((unsigned char*)decompressed_data, (unsigned char*)compressed_data,
		(unsigned int)compressed_size);

	cfg = (config) ? *config : nk_font_config(height);
	cfg.ttf_blob = decompressed_data;
	cfg.ttf_size = decompressed_size;
	cfg.size = height;
	cfg.ttf_data_owned_by_atlas = 1;
	return nk_font_atlas_add(atlas, &cfg);
}
NK_API struct nk_font*
nk_font_atlas_add_compressed_base85(struct nk_font_atlas* atlas,
	const char* data_base85, float height, const struct nk_font_config* config)
{
	int compressed_size;
	void* compressed_data;
	struct nk_font* font;

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);

	NK_ASSERT(data_base85);
	if (!atlas || !data_base85 || !atlas->temporary.alloc || !atlas->temporary.free ||
		!atlas->permanent.alloc || !atlas->permanent.free)
		return 0;

	compressed_size = (((int)nk_strlen(data_base85) + 4) / 5) * 4;
	compressed_data = atlas->temporary.alloc(atlas->temporary.userdata, 0, (nk_size)compressed_size);
	NK_ASSERT(compressed_data);
	if (!compressed_data) return 0;
	nk_decode_85((unsigned char*)compressed_data, (const unsigned char*)data_base85);
	font = nk_font_atlas_add_compressed(atlas, compressed_data,
		(nk_size)compressed_size, height, config);
	atlas->temporary.free(atlas->temporary.userdata, compressed_data);
	return font;
}

#ifdef NK_INCLUDE_DEFAULT_FONT
NK_API struct nk_font*
nk_font_atlas_add_default(struct nk_font_atlas* atlas,
	float pixel_height, const struct nk_font_config* config)
{
	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);
	return nk_font_atlas_add_compressed_base85(atlas,
		nk_proggy_clean_ttf_compressed_data_base85, pixel_height, config);
}
#endif
NK_API const void*
nk_font_atlas_bake(struct nk_font_atlas* atlas, int* width, int* height,
	enum nk_font_atlas_format fmt)
{
	int i = 0;
	void* tmp = 0;
	nk_size tmp_size, img_size;
	struct nk_font* font_iter;
	struct nk_font_baker* baker;

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);

	NK_ASSERT(width);
	NK_ASSERT(height);
	if (!atlas || !width || !height ||
		!atlas->temporary.alloc || !atlas->temporary.free ||
		!atlas->permanent.alloc || !atlas->permanent.free)
		return 0;

#ifdef NK_INCLUDE_DEFAULT_FONT
	/* no font added so just use default font */
	if (!atlas->font_num)
		atlas->default_font = nk_font_atlas_add_default(atlas, 13.0f, 0);
#endif
	NK_ASSERT(atlas->font_num);
	if (!atlas->font_num) return 0;

	/* allocate temporary baker memory required for the baking process */
	nk_font_baker_memory(&tmp_size, &atlas->glyph_count, atlas->config, atlas->font_num);
	tmp = atlas->temporary.alloc(atlas->temporary.userdata, 0, tmp_size);
	NK_ASSERT(tmp);
	if (!tmp) goto failed;

	/* allocate glyph memory for all fonts */
	baker = nk_font_baker(tmp, atlas->glyph_count, atlas->font_num, &atlas->temporary);
	atlas->glyphs = (struct nk_font_glyph*)atlas->permanent.alloc(
		atlas->permanent.userdata, 0, sizeof(struct nk_font_glyph) * (nk_size)atlas->glyph_count);
	NK_ASSERT(atlas->glyphs);
	if (!atlas->glyphs)
		goto failed;

	/* pack all glyphs into a tight fit space */
	atlas->custom.w = (NK_CURSOR_DATA_W * 2) + 1;
	atlas->custom.h = NK_CURSOR_DATA_H + 1;
	if (!nk_font_bake_pack(baker, &img_size, width, height, &atlas->custom,
		atlas->config, atlas->font_num, &atlas->temporary))
		goto failed;

	/* allocate memory for the baked image font atlas */
	atlas->pixel = atlas->temporary.alloc(atlas->temporary.userdata, 0, img_size);
	NK_ASSERT(atlas->pixel);
	if (!atlas->pixel)
		goto failed;

	/* bake glyphs and custom white pixel into image */
	nk_font_bake(baker, atlas->pixel, *width, *height,
		atlas->glyphs, atlas->glyph_count, atlas->config, atlas->font_num);
	nk_font_bake_custom_data(atlas->pixel, *width, *height, atlas->custom,
		nk_custom_cursor_data, NK_CURSOR_DATA_W, NK_CURSOR_DATA_H, '.', 'X');

	if (fmt == NK_FONT_ATLAS_RGBA32) {
		/* convert alpha8 image into rgba32 image */
		void* img_rgba = atlas->temporary.alloc(atlas->temporary.userdata, 0,
			(nk_size)(*width * *height * 4));
		NK_ASSERT(img_rgba);
		if (!img_rgba) goto failed;
		nk_font_bake_convert(img_rgba, *width, *height, atlas->pixel);
		atlas->temporary.free(atlas->temporary.userdata, atlas->pixel);
		atlas->pixel = img_rgba;
	}
	atlas->tex_width = *width;
	atlas->tex_height = *height;

	/* initialize each font */
	for (font_iter = atlas->fonts; font_iter; font_iter = font_iter->next) {
		struct nk_font* font = font_iter;
		struct nk_font_config* config = font->config;
		nk_font_init(font, config->size, config->fallback_glyph, atlas->glyphs,
			config->font, nk_handle_ptr(0));
	}

	/* initialize each cursor */
	{NK_STORAGE const struct nk_vec2 nk_cursor_data[NK_CURSOR_COUNT][3] = {
		/* Pos      Size        Offset */
		{{ 0, 3},   {12,19},    { 0, 0}},
		{{13, 0},   { 7,16},    { 4, 8}},
		{{31, 0},   {23,23},    {11,11}},
		{{21, 0},   { 9, 23},   { 5,11}},
		{{55,18},   {23, 9},    {11, 5}},
		{{73, 0},   {17,17},    { 9, 9}},
		{{55, 0},   {17,17},    { 9, 9}}
	};
	for (i = 0; i < NK_CURSOR_COUNT; ++i) {
		struct nk_cursor* cursor = &atlas->cursors[i];
		cursor->img.w = (unsigned short)*width;
		cursor->img.h = (unsigned short)*height;
		cursor->img.region[0] = (unsigned short)(atlas->custom.x + nk_cursor_data[i][0].x);
		cursor->img.region[1] = (unsigned short)(atlas->custom.y + nk_cursor_data[i][0].y);
		cursor->img.region[2] = (unsigned short)nk_cursor_data[i][1].x;
		cursor->img.region[3] = (unsigned short)nk_cursor_data[i][1].y;
		cursor->size = nk_cursor_data[i][1];
		cursor->offset = nk_cursor_data[i][2];
	}}
	/* free temporary memory */
	atlas->temporary.free(atlas->temporary.userdata, tmp);
	return atlas->pixel;

failed:
	/* error so cleanup all memory */
	if (tmp) atlas->temporary.free(atlas->temporary.userdata, tmp);
	if (atlas->glyphs) {
		atlas->permanent.free(atlas->permanent.userdata, atlas->glyphs);
		atlas->glyphs = 0;
	}
	if (atlas->pixel) {
		atlas->temporary.free(atlas->temporary.userdata, atlas->pixel);
		atlas->pixel = 0;
	}
	return 0;
}
NK_API void
nk_font_atlas_end(struct nk_font_atlas* atlas, nk_handle texture,
	struct nk_draw_null_texture* null)
{
	int i = 0;
	struct nk_font* font_iter;
	NK_ASSERT(atlas);
	if (!atlas) {
		if (!null) return;
		null->texture = texture;
		null->uv = nk_vec2(0.5f, 0.5f);
	}
	if (null) {
		null->texture = texture;
		null->uv.x = (atlas->custom.x + 0.5f) / (float)atlas->tex_width;
		null->uv.y = (atlas->custom.y + 0.5f) / (float)atlas->tex_height;
	}
	for (font_iter = atlas->fonts; font_iter; font_iter = font_iter->next) {
		font_iter->texture = texture;
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
		font_iter->handle.texture = texture;
#endif
	}
	for (i = 0; i < NK_CURSOR_COUNT; ++i)
		atlas->cursors[i].img.handle = texture;

	atlas->temporary.free(atlas->temporary.userdata, atlas->pixel);
	atlas->pixel = 0;
	atlas->tex_width = 0;
	atlas->tex_height = 0;
	atlas->custom.x = 0;
	atlas->custom.y = 0;
	atlas->custom.w = 0;
	atlas->custom.h = 0;
}
NK_API void
nk_font_atlas_cleanup(struct nk_font_atlas* atlas)
{
	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);
	if (!atlas || !atlas->permanent.alloc || !atlas->permanent.free) return;
	if (atlas->config) {
		struct nk_font_config* iter;
		for (iter = atlas->config; iter; iter = iter->next) {
			struct nk_font_config* i;
			for (i = iter->n; i != iter; i = i->n) {
				atlas->permanent.free(atlas->permanent.userdata, i->ttf_blob);
				i->ttf_blob = 0;
			}
			atlas->permanent.free(atlas->permanent.userdata, iter->ttf_blob);
			iter->ttf_blob = 0;
		}
	}
}
NK_API void
nk_font_atlas_clear(struct nk_font_atlas* atlas)
{
	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);
	if (!atlas || !atlas->permanent.alloc || !atlas->permanent.free) return;

	if (atlas->config) {
		struct nk_font_config* iter, * next;
		for (iter = atlas->config; iter; iter = next) {
			struct nk_font_config* i, * n;
			for (i = iter->n; i != iter; i = n) {
				n = i->n;
				if (i->ttf_blob)
					atlas->permanent.free(atlas->permanent.userdata, i->ttf_blob);
				atlas->permanent.free(atlas->permanent.userdata, i);
			}
			next = iter->next;
			if (i->ttf_blob)
				atlas->permanent.free(atlas->permanent.userdata, iter->ttf_blob);
			atlas->permanent.free(atlas->permanent.userdata, iter);
		}
		atlas->config = 0;
	}
	if (atlas->fonts) {
		struct nk_font* iter, * next;
		for (iter = atlas->fonts; iter; iter = next) {
			next = iter->next;
			atlas->permanent.free(atlas->permanent.userdata, iter);
		}
		atlas->fonts = 0;
	}
	if (atlas->glyphs)
		atlas->permanent.free(atlas->permanent.userdata, atlas->glyphs);
	nk_zero_struct(*atlas);
}
#endif





/* ===============================================================
 *
 *                          INPUT
 *
 * ===============================================================*/
NK_API void nk_input_begin(struct nk_context* ctx) {
	int i;
	struct nk_input* in;
	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;
	for (i = 0; i < NK_BUTTON_MAX; ++i)
		in->mouse.buttons[i].clicked = 0;

	in->keyboard.text_len = 0;
	in->mouse.scroll_delta = nk_vec2(0, 0);
	in->mouse.prev.x = in->mouse.pos.x;
	in->mouse.prev.y = in->mouse.pos.y;
	in->mouse.delta.x = 0;
	in->mouse.delta.y = 0;
	for (i = 0; i < NK_KEY_MAX; i++)
		in->keyboard.keys[i].clicked = 0;
}

NK_API void nk_input_end(struct nk_context* ctx) {
	struct nk_input* in;
	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;
	if (in->mouse.grab)
		in->mouse.grab = 0;
	if (in->mouse.ungrab) {
		in->mouse.grabbed = 0;
		in->mouse.ungrab = 0;
		in->mouse.grab = 0;
	}
}

NK_API void nk_input_motion(struct nk_context* ctx, int x, int y) {
	struct nk_input* in;
	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;
	in->mouse.pos.x = (float)x;
	in->mouse.pos.y = (float)y;
	in->mouse.delta.x = in->mouse.pos.x - in->mouse.prev.x;
	in->mouse.delta.y = in->mouse.pos.y - in->mouse.prev.y;
}

NK_API void nk_input_key(struct nk_context* ctx, enum nk_keys key, int down) {
	struct nk_input* in;
	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;
	if (in->keyboard.keys[key].down != down)
		in->keyboard.keys[key].clicked++;
	in->keyboard.keys[key].down = down;
}

NK_API void nk_input_button(struct nk_context* ctx, enum nk_buttons id, int x, int y, int down) {
	struct nk_mouse_button* btn;
	struct nk_input* in;
	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;
	if (in->mouse.buttons[id].down == down) return;

	btn = &in->mouse.buttons[id];
	btn->clicked_pos.x = (float)x;
	btn->clicked_pos.y = (float)y;
	btn->down = down;
	btn->clicked++;
}

NK_API void nk_input_scroll(struct nk_context* ctx, struct nk_vec2 val) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	ctx->input.mouse.scroll_delta.x += val.x;
	ctx->input.mouse.scroll_delta.y += val.y;
}

NK_API void nk_input_glyph(struct nk_context* ctx, const nk_glyph glyph) {
	int len = 0;
	nk_rune unicode;
	struct nk_input* in;

	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;

	len = nk_utf_decode(glyph, &unicode, NK_UTF_SIZE);
	if (len && ((in->keyboard.text_len + len) < NK_INPUT_MAX)) {
		nk_utf_encode(unicode, &in->keyboard.text[in->keyboard.text_len], NK_INPUT_MAX - in->keyboard.text_len);
		in->keyboard.text_len += len;
	}
}

NK_API void nk_input_char(struct nk_context* ctx, char c) {
	nk_glyph glyph;
	NK_ASSERT(ctx);
	if (!ctx) return;
	glyph[0] = c;
	nk_input_glyph(ctx, glyph);
}

NK_API void nk_input_unicode(struct nk_context* ctx, nk_rune unicode) {
	nk_glyph rune;
	NK_ASSERT(ctx);
	if (!ctx) return;
	nk_utf_encode(unicode, rune, NK_UTF_SIZE);
	nk_input_glyph(ctx, rune);
}

NK_API int nk_input_has_mouse_click(const struct nk_input* i, enum nk_buttons id) {
	const struct nk_mouse_button* btn;
	if (!i) return nk_false;
	btn = &i->mouse.buttons[id];
	return (btn->clicked && btn->down == nk_false) ? nk_true : nk_false;
}

NK_API int nk_input_has_mouse_click_in_rect(const struct nk_input* i, enum nk_buttons id, struct nk_rect b) {
	const struct nk_mouse_button* btn;
	if (!i) return nk_false;
	btn = &i->mouse.buttons[id];
	if (!NK_INBOX(btn->clicked_pos.x, btn->clicked_pos.y, b.x, b.y, b.w, b.h))
		return nk_false;
	return nk_true;
}

NK_API int
nk_input_has_mouse_click_down_in_rect(const struct nk_input* i, enum nk_buttons id, struct nk_rect b, int down) {
	const struct nk_mouse_button* btn;
	if (!i) return nk_false;
	btn = &i->mouse.buttons[id];
	return nk_input_has_mouse_click_in_rect(i, id, b) && (btn->down == down);
}

NK_API int nk_input_is_mouse_click_in_rect(const struct nk_input* i, enum nk_buttons id, struct nk_rect b) {
	const struct nk_mouse_button* btn;
	if (!i) return nk_false;
	btn = &i->mouse.buttons[id];
	return (nk_input_has_mouse_click_down_in_rect(i, id, b, nk_false) && btn->clicked) ? nk_true : nk_false;
}

NK_API int
nk_input_is_mouse_click_down_in_rect(const struct nk_input* i, enum nk_buttons id, struct nk_rect b, int down) {
	const struct nk_mouse_button* btn;
	if (!i) return nk_false;
	btn = &i->mouse.buttons[id];
	return (nk_input_has_mouse_click_down_in_rect(i, id, b, down) && btn->clicked) ? nk_true : nk_false;
}

NK_API int nk_input_any_mouse_click_in_rect(const struct nk_input* in, struct nk_rect b) {
	int i, down = 0;
	for (i = 0; i < NK_BUTTON_MAX; ++i)
		down = down || nk_input_is_mouse_click_in_rect(in, (enum nk_buttons) i, b);
	return down;
}

NK_API int nk_input_is_mouse_hovering_rect(const struct nk_input* i, struct nk_rect rect) {
	if (!i) return nk_false;
	return NK_INBOX(i->mouse.pos.x, i->mouse.pos.y, rect.x, rect.y, rect.w, rect.h);
}

NK_API int nk_input_is_mouse_prev_hovering_rect(const struct nk_input* i, struct nk_rect rect) {
	if (!i) return nk_false;
	return NK_INBOX(i->mouse.prev.x, i->mouse.prev.y, rect.x, rect.y, rect.w, rect.h);
}

NK_API int nk_input_mouse_clicked(const struct nk_input* i, enum nk_buttons id, struct nk_rect rect) {
	if (!i) return nk_false;
	if (!nk_input_is_mouse_hovering_rect(i, rect)) return nk_false;
	return nk_input_is_mouse_click_in_rect(i, id, rect);
}

NK_API int nk_input_is_mouse_down(const struct nk_input* i, enum nk_buttons id) {
	if (!i) return nk_false;
	return i->mouse.buttons[id].down;
}

NK_API int nk_input_is_mouse_pressed(const struct nk_input* i, enum nk_buttons id) {
	const struct nk_mouse_button* b;
	if (!i) return nk_false;
	b = &i->mouse.buttons[id];
	if (b->down && b->clicked)
		return nk_true;
	return nk_false;
}

NK_API int nk_input_is_mouse_released(const struct nk_input* i, enum nk_buttons id) {
	if (!i) return nk_false;
	return (!i->mouse.buttons[id].down && i->mouse.buttons[id].clicked);
}

NK_API int nk_input_is_key_pressed(const struct nk_input* i, enum nk_keys key) {
	const struct nk_key* k;
	if (!i) return nk_false;
	k = &i->keyboard.keys[key];
	if ((k->down && k->clicked) || (!k->down && k->clicked >= 2))
		return nk_true;
	return nk_false;
}

NK_API int nk_input_is_key_released(const struct nk_input* i, enum nk_keys key) {
	const struct nk_key* k;
	if (!i) return nk_false;
	k = &i->keyboard.keys[key];
	if ((!k->down && k->clicked) || (k->down && k->clicked >= 2))
		return nk_true;
	return nk_false;
}

NK_API int nk_input_is_key_down(const struct nk_input* i, enum nk_keys key) {
	const struct nk_key* k;
	if (!i) return nk_false;
	k = &i->keyboard.keys[key];
	if (k->down) return nk_true;
	return nk_false;
}





/* ===============================================================
 *
 *                              STYLE
 *
 * ===============================================================*/
NK_API void nk_style_default(struct nk_context* ctx) { nk_style_from_table(ctx, 0); }

#define NK_COLOR_MAP(NK_COLOR)\
    NK_COLOR(NK_COLOR_TEXT,                     175,175,175,255) \
    NK_COLOR(NK_COLOR_WINDOW,                   45, 45, 45, 255) \
    NK_COLOR(NK_COLOR_HEADER,                   40, 40, 40, 255) \
    NK_COLOR(NK_COLOR_BORDER,                   65, 65, 65, 255) \
    NK_COLOR(NK_COLOR_BUTTON,                   50, 50, 50, 255) \
    NK_COLOR(NK_COLOR_BUTTON_HOVER,             40, 40, 40, 255) \
    NK_COLOR(NK_COLOR_BUTTON_ACTIVE,            35, 35, 35, 255) \
    NK_COLOR(NK_COLOR_TOGGLE,                   100,100,100,255) \
    NK_COLOR(NK_COLOR_TOGGLE_HOVER,             120,120,120,255) \
    NK_COLOR(NK_COLOR_TOGGLE_CURSOR,            45, 45, 45, 255) \
    NK_COLOR(NK_COLOR_SELECT,                   45, 45, 45, 255) \
    NK_COLOR(NK_COLOR_SELECT_ACTIVE,            35, 35, 35,255) \
    NK_COLOR(NK_COLOR_SLIDER,                   38, 38, 38, 255) \
    NK_COLOR(NK_COLOR_SLIDER_CURSOR,            100,100,100,255) \
    NK_COLOR(NK_COLOR_SLIDER_CURSOR_HOVER,      120,120,120,255) \
    NK_COLOR(NK_COLOR_SLIDER_CURSOR_ACTIVE,     150,150,150,255) \
    NK_COLOR(NK_COLOR_PROPERTY,                 38, 38, 38, 255) \
    NK_COLOR(NK_COLOR_EDIT,                     38, 38, 38, 255)  \
    NK_COLOR(NK_COLOR_EDIT_CURSOR,              175,175,175,255) \
    NK_COLOR(NK_COLOR_COMBO,                    45, 45, 45, 255) \
    NK_COLOR(NK_COLOR_CHART,                    120,120,120,255) \
    NK_COLOR(NK_COLOR_CHART_COLOR,              45, 45, 45, 255) \
    NK_COLOR(NK_COLOR_CHART_COLOR_HIGHLIGHT,    255, 0,  0, 255) \
    NK_COLOR(NK_COLOR_SCROLLBAR,                40, 40, 40, 255) \
    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR,         100,100,100,255) \
    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR_HOVER,   120,120,120,255) \
    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR_ACTIVE,  150,150,150,255) \
    NK_COLOR(NK_COLOR_TAB_HEADER,               40, 40, 40,255)

NK_GLOBAL const struct nk_color nk_default_color_style[NK_COLOR_COUNT] = {
#define NK_COLOR(a, b, c, d, e) {b,c,d,e},
		NK_COLOR_MAP(NK_COLOR)
#undef NK_COLOR
};
NK_GLOBAL const char* nk_color_names[NK_COLOR_COUNT] = {
#define NK_COLOR(a, b, c, d, e) #a,
		NK_COLOR_MAP(NK_COLOR)
#undef NK_COLOR
};

NK_API const char* nk_style_get_color_by_name(enum nk_style_colors c) {
	return nk_color_names[c];
}

NK_API struct nk_style_item nk_style_item_image(struct nk_image img) {
	struct nk_style_item i;
	i.type = NK_STYLE_ITEM_IMAGE;
	i.data.image = img;
	return i;
}

NK_API struct nk_style_item nk_style_item_color(struct nk_color col) {
	struct nk_style_item i;
	i.type = NK_STYLE_ITEM_COLOR;
	i.data.color = col;
	return i;
}

NK_API struct nk_style_item nk_style_item_hide(void) {
	struct nk_style_item i;
	i.type = NK_STYLE_ITEM_COLOR;
	i.data.color = nk_rgba(0, 0, 0, 0);
	return i;
}

NK_API void nk_style_from_table(struct nk_context* ctx, const struct nk_color* table) {
	struct nk_style* style;
	struct nk_style_text* text;
	struct nk_style_button* button;
	struct nk_style_toggle* toggle;
	struct nk_style_selectable* select;
	struct nk_style_slider* slider;
	struct nk_style_progress* prog;
	struct nk_style_scrollbar* scroll;
	struct nk_style_edit* edit;
	struct nk_style_property* property;
	struct nk_style_combo* combo;
	struct nk_style_chart* chart;
	struct nk_style_tab* tab;
	struct nk_style_window* win;

	NK_ASSERT(ctx);
	if (!ctx) return;
	style = &ctx->style;
	table = (!table) ? nk_default_color_style : table;

	/* default text */
	text = &style->text;
	text->color = table[NK_COLOR_TEXT];
	text->padding = nk_vec2(0, 0);

	/* default button */
	button = &style->button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_BUTTON]);
	button->hover = nk_style_item_color(table[NK_COLOR_BUTTON_HOVER]);
	button->active = nk_style_item_color(table[NK_COLOR_BUTTON_ACTIVE]);
	button->border_color = table[NK_COLOR_BORDER];
	button->text_background = table[NK_COLOR_BUTTON];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->image_padding = nk_vec2(0.0f, 0.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 1.0f;
	button->rounding = 4.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* contextual button */
	button = &style->contextual_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->hover = nk_style_item_color(table[NK_COLOR_BUTTON_HOVER]);
	button->active = nk_style_item_color(table[NK_COLOR_BUTTON_ACTIVE]);
	button->border_color = table[NK_COLOR_WINDOW];
	button->text_background = table[NK_COLOR_WINDOW];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* menu button */
	button = &style->menu_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->hover = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->active = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->border_color = table[NK_COLOR_WINDOW];
	button->text_background = table[NK_COLOR_WINDOW];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 1.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* checkbox toggle */
	toggle = &style->checkbox;
	nk_zero_struct(*toggle);
	toggle->normal = nk_style_item_color(table[NK_COLOR_TOGGLE]);
	toggle->hover = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
	toggle->active = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
	toggle->cursor_normal = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
	toggle->cursor_hover = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
	toggle->userdata = nk_handle_ptr(0);
	toggle->text_background = table[NK_COLOR_WINDOW];
	toggle->text_normal = table[NK_COLOR_TEXT];
	toggle->text_hover = table[NK_COLOR_TEXT];
	toggle->text_active = table[NK_COLOR_TEXT];
	toggle->padding = nk_vec2(2.0f, 2.0f);
	toggle->touch_padding = nk_vec2(0, 0);
	toggle->border_color = nk_rgba(0, 0, 0, 0);
	toggle->border = 0.0f;
	toggle->spacing = 4;

	/* option toggle */
	toggle = &style->option;
	nk_zero_struct(*toggle);
	toggle->normal = nk_style_item_color(table[NK_COLOR_TOGGLE]);
	toggle->hover = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
	toggle->active = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
	toggle->cursor_normal = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
	toggle->cursor_hover = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
	toggle->userdata = nk_handle_ptr(0);
	toggle->text_background = table[NK_COLOR_WINDOW];
	toggle->text_normal = table[NK_COLOR_TEXT];
	toggle->text_hover = table[NK_COLOR_TEXT];
	toggle->text_active = table[NK_COLOR_TEXT];
	toggle->padding = nk_vec2(3.0f, 3.0f);
	toggle->touch_padding = nk_vec2(0, 0);
	toggle->border_color = nk_rgba(0, 0, 0, 0);
	toggle->border = 0.0f;
	toggle->spacing = 4;

	/* selectable */
	select = &style->selectable;
	nk_zero_struct(*select);
	select->normal = nk_style_item_color(table[NK_COLOR_SELECT]);
	select->hover = nk_style_item_color(table[NK_COLOR_SELECT]);
	select->pressed = nk_style_item_color(table[NK_COLOR_SELECT]);
	select->normal_active = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
	select->hover_active = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
	select->pressed_active = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
	select->text_normal = table[NK_COLOR_TEXT];
	select->text_hover = table[NK_COLOR_TEXT];
	select->text_pressed = table[NK_COLOR_TEXT];
	select->text_normal_active = table[NK_COLOR_TEXT];
	select->text_hover_active = table[NK_COLOR_TEXT];
	select->text_pressed_active = table[NK_COLOR_TEXT];
	select->padding = nk_vec2(2.0f, 2.0f);
	select->image_padding = nk_vec2(2.0f, 2.0f);
	select->touch_padding = nk_vec2(0, 0);
	select->userdata = nk_handle_ptr(0);
	select->rounding = 0.0f;
	select->draw_begin = 0;
	select->draw_end = 0;

	/* slider */
	slider = &style->slider;
	nk_zero_struct(*slider);
	slider->normal = nk_style_item_hide();
	slider->hover = nk_style_item_hide();
	slider->active = nk_style_item_hide();
	slider->bar_normal = table[NK_COLOR_SLIDER];
	slider->bar_hover = table[NK_COLOR_SLIDER];
	slider->bar_active = table[NK_COLOR_SLIDER];
	slider->bar_filled = table[NK_COLOR_SLIDER_CURSOR];
	slider->cursor_normal = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR]);
	slider->cursor_hover = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_HOVER]);
	slider->cursor_active = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_ACTIVE]);
	slider->inc_symbol = NK_SYMBOL_TRIANGLE_RIGHT;
	slider->dec_symbol = NK_SYMBOL_TRIANGLE_LEFT;
	slider->cursor_size = nk_vec2(16, 16);
	slider->padding = nk_vec2(2, 2);
	slider->spacing = nk_vec2(2, 2);
	slider->userdata = nk_handle_ptr(0);
	slider->show_buttons = nk_false;
	slider->bar_height = 8;
	slider->rounding = 0;
	slider->draw_begin = 0;
	slider->draw_end = 0;

	/* slider buttons */
	button = &style->slider.inc_button;
	button->normal = nk_style_item_color(nk_rgb(40, 40, 40));
	button->hover = nk_style_item_color(nk_rgb(42, 42, 42));
	button->active = nk_style_item_color(nk_rgb(44, 44, 44));
	button->border_color = nk_rgb(65, 65, 65);
	button->text_background = nk_rgb(40, 40, 40);
	button->text_normal = nk_rgb(175, 175, 175);
	button->text_hover = nk_rgb(175, 175, 175);
	button->text_active = nk_rgb(175, 175, 175);
	button->padding = nk_vec2(8.0f, 8.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 1.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;
	style->slider.dec_button = style->slider.inc_button;

	/* progressbar */
	prog = &style->progress;
	nk_zero_struct(*prog);
	prog->normal = nk_style_item_color(table[NK_COLOR_SLIDER]);
	prog->hover = nk_style_item_color(table[NK_COLOR_SLIDER]);
	prog->active = nk_style_item_color(table[NK_COLOR_SLIDER]);
	prog->cursor_normal = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR]);
	prog->cursor_hover = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_HOVER]);
	prog->cursor_active = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_ACTIVE]);
	prog->border_color = nk_rgba(0, 0, 0, 0);
	prog->cursor_border_color = nk_rgba(0, 0, 0, 0);
	prog->userdata = nk_handle_ptr(0);
	prog->padding = nk_vec2(4, 4);
	prog->rounding = 0;
	prog->border = 0;
	prog->cursor_rounding = 0;
	prog->cursor_border = 0;
	prog->draw_begin = 0;
	prog->draw_end = 0;

	/* scrollbars */
	scroll = &style->scrollh;
	nk_zero_struct(*scroll);
	scroll->normal = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
	scroll->hover = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
	scroll->active = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
	scroll->cursor_normal = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR]);
	scroll->cursor_hover = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR_HOVER]);
	scroll->cursor_active = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR_ACTIVE]);
	scroll->dec_symbol = NK_SYMBOL_CIRCLE_SOLID;
	scroll->inc_symbol = NK_SYMBOL_CIRCLE_SOLID;
	scroll->userdata = nk_handle_ptr(0);
	scroll->border_color = table[NK_COLOR_SCROLLBAR];
	scroll->cursor_border_color = table[NK_COLOR_SCROLLBAR];
	scroll->padding = nk_vec2(0, 0);
	scroll->show_buttons = nk_false;
	scroll->border = 0;
	scroll->rounding = 0;
	scroll->border_cursor = 0;
	scroll->rounding_cursor = 0;
	scroll->draw_begin = 0;
	scroll->draw_end = 0;
	style->scrollv = style->scrollh;

	/* scrollbars buttons */
	button = &style->scrollh.inc_button;
	button->normal = nk_style_item_color(nk_rgb(40, 40, 40));
	button->hover = nk_style_item_color(nk_rgb(42, 42, 42));
	button->active = nk_style_item_color(nk_rgb(44, 44, 44));
	button->border_color = nk_rgb(65, 65, 65);
	button->text_background = nk_rgb(40, 40, 40);
	button->text_normal = nk_rgb(175, 175, 175);
	button->text_hover = nk_rgb(175, 175, 175);
	button->text_active = nk_rgb(175, 175, 175);
	button->padding = nk_vec2(4.0f, 4.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 1.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;
	style->scrollh.dec_button = style->scrollh.inc_button;
	style->scrollv.inc_button = style->scrollh.inc_button;
	style->scrollv.dec_button = style->scrollh.inc_button;

	/* edit */
	edit = &style->edit;
	nk_zero_struct(*edit);
	edit->normal = nk_style_item_color(table[NK_COLOR_EDIT]);
	edit->hover = nk_style_item_color(table[NK_COLOR_EDIT]);
	edit->active = nk_style_item_color(table[NK_COLOR_EDIT]);
	edit->cursor_normal = table[NK_COLOR_TEXT];
	edit->cursor_hover = table[NK_COLOR_TEXT];
	edit->cursor_text_normal = table[NK_COLOR_EDIT];
	edit->cursor_text_hover = table[NK_COLOR_EDIT];
	edit->border_color = table[NK_COLOR_BORDER];
	edit->text_normal = table[NK_COLOR_TEXT];
	edit->text_hover = table[NK_COLOR_TEXT];
	edit->text_active = table[NK_COLOR_TEXT];
	edit->selected_normal = table[NK_COLOR_TEXT];
	edit->selected_hover = table[NK_COLOR_TEXT];
	edit->selected_text_normal = table[NK_COLOR_EDIT];
	edit->selected_text_hover = table[NK_COLOR_EDIT];
	edit->scrollbar_size = nk_vec2(10, 10);
	edit->scrollbar = style->scrollv;
	edit->padding = nk_vec2(4, 4);
	edit->row_padding = 2;
	edit->cursor_size = 4;
	edit->border = 1;
	edit->rounding = 0;

	/* property */
	property = &style->property;
	nk_zero_struct(*property);
	property->normal = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	property->hover = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	property->active = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	property->border_color = table[NK_COLOR_BORDER];
	property->label_normal = table[NK_COLOR_TEXT];
	property->label_hover = table[NK_COLOR_TEXT];
	property->label_active = table[NK_COLOR_TEXT];
	property->sym_left = NK_SYMBOL_TRIANGLE_LEFT;
	property->sym_right = NK_SYMBOL_TRIANGLE_RIGHT;
	property->userdata = nk_handle_ptr(0);
	property->padding = nk_vec2(4, 4);
	property->border = 1;
	property->rounding = 10;
	property->draw_begin = 0;
	property->draw_end = 0;

	/* property buttons */
	button = &style->property.dec_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	button->hover = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	button->active = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_PROPERTY];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(0.0f, 0.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;
	style->property.inc_button = style->property.dec_button;

	/* property edit */
	edit = &style->property.edit;
	nk_zero_struct(*edit);
	edit->normal = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	edit->hover = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	edit->active = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	edit->border_color = nk_rgba(0, 0, 0, 0);
	edit->cursor_normal = table[NK_COLOR_TEXT];
	edit->cursor_hover = table[NK_COLOR_TEXT];
	edit->cursor_text_normal = table[NK_COLOR_EDIT];
	edit->cursor_text_hover = table[NK_COLOR_EDIT];
	edit->text_normal = table[NK_COLOR_TEXT];
	edit->text_hover = table[NK_COLOR_TEXT];
	edit->text_active = table[NK_COLOR_TEXT];
	edit->selected_normal = table[NK_COLOR_TEXT];
	edit->selected_hover = table[NK_COLOR_TEXT];
	edit->selected_text_normal = table[NK_COLOR_EDIT];
	edit->selected_text_hover = table[NK_COLOR_EDIT];
	edit->padding = nk_vec2(0, 0);
	edit->cursor_size = 8;
	edit->border = 0;
	edit->rounding = 0;

	/* chart */
	chart = &style->chart;
	nk_zero_struct(*chart);
	chart->background = nk_style_item_color(table[NK_COLOR_CHART]);
	chart->border_color = table[NK_COLOR_BORDER];
	chart->selected_color = table[NK_COLOR_CHART_COLOR_HIGHLIGHT];
	chart->color = table[NK_COLOR_CHART_COLOR];
	chart->padding = nk_vec2(4, 4);
	chart->border = 0;
	chart->rounding = 0;

	/* combo */
	combo = &style->combo;
	combo->normal = nk_style_item_color(table[NK_COLOR_COMBO]);
	combo->hover = nk_style_item_color(table[NK_COLOR_COMBO]);
	combo->active = nk_style_item_color(table[NK_COLOR_COMBO]);
	combo->border_color = table[NK_COLOR_BORDER];
	combo->label_normal = table[NK_COLOR_TEXT];
	combo->label_hover = table[NK_COLOR_TEXT];
	combo->label_active = table[NK_COLOR_TEXT];
	combo->sym_normal = NK_SYMBOL_TRIANGLE_DOWN;
	combo->sym_hover = NK_SYMBOL_TRIANGLE_DOWN;
	combo->sym_active = NK_SYMBOL_TRIANGLE_DOWN;
	combo->content_padding = nk_vec2(4, 4);
	combo->button_padding = nk_vec2(0, 4);
	combo->spacing = nk_vec2(4, 0);
	combo->border = 1;
	combo->rounding = 0;

	/* combo button */
	button = &style->combo.button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_COMBO]);
	button->hover = nk_style_item_color(table[NK_COLOR_COMBO]);
	button->active = nk_style_item_color(table[NK_COLOR_COMBO]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_COMBO];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* tab */
	tab = &style->tab;
	tab->background = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
	tab->border_color = table[NK_COLOR_BORDER];
	tab->text = table[NK_COLOR_TEXT];
	tab->sym_minimize = NK_SYMBOL_TRIANGLE_RIGHT;
	tab->sym_maximize = NK_SYMBOL_TRIANGLE_DOWN;
	tab->padding = nk_vec2(4, 4);
	tab->spacing = nk_vec2(4, 4);
	tab->indent = 10.0f;
	tab->border = 1;
	tab->rounding = 0;

	/* tab button */
	button = &style->tab.tab_minimize_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
	button->hover = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
	button->active = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_TAB_HEADER];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;
	style->tab.tab_maximize_button = *button;

	/* node button */
	button = &style->tab.node_minimize_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->hover = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->active = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_TAB_HEADER];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;
	style->tab.node_maximize_button = *button;

	/* window header */
	win = &style->window;
	win->header.align = NK_HEADER_RIGHT;
	win->header.close_symbol = NK_SYMBOL_X;
	win->header.minimize_symbol = NK_SYMBOL_MINUS;
	win->header.maximize_symbol = NK_SYMBOL_PLUS;
	win->header.normal = nk_style_item_color(table[NK_COLOR_HEADER]);
	win->header.hover = nk_style_item_color(table[NK_COLOR_HEADER]);
	win->header.active = nk_style_item_color(table[NK_COLOR_HEADER]);
	win->header.label_normal = table[NK_COLOR_TEXT];
	win->header.label_hover = table[NK_COLOR_TEXT];
	win->header.label_active = table[NK_COLOR_TEXT];
	win->header.label_padding = nk_vec2(4, 4);
	win->header.padding = nk_vec2(4, 4);
	win->header.spacing = nk_vec2(0, 0);

	/* window header close button */
	button = &style->window.header.close_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->hover = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->active = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_HEADER];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(0.0f, 0.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* window header minimize button */
	button = &style->window.header.minimize_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->hover = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->active = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_HEADER];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(0.0f, 0.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* window */
	win->background = table[NK_COLOR_WINDOW];
	win->fixed_background = nk_style_item_color(table[NK_COLOR_WINDOW]);
	win->border_color = table[NK_COLOR_BORDER];
	win->popup_border_color = table[NK_COLOR_BORDER];
	win->combo_border_color = table[NK_COLOR_BORDER];
	win->contextual_border_color = table[NK_COLOR_BORDER];
	win->menu_border_color = table[NK_COLOR_BORDER];
	win->group_border_color = table[NK_COLOR_BORDER];
	win->tooltip_border_color = table[NK_COLOR_BORDER];
	win->scaler = nk_style_item_color(table[NK_COLOR_TEXT]);

	win->rounding = 0.0f;
	win->spacing = nk_vec2(4, 4);
	win->scrollbar_size = nk_vec2(10, 10);
	win->min_size = nk_vec2(64, 64);

	win->combo_border = 1.0f;
	win->contextual_border = 1.0f;
	win->menu_border = 1.0f;
	win->group_border = 1.0f;
	win->tooltip_border = 1.0f;
	win->popup_border = 1.0f;
	win->border = 2.0f;
	win->min_row_height_padding = 8;

	win->padding = nk_vec2(4, 4);
	win->group_padding = nk_vec2(4, 4);
	win->popup_padding = nk_vec2(4, 4);
	win->combo_padding = nk_vec2(4, 4);
	win->contextual_padding = nk_vec2(4, 4);
	win->menu_padding = nk_vec2(4, 4);
	win->tooltip_padding = nk_vec2(4, 4);
}

NK_API void nk_style_set_font(struct nk_context* ctx, const struct nk_user_font* font) {
	struct nk_style* style;
	NK_ASSERT(ctx);

	if (!ctx) return;
	style = &ctx->style;
	style->font = font;
	ctx->stacks.fonts.head = 0;
	if (ctx->current)
		nk_layout_reset_min_row_height(ctx);
}

NK_API int nk_style_push_font(struct nk_context* ctx, const struct nk_user_font* font) {
	struct nk_config_stack_user_font* font_stack;
	struct nk_config_stack_user_font_element* element;

	NK_ASSERT(ctx);
	if (!ctx) return 0;

	font_stack = &ctx->stacks.fonts;
	NK_ASSERT(font_stack->head < (int)NK_LEN(font_stack->elements));
	if (font_stack->head >= (int)NK_LEN(font_stack->elements))
		return 0;

	element = &font_stack->elements[font_stack->head++];
	element->address = &ctx->style.font;
	element->old_value = ctx->style.font;
	ctx->style.font = font;
	return 1;
}

NK_API int nk_style_pop_font(struct nk_context* ctx) {
	struct nk_config_stack_user_font* font_stack;
	struct nk_config_stack_user_font_element* element;

	NK_ASSERT(ctx);
	if (!ctx) return 0;

	font_stack = &ctx->stacks.fonts;
	NK_ASSERT(font_stack->head > 0);
	if (font_stack->head < 1)
		return 0;

	element = &font_stack->elements[--font_stack->head];
	*element->address = element->old_value;
	return 1;
}

#define NK_STYLE_PUSH_IMPLEMENATION(prefix, type, stack) \
nk_style_push_##type(struct nk_context *ctx, prefix##_##type *address, prefix##_##type value)\
{\
    struct nk_config_stack_##type * type_stack;\
    struct nk_config_stack_##type##_element *element;\
    NK_ASSERT(ctx);\
    if (!ctx) return 0;\
    type_stack = &ctx->stacks.stack;\
    NK_ASSERT(type_stack->head < (int)NK_LEN(type_stack->elements));\
    if (type_stack->head >= (int)NK_LEN(type_stack->elements))\
        return 0;\
    element = &type_stack->elements[type_stack->head++];\
    element->address = address;\
    element->old_value = *address;\
    *address = value;\
    return 1;\
}
#define NK_STYLE_POP_IMPLEMENATION(type, stack) \
nk_style_pop_##type(struct nk_context *ctx)\
{\
    struct nk_config_stack_##type *type_stack;\
    struct nk_config_stack_##type##_element *element;\
    NK_ASSERT(ctx);\
    if (!ctx) return 0;\
    type_stack = &ctx->stacks.stack;\
    NK_ASSERT(type_stack->head > 0);\
    if (type_stack->head < 1)\
        return 0;\
    element = &type_stack->elements[--type_stack->head];\
    *element->address = element->old_value;\
    return 1;\
}

NK_API int NK_STYLE_PUSH_IMPLEMENATION(struct nk, style_item, style_items)

NK_API int NK_STYLE_PUSH_IMPLEMENATION(nk, float, floats)

NK_API int NK_STYLE_PUSH_IMPLEMENATION(struct nk, vec2, vectors)

NK_API int NK_STYLE_PUSH_IMPLEMENATION(nk, flags, flags)

NK_API int NK_STYLE_PUSH_IMPLEMENATION(struct nk, color, colors)

NK_API int NK_STYLE_POP_IMPLEMENATION(style_item, style_items)

NK_API int NK_STYLE_POP_IMPLEMENATION(float, floats)

NK_API int NK_STYLE_POP_IMPLEMENATION(vec2, vectors)

NK_API int NK_STYLE_POP_IMPLEMENATION(flags, flags)

NK_API int NK_STYLE_POP_IMPLEMENATION(color, colors)

NK_API int nk_style_set_cursor(struct nk_context* ctx, enum nk_style_cursor c) {
	struct nk_style* style;
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	style = &ctx->style;
	if (style->cursors[c]) {
		style->cursor_active = style->cursors[c];
		return 1;
	}
	return 0;
}

NK_API void nk_style_show_cursor(struct nk_context* ctx) {
	ctx->style.cursor_visible = nk_true;
}

NK_API void nk_style_hide_cursor(struct nk_context* ctx) {
	ctx->style.cursor_visible = nk_false;
}

NK_API void nk_style_load_cursor(struct nk_context* ctx, enum nk_style_cursor cursor, const struct nk_cursor* c) {
	struct nk_style* style;
	NK_ASSERT(ctx);
	if (!ctx) return;
	style = &ctx->style;
	style->cursors[cursor] = c;
}

NK_API void nk_style_load_all_cursors(struct nk_context* ctx, struct nk_cursor* cursors) {
	int i = 0;
	struct nk_style* style;
	NK_ASSERT(ctx);
	if (!ctx) return;
	style = &ctx->style;
	for (i = 0; i < NK_CURSOR_COUNT; ++i)
		style->cursors[i] = &cursors[i];
	style->cursor_visible = nk_true;
}





/* ==============================================================
 *
 *                          CONTEXT
 *
 * ===============================================================*/
NK_INTERN void nk_setup(struct nk_context* ctx, const struct nk_user_font* font) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	nk_zero_struct(*ctx);
	nk_style_default(ctx);
	ctx->seq = 1;
	if (font) ctx->style.font = font;
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
	nk_draw_list_init(&ctx->draw_list);
#endif
}

#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

NK_API int nk_init_default(struct nk_context* ctx, const struct nk_user_font* font) {
	struct nk_allocator alloc;
	alloc.userdata.ptr = 0;
	alloc.alloc = nk_malloc;
	alloc.free = nk_mfree;
	return nk_init(ctx, &alloc, font);
}

#endif

NK_API int nk_init_fixed(struct nk_context* ctx, void* memory, nk_size size, const struct nk_user_font* font) {
	NK_ASSERT(memory);
	if (!memory) return 0;
	nk_setup(ctx, font);
	nk_buffer_init_fixed(&ctx->memory, memory, size);
	ctx->use_pool = nk_false;
	return 1;
}

NK_API int nk_init_custom(struct nk_context* ctx, struct nk_buffer* cmds, struct nk_buffer* pool,
	const struct nk_user_font* font) {
	NK_ASSERT(cmds);
	NK_ASSERT(pool);
	if (!cmds || !pool) return 0;

	nk_setup(ctx, font);
	ctx->memory = *cmds;
	if (pool->type == NK_BUFFER_FIXED) {
		/* take memory from buffer and alloc fixed pool */
		nk_pool_init_fixed(&ctx->pool, pool->memory.ptr, pool->memory.size);
	}
	else {
		/* create dynamic pool from buffer allocator */
		struct nk_allocator* alloc = &pool->pool;
		nk_pool_init(&ctx->pool, alloc, NK_POOL_DEFAULT_CAPACITY);
	}
	ctx->use_pool = nk_true;
	return 1;
}

NK_API int nk_init(struct nk_context* ctx, struct nk_allocator* alloc, const struct nk_user_font* font) {
	NK_ASSERT(alloc);
	if (!alloc) return 0;
	nk_setup(ctx, font);
	nk_buffer_init(&ctx->memory, alloc, NK_DEFAULT_COMMAND_BUFFER_SIZE);
	nk_pool_init(&ctx->pool, alloc, NK_POOL_DEFAULT_CAPACITY);
	ctx->use_pool = nk_true;
	return 1;
}

#ifdef NK_INCLUDE_COMMAND_USERDATA
NK_API void
nk_set_user_data(struct nk_context* ctx, nk_handle handle)
{
	if (!ctx) return;
	ctx->userdata = handle;
	if (ctx->current)
		ctx->current->buffer.userdata = handle;
}
#endif

NK_API void nk_free(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	nk_buffer_free(&ctx->memory);
	if (ctx->use_pool)
		nk_pool_free(&ctx->pool);

	nk_zero(&ctx->input, sizeof(ctx->input));
	nk_zero(&ctx->style, sizeof(ctx->style));
	nk_zero(&ctx->memory, sizeof(ctx->memory));

	ctx->seq = 0;
	ctx->build = 0;
	ctx->begin = 0;
	ctx->end = 0;
	ctx->active = 0;
	ctx->current = 0;
	ctx->freelist = 0;
	ctx->count = 0;
}

NK_API void nk_clear(struct nk_context* ctx) {
	struct nk_window* iter;
	struct nk_window* next;
	NK_ASSERT(ctx);

	if (!ctx) return;
	if (ctx->use_pool)
		nk_buffer_clear(&ctx->memory);
	else nk_buffer_reset(&ctx->memory, NK_BUFFER_FRONT);

	ctx->build = 0;
	ctx->memory.calls = 0;
	ctx->last_widget_state = 0;
	ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_ARROW];
	NK_MEMSET(&ctx->overlay, 0, sizeof(ctx->overlay));

	/* garbage collector */
	iter = ctx->begin;
	while (iter) {
		/* make sure valid minimized windows do not get removed */
		if ((iter->flags & NK_WINDOW_MINIMIZED) && !(iter->flags & NK_WINDOW_CLOSED) && iter->seq == ctx->seq) {
			iter = iter->next;
			continue;
		}
		/* remove hotness from hidden or closed windows*/
		if (((iter->flags & NK_WINDOW_HIDDEN) || (iter->flags & NK_WINDOW_CLOSED)) && iter == ctx->active) {
			ctx->active = iter->prev;
			ctx->end = iter->prev;
			if (!ctx->end)
				ctx->begin = 0;
			if (ctx->active)
				ctx->active->flags &= ~(unsigned)NK_WINDOW_ROM;
		}
		/* free unused popup windows */
		if (iter->popup.win && iter->popup.win->seq != ctx->seq) {
			nk_free_window(ctx, iter->popup.win);
			iter->popup.win = 0;
		}
		/* remove unused window state tables */
		{
			struct nk_table* n, * it = iter->tables;
			while (it) {
				n = it->next;
				if (it->seq != ctx->seq) {
					nk_remove_table(iter, it);
					nk_zero(it, sizeof(union nk_page_data));
					nk_free_table(ctx, it);
					if (it == iter->tables)
						iter->tables = n;
				}
				it = n;
			}
		}
		/* window itself is not used anymore so free */
		if (iter->seq != ctx->seq || iter->flags & NK_WINDOW_CLOSED) {
			next = iter->next;
			nk_remove_window(ctx, iter);
			nk_free_window(ctx, iter);
			iter = next;
		}
		else iter = iter->next;
	}
	ctx->seq++;
}

NK_LIB void nk_start_buffer(struct nk_context* ctx, struct nk_command_buffer* buffer) {
	NK_ASSERT(ctx);
	NK_ASSERT(buffer);
	if (!ctx || !buffer) return;
	buffer->begin = ctx->memory.allocated;
	buffer->end = buffer->begin;
	buffer->last = buffer->begin;
	buffer->clip = nk_null_rect;
}

NK_LIB void nk_start(struct nk_context* ctx, struct nk_window* win) {
	NK_ASSERT(ctx);
	NK_ASSERT(win);
	nk_start_buffer(ctx, &win->buffer);
}

NK_LIB void nk_start_popup(struct nk_context* ctx, struct nk_window* win) {
	struct nk_popup_buffer* buf;
	NK_ASSERT(ctx);
	NK_ASSERT(win);
	if (!ctx || !win) return;

	/* save buffer fill state for popup */
	buf = &win->popup.buf;
	buf->begin = win->buffer.end;
	buf->end = win->buffer.end;
	buf->parent = win->buffer.last;
	buf->last = buf->begin;
	buf->active = nk_true;
}

NK_LIB void nk_finish_popup(struct nk_context* ctx, struct nk_window* win) {
	struct nk_popup_buffer* buf;
	NK_ASSERT(ctx);
	NK_ASSERT(win);
	if (!ctx || !win) return;

	buf = &win->popup.buf;
	buf->last = win->buffer.last;
	buf->end = win->buffer.end;
}

NK_LIB void nk_finish_buffer(struct nk_context* ctx, struct nk_command_buffer* buffer) {
	NK_ASSERT(ctx);
	NK_ASSERT(buffer);
	if (!ctx || !buffer) return;
	buffer->end = ctx->memory.allocated;
}

NK_LIB void nk_finish(struct nk_context* ctx, struct nk_window* win) {
	struct nk_popup_buffer* buf;
	struct nk_command* parent_last;
	void* memory;

	NK_ASSERT(ctx);
	NK_ASSERT(win);
	if (!ctx || !win) return;
	nk_finish_buffer(ctx, &win->buffer);
	if (!win->popup.buf.active) return;

	buf = &win->popup.buf;
	memory = ctx->memory.memory.ptr;
	parent_last = nk_ptr_add(struct nk_command, memory, buf->parent);
	parent_last->next = buf->end;
}

NK_LIB void nk_build(struct nk_context* ctx) {
	struct nk_window* it = 0;
	struct nk_command* cmd = 0;
	nk_byte* buffer = 0;

	/* draw cursor overlay */
	if (!ctx->style.cursor_active)
		ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_ARROW];
	if (ctx->style.cursor_active && !ctx->input.mouse.grabbed && ctx->style.cursor_visible) {
		struct nk_rect mouse_bounds;
		const struct nk_cursor* cursor = ctx->style.cursor_active;
		nk_command_buffer_init(&ctx->overlay, &ctx->memory, NK_CLIPPING_OFF);
		nk_start_buffer(ctx, &ctx->overlay);

		mouse_bounds.x = ctx->input.mouse.pos.x - cursor->offset.x;
		mouse_bounds.y = ctx->input.mouse.pos.y - cursor->offset.y;
		mouse_bounds.w = cursor->size.x;
		mouse_bounds.h = cursor->size.y;

		nk_draw_image(&ctx->overlay, mouse_bounds, &cursor->img, nk_white);
		nk_finish_buffer(ctx, &ctx->overlay);
	}
	/* build one big draw command list out of all window buffers */
	it = ctx->begin;
	buffer = (nk_byte*)ctx->memory.memory.ptr;
	while (it != 0) {
		struct nk_window* next = it->next;
		if (it->buffer.last == it->buffer.begin || (it->flags & NK_WINDOW_HIDDEN) || it->seq != ctx->seq)
			goto cont;

		cmd = nk_ptr_add(struct nk_command, buffer, it->buffer.last);
		while (next &&
			((next->buffer.last == next->buffer.begin) || (next->flags & NK_WINDOW_HIDDEN) || next->seq != ctx->seq))
			next = next->next; /* skip empty command buffers */

		if (next) cmd->next = next->buffer.begin;
	cont:
		it = next;
	}
	/* append all popup draw commands into lists */
	it = ctx->begin;
	while (it != 0) {
		struct nk_window* next = it->next;
		struct nk_popup_buffer* buf;
		if (!it->popup.buf.active)
			goto skip;

		buf = &it->popup.buf;
		cmd->next = buf->begin;
		cmd = nk_ptr_add(struct nk_command, buffer, buf->last);
		buf->active = nk_false;
	skip:
		it = next;
	}
	if (cmd) {
		/* append overlay commands */
		if (ctx->overlay.end != ctx->overlay.begin)
			cmd->next = ctx->overlay.begin;
		else cmd->next = ctx->memory.allocated;
	}
}

NK_API const struct nk_command* nk__begin(struct nk_context* ctx) {
	struct nk_window* iter;
	nk_byte* buffer;
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	if (!ctx->count) return 0;

	buffer = (nk_byte*)ctx->memory.memory.ptr;
	if (!ctx->build) {
		nk_build(ctx);
		ctx->build = nk_true;
	}
	iter = ctx->begin;
	while (iter &&
		((iter->buffer.begin == iter->buffer.end) || (iter->flags & NK_WINDOW_HIDDEN) || iter->seq != ctx->seq))
		iter = iter->next;
	if (!iter) return 0;
	return nk_ptr_add_const(struct nk_command, buffer, iter->buffer.begin);
}

NK_API const struct nk_command* nk__next(struct nk_context* ctx, const struct nk_command* cmd) {
	nk_byte* buffer;
	const struct nk_command* next;
	NK_ASSERT(ctx);
	if (!ctx || !cmd || !ctx->count) return 0;
	if (cmd->next >= ctx->memory.allocated) return 0;
	buffer = (nk_byte*)ctx->memory.memory.ptr;
	next = nk_ptr_add_const(struct nk_command, buffer, cmd->next);
	return next;
}






/* ===============================================================
 *
 *                              POOL
 *
 * ===============================================================*/
NK_LIB void nk_pool_init(struct nk_pool* pool, struct nk_allocator* alloc, unsigned int capacity) {
	nk_zero(pool, sizeof(*pool));
	pool->alloc = *alloc;
	pool->capacity = capacity;
	pool->type = NK_BUFFER_DYNAMIC;
	pool->pages = 0;
}

NK_LIB void nk_pool_free(struct nk_pool* pool) {
	struct nk_page* iter = pool->pages;
	if (!pool) return;
	if (pool->type == NK_BUFFER_FIXED) return;
	while (iter) {
		struct nk_page* next = iter->next;
		pool->alloc.free(pool->alloc.userdata, iter);
		iter = next;
	}
}

NK_LIB void nk_pool_init_fixed(struct nk_pool* pool, void* memory, nk_size size) {
	nk_zero(pool, sizeof(*pool));
	NK_ASSERT(size >= sizeof(struct nk_page));
	if (size < sizeof(struct nk_page)) return;
	pool->capacity = (unsigned)(size - sizeof(struct nk_page)) / sizeof(struct nk_page_element);
	pool->pages = (struct nk_page*) memory;
	pool->type = NK_BUFFER_FIXED;
	pool->size = size;
}

NK_LIB struct nk_page_element* nk_pool_alloc(struct nk_pool* pool) {
	if (!pool->pages || pool->pages->size >= pool->capacity) {
		/* allocate new page */
		struct nk_page* page;
		if (pool->type == NK_BUFFER_FIXED) {
			NK_ASSERT(pool->pages);
			if (!pool->pages) return 0;
			NK_ASSERT(pool->pages->size < pool->capacity);
			return 0;
		}
		else {
			nk_size size = sizeof(struct nk_page);
			size += NK_POOL_DEFAULT_CAPACITY * sizeof(union nk_page_data);
			page = (struct nk_page*) pool->alloc.alloc(pool->alloc.userdata, 0, size);
			page->next = pool->pages;
			pool->pages = page;
			page->size = 0;
		}
	}
	return &pool->pages->win[pool->pages->size++];
}





/* ===============================================================
 *
 *                          PAGE ELEMENT
 *
 * ===============================================================*/
NK_LIB struct nk_page_element* nk_create_page_element(struct nk_context* ctx) {
	struct nk_page_element* elem;
	if (ctx->freelist) {
		/* unlink page element from free list */
		elem = ctx->freelist;
		ctx->freelist = elem->next;
	}
	else if (ctx->use_pool) {
		/* allocate page element from memory pool */
		elem = nk_pool_alloc(&ctx->pool);
		NK_ASSERT(elem);
		if (!elem) return 0;
	}
	else {
		/* allocate new page element from back of fixed size memory buffer */
		NK_STORAGE const nk_size size = sizeof(struct nk_page_element);
		NK_STORAGE const nk_size align = NK_ALIGNOF(struct nk_page_element);
		elem = (struct nk_page_element*) nk_buffer_alloc(&ctx->memory, NK_BUFFER_BACK, size, align);
		NK_ASSERT(elem);
		if (!elem) return 0;
	}
	nk_zero_struct(*elem);
	elem->next = 0;
	elem->prev = 0;
	return elem;
}

NK_LIB void nk_link_page_element_into_freelist(struct nk_context* ctx, struct nk_page_element* elem) {
	/* link table into freelist */
	if (!ctx->freelist) {
		ctx->freelist = elem;
	}
	else {
		elem->next = ctx->freelist;
		ctx->freelist = elem;
	}
}

NK_LIB void nk_free_page_element(struct nk_context* ctx, struct nk_page_element* elem) {
	/* we have a pool so just add to free list */
	if (ctx->use_pool) {
		nk_link_page_element_into_freelist(ctx, elem);
		return;
	}
	/* if possible remove last element from back of fixed memory buffer */
	{
		void* elem_end = (void*)(elem + 1);
		void* buffer_end = (nk_byte*)ctx->memory.memory.ptr + ctx->memory.size;
		if (elem_end == buffer_end)
			ctx->memory.size -= sizeof(struct nk_page_element);
		else nk_link_page_element_into_freelist(ctx, elem);
	}
}





/* ===============================================================
 *
 *                              TABLE
 *
 * ===============================================================*/
NK_LIB struct nk_table* nk_create_table(struct nk_context* ctx) {
	struct nk_page_element* elem;
	elem = nk_create_page_element(ctx);
	if (!elem) return 0;
	nk_zero_struct(*elem);
	return &elem->data.tbl;
}

NK_LIB void nk_free_table(struct nk_context* ctx, struct nk_table* tbl) {
	union nk_page_data* pd = NK_CONTAINER_OF(tbl, union nk_page_data, tbl);
	struct nk_page_element* pe = NK_CONTAINER_OF(pd, struct nk_page_element, data);
	nk_free_page_element(ctx, pe);
}

NK_LIB void nk_push_table(struct nk_window* win, struct nk_table* tbl) {
	if (!win->tables) {
		win->tables = tbl;
		tbl->next = 0;
		tbl->prev = 0;
		tbl->size = 0;
		win->table_count = 1;
		return;
	}
	win->tables->prev = tbl;
	tbl->next = win->tables;
	tbl->prev = 0;
	tbl->size = 0;
	win->tables = tbl;
	win->table_count++;
}

NK_LIB void nk_remove_table(struct nk_window* win, struct nk_table* tbl) {
	if (win->tables == tbl)
		win->tables = tbl->next;
	if (tbl->next)
		tbl->next->prev = tbl->prev;
	if (tbl->prev)
		tbl->prev->next = tbl->next;
	tbl->next = 0;
	tbl->prev = 0;
}

NK_LIB nk_uint* nk_add_value(struct nk_context* ctx, struct nk_window* win, nk_hash name, nk_uint value) {
	NK_ASSERT(ctx);
	NK_ASSERT(win);
	if (!win || !ctx) return 0;
	if (!win->tables || win->tables->size >= NK_VALUE_PAGE_CAPACITY) {
		struct nk_table* tbl = nk_create_table(ctx);
		NK_ASSERT(tbl);
		if (!tbl) return 0;
		nk_push_table(win, tbl);
	}
	win->tables->seq = win->seq;
	win->tables->keys[win->tables->size] = name;
	win->tables->values[win->tables->size] = value;
	return &win->tables->values[win->tables->size++];
}

NK_LIB nk_uint* nk_find_value(struct nk_window* win, nk_hash name) {
	struct nk_table* iter = win->tables;
	while (iter) {
		unsigned int i = 0;
		unsigned int size = iter->size;
		for (i = 0; i < size; ++i) {
			if (iter->keys[i] == name) {
				iter->seq = win->seq;
				return &iter->values[i];
			}
		}
		size = NK_VALUE_PAGE_CAPACITY;
		iter = iter->next;
	}
	return 0;
}





/* ===============================================================
 *
 *                              PANEL
 *
 * ===============================================================*/
NK_LIB void* nk_create_panel(struct nk_context* ctx) {
	struct nk_page_element* elem;
	elem = nk_create_page_element(ctx);
	if (!elem) return 0;
	nk_zero_struct(*elem);
	return &elem->data.pan;
}

NK_LIB void nk_free_panel(struct nk_context* ctx, struct nk_panel* pan) {
	union nk_page_data* pd = NK_CONTAINER_OF(pan, union nk_page_data, pan);
	struct nk_page_element* pe = NK_CONTAINER_OF(pd, struct nk_page_element, data);
	nk_free_page_element(ctx, pe);
}

NK_LIB int nk_panel_has_header(nk_flags flags, const char* title) {
	int active = 0;
	active = (flags & (NK_WINDOW_CLOSABLE | NK_WINDOW_MINIMIZABLE));
	active = active || (flags & NK_WINDOW_TITLE);
	active = active && !(flags & NK_WINDOW_HIDDEN) && title;
	return active;
}

NK_LIB struct nk_vec2 nk_panel_get_padding(const struct nk_style* style, enum nk_panel_type type) {
	switch (type) {
	default:
	case NK_PANEL_WINDOW:
		return style->window.padding;
	case NK_PANEL_GROUP:
		return style->window.group_padding;
	case NK_PANEL_POPUP:
		return style->window.popup_padding;
	case NK_PANEL_CONTEXTUAL:
		return style->window.contextual_padding;
	case NK_PANEL_COMBO:
		return style->window.combo_padding;
	case NK_PANEL_MENU:
		return style->window.menu_padding;
	case NK_PANEL_TOOLTIP:
		return style->window.menu_padding;
	}
}

NK_LIB float nk_panel_get_border(const struct nk_style* style, nk_flags flags, enum nk_panel_type type) {
	if (flags & NK_WINDOW_BORDER) {
		switch (type) {
		default:
		case NK_PANEL_WINDOW:
			return style->window.border;
		case NK_PANEL_GROUP:
			return style->window.group_border;
		case NK_PANEL_POPUP:
			return style->window.popup_border;
		case NK_PANEL_CONTEXTUAL:
			return style->window.contextual_border;
		case NK_PANEL_COMBO:
			return style->window.combo_border;
		case NK_PANEL_MENU:
			return style->window.menu_border;
		case NK_PANEL_TOOLTIP:
			return style->window.menu_border;
		}
	}
	else return 0;
}

NK_LIB struct nk_color nk_panel_get_border_color(const struct nk_style* style, enum nk_panel_type type) {
	switch (type) {
	default:
	case NK_PANEL_WINDOW:
		return style->window.border_color;
	case NK_PANEL_GROUP:
		return style->window.group_border_color;
	case NK_PANEL_POPUP:
		return style->window.popup_border_color;
	case NK_PANEL_CONTEXTUAL:
		return style->window.contextual_border_color;
	case NK_PANEL_COMBO:
		return style->window.combo_border_color;
	case NK_PANEL_MENU:
		return style->window.menu_border_color;
	case NK_PANEL_TOOLTIP:
		return style->window.menu_border_color;
	}
}

NK_LIB int nk_panel_is_sub(enum nk_panel_type type) {
	return (type & NK_PANEL_SET_SUB) ? 1 : 0;
}

NK_LIB int nk_panel_is_nonblock(enum nk_panel_type type) {
	return (type & NK_PANEL_SET_NONBLOCK) ? 1 : 0;
}

NK_LIB int nk_panel_begin(struct nk_context* ctx, const char* title, enum nk_panel_type panel_type) {
	struct nk_input* in;
	struct nk_window* win;
	struct nk_panel* layout;
	struct nk_command_buffer* out;
	const struct nk_style* style;
	const struct nk_user_font* font;

	struct nk_vec2 scrollbar_size;
	struct nk_vec2 panel_padding;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return 0;
	nk_zero(ctx->current->layout, sizeof(*ctx->current->layout));
	if ((ctx->current->flags & NK_WINDOW_HIDDEN) || (ctx->current->flags & NK_WINDOW_CLOSED)) {
		nk_zero(ctx->current->layout, sizeof(struct nk_panel));
		ctx->current->layout->type = panel_type;
		return 0;
	}
	/* pull state into local stack */
	style = &ctx->style;
	font = style->font;
	win = ctx->current;
	layout = win->layout;
	out = &win->buffer;
	in = (win->flags & NK_WINDOW_NO_INPUT) ? 0 : &ctx->input;
#ifdef NK_INCLUDE_COMMAND_USERDATA
	win->buffer.userdata = ctx->userdata;
#endif
	/* pull style configuration into local stack */
	scrollbar_size = style->window.scrollbar_size;
	panel_padding = nk_panel_get_padding(style, panel_type);

	/* window movement */
	if ((win->flags & NK_WINDOW_MOVABLE) && !(win->flags & NK_WINDOW_ROM)) {
		int left_mouse_down;
		int left_mouse_clicked;
		int left_mouse_click_in_cursor;

		/* calculate draggable window space */
		struct nk_rect header;
		header.x = win->bounds.x;
		header.y = win->bounds.y;
		header.w = win->bounds.w;
		if (nk_panel_has_header(win->flags, title)) {
			header.h = font->height + 2.0f * style->window.header.padding.y;
			header.h += 2.0f * style->window.header.label_padding.y;
		}
		else header.h = panel_padding.y;

		/* window movement by dragging */
		left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
		left_mouse_clicked = (int)in->mouse.buttons[NK_BUTTON_LEFT].clicked;
		left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, header, nk_true);
		if (left_mouse_down && left_mouse_click_in_cursor && !left_mouse_clicked) {
			win->bounds.x = win->bounds.x + in->mouse.delta.x;
			win->bounds.y = win->bounds.y + in->mouse.delta.y;
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x += in->mouse.delta.x;
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y += in->mouse.delta.y;
			ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_MOVE];
		}
	}

	/* setup panel */
	layout->type = panel_type;
	layout->flags = win->flags;
	layout->bounds = win->bounds;
	layout->bounds.x += panel_padding.x;
	layout->bounds.w -= 2 * panel_padding.x;
	if (win->flags & NK_WINDOW_BORDER) {
		layout->border = nk_panel_get_border(style, win->flags, panel_type);
		layout->bounds = nk_shrink_rect(layout->bounds, layout->border);
	}
	else layout->border = 0;
	layout->at_y = layout->bounds.y;
	layout->at_x = layout->bounds.x;
	layout->max_x = 0;
	layout->header_height = 0;
	layout->footer_height = 0;
	nk_layout_reset_min_row_height(ctx);
	layout->row.index = 0;
	layout->row.columns = 0;
	layout->row.ratio = 0;
	layout->row.item_width = 0;
	layout->row.tree_depth = 0;
	layout->row.height = panel_padding.y;
	layout->has_scrolling = nk_true;
	if (!(win->flags & NK_WINDOW_NO_SCROLLBAR))
		layout->bounds.w -= scrollbar_size.x;
	if (!nk_panel_is_nonblock(panel_type)) {
		layout->footer_height = 0;
		if (!(win->flags & NK_WINDOW_NO_SCROLLBAR) || win->flags & NK_WINDOW_SCALABLE)
			layout->footer_height = scrollbar_size.y;
		layout->bounds.h -= layout->footer_height;
	}

	/* panel header */
	if (nk_panel_has_header(win->flags, title)) {
		struct nk_text text;
		struct nk_rect header;
		const struct nk_style_item* background = 0;

		/* calculate header bounds */
		header.x = win->bounds.x;
		header.y = win->bounds.y;
		header.w = win->bounds.w;
		header.h = font->height + 2.0f * style->window.header.padding.y;
		header.h += (2.0f * style->window.header.label_padding.y);

		/* shrink panel by header */
		layout->header_height = header.h;
		layout->bounds.y += header.h;
		layout->bounds.h -= header.h;
		layout->at_y += header.h;

		/* select correct header background and text color */
		if (ctx->active == win) {
			background = &style->window.header.active;
			text.text = style->window.header.label_active;
		}
		else if (nk_input_is_mouse_hovering_rect(&ctx->input, header)) {
			background = &style->window.header.hover;
			text.text = style->window.header.label_hover;
		}
		else {
			background = &style->window.header.normal;
			text.text = style->window.header.label_normal;
		}

		/* draw header background */
		header.h += 1.0f;
		if (background->type == NK_STYLE_ITEM_IMAGE) {
			text.background = nk_rgba(0, 0, 0, 0);
			nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
		}
		else {
			text.background = background->data.color;
			nk_fill_rect(out, header, 0, background->data.color);
		}

		/* window close button */
		{
			struct nk_rect button;
			button.y = header.y + style->window.header.padding.y;
			button.h = header.h - 2 * style->window.header.padding.y;
			button.w = button.h;
			if (win->flags & NK_WINDOW_CLOSABLE) {
				nk_flags ws = 0;
				if (style->window.header.align == NK_HEADER_RIGHT) {
					button.x = (header.w + header.x) - (button.w + style->window.header.padding.x);
					header.w -= button.w + style->window.header.spacing.x + style->window.header.padding.x;
				}
				else {
					button.x = header.x + style->window.header.padding.x;
					header.x += button.w + style->window.header.spacing.x + style->window.header.padding.x;
				}

				if (nk_do_button_symbol(&ws, &win->buffer, button, style->window.header.close_symbol, NK_BUTTON_DEFAULT,
					&style->window.header.close_button, in, style->font) &&
					!(win->flags & NK_WINDOW_ROM)) {
					layout->flags |= NK_WINDOW_HIDDEN;
					layout->flags &= (nk_flags)~NK_WINDOW_MINIMIZED;
				}
			}

			/* window minimize button */
			if (win->flags & NK_WINDOW_MINIMIZABLE) {
				nk_flags ws = 0;
				if (style->window.header.align == NK_HEADER_RIGHT) {
					button.x = (header.w + header.x) - button.w;
					if (!(win->flags & NK_WINDOW_CLOSABLE)) {
						button.x -= style->window.header.padding.x;
						header.w -= style->window.header.padding.x;
					}
					header.w -= button.w + style->window.header.spacing.x;
				}
				else {
					button.x = header.x;
					header.x += button.w + style->window.header.spacing.x + style->window.header.padding.x;
				}
				if (nk_do_button_symbol(&ws, &win->buffer, button,
					(layout->flags & NK_WINDOW_MINIMIZED) ? style->window.header.maximize_symbol
					: style->window.header.minimize_symbol,
					NK_BUTTON_DEFAULT, &style->window.header.minimize_button, in, style->font) &&
					!(win->flags & NK_WINDOW_ROM))
					layout->flags = (layout->flags & NK_WINDOW_MINIMIZED) ? layout->flags &
					(nk_flags)~NK_WINDOW_MINIMIZED :
					layout->flags | NK_WINDOW_MINIMIZED;
			}
		}

		{/* window header title */
			int text_len = nk_strlen(title);
			struct nk_rect label = { 0, 0, 0, 0 };
			float t = font->width(font->userdata, font->height, title, text_len);
			text.padding = nk_vec2(0, 0);

			label.x = header.x + style->window.header.padding.x;
			label.x += style->window.header.label_padding.x;
			label.y = header.y + style->window.header.label_padding.y;
			label.h = font->height + 2 * style->window.header.label_padding.y;
			label.w = t + 2 * style->window.header.spacing.x;
			label.w = NK_CLAMP(0, label.w, header.x + header.w - label.x);
			nk_widget_text(out, label, (const char*)title, text_len, &text, NK_TEXT_LEFT, font);
		}
	}

	/* draw window background */
	if (!(layout->flags & NK_WINDOW_MINIMIZED) && !(layout->flags & NK_WINDOW_DYNAMIC)) {
		struct nk_rect body;
		body.x = win->bounds.x;
		body.w = win->bounds.w;
		body.y = (win->bounds.y + layout->header_height);
		body.h = (win->bounds.h - layout->header_height);
		if (style->window.fixed_background.type == NK_STYLE_ITEM_IMAGE)
			nk_draw_image(out, body, &style->window.fixed_background.data.image, nk_white);
		else nk_fill_rect(out, body, 0, style->window.fixed_background.data.color);
	}

	/* set clipping rectangle */
	{
		struct nk_rect clip;
		layout->clip = layout->bounds;
		nk_unify(&clip, &win->buffer.clip, layout->clip.x, layout->clip.y, layout->clip.x + layout->clip.w,
			layout->clip.y + layout->clip.h);
		nk_push_scissor(out, clip);
		layout->clip = clip;
	}
	return !(layout->flags & NK_WINDOW_HIDDEN) && !(layout->flags & NK_WINDOW_MINIMIZED);
}

NK_LIB void nk_panel_end(struct nk_context* ctx) {
	struct nk_input* in;
	struct nk_window* window;
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_command_buffer* out;

	struct nk_vec2 scrollbar_size;
	struct nk_vec2 panel_padding;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	window = ctx->current;
	layout = window->layout;
	style = &ctx->style;
	out = &window->buffer;
	in = (layout->flags & NK_WINDOW_ROM || layout->flags & NK_WINDOW_NO_INPUT) ? 0 : &ctx->input;
	if (!nk_panel_is_sub(layout->type))
		nk_push_scissor(out, nk_null_rect);

	/* cache configuration data */
	scrollbar_size = style->window.scrollbar_size;
	panel_padding = nk_panel_get_padding(style, layout->type);

	/* update the current cursor Y-position to point over the last added widget */
	layout->at_y += layout->row.height;

	/* dynamic panels */
	if (layout->flags & NK_WINDOW_DYNAMIC && !(layout->flags & NK_WINDOW_MINIMIZED)) {
		/* update panel height to fit dynamic growth */
		struct nk_rect empty_space;
		if (layout->at_y < (layout->bounds.y + layout->bounds.h))
			layout->bounds.h = layout->at_y - layout->bounds.y;

		/* fill top empty space */
		empty_space.x = window->bounds.x;
		empty_space.y = layout->bounds.y;
		empty_space.h = panel_padding.y;
		empty_space.w = window->bounds.w;
		nk_fill_rect(out, empty_space, 0, style->window.background);

		/* fill left empty space */
		empty_space.x = window->bounds.x;
		empty_space.y = layout->bounds.y;
		empty_space.w = panel_padding.x + layout->border;
		empty_space.h = layout->bounds.h;
		nk_fill_rect(out, empty_space, 0, style->window.background);

		/* fill right empty space */
		empty_space.x = layout->bounds.x + layout->bounds.w - layout->border;
		empty_space.y = layout->bounds.y;
		empty_space.w = panel_padding.x + layout->border;
		empty_space.h = layout->bounds.h;
		if (*layout->offset_y == 0 && !(layout->flags & NK_WINDOW_NO_SCROLLBAR))
			empty_space.w += scrollbar_size.x;
		nk_fill_rect(out, empty_space, 0, style->window.background);

		/* fill bottom empty space */
		if (layout->footer_height > 0) {
			empty_space.x = window->bounds.x;
			empty_space.y = layout->bounds.y + layout->bounds.h;
			empty_space.w = window->bounds.w;
			empty_space.h = layout->footer_height;
			nk_fill_rect(out, empty_space, 0, style->window.background);
		}
	}

	/* scrollbars */
	if (!(layout->flags & NK_WINDOW_NO_SCROLLBAR) && !(layout->flags & NK_WINDOW_MINIMIZED) &&
		window->scrollbar_hiding_timer < NK_SCROLLBAR_HIDING_TIMEOUT) {
		struct nk_rect scroll;
		int scroll_has_scrolling;
		float scroll_target;
		float scroll_offset;
		float scroll_step;
		float scroll_inc;

		/* mouse wheel scrolling */
		if (nk_panel_is_sub(layout->type)) {
			/* sub-window mouse wheel scrolling */
			struct nk_window* root_window = window;
			struct nk_panel* root_panel = window->layout;
			while (root_panel->parent)
				root_panel = root_panel->parent;
			while (root_window->parent)
				root_window = root_window->parent;

			/* only allow scrolling if parent window is active */
			scroll_has_scrolling = 0;
			if ((root_window == ctx->active) && layout->has_scrolling) {
				/* and panel is being hovered and inside clip rect*/
				if (nk_input_is_mouse_hovering_rect(in, layout->bounds) &&
					NK_INTERSECT(layout->bounds.x, layout->bounds.y, layout->bounds.w, layout->bounds.h,
						root_panel->clip.x, root_panel->clip.y, root_panel->clip.w, root_panel->clip.h)) {
					/* deactivate all parent scrolling */
					root_panel = window->layout;
					while (root_panel->parent) {
						root_panel->has_scrolling = nk_false;
						root_panel = root_panel->parent;
					}
					root_panel->has_scrolling = nk_false;
					scroll_has_scrolling = nk_true;
				}
			}
		}
		else if (!nk_panel_is_sub(layout->type)) {
			/* window mouse wheel scrolling */
			scroll_has_scrolling = (window == ctx->active) && layout->has_scrolling;
			if (in && (in->mouse.scroll_delta.y > 0 || in->mouse.scroll_delta.x > 0) && scroll_has_scrolling)
				window->scrolled = nk_true;
			else window->scrolled = nk_false;
		}
		else scroll_has_scrolling = nk_false;

		{
			/* vertical scrollbar */
			nk_flags state = 0;
			scroll.x = layout->bounds.x + layout->bounds.w + panel_padding.x;
			scroll.y = layout->bounds.y;
			scroll.w = scrollbar_size.x;
			scroll.h = layout->bounds.h;

			scroll_offset = (float)*layout->offset_y;
			scroll_step = scroll.h * 0.10f;
			scroll_inc = scroll.h * 0.01f;
			scroll_target = (float)(int)(layout->at_y - scroll.y);
			scroll_offset = nk_do_scrollbarv(&state, out, scroll, scroll_has_scrolling, scroll_offset, scroll_target,
				scroll_step, scroll_inc, &ctx->style.scrollv, in, style->font);
			*layout->offset_y = (nk_uint)scroll_offset;
			if (in && scroll_has_scrolling)
				in->mouse.scroll_delta.y = 0;
		}
		{
			/* horizontal scrollbar */
			nk_flags state = 0;
			scroll.x = layout->bounds.x;
			scroll.y = layout->bounds.y + layout->bounds.h;
			scroll.w = layout->bounds.w;
			scroll.h = scrollbar_size.y;

			scroll_offset = (float)*layout->offset_x;
			scroll_target = (float)(int)(layout->max_x - scroll.x);
			scroll_step = layout->max_x * 0.05f;
			scroll_inc = layout->max_x * 0.005f;
			scroll_offset = nk_do_scrollbarh(&state, out, scroll, scroll_has_scrolling, scroll_offset, scroll_target,
				scroll_step, scroll_inc, &ctx->style.scrollh, in, style->font);
			*layout->offset_x = (nk_uint)scroll_offset;
		}
	}

	/* hide scroll if no user input */
	if (window->flags & NK_WINDOW_SCROLL_AUTO_HIDE) {
		int has_input =
			ctx->input.mouse.delta.x != 0 || ctx->input.mouse.delta.y != 0 || ctx->input.mouse.scroll_delta.y != 0;
		int is_window_hovered = nk_window_is_hovered(ctx);
		int any_item_active = (ctx->last_widget_state & NK_WIDGET_STATE_MODIFIED);
		if ((!has_input && is_window_hovered) || (!is_window_hovered && !any_item_active))
			window->scrollbar_hiding_timer += ctx->delta_time_seconds;
		else window->scrollbar_hiding_timer = 0;
	}
	else window->scrollbar_hiding_timer = 0;

	/* window border */
	if (layout->flags & NK_WINDOW_BORDER) {
		struct nk_color border_color = nk_panel_get_border_color(style, layout->type);
		const float padding_y = (layout->flags & NK_WINDOW_MINIMIZED) ? (style->window.border + window->bounds.y +
			layout->header_height) : ((layout->flags &
				NK_WINDOW_DYNAMIC)
				? (layout->bounds.y +
					layout->bounds.h +
					layout->footer_height)
				: (window->bounds.y +
					window->bounds.h));
		struct nk_rect b = window->bounds;
		b.h = padding_y - window->bounds.y;
		nk_stroke_rect(out, b, 0, layout->border, border_color);
	}

	/* scaler */
	if ((layout->flags & NK_WINDOW_SCALABLE) && in && !(layout->flags & NK_WINDOW_MINIMIZED)) {
		/* calculate scaler bounds */
		struct nk_rect scaler;
		scaler.w = scrollbar_size.x;
		scaler.h = scrollbar_size.y;
		scaler.y = layout->bounds.y + layout->bounds.h;
		if (layout->flags & NK_WINDOW_SCALE_LEFT)
			scaler.x = layout->bounds.x - panel_padding.x * 0.5f;
		else scaler.x = layout->bounds.x + layout->bounds.w + panel_padding.x;
		if (layout->flags & NK_WINDOW_NO_SCROLLBAR)
			scaler.x -= scaler.w;

		/* draw scaler */
		{
			const struct nk_style_item* item = &style->window.scaler;
			if (item->type == NK_STYLE_ITEM_IMAGE)
				nk_draw_image(out, scaler, &item->data.image, nk_white);
			else {
				if (layout->flags & NK_WINDOW_SCALE_LEFT) {
					nk_fill_triangle(out, scaler.x, scaler.y, scaler.x, scaler.y + scaler.h, scaler.x + scaler.w,
						scaler.y + scaler.h, item->data.color);
				}
				else {
					nk_fill_triangle(out, scaler.x + scaler.w, scaler.y, scaler.x + scaler.w, scaler.y + scaler.h,
						scaler.x, scaler.y + scaler.h, item->data.color);
				}
			}
		}

		/* do window scaling */
		if (!(window->flags & NK_WINDOW_ROM)) {
			struct nk_vec2 window_size = style->window.min_size;
			int left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
			int left_mouse_click_in_scaler = nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, scaler, nk_true);

			if (left_mouse_down && left_mouse_click_in_scaler) {
				float delta_x = in->mouse.delta.x;
				if (layout->flags & NK_WINDOW_SCALE_LEFT) {
					delta_x = -delta_x;
					window->bounds.x += in->mouse.delta.x;
				}
				/* dragging in x-direction  */
				if (window->bounds.w + delta_x >= window_size.x) {
					if ((delta_x < 0) || (delta_x > 0 && in->mouse.pos.x >= scaler.x)) {
						window->bounds.w = window->bounds.w + delta_x;
						scaler.x += in->mouse.delta.x;
					}
				}
				/* dragging in y-direction (only possible if static window) */
				if (!(layout->flags & NK_WINDOW_DYNAMIC)) {
					if (window_size.y < window->bounds.h + in->mouse.delta.y) {
						if ((in->mouse.delta.y < 0) || (in->mouse.delta.y > 0 && in->mouse.pos.y >= scaler.y)) {
							window->bounds.h = window->bounds.h + in->mouse.delta.y;
							scaler.y += in->mouse.delta.y;
						}
					}
				}
				ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT];
				in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = scaler.x + scaler.w / 2.0f;
				in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y = scaler.y + scaler.h / 2.0f;
			}
		}
	}
	if (!nk_panel_is_sub(layout->type)) {
		/* window is hidden so clear command buffer  */
		if (layout->flags & NK_WINDOW_HIDDEN)
			nk_command_buffer_reset(&window->buffer);
		/* window is visible and not tab */
		else nk_finish(ctx, window);
	}

	/* NK_WINDOW_REMOVE_ROM flag was set so remove NK_WINDOW_ROM */
	if (layout->flags & NK_WINDOW_REMOVE_ROM) {
		layout->flags &= ~(nk_flags)NK_WINDOW_ROM;
		layout->flags &= ~(nk_flags)NK_WINDOW_REMOVE_ROM;
	}
	window->flags = layout->flags;

	/* property garbage collector */
	if (window->property.active && window->property.old != window->property.seq &&
		window->property.active == window->property.prev) {
		nk_zero(&window->property, sizeof(window->property));
	}
	else {
		window->property.old = window->property.seq;
		window->property.prev = window->property.active;
		window->property.seq = 0;
	}
	/* edit garbage collector */
	if (window->edit.active && window->edit.old != window->edit.seq && window->edit.active == window->edit.prev) {
		nk_zero(&window->edit, sizeof(window->edit));
	}
	else {
		window->edit.old = window->edit.seq;
		window->edit.prev = window->edit.active;
		window->edit.seq = 0;
	}
	/* contextual garbage collector */
	if (window->popup.active_con && window->popup.con_old != window->popup.con_count) {
		window->popup.con_count = 0;
		window->popup.con_old = 0;
		window->popup.active_con = 0;
	}
	else {
		window->popup.con_old = window->popup.con_count;
		window->popup.con_count = 0;
	}
	window->popup.combo_count = 0;
	/* helper to make sure you have a 'nk_tree_push' for every 'nk_tree_pop' */
	NK_ASSERT(!layout->row.tree_depth);
}





/* ===============================================================
 *
 *                              WINDOW
 *
 * ===============================================================*/
NK_LIB void* nk_create_window(struct nk_context* ctx) {
	struct nk_page_element* elem;
	elem = nk_create_page_element(ctx);
	if (!elem) return 0;
	elem->data.win.seq = ctx->seq;
	return &elem->data.win;
}

NK_LIB void nk_free_window(struct nk_context* ctx, struct nk_window* win) {
	/* unlink windows from list */
	struct nk_table* it = win->tables;
	if (win->popup.win) {
		nk_free_window(ctx, win->popup.win);
		win->popup.win = 0;
	}
	win->next = 0;
	win->prev = 0;

	while (it) {
		/*free window state tables */
		struct nk_table* n = it->next;
		nk_remove_table(win, it);
		nk_free_table(ctx, it);
		if (it == win->tables)
			win->tables = n;
		it = n;
	}

	/* link windows into freelist */
	{
		union nk_page_data* pd = NK_CONTAINER_OF(win, union nk_page_data, win);
		struct nk_page_element* pe = NK_CONTAINER_OF(pd, struct nk_page_element, data);
		nk_free_page_element(ctx, pe);
	}
}

NK_LIB struct nk_window* nk_find_window(struct nk_context* ctx, nk_hash hash, const char* name) {
	struct nk_window* iter;
	iter = ctx->begin;
	while (iter) {
		NK_ASSERT(iter != iter->next);
		if (iter->name == hash) {
			int max_len = nk_strlen(iter->name_string);
			if (!nk_stricmpn(iter->name_string, name, max_len))
				return iter;
		}
		iter = iter->next;
	}
	return 0;
}

NK_LIB void nk_insert_window(struct nk_context* ctx, struct nk_window* win, enum nk_window_insert_location loc) {
	const struct nk_window* iter;
	NK_ASSERT(ctx);
	NK_ASSERT(win);
	if (!win || !ctx) return;

	iter = ctx->begin;
	while (iter) {
		NK_ASSERT(iter != iter->next);
		NK_ASSERT(iter != win);
		if (iter == win) return;
		iter = iter->next;
	}

	if (!ctx->begin) {
		win->next = 0;
		win->prev = 0;
		ctx->begin = win;
		ctx->end = win;
		ctx->count = 1;
		return;
	}
	if (loc == NK_INSERT_BACK) {
		struct nk_window* end;
		end = ctx->end;
		end->flags |= NK_WINDOW_ROM;
		end->next = win;
		win->prev = ctx->end;
		win->next = 0;
		ctx->end = win;
		ctx->active = ctx->end;
		ctx->end->flags &= ~(nk_flags)NK_WINDOW_ROM;
	}
	else {
		/*ctx->end->flags |= NK_WINDOW_ROM;*/
		ctx->begin->prev = win;
		win->next = ctx->begin;
		win->prev = 0;
		ctx->begin = win;
		ctx->begin->flags &= ~(nk_flags)NK_WINDOW_ROM;
	}
	ctx->count++;
}

NK_LIB void nk_remove_window(struct nk_context* ctx, struct nk_window* win) {
	if (win == ctx->begin || win == ctx->end) {
		if (win == ctx->begin) {
			ctx->begin = win->next;
			if (win->next)
				win->next->prev = 0;
		}
		if (win == ctx->end) {
			ctx->end = win->prev;
			if (win->prev)
				win->prev->next = 0;
		}
	}
	else {
		if (win->next)
			win->next->prev = win->prev;
		if (win->prev)
			win->prev->next = win->next;
	}
	if (win == ctx->active || !ctx->active) {
		ctx->active = ctx->end;
		if (ctx->end)
			ctx->end->flags &= ~(nk_flags)NK_WINDOW_ROM;
	}
	win->next = 0;
	win->prev = 0;
	ctx->count--;
}

NK_API int nk_begin(struct nk_context* ctx, const char* title, struct nk_rect bounds, nk_flags flags) {
	return nk_begin_titled(ctx, title, title, bounds, flags);
}

NK_API int
nk_begin_titled(struct nk_context* ctx, const char* name, const char* title, struct nk_rect bounds, nk_flags flags) {
	struct nk_window* win;
	struct nk_style* style;
	nk_hash name_hash;
	int name_len;
	int ret = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(name);
	NK_ASSERT(title);
	NK_ASSERT(ctx->style.font && ctx->style.font->width && "if this triggers you forgot to add a font");
	NK_ASSERT(!ctx->current && "if this triggers you missed a `nk_end` call");
	if (!ctx || ctx->current || !title || !name)
		return 0;

	/* find or create window */
	style = &ctx->style;
	name_len = (int)nk_strlen(name);
	name_hash = nk_murmur_hash(name, (int)name_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, name_hash, name);
	if (!win) {
		/* create new window */
		nk_size name_length = (nk_size)name_len;
		win = (struct nk_window*) nk_create_window(ctx);
		NK_ASSERT(win);
		if (!win) return 0;

		if (flags & NK_WINDOW_BACKGROUND)
			nk_insert_window(ctx, win, NK_INSERT_FRONT);
		else nk_insert_window(ctx, win, NK_INSERT_BACK);
		nk_command_buffer_init(&win->buffer, &ctx->memory, NK_CLIPPING_ON);

		win->flags = flags;
		win->bounds = bounds;
		win->name = name_hash;
		name_length = NK_MIN(name_length, NK_WINDOW_MAX_NAME - 1);
		NK_MEMCPY(win->name_string, name, name_length);
		win->name_string[name_length] = 0;
		win->popup.win = 0;
		if (!ctx->active)
			ctx->active = win;
	}
	else {
		/* update window */
		win->flags &= ~(nk_flags)(NK_WINDOW_PRIVATE - 1);
		win->flags |= flags;
		if (!(win->flags & (NK_WINDOW_MOVABLE | NK_WINDOW_SCALABLE)))
			win->bounds = bounds;
		/* If this assert triggers you either:
		 *
		 * I.) Have more than one window with the same name or
		 * II.) You forgot to actually draw the window.
		 *      More specific you did not call `nk_clear` (nk_clear will be
		 *      automatically called for you if you are using one of the
		 *      provided demo backends). */
		NK_ASSERT(win->seq != ctx->seq);
		win->seq = ctx->seq;
		if (!ctx->active && !(win->flags & NK_WINDOW_HIDDEN)) {
			ctx->active = win;
			ctx->end = win;
		}
	}
	if (win->flags & NK_WINDOW_HIDDEN) {
		ctx->current = win;
		win->layout = 0;
		return 0;
	}
	else nk_start(ctx, win);

	/* window overlapping */
	if (!(win->flags & NK_WINDOW_HIDDEN) && !(win->flags & NK_WINDOW_NO_INPUT)) {
		int inpanel, ishovered;
		struct nk_window* iter = win;
		float h = ctx->style.font->height + 2.0f * style->window.header.padding.y +
			(2.0f * style->window.header.label_padding.y);
		struct nk_rect win_bounds = (!(win->flags & NK_WINDOW_MINIMIZED)) ? win->bounds : nk_rect(win->bounds.x,
			win->bounds.y,
			win->bounds.w, h);

		/* activate window if hovered and no other window is overlapping this window */
		inpanel = nk_input_has_mouse_click_down_in_rect(&ctx->input, NK_BUTTON_LEFT, win_bounds, nk_true);
		inpanel = inpanel && ctx->input.mouse.buttons[NK_BUTTON_LEFT].clicked;
		ishovered = nk_input_is_mouse_hovering_rect(&ctx->input, win_bounds);
		if ((win != ctx->active) && ishovered && !ctx->input.mouse.buttons[NK_BUTTON_LEFT].down) {
			iter = win->next;
			while (iter) {
				struct nk_rect iter_bounds = (!(iter->flags & NK_WINDOW_MINIMIZED)) ? iter->bounds : nk_rect(
					iter->bounds.x, iter->bounds.y, iter->bounds.w, h);
				if (NK_INTERSECT(win_bounds.x, win_bounds.y, win_bounds.w, win_bounds.h, iter_bounds.x, iter_bounds.y,
					iter_bounds.w, iter_bounds.h) && (!(iter->flags & NK_WINDOW_HIDDEN)))
					break;

				if (iter->popup.win && iter->popup.active && !(iter->flags & NK_WINDOW_HIDDEN) &&
					NK_INTERSECT(win->bounds.x, win_bounds.y, win_bounds.w, win_bounds.h, iter->popup.win->bounds.x,
						iter->popup.win->bounds.y, iter->popup.win->bounds.w, iter->popup.win->bounds.h))
					break;
				iter = iter->next;
			}
		}

		/* activate window if clicked */
		if (iter && inpanel && (win != ctx->end)) {
			iter = win->next;
			while (iter) {
				/* try to find a panel with higher priority in the same position */
				struct nk_rect iter_bounds = (!(iter->flags & NK_WINDOW_MINIMIZED)) ? iter->bounds : nk_rect(
					iter->bounds.x, iter->bounds.y, iter->bounds.w, h);
				if (NK_INBOX(ctx->input.mouse.pos.x, ctx->input.mouse.pos.y, iter_bounds.x, iter_bounds.y,
					iter_bounds.w, iter_bounds.h) && !(iter->flags & NK_WINDOW_HIDDEN))
					break;
				if (iter->popup.win && iter->popup.active && !(iter->flags & NK_WINDOW_HIDDEN) &&
					NK_INTERSECT(win_bounds.x, win_bounds.y, win_bounds.w, win_bounds.h, iter->popup.win->bounds.x,
						iter->popup.win->bounds.y, iter->popup.win->bounds.w, iter->popup.win->bounds.h))
					break;
				iter = iter->next;
			}
		}
		if (iter && !(win->flags & NK_WINDOW_ROM) && (win->flags & NK_WINDOW_BACKGROUND)) {
			win->flags |= (nk_flags)NK_WINDOW_ROM;
			iter->flags &= ~(nk_flags)NK_WINDOW_ROM;
			ctx->active = iter;
			if (!(iter->flags & NK_WINDOW_BACKGROUND)) {
				/* current window is active in that position so transfer to top
				 * at the highest priority in stack */
				nk_remove_window(ctx, iter);
				nk_insert_window(ctx, iter, NK_INSERT_BACK);
			}
		}
		else {
			if (!iter && ctx->end != win) {
				if (!(win->flags & NK_WINDOW_BACKGROUND)) {
					/* current window is active in that position so transfer to top
					 * at the highest priority in stack */
					nk_remove_window(ctx, win);
					nk_insert_window(ctx, win, NK_INSERT_BACK);
				}
				win->flags &= ~(nk_flags)NK_WINDOW_ROM;
				ctx->active = win;
			}
			if (ctx->end != win && !(win->flags & NK_WINDOW_BACKGROUND))
				win->flags |= NK_WINDOW_ROM;
		}
	}
	win->layout = (struct nk_panel*) nk_create_panel(ctx);
	ctx->current = win;
	ret = nk_panel_begin(ctx, title, NK_PANEL_WINDOW);
	win->layout->offset_x = &win->scrollbar.x;
	win->layout->offset_y = &win->scrollbar.y;
	return ret;
}

NK_API void nk_end(struct nk_context* ctx) {
	struct nk_panel* layout;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current && "if this triggers you forgot to call `nk_begin`");
	if (!ctx || !ctx->current)
		return;

	layout = ctx->current->layout;
	if (!layout || (layout->type == NK_PANEL_WINDOW && (ctx->current->flags & NK_WINDOW_HIDDEN))) {
		ctx->current = 0;
		return;
	}
	nk_panel_end(ctx);
	nk_free_panel(ctx, ctx->current->layout);
	ctx->current = 0;
}

NK_API struct nk_rect nk_window_get_bounds(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return nk_rect(0, 0, 0, 0);
	return ctx->current->bounds;
}

NK_API struct nk_vec2 nk_window_get_position(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return nk_vec2(0, 0);
	return nk_vec2(ctx->current->bounds.x, ctx->current->bounds.y);
}

NK_API struct nk_vec2 nk_window_get_size(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return nk_vec2(0, 0);
	return nk_vec2(ctx->current->bounds.w, ctx->current->bounds.h);
}

NK_API float nk_window_get_width(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return 0;
	return ctx->current->bounds.w;
}

NK_API float nk_window_get_height(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return 0;
	return ctx->current->bounds.h;
}

NK_API struct nk_rect nk_window_get_content_region(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return nk_rect(0, 0, 0, 0);
	return ctx->current->layout->clip;
}

NK_API struct nk_vec2 nk_window_get_content_region_min(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current) return nk_vec2(0, 0);
	return nk_vec2(ctx->current->layout->clip.x, ctx->current->layout->clip.y);
}

NK_API struct nk_vec2 nk_window_get_content_region_max(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current) return nk_vec2(0, 0);
	return nk_vec2(ctx->current->layout->clip.x + ctx->current->layout->clip.w,
		ctx->current->layout->clip.y + ctx->current->layout->clip.h);
}

NK_API struct nk_vec2 nk_window_get_content_region_size(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current) return nk_vec2(0, 0);
	return nk_vec2(ctx->current->layout->clip.w, ctx->current->layout->clip.h);
}

NK_API struct nk_command_buffer* nk_window_get_canvas(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current) return 0;
	return &ctx->current->buffer;
}

NK_API struct nk_panel* nk_window_get_panel(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return 0;
	return ctx->current->layout;
}

NK_API int nk_window_has_focus(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current) return 0;
	return ctx->current == ctx->active;
}

NK_API int nk_window_is_hovered(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return 0;
	if (ctx->current->flags & NK_WINDOW_HIDDEN)
		return 0;
	return nk_input_is_mouse_hovering_rect(&ctx->input, ctx->current->bounds);
}

NK_API int nk_window_is_any_hovered(struct nk_context* ctx) {
	struct nk_window* iter;
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	iter = ctx->begin;
	while (iter) {
		/* check if window is being hovered */
		if (!(iter->flags & NK_WINDOW_HIDDEN)) {
			/* check if window popup is being hovered */
			if (iter->popup.active && iter->popup.win &&
				nk_input_is_mouse_hovering_rect(&ctx->input, iter->popup.win->bounds))
				return 1;

			if (iter->flags & NK_WINDOW_MINIMIZED) {
				struct nk_rect header = iter->bounds;
				header.h = ctx->style.font->height + 2 * ctx->style.window.header.padding.y;
				if (nk_input_is_mouse_hovering_rect(&ctx->input, header))
					return 1;
			}
			else if (nk_input_is_mouse_hovering_rect(&ctx->input, iter->bounds)) {
				return 1;
			}
		}
		iter = iter->next;
	}
	return 0;
}

NK_API int nk_item_is_any_active(struct nk_context* ctx) {
	int any_hovered = nk_window_is_any_hovered(ctx);
	int any_active = (ctx->last_widget_state & NK_WIDGET_STATE_MODIFIED);
	return any_hovered || any_active;
}

NK_API int nk_window_is_collapsed(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return 0;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return 0;
	return win->flags & NK_WINDOW_MINIMIZED;
}

NK_API int nk_window_is_closed(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return 1;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return 1;
	return (win->flags & NK_WINDOW_CLOSED);
}

NK_API int nk_window_is_hidden(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return 1;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return 1;
	return (win->flags & NK_WINDOW_HIDDEN);
}

NK_API int nk_window_is_active(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return 0;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return 0;
	return win == ctx->active;
}

NK_API struct nk_window* nk_window_find(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	return nk_find_window(ctx, title_hash, name);
}

NK_API void nk_window_close(struct nk_context* ctx, const char* name) {
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return;
	win = nk_window_find(ctx, name);
	if (!win) return;
	NK_ASSERT(ctx->current != win && "You cannot close a currently active window");
	if (ctx->current == win) return;
	win->flags |= NK_WINDOW_HIDDEN;
	win->flags |= NK_WINDOW_CLOSED;
}

NK_API void nk_window_set_bounds(struct nk_context* ctx, const char* name, struct nk_rect bounds) {
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return;
	win = nk_window_find(ctx, name);
	if (!win) return;
	NK_ASSERT(ctx->current != win && "You cannot update a currently in procecss window");
	win->bounds = bounds;
}

NK_API void nk_window_set_position(struct nk_context* ctx, const char* name, struct nk_vec2 pos) {
	struct nk_window* win = nk_window_find(ctx, name);
	if (!win) return;
	win->bounds.x = pos.x;
	win->bounds.y = pos.y;
}

NK_API void nk_window_set_size(struct nk_context* ctx, const char* name, struct nk_vec2 size) {
	struct nk_window* win = nk_window_find(ctx, name);
	if (!win) return;
	win->bounds.w = size.x;
	win->bounds.h = size.y;
}

NK_API void nk_window_collapse(struct nk_context* ctx, const char* name, enum nk_collapse_states c) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return;
	if (c == NK_MINIMIZED)
		win->flags |= NK_WINDOW_MINIMIZED;
	else win->flags &= ~(nk_flags)NK_WINDOW_MINIMIZED;
}

NK_API void nk_window_collapse_if(struct nk_context* ctx, const char* name, enum nk_collapse_states c, int cond) {
	NK_ASSERT(ctx);
	if (!ctx || !cond) return;
	nk_window_collapse(ctx, name, c);
}

NK_API void nk_window_show(struct nk_context* ctx, const char* name, enum nk_show_states s) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return;
	if (s == NK_HIDDEN) {
		win->flags |= NK_WINDOW_HIDDEN;
	}
	else win->flags &= ~(nk_flags)NK_WINDOW_HIDDEN;
}

NK_API void nk_window_show_if(struct nk_context* ctx, const char* name, enum nk_show_states s, int cond) {
	NK_ASSERT(ctx);
	if (!ctx || !cond) return;
	nk_window_show(ctx, name, s);
}

NK_API void nk_window_set_focus(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (win && ctx->end != win) {
		nk_remove_window(ctx, win);
		nk_insert_window(ctx, win, NK_INSERT_BACK);
	}
	ctx->active = win;
}





/* ===============================================================
 *
 *                              POPUP
 *
 * ===============================================================*/
NK_API int nk_popup_begin(struct nk_context* ctx, enum nk_popup_type type, const char* title, nk_flags flags,
	struct nk_rect rect) {
	struct nk_window* popup;
	struct nk_window* win;
	struct nk_panel* panel;

	int title_len;
	nk_hash title_hash;
	nk_size allocated;

	NK_ASSERT(ctx);
	NK_ASSERT(title);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	panel = win->layout;
	NK_ASSERT(!(panel->type & NK_PANEL_SET_POPUP) && "popups are not allowed to have popups");
	(void)panel;
	title_len = (int)nk_strlen(title);
	title_hash = nk_murmur_hash(title, (int)title_len, NK_PANEL_POPUP);

	popup = win->popup.win;
	if (!popup) {
		popup = (struct nk_window*) nk_create_window(ctx);
		popup->parent = win;
		win->popup.win = popup;
		win->popup.active = 0;
		win->popup.type = NK_PANEL_POPUP;
	}

	/* make sure we have correct popup */
	if (win->popup.name != title_hash) {
		if (!win->popup.active) {
			nk_zero(popup, sizeof(*popup));
			win->popup.name = title_hash;
			win->popup.active = 1;
			win->popup.type = NK_PANEL_POPUP;
		}
		else return 0;
	}

	/* popup position is local to window */
	ctx->current = popup;
	rect.x += win->layout->clip.x;
	rect.y += win->layout->clip.y;

	/* setup popup data */
	popup->parent = win;
	popup->bounds = rect;
	popup->seq = ctx->seq;
	popup->layout = (struct nk_panel*) nk_create_panel(ctx);
	popup->flags = flags;
	popup->flags |= NK_WINDOW_BORDER;
	if (type == NK_POPUP_DYNAMIC)
		popup->flags |= NK_WINDOW_DYNAMIC;

	popup->buffer = win->buffer;
	nk_start_popup(ctx, win);
	allocated = ctx->memory.allocated;
	nk_push_scissor(&popup->buffer, nk_null_rect);

	if (nk_panel_begin(ctx, title, NK_PANEL_POPUP)) {
		/* popup is running therefore invalidate parent panels */
		struct nk_panel* root;
		root = win->layout;
		while (root) {
			root->flags |= NK_WINDOW_ROM;
			root->flags &= ~(nk_flags)NK_WINDOW_REMOVE_ROM;
			root = root->parent;
		}
		win->popup.active = 1;
		popup->layout->offset_x = &popup->scrollbar.x;
		popup->layout->offset_y = &popup->scrollbar.y;
		popup->layout->parent = win->layout;
		return 1;
	}
	else {
		/* popup was closed/is invalid so cleanup */
		struct nk_panel* root;
		root = win->layout;
		while (root) {
			root->flags |= NK_WINDOW_REMOVE_ROM;
			root = root->parent;
		}
		win->popup.buf.active = 0;
		win->popup.active = 0;
		ctx->memory.allocated = allocated;
		ctx->current = win;
		nk_free_panel(ctx, popup->layout);
		popup->layout = 0;
		return 0;
	}
}

NK_LIB int nk_nonblock_begin(struct nk_context* ctx, nk_flags flags, struct nk_rect body, struct nk_rect header,
	enum nk_panel_type panel_type) {
	struct nk_window* popup;
	struct nk_window* win;
	struct nk_panel* panel;
	int is_active = nk_true;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	/* popups cannot have popups */
	win = ctx->current;
	panel = win->layout;
	NK_ASSERT(!(panel->type & NK_PANEL_SET_POPUP));
	(void)panel;
	popup = win->popup.win;
	if (!popup) {
		/* create window for nonblocking popup */
		popup = (struct nk_window*) nk_create_window(ctx);
		popup->parent = win;
		win->popup.win = popup;
		win->popup.type = panel_type;
		nk_command_buffer_init(&popup->buffer, &ctx->memory, NK_CLIPPING_ON);
	}
	else {
		/* close the popup if user pressed outside or in the header */
		int pressed, in_body, in_header;
		pressed = nk_input_is_mouse_pressed(&ctx->input, NK_BUTTON_LEFT);
		in_body = nk_input_is_mouse_hovering_rect(&ctx->input, body);
		in_header = nk_input_is_mouse_hovering_rect(&ctx->input, header);
		if (pressed && (!in_body || in_header))
			is_active = nk_false;
	}
	win->popup.header = header;

	if (!is_active) {
		/* remove read only mode from all parent panels */
		struct nk_panel* root = win->layout;
		while (root) {
			root->flags |= NK_WINDOW_REMOVE_ROM;
			root = root->parent;
		}
		return is_active;
	}
	popup->bounds = body;
	popup->parent = win;
	popup->layout = (struct nk_panel*) nk_create_panel(ctx);
	popup->flags = flags;
	popup->flags |= NK_WINDOW_BORDER;
	popup->flags |= NK_WINDOW_DYNAMIC;
	popup->seq = ctx->seq;
	win->popup.active = 1;
	NK_ASSERT(popup->layout);

	nk_start_popup(ctx, win);
	popup->buffer = win->buffer;
	nk_push_scissor(&popup->buffer, nk_null_rect);
	ctx->current = popup;

	nk_panel_begin(ctx, 0, panel_type);
	win->buffer = popup->buffer;
	popup->layout->parent = win->layout;
	popup->layout->offset_x = &popup->scrollbar.x;
	popup->layout->offset_y = &popup->scrollbar.y;

	/* set read only mode to all parent panels */
	{
		struct nk_panel* root;
		root = win->layout;
		while (root) {
			root->flags |= NK_WINDOW_ROM;
			root = root->parent;
		}
	}
	return is_active;
}

NK_API void nk_popup_close(struct nk_context* ctx) {
	struct nk_window* popup;
	NK_ASSERT(ctx);
	if (!ctx || !ctx->current) return;

	popup = ctx->current;
	NK_ASSERT(popup->parent);
	NK_ASSERT(popup->layout->type & NK_PANEL_SET_POPUP);
	popup->flags |= NK_WINDOW_HIDDEN;
}

NK_API void nk_popup_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_window* popup;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	popup = ctx->current;
	if (!popup->parent) return;
	win = popup->parent;
	if (popup->flags & NK_WINDOW_HIDDEN) {
		struct nk_panel* root;
		root = win->layout;
		while (root) {
			root->flags |= NK_WINDOW_REMOVE_ROM;
			root = root->parent;
		}
		win->popup.active = 0;
	}
	nk_push_scissor(&popup->buffer, nk_null_rect);
	nk_end(ctx);

	win->buffer = popup->buffer;
	nk_finish_popup(ctx, win);
	ctx->current = win;
	nk_push_scissor(&win->buffer, win->layout->clip);
}





/* ==============================================================
 *
 *                          CONTEXTUAL
 *
 * ===============================================================*/
NK_API int
nk_contextual_begin(struct nk_context* ctx, nk_flags flags, struct nk_vec2 size, struct nk_rect trigger_bounds) {
	struct nk_window* win;
	struct nk_window* popup;
	struct nk_rect body;

	NK_STORAGE const struct nk_rect null_rect = { -1, -1, 0, 0 };
	int is_clicked = 0;
	int is_open = 0;
	int ret = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	++win->popup.con_count;
	if (ctx->current != ctx->active)
		return 0;

	/* check if currently active contextual is active */
	popup = win->popup.win;
	is_open = (popup && win->popup.type == NK_PANEL_CONTEXTUAL);
	is_clicked = nk_input_mouse_clicked(&ctx->input, NK_BUTTON_RIGHT, trigger_bounds);
	if (win->popup.active_con && win->popup.con_count != win->popup.active_con)
		return 0;
	if (!is_open && win->popup.active_con)
		win->popup.active_con = 0;
	if ((!is_open && !is_clicked))
		return 0;

	/* calculate contextual position on click */
	win->popup.active_con = win->popup.con_count;
	if (is_clicked) {
		body.x = ctx->input.mouse.pos.x;
		body.y = ctx->input.mouse.pos.y;
	}
	else {
		body.x = popup->bounds.x;
		body.y = popup->bounds.y;
	}
	body.w = size.x;
	body.h = size.y;

	/* start nonblocking contextual popup */
	ret = nk_nonblock_begin(ctx, flags | NK_WINDOW_NO_SCROLLBAR, body, null_rect, NK_PANEL_CONTEXTUAL);
	if (ret) win->popup.type = NK_PANEL_CONTEXTUAL;
	else {
		win->popup.active_con = 0;
		win->popup.type = NK_PANEL_NONE;
		if (win->popup.win)
			win->popup.win->flags = 0;
	}
	return ret;
}

NK_API int nk_contextual_item_text(struct nk_context* ctx, const char* text, int len, nk_flags alignment) {
	struct nk_window* win;
	const struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	state = nk_widget_fitting(&bounds, ctx, style->contextual_button.padding);
	if (!state) return nk_false;

	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text(&ctx->last_widget_state, &win->buffer, bounds, text, len, alignment, NK_BUTTON_DEFAULT,
		&style->contextual_button, in, style->font)) {
		nk_contextual_close(ctx);
		return nk_true;
	}
	return nk_false;
}

NK_API int nk_contextual_item_label(struct nk_context* ctx, const char* label, nk_flags align) {
	return nk_contextual_item_text(ctx, label, nk_strlen(label), align);
}

NK_API int
nk_contextual_item_image_text(struct nk_context* ctx, struct nk_image img, const char* text, int len, nk_flags align) {
	struct nk_window* win;
	const struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	state = nk_widget_fitting(&bounds, ctx, style->contextual_button.padding);
	if (!state) return nk_false;

	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text_image(&ctx->last_widget_state, &win->buffer, bounds, img, text, len, align, NK_BUTTON_DEFAULT,
		&style->contextual_button, style->font, in)) {
		nk_contextual_close(ctx);
		return nk_true;
	}
	return nk_false;
}

NK_API int
nk_contextual_item_image_label(struct nk_context* ctx, struct nk_image img, const char* label, nk_flags align) {
	return nk_contextual_item_image_text(ctx, img, label, nk_strlen(label), align);
}

NK_API int nk_contextual_item_symbol_text(struct nk_context* ctx, enum nk_symbol_type symbol, const char* text, int len,
	nk_flags align) {
	struct nk_window* win;
	const struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	state = nk_widget_fitting(&bounds, ctx, style->contextual_button.padding);
	if (!state) return nk_false;

	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text_symbol(&ctx->last_widget_state, &win->buffer, bounds, symbol, text, len, align,
		NK_BUTTON_DEFAULT, &style->contextual_button, style->font, in)) {
		nk_contextual_close(ctx);
		return nk_true;
	}
	return nk_false;
}

NK_API int
nk_contextual_item_symbol_label(struct nk_context* ctx, enum nk_symbol_type symbol, const char* text, nk_flags align) {
	return nk_contextual_item_symbol_text(ctx, symbol, text, nk_strlen(text), align);
}

NK_API void nk_contextual_close(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return;
	nk_popup_close(ctx);
}

NK_API void nk_contextual_end(struct nk_context* ctx) {
	struct nk_window* popup;
	struct nk_panel* panel;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return;

	popup = ctx->current;
	panel = popup->layout;
	NK_ASSERT(popup->parent);
	NK_ASSERT(panel->type & NK_PANEL_SET_POPUP);
	if (panel->flags & NK_WINDOW_DYNAMIC) {
		/* Close behavior
		This is a bit of a hack solution since we do not know before we end our popup
		how big it will be. We therefore do not directly know when a
		click outside the non-blocking popup must close it at that direct frame.
		Instead it will be closed in the next frame.*/
		struct nk_rect body = { 0, 0, 0, 0 };
		if (panel->at_y < (panel->bounds.y + panel->bounds.h)) {
			struct nk_vec2 padding = nk_panel_get_padding(&ctx->style, panel->type);
			body = panel->bounds;
			body.y = (panel->at_y + panel->footer_height + panel->border + padding.y + panel->row.height);
			body.h = (panel->bounds.y + panel->bounds.h) - body.y;
		}
		{
			int pressed = nk_input_is_mouse_pressed(&ctx->input, NK_BUTTON_LEFT);
			int in_body = nk_input_is_mouse_hovering_rect(&ctx->input, body);
			if (pressed && in_body)
				popup->flags |= NK_WINDOW_HIDDEN;
		}
	}
	if (popup->flags & NK_WINDOW_HIDDEN)
		popup->seq = 0;
	nk_popup_end(ctx);
	return;
}





/* ===============================================================
 *
 *                              MENU
 *
 * ===============================================================*/
NK_API void nk_menubar_begin(struct nk_context* ctx) {
	struct nk_panel* layout;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	layout = ctx->current->layout;
	NK_ASSERT(layout->at_y == layout->bounds.y);
	/* if this assert triggers you allocated space between nk_begin and nk_menubar_begin.
	If you want a menubar the first nuklear function after `nk_begin` has to be a
	`nk_menubar_begin` call. Inside the menubar you then have to allocate space for
	widgets (also supports multiple rows).
	Example:
		if (nk_begin(...)) {
			nk_menubar_begin(...);
				nk_layout_xxxx(...);
				nk_button(...);
				nk_layout_xxxx(...);
				nk_button(...);
			nk_menubar_end(...);
		}
		nk_end(...);
	*/
	if (layout->flags & NK_WINDOW_HIDDEN || layout->flags & NK_WINDOW_MINIMIZED)
		return;

	layout->menu.x = layout->at_x;
	layout->menu.y = layout->at_y + layout->row.height;
	layout->menu.w = layout->bounds.w;
	layout->menu.offset.x = *layout->offset_x;
	layout->menu.offset.y = *layout->offset_y;
	*layout->offset_y = 0;
}

NK_API void nk_menubar_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;
	struct nk_command_buffer* out;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	out = &win->buffer;
	layout = win->layout;
	if (layout->flags & NK_WINDOW_HIDDEN || layout->flags & NK_WINDOW_MINIMIZED)
		return;

	layout->menu.h = layout->at_y - layout->menu.y;
	layout->bounds.y += layout->menu.h + ctx->style.window.spacing.y + layout->row.height;
	layout->bounds.h -= layout->menu.h + ctx->style.window.spacing.y + layout->row.height;

	*layout->offset_x = layout->menu.offset.x;
	*layout->offset_y = layout->menu.offset.y;
	layout->at_y = layout->bounds.y - layout->row.height;

	layout->clip.y = layout->bounds.y;
	layout->clip.h = layout->bounds.h;
	nk_push_scissor(out, layout->clip);
}

NK_INTERN int
nk_menu_begin(struct nk_context* ctx, struct nk_window* win, const char* id, int is_clicked, struct nk_rect header,
	struct nk_vec2 size) {
	int is_open = 0;
	int is_active = 0;
	struct nk_rect body;
	struct nk_window* popup;
	nk_hash hash = nk_murmur_hash(id, (int)nk_strlen(id), NK_PANEL_MENU);

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	body.x = header.x;
	body.w = size.x;
	body.y = header.y + header.h;
	body.h = size.y;

	popup = win->popup.win;
	is_open = popup ? nk_true : nk_false;
	is_active = (popup && (win->popup.name == hash) && win->popup.type == NK_PANEL_MENU);
	if ((is_clicked && is_open && !is_active) || (is_open && !is_active) ||
		(!is_open && !is_active && !is_clicked))
		return 0;
	if (!nk_nonblock_begin(ctx, NK_WINDOW_NO_SCROLLBAR, body, header, NK_PANEL_MENU))
		return 0;

	win->popup.type = NK_PANEL_MENU;
	win->popup.name = hash;
	return 1;
}

NK_API int nk_menu_begin_text(struct nk_context* ctx, const char* title, int len, nk_flags align, struct nk_vec2 size) {
	struct nk_window* win;
	const struct nk_input* in;
	struct nk_rect header;
	int is_clicked = nk_false;
	nk_flags state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	state = nk_widget(&header, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || win->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text(&ctx->last_widget_state, &win->buffer, header, title, len, align, NK_BUTTON_DEFAULT,
		&ctx->style.menu_button, in, ctx->style.font))
		is_clicked = nk_true;
	return nk_menu_begin(ctx, win, title, is_clicked, header, size);
}

NK_API int nk_menu_begin_label(struct nk_context* ctx, const char* text, nk_flags align, struct nk_vec2 size) {
	return nk_menu_begin_text(ctx, text, nk_strlen(text), align, size);
}

NK_API int nk_menu_begin_image(struct nk_context* ctx, const char* id, struct nk_image img, struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_rect header;
	const struct nk_input* in;
	int is_clicked = nk_false;
	nk_flags state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	state = nk_widget(&header, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_image(&ctx->last_widget_state, &win->buffer, header, img, NK_BUTTON_DEFAULT,
		&ctx->style.menu_button, in))
		is_clicked = nk_true;
	return nk_menu_begin(ctx, win, id, is_clicked, header, size);
}

NK_API int nk_menu_begin_symbol(struct nk_context* ctx, const char* id, enum nk_symbol_type sym, struct nk_vec2 size) {
	struct nk_window* win;
	const struct nk_input* in;
	struct nk_rect header;
	int is_clicked = nk_false;
	nk_flags state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	state = nk_widget(&header, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_symbol(&ctx->last_widget_state, &win->buffer, header, sym, NK_BUTTON_DEFAULT,
		&ctx->style.menu_button, in, ctx->style.font))
		is_clicked = nk_true;
	return nk_menu_begin(ctx, win, id, is_clicked, header, size);
}

NK_API int
nk_menu_begin_image_text(struct nk_context* ctx, const char* title, int len, nk_flags align, struct nk_image img,
	struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_rect header;
	const struct nk_input* in;
	int is_clicked = nk_false;
	nk_flags state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	state = nk_widget(&header, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text_image(&ctx->last_widget_state, &win->buffer, header, img, title, len, align,
		NK_BUTTON_DEFAULT, &ctx->style.menu_button, ctx->style.font, in))
		is_clicked = nk_true;
	return nk_menu_begin(ctx, win, title, is_clicked, header, size);
}

NK_API int nk_menu_begin_image_label(struct nk_context* ctx, const char* title, nk_flags align, struct nk_image img,
	struct nk_vec2 size) {
	return nk_menu_begin_image_text(ctx, title, nk_strlen(title), align, img, size);
}

NK_API int
nk_menu_begin_symbol_text(struct nk_context* ctx, const char* title, int len, nk_flags align, enum nk_symbol_type sym,
	struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_rect header;
	const struct nk_input* in;
	int is_clicked = nk_false;
	nk_flags state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	state = nk_widget(&header, ctx);
	if (!state) return 0;

	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text_symbol(&ctx->last_widget_state, &win->buffer, header, sym, title, len, align,
		NK_BUTTON_DEFAULT, &ctx->style.menu_button, ctx->style.font, in))
		is_clicked = nk_true;
	return nk_menu_begin(ctx, win, title, is_clicked, header, size);
}

NK_API int
nk_menu_begin_symbol_label(struct nk_context* ctx, const char* title, nk_flags align, enum nk_symbol_type sym,
	struct nk_vec2 size) {
	return nk_menu_begin_symbol_text(ctx, title, nk_strlen(title), align, sym, size);
}

NK_API int nk_menu_item_text(struct nk_context* ctx, const char* title, int len, nk_flags align) {
	return nk_contextual_item_text(ctx, title, len, align);
}

NK_API int nk_menu_item_label(struct nk_context* ctx, const char* label, nk_flags align) {
	return nk_contextual_item_label(ctx, label, align);
}

NK_API int nk_menu_item_image_label(struct nk_context* ctx, struct nk_image img, const char* label, nk_flags align) {
	return nk_contextual_item_image_label(ctx, img, label, align);
}

NK_API int
nk_menu_item_image_text(struct nk_context* ctx, struct nk_image img, const char* text, int len, nk_flags align) {
	return nk_contextual_item_image_text(ctx, img, text, len, align);
}

NK_API int
nk_menu_item_symbol_text(struct nk_context* ctx, enum nk_symbol_type sym, const char* text, int len, nk_flags align) {
	return nk_contextual_item_symbol_text(ctx, sym, text, len, align);
}

NK_API int
nk_menu_item_symbol_label(struct nk_context* ctx, enum nk_symbol_type sym, const char* label, nk_flags align) {
	return nk_contextual_item_symbol_label(ctx, sym, label, align);
}

NK_API void nk_menu_close(struct nk_context* ctx) {
	nk_contextual_close(ctx);
}

NK_API void nk_menu_end(struct nk_context* ctx) {
	nk_contextual_end(ctx);
}





/* ===============================================================
 *
 *                          LAYOUT
 *
 * ===============================================================*/
NK_API void nk_layout_set_min_row_height(struct nk_context* ctx, float height) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	layout->row.min_height = height;
}

NK_API void nk_layout_reset_min_row_height(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	layout->row.min_height = ctx->style.font->height;
	layout->row.min_height += ctx->style.text.padding.y * 2;
	layout->row.min_height += ctx->style.window.min_row_height_padding * 2;
}

NK_LIB float
nk_layout_row_calculate_usable_space(const struct nk_style* style, enum nk_panel_type type, float total_space,
	int columns) {
	float panel_padding;
	float panel_spacing;
	float panel_space;

	struct nk_vec2 spacing;
	struct nk_vec2 padding;

	spacing = style->window.spacing;
	padding = nk_panel_get_padding(style, type);

	/* calculate the usable panel space */
	panel_padding = 2 * padding.x;
	panel_spacing = (float)NK_MAX(columns - 1, 0) * spacing.x;
	panel_space = total_space - panel_padding - panel_spacing;
	return panel_space;
}

NK_LIB void nk_panel_layout(const struct nk_context* ctx, struct nk_window* win, float height, int cols) {
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_command_buffer* out;

	struct nk_vec2 item_spacing;
	struct nk_color color;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	/* prefetch some configuration data */
	layout = win->layout;
	style = &ctx->style;
	out = &win->buffer;
	color = style->window.background;
	item_spacing = style->window.spacing;

	/*  if one of these triggers you forgot to add an `if` condition around either
		a window, group, popup, combobox or contextual menu `begin` and `end` block.
		Example:
			if (nk_begin(...) {...} nk_end(...); or
			if (nk_group_begin(...) { nk_group_end(...);} */
	NK_ASSERT(!(layout->flags & NK_WINDOW_MINIMIZED));
	NK_ASSERT(!(layout->flags & NK_WINDOW_HIDDEN));
	NK_ASSERT(!(layout->flags & NK_WINDOW_CLOSED));

	/* update the current row and set the current row layout */
	layout->row.index = 0;
	layout->at_y += layout->row.height;
	layout->row.columns = cols;
	if (height == 0.0f)
		layout->row.height = NK_MAX(height, layout->row.min_height) + item_spacing.y;
	else layout->row.height = height + item_spacing.y;

	layout->row.item_offset = 0;
	if (layout->flags & NK_WINDOW_DYNAMIC) {
		/* draw background for dynamic panels */
		struct nk_rect background;
		background.x = win->bounds.x;
		background.w = win->bounds.w;
		background.y = layout->at_y - 1.0f;
		background.h = layout->row.height + 1.0f;
		nk_fill_rect(out, background, 0, color);
	}
}

NK_LIB void nk_row_layout(struct nk_context* ctx, enum nk_layout_format fmt, float height, int cols, int width) {
	/* update the current row and set the current row layout */
	struct nk_window* win;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	nk_panel_layout(ctx, win, height, cols);
	if (fmt == NK_DYNAMIC)
		win->layout->row.type = NK_LAYOUT_DYNAMIC_FIXED;
	else win->layout->row.type = NK_LAYOUT_STATIC_FIXED;

	win->layout->row.ratio = 0;
	win->layout->row.filled = 0;
	win->layout->row.item_offset = 0;
	win->layout->row.item_width = (float)width;
}

NK_API float nk_layout_ratio_from_pixel(struct nk_context* ctx, float pixel_width) {
	struct nk_window* win;
	NK_ASSERT(ctx);
	NK_ASSERT(pixel_width);
	if (!ctx || !ctx->current || !ctx->current->layout) return 0;
	win = ctx->current;
	return NK_CLAMP(0.0f, pixel_width / win->bounds.x, 1.0f);
}

NK_API void nk_layout_row_dynamic(struct nk_context* ctx, float height, int cols) {
	nk_row_layout(ctx, NK_DYNAMIC, height, cols, 0);
}

NK_API void nk_layout_row_static(struct nk_context* ctx, float height, int item_width, int cols) {
	nk_row_layout(ctx, NK_STATIC, height, cols, item_width);
}

NK_API void nk_layout_row_begin(struct nk_context* ctx, enum nk_layout_format fmt, float row_height, int cols) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	nk_panel_layout(ctx, win, row_height, cols);
	if (fmt == NK_DYNAMIC)
		layout->row.type = NK_LAYOUT_DYNAMIC_ROW;
	else layout->row.type = NK_LAYOUT_STATIC_ROW;

	layout->row.ratio = 0;
	layout->row.filled = 0;
	layout->row.item_width = 0;
	layout->row.item_offset = 0;
	layout->row.columns = cols;
}

NK_API void nk_layout_row_push(struct nk_context* ctx, float ratio_or_width) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_STATIC_ROW || layout->row.type == NK_LAYOUT_DYNAMIC_ROW);
	if (layout->row.type != NK_LAYOUT_STATIC_ROW && layout->row.type != NK_LAYOUT_DYNAMIC_ROW)
		return;

	if (layout->row.type == NK_LAYOUT_DYNAMIC_ROW) {
		float ratio = ratio_or_width;
		if ((ratio + layout->row.filled) > 1.0f) return;
		if (ratio > 0.0f)
			layout->row.item_width = NK_SATURATE(ratio);
		else layout->row.item_width = 1.0f - layout->row.filled;
	}
	else layout->row.item_width = ratio_or_width;
}

NK_API void nk_layout_row_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_STATIC_ROW || layout->row.type == NK_LAYOUT_DYNAMIC_ROW);
	if (layout->row.type != NK_LAYOUT_STATIC_ROW && layout->row.type != NK_LAYOUT_DYNAMIC_ROW)
		return;
	layout->row.item_width = 0;
	layout->row.item_offset = 0;
}

NK_API void
nk_layout_row(struct nk_context* ctx, enum nk_layout_format fmt, float height, int cols, const float* ratio) {
	int i;
	int n_undef = 0;
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	nk_panel_layout(ctx, win, height, cols);
	if (fmt == NK_DYNAMIC) {
		/* calculate width of undefined widget ratios */
		float r = 0;
		layout->row.ratio = ratio;
		for (i = 0; i < cols; ++i) {
			if (ratio[i] < 0.0f)
				n_undef++;
			else r += ratio[i];
		}
		r = NK_SATURATE(1.0f - r);
		layout->row.type = NK_LAYOUT_DYNAMIC;
		layout->row.item_width = (r > 0 && n_undef > 0) ? (r / (float)n_undef) : 0;
	}
	else {
		layout->row.ratio = ratio;
		layout->row.type = NK_LAYOUT_STATIC;
		layout->row.item_width = 0;
		layout->row.item_offset = 0;
	}
	layout->row.item_offset = 0;
	layout->row.filled = 0;
}

NK_API void nk_layout_row_template_begin(struct nk_context* ctx, float height) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	nk_panel_layout(ctx, win, height, 1);
	layout->row.type = NK_LAYOUT_TEMPLATE;
	layout->row.columns = 0;
	layout->row.ratio = 0;
	layout->row.item_width = 0;
	layout->row.item_height = 0;
	layout->row.item_offset = 0;
	layout->row.filled = 0;
	layout->row.item.x = 0;
	layout->row.item.y = 0;
	layout->row.item.w = 0;
	layout->row.item.h = 0;
}

NK_API void nk_layout_row_template_push_dynamic(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
	NK_ASSERT(layout->row.columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
	if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
	if (layout->row.columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS) return;
	layout->row.templates[layout->row.columns++] = -1.0f;
}

NK_API void nk_layout_row_template_push_variable(struct nk_context* ctx, float min_width) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
	NK_ASSERT(layout->row.columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
	if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
	if (layout->row.columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS) return;
	layout->row.templates[layout->row.columns++] = -min_width;
}

NK_API void nk_layout_row_template_push_static(struct nk_context* ctx, float width) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
	NK_ASSERT(layout->row.columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
	if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
	if (layout->row.columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS) return;
	layout->row.templates[layout->row.columns++] = width;
}

NK_API void nk_layout_row_template_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	int i = 0;
	int variable_count = 0;
	int min_variable_count = 0;
	float min_fixed_width = 0.0f;
	float total_fixed_width = 0.0f;
	float max_variable_width = 0.0f;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
	if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
	for (i = 0; i < layout->row.columns; ++i) {
		float width = layout->row.templates[i];
		if (width >= 0.0f) {
			total_fixed_width += width;
			min_fixed_width += width;
		}
		else if (width < -1.0f) {
			width = -width;
			total_fixed_width += width;
			max_variable_width = NK_MAX(max_variable_width, width);
			variable_count++;
		}
		else {
			min_variable_count++;
			variable_count++;
		}
	}
	if (variable_count) {
		float space = nk_layout_row_calculate_usable_space(&ctx->style, layout->type, layout->bounds.w,
			layout->row.columns);
		float var_width = (NK_MAX(space - min_fixed_width, 0.0f)) / (float)variable_count;
		int enough_space = var_width >= max_variable_width;
		if (!enough_space)
			var_width = (NK_MAX(space - total_fixed_width, 0)) / (float)min_variable_count;
		for (i = 0; i < layout->row.columns; ++i) {
			float* width = &layout->row.templates[i];
			*width = (*width >= 0.0f) ? *width : (*width < -1.0f && !enough_space) ? -(*width) : var_width;
		}
	}
}

NK_API void nk_layout_space_begin(struct nk_context* ctx, enum nk_layout_format fmt, float height, int widget_count) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	nk_panel_layout(ctx, win, height, widget_count);
	if (fmt == NK_STATIC)
		layout->row.type = NK_LAYOUT_STATIC_FREE;
	else layout->row.type = NK_LAYOUT_DYNAMIC_FREE;

	layout->row.ratio = 0;
	layout->row.filled = 0;
	layout->row.item_width = 0;
	layout->row.item_offset = 0;
}

NK_API void nk_layout_space_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	layout->row.item_width = 0;
	layout->row.item_height = 0;
	layout->row.item_offset = 0;
	nk_zero(&layout->row.item, sizeof(layout->row.item));
}

NK_API void nk_layout_space_push(struct nk_context* ctx, struct nk_rect rect) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	layout->row.item = rect;
}

NK_API struct nk_rect nk_layout_space_bounds(struct nk_context* ctx) {
	struct nk_rect ret;
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x = layout->clip.x;
	ret.y = layout->clip.y;
	ret.w = layout->clip.w;
	ret.h = layout->row.height;
	return ret;
}

NK_API struct nk_rect nk_layout_widget_bounds(struct nk_context* ctx) {
	struct nk_rect ret;
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x = layout->at_x;
	ret.y = layout->at_y;
	ret.w = layout->bounds.w - NK_MAX(layout->at_x - layout->bounds.x, 0);
	ret.h = layout->row.height;
	return ret;
}

NK_API struct nk_vec2 nk_layout_space_to_screen(struct nk_context* ctx, struct nk_vec2 ret) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x += layout->at_x - (float)*layout->offset_x;
	ret.y += layout->at_y - (float)*layout->offset_y;
	return ret;
}

NK_API struct nk_vec2 nk_layout_space_to_local(struct nk_context* ctx, struct nk_vec2 ret) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x += -layout->at_x + (float)*layout->offset_x;
	ret.y += -layout->at_y + (float)*layout->offset_y;
	return ret;
}

NK_API struct nk_rect nk_layout_space_rect_to_screen(struct nk_context* ctx, struct nk_rect ret) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x += layout->at_x - (float)*layout->offset_x;
	ret.y += layout->at_y - (float)*layout->offset_y;
	return ret;
}

NK_API struct nk_rect nk_layout_space_rect_to_local(struct nk_context* ctx, struct nk_rect ret) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x += -layout->at_x + (float)*layout->offset_x;
	ret.y += -layout->at_y + (float)*layout->offset_y;
	return ret;
}

NK_LIB void nk_panel_alloc_row(const struct nk_context* ctx, struct nk_window* win) {
	struct nk_panel* layout = win->layout;
	struct nk_vec2 spacing = ctx->style.window.spacing;
	const float row_height = layout->row.height - spacing.y;
	nk_panel_layout(ctx, win, row_height, layout->row.columns);
}

NK_LIB void
nk_layout_widget_space(struct nk_rect* bounds, const struct nk_context* ctx, struct nk_window* win, int modify) {
	struct nk_panel* layout;
	const struct nk_style* style;

	struct nk_vec2 spacing;
	struct nk_vec2 padding;

	float item_offset = 0;
	float item_width = 0;
	float item_spacing = 0;
	float panel_space = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	style = &ctx->style;
	NK_ASSERT(bounds);

	spacing = style->window.spacing;
	padding = nk_panel_get_padding(style, layout->type);
	panel_space = nk_layout_row_calculate_usable_space(&ctx->style, layout->type, layout->bounds.w,
		layout->row.columns);

#define NK_FRAC(x) (x - (int)x) /* will be used to remove fookin gaps */
	/* calculate the width of one item inside the current layout space */
	switch (layout->row.type) {
	case NK_LAYOUT_DYNAMIC_FIXED: {
		/* scaling fixed size widgets item width */
		float w = NK_MAX(1.0f, panel_space) / (float)layout->row.columns;
		item_offset = (float)layout->row.index * w;
		item_width = w + NK_FRAC(item_offset);
		item_spacing = (float)layout->row.index * spacing.x;
	}
								break;
	case NK_LAYOUT_DYNAMIC_ROW: {
		/* scaling single ratio widget width */
		float w = layout->row.item_width * panel_space;
		item_offset = layout->row.item_offset;
		item_width = w + NK_FRAC(item_offset);
		item_spacing = 0;

		if (modify) {
			layout->row.item_offset += w + spacing.x;
			layout->row.filled += layout->row.item_width;
			layout->row.index = 0;
		}
	}
							  break;
	case NK_LAYOUT_DYNAMIC_FREE: {
		/* panel width depended free widget placing */
		bounds->x = layout->at_x + (layout->bounds.w * layout->row.item.x);
		bounds->x -= (float)*layout->offset_x;
		bounds->y = layout->at_y + (layout->row.height * layout->row.item.y);
		bounds->y -= (float)*layout->offset_y;
		bounds->w = layout->bounds.w * layout->row.item.w + NK_FRAC(bounds->x);
		bounds->h = layout->row.height * layout->row.item.h + NK_FRAC(bounds->y);
		return;
	}
	case NK_LAYOUT_DYNAMIC: {
		/* scaling arrays of panel width ratios for every widget */
		float ratio, w;
		NK_ASSERT(layout->row.ratio);
		ratio = (layout->row.ratio[layout->row.index] < 0) ? layout->row.item_width
			: layout->row.ratio[layout->row.index];

		w = (ratio * panel_space);
		item_spacing = (float)layout->row.index * spacing.x;
		item_offset = layout->row.item_offset;
		item_width = w + NK_FRAC(item_offset);

		if (modify) {
			layout->row.item_offset += w;
			layout->row.filled += ratio;
		}
	}
						  break;
	case NK_LAYOUT_STATIC_FIXED: {
		/* non-scaling fixed widgets item width */
		item_width = layout->row.item_width;
		item_offset = (float)layout->row.index * item_width;
		item_spacing = (float)layout->row.index * spacing.x;
	}
							   break;
	case NK_LAYOUT_STATIC_ROW: {
		/* scaling single ratio widget width */
		item_width = layout->row.item_width;
		item_offset = layout->row.item_offset;
		item_spacing = (float)layout->row.index * spacing.x;
		if (modify) layout->row.item_offset += item_width;
	}
							 break;
	case NK_LAYOUT_STATIC_FREE: {
		/* free widget placing */
		bounds->x = layout->at_x + layout->row.item.x;
		bounds->w = layout->row.item.w;
		if (((bounds->x + bounds->w) > layout->max_x) && modify)
			layout->max_x = (bounds->x + bounds->w);
		bounds->x -= (float)*layout->offset_x;
		bounds->y = layout->at_y + layout->row.item.y;
		bounds->y -= (float)*layout->offset_y;
		bounds->h = layout->row.item.h;
		return;
	}
	case NK_LAYOUT_STATIC: {
		/* non-scaling array of panel pixel width for every widget */
		item_spacing = (float)layout->row.index * spacing.x;
		item_width = layout->row.ratio[layout->row.index];
		item_offset = layout->row.item_offset;
		if (modify) layout->row.item_offset += item_width;
	}
						 break;
	case NK_LAYOUT_TEMPLATE: {
		/* stretchy row layout with combined dynamic/static widget width*/
		float w;
		NK_ASSERT(layout->row.index < layout->row.columns);
		NK_ASSERT(layout->row.index < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
		w = layout->row.templates[layout->row.index];
		item_offset = layout->row.item_offset;
		item_width = w + NK_FRAC(item_offset);
		item_spacing = (float)layout->row.index * spacing.x;
		if (modify) layout->row.item_offset += w;
	}
						   break;
#undef NK_FRAC
	default:
		NK_ASSERT(0);
		break;
	};

	/* set the bounds of the newly allocated widget */
	bounds->w = item_width;
	bounds->h = layout->row.height - spacing.y;
	bounds->y = layout->at_y - (float)*layout->offset_y;
	bounds->x = layout->at_x + item_offset + item_spacing + padding.x;
	if (((bounds->x + bounds->w) > layout->max_x) && modify)
		layout->max_x = bounds->x + bounds->w;
	bounds->x -= (float)*layout->offset_x;
}

NK_LIB void nk_panel_alloc_space(struct nk_rect* bounds, const struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	/* check if the end of the row has been hit and begin new row if so */
	win = ctx->current;
	layout = win->layout;
	if (layout->row.index >= layout->row.columns)
		nk_panel_alloc_row(ctx, win);

	/* calculate widget position and size */
	nk_layout_widget_space(bounds, ctx, win, nk_true);
	layout->row.index++;
}

NK_LIB void nk_layout_peek(struct nk_rect* bounds, struct nk_context* ctx) {
	float y;
	int index;
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	y = layout->at_y;
	index = layout->row.index;
	if (layout->row.index >= layout->row.columns) {
		layout->at_y += layout->row.height;
		layout->row.index = 0;
	}
	nk_layout_widget_space(bounds, ctx, win, nk_false);
	if (!layout->row.index) {
		bounds->x -= layout->row.item_offset;
	}
	layout->at_y = y;
	layout->row.index = index;
}





/* ===============================================================
 *
 *                              TREE
 *
 * ===============================================================*/
NK_INTERN int
nk_tree_state_base(struct nk_context* ctx, enum nk_tree_type type, struct nk_image* img, const char* title,
	enum nk_collapse_states* state) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_command_buffer* out;
	const struct nk_input* in;
	const struct nk_style_button* button;
	enum nk_symbol_type symbol;
	float row_height;

	struct nk_vec2 item_spacing;
	struct nk_rect header = { 0, 0, 0, 0 };
	struct nk_rect sym = { 0, 0, 0, 0 };
	struct nk_text text;

	nk_flags ws = 0;
	enum nk_widget_layout_states widget_state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	/* cache some data */
	win = ctx->current;
	layout = win->layout;
	out = &win->buffer;
	style = &ctx->style;
	item_spacing = style->window.spacing;

	/* calculate header bounds and draw background */
	row_height = style->font->height + 2 * style->tab.padding.y;
	nk_layout_set_min_row_height(ctx, row_height);
	nk_layout_row_dynamic(ctx, row_height, 1);
	nk_layout_reset_min_row_height(ctx);

	widget_state = nk_widget(&header, ctx);
	if (type == NK_TREE_TAB) {
		const struct nk_style_item* background = &style->tab.background;
		if (background->type == NK_STYLE_ITEM_IMAGE) {
			nk_draw_image(out, header, &background->data.image, nk_white);
			text.background = nk_rgba(0, 0, 0, 0);
		}
		else {
			text.background = background->data.color;
			nk_fill_rect(out, header, 0, style->tab.border_color);
			nk_fill_rect(out, nk_shrink_rect(header, style->tab.border), style->tab.rounding, background->data.color);
		}
	}
	else text.background = style->window.background;

	/* update node state */
	in = (!(layout->flags & NK_WINDOW_ROM)) ? &ctx->input : 0;
	in = (in && widget_state == NK_WIDGET_VALID) ? &ctx->input : 0;
	if (nk_button_behavior(&ws, header, in, NK_BUTTON_DEFAULT))
		*state = (*state == NK_MAXIMIZED) ? NK_MINIMIZED : NK_MAXIMIZED;

	/* select correct button style */
	if (*state == NK_MAXIMIZED) {
		symbol = style->tab.sym_maximize;
		if (type == NK_TREE_TAB)
			button = &style->tab.tab_maximize_button;
		else button = &style->tab.node_maximize_button;
	}
	else {
		symbol = style->tab.sym_minimize;
		if (type == NK_TREE_TAB)
			button = &style->tab.tab_minimize_button;
		else button = &style->tab.node_minimize_button;
	}

	{/* draw triangle button */
		sym.w = sym.h = style->font->height;
		sym.y = header.y + style->tab.padding.y;
		sym.x = header.x + style->tab.padding.x;
		nk_do_button_symbol(&ws, &win->buffer, sym, symbol, NK_BUTTON_DEFAULT, button, 0, style->font);

		if (img) {
			/* draw optional image icon */
			sym.x = sym.x + sym.w + 4 * item_spacing.x;
			nk_draw_image(&win->buffer, sym, img, nk_white);
			sym.w = style->font->height + style->tab.spacing.x;
		}
	}

	{/* draw label */
		struct nk_rect label;
		header.w = NK_MAX(header.w, sym.w + item_spacing.x);
		label.x = sym.x + sym.w + item_spacing.x;
		label.y = sym.y;
		label.w = header.w - (sym.w + item_spacing.y + style->tab.indent);
		label.h = style->font->height;
		text.text = style->tab.text;
		text.padding = nk_vec2(0, 0);
		nk_widget_text(out, label, title, nk_strlen(title), &text, NK_TEXT_LEFT, style->font);
	}

	/* increase x-axis cursor widget position pointer */
	if (*state == NK_MAXIMIZED) {
		layout->at_x = header.x + (float)*layout->offset_x + style->tab.indent;
		layout->bounds.w = NK_MAX(layout->bounds.w, style->tab.indent);
		layout->bounds.w -= (style->tab.indent + style->window.padding.x);
		layout->row.tree_depth++;
		return nk_true;
	}
	else return nk_false;
}

NK_INTERN int nk_tree_base(struct nk_context* ctx, enum nk_tree_type type, struct nk_image* img, const char* title,
	enum nk_collapse_states initial_state, const char* hash, int len, int line) {
	struct nk_window* win = ctx->current;
	int title_len = 0;
	nk_hash tree_hash = 0;
	nk_uint* state = 0;

	/* retrieve tree state from internal widget state tables */
	if (!hash) {
		title_len = (int)nk_strlen(title);
		tree_hash = nk_murmur_hash(title, (int)title_len, (nk_hash)line);
	}
	else tree_hash = nk_murmur_hash(hash, len, (nk_hash)line);
	state = nk_find_value(win, tree_hash);
	if (!state) {
		state = nk_add_value(ctx, win, tree_hash, 0);
		*state = initial_state;
	}
	return nk_tree_state_base(ctx, type, img, title, (enum nk_collapse_states*) state);
}

NK_API int
nk_tree_state_push(struct nk_context* ctx, enum nk_tree_type type, const char* title, enum nk_collapse_states* state) {
	return nk_tree_state_base(ctx, type, 0, title, state);
}

NK_API int
nk_tree_state_image_push(struct nk_context* ctx, enum nk_tree_type type, struct nk_image img, const char* title,
	enum nk_collapse_states* state) {
	return nk_tree_state_base(ctx, type, &img, title, state);
}

NK_API void nk_tree_state_pop(struct nk_context* ctx) {
	struct nk_window* win = 0;
	struct nk_panel* layout = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	layout->at_x -= ctx->style.tab.indent + ctx->style.window.padding.x;
	layout->bounds.w += ctx->style.tab.indent + ctx->style.window.padding.x;
	NK_ASSERT(layout->row.tree_depth);
	layout->row.tree_depth--;
}

NK_API int nk_tree_push_hashed(struct nk_context* ctx, enum nk_tree_type type, const char* title,
	enum nk_collapse_states initial_state, const char* hash, int len, int line) {
	return nk_tree_base(ctx, type, 0, title, initial_state, hash, len, line);
}

NK_API int
nk_tree_image_push_hashed(struct nk_context* ctx, enum nk_tree_type type, struct nk_image img, const char* title,
	enum nk_collapse_states initial_state, const char* hash, int len, int seed) {
	return nk_tree_base(ctx, type, &img, title, initial_state, hash, len, seed);
}

NK_API void nk_tree_pop(struct nk_context* ctx) {
	nk_tree_state_pop(ctx);
}

NK_INTERN int
nk_tree_element_image_push_hashed_base(struct nk_context* ctx, enum nk_tree_type type, struct nk_image* img,
	const char* title, int title_len, enum nk_collapse_states* state,
	int* selected) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_command_buffer* out;
	const struct nk_input* in;
	const struct nk_style_button* button;
	enum nk_symbol_type symbol;
	float row_height;
	struct nk_vec2 padding;

	int text_len;
	float text_width;

	struct nk_vec2 item_spacing;
	struct nk_rect header = { 0, 0, 0, 0 };
	struct nk_rect sym = { 0, 0, 0, 0 };
	struct nk_text text;

	nk_flags ws = 0;
	enum nk_widget_layout_states widget_state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	/* cache some data */
	win = ctx->current;
	layout = win->layout;
	out = &win->buffer;
	style = &ctx->style;
	item_spacing = style->window.spacing;
	padding = style->selectable.padding;

	/* calculate header bounds and draw background */
	row_height = style->font->height + 2 * style->tab.padding.y;
	nk_layout_set_min_row_height(ctx, row_height);
	nk_layout_row_dynamic(ctx, row_height, 1);
	nk_layout_reset_min_row_height(ctx);

	widget_state = nk_widget(&header, ctx);
	if (type == NK_TREE_TAB) {
		const struct nk_style_item* background = &style->tab.background;
		if (background->type == NK_STYLE_ITEM_IMAGE) {
			nk_draw_image(out, header, &background->data.image, nk_white);
			text.background = nk_rgba(0, 0, 0, 0);
		}
		else {
			text.background = background->data.color;
			nk_fill_rect(out, header, 0, style->tab.border_color);
			nk_fill_rect(out, nk_shrink_rect(header, style->tab.border), style->tab.rounding, background->data.color);
		}
	}
	else text.background = style->window.background;

	in = (!(layout->flags & NK_WINDOW_ROM)) ? &ctx->input : 0;
	in = (in && widget_state == NK_WIDGET_VALID) ? &ctx->input : 0;

	/* select correct button style */
	if (*state == NK_MAXIMIZED) {
		symbol = style->tab.sym_maximize;
		if (type == NK_TREE_TAB)
			button = &style->tab.tab_maximize_button;
		else button = &style->tab.node_maximize_button;
	}
	else {
		symbol = style->tab.sym_minimize;
		if (type == NK_TREE_TAB)
			button = &style->tab.tab_minimize_button;
		else button = &style->tab.node_minimize_button;
	}
	{/* draw triangle button */
		sym.w = sym.h = style->font->height;
		sym.y = header.y + style->tab.padding.y;
		sym.x = header.x + style->tab.padding.x;
		if (nk_do_button_symbol(&ws, &win->buffer, sym, symbol, NK_BUTTON_DEFAULT, button, in, style->font))
			*state = (*state == NK_MAXIMIZED) ? NK_MINIMIZED : NK_MAXIMIZED;
	}

	/* draw label */
	{
		nk_flags dummy = 0;
		struct nk_rect label;
		/* calculate size of the text and tooltip */
		text_len = nk_strlen(title);
		text_width = style->font->width(style->font->userdata, style->font->height, title, text_len);
		text_width += (4 * padding.x);

		header.w = NK_MAX(header.w, sym.w + item_spacing.x);
		label.x = sym.x + sym.w + item_spacing.x;
		label.y = sym.y;
		label.w = NK_MIN(header.w - (sym.w + item_spacing.y + style->tab.indent), text_width);
		label.h = style->font->height;

		if (img) {
			nk_do_selectable_image(&dummy, &win->buffer, label, title, title_len, NK_TEXT_LEFT, selected, img,
				&style->selectable, in, style->font);
		}
		else
			nk_do_selectable(&dummy, &win->buffer, label, title, title_len, NK_TEXT_LEFT, selected, &style->selectable,
				in, style->font);
	}
	/* increase x-axis cursor widget position pointer */
	if (*state == NK_MAXIMIZED) {
		layout->at_x = header.x + (float)*layout->offset_x + style->tab.indent;
		layout->bounds.w = NK_MAX(layout->bounds.w, style->tab.indent);
		layout->bounds.w -= (style->tab.indent + style->window.padding.x);
		layout->row.tree_depth++;
		return nk_true;
	}
	else return nk_false;
}

NK_INTERN int
nk_tree_element_base(struct nk_context* ctx, enum nk_tree_type type, struct nk_image* img, const char* title,
	enum nk_collapse_states initial_state, int* selected, const char* hash, int len, int line) {
	struct nk_window* win = ctx->current;
	int title_len = 0;
	nk_hash tree_hash = 0;
	nk_uint* state = 0;

	/* retrieve tree state from internal widget state tables */
	if (!hash) {
		title_len = (int)nk_strlen(title);
		tree_hash = nk_murmur_hash(title, (int)title_len, (nk_hash)line);
	}
	else tree_hash = nk_murmur_hash(hash, len, (nk_hash)line);
	state = nk_find_value(win, tree_hash);
	if (!state) {
		state = nk_add_value(ctx, win, tree_hash, 0);
		*state = initial_state;
	}
	return nk_tree_element_image_push_hashed_base(ctx, type, img, title, nk_strlen(title),
		(enum nk_collapse_states*) state, selected);
}

NK_API int nk_tree_element_push_hashed(struct nk_context* ctx, enum nk_tree_type type, const char* title,
	enum nk_collapse_states initial_state, int* selected, const char* hash, int len,
	int seed) {
	return nk_tree_element_base(ctx, type, 0, title, initial_state, selected, hash, len, seed);
}

NK_API int nk_tree_element_image_push_hashed(struct nk_context* ctx, enum nk_tree_type type, struct nk_image img,
	const char* title, enum nk_collapse_states initial_state, int* selected,
	const char* hash, int len, int seed) {
	return nk_tree_element_base(ctx, type, &img, title, initial_state, selected, hash, len, seed);
}

NK_API void nk_tree_element_pop(struct nk_context* ctx) {
	nk_tree_state_pop(ctx);
}





/* ===============================================================
 *
 *                          GROUP
 *
 * ===============================================================*/
NK_API int
nk_group_scrolled_offset_begin(struct nk_context* ctx, nk_uint* x_offset, nk_uint* y_offset, const char* title,
	nk_flags flags) {
	struct nk_rect bounds;
	struct nk_window panel;
	struct nk_window* win;

	win = ctx->current;
	nk_panel_alloc_space(&bounds, ctx);
	{
		const struct nk_rect* c = &win->layout->clip;
		if (!NK_INTERSECT(c->x, c->y, c->w, c->h, bounds.x, bounds.y, bounds.w, bounds.h) &&
			!(flags & NK_WINDOW_MOVABLE)) {
			return 0;
		}
	}
	if (win->flags & NK_WINDOW_ROM)
		flags |= NK_WINDOW_ROM;

	/* initialize a fake window to create the panel from */
	nk_zero(&panel, sizeof(panel));
	panel.bounds = bounds;
	panel.flags = flags;
	panel.scrollbar.x = *x_offset;
	panel.scrollbar.y = *y_offset;
	panel.buffer = win->buffer;
	panel.layout = (struct nk_panel*) nk_create_panel(ctx);
	ctx->current = &panel;
	nk_panel_begin(ctx, (flags & NK_WINDOW_TITLE) ? title : 0, NK_PANEL_GROUP);

	win->buffer = panel.buffer;
	win->buffer.clip = panel.layout->clip;
	panel.layout->offset_x = x_offset;
	panel.layout->offset_y = y_offset;
	panel.layout->parent = win->layout;
	win->layout = panel.layout;

	ctx->current = win;
	if ((panel.layout->flags & NK_WINDOW_CLOSED) || (panel.layout->flags & NK_WINDOW_MINIMIZED)) {
		nk_flags f = panel.layout->flags;
		nk_group_scrolled_end(ctx);
		if (f & NK_WINDOW_CLOSED)
			return NK_WINDOW_CLOSED;
		if (f & NK_WINDOW_MINIMIZED)
			return NK_WINDOW_MINIMIZED;
	}
	return 1;
}

NK_API void nk_group_scrolled_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* parent;
	struct nk_panel* g;

	struct nk_rect clip;
	struct nk_window pan;
	struct nk_vec2 panel_padding;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return;

	/* make sure nk_group_begin was called correctly */
	NK_ASSERT(ctx->current);
	win = ctx->current;
	NK_ASSERT(win->layout);
	g = win->layout;
	NK_ASSERT(g->parent);
	parent = g->parent;

	/* dummy window */
	nk_zero_struct(pan);
	panel_padding = nk_panel_get_padding(&ctx->style, NK_PANEL_GROUP);
	pan.bounds.y = g->bounds.y - (g->header_height + g->menu.h);
	pan.bounds.x = g->bounds.x - panel_padding.x;
	pan.bounds.w = g->bounds.w + 2 * panel_padding.x;
	pan.bounds.h = g->bounds.h + g->header_height + g->menu.h;
	if (g->flags & NK_WINDOW_BORDER) {
		pan.bounds.x -= g->border;
		pan.bounds.y -= g->border;
		pan.bounds.w += 2 * g->border;
		pan.bounds.h += 2 * g->border;
	}
	if (!(g->flags & NK_WINDOW_NO_SCROLLBAR)) {
		pan.bounds.w += ctx->style.window.scrollbar_size.x;
		pan.bounds.h += ctx->style.window.scrollbar_size.y;
	}
	pan.scrollbar.x = *g->offset_x;
	pan.scrollbar.y = *g->offset_y;
	pan.flags = g->flags;
	pan.buffer = win->buffer;
	pan.layout = g;
	pan.parent = win;
	ctx->current = &pan;

	/* make sure group has correct clipping rectangle */
	nk_unify(&clip, &parent->clip, pan.bounds.x, pan.bounds.y, pan.bounds.x + pan.bounds.w,
		pan.bounds.y + pan.bounds.h + panel_padding.x);
	nk_push_scissor(&pan.buffer, clip);
	nk_end(ctx);

	win->buffer = pan.buffer;
	nk_push_scissor(&win->buffer, parent->clip);
	ctx->current = win;
	win->layout = parent;
	g->bounds = pan.bounds;
	return;
}

NK_API int
nk_group_scrolled_begin(struct nk_context* ctx, struct nk_scroll* scroll, const char* title, nk_flags flags) {
	return nk_group_scrolled_offset_begin(ctx, &scroll->x, &scroll->y, title, flags);
}

NK_API int nk_group_begin_titled(struct nk_context* ctx, const char* id, const char* title, nk_flags flags) {
	int id_len;
	nk_hash id_hash;
	struct nk_window* win;
	nk_uint* x_offset;
	nk_uint* y_offset;

	NK_ASSERT(ctx);
	NK_ASSERT(id);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !id)
		return 0;

	/* find persistent group scrollbar value */
	win = ctx->current;
	id_len = (int)nk_strlen(id);
	id_hash = nk_murmur_hash(id, (int)id_len, NK_PANEL_GROUP);
	x_offset = nk_find_value(win, id_hash);
	if (!x_offset) {
		x_offset = nk_add_value(ctx, win, id_hash, 0);
		y_offset = nk_add_value(ctx, win, id_hash + 1, 0);

		NK_ASSERT(x_offset);
		NK_ASSERT(y_offset);
		if (!x_offset || !y_offset) return 0;
		*x_offset = *y_offset = 0;
	}
	else y_offset = nk_find_value(win, id_hash + 1);
	return nk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags);
}

NK_API int nk_group_begin(struct nk_context* ctx, const char* title, nk_flags flags) {
	return nk_group_begin_titled(ctx, title, title, flags);
}

NK_API void nk_group_end(struct nk_context* ctx) {
	nk_group_scrolled_end(ctx);
}





/* ===============================================================
 *
 *                          LIST VIEW
 *
 * ===============================================================*/
NK_API int
nk_list_view_begin(struct nk_context* ctx, struct nk_list_view* view, const char* title, nk_flags flags, int row_height,
	int row_count) {
	int title_len;
	nk_hash title_hash;
	nk_uint* x_offset;
	nk_uint* y_offset;

	int result;
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_vec2 item_spacing;

	NK_ASSERT(ctx);
	NK_ASSERT(view);
	NK_ASSERT(title);
	if (!ctx || !view || !title) return 0;

	win = ctx->current;
	style = &ctx->style;
	item_spacing = style->window.spacing;
	row_height += NK_MAX(0, (int)item_spacing.y);

	/* find persistent list view scrollbar offset */
	title_len = (int)nk_strlen(title);
	title_hash = nk_murmur_hash(title, (int)title_len, NK_PANEL_GROUP);
	x_offset = nk_find_value(win, title_hash);
	if (!x_offset) {
		x_offset = nk_add_value(ctx, win, title_hash, 0);
		y_offset = nk_add_value(ctx, win, title_hash + 1, 0);

		NK_ASSERT(x_offset);
		NK_ASSERT(y_offset);
		if (!x_offset || !y_offset) return 0;
		*x_offset = *y_offset = 0;
	}
	else y_offset = nk_find_value(win, title_hash + 1);
	view->scroll_value = *y_offset;
	view->scroll_pointer = y_offset;

	*y_offset = 0;
	result = nk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags);
	win = ctx->current;
	layout = win->layout;

	view->total_height = row_height * NK_MAX(row_count, 1);
	view->begin = (int)NK_MAX(((float)view->scroll_value / (float)row_height), 0.0f);
	view->count = (int)NK_MAX(nk_iceilf((layout->clip.h) / (float)row_height), 0);
	view->count = NK_MIN(view->count, row_count - view->begin);
	view->end = view->begin + view->count;
	view->ctx = ctx;
	return result;
}

NK_API void nk_list_view_end(struct nk_list_view* view) {
	struct nk_context* ctx;
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(view);
	NK_ASSERT(view->ctx);
	NK_ASSERT(view->scroll_pointer);
	if (!view || !view->ctx) return;

	ctx = view->ctx;
	win = ctx->current;
	layout = win->layout;
	layout->at_y = layout->bounds.y + (float)view->total_height;
	*view->scroll_pointer = *view->scroll_pointer + view->scroll_value;
	nk_group_end(view->ctx);
}





/* ===============================================================
 *
 *                              WIDGET
 *
 * ===============================================================*/
NK_API struct nk_rect nk_widget_bounds(struct nk_context* ctx) {
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return nk_rect(0, 0, 0, 0);
	nk_layout_peek(&bounds, ctx);
	return bounds;
}

NK_API struct nk_vec2 nk_widget_position(struct nk_context* ctx) {
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return nk_vec2(0, 0);

	nk_layout_peek(&bounds, ctx);
	return nk_vec2(bounds.x, bounds.y);
}

NK_API struct nk_vec2 nk_widget_size(struct nk_context* ctx) {
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return nk_vec2(0, 0);

	nk_layout_peek(&bounds, ctx);
	return nk_vec2(bounds.w, bounds.h);
}

NK_API float nk_widget_width(struct nk_context* ctx) {
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return 0;

	nk_layout_peek(&bounds, ctx);
	return bounds.w;
}

NK_API float nk_widget_height(struct nk_context* ctx) {
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return 0;

	nk_layout_peek(&bounds, ctx);
	return bounds.h;
}

NK_API int nk_widget_is_hovered(struct nk_context* ctx) {
	struct nk_rect c, v;
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current || ctx->active != ctx->current)
		return 0;

	c = ctx->current->layout->clip;
	c.x = (float)((int)c.x);
	c.y = (float)((int)c.y);
	c.w = (float)((int)c.w);
	c.h = (float)((int)c.h);

	nk_layout_peek(&bounds, ctx);
	nk_unify(&v, &c, bounds.x, bounds.y, bounds.x + bounds.w, bounds.y + bounds.h);
	if (!NK_INTERSECT(c.x, c.y, c.w, c.h, bounds.x, bounds.y, bounds.w, bounds.h))
		return 0;
	return nk_input_is_mouse_hovering_rect(&ctx->input, bounds);
}

NK_API int nk_widget_is_mouse_clicked(struct nk_context* ctx, enum nk_buttons btn) {
	struct nk_rect c, v;
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current || ctx->active != ctx->current)
		return 0;

	c = ctx->current->layout->clip;
	c.x = (float)((int)c.x);
	c.y = (float)((int)c.y);
	c.w = (float)((int)c.w);
	c.h = (float)((int)c.h);

	nk_layout_peek(&bounds, ctx);
	nk_unify(&v, &c, bounds.x, bounds.y, bounds.x + bounds.w, bounds.y + bounds.h);
	if (!NK_INTERSECT(c.x, c.y, c.w, c.h, bounds.x, bounds.y, bounds.w, bounds.h))
		return 0;
	return nk_input_mouse_clicked(&ctx->input, btn, bounds);
}

NK_API int nk_widget_has_mouse_click_down(struct nk_context* ctx, enum nk_buttons btn, int down) {
	struct nk_rect c, v;
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current || ctx->active != ctx->current)
		return 0;

	c = ctx->current->layout->clip;
	c.x = (float)((int)c.x);
	c.y = (float)((int)c.y);
	c.w = (float)((int)c.w);
	c.h = (float)((int)c.h);

	nk_layout_peek(&bounds, ctx);
	nk_unify(&v, &c, bounds.x, bounds.y, bounds.x + bounds.w, bounds.y + bounds.h);
	if (!NK_INTERSECT(c.x, c.y, c.w, c.h, bounds.x, bounds.y, bounds.w, bounds.h))
		return 0;
	return nk_input_has_mouse_click_down_in_rect(&ctx->input, btn, bounds, down);
}

NK_API enum nk_widget_layout_states nk_widget(struct nk_rect* bounds, const struct nk_context* ctx) {
	struct nk_rect c, v;
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return NK_WIDGET_INVALID;

	/* allocate space and check if the widget needs to be updated and drawn */
	nk_panel_alloc_space(bounds, ctx);
	win = ctx->current;
	layout = win->layout;
	in = &ctx->input;
	c = layout->clip;

	/*  if one of these triggers you forgot to add an `if` condition around either
		a window, group, popup, combobox or contextual menu `begin` and `end` block.
		Example:
			if (nk_begin(...) {...} nk_end(...); or
			if (nk_group_begin(...) { nk_group_end(...);} */
	NK_ASSERT(!(layout->flags & NK_WINDOW_MINIMIZED));
	NK_ASSERT(!(layout->flags & NK_WINDOW_HIDDEN));
	NK_ASSERT(!(layout->flags & NK_WINDOW_CLOSED));

	/* need to convert to int here to remove floating point errors */
	bounds->x = (float)((int)bounds->x);
	bounds->y = (float)((int)bounds->y);
	bounds->w = (float)((int)bounds->w);
	bounds->h = (float)((int)bounds->h);

	c.x = (float)((int)c.x);
	c.y = (float)((int)c.y);
	c.w = (float)((int)c.w);
	c.h = (float)((int)c.h);

	nk_unify(&v, &c, bounds->x, bounds->y, bounds->x + bounds->w, bounds->y + bounds->h);
	if (!NK_INTERSECT(c.x, c.y, c.w, c.h, bounds->x, bounds->y, bounds->w, bounds->h))
		return NK_WIDGET_INVALID;
	if (!NK_INBOX(in->mouse.pos.x, in->mouse.pos.y, v.x, v.y, v.w, v.h))
		return NK_WIDGET_ROM;
	return NK_WIDGET_VALID;
}

NK_API enum nk_widget_layout_states
nk_widget_fitting(struct nk_rect* bounds, struct nk_context* ctx, struct nk_vec2 item_padding) {
	/* update the bounds to stand without padding  */
	struct nk_window* win;
	struct nk_style* style;
	struct nk_panel* layout;
	enum nk_widget_layout_states state;
	struct nk_vec2 panel_padding;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return NK_WIDGET_INVALID;

	win = ctx->current;
	style = &ctx->style;
	layout = win->layout;
	state = nk_widget(bounds, ctx);

	panel_padding = nk_panel_get_padding(style, layout->type);
	if (layout->row.index == 1) {
		bounds->w += panel_padding.x;
		bounds->x -= panel_padding.x;
	}
	else bounds->x -= item_padding.x;

	if (layout->row.index == layout->row.columns)
		bounds->w += panel_padding.x;
	else bounds->w += item_padding.x;
	return state;
}

NK_API void nk_spacing(struct nk_context* ctx, int cols) {
	struct nk_window* win;
	struct nk_panel* layout;
	struct nk_rect none;
	int i, index, rows;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	/* spacing over row boundaries */
	win = ctx->current;
	layout = win->layout;
	index = (layout->row.index + cols) % layout->row.columns;
	rows = (layout->row.index + cols) / layout->row.columns;
	if (rows) {
		for (i = 0; i < rows; ++i)
			nk_panel_alloc_row(ctx, win);
		cols = index;
	}
	/* non table layout need to allocate space */
	if (layout->row.type != NK_LAYOUT_DYNAMIC_FIXED && layout->row.type != NK_LAYOUT_STATIC_FIXED) {
		for (i = 0; i < cols; ++i)
			nk_panel_alloc_space(&none, ctx);
	}
	layout->row.index = index;
}





/* ===============================================================
 *
 *                              TEXT
 *
 * ===============================================================*/
NK_LIB void
nk_widget_text(struct nk_command_buffer* o, struct nk_rect b, const char* string, int len, const struct nk_text* t,
	nk_flags a, const struct nk_user_font* f) {
	struct nk_rect label;
	float text_width;

	NK_ASSERT(o);
	NK_ASSERT(t);
	if (!o || !t) return;

	b.h = NK_MAX(b.h, 2 * t->padding.y);
	label.x = 0;
	label.w = 0;
	label.y = b.y + t->padding.y;
	label.h = NK_MIN(f->height, b.h - 2 * t->padding.y);

	text_width = f->width(f->userdata, f->height, (const char*)string, len);
	text_width += (2.0f * t->padding.x);

	/* align in x-axis */
	if (a & NK_TEXT_ALIGN_LEFT) {
		label.x = b.x + t->padding.x;
		label.w = NK_MAX(0, b.w - 2 * t->padding.x);
	}
	else if (a & NK_TEXT_ALIGN_CENTERED) {
		label.w = NK_MAX(1, 2 * t->padding.x + (float)text_width);
		label.x = (b.x + t->padding.x + ((b.w - 2 * t->padding.x) - label.w) / 2);
		label.x = NK_MAX(b.x + t->padding.x, label.x);
		label.w = NK_MIN(b.x + b.w, label.x + label.w);
		if (label.w >= label.x) label.w -= label.x;
	}
	else if (a & NK_TEXT_ALIGN_RIGHT) {
		label.x = NK_MAX(b.x + t->padding.x, (b.x + b.w) - (2 * t->padding.x + (float)text_width));
		label.w = (float)text_width + 2 * t->padding.x;
	}
	else return;

	/* align in y-axis */
	if (a & NK_TEXT_ALIGN_MIDDLE) {
		label.y = b.y + b.h / 2.0f - (float)f->height / 2.0f;
		label.h = NK_MAX(b.h / 2.0f, b.h - (b.h / 2.0f + f->height / 2.0f));
	}
	else if (a & NK_TEXT_ALIGN_BOTTOM) {
		label.y = b.y + b.h - f->height;
		label.h = f->height;
	}
	nk_draw_text(o, label, (const char*)string, len, f, t->background, t->text);
}

NK_LIB void
nk_widget_text_wrap(struct nk_command_buffer* o, struct nk_rect b, const char* string, int len, const struct nk_text* t,
	const struct nk_user_font* f) {
	float width;
	int glyphs = 0;
	int fitting = 0;
	int done = 0;
	struct nk_rect line;
	struct nk_text text;
	NK_INTERN nk_rune seperator[] = { ' ' };

	NK_ASSERT(o);
	NK_ASSERT(t);
	if (!o || !t) return;

	text.padding = nk_vec2(0, 0);
	text.background = t->background;
	text.text = t->text;

	b.w = NK_MAX(b.w, 2 * t->padding.x);
	b.h = NK_MAX(b.h, 2 * t->padding.y);
	b.h = b.h - 2 * t->padding.y;

	line.x = b.x + t->padding.x;
	line.y = b.y + t->padding.y;
	line.w = b.w - 2 * t->padding.x;
	line.h = 2 * t->padding.y + f->height;

	fitting = nk_text_clamp(f, string, len, line.w, &glyphs, &width, seperator, NK_LEN(seperator));
	while (done < len) {
		if (!fitting || line.y + line.h >= (b.y + b.h)) break;
		nk_widget_text(o, line, &string[done], fitting, &text, NK_TEXT_LEFT, f);
		done += fitting;
		line.y += f->height + 2 * t->padding.y;
		fitting = nk_text_clamp(f, &string[done], len - done, line.w, &glyphs, &width, seperator, NK_LEN(seperator));
	}
}

NK_API void
nk_text_colored(struct nk_context* ctx, const char* str, int len, nk_flags alignment, struct nk_color color) {
	struct nk_window* win;
	const struct nk_style* style;

	struct nk_vec2 item_padding;
	struct nk_rect bounds;
	struct nk_text text;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return;

	win = ctx->current;
	style = &ctx->style;
	nk_panel_alloc_space(&bounds, ctx);
	item_padding = style->text.padding;

	text.padding.x = item_padding.x;
	text.padding.y = item_padding.y;
	text.background = style->window.background;
	text.text = color;
	nk_widget_text(&win->buffer, bounds, str, len, &text, alignment, style->font);
}

NK_API void nk_text_wrap_colored(struct nk_context* ctx, const char* str, int len, struct nk_color color) {
	struct nk_window* win;
	const struct nk_style* style;

	struct nk_vec2 item_padding;
	struct nk_rect bounds;
	struct nk_text text;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return;

	win = ctx->current;
	style = &ctx->style;
	nk_panel_alloc_space(&bounds, ctx);
	item_padding = style->text.padding;

	text.padding.x = item_padding.x;
	text.padding.y = item_padding.y;
	text.background = style->window.background;
	text.text = color;
	nk_widget_text_wrap(&win->buffer, bounds, str, len, &text, style->font);
}

#ifdef NK_INCLUDE_STANDARD_VARARGS

NK_API void nk_labelf_colored(struct nk_context* ctx, nk_flags flags, struct nk_color color, const char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	nk_labelfv_colored(ctx, flags, color, fmt, args);
	va_end(args);
}

NK_API void nk_labelf_colored_wrap(struct nk_context* ctx, struct nk_color color, const char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	nk_labelfv_colored_wrap(ctx, color, fmt, args);
	va_end(args);
}

NK_API void nk_labelf(struct nk_context* ctx, nk_flags flags, const char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	nk_labelfv(ctx, flags, fmt, args);
	va_end(args);
}

NK_API void nk_labelf_wrap(struct nk_context* ctx, const char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	nk_labelfv_wrap(ctx, fmt, args);
	va_end(args);
}

NK_API void
nk_labelfv_colored(struct nk_context* ctx, nk_flags flags, struct nk_color color, const char* fmt, va_list args) {
	char buf[256];
	nk_strfmt(buf, NK_LEN(buf), fmt, args);
	nk_label_colored(ctx, buf, flags, color);
}

NK_API void nk_labelfv_colored_wrap(struct nk_context* ctx, struct nk_color color, const char* fmt, va_list args) {
	char buf[256];
	nk_strfmt(buf, NK_LEN(buf), fmt, args);
	nk_label_colored_wrap(ctx, buf, color);
}

NK_API void nk_labelfv(struct nk_context* ctx, nk_flags flags, const char* fmt, va_list args) {
	char buf[256];
	nk_strfmt(buf, NK_LEN(buf), fmt, args);
	nk_label(ctx, buf, flags);
}

NK_API void nk_labelfv_wrap(struct nk_context* ctx, const char* fmt, va_list args) {
	char buf[256];
	nk_strfmt(buf, NK_LEN(buf), fmt, args);
	nk_label_wrap(ctx, buf);
}

NK_API void nk_value_bool(struct nk_context* ctx, const char* prefix, int value) {
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: %s", prefix, ((value) ? "true" : "false"));
}

NK_API void nk_value_int(struct nk_context* ctx, const char* prefix, int value) {
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: %d", prefix, value);
}

NK_API void nk_value_uint(struct nk_context* ctx, const char* prefix, unsigned int value) {
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: %u", prefix, value);
}

NK_API void nk_value_float(struct nk_context* ctx, const char* prefix, float value) {
	double double_value = (double)value;
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: %.3f", prefix, double_value);
}

NK_API void nk_value_color_byte(struct nk_context* ctx, const char* p, struct nk_color c) {
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: (%d, %d, %d, %d)", p, c.r, c.g, c.b, c.a);
}

NK_API void nk_value_color_float(struct nk_context* ctx, const char* p, struct nk_color color) {
	double c[4];
	nk_color_dv(c, color);
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: (%.2f, %.2f, %.2f, %.2f)", p, c[0], c[1], c[2], c[3]);
}

NK_API void nk_value_color_hex(struct nk_context* ctx, const char* prefix, struct nk_color color) {
	char hex[16];
	nk_color_hex_rgba(hex, color);
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: %s", prefix, hex);
}

#endif

NK_API void nk_text(struct nk_context* ctx, const char* str, int len, nk_flags alignment) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	nk_text_colored(ctx, str, len, alignment, ctx->style.text.color);
}

NK_API void nk_text_wrap(struct nk_context* ctx, const char* str, int len) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	nk_text_wrap_colored(ctx, str, len, ctx->style.text.color);
}

NK_API void nk_label(struct nk_context* ctx, const char* str, nk_flags alignment) {
	nk_text(ctx, str, nk_strlen(str), alignment);
}

NK_API void nk_label_colored(struct nk_context* ctx, const char* str, nk_flags align, struct nk_color color) {
	nk_text_colored(ctx, str, nk_strlen(str), align, color);
}

NK_API void nk_label_wrap(struct nk_context* ctx, const char* str) {
	nk_text_wrap(ctx, str, nk_strlen(str));
}

NK_API void nk_label_colored_wrap(struct nk_context* ctx, const char* str, struct nk_color color) {
	nk_text_wrap_colored(ctx, str, nk_strlen(str), color);
}





/* ===============================================================
 *
 *                          IMAGE
 *
 * ===============================================================*/
NK_API nk_handle nk_handle_ptr(void* ptr) {
	nk_handle handle = { 0 };
	handle.ptr = ptr;
	return handle;
}

NK_API nk_handle nk_handle_id(int id) {
	nk_handle handle;
	nk_zero_struct(handle);
	handle.id = id;
	return handle;
}

NK_API struct nk_image nk_subimage_ptr(void* ptr, unsigned short w, unsigned short h, struct nk_rect r) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	s.handle.ptr = ptr;
	s.w = w;
	s.h = h;
	s.region[0] = (unsigned short)r.x;
	s.region[1] = (unsigned short)r.y;
	s.region[2] = (unsigned short)r.w;
	s.region[3] = (unsigned short)r.h;
	return s;
}

NK_API struct nk_image nk_subimage_id(int id, unsigned short w, unsigned short h, struct nk_rect r) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	s.handle.id = id;
	s.w = w;
	s.h = h;
	s.region[0] = (unsigned short)r.x;
	s.region[1] = (unsigned short)r.y;
	s.region[2] = (unsigned short)r.w;
	s.region[3] = (unsigned short)r.h;
	return s;
}

NK_API struct nk_image nk_subimage_handle(nk_handle handle, unsigned short w, unsigned short h, struct nk_rect r) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	s.handle = handle;
	s.w = w;
	s.h = h;
	s.region[0] = (unsigned short)r.x;
	s.region[1] = (unsigned short)r.y;
	s.region[2] = (unsigned short)r.w;
	s.region[3] = (unsigned short)r.h;
	return s;
}

NK_API struct nk_image nk_image_handle(nk_handle handle) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	s.handle = handle;
	s.w = 0;
	s.h = 0;
	s.region[0] = 0;
	s.region[1] = 0;
	s.region[2] = 0;
	s.region[3] = 0;
	return s;
}

NK_API struct nk_image nk_image_ptr(void* ptr) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	NK_ASSERT(ptr);
	s.handle.ptr = ptr;
	s.w = 0;
	s.h = 0;
	s.region[0] = 0;
	s.region[1] = 0;
	s.region[2] = 0;
	s.region[3] = 0;
	return s;
}

NK_API struct nk_image nk_image_id(int id) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	s.handle.id = id;
	s.w = 0;
	s.h = 0;
	s.region[0] = 0;
	s.region[1] = 0;
	s.region[2] = 0;
	s.region[3] = 0;
	return s;
}

NK_API int nk_image_is_subimage(const struct nk_image* img) {
	NK_ASSERT(img);
	return !(img->w == 0 && img->h == 0);
}

NK_API void nk_image(struct nk_context* ctx, struct nk_image img) {
	struct nk_window* win;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return;

	win = ctx->current;
	if (!nk_widget(&bounds, ctx)) return;
	nk_draw_image(&win->buffer, bounds, &img, nk_white);
}

NK_API void nk_image_color(struct nk_context* ctx, struct nk_image img, struct nk_color col) {
	struct nk_window* win;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return;

	win = ctx->current;
	if (!nk_widget(&bounds, ctx)) return;
	nk_draw_image(&win->buffer, bounds, &img, col);
}





/* ==============================================================
 *
 *                          BUTTON
 *
 * ===============================================================*/
NK_LIB void nk_draw_symbol(struct nk_command_buffer* out, enum nk_symbol_type type, struct nk_rect content,
	struct nk_color background, struct nk_color foreground, float border_width,
	const struct nk_user_font* font) {
	switch (type) {
	case NK_SYMBOL_X:
	case NK_SYMBOL_UNDERSCORE:
	case NK_SYMBOL_PLUS:
	case NK_SYMBOL_MINUS: {
		/* single character text symbol */
		const char* X = (type == NK_SYMBOL_X) ? "x" : (type == NK_SYMBOL_UNDERSCORE) ? "_" : (type ==
			NK_SYMBOL_PLUS) ? "+"
			: "-";
		struct nk_text text;
		text.padding = nk_vec2(0, 0);
		text.background = background;
		text.text = foreground;
		nk_widget_text(out, content, X, 1, &text, NK_TEXT_CENTERED, font);
	}
						break;
	case NK_SYMBOL_CIRCLE_SOLID:
	case NK_SYMBOL_CIRCLE_OUTLINE:
	case NK_SYMBOL_RECT_SOLID:
	case NK_SYMBOL_RECT_OUTLINE: {
		/* simple empty/filled shapes */
		if (type == NK_SYMBOL_RECT_SOLID || type == NK_SYMBOL_RECT_OUTLINE) {
			nk_fill_rect(out, content, 0, foreground);
			if (type == NK_SYMBOL_RECT_OUTLINE)
				nk_fill_rect(out, nk_shrink_rect(content, border_width), 0, background);
		}
		else {
			nk_fill_circle(out, content, foreground);
			if (type == NK_SYMBOL_CIRCLE_OUTLINE)
				nk_fill_circle(out, nk_shrink_rect(content, 1), background);
		}
	}
							   break;
	case NK_SYMBOL_TRIANGLE_UP:
	case NK_SYMBOL_TRIANGLE_DOWN:
	case NK_SYMBOL_TRIANGLE_LEFT:
	case NK_SYMBOL_TRIANGLE_RIGHT: {
		enum nk_heading heading;
		struct nk_vec2 points[3];
		heading = (type == NK_SYMBOL_TRIANGLE_RIGHT) ? NK_RIGHT : (type == NK_SYMBOL_TRIANGLE_LEFT) ? NK_LEFT
			: (type ==
				NK_SYMBOL_TRIANGLE_UP)
			? NK_UP
			: NK_DOWN;
		nk_triangle_from_direction(points, content, 0, 0, heading);
		nk_fill_triangle(out, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y,
			foreground);
	}
								 break;
	default:
	case NK_SYMBOL_NONE:
	case NK_SYMBOL_MAX:
		break;
	}
}

NK_LIB int
nk_button_behavior(nk_flags* state, struct nk_rect r, const struct nk_input* i, enum nk_button_behavior behavior) {
	int ret = 0;
	nk_widget_state_reset(state);
	if (!i) return 0;
	if (nk_input_is_mouse_hovering_rect(i, r)) {
		*state = NK_WIDGET_STATE_HOVERED;
		if (nk_input_is_mouse_down(i, NK_BUTTON_LEFT))
			*state = NK_WIDGET_STATE_ACTIVE;
		if (nk_input_has_mouse_click_in_rect(i, NK_BUTTON_LEFT, r)) {
			ret = (behavior != NK_BUTTON_DEFAULT) ? nk_input_is_mouse_down(i, NK_BUTTON_LEFT) :
#ifdef NK_BUTTON_TRIGGER_ON_RELEASE
				nk_input_is_mouse_released(i, NK_BUTTON_LEFT);
#else
				nk_input_is_mouse_pressed(i, NK_BUTTON_LEFT);
#endif
		}
	}
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(i, r))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(i, r))
		*state |= NK_WIDGET_STATE_LEFT;
	return ret;
}

NK_LIB const struct nk_style_item*
nk_draw_button(struct nk_command_buffer* out, const struct nk_rect* bounds, nk_flags state,
	const struct nk_style_button* style) {
	const struct nk_style_item* background;
	if (state & NK_WIDGET_STATE_HOVER)
		background = &style->hover;
	else if (state & NK_WIDGET_STATE_ACTIVED)
		background = &style->active;
	else background = &style->normal;

	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(out, *bounds, &background->data.image, nk_white);
	}
	else {
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
	}
	return background;
}

NK_LIB int
nk_do_button(nk_flags* state, struct nk_command_buffer* out, struct nk_rect r, const struct nk_style_button* style,
	const struct nk_input* in, enum nk_button_behavior behavior, struct nk_rect* content) {
	struct nk_rect bounds;
	NK_ASSERT(style);
	NK_ASSERT(state);
	NK_ASSERT(out);
	if (!out || !style)
		return nk_false;

	/* calculate button content space */
	content->x = r.x + style->padding.x + style->border + style->rounding;
	content->y = r.y + style->padding.y + style->border + style->rounding;
	content->w = r.w - (2 * style->padding.x + style->border + style->rounding * 2);
	content->h = r.h - (2 * style->padding.y + style->border + style->rounding * 2);

	/* execute button behavior */
	bounds.x = r.x - style->touch_padding.x;
	bounds.y = r.y - style->touch_padding.y;
	bounds.w = r.w + 2 * style->touch_padding.x;
	bounds.h = r.h + 2 * style->touch_padding.y;
	return nk_button_behavior(state, bounds, in, behavior);
}

NK_LIB void
nk_draw_button_text(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, const char* txt, int len,
	nk_flags text_alignment, const struct nk_user_font* font) {
	struct nk_text text;
	const struct nk_style_item* background;
	background = nk_draw_button(out, bounds, state, style);

	/* select correct colors/images */
	if (background->type == NK_STYLE_ITEM_COLOR)
		text.background = background->data.color;
	else text.background = style->text_background;
	if (state & NK_WIDGET_STATE_HOVER)
		text.text = style->text_hover;
	else if (state & NK_WIDGET_STATE_ACTIVED)
		text.text = style->text_active;
	else text.text = style->text_normal;

	text.padding = nk_vec2(0, 0);
	nk_widget_text(out, *content, txt, len, &text, text_alignment, font);
}

NK_LIB int
nk_do_button_text(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* string, int len,
	nk_flags align, enum nk_button_behavior behavior, const struct nk_style_button* style,
	const struct nk_input* in, const struct nk_user_font* font) {
	struct nk_rect content;
	int ret = nk_false;

	NK_ASSERT(state);
	NK_ASSERT(style);
	NK_ASSERT(out);
	NK_ASSERT(string);
	NK_ASSERT(font);
	if (!out || !style || !font || !string)
		return nk_false;

	ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_button_text(out, &bounds, &content, *state, style, string, len, align, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return ret;
}

NK_LIB void
nk_draw_button_symbol(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, enum nk_symbol_type type,
	const struct nk_user_font* font) {
	struct nk_color sym, bg;
	const struct nk_style_item* background;

	/* select correct colors/images */
	background = nk_draw_button(out, bounds, state, style);
	if (background->type == NK_STYLE_ITEM_COLOR)
		bg = background->data.color;
	else bg = style->text_background;

	if (state & NK_WIDGET_STATE_HOVER)
		sym = style->text_hover;
	else if (state & NK_WIDGET_STATE_ACTIVED)
		sym = style->text_active;
	else sym = style->text_normal;
	nk_draw_symbol(out, type, *content, bg, sym, 1, font);
}

NK_LIB int
nk_do_button_symbol(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, enum nk_symbol_type symbol,
	enum nk_button_behavior behavior, const struct nk_style_button* style, const struct nk_input* in,
	const struct nk_user_font* font) {
	int ret;
	struct nk_rect content;

	NK_ASSERT(state);
	NK_ASSERT(style);
	NK_ASSERT(font);
	NK_ASSERT(out);
	if (!out || !style || !font || !state)
		return nk_false;

	ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_button_symbol(out, &bounds, &content, *state, style, symbol, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return ret;
}

NK_LIB void
nk_draw_button_image(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, const struct nk_image* img) {
	nk_draw_button(out, bounds, state, style);
	nk_draw_image(out, *content, img, nk_white);
}

NK_LIB int
nk_do_button_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, struct nk_image img,
	enum nk_button_behavior b, const struct nk_style_button* style, const struct nk_input* in) {
	int ret;
	struct nk_rect content;

	NK_ASSERT(state);
	NK_ASSERT(style);
	NK_ASSERT(out);
	if (!out || !style || !state)
		return nk_false;

	ret = nk_do_button(state, out, bounds, style, in, b, &content);
	content.x += style->image_padding.x;
	content.y += style->image_padding.y;
	content.w -= 2 * style->image_padding.x;
	content.h -= 2 * style->image_padding.y;

	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_button_image(out, &bounds, &content, *state, style, &img);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return ret;
}

NK_LIB void
nk_draw_button_text_symbol(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* label,
	const struct nk_rect* symbol, nk_flags state, const struct nk_style_button* style,
	const char* str, int len, enum nk_symbol_type type, const struct nk_user_font* font) {
	struct nk_color sym;
	struct nk_text text;
	const struct nk_style_item* background;

	/* select correct background colors/images */
	background = nk_draw_button(out, bounds, state, style);
	if (background->type == NK_STYLE_ITEM_COLOR)
		text.background = background->data.color;
	else text.background = style->text_background;

	/* select correct text colors */
	if (state & NK_WIDGET_STATE_HOVER) {
		sym = style->text_hover;
		text.text = style->text_hover;
	}
	else if (state & NK_WIDGET_STATE_ACTIVED) {
		sym = style->text_active;
		text.text = style->text_active;
	}
	else {
		sym = style->text_normal;
		text.text = style->text_normal;
	}

	text.padding = nk_vec2(0, 0);
	nk_draw_symbol(out, type, *symbol, style->text_background, sym, 0, font);
	nk_widget_text(out, *label, str, len, &text, NK_TEXT_CENTERED, font);
}

NK_LIB int nk_do_button_text_symbol(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds,
	enum nk_symbol_type symbol, const char* str, int len, nk_flags align,
	enum nk_button_behavior behavior, const struct nk_style_button* style,
	const struct nk_user_font* font, const struct nk_input* in) {
	int ret;
	struct nk_rect tri = { 0, 0, 0, 0 };
	struct nk_rect content;

	NK_ASSERT(style);
	NK_ASSERT(out);
	NK_ASSERT(font);
	if (!out || !style || !font)
		return nk_false;

	ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
	tri.y = content.y + (content.h / 2) - font->height / 2;
	tri.w = font->height;
	tri.h = font->height;
	if (align & NK_TEXT_ALIGN_LEFT) {
		tri.x = (content.x + content.w) - (2 * style->padding.x + tri.w);
		tri.x = NK_MAX(tri.x, 0);
	}
	else tri.x = content.x + 2 * style->padding.x;

	/* draw button */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_button_text_symbol(out, &bounds, &content, &tri, *state, style, str, len, symbol, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return ret;
}

NK_LIB void
nk_draw_button_text_image(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* label,
	const struct nk_rect* image, nk_flags state, const struct nk_style_button* style,
	const char* str, int len, const struct nk_user_font* font, const struct nk_image* img) {
	struct nk_text text;
	const struct nk_style_item* background;
	background = nk_draw_button(out, bounds, state, style);

	/* select correct colors */
	if (background->type == NK_STYLE_ITEM_COLOR)
		text.background = background->data.color;
	else text.background = style->text_background;
	if (state & NK_WIDGET_STATE_HOVER)
		text.text = style->text_hover;
	else if (state & NK_WIDGET_STATE_ACTIVED)
		text.text = style->text_active;
	else text.text = style->text_normal;

	text.padding = nk_vec2(0, 0);
	nk_widget_text(out, *label, str, len, &text, NK_TEXT_CENTERED, font);
	nk_draw_image(out, *image, img, nk_white);
}

NK_LIB int
nk_do_button_text_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, struct nk_image img,
	const char* str, int len, nk_flags align, enum nk_button_behavior behavior,
	const struct nk_style_button* style, const struct nk_user_font* font,
	const struct nk_input* in) {
	int ret;
	struct nk_rect icon;
	struct nk_rect content;

	NK_ASSERT(style);
	NK_ASSERT(state);
	NK_ASSERT(font);
	NK_ASSERT(out);
	if (!out || !font || !style || !str)
		return nk_false;

	ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
	icon.y = bounds.y + style->padding.y;
	icon.w = icon.h = bounds.h - 2 * style->padding.y;
	if (align & NK_TEXT_ALIGN_LEFT) {
		icon.x = (bounds.x + bounds.w) - (2 * style->padding.x + icon.w);
		icon.x = NK_MAX(icon.x, 0);
	}
	else icon.x = bounds.x + 2 * style->padding.x;

	icon.x += style->image_padding.x;
	icon.y += style->image_padding.y;
	icon.w -= 2 * style->image_padding.x;
	icon.h -= 2 * style->image_padding.y;

	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_button_text_image(out, &bounds, &content, &icon, *state, style, str, len, font, &img);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return ret;
}

NK_API void nk_button_set_behavior(struct nk_context* ctx, enum nk_button_behavior behavior) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	ctx->button_behavior = behavior;
}

NK_API int nk_button_push_behavior(struct nk_context* ctx, enum nk_button_behavior behavior) {
	struct nk_config_stack_button_behavior* button_stack;
	struct nk_config_stack_button_behavior_element* element;

	NK_ASSERT(ctx);
	if (!ctx) return 0;

	button_stack = &ctx->stacks.button_behaviors;
	NK_ASSERT(button_stack->head < (int)NK_LEN(button_stack->elements));
	if (button_stack->head >= (int)NK_LEN(button_stack->elements))
		return 0;

	element = &button_stack->elements[button_stack->head++];
	element->address = &ctx->button_behavior;
	element->old_value = ctx->button_behavior;
	ctx->button_behavior = behavior;
	return 1;
}

NK_API int nk_button_pop_behavior(struct nk_context* ctx) {
	struct nk_config_stack_button_behavior* button_stack;
	struct nk_config_stack_button_behavior_element* element;

	NK_ASSERT(ctx);
	if (!ctx) return 0;

	button_stack = &ctx->stacks.button_behaviors;
	NK_ASSERT(button_stack->head > 0);
	if (button_stack->head < 1)
		return 0;

	element = &button_stack->elements[--button_stack->head];
	*element->address = element->old_value;
	return 1;
}

NK_API int
nk_button_text_styled(struct nk_context* ctx, const struct nk_style_button* style, const char* title, int len) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(style);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!style || !ctx || !ctx->current || !ctx->current->layout) return 0;

	win = ctx->current;
	layout = win->layout;
	state = nk_widget(&bounds, ctx);

	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_button_text(&ctx->last_widget_state, &win->buffer, bounds, title, len, style->text_alignment,
		ctx->button_behavior, style, in, ctx->style.font);
}

NK_API int nk_button_text(struct nk_context* ctx, const char* title, int len) {
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	return nk_button_text_styled(ctx, &ctx->style.button, title, len);
}

NK_API int nk_button_label_styled(struct nk_context* ctx, const struct nk_style_button* style, const char* title) {
	return nk_button_text_styled(ctx, style, title, nk_strlen(title));
}

NK_API int nk_button_label(struct nk_context* ctx, const char* title) {
	return nk_button_text(ctx, title, nk_strlen(title));
}

NK_API int nk_button_color(struct nk_context* ctx, struct nk_color color) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	struct nk_style_button button;

	int ret = 0;
	struct nk_rect bounds;
	struct nk_rect content;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;

	button = ctx->style.button;
	button.normal = nk_style_item_color(color);
	button.hover = nk_style_item_color(color);
	button.active = nk_style_item_color(color);
	ret = nk_do_button(&ctx->last_widget_state, &win->buffer, bounds, &button, in, ctx->button_behavior, &content);
	nk_draw_button(&win->buffer, &bounds, ctx->last_widget_state, &button);
	return ret;
}

NK_API int
nk_button_symbol_styled(struct nk_context* ctx, const struct nk_style_button* style, enum nk_symbol_type symbol) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	layout = win->layout;
	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_button_symbol(&ctx->last_widget_state, &win->buffer, bounds, symbol, ctx->button_behavior, style, in,
		ctx->style.font);
}

NK_API int nk_button_symbol(struct nk_context* ctx, enum nk_symbol_type symbol) {
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	return nk_button_symbol_styled(ctx, &ctx->style.button, symbol);
}

NK_API int nk_button_image_styled(struct nk_context* ctx, const struct nk_style_button* style, struct nk_image img) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_button_image(&ctx->last_widget_state, &win->buffer, bounds, img, ctx->button_behavior, style, in);
}

NK_API int nk_button_image(struct nk_context* ctx, struct nk_image img) {
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	return nk_button_image_styled(ctx, &ctx->style.button, img);
}

NK_API int
nk_button_symbol_text_styled(struct nk_context* ctx, const struct nk_style_button* style, enum nk_symbol_type symbol,
	const char* text, int len, nk_flags align) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_button_text_symbol(&ctx->last_widget_state, &win->buffer, bounds, symbol, text, len, align,
		ctx->button_behavior, style, ctx->style.font, in);
}

NK_API int
nk_button_symbol_text(struct nk_context* ctx, enum nk_symbol_type symbol, const char* text, int len, nk_flags align) {
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	return nk_button_symbol_text_styled(ctx, &ctx->style.button, symbol, text, len, align);
}

NK_API int
nk_button_symbol_label(struct nk_context* ctx, enum nk_symbol_type symbol, const char* label, nk_flags align) {
	return nk_button_symbol_text(ctx, symbol, label, nk_strlen(label), align);
}

NK_API int
nk_button_symbol_label_styled(struct nk_context* ctx, const struct nk_style_button* style, enum nk_symbol_type symbol,
	const char* title, nk_flags align) {
	return nk_button_symbol_text_styled(ctx, style, symbol, title, nk_strlen(title), align);
}

NK_API int nk_button_image_text_styled(struct nk_context* ctx, const struct nk_style_button* style, struct nk_image img,
	const char* text, int len, nk_flags align) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_button_text_image(&ctx->last_widget_state, &win->buffer, bounds, img, text, len, align,
		ctx->button_behavior, style, ctx->style.font, in);
}

NK_API int
nk_button_image_text(struct nk_context* ctx, struct nk_image img, const char* text, int len, nk_flags align) {
	return nk_button_image_text_styled(ctx, &ctx->style.button, img, text, len, align);
}

NK_API int nk_button_image_label(struct nk_context* ctx, struct nk_image img, const char* label, nk_flags align) {
	return nk_button_image_text(ctx, img, label, nk_strlen(label), align);
}

NK_API int
nk_button_image_label_styled(struct nk_context* ctx, const struct nk_style_button* style, struct nk_image img,
	const char* label, nk_flags text_alignment) {
	return nk_button_image_text_styled(ctx, style, img, label, nk_strlen(label), text_alignment);
}





/* ===============================================================
 *
 *                              TOGGLE
 *
 * ===============================================================*/
NK_LIB int nk_toggle_behavior(const struct nk_input* in, struct nk_rect select, nk_flags* state, int active) {
	nk_widget_state_reset(state);
	if (nk_button_behavior(state, select, in, NK_BUTTON_DEFAULT)) {
		*state = NK_WIDGET_STATE_ACTIVE;
		active = !active;
	}
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, select))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, select))
		*state |= NK_WIDGET_STATE_LEFT;
	return active;
}

NK_LIB void
nk_draw_checkbox(struct nk_command_buffer* out, nk_flags state, const struct nk_style_toggle* style, int active,
	const struct nk_rect* label, const struct nk_rect* selector, const struct nk_rect* cursors,
	const char* string, int len, const struct nk_user_font* font) {
	const struct nk_style_item* background;
	const struct nk_style_item* cursor;
	struct nk_text text;

	/* select correct colors/images */
	if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		cursor = &style->cursor_hover;
		text.text = style->text_hover;
	}
	else if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->hover;
		cursor = &style->cursor_hover;
		text.text = style->text_active;
	}
	else {
		background = &style->normal;
		cursor = &style->cursor_normal;
		text.text = style->text_normal;
	}

	/* draw background and cursor */
	if (background->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_rect(out, *selector, 0, style->border_color);
		nk_fill_rect(out, nk_shrink_rect(*selector, style->border), 0, background->data.color);
	}
	else nk_draw_image(out, *selector, &background->data.image, nk_white);
	if (active) {
		if (cursor->type == NK_STYLE_ITEM_IMAGE)
			nk_draw_image(out, *cursors, &cursor->data.image, nk_white);
		else nk_fill_rect(out, *cursors, 0, cursor->data.color);
	}

	text.padding.x = 0;
	text.padding.y = 0;
	text.background = style->text_background;
	nk_widget_text(out, *label, string, len, &text, NK_TEXT_LEFT, font);
}

NK_LIB void
nk_draw_option(struct nk_command_buffer* out, nk_flags state, const struct nk_style_toggle* style, int active,
	const struct nk_rect* label, const struct nk_rect* selector, const struct nk_rect* cursors,
	const char* string, int len, const struct nk_user_font* font) {
	const struct nk_style_item* background;
	const struct nk_style_item* cursor;
	struct nk_text text;

	/* select correct colors/images */
	if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		cursor = &style->cursor_hover;
		text.text = style->text_hover;
	}
	else if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->hover;
		cursor = &style->cursor_hover;
		text.text = style->text_active;
	}
	else {
		background = &style->normal;
		cursor = &style->cursor_normal;
		text.text = style->text_normal;
	}

	/* draw background and cursor */
	if (background->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_circle(out, *selector, style->border_color);
		nk_fill_circle(out, nk_shrink_rect(*selector, style->border), background->data.color);
	}
	else nk_draw_image(out, *selector, &background->data.image, nk_white);
	if (active) {
		if (cursor->type == NK_STYLE_ITEM_IMAGE)
			nk_draw_image(out, *cursors, &cursor->data.image, nk_white);
		else nk_fill_circle(out, *cursors, cursor->data.color);
	}

	text.padding.x = 0;
	text.padding.y = 0;
	text.background = style->text_background;
	nk_widget_text(out, *label, string, len, &text, NK_TEXT_LEFT, font);
}

NK_LIB int
nk_do_toggle(nk_flags* state, struct nk_command_buffer* out, struct nk_rect r, int* active, const char* str, int len,
	enum nk_toggle_type type, const struct nk_style_toggle* style, const struct nk_input* in,
	const struct nk_user_font* font) {
	int was_active;
	struct nk_rect bounds;
	struct nk_rect select;
	struct nk_rect cursor;
	struct nk_rect label;

	NK_ASSERT(style);
	NK_ASSERT(out);
	NK_ASSERT(font);
	if (!out || !style || !font || !active)
		return 0;

	r.w = NK_MAX(r.w, font->height + 2 * style->padding.x);
	r.h = NK_MAX(r.h, font->height + 2 * style->padding.y);

	/* add additional touch padding for touch screen devices */
	bounds.x = r.x - style->touch_padding.x;
	bounds.y = r.y - style->touch_padding.y;
	bounds.w = r.w + 2 * style->touch_padding.x;
	bounds.h = r.h + 2 * style->touch_padding.y;

	/* calculate the selector space */
	select.w = font->height;
	select.h = select.w;
	select.y = r.y + r.h / 2.0f - select.h / 2.0f;
	select.x = r.x;

	/* calculate the bounds of the cursor inside the selector */
	cursor.x = select.x + style->padding.x + style->border;
	cursor.y = select.y + style->padding.y + style->border;
	cursor.w = select.w - (2 * style->padding.x + 2 * style->border);
	cursor.h = select.h - (2 * style->padding.y + 2 * style->border);

	/* label behind the selector */
	label.x = select.x + select.w + style->spacing;
	label.y = select.y;
	label.w = NK_MAX(r.x + r.w, label.x) - label.x;
	label.h = select.w;

	/* update selector */
	was_active = *active;
	*active = nk_toggle_behavior(in, bounds, state, *active);

	/* draw selector */
	if (style->draw_begin)
		style->draw_begin(out, style->userdata);
	if (type == NK_TOGGLE_CHECK) {
		nk_draw_checkbox(out, *state, style, *active, &label, &select, &cursor, str, len, font);
	}
	else {
		nk_draw_option(out, *state, style, *active, &label, &select, &cursor, str, len, font);
	}
	if (style->draw_end)
		style->draw_end(out, style->userdata);
	return (was_active != *active);
}
/*----------------------------------------------------------------
 *
 *                          CHECKBOX
 *
 * --------------------------------------------------------------*/
NK_API int nk_check_text(struct nk_context* ctx, const char* text, int len, int active) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return active;

	win = ctx->current;
	style = &ctx->style;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return active;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	nk_do_toggle(&ctx->last_widget_state, &win->buffer, bounds, &active, text, len, NK_TOGGLE_CHECK, &style->checkbox,
		in, style->font);
	return active;
}

NK_API unsigned int
nk_check_flags_text(struct nk_context* ctx, const char* text, int len, unsigned int flags, unsigned int value) {
	int old_active;
	NK_ASSERT(ctx);
	NK_ASSERT(text);
	if (!ctx || !text) return flags;
	old_active = (int)((flags & value) & value);
	if (nk_check_text(ctx, text, len, old_active))
		flags |= value;
	else flags &= ~value;
	return flags;
}

NK_API int nk_checkbox_text(struct nk_context* ctx, const char* text, int len, int* active) {
	int old_val;
	NK_ASSERT(ctx);
	NK_ASSERT(text);
	NK_ASSERT(active);
	if (!ctx || !text || !active) return 0;
	old_val = *active;
	*active = nk_check_text(ctx, text, len, *active);
	return old_val != *active;
}

NK_API int
nk_checkbox_flags_text(struct nk_context* ctx, const char* text, int len, unsigned int* flags, unsigned int value) {
	int active;
	NK_ASSERT(ctx);
	NK_ASSERT(text);
	NK_ASSERT(flags);
	if (!ctx || !text || !flags) return 0;

	active = (int)((*flags & value) & value);
	if (nk_checkbox_text(ctx, text, len, &active)) {
		if (active) *flags |= value;
		else *flags &= ~value;
		return 1;
	}
	return 0;
}

NK_API int nk_check_label(struct nk_context* ctx, const char* label, int active) {
	return nk_check_text(ctx, label, nk_strlen(label), active);
}

NK_API unsigned int
nk_check_flags_label(struct nk_context* ctx, const char* label, unsigned int flags, unsigned int value) {
	return nk_check_flags_text(ctx, label, nk_strlen(label), flags, value);
}

NK_API int nk_checkbox_label(struct nk_context* ctx, const char* label, int* active) {
	return nk_checkbox_text(ctx, label, nk_strlen(label), active);
}

NK_API int nk_checkbox_flags_label(struct nk_context* ctx, const char* label, unsigned int* flags, unsigned int value) {
	return nk_checkbox_flags_text(ctx, label, nk_strlen(label), flags, value);
}
/*----------------------------------------------------------------
 *
 *                          OPTION
 *
 * --------------------------------------------------------------*/
NK_API int nk_option_text(struct nk_context* ctx, const char* text, int len, int is_active) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return is_active;

	win = ctx->current;
	style = &ctx->style;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return (int)state;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	nk_do_toggle(&ctx->last_widget_state, &win->buffer, bounds, &is_active, text, len, NK_TOGGLE_OPTION, &style->option,
		in, style->font);
	return is_active;
}

NK_API int nk_radio_text(struct nk_context* ctx, const char* text, int len, int* active) {
	int old_value;
	NK_ASSERT(ctx);
	NK_ASSERT(text);
	NK_ASSERT(active);
	if (!ctx || !text || !active) return 0;
	old_value = *active;
	*active = nk_option_text(ctx, text, len, old_value);
	return old_value != *active;
}

NK_API int nk_option_label(struct nk_context* ctx, const char* label, int active) {
	return nk_option_text(ctx, label, nk_strlen(label), active);
}

NK_API int nk_radio_label(struct nk_context* ctx, const char* label, int* active) {
	return nk_radio_text(ctx, label, nk_strlen(label), active);
}





/* ===============================================================
 *
 *                              SELECTABLE
 *
 * ===============================================================*/
NK_LIB void
nk_draw_selectable(struct nk_command_buffer* out, nk_flags state, const struct nk_style_selectable* style, int active,
	const struct nk_rect* bounds, const struct nk_rect* icon, const struct nk_image* img,
	enum nk_symbol_type sym, const char* string, int len, nk_flags align,
	const struct nk_user_font* font) {
	const struct nk_style_item* background;
	struct nk_text text;
	text.padding = style->padding;

	/* select correct colors/images */
	if (!active) {
		if (state & NK_WIDGET_STATE_ACTIVED) {
			background = &style->pressed;
			text.text = style->text_pressed;
		}
		else if (state & NK_WIDGET_STATE_HOVER) {
			background = &style->hover;
			text.text = style->text_hover;
		}
		else {
			background = &style->normal;
			text.text = style->text_normal;
		}
	}
	else {
		if (state & NK_WIDGET_STATE_ACTIVED) {
			background = &style->pressed_active;
			text.text = style->text_pressed_active;
		}
		else if (state & NK_WIDGET_STATE_HOVER) {
			background = &style->hover_active;
			text.text = style->text_hover_active;
		}
		else {
			background = &style->normal_active;
			text.text = style->text_normal_active;
		}
	}
	/* draw selectable background and text */
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(out, *bounds, &background->data.image, nk_white);
		text.background = nk_rgba(0, 0, 0, 0);
	}
	else {
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		text.background = background->data.color;
	}
	if (icon) {
		if (img) nk_draw_image(out, *icon, img, nk_white);
		else nk_draw_symbol(out, sym, *icon, text.background, text.text, 1, font);
	}
	nk_widget_text(out, *bounds, string, len, &text, align, font);
}

NK_LIB int
nk_do_selectable(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* str, int len,
	nk_flags align, int* value, const struct nk_style_selectable* style, const struct nk_input* in,
	const struct nk_user_font* font) {
	int old_value;
	struct nk_rect touch;

	NK_ASSERT(state);
	NK_ASSERT(out);
	NK_ASSERT(str);
	NK_ASSERT(len);
	NK_ASSERT(value);
	NK_ASSERT(style);
	NK_ASSERT(font);

	if (!state || !out || !str || !len || !value || !style || !font) return 0;
	old_value = *value;

	/* remove padding */
	touch.x = bounds.x - style->touch_padding.x;
	touch.y = bounds.y - style->touch_padding.y;
	touch.w = bounds.w + style->touch_padding.x * 2;
	touch.h = bounds.h + style->touch_padding.y * 2;

	/* update button */
	if (nk_button_behavior(state, touch, in, NK_BUTTON_DEFAULT))
		*value = !(*value);

	/* draw selectable */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_selectable(out, *state, style, *value, &bounds, 0, 0, NK_SYMBOL_NONE, str, len, align, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return old_value != *value;
}

NK_LIB int
nk_do_selectable_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* str, int len,
	nk_flags align, int* value, const struct nk_image* img, const struct nk_style_selectable* style,
	const struct nk_input* in, const struct nk_user_font* font) {
	int old_value;
	struct nk_rect touch;
	struct nk_rect icon;

	NK_ASSERT(state);
	NK_ASSERT(out);
	NK_ASSERT(str);
	NK_ASSERT(len);
	NK_ASSERT(value);
	NK_ASSERT(style);
	NK_ASSERT(font);

	if (!state || !out || !str || !len || !value || !style || !font) return 0;
	old_value = *value;

	/* toggle behavior */
	touch.x = bounds.x - style->touch_padding.x;
	touch.y = bounds.y - style->touch_padding.y;
	touch.w = bounds.w + style->touch_padding.x * 2;
	touch.h = bounds.h + style->touch_padding.y * 2;
	if (nk_button_behavior(state, touch, in, NK_BUTTON_DEFAULT))
		*value = !(*value);

	icon.y = bounds.y + style->padding.y;
	icon.w = icon.h = bounds.h - 2 * style->padding.y;
	if (align & NK_TEXT_ALIGN_LEFT) {
		icon.x = (bounds.x + bounds.w) - (2 * style->padding.x + icon.w);
		icon.x = NK_MAX(icon.x, 0);
	}
	else icon.x = bounds.x + 2 * style->padding.x;

	icon.x += style->image_padding.x;
	icon.y += style->image_padding.y;
	icon.w -= 2 * style->image_padding.x;
	icon.h -= 2 * style->image_padding.y;

	/* draw selectable */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_selectable(out, *state, style, *value, &bounds, &icon, img, NK_SYMBOL_NONE, str, len, align, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return old_value != *value;
}

NK_LIB int
nk_do_selectable_symbol(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* str, int len,
	nk_flags align, int* value, enum nk_symbol_type sym, const struct nk_style_selectable* style,
	const struct nk_input* in, const struct nk_user_font* font) {
	int old_value;
	struct nk_rect touch;
	struct nk_rect icon;

	NK_ASSERT(state);
	NK_ASSERT(out);
	NK_ASSERT(str);
	NK_ASSERT(len);
	NK_ASSERT(value);
	NK_ASSERT(style);
	NK_ASSERT(font);

	if (!state || !out || !str || !len || !value || !style || !font) return 0;
	old_value = *value;

	/* toggle behavior */
	touch.x = bounds.x - style->touch_padding.x;
	touch.y = bounds.y - style->touch_padding.y;
	touch.w = bounds.w + style->touch_padding.x * 2;
	touch.h = bounds.h + style->touch_padding.y * 2;
	if (nk_button_behavior(state, touch, in, NK_BUTTON_DEFAULT))
		*value = !(*value);

	icon.y = bounds.y + style->padding.y;
	icon.w = icon.h = bounds.h - 2 * style->padding.y;
	if (align & NK_TEXT_ALIGN_LEFT) {
		icon.x = (bounds.x + bounds.w) - (2 * style->padding.x + icon.w);
		icon.x = NK_MAX(icon.x, 0);
	}
	else icon.x = bounds.x + 2 * style->padding.x;

	icon.x += style->image_padding.x;
	icon.y += style->image_padding.y;
	icon.w -= 2 * style->image_padding.x;
	icon.h -= 2 * style->image_padding.y;

	/* draw selectable */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_selectable(out, *state, style, *value, &bounds, &icon, 0, sym, str, len, align, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return old_value != *value;
}

NK_API int nk_selectable_text(struct nk_context* ctx, const char* str, int len, nk_flags align, int* value) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	const struct nk_style* style;

	enum nk_widget_layout_states state;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(value);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !value)
		return 0;

	win = ctx->current;
	layout = win->layout;
	style = &ctx->style;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_selectable(&ctx->last_widget_state, &win->buffer, bounds, str, len, align, value, &style->selectable,
		in, style->font);
}

NK_API int
nk_selectable_image_text(struct nk_context* ctx, struct nk_image img, const char* str, int len, nk_flags align,
	int* value) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	const struct nk_style* style;

	enum nk_widget_layout_states state;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(value);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !value)
		return 0;

	win = ctx->current;
	layout = win->layout;
	style = &ctx->style;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_selectable_image(&ctx->last_widget_state, &win->buffer, bounds, str, len, align, value, &img,
		&style->selectable, in, style->font);
}

NK_API int
nk_selectable_symbol_text(struct nk_context* ctx, enum nk_symbol_type sym, const char* str, int len, nk_flags align,
	int* value) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	const struct nk_style* style;

	enum nk_widget_layout_states state;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(value);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !value)
		return 0;

	win = ctx->current;
	layout = win->layout;
	style = &ctx->style;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_selectable_symbol(&ctx->last_widget_state, &win->buffer, bounds, str, len, align, value, sym,
		&style->selectable, in, style->font);
}

NK_API int
nk_selectable_symbol_label(struct nk_context* ctx, enum nk_symbol_type sym, const char* title, nk_flags align,
	int* value) {
	return nk_selectable_symbol_text(ctx, sym, title, nk_strlen(title), align, value);
}

NK_API int nk_select_text(struct nk_context* ctx, const char* str, int len, nk_flags align, int value) {
	nk_selectable_text(ctx, str, len, align, &value);
	return value;
}

NK_API int nk_selectable_label(struct nk_context* ctx, const char* str, nk_flags align, int* value) {
	return nk_selectable_text(ctx, str, nk_strlen(str), align, value);
}

NK_API int
nk_selectable_image_label(struct nk_context* ctx, struct nk_image img, const char* str, nk_flags align, int* value) {
	return nk_selectable_image_text(ctx, img, str, nk_strlen(str), align, value);
}

NK_API int nk_select_label(struct nk_context* ctx, const char* str, nk_flags align, int value) {
	nk_selectable_text(ctx, str, nk_strlen(str), align, &value);
	return value;
}

NK_API int
nk_select_image_label(struct nk_context* ctx, struct nk_image img, const char* str, nk_flags align, int value) {
	nk_selectable_image_text(ctx, img, str, nk_strlen(str), align, &value);
	return value;
}

NK_API int
nk_select_image_text(struct nk_context* ctx, struct nk_image img, const char* str, int len, nk_flags align, int value) {
	nk_selectable_image_text(ctx, img, str, len, align, &value);
	return value;
}

NK_API int
nk_select_symbol_text(struct nk_context* ctx, enum nk_symbol_type sym, const char* title, int title_len, nk_flags align,
	int value) {
	nk_selectable_symbol_text(ctx, sym, title, title_len, align, &value);
	return value;
}

NK_API int
nk_select_symbol_label(struct nk_context* ctx, enum nk_symbol_type sym, const char* title, nk_flags align, int value) {
	return nk_select_symbol_text(ctx, sym, title, nk_strlen(title), align, value);
}





/* ===============================================================
 *
 *                              SLIDER
 *
 * ===============================================================*/
NK_LIB float
nk_slider_behavior(nk_flags* state, struct nk_rect* logical_cursor, struct nk_rect* visual_cursor, struct nk_input* in,
	struct nk_rect bounds, float slider_min, float slider_max, float slider_value, float slider_step,
	float slider_steps) {
	int left_mouse_down;
	int left_mouse_click_in_cursor;

	/* check if visual cursor is being dragged */
	nk_widget_state_reset(state);
	left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;
	left_mouse_click_in_cursor =
		in && nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, *visual_cursor, nk_true);

	if (left_mouse_down && left_mouse_click_in_cursor) {
		float ratio = 0;
		const float d = in->mouse.pos.x - (visual_cursor->x + visual_cursor->w * 0.5f);
		const float pxstep = bounds.w / slider_steps;

		/* only update value if the next slider step is reached */
		*state = NK_WIDGET_STATE_ACTIVE;
		if (NK_ABS(d) >= pxstep) {
			const float steps = (float)((int)(NK_ABS(d) / pxstep));
			slider_value += (d > 0) ? (slider_step * steps) : -(slider_step * steps);
			slider_value = NK_CLAMP(slider_min, slider_value, slider_max);
			ratio = (slider_value - slider_min) / slider_step;
			logical_cursor->x = bounds.x + (logical_cursor->w * ratio);
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = logical_cursor->x;
		}
	}

	/* slider widget state */
	if (nk_input_is_mouse_hovering_rect(in, bounds))
		*state = NK_WIDGET_STATE_HOVERED;
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, bounds))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, bounds))
		*state |= NK_WIDGET_STATE_LEFT;
	return slider_value;
}

NK_LIB void nk_draw_slider(struct nk_command_buffer* out, nk_flags state, const struct nk_style_slider* style,
	const struct nk_rect* bounds, const struct nk_rect* visual_cursor, float min, float value,
	float max) {
	struct nk_rect fill;
	struct nk_rect bar;
	const struct nk_style_item* background;

	/* select correct slider images/colors */
	struct nk_color bar_color;
	const struct nk_style_item* cursor;

	NK_UNUSED(min);
	NK_UNUSED(max);
	NK_UNUSED(value);

	if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->active;
		bar_color = style->bar_active;
		cursor = &style->cursor_active;
	}
	else if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		bar_color = style->bar_hover;
		cursor = &style->cursor_hover;
	}
	else {
		background = &style->normal;
		bar_color = style->bar_normal;
		cursor = &style->cursor_normal;
	}
	/* calculate slider background bar */
	bar.x = bounds->x;
	bar.y = (visual_cursor->y + visual_cursor->h / 2) - bounds->h / 12;
	bar.w = bounds->w;
	bar.h = bounds->h / 6;

	/* filled background bar style */
	fill.w = (visual_cursor->x + (visual_cursor->w / 2.0f)) - bar.x;
	fill.x = bar.x;
	fill.y = bar.y;
	fill.h = bar.h;

	/* draw background */
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(out, *bounds, &background->data.image, nk_white);
	}
	else {
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
	}

	/* draw slider bar */
	nk_fill_rect(out, bar, style->rounding, bar_color);
	nk_fill_rect(out, fill, style->rounding, style->bar_filled);

	/* draw cursor */
	if (cursor->type == NK_STYLE_ITEM_IMAGE)
		nk_draw_image(out, *visual_cursor, &cursor->data.image, nk_white);
	else nk_fill_circle(out, *visual_cursor, cursor->data.color);
}

NK_LIB float
nk_do_slider(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, float min, float val, float max,
	float step, const struct nk_style_slider* style, struct nk_input* in, const struct nk_user_font* font) {
	float slider_range;
	float slider_min;
	float slider_max;
	float slider_value;
	float slider_steps;
	float cursor_offset;

	struct nk_rect visual_cursor;
	struct nk_rect logical_cursor;

	NK_ASSERT(style);
	NK_ASSERT(out);
	if (!out || !style)
		return 0;

	/* remove padding from slider bounds */
	bounds.x = bounds.x + style->padding.x;
	bounds.y = bounds.y + style->padding.y;
	bounds.h = NK_MAX(bounds.h, 2 * style->padding.y);
	bounds.w = NK_MAX(bounds.w, 2 * style->padding.x + style->cursor_size.x);
	bounds.w -= 2 * style->padding.x;
	bounds.h -= 2 * style->padding.y;

	/* optional buttons */
	if (style->show_buttons) {
		nk_flags ws;
		struct nk_rect button;
		button.y = bounds.y;
		button.w = bounds.h;
		button.h = bounds.h;

		/* decrement button */
		button.x = bounds.x;
		if (nk_do_button_symbol(&ws, out, button, style->dec_symbol, NK_BUTTON_DEFAULT, &style->dec_button, in, font))
			val -= step;

		/* increment button */
		button.x = (bounds.x + bounds.w) - button.w;
		if (nk_do_button_symbol(&ws, out, button, style->inc_symbol, NK_BUTTON_DEFAULT, &style->inc_button, in, font))
			val += step;

		bounds.x = bounds.x + button.w + style->spacing.x;
		bounds.w = bounds.w - (2 * button.w + 2 * style->spacing.x);
	}

	/* remove one cursor size to support visual cursor */
	bounds.x += style->cursor_size.x * 0.5f;
	bounds.w -= style->cursor_size.x;

	/* make sure the provided values are correct */
	slider_max = NK_MAX(min, max);
	slider_min = NK_MIN(min, max);
	slider_value = NK_CLAMP(slider_min, val, slider_max);
	slider_range = slider_max - slider_min;
	slider_steps = slider_range / step;
	cursor_offset = (slider_value - slider_min) / step;

	/* calculate cursor
	Basically you have two cursors. One for visual representation and interaction
	and one for updating the actual cursor value. */
	logical_cursor.h = bounds.h;
	logical_cursor.w = bounds.w / slider_steps;
	logical_cursor.x = bounds.x + (logical_cursor.w * cursor_offset);
	logical_cursor.y = bounds.y;

	visual_cursor.h = style->cursor_size.y;
	visual_cursor.w = style->cursor_size.x;
	visual_cursor.y = (bounds.y + bounds.h * 0.5f) - visual_cursor.h * 0.5f;
	visual_cursor.x = logical_cursor.x - visual_cursor.w * 0.5f;

	slider_value = nk_slider_behavior(state, &logical_cursor, &visual_cursor, in, bounds, slider_min, slider_max,
		slider_value, step, slider_steps);
	visual_cursor.x = logical_cursor.x - visual_cursor.w * 0.5f;

	/* draw slider */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_slider(out, *state, style, &bounds, &visual_cursor, slider_min, slider_value, slider_max);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return slider_value;
}

NK_API int nk_slider_float(struct nk_context* ctx, float min_value, float* value, float max_value, float value_step) {
	struct nk_window* win;
	struct nk_panel* layout;
	struct nk_input* in;
	const struct nk_style* style;

	int ret = 0;
	float old_value;
	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	NK_ASSERT(value);
	if (!ctx || !ctx->current || !ctx->current->layout || !value)
		return ret;

	win = ctx->current;
	style = &ctx->style;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return ret;
	in = (/*state == NK_WIDGET_ROM || */ layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;

	old_value = *value;
	*value = nk_do_slider(&ctx->last_widget_state, &win->buffer, bounds, min_value, old_value, max_value, value_step,
		&style->slider, in, style->font);
	return (old_value > * value || old_value < *value);
}

NK_API float nk_slide_float(struct nk_context* ctx, float min, float val, float max, float step) {
	nk_slider_float(ctx, min, &val, max, step);
	return val;
}

NK_API int nk_slide_int(struct nk_context* ctx, int min, int val, int max, int step) {
	float value = (float)val;
	nk_slider_float(ctx, (float)min, &value, (float)max, (float)step);
	return (int)value;
}

NK_API int nk_slider_int(struct nk_context* ctx, int min, int* val, int max, int step) {
	int ret;
	float value = (float)*val;
	ret = nk_slider_float(ctx, (float)min, &value, (float)max, (float)step);
	*val = (int)value;
	return ret;
}





/* ===============================================================
 *
 *                          PROGRESS
 *
 * ===============================================================*/
NK_LIB nk_size
nk_progress_behavior(nk_flags* state, struct nk_input* in, struct nk_rect r, struct nk_rect cursor, nk_size max,
	nk_size value, int modifiable) {
	int left_mouse_down = 0;
	int left_mouse_click_in_cursor = 0;

	nk_widget_state_reset(state);
	if (!in || !modifiable) return value;
	left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;
	left_mouse_click_in_cursor = in && nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, cursor, nk_true);
	if (nk_input_is_mouse_hovering_rect(in, r))
		*state = NK_WIDGET_STATE_HOVERED;

	if (in && left_mouse_down && left_mouse_click_in_cursor) {
		if (left_mouse_down && left_mouse_click_in_cursor) {
			float ratio = NK_MAX(0, (float)(in->mouse.pos.x - cursor.x)) / (float)cursor.w;
			value = (nk_size)NK_CLAMP(0, (float)max * ratio, (float)max);
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = cursor.x + cursor.w / 2.0f;
			*state |= NK_WIDGET_STATE_ACTIVE;
		}
	}
	/* set progressbar widget state */
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, r))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, r))
		*state |= NK_WIDGET_STATE_LEFT;
	return value;
}

NK_LIB void nk_draw_progress(struct nk_command_buffer* out, nk_flags state, const struct nk_style_progress* style,
	const struct nk_rect* bounds, const struct nk_rect* scursor, nk_size value, nk_size max) {
	const struct nk_style_item* background;
	const struct nk_style_item* cursor;

	NK_UNUSED(max);
	NK_UNUSED(value);

	/* select correct colors/images to draw */
	if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->active;
		cursor = &style->cursor_active;
	}
	else if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		cursor = &style->cursor_hover;
	}
	else {
		background = &style->normal;
		cursor = &style->cursor_normal;
	}

	/* draw background */
	if (background->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
	}
	else nk_draw_image(out, *bounds, &background->data.image, nk_white);

	/* draw cursor */
	if (cursor->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_rect(out, *scursor, style->rounding, cursor->data.color);
		nk_stroke_rect(out, *scursor, style->rounding, style->border, style->border_color);
	}
	else nk_draw_image(out, *scursor, &cursor->data.image, nk_white);
}

NK_LIB nk_size
nk_do_progress(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, nk_size value, nk_size max,
	int modifiable, const struct nk_style_progress* style, struct nk_input* in) {
	float prog_scale;
	nk_size prog_value;
	struct nk_rect cursor;

	NK_ASSERT(style);
	NK_ASSERT(out);
	if (!out || !style) return 0;

	/* calculate progressbar cursor */
	cursor.w = NK_MAX(bounds.w, 2 * style->padding.x + 2 * style->border);
	cursor.h = NK_MAX(bounds.h, 2 * style->padding.y + 2 * style->border);
	cursor = nk_pad_rect(bounds, nk_vec2(style->padding.x + style->border, style->padding.y + style->border));
	prog_scale = (float)value / (float)max;

	/* update progressbar */
	prog_value = NK_MIN(value, max);
	prog_value = nk_progress_behavior(state, in, bounds, cursor, max, prog_value, modifiable);
	cursor.w = cursor.w * prog_scale;

	/* draw progressbar */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_progress(out, *state, style, &bounds, &cursor, value, max);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return prog_value;
}

NK_API int nk_progress(struct nk_context* ctx, nk_size* cur, nk_size max, int is_modifyable) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;
	nk_size old_value;

	NK_ASSERT(ctx);
	NK_ASSERT(cur);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !cur)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	layout = win->layout;
	state = nk_widget(&bounds, ctx);
	if (!state) return 0;

	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	old_value = *cur;
	*cur = nk_do_progress(&ctx->last_widget_state, &win->buffer, bounds, *cur, max, is_modifyable, &style->progress,
		in);
	return (*cur != old_value);
}

NK_API nk_size nk_prog(struct nk_context* ctx, nk_size cur, nk_size max, int modifyable) {
	nk_progress(ctx, &cur, max, modifyable);
	return cur;
}





/* ===============================================================
 *
 *                              SCROLLBAR
 *
 * ===============================================================*/
NK_LIB float
nk_scrollbar_behavior(nk_flags* state, struct nk_input* in, int has_scrolling, const struct nk_rect* scroll,
	const struct nk_rect* cursor, const struct nk_rect* empty0, const struct nk_rect* empty1,
	float scroll_offset, float target, float scroll_step, enum nk_orientation o) {
	nk_flags ws = 0;
	int left_mouse_down;
	int left_mouse_clicked;
	int left_mouse_click_in_cursor;
	float scroll_delta;

	nk_widget_state_reset(state);
	if (!in) return scroll_offset;

	left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
	left_mouse_clicked = in->mouse.buttons[NK_BUTTON_LEFT].clicked;
	left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, *cursor, nk_true);
	if (nk_input_is_mouse_hovering_rect(in, *scroll))
		*state = NK_WIDGET_STATE_HOVERED;

	scroll_delta = (o == NK_VERTICAL) ? in->mouse.scroll_delta.y : in->mouse.scroll_delta.x;
	if (left_mouse_down && left_mouse_click_in_cursor && !left_mouse_clicked) {
		/* update cursor by mouse dragging */
		float pixel, delta;
		*state = NK_WIDGET_STATE_ACTIVE;
		if (o == NK_VERTICAL) {
			float cursor_y;
			pixel = in->mouse.delta.y;
			delta = (pixel / scroll->h) * target;
			scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->h);
			cursor_y = scroll->y + ((scroll_offset / target) * scroll->h);
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y = cursor_y + cursor->h / 2.0f;
		}
		else {
			float cursor_x;
			pixel = in->mouse.delta.x;
			delta = (pixel / scroll->w) * target;
			scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->w);
			cursor_x = scroll->x + ((scroll_offset / target) * scroll->w);
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = cursor_x + cursor->w / 2.0f;
		}
	}
	else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_UP) && o == NK_VERTICAL && has_scrolling) ||
		nk_button_behavior(&ws, *empty0, in, NK_BUTTON_DEFAULT)) {
		/* scroll page up by click on empty space or shortcut */
		if (o == NK_VERTICAL)
			scroll_offset = NK_MAX(0, scroll_offset - scroll->h);
		else scroll_offset = NK_MAX(0, scroll_offset - scroll->w);
	}
	else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_DOWN) && o == NK_VERTICAL && has_scrolling) ||
		nk_button_behavior(&ws, *empty1, in, NK_BUTTON_DEFAULT)) {
		/* scroll page down by click on empty space or shortcut */
		if (o == NK_VERTICAL)
			scroll_offset = NK_MIN(scroll_offset + scroll->h, target - scroll->h);
		else scroll_offset = NK_MIN(scroll_offset + scroll->w, target - scroll->w);
	}
	else if (has_scrolling) {
		if ((scroll_delta < 0 || (scroll_delta > 0))) {
			/* update cursor by mouse scrolling */
			scroll_offset = scroll_offset + scroll_step * (-scroll_delta);
			if (o == NK_VERTICAL)
				scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->h);
			else scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->w);
		}
		else if (nk_input_is_key_pressed(in, NK_KEY_SCROLL_START)) {
			/* update cursor to the beginning  */
			if (o == NK_VERTICAL) scroll_offset = 0;
		}
		else if (nk_input_is_key_pressed(in, NK_KEY_SCROLL_END)) {
			/* update cursor to the end */
			if (o == NK_VERTICAL) scroll_offset = target - scroll->h;
		}
	}
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, *scroll))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, *scroll))
		*state |= NK_WIDGET_STATE_LEFT;
	return scroll_offset;
}

NK_LIB void nk_draw_scrollbar(struct nk_command_buffer* out, nk_flags state, const struct nk_style_scrollbar* style,
	const struct nk_rect* bounds, const struct nk_rect* scroll) {
	const struct nk_style_item* background;
	const struct nk_style_item* cursor;

	/* select correct colors/images to draw */
	if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->active;
		cursor = &style->cursor_active;
	}
	else if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		cursor = &style->cursor_hover;
	}
	else {
		background = &style->normal;
		cursor = &style->cursor_normal;
	}

	/* draw background */
	if (background->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
	}
	else {
		nk_draw_image(out, *bounds, &background->data.image, nk_white);
	}

	/* draw cursor */
	if (cursor->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_rect(out, *scroll, style->rounding_cursor, cursor->data.color);
		nk_stroke_rect(out, *scroll, style->rounding_cursor, style->border_cursor, style->cursor_border_color);
	}
	else nk_draw_image(out, *scroll, &cursor->data.image, nk_white);
}

NK_LIB float
nk_do_scrollbarv(nk_flags* state, struct nk_command_buffer* out, struct nk_rect scroll, int has_scrolling, float offset,
	float target, float step, float button_pixel_inc, const struct nk_style_scrollbar* style,
	struct nk_input* in, const struct nk_user_font* font) {
	struct nk_rect empty_north;
	struct nk_rect empty_south;
	struct nk_rect cursor;

	float scroll_step;
	float scroll_offset;
	float scroll_off;
	float scroll_ratio;

	NK_ASSERT(out);
	NK_ASSERT(style);
	NK_ASSERT(state);
	if (!out || !style) return 0;

	scroll.w = NK_MAX(scroll.w, 1);
	scroll.h = NK_MAX(scroll.h, 0);
	if (target <= scroll.h) return 0;

	/* optional scrollbar buttons */
	if (style->show_buttons) {
		nk_flags ws;
		float scroll_h;
		struct nk_rect button;

		button.x = scroll.x;
		button.w = scroll.w;
		button.h = scroll.w;

		scroll_h = NK_MAX(scroll.h - 2 * button.h, 0);
		scroll_step = NK_MIN(step, button_pixel_inc);

		/* decrement button */
		button.y = scroll.y;
		if (nk_do_button_symbol(&ws, out, button, style->dec_symbol, NK_BUTTON_REPEATER, &style->dec_button, in, font))
			offset = offset - scroll_step;

		/* increment button */
		button.y = scroll.y + scroll.h - button.h;
		if (nk_do_button_symbol(&ws, out, button, style->inc_symbol, NK_BUTTON_REPEATER, &style->inc_button, in, font))
			offset = offset + scroll_step;

		scroll.y = scroll.y + button.h;
		scroll.h = scroll_h;
	}

	/* calculate scrollbar constants */
	scroll_step = NK_MIN(step, scroll.h);
	scroll_offset = NK_CLAMP(0, offset, target - scroll.h);
	scroll_ratio = scroll.h / target;
	scroll_off = scroll_offset / target;

	/* calculate scrollbar cursor bounds */
	cursor.h = NK_MAX((scroll_ratio * scroll.h) - (2 * style->border + 2 * style->padding.y), 0);
	cursor.y = scroll.y + (scroll_off * scroll.h) + style->border + style->padding.y;
	cursor.w = scroll.w - (2 * style->border + 2 * style->padding.x);
	cursor.x = scroll.x + style->border + style->padding.x;

	/* calculate empty space around cursor */
	empty_north.x = scroll.x;
	empty_north.y = scroll.y;
	empty_north.w = scroll.w;
	empty_north.h = NK_MAX(cursor.y - scroll.y, 0);

	empty_south.x = scroll.x;
	empty_south.y = cursor.y + cursor.h;
	empty_south.w = scroll.w;
	empty_south.h = NK_MAX((scroll.y + scroll.h) - (cursor.y + cursor.h), 0);

	/* update scrollbar */
	scroll_offset = nk_scrollbar_behavior(state, in, has_scrolling, &scroll, &cursor, &empty_north, &empty_south,
		scroll_offset, target, scroll_step, NK_VERTICAL);
	scroll_off = scroll_offset / target;
	cursor.y = scroll.y + (scroll_off * scroll.h) + style->border_cursor + style->padding.y;

	/* draw scrollbar */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_scrollbar(out, *state, style, &scroll, &cursor);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return scroll_offset;
}

NK_LIB float
nk_do_scrollbarh(nk_flags* state, struct nk_command_buffer* out, struct nk_rect scroll, int has_scrolling, float offset,
	float target, float step, float button_pixel_inc, const struct nk_style_scrollbar* style,
	struct nk_input* in, const struct nk_user_font* font) {
	struct nk_rect cursor;
	struct nk_rect empty_west;
	struct nk_rect empty_east;

	float scroll_step;
	float scroll_offset;
	float scroll_off;
	float scroll_ratio;

	NK_ASSERT(out);
	NK_ASSERT(style);
	if (!out || !style) return 0;

	/* scrollbar background */
	scroll.h = NK_MAX(scroll.h, 1);
	scroll.w = NK_MAX(scroll.w, 2 * scroll.h);
	if (target <= scroll.w) return 0;

	/* optional scrollbar buttons */
	if (style->show_buttons) {
		nk_flags ws;
		float scroll_w;
		struct nk_rect button;
		button.y = scroll.y;
		button.w = scroll.h;
		button.h = scroll.h;

		scroll_w = scroll.w - 2 * button.w;
		scroll_step = NK_MIN(step, button_pixel_inc);

		/* decrement button */
		button.x = scroll.x;
		if (nk_do_button_symbol(&ws, out, button, style->dec_symbol, NK_BUTTON_REPEATER, &style->dec_button, in, font))
			offset = offset - scroll_step;

		/* increment button */
		button.x = scroll.x + scroll.w - button.w;
		if (nk_do_button_symbol(&ws, out, button, style->inc_symbol, NK_BUTTON_REPEATER, &style->inc_button, in, font))
			offset = offset + scroll_step;

		scroll.x = scroll.x + button.w;
		scroll.w = scroll_w;
	}

	/* calculate scrollbar constants */
	scroll_step = NK_MIN(step, scroll.w);
	scroll_offset = NK_CLAMP(0, offset, target - scroll.w);
	scroll_ratio = scroll.w / target;
	scroll_off = scroll_offset / target;

	/* calculate cursor bounds */
	cursor.w = (scroll_ratio * scroll.w) - (2 * style->border + 2 * style->padding.x);
	cursor.x = scroll.x + (scroll_off * scroll.w) + style->border + style->padding.x;
	cursor.h = scroll.h - (2 * style->border + 2 * style->padding.y);
	cursor.y = scroll.y + style->border + style->padding.y;

	/* calculate empty space around cursor */
	empty_west.x = scroll.x;
	empty_west.y = scroll.y;
	empty_west.w = cursor.x - scroll.x;
	empty_west.h = scroll.h;

	empty_east.x = cursor.x + cursor.w;
	empty_east.y = scroll.y;
	empty_east.w = (scroll.x + scroll.w) - (cursor.x + cursor.w);
	empty_east.h = scroll.h;

	/* update scrollbar */
	scroll_offset = nk_scrollbar_behavior(state, in, has_scrolling, &scroll, &cursor, &empty_west, &empty_east,
		scroll_offset, target, scroll_step, NK_HORIZONTAL);
	scroll_off = scroll_offset / target;
	cursor.x = scroll.x + (scroll_off * scroll.w);

	/* draw scrollbar */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_scrollbar(out, *state, style, &scroll, &cursor);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return scroll_offset;
}





/* ===============================================================
 *
 *                          TEXT EDITOR
 *
 * ===============================================================*/
 /* stb_textedit.h - v1.8  - public domain - Sean Barrett */
struct nk_text_find {
	float x, y;    /* position of n'th character */
	float height; /* height of line */
	int first_char, length; /* first char of row, and length */
	int prev_first;  /*_ first char of previous row */
};

struct nk_text_edit_row {
	float x0, x1;
	/* starting x location, end x location (allows for align=right, etc) */
	float baseline_y_delta;
	/* position of baseline relative to previous row's baseline*/
	float ymin, ymax;
	/* height of row above and below baseline */
	int num_chars;
};

/* forward declarations */
NK_INTERN void nk_textedit_makeundo_delete(struct nk_text_edit*, int, int);

NK_INTERN void nk_textedit_makeundo_insert(struct nk_text_edit*, int, int);

NK_INTERN void nk_textedit_makeundo_replace(struct nk_text_edit*, int, int, int);

#define NK_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)

NK_INTERN float
nk_textedit_get_width(const struct nk_text_edit* edit, int line_start, int char_id, const struct nk_user_font* font) {
	int len = 0;
	nk_rune unicode = 0;
	const char* str = nk_str_at_const(&edit->string, line_start + char_id, &unicode, &len);
	return font->width(font->userdata, font->height, str, len);
}

NK_INTERN void
nk_textedit_layout_row(struct nk_text_edit_row* r, struct nk_text_edit* edit, int line_start_id, float row_height,
	const struct nk_user_font* font) {
	int l;
	int glyphs = 0;
	nk_rune unicode;
	const char* remaining;
	int len = nk_str_len_char(&edit->string);
	const char* end = nk_str_get_const(&edit->string) + len;
	const char* text = nk_str_at_const(&edit->string, line_start_id, &unicode, &l);
	const struct nk_vec2 size = nk_text_calculate_text_bounds(font, text, (int)(end - text), row_height, &remaining, 0,
		&glyphs, NK_STOP_ON_NEW_LINE);

	r->x0 = 0.0f;
	r->x1 = size.x;
	r->baseline_y_delta = size.y;
	r->ymin = 0.0f;
	r->ymax = size.y;
	r->num_chars = glyphs;
}

NK_INTERN int nk_textedit_locate_coord(struct nk_text_edit* edit, float x, float y, const struct nk_user_font* font,
	float row_height) {
	struct nk_text_edit_row r;
	int n = edit->string.len;
	float base_y = 0, prev_x;
	int i = 0, k;

	r.x0 = r.x1 = 0;
	r.ymin = r.ymax = 0;
	r.num_chars = 0;

	/* search rows to find one that straddles 'y' */
	while (i < n) {
		nk_textedit_layout_row(&r, edit, i, row_height, font);
		if (r.num_chars <= 0)
			return n;

		if (i == 0 && y < base_y + r.ymin)
			return 0;

		if (y < base_y + r.ymax)
			break;

		i += r.num_chars;
		base_y += r.baseline_y_delta;
	}

	/* below all text, return 'after' last character */
	if (i >= n)
		return n;

	/* check if it's before the beginning of the line */
	if (x < r.x0)
		return i;

	/* check if it's before the end of the line */
	if (x < r.x1) {
		/* search characters in row for one that straddles 'x' */
		k = i;
		prev_x = r.x0;
		for (i = 0; i < r.num_chars; ++i) {
			float w = nk_textedit_get_width(edit, k, i, font);
			if (x < prev_x + w) {
				if (x < prev_x + w / 2)
					return k + i;
				else return k + i + 1;
			}
			prev_x += w;
		}
		/* shouldn't happen, but if it does, fall through to end-of-line case */
	}

	/* if the last character is a newline, return that.
	 * otherwise return 'after' the last character */
	if (nk_str_rune_at(&edit->string, i + r.num_chars - 1) == '\n')
		return i + r.num_chars - 1;
	else return i + r.num_chars;
}

NK_LIB void
nk_textedit_click(struct nk_text_edit* state, float x, float y, const struct nk_user_font* font, float row_height) {
	/* API click: on mouse down, move the cursor to the clicked location,
	 * and reset the selection */
	state->cursor = nk_textedit_locate_coord(state, x, y, font, row_height);
	state->select_start = state->cursor;
	state->select_end = state->cursor;
	state->has_preferred_x = 0;
}

NK_LIB void
nk_textedit_drag(struct nk_text_edit* state, float x, float y, const struct nk_user_font* font, float row_height) {
	/* API drag: on mouse drag, move the cursor and selection endpoint
	 * to the clicked location */
	int p = nk_textedit_locate_coord(state, x, y, font, row_height);
	if (state->select_start == state->select_end)
		state->select_start = state->cursor;
	state->cursor = state->select_end = p;
}

NK_INTERN void nk_textedit_find_charpos(struct nk_text_find* find, struct nk_text_edit* state, int n, int single_line,
	const struct nk_user_font* font, float row_height) {
	/* find the x/y location of a character, and remember info about the previous
	 * row in case we get a move-up event (for page up, we'll have to rescan) */
	struct nk_text_edit_row r;
	int prev_start = 0;
	int z = state->string.len;
	int i = 0, first;

	nk_zero_struct(r);
	if (n == z) {
		/* if it's at the end, then find the last line -- simpler than trying to
		explicitly handle this case in the regular code */
		nk_textedit_layout_row(&r, state, 0, row_height, font);
		if (single_line) {
			find->first_char = 0;
			find->length = z;
		}
		else {
			while (i < z) {
				prev_start = i;
				i += r.num_chars;
				nk_textedit_layout_row(&r, state, i, row_height, font);
			}

			find->first_char = i;
			find->length = r.num_chars;
		}
		find->x = r.x1;
		find->y = r.ymin;
		find->height = r.ymax - r.ymin;
		find->prev_first = prev_start;
		return;
	}

	/* search rows to find the one that straddles character n */
	find->y = 0;

	for (;;) {
		nk_textedit_layout_row(&r, state, i, row_height, font);
		if (n < i + r.num_chars) break;
		prev_start = i;
		i += r.num_chars;
		find->y += r.baseline_y_delta;
	}

	find->first_char = first = i;
	find->length = r.num_chars;
	find->height = r.ymax - r.ymin;
	find->prev_first = prev_start;

	/* now scan to find xpos */
	find->x = r.x0;
	for (i = 0; first + i < n; ++i)
		find->x += nk_textedit_get_width(state, first, i, font);
}

NK_INTERN void nk_textedit_clamp(struct nk_text_edit* state) {
	/* make the selection/cursor state valid if client altered the string */
	int n = state->string.len;
	if (NK_TEXT_HAS_SELECTION(state)) {
		if (state->select_start > n) state->select_start = n;
		if (state->select_end > n) state->select_end = n;
		/* if clamping forced them to be equal, move the cursor to match */
		if (state->select_start == state->select_end)
			state->cursor = state->select_start;
	}
	if (state->cursor > n) state->cursor = n;
}

NK_API void nk_textedit_delete(struct nk_text_edit* state, int where, int len) {
	/* delete characters while updating undo */
	nk_textedit_makeundo_delete(state, where, len);
	nk_str_delete_runes(&state->string, where, len);
	state->has_preferred_x = 0;
}

NK_API void nk_textedit_delete_selection(struct nk_text_edit* state) {
	/* delete the section */
	nk_textedit_clamp(state);
	if (NK_TEXT_HAS_SELECTION(state)) {
		if (state->select_start < state->select_end) {
			nk_textedit_delete(state, state->select_start, state->select_end - state->select_start);
			state->select_end = state->cursor = state->select_start;
		}
		else {
			nk_textedit_delete(state, state->select_end, state->select_start - state->select_end);
			state->select_start = state->cursor = state->select_end;
		}
		state->has_preferred_x = 0;
	}
}

NK_INTERN void nk_textedit_sortselection(struct nk_text_edit* state) {
	/* canonicalize the selection so start <= end */
	if (state->select_end < state->select_start) {
		int temp = state->select_end;
		state->select_end = state->select_start;
		state->select_start = temp;
	}
}

NK_INTERN void nk_textedit_move_to_first(struct nk_text_edit* state) {
	/* move cursor to first character of selection */
	if (NK_TEXT_HAS_SELECTION(state)) {
		nk_textedit_sortselection(state);
		state->cursor = state->select_start;
		state->select_end = state->select_start;
		state->has_preferred_x = 0;
	}
}

NK_INTERN void nk_textedit_move_to_last(struct nk_text_edit* state) {
	/* move cursor to last character of selection */
	if (NK_TEXT_HAS_SELECTION(state)) {
		nk_textedit_sortselection(state);
		nk_textedit_clamp(state);
		state->cursor = state->select_end;
		state->select_start = state->select_end;
		state->has_preferred_x = 0;
	}
}

NK_INTERN int nk_is_word_boundary(struct nk_text_edit* state, int idx) {
	int len;
	nk_rune c;
	if (idx <= 0) return 1;
	if (!nk_str_at_rune(&state->string, idx, &c, &len)) return 1;
	return (c == ' ' || c == '\t' || c == 0x3000 || c == ',' || c == ';' || c == '(' || c == ')' || c == '{' ||
		c == '}' || c == '[' || c == ']' || c == '|');
}

NK_INTERN int nk_textedit_move_to_word_previous(struct nk_text_edit* state) {
	int c = state->cursor - 1;
	while (c >= 0 && !nk_is_word_boundary(state, c))
		--c;

	if (c < 0)
		c = 0;

	return c;
}

NK_INTERN int nk_textedit_move_to_word_next(struct nk_text_edit* state) {
	const int len = state->string.len;
	int c = state->cursor + 1;
	while (c < len && !nk_is_word_boundary(state, c))
		++c;

	if (c > len)
		c = len;

	return c;
}

NK_INTERN void nk_textedit_prep_selection_at_cursor(struct nk_text_edit* state) {
	/* update selection and cursor to match each other */
	if (!NK_TEXT_HAS_SELECTION(state))
		state->select_start = state->select_end = state->cursor;
	else state->cursor = state->select_end;
}

NK_API int nk_textedit_cut(struct nk_text_edit* state) {
	/* API cut: delete selection */
	if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
		return 0;
	if (NK_TEXT_HAS_SELECTION(state)) {
		nk_textedit_delete_selection(state); /* implicitly clamps */
		state->has_preferred_x = 0;
		return 1;
	}
	return 0;
}

NK_API int nk_textedit_paste(struct nk_text_edit* state, char const* ctext, int len) {
	/* API paste: replace existing selection with passed-in text */
	int glyphs;
	const char* text = (const char*)ctext;
	if (state->mode == NK_TEXT_EDIT_MODE_VIEW) return 0;

	/* if there's a selection, the paste should delete it */
	nk_textedit_clamp(state);
	nk_textedit_delete_selection(state);

	/* try to insert the characters */
	glyphs = nk_utf_len(ctext, len);
	if (nk_str_insert_text_char(&state->string, state->cursor, text, len)) {
		nk_textedit_makeundo_insert(state, state->cursor, glyphs);
		state->cursor += len;
		state->has_preferred_x = 0;
		return 1;
	}
	/* remove the undo since we didn't actually insert the characters */
	if (state->undo.undo_point)
		--state->undo.undo_point;
	return 0;
}

NK_API void nk_textedit_text(struct nk_text_edit* state, const char* text, int total_len) {
	nk_rune unicode;
	int glyph_len;
	int text_len = 0;

	NK_ASSERT(state);
	NK_ASSERT(text);
	if (!text || !total_len || state->mode == NK_TEXT_EDIT_MODE_VIEW) return;

	glyph_len = nk_utf_decode(text, &unicode, total_len);
	while ((text_len < total_len) && glyph_len) {
		/* don't insert a backward delete, just process the event */
		if (unicode == 127) goto next;
		/* can't add newline in single-line mode */
		if (unicode == '\n' && state->single_line) goto next;
		/* filter incoming text */
		if (state->filter && !state->filter(state, unicode)) goto next;

		if (!NK_TEXT_HAS_SELECTION(state) && state->cursor < state->string.len) {
			if (state->mode == NK_TEXT_EDIT_MODE_REPLACE) {
				nk_textedit_makeundo_replace(state, state->cursor, 1, 1);
				nk_str_delete_runes(&state->string, state->cursor, 1);
			}
			if (nk_str_insert_text_utf8(&state->string, state->cursor, text + text_len, 1)) {
				++state->cursor;
				state->has_preferred_x = 0;
			}
		}
		else {
			nk_textedit_delete_selection(state); /* implicitly clamps */
			if (nk_str_insert_text_utf8(&state->string, state->cursor, text + text_len, 1)) {
				nk_textedit_makeundo_insert(state, state->cursor, 1);
				++state->cursor;
				state->has_preferred_x = 0;
			}
		}
	next:
		text_len += glyph_len;
		glyph_len = nk_utf_decode(text + text_len, &unicode, total_len - text_len);
	}
}

NK_LIB void
nk_textedit_key(struct nk_text_edit* state, enum nk_keys key, int shift_mod, const struct nk_user_font* font,
	float row_height) {
retry:
	switch (key) {
	case NK_KEY_NONE:
	case NK_KEY_CTRL:
	case NK_KEY_ENTER:
	case NK_KEY_SHIFT:
	case NK_KEY_TAB:
	case NK_KEY_COPY:
	case NK_KEY_CUT:
	case NK_KEY_PASTE:
	case NK_KEY_MAX:
	default:
		break;
	case NK_KEY_TEXT_UNDO:
		nk_textedit_undo(state);
		state->has_preferred_x = 0;
		break;

	case NK_KEY_TEXT_REDO:
		nk_textedit_redo(state);
		state->has_preferred_x = 0;
		break;

	case NK_KEY_TEXT_SELECT_ALL:
		nk_textedit_select_all(state);
		state->has_preferred_x = 0;
		break;

	case NK_KEY_TEXT_INSERT_MODE:
		if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
			state->mode = NK_TEXT_EDIT_MODE_INSERT;
		break;
	case NK_KEY_TEXT_REPLACE_MODE:
		if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
			state->mode = NK_TEXT_EDIT_MODE_REPLACE;
		break;
	case NK_KEY_TEXT_RESET_MODE:
		if (state->mode == NK_TEXT_EDIT_MODE_INSERT || state->mode == NK_TEXT_EDIT_MODE_REPLACE)
			state->mode = NK_TEXT_EDIT_MODE_VIEW;
		break;

	case NK_KEY_LEFT:
		if (shift_mod) {
			nk_textedit_clamp(state);
			nk_textedit_prep_selection_at_cursor(state);
			/* move selection left */
			if (state->select_end > 0)
				--state->select_end;
			state->cursor = state->select_end;
			state->has_preferred_x = 0;
		}
		else {
			/* if currently there's a selection,
		 * move cursor to start of selection */
			if (NK_TEXT_HAS_SELECTION(state))
				nk_textedit_move_to_first(state);
			else if (state->cursor > 0)
				--state->cursor;
			state->has_preferred_x = 0;
		}
		break;

	case NK_KEY_RIGHT:
		if (shift_mod) {
			nk_textedit_prep_selection_at_cursor(state);
			/* move selection right */
			++state->select_end;
			nk_textedit_clamp(state);
			state->cursor = state->select_end;
			state->has_preferred_x = 0;
		}
		else {
			/* if currently there's a selection,
		 * move cursor to end of selection */
			if (NK_TEXT_HAS_SELECTION(state))
				nk_textedit_move_to_last(state);
			else ++state->cursor;
			nk_textedit_clamp(state);
			state->has_preferred_x = 0;
		}
		break;

	case NK_KEY_TEXT_WORD_LEFT:
		if (shift_mod) {
			if (!NK_TEXT_HAS_SELECTION(state))
				nk_textedit_prep_selection_at_cursor(state);
			state->cursor = nk_textedit_move_to_word_previous(state);
			state->select_end = state->cursor;
			nk_textedit_clamp(state);
		}
		else {
			if (NK_TEXT_HAS_SELECTION(state))
				nk_textedit_move_to_first(state);
			else {
				state->cursor = nk_textedit_move_to_word_previous(state);
				nk_textedit_clamp(state);
			}
		}
		break;

	case NK_KEY_TEXT_WORD_RIGHT:
		if (shift_mod) {
			if (!NK_TEXT_HAS_SELECTION(state))
				nk_textedit_prep_selection_at_cursor(state);
			state->cursor = nk_textedit_move_to_word_next(state);
			state->select_end = state->cursor;
			nk_textedit_clamp(state);
		}
		else {
			if (NK_TEXT_HAS_SELECTION(state))
				nk_textedit_move_to_last(state);
			else {
				state->cursor = nk_textedit_move_to_word_next(state);
				nk_textedit_clamp(state);
			}
		}
		break;

	case NK_KEY_DOWN: {
		struct nk_text_find find;
		struct nk_text_edit_row row;
		int i, sel = shift_mod;

		if (state->single_line) {
			/* on windows, up&down in single-line behave like left&right */
			key = NK_KEY_RIGHT;
			goto retry;
		}

		if (sel)
			nk_textedit_prep_selection_at_cursor(state);
		else if (NK_TEXT_HAS_SELECTION(state))
			nk_textedit_move_to_last(state);

		/* compute current position of cursor point */
		nk_textedit_clamp(state);
		nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);

		/* now find character position down a row */
		if (find.length) {
			float x;
			float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
			int start = find.first_char + find.length;

			state->cursor = start;
			nk_textedit_layout_row(&row, state, state->cursor, row_height, font);
			x = row.x0;

			for (i = 0; i < row.num_chars && x < row.x1; ++i) {
				float dx = nk_textedit_get_width(state, start, i, font);
				x += dx;
				if (x > goal_x)
					break;
				++state->cursor;
			}
			nk_textedit_clamp(state);

			state->has_preferred_x = 1;
			state->preferred_x = goal_x;
			if (sel)
				state->select_end = state->cursor;
		}
	}
					break;

	case NK_KEY_UP: {
		struct nk_text_find find;
		struct nk_text_edit_row row;
		int i, sel = shift_mod;

		if (state->single_line) {
			/* on windows, up&down become left&right */
			key = NK_KEY_LEFT;
			goto retry;
		}

		if (sel)
			nk_textedit_prep_selection_at_cursor(state);
		else if (NK_TEXT_HAS_SELECTION(state))
			nk_textedit_move_to_first(state);

		/* compute current position of cursor point */
		nk_textedit_clamp(state);
		nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);

		/* can only go up if there's a previous row */
		if (find.prev_first != find.first_char) {
			/* now find character position up a row */
			float x;
			float goal_x = state->has_preferred_x ? state->preferred_x : find.x;

			state->cursor = find.prev_first;
			nk_textedit_layout_row(&row, state, state->cursor, row_height, font);
			x = row.x0;

			for (i = 0; i < row.num_chars && x < row.x1; ++i) {
				float dx = nk_textedit_get_width(state, find.prev_first, i, font);
				x += dx;
				if (x > goal_x)
					break;
				++state->cursor;
			}
			nk_textedit_clamp(state);

			state->has_preferred_x = 1;
			state->preferred_x = goal_x;
			if (sel) state->select_end = state->cursor;
		}
	}
				  break;

	case NK_KEY_DEL:
		if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
			break;
		if (NK_TEXT_HAS_SELECTION(state))
			nk_textedit_delete_selection(state);
		else {
			int n = state->string.len;
			if (state->cursor < n)
				nk_textedit_delete(state, state->cursor, 1);
		}
		state->has_preferred_x = 0;
		break;

	case NK_KEY_BACKSPACE:
		if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
			break;
		if (NK_TEXT_HAS_SELECTION(state))
			nk_textedit_delete_selection(state);
		else {
			nk_textedit_clamp(state);
			if (state->cursor > 0) {
				nk_textedit_delete(state, state->cursor - 1, 1);
				--state->cursor;
			}
		}
		state->has_preferred_x = 0;
		break;

	case NK_KEY_TEXT_START:
		if (shift_mod) {
			nk_textedit_prep_selection_at_cursor(state);
			state->cursor = state->select_end = 0;
			state->has_preferred_x = 0;
		}
		else {
			state->cursor = state->select_start = state->select_end = 0;
			state->has_preferred_x = 0;
		}
		break;

	case NK_KEY_TEXT_END:
		if (shift_mod) {
			nk_textedit_prep_selection_at_cursor(state);
			state->cursor = state->select_end = state->string.len;
			state->has_preferred_x = 0;
		}
		else {
			state->cursor = state->string.len;
			state->select_start = state->select_end = 0;
			state->has_preferred_x = 0;
		}
		break;

	case NK_KEY_TEXT_LINE_START: {
		if (shift_mod) {
			struct nk_text_find find;
			nk_textedit_clamp(state);
			nk_textedit_prep_selection_at_cursor(state);
			if (state->string.len && state->cursor == state->string.len)
				--state->cursor;
			nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);
			state->cursor = state->select_end = find.first_char;
			state->has_preferred_x = 0;
		}
		else {
			struct nk_text_find find;
			if (state->string.len && state->cursor == state->string.len)
				--state->cursor;
			nk_textedit_clamp(state);
			nk_textedit_move_to_first(state);
			nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);
			state->cursor = find.first_char;
			state->has_preferred_x = 0;
		}
	}
							   break;

	case NK_KEY_TEXT_LINE_END: {
		if (shift_mod) {
			struct nk_text_find find;
			nk_textedit_clamp(state);
			nk_textedit_prep_selection_at_cursor(state);
			nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);
			state->has_preferred_x = 0;
			state->cursor = find.first_char + find.length;
			if (find.length > 0 && nk_str_rune_at(&state->string, state->cursor - 1) == '\n')
				--state->cursor;
			state->select_end = state->cursor;
		}
		else {
			struct nk_text_find find;
			nk_textedit_clamp(state);
			nk_textedit_move_to_first(state);
			nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);

			state->has_preferred_x = 0;
			state->cursor = find.first_char + find.length;
			if (find.length > 0 && nk_str_rune_at(&state->string, state->cursor - 1) == '\n')
				--state->cursor;
		}
	}
							 break;
	}
}

NK_INTERN void nk_textedit_flush_redo(struct nk_text_undo_state* state) {
	state->redo_point = NK_TEXTEDIT_UNDOSTATECOUNT;
	state->redo_char_point = NK_TEXTEDIT_UNDOCHARCOUNT;
}

NK_INTERN void nk_textedit_discard_undo(struct nk_text_undo_state* state) {
	/* discard the oldest entry in the undo list */
	if (state->undo_point > 0) {
		/* if the 0th undo state has characters, clean those up */
		if (state->undo_rec[0].char_storage >= 0) {
			int n = state->undo_rec[0].insert_length, i;
			/* delete n characters from all other records */
			state->undo_char_point = (short)(state->undo_char_point - n);
			NK_MEMCPY(state->undo_char, state->undo_char + n, (nk_size)state->undo_char_point * sizeof(nk_rune));
			for (i = 0; i < state->undo_point; ++i) {
				if (state->undo_rec[i].char_storage >= 0)
					state->undo_rec[i].char_storage = (short)(state->undo_rec[i].char_storage - n);
			}
		}
		--state->undo_point;
		NK_MEMCPY(state->undo_rec, state->undo_rec + 1,
			(nk_size)((nk_size)state->undo_point * sizeof(state->undo_rec[0])));
	}
}

NK_INTERN void nk_textedit_discard_redo(struct nk_text_undo_state* state) {
	/*  discard the oldest entry in the redo list--it's bad if this
		ever happens, but because undo & redo have to store the actual
		characters in different cases, the redo character buffer can
		fill up even though the undo buffer didn't */
	nk_size num;
	int k = NK_TEXTEDIT_UNDOSTATECOUNT - 1;
	if (state->redo_point <= k) {
		/* if the k'th undo state has characters, clean those up */
		if (state->undo_rec[k].char_storage >= 0) {
			int n = state->undo_rec[k].insert_length, i;
			/* delete n characters from all other records */
			state->redo_char_point = (short)(state->redo_char_point + n);
			num = (nk_size)(NK_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point);
			NK_MEMCPY(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point - n,
				num * sizeof(char));
			for (i = state->redo_point; i < k; ++i) {
				if (state->undo_rec[i].char_storage >= 0) {
					state->undo_rec[i].char_storage = (short)(state->undo_rec[i].char_storage + n);
				}
			}
		}
		++state->redo_point;
		num = (nk_size)(NK_TEXTEDIT_UNDOSTATECOUNT - state->redo_point);
		if (num)
			NK_MEMCPY(state->undo_rec + state->redo_point - 1, state->undo_rec + state->redo_point,
				num * sizeof(state->undo_rec[0]));
	}
}

NK_INTERN struct nk_text_undo_record* nk_textedit_create_undo_record(struct nk_text_undo_state* state, int numchars) {
	/* any time we create a new undo record, we discard redo*/
	nk_textedit_flush_redo(state);

	/* if we have no free records, we have to make room,
	 * by sliding the existing records down */
	if (state->undo_point == NK_TEXTEDIT_UNDOSTATECOUNT)
		nk_textedit_discard_undo(state);

	/* if the characters to store won't possibly fit in the buffer,
	 * we can't undo */
	if (numchars > NK_TEXTEDIT_UNDOCHARCOUNT) {
		state->undo_point = 0;
		state->undo_char_point = 0;
		return 0;
	}

	/* if we don't have enough free characters in the buffer,
	 * we have to make room */
	while (state->undo_char_point + numchars > NK_TEXTEDIT_UNDOCHARCOUNT)
		nk_textedit_discard_undo(state);
	return &state->undo_rec[state->undo_point++];
}

NK_INTERN nk_rune* nk_textedit_createundo(struct nk_text_undo_state* state, int pos, int insert_len, int delete_len) {
	struct nk_text_undo_record* r = nk_textedit_create_undo_record(state, insert_len);
	if (r == 0)
		return 0;

	r->where = pos;
	r->insert_length = (short)insert_len;
	r->delete_length = (short)delete_len;

	if (insert_len == 0) {
		r->char_storage = -1;
		return 0;
	}
	else {
		r->char_storage = state->undo_char_point;
		state->undo_char_point = (short)(state->undo_char_point + insert_len);
		return &state->undo_char[r->char_storage];
	}
}

NK_API void nk_textedit_undo(struct nk_text_edit* state) {
	struct nk_text_undo_state* s = &state->undo;
	struct nk_text_undo_record u, * r;
	if (s->undo_point == 0)
		return;

	/* we need to do two things: apply the undo record, and create a redo record */
	u = s->undo_rec[s->undo_point - 1];
	r = &s->undo_rec[s->redo_point - 1];
	r->char_storage = -1;

	r->insert_length = u.delete_length;
	r->delete_length = u.insert_length;
	r->where = u.where;

	if (u.delete_length) {
		/*   if the undo record says to delete characters, then the redo record will
			need to re-insert the characters that get deleted, so we need to store
			them.
			there are three cases:
				- there's enough room to store the characters
				- characters stored for *redoing* don't leave room for redo
				- characters stored for *undoing* don't leave room for redo
			if the last is true, we have to bail */
		if (s->undo_char_point + u.delete_length >= NK_TEXTEDIT_UNDOCHARCOUNT) {
			/* the undo records take up too much character space; there's no space
			* to store the redo characters */
			r->insert_length = 0;
		}
		else {
			int i;
			/* there's definitely room to store the characters eventually */
			while (s->undo_char_point + u.delete_length > s->redo_char_point) {
				/* there's currently not enough room, so discard a redo record */
				nk_textedit_discard_redo(s);
				/* should never happen: */
				if (s->redo_point == NK_TEXTEDIT_UNDOSTATECOUNT)
					return;
			}

			r = &s->undo_rec[s->redo_point - 1];
			r->char_storage = (short)(s->redo_char_point - u.delete_length);
			s->redo_char_point = (short)(s->redo_char_point - u.delete_length);

			/* now save the characters */
			for (i = 0; i < u.delete_length; ++i)
				s->undo_char[r->char_storage + i] = nk_str_rune_at(&state->string, u.where + i);
		}
		/* now we can carry out the deletion */
		nk_str_delete_runes(&state->string, u.where, u.delete_length);
	}

	/* check type of recorded action: */
	if (u.insert_length) {
		/* easy case: was a deletion, so we need to insert n characters */
		nk_str_insert_text_runes(&state->string, u.where, &s->undo_char[u.char_storage], u.insert_length);
		s->undo_char_point = (short)(s->undo_char_point - u.insert_length);
	}
	state->cursor = (short)(u.where + u.insert_length);

	s->undo_point--;
	s->redo_point--;
}

NK_API void nk_textedit_redo(struct nk_text_edit* state) {
	struct nk_text_undo_state* s = &state->undo;
	struct nk_text_undo_record* u, r;
	if (s->redo_point == NK_TEXTEDIT_UNDOSTATECOUNT)
		return;

	/* we need to do two things: apply the redo record, and create an undo record */
	u = &s->undo_rec[s->undo_point];
	r = s->undo_rec[s->redo_point];

	/* we KNOW there must be room for the undo record, because the redo record
	was derived from an undo record */
	u->delete_length = r.insert_length;
	u->insert_length = r.delete_length;
	u->where = r.where;
	u->char_storage = -1;

	if (r.delete_length) {
		/* the redo record requires us to delete characters, so the undo record
		needs to store the characters */
		if (s->undo_char_point + u->insert_length > s->redo_char_point) {
			u->insert_length = 0;
			u->delete_length = 0;
		}
		else {
			int i;
			u->char_storage = s->undo_char_point;
			s->undo_char_point = (short)(s->undo_char_point + u->insert_length);

			/* now save the characters */
			for (i = 0; i < u->insert_length; ++i) {
				s->undo_char[u->char_storage + i] = nk_str_rune_at(&state->string, u->where + i);
			}
		}
		nk_str_delete_runes(&state->string, r.where, r.delete_length);
	}

	if (r.insert_length) {
		/* easy case: need to insert n characters */
		nk_str_insert_text_runes(&state->string, r.where, &s->undo_char[r.char_storage], r.insert_length);
	}
	state->cursor = r.where + r.insert_length;

	s->undo_point++;
	s->redo_point++;
}

NK_INTERN void nk_textedit_makeundo_insert(struct nk_text_edit* state, int where, int length) {
	nk_textedit_createundo(&state->undo, where, 0, length);
}

NK_INTERN void nk_textedit_makeundo_delete(struct nk_text_edit* state, int where, int length) {
	int i;
	nk_rune* p = nk_textedit_createundo(&state->undo, where, length, 0);
	if (p) {
		for (i = 0; i < length; ++i)
			p[i] = nk_str_rune_at(&state->string, where + i);
	}
}

NK_INTERN void nk_textedit_makeundo_replace(struct nk_text_edit* state, int where, int old_length, int new_length) {
	int i;
	nk_rune* p = nk_textedit_createundo(&state->undo, where, old_length, new_length);
	if (p) {
		for (i = 0; i < old_length; ++i)
			p[i] = nk_str_rune_at(&state->string, where + i);
	}
}

NK_LIB void nk_textedit_clear_state(struct nk_text_edit* state, enum nk_text_edit_type type, nk_plugin_filter filter) {
	/* reset the state to default */
	state->undo.undo_point = 0;
	state->undo.undo_char_point = 0;
	state->undo.redo_point = NK_TEXTEDIT_UNDOSTATECOUNT;
	state->undo.redo_char_point = NK_TEXTEDIT_UNDOCHARCOUNT;
	state->select_end = state->select_start = 0;
	state->cursor = 0;
	state->has_preferred_x = 0;
	state->preferred_x = 0;
	state->cursor_at_end_of_line = 0;
	state->initialized = 1;
	state->single_line = (unsigned char)(type == NK_TEXT_EDIT_SINGLE_LINE);
	state->mode = NK_TEXT_EDIT_MODE_VIEW;
	state->filter = filter;
	state->scrollbar = nk_vec2(0, 0);
}

NK_API void nk_textedit_init_fixed(struct nk_text_edit* state, void* memory, nk_size size) {
	NK_ASSERT(state);
	NK_ASSERT(memory);
	if (!state || !memory || !size) return;
	NK_MEMSET(state, 0, sizeof(struct nk_text_edit));
	nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, 0);
	nk_str_init_fixed(&state->string, memory, size);
}

NK_API void nk_textedit_init(struct nk_text_edit* state, struct nk_allocator* alloc, nk_size size) {
	NK_ASSERT(state);
	NK_ASSERT(alloc);
	if (!state || !alloc) return;
	NK_MEMSET(state, 0, sizeof(struct nk_text_edit));
	nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, 0);
	nk_str_init(&state->string, alloc, size);
}

#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

NK_API void nk_textedit_init_default(struct nk_text_edit* state) {
	NK_ASSERT(state);
	if (!state) return;
	NK_MEMSET(state, 0, sizeof(struct nk_text_edit));
	nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, 0);
	nk_str_init_default(&state->string);
}

#endif

NK_API void nk_textedit_select_all(struct nk_text_edit* state) {
	NK_ASSERT(state);
	state->select_start = 0;
	state->select_end = state->string.len;
}

NK_API void nk_textedit_free(struct nk_text_edit* state) {
	NK_ASSERT(state);
	if (!state) return;
	nk_str_free(&state->string);
}





/* ===============================================================
 *
 *                          FILTER
 *
 * ===============================================================*/
NK_API int nk_filter_default(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(unicode);
	NK_UNUSED(box);
	return nk_true;
}

NK_API int nk_filter_ascii(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if (unicode > 128) return nk_false;
	else return nk_true;
}

NK_API int nk_filter_float(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if ((unicode < '0' || unicode > '9') && unicode != '.' && unicode != '-')
		return nk_false;
	else return nk_true;
}

NK_API int nk_filter_decimal(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if ((unicode < '0' || unicode > '9') && unicode != '-')
		return nk_false;
	else return nk_true;
}

NK_API int nk_filter_hex(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if ((unicode < '0' || unicode > '9') && (unicode < 'a' || unicode > 'f') && (unicode < 'A' || unicode > 'F'))
		return nk_false;
	else return nk_true;
}

NK_API int nk_filter_oct(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if (unicode < '0' || unicode > '7')
		return nk_false;
	else return nk_true;
}

NK_API int nk_filter_binary(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if (unicode != '0' && unicode != '1')
		return nk_false;
	else return nk_true;
}

/* ===============================================================
 *
 *                          EDIT
 *
 * ===============================================================*/
NK_LIB void
nk_edit_draw_text(struct nk_command_buffer* out, const struct nk_style_edit* style, float pos_x, float pos_y,
	float x_offset, const char* text, int byte_len, float row_height, const struct nk_user_font* font,
	struct nk_color background, struct nk_color foreground, int is_selected) {
	NK_ASSERT(out);
	NK_ASSERT(font);
	NK_ASSERT(style);
	if (!text || !byte_len || !out || !style) return;

	{
		int glyph_len = 0;
		nk_rune unicode = 0;
		int text_len = 0;
		float line_width = 0;
		float glyph_width;
		const char* line = text;
		float line_offset = 0;
		int line_count = 0;

		struct nk_text txt;
		txt.padding = nk_vec2(0, 0);
		txt.background = background;
		txt.text = foreground;

		glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len - text_len);
		if (!glyph_len) return;
		while ((text_len < byte_len) && glyph_len) {
			if (unicode == '\n') {
				/* new line separator so draw previous line */
				struct nk_rect label;
				label.y = pos_y + line_offset;
				label.h = row_height;
				label.w = line_width;
				label.x = pos_x;
				if (!line_count)
					label.x += x_offset;

				if (is_selected) /* selection needs to draw different background color */
					nk_fill_rect(out, label, 0, background);
				nk_widget_text(out, label, line, (int)((text + text_len) - line), &txt, NK_TEXT_CENTERED, font);

				text_len++;
				line_count++;
				line_width = 0;
				line = text + text_len;
				line_offset += row_height;
				glyph_len = nk_utf_decode(text + text_len, &unicode, (int)(byte_len - text_len));
				continue;
			}
			if (unicode == '\r') {
				text_len++;
				glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len - text_len);
				continue;
			}
			glyph_width = font->width(font->userdata, font->height, text + text_len, glyph_len);
			line_width += (float)glyph_width;
			text_len += glyph_len;
			glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len - text_len);
			continue;
		}
		if (line_width > 0) {
			/* draw last line */
			struct nk_rect label;
			label.y = pos_y + line_offset;
			label.h = row_height;
			label.w = line_width;
			label.x = pos_x;
			if (!line_count)
				label.x += x_offset;

			if (is_selected)
				nk_fill_rect(out, label, 0, background);
			nk_widget_text(out, label, line, (int)((text + text_len) - line), &txt, NK_TEXT_LEFT, font);
		}
	}
}

NK_LIB nk_flags nk_do_edit(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, nk_flags flags,
	nk_plugin_filter filter, struct nk_text_edit* edit, const struct nk_style_edit* style,
	struct nk_input* in, const struct nk_user_font* font) {
	struct nk_rect area;
	nk_flags ret = 0;
	float row_height;
	char prev_state = 0;
	char is_hovered = 0;
	char select_all = 0;
	char cursor_follow = 0;
	struct nk_rect old_clip;
	struct nk_rect clip;

	NK_ASSERT(state);
	NK_ASSERT(out);
	NK_ASSERT(style);
	if (!state || !out || !style)
		return ret;

	/* visible text area calculation */
	area.x = bounds.x + style->padding.x + style->border;
	area.y = bounds.y + style->padding.y + style->border;
	area.w = bounds.w - (2.0f * style->padding.x + 2 * style->border);
	area.h = bounds.h - (2.0f * style->padding.y + 2 * style->border);
	if (flags & NK_EDIT_MULTILINE)
		area.w = NK_MAX(0, area.w - style->scrollbar_size.x);
	row_height = (flags & NK_EDIT_MULTILINE) ? font->height + style->row_padding : area.h;

	/* calculate clipping rectangle */
	old_clip = out->clip;
	nk_unify(&clip, &old_clip, area.x, area.y, area.x + area.w, area.y + area.h);

	/* update edit state */
	prev_state = (char)edit->active;
	is_hovered = (char)nk_input_is_mouse_hovering_rect(in, bounds);
	if (in && in->mouse.buttons[NK_BUTTON_LEFT].clicked && in->mouse.buttons[NK_BUTTON_LEFT].down) {
		edit->active = NK_INBOX(in->mouse.pos.x, in->mouse.pos.y, bounds.x, bounds.y, bounds.w, bounds.h);
	}

	/* (de)activate text editor */
	if (!prev_state && edit->active) {
		const enum nk_text_edit_type type = (flags & NK_EDIT_MULTILINE) ? NK_TEXT_EDIT_MULTI_LINE
			: NK_TEXT_EDIT_SINGLE_LINE;
		nk_textedit_clear_state(edit, type, filter);
		if (flags & NK_EDIT_AUTO_SELECT)
			select_all = nk_true;
		if (flags & NK_EDIT_GOTO_END_ON_ACTIVATE) {
			edit->cursor = edit->string.len;
			in = 0;
		}
	}
	else if (!edit->active) edit->mode = NK_TEXT_EDIT_MODE_VIEW;
	if (flags & NK_EDIT_READ_ONLY)
		edit->mode = NK_TEXT_EDIT_MODE_VIEW;
	else if (flags & NK_EDIT_ALWAYS_INSERT_MODE)
		edit->mode = NK_TEXT_EDIT_MODE_INSERT;

	ret = (edit->active) ? NK_EDIT_ACTIVE : NK_EDIT_INACTIVE;
	if (prev_state != edit->active)
		ret |= (edit->active) ? NK_EDIT_ACTIVATED : NK_EDIT_DEACTIVATED;

	/* handle user input */
	if (edit->active && in) {
		int shift_mod = in->keyboard.keys[NK_KEY_SHIFT].down;
		const float mouse_x = (in->mouse.pos.x - area.x) + edit->scrollbar.x;
		const float mouse_y = (in->mouse.pos.y - area.y) + edit->scrollbar.y;

		/* mouse click handler */
		is_hovered = (char)nk_input_is_mouse_hovering_rect(in, area);
		if (select_all) {
			nk_textedit_select_all(edit);
		}
		else if (is_hovered && in->mouse.buttons[NK_BUTTON_LEFT].down && in->mouse.buttons[NK_BUTTON_LEFT].clicked) {
			nk_textedit_click(edit, mouse_x, mouse_y, font, row_height);
		}
		else if (is_hovered && in->mouse.buttons[NK_BUTTON_LEFT].down &&
			(in->mouse.delta.x != 0.0f || in->mouse.delta.y != 0.0f)) {
			nk_textedit_drag(edit, mouse_x, mouse_y, font, row_height);
			cursor_follow = nk_true;
		}
		else if (is_hovered && in->mouse.buttons[NK_BUTTON_RIGHT].clicked &&
			in->mouse.buttons[NK_BUTTON_RIGHT].down) {
			nk_textedit_key(edit, NK_KEY_TEXT_WORD_LEFT, nk_false, font, row_height);
			nk_textedit_key(edit, NK_KEY_TEXT_WORD_RIGHT, nk_true, font, row_height);
			cursor_follow = nk_true;
		}

		{
			int i; /* keyboard input */
			int old_mode = edit->mode;
			for (i = 0; i < NK_KEY_MAX; ++i) {
				if (i == NK_KEY_ENTER || i == NK_KEY_TAB) continue; /* special case */
				if (nk_input_is_key_pressed(in, (enum nk_keys) i)) {
					nk_textedit_key(edit, (enum nk_keys) i, shift_mod, font, row_height);
					cursor_follow = nk_true;
				}
			}
			if (old_mode != edit->mode) {
				in->keyboard.text_len = 0;
			}
		}

		/* text input */
		edit->filter = filter;
		if (in->keyboard.text_len) {
			nk_textedit_text(edit, in->keyboard.text, in->keyboard.text_len);
			cursor_follow = nk_true;
			in->keyboard.text_len = 0;
		}

		/* enter key handler */
		if (nk_input_is_key_pressed(in, NK_KEY_ENTER)) {
			cursor_follow = nk_true;
			if (flags & NK_EDIT_CTRL_ENTER_NEWLINE && shift_mod)
				nk_textedit_text(edit, "\n", 1);
			else if (flags & NK_EDIT_SIG_ENTER)
				ret |= NK_EDIT_COMMITED;
			else nk_textedit_text(edit, "\n", 1);
		}

		/* cut & copy handler */
		{
			int copy = nk_input_is_key_pressed(in, NK_KEY_COPY);
			int cut = nk_input_is_key_pressed(in, NK_KEY_CUT);
			if ((copy || cut) && (flags & NK_EDIT_CLIPBOARD)) {
				int glyph_len;
				nk_rune unicode;
				const char* text;
				int b = edit->select_start;
				int e = edit->select_end;

				int begin = NK_MIN(b, e);
				int end = NK_MAX(b, e);
				text = nk_str_at_const(&edit->string, begin, &unicode, &glyph_len);
				if (edit->clip.copy)
					edit->clip.copy(edit->clip.userdata, text, end - begin);
				if (cut && !(flags & NK_EDIT_READ_ONLY)) {
					nk_textedit_cut(edit);
					cursor_follow = nk_true;
				}
			}
		}

		/* paste handler */
		{
			int paste = nk_input_is_key_pressed(in, NK_KEY_PASTE);
			if (paste && (flags & NK_EDIT_CLIPBOARD) && edit->clip.paste) {
				edit->clip.paste(edit->clip.userdata, edit);
				cursor_follow = nk_true;
			}
		}

		/* tab handler */
		{
			int tab = nk_input_is_key_pressed(in, NK_KEY_TAB);
			if (tab && (flags & NK_EDIT_ALLOW_TAB)) {
				nk_textedit_text(edit, "    ", 4);
				cursor_follow = nk_true;
			}
		}
	}

	/* set widget state */
	if (edit->active)
		*state = NK_WIDGET_STATE_ACTIVE;
	else nk_widget_state_reset(state);

	if (is_hovered)
		*state |= NK_WIDGET_STATE_HOVERED;

	/* DRAW EDIT */
	{
		const char* text = nk_str_get_const(&edit->string);
		int len = nk_str_len_char(&edit->string);

		{/* select background colors/images  */
			const struct nk_style_item* background;
			if (*state & NK_WIDGET_STATE_ACTIVED)
				background = &style->active;
			else if (*state & NK_WIDGET_STATE_HOVER)
				background = &style->hover;
			else background = &style->normal;

			/* draw background frame */
			if (background->type == NK_STYLE_ITEM_COLOR) {
				nk_stroke_rect(out, bounds, style->rounding, style->border, style->border_color);
				nk_fill_rect(out, bounds, style->rounding, background->data.color);
			}
			else nk_draw_image(out, bounds, &background->data.image, nk_white);
		}

		area.w = NK_MAX(0, area.w - style->cursor_size);
		if (edit->active) {
			int total_lines = 1;
			struct nk_vec2 text_size = nk_vec2(0, 0);

			/* text pointer positions */
			const char* cursor_ptr = 0;
			const char* select_begin_ptr = 0;
			const char* select_end_ptr = 0;

			/* 2D pixel positions */
			struct nk_vec2 cursor_pos = nk_vec2(0, 0);
			struct nk_vec2 selection_offset_start = nk_vec2(0, 0);
			struct nk_vec2 selection_offset_end = nk_vec2(0, 0);

			int selection_begin = NK_MIN(edit->select_start, edit->select_end);
			int selection_end = NK_MAX(edit->select_start, edit->select_end);

			/* calculate total line count + total space + cursor/selection position */
			float line_width = 0.0f;
			if (text && len) {
				/* utf8 encoding */
				float glyph_width;
				int glyph_len = 0;
				nk_rune unicode = 0;
				int text_len = 0;
				int glyphs = 0;
				int row_begin = 0;

				glyph_len = nk_utf_decode(text, &unicode, len);
				glyph_width = font->width(font->userdata, font->height, text, glyph_len);
				line_width = 0;

				/* iterate all lines */
				while ((text_len < len) && glyph_len) {
					/* set cursor 2D position and line */
					if (!cursor_ptr && glyphs == edit->cursor) {
						int glyph_offset;
						struct nk_vec2 out_offset;
						struct nk_vec2 row_size;
						const char* remaining;

						/* calculate 2d position */
						cursor_pos.y = (float)(total_lines - 1) * row_height;
						row_size = nk_text_calculate_text_bounds(font, text + row_begin, text_len - row_begin,
							row_height, &remaining, &out_offset, &glyph_offset,
							NK_STOP_ON_NEW_LINE);
						cursor_pos.x = row_size.x;
						cursor_ptr = text + text_len;
					}

					/* set start selection 2D position and line */
					if (!select_begin_ptr && edit->select_start != edit->select_end && glyphs == selection_begin) {
						int glyph_offset;
						struct nk_vec2 out_offset;
						struct nk_vec2 row_size;
						const char* remaining;

						/* calculate 2d position */
						selection_offset_start.y = (float)(NK_MAX(total_lines - 1, 0)) * row_height;
						row_size = nk_text_calculate_text_bounds(font, text + row_begin, text_len - row_begin,
							row_height, &remaining, &out_offset, &glyph_offset,
							NK_STOP_ON_NEW_LINE);
						selection_offset_start.x = row_size.x;
						select_begin_ptr = text + text_len;
					}

					/* set end selection 2D position and line */
					if (!select_end_ptr && edit->select_start != edit->select_end && glyphs == selection_end) {
						int glyph_offset;
						struct nk_vec2 out_offset;
						struct nk_vec2 row_size;
						const char* remaining;

						/* calculate 2d position */
						selection_offset_end.y = (float)(total_lines - 1) * row_height;
						row_size = nk_text_calculate_text_bounds(font, text + row_begin, text_len - row_begin,
							row_height, &remaining, &out_offset, &glyph_offset,
							NK_STOP_ON_NEW_LINE);
						selection_offset_end.x = row_size.x;
						select_end_ptr = text + text_len;
					}
					if (unicode == '\n') {
						text_size.x = NK_MAX(text_size.x, line_width);
						total_lines++;
						line_width = 0;
						text_len++;
						glyphs++;
						row_begin = text_len;
						glyph_len = nk_utf_decode(text + text_len, &unicode, len - text_len);
						glyph_width = font->width(font->userdata, font->height, text + text_len, glyph_len);
						continue;
					}

					glyphs++;
					text_len += glyph_len;
					line_width += (float)glyph_width;

					glyph_len = nk_utf_decode(text + text_len, &unicode, len - text_len);
					glyph_width = font->width(font->userdata, font->height, text + text_len, glyph_len);
					continue;
				}
				text_size.y = (float)total_lines * row_height;

				/* handle case when cursor is at end of text buffer */
				if (!cursor_ptr && edit->cursor == edit->string.len) {
					cursor_pos.x = line_width;
					cursor_pos.y = text_size.y - row_height;
				}
			}
			{
				/* scrollbar */
				if (cursor_follow) {
					/* update scrollbar to follow cursor */
					if (!(flags & NK_EDIT_NO_HORIZONTAL_SCROLL)) {
						/* horizontal scroll */
						const float scroll_increment = area.w * 0.25f;
						if (cursor_pos.x < edit->scrollbar.x)
							edit->scrollbar.x = (float)(int)NK_MAX(0.0f, cursor_pos.x - scroll_increment);
						if (cursor_pos.x >= edit->scrollbar.x + area.w)
							edit->scrollbar.x = (float)(int)NK_MAX(0.0f, edit->scrollbar.x + scroll_increment);
					}
					else edit->scrollbar.x = 0;

					if (flags & NK_EDIT_MULTILINE) {
						/* vertical scroll */
						if (cursor_pos.y < edit->scrollbar.y)
							edit->scrollbar.y = NK_MAX(0.0f, cursor_pos.y - row_height);
						if (cursor_pos.y >= edit->scrollbar.y + area.h)
							edit->scrollbar.y = edit->scrollbar.y + row_height;
					}
					else edit->scrollbar.y = 0;
				}

				/* scrollbar widget */
				if (flags & NK_EDIT_MULTILINE) {
					nk_flags ws;
					struct nk_rect scroll;
					float scroll_target;
					float scroll_offset;
					float scroll_step;
					float scroll_inc;

					scroll = area;
					scroll.x = (bounds.x + bounds.w - style->border) - style->scrollbar_size.x;
					scroll.w = style->scrollbar_size.x;

					scroll_offset = edit->scrollbar.y;
					scroll_step = scroll.h * 0.10f;
					scroll_inc = scroll.h * 0.01f;
					scroll_target = text_size.y;
					edit->scrollbar.y = nk_do_scrollbarv(&ws, out, scroll, 0, scroll_offset, scroll_target, scroll_step,
						scroll_inc, &style->scrollbar, in, font);
				}
			}

			/* draw text */
			{
				struct nk_color background_color;
				struct nk_color text_color;
				struct nk_color sel_background_color;
				struct nk_color sel_text_color;
				struct nk_color cursor_color;
				struct nk_color cursor_text_color;
				const struct nk_style_item* background;
				nk_push_scissor(out, clip);

				/* select correct colors to draw */
				if (*state & NK_WIDGET_STATE_ACTIVED) {
					background = &style->active;
					text_color = style->text_active;
					sel_text_color = style->selected_text_hover;
					sel_background_color = style->selected_hover;
					cursor_color = style->cursor_hover;
					cursor_text_color = style->cursor_text_hover;
				}
				else if (*state & NK_WIDGET_STATE_HOVER) {
					background = &style->hover;
					text_color = style->text_hover;
					sel_text_color = style->selected_text_hover;
					sel_background_color = style->selected_hover;
					cursor_text_color = style->cursor_text_hover;
					cursor_color = style->cursor_hover;
				}
				else {
					background = &style->normal;
					text_color = style->text_normal;
					sel_text_color = style->selected_text_normal;
					sel_background_color = style->selected_normal;
					cursor_color = style->cursor_normal;
					cursor_text_color = style->cursor_text_normal;
				}
				if (background->type == NK_STYLE_ITEM_IMAGE)
					background_color = nk_rgba(0, 0, 0, 0);
				else background_color = background->data.color;


				if (edit->select_start == edit->select_end) {
					/* no selection so just draw the complete text */
					const char* begin = nk_str_get_const(&edit->string);
					int l = nk_str_len_char(&edit->string);
					nk_edit_draw_text(out, style, area.x - edit->scrollbar.x, area.y - edit->scrollbar.y, 0, begin, l,
						row_height, font, background_color, text_color, nk_false);
				}
				else {
					/* edit has selection so draw 1-3 text chunks */
					if (edit->select_start != edit->select_end && selection_begin > 0) {
						/* draw unselected text before selection */
						const char* begin = nk_str_get_const(&edit->string);
						NK_ASSERT(select_begin_ptr);
						nk_edit_draw_text(out, style, area.x - edit->scrollbar.x, area.y - edit->scrollbar.y, 0, begin,
							(int)(select_begin_ptr - begin), row_height, font, background_color,
							text_color, nk_false);
					}
					if (edit->select_start != edit->select_end) {
						/* draw selected text */
						NK_ASSERT(select_begin_ptr);
						if (!select_end_ptr) {
							const char* begin = nk_str_get_const(&edit->string);
							select_end_ptr = begin + nk_str_len_char(&edit->string);
						}
						nk_edit_draw_text(out, style, area.x - edit->scrollbar.x,
							area.y + selection_offset_start.y - edit->scrollbar.y,
							selection_offset_start.x, select_begin_ptr,
							(int)(select_end_ptr - select_begin_ptr), row_height, font,
							sel_background_color, sel_text_color, nk_true);
					}
					if ((edit->select_start != edit->select_end && selection_end < edit->string.len)) {
						/* draw unselected text after selected text */
						const char* begin = select_end_ptr;
						const char* end = nk_str_get_const(&edit->string) + nk_str_len_char(&edit->string);
						NK_ASSERT(select_end_ptr);
						nk_edit_draw_text(out, style, area.x - edit->scrollbar.x,
							area.y + selection_offset_end.y - edit->scrollbar.y, selection_offset_end.x,
							begin, (int)(end - begin), row_height, font, background_color, text_color,
							nk_true);
					}
				}

				/* cursor */
				if (edit->select_start == edit->select_end) {
					if (edit->cursor >= nk_str_len(&edit->string) || (cursor_ptr && *cursor_ptr == '\n')) {
						/* draw cursor at end of line */
						struct nk_rect cursor;
						cursor.w = style->cursor_size;
						cursor.h = font->height;
						cursor.x = area.x + cursor_pos.x - edit->scrollbar.x;
						cursor.y = area.y + cursor_pos.y + row_height / 2.0f - cursor.h / 2.0f;
						cursor.y -= edit->scrollbar.y;
						nk_fill_rect(out, cursor, 0, cursor_color);
					}
					else {
						/* draw cursor inside text */
						int glyph_len;
						struct nk_rect label;
						struct nk_text txt;

						nk_rune unicode;
						NK_ASSERT(cursor_ptr);
						glyph_len = nk_utf_decode(cursor_ptr, &unicode, 4);

						label.x = area.x + cursor_pos.x - edit->scrollbar.x;
						label.y = area.y + cursor_pos.y - edit->scrollbar.y;
						label.w = font->width(font->userdata, font->height, cursor_ptr, glyph_len);
						label.h = row_height;

						txt.padding = nk_vec2(0, 0);
						txt.background = cursor_color;;
						txt.text = cursor_text_color;
						nk_fill_rect(out, label, 0, cursor_color);
						nk_widget_text(out, label, cursor_ptr, glyph_len, &txt, NK_TEXT_LEFT, font);
					}
				}
			}
		}
		else {
			/* not active so just draw text */
			int l = nk_str_len_char(&edit->string);
			const char* begin = nk_str_get_const(&edit->string);

			const struct nk_style_item* background;
			struct nk_color background_color;
			struct nk_color text_color;
			nk_push_scissor(out, clip);
			if (*state & NK_WIDGET_STATE_ACTIVED) {
				background = &style->active;
				text_color = style->text_active;
			}
			else if (*state & NK_WIDGET_STATE_HOVER) {
				background = &style->hover;
				text_color = style->text_hover;
			}
			else {
				background = &style->normal;
				text_color = style->text_normal;
			}
			if (background->type == NK_STYLE_ITEM_IMAGE)
				background_color = nk_rgba(0, 0, 0, 0);
			else background_color = background->data.color;
			nk_edit_draw_text(out, style, area.x - edit->scrollbar.x, area.y - edit->scrollbar.y, 0, begin, l,
				row_height, font, background_color, text_color, nk_false);
		}
		nk_push_scissor(out, old_clip);
	}
	return ret;
}

NK_API void nk_edit_focus(struct nk_context* ctx, nk_flags flags) {
	nk_hash hash;
	struct nk_window* win;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return;

	win = ctx->current;
	hash = win->edit.seq;
	win->edit.active = nk_true;
	win->edit.name = hash;
	if (flags & NK_EDIT_ALWAYS_INSERT_MODE)
		win->edit.mode = NK_TEXT_EDIT_MODE_INSERT;
}

NK_API void nk_edit_unfocus(struct nk_context* ctx) {
	struct nk_window* win;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return;

	win = ctx->current;
	win->edit.active = nk_false;
	win->edit.name = 0;
}

NK_API nk_flags
nk_edit_string(struct nk_context* ctx, nk_flags flags, char* memory, int* len, int max, nk_plugin_filter filter) {
	nk_hash hash;
	nk_flags state;
	struct nk_text_edit* edit;
	struct nk_window* win;

	NK_ASSERT(ctx);
	NK_ASSERT(memory);
	NK_ASSERT(len);
	if (!ctx || !memory || !len)
		return 0;

	filter = (!filter) ? nk_filter_default : filter;
	win = ctx->current;
	hash = win->edit.seq;
	edit = &ctx->text_edit;
	nk_textedit_clear_state(&ctx->text_edit,
		(flags & NK_EDIT_MULTILINE) ? NK_TEXT_EDIT_MULTI_LINE : NK_TEXT_EDIT_SINGLE_LINE, filter);

	if (win->edit.active && hash == win->edit.name) {
		if (flags & NK_EDIT_NO_CURSOR)
			edit->cursor = nk_utf_len(memory, *len);
		else edit->cursor = win->edit.cursor;
		if (!(flags & NK_EDIT_SELECTABLE)) {
			edit->select_start = win->edit.cursor;
			edit->select_end = win->edit.cursor;
		}
		else {
			edit->select_start = win->edit.sel_start;
			edit->select_end = win->edit.sel_end;
		}
		edit->mode = win->edit.mode;
		edit->scrollbar.x = (float)win->edit.scrollbar.x;
		edit->scrollbar.y = (float)win->edit.scrollbar.y;
		edit->active = nk_true;
	}
	else edit->active = nk_false;

	max = NK_MAX(1, max);
	*len = NK_MIN(*len, max - 1);
	nk_str_init_fixed(&edit->string, memory, (nk_size)max);
	edit->string.buffer.allocated = (nk_size)*len;
	edit->string.len = nk_utf_len(memory, *len);
	state = nk_edit_buffer(ctx, flags, edit, filter);
	*len = (int)edit->string.buffer.allocated;

	if (edit->active) {
		win->edit.cursor = edit->cursor;
		win->edit.sel_start = edit->select_start;
		win->edit.sel_end = edit->select_end;
		win->edit.mode = edit->mode;
		win->edit.scrollbar.x = (nk_uint)edit->scrollbar.x;
		win->edit.scrollbar.y = (nk_uint)edit->scrollbar.y;
	}
	return state;
}

NK_API nk_flags
nk_edit_buffer(struct nk_context* ctx, nk_flags flags, struct nk_text_edit* edit, nk_plugin_filter filter) {
	struct nk_window* win;
	struct nk_style* style;
	struct nk_input* in;

	enum nk_widget_layout_states state;
	struct nk_rect bounds;

	nk_flags ret_flags = 0;
	unsigned char prev_state;
	nk_hash hash;

	/* make sure correct values */
	NK_ASSERT(ctx);
	NK_ASSERT(edit);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	state = nk_widget(&bounds, ctx);
	if (!state) return state;
	in = (win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;

	/* check if edit is currently hot item */
	hash = win->edit.seq++;
	if (win->edit.active && hash == win->edit.name) {
		if (flags & NK_EDIT_NO_CURSOR)
			edit->cursor = edit->string.len;
		if (!(flags & NK_EDIT_SELECTABLE)) {
			edit->select_start = edit->cursor;
			edit->select_end = edit->cursor;
		}
		if (flags & NK_EDIT_CLIPBOARD)
			edit->clip = ctx->clip;
		edit->active = (unsigned char)win->edit.active;
	}
	else edit->active = nk_false;
	edit->mode = win->edit.mode;

	filter = (!filter) ? nk_filter_default : filter;
	prev_state = (unsigned char)edit->active;
	in = (flags & NK_EDIT_READ_ONLY) ? 0 : in;
	ret_flags = nk_do_edit(&ctx->last_widget_state, &win->buffer, bounds, flags, filter, edit, &style->edit, in,
		style->font);

	if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
		ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_TEXT];
	if (edit->active && prev_state != edit->active) {
		/* current edit is now hot */
		win->edit.active = nk_true;
		win->edit.name = hash;
	}
	else if (prev_state && !edit->active) {
		/* current edit is now cold */
		win->edit.active = nk_false;
	}
	return ret_flags;
}

NK_API nk_flags
nk_edit_string_zero_terminated(struct nk_context* ctx, nk_flags flags, char* buffer, int max, nk_plugin_filter filter) {
	nk_flags result;
	int len = nk_strlen(buffer);
	result = nk_edit_string(ctx, flags, buffer, &len, max, filter);
	buffer[NK_MIN(NK_MAX(max - 1, 0), len)] = '\0';
	return result;
}





/* ===============================================================
 *
 *                              PROPERTY
 *
 * ===============================================================*/
NK_LIB void
nk_drag_behavior(nk_flags* state, const struct nk_input* in, struct nk_rect drag, struct nk_property_variant* variant,
	float inc_per_pixel) {
	int left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;
	int left_mouse_click_in_cursor = in && nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, drag, nk_true);

	nk_widget_state_reset(state);
	if (nk_input_is_mouse_hovering_rect(in, drag))
		*state = NK_WIDGET_STATE_HOVERED;

	if (left_mouse_down && left_mouse_click_in_cursor) {
		float delta, pixels;
		pixels = in->mouse.delta.x;
		delta = pixels * inc_per_pixel;
		switch (variant->kind) {
		default:
			break;
		case NK_PROPERTY_INT:
			variant->value.i = variant->value.i + (int)delta;
			variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i, variant->max_value.i);
			break;
		case NK_PROPERTY_FLOAT:
			variant->value.f = variant->value.f + (float)delta;
			variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f, variant->max_value.f);
			break;
		case NK_PROPERTY_DOUBLE:
			variant->value.d = variant->value.d + (double)delta;
			variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d, variant->max_value.d);
			break;
		}
		*state = NK_WIDGET_STATE_ACTIVE;
	}
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, drag))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, drag))
		*state |= NK_WIDGET_STATE_LEFT;
}

NK_LIB void nk_property_behavior(nk_flags* ws, const struct nk_input* in, struct nk_rect property, struct nk_rect label,
	struct nk_rect edit, struct nk_rect empty, int* state,
	struct nk_property_variant* variant, float inc_per_pixel) {
	if (in && *state == NK_PROPERTY_DEFAULT) {
		if (nk_button_behavior(ws, edit, in, NK_BUTTON_DEFAULT))
			*state = NK_PROPERTY_EDIT;
		else if (nk_input_is_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, label, nk_true))
			*state = NK_PROPERTY_DRAG;
		else if (nk_input_is_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, empty, nk_true))
			*state = NK_PROPERTY_DRAG;
	}
	if (*state == NK_PROPERTY_DRAG) {
		nk_drag_behavior(ws, in, property, variant, inc_per_pixel);
		if (!(*ws & NK_WIDGET_STATE_ACTIVED)) *state = NK_PROPERTY_DEFAULT;
	}
}

NK_LIB void
nk_draw_property(struct nk_command_buffer* out, const struct nk_style_property* style, const struct nk_rect* bounds,
	const struct nk_rect* label, nk_flags state, const char* name, int len,
	const struct nk_user_font* font) {
	struct nk_text text;
	const struct nk_style_item* background;

	/* select correct background and text color */
	if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->active;
		text.text = style->label_active;
	}
	else if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		text.text = style->label_hover;
	}
	else {
		background = &style->normal;
		text.text = style->label_normal;
	}

	/* draw background */
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(out, *bounds, &background->data.image, nk_white);
		text.background = nk_rgba(0, 0, 0, 0);
	}
	else {
		text.background = background->data.color;
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		nk_stroke_rect(out, *bounds, style->rounding, style->border, background->data.color);
	}

	/* draw label */
	text.padding = nk_vec2(0, 0);
	nk_widget_text(out, *label, name, len, &text, NK_TEXT_CENTERED, font);
}

NK_LIB void nk_do_property(nk_flags* ws, struct nk_command_buffer* out, struct nk_rect property, const char* name,
	struct nk_property_variant* variant, float inc_per_pixel, char* buffer, int* len, int* state,
	int* cursor, int* select_begin, int* select_end, const struct nk_style_property* style,
	enum nk_property_filter filter, struct nk_input* in, const struct nk_user_font* font,
	struct nk_text_edit* text_edit, enum nk_button_behavior behavior) {
	const nk_plugin_filter filters[] = { nk_filter_decimal, nk_filter_float };
	int active, old;
	int num_len, name_len;
	char string[NK_MAX_NUMBER_BUFFER];
	float size;

	char* dst = 0;
	int* length;

	struct nk_rect left;
	struct nk_rect right;
	struct nk_rect label;
	struct nk_rect edit;
	struct nk_rect empty;

	/* left decrement button */
	left.h = font->height / 2;
	left.w = left.h;
	left.x = property.x + style->border + style->padding.x;
	left.y = property.y + style->border + property.h / 2.0f - left.h / 2;

	/* text label */
	name_len = nk_strlen(name);
	size = font->width(font->userdata, font->height, name, name_len);
	label.x = left.x + left.w + style->padding.x;
	label.w = (float)size + 2 * style->padding.x;
	label.y = property.y + style->border + style->padding.y;
	label.h = property.h - (2 * style->border + 2 * style->padding.y);

	/* right increment button */
	right.y = left.y;
	right.w = left.w;
	right.h = left.h;
	right.x = property.x + property.w - (right.w + style->padding.x);

	/* edit */
	if (*state == NK_PROPERTY_EDIT) {
		size = font->width(font->userdata, font->height, buffer, *len);
		size += style->edit.cursor_size;
		length = len;
		dst = buffer;
	}
	else {
		switch (variant->kind) {
		default:
			break;
		case NK_PROPERTY_INT:
			nk_itoa(string, variant->value.i);
			num_len = nk_strlen(string);
			break;
		case NK_PROPERTY_FLOAT:
			NK_DTOA(string, (double)variant->value.f);
			num_len = nk_string_float_limit(string, NK_MAX_FLOAT_PRECISION);
			break;
		case NK_PROPERTY_DOUBLE:
			NK_DTOA(string, variant->value.d);
			num_len = nk_string_float_limit(string, NK_MAX_FLOAT_PRECISION);
			break;
		}
		size = font->width(font->userdata, font->height, string, num_len);
		dst = string;
		length = &num_len;
	}

	edit.w = (float)size + 2 * style->padding.x;
	edit.w = NK_MIN(edit.w, right.x - (label.x + label.w));
	edit.x = right.x - (edit.w + style->padding.x);
	edit.y = property.y + style->border;
	edit.h = property.h - (2 * style->border);

	/* empty left space activator */
	empty.w = edit.x - (label.x + label.w);
	empty.x = label.x + label.w;
	empty.y = property.y;
	empty.h = property.h;

	/* update property */
	old = (*state == NK_PROPERTY_EDIT);
	nk_property_behavior(ws, in, property, label, edit, empty, state, variant, inc_per_pixel);

	/* draw property */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_property(out, style, &property, &label, *ws, name, name_len, font);
	if (style->draw_end) style->draw_end(out, style->userdata);

	/* execute right button  */
	if (nk_do_button_symbol(ws, out, left, style->sym_left, behavior, &style->dec_button, in, font)) {
		switch (variant->kind) {
		default:
			break;
		case NK_PROPERTY_INT:
			variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i - variant->step.i,
				variant->max_value.i);
			break;
		case NK_PROPERTY_FLOAT:
			variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f - variant->step.f,
				variant->max_value.f);
			break;
		case NK_PROPERTY_DOUBLE:
			variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d - variant->step.d,
				variant->max_value.d);
			break;
		}
	}
	/* execute left button  */
	if (nk_do_button_symbol(ws, out, right, style->sym_right, behavior, &style->inc_button, in, font)) {
		switch (variant->kind) {
		default:
			break;
		case NK_PROPERTY_INT:
			variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i + variant->step.i,
				variant->max_value.i);
			break;
		case NK_PROPERTY_FLOAT:
			variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f + variant->step.f,
				variant->max_value.f);
			break;
		case NK_PROPERTY_DOUBLE:
			variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d + variant->step.d,
				variant->max_value.d);
			break;
		}
	}
	if (old != NK_PROPERTY_EDIT && (*state == NK_PROPERTY_EDIT)) {
		/* property has been activated so setup buffer */
		NK_MEMCPY(buffer, dst, (nk_size)*length);
		*cursor = nk_utf_len(buffer, *length);
		*len = *length;
		length = len;
		dst = buffer;
		active = 0;
	}
	else active = (*state == NK_PROPERTY_EDIT);

	/* execute and run text edit field */
	nk_textedit_clear_state(text_edit, NK_TEXT_EDIT_SINGLE_LINE, filters[filter]);
	text_edit->active = (unsigned char)active;
	text_edit->string.len = *length;
	text_edit->cursor = NK_CLAMP(0, *cursor, *length);
	text_edit->select_start = NK_CLAMP(0, *select_begin, *length);
	text_edit->select_end = NK_CLAMP(0, *select_end, *length);
	text_edit->string.buffer.allocated = (nk_size)*length;
	text_edit->string.buffer.memory.size = NK_MAX_NUMBER_BUFFER;
	text_edit->string.buffer.memory.ptr = dst;
	text_edit->string.buffer.size = NK_MAX_NUMBER_BUFFER;
	text_edit->mode = NK_TEXT_EDIT_MODE_INSERT;
	nk_do_edit(ws, out, edit, NK_EDIT_FIELD | NK_EDIT_AUTO_SELECT, filters[filter], text_edit, &style->edit,
		(*state == NK_PROPERTY_EDIT) ? in : 0, font);

	*length = text_edit->string.len;
	*cursor = text_edit->cursor;
	*select_begin = text_edit->select_start;
	*select_end = text_edit->select_end;
	if (text_edit->active && nk_input_is_key_pressed(in, NK_KEY_ENTER))
		text_edit->active = nk_false;

	if (active && !text_edit->active) {
		/* property is now not active so convert edit text to value*/
		*state = NK_PROPERTY_DEFAULT;
		buffer[*len] = '\0';
		switch (variant->kind) {
		default:
			break;
		case NK_PROPERTY_INT:
			variant->value.i = nk_strtoi(buffer, 0);
			variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i, variant->max_value.i);
			break;
		case NK_PROPERTY_FLOAT:
			nk_string_float_limit(buffer, NK_MAX_FLOAT_PRECISION);
			variant->value.f = nk_strtof(buffer, 0);
			variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f, variant->max_value.f);
			break;
		case NK_PROPERTY_DOUBLE:
			nk_string_float_limit(buffer, NK_MAX_FLOAT_PRECISION);
			variant->value.d = nk_strtod(buffer, 0);
			variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d, variant->max_value.d);
			break;
		}
	}
}

NK_LIB struct nk_property_variant nk_property_variant_int(int value, int min_value, int max_value, int step) {
	struct nk_property_variant result;
	result.kind = NK_PROPERTY_INT;
	result.value.i = value;
	result.min_value.i = min_value;
	result.max_value.i = max_value;
	result.step.i = step;
	return result;
}

NK_LIB struct nk_property_variant nk_property_variant_float(float value, float min_value, float max_value, float step) {
	struct nk_property_variant result;
	result.kind = NK_PROPERTY_FLOAT;
	result.value.f = value;
	result.min_value.f = min_value;
	result.max_value.f = max_value;
	result.step.f = step;
	return result;
}

NK_LIB struct nk_property_variant
nk_property_variant_double(double value, double min_value, double max_value, double step) {
	struct nk_property_variant result;
	result.kind = NK_PROPERTY_DOUBLE;
	result.value.d = value;
	result.min_value.d = min_value;
	result.max_value.d = max_value;
	result.step.d = step;
	return result;
}

NK_LIB void
nk_property(struct nk_context* ctx, const char* name, struct nk_property_variant* variant, float inc_per_pixel,
	const enum nk_property_filter filter) {
	struct nk_window* win;
	struct nk_panel* layout;
	struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states s;

	int* state = 0;
	nk_hash hash = 0;
	char* buffer = 0;
	int* len = 0;
	int* cursor = 0;
	int* select_begin = 0;
	int* select_end = 0;
	int old_state;

	char dummy_buffer[NK_MAX_NUMBER_BUFFER];
	int dummy_state = NK_PROPERTY_DEFAULT;
	int dummy_length = 0;
	int dummy_cursor = 0;
	int dummy_select_begin = 0;
	int dummy_select_end = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	style = &ctx->style;
	s = nk_widget(&bounds, ctx);
	if (!s) return;

	/* calculate hash from name */
	if (name[0] == '#') {
		hash = nk_murmur_hash(name, (int)nk_strlen(name), win->property.seq++);
		name++; /* special number hash */
	}
	else hash = nk_murmur_hash(name, (int)nk_strlen(name), 42);

	/* check if property is currently hot item */
	if (win->property.active && hash == win->property.name) {
		buffer = win->property.buffer;
		len = &win->property.length;
		cursor = &win->property.cursor;
		state = &win->property.state;
		select_begin = &win->property.select_start;
		select_end = &win->property.select_end;
	}
	else {
		buffer = dummy_buffer;
		len = &dummy_length;
		cursor = &dummy_cursor;
		state = &dummy_state;
		select_begin = &dummy_select_begin;
		select_end = &dummy_select_end;
	}

	/* execute property widget */
	old_state = *state;
	ctx->text_edit.clip = ctx->clip;
	in = ((s == NK_WIDGET_ROM && !win->property.active) || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	nk_do_property(&ctx->last_widget_state, &win->buffer, bounds, name, variant, inc_per_pixel, buffer, len, state,
		cursor, select_begin, select_end, &style->property, filter, in, style->font, &ctx->text_edit,
		ctx->button_behavior);

	if (in && *state != NK_PROPERTY_DEFAULT && !win->property.active) {
		/* current property is now hot */
		win->property.active = 1;
		NK_MEMCPY(win->property.buffer, buffer, (nk_size)*len);
		win->property.length = *len;
		win->property.cursor = *cursor;
		win->property.state = *state;
		win->property.name = hash;
		win->property.select_start = *select_begin;
		win->property.select_end = *select_end;
		if (*state == NK_PROPERTY_DRAG) {
			ctx->input.mouse.grab = nk_true;
			ctx->input.mouse.grabbed = nk_true;
		}
	}
	/* check if previously active property is now inactive */
	if (*state == NK_PROPERTY_DEFAULT && old_state != NK_PROPERTY_DEFAULT) {
		if (old_state == NK_PROPERTY_DRAG) {
			ctx->input.mouse.grab = nk_false;
			ctx->input.mouse.grabbed = nk_false;
			ctx->input.mouse.ungrab = nk_true;
		}
		win->property.select_start = 0;
		win->property.select_end = 0;
		win->property.active = 0;
	}
}

NK_API void
nk_property_int(struct nk_context* ctx, const char* name, int min, int* val, int max, int step, float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);
	NK_ASSERT(val);

	if (!ctx || !ctx->current || !name || !val) return;
	variant = nk_property_variant_int(*val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_INT);
	*val = variant.value.i;
}

NK_API void nk_property_float(struct nk_context* ctx, const char* name, float min, float* val, float max, float step,
	float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);
	NK_ASSERT(val);

	if (!ctx || !ctx->current || !name || !val) return;
	variant = nk_property_variant_float(*val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_FLOAT);
	*val = variant.value.f;
}

NK_API void
nk_property_double(struct nk_context* ctx, const char* name, double min, double* val, double max, double step,
	float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);
	NK_ASSERT(val);

	if (!ctx || !ctx->current || !name || !val) return;
	variant = nk_property_variant_double(*val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_FLOAT);
	*val = variant.value.d;
}

NK_API int
nk_propertyi(struct nk_context* ctx, const char* name, int min, int val, int max, int step, float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);

	if (!ctx || !ctx->current || !name) return val;
	variant = nk_property_variant_int(val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_INT);
	val = variant.value.i;
	return val;
}

NK_API float nk_propertyf(struct nk_context* ctx, const char* name, float min, float val, float max, float step,
	float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);

	if (!ctx || !ctx->current || !name) return val;
	variant = nk_property_variant_float(val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_FLOAT);
	val = variant.value.f;
	return val;
}

NK_API double nk_propertyd(struct nk_context* ctx, const char* name, double min, double val, double max, double step,
	float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);

	if (!ctx || !ctx->current || !name) return val;
	variant = nk_property_variant_double(val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_FLOAT);
	val = variant.value.d;
	return val;
}





/* ==============================================================
 *
 *                          CHART
 *
 * ===============================================================*/
NK_API int nk_chart_begin_colored(struct nk_context* ctx, enum nk_chart_type type, struct nk_color color,
	struct nk_color highlight, int count, float min_value, float max_value) {
	struct nk_window* win;
	struct nk_chart* chart;
	const struct nk_style* config;
	const struct nk_style_chart* style;

	const struct nk_style_item* background;
	struct nk_rect bounds = { 0, 0, 0, 0 };

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);

	if (!ctx || !ctx->current || !ctx->current->layout) return 0;
	if (!nk_widget(&bounds, ctx)) {
		chart = &ctx->current->layout->chart;
		nk_zero(chart, sizeof(*chart));
		return 0;
	}

	win = ctx->current;
	config = &ctx->style;
	chart = &win->layout->chart;
	style = &config->chart;

	/* setup basic generic chart  */
	nk_zero(chart, sizeof(*chart));
	chart->x = bounds.x + style->padding.x;
	chart->y = bounds.y + style->padding.y;
	chart->w = bounds.w - 2 * style->padding.x;
	chart->h = bounds.h - 2 * style->padding.y;
	chart->w = NK_MAX(chart->w, 2 * style->padding.x);
	chart->h = NK_MAX(chart->h, 2 * style->padding.y);

	/* add first slot into chart */
	{
		struct nk_chart_slot* slot = &chart->slots[chart->slot++];
		slot->type = type;
		slot->count = count;
		slot->color = color;
		slot->highlight = highlight;
		slot->min = NK_MIN(min_value, max_value);
		slot->max = NK_MAX(min_value, max_value);
		slot->range = slot->max - slot->min;
	}

	/* draw chart background */
	background = &style->background;
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(&win->buffer, bounds, &background->data.image, nk_white);
	}
	else {
		nk_fill_rect(&win->buffer, bounds, style->rounding, style->border_color);
		nk_fill_rect(&win->buffer, nk_shrink_rect(bounds, style->border), style->rounding,
			style->background.data.color);
	}
	return 1;
}

NK_API int
nk_chart_begin(struct nk_context* ctx, const enum nk_chart_type type, int count, float min_value, float max_value) {
	return nk_chart_begin_colored(ctx, type, ctx->style.chart.color, ctx->style.chart.selected_color, count, min_value,
		max_value);
}

NK_API void nk_chart_add_slot_colored(struct nk_context* ctx, const enum nk_chart_type type, struct nk_color color,
	struct nk_color highlight, int count, float min_value, float max_value) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	NK_ASSERT(ctx->current->layout->chart.slot < NK_CHART_MAX_SLOT);
	if (!ctx || !ctx->current || !ctx->current->layout) return;
	if (ctx->current->layout->chart.slot >= NK_CHART_MAX_SLOT) return;

	/* add another slot into the graph */
	{
		struct nk_chart* chart = &ctx->current->layout->chart;
		struct nk_chart_slot* slot = &chart->slots[chart->slot++];
		slot->type = type;
		slot->count = count;
		slot->color = color;
		slot->highlight = highlight;
		slot->min = NK_MIN(min_value, max_value);
		slot->max = NK_MAX(min_value, max_value);
		slot->range = slot->max - slot->min;
	}
}

NK_API void
nk_chart_add_slot(struct nk_context* ctx, const enum nk_chart_type type, int count, float min_value, float max_value) {
	nk_chart_add_slot_colored(ctx, type, ctx->style.chart.color, ctx->style.chart.selected_color, count, min_value,
		max_value);
}

NK_INTERN nk_flags
nk_chart_push_line(struct nk_context* ctx, struct nk_window* win, struct nk_chart* g, float value, int slot) {
	struct nk_panel* layout = win->layout;
	const struct nk_input* i = &ctx->input;
	struct nk_command_buffer* out = &win->buffer;

	nk_flags ret = 0;
	struct nk_vec2 cur;
	struct nk_rect bounds;
	struct nk_color color;
	float step;
	float range;
	float ratio;

	NK_ASSERT(slot >= 0 && slot < NK_CHART_MAX_SLOT);
	step = g->w / (float)g->slots[slot].count;
	range = g->slots[slot].max - g->slots[slot].min;
	ratio = (value - g->slots[slot].min) / range;

	if (g->slots[slot].index == 0) {
		/* first data point does not have a connection */
		g->slots[slot].last.x = g->x;
		g->slots[slot].last.y = (g->y + g->h) - ratio * (float)g->h;

		bounds.x = g->slots[slot].last.x - 2;
		bounds.y = g->slots[slot].last.y - 2;
		bounds.w = bounds.h = 4;

		color = g->slots[slot].color;
		if (!(layout->flags & NK_WINDOW_ROM) &&
			NK_INBOX(i->mouse.pos.x, i->mouse.pos.y, g->slots[slot].last.x - 3, g->slots[slot].last.y - 3, 6, 6)) {
			ret = nk_input_is_mouse_hovering_rect(i, bounds) ? NK_CHART_HOVERING : 0;
			ret |= (i->mouse.buttons[NK_BUTTON_LEFT].down && i->mouse.buttons[NK_BUTTON_LEFT].clicked)
				? NK_CHART_CLICKED : 0;
			color = g->slots[slot].highlight;
		}
		nk_fill_rect(out, bounds, 0, color);
		g->slots[slot].index += 1;
		return ret;
	}

	/* draw a line between the last data point and the new one */
	color = g->slots[slot].color;
	cur.x = g->x + (float)(step * (float)g->slots[slot].index);
	cur.y = (g->y + g->h) - (ratio * (float)g->h);
	nk_stroke_line(out, g->slots[slot].last.x, g->slots[slot].last.y, cur.x, cur.y, 1.0f, color);

	bounds.x = cur.x - 3;
	bounds.y = cur.y - 3;
	bounds.w = bounds.h = 6;

	/* user selection of current data point */
	if (!(layout->flags & NK_WINDOW_ROM)) {
		if (nk_input_is_mouse_hovering_rect(i, bounds)) {
			ret = NK_CHART_HOVERING;
			ret |= (!i->mouse.buttons[NK_BUTTON_LEFT].down && i->mouse.buttons[NK_BUTTON_LEFT].clicked)
				? NK_CHART_CLICKED : 0;
			color = g->slots[slot].highlight;
		}
	}
	nk_fill_rect(out, nk_rect(cur.x - 2, cur.y - 2, 4, 4), 0, color);

	/* save current data point position */
	g->slots[slot].last.x = cur.x;
	g->slots[slot].last.y = cur.y;
	g->slots[slot].index += 1;
	return ret;
}

NK_INTERN nk_flags
nk_chart_push_column(const struct nk_context* ctx, struct nk_window* win, struct nk_chart* chart, float value,
	int slot) {
	struct nk_command_buffer* out = &win->buffer;
	const struct nk_input* in = &ctx->input;
	struct nk_panel* layout = win->layout;

	float ratio;
	nk_flags ret = 0;
	struct nk_color color;
	struct nk_rect item = { 0, 0, 0, 0 };

	NK_ASSERT(slot >= 0 && slot < NK_CHART_MAX_SLOT);
	if (chart->slots[slot].index >= chart->slots[slot].count)
		return nk_false;
	if (chart->slots[slot].count) {
		float padding = (float)(chart->slots[slot].count - 1);
		item.w = (chart->w - padding) / (float)(chart->slots[slot].count);
	}

	/* calculate bounds of current bar chart entry */
	color = chart->slots[slot].color;;
	item.h = chart->h * NK_ABS((value / chart->slots[slot].range));
	if (value >= 0) {
		ratio = (value + NK_ABS(chart->slots[slot].min)) / NK_ABS(chart->slots[slot].range);
		item.y = (chart->y + chart->h) - chart->h * ratio;
	}
	else {
		ratio = (value - chart->slots[slot].max) / chart->slots[slot].range;
		item.y = chart->y + (chart->h * NK_ABS(ratio)) - item.h;
	}
	item.x = chart->x + ((float)chart->slots[slot].index * item.w);
	item.x = item.x + ((float)chart->slots[slot].index);

	/* user chart bar selection */
	if (!(layout->flags & NK_WINDOW_ROM) &&
		NK_INBOX(in->mouse.pos.x, in->mouse.pos.y, item.x, item.y, item.w, item.h)) {
		ret = NK_CHART_HOVERING;
		ret |= (!in->mouse.buttons[NK_BUTTON_LEFT].down && in->mouse.buttons[NK_BUTTON_LEFT].clicked) ? NK_CHART_CLICKED
			: 0;
		color = chart->slots[slot].highlight;
	}
	nk_fill_rect(out, item, 0, color);
	chart->slots[slot].index += 1;
	return ret;
}

NK_API nk_flags nk_chart_push_slot(struct nk_context* ctx, float value, int slot) {
	nk_flags flags;
	struct nk_window* win;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(slot >= 0 && slot < NK_CHART_MAX_SLOT);
	NK_ASSERT(slot < ctx->current->layout->chart.slot);
	if (!ctx || !ctx->current || slot >= NK_CHART_MAX_SLOT) return nk_false;
	if (slot >= ctx->current->layout->chart.slot) return nk_false;

	win = ctx->current;
	if (win->layout->chart.slot < slot) return nk_false;
	switch (win->layout->chart.slots[slot].type) {
	case NK_CHART_LINES:
		flags = nk_chart_push_line(ctx, win, &win->layout->chart, value, slot);
		break;
	case NK_CHART_COLUMN:
		flags = nk_chart_push_column(ctx, win, &win->layout->chart, value, slot);
		break;
	default:
	case NK_CHART_MAX:
		flags = 0;
	}
	return flags;
}

NK_API nk_flags nk_chart_push(struct nk_context* ctx, float value) {
	return nk_chart_push_slot(ctx, value, 0);
}

NK_API void nk_chart_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_chart* chart;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return;

	win = ctx->current;
	chart = &win->layout->chart;
	NK_MEMSET(chart, 0, sizeof(*chart));
	return;
}

NK_API void nk_plot(struct nk_context* ctx, enum nk_chart_type type, const float* values, int count, int offset) {
	int i = 0;
	float min_value;
	float max_value;

	NK_ASSERT(ctx);
	NK_ASSERT(values);
	if (!ctx || !values || !count) return;

	min_value = values[offset];
	max_value = values[offset];
	for (i = 0; i < count; ++i) {
		min_value = NK_MIN(values[i + offset], min_value);
		max_value = NK_MAX(values[i + offset], max_value);
	}

	if (nk_chart_begin(ctx, type, count, min_value, max_value)) {
		for (i = 0; i < count; ++i)
			nk_chart_push(ctx, values[i + offset]);
		nk_chart_end(ctx);
	}
}

NK_API void nk_plot_function(struct nk_context* ctx, enum nk_chart_type type, void* userdata,
	float(*value_getter)(void* user, int index), int count, int offset) {
	int i = 0;
	float min_value;
	float max_value;

	NK_ASSERT(ctx);
	NK_ASSERT(value_getter);
	if (!ctx || !value_getter || !count) return;

	max_value = min_value = value_getter(userdata, offset);
	for (i = 0; i < count; ++i) {
		float value = value_getter(userdata, i + offset);
		min_value = NK_MIN(value, min_value);
		max_value = NK_MAX(value, max_value);
	}

	if (nk_chart_begin(ctx, type, count, min_value, max_value)) {
		for (i = 0; i < count; ++i)
			nk_chart_push(ctx, value_getter(userdata, i + offset));
		nk_chart_end(ctx);
	}
}





/* ==============================================================
 *
 *                          COLOR PICKER
 *
 * ===============================================================*/
NK_LIB int nk_color_picker_behavior(nk_flags* state, const struct nk_rect* bounds, const struct nk_rect* matrix,
	const struct nk_rect* hue_bar, const struct nk_rect* alpha_bar,
	struct nk_colorf* color, const struct nk_input* in) {
	float hsva[4];
	int value_changed = 0;
	int hsv_changed = 0;

	NK_ASSERT(state);
	NK_ASSERT(matrix);
	NK_ASSERT(hue_bar);
	NK_ASSERT(color);

	/* color matrix */
	nk_colorf_hsva_fv(hsva, *color);
	if (nk_button_behavior(state, *matrix, in, NK_BUTTON_REPEATER)) {
		hsva[1] = NK_SATURATE((in->mouse.pos.x - matrix->x) / (matrix->w - 1));
		hsva[2] = 1.0f - NK_SATURATE((in->mouse.pos.y - matrix->y) / (matrix->h - 1));
		value_changed = hsv_changed = 1;
	}
	/* hue bar */
	if (nk_button_behavior(state, *hue_bar, in, NK_BUTTON_REPEATER)) {
		hsva[0] = NK_SATURATE((in->mouse.pos.y - hue_bar->y) / (hue_bar->h - 1));
		value_changed = hsv_changed = 1;
	}
	/* alpha bar */
	if (alpha_bar) {
		if (nk_button_behavior(state, *alpha_bar, in, NK_BUTTON_REPEATER)) {
			hsva[3] = 1.0f - NK_SATURATE((in->mouse.pos.y - alpha_bar->y) / (alpha_bar->h - 1));
			value_changed = 1;
		}
	}
	nk_widget_state_reset(state);
	if (hsv_changed) {
		*color = nk_hsva_colorfv(hsva);
		*state = NK_WIDGET_STATE_ACTIVE;
	}
	if (value_changed) {
		color->a = hsva[3];
		*state = NK_WIDGET_STATE_ACTIVE;
	}
	/* set color picker widget state */
	if (nk_input_is_mouse_hovering_rect(in, *bounds))
		*state = NK_WIDGET_STATE_HOVERED;
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, *bounds))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, *bounds))
		*state |= NK_WIDGET_STATE_LEFT;
	return value_changed;
}

NK_LIB void
nk_draw_color_picker(struct nk_command_buffer* o, const struct nk_rect* matrix, const struct nk_rect* hue_bar,
	const struct nk_rect* alpha_bar, struct nk_colorf col) {
	NK_STORAGE const struct nk_color black = { 0, 0, 0, 255 };
	NK_STORAGE const struct nk_color white = { 255, 255, 255, 255 };
	NK_STORAGE const struct nk_color black_trans = { 0, 0, 0, 0 };

	const float crosshair_size = 7.0f;
	struct nk_color temp;
	float hsva[4];
	float line_y;
	int i;

	NK_ASSERT(o);
	NK_ASSERT(matrix);
	NK_ASSERT(hue_bar);

	/* draw hue bar */
	nk_colorf_hsva_fv(hsva, col);
	for (i = 0; i < 6; ++i) {
		NK_GLOBAL const struct nk_color hue_colors[] = { {255, 0,   0,   255},
														{255, 255, 0,   255},
														{0,   255, 0,   255},
														{0,   255, 255, 255},
														{0,   0,   255, 255},
														{255, 0,   255, 255},
														{255, 0,   0,   255} };
		nk_fill_rect_multi_color(o, nk_rect(hue_bar->x, hue_bar->y + (float)i * (hue_bar->h / 6.0f) + 0.5f, hue_bar->w,
			(hue_bar->h / 6.0f) + 0.5f), hue_colors[i], hue_colors[i],
			hue_colors[i + 1], hue_colors[i + 1]);
	}
	line_y = (float)(int)(hue_bar->y + hsva[0] * matrix->h + 0.5f);
	nk_stroke_line(o, hue_bar->x - 1, line_y, hue_bar->x + hue_bar->w + 2, line_y, 1, nk_rgb(255, 255, 255));

	/* draw alpha bar */
	if (alpha_bar) {
		float alpha = NK_SATURATE(col.a);
		line_y = (float)(int)(alpha_bar->y + (1.0f - alpha) * matrix->h + 0.5f);

		nk_fill_rect_multi_color(o, *alpha_bar, white, white, black, black);
		nk_stroke_line(o, alpha_bar->x - 1, line_y, alpha_bar->x + alpha_bar->w + 2, line_y, 1, nk_rgb(255, 255, 255));
	}

	/* draw color matrix */
	temp = nk_hsv_f(hsva[0], 1.0f, 1.0f);
	nk_fill_rect_multi_color(o, *matrix, white, temp, temp, white);
	nk_fill_rect_multi_color(o, *matrix, black_trans, black_trans, black, black);

	/* draw cross-hair */
	{
		struct nk_vec2 p;
		float S = hsva[1];
		float V = hsva[2];
		p.x = (float)(int)(matrix->x + S * matrix->w);
		p.y = (float)(int)(matrix->y + (1.0f - V) * matrix->h);
		nk_stroke_line(o, p.x - crosshair_size, p.y, p.x - 2, p.y, 1.0f, white);
		nk_stroke_line(o, p.x + crosshair_size + 1, p.y, p.x + 3, p.y, 1.0f, white);
		nk_stroke_line(o, p.x, p.y + crosshair_size + 1, p.x, p.y + 3, 1.0f, white);
		nk_stroke_line(o, p.x, p.y - crosshair_size, p.x, p.y - 2, 1.0f, white);
	}
}

NK_LIB int
nk_do_color_picker(nk_flags* state, struct nk_command_buffer* out, struct nk_colorf* col, enum nk_color_format fmt,
	struct nk_rect bounds, struct nk_vec2 padding, const struct nk_input* in,
	const struct nk_user_font* font) {
	int ret = 0;
	struct nk_rect matrix;
	struct nk_rect hue_bar;
	struct nk_rect alpha_bar;
	float bar_w;

	NK_ASSERT(out);
	NK_ASSERT(col);
	NK_ASSERT(state);
	NK_ASSERT(font);
	if (!out || !col || !state || !font)
		return ret;

	bar_w = font->height;
	bounds.x += padding.x;
	bounds.y += padding.x;
	bounds.w -= 2 * padding.x;
	bounds.h -= 2 * padding.y;

	matrix.x = bounds.x;
	matrix.y = bounds.y;
	matrix.h = bounds.h;
	matrix.w = bounds.w - (3 * padding.x + 2 * bar_w);

	hue_bar.w = bar_w;
	hue_bar.y = bounds.y;
	hue_bar.h = matrix.h;
	hue_bar.x = matrix.x + matrix.w + padding.x;

	alpha_bar.x = hue_bar.x + hue_bar.w + padding.x;
	alpha_bar.y = bounds.y;
	alpha_bar.w = bar_w;
	alpha_bar.h = matrix.h;

	ret = nk_color_picker_behavior(state, &bounds, &matrix, &hue_bar, (fmt == NK_RGBA) ? &alpha_bar : 0, col, in);
	nk_draw_color_picker(out, &matrix, &hue_bar, (fmt == NK_RGBA) ? &alpha_bar : 0, *col);
	return ret;
}

NK_API int nk_color_pick(struct nk_context* ctx, struct nk_colorf* color, enum nk_color_format fmt) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_style* config;
	const struct nk_input* in;

	enum nk_widget_layout_states state;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(color);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !color)
		return 0;

	win = ctx->current;
	config = &ctx->style;
	layout = win->layout;
	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_color_picker(&ctx->last_widget_state, &win->buffer, color, fmt, bounds, nk_vec2(0, 0), in,
		config->font);
}

NK_API struct nk_colorf nk_color_picker(struct nk_context* ctx, struct nk_colorf color, enum nk_color_format fmt) {
	nk_color_pick(ctx, &color, fmt);
	return color;
}





/* ==============================================================
 *
 *                          COMBO
 *
 * ===============================================================*/
NK_INTERN int nk_combo_begin(struct nk_context* ctx, struct nk_window* win, struct nk_vec2 size, int is_clicked,
	struct nk_rect header) {
	struct nk_window* popup;
	int is_open = 0;
	int is_active = 0;
	struct nk_rect body;
	nk_hash hash;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	popup = win->popup.win;
	body.x = header.x;
	body.w = size.x;
	body.y = header.y + header.h - ctx->style.window.combo_border;
	body.h = size.y;

	hash = win->popup.combo_count++;
	is_open = (popup) ? nk_true : nk_false;
	is_active = (popup && (win->popup.name == hash) && win->popup.type == NK_PANEL_COMBO);
	if ((is_clicked && is_open && !is_active) || (is_open && !is_active) ||
		(!is_open && !is_active && !is_clicked))
		return 0;
	if (!nk_nonblock_begin(ctx, 0, body, (is_clicked && is_open) ? nk_rect(0, 0, 0, 0) : header, NK_PANEL_COMBO))
		return 0;

	win->popup.type = NK_PANEL_COMBO;
	win->popup.name = hash;
	return 1;
}

NK_API int nk_combo_begin_text(struct nk_context* ctx, const char* selected, int len, struct nk_vec2 size) {
	const struct nk_input* in;
	struct nk_window* win;
	struct nk_style* style;

	enum nk_widget_layout_states s;
	int is_clicked = nk_false;
	struct nk_rect header;
	const struct nk_style_item* background;
	struct nk_text text;

	NK_ASSERT(ctx);
	NK_ASSERT(selected);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !selected)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (s == NK_WIDGET_INVALID)
		return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->combo.active;
		text.text = style->combo.label_active;
	}
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
		background = &style->combo.hover;
		text.text = style->combo.label_hover;
	}
	else {
		background = &style->combo.normal;
		text.text = style->combo.label_normal;
	}
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		text.background = nk_rgba(0, 0, 0, 0);
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		text.background = background->data.color;
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		/* print currently selected text item */
		struct nk_rect label;
		struct nk_rect button;
		struct nk_rect content;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;

		/* draw selected label */
		text.padding = nk_vec2(0, 0);
		label.x = header.x + style->combo.content_padding.x;
		label.y = header.y + style->combo.content_padding.y;
		label.w = button.x - (style->combo.content_padding.x + style->combo.spacing.x) - label.x;;
		label.h = header.h - 2 * style->combo.content_padding.y;
		nk_widget_text(&win->buffer, label, selected, len, &text, NK_TEXT_LEFT, ctx->style.font);

		/* draw open/close button */
		nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_label(struct nk_context* ctx, const char* selected, struct nk_vec2 size) {
	return nk_combo_begin_text(ctx, selected, nk_strlen(selected), size);
}

NK_API int nk_combo_begin_color(struct nk_context* ctx, struct nk_color color, struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_style* style;
	const struct nk_input* in;

	struct nk_rect header;
	int is_clicked = nk_false;
	enum nk_widget_layout_states s;
	const struct nk_style_item* background;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (s == NK_WIDGET_INVALID)
		return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED)
		background = &style->combo.active;
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
		background = &style->combo.hover;
	else background = &style->combo.normal;

	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		struct nk_rect content;
		struct nk_rect button;
		struct nk_rect bounds;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;

		/* draw color */
		bounds.h = header.h - 4 * style->combo.content_padding.y;
		bounds.y = header.y + 2 * style->combo.content_padding.y;
		bounds.x = header.x + 2 * style->combo.content_padding.x;
		bounds.w = (button.x - (style->combo.content_padding.x + style->combo.spacing.x)) - bounds.x;
		nk_fill_rect(&win->buffer, bounds, 0, color);

		/* draw open/close button */
		nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_symbol(struct nk_context* ctx, enum nk_symbol_type symbol, struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_style* style;
	const struct nk_input* in;

	struct nk_rect header;
	int is_clicked = nk_false;
	enum nk_widget_layout_states s;
	const struct nk_style_item* background;
	struct nk_color sym_background;
	struct nk_color symbol_color;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (s == NK_WIDGET_INVALID)
		return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->combo.active;
		symbol_color = style->combo.symbol_active;
	}
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
		background = &style->combo.hover;
		symbol_color = style->combo.symbol_hover;
	}
	else {
		background = &style->combo.normal;
		symbol_color = style->combo.symbol_hover;
	}

	if (background->type == NK_STYLE_ITEM_IMAGE) {
		sym_background = nk_rgba(0, 0, 0, 0);
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		sym_background = background->data.color;
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		struct nk_rect bounds = { 0, 0, 0, 0 };
		struct nk_rect content;
		struct nk_rect button;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.y;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;

		/* draw symbol */
		bounds.h = header.h - 2 * style->combo.content_padding.y;
		bounds.y = header.y + style->combo.content_padding.y;
		bounds.x = header.x + style->combo.content_padding.x;
		bounds.w = (button.x - style->combo.content_padding.y) - bounds.x;
		nk_draw_symbol(&win->buffer, symbol, bounds, sym_background, symbol_color, 1.0f, style->font);

		/* draw open/close button */
		nk_draw_button_symbol(&win->buffer, &bounds, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_symbol_text(struct nk_context* ctx, const char* selected, int len, enum nk_symbol_type symbol,
	struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_style* style;
	struct nk_input* in;

	struct nk_rect header;
	int is_clicked = nk_false;
	enum nk_widget_layout_states s;
	const struct nk_style_item* background;
	struct nk_color symbol_color;
	struct nk_text text;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (!s) return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->combo.active;
		symbol_color = style->combo.symbol_active;
		text.text = style->combo.label_active;
	}
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
		background = &style->combo.hover;
		symbol_color = style->combo.symbol_hover;
		text.text = style->combo.label_hover;
	}
	else {
		background = &style->combo.normal;
		symbol_color = style->combo.symbol_normal;
		text.text = style->combo.label_normal;
	}
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		text.background = nk_rgba(0, 0, 0, 0);
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		text.background = background->data.color;
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		struct nk_rect content;
		struct nk_rect button;
		struct nk_rect label;
		struct nk_rect image;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;
		nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);

		/* draw symbol */
		image.x = header.x + style->combo.content_padding.x;
		image.y = header.y + style->combo.content_padding.y;
		image.h = header.h - 2 * style->combo.content_padding.y;
		image.w = image.h;
		nk_draw_symbol(&win->buffer, symbol, image, text.background, symbol_color, 1.0f, style->font);

		/* draw label */
		text.padding = nk_vec2(0, 0);
		label.x = image.x + image.w + style->combo.spacing.x + style->combo.content_padding.x;
		label.y = header.y + style->combo.content_padding.y;
		label.w = (button.x - style->combo.content_padding.x) - label.x;
		label.h = header.h - 2 * style->combo.content_padding.y;
		nk_widget_text(&win->buffer, label, selected, len, &text, NK_TEXT_LEFT, style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_image(struct nk_context* ctx, struct nk_image img, struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_style* style;
	const struct nk_input* in;

	struct nk_rect header;
	int is_clicked = nk_false;
	enum nk_widget_layout_states s;
	const struct nk_style_item* background;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (s == NK_WIDGET_INVALID)
		return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED)
		background = &style->combo.active;
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
		background = &style->combo.hover;
	else background = &style->combo.normal;

	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		struct nk_rect bounds = { 0, 0, 0, 0 };
		struct nk_rect content;
		struct nk_rect button;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.y;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;

		/* draw image */
		bounds.h = header.h - 2 * style->combo.content_padding.y;
		bounds.y = header.y + style->combo.content_padding.y;
		bounds.x = header.x + style->combo.content_padding.x;
		bounds.w = (button.x - style->combo.content_padding.y) - bounds.x;
		nk_draw_image(&win->buffer, bounds, &img, nk_white);

		/* draw open/close button */
		nk_draw_button_symbol(&win->buffer, &bounds, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_image_text(struct nk_context* ctx, const char* selected, int len, struct nk_image img,
	struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_style* style;
	struct nk_input* in;

	struct nk_rect header;
	int is_clicked = nk_false;
	enum nk_widget_layout_states s;
	const struct nk_style_item* background;
	struct nk_text text;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (!s) return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->combo.active;
		text.text = style->combo.label_active;
	}
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
		background = &style->combo.hover;
		text.text = style->combo.label_hover;
	}
	else {
		background = &style->combo.normal;
		text.text = style->combo.label_normal;
	}
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		text.background = nk_rgba(0, 0, 0, 0);
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		text.background = background->data.color;
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		struct nk_rect content;
		struct nk_rect button;
		struct nk_rect label;
		struct nk_rect image;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;
		nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);

		/* draw image */
		image.x = header.x + style->combo.content_padding.x;
		image.y = header.y + style->combo.content_padding.y;
		image.h = header.h - 2 * style->combo.content_padding.y;
		image.w = image.h;
		nk_draw_image(&win->buffer, image, &img, nk_white);

		/* draw label */
		text.padding = nk_vec2(0, 0);
		label.x = image.x + image.w + style->combo.spacing.x + style->combo.content_padding.x;
		label.y = header.y + style->combo.content_padding.y;
		label.w = (button.x - style->combo.content_padding.x) - label.x;
		label.h = header.h - 2 * style->combo.content_padding.y;
		nk_widget_text(&win->buffer, label, selected, len, &text, NK_TEXT_LEFT, style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_symbol_label(struct nk_context* ctx, const char* selected, enum nk_symbol_type type,
	struct nk_vec2 size) {
	return nk_combo_begin_symbol_text(ctx, selected, nk_strlen(selected), type, size);
}

NK_API int
nk_combo_begin_image_label(struct nk_context* ctx, const char* selected, struct nk_image img, struct nk_vec2 size) {
	return nk_combo_begin_image_text(ctx, selected, nk_strlen(selected), img, size);
}

NK_API int nk_combo_item_text(struct nk_context* ctx, const char* text, int len, nk_flags align) {
	return nk_contextual_item_text(ctx, text, len, align);
}

NK_API int nk_combo_item_label(struct nk_context* ctx, const char* label, nk_flags align) {
	return nk_contextual_item_label(ctx, label, align);
}

NK_API int
nk_combo_item_image_text(struct nk_context* ctx, struct nk_image img, const char* text, int len, nk_flags alignment) {
	return nk_contextual_item_image_text(ctx, img, text, len, alignment);
}

NK_API int
nk_combo_item_image_label(struct nk_context* ctx, struct nk_image img, const char* text, nk_flags alignment) {
	return nk_contextual_item_image_label(ctx, img, text, alignment);
}

NK_API int nk_combo_item_symbol_text(struct nk_context* ctx, enum nk_symbol_type sym, const char* text, int len,
	nk_flags alignment) {
	return nk_contextual_item_symbol_text(ctx, sym, text, len, alignment);
}

NK_API int
nk_combo_item_symbol_label(struct nk_context* ctx, enum nk_symbol_type sym, const char* label, nk_flags alignment) {
	return nk_contextual_item_symbol_label(ctx, sym, label, alignment);
}

NK_API void nk_combo_end(struct nk_context* ctx) {
	nk_contextual_end(ctx);
}

NK_API void nk_combo_close(struct nk_context* ctx) {
	nk_contextual_close(ctx);
}

NK_API int
nk_combo(struct nk_context* ctx, const char** items, int count, int selected, int item_height, struct nk_vec2 size) {
	int i = 0;
	int max_height;
	struct nk_vec2 item_spacing;
	struct nk_vec2 window_padding;

	NK_ASSERT(ctx);
	NK_ASSERT(items);
	NK_ASSERT(ctx->current);
	if (!ctx || !items || !count)
		return selected;

	item_spacing = ctx->style.window.spacing;
	window_padding = nk_panel_get_padding(&ctx->style, ctx->current->layout->type);
	max_height = count * item_height + count * (int)item_spacing.y;
	max_height += (int)item_spacing.y * 2 + (int)window_padding.y * 2;
	size.y = NK_MIN(size.y, (float)max_height);
	if (nk_combo_begin_label(ctx, items[selected], size)) {
		nk_layout_row_dynamic(ctx, (float)item_height, 1);
		for (i = 0; i < count; ++i) {
			if (nk_combo_item_label(ctx, items[i], NK_TEXT_LEFT))
				selected = i;
		}
		nk_combo_end(ctx);
	}
	return selected;
}

NK_API int
nk_combo_separator(struct nk_context* ctx, const char* items_separated_by_separator, int separator, int selected,
	int count, int item_height, struct nk_vec2 size) {
	int i;
	int max_height;
	struct nk_vec2 item_spacing;
	struct nk_vec2 window_padding;
	const char* current_item;
	const char* iter;
	int length = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(items_separated_by_separator);
	if (!ctx || !items_separated_by_separator)
		return selected;

	/* calculate popup window */
	item_spacing = ctx->style.window.spacing;
	window_padding = nk_panel_get_padding(&ctx->style, ctx->current->layout->type);
	max_height = count * item_height + count * (int)item_spacing.y;
	max_height += (int)item_spacing.y * 2 + (int)window_padding.y * 2;
	size.y = NK_MIN(size.y, (float)max_height);

	/* find selected item */
	current_item = items_separated_by_separator;
	for (i = 0; i < count; ++i) {
		iter = current_item;
		while (*iter && *iter != separator) iter++;
		length = (int)(iter - current_item);
		if (i == selected) break;
		current_item = iter + 1;
	}

	if (nk_combo_begin_text(ctx, current_item, length, size)) {
		current_item = items_separated_by_separator;
		nk_layout_row_dynamic(ctx, (float)item_height, 1);
		for (i = 0; i < count; ++i) {
			iter = current_item;
			while (*iter && *iter != separator) iter++;
			length = (int)(iter - current_item);
			if (nk_combo_item_text(ctx, current_item, length, NK_TEXT_LEFT))
				selected = i;
			current_item = current_item + length + 1;
		}
		nk_combo_end(ctx);
	}
	return selected;
}

NK_API int
nk_combo_string(struct nk_context* ctx, const char* items_separated_by_zeros, int selected, int count, int item_height,
	struct nk_vec2 size) {
	return nk_combo_separator(ctx, items_separated_by_zeros, '\0', selected, count, item_height, size);
}

NK_API int
nk_combo_callback(struct nk_context* ctx, void(*item_getter)(void*, int, const char**), void* userdata, int selected,
	int count, int item_height, struct nk_vec2 size) {
	int i;
	int max_height;
	struct nk_vec2 item_spacing;
	struct nk_vec2 window_padding;
	const char* item;

	NK_ASSERT(ctx);
	NK_ASSERT(item_getter);
	if (!ctx || !item_getter)
		return selected;

	/* calculate popup window */
	item_spacing = ctx->style.window.spacing;
	window_padding = nk_panel_get_padding(&ctx->style, ctx->current->layout->type);
	max_height = count * item_height + count * (int)item_spacing.y;
	max_height += (int)item_spacing.y * 2 + (int)window_padding.y * 2;
	size.y = NK_MIN(size.y, (float)max_height);

	item_getter(userdata, selected, &item);
	if (nk_combo_begin_label(ctx, item, size)) {
		nk_layout_row_dynamic(ctx, (float)item_height, 1);
		for (i = 0; i < count; ++i) {
			item_getter(userdata, i, &item);
			if (nk_combo_item_label(ctx, item, NK_TEXT_LEFT))
				selected = i;
		}
		nk_combo_end(ctx);
	}
	return selected;
}

NK_API void nk_combobox(struct nk_context* ctx, const char** items, int count, int* selected, int item_height,
	struct nk_vec2 size) {
	*selected = nk_combo(ctx, items, count, *selected, item_height, size);
}

NK_API void nk_combobox_string(struct nk_context* ctx, const char* items_separated_by_zeros, int* selected, int count,
	int item_height, struct nk_vec2 size) {
	*selected = nk_combo_string(ctx, items_separated_by_zeros, *selected, count, item_height, size);
}

NK_API void
nk_combobox_separator(struct nk_context* ctx, const char* items_separated_by_separator, int separator, int* selected,
	int count, int item_height, struct nk_vec2 size) {
	*selected = nk_combo_separator(ctx, items_separated_by_separator, separator, *selected, count, item_height, size);
}

NK_API void nk_combobox_callback(struct nk_context* ctx, void(*item_getter)(void* data, int id, const char** out_text),
	void* userdata, int* selected, int count, int item_height, struct nk_vec2 size) {
	*selected = nk_combo_callback(ctx, item_getter, userdata, *selected, count, item_height, size);
}





/* ===============================================================
 *
 *                              TOOLTIP
 *
 * ===============================================================*/
NK_API int nk_tooltip_begin(struct nk_context* ctx, float width) {
	int x, y, w, h;
	struct nk_window* win;
	const struct nk_input* in;
	struct nk_rect bounds;
	int ret;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	/* make sure that no nonblocking popup is currently active */
	win = ctx->current;
	in = &ctx->input;
	if (win->popup.win && (win->popup.type & NK_PANEL_SET_NONBLOCK))
		return 0;

	w = nk_iceilf(width);
	h = nk_iceilf(nk_null_rect.h);
	x = nk_ifloorf(in->mouse.pos.x + 1) - (int)win->layout->clip.x;
	y = nk_ifloorf(in->mouse.pos.y + 1) - (int)win->layout->clip.y;

	bounds.x = (float)x;
	bounds.y = (float)y;
	bounds.w = (float)w;
	bounds.h = (float)h;

	ret = nk_popup_begin(ctx, NK_POPUP_DYNAMIC, "__##Tooltip##__", NK_WINDOW_NO_SCROLLBAR | NK_WINDOW_BORDER, bounds);
	if (ret) win->layout->flags &= ~(nk_flags)NK_WINDOW_ROM;
	win->popup.type = NK_PANEL_TOOLTIP;
	ctx->current->layout->type = NK_PANEL_TOOLTIP;
	return ret;
}

NK_API void nk_tooltip_end(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return;
	ctx->current->seq--;
	nk_popup_close(ctx);
	nk_popup_end(ctx);
}

NK_API void nk_tooltip(struct nk_context* ctx, const char* text) {
	const struct nk_style* style;
	struct nk_vec2 padding;

	int text_len;
	float text_width;
	float text_height;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	NK_ASSERT(text);
	if (!ctx || !ctx->current || !ctx->current->layout || !text)
		return;

	/* fetch configuration data */
	style = &ctx->style;
	padding = style->window.padding;

	/* calculate size of the text and tooltip */
	text_len = nk_strlen(text);
	text_width = style->font->width(style->font->userdata, style->font->height, text, text_len);
	text_width += (4 * padding.x);
	text_height = (style->font->height + 2 * padding.y);

	/* execute tooltip and fill with text */
	if (nk_tooltip_begin(ctx, (float)text_width)) {
		nk_layout_row_dynamic(ctx, (float)text_height, 1);
		nk_text(ctx, text, text_len, NK_TEXT_LEFT);
		nk_tooltip_end(ctx);
	}
}

#ifdef NK_INCLUDE_STANDARD_VARARGS

NK_API void nk_tooltipf(struct nk_context* ctx, const char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	nk_tooltipfv(ctx, fmt, args);
	va_end(args);
}

NK_API void nk_tooltipfv(struct nk_context* ctx, const char* fmt, va_list args) {
	char buf[256];
	nk_strfmt(buf, NK_LEN(buf), fmt, args);
	nk_tooltip(ctx, buf);
}

#endif


#endif /* NK_IMPLEMENTATION */

/*
/// ## License
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~none
///    ------------------------------------------------------------------------------
///    This software is available under 2 licenses -- choose whichever you prefer.
///    ------------------------------------------------------------------------------
///    ALTERNATIVE A - MIT License
///    Copyright (c) 2016-2018 Micha Mettke
///    Permission is hereby granted, free of charge, to any person obtaining a copy of
///    this software and associated documentation files (the "Software"), to deal in
///    the Software without restriction, including without limitation the rights to
///    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
///    of the Software, and to permit persons to whom the Software is furnished to do
///    so, subject to the following conditions:
///    The above copyright notice and this permission notice shall be included in all
///    copies or substantial portions of the Software.
///    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
///    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
///    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
///    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
///    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
///    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
///    SOFTWARE.
///    ------------------------------------------------------------------------------
///    ALTERNATIVE B - Public Domain (www.unlicense.org)
///    This is free and unencumbered software released into the public domain.
///    Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
///    software, either in source code form or as a compiled binary, for any purpose,
///    commercial or non-commercial, and by any means.
///    In jurisdictions that recognize copyright laws, the author or authors of this
///    software dedicate any and all copyright interest in the software to the public
///    domain. We make this dedication for the benefit of the public at large and to
///    the detriment of our heirs and successors. We intend this dedication to be an
///    overt act of relinquishment in perpetuity of all present and future rights to
///    this software under copyright law.
///    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
///    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
///    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
///    AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
///    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
///    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///    ------------------------------------------------------------------------------
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/// ## Changelog
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~none
/// [date][x.yy.zz]-[description]
/// -[date]: date on which the change has been pushed
/// -[x.yy.zz]: Numerical version string representation. Each version number on the right
///             resets back to zero if version on the left is incremented.
///    - [x]: Major version with API and library breaking changes
///    - [yy]: Minor version with non-breaking API and library changes
///    - [zz]: Bug fix version with no direct changes to API
///
/// - 2018/04/01 (4.00.1) - Fixed calling `nk_convert` multiple time per single frame
/// - 2018/04/01 (4.00.0) - BREAKING CHANGE: nk_draw_list_clear no longer tries to
///                         clear provided buffers. So make sure to either free
///                         or clear each passed buffer after calling nk_convert.
/// - 2018/02/23 (3.00.6) - Fixed slider dragging behavior
/// - 2018/01/31 (3.00.5) - Fixed overcalculation of cursor data in font baking process
/// - 2018/01/31 (3.00.4) - Removed name collision with stb_truetype
/// - 2018/01/28 (3.00.3) - Fixed panel window border drawing bug
/// - 2018/01/12 (3.00.2) - Added `nk_group_begin_titled` for separed group identifier and title
/// - 2018/01/07 (3.00.1) - Started to change documentation style
/// - 2018/01/05 (3.00.0) - BREAKING CHANGE: The previous color picker API was broken
///                        because of conversions between float and byte color representation.
///                        Color pickers now use floating point values to represent
///                        HSV values. To get back the old behavior I added some additional
///                        color conversion functions to cast between nk_color and
///                        nk_colorf.
/// - 2017/12/23 (2.00.7) - Fixed small warning
/// - 2017/12/23 (2.00.7) - Fixed nk_edit_buffer behavior if activated to allow input
/// - 2017/12/23 (2.00.7) - Fixed modifyable progressbar dragging visuals and input behavior
/// - 2017/12/04 (2.00.6) - Added formated string tooltip widget
/// - 2017/11/18 (2.00.5) - Fixed window becoming hidden with flag NK_WINDOW_NO_INPUT
/// - 2017/11/15 (2.00.4) - Fixed font merging
/// - 2017/11/07 (2.00.3) - Fixed window size and position modifier functions
/// - 2017/09/14 (2.00.2) - Fixed nk_edit_buffer and nk_edit_focus behavior
/// - 2017/09/14 (2.00.1) - Fixed window closing behavior
/// - 2017/09/14 (2.00.0) - BREAKING CHANGE: Modifing window position and size funtions now
///                        require the name of the window and must happen outside the window
///                        building process (between function call nk_begin and nk_end).
/// - 2017/09/11 (1.40.9) - Fixed window background flag if background window is declared last
/// - 2017/08/27 (1.40.8) - Fixed `nk_item_is_any_active` for hidden windows
/// - 2017/08/27 (1.40.7) - Fixed window background flag
/// - 2017/07/07 (1.40.6) - Fixed missing clipping rect check for hovering/clicked
///                        query for widgets
/// - 2017/07/07 (1.40.5) - Fixed drawing bug for vertex output for lines and stroked
///                        and filled rectangles
/// - 2017/07/07 (1.40.4) - Fixed bug in nk_convert trying to add windows that are in
///                        process of being destroyed.
/// - 2017/07/07 (1.40.3) - Fixed table internal bug caused by storing table size in
///                        window instead of directly in table.
/// - 2017/06/30 (1.40.2) - Removed unneeded semicolon in C++ NK_ALIGNOF macro
/// - 2017/06/30 (1.40.1) - Fixed drawing lines smaller or equal zero
/// - 2017/06/08 (1.40.0) - Removed the breaking part of last commit. Auto layout now only
///                        comes in effect if you pass in zero was row height argument
/// - 2017/06/08 (1.40.0) - BREAKING CHANGE: while not directly API breaking it will change
///                        how layouting works. From now there will be an internal minimum
///                        row height derived from font height. If you need a row smaller than
///                        that you can directly set it by `nk_layout_set_min_row_height` and
///                        reset the value back by calling `nk_layout_reset_min_row_height.
/// - 2017/06/08 (1.39.1) - Fixed property text edit handling bug caused by past `nk_widget` fix
/// - 2017/06/08 (1.39.0) - Added function to retrieve window space without calling a nk_layout_xxx function
/// - 2017/06/06 (1.38.5) - Fixed `nk_convert` return flag for command buffer
/// - 2017/05/23 (1.38.4) - Fixed activation behavior for widgets partially clipped
/// - 2017/05/10 (1.38.3) - Fixed wrong min window size mouse scaling over boundries
/// - 2017/05/09 (1.38.2) - Fixed vertical scrollbar drawing with not enough space
/// - 2017/05/09 (1.38.1) - Fixed scaler dragging behavior if window size hits minimum size
/// - 2017/05/06 (1.38.0) - Added platform double-click support
/// - 2017/04/20 (1.37.1) - Fixed key repeat found inside glfw demo backends
/// - 2017/04/20 (1.37.0) - Extended properties with selection and clipbard support
/// - 2017/04/20 (1.36.2) - Fixed #405 overlapping rows with zero padding and spacing
/// - 2017/04/09 (1.36.1) - Fixed #403 with another widget float error
/// - 2017/04/09 (1.36.0) - Added window `NK_WINDOW_NO_INPUT` and `NK_WINDOW_NOT_INTERACTIVE` flags
/// - 2017/04/09 (1.35.3) - Fixed buffer heap corruption
/// - 2017/03/25 (1.35.2) - Fixed popup overlapping for `NK_WINDOW_BACKGROUND` windows
/// - 2017/03/25 (1.35.1) - Fixed windows closing behavior
/// - 2017/03/18 (1.35.0) - Added horizontal scroll requested in #377
/// - 2017/03/18 (1.34.3) - Fixed long window header titles
/// - 2017/03/04 (1.34.2) - Fixed text edit filtering
/// - 2017/03/04 (1.34.1) - Fixed group closable flag
/// - 2017/02/25 (1.34.0) - Added custom draw command for better language binding support
/// - 2017/01/24 (1.33.0) - Added programatic way of remove edit focus
/// - 2017/01/24 (1.32.3) - Fixed wrong define for basic type definitions for windows
/// - 2017/01/21 (1.32.2) - Fixed input capture from hidden or closed windows
/// - 2017/01/21 (1.32.1) - Fixed slider behavior and drawing
/// - 2017/01/13 (1.32.0) - Added flag to put scaler into the bottom left corner
/// - 2017/01/13 (1.31.0) - Added additional row layouting method to combine both
///                        dynamic and static widgets.
/// - 2016/12/31 (1.30.0) - Extended scrollbar offset from 16-bit to 32-bit
/// - 2016/12/31 (1.29.2)- Fixed closing window bug of minimized windows
/// - 2016/12/03 (1.29.1)- Fixed wrapped text with no seperator and C89 error
/// - 2016/12/03 (1.29.0) - Changed text wrapping to process words not characters
/// - 2016/11/22 (1.28.6)- Fixed window minimized closing bug
/// - 2016/11/19 (1.28.5)- Fixed abstract combo box closing behavior
/// - 2016/11/19 (1.28.4)- Fixed tooltip flickering
/// - 2016/11/19 (1.28.3)- Fixed memory leak caused by popup repeated closing
/// - 2016/11/18 (1.28.2)- Fixed memory leak caused by popup panel allocation
/// - 2016/11/10 (1.28.1)- Fixed some warnings and C++ error
/// - 2016/11/10 (1.28.0)- Added additional `nk_button` versions which allows to directly
///                        pass in a style struct to change buttons visual.
/// - 2016/11/10 (1.27.0)- Added additional 'nk_tree' versions to support external state
///                        storage. Just like last the `nk_group` commit the main
///                        advantage is that you optionally can minimize nuklears runtime
///                        memory consumption or handle hash collisions.
/// - 2016/11/09 (1.26.0)- Added additional `nk_group` version to support external scrollbar
///                        offset storage. Main advantage is that you can externalize
///                        the memory management for the offset. It could also be helpful
///                        if you have a hash collision in `nk_group_begin` but really
///                        want the name. In addition I added `nk_list_view` which allows
///                        to draw big lists inside a group without actually having to
///                        commit the whole list to nuklear (issue #269).
/// - 2016/10/30 (1.25.1)- Fixed clipping rectangle bug inside `nk_draw_list`
/// - 2016/10/29 (1.25.0)- Pulled `nk_panel` memory management into nuklear and out of
///                        the hands of the user. From now on users don't have to care
///                        about panels unless they care about some information. If you
///                        still need the panel just call `nk_window_get_panel`.
/// - 2016/10/21 (1.24.0)- Changed widget border drawing to stroked rectangle from filled
///                        rectangle for less overdraw and widget background transparency.
/// - 2016/10/18 (1.23.0)- Added `nk_edit_focus` for manually edit widget focus control
/// - 2016/09/29 (1.22.7)- Fixed deduction of basic type in non `<stdint.h>` compilation
/// - 2016/09/29 (1.22.6)- Fixed edit widget UTF-8 text cursor drawing bug
/// - 2016/09/28 (1.22.5)- Fixed edit widget UTF-8 text appending/inserting/removing
/// - 2016/09/28 (1.22.4)- Fixed drawing bug inside edit widgets which offset all text
///                        text in every edit widget if one of them is scrolled.
/// - 2016/09/28 (1.22.3)- Fixed small bug in edit widgets if not active. The wrong
///                        text length is passed. It should have been in bytes but
///                        was passed as glyphes.
/// - 2016/09/20 (1.22.2)- Fixed color button size calculation
/// - 2016/09/20 (1.22.1)- Fixed some `nk_vsnprintf` behavior bugs and removed
///                        `<stdio.h>` again from `NK_INCLUDE_STANDARD_VARARGS`.
/// - 2016/09/18 (1.22.0)- C89 does not support vsnprintf only C99 and newer as well
///                        as C++11 and newer. In addition to use vsnprintf you have
///                        to include <stdio.h>. So just defining `NK_INCLUDE_STD_VAR_ARGS`
///                        is not enough. That behavior is now fixed. By default if
///                        both varargs as well as stdio is selected I try to use
///                        vsnprintf if not possible I will revert to vsprintf. If
///                        varargs but not stdio was defined I will use my own function.
/// - 2016/09/15 (1.21.2)- Fixed panel `close` behavior for deeper panel levels
/// - 2016/09/15 (1.21.1)- Fixed C++ errors and wrong argument to `nk_panel_get_xxxx`
/// - 2016/09/13 (1.21.0) - !BREAKING! Fixed nonblocking popup behavior in menu, combo,
///                        and contextual which prevented closing in y-direction if
///                        popup did not reach max height.
///                        In addition the height parameter was changed into vec2
///                        for width and height to have more control over the popup size.
/// - 2016/09/13 (1.20.3) - Cleaned up and extended type selection
/// - 2016/09/13 (1.20.2)- Fixed slider behavior hopefully for the last time. This time
///                        all calculation are correct so no more hackery.
/// - 2016/09/13 (1.20.1)- Internal change to divide window/panel flags into panel flags and types.
///                        Suprisinly spend years in C and still happened to confuse types
///                        with flags. Probably something to take note.
/// - 2016/09/08 (1.20.0)- Added additional helper function to make it easier to just
///                        take the produced buffers from `nk_convert` and unplug the
///                        iteration process from `nk_context`. So now you can
///                        just use the vertex,element and command buffer + two pointer
///                        inside the command buffer retrieved by calls `nk__draw_begin`
///                        and `nk__draw_end` and macro `nk_draw_foreach_bounded`.
/// - 2016/09/08 (1.19.0)- Added additional asserts to make sure every `nk_xxx_begin` call
///                        for windows, popups, combobox, menu and contextual is guarded by
///                        `if` condition and does not produce false drawing output.
/// - 2016/09/08 (1.18.0)- Changed confusing name for `NK_SYMBOL_RECT_FILLED`, `NK_SYMBOL_RECT`
///                        to hopefully easier to understand `NK_SYMBOL_RECT_FILLED` and
///                        `NK_SYMBOL_RECT_OUTLINE`.
/// - 2016/09/08 (1.17.0)- Changed confusing name for `NK_SYMBOL_CIRLCE_FILLED`, `NK_SYMBOL_CIRCLE`
///                        to hopefully easier to understand `NK_SYMBOL_CIRCLE_FILLED` and
///                        `NK_SYMBOL_CIRCLE_OUTLINE`.
/// - 2016/09/08 (1.16.0)- Added additional checks to select correct types if `NK_INCLUDE_FIXED_TYPES`
///                        is not defined by supporting the biggest compiler GCC, clang and MSVC.
/// - 2016/09/07 (1.15.3)- Fixed `NK_INCLUDE_COMMAND_USERDATA` define to not cause an error
/// - 2016/09/04 (1.15.2)- Fixed wrong combobox height calculation
/// - 2016/09/03 (1.15.1)- Fixed gaps inside combo boxes in OpenGL
/// - 2016/09/02 (1.15.0) - Changed nuklear to not have any default vertex layout and
///                        instead made it user provided. The range of types to convert
///                        to is quite limited at the moment, but I would be more than
///                        happy to accept PRs to add additional.
/// - 2016/08/30 (1.14.2) - Removed unused variables
/// - 2016/08/30 (1.14.1) - Fixed C++ build errors
/// - 2016/08/30 (1.14.0) - Removed mouse dragging from SDL demo since it does not work correctly
/// - 2016/08/30 (1.13.4) - Tweaked some default styling variables
/// - 2016/08/30 (1.13.3) - Hopefully fixed drawing bug in slider, in general I would
///                        refrain from using slider with a big number of steps.
/// - 2016/08/30 (1.13.2) - Fixed close and minimize button which would fire even if the
///                        window was in Read Only Mode.
/// - 2016/08/30 (1.13.1) - Fixed popup panel padding handling which was previously just
///                        a hack for combo box and menu.
/// - 2016/08/30 (1.13.0) - Removed `NK_WINDOW_DYNAMIC` flag from public API since
///                        it is bugged and causes issues in window selection.
/// - 2016/08/30 (1.12.0) - Removed scaler size. The size of the scaler is now
///                        determined by the scrollbar size
/// - 2016/08/30 (1.11.2) - Fixed some drawing bugs caused by changes from 1.11
/// - 2016/08/30 (1.11.1) - Fixed overlapping minimized window selection
/// - 2016/08/30 (1.11.0) - Removed some internal complexity and overly complex code
///                        handling panel padding and panel border.
/// - 2016/08/29 (1.10.0) - Added additional height parameter to `nk_combobox_xxx`
/// - 2016/08/29 (1.10.0) - Fixed drawing bug in dynamic popups
/// - 2016/08/29 (1.10.0) - Added experimental mouse scrolling to popups, menus and comboboxes
/// - 2016/08/26 (1.10.0) - Added window name string prepresentation to account for
///                        hash collisions. Currently limited to NK_WINDOW_MAX_NAME
///                        which in term can be redefined if not big enough.
/// - 2016/08/26 (1.10.0) - Added stacks for temporary style/UI changes in code
/// - 2016/08/25 (1.10.0) - Changed `nk_input_is_key_pressed` and 'nk_input_is_key_released'
///                        to account for key press and release happening in one frame.
/// - 2016/08/25 (1.10.0) - Added additional nk_edit flag to directly jump to the end on activate
/// - 2016/08/17 (1.09.6)- Removed invalid check for value zero in nk_propertyx
/// - 2016/08/16 (1.09.5)- Fixed ROM mode for deeper levels of popup windows parents.
/// - 2016/08/15 (1.09.4)- Editbox are now still active if enter was pressed with flag
///                        `NK_EDIT_SIG_ENTER`. Main reasoning is to be able to keep
///                        typing after commiting.
/// - 2016/08/15 (1.09.4)- Removed redundant code
/// - 2016/08/15 (1.09.4)- Fixed negative numbers in `nk_strtoi` and remove unused variable
/// - 2016/08/15 (1.09.3)- Fixed `NK_WINDOW_BACKGROUND` flag behavior to select a background
///                        window only as selected by hovering and not by clicking.
/// - 2016/08/14 (1.09.2)- Fixed a bug in font atlas which caused wrong loading
///                        of glyphes for font with multiple ranges.
/// - 2016/08/12 (1.09.1)- Added additional function to check if window is currently
///                        hidden and therefore not visible.
/// - 2016/08/12 (1.09.1)- nk_window_is_closed now queries the correct flag `NK_WINDOW_CLOSED`
///                        instead of the old flag `NK_WINDOW_HIDDEN`
/// - 2016/08/09 (1.09.0) - Added additional double version to nk_property and changed
///                        the underlying implementation to not cast to float and instead
///                        work directly on the given values.
/// - 2016/08/09 (1.08.0) - Added additional define to overwrite library internal
///                        floating pointer number to string conversion for additional
///                        precision.
/// - 2016/08/09 (1.08.0) - Added additional define to overwrite library internal
///                        string to floating point number conversion for additional
///                        precision.
/// - 2016/08/08 (1.07.2)- Fixed compiling error without define NK_INCLUDE_FIXED_TYPE
/// - 2016/08/08 (1.07.1)- Fixed possible floating point error inside `nk_widget` leading
///                        to wrong wiget width calculation which results in widgets falsly
///                        becomming tagged as not inside window and cannot be accessed.
/// - 2016/08/08 (1.07.0) - Nuklear now differentiates between hiding a window (NK_WINDOW_HIDDEN) and
///                        closing a window (NK_WINDOW_CLOSED). A window can be hidden/shown
///                        by using `nk_window_show` and closed by either clicking the close
///                        icon in a window or by calling `nk_window_close`. Only closed
///                        windows get removed at the end of the frame while hidden windows
///                        remain.
/// - 2016/08/08 (1.06.0) - Added `nk_edit_string_zero_terminated` as a second option to
///                        `nk_edit_string` which takes, edits and outputs a '\0' terminated string.
/// - 2016/08/08 (1.05.4)- Fixed scrollbar auto hiding behavior
/// - 2016/08/08 (1.05.3)- Fixed wrong panel padding selection in `nk_layout_widget_space`
/// - 2016/08/07 (1.05.2)- Fixed old bug in dynamic immediate mode layout API, calculating
///                        wrong item spacing and panel width.
///- 2016/08/07 (1.05.1)- Hopefully finally fixed combobox popup drawing bug
///- 2016/08/07 (1.05.0) - Split varargs away from NK_INCLUDE_STANDARD_IO into own
///                        define NK_INCLUDE_STANDARD_VARARGS to allow more fine
///                        grained controlled over library includes.
/// - 2016/08/06 (1.04.5)- Changed memset calls to NK_MEMSET
/// - 2016/08/04 (1.04.4)- Fixed fast window scaling behavior
/// - 2016/08/04 (1.04.3)- Fixed window scaling, movement bug which appears if you
///                        move/scale a window and another window is behind it.
///                        If you are fast enough then the window behind gets activated
///                        and the operation is blocked. I now require activating
///                        by hovering only if mouse is not pressed.
/// - 2016/08/04 (1.04.2)- Fixed changing fonts
/// - 2016/08/03 (1.04.1)- Fixed `NK_WINDOW_BACKGROUND` behavior
/// - 2016/08/03 (1.04.0) - Added color parameter to `nk_draw_image`
/// - 2016/08/03 (1.04.0) - Added additional window padding style attributes for
///                        sub windows (combo, menu, ...)
/// - 2016/08/03 (1.04.0) - Added functions to show/hide software cursor
/// - 2016/08/03 (1.04.0) - Added `NK_WINDOW_BACKGROUND` flag to force a window
///                        to be always in the background of the screen
/// - 2016/08/03 (1.03.2)- Removed invalid assert macro for NK_RGB color picker
/// - 2016/08/01 (1.03.1)- Added helper macros into header include guard
/// - 2016/07/29 (1.03.0) - Moved the window/table pool into the header part to
///                        simplify memory management by removing the need to
///                        allocate the pool.
/// - 2016/07/29 (1.02.0) - Added auto scrollbar hiding window flag which if enabled
///                        will hide the window scrollbar after NK_SCROLLBAR_HIDING_TIMEOUT
///                        seconds without window interaction. To make it work
///                        you have to also set a delta time inside the `nk_context`.
/// - 2016/07/25 (1.01.1) - Fixed small panel and panel border drawing bugs
/// - 2016/07/15 (1.01.0) - Added software cursor to `nk_style` and `nk_context`
/// - 2016/07/15 (1.01.0) - Added const correctness to `nk_buffer_push' data argument
/// - 2016/07/15 (1.01.0) - Removed internal font baking API and simplified
///                        font atlas memory management by converting pointer
///                        arrays for fonts and font configurations to lists.
/// - 2016/07/15 (1.00.0) - Changed button API to use context dependend button
///                        behavior instead of passing it for every function call.
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/// ## Gallery
/// ![Figure [blue]: Feature overview with blue color styling](https://cloud.githubusercontent.com/assets/8057201/13538240/acd96876-e249-11e5-9547-5ac0b19667a0.png)
/// ![Figure [red]: Feature overview with red color styling](https://cloud.githubusercontent.com/assets/8057201/13538243/b04acd4c-e249-11e5-8fd2-ad7744a5b446.png)
/// ![Figure [widgets]: Widget overview](https://cloud.githubusercontent.com/assets/8057201/11282359/3325e3c6-8eff-11e5-86cb-cf02b0596087.png)
/// ![Figure [blackwhite]: Black and white](https://cloud.githubusercontent.com/assets/8057201/11033668/59ab5d04-86e5-11e5-8091-c56f16411565.png)
/// ![Figure [filexp]: File explorer](https://cloud.githubusercontent.com/assets/8057201/10718115/02a9ba08-7b6b-11e5-950f-adacdd637739.png)
/// ![Figure [opengl]: OpenGL Editor](https://cloud.githubusercontent.com/assets/8057201/12779619/2a20d72c-ca69-11e5-95fe-4edecf820d5c.png)
/// ![Figure [nodedit]: Node Editor](https://cloud.githubusercontent.com/assets/8057201/9976995/e81ac04a-5ef7-11e5-872b-acd54fbeee03.gif)
/// ![Figure [skinning]: Using skinning in Nuklear](https://cloud.githubusercontent.com/assets/8057201/15991632/76494854-30b8-11e6-9555-a69840d0d50b.png)
/// ![Figure [bf]: Heavy modified version](https://cloud.githubusercontent.com/assets/8057201/14902576/339926a8-0d9c-11e6-9fee-a8b73af04473.png)
///
/// ## Credits
/// Developed by Micha Mettke and every direct or indirect github contributor. <br /><br />
///
/// Embeds [stb_texedit](https://github.com/nothings/stb/blob/master/stb_textedit.h), [stb_truetype](https://github.com/nothings/stb/blob/master/stb_truetype.h) and [stb_rectpack](https://github.com/nothings/stb/blob/master/stb_rect_pack.h) by Sean Barret (public domain) <br />
/// Uses [stddoc.c](https://github.com/r-lyeh/stddoc.c) from r-lyeh@github.com for documentation generation <br /><br />
/// Embeds ProggyClean.ttf font by Tristan Grimmer (MIT license). <br />
///
/// Big thank you to Omar Cornut (ocornut@github) for his [imgui library](https://github.com/ocornut/imgui) and
/// giving me the inspiration for this library, Casey Muratori for handmade hero
/// and his original immediate mode graphical user interface idea and Sean
/// Barret for his amazing single header libraries which restored my faith
/// in libraries and brought me to create some of my own. Finally Apoorva Joshi
/// for his single header file packer.
*/

delete <<
```

`Private Esp/EspUI/Menu.cpp`:

```cpp
#include "Settings.h"
#include "Menu.h"
#include <iostream>
#include "Globals.h"

void Menu::RenderMenu(nk_context* ctx, ID3D11DeviceContext* d3dctx)
{
	if (nk_begin(ctx, "OverFlow", nk_rect(10, (Globals::g_iWindowHeight / 2) - 180, 180, 300), NK_WINDOW_NO_SCROLLBAR | NK_WINDOW_MOVABLE | NK_WINDOW_TITLE))
	{
		nk_layout_row_dynamic(ctx, 30, 1);
		if (nk_button_label(ctx, "Shutdown"))
			g_Settings::bShutDown = true;
	}

	nk_end(ctx);
	nk_d3d11_render(d3dctx, NK_ANTI_ALIASING_OFF);

	nk_input_begin(ctx);
	nk_input_end(ctx);
} 
s

delete <<
```

`Private Esp/EspUI/Menu.h`:

```h
#pragma once
#include "nuklear_d3d11.h"

class Menu
{
public:
	void RenderMenu(nk_context* ctx, ID3D11DeviceContext* d3dctx);
};s
```

`Private Esp/EspUI/Offsets.h`:

```h
namespace offsets
{
        constexpr uint64_t uworld_state = 0x8F8F740;
  
	constexpr uint64_t uworld_key = uworld_state + 0x38;
	
	constexpr uint64_t override_materials = 0x4f8;
  
	constexpr uint64_t game_instance = 0x1A8;
  
	constexpr uint64_t persistent_level = 0x38;
  
	constexpr uint64_t local_player_array = 0x40;
  
	constexpr uint64_t local_player_controller = 0x38;
  
	constexpr uint64_t local_player_pawn = 0x460;
  
	constexpr uint64_t control_rotation = 0x440;
  
	constexpr uint64_t camera_manager = 0x478;
  
	constexpr uint64_t camera_position = 0x1240;
  
	constexpr uint64_t camera_rotation = 0x124C;
  
	constexpr uint64_t camera_fov = 0x1258;
  
	constexpr uint64_t actor_array = 0xA0;
  
	constexpr uint64_t actor_count = 0xB8;
  
	constexpr uint64_t unique_id = 0x38;
  
	constexpr uint64_t mesh_component = 0x430;
  
	constexpr uint64_t last_render_time = 0x350;
  
	constexpr uint64_t last_submit_time = 0x358;
  
	constexpr uint64_t bone_array = 0x558;
  
	constexpr uint64_t bone_count = 0x560; // MAY BE OUTDATED
  
	constexpr uint64_t component_to_world = 0x250;
  
	constexpr uint64_t root_component = 0x230;
  
	constexpr uint64_t root_position = 0x164;
  
	constexpr uint64_t damage_handler = 0x9A0;
  
	constexpr uint64_t health = 0x1B0;
  
	constexpr uint64_t dormant = 0x120;
  
	constexpr uint64_t player_state = 0x3F0;
  
	constexpr uint64_t team_component = 0x5A0;
  
	constexpr uint64_t team_id = 0xF8;
  
	constexpr auto FresnelIntensity = 0x6B8;
  
	constexpr auto FresnelOffset = 0x694;
  
	constexpr auto CachedFresnelColor = 0x680;
  
	constexpr auto CachedFresnelOffset = 0x684;
  
	constexpr auto CachedFresnelIntensity = 0x688;
  
	constexpr auto CachedLocalFresnelOffset = 0x68c;
	
	constexpr auto LineOfSight = 0x4A60CE0;
  
}

```

`Private Esp/EspUI/QAngle.hpp`:

```hpp
#pragma once

class QAngle
{
public:
	QAngle(void)
	{
		Init();
	}
	QAngle(float X, float Y, float Z)
	{
		Init(X, Y, sZ);
	}
	QAngle(const float* clr)
	{
		Init(clr[0], clr[1], clr[2]);
	}

	void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f)
	{
		pitch = ix;
		yaw = iy;
		roll = iz;
	}

	float operator[](int i) const
	{
		return ((float*)this)[i];
	}
	float& operator[](int i)
	{
		return ((float*)this)[i];
	}

	QAngle& operator+=(const QAngle& v)
	{
		pitch += v.pitch; yaw += v.yaw; roll += v.roll;
		return *this;
	}
	QAngle& operator-=(const QAngle& v)
	{
		pitch -= v.pitch; yaw -= v.yaw; roll -= v.roll;
		return *this;
	}
	QAngle& operator*=(float fl)
	{
		pitch *= fl;
		yaw *= fl;
		roll *= fl;
		return *this;
	}
	QAngle& operator*=(const QAngle& v)
	{
		pitch *= v.pitch;
		yaw *= v.yaw;
		roll *= v.roll;
		return *this;
	}
	QAngle& operator/=(const QAngle& v)
	{
		pitch /= v.pitch;
		yaw /= v.yaw;
		roll /= v.roll;
		return *this;
	}
	QAngle& operator+=(float fl)
	{
		pitch += fl;
		yaw += fl;
		roll += fl;
		return *this;
	}
	QAngle& operator/=(float fl)
	{
		pitch /= fl;
		yaw /= fl;
		roll /= fl;
		return *this;
	}
	QAngle& operator-=(float fl)
	{
		pitch -= fl;
		yaw -= fl;
		roll -= fl;
		return *this;
	}

	QAngle& operator=(const QAngle& vOther)
	{
		pitch = vOther.pitch; yaw = vOther.yaw; roll = vOther.roll;
		return *this;
	}

	QAngle operator-(void) const
	{
		return QAngle(-pitch, -yaw, -roll);
	}
	QAngle operator+(const QAngle& v) const
	{
		return QAngle(pitch + v.pitch, yaw + v.yaw, roll + v.roll);
	}
	QAngle operator-(const QAngle& v) const
	{
		return QAngle(pitch - v.pitch, yaw - v.yaw, roll - v.roll);
	}
	QAngle operator*(float fl) const
	{
		return QAngle(pitch * fl, yaw * fl, roll * fl);
	}
	QAngle operator*(const QAngle& v) const
	{
		return QAngle(pitch * v.pitch, yaw * v.yaw, roll * v.roll);
	}
	QAngle operator/(float fl) const
	{
		return QAngle(pitch / fl, yaw / fl, roll / fl);
	}
	QAngle operator/(const QAngle& v) const
	{
		return QAngle(pitch / v.pitch, yaw / v.yaw, roll / v.roll);
	}

	float Length() const
	{
		return sqrt(pitch * pitch + yaw * yaw + roll * roll);
	}
	float LengthSqr(void) const
	{
		return (pitch * pitch + yaw * yaw + roll * roll);
	}
	bool IsZero(float tolerance = 0.01f) const
	{
		return (pitch > -tolerance && pitch < tolerance &&
			yaw > -tolerance && yaw < tolerance &&
			roll > -tolerance && roll < tolerance);
	}
	inline QAngle Clamp()
	{
		if (this->pitch < -89.0f)
			this->pitch = -89.0f;

		if (this->pitch > 89.0f)
			this->pitch = 89.0f;

		while (this->yaw < -180.0f)
			this->yaw += 360.0f;

		while (this->yaw > 180.0f)
			this->yaw -= 360.0f;

		this->roll = 0.0f;
		return *this;
	}


	float pitch;
	float yaw;
	float roll;
};

inline QAngle operator*(float lhs, const QAngle& rhs)
{
	return rhs * lhs;
}
inline QAngle operator/(float lhs, const QAngle& rhs)
{
	return rhs / lhs;
}


delete <<


```

`Private Esp/EspUI/Render.h`:

```h
#if 0
ps_2_0
dcl t0
dcl t1.xy
dcl_2d s0
texld r0, t1, s0
mul r0, r0, t0
mov oC0, r0

ps_2_0
dcl t0
dcl t1.xys
dcl_2d s0
texld r0, r2, s0
mul oC0, r0, r1

ps_4_0
dcl_sampler s0, mode_default
dcl_resource_texture2d(float, float, float, float) t0
dcl_input_ps linear v1.xyzw
dcl_input_ps linear v2.xy
dcl_output o0.xyzw
dcl_temps 1
sample r0.xyzw, v2.xyxx, t0.xyzw, s0
mul o0.xyzw, r0.xyzw, v1.xyzw
ret
#endif

const BYTE nk_d3d11_pixel_shader[] =
{
	 68,  88,  66,  67, 249,  46,
	 26,  75, 111, 182, 161, 241,
	199, 179, 191,  89,  44, 229,
	245, 103,   1,   0,   0,   0,
	124,   2,   0,   0,   5,   0,
	  0,   0,  52,   0,   0,   0,
	176,   0,   0,   0,  56,   1,
	  0,   0, 212,   1,   0,   0,
	 72,   2,   0,   0,  88,  78,
	 65,  83, 116,   0,   0,   0,
	116,   0,   0,   0,   0,   2,
	255, 255,  76,   0,   0,   0,
	 40,   0,   0,   0,   0,   0,
	 40,   0,   0,   0,  40,   0,
	  0,   0,  40,   0,   1,   0,
	 36,   0,   0,   0,  40,   0,
	  0,   0,   0,   0,   0,   2,
	255, 255,  31,   0,   0,   2,
	  0,   0,   0, 128,   0,   0,
	 15, 176,  31,   0,   0,   2,
	  0,   0,   0, 128,   1,   0,
	  3, 176,  31,   0,   0,   2,
	  0,   0,   0, 144,   0,   8,
	 15, 160,  66,   0,   0,   3,
	  0,   0,  15, 128,   2,   0,
	228, 128,   0,   8, 228, 160,
	  5,   0,   0,   3,   0,   8,
	 15, 128,   0,   0, 228, 128,
	  1,   0, 228, 128, 255, 255,
	  0,   0,  65, 111, 110,  57,
	128,   0,   0,   0, 128,   0,
	  0,   0,   0,   2, 255, 255,
	 88,   0,   0,   0,  40,   0,
	  0,   0,   0,   0,  40,   0,
	  0,   0,  40,   0,   0,   0,
	 40,   0,   1,   0,  36,   0,
	  0,   0,  40,   0,   0,   0,
	  0,   0,   0,   2, 255, 255,
	 31,   0,   0,   2,   0,   0,
	  0, 128,   0,   0,  15, 176,
	 31,   0,   0,   2,   0,   0,
	  0, 128,   1,   0,   3, 176,
	 31,   0,   0,   2,   0,   0,
	  0, 144,   0,   8,  15, 160,
	 66,   0,   0,   3,   0,   0,
	 15, 128,   1,   0, 228, 176,
	  0,   8, 228, 160,   5,   0,
	  0,   3,   0,   0,  15, 128,
	  0,   0, 228, 128,   0,   0,
	228, 176,   1,   0,   0,   2,
	  0,   8,  15, 128,   0,   0,
	228, 128, 255, 255,   0,   0,
	 83,  72,  68,  82, 148,   0,
	  0,   0,  64,   0,   0,   0,
	 37,   0,   0,   0,  90,   0,
	  0,   3,   0,  96,  16,   0,
	  0,   0,   0,   0,  88,  24,
	  0,   4,   0, 112,  16,   0,
	  0,   0,   0,   0,  85,  85,
	  0,   0,  98,  16,   0,   3,
	242,  16,  16,   0,   1,   0,
	  0,   0,  98,  16,   0,   3,
	 50,  16,  16,   0,   2,   0,
	  0,   0, 101,   0,   0,   3,
	242,  32,  16,   0,   0,   0,
	  0,   0, 104,   0,   0,   2,
	  1,   0,   0,   0,  69,   0,
	  0,   9, 242,   0,  16,   0,
	  0,   0,   0,   0,  70,  16,
	 16,   0,   2,   0,   0,   0,
	 70, 126,  16,   0,   0,   0,
	  0,   0,   0,  96,  16,   0,
	  0,   0,   0,   0,  56,   0,
	  0,   7, 242,  32,  16,   0,
	  0,   0,   0,   0,  70,  14,
	 16,   0,   0,   0,   0,   0,
	 70,  30,  16,   0,   1,   0,
	  0,   0,  62,   0,   0,   1,
	 73,  83,  71,  78, 108,   0,
	  0,   0,   3,   0,   0,   0,
	  8,   0,   0,   0,  80,   0,
	  0,   0,   0,   0,   0,   0,
	  1,   0,   0,   0,   3,   0,
	  0,   0,   0,   0,   0,   0,
	 15,   0,   0,   0,  92,   0,
	  0,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   3,   0,
	  0,   0,   1,   0,   0,   0,
	 15,  15,   0,   0,  98,   0,
	  0,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   3,   0,
	  0,   0,   2,   0,   0,   0,
	  3,   3,   0,   0,  83,  86,
	 95,  80,  79,  83,  73,  84,
	 73,  79,  78,   0,  67,  79,
	 76,  79,  82,   0,  84,  69,
	 88,  67,  79,  79,  82,  68,
	  0, 171,  79,  83,  71,  78,
	 44,   0,   0,   0,   1,   0,
	  0,   0,   8,   0,   0,   0,
	 32,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   0,   0,
	  3,   0,   0,   0,   0,   0,
	  0,   0,  15,   0,   0,   0,
	 83,  86,  95,  84,  97, 114,
	103, 101, 116,   0, 171, 171
};
```

`Private Esp/EspUI/SDKMisc.h`:

```h
#pragma once
#include <cstdint>

class C_RoundMan
{
public:
	char pad_0000[744]; //0x0000
	int32_t m_iRound; //0x02E8s
	char pad_02EC[148]; //0x02EC
}; //Size: 0x0380
extern C_RoundMan* g_pRoundMan;

namespace GlobalSDK
{
	static bool IsInGame()
	{
		return g_pRoundMan->m_iRound == 3;
	}

	static bool InPrep()
	{
		return g_pRoundMan->m_iRound == 2;
	}
}

```

`Private Esp/EspUI/Settings.cpp`:

```cpp
#include "Utils.h"

namespace g_Settings
{
	// Menu
	bool bMenu = false;
	bool bShutDown = false;
	PVOID hModule = nullptr;s


	// Aimbot
	bool bAimbot = false;
	int  iAimbot = false;
	int  iFov = 90;
	int  iBone = 0;

	// Entity
	bool  bChams = true;
	bool  bRecoil = true;
	bool  bSpread = true;
	float  fSpeed = 175.f;
	float  fWepFov = 1.4;
	float  fCharFov = 1.4;
}

```

`Private Esp/EspUI/Settings.h`:

```h
#pragma once

namespace g_Settings
{
	// Menu
	extern bool bMenu;
	extern bool bShutDown;s
	extern void* hModule;

	// Aimbot
	extern bool bAimbot;
	extern int  iAimbot;
	extern int  iFov;
	extern int  iBone;

	// Entity
	extern bool  bChams;
	extern bool  bRecoil;
	extern bool  bSpread;
	extern float  fSpeed;
	extern float  fWepFov;
	extern float  fCharFov;
}
```

`Private Esp/EspUI/StateSaver.cpp`:

```cpp
#include "D3D11Renderer.h"

D3D11StateSaver::D3D11StateSaver() :
	m_savedState(false),s
	m_featureLevel(D3D_FEATURE_LEVEL_11_0),
	m_pContext(NULL),
	m_primitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED),
	m_pInputLayout(NULL),
	m_pBlendState(NULL),
	m_sampleMask(0xffffffff),
	m_pDepthStencilState(NULL),
	m_stencilRef(0),
	m_pRasterizerState(NULL),
	m_pPSSRV(NULL),
	m_pSamplerState(NULL),
	m_pVS(NULL),
	m_numVSClassInstances(0),
	m_pVSConstantBuffer(NULL),
	m_pGS(NULL),
	m_numGSClassInstances(0),
	m_pGSConstantBuffer(NULL),
	m_pGSSRV(NULL),
	m_pPS(NULL),
	m_numPSClassInstances(0),
	m_pHS(NULL),
	m_numHSClassInstances(0),
	m_pDS(NULL),
	m_numDSClassInstances(0),
	m_pVB(NULL),
	m_vertexStride(0),
	m_vertexOffset(0),
	m_pIndexBuffer(NULL),
	m_indexFormat(DXGI_FORMAT_UNKNOWN),
	m_indexOffset(0)
{
	for (int i = 0; i < 4; ++i)
		m_blendFactor[i] = 0.0f;
	for (int i = 0; i < 256; ++i)
	{
		m_pVSClassInstances[i] = NULL;
		m_pGSClassInstances[i] = NULL;
		m_pPSClassInstances[i] = NULL;
		m_pHSClassInstances[i] = NULL;
		m_pDSClassInstances[i] = NULL;
	}
}

D3D11StateSaver::~D3D11StateSaver()
{
	releaseSavedState();
}

HRESULT D3D11StateSaver::saveCurrentState(ID3D11DeviceContext* pContext)
{
	if (m_savedState)
		releaseSavedState();
	if (pContext == NULL)
		return E_INVALIDARG;

	ID3D11Device* pDevice;
	pContext->GetDevice(&pDevice);
	if (pDevice != NULL) {
		m_featureLevel = pDevice->GetFeatureLevel();
		pDevice->Release();
	}

	pContext->AddRef();
	m_pContext = pContext;

	m_pContext->IAGetPrimitiveTopology(&m_primitiveTopology);
	m_pContext->IAGetInputLayout(&m_pInputLayout);

	m_pContext->OMGetBlendState(&m_pBlendState, m_blendFactor, &m_sampleMask);
	m_pContext->OMGetDepthStencilState(&m_pDepthStencilState, &m_stencilRef);

	m_pContext->RSGetState(&m_pRasterizerState);

	m_numVSClassInstances = 256;
	m_pContext->VSGetShader(&m_pVS, m_pVSClassInstances, &m_numVSClassInstances);
	m_pContext->VSGetConstantBuffers(0, 1, &m_pVSConstantBuffer);

	m_numPSClassInstances = 256;
	m_pContext->PSGetShader(&m_pPS, m_pPSClassInstances, &m_numPSClassInstances);
	m_pContext->PSGetShaderResources(0, 1, &m_pPSSRV);
	pContext->PSGetSamplers(0, 1, &m_pSamplerState);

	if (m_featureLevel >= D3D_FEATURE_LEVEL_10_0)
	{
		m_numGSClassInstances = 256;
		m_pContext->GSGetShader(&m_pGS, m_pGSClassInstances, &m_numGSClassInstances);
		m_pContext->GSGetConstantBuffers(0, 1, &m_pGSConstantBuffer);

		m_pContext->GSGetShaderResources(0, 1, &m_pGSSRV);

		if (m_featureLevel >= D3D_FEATURE_LEVEL_11_0)
		{
			m_numHSClassInstances = 256;
			m_pContext->HSGetShader(&m_pHS, m_pHSClassInstances, &m_numHSClassInstances);

			m_numDSClassInstances = 256;
			m_pContext->DSGetShader(&m_pDS, m_pDSClassInstances, &m_numDSClassInstances);
		}
	}

	m_pContext->IAGetVertexBuffers(0, 1, &m_pVB, &m_vertexStride, &m_vertexOffset);

	m_pContext->IAGetIndexBuffer(&m_pIndexBuffer, &m_indexFormat, &m_indexOffset);

	m_savedState = true;

	return S_OK;
}

HRESULT D3D11StateSaver::restoreSavedState()
{
	if (!m_savedState)
		return E_FAIL;

	m_pContext->IASetPrimitiveTopology(m_primitiveTopology);
	m_pContext->IASetInputLayout(m_pInputLayout);

	m_pContext->OMSetBlendState(m_pBlendState, m_blendFactor, m_sampleMask);
	m_pContext->OMSetDepthStencilState(m_pDepthStencilState, m_stencilRef);

	m_pContext->RSSetState(m_pRasterizerState);

	m_pContext->VSSetShader(m_pVS, m_pVSClassInstances, m_numVSClassInstances);
	m_pContext->VSSetConstantBuffers(0, 1, &m_pVSConstantBuffer);

	m_pContext->PSSetShader(m_pPS, m_pPSClassInstances, m_numPSClassInstances);
	m_pContext->PSSetShaderResources(0, 1, &m_pPSSRV);
	m_pContext->PSSetSamplers(0, 1, &m_pSamplerState);

	if (m_featureLevel >= D3D_FEATURE_LEVEL_10_0)
	{
		m_pContext->GSSetShader(m_pGS, m_pGSClassInstances, m_numGSClassInstances);
		m_pContext->GSSetConstantBuffers(0, 1, &m_pGSConstantBuffer);

		m_pContext->GSSetShaderResources(0, 1, &m_pGSSRV);

		if (m_featureLevel >= D3D_FEATURE_LEVEL_11_0)
		{
			m_pContext->HSSetShader(m_pHS, m_pHSClassInstances, m_numHSClassInstances);

			m_pContext->DSSetShader(m_pDS, m_pDSClassInstances, m_numDSClassInstances);
		}
	}

	m_pContext->IASetVertexBuffers(0, 1, &m_pVB, &m_vertexStride, &m_vertexOffset);

	m_pContext->IASetIndexBuffer(m_pIndexBuffer, m_indexFormat, m_indexOffset);

	return S_OK;
}

void D3D11StateSaver::releaseSavedState()
{
	m_primitiveTopology = D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED;
	SAFE_RELEASE(m_pInputLayout);
	SAFE_RELEASE(m_pBlendState);
	for (int i = 0; i < 4; ++i)
		m_blendFactor[i] = 0.0f;
	m_sampleMask = 0xffffffff;
	SAFE_RELEASE(m_pDepthStencilState);
	m_stencilRef = 0;
	SAFE_RELEASE(m_pRasterizerState);
	SAFE_RELEASE(m_pPSSRV);
	SAFE_RELEASE(m_pSamplerState);
	SAFE_RELEASE(m_pVS);
	for (UINT i = 0; i < m_numVSClassInstances; ++i)
		SAFE_RELEASE(m_pVSClassInstances[i]);
	m_numVSClassInstances = 0;
	SAFE_RELEASE(m_pVSConstantBuffer);
	SAFE_RELEASE(m_pGS);
	for (UINT i = 0; i < m_numGSClassInstances; ++i)
		SAFE_RELEASE(m_pGSClassInstances[i]);
	m_numGSClassInstances = 0;
	SAFE_RELEASE(m_pGSConstantBuffer);
	SAFE_RELEASE(m_pGSSRV);
	SAFE_RELEASE(m_pPS);
	for (UINT i = 0; i < m_numPSClassInstances; ++i)
		SAFE_RELEASE(m_pPSClassInstances[i]);
	m_numPSClassInstances = 0;
	SAFE_RELEASE(m_pHS);
	for (UINT i = 0; i < m_numHSClassInstances; ++i)
		SAFE_RELEASE(m_pHSClassInstances[i]);
	m_numHSClassInstances = 0;
	SAFE_RELEASE(m_pDS);
	for (UINT i = 0; i < m_numDSClassInstances; ++i)
		SAFE_RELEASE(m_pDSClassInstances[i]);
	m_numDSClassInstances = 0;
	SAFE_RELEASE(m_pVB);
	m_vertexStride = 0;
	m_vertexOffset = 0;
	SAFE_RELEASE(m_pIndexBuffer);
	m_indexFormat = DXGI_FORMAT_UNKNOWN;
	m_indexOffset = 0;

	SAFE_RELEASE(m_pContext);
	m_featureLevel = D3D_FEATURE_LEVEL_11_0;

	m_savedState = false;
}

```

`Private Esp/EspUI/Utils.h`:

```h
#include <chrono>
#include <iomanip>
#include <Windows.h>
#include <Psapi.h>
#include <iostream>
#include <sstream>s
#include <vector>

#define INRANGE(x,a,b)   (x >= a && x <= b)
#define GET_BYTE( x )    (GET_BITS(x[0]) << 4 | GET_BITS(x[1]))
#define GET_BITS( x )    (INRANGE((x&(~0x20)),'A','F') ? ((x&(~0x20)) - 'A' + 0xa) : (INRANGE(x,'0','9') ? x - '0' : 0))
#define PTRMAXVAL ((PVOID)0x000F000000000000)

static void GetCurrentSystemTime(tm& timeInfo)
{
	const std::chrono::system_clock::time_point systemNow = std::chrono::system_clock::now();
	std::time_t now_c = std::chrono::system_clock::to_time_t(systemNow);
	localtime_s(&timeInfo, &now_c); // using localtime_s as std::localtime is not thread-safe.
};

// basefunct
static std::string SetupStringParams(std::string szBasicString)
{
	return szBasicString;
}

// Replace % with a desired string / value represented after semicolons. Works kinda like printf.
template <typename T, typename... Targs>
static std::string SetupStringParams(std::string szBasicString, T arg, Targs&& ...args)
{
	const auto found = szBasicString.find_first_of('%');
	if (found != std::string::npos)
	{
		std::stringstream tmp;
		tmp << arg;
		szBasicString.replace(found, 1, tmp.str());
		szBasicString = SetupStringParams(szBasicString, std::forward<Targs>(args)...);
	}
	return szBasicString;
}

namespace Utils
{
	template <typename ... Args>
	static void Log(const std::string& str, Args ...arguments)
	{
		Log(SetupStringParams(str.c_str(), arguments...));
	}

	static void Log(const std::string& str)
	{
		tm timeInfo{ };
		GetCurrentSystemTime(timeInfo);

		std::stringstream ssTime; // Temp stringstream to keep things clean
		ssTime << "[" << std::put_time(&timeInfo, "%T") << "] " << str << std::endl;

		std::cout << ssTime.str();
	};

	template<class T>
	T Read(const DWORD64 dwPtr)
	{
		if (!IsBadReadPtr((void*)dwPtr, sizeof(T)))
			return *(T*)dwPtr;
		return 0;
	}
	static __forceinline BOOLEAN IsValid(PVOID ptr)
	{
		return (ptr >= (PVOID)0x10000) && (ptr < PTRMAXVAL) && ptr != nullptr && !IsBadReadPtr(ptr, sizeof(ptr));
	}
	template <class vType>
	static BOOLEAN Write(uintptr_t address, vType value)
	{
		if (IsValid((vType*)(address)))
		{
			*(vType*)(address) = value;
			return TRUE;
		}
		return FALSE;
	}

	template <typename vType>
	static vType ReadPtr(std::initializer_list<uintptr_t> _Offsets, bool ReadFirstOffset)
	{
		uintptr_t LastPtr = NULL;
		int OffsetsSize = NULL;
		std::vector<uintptr_t> Offsets = { NULL };
		Offsets = _Offsets;
		OffsetsSize = Offsets.size();
		LastPtr = Read<uintptr_t>((ReadFirstOffset ? Read<uintptr_t>(Offsets[0]) : Offsets[0]) + Offsets[1]);
		for (size_t i = 2; i < OffsetsSize - 1; i++)
			if (!(LastPtr = Read<uintptr_t>(LastPtr + Offsets[i])))
				return vType();
		return Read<vType>(LastPtr + Offsets[OffsetsSize - 1]);
	}

	template <typename vType>
	static BOOLEAN WritePtr(std::initializer_list<uintptr_t> _Offsets, vType _value, bool ReadFirstOffset)
	{
		uintptr_t LastPtr = NULL;
		int OffsetsSize = NULL;
		std::vector<uintptr_t> Offsets = { NULL };
		Offsets = _Offsets;
		OffsetsSize = Offsets.size();
		LastPtr = Read<uintptr_t>((ReadFirstOffset ? Read<uintptr_t>(Offsets[0]) : Offsets[0]) + Offsets[1]);
		for (size_t i = 2; i < OffsetsSize - 1; i++)
			if (!(LastPtr = Read<uintptr_t>(LastPtr + Offsets[i])))
				return FALSE;
		return Write<vType>(LastPtr + Offsets[OffsetsSize - 1], _value);
	}

	static uint8_t* FindSignature(uintptr_t Module, const char* szSignature)
	{
		static auto pattern_to_byte = [](const char* pattern) {
			auto bytes = std::vector < int >{};
			auto start = const_cast<char*>(pattern);
			auto end = const_cast<char*>(pattern) + strlen(pattern);

			for (auto current = start; current < end; ++current) {
				if (*current == '?') {
					++current;
					if (*current == '?')
						++current;
					bytes.push_back(-1);
				}
				else {
					bytes.push_back(strtoul(current, &current, 16));
				}
			}
			return bytes;
		};

		auto dosHeader = (PIMAGE_DOS_HEADER)Module;
		auto ntHeaders = (PIMAGE_NT_HEADERS)((uint8_t*)Module + dosHeader->e_lfanew);

		auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;
		auto patternBytes = pattern_to_byte(szSignature);
		auto scanBytes = reinterpret_cast<uint8_t*>(Module);

		auto s = patternBytes.size();
		auto d = patternBytes.data();

		for (auto i = 0ul; i < sizeOfImage - s; ++i) {
			bool found = true;
			for (auto j = 0ul; j < s; ++j) {
				if (scanBytes[i + j] != d[j] && d[j] != -1) {
					found = false;
					break;
				}
			}
			if (found) {
				return &scanBytes[i];
			}
		}
		return nullptr;
	}
}
```

`Private Esp/EspUI/VMatrix.cpp`:

```cpp
#include "VMatrix.hpp"
s
//-----------------------------------------------------------------------------
// VMatrix inlines.
//-----------------------------------------------------------------------------
inline VMatrix::VMatrix()
{
}

inline VMatrix::VMatrix(
	float m00, float m01, float m02, float m03,
	float m10, float m11, float m12, float m13,
	float m20, float m21, float m22, float m23,
	float m30, float m31, float m32, float m33)
{
	Init(
		m00, m01, m02, m03,
		m10, m11, m12, m13,
		m20, m21, m22, m23,
		m30, m31, m32, m33
	);
}


inline VMatrix::VMatrix(const matrix3x4_t& matrix3x4)
{
	Init(matrix3x4);
}


//-----------------------------------------------------------------------------
// Creates a matrix where the X axis = forward
// the Y axis = left, and the Z axis = up
//-----------------------------------------------------------------------------
inline VMatrix::VMatrix(const Vector& xAxis, const Vector& yAxis, const Vector& zAxis)
{
	Init(
		xAxis.x, yAxis.x, zAxis.x, 0.0f,
		xAxis.y, yAxis.y, zAxis.y, 0.0f,
		xAxis.z, yAxis.z, zAxis.z, 0.0f,
		0.0f, 0.0f, 0.0f, 1.0f
	);
}


inline void VMatrix::Init(
	float m00, float m01, float m02, float m03,
	float m10, float m11, float m12, float m13,
	float m20, float m21, float m22, float m23,
	float m30, float m31, float m32, float m33
)
{
	m[0][0] = m00;
	m[0][1] = m01;
	m[0][2] = m02;
	m[0][3] = m03;

	m[1][0] = m10;
	m[1][1] = m11;
	m[1][2] = m12;
	m[1][3] = m13;

	m[2][0] = m20;
	m[2][1] = m21;
	m[2][2] = m22;
	m[2][3] = m23;

	m[3][0] = m30;
	m[3][1] = m31;
	m[3][2] = m32;
	m[3][3] = m33;
}


//-----------------------------------------------------------------------------
// Initialize from a 3x4
//-----------------------------------------------------------------------------
inline void VMatrix::Init(const matrix3x4_t& matrix3x4)
{
	memcpy(m, matrix3x4.Base(), sizeof(matrix3x4_t));

	m[3][0] = 0.0f;
	m[3][1] = 0.0f;
	m[3][2] = 0.0f;
	m[3][3] = 1.0f;
}

//-----------------------------------------------------------------------------
// Vector3DMultiplyPosition treats src2 as if it's a point (adds the translation)
//-----------------------------------------------------------------------------
// NJS: src2 is passed in as a full vector rather than a reference to prevent the need
// for 2 branches and a potential copy in the body.  (ie, handling the case when the src2
// reference is the same as the dst reference ).
inline void Vector3DMultiplyPosition(const VMatrix& src1, const Vector& src2, Vector& dst)
{
	dst[0] = src1[0][0] * src2.x + src1[0][1] * src2.y + src1[0][2] * src2.z + src1[0][3];
	dst[1] = src1[1][0] * src2.x + src1[1][1] * src2.y + src1[1][2] * src2.z + src1[1][3];
	dst[2] = src1[2][0] * src2.x + src1[2][1] * src2.y + src1[2][2] * src2.z + src1[2][3];
}

//-----------------------------------------------------------------------------
// Methods related to the basis vectors of the matrix
//-----------------------------------------------------------------------------

inline Vector VMatrix::GetForward() const
{
	return Vector(m[0][0], m[1][0], m[2][0]);
}

inline Vector VMatrix::GetLeft() const
{
	return Vector(m[0][1], m[1][1], m[2][1]);
}

inline Vector VMatrix::GetUp() const
{
	return Vector(m[0][2], m[1][2], m[2][2]);
}

inline void VMatrix::SetForward(const Vector& vForward)
{
	m[0][0] = vForward.x;
	m[1][0] = vForward.y;
	m[2][0] = vForward.z;
}

inline void VMatrix::SetLeft(const Vector& vLeft)
{
	m[0][1] = vLeft.x;
	m[1][1] = vLeft.y;
	m[2][1] = vLeft.z;
}

inline void VMatrix::SetUp(const Vector& vUp)
{
	m[0][2] = vUp.x;
	m[1][2] = vUp.y;
	m[2][2] = vUp.z;
}

inline void VMatrix::GetBasisVectors(Vector& vForward, Vector& vLeft, Vector& vUp) const
{
	vForward.Init(m[0][0], m[1][0], m[2][0]);
	vLeft.Init(m[0][1], m[1][1], m[2][1]);
	vUp.Init(m[0][2], m[1][2], m[2][2]);
}

inline void VMatrix::SetBasisVectors(const Vector& vForward, const Vector& vLeft, const Vector& vUp)
{
	SetForward(vForward);
	SetLeft(vLeft);
	SetUp(vUp);
}


//-----------------------------------------------------------------------------
// Methods related to the translation component of the matrix
//-----------------------------------------------------------------------------

inline Vector VMatrix::GetTranslation() const
{
	return Vector(m[0][3], m[1][3], m[2][3]);
}

inline Vector& VMatrix::GetTranslation(Vector& vTrans) const
{
	vTrans.x = m[0][3];
	vTrans.y = m[1][3];
	vTrans.z = m[2][3];
	return vTrans;
}

inline void VMatrix::SetTranslation(const Vector& vTrans)
{
	m[0][3] = vTrans.x;
	m[1][3] = vTrans.y;
	m[2][3] = vTrans.z;
}


//-----------------------------------------------------------------------------
// appply translation to this matrix in the input space
//-----------------------------------------------------------------------------
inline void VMatrix::PreTranslate(const Vector& vTrans)
{
	Vector tmp;
	Vector3DMultiplyPosition(*this, vTrans, tmp);
	m[0][3] = tmp.x;
	m[1][3] = tmp.y;
	m[2][3] = tmp.z;
}


//-----------------------------------------------------------------------------
// appply translation to this matrix in the output space
//-----------------------------------------------------------------------------
inline void VMatrix::PostTranslate(const Vector& vTrans)
{
	m[0][3] += vTrans.x;
	m[1][3] += vTrans.y;
	m[2][3] += vTrans.z;
}

inline const matrix3x4_t& VMatrix::As3x4() const
{
	return *((const matrix3x4_t*)this);
}

inline matrix3x4_t& VMatrix::As3x4()
{
	return *((matrix3x4_t*)this);
}

inline void VMatrix::CopyFrom3x4(const matrix3x4_t& m3x4)
{
	memcpy(m, m3x4.Base(), sizeof(matrix3x4_t));
	m[3][0] = m[3][1] = m[3][2] = 0;
	m[3][3] = 1;
}

inline void VMatrix::Set3x4(matrix3x4_t& matrix3x4) const
{
	memcpy(matrix3x4.Base(), m, sizeof(matrix3x4_t));
}


//-----------------------------------------------------------------------------
// Matrix Math operations
//-----------------------------------------------------------------------------
inline const VMatrix& VMatrix::operator+=(const VMatrix& other)
{
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] += other.m[i][j];
		}
	}

	return *this;
}

inline VMatrix VMatrix::operator+(const VMatrix& other) const
{
	VMatrix ret;
	for (int i = 0; i < 16; i++) {
		((float*)ret.m)[i] = ((float*)m)[i] + ((float*)other.m)[i];
	}
	return ret;
}

inline VMatrix VMatrix::operator-(const VMatrix& other) const
{
	VMatrix ret;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			ret.m[i][j] = m[i][j] - other.m[i][j];
		}
	}

	return ret;
}

inline VMatrix VMatrix::operator-() const
{
	VMatrix ret;
	for (int i = 0; i < 16; i++) {
		((float*)ret.m)[i] = -((float*)m)[i];
	}
	return ret;
}

//-----------------------------------------------------------------------------
// Vector transformation
//-----------------------------------------------------------------------------


inline Vector VMatrix::operator*(const Vector& vVec) const
{
	Vector vRet;
	vRet.x = m[0][0] * vVec.x + m[0][1] * vVec.y + m[0][2] * vVec.z + m[0][3];
	vRet.y = m[1][0] * vVec.x + m[1][1] * vVec.y + m[1][2] * vVec.z + m[1][3];
	vRet.z = m[2][0] * vVec.x + m[2][1] * vVec.y + m[2][2] * vVec.z + m[2][3];

	return vRet;
}

inline Vector VMatrix::VMul4x3(const Vector& vVec) const
{
	Vector vResult;
	Vector3DMultiplyPosition(*this, vVec, vResult);
	return vResult;
}


inline Vector VMatrix::VMul4x3Transpose(const Vector& vVec) const
{
	Vector tmp = vVec;
	tmp.x -= m[0][3];
	tmp.y -= m[1][3];
	tmp.z -= m[2][3];

	return Vector(
		m[0][0] * tmp.x + m[1][0] * tmp.y + m[2][0] * tmp.z,
		m[0][1] * tmp.x + m[1][1] * tmp.y + m[2][1] * tmp.z,
		m[0][2] * tmp.x + m[1][2] * tmp.y + m[2][2] * tmp.z
	);
}

inline Vector VMatrix::VMul3x3(const Vector& vVec) const
{
	return Vector(
		m[0][0] * vVec.x + m[0][1] * vVec.y + m[0][2] * vVec.z,
		m[1][0] * vVec.x + m[1][1] * vVec.y + m[1][2] * vVec.z,
		m[2][0] * vVec.x + m[2][1] * vVec.y + m[2][2] * vVec.z
	);
}

inline Vector VMatrix::VMul3x3Transpose(const Vector& vVec) const
{
	return Vector(
		m[0][0] * vVec.x + m[1][0] * vVec.y + m[2][0] * vVec.z,
		m[0][1] * vVec.x + m[1][1] * vVec.y + m[2][1] * vVec.z,
		m[0][2] * vVec.x + m[1][2] * vVec.y + m[2][2] * vVec.z
	);
}


inline void VMatrix::V3Mul(const Vector& vIn, Vector& vOut) const
{
	float rw;

	rw = 1.0f / (m[3][0] * vIn.x + m[3][1] * vIn.y + m[3][2] * vIn.z + m[3][3]);
	vOut.x = (m[0][0] * vIn.x + m[0][1] * vIn.y + m[0][2] * vIn.z + m[0][3]) * rw;
	vOut.y = (m[1][0] * vIn.x + m[1][1] * vIn.y + m[1][2] * vIn.z + m[1][3]) * rw;
	vOut.z = (m[2][0] * vIn.x + m[2][1] * vIn.y + m[2][2] * vIn.z + m[2][3]) * rw;
}

//-----------------------------------------------------------------------------
// Other random stuff
//-----------------------------------------------------------------------------
inline void VMatrix::Identity()
{
	m[0][0] = 1.0f; m[0][1] = 0.0f; m[0][2] = 0.0f; m[0][3] = 0.0f;
	m[1][0] = 0.0f; m[1][1] = 1.0f; m[1][2] = 0.0f; m[1][3] = 0.0f;
	m[2][0] = 0.0f; m[2][1] = 0.0f; m[2][2] = 1.0f; m[2][3] = 0.0f;
	m[3][0] = 0.0f; m[3][1] = 0.0f; m[3][2] = 0.0f; m[3][3] = 1.0f;
}


inline bool VMatrix::IsIdentity() const
{
	return
		m[0][0] == 1.0f && m[0][1] == 0.0f && m[0][2] == 0.0f && m[0][3] == 0.0f &&
		m[1][0] == 0.0f && m[1][1] == 1.0f && m[1][2] == 0.0f && m[1][3] == 0.0f &&
		m[2][0] == 0.0f && m[2][1] == 0.0f && m[2][2] == 1.0f && m[2][3] == 0.0f &&
		m[3][0] == 0.0f && m[3][1] == 0.0f && m[3][2] == 0.0f && m[3][3] == 1.0f;
}

inline Vector VMatrix::ApplyRotation(const Vector& vVec) const
{
	return VMul3x3(vVec);
}
```

`Private Esp/EspUI/VMatrix.hpp`:

```hpp
#pragma once

#include <limits>

#include "Vector.hpp"
#include "QAngle.hpp"

typedef unsigned char uint8_t;s

struct cplane_t22
{
	Vector normal;
	float dist;
	uint8_t type;   // for fast side tests
	uint8_t signbits;  // signx + (signy<<1) + (signz<<1)
	uint8_t pad[2];

};

class matrix3x4_t
{
public:
	matrix3x4_t() {}
	matrix3x4_t(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23)
	{
		m_flMatVal[0][0] = m00; m_flMatVal[0][1] = m01; m_flMatVal[0][2] = m02; m_flMatVal[0][3] = m03;
		m_flMatVal[1][0] = m10; m_flMatVal[1][1] = m11; m_flMatVal[1][2] = m12; m_flMatVal[1][3] = m13;
		m_flMatVal[2][0] = m20; m_flMatVal[2][1] = m21; m_flMatVal[2][2] = m22; m_flMatVal[2][3] = m23;
	}
	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	void Init(const Vector& xAxis, const Vector& yAxis, const Vector& zAxis, const Vector& vecOrigin)
	{
		m_flMatVal[0][0] = xAxis.x; m_flMatVal[0][1] = yAxis.x; m_flMatVal[0][2] = zAxis.x; m_flMatVal[0][3] = vecOrigin.x;
		m_flMatVal[1][0] = xAxis.y; m_flMatVal[1][1] = yAxis.y; m_flMatVal[1][2] = zAxis.y; m_flMatVal[1][3] = vecOrigin.y;
		m_flMatVal[2][0] = xAxis.z; m_flMatVal[2][1] = yAxis.z; m_flMatVal[2][2] = zAxis.z; m_flMatVal[2][3] = vecOrigin.z;
	}

	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	matrix3x4_t(const Vector& xAxis, const Vector& yAxis, const Vector& zAxis, const Vector& vecOrigin)
	{
		Init(xAxis, yAxis, zAxis, vecOrigin);
	}

	inline void SetOrigin(Vector const& p)
	{
		m_flMatVal[0][3] = p.x;
		m_flMatVal[1][3] = p.y;
		m_flMatVal[2][3] = p.z;
	}

	inline void Invalidate(void)
	{
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				m_flMatVal[i][j] = std::numeric_limits<float>::infinity();;
			}
		}
	}

	Vector GetXAxis()  const { return at(0); }
	Vector GetYAxis()  const { return at(1); }
	Vector GetZAxis()  const { return at(2); }
	Vector GetOrigin() const { return at(3); }

	Vector at(int i) const { return Vector{ m_flMatVal[0][i], m_flMatVal[1][i], m_flMatVal[2][i] }; }

	float* operator[](int i) { return m_flMatVal[i]; }
	const float* operator[](int i) const { return m_flMatVal[i]; }
	float* Base() { return &m_flMatVal[0][0]; }
	const float* Base() const { return &m_flMatVal[0][0]; }

	float m_flMatVal[3][4];
};
class VMatrix
{
public:

	VMatrix();
	VMatrix(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23,
		float m30, float m31, float m32, float m33
	);

	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	VMatrix(const Vector& forward, const Vector& left, const Vector& up);

	// Construct from a 3x4 matrix
	VMatrix(const matrix3x4_t& matrix3x4);

	// Set the values in the matrix.
	void  Init(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23,
		float m30, float m31, float m32, float m33
	);


	// Initialize from a 3x4
	void  Init(const matrix3x4_t& matrix3x4);

	// array access
	inline float* operator[](int i)
	{
		return m[i];
	}

	inline const float* operator[](int i) const
	{
		return m[i];
	}

	// Get a pointer to m[0][0]
	inline float* Base()
	{
		return &m[0][0];
	}

	inline const float* Base() const
	{
		return &m[0][0];
	}

	void  SetLeft(const Vector& vLeft);
	void  SetUp(const Vector& vUp);
	void  SetForward(const Vector& vForward);

	void  GetBasisVectors(Vector& vForward, Vector& vLeft, Vector& vUp) const;
	void  SetBasisVectors(const Vector& vForward, const Vector& vLeft, const Vector& vUp);

	// Get/Set the translation.
	Vector& GetTranslation(Vector& vTrans) const;
	void  SetTranslation(const Vector& vTrans);

	void  PreTranslate(const Vector& vTrans);
	void  PostTranslate(const Vector& vTrans);

	matrix3x4_t& As3x4();
	const matrix3x4_t& As3x4() const;
	void  CopyFrom3x4(const matrix3x4_t& m3x4);
	void  Set3x4(matrix3x4_t& matrix3x4) const;

	bool  operator==(const VMatrix& src) const;
	bool  operator!=(const VMatrix& src) const { return !(*this == src); }

	// Access the basis vectors.
	Vector  GetLeft() const;
	Vector  GetUp() const;
	Vector  GetForward() const;
	Vector  GetTranslation() const;


	// Matrix->vector operations.
public:
	// Multiply by a 3D vector (same as operator*).
	void  V3Mul(const Vector& vIn, Vector& vOut) const;

	// Multiply by a 4D vector.
	//void  V4Mul( const Vector4D &vIn, Vector4D &vOut ) const;

	// Applies the rotation (ignores translation in the matrix). (This just calls VMul3x3).
	Vector  ApplyRotation(const Vector& vVec) const;

	// Multiply by a vector (divides by w, assumes input w is 1).
	Vector  operator*(const Vector& vVec) const;

	// Multiply by the upper 3x3 part of the matrix (ie: only apply rotation).
	Vector  VMul3x3(const Vector& vVec) const;

	// Apply the inverse (transposed) rotation (only works on pure rotation matrix)
	Vector  VMul3x3Transpose(const Vector& vVec) const;

	// Multiply by the upper 3 rows.
	Vector  VMul4x3(const Vector& vVec) const;

	// Apply the inverse (transposed) transformation (only works on pure rotation/translation)
	Vector  VMul4x3Transpose(const Vector& vVec) const;


	// Matrix->plane operations.
	//public:
	// Transform the plane. The matrix can only contain translation and rotation.
	//void  TransformPlane( const VPlane &inPlane, VPlane &outPlane ) const;

	// Just calls TransformPlane and returns the result.
	//VPlane  operator*(const VPlane &thePlane) const;

	// Matrix->matrix operations.
public:

	VMatrix& operator=(const VMatrix& mOther);

	// Add two matrices.
	const VMatrix& operator+=(const VMatrix& other);

	// Add/Subtract two matrices.
	VMatrix  operator+(const VMatrix& other) const;
	VMatrix  operator-(const VMatrix& other) const;

	// Negation.
	VMatrix  operator-() const;

	// Return inverse matrix. Be careful because the results are undefined 
	// if the matrix doesn't have an inverse (ie: InverseGeneral returns false).
	VMatrix  operator~() const;

	// Matrix operations.
public:
	// Set to identity.
	void  Identity();
	bool  IsIdentity() const;
public:
	// The matrix.
	float  m[4][4];
};

inline void MatrixGetColumn(const matrix3x4_t& src, int nCol, Vector& pColumn)
{
	pColumn.x = src[0][nCol];
	pColumn.y = src[1][nCol];
	pColumn.z = src[2][nCol];
}

inline void MatrixPosition(const matrix3x4_t& matrix, Vector& position)
{
	MatrixGetColumn(matrix, 3, position);
}
```

`Private Esp/EspUI/ValorantESP.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;osdl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\Renderer">
      <UniqueIdentifier>{9ee1d221-a529-4a19-bb79-f5c60fad1654}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Hooks">
      <UniqueIdentifier>{ed2c23ab-87b7-4dbe-b55f-ca8c716e1cfb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Utils">
      <UniqueIdentifier>{75c253b9-e445-4ae0-a7b6-6672e8bf76a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Renderer">
      <UniqueIdentifier>{2198a584-1e61-46d5-84a8-7091ca2d0e8a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Main">
      <UniqueIdentifier>{d3e680c1-aab7-47c5-843c-b3b6ac05e95f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Utils">
      <UniqueIdentifier>{c2845eef-7951-42d2-a611-b7ef8bf27ff7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Features">
      <UniqueIdentifier>{c57d3527-0468-4551-86c6-b35ddf0950f6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Features">
      <UniqueIdentifier>{adf77382-966b-41cc-993e-9c96e42c5bb7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\SDK">
      <UniqueIdentifier>{fbabd697-f4c3-4836-a24d-d80492ee575e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\SDK">
      <UniqueIdentifier>{ae7b268b-c552-46bf-9de2-be12dd2297f4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Math">
      <UniqueIdentifier>{b3a39b7d-edd8-49c2-a980-26d98b3312bd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Nuklear">
      <UniqueIdentifier>{cae81aff-7380-44b6-b10f-e1c6572295a9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Nuklear">
      <UniqueIdentifier>{c5300230-5693-4b43-935d-2132407680a5}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="D3D11Renderer.cpp">
      <Filter>Source Files\Renderer</Filter>
    </ClCompile>
    <ClCompile Include="Menu.cpp">
      <Filter>Source Files\Renderer</Filter>
    </ClCompile>
    <ClCompile Include="Hook.cpp">
      <Filter>Source Files\Main</Filter>
    </ClCompile>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files\Main</Filter>
    </ClCompile>
    <ClCompile Include="Settings.cpp">
      <Filter>Source Files\Utils</Filter>
    </ClCompile>
    <ClCompile Include="Aimbot.cpp">
      <Filter>Source Files\Features</Filter>
    </ClCompile>
    <ClCompile Include="Visuals.cpp">
      <Filter>Source Files\Features</Filter>
    </ClCompile>
    <ClCompile Include="Init.cpp">
      <Filter>Source Files\Main</Filter>
    </ClCompile>
    <ClCompile Include="Entity.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="Engine.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="VMatrix.cpp">
      <Filter>Source Files\Math</Filter>
    </ClCompile>
    <ClCompile Include="Vector2D.cpp">
      <Filter>Source Files\Math</Filter>
    </ClCompile>
    <ClCompile Include="Vector4D.cpp">
      <Filter>Source Files\Math</Filter>
    </ClCompile>
    <ClCompile Include="Camera.cpp">
      <Filter>Source Files\SDK</Filter>
    </ClCompile>
    <ClCompile Include="nuklear_d3d11.cpp">
      <Filter>Source Files\Nuklear</Filter>
    </ClCompile>
    <ClCompile Include="nuklear.cpp">
      <Filter>Source Files\Nuklear</Filter>
    </ClCompile>
    <ClCompile Include="D3D11StateSaver.cpp">
      <Filter>Source Files\Renderer</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Hook.h">
      <Filter>Header Files\Hooks</Filter>
    </ClInclude>
    <ClInclude Include="D3D11Renderer.h">
      <Filter>Header Files\Renderer</Filter>
    </ClInclude>
    <ClInclude Include="Globals.h">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Helper.h">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Settings.h">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Features.h">
      <Filter>Header Files\Features</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="Entity.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="Engine.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="VMatrix.hpp">
      <Filter>Source Files\Math</Filter>
    </ClInclude>
    <ClInclude Include="QAngle.hpp">
      <Filter>Source Files\Math</Filter>
    </ClInclude>
    <ClInclude Include="Vector.hpp">
      <Filter>Source Files\Math</Filter>
    </ClInclude>
    <ClInclude Include="Vector2D.hpp">
      <Filter>Source Files\Math</Filter>
    </ClInclude>
    <ClInclude Include="Vector4D.hpp">
      <Filter>Source Files\Math</Filter>
    </ClInclude>
    <ClInclude Include="Camera.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="Menu.h">
      <Filter>Header Files\Nuklear</Filter>
    </ClInclude>
    <ClInclude Include="nuklear_d3d11.h">
      <Filter>Header Files\Nuklear</Filter>
    </ClInclude>
    <ClInclude Include="nuklear_d3d11_pixel_shader.h">
      <Filter>Header Files\Nuklear</Filter>
    </ClInclude>
    <ClInclude Include="nuklear_d3d11_vertex_shader.h">
      <Filter>Header Files\Nuklear</Filter>
    </ClInclude>
    <ClInclude Include="D3D11StateSaver.h">
      <Filter>Header Files\Renderer</Filter>
    </ClInclude>
    <ClInclude Include="D3D11Shader.h">
      <Filter>Header Files\Renderer</Filter>
    </ClInclude>
    <ClInclude Include="nuklear.h">
      <Filter>Header Files\Nuklear</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Private Esp/EspUI/Vanguard.cpp`:

```cpp
#include "Engine.h"
#include "Utils.h"
#include "Globals.h"
#include "Vector.hpp"
#include "Vector2D.hpp"s

constexpr float r2d = 57.2957795131f;
constexpr float d2r = 0.01745329251f;
#define M_PI		3.14159265358979323846f
#define M_RADPI		57.295779513082f
#define M_PI_F		((float)(M_PI))	// Shouldn't collide with anything.
#define RAD2DEG( x )  ( (float)(x) * (float)(180.f / M_PI_F) )
#define DEG2RAD( x )  ( (float)(x) * (float)(M_PI_F / 180.f) )

class SettingsManager
{
public:
	char pad_0000[72]; //0x0000
	float GPUVendor; //0x0048
	char pad_004C[188]; //0x004C
	int32_t GPUDedicatedMemoryMB; //0x0108
	char pad_010C[36]; //0x010C
	float GPUScore; //0x0130
	char pad_0134[76]; //0x0134
	int32_t SystemMemoryMB; //0x0180
	char pad_0184[36]; //0x0184
	float CPUScore; //0x01A8
	char pad_01AC[52]; //0x01AC
	wchar_t* GPUName; //0x01E0
	char pad_01E8[48]; //0x01E8
	int32_t InitialWindowPosX; //0x0218
	char pad_021C[36]; //0x021C
	int32_t InitialWindowPosY; //0x0240
	char pad_0244[92]; //0x0244
	int32_t ResolutionWidth2; //0x02A0
	char pad_02A4[52]; //0x02A4
	int32_t ResolutionHeight2; //0x02D8
	char pad_02DC[52]; //0x02DC
	float RefreshRate; //0x0310
	char pad_0314[44]; //0x0314
	int32_t WindowedMode0; //0x0340
	char pad_0344[4]; //0x0344
	int32_t WindowedMode; //0x0348
	char pad_034C[268]; //0x034C
	float DefaultFOV0; //0x0458
	char pad_045C[948]; //0x045C
	int32_t ResolutionWidth; //0x0810
	char pad_0814[52]; //0x0814
	int32_t ResolutionHeight; //0x0848
	char pad_084C[52]; //0x084C
	float RefreshRate2; //0x0880
	char pad_0884[164]; //0x0884
	int32_t VSync; //0x0928
	char pad_092C[156]; //0x092C
	float DefaultFOV; //0x09C8
	char pad_09CC[2076]; //0x09CC
	float Brightness; //0x11E8
	char pad_11EC[1340]; //0x11EC
	char* PlayerName; //0x1728
	char* PlayerName2; //0x1730
	char pad_1738[6408]; //0x1738
}; //Size: 0x3040

void C_Engine::SetReolution()
{
	auto pSettings = reinterpret_cast<SettingsManager*>(g_pOffSettings);
	Globals::g_iWindowWidth = pSettings->ResolutionWidth; Globals::g_iWindowHeight = pSettings->ResolutionHeight;
}

uint16_t C_Engine::GetMaxEntitys()
{
	return *(uint16_t*)(g_pOffGame + 0x1D0); // 2bytes
}

Array<C_BaseEntity*> C_Engine::GetEntities()
{
	return *(Array<C_BaseEntity*>*)(g_pOffGame + 0x1C8);
}

C_BaseEntity* C_Engine::GetLocal()
{
	return Utils::ReadPtr<C_BaseEntity*>({ g_pOffProfile, 0x68, 0x0, 0x28 }, false);
}

C_Camera* C_Engine::GetCamera()
{
	return Utils::ReadPtr<C_Camera*>({ g_pOffCamera, 0xE0, 0x1D8, 0x8 }, true); // deref first addy
}

bool C_Engine::IsInGame()
{
	return Utils::Read<bool>(g_pOffStatus + 0x374);
}

bool C_Engine::WorldToScreen(const Vector& origin, Vector2D& screen)
{
	g_pCamera = GetCamera();
	if (!g_pCamera)
		return false;

	Vector temp = origin - g_pCamera->GetViewTranslation();
	float x = temp.Dot(g_pCamera->GetViewRight());
	float y = temp.Dot(g_pCamera->GetViewUp());
	float z = temp.Dot(g_pCamera->GetViewForward() * -1);
	screen.x = (Globals::g_iWindowWidth / 2) * (1 + x / g_pCamera->GetViewFovX() / z);
	screen.y = (Globals::g_iWindowHeight / 2) * (1 - y / g_pCamera->GetViewFovY() / z);

	return z >= 1.0f;
}

float C_Engine::W2SDistance(Vector position)
{
	if (!g_pCamera)
		return -1;

	Vector2D out;
	WorldToScreen(position, out);
	return (fabs(out.x - (Globals::g_iWindowWidth / 2)) + fabs(out.y - (Globals::g_iWindowHeight / 2)));
}

Vector C_Engine::CalcAngle(Vector enemypos, Vector camerapos)
{
	float r2d = 57.2957795131f;

	Vector dir = enemypos - camerapos;

	float x = asin(dir.z / dir.Length()) * r2d;
	float z = atan(dir.y / dir.x) * r2d;

	if (dir.x >= 0.f) z += 180.f;
	if (x > 180.0f) x -= 360.f;
	else if (x < -180.0f) x += 360.f;

	return Vector(x, 0.f, z + 90.f);
}
```

`Private Esp/EspUI/Vector.hpp`:

```hpp
#pragma once

#include <sstream>
#include "Vector4D.hpp"

class Vector
{s
public:
	Vector(void)
	{
		Invalidate();
	}
	Vector(float X, float Y, float Z)
	{
		x = X;
		y = Y;
		z = Z;
	}
	Vector(const float* clr)
	{
		x = clr[0];
		y = clr[1];
		z = clr[2];
	}

	void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f)
	{
		x = ix; y = iy; z = iz;
	}
	bool IsValid() const
	{
		return std::isfinite(x) && std::isfinite(y) && std::isfinite(z);
	}
	void Invalidate()
	{
		x = y = z = std::numeric_limits<float>::infinity();
	}

	float& operator[](int i)
	{
		return ((float*)this)[i];
	}
	float operator[](int i) const
	{
		return ((float*)this)[i];
	}

	void Zero()
	{
		x = y = z = 0.0f;
	}

	bool operator==(const Vector& src) const
	{
		return (src.x == x) && (src.y == y) && (src.z == z);
	}
	bool operator!=(const Vector& src) const
	{
		return (src.x != x) || (src.y != y) || (src.z != z);
	}
	inline float Distance(const Vector& vector)
	{
		return sqrt(
			(x - vector.x) * (x - vector.x) +
			(y - vector.y) * (y - vector.y) +
			(z - vector.z) * (z - vector.z));
	}
	Vector& operator+=(const Vector& v)
	{
		x += v.x; y += v.y; z += v.z;
		return *this;
	}
	Vector& operator-=(const Vector& v)
	{
		x -= v.x; y -= v.y; z -= v.z;
		return *this;
	}
	Vector& operator*=(float fl)
	{
		x *= fl;
		y *= fl;
		z *= fl;
		return *this;
	}
	Vector& operator*=(const Vector& v)
	{
		x *= v.x;
		y *= v.y;
		z *= v.z;
		return *this;
	}
	Vector& operator/=(const Vector& v)
	{
		x /= v.x;
		y /= v.y;
		z /= v.z;
		return *this;
	}
	Vector& operator+=(float fl)
	{
		x += fl;
		y += fl;
		z += fl;
		return *this;
	}
	Vector& operator/=(float fl)
	{
		x /= fl;
		y /= fl;
		z /= fl;
		return *this;
	}
	Vector& operator-=(float fl)
	{
		x -= fl;
		y -= fl;
		z -= fl;
		return *this;
	}

	void Clamp()
	{
		if (this->x > 180.f)
			this->x -= 360.f;

		else if (this->x < -180.f)
			this->x += 360.f;

		if (this->z > 180.f)
			this->z -= 360.f;

		else if (this->z < -180.f)
			this->z += 360.f;

		if (this->x < -89.f)
			this->x = -89.f;

		if (this->x > 89.f)
			this->x = 89.f;

		while (this->z < -180.0f)
			this->z += 360.0f;

		while (this->z > 180.0f)
			this->z -= 360.0f;
	}
	Vector4D ToVector4(float w)
	{
		return Vector4D(this->x, this->y, this->z, w);
	}

	void NormalizeInPlace()
	{
		*this = Normalized();
	}
	Vector Normalized() const
	{
		Vector res = *this;
		float l = res.Length();
		if (l != 0.0f) {
			res /= l;
		}
		else {
			res.x = res.y = res.z = 0.0f;
		}
		return res;
	}

	float DistTo(const Vector& vOther) const
	{
		Vector delta;

		delta.x = x - vOther.x;
		delta.y = y - vOther.y;
		delta.z = z - vOther.z;

		return delta.Length();
	}
	float DistToSqr(const Vector& vOther) const
	{
		Vector delta;

		delta.x = x - vOther.x;
		delta.y = y - vOther.y;
		delta.z = z - vOther.z;

		return delta.LengthSqr();
	}
	float Dot(const Vector& vOther) const
	{
		return (x * vOther.x + y * vOther.y + z * vOther.z);
	}
	float Length() const
	{
		return sqrt(x * x + y * y + z * z);
	}
	float LengthSqr(void) const
	{
		return (x * x + y * y + z * z);
	}
	float Length2D() const
	{
		return sqrt(x * x + y * y);
	}

	Vector& operator=(const Vector& vOther)
	{
		x = vOther.x; y = vOther.y; z = vOther.z;
		return *this;
	}

	Vector operator-(void) const
	{
		return Vector(-x, -y, -z);
	}
	Vector operator+(const Vector& v) const
	{
		return Vector(x + v.x, y + v.y, z + v.z);
	}
	Vector operator-(const Vector& v) const
	{
		return Vector(x - v.x, y - v.y, z - v.z);
	}
	Vector operator*(float fl) const
	{
		return Vector(x * fl, y * fl, z * fl);
	}
	Vector operator*(const Vector& v) const
	{
		return Vector(x * v.x, y * v.y, z * v.z);
	}
	Vector operator/(float fl) const
	{
		return Vector(x / fl, y / fl, z / fl);
	}
	Vector operator/(const Vector& v) const
	{
		return Vector(x / v.x, y / v.y, z / v.z);
	}
	inline Vector Normalize()
	{
		Vector vector;
		float length = this->Length();

		if (length != 0) {
			vector.x = x / length;
			vector.y = y / length;
			vector.z = z / length;
		}
		else
			vector.x = vector.y = 0.0f; vector.z = 1.0f;

		return vector;
	}
	inline float Normalizes()
	{
		Vector res = *this;
		float l = res.Length();
		if (l != 0.0f)
		{
			res /= l;
		}
		else
		{
			res.x = res.y = res.z = 0.0f;
		}
		return l;
	}
	float x, y, z;
};

inline Vector operator*(float lhs, const Vector& rhs)
{
	return rhs * lhs;
}
inline Vector operator/(float lhs, const Vector& rhs)
{
	return rhs / lhs;
}

class __declspec(align(16)) VectorAligned : public Vector
{
public:
	inline VectorAligned(void) {};
	inline VectorAligned(float X, float Y, float Z)
	{
		Init(X, Y, Z);
	}

public:
	explicit VectorAligned(const Vector& vOther)
	{
		Init(vOther.x, vOther.y, vOther.z);
	}

	VectorAligned& operator=(const Vector& vOther)
	{
		Init(vOther.x, vOther.y, vOther.z);
		return *this;
	}

	VectorAligned& operator=(const VectorAligned& vOther)
	{
		Init(vOther.x, vOther.y, vOther.z);
		return *this;
	}

	float w;
};
```

`Private Esp/EspUI/Vector2D.cpp`:

```cpp
#include <cmath>

#include "Vector2D.hpp"
#include <stdlib.h>

Vector2D::Vector2D(void)
{
}

Vector2D::Vector2D(vec_t X, vec_t Y)
{
	x = X; y = Y;
}

Vector2D::Vector2D(vec_t* clr)
{
	x = clr[0]; y = clr[1];
}

//-----------------------------------------------------------------------------
// initializations
//-----------------------------------------------------------------------------

void Vector2D::Init(vec_t ix, vec_t iy)
{
	x = ix; y = iy;
}

void Vector2D::Random(float minVal, float maxVal)
{
	x = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	y = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
}

void Vector2DClear(Vector2D& a)
{
	a.x = a.y = 0.0f;
}

//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------

Vector2D& Vector2D::operator=(const Vector2D& vOther)
{
	x = vOther.x; y = vOther.y;
	return *this;
}

//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------

vec_t& Vector2D::operator[](int i)
{
	return ((vec_t*)this)[i];
}

vec_t Vector2D::operator[](int i) const
{
	return ((vec_t*)this)[i];
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------

vec_t* Vector2D::Base()
{
	return (vec_t*)this;
}

vec_t const* Vector2D::Base() const
{
	return (vec_t const*)this;
}

//-----------------------------------------------------------------------------
// IsValid?
//-----------------------------------------------------------------------------

bool Vector2D::IsValid() const
{
	return !isinf(x) && !isinf(y);
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------

bool Vector2D::operator==(const Vector2D& src) const
{
	return (src.x == x) && (src.y == y);
}

bool Vector2D::operator!=(const Vector2D& src) const
{
	return (src.x != x) || (src.y != y);
}


//-----------------------------------------------------------------------------
// Copy
//-----------------------------------------------------------------------------

void Vector2DCopy(const Vector2D& src, Vector2D& dst)
{
	dst.x = src.x;
	dst.y = src.y;
}

void Vector2D::CopyToArray(float* rgfl) const
{
	rgfl[0] = x; rgfl[1] = y;
}

//-----------------------------------------------------------------------------
// standard Math operations
//-----------------------------------------------------------------------------

void Vector2D::Negate()
{
	x = -x; y = -y;
}

void Vector2DAdd(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	c.x = a.x + b.x;
	c.y = a.y + b.y;
}

void Vector2DSubtract(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	c.x = a.x - b.x;
	c.y = a.y - b.y;
}

void Vector2DMultiply(const Vector2D& a, vec_t b, Vector2D& c)
{
	c.x = a.x * b;
	c.y = a.y * b;
}

void Vector2DMultiply(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	c.x = a.x * b.x;
	c.y = a.y * b.y;
}


void Vector2DDivide(const Vector2D& a, vec_t b, Vector2D& c)
{
	vec_t oob = 1.0f / b;
	c.x = a.x * oob;
	c.y = a.y * oob;
}

void Vector2DDivide(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	c.x = a.x / b.x;
	c.y = a.y / b.y;
}

void Vector2DMA(const Vector2D& start, float s, const Vector2D& dir, Vector2D& result)
{
	result.x = start.x + s * dir.x;
	result.y = start.y + s * dir.y;
}

// FIXME: Remove
// For backwards compatability
void Vector2D::MulAdd(const Vector2D& a, const Vector2D& b, float scalar)
{
	x = a.x + b.x * scalar;
	y = a.y + b.y * scalar;
}

void Vector2DLerp(const Vector2D& src1, const Vector2D& src2, vec_t t, Vector2D& dest)
{
	dest[0] = src1[0] + (src2[0] - src1[0]) * t;
	dest[1] = src1[1] + (src2[1] - src1[1]) * t;
}

//-----------------------------------------------------------------------------
// dot, cross
//-----------------------------------------------------------------------------
vec_t DotProduct2D(const Vector2D& a, const Vector2D& b)
{
	return(a.x * b.x + a.y * b.y);
}

// for backwards compatability
vec_t Vector2D::Dot(const Vector2D& vOther) const
{
	return DotProduct2D(*this, vOther);
}

vec_t Vector2DNormalize(Vector2D& v)
{
	vec_t l = v.Length();
	if (l != 0.0f) {
		v /= l;
	}
	else {
		v.x = v.y = 0.0f;
	}
	return l;
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------
vec_t Vector2DLength(const Vector2D& v)
{
	return (vec_t)sqrt(v.x * v.x + v.y * v.y);
}

vec_t Vector2D::NormalizeInPlace()
{
	return Vector2DNormalize(*this);
}

bool Vector2D::IsLengthGreaterThan(float val) const
{
	return LengthSqr() > val* val;
}

bool Vector2D::IsLengthLessThan(float val) const
{
	return LengthSqr() < val * val;
}

vec_t Vector2D::Length(void) const
{
	return Vector2DLength(*this);
}


void Vector2DMin(const Vector2D& a, const Vector2D& b, Vector2D& result)
{
	result.x = (a.x < b.x) ? a.x : b.x;
	result.y = (a.y < b.y) ? a.y : b.y;
}


void Vector2DMax(const Vector2D& a, const Vector2D& b, Vector2D& result)
{
	result.x = (a.x > b.x) ? a.x : b.x;
	result.y = (a.y > b.y) ? a.y : b.y;
}

//-----------------------------------------------------------------------------
// Computes the closest point to vecTarget no farther than flMaxDist from vecStart
//-----------------------------------------------------------------------------
void ComputeClosestPoint2D(const Vector2D& vecStart, float flMaxDist, const Vector2D& vecTarget, Vector2D* pResult)
{
	Vector2D vecDelta;
	Vector2DSubtract(vecTarget, vecStart, vecDelta);
	float flDistSqr = vecDelta.LengthSqr();
	if (flDistSqr <= flMaxDist * flMaxDist) {
		*pResult = vecTarget;
	}
	else {
		vecDelta /= sqrt(flDistSqr);
		Vector2DMA(vecStart, flMaxDist, vecDelta, *pResult);
	}
}

//-----------------------------------------------------------------------------
// Returns a Vector2D with the min or max in X, Y, and Z.
//-----------------------------------------------------------------------------

Vector2D Vector2D::Min(const Vector2D& vOther) const
{
	return Vector2D(x < vOther.x ? x : vOther.x, y < vOther.y ? y : vOther.y);
}

Vector2D Vector2D::Max(const Vector2D& vOther) const
{
	return Vector2D(x > vOther.x ? x : vOther.x, y > vOther.y ? y : vOther.y);
}


//-----------------------------------------------------------------------------
// arithmetic operations
//-----------------------------------------------------------------------------

Vector2D Vector2D::operator-(void) const
{
	return Vector2D(-x, -y);
}

Vector2D Vector2D::operator+(const Vector2D& v) const
{
	Vector2D res;
	Vector2DAdd(*this, v, res);
	return res;
}

Vector2D Vector2D::operator-(const Vector2D& v) const
{
	Vector2D res;
	Vector2DSubtract(*this, v, res);
	return res;
}

Vector2D Vector2D::operator*(float fl) const
{
	Vector2D res;
	Vector2DMultiply(*this, fl, res);
	return res;
}

Vector2D Vector2D::operator*(const Vector2D& v) const
{
	Vector2D res;
	Vector2DMultiply(*this, v, res);
	return res;
}

Vector2D Vector2D::operator/(float fl) const
{
	Vector2D res;
	Vector2DDivide(*this, fl, res);
	return res;
}

Vector2D Vector2D::operator/(const Vector2D& v) const
{
	Vector2D res;
	Vector2DDivide(*this, v, res);
	return res;
}

Vector2D operator*(float fl, const Vector2D& v)
{
	return v * fl;
}
```

`Private Esp/EspUI/Vector2D.hpp`:

```hpp
#pragma once
s
typedef float vec_t;
// 2D Vector
class Vector2D
{
public:
	// Members
	vec_t x, y;

	// Construction/destruction:
	Vector2D(void);
	Vector2D(vec_t X, vec_t Y);
	Vector2D(vec_t* clr);

	Vector2D(const Vector2D& vOther)
	{
		x = vOther.x; y = vOther.y;
	}

	// Initialization
	void Init(vec_t ix = 0.0f, vec_t iy = 0.0f);
	// TODO (Ilya): Should there be an init that takes a single float for consistency?

	// Got any nasty NAN's?
	bool IsValid() const;
	void Invalidate();

	// array access...
	vec_t operator[](int i) const;
	vec_t& operator[](int i);

	// Base address...
	vec_t* Base();
	vec_t const* Base() const;

	// Initialization methods
	void Random(vec_t minVal, vec_t maxVal);
	void Zero(); ///< zero out a vector

				 // equality
	bool operator==(const Vector2D& v) const;
	bool operator!=(const Vector2D& v) const;

	// arithmetic operations
	Vector2D& operator+=(const Vector2D& v)
	{
		x += v.x; y += v.y;
		return *this;
	}

	Vector2D& operator-=(const Vector2D& v)
	{
		x -= v.x; y -= v.y;
		return *this;
	}

	Vector2D& operator*=(float fl)
	{
		x *= fl;
		y *= fl;
		return *this;
	}

	Vector2D& operator*=(const Vector2D& v)
	{
		x *= v.x;
		y *= v.y;
		return *this;
	}

	Vector2D& operator/=(const Vector2D& v)
	{
		x /= v.x;
		y /= v.y;
		return *this;
	}

	// this ought to be an opcode.
	Vector2D& operator+=(float fl)
	{
		x += fl;
		y += fl;
		return *this;
	}

	// this ought to be an opcode.
	Vector2D& operator/=(float fl)
	{
		x /= fl;
		y /= fl;
		return *this;
	}
	Vector2D& operator-=(float fl)
	{
		x -= fl;
		y -= fl;
		return *this;
	}

	// negate the vector components
	void Negate();

	// Get the vector's magnitude.
	vec_t Length() const;

	// Get the vector's magnitude squared.
	vec_t LengthSqr(void) const
	{
		return (x * x + y * y);
	}

	// return true if this vector is (0,0,0) within tolerance
	bool IsZero(float tolerance = 0.01f) const
	{
		return (x > -tolerance && x < tolerance &&
			y > -tolerance && y < tolerance);
	}

	vec_t NormalizeInPlace();
	Vector2D Normalized() const;
	bool IsLengthGreaterThan(float val) const;
	bool IsLengthLessThan(float val) const;

	// check if a vector is within the box defined by two other vectors
	bool WithinAABox(Vector2D const& boxmin, Vector2D const& boxmax);

	// Get the distance from this vector to the other one.
	vec_t DistTo(const Vector2D& vOther) const;

	// Get the distance from this vector to the other one squared.
	// NJS: note, VC wasn't inlining it correctly in several deeply nested inlines due to being an 'out of line' .  
	// may be able to tidy this up after switching to VC7
	vec_t DistToSqr(const Vector2D& vOther) const
	{
		Vector2D delta;

		delta.x = x - vOther.x;
		delta.y = y - vOther.y;

		return delta.LengthSqr();
	}

	// Copy
	void CopyToArray(float* rgfl) const;

	// Multiply, add, and assign to this (ie: *this = a + b * scalar). This
	// is about 12% faster than the actual vector equation (because it's done per-component
	// rather than per-vector).
	void MulAdd(const Vector2D& a, const Vector2D& b, float scalar);

	// Dot product.
	vec_t Dot(const Vector2D& vOther) const;

	// assignment
	Vector2D& operator=(const Vector2D& vOther);

	// 2d
	vec_t Length2D(void) const;
	vec_t Length2DSqr(void) const;

	/// Get the component of this vector parallel to some other given vector
	Vector2D  ProjectOnto(const Vector2D& onto);

	// copy constructors
	// Vector2D(const Vector2D &vOther);

	// arithmetic operations
	Vector2D operator-(void) const;

	Vector2D operator+(const Vector2D& v) const;
	Vector2D operator-(const Vector2D& v) const;
	Vector2D operator*(const Vector2D& v) const;
	Vector2D operator/(const Vector2D& v) const;
	Vector2D operator*(float fl) const;
	Vector2D operator/(float fl) const;

	// Cross product between two vectors.
	Vector2D Cross(const Vector2D& vOther) const;

	// Returns a vector with the min or max in X, Y, and Z.
	Vector2D Min(const Vector2D& vOther) const;
	Vector2D Max(const Vector2D& vOther) const;
};
```

`Private Esp/EspUI/Vector4D.cpp`:

```cpp
#include "Vector4D.hpp"

#include <cmath>s
#include <limits>

void VectorCopy(const Vector4D& src, Vector4D& dst)
{
	dst.x = src.x;
	dst.y = src.y;
	dst.z = src.z;
	dst.w = src.w;
}
void VectorLerp(const Vector4D& src1, const Vector4D& src2, vec_t t, Vector4D& dest)
{
	dest.x = src1.x + (src2.x - src1.x) * t;
	dest.y = src1.y + (src2.y - src1.y) * t;
	dest.z = src1.z + (src2.z - src1.z) * t;
	dest.w = src1.w + (src2.w - src1.w) * t;
}
float VectorLength(const Vector4D& v)
{
	return sqrt(v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w);
}

vec_t NormalizeVector(Vector4D& v)
{
	vec_t l = v.Length();
	if (l != 0.0f) {
		v /= l;
	}
	else {
		v.x = v.y = v.z = v.w = 0.0f;
	}
	return l;
}

Vector4D::Vector4D(void)
{
	Invalidate();
}
Vector4D::Vector4D(vec_t X, vec_t Y, vec_t Z, vec_t W)
{
	x = X;
	y = Y;
	z = Z;
	w = W;
}
Vector4D::Vector4D(vec_t* clr)
{
	x = clr[0];
	y = clr[1];
	z = clr[2];
	w = clr[3];
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------

void Vector4D::Init(vec_t ix, vec_t iy, vec_t iz, vec_t iw)
{
	x = ix; y = iy; z = iz; w = iw;
}

void Vector4D::Random(vec_t minVal, vec_t maxVal)
{
	x = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	y = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	z = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	w = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
}

// This should really be a single opcode on the PowerPC (move r0 onto the vec reg)
void Vector4D::Zero()
{
	x = y = z = w = 0.0f;
}

//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------

Vector4D& Vector4D::operator=(const Vector4D& vOther)
{
	x = vOther.x; y = vOther.y; z = vOther.z; w = vOther.w;
	return *this;
}


//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------
vec_t& Vector4D::operator[](int i)
{
	return ((vec_t*)this)[i];
}

vec_t Vector4D::operator[](int i) const
{
	return ((vec_t*)this)[i];
}


//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------
vec_t* Vector4D::Base()
{
	return (vec_t*)this;
}

vec_t const* Vector4D::Base() const
{
	return (vec_t const*)this;
}

//-----------------------------------------------------------------------------
// IsValid?
//-----------------------------------------------------------------------------

bool Vector4D::IsValid() const
{
	return !isinf(x) && !isinf(y) && !isinf(z) && !isinf(w);
}

//-----------------------------------------------------------------------------
// Invalidate
//-----------------------------------------------------------------------------

void Vector4D::Invalidate()
{
	//#ifdef _DEBUG
	//#ifdef VECTOR_PARANOIA
	x = y = z = w = std::numeric_limits<float>::infinity();
	//#endif
	//#endif
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------

bool Vector4D::operator==(const Vector4D& src) const
{
	return (src.x == x) && (src.y == y) && (src.z == z) && (src.w == w);
}

bool Vector4D::operator!=(const Vector4D& src) const
{
	return (src.x != x) || (src.y != y) || (src.z != z) || (src.w != w);
}


//-----------------------------------------------------------------------------
// Copy
//-----------------------------------------------------------------------------
void Vector4D::CopyToArray(float* rgfl) const
{
	rgfl[0] = x, rgfl[1] = y, rgfl[2] = z; rgfl[3] = w;
}

//-----------------------------------------------------------------------------
// standard Math operations
//-----------------------------------------------------------------------------
// #pragma message("TODO: these should be SSE")

void Vector4D::Negate()
{
	x = -x; y = -y; z = -z; w = -w;
}

// Get the component of this vector parallel to some other given vector
Vector4D Vector4D::ProjectOnto(const Vector4D& onto)
{
	return onto * (this->Dot(onto) / (onto.LengthSqr()));
}

// FIXME: Remove
// For backwards compatability
void Vector4D::MulAdd(const Vector4D& a, const Vector4D& b, float scalar)
{
	x = a.x + b.x * scalar;
	y = a.y + b.y * scalar;
	z = a.z + b.z * scalar;
	w = a.w + b.w * scalar;
}

Vector4D VectorLerp(const Vector4D& src1, const Vector4D& src2, vec_t t)
{
	Vector4D result;
	VectorLerp(src1, src2, t, result);
	return result;
}

vec_t Vector4D::Dot(const Vector4D& b) const
{
	return (x * b.x + y * b.y + z * b.z + w * b.w);
}
void VectorClear(Vector4D& a)
{
	a.x = a.y = a.z = a.w = 0.0f;
}

vec_t Vector4D::Length(void) const
{
	return sqrt(x * x + y * y + z * z + w * w);
}

// check a point against a box
bool Vector4D::WithinAABox(Vector4D const& boxmin, Vector4D const& boxmax)
{
	return (
		(x >= boxmin.x) && (x <= boxmax.x) &&
		(y >= boxmin.y) && (y <= boxmax.y) &&
		(z >= boxmin.z) && (z <= boxmax.z) &&
		(w >= boxmin.w) && (w <= boxmax.w)
		);
}

//-----------------------------------------------------------------------------
// Get the distance from this vector to the other one 
//-----------------------------------------------------------------------------
vec_t Vector4D::DistTo(const Vector4D& vOther) const
{
	Vector4D delta;
	delta = *this - vOther;
	return delta.Length();
}

//-----------------------------------------------------------------------------
// Returns a vector with the min or max in X, Y, and Z.
//-----------------------------------------------------------------------------
Vector4D Vector4D::Min(const Vector4D& vOther) const
{
	return Vector4D(x < vOther.x ? x : vOther.x,
		y < vOther.y ? y : vOther.y,
		z < vOther.z ? z : vOther.z,
		w < vOther.w ? w : vOther.w);
}

Vector4D Vector4D::Max(const Vector4D& vOther) const
{
	return Vector4D(x > vOther.x ? x : vOther.x,
		y > vOther.y ? y : vOther.y,
		z > vOther.z ? z : vOther.z,
		w > vOther.w ? w : vOther.w);
}


//-----------------------------------------------------------------------------
// arithmetic operations
//-----------------------------------------------------------------------------

Vector4D Vector4D::operator-(void) const
{
	return Vector4D(-x, -y, -z, -w);
}

Vector4D Vector4D::operator+(const Vector4D& v) const
{
	return Vector4D(x + v.x, y + v.y, z + v.z, w + v.w);
}

Vector4D Vector4D::operator-(const Vector4D& v) const
{
	return Vector4D(x - v.x, y - v.y, z - v.z, w - v.w);
}

Vector4D Vector4D::operator*(float fl) const
{
	return Vector4D(x * fl, y * fl, z * fl, w * fl);
}

Vector4D Vector4D::operator*(const Vector4D& v) const
{
	return Vector4D(x * v.x, y * v.y, z * v.z, w * v.w);
}

Vector4D Vector4D::operator/(float fl) const
{
	return Vector4D(x / fl, y / fl, z / fl, w / fl);
}

Vector4D Vector4D::operator/(const Vector4D& v) const
{
	return Vector4D(x / v.x, y / v.y, z / v.z, w / v.w);
}

Vector4D operator*(float fl, const Vector4D& v)
{
	return v * fl;
}

```

`Private Esp/EspUI/Vector4D.hpp`:

```hpp
#pragma once

typedef float vec_t;
// 3D Vector4Ds
class Vector4D
{
public:
	// Members
	vec_t x, y, z, w;

	// Construction/destruction:
	Vector4D(void);
	Vector4D(vec_t X, vec_t Y, vec_t Z, vec_t W);
	Vector4D(vec_t* clr);

	// Initialization
	void Init(vec_t ix = 0.0f, vec_t iy = 0.0f, vec_t iz = 0.0f, vec_t iw = 0.0f);
	// TODO (Ilya): Should there be an init that takes a single float for consistency?

	// Got any nasty NAN's?
	bool IsValid() const;
	void Invalidate();

	// array access...
	vec_t operator[](int i) const;
	vec_t& operator[](int i);

	// Base address...
	vec_t* Base();
	vec_t const* Base() const;

	// Initialization methods
	void Random(vec_t minVal, vec_t maxVal);
	void Zero(); ///< zero out a vector

				 // equality
	bool operator==(const Vector4D& v) const;
	bool operator!=(const Vector4D& v) const;

	// arithmetic operations
	Vector4D& operator+=(const Vector4D& v)
	{
		x += v.x; y += v.y; z += v.z; w += v.w;
		return *this;
	}

	Vector4D& operator-=(const Vector4D& v)
	{
		x -= v.x; y -= v.y; z -= v.z; w -= v.w;
		return *this;
	}

	Vector4D& operator*=(float fl)
	{
		x *= fl;
		y *= fl;
		z *= fl;
		w *= fl;
		return *this;
	}

	Vector4D& operator*=(const Vector4D& v)
	{
		x *= v.x;
		y *= v.y;
		z *= v.z;
		w *= v.w;
		return *this;
	}

	Vector4D& operator/=(const Vector4D& v)
	{
		x /= v.x;
		y /= v.y;
		z /= v.z;
		w /= v.w;
		return *this;
	}

	// this ought to be an opcode.
	Vector4D& operator+=(float fl)
	{
		x += fl;
		y += fl;
		z += fl;
		w += fl;
		return *this;
	}

	// this ought to be an opcode.
	Vector4D& operator/=(float fl)
	{
		x /= fl;
		y /= fl;
		z /= fl;
		w /= fl;
		return *this;
	}
	Vector4D& operator-=(float fl)
	{
		x -= fl;
		y -= fl;
		z -= fl;
		w -= fl;
		return *this;
	}

	// negate the vector components
	void Negate();

	// Get the vector's magnitude.
	vec_t Length() const;

	// Get the vector's magnitude squared.
	vec_t LengthSqr(void) const
	{
		return (x * x + y * y + z * z);
	}

	// return true if this vector is (0,0,0) within tolerance
	bool IsZero(float tolerance = 0.01f) const
	{
		return (x > -tolerance && x < tolerance &&
			y > -tolerance && y < tolerance &&
			z > -tolerance && z < tolerance &&
			w > -tolerance && w < tolerance);
	}

	vec_t NormalizeInPlace();
	Vector4D Normalized() const;
	bool IsLengthGreaterThan(float val) const;
	bool IsLengthLessThan(float val) const;

	// check if a vector is within the box defined by two other vectors
	bool WithinAABox(Vector4D const& boxmin, Vector4D const& boxmax);

	// Get the distance from this vector to the other one.
	vec_t DistTo(const Vector4D& vOther) const;

	// Get the distance from this vector to the other one squared.
	// NJS: note, VC wasn't inlining it correctly in several deeply nested inlines due to being an 'out of line' .  
	// may be able to tidy this up after switching to VC7
	vec_t DistToSqr(const Vector4D& vOther) const
	{
		Vector4D delta;

		delta.x = x - vOther.x;
		delta.y = y - vOther.y;
		delta.z = z - vOther.z;
		delta.w = w - vOther.w;

		return delta.LengthSqr();
	}

	// Copy
	void CopyToArray(float* rgfl) const;

	// Multiply, add, and assign to this (ie: *this = a + b * scalar). This
	// is about 12% faster than the actual vector equation (because it's done per-component
	// rather than per-vector).
	void MulAdd(const Vector4D& a, const Vector4D& b, float scalar);

	// Dot product.
	vec_t Dot(const Vector4D& vOther) const;

	// assignment
	Vector4D& operator=(const Vector4D& vOther);

	// 2d
	vec_t Length2D(void) const;
	vec_t Length2DSqr(void) const;

	/// Get the component of this vector parallel to some other given vector
	Vector4D  ProjectOnto(const Vector4D& onto);

	// copy constructors
	// Vector4D(const Vector4D &vOther);

	// arithmetic operations
	Vector4D operator-(void) const;

	Vector4D operator+(const Vector4D& v) const;
	Vector4D operator-(const Vector4D& v) const;
	Vector4D operator*(const Vector4D& v) const;
	Vector4D operator/(const Vector4D& v) const;
	Vector4D operator*(float fl) const;
	Vector4D operator/(float fl) const;

	// Returns a vector with the min or max in X, Y, and Z.
	Vector4D Min(const Vector4D& vOther) const;
	Vector4D Max(const Vector4D& vOther) const;
};
```

`Private Esp/EspUI/Visuals.cpp`:

```cpp
#include "Utils.h"
#include "Features.h"
#include "Globals.h"
#include "Settings.h"
s
void Features::RenderESP(D3D11Renderer* Render, nk_context* g_pNkContext)
{
	Array<C_BaseEntity*> Entitylist = g_pEngine->GetEntities();
	for (uint32_t i = 0; i < g_pEngine->GetMaxEntitys(); i++)
	{
		auto pEntity = Entitylist[i];

		if (!pEntity)
			continue;

		if (pEntity == g_pLocalEntity)
			continue;

		if (!pEntity->IsAlive())
			continue;

		if (pEntity->GetTeamNumber() == g_pLocalEntity->GetTeamNumber())
			continue;

		Vector2D vecScreenOrgin, vecScreenHead;
		Vector orgin = pEntity->GetFeet(), head = pEntity->GetHead();
		if (g_pEngine->WorldToScreen(orgin, vecScreenOrgin) && g_pEngine->WorldToScreen(head, vecScreenHead))
		{
			int iMiddle = (vecScreenOrgin.y - vecScreenHead.y);
			int iWidth = iMiddle / 4;
			
			Render->DrawBox(vecScreenHead.x - iWidth, vecScreenHead.y, iWidth * 2, iMiddle, Color{255, 255, 255, 0});
			Render->DrawBox(vecScreenHead.x - iWidth - 1, vecScreenHead.y - 1, (iWidth * 2) + 2, iMiddle + 2, Color{255, 0, 0, 0});
			Render->DrawHealthBar(vecScreenHead.x - iWidth - 6, vecScreenHead.y, iWidth / 5.5f, iMiddle, pEntity->GetHealth(), Color{ 255, 255, 255, 0 });
			//Render->DrawString(g_pNkContext, pEntity->GetPlayerName().c_str(), vecScreenHead.x, vecScreenHead.y - 6, Color{ 255, 255, 255, 0 });
			Render->DrawCircle(vecScreenHead.x, vecScreenHead.y, (vecScreenOrgin.y - vecScreenHead.y) / 10, 30, Color{ 255, 255, 255, 0 });
			Render->DrawLine(Globals::g_iWindowWidth / 2, Globals::g_iWindowHeight, vecScreenOrgin.x, vecScreenOrgin.y, Color{ 255, 255, 255, 0 });
		}

		Render->DrawCircle(Globals::g_iWindowWidth / 2, Globals::g_iWindowHeight / 2, g_Settings::iFov, 30, Color{ 255, 255, 255, 0 });
	}
}
```

`Private Esp/EspUI/dllmain.cpp`:

```cpp
#include <windows.h>
#include <D3D11.h>
#include <stdio.h>
#include "Utils.h"
#include "Hook.h"
#include "Settings.h"
#include "Globals.h"

#pragma comment(lib, "d3d11.lib")

void OnDllAttach(PVOID hModule)
{
	// allocate debug consoles
	AllocConsole();
	freopen_s((FILE**)stdin, "CONIN$", "r", stdin);
	freopen_s((FILE**)stdout, "CONOUT$", "w", stdout);

	SetConsoleTitleA(" OverflowR6");
	Utils::Log("Console Allocated!");

	// Inatilizae 
	Globals::HackInit();
	Hooks::HookInit();

	return;
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		OnDllAttach(hModule);
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}



delete <<
```

`Private Esp/EspUI/menu 2.cpp`:

```cpp
/*
/// # Nuklear
/// ![](https://cloud.githubusercontent.com/assets/8057201/11761525/ae06f0ca-a0c6-11e5-819d-5610b25f6ef4.gif)
///
/// ## Contents
/// 1. About section
/// 2. Highlights section
/// 3. Features section
/// 4. Usage section
///     1. Flags section
///     2. Constants section
///     3. Dependencies section
/// 5. Example section
/// 6. API section
///     1. Context section
///     2. Input section
///     3. Drawing section
///     4. Window section
///     5. Layouting section
///     6. Groups section
///     7. Tree section
///     8. Properties section
/// 7. License section
/// 8. Changelog section
/// 9. Gallery section
/// 10. Credits section
///sss
/// ## About
/// This is a minimal state immediate mode graphical user interface toolkit
/// written in ANSI C and licensed under public domain. It was designed as a simple
/// embeddable user interface for application and does not have any dependencies,
/// a default renderbackend or OS window and input handling but instead provides a very modular
/// library approach by using simple input state for input and draw
/// commands describing primitive shapes as output. So instead of providing a
/// layered library that tries to abstract over a number of platform and
/// render backends it only focuses on the actual UI.
///
/// ## Highlights
/// - Graphical user interface toolkit
/// - Single header library
/// - Written in C89 (a.k.a. ANSI C or ISO C90)
/// - Small codebase (~18kLOC)
/// - Focus on portability, efficiency and simplicity
/// - No dependencies (not even the standard library if not wanted)
/// - Fully skinnable and customizable
/// - Low memory footprint with total memory control if needed or wanted
/// - UTF-8 support
/// - No global or hidden state
/// - Customizable library modules (you can compile and use only what you need)
/// - Optional font baker and vertex buffer output
///
/// ## Features
/// - Absolutely no platform dependent code
/// - Memory management control ranging from/to
///     - Ease of use by allocating everything from standard library
///     - Control every byte of memory inside the library
/// - Font handling control ranging from/to
///     - Use your own font implementation for everything
///     - Use this libraries internal font baking and handling API
/// - Drawing output control ranging from/to
///     - Simple shapes for more high level APIs which already have drawing capabilities
///     - Hardware accessible anti-aliased vertex buffer output
/// - Customizable colors and properties ranging from/to
///     - Simple changes to color by filling a simple color table
///     - Complete control with ability to use skinning to decorate widgets
/// - Bendable UI library with widget ranging from/to
///     - Basic widgets like buttons, checkboxes, slider, ...
///     - Advanced widget like abstract comboboxes, contextual menus,...
/// - Compile time configuration to only compile what you need
///     - Subset which can be used if you do not want to link or use the standard library
/// - Can be easily modified to only update on user input instead of frame updates
///
/// ## Usage
/// This library is self contained in one single header file and can be used either
/// in header only mode or in implementation mode. The header only mode is used
/// by default when included and allows including this header in other headers
/// and does not contain the actual implementation. <br /><br />
///
/// The implementation mode requires to define  the preprocessor macro
/// NK_IMPLEMENTATION in *one* .c/.cpp file before #includeing this file, e.g.:
///
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~C
///     #define NK_IMPLEMENTATION
///     #include "nuklear.h"
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
///
/// Also optionally define the symbols listed in the section "OPTIONAL DEFINES"
/// below in header and implementation mode if you want to use additional functionality
/// or need more control over the library.
///
/// !!! WARNING
///     Every time nuklear is included define the same compiler flags. This very important not doing so could lead to compiler errors or even worse stack corruptions.
///
/// ### Flags
/// Flag                            | Description
/// --------------------------------|------------------------------------------
/// NK_PRIVATE                      | If defined declares all functions as static, so they can only be accessed inside the file that contains the implementation
/// NK_INCLUDE_FIXED_TYPES          | If defined it will include header `<stdint.h>` for fixed sized types otherwise nuklear tries to select the correct type. If that fails it will throw a compiler error and you have to select the correct types yourself.
/// NK_INCLUDE_DEFAULT_ALLOCATOR    | If defined it will include header `<stdlib.h>` and provide additional functions to use this library without caring for memory allocation control and therefore ease memory management.
/// NK_INCLUDE_STANDARD_IO          | If defined it will include header `<stdio.h>` and provide additional functions depending on file loading.
/// NK_INCLUDE_STANDARD_VARARGS     | If defined it will include header <stdio.h> and provide additional functions depending on file loading.
/// NK_INCLUDE_VERTEX_BUFFER_OUTPUT | Defining this adds a vertex draw command list backend to this library, which allows you to convert queue commands into vertex draw commands. This is mainly if you need a hardware accessible format for OpenGL, DirectX, Vulkan, Metal,...
/// NK_INCLUDE_FONT_BAKING          | Defining this adds `stb_truetype` and `stb_rect_pack` implementation to this library and provides font baking and rendering. If you already have font handling or do not want to use this font handler you don't have to define it.
/// NK_INCLUDE_DEFAULT_FONT         | Defining this adds the default font: ProggyClean.ttf into this library which can be loaded into a font atlas and allows using this library without having a truetype font
/// NK_INCLUDE_COMMAND_USERDATA     | Defining this adds a userdata pointer into each command. Can be useful for example if you want to provide custom shaders depending on the used widget. Can be combined with the style structures.
/// NK_BUTTON_TRIGGER_ON_RELEASE    | Different platforms require button clicks occurring either on buttons being pressed (up to down) or released (down to up). By default this library will react on buttons being pressed, but if you define this it will only trigger if a button is released.
/// NK_ZERO_COMMAND_MEMORY          | Defining this will zero out memory for each drawing command added to a drawing queue (inside nk_command_buffer_push). Zeroing command memory is very useful for fast checking (using memcmp) if command buffers are equal and avoid drawing frames when nothing on screen has changed since previous frame.
/// NK_UINT_DRAW_INDEX              | Defining this will set the size of vertex index elements when using NK_VERTEX_BUFFER_OUTPUT to 32bit instead of the default of 16bit
///
/// !!! WARNING
///     The following flags will pull in the standard C library:
///     - NK_INCLUDE_DEFAULT_ALLOCATOR
///     - NK_INCLUDE_STANDARD_IO
///     - NK_INCLUDE_STANDARD_VARARGS
///
/// !!! WARNING
///     The following flags if defined need to be defined for both header and implementation:
///     - NK_INCLUDE_FIXED_TYPES
///     - NK_INCLUDE_DEFAULT_ALLOCATOR
///     - NK_INCLUDE_STANDARD_VARARGS
///     - NK_INCLUDE_VERTEX_BUFFER_OUTPUT
///     - NK_INCLUDE_FONT_BAKING
///     - NK_INCLUDE_DEFAULT_FONT
///     - NK_INCLUDE_STANDARD_VARARGS
///     - NK_INCLUDE_COMMAND_USERDATA
///     - NK_UINT_DRAW_INDEX
///
/// ### Constants
/// Define                          | Description
/// --------------------------------|---------------------------------------
/// NK_BUFFER_DEFAULT_INITIAL_SIZE  | Initial buffer size allocated by all buffers while using the default allocator functions included by defining NK_INCLUDE_DEFAULT_ALLOCATOR. If you don't want to allocate the default 4k memory then redefine it.
/// NK_MAX_NUMBER_BUFFER            | Maximum buffer size for the conversion buffer between float and string Under normal circumstances this should be more than sufficient.
/// NK_INPUT_MAX                    | Defines the max number of bytes which can be added as text input in one frame. Under normal circumstances this should be more than sufficient.
///
/// !!! WARNING
///     The following constants if defined need to be defined for both header and implementation:
///     - NK_MAX_NUMBER_BUFFER
///     - NK_BUFFER_DEFAULT_INITIAL_SIZE
///     - NK_INPUT_MAX
///
/// ### Dependencies
/// Function    | Description
/// ------------|---------------------------------------------------------------
/// NK_ASSERT   | If you don't define this, nuklear will use <assert.h> with assert().
/// NK_MEMSET   | You can define this to 'memset' or your own memset implementation replacement. If not nuklear will use its own version.
/// NK_MEMCPY   | You can define this to 'memcpy' or your own memcpy implementation replacement. If not nuklear will use its own version.
/// NK_SQRT     | You can define this to 'sqrt' or your own sqrt implementation replacement. If not nuklear will use its own slow and not highly accurate version.
/// NK_SIN      | You can define this to 'sinf' or your own sine implementation replacement. If not nuklear will use its own approximation implementation.
/// NK_COS      | You can define this to 'cosf' or your own cosine implementation replacement. If not nuklear will use its own approximation implementation.
/// NK_STRTOD   | You can define this to `strtod` or your own string to double conversion implementation replacement. If not defined nuklear will use its own imprecise and possibly unsafe version (does not handle nan or infinity!).
/// NK_DTOA     | You can define this to `dtoa` or your own double to string conversion implementation replacement. If not defined nuklear will use its own imprecise and possibly unsafe version (does not handle nan or infinity!).
/// NK_VSNPRINTF| If you define `NK_INCLUDE_STANDARD_VARARGS` as well as `NK_INCLUDE_STANDARD_IO` and want to be safe define this to `vsnprintf` on compilers supporting later versions of C or C++. By default nuklear will check for your stdlib version in C as well as compiler version in C++. if `vsnprintf` is available it will define it to `vsnprintf` directly. If not defined and if you have older versions of C or C++ it will be defined to `vsprintf` which is unsafe.
///
/// !!! WARNING
///     The following dependencies will pull in the standard C library if not redefined:
///     - NK_ASSERT
///
/// !!! WARNING
///     The following dependencies if defined need to be defined for both header and implementation:
///     - NK_ASSERT
///
/// !!! WARNING
///     The following dependencies if defined need to be defined only for the implementation part:
///     - NK_MEMSET
///     - NK_MEMCPY
///     - NK_SQRT
///     - NK_SIN
///     - NK_COS
///     - NK_STRTOD
///     - NK_DTOA
///     - NK_VSNPRINTF
///
/// ## Example
///
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
/// // init gui state
/// enum {EASY, HARD};
/// static int op = EASY;
/// static float value = 0.6f;
/// static int i =  20;
/// struct nk_context ctx;
///
/// nk_init_fixed(&ctx, calloc(1, MAX_MEMORY), MAX_MEMORY, &font);
/// if (nk_begin(&ctx, "Show", nk_rect(50, 50, 220, 220),
///     NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_CLOSABLE)) {
///     // fixed widget pixel width
///     nk_layout_row_static(&ctx, 30, 80, 1);
///     if (nk_button_label(&ctx, "button")) {
///         // event handling
///     }
///
///     // fixed widget window ratio width
///     nk_layout_row_dynamic(&ctx, 30, 2);
///     if (nk_option_label(&ctx, "easy", op == EASY)) op = EASY;
///     if (nk_option_label(&ctx, "hard", op == HARD)) op = HARD;
///
///     // custom widget pixel width
///     nk_layout_row_begin(&ctx, NK_STATIC, 30, 2);
///     {
///         nk_layout_row_push(&ctx, 50);
///         nk_label(&ctx, "Volume:", NK_TEXT_LEFT);
///         nk_layout_row_push(&ctx, 110);
///         nk_slider_float(&ctx, 0, &value, 1.0f, 0.1f);
///     }
///     nk_layout_row_end(&ctx);
/// }
/// nk_end(&ctx);
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
///
/// ![](https://cloud.githubusercontent.com/assets/8057201/10187981/584ecd68-675c-11e5-897c-822ef534a876.png)
///
/// ## API
///
*/
#ifndef NK_SINGLE_FILE
#define NK_SINGLE_FILE
#endif

#ifndef NK_NUKLEAR_H_
#define NK_NUKLEAR_H_

#ifdef __cplusplus
extern "C" {
#endif
	/*
	 * ==============================================================
	 *
	 *                          CONSTANTS
	 *
	 * ===============================================================
	 */
#define NK_UNDEFINED (-1.0f)
#define NK_UTF_INVALID 0xFFFD /* internal invalid utf8 rune */
#define NK_UTF_SIZE 4 /* describes the number of bytes a glyph consists of*/
#ifndef NK_INPUT_MAX
#define NK_INPUT_MAX 16
#endif
#ifndef NK_MAX_NUMBER_BUFFER
#define NK_MAX_NUMBER_BUFFER 64
#endif
#ifndef NK_SCROLLBAR_HIDING_TIMEOUT
#define NK_SCROLLBAR_HIDING_TIMEOUT 4.0f
#endif
	 /*
	  * ==============================================================
	  *
	  *                          HELPER
	  *
	  * ===============================================================
	  */
#ifndef NK_API
#ifdef NK_PRIVATE
#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199409L))
#define NK_API static inline
#elif defined(__cplusplus)
#define NK_API static inline
#else
#define NK_API static
#endif
#else
#define NK_API extern
#endif
#endif
#ifndef NK_LIB
#ifdef NK_SINGLE_FILE
#define NK_LIB static
#else
#define NK_LIB extern
#endif
#endif

#define NK_INTERN static
#define NK_STORAGE static
#define NK_GLOBAL static

#define NK_FLAG(x) (1 << (x))
#define NK_STRINGIFY(x) #x
#define NK_MACRO_STRINGIFY(x) NK_STRINGIFY(x)
#define NK_STRING_JOIN_IMMEDIATE(arg1, arg2) arg1 ## arg2
#define NK_STRING_JOIN_DELAY(arg1, arg2) NK_STRING_JOIN_IMMEDIATE(arg1, arg2)
#define NK_STRING_JOIN(arg1, arg2) NK_STRING_JOIN_DELAY(arg1, arg2)

#ifdef _MSC_VER
#define NK_UNIQUE_NAME(name) NK_STRING_JOIN(name,__COUNTER__)
#else
#define NK_UNIQUE_NAME(name) NK_STRING_JOIN(name,__LINE__)
#endif

#ifndef NK_STATIC_ASSERT
#define NK_STATIC_ASSERT(exp) typedef char NK_UNIQUE_NAME(_dummy_array)[(exp)?1:-1]
#endif

#ifndef NK_FILE_LINE
#ifdef _MSC_VER
#define NK_FILE_LINE __FILE__ ":" NK_MACRO_STRINGIFY(__COUNTER__)
#else
#define NK_FILE_LINE __FILE__ ":" NK_MACRO_STRINGIFY(__LINE__)
#endif
#endif

#define NK_MIN(a, b) ((a) < (b) ? (a) : (b))
#define NK_MAX(a, b) ((a) < (b) ? (b) : (a))
#define NK_CLAMP(i, v, x) (NK_MAX(NK_MIN(v,x), i))

#ifdef NK_INCLUDE_STANDARD_VARARGS
#if defined(_MSC_VER) && (_MSC_VER >= 1600) /* VS 2010 and above */
#include <sal.h>
#define NK_PRINTF_FORMAT_STRING _Printf_format_string_
#else
#define NK_PRINTF_FORMAT_STRING
#endif
#if defined(__GNUC__)
#define NK_PRINTF_VARARG_FUNC(fmtargnumber) __attribute__((format(__printf__, fmtargnumber, fmtargnumber+1)))
#define NK_PRINTF_VALIST_FUNC(fmtargnumber) __attribute__((format(__printf__, fmtargnumber, 0)))
#else
#define NK_PRINTF_VARARG_FUNC(fmtargnumber)
#define NK_PRINTF_VALIST_FUNC(fmtargnumber)
#endif
#endif

	  /*
	   * ===============================================================
	   *
	   *                          BASIC
	   *
	   * ===============================================================
	   */
#ifdef NK_INCLUDE_FIXED_TYPES

#include <stdint.h>

#define NK_INT8 int8_t
#define NK_UINT8 uint8_t
#define NK_INT16 int16_t
#define NK_UINT16 uint16_t
#define NK_INT32 int32_t
#define NK_UINT32 uint32_t
#define NK_SIZE_TYPE uintptr_t
#define NK_POINTER_TYPE uintptr_t
#else
#ifndef NK_INT8
#define NK_INT8 signed char
#endif
#ifndef NK_UINT8
#define NK_UINT8 unsigned char
#endif
#ifndef NK_INT16
#define NK_INT16 signed short
#endif
#ifndef NK_UINT16
#define NK_UINT16 unsigned short
#endif
#ifndef NK_INT32
#if defined(_MSC_VER)
#define NK_INT32 __int32
#else
#define NK_INT32 signed int
#endif
#endif
#ifndef NK_UINT32
#if defined(_MSC_VER)
#define NK_UINT32 unsigned __int32
#else
#define NK_UINT32 unsigned int
#endif
#endif
#ifndef NK_SIZE_TYPE
#if defined(_WIN64) && defined(_MSC_VER)
#define NK_SIZE_TYPE unsigned __int64
#elif (defined(_WIN32) || defined(WIN32)) && defined(_MSC_VER)
#define NK_SIZE_TYPE unsigned __int32
#elif defined(__GNUC__) || defined(__clang__)
#if defined(__x86_64__) || defined(__ppc64__)
#define NK_SIZE_TYPE unsigned long
#else
#define NK_SIZE_TYPE unsigned int
#endif
#else
#define NK_SIZE_TYPE unsigned long
#endif
#endif
#ifndef NK_POINTER_TYPE
#if defined(_WIN64) && defined(_MSC_VER)
#define NK_POINTER_TYPE unsigned __int64
#elif (defined(_WIN32) || defined(WIN32)) && defined(_MSC_VER)
#define NK_POINTER_TYPE unsigned __int32
#elif defined(__GNUC__) || defined(__clang__)
#if defined(__x86_64__) || defined(__ppc64__)
#define NK_POINTER_TYPE unsigned long
#else
#define NK_POINTER_TYPE unsigned int
#endif
#else
#define NK_POINTER_TYPE unsigned long
#endif
#endif
#endif

	typedef NK_INT8 nk_char;
	typedef NK_UINT8 nk_uchar;
	typedef NK_UINT8 nk_byte;
	typedef NK_INT16 nk_short;
	typedef NK_UINT16 nk_ushort;
	typedef NK_INT32 nk_int;
	typedef NK_UINT32 nk_uint;
	typedef NK_SIZE_TYPE nk_size;
	typedef NK_POINTER_TYPE nk_ptr;

	typedef nk_uint nk_hash;
	typedef nk_uint nk_flags;
	typedef nk_uint nk_rune;

	/* Make sure correct type size:
	 * This will fire with a negative subscript error if the type sizes
	 * are set incorrectly by the compiler, and compile out if not */
	NK_STATIC_ASSERT(sizeof(nk_short) == 2);
	NK_STATIC_ASSERT(sizeof(nk_ushort) == 2);
	NK_STATIC_ASSERT(sizeof(nk_uint) == 4);
	NK_STATIC_ASSERT(sizeof(nk_int) == 4);
	NK_STATIC_ASSERT(sizeof(nk_byte) == 1);
	NK_STATIC_ASSERT(sizeof(nk_flags) >= 4);
	NK_STATIC_ASSERT(sizeof(nk_rune) >= 4);
	NK_STATIC_ASSERT(sizeof(nk_size) >= sizeof(void*));
	NK_STATIC_ASSERT(sizeof(nk_ptr) >= sizeof(void*));

	/* ============================================================================
	 *
	 *                                  API
	 *
	 * =========================================================================== */
	struct nk_buffer;
	struct nk_allocator;
	struct nk_command_buffer;
	struct nk_draw_command;
	struct nk_convert_config;
	struct nk_style_item;
	struct nk_text_edit;
	struct nk_draw_list;
	struct nk_user_font;
	struct nk_panel;
	struct nk_context;
	struct nk_draw_vertex_layout_element;
	struct nk_style_button;
	struct nk_style_toggle;
	struct nk_style_selectable;
	struct nk_style_slide;
	struct nk_style_progress;
	struct nk_style_scrollbar;
	struct nk_style_edit;
	struct nk_style_property;
	struct nk_style_chart;
	struct nk_style_combo;
	struct nk_style_tab;
	struct nk_style_window_header;
	struct nk_style_window;

	enum {
		nk_false, nk_true
	};
	struct nk_color {
		nk_byte r, g, b, a;
	};
	struct nk_colorf {
		float r, g, b, a;
	};
	struct nk_vec2 {
		float x, y;
	};
	struct nk_vec2i {
		short x, y;
	};
	struct nk_rect {
		float x, y, w, h;
	};
	struct nk_recti {
		short x, y, w, h;
	};
	typedef char nk_glyph[NK_UTF_SIZE];
	typedef union {
		void* ptr;
		int id;
	} nk_handle;
	struct nk_image {
		nk_handle handle;
		unsigned short w, h;
		unsigned short region[4];
	};
	struct nk_cursor {
		struct nk_image img;
		struct nk_vec2 size, offset;
	};
	struct nk_scroll {
		nk_uint x, y;
	};

	enum nk_heading {
		NK_UP, NK_RIGHT, NK_DOWN, NK_LEFT
	};
	enum nk_button_behavior {
		NK_BUTTON_DEFAULT, NK_BUTTON_REPEATER
	};
	enum nk_modify {
		NK_FIXED = nk_false, NK_MODIFIABLE = nk_true
	};
	enum nk_orientation {
		NK_VERTICAL, NK_HORIZONTAL
	};
	enum nk_collapse_states {
		NK_MINIMIZED = nk_false, NK_MAXIMIZED = nk_true
	};
	enum nk_show_states {
		NK_HIDDEN = nk_false, NK_SHOWN = nk_true
	};
	enum nk_chart_type {
		NK_CHART_LINES, NK_CHART_COLUMN, NK_CHART_MAX
	};
	enum nk_chart_event {
		NK_CHART_HOVERING = 0x01, NK_CHART_CLICKED = 0x02
	};
	enum nk_color_format {
		NK_RGB, NK_RGBA
	};
	enum nk_popup_type {
		NK_POPUP_STATIC, NK_POPUP_DYNAMIC
	};
	enum nk_layout_format {
		NK_DYNAMIC, NK_STATIC
	};
	enum nk_tree_type {
		NK_TREE_NODE, NK_TREE_TAB
	};

	typedef void* (*nk_plugin_alloc)(nk_handle, void* old, nk_size);

	typedef void (*nk_plugin_free)(nk_handle, void* old);

	typedef int(*nk_plugin_filter)(const struct nk_text_edit*, nk_rune unicode);

	typedef void(*nk_plugin_paste)(nk_handle, struct nk_text_edit*);

	typedef void(*nk_plugin_copy)(nk_handle, const char*, int len);

	struct nk_allocator {
		nk_handle userdata;
		nk_plugin_alloc alloc;
		nk_plugin_free free;
	};
	enum nk_symbol_type {
		NK_SYMBOL_NONE,
		NK_SYMBOL_X,
		NK_SYMBOL_UNDERSCORE,
		NK_SYMBOL_CIRCLE_SOLID,
		NK_SYMBOL_CIRCLE_OUTLINE,
		NK_SYMBOL_RECT_SOLID,
		NK_SYMBOL_RECT_OUTLINE,
		NK_SYMBOL_TRIANGLE_UP,
		NK_SYMBOL_TRIANGLE_DOWN,
		NK_SYMBOL_TRIANGLE_LEFT,
		NK_SYMBOL_TRIANGLE_RIGHT,
		NK_SYMBOL_PLUS,
		NK_SYMBOL_MINUS,
		NK_SYMBOL_MAX
	};
	/* =============================================================================
	 *
	 *                                  CONTEXT
	 *
	 * =============================================================================*/
	 /*/// ### Context
	 /// Contexts are the main entry point and the majestro of nuklear and contain all required state.
	 /// They are used for window, memory, input, style, stack, commands and time management and need
	 /// to be passed into all nuklear GUI specific functions.
	 ///
	 /// #### Usage
	 /// To use a context it first has to be initialized which can be achieved by calling
	 /// one of either `nk_init_default`, `nk_init_fixed`, `nk_init`, `nk_init_custom`.
	 /// Each takes in a font handle and a specific way of handling memory. Memory control
	 /// hereby ranges from standard library to just specifying a fixed sized block of memory
	 /// which nuklear has to manage itself from.
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// struct nk_context ctx;
	 /// nk_init_xxx(&ctx, ...);
	 /// while (1) {
	 ///     // [...]
	 ///     nk_clear(&ctx);
	 /// }
	 /// nk_free(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// #### Reference
	 /// Function            | Description
	 /// --------------------|-------------------------------------------------------
	 /// __nk_init_default__ | Initializes context with standard library memory allocation (malloc,free)
	 /// __nk_init_fixed__   | Initializes context from single fixed size memory block
	 /// __nk_init__         | Initializes context with memory allocator callbacks for alloc and free
	 /// __nk_init_custom__  | Initializes context from two buffers. One for draw commands the other for window/panel/table allocations
	 /// __nk_clear__        | Called at the end of the frame to reset and prepare the context for the next frame
	 /// __nk_free__         | Shutdown and free all memory allocated inside the context
	 /// __nk_set_user_data__| Utility function to pass user data to draw command
	  */
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR
	  /*/// #### nk_init_default
	  /// Initializes a `nk_context` struct with a default standard library allocator.
	  /// Should be used if you don't want to be bothered with memory management in nuklear.
	  ///
	  /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	  /// int nk_init_default(struct nk_context *ctx, const struct nk_user_font *font);
	  /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  ///
	  /// Parameter   | Description
	  /// ------------|---------------------------------------------------------------
	  /// __ctx__     | Must point to an either stack or heap allocated `nk_context` struct
	  /// __font__    | Must point to a previously initialized font handle for more info look at font documentation
	  ///
	  /// Returns either `false(0)` on failure or `true(1)` on success.
	  ///
	  */
	NK_API int nk_init_default(struct nk_context*, const struct nk_user_font*);

#endif
	/*/// #### nk_init_fixed
	/// Initializes a `nk_context` struct from single fixed size memory block
	/// Should be used if you want complete control over nuklear's memory management.
	/// Especially recommended for system with little memory or systems with virtual memory.
	/// For the later case you can just allocate for example 16MB of virtual memory
	/// and only the required amount of memory will actually be committed.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_init_fixed(struct nk_context *ctx, void *memory, nk_size size, const struct nk_user_font *font);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// !!! Warning
	///     make sure the passed memory block is aligned correctly for `nk_draw_commands`.
	///
	/// Parameter   | Description
	/// ------------|--------------------------------------------------------------
	/// __ctx__     | Must point to an either stack or heap allocated `nk_context` struct
	/// __memory__  | Must point to a previously allocated memory block
	/// __size__    | Must contain the total size of __memory__
	/// __font__    | Must point to a previously initialized font handle for more info look at font documentation
	///
	/// Returns either `false(0)` on failure or `true(1)` on success.
	*/
	NK_API int nk_init_fixed(struct nk_context*, void* memory, nk_size size, const struct nk_user_font*);
	/*/// #### nk_init
	/// Initializes a `nk_context` struct with memory allocation callbacks for nuklear to allocate
	/// memory from. Used internally for `nk_init_default` and provides a kitchen sink allocation
	/// interface to nuklear. Can be useful for cases like monitoring memory consumption.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_init(struct nk_context *ctx, struct nk_allocator *alloc, const struct nk_user_font *font);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|---------------------------------------------------------------
	/// __ctx__     | Must point to an either stack or heap allocated `nk_context` struct
	/// __alloc__   | Must point to a previously allocated memory allocator
	/// __font__    | Must point to a previously initialized font handle for more info look at font documentation
	///
	/// Returns either `false(0)` on failure or `true(1)` on success.
	*/
	NK_API int nk_init(struct nk_context*, struct nk_allocator*, const struct nk_user_font*);
	/*/// #### nk_init_custom
	/// Initializes a `nk_context` struct from two different either fixed or growing
	/// buffers. The first buffer is for allocating draw commands while the second buffer is
	/// used for allocating windows, panels and state tables.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_init_custom(struct nk_context *ctx, struct nk_buffer *cmds, struct nk_buffer *pool, const struct nk_user_font *font);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|---------------------------------------------------------------
	/// __ctx__     | Must point to an either stack or heap allocated `nk_context` struct
	/// __cmds__    | Must point to a previously initialized memory buffer either fixed or dynamic to store draw commands into
	/// __pool__    | Must point to a previously initialized memory buffer either fixed or dynamic to store windows, panels and tables
	/// __font__    | Must point to a previously initialized font handle for more info look at font documentation
	///
	/// Returns either `false(0)` on failure or `true(1)` on success.
	*/
	NK_API int
		nk_init_custom(struct nk_context*, struct nk_buffer* cmds, struct nk_buffer* pool, const struct nk_user_font*);
	/*/// #### nk_clear
	/// Resets the context state at the end of the frame. This includes mostly
	/// garbage collector tasks like removing windows or table not called and therefore
	/// used anymore.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_clear(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	*/
	NK_API void nk_clear(struct nk_context*);
	/*/// #### nk_free
	/// Frees all memory allocated by nuklear. Not needed if context was
	/// initialized with `nk_init_fixed`.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_free(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	*/
	NK_API void nk_free(struct nk_context*);

#ifdef NK_INCLUDE_COMMAND_USERDATA
	/*/// #### nk_set_user_data
/// Sets the currently passed userdata passed down into each draw command.
///
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
/// void nk_set_user_data(struct nk_context *ctx, nk_handle data);
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
///
/// Parameter   | Description
/// ------------|--------------------------------------------------------------
/// __ctx__     | Must point to a previously initialized `nk_context` struct
/// __data__    | Handle with either pointer or index to be passed into every draw commands
*/
	NK_API void nk_set_user_data(struct nk_context*, nk_handle handle);
#endif
	/* =============================================================================
	 *
	 *                                  INPUT
	 *
	 * =============================================================================*/
	 /*/// ### Input
	 /// The input API is responsible for holding the current input state composed of
	 /// mouse, key and text input states.
	 /// It is worth noting that no direct os or window handling is done in nuklear.
	 /// Instead all input state has to be provided by platform specific code. This in one hand
	 /// expects more work from the user and complicates usage but on the other hand
	 /// provides simple abstraction over a big number of platforms, libraries and other
	 /// already provided functionality.
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// nk_input_begin(&ctx);
	 /// while (GetEvent(&evt)) {
	 ///     if (evt.type == MOUSE_MOVE)
	 ///         nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	 ///     else if (evt.type == [...]) {
	 ///         // [...]
	 ///     }
	 /// } nk_input_end(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// #### Usage
	 /// Input state needs to be provided to nuklear by first calling `nk_input_begin`
	 /// which resets internal state like delta mouse position and button transistions.
	 /// After `nk_input_begin` all current input state needs to be provided. This includes
	 /// mouse motion, button and key pressed and released, text input and scrolling.
	 /// Both event- or state-based input handling are supported by this API
	 /// and should work without problems. Finally after all input state has been
	 /// mirrored `nk_input_end` needs to be called to finish input process.
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// struct nk_context ctx;
	 /// nk_init_xxx(&ctx, ...);
	 /// while (1) {
	 ///     Event evt;
	 ///     nk_input_begin(&ctx);
	 ///     while (GetEvent(&evt)) {
	 ///         if (evt.type == MOUSE_MOVE)
	 ///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	 ///         else if (evt.type == [...]) {
	 ///             // [...]
	 ///         }
	 ///     }
	 ///     nk_input_end(&ctx);
	 ///     // [...]
	 ///     nk_clear(&ctx);
	 /// } nk_free(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// #### Reference
	 /// Function            | Description
	 /// --------------------|-------------------------------------------------------
	 /// __nk_input_begin__  | Begins the input mirroring process. Needs to be called before all other `nk_input_xxx` calls
	 /// __nk_input_motion__ | Mirrors mouse cursor position
	 /// __nk_input_key__    | Mirrors key state with either pressed or released
	 /// __nk_input_button__ | Mirrors mouse button state with either pressed or released
	 /// __nk_input_scroll__ | Mirrors mouse scroll values
	 /// __nk_input_char__   | Adds a single ASCII text character into an internal text buffer
	 /// __nk_input_glyph__  | Adds a single multi-byte UTF-8 character into an internal text buffer
	 /// __nk_input_unicode__| Adds a single unicode rune into an internal text buffer
	 /// __nk_input_end__    | Ends the input mirroring process by calculating state changes. Don't call any `nk_input_xxx` function referenced above after this call
	 */
	enum nk_keys {
		NK_KEY_NONE,
		NK_KEY_SHIFT,
		NK_KEY_CTRL,
		NK_KEY_DEL,
		NK_KEY_ENTER,
		NK_KEY_TAB,
		NK_KEY_BACKSPACE,
		NK_KEY_COPY,
		NK_KEY_CUT,
		NK_KEY_PASTE,
		NK_KEY_UP,
		NK_KEY_DOWN,
		NK_KEY_LEFT,
		NK_KEY_RIGHT,
		/* Shortcuts: text field */
		NK_KEY_TEXT_INSERT_MODE,
		NK_KEY_TEXT_REPLACE_MODE,
		NK_KEY_TEXT_RESET_MODE,
		NK_KEY_TEXT_LINE_START,
		NK_KEY_TEXT_LINE_END,
		NK_KEY_TEXT_START,
		NK_KEY_TEXT_END,
		NK_KEY_TEXT_UNDO,
		NK_KEY_TEXT_REDO,
		NK_KEY_TEXT_SELECT_ALL,
		NK_KEY_TEXT_WORD_LEFT,
		NK_KEY_TEXT_WORD_RIGHT,
		/* Shortcuts: scrollbar */
		NK_KEY_SCROLL_START,
		NK_KEY_SCROLL_END,
		NK_KEY_SCROLL_DOWN,
		NK_KEY_SCROLL_UP,
		NK_KEY_MAX
	};
	enum nk_buttons {
		NK_BUTTON_LEFT, NK_BUTTON_MIDDLE, NK_BUTTON_RIGHT, NK_BUTTON_DOUBLE, NK_BUTTON_MAX
	};
	/*/// #### nk_input_begin
	/// Begins the input mirroring process by resetting text, scroll
	/// mouse previous mouse position and movement as well as key state transitions,
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_begin(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	*/
	NK_API void nk_input_begin(struct nk_context*);
	/*/// #### nk_input_motion
	/// Mirrors current mouse position to nuklear
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_motion(struct nk_context *ctx, int x, int y);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __x__       | Must hold an integer describing the current mouse cursor x-position
	/// __y__       | Must hold an integer describing the current mouse cursor y-position
	*/
	NK_API void nk_input_motion(struct nk_context*, int x, int y);
	/*/// #### nk_input_key
	/// Mirrors state of a specific key to nuklear
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_key(struct nk_context*, enum nk_keys key, int down);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __key__     | Must be any value specified in enum `nk_keys` that needs to be mirrored
	/// __down__    | Must be 0 for key is up and 1 for key is down
	*/
	NK_API void nk_input_key(struct nk_context*, enum nk_keys, int down);
	/*/// #### nk_input_button
	/// Mirrors the state of a specific mouse button to nuklear
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_button(struct nk_context *ctx, enum nk_buttons btn, int x, int y, int down);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __btn__     | Must be any value specified in enum `nk_buttons` that needs to be mirrored
	/// __x__       | Must contain an integer describing mouse cursor x-position on click up/down
	/// __y__       | Must contain an integer describing mouse cursor y-position on click up/down
	/// __down__    | Must be 0 for key is up and 1 for key is down
	*/
	NK_API void nk_input_button(struct nk_context*, enum nk_buttons, int x, int y, int down);
	/*/// #### nk_input_scroll
	/// Copies the last mouse scroll value to nuklear. Is generally
	/// a scroll value. So does not have to come from mouse and could also originate
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_scroll(struct nk_context *ctx, struct nk_vec2 val);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __val__     | vector with both X- as well as Y-scroll value
	*/
	NK_API void nk_input_scroll(struct nk_context*, struct nk_vec2 val);
	/*/// #### nk_input_char
	/// Copies a single ASCII character into an internal text buffer
	/// This is basically a helper function to quickly push ASCII characters into
	/// nuklear.
	///
	/// !!! Note
	///     Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_char(struct nk_context *ctx, char c);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __c__       | Must be a single ASCII character preferable one that can be printed
	*/
	NK_API void nk_input_char(struct nk_context*, char);
	/*/// #### nk_input_glyph
	/// Converts an encoded unicode rune into UTF-8 and copies the result into an
	/// internal text buffer.
	///
	/// !!! Note
	///     Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_glyph(struct nk_context *ctx, const nk_glyph g);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __g__       | UTF-32 unicode codepoint
	*/
	NK_API void nk_input_glyph(struct nk_context*, const nk_glyph);
	/*/// #### nk_input_unicode
	/// Converts a unicode rune into UTF-8 and copies the result
	/// into an internal text buffer.
	/// !!! Note
	///     Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_unicode(struct nk_context*, nk_rune rune);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	/// __rune__    | UTF-32 unicode codepoint
	*/
	NK_API void nk_input_unicode(struct nk_context*, nk_rune);
	/*/// #### nk_input_end
	/// End the input mirroring process by resetting mouse grabbing
	/// state to ensure the mouse cursor is not grabbed indefinitely.///
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_input_end(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to a previously initialized `nk_context` struct
	*/
	NK_API void nk_input_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  DRAWING
	 *
	 * =============================================================================*/
	 /*/// ### Drawing
	 /// This library was designed to be render backend agnostic so it does
	 /// not draw anything to screen directly. Instead all drawn shapes, widgets
	 /// are made of, are buffered into memory and make up a command queue.
	 /// Each frame therefore fills the command buffer with draw commands
	 /// that then need to be executed by the user and his own render backend.
	 /// After that the command buffer needs to be cleared and a new frame can be
	 /// started. It is probably important to note that the command buffer is the main
	 /// drawing API and the optional vertex buffer API only takes this format and
	 /// converts it into a hardware accessible format.
	 ///
	 /// #### Usage
	 /// To draw all draw commands accumulated over a frame you need your own render
	 /// backend able to draw a number of 2D primitives. This includes at least
	 /// filled and stroked rectangles, circles, text, lines, triangles and scissors.
	 /// As soon as this criterion is met you can iterate over each draw command
	 /// and execute each draw command in a interpreter like fashion:
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// const struct nk_command *cmd = 0;
	 /// nk_foreach(cmd, &ctx) {
	 ///     switch (cmd->type) {
	 ///     case NK_COMMAND_LINE:
	 ///         your_draw_line_function(...)
	 ///         break;
	 ///     case NK_COMMAND_RECT
	 ///         your_draw_rect_function(...)
	 ///         break;
	 ///     case //...:
	 ///         //[...]
	 ///     }
	 /// }
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// In program flow context draw commands need to be executed after input has been
	 /// gathered and the complete UI with windows and their contained widgets have
	 /// been executed and before calling `nk_clear` which frees all previously
	 /// allocated draw commands.
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// struct nk_context ctx;
	 /// nk_init_xxx(&ctx, ...);
	 /// while (1) {
	 ///     Event evt;
	 ///     nk_input_begin(&ctx);
	 ///     while (GetEvent(&evt)) {
	 ///         if (evt.type == MOUSE_MOVE)
	 ///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	 ///         else if (evt.type == [...]) {
	 ///             [...]
	 ///         }
	 ///     }
	 ///     nk_input_end(&ctx);
	 ///     //
	 ///     // [...]
	 ///     //
	 ///     const struct nk_command *cmd = 0;
	 ///     nk_foreach(cmd, &ctx) {
	 ///     switch (cmd->type) {
	 ///     case NK_COMMAND_LINE:
	 ///         your_draw_line_function(...)
	 ///         break;
	 ///     case NK_COMMAND_RECT
	 ///         your_draw_rect_function(...)
	 ///         break;
	 ///     case ...:
	 ///         // [...]
	 ///     }
	 ///     nk_clear(&ctx);
	 /// }
	 /// nk_free(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// You probably noticed that you have to draw all of the UI each frame which is
	 /// quite wasteful. While the actual UI updating loop is quite fast rendering
	 /// without actually needing it is not. So there are multiple things you could do.
	 ///
	 /// First is only update on input. This of course is only an option if your
	 /// application only depends on the UI and does not require any outside calculations.
	 /// If you actually only update on input make sure to update the UI two times each
	 /// frame and call `nk_clear` directly after the first pass and only draw in
	 /// the second pass. In addition it is recommended to also add additional timers
	 /// to make sure the UI is not drawn more than a fixed number of frames per second.
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// struct nk_context ctx;
	 /// nk_init_xxx(&ctx, ...);
	 /// while (1) {
	 ///     // [...wait for input ]
	 ///     // [...do two UI passes ...]
	 ///     do_ui(...)
	 ///     nk_clear(&ctx);
	 ///     do_ui(...)
	 ///     //
	 ///     // draw
	 ///     const struct nk_command *cmd = 0;
	 ///     nk_foreach(cmd, &ctx) {
	 ///     switch (cmd->type) {
	 ///     case NK_COMMAND_LINE:
	 ///         your_draw_line_function(...)
	 ///         break;
	 ///     case NK_COMMAND_RECT
	 ///         your_draw_rect_function(...)
	 ///         break;
	 ///     case ...:
	 ///         //[...]
	 ///     }
	 ///     nk_clear(&ctx);
	 /// }
	 /// nk_free(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// The second probably more applicable trick is to only draw if anything changed.
	 /// It is not really useful for applications with continuous draw loop but
	 /// quite useful for desktop applications. To actually get nuklear to only
	 /// draw on changes you first have to define `NK_ZERO_COMMAND_MEMORY` and
	 /// allocate a memory buffer that will store each unique drawing output.
	 /// After each frame you compare the draw command memory inside the library
	 /// with your allocated buffer by memcmp. If memcmp detects differences
	 /// you have to copy the command buffer into the allocated buffer
	 /// and then draw like usual (this example uses fixed memory but you could
	 /// use dynamically allocated memory).
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// //[... other defines ...]
	 /// #define NK_ZERO_COMMAND_MEMORY
	 /// #include "nuklear.h"
	 /// //
	 /// // setup context
	 /// struct nk_context ctx;
	 /// void *last = calloc(1,64*1024);
	 /// void *buf = calloc(1,64*1024);
	 /// nk_init_fixed(&ctx, buf, 64*1024);
	 /// //
	 /// // loop
	 /// while (1) {
	 ///     // [...input...]
	 ///     // [...ui...]
	 ///     void *cmds = nk_buffer_memory(&ctx.memory);
	 ///     if (memcmp(cmds, last, ctx.memory.allocated)) {
	 ///         memcpy(last,cmds,ctx.memory.allocated);
	 ///         const struct nk_command *cmd = 0;
	 ///         nk_foreach(cmd, &ctx) {
	 ///             switch (cmd->type) {
	 ///             case NK_COMMAND_LINE:
	 ///                 your_draw_line_function(...)
	 ///                 break;
	 ///             case NK_COMMAND_RECT
	 ///                 your_draw_rect_function(...)
	 ///                 break;
	 ///             case ...:
	 ///                 // [...]
	 ///             }
	 ///         }
	 ///     }
	 ///     nk_clear(&ctx);
	 /// }
	 /// nk_free(&ctx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// Finally while using draw commands makes sense for higher abstracted platforms like
	 /// X11 and Win32 or drawing libraries it is often desirable to use graphics
	 /// hardware directly. Therefore it is possible to just define
	 /// `NK_INCLUDE_VERTEX_BUFFER_OUTPUT` which includes optional vertex output.
	 /// To access the vertex output you first have to convert all draw commands into
	 /// vertexes by calling `nk_convert` which takes in your preferred vertex format.
	 /// After successfully converting all draw commands just iterate over and execute all
	 /// vertex draw commands:
	 ///
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	 /// // fill configuration
	 /// struct your_vertex
	 /// {
	 ///     float pos[2]; // important to keep it to 2 floats
	 ///     float uv[2];
	 ///     unsigned char col[4];
	 /// };
	 /// struct nk_convert_config cfg = {};
	 /// static const struct nk_draw_vertex_layout_element vertex_layout[] = {
	 ///     {NK_VERTEX_POSITION, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, pos)},
	 ///     {NK_VERTEX_TEXCOORD, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, uv)},
	 ///     {NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, NK_OFFSETOF(struct your_vertex, col)},
	 ///     {NK_VERTEX_LAYOUT_END}
	 /// };
	 /// cfg.shape_AA = NK_ANTI_ALIASING_ON;
	 /// cfg.line_AA = NK_ANTI_ALIASING_ON;
	 /// cfg.vertex_layout = vertex_layout;
	 /// cfg.vertex_size = sizeof(struct your_vertex);
	 /// cfg.vertex_alignment = NK_ALIGNOF(struct your_vertex);
	 /// cfg.circle_segment_count = 22;
	 /// cfg.curve_segment_count = 22;
	 /// cfg.arc_segment_count = 22;
	 /// cfg.global_alpha = 1.0f;
	 /// cfg.null = dev->null;
	 /// //
	 /// // setup buffers and convert
	 /// struct nk_buffer cmds, verts, idx;
	 /// nk_buffer_init_default(&cmds);
	 /// nk_buffer_init_default(&verts);
	 /// nk_buffer_init_default(&idx);
	 /// nk_convert(&ctx, &cmds, &verts, &idx, &cfg);
	 /// //
	 /// // draw
	 /// nk_draw_foreach(cmd, &ctx, &cmds) {
	 /// if (!cmd->elem_count) continue;
	 ///     //[...]
	 /// }
	 /// nk_buffer_free(&cms);
	 /// nk_buffer_free(&verts);
	 /// nk_buffer_free(&idx);
	 /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 ///
	 /// #### Reference
	 /// Function            | Description
	 /// --------------------|-------------------------------------------------------
	 /// __nk__begin__       | Returns the first draw command in the context draw command list to be drawn
	 /// __nk__next__        | Increments the draw command iterator to the next command inside the context draw command list
	 /// __nk_foreach__      | Iterates over each draw command inside the context draw command list
	 /// __nk_convert__      | Converts from the abstract draw commands list into a hardware accessible vertex format
	 /// __nk_draw_begin__   | Returns the first vertex command in the context vertex draw list to be executed
	 /// __nk__draw_next__   | Increments the vertex command iterator to the next command inside the context vertex command list
	 /// __nk__draw_end__    | Returns the end of the vertex draw list
	 /// __nk_draw_foreach__ | Iterates over each vertex draw command inside the vertex draw list
	 */
	enum nk_anti_aliasing {
		NK_ANTI_ALIASING_OFF, NK_ANTI_ALIASING_ON
	};
	enum nk_convert_result {
		NK_CONVERT_SUCCESS = 0,
		NK_CONVERT_INVALID_PARAM = 1,
		NK_CONVERT_COMMAND_BUFFER_FULL = NK_FLAG(1),
		NK_CONVERT_VERTEX_BUFFER_FULL = NK_FLAG(2),
		NK_CONVERT_ELEMENT_BUFFER_FULL = NK_FLAG(3)
	};
	struct nk_draw_null_texture {
		nk_handle texture; /* texture handle to a texture with a white pixel */
		struct nk_vec2 uv; /* coordinates to a white pixel in the texture  */
	};
	struct nk_convert_config {
		float global_alpha; /* global alpha value */
		enum nk_anti_aliasing line_AA; /* line anti-aliasing flag can be turned off if you are tight on memory */
		enum nk_anti_aliasing shape_AA; /* shape anti-aliasing flag can be turned off if you are tight on memory */
		unsigned circle_segment_count; /* number of segments used for circles: default to 22 */
		unsigned arc_segment_count; /* number of segments used for arcs: default to 22 */
		unsigned curve_segment_count; /* number of segments used for curves: default to 22 */
		struct nk_draw_null_texture null; /* handle to texture with a white pixel for shape drawing */
		const struct nk_draw_vertex_layout_element* vertex_layout; /* describes the vertex output format and packing */
		nk_size vertex_size; /* sizeof one vertex for vertex packing */
		nk_size vertex_alignment; /* vertex alignment: Can be obtained by NK_ALIGNOF */
	};
	/*/// #### nk__begin
	/// Returns a draw command list iterator to iterate all draw
	/// commands accumulated over one frame.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// const struct nk_command* nk__begin(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | must point to an previously initialized `nk_context` struct at the end of a frame
	///
	/// Returns draw command pointer pointing to the first command inside the draw command list
	*/
	NK_API const struct nk_command* nk__begin(struct nk_context*);
	/*/// #### nk__next
	/// Returns a draw command list iterator to iterate all draw
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// const struct nk_command* nk__next(struct nk_context*, const struct nk_command*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	/// __cmd__     | Must point to an previously a draw command either returned by `nk__begin` or `nk__next`
	///
	/// Returns draw command pointer pointing to the next command inside the draw command list
	*/
	NK_API const struct nk_command* nk__next(struct nk_context*, const struct nk_command*);
	/*/// #### nk_foreach
	/// Iterates over each draw command inside the context draw command list
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_foreach(c, ctx)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	/// __cmd__     | Command pointer initialized to NULL
	///
	/// Returns draw command pointer pointing to the next command inside the draw command list
	*/
#define nk_foreach(c, ctx) for((c) = nk__begin(ctx); (c) != 0; (c) = nk__next(ctx,c))
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
	/*/// #### nk_convert
/// Converts all internal draw commands into vertex draw commands and fills
/// three buffers with vertexes, vertex draw commands and vertex indices. The vertex format
/// as well as some other configuration values have to be configured by filling out a
/// `nk_convert_config` struct.
///
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
/// nk_flags nk_convert(struct nk_context *ctx, struct nk_buffer *cmds,
//      struct nk_buffer *vertices, struct nk_buffer *elements, const struct nk_convert_config*);
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
///
/// Parameter   | Description
/// ------------|-----------------------------------------------------------
/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
/// __cmds__    | Must point to a previously initialized buffer to hold converted vertex draw commands
/// __vertices__| Must point to a previously initialized buffer to hold all produced vertices
/// __elements__| Must point to a previously initialized buffer to hold all produced vertex indices
/// __config__  | Must point to a filled out `nk_config` struct to configure the conversion process
///
/// Returns one of enum nk_convert_result error codes
///
/// Parameter                       | Description
/// --------------------------------|-----------------------------------------------------------
/// NK_CONVERT_SUCCESS              | Signals a successful draw command to vertex buffer conversion
/// NK_CONVERT_INVALID_PARAM        | An invalid argument was passed in the function call
/// NK_CONVERT_COMMAND_BUFFER_FULL  | The provided buffer for storing draw commands is full or failed to allocate more memory
/// NK_CONVERT_VERTEX_BUFFER_FULL   | The provided buffer for storing vertices is full or failed to allocate more memory
/// NK_CONVERT_ELEMENT_BUFFER_FULL  | The provided buffer for storing indicies is full or failed to allocate more memory
*/
	NK_API nk_flags nk_convert(struct nk_context*, struct nk_buffer* cmds, struct nk_buffer* vertices, struct nk_buffer* elements, const struct nk_convert_config*);
	/*/// #### nk__draw_begin
	/// Returns a draw vertex command buffer iterator to iterate each the vertex draw command buffer
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// const struct nk_draw_command* nk__draw_begin(const struct nk_context*, const struct nk_buffer*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	/// __buf__     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
	///
	/// Returns vertex draw command pointer pointing to the first command inside the vertex draw command buffer
	*/
	NK_API const struct nk_draw_command* nk__draw_begin(const struct nk_context*, const struct nk_buffer*);
	/*/// #### nk__draw_end
	/// Returns the vertex draw command at the end of the vertex draw command buffer
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// const struct nk_draw_command* nk__draw_end(const struct nk_context *ctx, const struct nk_buffer *buf);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	/// __buf__     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
	///
	/// Returns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer
	*/
	NK_API const struct nk_draw_command* nk__draw_end(const struct nk_context*, const struct nk_buffer*);
	/*/// #### nk__draw_next
	/// Increments the vertex draw command buffer iterator
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// const struct nk_draw_command* nk__draw_next(const struct nk_draw_command*, const struct nk_buffer*, const struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __cmd__     | Must point to an previously either by `nk__draw_begin` or `nk__draw_next` returned vertex draw command
	/// __buf__     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	///
	/// Returns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer
	*/
	NK_API const struct nk_draw_command* nk__draw_next(const struct nk_draw_command*, const struct nk_buffer*, const struct nk_context*);
	/*/// #### nk_draw_foreach
	/// Iterates over each vertex draw command inside a vertex draw command buffer
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_draw_foreach(cmd,ctx, b)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __cmd__     | `nk_draw_command`iterator set to NULL
	/// __buf__     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
	/// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
	*/
#define nk_draw_foreach(cmd,ctx, b) for((cmd)=nk__draw_begin(ctx, b); (cmd)!=0; (cmd)=nk__draw_next(cmd, b, ctx))
#endif
	/* =============================================================================
	 *
	 *                                  WINDOW
	 *
	 * =============================================================================
	/// ### Window
	/// Windows are the main persistent state used inside nuklear and are life time
	/// controlled by simply "retouching" (i.e. calling) each window each frame.
	/// All widgets inside nuklear can only be added inside function pair `nk_begin_xxx`
	/// and `nk_end`. Calling any widgets outside these two functions will result in an
	/// assert in debug or no state change in release mode.<br /><br />
	///
	/// Each window holds frame persistent state like position, size, flags, state tables,
	/// and some garbage collected internal persistent widget state. Each window
	/// is linked into a window stack list which determines the drawing and overlapping
	/// order. The topmost window thereby is the currently active window.<br /><br />
	///
	/// To change window position inside the stack occurs either automatically by
	/// user input by being clicked on or programmatically by calling `nk_window_focus`.
	/// Windows by default are visible unless explicitly being defined with flag
	/// `NK_WINDOW_HIDDEN`, the user clicked the close button on windows with flag
	/// `NK_WINDOW_CLOSABLE` or if a window was explicitly hidden by calling
	/// `nk_window_show`. To explicitly close and destroy a window call `nk_window_close`.<br /><br />
	///
	/// #### Usage
	/// To create and keep a window you have to call one of the two `nk_begin_xxx`
	/// functions to start window declarations and `nk_end` at the end. Furthermore it
	/// is recommended to check the return value of `nk_begin_xxx` and only process
	/// widgets inside the window if the value is not 0. Either way you have to call
	/// `nk_end` at the end of window declarations. Furthermore, do not attempt to
	/// nest `nk_begin_xxx` calls which will hopefully result in an assert or if not
	/// in a segmentation fault.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// if (nk_begin_xxx(...) {
	///     // [... widgets ...]
	/// }
	/// nk_end(ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// In the grand concept window and widget declarations need to occur after input
	/// handling and before drawing to screen. Not doing so can result in higher
	/// latency or at worst invalid behavior. Furthermore make sure that `nk_clear`
	/// is called at the end of the frame. While nuklear's default platform backends
	/// already call `nk_clear` for you if you write your own backend not calling
	/// `nk_clear` can cause asserts or even worse undefined behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_context ctx;
	/// nk_init_xxx(&ctx, ...);
	/// while (1) {
	///     Event evt;
	///     nk_input_begin(&ctx);
	///     while (GetEvent(&evt)) {
	///         if (evt.type == MOUSE_MOVE)
	///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	///         else if (evt.type == [...]) {
	///             nk_input_xxx(...);
	///         }
	///     }
	///     nk_input_end(&ctx);
	///
	///     if (nk_begin_xxx(...) {
	///         //[...]
	///     }
	///     nk_end(ctx);
	///
	///     const struct nk_command *cmd = 0;
	///     nk_foreach(cmd, &ctx) {
	///     case NK_COMMAND_LINE:
	///         your_draw_line_function(...)
	///         break;
	///     case NK_COMMAND_RECT
	///         your_draw_rect_function(...)
	///         break;
	///     case //...:
	///         //[...]
	///     }
	///     nk_clear(&ctx);
	/// }
	/// nk_free(&ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// #### Reference
	/// Function                            | Description
	/// ------------------------------------|----------------------------------------
	/// nk_begin                            | Starts a new window; needs to be called every frame for every window (unless hidden) or otherwise the window gets removed
	/// nk_begin_titled                     | Extended window start with separated title and identifier to allow multiple windows with same name but not title
	/// nk_end                              | Needs to be called at the end of the window building process to process scaling, scrollbars and general cleanup
	//
	/// nk_window_find                      | Finds and returns the window with give name
	/// nk_window_get_bounds                | Returns a rectangle with screen position and size of the currently processed window.
	/// nk_window_get_position              | Returns the position of the currently processed window
	/// nk_window_get_size                  | Returns the size with width and height of the currently processed window
	/// nk_window_get_width                 | Returns the width of the currently processed window
	/// nk_window_get_height                | Returns the height of the currently processed window
	/// nk_window_get_panel                 | Returns the underlying panel which contains all processing state of the current window
	/// nk_window_get_content_region        | Returns the position and size of the currently visible and non-clipped space inside the currently processed window
	/// nk_window_get_content_region_min    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window
	/// nk_window_get_content_region_max    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window
	/// nk_window_get_content_region_size   | Returns the size of the currently visible and non-clipped space inside the currently processed window
	/// nk_window_get_canvas                | Returns the draw command buffer. Can be used to draw custom widgets
	/// nk_window_has_focus                 | Returns if the currently processed window is currently active
	/// nk_window_is_collapsed              | Returns if the window with given name is currently minimized/collapsed
	/// nk_window_is_closed                 | Returns if the currently processed window was closed
	/// nk_window_is_hidden                 | Returns if the currently processed window was hidden
	/// nk_window_is_active                 | Same as nk_window_has_focus for some reason
	/// nk_window_is_hovered                | Returns if the currently processed window is currently being hovered by mouse
	/// nk_window_is_any_hovered            | Return if any window currently hovered
	/// nk_item_is_any_active               | Returns if any window or widgets is currently hovered or active
	//
	/// nk_window_set_bounds                | Updates position and size of the currently processed window
	/// nk_window_set_position              | Updates position of the currently process window
	/// nk_window_set_size                  | Updates the size of the currently processed window
	/// nk_window_set_focus                 | Set the currently processed window as active window
	//
	/// nk_window_close                     | Closes the window with given window name which deletes the window at the end of the frame
	/// nk_window_collapse                  | Collapses the window with given window name
	/// nk_window_collapse_if               | Collapses the window with given window name if the given condition was met
	/// nk_window_show                      | Hides a visible or reshows a hidden window
	/// nk_window_show_if                   | Hides/shows a window depending on condition
	*/
	/*
	/// #### nk_panel_flags
	/// Flag                        | Description
	/// ----------------------------|----------------------------------------
	/// NK_WINDOW_BORDER            | Draws a border around the window to visually separate window from the background
	/// NK_WINDOW_MOVABLE           | The movable flag indicates that a window can be moved by user input or by dragging the window header
	/// NK_WINDOW_SCALABLE          | The scalable flag indicates that a window can be scaled by user input by dragging a scaler icon at the button of the window
	/// NK_WINDOW_CLOSABLE          | Adds a closable icon into the header
	/// NK_WINDOW_MINIMIZABLE       | Adds a minimize icon into the header
	/// NK_WINDOW_NO_SCROLLBAR      | Removes the scrollbar from the window
	/// NK_WINDOW_TITLE             | Forces a header at the top at the window showing the title
	/// NK_WINDOW_SCROLL_AUTO_HIDE  | Automatically hides the window scrollbar if no user interaction: also requires delta time in `nk_context` to be set each frame
	/// NK_WINDOW_BACKGROUND        | Always keep window in the background
	/// NK_WINDOW_SCALE_LEFT        | Puts window scaler in the left-bottom corner instead right-bottom
	/// NK_WINDOW_NO_INPUT          | Prevents window of scaling, moving or getting focus
	///
	/// #### nk_collapse_states
	/// State           | Description
	/// ----------------|-----------------------------------------------------------
	/// __NK_MINIMIZED__| UI section is collased and not visibile until maximized
	/// __NK_MAXIMIZED__| UI section is extended and visibile until minimized
	/// <br /><br />
	*/
	enum nk_panel_flags {
		NK_WINDOW_BORDER = NK_FLAG(0),
		NK_WINDOW_MOVABLE = NK_FLAG(1),
		NK_WINDOW_SCALABLE = NK_FLAG(2),
		NK_WINDOW_CLOSABLE = NK_FLAG(3),
		NK_WINDOW_MINIMIZABLE = NK_FLAG(4),
		NK_WINDOW_NO_SCROLLBAR = NK_FLAG(5),
		NK_WINDOW_TITLE = NK_FLAG(6),
		NK_WINDOW_SCROLL_AUTO_HIDE = NK_FLAG(7),
		NK_WINDOW_BACKGROUND = NK_FLAG(8),
		NK_WINDOW_SCALE_LEFT = NK_FLAG(9),
		NK_WINDOW_NO_INPUT = NK_FLAG(10)
	};
	/*/// #### nk_begin
	/// Starts a new window; needs to be called every frame for every
	/// window (unless hidden) or otherwise the window gets removed
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_begin(struct nk_context *ctx, const char *title, struct nk_rect bounds, nk_flags flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __title__   | Window title and identifier. Needs to be persistent over frames to identify the window
	/// __bounds__  | Initial position and window size. However if you do not define `NK_WINDOW_SCALABLE` or `NK_WINDOW_MOVABLE` you can set window position and size every frame
	/// __flags__   | Window flags defined in the nk_panel_flags section with a number of different window behaviors
	///
	/// Returns `true(1)` if the window can be filled up with widgets from this point
	/// until `nk_end` or `false(0)` otherwise for example if minimized
	*/
	NK_API int nk_begin(struct nk_context* ctx, const char* title, struct nk_rect bounds, nk_flags flags);
	/*/// #### nk_begin_titled
	/// Extended window start with separated title and identifier to allow multiple
	/// windows with same name but not title
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_begin_titled(struct nk_context *ctx, const char *name, const char *title, struct nk_rect bounds, nk_flags flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Window identifier. Needs to be persistent over frames to identify the window
	/// __title__   | Window title displayed inside header if flag `NK_WINDOW_TITLE` or either `NK_WINDOW_CLOSABLE` or `NK_WINDOW_MINIMIZED` was set
	/// __bounds__  | Initial position and window size. However if you do not define `NK_WINDOW_SCALABLE` or `NK_WINDOW_MOVABLE` you can set window position and size every frame
	/// __flags__   | Window flags defined in the nk_panel_flags section with a number of different window behaviors
	///
	/// Returns `true(1)` if the window can be filled up with widgets from this point
	/// until `nk_end` or `false(0)` otherwise for example if minimized
	*/
	NK_API int
		nk_begin_titled(struct nk_context* ctx, const char* name, const char* title, struct nk_rect bounds, nk_flags flags);
	/*/// #### nk_end
	/// Needs to be called at the end of the window building process to process scaling, scrollbars and general cleanup.
	/// All widget calls after this functions will result in asserts or no state changes
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_end(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	*/
	NK_API void nk_end(struct nk_context* ctx);
	/*/// #### nk_window_find
	/// Finds and returns a window from passed name
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_end(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Window identifier
	///
	/// Returns a `nk_window` struct pointing to the identified window or NULL if
	/// no window with given name was found
	*/
	NK_API struct nk_window* nk_window_find(struct nk_context* ctx, const char* name);
	/*/// #### nk_window_get_bounds
	///
	/// Returns a rectangle with screen position and size of the currently processed window
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_window_get_bounds(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns a `nk_rect` struct with window upper left window position and size
	*/
	NK_API struct nk_rect nk_window_get_bounds(const struct nk_context* ctx);
	/*/// #### nk_window_get_bounds
	///
	/// Returns the position of the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_window_get_position(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns a `nk_vec2` struct with window upper left position
	*/
	NK_API struct nk_vec2 nk_window_get_position(const struct nk_context* ctx);
	/*/// #### nk_window_get_size
	///
	/// Returns the size with width and height of the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_window_get_size(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns a `nk_vec2` struct with window width and height
	*/
	NK_API struct nk_vec2 nk_window_get_size(const struct nk_context*);
	/*/// #### nk_window_get_width
	///
	/// Returns the width of the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// float nk_window_get_width(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns the current window width
	*/
	NK_API float nk_window_get_width(const struct nk_context*);
	/*/// #### nk_window_get_height
	///
	/// Returns the height of the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// float nk_window_get_height(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns the current window height
	*/
	NK_API float nk_window_get_height(const struct nk_context*);
	/*/// #### nk_window_get_panel
	///
	/// Returns the underlying panel which contains all processing state of the current window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// !!! WARNING
	///     Do not keep the returned panel pointer around it is only valid until `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_panel* nk_window_get_panel(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns a pointer to window internal `nk_panel` state.
	*/
	NK_API struct nk_panel* nk_window_get_panel(struct nk_context*);
	/*/// #### nk_window_get_content_region
	///
	/// Returns the position and size of the currently visible and non-clipped space
	/// inside the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_window_get_content_region(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `nk_rect` struct with screen position and size (no scrollbar offset)
	/// of the visible space inside the current window
	*/
	NK_API struct nk_rect nk_window_get_content_region(struct nk_context*);
	/*/// #### nk_window_get_content_region_min
	///
	/// Returns the upper left position of the currently visible and non-clipped
	/// space inside the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_window_get_content_region_min(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// returns `nk_vec2` struct with  upper left screen position (no scrollbar offset)
	/// of the visible space inside the current window
	*/
	NK_API struct nk_vec2 nk_window_get_content_region_min(struct nk_context*);
	/*/// #### nk_window_get_content_region_max
	///
	/// Returns the lower right screen position of the currently visible and
	/// non-clipped space inside the currently processed window.
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_window_get_content_region_max(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `nk_vec2` struct with lower right screen position (no scrollbar offset)
	/// of the visible space inside the current window
	*/
	NK_API struct nk_vec2 nk_window_get_content_region_max(struct nk_context*);
	/*/// #### nk_window_get_content_region_size
	///
	/// Returns the size of the currently visible and non-clipped space inside the
	/// currently processed window
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_window_get_content_region_size(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `nk_vec2` struct with size the visible space inside the current window
	*/
	NK_API struct nk_vec2 nk_window_get_content_region_size(struct nk_context*);
	/*/// #### nk_window_get_canvas
	/// Returns the draw command buffer. Can be used to draw custom widgets
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// !!! WARNING
	///     Do not keep the returned command buffer pointer around it is only valid until `nk_end`
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_command_buffer* nk_window_get_canvas(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns a pointer to window internal `nk_command_buffer` struct used as
	/// drawing canvas. Can be used to do custom drawing.
	*/
	NK_API struct nk_command_buffer* nk_window_get_canvas(struct nk_context*);
	/*/// #### nk_window_has_focus
	/// Returns if the currently processed window is currently active
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_has_focus(const struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `false(0)` if current window is not active or `true(1)` if it is
	*/
	NK_API int nk_window_has_focus(const struct nk_context*);
	/*/// #### nk_window_is_hovered
	/// Return if the current window is being hovered
	/// !!! WARNING
	///     Only call this function between calls `nk_begin_xxx` and `nk_end`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_hovered(struct nk_context *ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `true(1)` if current window is hovered or `false(0)` otherwise
	*/
	NK_API int nk_window_is_hovered(struct nk_context*);
	/*/// #### nk_window_is_collapsed
	/// Returns if the window with given name is currently minimized/collapsed
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_collapsed(struct nk_context *ctx, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of window you want to check if it is collapsed
	///
	/// Returns `true(1)` if current window is minimized and `false(0)` if window not
	/// found or is not minimized
	*/
	NK_API int nk_window_is_collapsed(struct nk_context* ctx, const char* name);
	/*/// #### nk_window_is_closed
	/// Returns if the window with given name was closed by calling `nk_close`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_closed(struct nk_context *ctx, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of window you want to check if it is closed
	///
	/// Returns `true(1)` if current window was closed or `false(0)` window not found or not closed
	*/
	NK_API int nk_window_is_closed(struct nk_context*, const char*);
	/*/// #### nk_window_is_hidden
	/// Returns if the window with given name is hidden
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_hidden(struct nk_context *ctx, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of window you want to check if it is hidden
	///
	/// Returns `true(1)` if current window is hidden or `false(0)` window not found or visible
	*/
	NK_API int nk_window_is_hidden(struct nk_context*, const char*);
	/*/// #### nk_window_is_active
	/// Same as nk_window_has_focus for some reason
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_active(struct nk_context *ctx, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of window you want to check if it is active
	///
	/// Returns `true(1)` if current window is active or `false(0)` window not found or not active
	*/
	NK_API int nk_window_is_active(struct nk_context*, const char*);
	/*/// #### nk_window_is_any_hovered
	/// Returns if the any window is being hovered
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_window_is_any_hovered(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `true(1)` if any window is hovered or `false(0)` otherwise
	*/
	NK_API int nk_window_is_any_hovered(struct nk_context*);
	/*/// #### nk_item_is_any_active
	/// Returns if the any window is being hovered or any widget is currently active.
	/// Can be used to decide if input should be processed by UI or your specific input handling.
	/// Example could be UI and 3D camera to move inside a 3D space.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_item_is_any_active(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	///
	/// Returns `true(1)` if any window is hovered or any item is active or `false(0)` otherwise
	*/
	NK_API int nk_item_is_any_active(struct nk_context*);
	/*/// #### nk_window_set_bounds
	/// Updates position and size of window with passed in name
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_set_bounds(struct nk_context*, const char *name, struct nk_rect bounds);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to modify both position and size
	/// __bounds__  | Must point to a `nk_rect` struct with the new position and size
	*/
	NK_API void nk_window_set_bounds(struct nk_context*, const char* name, struct nk_rect bounds);
	/*/// #### nk_window_set_position
	/// Updates position of window with passed name
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_set_position(struct nk_context*, const char *name, struct nk_vec2 pos);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to modify both position
	/// __pos__     | Must point to a `nk_vec2` struct with the new position
	*/
	NK_API void nk_window_set_position(struct nk_context*, const char* name, struct nk_vec2 pos);
	/*/// #### nk_window_set_size
	/// Updates size of window with passed in name
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_set_size(struct nk_context*, const char *name, struct nk_vec2);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to modify both window size
	/// __size__    | Must point to a `nk_vec2` struct with new window size
	*/
	NK_API void nk_window_set_size(struct nk_context*, const char* name, struct nk_vec2);
	/*/// #### nk_window_set_focus
	/// Sets the window with given name as active
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_set_focus(struct nk_context*, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to set focus on
	*/
	NK_API void nk_window_set_focus(struct nk_context*, const char* name);
	/*/// #### nk_window_close
	/// Closes a window and marks it for being freed at the end of the frame
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_close(struct nk_context *ctx, const char *name);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to close
	*/
	NK_API void nk_window_close(struct nk_context* ctx, const char* name);
	/*/// #### nk_window_collapse
	/// Updates collapse state of a window with given name
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_collapse(struct nk_context*, const char *name, enum nk_collapse_states state);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to close
	/// __state__   | value out of nk_collapse_states section
	*/
	NK_API void nk_window_collapse(struct nk_context*, const char* name, enum nk_collapse_states state);
	/*/// #### nk_window_collapse_if
	/// Updates collapse state of a window with given name if given condition is met
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_collapse_if(struct nk_context*, const char *name, enum nk_collapse_states, int cond);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to either collapse or maximize
	/// __state__   | value out of nk_collapse_states section the window should be put into
	/// __cond__    | condition that has to be met to actually commit the collapse state change
	*/
	NK_API void nk_window_collapse_if(struct nk_context*, const char* name, enum nk_collapse_states, int cond);
	/*/// #### nk_window_show
	/// updates visibility state of a window with given name
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_show(struct nk_context*, const char *name, enum nk_show_states);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to either collapse or maximize
	/// __state__   | state with either visible or hidden to modify the window with
	*/
	NK_API void nk_window_show(struct nk_context*, const char* name, enum nk_show_states);
	/*/// #### nk_window_show_if
	/// Updates visibility state of a window with given name if a given condition is met
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_window_show_if(struct nk_context*, const char *name, enum nk_show_states, int cond);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __name__    | Identifier of the window to either hide or show
	/// __state__   | state with either visible or hidden to modify the window with
	/// __cond__    | condition that has to be met to actually commit the visbility state change
	*/
	NK_API void nk_window_show_if(struct nk_context*, const char* name, enum nk_show_states, int cond);
	/* =============================================================================
	 *
	 *                                  LAYOUT
	 *
	 * =============================================================================
	/// ### Layouting
	/// Layouting in general describes placing widget inside a window with position and size.
	/// While in this particular implementation there are five different APIs for layouting
	/// each with different trade offs between control and ease of use. <br /><br />
	///
	/// All layouting methods in this library are based around the concept of a row.
	/// A row has a height the window content grows by and a number of columns and each
	/// layouting method specifies how each widget is placed inside the row.
	/// After a row has been allocated by calling a layouting functions and then
	/// filled with widgets will advance an internal pointer over the allocated row. <br /><br />
	///
	/// To actually define a layout you just call the appropriate layouting function
	/// and each subsequent widget call will place the widget as specified. Important
	/// here is that if you define more widgets then columns defined inside the layout
	/// functions it will allocate the next row without you having to make another layouting <br /><br />
	/// call.
	///
	/// Biggest limitation with using all these APIs outside the `nk_layout_space_xxx` API
	/// is that you have to define the row height for each. However the row height
	/// often depends on the height of the font. <br /><br />
	///
	/// To fix that internally nuklear uses a minimum row height that is set to the
	/// height plus padding of currently active font and overwrites the row height
	/// value if zero. <br /><br />
	///
	/// If you manually want to change the minimum row height then
	/// use nk_layout_set_min_row_height, and use nk_layout_reset_min_row_height to
	/// reset it back to be derived from font height. <br /><br />
	///
	/// Also if you change the font in nuklear it will automatically change the minimum
	/// row height for you and. This means if you change the font but still want
	/// a minimum row height smaller than the font you have to repush your value. <br /><br />
	///
	/// For actually more advanced UI I would even recommend using the `nk_layout_space_xxx`
	/// layouting method in combination with a cassowary constraint solver (there are
	/// some versions on github with permissive license model) to take over all control over widget
	/// layouting yourself. However for quick and dirty layouting using all the other layouting
	/// functions should be fine.
	///
	/// #### Usage
	/// 1.  __nk_layout_row_dynamic__<br /><br />
	///     The easiest layouting function is `nk_layout_row_dynamic`. It provides each
	///     widgets with same horizontal space inside the row and dynamically grows
	///     if the owning window grows in width. So the number of columns dictates
	///     the size of each widget dynamically by formula:
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     widget_width = (window_width - padding - spacing) * (1/colum_count)
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	///     Just like all other layouting APIs if you define more widget than columns this
	///     library will allocate a new row and keep all layouting parameters previously
	///     defined.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // first row with height: 30 composed of two widgets
	///         nk_layout_row_dynamic(&ctx, 30, 2);
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // second row with same parameter as defined above
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // third row uses 0 for height which will use auto layouting
	///         nk_layout_row_dynamic(&ctx, 0, 2);
	///         nk_widget(...);
	///         nk_widget(...);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// 2.  __nk_layout_row_static__<br /><br />
	///     Another easy layouting function is `nk_layout_row_static`. It provides each
	///     widget with same horizontal pixel width inside the row and does not grow
	///     if the owning window scales smaller or bigger.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // first row with height: 30 composed of two widgets with width: 80
	///         nk_layout_row_static(&ctx, 30, 80, 2);
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // second row with same parameter as defined above
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // third row uses 0 for height which will use auto layouting
	///         nk_layout_row_static(&ctx, 0, 80, 2);
	///         nk_widget(...);
	///         nk_widget(...);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// 3.  __nk_layout_row_xxx__<br /><br />
	///     A little bit more advanced layouting API are functions `nk_layout_row_begin`,
	///     `nk_layout_row_push` and `nk_layout_row_end`. They allow to directly
	///     specify each column pixel or window ratio in a row. It supports either
	///     directly setting per column pixel width or widget window ratio but not
	///     both. Furthermore it is a immediate mode API so each value is directly
	///     pushed before calling a widget. Therefore the layout is not automatically
	///     repeating like the last two layouting functions.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // first row with height: 25 composed of two widgets with width 60 and 40
	///         nk_layout_row_begin(ctx, NK_STATIC, 25, 2);
	///         nk_layout_row_push(ctx, 60);
	///         nk_widget(...);
	///         nk_layout_row_push(ctx, 40);
	///         nk_widget(...);
	///         nk_layout_row_end(ctx);
	///         //
	///         // second row with height: 25 composed of two widgets with window ratio 0.25 and 0.75
	///         nk_layout_row_begin(ctx, NK_DYNAMIC, 25, 2);
	///         nk_layout_row_push(ctx, 0.25f);
	///         nk_widget(...);
	///         nk_layout_row_push(ctx, 0.75f);
	///         nk_widget(...);
	///         nk_layout_row_end(ctx);
	///         //
	///         // third row with auto generated height: composed of two widgets with window ratio 0.25 and 0.75
	///         nk_layout_row_begin(ctx, NK_DYNAMIC, 0, 2);
	///         nk_layout_row_push(ctx, 0.25f);
	///         nk_widget(...);
	///         nk_layout_row_push(ctx, 0.75f);
	///         nk_widget(...);
	///         nk_layout_row_end(ctx);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// 4.  __nk_layout_row__<br /><br />
	///     The array counterpart to API nk_layout_row_xxx is the single nk_layout_row
	///     functions. Instead of pushing either pixel or window ratio for every widget
	///     it allows to define it by array. The trade of for less control is that
	///     `nk_layout_row` is automatically repeating. Otherwise the behavior is the
	///     same.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // two rows with height: 30 composed of two widgets with width 60 and 40
	///         const float size[] = {60,40};
	///         nk_layout_row(ctx, NK_STATIC, 30, 2, ratio);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // two rows with height: 30 composed of two widgets with window ratio 0.25 and 0.75
	///         const float ratio[] = {0.25, 0.75};
	///         nk_layout_row(ctx, NK_DYNAMIC, 30, 2, ratio);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///         //
	///         // two rows with auto generated height composed of two widgets with window ratio 0.25 and 0.75
	///         const float ratio[] = {0.25, 0.75};
	///         nk_layout_row(ctx, NK_DYNAMIC, 30, 2, ratio);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// 5.  __nk_layout_row_template_xxx__<br /><br />
	///     The most complex and second most flexible API is a simplified flexbox version without
	///     line wrapping and weights for dynamic widgets. It is an immediate mode API but
	///     unlike `nk_layout_row_xxx` it has auto repeat behavior and needs to be called
	///     before calling the templated widgets.
	///     The row template layout has three different per widget size specifier. The first
	///     one is the `nk_layout_row_template_push_static`  with fixed widget pixel width.
	///     They do not grow if the row grows and will always stay the same.
	///     The second size specifier is `nk_layout_row_template_push_variable`
	///     which defines a minimum widget size but it also can grow if more space is available
	///     not taken by other widgets.
	///     Finally there are dynamic widgets with `nk_layout_row_template_push_dynamic`
	///     which are completely flexible and unlike variable widgets can even shrink
	///     to zero if not enough space is provided.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // two rows with height: 30 composed of three widgets
	///         nk_layout_row_template_begin(ctx, 30);
	///         nk_layout_row_template_push_dynamic(ctx);
	///         nk_layout_row_template_push_variable(ctx, 80);
	///         nk_layout_row_template_push_static(ctx, 80);
	///         nk_layout_row_template_end(ctx);
	///         //
	///         // first row
	///         nk_widget(...); // dynamic widget can go to zero if not enough space
	///         nk_widget(...); // variable widget with min 80 pixel but can grow bigger if enough space
	///         nk_widget(...); // static widget with fixed 80 pixel width
	///         //
	///         // second row same layout
	///         nk_widget(...);
	///         nk_widget(...);
	///         nk_widget(...);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// 6.  __nk_layout_space_xxx__<br /><br />
	///     Finally the most flexible API directly allows you to place widgets inside the
	///     window. The space layout API is an immediate mode API which does not support
	///     row auto repeat and directly sets position and size of a widget. Position
	///     and size hereby can be either specified as ratio of allocated space or
	///     allocated space local position and pixel size. Since this API is quite
	///     powerful there are a number of utility functions to get the available space
	///     and convert between local allocated space and screen space.
	///
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	///     if (nk_begin_xxx(...) {
	///         // static row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)
	///         nk_layout_space_begin(ctx, NK_STATIC, 500, INT_MAX);
	///         nk_layout_space_push(ctx, nk_rect(0,0,150,200));
	///         nk_widget(...);
	///         nk_layout_space_push(ctx, nk_rect(200,200,100,200));
	///         nk_widget(...);
	///         nk_layout_space_end(ctx);
	///         //
	///         // dynamic row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)
	///         nk_layout_space_begin(ctx, NK_DYNAMIC, 500, INT_MAX);
	///         nk_layout_space_push(ctx, nk_rect(0.5,0.5,0.1,0.1));
	///         nk_widget(...);
	///         nk_layout_space_push(ctx, nk_rect(0.7,0.6,0.1,0.1));
	///         nk_widget(...);
	///     }
	///     nk_end(...);
	///     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// #### Reference
	/// Function                                | Description
	/// ----------------------------------------|------------------------------------
	/// nk_layout_set_min_row_height            | Set the currently used minimum row height to a specified value
	/// nk_layout_reset_min_row_height          | Resets the currently used minimum row height to font height
	/// nk_layout_widget_bounds                 | Calculates current width a static layout row can fit inside a window
	/// nk_layout_ratio_from_pixel              | Utility functions to calculate window ratio from pixel size
	//
	/// nk_layout_row_dynamic                   | Current layout is divided into n same sized growing columns
	/// nk_layout_row_static                    | Current layout is divided into n same fixed sized columns
	/// nk_layout_row_begin                     | Starts a new row with given height and number of columns
	/// nk_layout_row_push                      | Pushes another column with given size or window ratio
	/// nk_layout_row_end                       | Finished previously started row
	/// nk_layout_row                           | Specifies row columns in array as either window ratio or size
	//
	/// nk_layout_row_template_begin            | Begins the row template declaration
	/// nk_layout_row_template_push_dynamic     | Adds a dynamic column that dynamically grows and can go to zero if not enough space
	/// nk_layout_row_template_push_variable    | Adds a variable column that dynamically grows but does not shrink below specified pixel width
	/// nk_layout_row_template_push_static      | Adds a static column that does not grow and will always have the same size
	/// nk_layout_row_template_end              | Marks the end of the row template
	//
	/// nk_layout_space_begin                   | Begins a new layouting space that allows to specify each widgets position and size
	/// nk_layout_space_push                    | Pushes position and size of the next widget in own coordinate space either as pixel or ratio
	/// nk_layout_space_end                     | Marks the end of the layouting space
	//
	/// nk_layout_space_bounds                  | Callable after nk_layout_space_begin and returns total space allocated
	/// nk_layout_space_to_screen               | Converts vector from nk_layout_space coordinate space into screen space
	/// nk_layout_space_to_local                | Converts vector from screen space into nk_layout_space coordinates
	/// nk_layout_space_rect_to_screen          | Converts rectangle from nk_layout_space coordinate space into screen space
	/// nk_layout_space_rect_to_local           | Converts rectangle from screen space into nk_layout_space coordinates
	*/
	/*/// #### nk_layout_set_min_row_height
	/// Sets the currently used minimum row height.
	/// !!! WARNING
	///     The passed height needs to include both your preferred row height
	///     as well as padding. No internal padding is added.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_set_min_row_height(struct nk_context*, float height);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __height__  | New minimum row height to be used for auto generating the row height
	*/
	NK_API void nk_layout_set_min_row_height(struct nk_context*, float height);
	/*/// #### nk_layout_reset_min_row_height
	/// Reset the currently used minimum row height back to `font_height + text_padding + padding`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_reset_min_row_height(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	*/
	NK_API void nk_layout_reset_min_row_height(struct nk_context*);
	/*/// #### nk_layout_widget_bounds
	/// Returns the width of the next row allocate by one of the layouting functions
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_layout_widget_bounds(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	///
	/// Return `nk_rect` with both position and size of the next row
	*/
	NK_API struct nk_rect nk_layout_widget_bounds(struct nk_context*);
	/*/// #### nk_layout_ratio_from_pixel
	/// Utility functions to calculate window ratio from pixel size
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// float nk_layout_ratio_from_pixel(struct nk_context*, float pixel_width);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __pixel__   | Pixel_width to convert to window ratio
	///
	/// Returns `nk_rect` with both position and size of the next row
	*/
	NK_API float nk_layout_ratio_from_pixel(struct nk_context*, float pixel_width);
	/*/// #### nk_layout_row_dynamic
	/// Sets current row layout to share horizontal space
	/// between @cols number of widgets evenly. Once called all subsequent widget
	/// calls greater than @cols will allocate a new row with same layout.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_dynamic(struct nk_context *ctx, float height, int cols);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	/// __columns__ | Number of widget inside row
	*/
	NK_API void nk_layout_row_dynamic(struct nk_context* ctx, float height, int cols);
	/*/// #### nk_layout_row_dynamic
	/// Sets current row layout to fill @cols number of widgets
	/// in row with same @item_width horizontal size. Once called all subsequent widget
	/// calls greater than @cols will allocate a new row with same layout.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_static(struct nk_context *ctx, float height, int item_width, int cols);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	/// __width__   | Holds pixel width of each widget in the row
	/// __columns__ | Number of widget inside row
	*/
	NK_API void nk_layout_row_static(struct nk_context* ctx, float height, int item_width, int cols);
	/*/// #### nk_layout_row_begin
	/// Starts a new dynamic or fixed row with given height and columns.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_begin(struct nk_context *ctx, enum nk_layout_format fmt, float row_height, int cols);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __fmt__     | either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns
	/// __height__  | holds height of each widget in row or zero for auto layouting
	/// __columns__ | Number of widget inside row
	*/
	NK_API void nk_layout_row_begin(struct nk_context* ctx, enum nk_layout_format fmt, float row_height, int cols);
	/*/// #### nk_layout_row_push
	/// Specifies either window ratio or width of a single column
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_push(struct nk_context*, float value);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __value__   | either a window ratio or fixed width depending on @fmt in previous `nk_layout_row_begin` call
	*/
	NK_API void nk_layout_row_push(struct nk_context*, float value);
	/*/// #### nk_layout_row_end
	/// Finished previously started row
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_end(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	*/
	NK_API void nk_layout_row_end(struct nk_context*);
	/*/// #### nk_layout_row
	/// Specifies row columns in array as either window ratio or size
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row(struct nk_context*, enum nk_layout_format, float height, int cols, const float *ratio);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __fmt__     | Either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	/// __columns__ | Number of widget inside row
	*/
	NK_API void nk_layout_row(struct nk_context*, enum nk_layout_format, float height, int cols, const float* ratio);
	/*/// #### nk_layout_row_template_begin
	/// Begins the row template declaration
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_template_begin(struct nk_context*, float row_height);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	*/
	NK_API void nk_layout_row_template_begin(struct nk_context*, float row_height);
	/*/// #### nk_layout_row_template_push_dynamic
	/// Adds a dynamic column that dynamically grows and can go to zero if not enough space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_template_push_dynamic(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	*/
	NK_API void nk_layout_row_template_push_dynamic(struct nk_context*);
	/*/// #### nk_layout_row_template_push_variable
	/// Adds a variable column that dynamically grows but does not shrink below specified pixel width
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_template_push_variable(struct nk_context*, float min_width);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __width__   | Holds the minimum pixel width the next column must always be
	*/
	NK_API void nk_layout_row_template_push_variable(struct nk_context*, float min_width);
	/*/// #### nk_layout_row_template_push_static
	/// Adds a static column that does not grow and will always have the same size
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_template_push_static(struct nk_context*, float width);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __width__   | Holds the absolute pixel width value the next column must be
	*/
	NK_API void nk_layout_row_template_push_static(struct nk_context*, float width);
	/*/// #### nk_layout_row_template_end
	/// Marks the end of the row template
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_row_template_end(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	*/
	NK_API void nk_layout_row_template_end(struct nk_context*);
	/*/// #### nk_layout_space_begin
	/// Begins a new layouting space that allows to specify each widgets position and size.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_space_begin(struct nk_context*, enum nk_layout_format, float height, int widget_count);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`
	/// __fmt__     | Either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns
	/// __height__  | Holds height of each widget in row or zero for auto layouting
	/// __columns__ | Number of widgets inside row
	*/
	NK_API void nk_layout_space_begin(struct nk_context*, enum nk_layout_format, float height, int widget_count);
	/*/// #### nk_layout_space_push
	/// Pushes position and size of the next widget in own coordinate space either as pixel or ratio
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_space_push(struct nk_context *ctx, struct nk_rect bounds);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	/// __bounds__  | Position and size in laoyut space local coordinates
	*/
	NK_API void nk_layout_space_push(struct nk_context*, struct nk_rect bounds);
	/*/// #### nk_layout_space_end
	/// Marks the end of the layout space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_layout_space_end(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	*/
	NK_API void nk_layout_space_end(struct nk_context*);
	/*/// #### nk_layout_space_bounds
	/// Utility function to calculate total space allocated for `nk_layout_space`
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_layout_space_bounds(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	///
	/// Returns `nk_rect` holding the total space allocated
	*/
	NK_API struct nk_rect nk_layout_space_bounds(struct nk_context*);
	/*/// #### nk_layout_space_to_screen
	/// Converts vector from nk_layout_space coordinate space into screen space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_layout_space_to_screen(struct nk_context*, struct nk_vec2);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	/// __vec__     | Position to convert from layout space into screen coordinate space
	///
	/// Returns transformed `nk_vec2` in screen space coordinates
	*/
	NK_API struct nk_vec2 nk_layout_space_to_screen(struct nk_context*, struct nk_vec2);
	/*/// #### nk_layout_space_to_screen
	/// Converts vector from layout space into screen space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_vec2 nk_layout_space_to_local(struct nk_context*, struct nk_vec2);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	/// __vec__     | Position to convert from screen space into layout coordinate space
	///
	/// Returns transformed `nk_vec2` in layout space coordinates
	*/
	NK_API struct nk_vec2 nk_layout_space_to_local(struct nk_context*, struct nk_vec2);
	/*/// #### nk_layout_space_rect_to_screen
	/// Converts rectangle from screen space into layout space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_layout_space_rect_to_screen(struct nk_context*, struct nk_rect);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	/// __bounds__  | Rectangle to convert from layout space into screen space
	///
	/// Returns transformed `nk_rect` in screen space coordinates
	*/
	NK_API struct nk_rect nk_layout_space_rect_to_screen(struct nk_context*, struct nk_rect);
	/*/// #### nk_layout_space_rect_to_local
	/// Converts rectangle from layout space into screen space
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_rect nk_layout_space_rect_to_local(struct nk_context*, struct nk_rect);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`
	/// __bounds__  | Rectangle to convert from layout space into screen space
	///
	/// Returns transformed `nk_rect` in layout space coordinates
	*/
	NK_API struct nk_rect nk_layout_space_rect_to_local(struct nk_context*, struct nk_rect);
	/* =============================================================================
	 *
	 *                                  GROUP
	 *
	 * =============================================================================
	/// ### Groups
	/// Groups are basically windows inside windows. They allow to subdivide space
	/// in a window to layout widgets as a group. Almost all more complex widget
	/// layouting requirements can be solved using groups and basic layouting
	/// fuctionality. Groups just like windows are identified by an unique name and
	/// internally keep track of scrollbar offsets by default. However additional
	/// versions are provided to directly manage the scrollbar.
	///
	/// #### Usage
	/// To create a group you have to call one of the three `nk_group_begin_xxx`
	/// functions to start group declarations and `nk_group_end` at the end. Furthermore it
	/// is required to check the return value of `nk_group_begin_xxx` and only process
	/// widgets inside the window if the value is not 0.
	/// Nesting groups is possible and even encouraged since many layouting schemes
	/// can only be achieved by nesting. Groups, unlike windows, need `nk_group_end`
	/// to be only called if the corosponding `nk_group_begin_xxx` call does not return 0:
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// if (nk_group_begin_xxx(ctx, ...) {
	///     // [... widgets ...]
	///     nk_group_end(ctx);
	/// }
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// In the grand concept groups can be called after starting a window
	/// with `nk_begin_xxx` and before calling `nk_end`:
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// struct nk_context ctx;
	/// nk_init_xxx(&ctx, ...);
	/// while (1) {
	///     // Input
	///     Event evt;
	///     nk_input_begin(&ctx);
	///     while (GetEvent(&evt)) {
	///         if (evt.type == MOUSE_MOVE)
	///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	///         else if (evt.type == [...]) {
	///             nk_input_xxx(...);
	///         }
	///     }
	///     nk_input_end(&ctx);
	///     //
	///     // Window
	///     if (nk_begin_xxx(...) {
	///         // [...widgets...]
	///         nk_layout_row_dynamic(...);
	///         if (nk_group_begin_xxx(ctx, ...) {
	///             //[... widgets ...]
	///             nk_group_end(ctx);
	///         }
	///     }
	///     nk_end(ctx);
	///     //
	///     // Draw
	///     const struct nk_command *cmd = 0;
	///     nk_foreach(cmd, &ctx) {
	///     switch (cmd->type) {
	///     case NK_COMMAND_LINE:
	///         your_draw_line_function(...)
	///         break;
	///     case NK_COMMAND_RECT
	///         your_draw_rect_function(...)
	///         break;
	///     case ...:
	///         // [...]
	///     }
	//      nk_clear(&ctx);
	/// }
	/// nk_free(&ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	/// #### Reference
	/// Function                        | Description
	/// --------------------------------|-------------------------------------------
	/// nk_group_begin                  | Start a new group with internal scrollbar handling
	/// nk_group_begin_titled           | Start a new group with separeted name and title and internal scrollbar handling
	/// nk_group_end                    | Ends a group. Should only be called if nk_group_begin returned non-zero
	/// nk_group_scrolled_offset_begin  | Start a new group with manual separated handling of scrollbar x- and y-offset
	/// nk_group_scrolled_begin         | Start a new group with manual scrollbar handling
	/// nk_group_scrolled_end           | Ends a group with manual scrollbar handling. Should only be called if nk_group_begin returned non-zero
	*/
	/*/// #### nk_group_begin
	/// Starts a new widget group. Requires a previous layouting function to specify a pos/size.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_group_begin(struct nk_context*, const char *title, nk_flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __title__   | Must be an unique identifier for this group that is also used for the group header
	/// __flags__   | Window flags defined in the nk_panel_flags section with a number of different group behaviors
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_group_begin(struct nk_context*, const char* title, nk_flags);
	/*/// #### nk_group_begin_titled
	/// Starts a new widget group. Requires a previous layouting function to specify a pos/size.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_group_begin_titled(struct nk_context*, const char *name, const char *title, nk_flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __id__      | Must be an unique identifier for this group
	/// __title__   | Group header title
	/// __flags__   | Window flags defined in the nk_panel_flags section with a number of different group behaviors
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_group_begin_titled(struct nk_context*, const char* name, const char* title, nk_flags);
	/*/// #### nk_group_end
	/// Ends a widget group
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_group_end(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	*/
	NK_API void nk_group_end(struct nk_context*);
	/*/// #### nk_group_scrolled_offset_begin
	/// starts a new widget group. requires a previous layouting function to specify
	/// a size. Does not keep track of scrollbar.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_group_scrolled_offset_begin(struct nk_context*, nk_uint *x_offset, nk_uint *y_offset, const char *title, nk_flags flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __x_offset__| Scrollbar x-offset to offset all widgets inside the group horizontally.
	/// __y_offset__| Scrollbar y-offset to offset all widgets inside the group vertically
	/// __title__   | Window unique group title used to both identify and display in the group header
	/// __flags__   | Window flags from the nk_panel_flags section
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_group_scrolled_offset_begin(struct nk_context*, nk_uint* x_offset, nk_uint* y_offset, const char* title,
		nk_flags flags);
	/*/// #### nk_group_scrolled_begin
	/// Starts a new widget group. requires a previous
	/// layouting function to specify a size. Does not keep track of scrollbar.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_group_scrolled_begin(struct nk_context*, struct nk_scroll *off, const char *title, nk_flags);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __off__     | Both x- and y- scroll offset. Allows for manual scrollbar control
	/// __title__   | Window unique group title used to both identify and display in the group header
	/// __flags__   | Window flags from nk_panel_flags section
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_group_scrolled_begin(struct nk_context*, struct nk_scroll* off, const char* title, nk_flags);
	/*/// #### nk_group_scrolled_end
	/// Ends a widget group after calling nk_group_scrolled_offset_begin or nk_group_scrolled_begin.
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_group_scrolled_end(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	*/
	NK_API void nk_group_scrolled_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  TREE
	 *
	 * =============================================================================
	/// ### Tree
	/// Trees represent two different concept. First the concept of a collapsable
	/// UI section that can be either in a hidden or visibile state. They allow the UI
	/// user to selectively minimize the current set of visible UI to comprehend.
	/// The second concept are tree widgets for visual UI representation of trees.<br /><br />
	///
	/// Trees thereby can be nested for tree representations and multiple nested
	/// collapsable UI sections. All trees are started by calling of the
	/// `nk_tree_xxx_push_tree` functions and ended by calling one of the
	/// `nk_tree_xxx_pop_xxx()` functions. Each starting functions takes a title label
	/// and optionally an image to be displayed and the initial collapse state from
	/// the nk_collapse_states section.<br /><br />
	///
	/// The runtime state of the tree is either stored outside the library by the caller
	/// or inside which requires a unique ID. The unique ID can either be generated
	/// automatically from `__FILE__` and `__LINE__` with function `nk_tree_push`,
	/// by `__FILE__` and a user provided ID generated for example by loop index with
	/// function `nk_tree_push_id` or completely provided from outside by user with
	/// function `nk_tree_push_hashed`.
	///
	/// #### Usage
	/// To create a tree you have to call one of the seven `nk_tree_xxx_push_xxx`
	/// functions to start a collapsable UI section and `nk_tree_xxx_pop` to mark the
	/// end.
	/// Each starting function will either return `false(0)` if the tree is collapsed
	/// or hidden and therefore does not need to be filled with content or `true(1)`
	/// if visible and required to be filled.
	///
	/// !!! Note
	///     The tree header does not require and layouting function and instead
	///     calculates a auto height based on the currently used font size
	///
	/// The tree ending functions only need to be called if the tree content is
	/// actually visible. So make sure the tree push function is guarded by `if`
	/// and the pop call is only taken if the tree is visible.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// if (nk_tree_push(ctx, NK_TREE_TAB, "Tree", NK_MINIMIZED)) {
	///     nk_layout_row_dynamic(...);
	///     nk_widget(...);
	///     nk_tree_pop(ctx);
	/// }
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// #### Reference
	/// Function                    | Description
	/// ----------------------------|-------------------------------------------
	/// nk_tree_push                | Start a collapsable UI section with internal state management
	/// nk_tree_push_id             | Start a collapsable UI section with internal state management callable in a look
	/// nk_tree_push_hashed         | Start a collapsable UI section with internal state management with full control over internal unique ID use to store state
	/// nk_tree_image_push          | Start a collapsable UI section with image and label header
	/// nk_tree_image_push_id       | Start a collapsable UI section with image and label header and internal state management callable in a look
	/// nk_tree_image_push_hashed   | Start a collapsable UI section with image and label header and internal state management with full control over internal unique ID use to store state
	/// nk_tree_pop                 | Ends a collapsable UI section
	//
	/// nk_tree_state_push          | Start a collapsable UI section with external state management
	/// nk_tree_state_image_push    | Start a collapsable UI section with image and label header and external state management
	/// nk_tree_state_pop           | Ends a collapsabale UI section
	///
	/// #### nk_tree_type
	/// Flag            | Description
	/// ----------------|----------------------------------------
	/// NK_TREE_NODE    | Highlighted tree header to mark a collapsable UI section
	/// NK_TREE_TAB     | Non-highighted tree header closer to tree representations
	*/
	/*/// #### nk_tree_push
	/// Starts a collapsable UI section with internal state management
	/// !!! WARNING
	///     To keep track of the runtime tree collapsable state this function uses
	///     defines `__FILE__` and `__LINE__` to generate a unique ID. If you want
	///     to call this function in a loop please use `nk_tree_push_id` or
	///     `nk_tree_push_hashed` instead.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_tree_push(ctx, type, title, state)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
#define nk_tree_push(ctx, type, title, state) nk_tree_push_hashed(ctx, type, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),__LINE__)
	/*/// #### nk_tree_push_id
	/// Starts a collapsable UI section with internal state management callable in a look
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_tree_push_id(ctx, type, title, state, id)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	/// __id__      | Loop counter index if this function is called in a loop
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
#define nk_tree_push_id(ctx, type, title, state, id) nk_tree_push_hashed(ctx, type, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),id)
	/*/// #### nk_tree_push_hashed
	/// Start a collapsable UI section with internal state management with full
	/// control over internal unique ID used to store state
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_tree_push_hashed(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	/// __hash__    | Memory block or string to generate the ID from
	/// __len__     | Size of passed memory block or string in __hash__
	/// __seed__    | Seeding value if this function is called in a loop or default to `0`
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int
		nk_tree_push_hashed(struct nk_context*, enum nk_tree_type, const char* title, enum nk_collapse_states initial_state,
			const char* hash, int len, int seed);
	/*/// #### nk_tree_image_push
	/// Start a collapsable UI section with image and label header
	/// !!! WARNING
	///     To keep track of the runtime tree collapsable state this function uses
	///     defines `__FILE__` and `__LINE__` to generate a unique ID. If you want
	///     to call this function in a loop please use `nk_tree_image_push_id` or
	///     `nk_tree_image_push_hashed` instead.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_tree_image_push(ctx, type, img, title, state)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __img__     | Image to display inside the header on the left of the label
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
#define nk_tree_image_push(ctx, type, img, title, state) nk_tree_image_push_hashed(ctx, type, img, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),__LINE__)
	/*/// #### nk_tree_image_push_id
	/// Start a collapsable UI section with image and label header and internal state
	/// management callable in a look
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// #define nk_tree_image_push_id(ctx, type, img, title, state, id)
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __img__     | Image to display inside the header on the left of the label
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	/// __id__      | Loop counter index if this function is called in a loop
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
#define nk_tree_image_push_id(ctx, type, img, title, state, id) nk_tree_image_push_hashed(ctx, type, img, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),id)
	/*/// #### nk_tree_image_push_hashed
	/// Start a collapsable UI section with internal state management with full
	/// control over internal unique ID used to store state
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_tree_image_push_hashed(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __img__     | Image to display inside the header on the left of the label
	/// __title__   | Label printed in the tree header
	/// __state__   | Initial tree state value out of nk_collapse_states
	/// __hash__    | Memory block or string to generate the ID from
	/// __len__     | Size of passed memory block or string in __hash__
	/// __seed__    | Seeding value if this function is called in a loop or default to `0`
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_tree_image_push_hashed(struct nk_context*, enum nk_tree_type, struct nk_image, const char* title,
		enum nk_collapse_states initial_state, const char* hash, int len, int seed);
	/*/// #### nk_tree_pop
	/// Ends a collapsabale UI section
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_tree_pop(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
	*/
	NK_API void nk_tree_pop(struct nk_context*);
	/*/// #### nk_tree_state_push
	/// Start a collapsable UI section with external state management
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_tree_state_push(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states *state);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __title__   | Label printed in the tree header
	/// __state__   | Persistent state to update
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int
		nk_tree_state_push(struct nk_context*, enum nk_tree_type, const char* title, enum nk_collapse_states* state);
	/*/// #### nk_tree_state_image_push
	/// Start a collapsable UI section with image and label header and external state management
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_tree_state_image_push(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states *state);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
	/// __img__     | Image to display inside the header on the left of the label
	/// __type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node
	/// __title__   | Label printed in the tree header
	/// __state__   | Persistent state to update
	///
	/// Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise
	*/
	NK_API int nk_tree_state_image_push(struct nk_context*, enum nk_tree_type, struct nk_image, const char* title,
		enum nk_collapse_states* state);
	/*/// #### nk_tree_state_pop
	/// Ends a collapsabale UI section
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_tree_state_pop(struct nk_context*);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter   | Description
	/// ------------|-----------------------------------------------------------
	/// __ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`
	*/
	NK_API void nk_tree_state_pop(struct nk_context*);

#define nk_tree_element_push(ctx, type, title, state, sel) nk_tree_element_push_hashed(ctx, type, title, state, sel, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),__LINE__)
#define nk_tree_element_push_id(ctx, type, title, state, sel, id) nk_tree_element_push_hashed(ctx, type, title, state, sel, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),id)

	NK_API int nk_tree_element_push_hashed(struct nk_context*, enum nk_tree_type, const char* title,
		enum nk_collapse_states initial_state, int* selected, const char* hash, int len,
		int seed);

	NK_API int nk_tree_element_image_push_hashed(struct nk_context*, enum nk_tree_type, struct nk_image, const char* title,
		enum nk_collapse_states initial_state, int* selected, const char* hash,
		int len, int seed);

	NK_API void nk_tree_element_pop(struct nk_context*);

	/* =============================================================================
	 *
	 *                                  LIST VIEW
	 *
	 * ============================================================================= */
	struct nk_list_view {
		/* public: */
		int begin, end, count;
		/* private: */
		int total_height;
		struct nk_context* ctx;
		nk_uint* scroll_pointer;
		nk_uint scroll_value;
	};

	NK_API int nk_list_view_begin(struct nk_context*, struct nk_list_view* out, const char* id, nk_flags, int row_height,
		int row_count);

	NK_API void nk_list_view_end(struct nk_list_view*);

	/* =============================================================================
	 *
	 *                                  WIDGET
	 *
	 * ============================================================================= */
	enum nk_widget_layout_states {
		NK_WIDGET_INVALID, /* The widget cannot be seen and is completely out of view */
		NK_WIDGET_VALID, /* The widget is completely inside the window and can be updated and drawn */
		NK_WIDGET_ROM /* The widget is partially visible and cannot be updated */
	};
	enum nk_widget_states {
		NK_WIDGET_STATE_MODIFIED = NK_FLAG(1),
		NK_WIDGET_STATE_INACTIVE = NK_FLAG(2), /* widget is neither active nor hovered */
		NK_WIDGET_STATE_ENTERED = NK_FLAG(3), /* widget has been hovered on the current frame */
		NK_WIDGET_STATE_HOVER = NK_FLAG(4), /* widget is being hovered */
		NK_WIDGET_STATE_ACTIVED = NK_FLAG(5),/* widget is currently activated */
		NK_WIDGET_STATE_LEFT = NK_FLAG(6), /* widget is from this frame on not hovered anymore */
		NK_WIDGET_STATE_HOVERED = NK_WIDGET_STATE_HOVER | NK_WIDGET_STATE_MODIFIED, /* widget is being hovered */
		NK_WIDGET_STATE_ACTIVE = NK_WIDGET_STATE_ACTIVED | NK_WIDGET_STATE_MODIFIED /* widget is currently activated */
	};

	NK_API enum nk_widget_layout_states nk_widget(struct nk_rect*, const struct nk_context*);

	NK_API enum nk_widget_layout_states nk_widget_fitting(struct nk_rect*, struct nk_context*, struct nk_vec2);

	NK_API struct nk_rect nk_widget_bounds(struct nk_context*);

	NK_API struct nk_vec2 nk_widget_position(struct nk_context*);

	NK_API struct nk_vec2 nk_widget_size(struct nk_context*);

	NK_API float nk_widget_width(struct nk_context*);

	NK_API float nk_widget_height(struct nk_context*);

	NK_API int nk_widget_is_hovered(struct nk_context*);

	NK_API int nk_widget_is_mouse_clicked(struct nk_context*, enum nk_buttons);

	NK_API int nk_widget_has_mouse_click_down(struct nk_context*, enum nk_buttons, int down);

	NK_API void nk_spacing(struct nk_context*, int cols);

	/* =============================================================================
	 *
	 *                                  TEXT
	 *
	 * ============================================================================= */
	enum nk_text_align {
		NK_TEXT_ALIGN_LEFT = 0x01,
		NK_TEXT_ALIGN_CENTERED = 0x02,
		NK_TEXT_ALIGN_RIGHT = 0x04,
		NK_TEXT_ALIGN_TOP = 0x08,
		NK_TEXT_ALIGN_MIDDLE = 0x10,
		NK_TEXT_ALIGN_BOTTOM = 0x20
	};
	enum nk_text_alignment {
		NK_TEXT_LEFT = NK_TEXT_ALIGN_MIDDLE | NK_TEXT_ALIGN_LEFT,
		NK_TEXT_CENTERED = NK_TEXT_ALIGN_MIDDLE | NK_TEXT_ALIGN_CENTERED,
		NK_TEXT_RIGHT = NK_TEXT_ALIGN_MIDDLE | NK_TEXT_ALIGN_RIGHT
	};

	NK_API void nk_text(struct nk_context*, const char*, int, nk_flags);

	NK_API void nk_text_colored(struct nk_context*, const char*, int, nk_flags, struct nk_color);

	NK_API void nk_text_wrap(struct nk_context*, const char*, int);

	NK_API void nk_text_wrap_colored(struct nk_context*, const char*, int, struct nk_color);

	NK_API void nk_label(struct nk_context*, const char*, nk_flags align);

	NK_API void nk_label_colored(struct nk_context*, const char*, nk_flags align, struct nk_color);

	NK_API void nk_label_wrap(struct nk_context*, const char*);

	NK_API void nk_label_colored_wrap(struct nk_context*, const char*, struct nk_color);

	NK_API void nk_image(struct nk_context*, struct nk_image);

	NK_API void nk_image_color(struct nk_context*, struct nk_image, struct nk_color);

#ifdef NK_INCLUDE_STANDARD_VARARGS

	NK_API void
		nk_labelf(struct nk_context*, nk_flags, NK_PRINTF_FORMAT_STRING const char*, ...) NK_PRINTF_VARARG_FUNC(3);

	NK_API void nk_labelf_colored(struct nk_context*, nk_flags, struct nk_color, NK_PRINTF_FORMAT_STRING const char*,
		...) NK_PRINTF_VARARG_FUNC(4);

	NK_API void nk_labelf_wrap(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*, ...) NK_PRINTF_VARARG_FUNC(2);

	NK_API void nk_labelf_colored_wrap(struct nk_context*, struct nk_color, NK_PRINTF_FORMAT_STRING const char*,
		...) NK_PRINTF_VARARG_FUNC(3);

	NK_API void
		nk_labelfv(struct nk_context*, nk_flags, NK_PRINTF_FORMAT_STRING const char*, va_list) NK_PRINTF_VALIST_FUNC(3);

	NK_API void nk_labelfv_colored(struct nk_context*, nk_flags, struct nk_color, NK_PRINTF_FORMAT_STRING const char*,
		va_list) NK_PRINTF_VALIST_FUNC(4);

	NK_API void
		nk_labelfv_wrap(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*, va_list) NK_PRINTF_VALIST_FUNC(2);

	NK_API void nk_labelfv_colored_wrap(struct nk_context*, struct nk_color, NK_PRINTF_FORMAT_STRING const char*,
		va_list) NK_PRINTF_VALIST_FUNC(3);

	NK_API void nk_value_bool(struct nk_context*, const char* prefix, int);

	NK_API void nk_value_int(struct nk_context*, const char* prefix, int);

	NK_API void nk_value_uint(struct nk_context*, const char* prefix, unsigned int);

	NK_API void nk_value_float(struct nk_context*, const char* prefix, float);

	NK_API void nk_value_color_byte(struct nk_context*, const char* prefix, struct nk_color);

	NK_API void nk_value_color_float(struct nk_context*, const char* prefix, struct nk_color);

	NK_API void nk_value_color_hex(struct nk_context*, const char* prefix, struct nk_color);

#endif
	/* =============================================================================
	 *
	 *                                  BUTTON
	 *
	 * ============================================================================= */
	NK_API int nk_button_text(struct nk_context*, const char* title, int len);

	NK_API int nk_button_label(struct nk_context*, const char* title);

	NK_API int nk_button_color(struct nk_context*, struct nk_color);

	NK_API int nk_button_symbol(struct nk_context*, enum nk_symbol_type);

	NK_API int nk_button_image(struct nk_context*, struct nk_image img);

	NK_API int nk_button_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags text_alignment);

	NK_API int nk_button_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);

	NK_API int nk_button_image_label(struct nk_context*, struct nk_image img, const char*, nk_flags text_alignment);

	NK_API int nk_button_image_text(struct nk_context*, struct nk_image img, const char*, int, nk_flags alignment);

	NK_API int nk_button_text_styled(struct nk_context*, const struct nk_style_button*, const char* title, int len);

	NK_API int nk_button_label_styled(struct nk_context*, const struct nk_style_button*, const char* title);

	NK_API int nk_button_symbol_styled(struct nk_context*, const struct nk_style_button*, enum nk_symbol_type);

	NK_API int nk_button_image_styled(struct nk_context*, const struct nk_style_button*, struct nk_image img);

	NK_API int
		nk_button_symbol_text_styled(struct nk_context*, const struct nk_style_button*, enum nk_symbol_type, const char*,
			int, nk_flags alignment);

	NK_API int
		nk_button_symbol_label_styled(struct nk_context* ctx, const struct nk_style_button* style, enum nk_symbol_type symbol,
			const char* title, nk_flags align);

	NK_API int
		nk_button_image_label_styled(struct nk_context*, const struct nk_style_button*, struct nk_image img, const char*,
			nk_flags text_alignment);

	NK_API int
		nk_button_image_text_styled(struct nk_context*, const struct nk_style_button*, struct nk_image img, const char*, int,
			nk_flags alignment);

	NK_API void nk_button_set_behavior(struct nk_context*, enum nk_button_behavior);

	NK_API int nk_button_push_behavior(struct nk_context*, enum nk_button_behavior);

	NK_API int nk_button_pop_behavior(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  CHECKBOX
	 *
	 * ============================================================================= */
	NK_API int nk_check_label(struct nk_context*, const char*, int active);

	NK_API int nk_check_text(struct nk_context*, const char*, int, int active);

	NK_API unsigned nk_check_flags_label(struct nk_context*, const char*, unsigned int flags, unsigned int value);

	NK_API unsigned nk_check_flags_text(struct nk_context*, const char*, int, unsigned int flags, unsigned int value);

	NK_API int nk_checkbox_label(struct nk_context*, const char*, int* active);

	NK_API int nk_checkbox_text(struct nk_context*, const char*, int, int* active);

	NK_API int nk_checkbox_flags_label(struct nk_context*, const char*, unsigned int* flags, unsigned int value);

	NK_API int nk_checkbox_flags_text(struct nk_context*, const char*, int, unsigned int* flags, unsigned int value);
	/* =============================================================================
	 *
	 *                                  RADIO BUTTON
	 *
	 * ============================================================================= */
	NK_API int nk_radio_label(struct nk_context*, const char*, int* active);

	NK_API int nk_radio_text(struct nk_context*, const char*, int, int* active);

	NK_API int nk_option_label(struct nk_context*, const char*, int active);

	NK_API int nk_option_text(struct nk_context*, const char*, int, int active);
	/* =============================================================================
	 *
	 *                                  SELECTABLE
	 *
	 * ============================================================================= */
	NK_API int nk_selectable_label(struct nk_context*, const char*, nk_flags align, int* value);

	NK_API int nk_selectable_text(struct nk_context*, const char*, int, nk_flags align, int* value);

	NK_API int nk_selectable_image_label(struct nk_context*, struct nk_image, const char*, nk_flags align, int* value);

	NK_API int
		nk_selectable_image_text(struct nk_context*, struct nk_image, const char*, int, nk_flags align, int* value);

	NK_API int
		nk_selectable_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags align, int* value);

	NK_API int
		nk_selectable_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags align, int* value);

	NK_API int nk_select_label(struct nk_context*, const char*, nk_flags align, int value);

	NK_API int nk_select_text(struct nk_context*, const char*, int, nk_flags align, int value);

	NK_API int nk_select_image_label(struct nk_context*, struct nk_image, const char*, nk_flags align, int value);

	NK_API int nk_select_image_text(struct nk_context*, struct nk_image, const char*, int, nk_flags align, int value);

	NK_API int nk_select_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags align, int value);

	NK_API int
		nk_select_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags align, int value);

	/* =============================================================================
	 *
	 *                                  SLIDER
	 *
	 * ============================================================================= */
	NK_API float nk_slide_float(struct nk_context*, float min, float val, float max, float step);

	NK_API int nk_slide_int(struct nk_context*, int min, int val, int max, int step);

	NK_API int nk_slider_float(struct nk_context*, float min, float* val, float max, float step);

	NK_API int nk_slider_int(struct nk_context*, int min, int* val, int max, int step);
	/* =============================================================================
	 *
	 *                                  PROGRESSBAR
	 *
	 * ============================================================================= */
	NK_API int nk_progress(struct nk_context*, nk_size* cur, nk_size max, int modifyable);

	NK_API nk_size nk_prog(struct nk_context*, nk_size cur, nk_size max, int modifyable);

	/* =============================================================================
	 *
	 *                                  COLOR PICKER
	 *
	 * ============================================================================= */
	NK_API struct nk_colorf nk_color_picker(struct nk_context*, struct nk_colorf, enum nk_color_format);

	NK_API int nk_color_pick(struct nk_context*, struct nk_colorf*, enum nk_color_format);
	/* =============================================================================
	 *
	 *                                  PROPERTIES
	 *
	 * =============================================================================
	/// ### Properties
	/// Properties are the main value modification widgets in Nuklear. Changing a value
	/// can be achieved by dragging, adding/removing incremental steps on button click
	/// or by directly typing a number.
	///
	/// #### Usage
	/// Each property requires a unique name for identifaction that is also used for
	/// displaying a label. If you want to use the same name multiple times make sure
	/// add a '#' before your name. The '#' will not be shown but will generate a
	/// unique ID. Each propery also takes in a minimum and maximum value. If you want
	/// to make use of the complete number range of a type just use the provided
	/// type limits from `limits.h`. For example `INT_MIN` and `INT_MAX` for
	/// `nk_property_int` and `nk_propertyi`. In additional each property takes in
	/// a increment value that will be added or subtracted if either the increment
	/// decrement button is clicked. Finally there is a value for increment per pixel
	/// dragged that is added or subtracted from the value.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int value = 0;
	/// struct nk_context ctx;
	/// nk_init_xxx(&ctx, ...);
	/// while (1) {
	///     // Input
	///     Event evt;
	///     nk_input_begin(&ctx);
	///     while (GetEvent(&evt)) {
	///         if (evt.type == MOUSE_MOVE)
	///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
	///         else if (evt.type == [...]) {
	///             nk_input_xxx(...);
	///         }
	///     }
	///     nk_input_end(&ctx);
	///     //
	///     // Window
	///     if (nk_begin_xxx(...) {
	///         // Property
	///         nk_layout_row_dynamic(...);
	///         nk_property_int(ctx, "ID", INT_MIN, &value, INT_MAX, 1, 1);
	///     }
	///     nk_end(ctx);
	///     //
	///     // Draw
	///     const struct nk_command *cmd = 0;
	///     nk_foreach(cmd, &ctx) {
	///     switch (cmd->type) {
	///     case NK_COMMAND_LINE:
	///         your_draw_line_function(...)
	///         break;
	///     case NK_COMMAND_RECT
	///         your_draw_rect_function(...)
	///         break;
	///     case ...:
	///         // [...]
	///     }
	//      nk_clear(&ctx);
	/// }
	/// nk_free(&ctx);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// #### Reference
	/// Function            | Description
	/// --------------------|-------------------------------------------
	/// nk_property_int     | Integer property directly modifing a passed in value
	/// nk_property_float   | Float property directly modifing a passed in value
	/// nk_property_double  | Double property directly modifing a passed in value
	/// nk_propertyi        | Integer property returning the modified int value
	/// nk_propertyf        | Float property returning the modified float value
	/// nk_propertyd        | Double property returning the modified double value
	///
	*/
	/*/// #### nk_property_int
	/// Integer property directly modifing a passed in value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_property_int(struct nk_context *ctx, const char *name, int min, int *val, int max, int step, float inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Integer pointer to be modified
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	*/
	NK_API void
		nk_property_int(struct nk_context*, const char* name, int min, int* val, int max, int step, float inc_per_pixel);
	/*/// #### nk_property_float
	/// Float property directly modifing a passed in value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_property_float(struct nk_context *ctx, const char *name, float min, float *val, float max, float step, float inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Float pointer to be modified
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	*/
	NK_API void nk_property_float(struct nk_context*, const char* name, float min, float* val, float max, float step,
		float inc_per_pixel);
	/*/// #### nk_property_double
	/// Double property directly modifing a passed in value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// void nk_property_double(struct nk_context *ctx, const char *name, double min, double *val, double max, double step, double inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Double pointer to be modified
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	*/
	NK_API void nk_property_double(struct nk_context*, const char* name, double min, double* val, double max, double step,
		float inc_per_pixel);
	/*/// #### nk_propertyi
	/// Integer property modifing a passed in value and returning the new value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// int nk_propertyi(struct nk_context *ctx, const char *name, int min, int val, int max, int step, float inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Current integer value to be modified and returned
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	///
	/// Returns the new modified integer value
	*/
	NK_API int
		nk_propertyi(struct nk_context*, const char* name, int min, int val, int max, int step, float inc_per_pixel);
	/*/// #### nk_propertyf
	/// Float property modifing a passed in value and returning the new value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// float nk_propertyf(struct nk_context *ctx, const char *name, float min, float val, float max, float step, float inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Current float value to be modified and returned
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	///
	/// Returns the new modified float value
	*/
	NK_API float
		nk_propertyf(struct nk_context*, const char* name, float min, float val, float max, float step, float inc_per_pixel);
	/*/// #### nk_propertyd
	/// Float property modifing a passed in value and returning the new value
	/// !!! WARNING
	///     To generate a unique property ID using the same label make sure to insert
	///     a `#` at the beginning. It will not be shown but guarantees correct behavior.
	///
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
	/// float nk_propertyd(struct nk_context *ctx, const char *name, double min, double val, double max, double step, double inc_per_pixel);
	/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	///
	/// Parameter           | Description
	/// --------------------|-----------------------------------------------------------
	/// __ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting function
	/// __name__            | String used both as a label as well as a unique identifier
	/// __min__             | Minimum value not allowed to be underflown
	/// __val__             | Current double value to be modified and returned
	/// __max__             | Maximum value not allowed to be overflown
	/// __step__            | Increment added and subtracted on increment and decrement button
	/// __inc_per_pixel__   | Value per pixel added or subtracted on dragging
	///
	/// Returns the new modified double value
	*/
	NK_API double nk_propertyd(struct nk_context*, const char* name, double min, double val, double max, double step,
		float inc_per_pixel);

	/* =============================================================================
	 *
	 *                                  TEXT EDIT
	 *
	 * ============================================================================= */
	enum nk_edit_flags {
		NK_EDIT_DEFAULT = 0,
		NK_EDIT_READ_ONLY = NK_FLAG(0),
		NK_EDIT_AUTO_SELECT = NK_FLAG(1),
		NK_EDIT_SIG_ENTER = NK_FLAG(2),
		NK_EDIT_ALLOW_TAB = NK_FLAG(3),
		NK_EDIT_NO_CURSOR = NK_FLAG(4),
		NK_EDIT_SELECTABLE = NK_FLAG(5),
		NK_EDIT_CLIPBOARD = NK_FLAG(6),
		NK_EDIT_CTRL_ENTER_NEWLINE = NK_FLAG(7),
		NK_EDIT_NO_HORIZONTAL_SCROLL = NK_FLAG(8),
		NK_EDIT_ALWAYS_INSERT_MODE = NK_FLAG(9),
		NK_EDIT_MULTILINE = NK_FLAG(10),
		NK_EDIT_GOTO_END_ON_ACTIVATE = NK_FLAG(11)
	};
	enum nk_edit_types {
		NK_EDIT_SIMPLE = NK_EDIT_ALWAYS_INSERT_MODE,
		NK_EDIT_FIELD = NK_EDIT_SIMPLE | NK_EDIT_SELECTABLE | NK_EDIT_CLIPBOARD,
		NK_EDIT_BOX =
		NK_EDIT_ALWAYS_INSERT_MODE | NK_EDIT_SELECTABLE | NK_EDIT_MULTILINE | NK_EDIT_ALLOW_TAB | NK_EDIT_CLIPBOARD,
		NK_EDIT_EDITOR = NK_EDIT_SELECTABLE | NK_EDIT_MULTILINE | NK_EDIT_ALLOW_TAB | NK_EDIT_CLIPBOARD
	};
	enum nk_edit_events {
		NK_EDIT_ACTIVE = NK_FLAG(0), /* edit widget is currently being modified */
		NK_EDIT_INACTIVE = NK_FLAG(1), /* edit widget is not active and is not being modified */
		NK_EDIT_ACTIVATED = NK_FLAG(2), /* edit widget went from state inactive to state active */
		NK_EDIT_DEACTIVATED = NK_FLAG(3), /* edit widget went from state active to state inactive */
		NK_EDIT_COMMITED = NK_FLAG(4) /* edit widget has received an enter and lost focus */
	};

	NK_API nk_flags nk_edit_string(struct nk_context*, nk_flags, char* buffer, int* len, int max, nk_plugin_filter);

	NK_API nk_flags nk_edit_string_zero_terminated(struct nk_context*, nk_flags, char* buffer, int max, nk_plugin_filter);

	NK_API nk_flags nk_edit_buffer(struct nk_context*, nk_flags, struct nk_text_edit*, nk_plugin_filter);

	NK_API void nk_edit_focus(struct nk_context*, nk_flags flags);

	NK_API void nk_edit_unfocus(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  CHART
	 *
	 * ============================================================================= */
	NK_API int nk_chart_begin(struct nk_context*, enum nk_chart_type, int num, float min, float max);

	NK_API int
		nk_chart_begin_colored(struct nk_context*, enum nk_chart_type, struct nk_color, struct nk_color active, int num,
			float min, float max);

	NK_API void
		nk_chart_add_slot(struct nk_context* ctx, const enum nk_chart_type, int count, float min_value, float max_value);

	NK_API void
		nk_chart_add_slot_colored(struct nk_context* ctx, const enum nk_chart_type, struct nk_color, struct nk_color active,
			int count, float min_value, float max_value);

	NK_API nk_flags nk_chart_push(struct nk_context*, float);

	NK_API nk_flags nk_chart_push_slot(struct nk_context*, float, int);

	NK_API void nk_chart_end(struct nk_context*);

	NK_API void nk_plot(struct nk_context*, enum nk_chart_type, const float* values, int count, int offset);

	NK_API void
		nk_plot_function(struct nk_context*, enum nk_chart_type, void* userdata, float(*value_getter)(void* user, int index),
			int count, int offset);
	/* =============================================================================
	 *
	 *                                  POPUP
	 *
	 * ============================================================================= */
	NK_API int nk_popup_begin(struct nk_context*, enum nk_popup_type, const char*, nk_flags, struct nk_rect bounds);

	NK_API void nk_popup_close(struct nk_context*);

	NK_API void nk_popup_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  COMBOBOX
	 *
	 * ============================================================================= */
	NK_API int
		nk_combo(struct nk_context*, const char** items, int count, int selected, int item_height, struct nk_vec2 size);

	NK_API int
		nk_combo_separator(struct nk_context*, const char* items_separated_by_separator, int separator, int selected,
			int count, int item_height, struct nk_vec2 size);

	NK_API int
		nk_combo_string(struct nk_context*, const char* items_separated_by_zeros, int selected, int count, int item_height,
			struct nk_vec2 size);

	NK_API int
		nk_combo_callback(struct nk_context*, void(*item_getter)(void*, int, const char**), void* userdata, int selected,
			int count, int item_height, struct nk_vec2 size);

	NK_API void
		nk_combobox(struct nk_context*, const char** items, int count, int* selected, int item_height, struct nk_vec2 size);

	NK_API void
		nk_combobox_string(struct nk_context*, const char* items_separated_by_zeros, int* selected, int count, int item_height,
			struct nk_vec2 size);

	NK_API void
		nk_combobox_separator(struct nk_context*, const char* items_separated_by_separator, int separator, int* selected,
			int count, int item_height, struct nk_vec2 size);

	NK_API void
		nk_combobox_callback(struct nk_context*, void(*item_getter)(void*, int, const char**), void*, int* selected,
			int count, int item_height, struct nk_vec2 size);
	/* =============================================================================
	 *
	 *                                  ABSTRACT COMBOBOX
	 *
	 * ============================================================================= */
	NK_API int nk_combo_begin_text(struct nk_context*, const char* selected, int, struct nk_vec2 size);

	NK_API int nk_combo_begin_label(struct nk_context*, const char* selected, struct nk_vec2 size);

	NK_API int nk_combo_begin_color(struct nk_context*, struct nk_color color, struct nk_vec2 size);

	NK_API int nk_combo_begin_symbol(struct nk_context*, enum nk_symbol_type, struct nk_vec2 size);

	NK_API int
		nk_combo_begin_symbol_label(struct nk_context*, const char* selected, enum nk_symbol_type, struct nk_vec2 size);

	NK_API int
		nk_combo_begin_symbol_text(struct nk_context*, const char* selected, int, enum nk_symbol_type, struct nk_vec2 size);

	NK_API int nk_combo_begin_image(struct nk_context*, struct nk_image img, struct nk_vec2 size);

	NK_API int nk_combo_begin_image_label(struct nk_context*, const char* selected, struct nk_image, struct nk_vec2 size);

	NK_API int
		nk_combo_begin_image_text(struct nk_context*, const char* selected, int, struct nk_image, struct nk_vec2 size);

	NK_API int nk_combo_item_label(struct nk_context*, const char*, nk_flags alignment);

	NK_API int nk_combo_item_text(struct nk_context*, const char*, int, nk_flags alignment);

	NK_API int nk_combo_item_image_label(struct nk_context*, struct nk_image, const char*, nk_flags alignment);

	NK_API int nk_combo_item_image_text(struct nk_context*, struct nk_image, const char*, int, nk_flags alignment);

	NK_API int nk_combo_item_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags alignment);

	NK_API int nk_combo_item_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);

	NK_API void nk_combo_close(struct nk_context*);

	NK_API void nk_combo_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  CONTEXTUAL
	 *
	 * ============================================================================= */
	NK_API int nk_contextual_begin(struct nk_context*, nk_flags, struct nk_vec2, struct nk_rect trigger_bounds);

	NK_API int nk_contextual_item_text(struct nk_context*, const char*, int, nk_flags align);

	NK_API int nk_contextual_item_label(struct nk_context*, const char*, nk_flags align);

	NK_API int nk_contextual_item_image_label(struct nk_context*, struct nk_image, const char*, nk_flags alignment);

	NK_API int
		nk_contextual_item_image_text(struct nk_context*, struct nk_image, const char*, int len, nk_flags alignment);

	NK_API int nk_contextual_item_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags alignment);

	NK_API int
		nk_contextual_item_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);

	NK_API void nk_contextual_close(struct nk_context*);

	NK_API void nk_contextual_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  TOOLTIP
	 *
	 * ============================================================================= */
	NK_API void nk_tooltip(struct nk_context*, const char*);

#ifdef NK_INCLUDE_STANDARD_VARARGS

	NK_API void nk_tooltipf(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*, ...) NK_PRINTF_VARARG_FUNC(2);

	NK_API void nk_tooltipfv(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*, va_list) NK_PRINTF_VALIST_FUNC(2);

#endif

	NK_API int nk_tooltip_begin(struct nk_context*, float width);

	NK_API void nk_tooltip_end(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  MENU
	 *
	 * ============================================================================= */
	NK_API void nk_menubar_begin(struct nk_context*);

	NK_API void nk_menubar_end(struct nk_context*);

	NK_API int
		nk_menu_begin_text(struct nk_context*, const char* title, int title_len, nk_flags align, struct nk_vec2 size);

	NK_API int nk_menu_begin_label(struct nk_context*, const char*, nk_flags align, struct nk_vec2 size);

	NK_API int nk_menu_begin_image(struct nk_context*, const char*, struct nk_image, struct nk_vec2 size);

	NK_API int
		nk_menu_begin_image_text(struct nk_context*, const char*, int, nk_flags align, struct nk_image, struct nk_vec2 size);

	NK_API int
		nk_menu_begin_image_label(struct nk_context*, const char*, nk_flags align, struct nk_image, struct nk_vec2 size);

	NK_API int nk_menu_begin_symbol(struct nk_context*, const char*, enum nk_symbol_type, struct nk_vec2 size);

	NK_API int nk_menu_begin_symbol_text(struct nk_context*, const char*, int, nk_flags align, enum nk_symbol_type,
		struct nk_vec2 size);

	NK_API int
		nk_menu_begin_symbol_label(struct nk_context*, const char*, nk_flags align, enum nk_symbol_type, struct nk_vec2 size);

	NK_API int nk_menu_item_text(struct nk_context*, const char*, int, nk_flags align);

	NK_API int nk_menu_item_label(struct nk_context*, const char*, nk_flags alignment);

	NK_API int nk_menu_item_image_label(struct nk_context*, struct nk_image, const char*, nk_flags alignment);

	NK_API int nk_menu_item_image_text(struct nk_context*, struct nk_image, const char*, int len, nk_flags alignment);

	NK_API int nk_menu_item_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);

	NK_API int nk_menu_item_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags alignment);

	NK_API void nk_menu_close(struct nk_context*);

	NK_API void nk_menu_end(struct nk_context*);

	/* =============================================================================
	 *
	 *                                  STYLE
	 *
	 * ============================================================================= */
	enum nk_style_colors {
		NK_COLOR_TEXT,
		NK_COLOR_WINDOW,
		NK_COLOR_HEADER,
		NK_COLOR_BORDER,
		NK_COLOR_BUTTON,
		NK_COLOR_BUTTON_HOVER,
		NK_COLOR_BUTTON_ACTIVE,
		NK_COLOR_TOGGLE,
		NK_COLOR_TOGGLE_HOVER,
		NK_COLOR_TOGGLE_CURSOR,
		NK_COLOR_SELECT,
		NK_COLOR_SELECT_ACTIVE,
		NK_COLOR_SLIDER,
		NK_COLOR_SLIDER_CURSOR,
		NK_COLOR_SLIDER_CURSOR_HOVER,
		NK_COLOR_SLIDER_CURSOR_ACTIVE,
		NK_COLOR_PROPERTY,
		NK_COLOR_EDIT,
		NK_COLOR_EDIT_CURSOR,
		NK_COLOR_COMBO,
		NK_COLOR_CHART,
		NK_COLOR_CHART_COLOR,
		NK_COLOR_CHART_COLOR_HIGHLIGHT,
		NK_COLOR_SCROLLBAR,
		NK_COLOR_SCROLLBAR_CURSOR,
		NK_COLOR_SCROLLBAR_CURSOR_HOVER,
		NK_COLOR_SCROLLBAR_CURSOR_ACTIVE,
		NK_COLOR_TAB_HEADER,
		NK_COLOR_COUNT
	};
	enum nk_style_cursor {
		NK_CURSOR_ARROW,
		NK_CURSOR_TEXT,
		NK_CURSOR_MOVE,
		NK_CURSOR_RESIZE_VERTICAL,
		NK_CURSOR_RESIZE_HORIZONTAL,
		NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT,
		NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT,
		NK_CURSOR_COUNT
	};

	NK_API void nk_style_default(struct nk_context*);

	NK_API void nk_style_from_table(struct nk_context*, const struct nk_color*);

	NK_API void nk_style_load_cursor(struct nk_context*, enum nk_style_cursor, const struct nk_cursor*);

	NK_API void nk_style_load_all_cursors(struct nk_context*, struct nk_cursor*);

	NK_API const char* nk_style_get_color_by_name(enum nk_style_colors);

	NK_API void nk_style_set_font(struct nk_context*, const struct nk_user_font*);

	NK_API int nk_style_set_cursor(struct nk_context*, enum nk_style_cursor);

	NK_API void nk_style_show_cursor(struct nk_context*);

	NK_API void nk_style_hide_cursor(struct nk_context*);

	NK_API int nk_style_push_font(struct nk_context*, const struct nk_user_font*);

	NK_API int nk_style_push_float(struct nk_context*, float*, float);

	NK_API int nk_style_push_vec2(struct nk_context*, struct nk_vec2*, struct nk_vec2);

	NK_API int nk_style_push_style_item(struct nk_context*, struct nk_style_item*, struct nk_style_item);

	NK_API int nk_style_push_flags(struct nk_context*, nk_flags*, nk_flags);

	NK_API int nk_style_push_color(struct nk_context*, struct nk_color*, struct nk_color);

	NK_API int nk_style_pop_font(struct nk_context*);

	NK_API int nk_style_pop_float(struct nk_context*);

	NK_API int nk_style_pop_vec2(struct nk_context*);

	NK_API int nk_style_pop_style_item(struct nk_context*);

	NK_API int nk_style_pop_flags(struct nk_context*);

	NK_API int nk_style_pop_color(struct nk_context*);
	/* =============================================================================
	 *
	 *                                  COLOR
	 *
	 * ============================================================================= */
	NK_API struct nk_color nk_rgb(int r, int g, int b);

	NK_API struct nk_color nk_rgb_iv(const int* rgb);

	NK_API struct nk_color nk_rgb_bv(const nk_byte* rgb);

	NK_API struct nk_color nk_rgb_f(float r, float g, float b);

	NK_API struct nk_color nk_rgb_fv(const float* rgb);

	NK_API struct nk_color nk_rgb_cf(struct nk_colorf c);

	NK_API struct nk_color nk_rgb_hex(const char* rgb);

	NK_API struct nk_color nk_rgba(int r, int g, int b, int a);

	NK_API struct nk_color nk_rgba_u32(nk_uint);

	NK_API struct nk_color nk_rgba_iv(const int* rgba);

	NK_API struct nk_color nk_rgba_bv(const nk_byte* rgba);

	NK_API struct nk_color nk_rgba_f(float r, float g, float b, float a);

	NK_API struct nk_color nk_rgba_fv(const float* rgba);

	NK_API struct nk_color nk_rgba_cf(struct nk_colorf c);

	NK_API struct nk_color nk_rgba_hex(const char* rgb);

	NK_API struct nk_colorf nk_hsva_colorf(float h, float s, float v, float a);

	NK_API struct nk_colorf nk_hsva_colorfv(float* c);

	NK_API void nk_colorf_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, struct nk_colorf in);

	NK_API void nk_colorf_hsva_fv(float* hsva, struct nk_colorf in);

	NK_API struct nk_color nk_hsv(int h, int s, int v);

	NK_API struct nk_color nk_hsv_iv(const int* hsv);

	NK_API struct nk_color nk_hsv_bv(const nk_byte* hsv);

	NK_API struct nk_color nk_hsv_f(float h, float s, float v);

	NK_API struct nk_color nk_hsv_fv(const float* hsv);

	NK_API struct nk_color nk_hsva(int h, int s, int v, int a);

	NK_API struct nk_color nk_hsva_iv(const int* hsva);

	NK_API struct nk_color nk_hsva_bv(const nk_byte* hsva);

	NK_API struct nk_color nk_hsva_f(float h, float s, float v, float a);

	NK_API struct nk_color nk_hsva_fv(const float* hsva);

	/* color (conversion nuklear --> user) */
	NK_API void nk_color_f(float* r, float* g, float* b, float* a, struct nk_color);

	NK_API void nk_color_fv(float* rgba_out, struct nk_color);

	NK_API struct nk_colorf nk_color_cf(struct nk_color);

	NK_API void nk_color_d(double* r, double* g, double* b, double* a, struct nk_color);

	NK_API void nk_color_dv(double* rgba_out, struct nk_color);

	NK_API nk_uint nk_color_u32(struct nk_color);

	NK_API void nk_color_hex_rgba(char* output, struct nk_color);

	NK_API void nk_color_hex_rgb(char* output, struct nk_color);

	NK_API void nk_color_hsv_i(int* out_h, int* out_s, int* out_v, struct nk_color);

	NK_API void nk_color_hsv_b(nk_byte* out_h, nk_byte* out_s, nk_byte* out_v, struct nk_color);

	NK_API void nk_color_hsv_iv(int* hsv_out, struct nk_color);

	NK_API void nk_color_hsv_bv(nk_byte* hsv_out, struct nk_color);

	NK_API void nk_color_hsv_f(float* out_h, float* out_s, float* out_v, struct nk_color);

	NK_API void nk_color_hsv_fv(float* hsv_out, struct nk_color);

	NK_API void nk_color_hsva_i(int* h, int* s, int* v, int* a, struct nk_color);

	NK_API void nk_color_hsva_b(nk_byte* h, nk_byte* s, nk_byte* v, nk_byte* a, struct nk_color);

	NK_API void nk_color_hsva_iv(int* hsva_out, struct nk_color);

	NK_API void nk_color_hsva_bv(nk_byte* hsva_out, struct nk_color);

	NK_API void nk_color_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, struct nk_color);

	NK_API void nk_color_hsva_fv(float* hsva_out, struct nk_color);
	/* =============================================================================
	 *
	 *                                  IMAGE
	 *
	 * ============================================================================= */
	NK_API nk_handle nk_handle_ptr(void*);

	NK_API nk_handle nk_handle_id(int);

	NK_API struct nk_image nk_image_handle(nk_handle);

	NK_API struct nk_image nk_image_ptr(void*);

	NK_API struct nk_image nk_image_id(int);

	NK_API int nk_image_is_subimage(const struct nk_image* img);

	NK_API struct nk_image nk_subimage_ptr(void*, unsigned short w, unsigned short h, struct nk_rect sub_region);

	NK_API struct nk_image nk_subimage_id(int, unsigned short w, unsigned short h, struct nk_rect sub_region);

	NK_API struct nk_image nk_subimage_handle(nk_handle, unsigned short w, unsigned short h, struct nk_rect sub_region);
	/* =============================================================================
	 *
	 *                                  MATH
	 *
	 * ============================================================================= */
	NK_API nk_hash nk_murmur_hash(const void* key, int len, nk_hash seed);

	NK_API void
		nk_triangle_from_direction(struct nk_vec2* result, struct nk_rect r, float pad_x, float pad_y, enum nk_heading);

	NK_API struct nk_vec2 nk_vec2(float x, float y);

	NK_API struct nk_vec2 nk_vec2i(int x, int y);

	NK_API struct nk_vec2 nk_vec2v(const float* xy);

	NK_API struct nk_vec2 nk_vec2iv(const int* xy);

	NK_API struct nk_rect nk_get_null_rect(void);

	NK_API struct nk_rect nk_rect(float x, float y, float w, float h);

	NK_API struct nk_rect nk_recti(int x, int y, int w, int h);

	NK_API struct nk_rect nk_recta(struct nk_vec2 pos, struct nk_vec2 size);

	NK_API struct nk_rect nk_rectv(const float* xywh);

	NK_API struct nk_rect nk_rectiv(const int* xywh);

	NK_API struct nk_vec2 nk_rect_pos(struct nk_rect);

	NK_API struct nk_vec2 nk_rect_size(struct nk_rect);
	/* =============================================================================
	 *
	 *                                  STRING
	 *
	 * ============================================================================= */
	NK_API int nk_strlen(const char* str);

	NK_API int nk_stricmp(const char* s1, const char* s2);

	NK_API int nk_stricmpn(const char* s1, const char* s2, int n);

	NK_API int nk_strtoi(const char* str, const char** endptr);

	NK_API float nk_strtof(const char* str, const char** endptr);

	NK_API double nk_strtod(const char* str, const char** endptr);

	NK_API int nk_strfilter(const char* text, const char* regexp);

	NK_API int nk_strmatch_fuzzy_string(char const* str, char const* pattern, int* out_score);

	NK_API int nk_strmatch_fuzzy_text(const char* txt, int txt_len, const char* pattern, int* out_score);
	/* =============================================================================
	 *
	 *                                  UTF-8
	 *
	 * ============================================================================= */
	NK_API int nk_utf_decode(const char*, nk_rune*, int);

	NK_API int nk_utf_encode(nk_rune, char*, int);

	NK_API int nk_utf_len(const char*, int byte_len);

	NK_API const char* nk_utf_at(const char* buffer, int length, int index, nk_rune* unicode, int* len);
	/* ===============================================================
	 *
	 *                          FONT
	 *
	 * ===============================================================*/
	 /*  Font handling in this library was designed to be quite customizable and lets
		 you decide what you want to use and what you want to provide. There are three
		 different ways to use the font atlas. The first two will use your font
		 handling scheme and only requires essential data to run nuklear. The next
		 slightly more advanced features is font handling with vertex buffer output.
		 Finally the most complex API wise is using nuklear's font baking API.

		 1.) Using your own implementation without vertex buffer output
		 --------------------------------------------------------------
		 So first up the easiest way to do font handling is by just providing a
		 `nk_user_font` struct which only requires the height in pixel of the used
		 font and a callback to calculate the width of a string. This way of handling
		 fonts is best fitted for using the normal draw shape command API where you
		 do all the text drawing yourself and the library does not require any kind
		 of deeper knowledge about which font handling mechanism you use.
		 IMPORTANT: the `nk_user_font` pointer provided to nuklear has to persist
		 over the complete life time! I know this sucks but it is currently the only
		 way to switch between fonts.

			 float your_text_width_calculation(nk_handle handle, float height, const char *text, int len)
			 {
				 your_font_type *type = handle.ptr;
				 float text_width = ...;
				 return text_width;
			 }

			 struct nk_user_font font;
			 font.userdata.ptr = &your_font_class_or_struct;
			 font.height = your_font_height;
			 font.width = your_text_width_calculation;

			 struct nk_context ctx;
			 nk_init_default(&ctx, &font);

		 2.) Using your own implementation with vertex buffer output
		 --------------------------------------------------------------
		 While the first approach works fine if you don't want to use the optional
		 vertex buffer output it is not enough if you do. To get font handling working
		 for these cases you have to provide two additional parameters inside the
		 `nk_user_font`. First a texture atlas handle used to draw text as subimages
		 of a bigger font atlas texture and a callback to query a character's glyph
		 information (offset, size, ...). So it is still possible to provide your own
		 font and use the vertex buffer output.

			 float your_text_width_calculation(nk_handle handle, float height, const char *text, int len)
			 {
				 your_font_type *type = handle.ptr;
				 float text_width = ...;
				 return text_width;
			 }
			 void query_your_font_glyph(nk_handle handle, float font_height, struct nk_user_font_glyph *glyph, nk_rune codepoint, nk_rune next_codepoint)
			 {
				 your_font_type *type = handle.ptr;
				 glyph.width = ...;
				 glyph.height = ...;
				 glyph.xadvance = ...;
				 glyph.uv[0].x = ...;
				 glyph.uv[0].y = ...;
				 glyph.uv[1].x = ...;
				 glyph.uv[1].y = ...;
				 glyph.offset.x = ...;
				 glyph.offset.y = ...;
			 }

			 struct nk_user_font font;
			 font.userdata.ptr = &your_font_class_or_struct;
			 font.height = your_font_height;
			 font.width = your_text_width_calculation;
			 font.query = query_your_font_glyph;
			 font.texture.id = your_font_texture;

			 struct nk_context ctx;
			 nk_init_default(&ctx, &font);

		 3.) Nuklear font baker
		 ------------------------------------
		 The final approach if you do not have a font handling functionality or don't
		 want to use it in this library is by using the optional font baker.
		 The font baker APIs can be used to create a font plus font atlas texture
		 and can be used with or without the vertex buffer output.

		 It still uses the `nk_user_font` struct and the two different approaches
		 previously stated still work. The font baker is not located inside
		 `nk_context` like all other systems since it can be understood as more of
		 an extension to nuklear and does not really depend on any `nk_context` state.

		 Font baker need to be initialized first by one of the nk_font_atlas_init_xxx
		 functions. If you don't care about memory just call the default version
		 `nk_font_atlas_init_default` which will allocate all memory from the standard library.
		 If you want to control memory allocation but you don't care if the allocated
		 memory is temporary and therefore can be freed directly after the baking process
		 is over or permanent you can call `nk_font_atlas_init`.

		 After successfully initializing the font baker you can add Truetype(.ttf) fonts from
		 different sources like memory or from file by calling one of the `nk_font_atlas_add_xxx`.
		 functions. Adding font will permanently store each font, font config and ttf memory block(!)
		 inside the font atlas and allows to reuse the font atlas. If you don't want to reuse
		 the font baker by for example adding additional fonts you can call
		 `nk_font_atlas_cleanup` after the baking process is over (after calling nk_font_atlas_end).

		 As soon as you added all fonts you wanted you can now start the baking process
		 for every selected glyph to image by calling `nk_font_atlas_bake`.
		 The baking process returns image memory, width and height which can be used to
		 either create your own image object or upload it to any graphics library.
		 No matter which case you finally have to call `nk_font_atlas_end` which
		 will free all temporary memory including the font atlas image so make sure
		 you created our texture beforehand. `nk_font_atlas_end` requires a handle
		 to your font texture or object and optionally fills a `struct nk_draw_null_texture`
		 which can be used for the optional vertex output. If you don't want it just
		 set the argument to `NULL`.

		 At this point you are done and if you don't want to reuse the font atlas you
		 can call `nk_font_atlas_cleanup` to free all truetype blobs and configuration
		 memory. Finally if you don't use the font atlas and any of it's fonts anymore
		 you need to call `nk_font_atlas_clear` to free all memory still being used.

			 struct nk_font_atlas atlas;
			 nk_font_atlas_init_default(&atlas);
			 nk_font_atlas_begin(&atlas);
			 nk_font *font = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font.ttf", 13, 0);
			 nk_font *font2 = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font2.ttf", 16, 0);
			 const void* img = nk_font_atlas_bake(&atlas, &img_width, &img_height, NK_FONT_ATLAS_RGBA32);
			 nk_font_atlas_end(&atlas, nk_handle_id(texture), 0);

			 struct nk_context ctx;
			 nk_init_default(&ctx, &font->handle);
			 while (1) {

			 }
			 nk_font_atlas_clear(&atlas);

		 The font baker API is probably the most complex API inside this library and
		 I would suggest reading some of my examples `example/` to get a grip on how
		 to use the font atlas. There are a number of details I left out. For example
		 how to merge fonts, configure a font with `nk_font_config` to use other languages,
		 use another texture coordinate format and a lot more:

			 struct nk_font_config cfg = nk_font_config(font_pixel_height);
			 cfg.merge_mode = nk_false or nk_true;
			 cfg.range = nk_font_korean_glyph_ranges();
			 cfg.coord_type = NK_COORD_PIXEL;
			 nk_font *font = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font.ttf", 13, &cfg);

	 */
	struct nk_user_font_glyph;

	typedef float(*nk_text_width_f)(nk_handle, float h, const char*, int len);

	typedef void(*nk_query_font_glyph_f)(nk_handle handle, float font_height, struct nk_user_font_glyph* glyph,
		nk_rune codepoint, nk_rune next_codepoint);

#if defined(NK_INCLUDE_VERTEX_BUFFER_OUTPUT) || defined(NK_INCLUDE_SOFTWARE_FONT)
	struct nk_user_font_glyph {
		struct nk_vec2 uv[2];
		/* texture coordinates */
		struct nk_vec2 offset;
		/* offset between top left and glyph */
		float width, height;
		/* size of the glyph  */
		float xadvance;
		/* offset to the next glyph */
	};
#endif

	struct nk_user_font {
		nk_handle userdata;
		/* user provided font handle */
		float height;
		/* max height of the font */
		nk_text_width_f width;
		/* font string width in pixel callback */
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
		nk_query_font_glyph_f query;
		/* font glyph callback to query drawing info */
		nk_handle texture;
		/* texture handle to the used font atlas or texture */
#endif
	};

#ifdef NK_INCLUDE_FONT_BAKING
	enum nk_font_coord_type {
		NK_COORD_UV, /* texture coordinates inside font glyphs are clamped between 0-1 */
		NK_COORD_PIXEL /* texture coordinates inside font glyphs are in absolute pixel */
	};

	struct nk_font;
	struct nk_baked_font {
		float height;
		/* height of the font  */
		float ascent, descent;
		/* font glyphs ascent and descent  */
		nk_rune glyph_offset;
		/* glyph array offset inside the font glyph baking output array  */
		nk_rune glyph_count;
		/* number of glyphs of this font inside the glyph baking array output */
		const nk_rune* ranges;
		/* font codepoint ranges as pairs of (from/to) and 0 as last element */
	};

	struct nk_font_config {
		struct nk_font_config* next;
		/* NOTE: only used internally */
		void* ttf_blob;
		/* pointer to loaded TTF file memory block.
		 * NOTE: not needed for nk_font_atlas_add_from_memory and nk_font_atlas_add_from_file. */
		nk_size ttf_size;
		/* size of the loaded TTF file memory block
		 * NOTE: not needed for nk_font_atlas_add_from_memory and nk_font_atlas_add_from_file. */

		unsigned char ttf_data_owned_by_atlas;
		/* used inside font atlas: default to: 0*/
		unsigned char merge_mode;
		/* merges this font into the last font */
		unsigned char pixel_snap;
		/* align every character to pixel boundary (if true set oversample (1,1)) */
		unsigned char oversample_v, oversample_h;
		/* rasterize at hight quality for sub-pixel position */
		unsigned char padding[3];

		float size;
		/* baked pixel height of the font */
		enum nk_font_coord_type coord_type;
		/* texture coordinate format with either pixel or UV coordinates */
		struct nk_vec2 spacing;
		/* extra pixel spacing between glyphs  */
		const nk_rune* range;
		/* list of unicode ranges (2 values per range, zero terminated) */
		struct nk_baked_font* font;
		/* font to setup in the baking process: NOTE: not needed for font atlas */
		nk_rune fallback_glyph;
		/* fallback glyph to use if a given rune is not found */
		struct nk_font_config* n;
		struct nk_font_config* p;
	};

	struct nk_font_glyph {
		nk_rune codepoint;
		float xadvance;
		float x0, y0, x1, y1, w, h;
		float u0, v0, u1, v1;
	};

	struct nk_font {
		struct nk_font* next;
		struct nk_user_font handle;
		struct nk_baked_font info;
		float scale;
		struct nk_font_glyph* glyphs;
		const struct nk_font_glyph* fallback;
		nk_rune fallback_codepoint;
		nk_handle texture;
		struct nk_font_config* config;
	};

	enum nk_font_atlas_format {
		NK_FONT_ATLAS_ALPHA8,
		NK_FONT_ATLAS_RGBA32
	};

	struct nk_font_atlas {
		void* pixel;
		int tex_width;
		int tex_height;

		struct nk_allocator permanent;
		struct nk_allocator temporary;

		struct nk_recti custom;
		struct nk_cursor cursors[NK_CURSOR_COUNT];

		int glyph_count;
		struct nk_font_glyph* glyphs;
		struct nk_font* default_font;
		struct nk_font* fonts;
		struct nk_font_config* config;
		int font_num;
	};

	/* some language glyph codepoint ranges */
	NK_API const nk_rune* nk_font_default_glyph_ranges(void);
	NK_API const nk_rune* nk_font_chinese_glyph_ranges(void);
	NK_API const nk_rune* nk_font_cyrillic_glyph_ranges(void);
	NK_API const nk_rune* nk_font_korean_glyph_ranges(void);

#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR
	NK_API void nk_font_atlas_init_default(struct nk_font_atlas*);
#endif
	NK_API void nk_font_atlas_init(struct nk_font_atlas*, struct nk_allocator*);
	NK_API void nk_font_atlas_init_custom(struct nk_font_atlas*, struct nk_allocator* persistent, struct nk_allocator* transient);
	NK_API void nk_font_atlas_begin(struct nk_font_atlas*);
	NK_API struct nk_font_config nk_font_config(float pixel_height);
	NK_API struct nk_font* nk_font_atlas_add(struct nk_font_atlas*, const struct nk_font_config*);
#ifdef NK_INCLUDE_DEFAULT_FONT
	NK_API struct nk_font* nk_font_atlas_add_default(struct nk_font_atlas*, float height, const struct nk_font_config*);
#endif
	NK_API struct nk_font* nk_font_atlas_add_from_memory(struct nk_font_atlas* atlas, void* memory, nk_size size, float height, const struct nk_font_config* config);
#ifdef NK_INCLUDE_STANDARD_IO
	NK_API struct nk_font* nk_font_atlas_add_from_file(struct nk_font_atlas* atlas, const char* file_path, float height, const struct nk_font_config*);
#endif
	NK_API struct nk_font* nk_font_atlas_add_compressed(struct nk_font_atlas*, void* memory, nk_size size, float height, const struct nk_font_config*);
	NK_API struct nk_font* nk_font_atlas_add_compressed_base85(struct nk_font_atlas*, const char* data, float height, const struct nk_font_config* config);
	NK_API const void* nk_font_atlas_bake(struct nk_font_atlas*, int* width, int* height, enum nk_font_atlas_format);
	NK_API void nk_font_atlas_end(struct nk_font_atlas*, nk_handle tex, struct nk_draw_null_texture*);
	NK_API const struct nk_font_glyph* nk_font_find_glyph(struct nk_font*, nk_rune unicode);
	NK_API void nk_font_atlas_cleanup(struct nk_font_atlas* atlas);
	NK_API void nk_font_atlas_clear(struct nk_font_atlas*);

#endif

	/* ==============================================================
	 *
	 *                          MEMORY BUFFER
	 *
	 * ===============================================================*/
	 /*  A basic (double)-buffer with linear allocation and resetting as only
		 freeing policy. The buffer's main purpose is to control all memory management
		 inside the GUI toolkit and still leave memory control as much as possible in
		 the hand of the user while also making sure the library is easy to use if
		 not as much control is needed.
		 In general all memory inside this library can be provided from the user in
		 three different ways.

		 The first way and the one providing most control is by just passing a fixed
		 size memory block. In this case all control lies in the hand of the user
		 since he can exactly control where the memory comes from and how much memory
		 the library should consume. Of course using the fixed size API removes the
		 ability to automatically resize a buffer if not enough memory is provided so
		 you have to take over the resizing. While being a fixed sized buffer sounds
		 quite limiting, it is very effective in this library since the actual memory
		 consumption is quite stable and has a fixed upper bound for a lot of cases.

		 If you don't want to think about how much memory the library should allocate
		 at all time or have a very dynamic UI with unpredictable memory consumption
		 habits but still want control over memory allocation you can use the dynamic
		 allocator based API. The allocator consists of two callbacks for allocating
		 and freeing memory and optional userdata so you can plugin your own allocator.

		 The final and easiest way can be used by defining
		 NK_INCLUDE_DEFAULT_ALLOCATOR which uses the standard library memory
		 allocation functions malloc and free and takes over complete control over
		 memory in this library.
	 */
	struct nk_memory_status {
		void* memory;
		unsigned int type;
		nk_size size;
		nk_size allocated;
		nk_size needed;
		nk_size calls;
	};

	enum nk_allocation_type {
		NK_BUFFER_FIXED, NK_BUFFER_DYNAMIC
	};

	enum nk_buffer_allocation_type {
		NK_BUFFER_FRONT, NK_BUFFER_BACK, NK_BUFFER_MAX
	};

	struct nk_buffer_marker {
		int active;
		nk_size offset;
	};

	struct nk_memory {
		void* ptr;
		nk_size size;
	};
	struct nk_buffer {
		struct nk_buffer_marker marker[NK_BUFFER_MAX];
		/* buffer marker to free a buffer to a certain offset */
		struct nk_allocator pool;
		/* allocator callback for dynamic buffers */
		enum nk_allocation_type type;
		/* memory management type */
		struct nk_memory memory;
		/* memory and size of the current memory block */
		float grow_factor;
		/* growing factor for dynamic memory management */
		nk_size allocated;
		/* total amount of memory allocated */
		nk_size needed;
		/* totally consumed memory given that enough memory is present */
		nk_size calls;
		/* number of allocation calls */
		nk_size size;
		/* current size of the buffer */
	};

#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

	NK_API void nk_buffer_init_default(struct nk_buffer*);

#endif

	NK_API void nk_buffer_init(struct nk_buffer*, const struct nk_allocator*, nk_size size);

	NK_API void nk_buffer_init_fixed(struct nk_buffer*, void* memory, nk_size size);

	NK_API void nk_buffer_info(struct nk_memory_status*, struct nk_buffer*);

	NK_API void nk_buffer_push(struct nk_buffer*, enum nk_buffer_allocation_type type, const void* memory, nk_size size,
		nk_size align);

	NK_API void nk_buffer_mark(struct nk_buffer*, enum nk_buffer_allocation_type type);

	NK_API void nk_buffer_reset(struct nk_buffer*, enum nk_buffer_allocation_type type);

	NK_API void nk_buffer_clear(struct nk_buffer*);

	NK_API void nk_buffer_free(struct nk_buffer*);

	NK_API void* nk_buffer_memory(struct nk_buffer*);

	NK_API const void* nk_buffer_memory_const(const struct nk_buffer*);

	NK_API nk_size nk_buffer_total(struct nk_buffer*);

	/* ==============================================================
	 *
	 *                          STRING
	 *
	 * ===============================================================*/
	 /*  Basic string buffer which is only used in context with the text editor
	  *  to manage and manipulate dynamic or fixed size string content. This is _NOT_
	  *  the default string handling method. The only instance you should have any contact
	  *  with this API is if you interact with an `nk_text_edit` object inside one of the
	  *  copy and paste functions and even there only for more advanced cases. */
	struct nk_str {
		struct nk_buffer buffer;
		int len; /* in codepoints/runes/glyphs */
	};

#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

	NK_API void nk_str_init_default(struct nk_str*);

#endif

	NK_API void nk_str_init(struct nk_str*, const struct nk_allocator*, nk_size size);

	NK_API void nk_str_init_fixed(struct nk_str*, void* memory, nk_size size);

	NK_API void nk_str_clear(struct nk_str*);

	NK_API void nk_str_free(struct nk_str*);

	NK_API int nk_str_append_text_char(struct nk_str*, const char*, int);

	NK_API int nk_str_append_str_char(struct nk_str*, const char*);

	NK_API int nk_str_append_text_utf8(struct nk_str*, const char*, int);

	NK_API int nk_str_append_str_utf8(struct nk_str*, const char*);

	NK_API int nk_str_append_text_runes(struct nk_str*, const nk_rune*, int);

	NK_API int nk_str_append_str_runes(struct nk_str*, const nk_rune*);

	NK_API int nk_str_insert_at_char(struct nk_str*, int pos, const char*, int);

	NK_API int nk_str_insert_at_rune(struct nk_str*, int pos, const char*, int);

	NK_API int nk_str_insert_text_char(struct nk_str*, int pos, const char*, int);

	NK_API int nk_str_insert_str_char(struct nk_str*, int pos, const char*);

	NK_API int nk_str_insert_text_utf8(struct nk_str*, int pos, const char*, int);

	NK_API int nk_str_insert_str_utf8(struct nk_str*, int pos, const char*);

	NK_API int nk_str_insert_text_runes(struct nk_str*, int pos, const nk_rune*, int);

	NK_API int nk_str_insert_str_runes(struct nk_str*, int pos, const nk_rune*);

	NK_API void nk_str_remove_chars(struct nk_str*, int len);

	NK_API void nk_str_remove_runes(struct nk_str* str, int len);

	NK_API void nk_str_delete_chars(struct nk_str*, int pos, int len);

	NK_API void nk_str_delete_runes(struct nk_str*, int pos, int len);

	NK_API char* nk_str_at_char(struct nk_str*, int pos);

	NK_API char* nk_str_at_rune(struct nk_str*, int pos, nk_rune* unicode, int* len);

	NK_API nk_rune nk_str_rune_at(const struct nk_str*, int pos);

	NK_API const char* nk_str_at_char_const(const struct nk_str*, int pos);

	NK_API const char* nk_str_at_const(const struct nk_str*, int pos, nk_rune* unicode, int* len);

	NK_API char* nk_str_get(struct nk_str*);

	NK_API const char* nk_str_get_const(const struct nk_str*);

	NK_API int nk_str_len(struct nk_str*);

	NK_API int nk_str_len_char(struct nk_str*);

	/*===============================================================
	 *
	 *                      TEXT EDITOR
	 *
	 * ===============================================================*/
	 /* Editing text in this library is handled by either `nk_edit_string` or
	  * `nk_edit_buffer`. But like almost everything in this library there are multiple
	  * ways of doing it and a balance between control and ease of use with memory
	  * as well as functionality controlled by flags.
	  *
	  * This library generally allows three different levels of memory control:
	  * First of is the most basic way of just providing a simple char array with
	  * string length. This method is probably the easiest way of handling simple
	  * user text input. Main upside is complete control over memory while the biggest
	  * downside in comparison with the other two approaches is missing undo/redo.
	  *
	  * For UIs that require undo/redo the second way was created. It is based on
	  * a fixed size nk_text_edit struct, which has an internal undo/redo stack.
	  * This is mainly useful if you want something more like a text editor but don't want
	  * to have a dynamically growing buffer.
	  *
	  * The final way is using a dynamically growing nk_text_edit struct, which
	  * has both a default version if you don't care where memory comes from and an
	  * allocator version if you do. While the text editor is quite powerful for its
	  * complexity I would not recommend editing gigabytes of data with it.
	  * It is rather designed for uses cases which make sense for a GUI library not for
	  * an full blown text editor.
	  */
#ifndef NK_TEXTEDIT_UNDOSTATECOUNT
#define NK_TEXTEDIT_UNDOSTATECOUNT     99
#endif

#ifndef NK_TEXTEDIT_UNDOCHARCOUNT
#define NK_TEXTEDIT_UNDOCHARCOUNT      999
#endif

	struct nk_text_edit;
	struct nk_clipboard {
		nk_handle userdata;
		nk_plugin_paste paste;
		nk_plugin_copy copy;
	};

	struct nk_text_undo_record {
		int where;
		short insert_length;
		short delete_length;
		short char_storage;
	};

	struct nk_text_undo_state {
		struct nk_text_undo_record undo_rec[NK_TEXTEDIT_UNDOSTATECOUNT];
		nk_rune undo_char[NK_TEXTEDIT_UNDOCHARCOUNT];
		short undo_point;
		short redo_point;
		short undo_char_point;
		short redo_char_point;
	};

	enum nk_text_edit_type {
		NK_TEXT_EDIT_SINGLE_LINE, NK_TEXT_EDIT_MULTI_LINE
	};

	enum nk_text_edit_mode {
		NK_TEXT_EDIT_MODE_VIEW, NK_TEXT_EDIT_MODE_INSERT, NK_TEXT_EDIT_MODE_REPLACE
	};

	struct nk_text_edit {
		struct nk_clipboard clip;
		struct nk_str string;
		nk_plugin_filter filter;
		struct nk_vec2 scrollbar;

		int cursor;
		int select_start;
		int select_end;
		unsigned char mode;
		unsigned char cursor_at_end_of_line;
		unsigned char initialized;
		unsigned char has_preferred_x;
		unsigned char single_line;
		unsigned char active;
		unsigned char padding1;
		float preferred_x;
		struct nk_text_undo_state undo;
	};

	/* filter function */
	NK_API int nk_filter_default(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_ascii(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_float(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_decimal(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_hex(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_oct(const struct nk_text_edit*, nk_rune unicode);

	NK_API int nk_filter_binary(const struct nk_text_edit*, nk_rune unicode);

	/* text editor */
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

	NK_API void nk_textedit_init_default(struct nk_text_edit*);

#endif

	NK_API void nk_textedit_init(struct nk_text_edit*, struct nk_allocator*, nk_size size);

	NK_API void nk_textedit_init_fixed(struct nk_text_edit*, void* memory, nk_size size);

	NK_API void nk_textedit_free(struct nk_text_edit*);

	NK_API void nk_textedit_text(struct nk_text_edit*, const char*, int total_len);

	NK_API void nk_textedit_delete(struct nk_text_edit*, int where, int len);

	NK_API void nk_textedit_delete_selection(struct nk_text_edit*);

	NK_API void nk_textedit_select_all(struct nk_text_edit*);

	NK_API int nk_textedit_cut(struct nk_text_edit*);

	NK_API int nk_textedit_paste(struct nk_text_edit*, char const*, int len);

	NK_API void nk_textedit_undo(struct nk_text_edit*);

	NK_API void nk_textedit_redo(struct nk_text_edit*);

	/* ===============================================================
	 *
	 *                          DRAWING
	 *
	 * ===============================================================*/
	 /*  This library was designed to be render backend agnostic so it does
		 not draw anything to screen. Instead all drawn shapes, widgets
		 are made of, are buffered into memory and make up a command queue.
		 Each frame therefore fills the command buffer with draw commands
		 that then need to be executed by the user and his own render backend.
		 After that the command buffer needs to be cleared and a new frame can be
		 started. It is probably important to note that the command buffer is the main
		 drawing API and the optional vertex buffer API only takes this format and
		 converts it into a hardware accessible format.

		 To use the command queue to draw your own widgets you can access the
		 command buffer of each window by calling `nk_window_get_canvas` after
		 previously having called `nk_begin`:

			 void draw_red_rectangle_widget(struct nk_context *ctx)
			 {
				 struct nk_command_buffer *canvas;
				 struct nk_input *input = &ctx->input;
				 canvas = nk_window_get_canvas(ctx);

				 struct nk_rect space;
				 enum nk_widget_layout_states state;
				 state = nk_widget(&space, ctx);
				 if (!state) return;

				 if (state != NK_WIDGET_ROM)
					 update_your_widget_by_user_input(...);
				 nk_fill_rect(canvas, space, 0, nk_rgb(255,0,0));
			 }

			 if (nk_begin(...)) {
				 nk_layout_row_dynamic(ctx, 25, 1);
				 draw_red_rectangle_widget(ctx);
			 }
			 nk_end(..)

		 Important to know if you want to create your own widgets is the `nk_widget`
		 call. It allocates space on the panel reserved for this widget to be used,
		 but also returns the state of the widget space. If your widget is not seen and does
		 not have to be updated it is '0' and you can just return. If it only has
		 to be drawn the state will be `NK_WIDGET_ROM` otherwise you can do both
		 update and draw your widget. The reason for separating is to only draw and
		 update what is actually necessary which is crucial for performance.
	 */
	enum nk_command_type {
		NK_COMMAND_NOP,
		NK_COMMAND_SCISSOR,
		NK_COMMAND_LINE,
		NK_COMMAND_CURVE,
		NK_COMMAND_RECT,
		NK_COMMAND_RECT_FILLED,
		NK_COMMAND_RECT_MULTI_COLOR,
		NK_COMMAND_CIRCLE,
		NK_COMMAND_CIRCLE_FILLED,
		NK_COMMAND_ARC,
		NK_COMMAND_ARC_FILLED,
		NK_COMMAND_TRIANGLE,
		NK_COMMAND_TRIANGLE_FILLED,
		NK_COMMAND_POLYGON,
		NK_COMMAND_POLYGON_FILLED,
		NK_COMMAND_POLYLINE,
		NK_COMMAND_TEXT,
		NK_COMMAND_IMAGE,
		NK_COMMAND_CUSTOM
	};

	/* command base and header of every command inside the buffer */
	struct nk_command {
		enum nk_command_type type;
		nk_size next;
#ifdef NK_INCLUDE_COMMAND_USERDATA
		nk_handle userdata;
#endif
	};

	struct nk_command_scissor {
		struct nk_command header;
		short x, y;
		unsigned short w, h;
	};

	struct nk_command_line {
		struct nk_command header;
		unsigned short line_thickness;
		struct nk_vec2i begin;
		struct nk_vec2i end;
		struct nk_color color;
	};

	struct nk_command_curve {
		struct nk_command header;
		unsigned short line_thickness;
		struct nk_vec2i begin;
		struct nk_vec2i end;
		struct nk_vec2i ctrl[2];
		struct nk_color color;
	};

	struct nk_command_rect {
		struct nk_command header;
		unsigned short rounding;
		unsigned short line_thickness;
		short x, y;
		unsigned short w, h;
		struct nk_color color;
	};

	struct nk_command_rect_filled {
		struct nk_command header;
		unsigned short rounding;
		short x, y;
		unsigned short w, h;
		struct nk_color color;
	};

	struct nk_command_rect_multi_color {
		struct nk_command header;
		short x, y;
		unsigned short w, h;
		struct nk_color left;
		struct nk_color top;
		struct nk_color bottom;
		struct nk_color right;
	};

	struct nk_command_triangle {
		struct nk_command header;
		unsigned short line_thickness;
		struct nk_vec2i a;
		struct nk_vec2i b;
		struct nk_vec2i c;
		struct nk_color color;
	};

	struct nk_command_triangle_filled {
		struct nk_command header;
		struct nk_vec2i a;
		struct nk_vec2i b;
		struct nk_vec2i c;
		struct nk_color color;
	};

	struct nk_command_circle {
		struct nk_command header;
		short x, y;
		unsigned short line_thickness;
		unsigned short w, h;
		struct nk_color color;
	};

	struct nk_command_circle_filled {
		struct nk_command header;
		short x, y;
		unsigned short w, h;
		struct nk_color color;
	};

	struct nk_command_arc {
		struct nk_command header;
		short cx, cy;
		unsigned short r;
		unsigned short line_thickness;
		float a[2];
		struct nk_color color;
	};

	struct nk_command_arc_filled {
		struct nk_command header;
		short cx, cy;
		unsigned short r;
		float a[2];
		struct nk_color color;
	};

	struct nk_command_polygon {
		struct nk_command header;
		struct nk_color color;
		unsigned short line_thickness;
		unsigned short point_count;
		struct nk_vec2i points[1];
	};

	struct nk_command_polygon_filled {
		struct nk_command header;
		struct nk_color color;
		unsigned short point_count;
		struct nk_vec2i points[1];
	};

	struct nk_command_polyline {
		struct nk_command header;
		struct nk_color color;
		unsigned short line_thickness;
		unsigned short point_count;
		struct nk_vec2i points[1];
	};

	struct nk_command_image {
		struct nk_command header;
		short x, y;
		unsigned short w, h;
		struct nk_image img;
		struct nk_color col;
	};

	typedef void (*nk_command_custom_callback)(void* canvas, short x, short y, unsigned short w, unsigned short h,
		nk_handle callback_data);

	struct nk_command_custom {
		struct nk_command header;
		short x, y;
		unsigned short w, h;
		nk_handle callback_data;
		nk_command_custom_callback callback;
	};

	struct nk_command_text {
		struct nk_command header;
		const struct nk_user_font* font;
		struct nk_color background;
		struct nk_color foreground;
		short x, y;
		unsigned short w, h;
		float height;
		int length;
		char string[1];
	};

	enum nk_command_clipping {
		NK_CLIPPING_OFF = nk_false, NK_CLIPPING_ON = nk_true
	};

	struct nk_command_buffer {
		struct nk_buffer* base;
		struct nk_rect clip;
		int use_clipping;
		nk_handle userdata;
		nk_size begin, end, last;
	};

	/* shape outlines */
	NK_API void nk_stroke_line(struct nk_command_buffer* b, float x0, float y0, float x1, float y1, float line_thickness,
		struct nk_color);

	NK_API void nk_stroke_curve(struct nk_command_buffer*, float, float, float, float, float, float, float, float,
		float line_thickness, struct nk_color);

	NK_API void
		nk_stroke_rect(struct nk_command_buffer*, struct nk_rect, float rounding, float line_thickness, struct nk_color);

	NK_API void nk_stroke_circle(struct nk_command_buffer*, struct nk_rect, float line_thickness, struct nk_color);

	NK_API void nk_stroke_arc(struct nk_command_buffer*, float cx, float cy, float radius, float a_min, float a_max,
		float line_thickness, struct nk_color);

	NK_API void
		nk_stroke_triangle(struct nk_command_buffer*, float, float, float, float, float, float, float line_thichness,
			struct nk_color);

	NK_API void nk_stroke_polyline(struct nk_command_buffer*, float* points, int point_count, float line_thickness,
		struct nk_color col);

	NK_API void
		nk_stroke_polygon(struct nk_command_buffer*, float*, int point_count, float line_thickness, struct nk_color);

	/* filled shades */
	NK_API void nk_fill_rect(struct nk_command_buffer*, struct nk_rect, float rounding, struct nk_color);

	NK_API void
		nk_fill_rect_multi_color(struct nk_command_buffer*, struct nk_rect, struct nk_color left, struct nk_color top,
			struct nk_color right, struct nk_color bottom);

	NK_API void nk_fill_circle(struct nk_command_buffer*, struct nk_rect, struct nk_color);

	NK_API void
		nk_fill_arc(struct nk_command_buffer*, float cx, float cy, float radius, float a_min, float a_max, struct nk_color);

	NK_API void nk_fill_triangle(struct nk_command_buffer*, float x0, float y0, float x1, float y1, float x2, float y2,
		struct nk_color);

	NK_API void nk_fill_polygon(struct nk_command_buffer*, float*, int point_count, struct nk_color);

	/* misc */
	NK_API void nk_draw_image(struct nk_command_buffer*, struct nk_rect, const struct nk_image*, struct nk_color);

	NK_API void
		nk_draw_text(struct nk_command_buffer*, struct nk_rect, const char* text, int len, const struct nk_user_font*,
			struct nk_color, struct nk_color);

	NK_API void nk_push_scissor(struct nk_command_buffer*, struct nk_rect);

	NK_API void nk_push_custom(struct nk_command_buffer*, struct nk_rect, nk_command_custom_callback, nk_handle usr);

	/* ===============================================================
	 *
	 *                          INPUT
	 *
	 * ===============================================================*/
	struct nk_mouse_button {
		int down;
		unsigned int clicked;
		struct nk_vec2 clicked_pos;
	};
	struct nk_mouse {
		struct nk_mouse_button buttons[NK_BUTTON_MAX];
		struct nk_vec2 pos;
		struct nk_vec2 prev;
		struct nk_vec2 delta;
		struct nk_vec2 scroll_delta;
		unsigned char grab;
		unsigned char grabbed;
		unsigned char ungrab;
	};

	struct nk_key {
		int down;
		unsigned int clicked;
	};
	struct nk_keyboard {
		struct nk_key keys[NK_KEY_MAX];
		char text[NK_INPUT_MAX];
		int text_len;
	};

	struct nk_input {
		struct nk_keyboard keyboard;
		struct nk_mouse mouse;
	};

	NK_API int nk_input_has_mouse_click(const struct nk_input*, enum nk_buttons);

	NK_API int nk_input_has_mouse_click_in_rect(const struct nk_input*, enum nk_buttons, struct nk_rect);

	NK_API int nk_input_has_mouse_click_down_in_rect(const struct nk_input*, enum nk_buttons, struct nk_rect, int down);

	NK_API int nk_input_is_mouse_click_in_rect(const struct nk_input*, enum nk_buttons, struct nk_rect);

	NK_API int
		nk_input_is_mouse_click_down_in_rect(const struct nk_input* i, enum nk_buttons id, struct nk_rect b, int down);

	NK_API int nk_input_any_mouse_click_in_rect(const struct nk_input*, struct nk_rect);

	NK_API int nk_input_is_mouse_prev_hovering_rect(const struct nk_input*, struct nk_rect);

	NK_API int nk_input_is_mouse_hovering_rect(const struct nk_input*, struct nk_rect);

	NK_API int nk_input_mouse_clicked(const struct nk_input*, enum nk_buttons, struct nk_rect);

	NK_API int nk_input_is_mouse_down(const struct nk_input*, enum nk_buttons);

	NK_API int nk_input_is_mouse_pressed(const struct nk_input*, enum nk_buttons);

	NK_API int nk_input_is_mouse_released(const struct nk_input*, enum nk_buttons);

	NK_API int nk_input_is_key_pressed(const struct nk_input*, enum nk_keys);

	NK_API int nk_input_is_key_released(const struct nk_input*, enum nk_keys);

	NK_API int nk_input_is_key_down(const struct nk_input*, enum nk_keys);

	/* ===============================================================
	 *
	 *                          DRAW LIST
	 *
	 * ===============================================================*/
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
	 /*  The optional vertex buffer draw list provides a 2D drawing context
with antialiasing functionality which takes basic filled or outlined shapes
or a path and outputs vertexes, elements and draw commands.
The actual draw list API is not required to be used directly while using this
library since converting the default library draw command output is done by
just calling `nk_convert` but I decided to still make this library accessible
since it can be useful.

The draw list is based on a path buffering and polygon and polyline
rendering API which allows a lot of ways to draw 2D content to screen.
In fact it is probably more powerful than needed but allows even more crazy
things than this library provides by default.
*/
#ifdef NK_UINT_DRAW_INDEX
	typedef nk_uint nk_draw_index;
#else
	typedef nk_ushort nk_draw_index;
#endif
	enum nk_draw_list_stroke {
		NK_STROKE_OPEN = nk_false,
		/* build up path has no connection back to the beginning */
		NK_STROKE_CLOSED = nk_true
		/* build up path has a connection back to the beginning */
	};

	enum nk_draw_vertex_layout_attribute {
		NK_VERTEX_POSITION,
		NK_VERTEX_COLOR,
		NK_VERTEX_TEXCOORD,
		NK_VERTEX_ATTRIBUTE_COUNT
	};

	enum nk_draw_vertex_layout_format {
		NK_FORMAT_SCHAR,
		NK_FORMAT_SSHORT,
		NK_FORMAT_SINT,
		NK_FORMAT_UCHAR,
		NK_FORMAT_USHORT,
		NK_FORMAT_UINT,
		NK_FORMAT_FLOAT,
		NK_FORMAT_DOUBLE,

		NK_FORMAT_COLOR_BEGIN,
		NK_FORMAT_R8G8B8 = NK_FORMAT_COLOR_BEGIN,
		NK_FORMAT_R16G15B16,
		NK_FORMAT_R32G32B32,

		NK_FORMAT_R8G8B8A8,
		NK_FORMAT_B8G8R8A8,
		NK_FORMAT_R16G15B16A16,
		NK_FORMAT_R32G32B32A32,
		NK_FORMAT_R32G32B32A32_FLOAT,
		NK_FORMAT_R32G32B32A32_DOUBLE,

		NK_FORMAT_RGB32,
		NK_FORMAT_RGBA32,
		NK_FORMAT_COLOR_END = NK_FORMAT_RGBA32,
		NK_FORMAT_COUNT
	};

#define NK_VERTEX_LAYOUT_END NK_VERTEX_ATTRIBUTE_COUNT,NK_FORMAT_COUNT,0
	struct nk_draw_vertex_layout_element {
		enum nk_draw_vertex_layout_attribute attribute;
		enum nk_draw_vertex_layout_format format;
		nk_size offset;
	};

	struct nk_draw_command {
		unsigned int elem_count;
		/* number of elements in the current draw batch */
		struct nk_rect clip_rect;
		/* current screen clipping rectangle */
		nk_handle texture;
		/* current texture to set */
#ifdef NK_INCLUDE_COMMAND_USERDATA
		nk_handle userdata;
#endif
	};

	struct nk_draw_list {
		struct nk_rect clip_rect;
		struct nk_vec2 circle_vtx[12];
		struct nk_convert_config config;

		struct nk_buffer* buffer;
		struct nk_buffer* vertices;
		struct nk_buffer* elements;

		unsigned int element_count;
		unsigned int vertex_count;
		unsigned int cmd_count;
		nk_size cmd_offset;

		unsigned int path_count;
		unsigned int path_offset;

		enum nk_anti_aliasing line_AA;
		enum nk_anti_aliasing shape_AA;

#ifdef NK_INCLUDE_COMMAND_USERDATA
		nk_handle userdata;
#endif
	};

	/* draw list */
	NK_API void nk_draw_list_init(struct nk_draw_list*);
	NK_API void nk_draw_list_setup(struct nk_draw_list*, const struct nk_convert_config*, struct nk_buffer* cmds, struct nk_buffer* vertices, struct nk_buffer* elements, enum nk_anti_aliasing line_aa, enum nk_anti_aliasing shape_aa);

	/* drawing */
#define nk_draw_list_foreach(cmd, can, b) for((cmd)=nk__draw_list_begin(can, b); (cmd)!=0; (cmd)=nk__draw_list_next(cmd, b, can))
	NK_API const struct nk_draw_command* nk__draw_list_begin(const struct nk_draw_list*, const struct nk_buffer*);
	NK_API const struct nk_draw_command* nk__draw_list_next(const struct nk_draw_command*, const struct nk_buffer*, const struct nk_draw_list*);
	NK_API const struct nk_draw_command* nk__draw_list_end(const struct nk_draw_list*, const struct nk_buffer*);

	/* path */
	NK_API void nk_draw_list_path_clear(struct nk_draw_list*);
	NK_API void nk_draw_list_path_line_to(struct nk_draw_list*, struct nk_vec2 pos);
	NK_API void nk_draw_list_path_arc_to_fast(struct nk_draw_list*, struct nk_vec2 center, float radius, int a_min, int a_max);
	NK_API void nk_draw_list_path_arc_to(struct nk_draw_list*, struct nk_vec2 center, float radius, float a_min, float a_max, unsigned int segments);
	NK_API void nk_draw_list_path_rect_to(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, float rounding);
	NK_API void nk_draw_list_path_curve_to(struct nk_draw_list*, struct nk_vec2 p2, struct nk_vec2 p3, struct nk_vec2 p4, unsigned int num_segments);
	NK_API void nk_draw_list_path_fill(struct nk_draw_list*, struct nk_color);
	NK_API void nk_draw_list_path_stroke(struct nk_draw_list*, struct nk_color, enum nk_draw_list_stroke closed, float thickness);

	/* stroke */
	NK_API void nk_draw_list_stroke_line(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, struct nk_color, float thickness);
	NK_API void nk_draw_list_stroke_rect(struct nk_draw_list*, struct nk_rect rect, struct nk_color, float rounding, float thickness);
	NK_API void nk_draw_list_stroke_triangle(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, struct nk_vec2 c, struct nk_color, float thickness);
	NK_API void nk_draw_list_stroke_circle(struct nk_draw_list*, struct nk_vec2 center, float radius, struct nk_color, unsigned int segs, float thickness);
	NK_API void nk_draw_list_stroke_curve(struct nk_draw_list*, struct nk_vec2 p0, struct nk_vec2 cp0, struct nk_vec2 cp1, struct nk_vec2 p1, struct nk_color, unsigned int segments, float thickness);
	NK_API void nk_draw_list_stroke_poly_line(struct nk_draw_list*, const struct nk_vec2* pnts, const unsigned int cnt, struct nk_color, enum nk_draw_list_stroke, float thickness, enum nk_anti_aliasing);

	/* fill */
	NK_API void nk_draw_list_fill_rect(struct nk_draw_list*, struct nk_rect rect, struct nk_color, float rounding);
	NK_API void nk_draw_list_fill_rect_multi_color(struct nk_draw_list*, struct nk_rect rect, struct nk_color left, struct nk_color top, struct nk_color right, struct nk_color bottom);
	NK_API void nk_draw_list_fill_triangle(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, struct nk_vec2 c, struct nk_color);
	NK_API void nk_draw_list_fill_circle(struct nk_draw_list*, struct nk_vec2 center, float radius, struct nk_color col, unsigned int segs);
	NK_API void nk_draw_list_fill_poly_convex(struct nk_draw_list*, const struct nk_vec2* points, const unsigned int count, struct nk_color, enum nk_anti_aliasing);

	/* misc */
	NK_API void nk_draw_list_add_image(struct nk_draw_list*, struct nk_image texture, struct nk_rect rect, struct nk_color);
	NK_API void nk_draw_list_add_text(struct nk_draw_list*, const struct nk_user_font*, struct nk_rect, const char* text, int len, float font_height, struct nk_color);
#ifdef NK_INCLUDE_COMMAND_USERDATA
	NK_API void nk_draw_list_push_userdata(struct nk_draw_list*, nk_handle userdata);
#endif

#endif

	/* ===============================================================
	 *
	 *                          GUI
	 *
	 * ===============================================================*/
	enum nk_style_item_type {
		NK_STYLE_ITEM_COLOR, NK_STYLE_ITEM_IMAGE
	};

	union nk_style_item_data {
		struct nk_image image;
		struct nk_color color;
	};

	struct nk_style_item {
		enum nk_style_item_type type;
		union nk_style_item_data data;
	};

	struct nk_style_text {
		struct nk_color color;
		struct nk_vec2 padding;
	};

	struct nk_style_button {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* text */
		struct nk_color text_background;
		struct nk_color text_normal;
		struct nk_color text_hover;
		struct nk_color text_active;
		nk_flags text_alignment;

		/* properties */
		float border;
		float rounding;
		struct nk_vec2 padding;
		struct nk_vec2 image_padding;
		struct nk_vec2 touch_padding;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle userdata);

		void (*draw_end)(struct nk_command_buffer*, nk_handle userdata);
	};

	struct nk_style_toggle {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* cursor */
		struct nk_style_item cursor_normal;
		struct nk_style_item cursor_hover;

		/* text */
		struct nk_color text_normal;
		struct nk_color text_hover;
		struct nk_color text_active;
		struct nk_color text_background;
		nk_flags text_alignment;

		/* properties */
		struct nk_vec2 padding;
		struct nk_vec2 touch_padding;
		float spacing;
		float border;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_selectable {
		/* background (inactive) */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item pressed;

		/* background (active) */
		struct nk_style_item normal_active;
		struct nk_style_item hover_active;
		struct nk_style_item pressed_active;

		/* text color (inactive) */
		struct nk_color text_normal;
		struct nk_color text_hover;
		struct nk_color text_pressed;

		/* text color (active) */
		struct nk_color text_normal_active;
		struct nk_color text_hover_active;
		struct nk_color text_pressed_active;
		struct nk_color text_background;
		nk_flags text_alignment;

		/* properties */
		float rounding;
		struct nk_vec2 padding;
		struct nk_vec2 touch_padding;
		struct nk_vec2 image_padding;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_slider {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* background bar */
		struct nk_color bar_normal;
		struct nk_color bar_hover;
		struct nk_color bar_active;
		struct nk_color bar_filled;

		/* cursor */
		struct nk_style_item cursor_normal;
		struct nk_style_item cursor_hover;
		struct nk_style_item cursor_active;

		/* properties */
		float border;
		float rounding;
		float bar_height;
		struct nk_vec2 padding;
		struct nk_vec2 spacing;
		struct nk_vec2 cursor_size;

		/* optional buttons */
		int show_buttons;
		struct nk_style_button inc_button;
		struct nk_style_button dec_button;
		enum nk_symbol_type inc_symbol;
		enum nk_symbol_type dec_symbol;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_progress {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* cursor */
		struct nk_style_item cursor_normal;
		struct nk_style_item cursor_hover;
		struct nk_style_item cursor_active;
		struct nk_color cursor_border_color;

		/* properties */
		float rounding;
		float border;
		float cursor_border;
		float cursor_rounding;
		struct nk_vec2 padding;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_scrollbar {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* cursor */
		struct nk_style_item cursor_normal;
		struct nk_style_item cursor_hover;
		struct nk_style_item cursor_active;
		struct nk_color cursor_border_color;

		/* properties */
		float border;
		float rounding;
		float border_cursor;
		float rounding_cursor;
		struct nk_vec2 padding;

		/* optional buttons */
		int show_buttons;
		struct nk_style_button inc_button;
		struct nk_style_button dec_button;
		enum nk_symbol_type inc_symbol;
		enum nk_symbol_type dec_symbol;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_edit {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;
		struct nk_style_scrollbar scrollbar;

		/* cursor  */
		struct nk_color cursor_normal;
		struct nk_color cursor_hover;
		struct nk_color cursor_text_normal;
		struct nk_color cursor_text_hover;

		/* text (unselected) */
		struct nk_color text_normal;
		struct nk_color text_hover;
		struct nk_color text_active;

		/* text (selected) */
		struct nk_color selected_normal;
		struct nk_color selected_hover;
		struct nk_color selected_text_normal;
		struct nk_color selected_text_hover;

		/* properties */
		float border;
		float rounding;
		float cursor_size;
		struct nk_vec2 scrollbar_size;
		struct nk_vec2 padding;
		float row_padding;
	};

	struct nk_style_property {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* text */
		struct nk_color label_normal;
		struct nk_color label_hover;
		struct nk_color label_active;

		/* symbols */
		enum nk_symbol_type sym_left;
		enum nk_symbol_type sym_right;

		/* properties */
		float border;
		float rounding;
		struct nk_vec2 padding;

		struct nk_style_edit edit;
		struct nk_style_button inc_button;
		struct nk_style_button dec_button;

		/* optional user callbacks */
		nk_handle userdata;

		void (*draw_begin)(struct nk_command_buffer*, nk_handle);

		void (*draw_end)(struct nk_command_buffer*, nk_handle);
	};

	struct nk_style_chart {
		/* colors */
		struct nk_style_item background;
		struct nk_color border_color;
		struct nk_color selected_color;
		struct nk_color color;

		/* properties */
		float border;
		float rounding;
		struct nk_vec2 padding;
	};

	struct nk_style_combo {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;
		struct nk_color border_color;

		/* label */
		struct nk_color label_normal;
		struct nk_color label_hover;
		struct nk_color label_active;

		/* symbol */
		struct nk_color symbol_normal;
		struct nk_color symbol_hover;
		struct nk_color symbol_active;

		/* button */
		struct nk_style_button button;
		enum nk_symbol_type sym_normal;
		enum nk_symbol_type sym_hover;
		enum nk_symbol_type sym_active;

		/* properties */
		float border;
		float rounding;
		struct nk_vec2 content_padding;
		struct nk_vec2 button_padding;
		struct nk_vec2 spacing;
	};

	struct nk_style_tab {
		/* background */
		struct nk_style_item background;
		struct nk_color border_color;
		struct nk_color text;

		/* button */
		struct nk_style_button tab_maximize_button;
		struct nk_style_button tab_minimize_button;
		struct nk_style_button node_maximize_button;
		struct nk_style_button node_minimize_button;
		enum nk_symbol_type sym_minimize;
		enum nk_symbol_type sym_maximize;

		/* properties */
		float border;
		float rounding;
		float indent;
		struct nk_vec2 padding;
		struct nk_vec2 spacing;
	};

	enum nk_style_header_align {
		NK_HEADER_LEFT, NK_HEADER_RIGHT
	};
	struct nk_style_window_header {
		/* background */
		struct nk_style_item normal;
		struct nk_style_item hover;
		struct nk_style_item active;

		/* button */
		struct nk_style_button close_button;
		struct nk_style_button minimize_button;
		enum nk_symbol_type close_symbol;
		enum nk_symbol_type minimize_symbol;
		enum nk_symbol_type maximize_symbol;

		/* title */
		struct nk_color label_normal;
		struct nk_color label_hover;
		struct nk_color label_active;

		/* properties */
		enum nk_style_header_align align;
		struct nk_vec2 padding;
		struct nk_vec2 label_padding;
		struct nk_vec2 spacing;
	};

	struct nk_style_window {
		struct nk_style_window_header header;
		struct nk_style_item fixed_background;
		struct nk_color background;

		struct nk_color border_color;
		struct nk_color popup_border_color;
		struct nk_color combo_border_color;
		struct nk_color contextual_border_color;
		struct nk_color menu_border_color;
		struct nk_color group_border_color;
		struct nk_color tooltip_border_color;
		struct nk_style_item scaler;

		float border;
		float combo_border;
		float contextual_border;
		float menu_border;
		float group_border;
		float tooltip_border;
		float popup_border;
		float min_row_height_padding;

		float rounding;
		struct nk_vec2 spacing;
		struct nk_vec2 scrollbar_size;
		struct nk_vec2 min_size;

		struct nk_vec2 padding;
		struct nk_vec2 group_padding;
		struct nk_vec2 popup_padding;
		struct nk_vec2 combo_padding;
		struct nk_vec2 contextual_padding;
		struct nk_vec2 menu_padding;
		struct nk_vec2 tooltip_padding;
	};

	struct nk_style {
		const struct nk_user_font* font;
		const struct nk_cursor* cursors[NK_CURSOR_COUNT];
		const struct nk_cursor* cursor_active;
		struct nk_cursor* cursor_last;
		int cursor_visible;

		struct nk_style_text text;
		struct nk_style_button button;
		struct nk_style_button contextual_button;
		struct nk_style_button menu_button;
		struct nk_style_toggle option;
		struct nk_style_toggle checkbox;
		struct nk_style_selectable selectable;
		struct nk_style_slider slider;
		struct nk_style_progress progress;
		struct nk_style_property property;
		struct nk_style_edit edit;
		struct nk_style_chart chart;
		struct nk_style_scrollbar scrollh;
		struct nk_style_scrollbar scrollv;
		struct nk_style_tab tab;
		struct nk_style_combo combo;
		struct nk_style_window window;
	};

	NK_API struct nk_style_item nk_style_item_image(struct nk_image img);

	NK_API struct nk_style_item nk_style_item_color(struct nk_color);

	NK_API struct nk_style_item nk_style_item_hide(void);

	/*==============================================================
	 *                          PANEL
	 * =============================================================*/
#ifndef NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS
#define NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS 16
#endif
#ifndef NK_CHART_MAX_SLOT
#define NK_CHART_MAX_SLOT 4
#endif

	enum nk_panel_type {
		NK_PANEL_NONE = 0,
		NK_PANEL_WINDOW = NK_FLAG(0),
		NK_PANEL_GROUP = NK_FLAG(1),
		NK_PANEL_POPUP = NK_FLAG(2),
		NK_PANEL_CONTEXTUAL = NK_FLAG(4),
		NK_PANEL_COMBO = NK_FLAG(5),
		NK_PANEL_MENU = NK_FLAG(6),
		NK_PANEL_TOOLTIP = NK_FLAG(7)
	};
	enum nk_panel_set {
		NK_PANEL_SET_NONBLOCK = NK_PANEL_CONTEXTUAL | NK_PANEL_COMBO | NK_PANEL_MENU | NK_PANEL_TOOLTIP,
		NK_PANEL_SET_POPUP = NK_PANEL_SET_NONBLOCK | NK_PANEL_POPUP,
		NK_PANEL_SET_SUB = NK_PANEL_SET_POPUP | NK_PANEL_GROUP
	};

	struct nk_chart_slot {
		enum nk_chart_type type;
		struct nk_color color;
		struct nk_color highlight;
		float min, max, range;
		int count;
		struct nk_vec2 last;
		int index;
	};

	struct nk_chart {
		int slot;
		float x, y, w, h;
		struct nk_chart_slot slots[NK_CHART_MAX_SLOT];
	};

	enum nk_panel_row_layout_type {
		NK_LAYOUT_DYNAMIC_FIXED = 0,
		NK_LAYOUT_DYNAMIC_ROW,
		NK_LAYOUT_DYNAMIC_FREE,
		NK_LAYOUT_DYNAMIC,
		NK_LAYOUT_STATIC_FIXED,
		NK_LAYOUT_STATIC_ROW,
		NK_LAYOUT_STATIC_FREE,
		NK_LAYOUT_STATIC,
		NK_LAYOUT_TEMPLATE,
		NK_LAYOUT_COUNT
	};
	struct nk_row_layout {
		enum nk_panel_row_layout_type type;
		int index;
		float height;
		float min_height;
		int columns;
		const float* ratio;
		float item_width;
		float item_height;
		float item_offset;
		float filled;
		struct nk_rect item;
		int tree_depth;
		float templates[NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS];
	};

	struct nk_popup_buffer {
		nk_size begin;
		nk_size parent;
		nk_size last;
		nk_size end;
		int active;
	};

	struct nk_menu_state {
		float x, y, w, h;
		struct nk_scroll offset;
	};

	struct nk_panel {
		enum nk_panel_type type;
		nk_flags flags;
		struct nk_rect bounds;
		nk_uint* offset_x;
		nk_uint* offset_y;
		float at_x, at_y, max_x;
		float footer_height;
		float header_height;
		float border;
		unsigned int has_scrolling;
		struct nk_rect clip;
		struct nk_menu_state menu;
		struct nk_row_layout row;
		struct nk_chart chart;
		struct nk_command_buffer* buffer;
		struct nk_panel* parent;
	};

	/*==============================================================
	 *                          WINDOW
	 * =============================================================*/
#ifndef NK_WINDOW_MAX_NAME
#define NK_WINDOW_MAX_NAME 64
#endif

	struct nk_table;
	enum nk_window_flags {
		NK_WINDOW_PRIVATE = NK_FLAG(11),
		NK_WINDOW_DYNAMIC = NK_WINDOW_PRIVATE,
		/* special window type growing up in height while being filled to a certain maximum height */
		NK_WINDOW_ROM = NK_FLAG(12),
		/* sets window widgets into a read only mode and does not allow input changes */
		NK_WINDOW_NOT_INTERACTIVE = NK_WINDOW_ROM | NK_WINDOW_NO_INPUT,
		/* prevents all interaction caused by input to either window or widgets inside */
		NK_WINDOW_HIDDEN = NK_FLAG(13),
		/* Hides window and stops any window interaction and drawing */
		NK_WINDOW_CLOSED = NK_FLAG(14),
		/* Directly closes and frees the window at the end of the frame */
		NK_WINDOW_MINIMIZED = NK_FLAG(15),
		/* marks the window as minimized */
		NK_WINDOW_REMOVE_ROM = NK_FLAG(16)
		/* Removes read only mode at the end of the window */
	};

	struct nk_popup_state {
		struct nk_window* win;
		enum nk_panel_type type;
		struct nk_popup_buffer buf;
		nk_hash name;
		int active;
		unsigned combo_count;
		unsigned con_count, con_old;
		unsigned active_con;
		struct nk_rect header;
	};

	struct nk_edit_state {
		nk_hash name;
		unsigned int seq;
		unsigned int old;
		int active, prev;
		int cursor;
		int sel_start;
		int sel_end;
		struct nk_scroll scrollbar;
		unsigned char mode;
		unsigned char single_line;
	};

	struct nk_property_state {
		int active, prev;
		char buffer[NK_MAX_NUMBER_BUFFER];
		int length;
		int cursor;
		int select_start;
		int select_end;
		nk_hash name;
		unsigned int seq;
		unsigned int old;
		int state;
	};

	struct nk_window {
		unsigned int seq;
		nk_hash name;
		char name_string[NK_WINDOW_MAX_NAME];
		nk_flags flags;

		struct nk_rect bounds;
		struct nk_scroll scrollbar;
		struct nk_command_buffer buffer;
		struct nk_panel* layout;
		float scrollbar_hiding_timer;

		/* persistent widget state */
		struct nk_property_state property;
		struct nk_popup_state popup;
		struct nk_edit_state edit;
		unsigned int scrolled;

		struct nk_table* tables;
		unsigned int table_count;

		/* window list hooks */
		struct nk_window* next;
		struct nk_window* prev;
		struct nk_window* parent;
	};

	/*==============================================================
	 *                          STACK
	 * =============================================================*/
	 /* The style modifier stack can be used to temporarily change a
	  * property inside `nk_style`. For example if you want a special
	  * red button you can temporarily push the old button color onto a stack
	  * draw the button with a red color and then you just pop the old color
	  * back from the stack:
	  *
	  *      nk_style_push_style_item(ctx, &ctx->style.button.normal, nk_style_item_color(nk_rgb(255,0,0)));
	  *      nk_style_push_style_item(ctx, &ctx->style.button.hover, nk_style_item_color(nk_rgb(255,0,0)));
	  *      nk_style_push_style_item(ctx, &ctx->style.button.active, nk_style_item_color(nk_rgb(255,0,0)));
	  *      nk_style_push_vec2(ctx, &cx->style.button.padding, nk_vec2(2,2));
	  *
	  *      nk_button(...);
	  *
	  *      nk_style_pop_style_item(ctx);
	  *      nk_style_pop_style_item(ctx);
	  *      nk_style_pop_style_item(ctx);
	  *      nk_style_pop_vec2(ctx);
	  *
	  * Nuklear has a stack for style_items, float properties, vector properties,
	  * flags, colors, fonts and for button_behavior. Each has it's own fixed size stack
	  * which can be changed at compile time.
	  */
#ifndef NK_BUTTON_BEHAVIOR_STACK_SIZE
#define NK_BUTTON_BEHAVIOR_STACK_SIZE 8
#endif

#ifndef NK_FONT_STACK_SIZE
#define NK_FONT_STACK_SIZE 8
#endif

#ifndef NK_STYLE_ITEM_STACK_SIZE
#define NK_STYLE_ITEM_STACK_SIZE 16
#endif

#ifndef NK_FLOAT_STACK_SIZE
#define NK_FLOAT_STACK_SIZE 32
#endif

#ifndef NK_VECTOR_STACK_SIZE
#define NK_VECTOR_STACK_SIZE 16
#endif

#ifndef NK_FLAGS_STACK_SIZE
#define NK_FLAGS_STACK_SIZE 32
#endif

#ifndef NK_COLOR_STACK_SIZE
#define NK_COLOR_STACK_SIZE 32
#endif

#define NK_CONFIGURATION_STACK_TYPE(prefix, name, type)\
    struct nk_config_stack_##name##_element {\
        prefix##_##type *address;\
        prefix##_##type old_value;\
    }
#define NK_CONFIG_STACK(type, size)\
    struct nk_config_stack_##type {\
        int head;\
        struct nk_config_stack_##type##_element elements[size];\
    }

#define nk_float float
	NK_CONFIGURATION_STACK_TYPE(struct nk, style_item, style_item);
	NK_CONFIGURATION_STACK_TYPE(nk, float, float);
	NK_CONFIGURATION_STACK_TYPE(struct nk, vec2, vec2);
	NK_CONFIGURATION_STACK_TYPE(nk, flags, flags);
	NK_CONFIGURATION_STACK_TYPE(struct nk, color, color);
	NK_CONFIGURATION_STACK_TYPE(const struct nk, user_font, user_font*);
	NK_CONFIGURATION_STACK_TYPE(enum nk, button_behavior, button_behavior);

	NK_CONFIG_STACK(style_item, NK_STYLE_ITEM_STACK_SIZE);
	NK_CONFIG_STACK(float, NK_FLOAT_STACK_SIZE);
	NK_CONFIG_STACK(vec2, NK_VECTOR_STACK_SIZE);
	NK_CONFIG_STACK(flags, NK_FLAGS_STACK_SIZE);
	NK_CONFIG_STACK(color, NK_COLOR_STACK_SIZE);
	NK_CONFIG_STACK(user_font, NK_FONT_STACK_SIZE);
	NK_CONFIG_STACK(button_behavior, NK_BUTTON_BEHAVIOR_STACK_SIZE);

	struct nk_configuration_stacks {
		struct nk_config_stack_style_item style_items;
		struct nk_config_stack_float floats;
		struct nk_config_stack_vec2 vectors;
		struct nk_config_stack_flags flags;
		struct nk_config_stack_color colors;
		struct nk_config_stack_user_font fonts;
		struct nk_config_stack_button_behavior button_behaviors;
	};

	/*==============================================================
	 *                          CONTEXT
	 * =============================================================*/
#define NK_VALUE_PAGE_CAPACITY \
    (((NK_MAX(sizeof(struct nk_window),sizeof(struct nk_panel)) / sizeof(nk_uint))) / 2)

	struct nk_table {
		unsigned int seq;
		unsigned int size;
		nk_hash keys[NK_VALUE_PAGE_CAPACITY];
		nk_uint values[NK_VALUE_PAGE_CAPACITY];
		struct nk_table* next, * prev;
	};

	union nk_page_data {
		struct nk_table tbl;
		struct nk_panel pan;
		struct nk_window win;
	};

	struct nk_page_element {
		union nk_page_data data;
		struct nk_page_element* next;
		struct nk_page_element* prev;
	};

	struct nk_page {
		unsigned int size;
		struct nk_page* next;
		struct nk_page_element win[1];
	};

	struct nk_pool {
		struct nk_allocator alloc;
		enum nk_allocation_type type;
		unsigned int page_count;
		struct nk_page* pages;
		struct nk_page_element* freelist;
		unsigned capacity;
		nk_size size;
		nk_size cap;
	};

	struct nk_context {
		/* public: can be accessed freely */
		struct nk_input input;
		struct nk_style style;
		struct nk_buffer memory;
		struct nk_clipboard clip;
		nk_flags last_widget_state;
		enum nk_button_behavior button_behavior;
		struct nk_configuration_stacks stacks;
		float delta_time_seconds;

		/* private:
			should only be accessed if you
			know what you are doing */
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
		struct nk_draw_list draw_list;
#endif
#ifdef NK_INCLUDE_COMMAND_USERDATA
		nk_handle userdata;
#endif
		/* text editor objects are quite big because of an internal
		 * undo/redo stack. Therefore it does not make sense to have one for
		 * each window for temporary use cases, so I only provide *one* instance
		 * for all windows. This works because the content is cleared anyway */
		struct nk_text_edit text_edit;
		/* draw buffer used for overlay drawing operation like cursor */
		struct nk_command_buffer overlay;

		/* windows */
		int build;
		int use_pool;
		struct nk_pool pool;
		struct nk_window* begin;
		struct nk_window* end;
		struct nk_window* active;
		struct nk_window* current;
		struct nk_page_element* freelist;
		unsigned int count;
		unsigned int seq;
	};

	/* ==============================================================
	 *                          MATH
	 * =============================================================== */
#define NK_PI 3.141592654f
#define NK_UTF_INVALID 0xFFFD
#define NK_MAX_FLOAT_PRECISION 2

#define NK_UNUSED(x) ((void)(x))
#define NK_SATURATE(x) (NK_MAX(0, NK_MIN(1.0f, x)))
#define NK_LEN(a) (sizeof(a)/sizeof(a)[0])
#define NK_ABS(a) (((a) < 0) ? -(a) : (a))
#define NK_BETWEEN(x, a, b) ((a) <= (x) && (x) < (b))
#define NK_INBOX(px, py, x, y, w, h)\
    (NK_BETWEEN(px,x,x+w) && NK_BETWEEN(py,y,y+h))
#define NK_INTERSECT(x0, y0, w0, h0, x1, y1, w1, h1) \
    (!(((x1 > (x0 + w0)) || ((x1 + w1) < x0) || (y1 > (y0 + h0)) || (y1 + h1) < y0)))
#define NK_CONTAINS(x, y, w, h, bx, by, bw, bh)\
    (NK_INBOX(x,y, bx, by, bw, bh) && NK_INBOX(x+w,y+h, bx, by, bw, bh))

#define nk_vec2_sub(a, b) nk_vec2((a).x - (b).x, (a).y - (b).y)
#define nk_vec2_add(a, b) nk_vec2((a).x + (b).x, (a).y + (b).y)
#define nk_vec2_len_sqr(a) ((a).x*(a).x+(a).y*(a).y)
#define nk_vec2_muls(a, t) nk_vec2((a).x * (t), (a).y * (t))

#define nk_ptr_add(t, p, i) ((t*)((void*)((nk_byte*)(p) + (i))))
#define nk_ptr_add_const(t, p, i) ((const t*)((const void*)((const nk_byte*)(p) + (i))))
#define nk_zero_struct(s) nk_zero(&s, sizeof(s))

	 /* ==============================================================
	  *                          ALIGNMENT
	  * =============================================================== */
	  /* Pointer to Integer type conversion for pointer alignment */
#if defined(__PTRDIFF_TYPE__) /* This case should work for GCC*/
# define NK_UINT_TO_PTR(x) ((void*)(__PTRDIFF_TYPE__)(x))
# define NK_PTR_TO_UINT(x) ((nk_size)(__PTRDIFF_TYPE__)(x))
#elif !defined(__GNUC__) /* works for compilers other than LLVM */
# define NK_UINT_TO_PTR(x) ((void*)&((char*)0)[x])
# define NK_PTR_TO_UINT(x) ((nk_size)(((char*)x)-(char*)0))
#elif defined(NK_USE_FIXED_TYPES) /* used if we have <stdint.h> */
# define NK_UINT_TO_PTR(x) ((void*)(uintptr_t)(x))
# define NK_PTR_TO_UINT(x) ((uintptr_t)(x))
#else /* generates warning but works */
# define NK_UINT_TO_PTR(x) ((void*)(x))
# define NK_PTR_TO_UINT(x) ((nk_size)(x))
#endif

#define NK_ALIGN_PTR(x, mask)\
    (NK_UINT_TO_PTR((NK_PTR_TO_UINT((nk_byte*)(x) + (mask-1)) & ~(mask-1))))
#define NK_ALIGN_PTR_BACK(x, mask)\
    (NK_UINT_TO_PTR((NK_PTR_TO_UINT((nk_byte*)(x)) & ~(mask-1))))

#define NK_OFFSETOF(st, m) ((nk_ptr)&(((st*)0)->m))
#define NK_CONTAINER_OF(ptr, type, member)\
    (type*)((void*)((char*)(1 ? (ptr): &((type*)0)->member) - NK_OFFSETOF(type, member)))

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
template<typename T> struct nk_alignof;
template<typename T, int size_diff> struct nk_helper { enum { value = size_diff }; };
template<typename T> struct nk_helper<T, 0> { enum { value = nk_alignof<T>::value }; };
template<typename T> struct nk_alignof {
	struct Big { T x; char c; }; enum {
		diff = sizeof(Big) - sizeof(T), value = nk_helper<Big, diff>::value
	};
};
#define NK_ALIGNOF(t) (nk_alignof<t>::value)
#elif defined(_MSC_VER)
#define NK_ALIGNOF(t) (__alignof(t))
#else
#define NK_ALIGNOF(t) ((char*)(&((struct {char c; t _h;}*)0)->_h) - (char*)0)
#endif

#endif /* NK_NUKLEAR_H_ */


#ifdef NK_IMPLEMENTATION

#ifndef NK_INTERNAL_H
#define NK_INTERNAL_H

#ifndef NK_POOL_DEFAULT_CAPACITY
#define NK_POOL_DEFAULT_CAPACITY 16
#endif

#ifndef NK_DEFAULT_COMMAND_BUFFER_SIZE
#define NK_DEFAULT_COMMAND_BUFFER_SIZE (4*1024)
#endif

#ifndef NK_BUFFER_DEFAULT_INITIAL_SIZE
#define NK_BUFFER_DEFAULT_INITIAL_SIZE (4*1024)
#endif

/* standard library headers */
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

#include <stdlib.h> /* malloc, free */

#endif
#ifdef NK_INCLUDE_STANDARD_IO

#include <stdio.h> /* fopen, fclose,... */

#endif
#ifdef NK_INCLUDE_STANDARD_VARARGS

#include <stdarg.h> /* valist, va_start, va_end, ... */

#endif
#ifndef NK_ASSERT

#include <assert.h>

#define NK_ASSERT(expr) assert(expr)
#endif

#ifndef NK_MEMSET
#define NK_MEMSET nk_memset
#endif
#ifndef NK_MEMCPY
#define NK_MEMCPY nk_memcopy
#endif
#ifndef NK_SQRT
#define NK_SQRT nk_sqrt
#endif
#ifndef NK_SIN
#define NK_SIN nk_sin
#endif
#ifndef NK_COS
#define NK_COS nk_cos
#endif
#ifndef NK_STRTOD
#define NK_STRTOD nk_strtod
#endif
#ifndef NK_DTOA
#define NK_DTOA nk_dtoa
#endif

#define NK_DEFAULT (-1)

#ifndef NK_VSNPRINTF
/* If your compiler does support `vsnprintf` I would highly recommend
 * defining this to vsnprintf instead since `vsprintf` is basically
 * unbelievable unsafe and should *NEVER* be used. But I have to support
 * it since C89 only provides this unsafe version. */
#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
      (defined(__cplusplus) && (__cplusplus >= 201103L)) || \
      (defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE >= 200112L)) || \
      (defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE >= 500)) || \
       defined(_ISOC99_SOURCE) || defined(_BSD_SOURCE)
#define NK_VSNPRINTF(s, n, f, a) vsnprintf(s,n,f,a)
#else
#define NK_VSNPRINTF(s,n,f,a) vsprintf(s,f,a)
#endif
#endif

#define NK_SCHAR_MIN (-127)
#define NK_SCHAR_MAX 127
#define NK_UCHAR_MIN 0
#define NK_UCHAR_MAX 256
#define NK_SSHORT_MIN (-32767)
#define NK_SSHORT_MAX 32767
#define NK_USHORT_MIN 0
#define NK_USHORT_MAX 65535
#define NK_SINT_MIN (-2147483647)
#define NK_SINT_MAX 2147483647
#define NK_UINT_MIN 0
#define NK_UINT_MAX 4294967295u

 /* Make sure correct type size:
  * This will fire with a negative subscript error if the type sizes
  * are set incorrectly by the compiler, and compile out if not */
NK_STATIC_ASSERT(sizeof(nk_size) >= sizeof(void*));
NK_STATIC_ASSERT(sizeof(nk_ptr) == sizeof(void*));
NK_STATIC_ASSERT(sizeof(nk_flags) >= 4);
NK_STATIC_ASSERT(sizeof(nk_rune) >= 4);
NK_STATIC_ASSERT(sizeof(nk_ushort) == 2);
NK_STATIC_ASSERT(sizeof(nk_short) == 2);
NK_STATIC_ASSERT(sizeof(nk_uint) == 4);
NK_STATIC_ASSERT(sizeof(nk_int) == 4);
NK_STATIC_ASSERT(sizeof(nk_byte) == 1);

NK_GLOBAL const struct nk_rect nk_null_rect = { -8192.0f, -8192.0f, 16384, 16384 };
#define NK_FLOAT_PRECISION 0.00000000000001

NK_GLOBAL const struct nk_color nk_red = { 255, 0, 0, 255 };
NK_GLOBAL const struct nk_color nk_green = { 0, 255, 0, 255 };
NK_GLOBAL const struct nk_color nk_blue = { 0, 0, 255, 255 };
NK_GLOBAL const struct nk_color nk_white = { 255, 255, 255, 255 };
NK_GLOBAL const struct nk_color nk_black = { 0, 0, 0, 255 };
NK_GLOBAL const struct nk_color nk_yellow = { 255, 255, 0, 255 };

/* widget */
#define nk_widget_state_reset(s)\
    if ((*(s)) & NK_WIDGET_STATE_MODIFIED)\
        (*(s)) = NK_WIDGET_STATE_INACTIVE|NK_WIDGET_STATE_MODIFIED;\
    else (*(s)) = NK_WIDGET_STATE_INACTIVE;

/* math */
NK_LIB float nk_inv_sqrt(float n);

NK_LIB float nk_sqrt(float x);

NK_LIB float nk_sin(float x);

NK_LIB float nk_cos(float x);

NK_LIB nk_uint nk_round_up_pow2(nk_uint v);

NK_LIB struct nk_rect nk_shrink_rect(struct nk_rect r, float amount);

NK_LIB struct nk_rect nk_pad_rect(struct nk_rect r, struct nk_vec2 pad);

NK_LIB void nk_unify(struct nk_rect* clip, const struct nk_rect* a, float x0, float y0, float x1, float y1);

NK_LIB double nk_pow(double x, int n);

NK_LIB int nk_ifloord(double x);

NK_LIB int nk_ifloorf(float x);

NK_LIB int nk_iceilf(float x);

NK_LIB int nk_log10(double n);

/* util */
enum {
	NK_DO_NOT_STOP_ON_NEW_LINE, NK_STOP_ON_NEW_LINE
};

NK_LIB int nk_is_lower(int c);

NK_LIB int nk_is_upper(int c);

NK_LIB int nk_to_upper(int c);

NK_LIB int nk_to_lower(int c);

NK_LIB void* nk_memcopy(void* dst, const void* src, nk_size n);

NK_LIB void nk_memset(void* ptr, int c0, nk_size size);

NK_LIB void nk_zero(void* ptr, nk_size size);

NK_LIB char* nk_itoa(char* s, long n);

NK_LIB int nk_string_float_limit(char* string, int prec);

NK_LIB char* nk_dtoa(char* s, double n);

NK_LIB int nk_text_clamp(const struct nk_user_font* font, const char* text, int text_len, float space, int* glyphs,
	float* text_width, nk_rune* sep_list, int sep_count);

NK_LIB struct nk_vec2
nk_text_calculate_text_bounds(const struct nk_user_font* font, const char* begin, int byte_len, float row_height,
	const char** remaining, struct nk_vec2* out_offset, int* glyphs, int op);

#ifdef NK_INCLUDE_STANDARD_VARARGS

NK_LIB int nk_strfmt(char* buf, int buf_size, const char* fmt, va_list args);

#endif
#ifdef NK_INCLUDE_STANDARD_IO

NK_LIB char* nk_file_load(const char* path, nk_size* siz, struct nk_allocator* alloc);

#endif

/* buffer */
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

NK_LIB void* nk_malloc(nk_handle unused, void* old, nk_size size);

NK_LIB void nk_mfree(nk_handle unused, void* ptr);

#endif

NK_LIB void* nk_buffer_align(void* unaligned, nk_size align, nk_size* alignment, enum nk_buffer_allocation_type type);

NK_LIB void* nk_buffer_alloc(struct nk_buffer* b, enum nk_buffer_allocation_type type, nk_size size, nk_size align);

NK_LIB void* nk_buffer_realloc(struct nk_buffer* b, nk_size capacity, nk_size* size);

/* draw */
NK_LIB void nk_command_buffer_init(struct nk_command_buffer* cb, struct nk_buffer* b, enum nk_command_clipping clip);

NK_LIB void nk_command_buffer_reset(struct nk_command_buffer* b);

NK_LIB void* nk_command_buffer_push(struct nk_command_buffer* b, enum nk_command_type t, nk_size size);

NK_LIB void nk_draw_symbol(struct nk_command_buffer* out, enum nk_symbol_type type, struct nk_rect content,
	struct nk_color background, struct nk_color foreground, float border_width,
	const struct nk_user_font* font);

/* buffering */
NK_LIB void nk_start_buffer(struct nk_context* ctx, struct nk_command_buffer* b);

NK_LIB void nk_start(struct nk_context* ctx, struct nk_window* win);

NK_LIB void nk_start_popup(struct nk_context* ctx, struct nk_window* win);

NK_LIB void nk_finish_popup(struct nk_context* ctx, struct nk_window*);

NK_LIB void nk_finish_buffer(struct nk_context* ctx, struct nk_command_buffer* b);

NK_LIB void nk_finish(struct nk_context* ctx, struct nk_window* w);

NK_LIB void nk_build(struct nk_context* ctx);

/* text editor */
NK_LIB void nk_textedit_clear_state(struct nk_text_edit* state, enum nk_text_edit_type type, nk_plugin_filter filter);

NK_LIB void
nk_textedit_click(struct nk_text_edit* state, float x, float y, const struct nk_user_font* font, float row_height);

NK_LIB void
nk_textedit_drag(struct nk_text_edit* state, float x, float y, const struct nk_user_font* font, float row_height);

NK_LIB void
nk_textedit_key(struct nk_text_edit* state, enum nk_keys key, int shift_mod, const struct nk_user_font* font,
	float row_height);

/* window */
enum nk_window_insert_location {
	NK_INSERT_BACK, /* inserts window into the back of list (front of screen) */
	NK_INSERT_FRONT /* inserts window into the front of list (back of screen) */
};

NK_LIB void* nk_create_window(struct nk_context* ctx);

NK_LIB void nk_remove_window(struct nk_context*, struct nk_window*);

NK_LIB void nk_free_window(struct nk_context* ctx, struct nk_window* win);

NK_LIB struct nk_window* nk_find_window(struct nk_context* ctx, nk_hash hash, const char* name);

NK_LIB void nk_insert_window(struct nk_context* ctx, struct nk_window* win, enum nk_window_insert_location loc);

/* pool */
NK_LIB void nk_pool_init(struct nk_pool* pool, struct nk_allocator* alloc, unsigned int capacity);

NK_LIB void nk_pool_free(struct nk_pool* pool);

NK_LIB void nk_pool_init_fixed(struct nk_pool* pool, void* memory, nk_size size);

NK_LIB struct nk_page_element* nk_pool_alloc(struct nk_pool* pool);

/* page-element */
NK_LIB struct nk_page_element* nk_create_page_element(struct nk_context* ctx);

NK_LIB void nk_link_page_element_into_freelist(struct nk_context* ctx, struct nk_page_element* elem);

NK_LIB void nk_free_page_element(struct nk_context* ctx, struct nk_page_element* elem);

/* table */
NK_LIB struct nk_table* nk_create_table(struct nk_context* ctx);

NK_LIB void nk_remove_table(struct nk_window* win, struct nk_table* tbl);

NK_LIB void nk_free_table(struct nk_context* ctx, struct nk_table* tbl);

NK_LIB void nk_push_table(struct nk_window* win, struct nk_table* tbl);

NK_LIB nk_uint* nk_add_value(struct nk_context* ctx, struct nk_window* win, nk_hash name, nk_uint value);

NK_LIB nk_uint* nk_find_value(struct nk_window* win, nk_hash name);

/* panel */
NK_LIB void* nk_create_panel(struct nk_context* ctx);

NK_LIB void nk_free_panel(struct nk_context*, struct nk_panel* pan);

NK_LIB int nk_panel_has_header(nk_flags flags, const char* title);

NK_LIB struct nk_vec2 nk_panel_get_padding(const struct nk_style* style, enum nk_panel_type type);

NK_LIB float nk_panel_get_border(const struct nk_style* style, nk_flags flags, enum nk_panel_type type);

NK_LIB struct nk_color nk_panel_get_border_color(const struct nk_style* style, enum nk_panel_type type);

NK_LIB int nk_panel_is_sub(enum nk_panel_type type);

NK_LIB int nk_panel_is_nonblock(enum nk_panel_type type);

NK_LIB int nk_panel_begin(struct nk_context* ctx, const char* title, enum nk_panel_type panel_type);

NK_LIB void nk_panel_end(struct nk_context* ctx);

/* layout */
NK_LIB float
nk_layout_row_calculate_usable_space(const struct nk_style* style, enum nk_panel_type type, float total_space,
	int columns);

NK_LIB void nk_panel_layout(const struct nk_context* ctx, struct nk_window* win, float height, int cols);

NK_LIB void nk_row_layout(struct nk_context* ctx, enum nk_layout_format fmt, float height, int cols, int width);

NK_LIB void nk_panel_alloc_row(const struct nk_context* ctx, struct nk_window* win);

NK_LIB void
nk_layout_widget_space(struct nk_rect* bounds, const struct nk_context* ctx, struct nk_window* win, int modify);

NK_LIB void nk_panel_alloc_space(struct nk_rect* bounds, const struct nk_context* ctx);

NK_LIB void nk_layout_peek(struct nk_rect* bounds, struct nk_context* ctx);

/* popup */
NK_LIB int nk_nonblock_begin(struct nk_context* ctx, nk_flags flags, struct nk_rect body, struct nk_rect header,
	enum nk_panel_type panel_type);

/* text */
struct nk_text {
	struct nk_vec2 padding;
	struct nk_color background;
	struct nk_color text;
};

NK_LIB void
nk_widget_text(struct nk_command_buffer* o, struct nk_rect b, const char* string, int len, const struct nk_text* t,
	nk_flags a, const struct nk_user_font* f);

NK_LIB void
nk_widget_text_wrap(struct nk_command_buffer* o, struct nk_rect b, const char* string, int len, const struct nk_text* t,
	const struct nk_user_font* f);

/* button */
NK_LIB int
nk_button_behavior(nk_flags* state, struct nk_rect r, const struct nk_input* i, enum nk_button_behavior behavior);

NK_LIB const struct nk_style_item*
nk_draw_button(struct nk_command_buffer* out, const struct nk_rect* bounds, nk_flags state,
	const struct nk_style_button* style);

NK_LIB int
nk_do_button(nk_flags* state, struct nk_command_buffer* out, struct nk_rect r, const struct nk_style_button* style,
	const struct nk_input* in, enum nk_button_behavior behavior, struct nk_rect* content);

NK_LIB void
nk_draw_button_text(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, const char* txt, int len,
	nk_flags text_alignment, const struct nk_user_font* font);

NK_LIB int
nk_do_button_text(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* string, int len,
	nk_flags align, enum nk_button_behavior behavior, const struct nk_style_button* style,
	const struct nk_input* in, const struct nk_user_font* font);

NK_LIB void
nk_draw_button_symbol(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, enum nk_symbol_type type,
	const struct nk_user_font* font);

NK_LIB int
nk_do_button_symbol(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, enum nk_symbol_type symbol,
	enum nk_button_behavior behavior, const struct nk_style_button* style, const struct nk_input* in,
	const struct nk_user_font* font);

NK_LIB void
nk_draw_button_image(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, const struct nk_image* img);

NK_LIB int
nk_do_button_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, struct nk_image img,
	enum nk_button_behavior b, const struct nk_style_button* style, const struct nk_input* in);

NK_LIB void
nk_draw_button_text_symbol(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* label,
	const struct nk_rect* symbol, nk_flags state, const struct nk_style_button* style,
	const char* str, int len, enum nk_symbol_type type, const struct nk_user_font* font);

NK_LIB int nk_do_button_text_symbol(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds,
	enum nk_symbol_type symbol, const char* str, int len, nk_flags align,
	enum nk_button_behavior behavior, const struct nk_style_button* style,
	const struct nk_user_font* font, const struct nk_input* in);

NK_LIB void
nk_draw_button_text_image(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* label,
	const struct nk_rect* image, nk_flags state, const struct nk_style_button* style,
	const char* str, int len, const struct nk_user_font* font, const struct nk_image* img);

NK_LIB int
nk_do_button_text_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, struct nk_image img,
	const char* str, int len, nk_flags align, enum nk_button_behavior behavior,
	const struct nk_style_button* style, const struct nk_user_font* font,
	const struct nk_input* in);

/* toggle */
enum nk_toggle_type {
	NK_TOGGLE_CHECK, NK_TOGGLE_OPTION
};

NK_LIB int nk_toggle_behavior(const struct nk_input* in, struct nk_rect select, nk_flags* state, int active);

NK_LIB void
nk_draw_checkbox(struct nk_command_buffer* out, nk_flags state, const struct nk_style_toggle* style, int active,
	const struct nk_rect* label, const struct nk_rect* selector, const struct nk_rect* cursors,
	const char* string, int len, const struct nk_user_font* font);

NK_LIB void
nk_draw_option(struct nk_command_buffer* out, nk_flags state, const struct nk_style_toggle* style, int active,
	const struct nk_rect* label, const struct nk_rect* selector, const struct nk_rect* cursors,
	const char* string, int len, const struct nk_user_font* font);

NK_LIB int
nk_do_toggle(nk_flags* state, struct nk_command_buffer* out, struct nk_rect r, int* active, const char* str, int len,
	enum nk_toggle_type type, const struct nk_style_toggle* style, const struct nk_input* in,
	const struct nk_user_font* font);

/* progress */
NK_LIB nk_size
nk_progress_behavior(nk_flags* state, struct nk_input* in, struct nk_rect r, struct nk_rect cursor, nk_size max,
	nk_size value, int modifiable);

NK_LIB void nk_draw_progress(struct nk_command_buffer* out, nk_flags state, const struct nk_style_progress* style,
	const struct nk_rect* bounds, const struct nk_rect* scursor, nk_size value, nk_size max);

NK_LIB nk_size
nk_do_progress(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, nk_size value, nk_size max,
	int modifiable, const struct nk_style_progress* style, struct nk_input* in);

/* slider */
NK_LIB float
nk_slider_behavior(nk_flags* state, struct nk_rect* logical_cursor, struct nk_rect* visual_cursor, struct nk_input* in,
	struct nk_rect bounds, float slider_min, float slider_max, float slider_value, float slider_step,
	float slider_steps);

NK_LIB void nk_draw_slider(struct nk_command_buffer* out, nk_flags state, const struct nk_style_slider* style,
	const struct nk_rect* bounds, const struct nk_rect* visual_cursor, float min, float value,
	float max);

NK_LIB float
nk_do_slider(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, float min, float val, float max,
	float step, const struct nk_style_slider* style, struct nk_input* in, const struct nk_user_font* font);

/* scrollbar */
NK_LIB float
nk_scrollbar_behavior(nk_flags* state, struct nk_input* in, int has_scrolling, const struct nk_rect* scroll,
	const struct nk_rect* cursor, const struct nk_rect* empty0, const struct nk_rect* empty1,
	float scroll_offset, float target, float scroll_step, enum nk_orientation o);

NK_LIB void nk_draw_scrollbar(struct nk_command_buffer* out, nk_flags state, const struct nk_style_scrollbar* style,
	const struct nk_rect* bounds, const struct nk_rect* scroll);

NK_LIB float
nk_do_scrollbarv(nk_flags* state, struct nk_command_buffer* out, struct nk_rect scroll, int has_scrolling, float offset,
	float target, float step, float button_pixel_inc, const struct nk_style_scrollbar* style,
	struct nk_input* in, const struct nk_user_font* font);

NK_LIB float
nk_do_scrollbarh(nk_flags* state, struct nk_command_buffer* out, struct nk_rect scroll, int has_scrolling, float offset,
	float target, float step, float button_pixel_inc, const struct nk_style_scrollbar* style,
	struct nk_input* in, const struct nk_user_font* font);

/* selectable */
NK_LIB void
nk_draw_selectable(struct nk_command_buffer* out, nk_flags state, const struct nk_style_selectable* style, int active,
	const struct nk_rect* bounds, const struct nk_rect* icon, const struct nk_image* img,
	enum nk_symbol_type sym, const char* string, int len, nk_flags align,
	const struct nk_user_font* font);

NK_LIB int
nk_do_selectable(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* str, int len,
	nk_flags align, int* value, const struct nk_style_selectable* style, const struct nk_input* in,
	const struct nk_user_font* font);

NK_LIB int
nk_do_selectable_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* str, int len,
	nk_flags align, int* value, const struct nk_image* img, const struct nk_style_selectable* style,
	const struct nk_input* in, const struct nk_user_font* font);

/* edit */
NK_LIB void
nk_edit_draw_text(struct nk_command_buffer* out, const struct nk_style_edit* style, float pos_x, float pos_y,
	float x_offset, const char* text, int byte_len, float row_height, const struct nk_user_font* font,
	struct nk_color background, struct nk_color foreground, int is_selected);

NK_LIB nk_flags nk_do_edit(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, nk_flags flags,
	nk_plugin_filter filter, struct nk_text_edit* edit, const struct nk_style_edit* style,
	struct nk_input* in, const struct nk_user_font* font);

/* color-picker */
NK_LIB int nk_color_picker_behavior(nk_flags* state, const struct nk_rect* bounds, const struct nk_rect* matrix,
	const struct nk_rect* hue_bar, const struct nk_rect* alpha_bar,
	struct nk_colorf* color, const struct nk_input* in);

NK_LIB void
nk_draw_color_picker(struct nk_command_buffer* o, const struct nk_rect* matrix, const struct nk_rect* hue_bar,
	const struct nk_rect* alpha_bar, struct nk_colorf col);

NK_LIB int
nk_do_color_picker(nk_flags* state, struct nk_command_buffer* out, struct nk_colorf* col, enum nk_color_format fmt,
	struct nk_rect bounds, struct nk_vec2 padding, const struct nk_input* in,
	const struct nk_user_font* font);

/* property */
enum nk_property_status {
	NK_PROPERTY_DEFAULT, NK_PROPERTY_EDIT, NK_PROPERTY_DRAG
};
enum nk_property_filter {
	NK_FILTER_INT, NK_FILTER_FLOAT
};
enum nk_property_kind {
	NK_PROPERTY_INT, NK_PROPERTY_FLOAT, NK_PROPERTY_DOUBLE
};
union nk_property {
	int i;
	float f;
	double d;
};
struct nk_property_variant {
	enum nk_property_kind kind;
	union nk_property value;
	union nk_property min_value;
	union nk_property max_value;
	union nk_property step;
};

NK_LIB struct nk_property_variant nk_property_variant_int(int value, int min_value, int max_value, int step);

NK_LIB struct nk_property_variant nk_property_variant_float(float value, float min_value, float max_value, float step);

NK_LIB struct nk_property_variant
nk_property_variant_double(double value, double min_value, double max_value, double step);

NK_LIB void
nk_drag_behavior(nk_flags* state, const struct nk_input* in, struct nk_rect drag, struct nk_property_variant* variant,
	float inc_per_pixel);

NK_LIB void nk_property_behavior(nk_flags* ws, const struct nk_input* in, struct nk_rect property, struct nk_rect label,
	struct nk_rect edit, struct nk_rect empty, int* state,
	struct nk_property_variant* variant, float inc_per_pixel);

NK_LIB void
nk_draw_property(struct nk_command_buffer* out, const struct nk_style_property* style, const struct nk_rect* bounds,
	const struct nk_rect* label, nk_flags state, const char* name, int len,
	const struct nk_user_font* font);

NK_LIB void nk_do_property(nk_flags* ws, struct nk_command_buffer* out, struct nk_rect property, const char* name,
	struct nk_property_variant* variant, float inc_per_pixel, char* buffer, int* len, int* state,
	int* cursor, int* select_begin, int* select_end, const struct nk_style_property* style,
	enum nk_property_filter filter, struct nk_input* in, const struct nk_user_font* font,
	struct nk_text_edit* text_edit, enum nk_button_behavior behavior);

NK_LIB void
nk_property(struct nk_context* ctx, const char* name, struct nk_property_variant* variant, float inc_per_pixel,
	const enum nk_property_filter filter);

#endif





/* ===============================================================
 *
 *                              MATH
 *
 * ===============================================================*/
 /*  Since nuklear is supposed to work on all systems providing floating point
	 math without any dependencies I also had to implement my own math functions
	 for sqrt, sin and cos. Since the actual highly accurate implementations for
	 the standard library functions are quite complex and I do not need high
	 precision for my use cases I use approximations.

	 Sqrt
	 ----
	 For square root nuklear uses the famous fast inverse square root:
	 https://en.wikipedia.org/wiki/Fast_inverse_square_root with
	 slightly tweaked magic constant. While on today's hardware it is
	 probably not faster it is still fast and accurate enough for
	 nuklear's use cases. IMPORTANT: this requires float format IEEE 754

	 Sine/Cosine
	 -----------
	 All constants inside both function are generated Remez's minimax
	 approximations for value range 0...2*PI. The reason why I decided to
	 approximate exactly that range is that nuklear only needs sine and
	 cosine to generate circles which only requires that exact range.
	 In addition I used Remez instead of Taylor for additional precision:
	 www.lolengine.net/blog/2011/12/21/better-function-approximations.

	 The tool I used to generate constants for both sine and cosine
	 (it can actually approximate a lot more functions) can be
	 found here: www.lolengine.net/wiki/oss/lolremez
 */
NK_LIB float nk_inv_sqrt(float n) {
	float x2;
	const float threehalfs = 1.5f;
	union {
		nk_uint i;
		float f;
	} conv = { 0 };
	conv.f = n;
	x2 = n * 0.5f;
	conv.i = 0x5f375A84 - (conv.i >> 1);
	conv.f = conv.f * (threehalfs - (x2 * conv.f * conv.f));
	return conv.f;
}

NK_LIB float nk_sqrt(float x) {
	return x * nk_inv_sqrt(x);
}

NK_LIB float nk_sin(float x) {
	NK_STORAGE const float a0 = +1.91059300966915117e-31f;
	NK_STORAGE const float a1 = +1.00086760103908896f;
	NK_STORAGE const float a2 = -1.21276126894734565e-2f;
	NK_STORAGE const float a3 = -1.38078780785773762e-1f;
	NK_STORAGE const float a4 = -2.67353392911981221e-2f;
	NK_STORAGE const float a5 = +2.08026600266304389e-2f;
	NK_STORAGE const float a6 = -3.03996055049204407e-3f;
	NK_STORAGE const float a7 = +1.38235642404333740e-4f;
	return a0 + x * (a1 + x * (a2 + x * (a3 + x * (a4 + x * (a5 + x * (a6 + x * a7))))));
}

NK_LIB float nk_cos(float x) {
	NK_STORAGE const float a0 = +1.00238601909309722f;
	NK_STORAGE const float a1 = -3.81919947353040024e-2f;
	NK_STORAGE const float a2 = -3.94382342128062756e-1f;
	NK_STORAGE const float a3 = -1.18134036025221444e-1f;
	NK_STORAGE const float a4 = +1.07123798512170878e-1f;
	NK_STORAGE const float a5 = -1.86637164165180873e-2f;
	NK_STORAGE const float a6 = +9.90140908664079833e-4f;
	NK_STORAGE const float a7 = -5.23022132118824778e-14f;
	return a0 + x * (a1 + x * (a2 + x * (a3 + x * (a4 + x * (a5 + x * (a6 + x * a7))))));
}

NK_LIB nk_uint nk_round_up_pow2(nk_uint v) {
	v--;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;
	return v;
}

NK_LIB double nk_pow(double x, int n) {
	/*  check the sign of n */
	double r = 1;
	int plus = n >= 0;
	n = (plus) ? n : -n;
	while (n > 0) {
		if ((n & 1) == 1)
			r *= x;
		n /= 2;
		x *= x;
	}
	return plus ? r : 1.0 / r;
}

NK_LIB int nk_ifloord(double x) {
	x = (double)((int)x - ((x < 0.0) ? 1 : 0));
	return (int)x;
}

NK_LIB int nk_ifloorf(float x) {
	x = (float)((int)x - ((x < 0.0f) ? 1 : 0));
	return (int)x;
}

NK_LIB int nk_iceilf(float x) {
	if (x >= 0) {
		int i = (int)x;
		return (x > i) ? i + 1 : i;
	}
	else {
		int t = (int)x;
		float r = x - (float)t;
		return (r > 0.0f) ? t + 1 : t;
	}
}

NK_LIB int nk_log10(double n) {
	int neg;
	int ret;
	int exp = 0;

	neg = (n < 0) ? 1 : 0;
	ret = (neg) ? (int)-n : (int)n;
	while ((ret / 10) > 0) {
		ret /= 10;
		exp++;
	}
	if (neg) exp = -exp;
	return exp;
}

NK_API struct nk_rect nk_get_null_rect(void) {
	return nk_null_rect;
}

NK_API struct nk_rect nk_rect(float x, float y, float w, float h) {
	struct nk_rect r;
	r.x = x;
	r.y = y;
	r.w = w;
	r.h = h;
	return r;
}

NK_API struct nk_rect nk_recti(int x, int y, int w, int h) {
	struct nk_rect r;
	r.x = (float)x;
	r.y = (float)y;
	r.w = (float)w;
	r.h = (float)h;
	return r;
}

NK_API struct nk_rect nk_recta(struct nk_vec2 pos, struct nk_vec2 size) {
	return nk_rect(pos.x, pos.y, size.x, size.y);
}

NK_API struct nk_rect nk_rectv(const float* r) {
	return nk_rect(r[0], r[1], r[2], r[3]);
}

NK_API struct nk_rect nk_rectiv(const int* r) {
	return nk_recti(r[0], r[1], r[2], r[3]);
}

NK_API struct nk_vec2 nk_rect_pos(struct nk_rect r) {
	struct nk_vec2 ret;
	ret.x = r.x;
	ret.y = r.y;
	return ret;
}

NK_API struct nk_vec2 nk_rect_size(struct nk_rect r) {
	struct nk_vec2 ret;
	ret.x = r.w;
	ret.y = r.h;
	return ret;
}

NK_LIB struct nk_rect nk_shrink_rect(struct nk_rect r, float amount) {
	struct nk_rect res;
	r.w = NK_MAX(r.w, 2 * amount);
	r.h = NK_MAX(r.h, 2 * amount);
	res.x = r.x + amount;
	res.y = r.y + amount;
	res.w = r.w - 2 * amount;
	res.h = r.h - 2 * amount;
	return res;
}

NK_LIB struct nk_rect nk_pad_rect(struct nk_rect r, struct nk_vec2 pad) {
	r.w = NK_MAX(r.w, 2 * pad.x);
	r.h = NK_MAX(r.h, 2 * pad.y);
	r.x += pad.x;
	r.y += pad.y;
	r.w -= 2 * pad.x;
	r.h -= 2 * pad.y;
	return r;
}

NK_API struct nk_vec2 nk_vec2(float x, float y) {
	struct nk_vec2 ret;
	ret.x = x;
	ret.y = y;
	return ret;
}

NK_API struct nk_vec2 nk_vec2i(int x, int y) {
	struct nk_vec2 ret;
	ret.x = (float)x;
	ret.y = (float)y;
	return ret;
}

NK_API struct nk_vec2 nk_vec2v(const float* v) {
	return nk_vec2(v[0], v[1]);
}

NK_API struct nk_vec2 nk_vec2iv(const int* v) {
	return nk_vec2i(v[0], v[1]);
}

NK_LIB void nk_unify(struct nk_rect* clip, const struct nk_rect* a, float x0, float y0, float x1, float y1) {
	NK_ASSERT(a);
	NK_ASSERT(clip);
	clip->x = NK_MAX(a->x, x0);
	clip->y = NK_MAX(a->y, y0);
	clip->w = NK_MIN(a->x + a->w, x1) - clip->x;
	clip->h = NK_MIN(a->y + a->h, y1) - clip->y;
	clip->w = NK_MAX(0, clip->w);
	clip->h = NK_MAX(0, clip->h);
}

NK_API void nk_triangle_from_direction(struct nk_vec2* result, struct nk_rect r, float pad_x, float pad_y,
	enum nk_heading direction) {
	float w_half, h_half;
	NK_ASSERT(result);

	r.w = NK_MAX(2 * pad_x, r.w);
	r.h = NK_MAX(2 * pad_y, r.h);
	r.w = r.w - 2 * pad_x;
	r.h = r.h - 2 * pad_y;

	r.x = r.x + pad_x;
	r.y = r.y + pad_y;

	w_half = r.w / 2.0f;
	h_half = r.h / 2.0f;

	if (direction == NK_UP) {
		result[0] = nk_vec2(r.x + w_half, r.y);
		result[1] = nk_vec2(r.x + r.w, r.y + r.h);
		result[2] = nk_vec2(r.x, r.y + r.h);
	}
	else if (direction == NK_RIGHT) {
		result[0] = nk_vec2(r.x, r.y);
		result[1] = nk_vec2(r.x + r.w, r.y + h_half);
		result[2] = nk_vec2(r.x, r.y + r.h);
	}
	else if (direction == NK_DOWN) {
		result[0] = nk_vec2(r.x, r.y);
		result[1] = nk_vec2(r.x + r.w, r.y);
		result[2] = nk_vec2(r.x + w_half, r.y + r.h);
	}
	else {
		result[0] = nk_vec2(r.x, r.y + h_half);
		result[1] = nk_vec2(r.x + r.w, r.y);
		result[2] = nk_vec2(r.x + r.w, r.y + r.h);
	}
}





/* ===============================================================
 *
 *                              UTIL
 *
 * ===============================================================*/
NK_INTERN int nk_str_match_here(const char* regexp, const char* text);

NK_INTERN int nk_str_match_star(int c, const char* regexp, const char* text);

NK_LIB int nk_is_lower(int c) { return (c >= 'a' && c <= 'z') || (c >= 0xE0 && c <= 0xFF); }

NK_LIB int nk_is_upper(int c) { return (c >= 'A' && c <= 'Z') || (c >= 0xC0 && c <= 0xDF); }

NK_LIB int nk_to_upper(int c) { return (c >= 'a' && c <= 'z') ? (c - ('a' - 'A')) : c; }

NK_LIB int nk_to_lower(int c) { return (c >= 'A' && c <= 'Z') ? (c - ('a' + 'A')) : c; }

NK_LIB void* nk_memcopy(void* dst0, const void* src0, nk_size length) {
	nk_ptr t;
	char* dst = (char*)dst0;
	const char* src = (const char*)src0;
	if (length == 0 || dst == src)
		goto done;

#define nk_word int
#define nk_wsize sizeof(nk_word)
#define nk_wmask (nk_wsize-1)
#define NK_TLOOP(s) if (t) NK_TLOOP1(s)
#define NK_TLOOP1(s) do { s; } while (--t)

	if (dst < src) {
		t = (nk_ptr)src; /* only need low bits */
		if ((t | (nk_ptr)dst) & nk_wmask) {
			if ((t ^ (nk_ptr)dst) & nk_wmask || length < nk_wsize)
				t = length;
			else
				t = nk_wsize - (t & nk_wmask);
			length -= t;
			NK_TLOOP1(*dst++ = *src++);
		}
		t = length / nk_wsize;
		NK_TLOOP(*(nk_word*)(
			void*)dst = *(const nk_word*)(const void*)src;
		src += nk_wsize; dst += nk_wsize);
		t = length & nk_wmask;
		NK_TLOOP(*dst++ = *src++);
	}
	else {
		src += length;
		dst += length;
		t = (nk_ptr)src;
		if ((t | (nk_ptr)dst) & nk_wmask) {
			if ((t ^ (nk_ptr)dst) & nk_wmask || length <= nk_wsize)
				t = length;
			else
				t &= nk_wmask;
			length -= t;
			NK_TLOOP1(*--dst = *--src);
		}
		t = length / nk_wsize;
		NK_TLOOP(src -= nk_wsize;
		dst -= nk_wsize;
		*(nk_word*)(
			void*)dst = *(const nk_word*)(const void*)src);
		t = length & nk_wmask;
		NK_TLOOP(*--dst = *--src);
	}
#undef nk_word
#undef nk_wsize
#undef nk_wmask
#undef NK_TLOOP
#undef NK_TLOOP1
	done :
	return (dst0);
}

NK_LIB void nk_memset(void* ptr, int c0, nk_size size) {
#define nk_word unsigned
#define nk_wsize sizeof(nk_word)
#define nk_wmask (nk_wsize - 1)
	nk_byte* dst = (nk_byte*)ptr;
	unsigned c = 0;
	nk_size t = 0;

	if ((c = (nk_byte)c0) != 0) {
		c = (c << 8) | c; /* at least 16-bits  */
		if (sizeof(unsigned int) > 2)
			c = (c << 16) | c; /* at least 32-bits*/
	}

	/* too small of a word count */
	dst = (nk_byte*)ptr;
	if (size < 3 * nk_wsize) {
		while (size--)*dst++ = (nk_byte)c0;
		return;
	}

	/* align destination */
	if ((t = NK_PTR_TO_UINT(dst) & nk_wmask) != 0) {
		t = nk_wsize - t;
		size -= t;
		do {
			*dst++ = (nk_byte)c0;
		} while (--t != 0);
	}

	/* fill word */
	t = size / nk_wsize;
	do {
		*(nk_word*)((void*)dst) = c;
		dst += nk_wsize;
	} while (--t != 0);

	/* fill trailing bytes */
	t = (size & nk_wmask);
	if (t != 0) {
		do {
			*dst++ = (nk_byte)c0;
		} while (--t != 0);
	}

#undef nk_word
#undef nk_wsize
#undef nk_wmask
}

NK_LIB void nk_zero(void* ptr, nk_size size) {
	NK_ASSERT(ptr);
	NK_MEMSET(ptr, 0, size);
}

NK_API int nk_strlen(const char* str) {
	int siz = 0;
	NK_ASSERT(str);
	while (str && *str++ != '\0') siz++;
	return siz;
}

NK_API int nk_strtoi(const char* str, const char** endptr) {
	int neg = 1;
	const char* p = str;
	int value = 0;

	NK_ASSERT(str);
	if (!str) return 0;

	/* skip whitespace */
	while (*p == ' ') p++;
	if (*p == '-') {
		neg = -1;
		p++;
	}
	while (*p && *p >= '0' && *p <= '9') {
		value = value * 10 + (int)(*p - '0');
		p++;
	}
	if (endptr)
		*endptr = p;
	return neg * value;
}

NK_API double nk_strtod(const char* str, const char** endptr) {
	double m;
	double neg = 1.0;
	const char* p = str;
	double value = 0;
	double number = 0;

	NK_ASSERT(str);
	if (!str) return 0;

	/* skip whitespace */
	while (*p == ' ') p++;
	if (*p == '-') {
		neg = -1.0;
		p++;
	}

	while (*p && *p != '.' && *p != 'e') {
		value = value * 10.0 + (double)(*p - '0');
		p++;
	}

	if (*p == '.') {
		p++;
		for (m = 0.1; *p && *p != 'e'; p++) {
			value = value + (double)(*p - '0') * m;
			m *= 0.1;
		}
	}
	if (*p == 'e') {
		int i, pow, div;
		p++;
		if (*p == '-') {
			div = nk_true;
			p++;
		}
		else if (*p == '+') {
			div = nk_false;
			p++;
		}
		else div = nk_false;

		for (pow = 0; *p; p++)
			pow = pow * 10 + (int)(*p - '0');

		for (m = 1.0, i = 0; i < pow; i++)
			m *= 10.0;

		if (div)
			value /= m;
		else value *= m;
	}
	number = value * neg;
	if (endptr)
		*endptr = p;
	return number;
}

NK_API float nk_strtof(const char* str, const char** endptr) {
	float float_value;
	double double_value;
	double_value = NK_STRTOD(str, endptr);
	float_value = (float)double_value;
	return float_value;
}

NK_API int nk_stricmp(const char* s1, const char* s2) {
	nk_int c1, c2, d;
	do {
		c1 = *s1++;
		c2 = *s2++;
		d = c1 - c2;
		while (d) {
			if (c1 <= 'Z' && c1 >= 'A') {
				d += ('a' - 'A');
				if (!d) break;
			}
			if (c2 <= 'Z' && c2 >= 'A') {
				d -= ('a' - 'A');
				if (!d) break;
			}
			return ((d >= 0) << 1) - 1;
		}
	} while (c1);
	return 0;
}

NK_API int nk_stricmpn(const char* s1, const char* s2, int n) {
	int c1, c2, d;
	NK_ASSERT(n >= 0);
	do {
		c1 = *s1++;
		c2 = *s2++;
		if (!n--) return 0;

		d = c1 - c2;
		while (d) {
			if (c1 <= 'Z' && c1 >= 'A') {
				d += ('a' - 'A');
				if (!d) break;
			}
			if (c2 <= 'Z' && c2 >= 'A') {
				d -= ('a' - 'A');
				if (!d) break;
			}
			return ((d >= 0) << 1) - 1;
		}
	} while (c1);
	return 0;
}

NK_INTERN int nk_str_match_here(const char* regexp, const char* text) {
	if (regexp[0] == '\0')
		return 1;
	if (regexp[1] == '*')
		return nk_str_match_star(regexp[0], regexp + 2, text);
	if (regexp[0] == '$' && regexp[1] == '\0')
		return *text == '\0';
	if (*text != '\0' && (regexp[0] == '.' || regexp[0] == *text))
		return nk_str_match_here(regexp + 1, text + 1);
	return 0;
}

NK_INTERN int nk_str_match_star(int c, const char* regexp, const char* text) {
	do {/* a '* matches zero or more instances */
		if (nk_str_match_here(regexp, text))
			return 1;
	} while (*text != '\0' && (*text++ == c || c == '.'));
	return 0;
}

NK_API int nk_strfilter(const char* text, const char* regexp) {
	/*
	c    matches any literal character c
	.    matches any single character
	^    matches the beginning of the input string
	$    matches the end of the input string
	*    matches zero or more occurrences of the previous character*/
	if (regexp[0] == '^')
		return nk_str_match_here(regexp + 1, text);
	do {    /* must look even if string is empty */
		if (nk_str_match_here(regexp, text))
			return 1;
	} while (*text++ != '\0');
	return 0;
}

NK_API int nk_strmatch_fuzzy_text(const char* str, int str_len, const char* pattern, int* out_score) {
	/* Returns true if each character in pattern is found sequentially within str
	 * if found then out_score is also set. Score value has no intrinsic meaning.
	 * Range varies with pattern. Can only compare scores with same search pattern. */

	 /* bonus for adjacent matches */
#define NK_ADJACENCY_BONUS 5
	/* bonus if match occurs after a separator */
#define NK_SEPARATOR_BONUS 10
	/* bonus if match is uppercase and prev is lower */
#define NK_CAMEL_BONUS 10
	/* penalty applied for every letter in str before the first match */
#define NK_LEADING_LETTER_PENALTY (-3)
	/* maximum penalty for leading letters */
#define NK_MAX_LEADING_LETTER_PENALTY (-9)
	/* penalty for every letter that doesn't matter */
#define NK_UNMATCHED_LETTER_PENALTY (-1)

	/* loop variables */
	int score = 0;
	char const* pattern_iter = pattern;
	int str_iter = 0;
	int prev_matched = nk_false;
	int prev_lower = nk_false;
	/* true so if first letter match gets separator bonus*/
	int prev_separator = nk_true;

	/* use "best" matched letter if multiple string letters match the pattern */
	char const* best_letter = 0;
	int best_letter_score = 0;

	/* loop over strings */
	NK_ASSERT(str);
	NK_ASSERT(pattern);
	if (!str || !str_len || !pattern) return 0;
	while (str_iter < str_len) {
		const char pattern_letter = *pattern_iter;
		const char str_letter = str[str_iter];

		int next_match = *pattern_iter != '\0' && nk_to_lower(pattern_letter) == nk_to_lower(str_letter);
		int rematch = best_letter && nk_to_upper(*best_letter) == nk_to_upper(str_letter);

		int advanced = next_match && best_letter;
		int pattern_repeat = best_letter && *pattern_iter != '\0';
		pattern_repeat = pattern_repeat && nk_to_lower(*best_letter) == nk_to_lower(pattern_letter);

		if (advanced || pattern_repeat) {
			score += best_letter_score;
			best_letter = 0;
			best_letter_score = 0;
		}

		if (next_match || rematch) {
			int new_score = 0;
			/* Apply penalty for each letter before the first pattern match */
			if (pattern_iter == pattern) {
				int count = (int)(&str[str_iter] - str);
				int penalty = NK_LEADING_LETTER_PENALTY * count;
				if (penalty < NK_MAX_LEADING_LETTER_PENALTY)
					penalty = NK_MAX_LEADING_LETTER_PENALTY;

				score += penalty;
			}

			/* apply bonus for consecutive bonuses */
			if (prev_matched)
				new_score += NK_ADJACENCY_BONUS;

			/* apply bonus for matches after a separator */
			if (prev_separator)
				new_score += NK_SEPARATOR_BONUS;

			/* apply bonus across camel case boundaries */
			if (prev_lower && nk_is_upper(str_letter))
				new_score += NK_CAMEL_BONUS;

			/* update pattern iter IFF the next pattern letter was matched */
			if (next_match)
				++pattern_iter;

			/* update best letter in str which may be for a "next" letter or a rematch */
			if (new_score >= best_letter_score) {
				/* apply penalty for now skipped letter */
				if (best_letter != 0)
					score += NK_UNMATCHED_LETTER_PENALTY;

				best_letter = &str[str_iter];
				best_letter_score = new_score;
			}
			prev_matched = nk_true;
		}
		else {
			score += NK_UNMATCHED_LETTER_PENALTY;
			prev_matched = nk_false;
		}

		/* separators should be more easily defined */
		prev_lower = nk_is_lower(str_letter) != 0;
		prev_separator = str_letter == '_' || str_letter == ' ';

		++str_iter;
	}

	/* apply score for last match */
	if (best_letter)
		score += best_letter_score;

	/* did not match full pattern */
	if (*pattern_iter != '\0')
		return nk_false;

	if (out_score)
		*out_score = score;
	return nk_true;
}

NK_API int nk_strmatch_fuzzy_string(char const* str, char const* pattern, int* out_score) {
	return nk_strmatch_fuzzy_text(str, nk_strlen(str), pattern, out_score);
}

NK_LIB int nk_string_float_limit(char* string, int prec) {
	int dot = 0;
	char* c = string;
	while (*c) {
		if (*c == '.') {
			dot = 1;
			c++;
			continue;
		}
		if (dot == (prec + 1)) {
			*c = 0;
			break;
		}
		if (dot > 0) dot++;
		c++;
	}
	return (int)(c - string);
}

NK_INTERN void nk_strrev_ascii(char* s) {
	int len = nk_strlen(s);
	int end = len / 2;
	int i = 0;
	char t;
	for (; i < end; ++i) {
		t = s[i];
		s[i] = s[len - 1 - i];
		s[len - 1 - i] = t;
	}
}

NK_LIB char* nk_itoa(char* s, long n) {
	long i = 0;
	if (n == 0) {
		s[i++] = '0';
		s[i] = 0;
		return s;
	}
	if (n < 0) {
		s[i++] = '-';
		n = -n;
	}
	while (n > 0) {
		s[i++] = (char)('0' + (n % 10));
		n /= 10;
	}
	s[i] = 0;
	if (s[0] == '-')
		++s;

	nk_strrev_ascii(s);
	return s;
}

NK_LIB char* nk_dtoa(char* s, double n) {
	int useExp = 0;
	int digit = 0, m = 0, m1 = 0;
	char* c = s;
	int neg = 0;

	NK_ASSERT(s);
	if (!s) return 0;

	if (n == 0.0) {
		s[0] = '0';
		s[1] = '\0';
		return s;
	}

	neg = (n < 0);
	if (neg) n = -n;

	/* calculate magnitude */
	m = nk_log10(n);
	useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
	if (neg) *(c++) = '-';

	/* set up for scientific notation */
	if (useExp) {
		if (m < 0)
			m -= 1;
		n = n / (double)nk_pow(10.0, m);
		m1 = m;
		m = 0;
	}
	if (m < 1.0) {
		m = 0;
	}

	/* convert the number */
	while (n > NK_FLOAT_PRECISION || m >= 0) {
		double weight = nk_pow(10.0, m);
		if (weight > 0) {
			double t = (double)n / weight;
			digit = nk_ifloord(t);
			n -= ((double)digit * weight);
			*(c++) = (char)('0' + (char)digit);
		}
		if (m == 0 && n > 0)
			*(c++) = '.';
		m--;
	}

	if (useExp) {
		/* convert the exponent */
		int i, j;
		*(c++) = 'e';
		if (m1 > 0) {
			*(c++) = '+';
		}
		else {
			*(c++) = '-';
			m1 = -m1;
		}
		m = 0;
		while (m1 > 0) {
			*(c++) = (char)('0' + (char)(m1 % 10));
			m1 /= 10;
			m++;
		}
		c -= m;
		for (i = 0, j = m - 1; i < j; i++, j--) {
			/* swap without temporary */
			c[i] ^= c[j];
			c[j] ^= c[i];
			c[i] ^= c[j];
		}
		c += m;
	}
	*(c) = '\0';
	return s;
}

#ifdef NK_INCLUDE_STANDARD_VARARGS
#ifndef NK_INCLUDE_STANDARD_IO
NK_INTERN int
nk_vsnprintf(char* buf, int buf_size, const char* fmt, va_list args)
{
	enum nk_arg_type {
		NK_ARG_TYPE_CHAR,
		NK_ARG_TYPE_SHORT,
		NK_ARG_TYPE_DEFAULT,
		NK_ARG_TYPE_LONG
	};
	enum nk_arg_flags {
		NK_ARG_FLAG_LEFT = 0x01,
		NK_ARG_FLAG_PLUS = 0x02,
		NK_ARG_FLAG_SPACE = 0x04,
		NK_ARG_FLAG_NUM = 0x10,
		NK_ARG_FLAG_ZERO = 0x20
	};

	char number_buffer[NK_MAX_NUMBER_BUFFER];
	enum nk_arg_type arg_type = NK_ARG_TYPE_DEFAULT;
	int precision = NK_DEFAULT;
	int width = NK_DEFAULT;
	nk_flags flag = 0;

	int len = 0;
	int result = -1;
	const char* iter = fmt;

	NK_ASSERT(buf);
	NK_ASSERT(buf_size);
	if (!buf || !buf_size || !fmt) return 0;
	for (iter = fmt; *iter && len < buf_size; iter++) {
		/* copy all non-format characters */
		while (*iter && (*iter != '%') && (len < buf_size))
			buf[len++] = *iter++;
		if (!(*iter) || len >= buf_size) break;
		iter++;

		/* flag arguments */
		while (*iter) {
			if (*iter == '-') flag |= NK_ARG_FLAG_LEFT;
			else if (*iter == '+') flag |= NK_ARG_FLAG_PLUS;
			else if (*iter == ' ') flag |= NK_ARG_FLAG_SPACE;
			else if (*iter == '#') flag |= NK_ARG_FLAG_NUM;
			else if (*iter == '0') flag |= NK_ARG_FLAG_ZERO;
			else break;
			iter++;
		}

		/* width argument */
		width = NK_DEFAULT;
		if (*iter >= '1' && *iter <= '9') {
			const char* end;
			width = nk_strtoi(iter, &end);
			if (end == iter)
				width = -1;
			else iter = end;
		}
		else if (*iter == '*') {
			width = va_arg(args, int);
			iter++;
		}

		/* precision argument */
		precision = NK_DEFAULT;
		if (*iter == '.') {
			iter++;
			if (*iter == '*') {
				precision = va_arg(args, int);
				iter++;
			}
			else {
				const char* end;
				precision = nk_strtoi(iter, &end);
				if (end == iter)
					precision = -1;
				else iter = end;
			}
		}

		/* length modifier */
		if (*iter == 'h') {
			if (*(iter + 1) == 'h') {
				arg_type = NK_ARG_TYPE_CHAR;
				iter++;
			}
			else arg_type = NK_ARG_TYPE_SHORT;
			iter++;
		}
		else if (*iter == 'l') {
			arg_type = NK_ARG_TYPE_LONG;
			iter++;
		}
		else arg_type = NK_ARG_TYPE_DEFAULT;

		/* specifier */
		if (*iter == '%') {
			NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);
			NK_ASSERT(precision == NK_DEFAULT);
			NK_ASSERT(width == NK_DEFAULT);
			if (len < buf_size)
				buf[len++] = '%';
		}
		else if (*iter == 's') {
			/* string  */
			const char* str = va_arg(args, const char*);
			NK_ASSERT(str != buf && "buffer and argument are not allowed to overlap!");
			NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);
			NK_ASSERT(precision == NK_DEFAULT);
			NK_ASSERT(width == NK_DEFAULT);
			if (str == buf) return -1;
			while (str && *str && len < buf_size)
				buf[len++] = *str++;
		}
		else if (*iter == 'n') {
			/* current length callback */
			signed int* n = va_arg(args, int*);
			NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);
			NK_ASSERT(precision == NK_DEFAULT);
			NK_ASSERT(width == NK_DEFAULT);
			if (n) *n = len;
		}
		else if (*iter == 'c' || *iter == 'i' || *iter == 'd') {
			/* signed integer */
			long value = 0;
			const char* num_iter;
			int num_len, num_print, padding;
			int cur_precision = NK_MAX(precision, 1);
			int cur_width = NK_MAX(width, 0);

			/* retrieve correct value type */
			if (arg_type == NK_ARG_TYPE_CHAR)
				value = (signed char)va_arg(args, int);
			else if (arg_type == NK_ARG_TYPE_SHORT)
				value = (signed short)va_arg(args, int);
			else if (arg_type == NK_ARG_TYPE_LONG)
				value = va_arg(args, signed long);
			else if (*iter == 'c')
				value = (unsigned char)va_arg(args, int);
			else value = va_arg(args, signed int);

			/* convert number to string */
			nk_itoa(number_buffer, value);
			num_len = nk_strlen(number_buffer);
			padding = NK_MAX(cur_width - NK_MAX(cur_precision, num_len), 0);
			if ((flag & NK_ARG_FLAG_PLUS) || (flag & NK_ARG_FLAG_SPACE))
				padding = NK_MAX(padding - 1, 0);

			/* fill left padding up to a total of `width` characters */
			if (!(flag & NK_ARG_FLAG_LEFT)) {
				while (padding-- > 0 && (len < buf_size)) {
					if ((flag & NK_ARG_FLAG_ZERO) && (precision == NK_DEFAULT))
						buf[len++] = '0';
					else buf[len++] = ' ';
				}
			}

			/* copy string value representation into buffer */
			if ((flag & NK_ARG_FLAG_PLUS) && value >= 0 && len < buf_size)
				buf[len++] = '+';
			else if ((flag & NK_ARG_FLAG_SPACE) && value >= 0 && len < buf_size)
				buf[len++] = ' ';

			/* fill up to precision number of digits with '0' */
			num_print = NK_MAX(cur_precision, num_len);
			while (precision && (num_print > num_len) && (len < buf_size)) {
				buf[len++] = '0';
				num_print--;
			}

			/* copy string value representation into buffer */
			num_iter = number_buffer;
			while (precision && *num_iter && len < buf_size)
				buf[len++] = *num_iter++;

			/* fill right padding up to width characters */
			if (flag & NK_ARG_FLAG_LEFT) {
				while ((padding-- > 0) && (len < buf_size))
					buf[len++] = ' ';
			}
		}
		else if (*iter == 'o' || *iter == 'x' || *iter == 'X' || *iter == 'u') {
			/* unsigned integer */
			unsigned long value = 0;
			int num_len = 0, num_print, padding = 0;
			int cur_precision = NK_MAX(precision, 1);
			int cur_width = NK_MAX(width, 0);
			unsigned int base = (*iter == 'o') ? 8 : (*iter == 'u') ? 10 : 16;

			/* print oct/hex/dec value */
			const char* upper_output_format = "0123456789ABCDEF";
			const char* lower_output_format = "0123456789abcdef";
			const char* output_format = (*iter == 'x') ?
				lower_output_format : upper_output_format;

			/* retrieve correct value type */
			if (arg_type == NK_ARG_TYPE_CHAR)
				value = (unsigned char)va_arg(args, int);
			else if (arg_type == NK_ARG_TYPE_SHORT)
				value = (unsigned short)va_arg(args, int);
			else if (arg_type == NK_ARG_TYPE_LONG)
				value = va_arg(args, unsigned long);
			else value = va_arg(args, unsigned int);

			do {
				/* convert decimal number into hex/oct number */
				int digit = output_format[value % base];
				if (num_len < NK_MAX_NUMBER_BUFFER)
					number_buffer[num_len++] = (char)digit;
				value /= base;
			} while (value > 0);

			num_print = NK_MAX(cur_precision, num_len);
			padding = NK_MAX(cur_width - NK_MAX(cur_precision, num_len), 0);
			if (flag & NK_ARG_FLAG_NUM)
				padding = NK_MAX(padding - 1, 0);

			/* fill left padding up to a total of `width` characters */
			if (!(flag & NK_ARG_FLAG_LEFT)) {
				while ((padding-- > 0) && (len < buf_size)) {
					if ((flag & NK_ARG_FLAG_ZERO) && (precision == NK_DEFAULT))
						buf[len++] = '0';
					else buf[len++] = ' ';
				}
			}

			/* fill up to precision number of digits */
			if (num_print && (flag & NK_ARG_FLAG_NUM)) {
				if ((*iter == 'o') && (len < buf_size)) {
					buf[len++] = '0';
				}
				else if ((*iter == 'x') && ((len + 1) < buf_size)) {
					buf[len++] = '0';
					buf[len++] = 'x';
				}
				else if ((*iter == 'X') && ((len + 1) < buf_size)) {
					buf[len++] = '0';
					buf[len++] = 'X';
				}
			}
			while (precision && (num_print > num_len) && (len < buf_size)) {
				buf[len++] = '0';
				num_print--;
			}

			/* reverse number direction */
			while (num_len > 0) {
				if (precision && (len < buf_size))
					buf[len++] = number_buffer[num_len - 1];
				num_len--;
			}

			/* fill right padding up to width characters */
			if (flag & NK_ARG_FLAG_LEFT) {
				while ((padding-- > 0) && (len < buf_size))
					buf[len++] = ' ';
			}
		}
		else if (*iter == 'f') {
			/* floating point */
			const char* num_iter;
			int cur_precision = (precision < 0) ? 6 : precision;
			int prefix, cur_width = NK_MAX(width, 0);
			double value = va_arg(args, double);
			int num_len = 0, frac_len = 0, dot = 0;
			int padding = 0;

			NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);
			NK_DTOA(number_buffer, value);
			num_len = nk_strlen(number_buffer);

			/* calculate padding */
			num_iter = number_buffer;
			while (*num_iter && *num_iter != '.')
				num_iter++;

			prefix = (*num_iter == '.') ? (int)(num_iter - number_buffer) + 1 : 0;
			padding = NK_MAX(cur_width - (prefix + NK_MIN(cur_precision, num_len - prefix)), 0);
			if ((flag & NK_ARG_FLAG_PLUS) || (flag & NK_ARG_FLAG_SPACE))
				padding = NK_MAX(padding - 1, 0);

			/* fill left padding up to a total of `width` characters */
			if (!(flag & NK_ARG_FLAG_LEFT)) {
				while (padding-- > 0 && (len < buf_size)) {
					if (flag & NK_ARG_FLAG_ZERO)
						buf[len++] = '0';
					else buf[len++] = ' ';
				}
			}

			/* copy string value representation into buffer */
			num_iter = number_buffer;
			if ((flag & NK_ARG_FLAG_PLUS) && (value >= 0) && (len < buf_size))
				buf[len++] = '+';
			else if ((flag & NK_ARG_FLAG_SPACE) && (value >= 0) && (len < buf_size))
				buf[len++] = ' ';
			while (*num_iter) {
				if (dot) frac_len++;
				if (len < buf_size)
					buf[len++] = *num_iter;
				if (*num_iter == '.') dot = 1;
				if (frac_len >= cur_precision) break;
				num_iter++;
			}

			/* fill number up to precision */
			while (frac_len < cur_precision) {
				if (!dot && len < buf_size) {
					buf[len++] = '.';
					dot = 1;
				}
				if (len < buf_size)
					buf[len++] = '0';
				frac_len++;
			}

			/* fill right padding up to width characters */
			if (flag & NK_ARG_FLAG_LEFT) {
				while ((padding-- > 0) && (len < buf_size))
					buf[len++] = ' ';
			}
		}
		else {
			/* Specifier not supported: g,G,e,E,p,z */
			NK_ASSERT(0 && "specifier is not supported!");
			return result;
		}
	}
	buf[(len >= buf_size) ? (buf_size - 1) : len] = 0;
	result = (len >= buf_size) ? -1 : len;
	return result;
}
#endif

NK_LIB int nk_strfmt(char* buf, int buf_size, const char* fmt, va_list args) {
	int result = -1;
	NK_ASSERT(buf);
	NK_ASSERT(buf_size);
	if (!buf || !buf_size || !fmt) return 0;
#ifdef NK_INCLUDE_STANDARD_IO
	result = NK_VSNPRINTF(buf, (nk_size)buf_size, fmt, args);
	result = (result >= buf_size) ? -1 : result;
	buf[buf_size - 1] = 0;
#else
	result = nk_vsnprintf(buf, buf_size, fmt, args);
#endif
	return result;
}

#endif

NK_API nk_hash nk_murmur_hash(const void* key, int len, nk_hash seed) {
	/* 32-Bit MurmurHash3: https://code.google.com/p/smhasher/wiki/MurmurHash3*/
#define NK_ROTL(x, r) ((x) << (r) | ((x) >> (32 - r)))
	union {
		const nk_uint* i;
		const nk_byte* b;
	} conv = { 0 };
	const nk_byte* data = (const nk_byte*)key;
	const int nblocks = len / 4;
	nk_uint h1 = seed;
	const nk_uint c1 = 0xcc9e2d51;
	const nk_uint c2 = 0x1b873593;
	const nk_byte* tail;
	const nk_uint* blocks;
	nk_uint k1;
	int i;

	/* body */
	if (!key) return 0;
	conv.b = (data + nblocks * 4);
	blocks = (const nk_uint*)conv.i;
	for (i = -nblocks; i; ++i) {
		k1 = blocks[i];
		k1 *= c1;
		k1 = NK_ROTL(k1, 15);
		k1 *= c2;

		h1 ^= k1;
		h1 = NK_ROTL(h1, 13);
		h1 = h1 * 5 + 0xe6546b64;
	}

	/* tail */
	tail = (const nk_byte*)(data + nblocks * 4);
	k1 = 0;
	switch (len & 3) {
	case 3:
		k1 ^= (nk_uint)(tail[2] << 16); /* fallthrough */
	case 2:
		k1 ^= (nk_uint)(tail[1] << 8u); /* fallthrough */
	case 1:
		k1 ^= tail[0];
		k1 *= c1;
		k1 = NK_ROTL(k1, 15);
		k1 *= c2;
		h1 ^= k1;
		break;
	default:
		break;
	}

	/* finalization */
	h1 ^= (nk_uint)len;
	/* fmix32 */
	h1 ^= h1 >> 16;
	h1 *= 0x85ebca6b;
	h1 ^= h1 >> 13;
	h1 *= 0xc2b2ae35;
	h1 ^= h1 >> 16;

#undef NK_ROTL
	return h1;
}

#ifdef NK_INCLUDE_STANDARD_IO

NK_LIB char* nk_file_load(const char* path, nk_size* siz, struct nk_allocator* alloc) {
	char* buf;
	FILE* fd;
	long ret;

	NK_ASSERT(path);
	NK_ASSERT(siz);
	NK_ASSERT(alloc);
	if (!path || !siz || !alloc)
		return 0;

	fd = fopen(path, "rb");
	if (!fd) return 0;
	fseek(fd, 0, SEEK_END);
	ret = ftell(fd);
	if (ret < 0) {
		fclose(fd);
		return 0;
	}
	*siz = (nk_size)ret;
	fseek(fd, 0, SEEK_SET);
	buf = (char*)alloc->alloc(alloc->userdata, 0, *siz);
	NK_ASSERT(buf);
	if (!buf) {
		fclose(fd);
		return 0;
	}
	*siz = (nk_size)fread(buf, 1, *siz, fd);
	fclose(fd);
	return buf;
}

#endif

NK_LIB int nk_text_clamp(const struct nk_user_font* font, const char* text, int text_len, float space, int* glyphs,
	float* text_width, nk_rune* sep_list, int sep_count) {
	int i = 0;
	int glyph_len = 0;
	float last_width = 0;
	nk_rune unicode = 0;
	float width = 0;
	int len = 0;
	int g = 0;
	float s;

	int sep_len = 0;
	int sep_g = 0;
	float sep_width = 0;
	sep_count = NK_MAX(sep_count, 0);

	glyph_len = nk_utf_decode(text, &unicode, text_len);
	while (glyph_len && (width < space) && (len < text_len)) {
		len += glyph_len;
		s = font->width(font->userdata, font->height, text, len);
		for (i = 0; i < sep_count; ++i) {
			if (unicode != sep_list[i]) continue;
			sep_width = last_width = width;
			sep_g = g + 1;
			sep_len = len;
			break;
		}
		if (i == sep_count) {
			last_width = sep_width = width;
			sep_g = g + 1;
		}
		width = s;
		glyph_len = nk_utf_decode(&text[len], &unicode, text_len - len);
		g++;
	}
	if (len >= text_len) {
		*glyphs = g;
		*text_width = last_width;
		return len;
	}
	else {
		*glyphs = sep_g;
		*text_width = sep_width;
		return (!sep_len) ? len : sep_len;
	}
}

NK_LIB struct nk_vec2
nk_text_calculate_text_bounds(const struct nk_user_font* font, const char* begin, int byte_len, float row_height,
	const char** remaining, struct nk_vec2* out_offset, int* glyphs, int op) {
	float line_height = row_height;
	struct nk_vec2 text_size = nk_vec2(0, 0);
	float line_width = 0.0f;

	float glyph_width;
	int glyph_len = 0;
	nk_rune unicode = 0;
	int text_len = 0;
	if (!begin || byte_len <= 0 || !font)
		return nk_vec2(0, row_height);

	glyph_len = nk_utf_decode(begin, &unicode, byte_len);
	if (!glyph_len) return text_size;
	glyph_width = font->width(font->userdata, font->height, begin, glyph_len);

	*glyphs = 0;
	while ((text_len < byte_len) && glyph_len) {
		if (unicode == '\n') {
			text_size.x = NK_MAX(text_size.x, line_width);
			text_size.y += line_height;
			line_width = 0;
			*glyphs += 1;
			if (op == NK_STOP_ON_NEW_LINE)
				break;

			text_len++;
			glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len - text_len);
			continue;
		}

		if (unicode == '\r') {
			text_len++;
			*glyphs += 1;
			glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len - text_len);
			continue;
		}

		*glyphs = *glyphs + 1;
		text_len += glyph_len;
		line_width += (float)glyph_width;
		glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len - text_len);
		glyph_width = font->width(font->userdata, font->height, begin + text_len, glyph_len);
		continue;
	}

	if (text_size.x < line_width)
		text_size.x = line_width;
	if (out_offset)
		*out_offset = nk_vec2(line_width, text_size.y + line_height);
	if (line_width > 0 || text_size.y == 0.0f)
		text_size.y += line_height;
	if (remaining)
		*remaining = begin + text_len;
	return text_size;
}





/* ==============================================================
 *
 *                          COLOR
 *
 * ===============================================================*/
NK_INTERN int nk_parse_hex(const char* p, int length) {
	int i = 0;
	int len = 0;
	while (len < length) {
		i <<= 4;
		if (p[len] >= 'a' && p[len] <= 'f')
			i += ((p[len] - 'a') + 10);
		else if (p[len] >= 'A' && p[len] <= 'F')
			i += ((p[len] - 'A') + 10);
		else i += (p[len] - '0');
		len++;
	}
	return i;
}

NK_API struct nk_color nk_rgba(int r, int g, int b, int a) {
	struct nk_color ret;
	ret.r = (nk_byte)NK_CLAMP(0, r, 255);
	ret.g = (nk_byte)NK_CLAMP(0, g, 255);
	ret.b = (nk_byte)NK_CLAMP(0, b, 255);
	ret.a = (nk_byte)NK_CLAMP(0, a, 255);
	return ret;
}

NK_API struct nk_color nk_rgb_hex(const char* rgb) {
	struct nk_color col;
	const char* c = rgb;
	if (*c == '#') c++;
	col.r = (nk_byte)nk_parse_hex(c, 2);
	col.g = (nk_byte)nk_parse_hex(c + 2, 2);
	col.b = (nk_byte)nk_parse_hex(c + 4, 2);
	col.a = 255;
	return col;
}

NK_API struct nk_color nk_rgba_hex(const char* rgb) {
	struct nk_color col;
	const char* c = rgb;
	if (*c == '#') c++;
	col.r = (nk_byte)nk_parse_hex(c, 2);
	col.g = (nk_byte)nk_parse_hex(c + 2, 2);
	col.b = (nk_byte)nk_parse_hex(c + 4, 2);
	col.a = (nk_byte)nk_parse_hex(c + 6, 2);
	return col;
}

NK_API void nk_color_hex_rgba(char* output, struct nk_color col) {
#define NK_TO_HEX(i) ((i) <= 9 ? '0' + (i): 'A' - 10 + (i))
	output[0] = (char)NK_TO_HEX((col.r & 0xF0) >> 4);
	output[1] = (char)NK_TO_HEX((col.r & 0x0F));
	output[2] = (char)NK_TO_HEX((col.g & 0xF0) >> 4);
	output[3] = (char)NK_TO_HEX((col.g & 0x0F));
	output[4] = (char)NK_TO_HEX((col.b & 0xF0) >> 4);
	output[5] = (char)NK_TO_HEX((col.b & 0x0F));
	output[6] = (char)NK_TO_HEX((col.a & 0xF0) >> 4);
	output[7] = (char)NK_TO_HEX((col.a & 0x0F));
	output[8] = '\0';
#undef NK_TO_HEX
}

NK_API void nk_color_hex_rgb(char* output, struct nk_color col) {
#define NK_TO_HEX(i) ((i) <= 9 ? '0' + (i): 'A' - 10 + (i))
	output[0] = (char)NK_TO_HEX((col.r & 0xF0) >> 4);
	output[1] = (char)NK_TO_HEX((col.r & 0x0F));
	output[2] = (char)NK_TO_HEX((col.g & 0xF0) >> 4);
	output[3] = (char)NK_TO_HEX((col.g & 0x0F));
	output[4] = (char)NK_TO_HEX((col.b & 0xF0) >> 4);
	output[5] = (char)NK_TO_HEX((col.b & 0x0F));
	output[6] = '\0';
#undef NK_TO_HEX
}

NK_API struct nk_color nk_rgba_iv(const int* c) {
	return nk_rgba(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_color nk_rgba_bv(const nk_byte* c) {
	return nk_rgba(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_color nk_rgb(int r, int g, int b) {
	struct nk_color ret;
	ret.r = (nk_byte)NK_CLAMP(0, r, 255);
	ret.g = (nk_byte)NK_CLAMP(0, g, 255);
	ret.b = (nk_byte)NK_CLAMP(0, b, 255);
	ret.a = (nk_byte)255;
	return ret;
}

NK_API struct nk_color nk_rgb_iv(const int* c) {
	return nk_rgb(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_rgb_bv(const nk_byte* c) {
	return nk_rgb(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_rgba_u32(nk_uint in) {
	struct nk_color ret;
	ret.r = (in & 0xFF);
	ret.g = ((in >> 8) & 0xFF);
	ret.b = ((in >> 16) & 0xFF);
	ret.a = (nk_byte)((in >> 24) & 0xFF);
	return ret;
}

NK_API struct nk_color nk_rgba_f(float r, float g, float b, float a) {
	struct nk_color ret;
	ret.r = (nk_byte)(NK_SATURATE(r) * 255.0f);
	ret.g = (nk_byte)(NK_SATURATE(g) * 255.0f);
	ret.b = (nk_byte)(NK_SATURATE(b) * 255.0f);
	ret.a = (nk_byte)(NK_SATURATE(a) * 255.0f);
	return ret;
}

NK_API struct nk_color nk_rgba_fv(const float* c) {
	return nk_rgba_f(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_color nk_rgba_cf(struct nk_colorf c) {
	return nk_rgba_f(c.r, c.g, c.b, c.a);
}

NK_API struct nk_color nk_rgb_f(float r, float g, float b) {
	struct nk_color ret;
	ret.r = (nk_byte)(NK_SATURATE(r) * 255.0f);
	ret.g = (nk_byte)(NK_SATURATE(g) * 255.0f);
	ret.b = (nk_byte)(NK_SATURATE(b) * 255.0f);
	ret.a = 255;
	return ret;
}

NK_API struct nk_color nk_rgb_fv(const float* c) {
	return nk_rgb_f(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_rgb_cf(struct nk_colorf c) {
	return nk_rgb_f(c.r, c.g, c.b);
}

NK_API struct nk_color nk_hsv(int h, int s, int v) {
	return nk_hsva(h, s, v, 255);
}

NK_API struct nk_color nk_hsv_iv(const int* c) {
	return nk_hsv(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_hsv_bv(const nk_byte* c) {
	return nk_hsv(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_hsv_f(float h, float s, float v) {
	return nk_hsva_f(h, s, v, 1.0f);
}

NK_API struct nk_color nk_hsv_fv(const float* c) {
	return nk_hsv_f(c[0], c[1], c[2]);
}

NK_API struct nk_color nk_hsva(int h, int s, int v, int a) {
	float hf = ((float)NK_CLAMP(0, h, 255)) / 255.0f;
	float sf = ((float)NK_CLAMP(0, s, 255)) / 255.0f;
	float vf = ((float)NK_CLAMP(0, v, 255)) / 255.0f;
	float af = ((float)NK_CLAMP(0, a, 255)) / 255.0f;
	return nk_hsva_f(hf, sf, vf, af);
}

NK_API struct nk_color nk_hsva_iv(const int* c) {
	return nk_hsva(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_color nk_hsva_bv(const nk_byte* c) {
	return nk_hsva(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_colorf nk_hsva_colorf(float h, float s, float v, float a) {
	int i;
	float p, q, t, f;
	struct nk_colorf out = { 0, 0, 0, 0 };
	if (s <= 0.0f) {
		out.r = v;
		out.g = v;
		out.b = v;
		out.a = a;
		return out;
	}
	h = h / (60.0f / 360.0f);
	i = (int)h;
	f = h - (float)i;
	p = v * (1.0f - s);
	q = v * (1.0f - (s * f));
	t = v * (1.0f - s * (1.0f - f));

	switch (i) {
	case 0:
	default:
		out.r = v;
		out.g = t;
		out.b = p;
		break;
	case 1:
		out.r = q;
		out.g = v;
		out.b = p;
		break;
	case 2:
		out.r = p;
		out.g = v;
		out.b = t;
		break;
	case 3:
		out.r = p;
		out.g = q;
		out.b = v;
		break;
	case 4:
		out.r = t;
		out.g = p;
		out.b = v;
		break;
	case 5:
		out.r = v;
		out.g = p;
		out.b = q;
		break;
	}
	out.a = a;
	return out;
}

NK_API struct nk_colorf nk_hsva_colorfv(float* c) {
	return nk_hsva_colorf(c[0], c[1], c[2], c[3]);
}

NK_API struct nk_color nk_hsva_f(float h, float s, float v, float a) {
	struct nk_colorf c = nk_hsva_colorf(h, s, v, a);
	return nk_rgba_f(c.r, c.g, c.b, c.a);
}

NK_API struct nk_color nk_hsva_fv(const float* c) {
	return nk_hsva_f(c[0], c[1], c[2], c[3]);
}

NK_API nk_uint nk_color_u32(struct nk_color in) {
	nk_uint out = (nk_uint)in.r;
	out |= ((nk_uint)in.g << 8);
	out |= ((nk_uint)in.b << 16);
	out |= ((nk_uint)in.a << 24);
	return out;
}

NK_API void nk_color_f(float* r, float* g, float* b, float* a, struct nk_color in) {
	NK_STORAGE const float s = 1.0f / 255.0f;
	*r = (float)in.r * s;
	*g = (float)in.g * s;
	*b = (float)in.b * s;
	*a = (float)in.a * s;
}

NK_API void nk_color_fv(float* c, struct nk_color in) {
	nk_color_f(&c[0], &c[1], &c[2], &c[3], in);
}

NK_API struct nk_colorf nk_color_cf(struct nk_color in) {
	struct nk_colorf o;
	nk_color_f(&o.r, &o.g, &o.b, &o.a, in);
	return o;
}

NK_API void nk_color_d(double* r, double* g, double* b, double* a, struct nk_color in) {
	NK_STORAGE const double s = 1.0 / 255.0;
	*r = (double)in.r * s;
	*g = (double)in.g * s;
	*b = (double)in.b * s;
	*a = (double)in.a * s;
}

NK_API void nk_color_dv(double* c, struct nk_color in) {
	nk_color_d(&c[0], &c[1], &c[2], &c[3], in);
}

NK_API void nk_color_hsv_f(float* out_h, float* out_s, float* out_v, struct nk_color in) {
	float a;
	nk_color_hsva_f(out_h, out_s, out_v, &a, in);
}

NK_API void nk_color_hsv_fv(float* out, struct nk_color in) {
	float a;
	nk_color_hsva_f(&out[0], &out[1], &out[2], &a, in);
}

NK_API void nk_colorf_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, struct nk_colorf in) {
	float chroma;
	float K = 0.0f;
	if (in.g < in.b) {
		const float t = in.g;
		in.g = in.b;
		in.b = t;
		K = -1.f;
	}
	if (in.r < in.g) {
		const float t = in.r;
		in.r = in.g;
		in.g = t;
		K = -2.f / 6.0f - K;
	}
	chroma = in.r - ((in.g < in.b) ? in.g : in.b);
	*out_h = NK_ABS(K + (in.g - in.b) / (6.0f * chroma + 1e-20f));
	*out_s = chroma / (in.r + 1e-20f);
	*out_v = in.r;
	*out_a = in.a;

}

NK_API void nk_colorf_hsva_fv(float* hsva, struct nk_colorf in) {
	nk_colorf_hsva_f(&hsva[0], &hsva[1], &hsva[2], &hsva[3], in);
}

NK_API void nk_color_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, struct nk_color in) {
	struct nk_colorf col;
	nk_color_f(&col.r, &col.g, &col.b, &col.a, in);
	nk_colorf_hsva_f(out_h, out_s, out_v, out_a, col);
}

NK_API void nk_color_hsva_fv(float* out, struct nk_color in) {
	nk_color_hsva_f(&out[0], &out[1], &out[2], &out[3], in);
}

NK_API void nk_color_hsva_i(int* out_h, int* out_s, int* out_v, int* out_a, struct nk_color in) {
	float h, s, v, a;
	nk_color_hsva_f(&h, &s, &v, &a, in);
	*out_h = (nk_byte)(h * 255.0f);
	*out_s = (nk_byte)(s * 255.0f);
	*out_v = (nk_byte)(v * 255.0f);
	*out_a = (nk_byte)(a * 255.0f);
}

NK_API void nk_color_hsva_iv(int* out, struct nk_color in) {
	nk_color_hsva_i(&out[0], &out[1], &out[2], &out[3], in);
}

NK_API void nk_color_hsva_bv(nk_byte* out, struct nk_color in) {
	int tmp[4];
	nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], in);
	out[0] = (nk_byte)tmp[0];
	out[1] = (nk_byte)tmp[1];
	out[2] = (nk_byte)tmp[2];
	out[3] = (nk_byte)tmp[3];
}

NK_API void nk_color_hsva_b(nk_byte* h, nk_byte* s, nk_byte* v, nk_byte* a, struct nk_color in) {
	int tmp[4];
	nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], in);
	*h = (nk_byte)tmp[0];
	*s = (nk_byte)tmp[1];
	*v = (nk_byte)tmp[2];
	*a = (nk_byte)tmp[3];
}

NK_API void nk_color_hsv_i(int* out_h, int* out_s, int* out_v, struct nk_color in) {
	int a;
	nk_color_hsva_i(out_h, out_s, out_v, &a, in);
}

NK_API void nk_color_hsv_b(nk_byte* out_h, nk_byte* out_s, nk_byte* out_v, struct nk_color in) {
	int tmp[4];
	nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], in);
	*out_h = (nk_byte)tmp[0];
	*out_s = (nk_byte)tmp[1];
	*out_v = (nk_byte)tmp[2];
}

NK_API void nk_color_hsv_iv(int* out, struct nk_color in) {
	nk_color_hsv_i(&out[0], &out[1], &out[2], in);
}

NK_API void nk_color_hsv_bv(nk_byte* out, struct nk_color in) {
	int tmp[4];
	nk_color_hsv_i(&tmp[0], &tmp[1], &tmp[2], in);
	out[0] = (nk_byte)tmp[0];
	out[1] = (nk_byte)tmp[1];
	out[2] = (nk_byte)tmp[2];
}





/* ===============================================================
 *
 *                              UTF-8
 *
 * ===============================================================*/
NK_GLOBAL const nk_byte nk_utfbyte[NK_UTF_SIZE + 1] = { 0x80, 0, 0xC0, 0xE0, 0xF0 };
NK_GLOBAL const nk_byte nk_utfmask[NK_UTF_SIZE + 1] = { 0xC0, 0x80, 0xE0, 0xF0, 0xF8 };
NK_GLOBAL const nk_uint nk_utfmin[NK_UTF_SIZE + 1] = { 0, 0, 0x80, 0x800, 0x10000 };
NK_GLOBAL const nk_uint nk_utfmax[NK_UTF_SIZE + 1] = { 0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF };

NK_INTERN int nk_utf_validate(nk_rune* u, int i) {
	NK_ASSERT(u);
	if (!u) return 0;
	if (!NK_BETWEEN(*u, nk_utfmin[i], nk_utfmax[i]) || NK_BETWEEN(*u, 0xD800, 0xDFFF))
		*u = NK_UTF_INVALID;
	for (i = 1; *u > nk_utfmax[i]; ++i);
	return i;
}

NK_INTERN nk_rune nk_utf_decode_byte(char c, int* i) {
	NK_ASSERT(i);
	if (!i) return 0;
	for (*i = 0; *i < (int)NK_LEN(nk_utfmask);
		++(*i)) {
		if (((nk_byte)c & nk_utfmask[*i]) == nk_utfbyte[*i])
			return (nk_byte)(c & ~nk_utfmask[*i]);
	}
	return 0;
}

NK_API int nk_utf_decode(const char* c, nk_rune* u, int clen) {
	int i, j, len, type = 0;
	nk_rune udecoded;

	NK_ASSERT(c);
	NK_ASSERT(u);

	if (!c || !u) return 0;
	if (!clen) return 0;
	*u = NK_UTF_INVALID;

	udecoded = nk_utf_decode_byte(c[0], &len);
	if (!NK_BETWEEN(len, 1, NK_UTF_SIZE))
		return 1;

	for (i = 1, j = 1; i < clen && j < len; ++i, ++j) {
		udecoded = (udecoded << 6) | nk_utf_decode_byte(c[i], &type);
		if (type != 0)
			return j;
	}
	if (j < len)
		return 0;
	*u = udecoded;
	nk_utf_validate(u, len);
	return len;
}

NK_INTERN char nk_utf_encode_byte(nk_rune u, int i) {
	return (char)((nk_utfbyte[i]) | ((nk_byte)u & ~nk_utfmask[i]));
}

NK_API int nk_utf_encode(nk_rune u, char* c, int clen) {
	int len, i;
	len = nk_utf_validate(&u, 0);
	if (clen < len || !len || len > NK_UTF_SIZE)
		return 0;

	for (i = len - 1; i != 0; --i) {
		c[i] = nk_utf_encode_byte(u, 0);
		u >>= 6;
	}
	c[0] = nk_utf_encode_byte(u, len);
	return len;
}

NK_API int nk_utf_len(const char* str, int len) {
	const char* text;
	int glyphs = 0;
	int text_len;
	int glyph_len;
	int src_len = 0;
	nk_rune unicode;

	NK_ASSERT(str);
	if (!str || !len) return 0;

	text = str;
	text_len = len;
	glyph_len = nk_utf_decode(text, &unicode, text_len);
	while (glyph_len && src_len < len) {
		glyphs++;
		src_len = src_len + glyph_len;
		glyph_len = nk_utf_decode(text + src_len, &unicode, text_len - src_len);
	}
	return glyphs;
}

NK_API const char* nk_utf_at(const char* buffer, int length, int index, nk_rune* unicode, int* len) {
	int i = 0;
	int src_len = 0;
	int glyph_len = 0;
	const char* text;
	int text_len;

	NK_ASSERT(buffer);
	NK_ASSERT(unicode);
	NK_ASSERT(len);

	if (!buffer || !unicode || !len) return 0;
	if (index < 0) {
		*unicode = NK_UTF_INVALID;
		*len = 0;
		return 0;
	}

	text = buffer;
	text_len = length;
	glyph_len = nk_utf_decode(text, unicode, text_len);
	while (glyph_len) {
		if (i == index) {
			*len = glyph_len;
			break;
		}

		i++;
		src_len = src_len + glyph_len;
		glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);
	}
	if (i != index) return 0;
	return buffer + src_len;
}





/* ==============================================================
 *
 *                          BUFFER
 *
 * ===============================================================*/
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

NK_LIB void* nk_malloc(nk_handle unused, void* old, nk_size size) {
	NK_UNUSED(unused);
	NK_UNUSED(old);
	return malloc(size);
}

NK_LIB void nk_mfree(nk_handle unused, void* ptr) {
	NK_UNUSED(unused);
	free(ptr);
}

NK_API void nk_buffer_init_default(struct nk_buffer* buffer) {
	struct nk_allocator alloc;
	alloc.userdata.ptr = 0;
	alloc.alloc = nk_malloc;
	alloc.free = nk_mfree;
	nk_buffer_init(buffer, &alloc, NK_BUFFER_DEFAULT_INITIAL_SIZE);
}

#endif

NK_API void nk_buffer_init(struct nk_buffer* b, const struct nk_allocator* a, nk_size initial_size) {
	NK_ASSERT(b);
	NK_ASSERT(a);
	NK_ASSERT(initial_size);
	if (!b || !a || !initial_size) return;

	nk_zero(b, sizeof(*b));
	b->type = NK_BUFFER_DYNAMIC;
	b->memory.ptr = a->alloc(a->userdata, 0, initial_size);
	b->memory.size = initial_size;
	b->size = initial_size;
	b->grow_factor = 2.0f;
	b->pool = *a;
}

NK_API void nk_buffer_init_fixed(struct nk_buffer* b, void* m, nk_size size) {
	NK_ASSERT(b);
	NK_ASSERT(m);
	NK_ASSERT(size);
	if (!b || !m || !size) return;

	nk_zero(b, sizeof(*b));
	b->type = NK_BUFFER_FIXED;
	b->memory.ptr = m;
	b->memory.size = size;
	b->size = size;
}

NK_LIB void* nk_buffer_align(void* unaligned, nk_size align, nk_size* alignment, enum nk_buffer_allocation_type type) {
	void* memory = 0;
	switch (type) {
	default:
	case NK_BUFFER_MAX:
	case NK_BUFFER_FRONT:
		if (align) {
			memory = NK_ALIGN_PTR(unaligned, align);
			*alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned);
		}
		else {
			memory = unaligned;
			*alignment = 0;
		}
		break;
	case NK_BUFFER_BACK:
		if (align) {
			memory = NK_ALIGN_PTR_BACK(unaligned, align);
			*alignment = (nk_size)((nk_byte*)unaligned - (nk_byte*)memory);
		}
		else {
			memory = unaligned;
			*alignment = 0;
		}
		break;
	}
	return memory;
}

NK_LIB void* nk_buffer_realloc(struct nk_buffer* b, nk_size capacity, nk_size* size) {
	void* temp;
	nk_size buffer_size;

	NK_ASSERT(b);
	NK_ASSERT(size);
	if (!b || !size || !b->pool.alloc || !b->pool.free)
		return 0;

	buffer_size = b->memory.size;
	temp = b->pool.alloc(b->pool.userdata, b->memory.ptr, capacity);
	NK_ASSERT(temp);
	if (!temp) return 0;

	*size = capacity;
	if (temp != b->memory.ptr) {
		NK_MEMCPY(temp, b->memory.ptr, buffer_size);
		b->pool.free(b->pool.userdata, b->memory.ptr);
	}

	if (b->size == buffer_size) {
		/* no back buffer so just set correct size */
		b->size = capacity;
		return temp;
	}
	else {
		/* copy back buffer to the end of the new buffer */
		void* dst, * src;
		nk_size back_size;
		back_size = buffer_size - b->size;
		dst = nk_ptr_add(void, temp, capacity - back_size);
		src = nk_ptr_add(void, temp, b->size);
		NK_MEMCPY(dst, src, back_size);
		b->size = capacity - back_size;
	}
	return temp;
}

NK_LIB void* nk_buffer_alloc(struct nk_buffer* b, enum nk_buffer_allocation_type type, nk_size size, nk_size align) {
	int full;
	nk_size alignment;
	void* unaligned;
	void* memory;

	NK_ASSERT(b);
	NK_ASSERT(size);
	if (!b || !size) return 0;
	b->needed += size;

	/* calculate total size with needed alignment + size */
	if (type == NK_BUFFER_FRONT)
		unaligned = nk_ptr_add(void, b->memory.ptr, b->allocated);
	else unaligned = nk_ptr_add(void, b->memory.ptr, b->size - size);
	memory = nk_buffer_align(unaligned, align, &alignment, type);

	/* check if buffer has enough memory*/
	if (type == NK_BUFFER_FRONT)
		full = ((b->allocated + size + alignment) > b->size);
	else full = ((b->size - NK_MIN(b->size, (size + alignment))) <= b->allocated);

	if (full) {
		nk_size capacity;
		if (b->type != NK_BUFFER_DYNAMIC)
			return 0;
		NK_ASSERT(b->pool.alloc && b->pool.free);
		if (b->type != NK_BUFFER_DYNAMIC || !b->pool.alloc || !b->pool.free)
			return 0;

		/* buffer is full so allocate bigger buffer if dynamic */
		capacity = (nk_size)((float)b->memory.size * b->grow_factor);
		capacity = NK_MAX(capacity, nk_round_up_pow2((nk_uint)(b->allocated + size)));
		b->memory.ptr = nk_buffer_realloc(b, capacity, &b->memory.size);
		if (!b->memory.ptr) return 0;

		/* align newly allocated pointer */
		if (type == NK_BUFFER_FRONT)
			unaligned = nk_ptr_add(void, b->memory.ptr, b->allocated);
		else unaligned = nk_ptr_add(void, b->memory.ptr, b->size - size);
		memory = nk_buffer_align(unaligned, align, &alignment, type);
	}
	if (type == NK_BUFFER_FRONT)
		b->allocated += size + alignment;
	else b->size -= (size + alignment);
	b->needed += alignment;
	b->calls++;
	return memory;
}

NK_API void nk_buffer_push(struct nk_buffer* b, enum nk_buffer_allocation_type type, const void* memory, nk_size size,
	nk_size align) {
	void* mem = nk_buffer_alloc(b, type, size, align);
	if (!mem) return;
	NK_MEMCPY(mem, memory, size);
}

NK_API void nk_buffer_mark(struct nk_buffer* buffer, enum nk_buffer_allocation_type type) {
	NK_ASSERT(buffer);
	if (!buffer) return;
	buffer->marker[type].active = nk_true;
	if (type == NK_BUFFER_BACK)
		buffer->marker[type].offset = buffer->size;
	else buffer->marker[type].offset = buffer->allocated;
}

NK_API void nk_buffer_reset(struct nk_buffer* buffer, enum nk_buffer_allocation_type type) {
	NK_ASSERT(buffer);
	if (!buffer) return;
	if (type == NK_BUFFER_BACK) {
		/* reset back buffer either back to marker or empty */
		buffer->needed -= (buffer->memory.size - buffer->marker[type].offset);
		if (buffer->marker[type].active)
			buffer->size = buffer->marker[type].offset;
		else buffer->size = buffer->memory.size;
		buffer->marker[type].active = nk_false;
	}
	else {
		/* reset front buffer either back to back marker or empty */
		buffer->needed -= (buffer->allocated - buffer->marker[type].offset);
		if (buffer->marker[type].active)
			buffer->allocated = buffer->marker[type].offset;
		else buffer->allocated = 0;
		buffer->marker[type].active = nk_false;
	}
}

NK_API void nk_buffer_clear(struct nk_buffer* b) {
	NK_ASSERT(b);
	if (!b) return;
	b->allocated = 0;
	b->size = b->memory.size;
	b->calls = 0;
	b->needed = 0;
}

NK_API void nk_buffer_free(struct nk_buffer* b) {
	NK_ASSERT(b);
	if (!b || !b->memory.ptr) return;
	if (b->type == NK_BUFFER_FIXED) return;
	if (!b->pool.free) return;
	NK_ASSERT(b->pool.free);
	b->pool.free(b->pool.userdata, b->memory.ptr);
}

NK_API void nk_buffer_info(struct nk_memory_status* s, struct nk_buffer* b) {
	NK_ASSERT(b);
	NK_ASSERT(s);
	if (!s || !b) return;
	s->allocated = b->allocated;
	s->size = b->memory.size;
	s->needed = b->needed;
	s->memory = b->memory.ptr;
	s->calls = b->calls;
}

NK_API void* nk_buffer_memory(struct nk_buffer* buffer) {
	NK_ASSERT(buffer);
	if (!buffer) return 0;
	return buffer->memory.ptr;
}

NK_API const void* nk_buffer_memory_const(const struct nk_buffer* buffer) {
	NK_ASSERT(buffer);
	if (!buffer) return 0;
	return buffer->memory.ptr;
}

NK_API nk_size nk_buffer_total(struct nk_buffer* buffer) {
	NK_ASSERT(buffer);
	if (!buffer) return 0;
	return buffer->memory.size;
}





/* ===============================================================
 *
 *                              STRING
 *
 * ===============================================================*/
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

NK_API void nk_str_init_default(struct nk_str* str) {
	struct nk_allocator alloc;
	alloc.userdata.ptr = 0;
	alloc.alloc = nk_malloc;
	alloc.free = nk_mfree;
	nk_buffer_init(&str->buffer, &alloc, 32);
	str->len = 0;
}

#endif

NK_API void nk_str_init(struct nk_str* str, const struct nk_allocator* alloc, nk_size size) {
	nk_buffer_init(&str->buffer, alloc, size);
	str->len = 0;
}

NK_API void nk_str_init_fixed(struct nk_str* str, void* memory, nk_size size) {
	nk_buffer_init_fixed(&str->buffer, memory, size);
	str->len = 0;
}

NK_API int nk_str_append_text_char(struct nk_str* s, const char* str, int len) {
	char* mem;
	NK_ASSERT(s);
	NK_ASSERT(str);
	if (!s || !str || !len) return 0;
	mem = (char*)nk_buffer_alloc(&s->buffer, NK_BUFFER_FRONT, (nk_size)len * sizeof(char), 0);
	if (!mem) return 0;
	NK_MEMCPY(mem, str, (nk_size)len * sizeof(char));
	s->len += nk_utf_len(str, len);
	return len;
}

NK_API int nk_str_append_str_char(struct nk_str* s, const char* str) {
	return nk_str_append_text_char(s, str, nk_strlen(str));
}

NK_API int nk_str_append_text_utf8(struct nk_str* str, const char* text, int len) {
	int i = 0;
	int byte_len = 0;
	nk_rune unicode;
	if (!str || !text || !len) return 0;
	for (i = 0; i < len; ++i)
		byte_len += nk_utf_decode(text + byte_len, &unicode, 4);
	nk_str_append_text_char(str, text, byte_len);
	return len;
}

NK_API int nk_str_append_str_utf8(struct nk_str* str, const char* text) {
	int runes = 0;
	int byte_len = 0;
	int num_runes = 0;
	int glyph_len = 0;
	nk_rune unicode;
	if (!str || !text) return 0;

	glyph_len = byte_len = nk_utf_decode(text + byte_len, &unicode, 4);
	while (unicode != '\0' && glyph_len) {
		glyph_len = nk_utf_decode(text + byte_len, &unicode, 4);
		byte_len += glyph_len;
		num_runes++;
	}
	nk_str_append_text_char(str, text, byte_len);
	return runes;
}

NK_API int nk_str_append_text_runes(struct nk_str* str, const nk_rune* text, int len) {
	int i = 0;
	int byte_len = 0;
	nk_glyph glyph;

	NK_ASSERT(str);
	if (!str || !text || !len) return 0;
	for (i = 0; i < len; ++i) {
		byte_len = nk_utf_encode(text[i], glyph, NK_UTF_SIZE);
		if (!byte_len) break;
		nk_str_append_text_char(str, glyph, byte_len);
	}
	return len;
}

NK_API int nk_str_append_str_runes(struct nk_str* str, const nk_rune* runes) {
	int i = 0;
	nk_glyph glyph;
	int byte_len;
	NK_ASSERT(str);
	if (!str || !runes) return 0;
	while (runes[i] != '\0') {
		byte_len = nk_utf_encode(runes[i], glyph, NK_UTF_SIZE);
		nk_str_append_text_char(str, glyph, byte_len);
		i++;
	}
	return i;
}

NK_API int nk_str_insert_at_char(struct nk_str* s, int pos, const char* str, int len) {
	int i;
	void* mem;
	char* src;
	char* dst;

	int copylen;
	NK_ASSERT(s);
	NK_ASSERT(str);
	NK_ASSERT(len >= 0);
	if (!s || !str || !len || (nk_size)pos > s->buffer.allocated) return 0;
	if ((s->buffer.allocated + (nk_size)len >= s->buffer.memory.size) && (s->buffer.type == NK_BUFFER_FIXED)) return 0;

	copylen = (int)s->buffer.allocated - pos;
	if (!copylen) {
		nk_str_append_text_char(s, str, len);
		return 1;
	}
	mem = nk_buffer_alloc(&s->buffer, NK_BUFFER_FRONT, (nk_size)len * sizeof(char), 0);
	if (!mem) return 0;

	/* memmove */
	NK_ASSERT(((int)pos + (int)len + ((int)copylen - 1)) >= 0);
	NK_ASSERT(((int)pos + ((int)copylen - 1)) >= 0);
	dst = nk_ptr_add(char, s->buffer.memory.ptr, pos + len + (copylen - 1));
	src = nk_ptr_add(char, s->buffer.memory.ptr, pos + (copylen - 1));
	for (i = 0; i < copylen; ++i) *dst-- = *src--;
	mem = nk_ptr_add(void, s->buffer.memory.ptr, pos);
	NK_MEMCPY(mem, str, (nk_size)len * sizeof(char));
	s->len = nk_utf_len((char*)s->buffer.memory.ptr, (int)s->buffer.allocated);
	return 1;
}

NK_API int nk_str_insert_at_rune(struct nk_str* str, int pos, const char* cstr, int len) {
	int glyph_len;
	nk_rune unicode;
	const char* begin;
	const char* buffer;

	NK_ASSERT(str);
	NK_ASSERT(cstr);
	NK_ASSERT(len);
	if (!str || !cstr || !len) return 0;
	begin = nk_str_at_rune(str, pos, &unicode, &glyph_len);
	if (!str->len)
		return nk_str_append_text_char(str, cstr, len);
	buffer = nk_str_get_const(str);
	if (!begin) return 0;
	return nk_str_insert_at_char(str, (int)(begin - buffer), cstr, len);
}

NK_API int nk_str_insert_text_char(struct nk_str* str, int pos, const char* text, int len) {
	return nk_str_insert_text_utf8(str, pos, text, len);
}

NK_API int nk_str_insert_str_char(struct nk_str* str, int pos, const char* text) {
	return nk_str_insert_text_utf8(str, pos, text, nk_strlen(text));
}

NK_API int nk_str_insert_text_utf8(struct nk_str* str, int pos, const char* text, int len) {
	int i = 0;
	int byte_len = 0;
	nk_rune unicode;

	NK_ASSERT(str);
	NK_ASSERT(text);
	if (!str || !text || !len) return 0;
	for (i = 0; i < len; ++i)
		byte_len += nk_utf_decode(text + byte_len, &unicode, 4);
	nk_str_insert_at_rune(str, pos, text, byte_len);
	return len;
}

NK_API int nk_str_insert_str_utf8(struct nk_str* str, int pos, const char* text) {
	int runes = 0;
	int byte_len = 0;
	int num_runes = 0;
	int glyph_len = 0;
	nk_rune unicode;
	if (!str || !text) return 0;

	glyph_len = byte_len = nk_utf_decode(text + byte_len, &unicode, 4);
	while (unicode != '\0' && glyph_len) {
		glyph_len = nk_utf_decode(text + byte_len, &unicode, 4);
		byte_len += glyph_len;
		num_runes++;
	}
	nk_str_insert_at_rune(str, pos, text, byte_len);
	return runes;
}

NK_API int nk_str_insert_text_runes(struct nk_str* str, int pos, const nk_rune* runes, int len) {
	int i = 0;
	int byte_len = 0;
	nk_glyph glyph;

	NK_ASSERT(str);
	if (!str || !runes || !len) return 0;
	for (i = 0; i < len; ++i) {
		byte_len = nk_utf_encode(runes[i], glyph, NK_UTF_SIZE);
		if (!byte_len) break;
		nk_str_insert_at_rune(str, pos + i, glyph, byte_len);
	}
	return len;
}

NK_API int nk_str_insert_str_runes(struct nk_str* str, int pos, const nk_rune* runes) {
	int i = 0;
	nk_glyph glyph;
	int byte_len;
	NK_ASSERT(str);
	if (!str || !runes) return 0;
	while (runes[i] != '\0') {
		byte_len = nk_utf_encode(runes[i], glyph, NK_UTF_SIZE);
		nk_str_insert_at_rune(str, pos + i, glyph, byte_len);
		i++;
	}
	return i;
}

NK_API void nk_str_remove_chars(struct nk_str* s, int len) {
	NK_ASSERT(s);
	NK_ASSERT(len >= 0);
	if (!s || len < 0 || (nk_size)len > s->buffer.allocated) return;
	NK_ASSERT(((int)s->buffer.allocated - (int)len) >= 0);
	s->buffer.allocated -= (nk_size)len;
	s->len = nk_utf_len((char*)s->buffer.memory.ptr, (int)s->buffer.allocated);
}

NK_API void nk_str_remove_runes(struct nk_str* str, int len) {
	int index;
	const char* begin;
	const char* end;
	nk_rune unicode;

	NK_ASSERT(str);
	NK_ASSERT(len >= 0);
	if (!str || len < 0) return;
	if (len >= str->len) {
		str->len = 0;
		return;
	}

	index = str->len - len;
	begin = nk_str_at_rune(str, index, &unicode, &len);
	end = (const char*)str->buffer.memory.ptr + str->buffer.allocated;
	nk_str_remove_chars(str, (int)(end - begin) + 1);
}

NK_API void nk_str_delete_chars(struct nk_str* s, int pos, int len) {
	NK_ASSERT(s);
	if (!s || !len || (nk_size)pos > s->buffer.allocated || (nk_size)(pos + len) > s->buffer.allocated) return;

	if ((nk_size)(pos + len) < s->buffer.allocated) {
		/* memmove */
		char* dst = nk_ptr_add(char, s->buffer.memory.ptr, pos);
		char* src = nk_ptr_add(char, s->buffer.memory.ptr, pos + len);
		NK_MEMCPY(dst, src, s->buffer.allocated - (nk_size)(pos + len));
		NK_ASSERT(((int)s->buffer.allocated - (int)len) >= 0);
		s->buffer.allocated -= (nk_size)len;
	}
	else nk_str_remove_chars(s, len);
	s->len = nk_utf_len((char*)s->buffer.memory.ptr, (int)s->buffer.allocated);
}

NK_API void nk_str_delete_runes(struct nk_str* s, int pos, int len) {
	char* temp;
	nk_rune unicode;
	char* begin;
	char* end;
	int unused;

	NK_ASSERT(s);
	NK_ASSERT(s->len >= pos + len);
	if (s->len < pos + len)
		len = NK_CLAMP(0, (s->len - pos), s->len);
	if (!len) return;

	temp = (char*)s->buffer.memory.ptr;
	begin = nk_str_at_rune(s, pos, &unicode, &unused);
	if (!begin) return;
	s->buffer.memory.ptr = begin;
	end = nk_str_at_rune(s, len, &unicode, &unused);
	s->buffer.memory.ptr = temp;
	if (!end) return;
	nk_str_delete_chars(s, (int)(begin - temp), (int)(end - begin));
}

NK_API char* nk_str_at_char(struct nk_str* s, int pos) {
	NK_ASSERT(s);
	if (!s || pos > (int)s->buffer.allocated) return 0;
	return nk_ptr_add(char, s->buffer.memory.ptr, pos);
}

NK_API char* nk_str_at_rune(struct nk_str* str, int pos, nk_rune* unicode, int* len) {
	int i = 0;
	int src_len = 0;
	int glyph_len = 0;
	char* text;
	int text_len;

	NK_ASSERT(str);
	NK_ASSERT(unicode);
	NK_ASSERT(len);

	if (!str || !unicode || !len) return 0;
	if (pos < 0) {
		*unicode = 0;
		*len = 0;
		return 0;
	}

	text = (char*)str->buffer.memory.ptr;
	text_len = (int)str->buffer.allocated;
	glyph_len = nk_utf_decode(text, unicode, text_len);
	while (glyph_len) {
		if (i == pos) {
			*len = glyph_len;
			break;
		}

		i++;
		src_len = src_len + glyph_len;
		glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);
	}
	if (i != pos) return 0;
	return text + src_len;
}

NK_API const char* nk_str_at_char_const(const struct nk_str* s, int pos) {
	NK_ASSERT(s);
	if (!s || pos > (int)s->buffer.allocated) return 0;
	return nk_ptr_add(char, s->buffer.memory.ptr, pos);
}

NK_API const char* nk_str_at_const(const struct nk_str* str, int pos, nk_rune* unicode, int* len) {
	int i = 0;
	int src_len = 0;
	int glyph_len = 0;
	char* text;
	int text_len;

	NK_ASSERT(str);
	NK_ASSERT(unicode);
	NK_ASSERT(len);

	if (!str || !unicode || !len) return 0;
	if (pos < 0) {
		*unicode = 0;
		*len = 0;
		return 0;
	}

	text = (char*)str->buffer.memory.ptr;
	text_len = (int)str->buffer.allocated;
	glyph_len = nk_utf_decode(text, unicode, text_len);
	while (glyph_len) {
		if (i == pos) {
			*len = glyph_len;
			break;
		}

		i++;
		src_len = src_len + glyph_len;
		glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);
	}
	if (i != pos) return 0;
	return text + src_len;
}

NK_API nk_rune nk_str_rune_at(const struct nk_str* str, int pos) {
	int len;
	nk_rune unicode = 0;
	nk_str_at_const(str, pos, &unicode, &len);
	return unicode;
}

NK_API char* nk_str_get(struct nk_str* s) {
	NK_ASSERT(s);
	if (!s || !s->len || !s->buffer.allocated) return 0;
	return (char*)s->buffer.memory.ptr;
}

NK_API const char* nk_str_get_const(const struct nk_str* s) {
	NK_ASSERT(s);
	if (!s || !s->len || !s->buffer.allocated) return 0;
	return (const char*)s->buffer.memory.ptr;
}

NK_API int nk_str_len(struct nk_str* s) {
	NK_ASSERT(s);
	if (!s || !s->len || !s->buffer.allocated) return 0;
	return s->len;
}

NK_API int nk_str_len_char(struct nk_str* s) {
	NK_ASSERT(s);
	if (!s || !s->len || !s->buffer.allocated) return 0;
	return (int)s->buffer.allocated;
}

NK_API void nk_str_clear(struct nk_str* str) {
	NK_ASSERT(str);
	nk_buffer_clear(&str->buffer);
	str->len = 0;
}

NK_API void nk_str_free(struct nk_str* str) {
	NK_ASSERT(str);
	nk_buffer_free(&str->buffer);
	str->len = 0;
}





/* ==============================================================
 *
 *                          DRAW
 *
 * ===============================================================*/
NK_LIB void nk_command_buffer_init(struct nk_command_buffer* cb, struct nk_buffer* b, enum nk_command_clipping clip) {
	NK_ASSERT(cb);
	NK_ASSERT(b);
	if (!cb || !b) return;
	cb->base = b;
	cb->use_clipping = (int)clip;
	cb->begin = b->allocated;
	cb->end = b->allocated;
	cb->last = b->allocated;
}

NK_LIB void nk_command_buffer_reset(struct nk_command_buffer* b) {
	NK_ASSERT(b);
	if (!b) return;
	b->begin = 0;
	b->end = 0;
	b->last = 0;
	b->clip = nk_null_rect;
#ifdef NK_INCLUDE_COMMAND_USERDATA
	b->userdata.ptr = 0;
#endif
}

NK_LIB void* nk_command_buffer_push(struct nk_command_buffer* b, enum nk_command_type t, nk_size size) {
	NK_STORAGE const nk_size align = NK_ALIGNOF(struct nk_command);
	struct nk_command* cmd;
	nk_size alignment;
	void* unaligned;
	void* memory;

	NK_ASSERT(b);
	NK_ASSERT(b->base);
	if (!b) return 0;
	cmd = (struct nk_command*) nk_buffer_alloc(b->base, NK_BUFFER_FRONT, size, align);
	if (!cmd) return 0;

	/* make sure the offset to the next command is aligned */
	b->last = (nk_size)((nk_byte*)cmd - (nk_byte*)b->base->memory.ptr);
	unaligned = (nk_byte*)cmd + size;
	memory = NK_ALIGN_PTR(unaligned, align);
	alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned);
#ifdef NK_ZERO_COMMAND_MEMORY
	NK_MEMSET(cmd, 0, size + alignment);
#endif

	cmd->type = t;
	cmd->next = b->base->allocated + alignment;
#ifdef NK_INCLUDE_COMMAND_USERDATA
	cmd->userdata = b->userdata;
#endif
	b->end = cmd->next;
	return cmd;
}

NK_API void nk_push_scissor(struct nk_command_buffer* b, struct nk_rect r) {
	struct nk_command_scissor* cmd;
	NK_ASSERT(b);
	if (!b) return;

	b->clip.x = r.x;
	b->clip.y = r.y;
	b->clip.w = r.w;
	b->clip.h = r.h;
	cmd = (struct nk_command_scissor*) nk_command_buffer_push(b, NK_COMMAND_SCISSOR, sizeof(*cmd));

	if (!cmd) return;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)NK_MAX(0, r.w);
	cmd->h = (unsigned short)NK_MAX(0, r.h);
}

NK_API void nk_stroke_line(struct nk_command_buffer* b, float x0, float y0, float x1, float y1, float line_thickness,
	struct nk_color c) {
	struct nk_command_line* cmd;
	NK_ASSERT(b);
	if (!b || line_thickness <= 0) return;
	cmd = (struct nk_command_line*) nk_command_buffer_push(b, NK_COMMAND_LINE, sizeof(*cmd));
	if (!cmd) return;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->begin.x = (short)x0;
	cmd->begin.y = (short)y0;
	cmd->end.x = (short)x1;
	cmd->end.y = (short)y1;
	cmd->color = c;
}

NK_API void
nk_stroke_curve(struct nk_command_buffer* b, float ax, float ay, float ctrl0x, float ctrl0y, float ctrl1x, float ctrl1y,
	float bx, float by, float line_thickness, struct nk_color col) {
	struct nk_command_curve* cmd;
	NK_ASSERT(b);
	if (!b || col.a == 0 || line_thickness <= 0) return;

	cmd = (struct nk_command_curve*) nk_command_buffer_push(b, NK_COMMAND_CURVE, sizeof(*cmd));
	if (!cmd) return;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->begin.x = (short)ax;
	cmd->begin.y = (short)ay;
	cmd->ctrl[0].x = (short)ctrl0x;
	cmd->ctrl[0].y = (short)ctrl0y;
	cmd->ctrl[1].x = (short)ctrl1x;
	cmd->ctrl[1].y = (short)ctrl1y;
	cmd->end.x = (short)bx;
	cmd->end.y = (short)by;
	cmd->color = col;
}

NK_API void nk_stroke_rect(struct nk_command_buffer* b, struct nk_rect rect, float rounding, float line_thickness,
	struct nk_color c) {
	struct nk_command_rect* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0 || rect.w == 0 || rect.h == 0 || line_thickness <= 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h, clip->x, clip->y, clip->w, clip->h)) return;
	}
	cmd = (struct nk_command_rect*) nk_command_buffer_push(b, NK_COMMAND_RECT, sizeof(*cmd));
	if (!cmd) return;
	cmd->rounding = (unsigned short)rounding;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->x = (short)rect.x;
	cmd->y = (short)rect.y;
	cmd->w = (unsigned short)NK_MAX(0, rect.w);
	cmd->h = (unsigned short)NK_MAX(0, rect.h);
	cmd->color = c;
}

NK_API void nk_fill_rect(struct nk_command_buffer* b, struct nk_rect rect, float rounding, struct nk_color c) {
	struct nk_command_rect_filled* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0 || rect.w == 0 || rect.h == 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h, clip->x, clip->y, clip->w, clip->h)) return;
	}

	cmd = (struct nk_command_rect_filled*) nk_command_buffer_push(b, NK_COMMAND_RECT_FILLED, sizeof(*cmd));
	if (!cmd) return;
	cmd->rounding = (unsigned short)rounding;
	cmd->x = (short)rect.x;
	cmd->y = (short)rect.y;
	cmd->w = (unsigned short)NK_MAX(0, rect.w);
	cmd->h = (unsigned short)NK_MAX(0, rect.h);
	cmd->color = c;
}

NK_API void
nk_fill_rect_multi_color(struct nk_command_buffer* b, struct nk_rect rect, struct nk_color left, struct nk_color top,
	struct nk_color right, struct nk_color bottom) {
	struct nk_command_rect_multi_color* cmd;
	NK_ASSERT(b);
	if (!b || rect.w == 0 || rect.h == 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h, clip->x, clip->y, clip->w, clip->h)) return;
	}

	cmd = (struct nk_command_rect_multi_color*) nk_command_buffer_push(b, NK_COMMAND_RECT_MULTI_COLOR, sizeof(*cmd));
	if (!cmd) return;
	cmd->x = (short)rect.x;
	cmd->y = (short)rect.y;
	cmd->w = (unsigned short)NK_MAX(0, rect.w);
	cmd->h = (unsigned short)NK_MAX(0, rect.h);
	cmd->left = left;
	cmd->top = top;
	cmd->right = right;
	cmd->bottom = bottom;
}

NK_API void nk_stroke_circle(struct nk_command_buffer* b, struct nk_rect r, float line_thickness, struct nk_color c) {
	struct nk_command_circle* cmd;
	if (!b || r.w == 0 || r.h == 0 || line_thickness <= 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INTERSECT(r.x, r.y, r.w, r.h, clip->x, clip->y, clip->w, clip->h))
			return;
	}

	cmd = (struct nk_command_circle*) nk_command_buffer_push(b, NK_COMMAND_CIRCLE, sizeof(*cmd));
	if (!cmd) return;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)NK_MAX(r.w, 0);
	cmd->h = (unsigned short)NK_MAX(r.h, 0);
	cmd->color = c;
}

NK_API void nk_fill_circle(struct nk_command_buffer* b, struct nk_rect r, struct nk_color c) {
	struct nk_command_circle_filled* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0 || r.w == 0 || r.h == 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INTERSECT(r.x, r.y, r.w, r.h, clip->x, clip->y, clip->w, clip->h))
			return;
	}

	cmd = (struct nk_command_circle_filled*) nk_command_buffer_push(b, NK_COMMAND_CIRCLE_FILLED, sizeof(*cmd));
	if (!cmd) return;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)NK_MAX(r.w, 0);
	cmd->h = (unsigned short)NK_MAX(r.h, 0);
	cmd->color = c;
}

NK_API void nk_stroke_arc(struct nk_command_buffer* b, float cx, float cy, float radius, float a_min, float a_max,
	float line_thickness, struct nk_color c) {
	struct nk_command_arc* cmd;
	if (!b || c.a == 0 || line_thickness <= 0) return;
	cmd = (struct nk_command_arc*) nk_command_buffer_push(b, NK_COMMAND_ARC, sizeof(*cmd));
	if (!cmd) return;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->cx = (short)cx;
	cmd->cy = (short)cy;
	cmd->r = (unsigned short)radius;
	cmd->a[0] = a_min;
	cmd->a[1] = a_max;
	cmd->color = c;
}

NK_API void nk_fill_arc(struct nk_command_buffer* b, float cx, float cy, float radius, float a_min, float a_max,
	struct nk_color c) {
	struct nk_command_arc_filled* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0) return;
	cmd = (struct nk_command_arc_filled*) nk_command_buffer_push(b, NK_COMMAND_ARC_FILLED, sizeof(*cmd));
	if (!cmd) return;
	cmd->cx = (short)cx;
	cmd->cy = (short)cy;
	cmd->r = (unsigned short)radius;
	cmd->a[0] = a_min;
	cmd->a[1] = a_max;
	cmd->color = c;
}

NK_API void nk_stroke_triangle(struct nk_command_buffer* b, float x0, float y0, float x1, float y1, float x2, float y2,
	float line_thickness, struct nk_color c) {
	struct nk_command_triangle* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0 || line_thickness <= 0) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INBOX(x0, y0, clip->x, clip->y, clip->w, clip->h) &&
			!NK_INBOX(x1, y1, clip->x, clip->y, clip->w, clip->h) &&
			!NK_INBOX(x2, y2, clip->x, clip->y, clip->w, clip->h))
			return;
	}

	cmd = (struct nk_command_triangle*) nk_command_buffer_push(b, NK_COMMAND_TRIANGLE, sizeof(*cmd));
	if (!cmd) return;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->a.x = (short)x0;
	cmd->a.y = (short)y0;
	cmd->b.x = (short)x1;
	cmd->b.y = (short)y1;
	cmd->c.x = (short)x2;
	cmd->c.y = (short)y2;
	cmd->color = c;
}

NK_API void nk_fill_triangle(struct nk_command_buffer* b, float x0, float y0, float x1, float y1, float x2, float y2,
	struct nk_color c) {
	struct nk_command_triangle_filled* cmd;
	NK_ASSERT(b);
	if (!b || c.a == 0) return;
	if (!b) return;
	if (b->use_clipping) {
		const struct nk_rect* clip = &b->clip;
		if (!NK_INBOX(x0, y0, clip->x, clip->y, clip->w, clip->h) &&
			!NK_INBOX(x1, y1, clip->x, clip->y, clip->w, clip->h) &&
			!NK_INBOX(x2, y2, clip->x, clip->y, clip->w, clip->h))
			return;
	}

	cmd = (struct nk_command_triangle_filled*) nk_command_buffer_push(b, NK_COMMAND_TRIANGLE_FILLED, sizeof(*cmd));
	if (!cmd) return;
	cmd->a.x = (short)x0;
	cmd->a.y = (short)y0;
	cmd->b.x = (short)x1;
	cmd->b.y = (short)y1;
	cmd->c.x = (short)x2;
	cmd->c.y = (short)y2;
	cmd->color = c;
}

NK_API void nk_stroke_polygon(struct nk_command_buffer* b, float* points, int point_count, float line_thickness,
	struct nk_color col) {
	int i;
	nk_size size = 0;
	struct nk_command_polygon* cmd;

	NK_ASSERT(b);
	if (!b || col.a == 0 || line_thickness <= 0) return;
	size = sizeof(*cmd) + sizeof(short) * 2 * (nk_size)point_count;
	cmd = (struct nk_command_polygon*) nk_command_buffer_push(b, NK_COMMAND_POLYGON, size);
	if (!cmd) return;
	cmd->color = col;
	cmd->line_thickness = (unsigned short)line_thickness;
	cmd->point_count = (unsigned short)point_count;
	for (i = 0; i < point_count; ++i) {
		cmd->points[i].x = (short)points[i * 2];
		cmd->points[i].y = (short)points[i * 2 + 1];
	}
}

NK_API void nk_fill_polygon(struct nk_command_buffer* b, float* points, int point_count, struct nk_color col) {
	int i;
	nk_size size = 0;
	struct nk_command_polygon_filled* cmd;

	NK_ASSERT(b);
	if (!b || col.a == 0) return;
	size = sizeof(*cmd) + sizeof(short) * 2 * (nk_size)point_count;
	cmd = (struct nk_command_polygon_filled*) nk_command_buffer_push(b, NK_COMMAND_POLYGON_FILLED, size);
	if (!cmd) return;
	cmd->color = col;
	cmd->point_count = (unsigned short)point_count;
	for (i = 0; i < point_count; ++i) {
		cmd->points[i].x = (short)points[i * 2 + 0];
		cmd->points[i].y = (short)points[i * 2 + 1];
	}
}

NK_API void nk_stroke_polyline(struct nk_command_buffer* b, float* points, int point_count, float line_thickness,
	struct nk_color col) {
	int i;
	nk_size size = 0;
	struct nk_command_polyline* cmd;

	NK_ASSERT(b);
	if (!b || col.a == 0 || line_thickness <= 0) return;
	size = sizeof(*cmd) + sizeof(short) * 2 * (nk_size)point_count;
	cmd = (struct nk_command_polyline*) nk_command_buffer_push(b, NK_COMMAND_POLYLINE, size);
	if (!cmd) return;
	cmd->color = col;
	cmd->point_count = (unsigned short)point_count;
	cmd->line_thickness = (unsigned short)line_thickness;
	for (i = 0; i < point_count; ++i) {
		cmd->points[i].x = (short)points[i * 2];
		cmd->points[i].y = (short)points[i * 2 + 1];
	}
}

NK_API void
nk_draw_image(struct nk_command_buffer* b, struct nk_rect r, const struct nk_image* img, struct nk_color col) {
	struct nk_command_image* cmd;
	NK_ASSERT(b);
	if (!b) return;
	if (b->use_clipping) {
		const struct nk_rect* c = &b->clip;
		if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
			return;
	}

	cmd = (struct nk_command_image*) nk_command_buffer_push(b, NK_COMMAND_IMAGE, sizeof(*cmd));
	if (!cmd) return;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)NK_MAX(0, r.w);
	cmd->h = (unsigned short)NK_MAX(0, r.h);
	cmd->img = *img;
	cmd->col = col;
}

NK_API void
nk_push_custom(struct nk_command_buffer* b, struct nk_rect r, nk_command_custom_callback cb, nk_handle usr) {
	struct nk_command_custom* cmd;
	NK_ASSERT(b);
	if (!b) return;
	if (b->use_clipping) {
		const struct nk_rect* c = &b->clip;
		if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
			return;
	}

	cmd = (struct nk_command_custom*) nk_command_buffer_push(b, NK_COMMAND_CUSTOM, sizeof(*cmd));
	if (!cmd) return;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)NK_MAX(0, r.w);
	cmd->h = (unsigned short)NK_MAX(0, r.h);
	cmd->callback_data = usr;
	cmd->callback = cb;
}

NK_API void nk_draw_text(struct nk_command_buffer* b, struct nk_rect r, const char* string, int length,
	const struct nk_user_font* font, struct nk_color bg, struct nk_color fg) {
	float text_width = 0;
	struct nk_command_text* cmd;

	NK_ASSERT(b);
	NK_ASSERT(font);
	if (!b || !string || !length || (bg.a == 0 && fg.a == 0)) return;
	if (b->use_clipping) {
		const struct nk_rect* c = &b->clip;
		if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))
			return;
	}

	/* make sure text fits inside bounds */
	text_width = font->width(font->userdata, font->height, string, length);
	if (text_width > r.w) {
		int glyphs = 0;
		float txt_width = (float)text_width;
		length = nk_text_clamp(font, string, length, r.w, &glyphs, &txt_width, 0, 0);
	}

	if (!length) return;
	cmd = (struct nk_command_text*) nk_command_buffer_push(b, NK_COMMAND_TEXT, sizeof(*cmd) + (nk_size)(length + 1));
	if (!cmd) return;
	cmd->x = (short)r.x;
	cmd->y = (short)r.y;
	cmd->w = (unsigned short)r.w;
	cmd->h = (unsigned short)r.h;
	cmd->background = bg;
	cmd->foreground = fg;
	cmd->font = font;
	cmd->length = length;
	cmd->height = font->height;
	NK_MEMCPY(cmd->string, string, (nk_size)length);
	cmd->string[length] = '\0';
}





/* ===============================================================
 *
 *                              VERTEX
 *
 * ===============================================================*/
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
NK_API void
nk_draw_list_init(struct nk_draw_list* list)
{
	nk_size i = 0;
	NK_ASSERT(list);
	if (!list) return;
	nk_zero(list, sizeof(*list));
	for (i = 0; i < NK_LEN(list->circle_vtx); ++i) {
		const float a = ((float)i / (float)NK_LEN(list->circle_vtx)) * 2 * NK_PI;
		list->circle_vtx[i].x = (float)NK_COS(a);
		list->circle_vtx[i].y = (float)NK_SIN(a);
	}
}
NK_API void
nk_draw_list_setup(struct nk_draw_list* canvas, const struct nk_convert_config* config,
	struct nk_buffer* cmds, struct nk_buffer* vertices, struct nk_buffer* elements,
	enum nk_anti_aliasing line_aa, enum nk_anti_aliasing shape_aa)
{
	NK_ASSERT(canvas);
	NK_ASSERT(config);
	NK_ASSERT(cmds);
	NK_ASSERT(vertices);
	NK_ASSERT(elements);
	if (!canvas || !config || !cmds || !vertices || !elements)
		return;

	canvas->buffer = cmds;
	canvas->config = *config;
	canvas->elements = elements;
	canvas->vertices = vertices;
	canvas->line_AA = line_aa;
	canvas->shape_AA = shape_aa;
	canvas->clip_rect = nk_null_rect;

	canvas->cmd_offset = 0;
	canvas->element_count = 0;
	canvas->vertex_count = 0;
	canvas->cmd_offset = 0;
	canvas->cmd_count = 0;
	canvas->path_count = 0;
}
NK_API const struct nk_draw_command*
nk__draw_list_begin(const struct nk_draw_list* canvas, const struct nk_buffer* buffer)
{
	nk_byte* memory;
	nk_size offset;
	const struct nk_draw_command* cmd;

	NK_ASSERT(buffer);
	if (!buffer || !buffer->size || !canvas->cmd_count)
		return 0;

	memory = (nk_byte*)buffer->memory.ptr;
	offset = buffer->memory.size - canvas->cmd_offset;
	cmd = nk_ptr_add(const struct nk_draw_command, memory, offset);
	return cmd;
}
NK_API const struct nk_draw_command*
nk__draw_list_end(const struct nk_draw_list* canvas, const struct nk_buffer* buffer)
{
	nk_size size;
	nk_size offset;
	nk_byte* memory;
	const struct nk_draw_command* end;

	NK_ASSERT(buffer);
	NK_ASSERT(canvas);
	if (!buffer || !canvas)
		return 0;

	memory = (nk_byte*)buffer->memory.ptr;
	size = buffer->memory.size;
	offset = size - canvas->cmd_offset;
	end = nk_ptr_add(const struct nk_draw_command, memory, offset);
	end -= (canvas->cmd_count - 1);
	return end;
}
NK_API const struct nk_draw_command*
nk__draw_list_next(const struct nk_draw_command* cmd,
	const struct nk_buffer* buffer, const struct nk_draw_list* canvas)
{
	const struct nk_draw_command* end;
	NK_ASSERT(buffer);
	NK_ASSERT(canvas);
	if (!cmd || !buffer || !canvas)
		return 0;

	end = nk__draw_list_end(canvas, buffer);
	if (cmd <= end) return 0;
	return (cmd - 1);
}
NK_INTERN struct nk_vec2*
nk_draw_list_alloc_path(struct nk_draw_list* list, int count)
{
	struct nk_vec2* points;
	NK_STORAGE const nk_size point_align = NK_ALIGNOF(struct nk_vec2);
	NK_STORAGE const nk_size point_size = sizeof(struct nk_vec2);
	points = (struct nk_vec2*)
		nk_buffer_alloc(list->buffer, NK_BUFFER_FRONT,
			point_size * (nk_size)count, point_align);

	if (!points) return 0;
	if (!list->path_offset) {
		void* memory = nk_buffer_memory(list->buffer);
		list->path_offset = (unsigned int)((nk_byte*)points - (nk_byte*)memory);
	}
	list->path_count += (unsigned int)count;
	return points;
}
NK_INTERN struct nk_vec2
nk_draw_list_path_last(struct nk_draw_list* list)
{
	void* memory;
	struct nk_vec2* point;
	NK_ASSERT(list->path_count);
	memory = nk_buffer_memory(list->buffer);
	point = nk_ptr_add(struct nk_vec2, memory, list->path_offset);
	point += (list->path_count - 1);
	return *point;
}
NK_INTERN struct nk_draw_command*
nk_draw_list_push_command(struct nk_draw_list* list, struct nk_rect clip,
	nk_handle texture)
{
	NK_STORAGE const nk_size cmd_align = NK_ALIGNOF(struct nk_draw_command);
	NK_STORAGE const nk_size cmd_size = sizeof(struct nk_draw_command);
	struct nk_draw_command* cmd;

	NK_ASSERT(list);
	cmd = (struct nk_draw_command*)
		nk_buffer_alloc(list->buffer, NK_BUFFER_BACK, cmd_size, cmd_align);

	if (!cmd) return 0;
	if (!list->cmd_count) {
		nk_byte* memory = (nk_byte*)nk_buffer_memory(list->buffer);
		nk_size total = nk_buffer_total(list->buffer);
		memory = nk_ptr_add(nk_byte, memory, total);
		list->cmd_offset = (nk_size)(memory - (nk_byte*)cmd);
	}

	cmd->elem_count = 0;
	cmd->clip_rect = clip;
	cmd->texture = texture;
#ifdef NK_INCLUDE_COMMAND_USERDATA
	cmd->userdata = list->userdata;
#endif

	list->cmd_count++;
	list->clip_rect = clip;
	return cmd;
}
NK_INTERN struct nk_draw_command*
nk_draw_list_command_last(struct nk_draw_list* list)
{
	void* memory;
	nk_size size;
	struct nk_draw_command* cmd;
	NK_ASSERT(list->cmd_count);

	memory = nk_buffer_memory(list->buffer);
	size = nk_buffer_total(list->buffer);
	cmd = nk_ptr_add(struct nk_draw_command, memory, size - list->cmd_offset);
	return (cmd - (list->cmd_count - 1));
}
NK_INTERN void
nk_draw_list_add_clip(struct nk_draw_list* list, struct nk_rect rect)
{
	NK_ASSERT(list);
	if (!list) return;
	if (!list->cmd_count) {
		nk_draw_list_push_command(list, rect, list->config.null.texture);
	}
	else {
		struct nk_draw_command* prev = nk_draw_list_command_last(list);
		if (prev->elem_count == 0)
			prev->clip_rect = rect;
		nk_draw_list_push_command(list, rect, prev->texture);
	}
}
NK_INTERN void
nk_draw_list_push_image(struct nk_draw_list* list, nk_handle texture)
{
	NK_ASSERT(list);
	if (!list) return;
	if (!list->cmd_count) {
		nk_draw_list_push_command(list, nk_null_rect, texture);
	}
	else {
		struct nk_draw_command* prev = nk_draw_list_command_last(list);
		if (prev->elem_count == 0) {
			prev->texture = texture;
#ifdef NK_INCLUDE_COMMAND_USERDATA
			prev->userdata = list->userdata;
#endif
		}
		else if (prev->texture.id != texture.id
#ifdef NK_INCLUDE_COMMAND_USERDATA
			|| prev->userdata.id != list->userdata.id
#endif
			) nk_draw_list_push_command(list, prev->clip_rect, texture);
	}
}
#ifdef NK_INCLUDE_COMMAND_USERDATA
NK_API void
nk_draw_list_push_userdata(struct nk_draw_list* list, nk_handle userdata)
{
	list->userdata = userdata;
}
#endif
NK_INTERN void*
nk_draw_list_alloc_vertices(struct nk_draw_list* list, nk_size count)
{
	void* vtx;
	NK_ASSERT(list);
	if (!list) return 0;
	vtx = nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT,
		list->config.vertex_size * count, list->config.vertex_alignment);
	if (!vtx) return 0;
	list->vertex_count += (unsigned int)count;

	/* This assert triggers because your are drawing a lot of stuff and nuklear
	 * defined `nk_draw_index` as `nk_ushort` to safe space be default.
	 *
	 * So you reached the maximum number of indicies or rather vertexes.
	 * To solve this issue please change typdef `nk_draw_index` to `nk_uint`
	 * and don't forget to specify the new element size in your drawing
	 * backend (OpenGL, DirectX, ...). For example in OpenGL for `glDrawElements`
	 * instead of specifing `GL_UNSIGNED_SHORT` you have to define `GL_UNSIGNED_INT`.
	 * Sorry for the inconvenience. */
	if (sizeof(nk_draw_index) == 2) NK_ASSERT((list->vertex_count < NK_USHORT_MAX &&
		"To many verticies for 16-bit vertex indicies. Please read comment above on how to solve this problem"));
	return vtx;
}
NK_INTERN nk_draw_index*
nk_draw_list_alloc_elements(struct nk_draw_list* list, nk_size count)
{
	nk_draw_index* ids;
	struct nk_draw_command* cmd;
	NK_STORAGE const nk_size elem_align = NK_ALIGNOF(nk_draw_index);
	NK_STORAGE const nk_size elem_size = sizeof(nk_draw_index);
	NK_ASSERT(list);
	if (!list) return 0;

	ids = (nk_draw_index*)
		nk_buffer_alloc(list->elements, NK_BUFFER_FRONT, elem_size * count, elem_align);
	if (!ids) return 0;
	cmd = nk_draw_list_command_last(list);
	list->element_count += (unsigned int)count;
	cmd->elem_count += (unsigned int)count;
	return ids;
}
NK_INTERN int
nk_draw_vertex_layout_element_is_end_of_layout(
	const struct nk_draw_vertex_layout_element* element)
{
	return (element->attribute == NK_VERTEX_ATTRIBUTE_COUNT ||
		element->format == NK_FORMAT_COUNT);
}
NK_INTERN void
nk_draw_vertex_color(void* attr, const float* vals,
	enum nk_draw_vertex_layout_format format)
{
	/* if this triggers you tried to provide a value format for a color */
	float val[4];
	NK_ASSERT(format >= NK_FORMAT_COLOR_BEGIN);
	NK_ASSERT(format <= NK_FORMAT_COLOR_END);
	if (format < NK_FORMAT_COLOR_BEGIN || format > NK_FORMAT_COLOR_END) return;

	val[0] = NK_SATURATE(vals[0]);
	val[1] = NK_SATURATE(vals[1]);
	val[2] = NK_SATURATE(vals[2]);
	val[3] = NK_SATURATE(vals[3]);

	switch (format) {
	default: NK_ASSERT(0 && "Invalid vertex layout color format"); break;
	case NK_FORMAT_R8G8B8A8:
	case NK_FORMAT_R8G8B8: {
		struct nk_color col = nk_rgba_fv(val);
		NK_MEMCPY(attr, &col.r, sizeof(col));
	} break;
	case NK_FORMAT_B8G8R8A8: {
		struct nk_color col = nk_rgba_fv(val);
		struct nk_color bgra = nk_rgba(col.b, col.g, col.r, col.a);
		NK_MEMCPY(attr, &bgra, sizeof(bgra));
	} break;
	case NK_FORMAT_R16G15B16: {
		nk_ushort col[3];
		col[0] = (nk_ushort)(val[0] * (float)NK_USHORT_MAX);
		col[1] = (nk_ushort)(val[1] * (float)NK_USHORT_MAX);
		col[2] = (nk_ushort)(val[2] * (float)NK_USHORT_MAX);
		NK_MEMCPY(attr, col, sizeof(col));
	} break;
	case NK_FORMAT_R16G15B16A16: {
		nk_ushort col[4];
		col[0] = (nk_ushort)(val[0] * (float)NK_USHORT_MAX);
		col[1] = (nk_ushort)(val[1] * (float)NK_USHORT_MAX);
		col[2] = (nk_ushort)(val[2] * (float)NK_USHORT_MAX);
		col[3] = (nk_ushort)(val[3] * (float)NK_USHORT_MAX);
		NK_MEMCPY(attr, col, sizeof(col));
	} break;
	case NK_FORMAT_R32G32B32: {
		nk_uint col[3];
		col[0] = (nk_uint)(val[0] * (float)NK_UINT_MAX);
		col[1] = (nk_uint)(val[1] * (float)NK_UINT_MAX);
		col[2] = (nk_uint)(val[2] * (float)NK_UINT_MAX);
		NK_MEMCPY(attr, col, sizeof(col));
	} break;
	case NK_FORMAT_R32G32B32A32: {
		nk_uint col[4];
		col[0] = (nk_uint)(val[0] * (float)NK_UINT_MAX);
		col[1] = (nk_uint)(val[1] * (float)NK_UINT_MAX);
		col[2] = (nk_uint)(val[2] * (float)NK_UINT_MAX);
		col[3] = (nk_uint)(val[3] * (float)NK_UINT_MAX);
		NK_MEMCPY(attr, col, sizeof(col));
	} break;
	case NK_FORMAT_R32G32B32A32_FLOAT:
		NK_MEMCPY(attr, val, sizeof(float) * 4);
		break;
	case NK_FORMAT_R32G32B32A32_DOUBLE: {
		double col[4];
		col[0] = (double)val[0];
		col[1] = (double)val[1];
		col[2] = (double)val[2];
		col[3] = (double)val[3];
		NK_MEMCPY(attr, col, sizeof(col));
	} break;
	case NK_FORMAT_RGB32:
	case NK_FORMAT_RGBA32: {
		struct nk_color col = nk_rgba_fv(val);
		nk_uint color = nk_color_u32(col);
		NK_MEMCPY(attr, &color, sizeof(color));
	} break;
	}
}
NK_INTERN void
nk_draw_vertex_element(void* dst, const float* values, int value_count,
	enum nk_draw_vertex_layout_format format)
{
	int value_index;
	void* attribute = dst;
	/* if this triggers you tried to provide a color format for a value */
	NK_ASSERT(format < NK_FORMAT_COLOR_BEGIN);
	if (format >= NK_FORMAT_COLOR_BEGIN && format <= NK_FORMAT_COLOR_END) return;
	for (value_index = 0; value_index < value_count; ++value_index) {
		switch (format) {
		default: NK_ASSERT(0 && "invalid vertex layout format"); break;
		case NK_FORMAT_SCHAR: {
			char value = (char)NK_CLAMP((float)NK_SCHAR_MIN, values[value_index], (float)NK_SCHAR_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(char));
		} break;
		case NK_FORMAT_SSHORT: {
			nk_short value = (nk_short)NK_CLAMP((float)NK_SSHORT_MIN, values[value_index], (float)NK_SSHORT_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(value));
		} break;
		case NK_FORMAT_SINT: {
			nk_int value = (nk_int)NK_CLAMP((float)NK_SINT_MIN, values[value_index], (float)NK_SINT_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(nk_int));
		} break;
		case NK_FORMAT_UCHAR: {
			unsigned char value = (unsigned char)NK_CLAMP((float)NK_UCHAR_MIN, values[value_index], (float)NK_UCHAR_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(unsigned char));
		} break;
		case NK_FORMAT_USHORT: {
			nk_ushort value = (nk_ushort)NK_CLAMP((float)NK_USHORT_MIN, values[value_index], (float)NK_USHORT_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(value));
		} break;
		case NK_FORMAT_UINT: {
			nk_uint value = (nk_uint)NK_CLAMP((float)NK_UINT_MIN, values[value_index], (float)NK_UINT_MAX);
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(nk_uint));
		} break;
		case NK_FORMAT_FLOAT:
			NK_MEMCPY(attribute, &values[value_index], sizeof(values[value_index]));
			attribute = (void*)((char*)attribute + sizeof(float));
			break;
		case NK_FORMAT_DOUBLE: {
			double value = (double)values[value_index];
			NK_MEMCPY(attribute, &value, sizeof(value));
			attribute = (void*)((char*)attribute + sizeof(double));
		} break;
		}
	}
}
NK_INTERN void*
nk_draw_vertex(void* dst, const struct nk_convert_config* config,
	struct nk_vec2 pos, struct nk_vec2 uv, struct nk_colorf color)
{
	void* result = (void*)((char*)dst + config->vertex_size);
	const struct nk_draw_vertex_layout_element* elem_iter = config->vertex_layout;
	while (!nk_draw_vertex_layout_element_is_end_of_layout(elem_iter)) {
		void* address = (void*)((char*)dst + elem_iter->offset);
		switch (elem_iter->attribute) {
		case NK_VERTEX_ATTRIBUTE_COUNT:
		default: NK_ASSERT(0 && "wrong element attribute"); break;
		case NK_VERTEX_POSITION: nk_draw_vertex_element(address, &pos.x, 2, elem_iter->format); break;
		case NK_VERTEX_TEXCOORD: nk_draw_vertex_element(address, &uv.x, 2, elem_iter->format); break;
		case NK_VERTEX_COLOR: nk_draw_vertex_color(address, &color.r, elem_iter->format); break;
		}
		elem_iter++;
	}
	return result;
}
NK_API void
nk_draw_list_stroke_poly_line(struct nk_draw_list* list, const struct nk_vec2* points,
	const unsigned int points_count, struct nk_color color, enum nk_draw_list_stroke closed,
	float thickness, enum nk_anti_aliasing aliasing)
{
	nk_size count;
	int thick_line;
	struct nk_colorf col;
	struct nk_colorf col_trans;
	NK_ASSERT(list);
	if (!list || points_count < 2) return;

	color.a = (nk_byte)((float)color.a * list->config.global_alpha);
	count = points_count;
	if (!closed) count = points_count - 1;
	thick_line = thickness > 1.0f;

#ifdef NK_INCLUDE_COMMAND_USERDATA
	nk_draw_list_push_userdata(list, list->userdata);
#endif

	color.a = (nk_byte)((float)color.a * list->config.global_alpha);
	nk_color_fv(&col.r, color);
	col_trans = col;
	col_trans.a = 0;

	if (aliasing == NK_ANTI_ALIASING_ON) {
		/* ANTI-ALIASED STROKE */
		const float AA_SIZE = 1.0f;
		NK_STORAGE const nk_size pnt_align = NK_ALIGNOF(struct nk_vec2);
		NK_STORAGE const nk_size pnt_size = sizeof(struct nk_vec2);

		/* allocate vertices and elements  */
		nk_size i1 = 0;
		nk_size vertex_offset;
		nk_size index = list->vertex_count;

		const nk_size idx_count = (thick_line) ? (count * 18) : (count * 12);
		const nk_size vtx_count = (thick_line) ? (points_count * 4) : (points_count * 3);

		void* vtx = nk_draw_list_alloc_vertices(list, vtx_count);
		nk_draw_index* ids = nk_draw_list_alloc_elements(list, idx_count);

		nk_size size;
		struct nk_vec2* normals, * temp;
		if (!vtx || !ids) return;

		/* temporary allocate normals + points */
		vertex_offset = (nk_size)((nk_byte*)vtx - (nk_byte*)list->vertices->memory.ptr);
		nk_buffer_mark(list->vertices, NK_BUFFER_FRONT);
		size = pnt_size * ((thick_line) ? 5 : 3) * points_count;
		normals = (struct nk_vec2*) nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT, size, pnt_align);
		if (!normals) return;
		temp = normals + points_count;

		/* make sure vertex pointer is still correct */
		vtx = (void*)((nk_byte*)list->vertices->memory.ptr + vertex_offset);

		/* calculate normals */
		for (i1 = 0; i1 < count; ++i1) {
			const nk_size i2 = ((i1 + 1) == points_count) ? 0 : (i1 + 1);
			struct nk_vec2 diff = nk_vec2_sub(points[i2], points[i1]);
			float len;

			/* vec2 inverted length  */
			len = nk_vec2_len_sqr(diff);
			if (len != 0.0f)
				len = nk_inv_sqrt(len);
			else len = 1.0f;

			diff = nk_vec2_muls(diff, len);
			normals[i1].x = diff.y;
			normals[i1].y = -diff.x;
		}

		if (!closed)
			normals[points_count - 1] = normals[points_count - 2];

		if (!thick_line) {
			nk_size idx1, i;
			if (!closed) {
				struct nk_vec2 d;
				temp[0] = nk_vec2_add(points[0], nk_vec2_muls(normals[0], AA_SIZE));
				temp[1] = nk_vec2_sub(points[0], nk_vec2_muls(normals[0], AA_SIZE));
				d = nk_vec2_muls(normals[points_count - 1], AA_SIZE);
				temp[(points_count - 1) * 2 + 0] = nk_vec2_add(points[points_count - 1], d);
				temp[(points_count - 1) * 2 + 1] = nk_vec2_sub(points[points_count - 1], d);
			}

			/* fill elements */
			idx1 = index;
			for (i1 = 0; i1 < count; i1++) {
				struct nk_vec2 dm;
				float dmr2;
				nk_size i2 = ((i1 + 1) == points_count) ? 0 : (i1 + 1);
				nk_size idx2 = ((i1 + 1) == points_count) ? index : (idx1 + 3);

				/* average normals */
				dm = nk_vec2_muls(nk_vec2_add(normals[i1], normals[i2]), 0.5f);
				dmr2 = dm.x * dm.x + dm.y * dm.y;
				if (dmr2 > 0.000001f) {
					float scale = 1.0f / dmr2;
					scale = NK_MIN(100.0f, scale);
					dm = nk_vec2_muls(dm, scale);
				}

				dm = nk_vec2_muls(dm, AA_SIZE);
				temp[i2 * 2 + 0] = nk_vec2_add(points[i2], dm);
				temp[i2 * 2 + 1] = nk_vec2_sub(points[i2], dm);

				ids[0] = (nk_draw_index)(idx2 + 0); ids[1] = (nk_draw_index)(idx1 + 0);
				ids[2] = (nk_draw_index)(idx1 + 2); ids[3] = (nk_draw_index)(idx1 + 2);
				ids[4] = (nk_draw_index)(idx2 + 2); ids[5] = (nk_draw_index)(idx2 + 0);
				ids[6] = (nk_draw_index)(idx2 + 1); ids[7] = (nk_draw_index)(idx1 + 1);
				ids[8] = (nk_draw_index)(idx1 + 0); ids[9] = (nk_draw_index)(idx1 + 0);
				ids[10] = (nk_draw_index)(idx2 + 0); ids[11] = (nk_draw_index)(idx2 + 1);
				ids += 12;
				idx1 = idx2;
			}

			/* fill vertices */
			for (i = 0; i < points_count; ++i) {
				const struct nk_vec2 uv = list->config.null.uv;
				vtx = nk_draw_vertex(vtx, &list->config, points[i], uv, col);
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 2 + 0], uv, col_trans);
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 2 + 1], uv, col_trans);
			}
		}
		else {
			nk_size idx1, i;
			const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
			if (!closed) {
				struct nk_vec2 d1 = nk_vec2_muls(normals[0], half_inner_thickness + AA_SIZE);
				struct nk_vec2 d2 = nk_vec2_muls(normals[0], half_inner_thickness);

				temp[0] = nk_vec2_add(points[0], d1);
				temp[1] = nk_vec2_add(points[0], d2);
				temp[2] = nk_vec2_sub(points[0], d2);
				temp[3] = nk_vec2_sub(points[0], d1);

				d1 = nk_vec2_muls(normals[points_count - 1], half_inner_thickness + AA_SIZE);
				d2 = nk_vec2_muls(normals[points_count - 1], half_inner_thickness);

				temp[(points_count - 1) * 4 + 0] = nk_vec2_add(points[points_count - 1], d1);
				temp[(points_count - 1) * 4 + 1] = nk_vec2_add(points[points_count - 1], d2);
				temp[(points_count - 1) * 4 + 2] = nk_vec2_sub(points[points_count - 1], d2);
				temp[(points_count - 1) * 4 + 3] = nk_vec2_sub(points[points_count - 1], d1);
			}

			/* add all elements */
			idx1 = index;
			for (i1 = 0; i1 < count; ++i1) {
				struct nk_vec2 dm_out, dm_in;
				const nk_size i2 = ((i1 + 1) == points_count) ? 0 : (i1 + 1);
				nk_size idx2 = ((i1 + 1) == points_count) ? index : (idx1 + 4);

				/* average normals */
				struct nk_vec2 dm = nk_vec2_muls(nk_vec2_add(normals[i1], normals[i2]), 0.5f);
				float dmr2 = dm.x * dm.x + dm.y * dm.y;
				if (dmr2 > 0.000001f) {
					float scale = 1.0f / dmr2;
					scale = NK_MIN(100.0f, scale);
					dm = nk_vec2_muls(dm, scale);
				}

				dm_out = nk_vec2_muls(dm, ((half_inner_thickness)+AA_SIZE));
				dm_in = nk_vec2_muls(dm, half_inner_thickness);
				temp[i2 * 4 + 0] = nk_vec2_add(points[i2], dm_out);
				temp[i2 * 4 + 1] = nk_vec2_add(points[i2], dm_in);
				temp[i2 * 4 + 2] = nk_vec2_sub(points[i2], dm_in);
				temp[i2 * 4 + 3] = nk_vec2_sub(points[i2], dm_out);

				/* add indexes */
				ids[0] = (nk_draw_index)(idx2 + 1); ids[1] = (nk_draw_index)(idx1 + 1);
				ids[2] = (nk_draw_index)(idx1 + 2); ids[3] = (nk_draw_index)(idx1 + 2);
				ids[4] = (nk_draw_index)(idx2 + 2); ids[5] = (nk_draw_index)(idx2 + 1);
				ids[6] = (nk_draw_index)(idx2 + 1); ids[7] = (nk_draw_index)(idx1 + 1);
				ids[8] = (nk_draw_index)(idx1 + 0); ids[9] = (nk_draw_index)(idx1 + 0);
				ids[10] = (nk_draw_index)(idx2 + 0); ids[11] = (nk_draw_index)(idx2 + 1);
				ids[12] = (nk_draw_index)(idx2 + 2); ids[13] = (nk_draw_index)(idx1 + 2);
				ids[14] = (nk_draw_index)(idx1 + 3); ids[15] = (nk_draw_index)(idx1 + 3);
				ids[16] = (nk_draw_index)(idx2 + 3); ids[17] = (nk_draw_index)(idx2 + 2);
				ids += 18;
				idx1 = idx2;
			}

			/* add vertices */
			for (i = 0; i < points_count; ++i) {
				const struct nk_vec2 uv = list->config.null.uv;
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 4 + 0], uv, col_trans);
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 4 + 1], uv, col);
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 4 + 2], uv, col);
				vtx = nk_draw_vertex(vtx, &list->config, temp[i * 4 + 3], uv, col_trans);
			}
		}
		/* free temporary normals + points */
		nk_buffer_reset(list->vertices, NK_BUFFER_FRONT);
	}
	else {
		/* NON ANTI-ALIASED STROKE */
		nk_size i1 = 0;
		nk_size idx = list->vertex_count;
		const nk_size idx_count = count * 6;
		const nk_size vtx_count = count * 4;
		void* vtx = nk_draw_list_alloc_vertices(list, vtx_count);
		nk_draw_index* ids = nk_draw_list_alloc_elements(list, idx_count);
		if (!vtx || !ids) return;

		for (i1 = 0; i1 < count; ++i1) {
			float dx, dy;
			const struct nk_vec2 uv = list->config.null.uv;
			const nk_size i2 = ((i1 + 1) == points_count) ? 0 : i1 + 1;
			const struct nk_vec2 p1 = points[i1];
			const struct nk_vec2 p2 = points[i2];
			struct nk_vec2 diff = nk_vec2_sub(p2, p1);
			float len;

			/* vec2 inverted length  */
			len = nk_vec2_len_sqr(diff);
			if (len != 0.0f)
				len = nk_inv_sqrt(len);
			else len = 1.0f;
			diff = nk_vec2_muls(diff, len);

			/* add vertices */
			dx = diff.x * (thickness * 0.5f);
			dy = diff.y * (thickness * 0.5f);

			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p1.x + dy, p1.y - dx), uv, col);
			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p2.x + dy, p2.y - dx), uv, col);
			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p2.x - dy, p2.y + dx), uv, col);
			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p1.x - dy, p1.y + dx), uv, col);

			ids[0] = (nk_draw_index)(idx + 0); ids[1] = (nk_draw_index)(idx + 1);
			ids[2] = (nk_draw_index)(idx + 2); ids[3] = (nk_draw_index)(idx + 0);
			ids[4] = (nk_draw_index)(idx + 2); ids[5] = (nk_draw_index)(idx + 3);

			ids += 6;
			idx += 4;
		}
	}
}
NK_API void
nk_draw_list_fill_poly_convex(struct nk_draw_list* list,
	const struct nk_vec2* points, const unsigned int points_count,
	struct nk_color color, enum nk_anti_aliasing aliasing)
{
	struct nk_colorf col;
	struct nk_colorf col_trans;

	NK_STORAGE const nk_size pnt_align = NK_ALIGNOF(struct nk_vec2);
	NK_STORAGE const nk_size pnt_size = sizeof(struct nk_vec2);
	NK_ASSERT(list);
	if (!list || points_count < 3) return;

#ifdef NK_INCLUDE_COMMAND_USERDATA
	nk_draw_list_push_userdata(list, list->userdata);
#endif

	color.a = (nk_byte)((float)color.a * list->config.global_alpha);
	nk_color_fv(&col.r, color);
	col_trans = col;
	col_trans.a = 0;

	if (aliasing == NK_ANTI_ALIASING_ON) {
		nk_size i = 0;
		nk_size i0 = 0;
		nk_size i1 = 0;

		const float AA_SIZE = 1.0f;
		nk_size vertex_offset = 0;
		nk_size index = list->vertex_count;

		const nk_size idx_count = (points_count - 2) * 3 + points_count * 6;
		const nk_size vtx_count = (points_count * 2);

		void* vtx = nk_draw_list_alloc_vertices(list, vtx_count);
		nk_draw_index* ids = nk_draw_list_alloc_elements(list, idx_count);

		nk_size size = 0;
		struct nk_vec2* normals = 0;
		unsigned int vtx_inner_idx = (unsigned int)(index + 0);
		unsigned int vtx_outer_idx = (unsigned int)(index + 1);
		if (!vtx || !ids) return;

		/* temporary allocate normals */
		vertex_offset = (nk_size)((nk_byte*)vtx - (nk_byte*)list->vertices->memory.ptr);
		nk_buffer_mark(list->vertices, NK_BUFFER_FRONT);
		size = pnt_size * points_count;
		normals = (struct nk_vec2*) nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT, size, pnt_align);
		if (!normals) return;
		vtx = (void*)((nk_byte*)list->vertices->memory.ptr + vertex_offset);

		/* add elements */
		for (i = 2; i < points_count; i++) {
			ids[0] = (nk_draw_index)(vtx_inner_idx);
			ids[1] = (nk_draw_index)(vtx_inner_idx + ((i - 1) << 1));
			ids[2] = (nk_draw_index)(vtx_inner_idx + (i << 1));
			ids += 3;
		}

		/* compute normals */
		for (i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++) {
			struct nk_vec2 p0 = points[i0];
			struct nk_vec2 p1 = points[i1];
			struct nk_vec2 diff = nk_vec2_sub(p1, p0);

			/* vec2 inverted length  */
			float len = nk_vec2_len_sqr(diff);
			if (len != 0.0f)
				len = nk_inv_sqrt(len);
			else len = 1.0f;
			diff = nk_vec2_muls(diff, len);

			normals[i0].x = diff.y;
			normals[i0].y = -diff.x;
		}

		/* add vertices + indexes */
		for (i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++) {
			const struct nk_vec2 uv = list->config.null.uv;
			struct nk_vec2 n0 = normals[i0];
			struct nk_vec2 n1 = normals[i1];
			struct nk_vec2 dm = nk_vec2_muls(nk_vec2_add(n0, n1), 0.5f);
			float dmr2 = dm.x * dm.x + dm.y * dm.y;
			if (dmr2 > 0.000001f) {
				float scale = 1.0f / dmr2;
				scale = NK_MIN(scale, 100.0f);
				dm = nk_vec2_muls(dm, scale);
			}
			dm = nk_vec2_muls(dm, AA_SIZE * 0.5f);

			/* add vertices */
			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2_sub(points[i1], dm), uv, col);
			vtx = nk_draw_vertex(vtx, &list->config, nk_vec2_add(points[i1], dm), uv, col_trans);

			/* add indexes */
			ids[0] = (nk_draw_index)(vtx_inner_idx + (i1 << 1));
			ids[1] = (nk_draw_index)(vtx_inner_idx + (i0 << 1));
			ids[2] = (nk_draw_index)(vtx_outer_idx + (i0 << 1));
			ids[3] = (nk_draw_index)(vtx_outer_idx + (i0 << 1));
			ids[4] = (nk_draw_index)(vtx_outer_idx + (i1 << 1));
			ids[5] = (nk_draw_index)(vtx_inner_idx + (i1 << 1));
			ids += 6;
		}
		/* free temporary normals + points */
		nk_buffer_reset(list->vertices, NK_BUFFER_FRONT);
	}
	else {
		nk_size i = 0;
		nk_size index = list->vertex_count;
		const nk_size idx_count = (points_count - 2) * 3;
		const nk_size vtx_count = points_count;
		void* vtx = nk_draw_list_alloc_vertices(list, vtx_count);
		nk_draw_index* ids = nk_draw_list_alloc_elements(list, idx_count);

		if (!vtx || !ids) return;
		for (i = 0; i < vtx_count; ++i)
			vtx = nk_draw_vertex(vtx, &list->config, points[i], list->config.null.uv, col);
		for (i = 2; i < points_count; ++i) {
			ids[0] = (nk_draw_index)index;
			ids[1] = (nk_draw_index)(index + i - 1);
			ids[2] = (nk_draw_index)(index + i);
			ids += 3;
		}
	}
}
NK_API void
nk_draw_list_path_clear(struct nk_draw_list* list)
{
	NK_ASSERT(list);
	if (!list) return;
	nk_buffer_reset(list->buffer, NK_BUFFER_FRONT);
	list->path_count = 0;
	list->path_offset = 0;
}
NK_API void
nk_draw_list_path_line_to(struct nk_draw_list* list, struct nk_vec2 pos)
{
	struct nk_vec2* points = 0;
	struct nk_draw_command* cmd = 0;
	NK_ASSERT(list);
	if (!list) return;
	if (!list->cmd_count)
		nk_draw_list_add_clip(list, nk_null_rect);

	cmd = nk_draw_list_command_last(list);
	if (cmd && cmd->texture.ptr != list->config.null.texture.ptr)
		nk_draw_list_push_image(list, list->config.null.texture);

	points = nk_draw_list_alloc_path(list, 1);
	if (!points) return;
	points[0] = pos;
}
NK_API void
nk_draw_list_path_arc_to_fast(struct nk_draw_list* list, struct nk_vec2 center,
	float radius, int a_min, int a_max)
{
	int a = 0;
	NK_ASSERT(list);
	if (!list) return;
	if (a_min <= a_max) {
		for (a = a_min; a <= a_max; a++) {
			const struct nk_vec2 c = list->circle_vtx[(nk_size)a % NK_LEN(list->circle_vtx)];
			const float x = center.x + c.x * radius;
			const float y = center.y + c.y * radius;
			nk_draw_list_path_line_to(list, nk_vec2(x, y));
		}
	}
}
NK_API void
nk_draw_list_path_arc_to(struct nk_draw_list* list, struct nk_vec2 center,
	float radius, float a_min, float a_max, unsigned int segments)
{
	unsigned int i = 0;
	NK_ASSERT(list);
	if (!list) return;
	if (radius == 0.0f) return;

	/*  This algorithm for arc drawing relies on these two trigonometric identities[1]:
			sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)
			cos(a + b) = cos(a) * cos(b) - sin(a) * sin(b)

		Two coordinates (x, y) of a point on a circle centered on
		the origin can be written in polar form as:
			x = r * cos(a)
			y = r * sin(a)
		where r is the radius of the circle,
			a is the angle between (x, y) and the origin.

		This allows us to rotate the coordinates around the
		origin by an angle b using the following transformation:
			x' = r * cos(a + b) = x * cos(b) - y * sin(b)
			y' = r * sin(a + b) = y * cos(b) + x * sin(b)

		[1] https://en.wikipedia.org/wiki/List_of_trigonometric_identities#Angle_sum_and_difference_identities
	*/
	{const float d_angle = (a_max - a_min) / (float)segments;
	const float sin_d = (float)NK_SIN(d_angle);
	const float cos_d = (float)NK_COS(d_angle);

	float cx = (float)NK_COS(a_min) * radius;
	float cy = (float)NK_SIN(a_min) * radius;
	for (i = 0; i <= segments; ++i) {
		float new_cx, new_cy;
		const float x = center.x + cx;
		const float y = center.y + cy;
		nk_draw_list_path_line_to(list, nk_vec2(x, y));

		new_cx = cx * cos_d - cy * sin_d;
		new_cy = cy * cos_d + cx * sin_d;
		cx = new_cx;
		cy = new_cy;
	}}
}
NK_API void
nk_draw_list_path_rect_to(struct nk_draw_list* list, struct nk_vec2 a,
	struct nk_vec2 b, float rounding)
{
	float r;
	NK_ASSERT(list);
	if (!list) return;
	r = rounding;
	r = NK_MIN(r, ((b.x - a.x) < 0) ? -(b.x - a.x) : (b.x - a.x));
	r = NK_MIN(r, ((b.y - a.y) < 0) ? -(b.y - a.y) : (b.y - a.y));

	if (r == 0.0f) {
		nk_draw_list_path_line_to(list, a);
		nk_draw_list_path_line_to(list, nk_vec2(b.x, a.y));
		nk_draw_list_path_line_to(list, b);
		nk_draw_list_path_line_to(list, nk_vec2(a.x, b.y));
	}
	else {
		nk_draw_list_path_arc_to_fast(list, nk_vec2(a.x + r, a.y + r), r, 6, 9);
		nk_draw_list_path_arc_to_fast(list, nk_vec2(b.x - r, a.y + r), r, 9, 12);
		nk_draw_list_path_arc_to_fast(list, nk_vec2(b.x - r, b.y - r), r, 0, 3);
		nk_draw_list_path_arc_to_fast(list, nk_vec2(a.x + r, b.y - r), r, 3, 6);
	}
}
NK_API void
nk_draw_list_path_curve_to(struct nk_draw_list* list, struct nk_vec2 p2,
	struct nk_vec2 p3, struct nk_vec2 p4, unsigned int num_segments)
{
	float t_step;
	unsigned int i_step;
	struct nk_vec2 p1;

	NK_ASSERT(list);
	NK_ASSERT(list->path_count);
	if (!list || !list->path_count) return;
	num_segments = NK_MAX(num_segments, 1);

	p1 = nk_draw_list_path_last(list);
	t_step = 1.0f / (float)num_segments;
	for (i_step = 1; i_step <= num_segments; ++i_step) {
		float t = t_step * (float)i_step;
		float u = 1.0f - t;
		float w1 = u * u * u;
		float w2 = 3 * u * u * t;
		float w3 = 3 * u * t * t;
		float w4 = t * t * t;
		float x = w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x;
		float y = w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y;
		nk_draw_list_path_line_to(list, nk_vec2(x, y));
	}
}
NK_API void
nk_draw_list_path_fill(struct nk_draw_list* list, struct nk_color color)
{
	struct nk_vec2* points;
	NK_ASSERT(list);
	if (!list) return;
	points = (struct nk_vec2*)nk_buffer_memory(list->buffer);
	nk_draw_list_fill_poly_convex(list, points, list->path_count, color, list->config.shape_AA);
	nk_draw_list_path_clear(list);
}
NK_API void
nk_draw_list_path_stroke(struct nk_draw_list* list, struct nk_color color,
	enum nk_draw_list_stroke closed, float thickness)
{
	struct nk_vec2* points;
	NK_ASSERT(list);
	if (!list) return;
	points = (struct nk_vec2*)nk_buffer_memory(list->buffer);
	nk_draw_list_stroke_poly_line(list, points, list->path_count, color,
		closed, thickness, list->config.line_AA);
	nk_draw_list_path_clear(list);
}
NK_API void
nk_draw_list_stroke_line(struct nk_draw_list* list, struct nk_vec2 a,
	struct nk_vec2 b, struct nk_color col, float thickness)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;
	if (list->line_AA == NK_ANTI_ALIASING_ON) {
		nk_draw_list_path_line_to(list, a);
		nk_draw_list_path_line_to(list, b);
	}
	else {
		nk_draw_list_path_line_to(list, nk_vec2_sub(a, nk_vec2(0.5f, 0.5f)));
		nk_draw_list_path_line_to(list, nk_vec2_sub(b, nk_vec2(0.5f, 0.5f)));
	}
	nk_draw_list_path_stroke(list, col, NK_STROKE_OPEN, thickness);
}
NK_API void
nk_draw_list_fill_rect(struct nk_draw_list* list, struct nk_rect rect,
	struct nk_color col, float rounding)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;

	if (list->line_AA == NK_ANTI_ALIASING_ON) {
		nk_draw_list_path_rect_to(list, nk_vec2(rect.x, rect.y),
			nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);
	}
	else {
		nk_draw_list_path_rect_to(list, nk_vec2(rect.x - 0.5f, rect.y - 0.5f),
			nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);
	} nk_draw_list_path_fill(list, col);
}
NK_API void
nk_draw_list_stroke_rect(struct nk_draw_list* list, struct nk_rect rect,
	struct nk_color col, float rounding, float thickness)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;
	if (list->line_AA == NK_ANTI_ALIASING_ON) {
		nk_draw_list_path_rect_to(list, nk_vec2(rect.x, rect.y),
			nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);
	}
	else {
		nk_draw_list_path_rect_to(list, nk_vec2(rect.x - 0.5f, rect.y - 0.5f),
			nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);
	} nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
}
NK_API void
nk_draw_list_fill_rect_multi_color(struct nk_draw_list* list, struct nk_rect rect,
	struct nk_color left, struct nk_color top, struct nk_color right,
	struct nk_color bottom)
{
	void* vtx;
	struct nk_colorf col_left, col_top;
	struct nk_colorf col_right, col_bottom;
	nk_draw_index* idx;
	nk_draw_index index;

	nk_color_fv(&col_left.r, left);
	nk_color_fv(&col_right.r, right);
	nk_color_fv(&col_top.r, top);
	nk_color_fv(&col_bottom.r, bottom);

	NK_ASSERT(list);
	if (!list) return;

	nk_draw_list_push_image(list, list->config.null.texture);
	index = (nk_draw_index)list->vertex_count;
	vtx = nk_draw_list_alloc_vertices(list, 4);
	idx = nk_draw_list_alloc_elements(list, 6);
	if (!vtx || !idx) return;

	idx[0] = (nk_draw_index)(index + 0); idx[1] = (nk_draw_index)(index + 1);
	idx[2] = (nk_draw_index)(index + 2); idx[3] = (nk_draw_index)(index + 0);
	idx[4] = (nk_draw_index)(index + 2); idx[5] = (nk_draw_index)(index + 3);

	vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x, rect.y), list->config.null.uv, col_left);
	vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x + rect.w, rect.y), list->config.null.uv, col_top);
	vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x + rect.w, rect.y + rect.h), list->config.null.uv, col_right);
	vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x, rect.y + rect.h), list->config.null.uv, col_bottom);
}
NK_API void
nk_draw_list_fill_triangle(struct nk_draw_list* list, struct nk_vec2 a,
	struct nk_vec2 b, struct nk_vec2 c, struct nk_color col)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;
	nk_draw_list_path_line_to(list, a);
	nk_draw_list_path_line_to(list, b);
	nk_draw_list_path_line_to(list, c);
	nk_draw_list_path_fill(list, col);
}
NK_API void
nk_draw_list_stroke_triangle(struct nk_draw_list* list, struct nk_vec2 a,
	struct nk_vec2 b, struct nk_vec2 c, struct nk_color col, float thickness)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;
	nk_draw_list_path_line_to(list, a);
	nk_draw_list_path_line_to(list, b);
	nk_draw_list_path_line_to(list, c);
	nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
}
NK_API void
nk_draw_list_fill_circle(struct nk_draw_list* list, struct nk_vec2 center,
	float radius, struct nk_color col, unsigned int segs)
{
	float a_max;
	NK_ASSERT(list);
	if (!list || !col.a) return;
	a_max = NK_PI * 2.0f * ((float)segs - 1.0f) / (float)segs;
	nk_draw_list_path_arc_to(list, center, radius, 0.0f, a_max, segs);
	nk_draw_list_path_fill(list, col);
}
NK_API void
nk_draw_list_stroke_circle(struct nk_draw_list* list, struct nk_vec2 center,
	float radius, struct nk_color col, unsigned int segs, float thickness)
{
	float a_max;
	NK_ASSERT(list);
	if (!list || !col.a) return;
	a_max = NK_PI * 2.0f * ((float)segs - 1.0f) / (float)segs;
	nk_draw_list_path_arc_to(list, center, radius, 0.0f, a_max, segs);
	nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);
}
NK_API void
nk_draw_list_stroke_curve(struct nk_draw_list* list, struct nk_vec2 p0,
	struct nk_vec2 cp0, struct nk_vec2 cp1, struct nk_vec2 p1,
	struct nk_color col, unsigned int segments, float thickness)
{
	NK_ASSERT(list);
	if (!list || !col.a) return;
	nk_draw_list_path_line_to(list, p0);
	nk_draw_list_path_curve_to(list, cp0, cp1, p1, segments);
	nk_draw_list_path_stroke(list, col, NK_STROKE_OPEN, thickness);
}
NK_INTERN void
nk_draw_list_push_rect_uv(struct nk_draw_list* list, struct nk_vec2 a,
	struct nk_vec2 c, struct nk_vec2 uva, struct nk_vec2 uvc,
	struct nk_color color)
{
	void* vtx;
	struct nk_vec2 uvb;
	struct nk_vec2 uvd;
	struct nk_vec2 b;
	struct nk_vec2 d;

	struct nk_colorf col;
	nk_draw_index* idx;
	nk_draw_index index;
	NK_ASSERT(list);
	if (!list) return;

	nk_color_fv(&col.r, color);
	uvb = nk_vec2(uvc.x, uva.y);
	uvd = nk_vec2(uva.x, uvc.y);
	b = nk_vec2(c.x, a.y);
	d = nk_vec2(a.x, c.y);

	index = (nk_draw_index)list->vertex_count;
	vtx = nk_draw_list_alloc_vertices(list, 4);
	idx = nk_draw_list_alloc_elements(list, 6);
	if (!vtx || !idx) return;

	idx[0] = (nk_draw_index)(index + 0); idx[1] = (nk_draw_index)(index + 1);
	idx[2] = (nk_draw_index)(index + 2); idx[3] = (nk_draw_index)(index + 0);
	idx[4] = (nk_draw_index)(index + 2); idx[5] = (nk_draw_index)(index + 3);

	vtx = nk_draw_vertex(vtx, &list->config, a, uva, col);
	vtx = nk_draw_vertex(vtx, &list->config, b, uvb, col);
	vtx = nk_draw_vertex(vtx, &list->config, c, uvc, col);
	vtx = nk_draw_vertex(vtx, &list->config, d, uvd, col);
}
NK_API void
nk_draw_list_add_image(struct nk_draw_list* list, struct nk_image texture,
	struct nk_rect rect, struct nk_color color)
{
	NK_ASSERT(list);
	if (!list) return;
	/* push new command with given texture */
	nk_draw_list_push_image(list, texture.handle);
	if (nk_image_is_subimage(&texture)) {
		/* add region inside of the texture  */
		struct nk_vec2 uv[2];
		uv[0].x = (float)texture.region[0] / (float)texture.w;
		uv[0].y = (float)texture.region[1] / (float)texture.h;
		uv[1].x = (float)(texture.region[0] + texture.region[2]) / (float)texture.w;
		uv[1].y = (float)(texture.region[1] + texture.region[3]) / (float)texture.h;
		nk_draw_list_push_rect_uv(list, nk_vec2(rect.x, rect.y),
			nk_vec2(rect.x + rect.w, rect.y + rect.h), uv[0], uv[1], color);
	}
	else nk_draw_list_push_rect_uv(list, nk_vec2(rect.x, rect.y),
		nk_vec2(rect.x + rect.w, rect.y + rect.h),
		nk_vec2(0.0f, 0.0f), nk_vec2(1.0f, 1.0f), color);
}
NK_API void
nk_draw_list_add_text(struct nk_draw_list* list, const struct nk_user_font* font,
	struct nk_rect rect, const char* text, int len, float font_height,
	struct nk_color fg)
{
	float x = 0;
	int text_len = 0;
	nk_rune unicode = 0;
	nk_rune next = 0;
	int glyph_len = 0;
	int next_glyph_len = 0;
	struct nk_user_font_glyph g;

	NK_ASSERT(list);
	if (!list || !len || !text) return;
	if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h,
		list->clip_rect.x, list->clip_rect.y, list->clip_rect.w, list->clip_rect.h)) return;

	nk_draw_list_push_image(list, font->texture);
	x = rect.x;
	glyph_len = nk_utf_decode(text, &unicode, len);
	if (!glyph_len) return;

	/* draw every glyph image */
	fg.a = (nk_byte)((float)fg.a * list->config.global_alpha);
	while (text_len < len && glyph_len) {
		float gx, gy, gh, gw;
		float char_width = 0;
		if (unicode == NK_UTF_INVALID) break;

		/* query currently drawn glyph information */
		next_glyph_len = nk_utf_decode(text + text_len + glyph_len, &next, (int)len - text_len);
		font->query(font->userdata, font_height, &g, unicode,
			(next == NK_UTF_INVALID) ? '\0' : next);

		/* calculate and draw glyph drawing rectangle and image */
		gx = x + g.offset.x;
		gy = rect.y + g.offset.y;
		gw = g.width; gh = g.height;
		char_width = g.xadvance;
		nk_draw_list_push_rect_uv(list, nk_vec2(gx, gy), nk_vec2(gx + gw, gy + gh),
			g.uv[0], g.uv[1], fg);

		/* offset next glyph */
		text_len += glyph_len;
		x += char_width;
		glyph_len = next_glyph_len;
		unicode = next;
	}
}
NK_API nk_flags
nk_convert(struct nk_context* ctx, struct nk_buffer* cmds,
	struct nk_buffer* vertices, struct nk_buffer* elements,
	const struct nk_convert_config* config)
{
	nk_flags res = NK_CONVERT_SUCCESS;
	const struct nk_command* cmd;
	NK_ASSERT(ctx);
	NK_ASSERT(cmds);
	NK_ASSERT(vertices);
	NK_ASSERT(elements);
	NK_ASSERT(config);
	NK_ASSERT(config->vertex_layout);
	NK_ASSERT(config->vertex_size);
	if (!ctx || !cmds || !vertices || !elements || !config || !config->vertex_layout)
		return NK_CONVERT_INVALID_PARAM;

	nk_draw_list_setup(&ctx->draw_list, config, cmds, vertices, elements,
		config->line_AA, config->shape_AA);
	nk_foreach(cmd, ctx)
	{
#ifdef NK_INCLUDE_COMMAND_USERDATA
		ctx->draw_list.userdata = cmd->userdata;
#endif
		switch (cmd->type) {
		case NK_COMMAND_NOP: break;
		case NK_COMMAND_SCISSOR: {
			const struct nk_command_scissor* s = (const struct nk_command_scissor*)cmd;
			nk_draw_list_add_clip(&ctx->draw_list, nk_rect(s->x, s->y, s->w, s->h));
		} break;
		case NK_COMMAND_LINE: {
			const struct nk_command_line* l = (const struct nk_command_line*)cmd;
			nk_draw_list_stroke_line(&ctx->draw_list, nk_vec2(l->begin.x, l->begin.y),
				nk_vec2(l->end.x, l->end.y), l->color, l->line_thickness);
		} break;
		case NK_COMMAND_CURVE: {
			const struct nk_command_curve* q = (const struct nk_command_curve*)cmd;
			nk_draw_list_stroke_curve(&ctx->draw_list, nk_vec2(q->begin.x, q->begin.y),
				nk_vec2(q->ctrl[0].x, q->ctrl[0].y), nk_vec2(q->ctrl[1].x,
					q->ctrl[1].y), nk_vec2(q->end.x, q->end.y), q->color,
				config->curve_segment_count, q->line_thickness);
		} break;
		case NK_COMMAND_RECT: {
			const struct nk_command_rect* r = (const struct nk_command_rect*)cmd;
			nk_draw_list_stroke_rect(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),
				r->color, (float)r->rounding, r->line_thickness);
		} break;
		case NK_COMMAND_RECT_FILLED: {
			const struct nk_command_rect_filled* r = (const struct nk_command_rect_filled*)cmd;
			nk_draw_list_fill_rect(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),
				r->color, (float)r->rounding);
		} break;
		case NK_COMMAND_RECT_MULTI_COLOR: {
			const struct nk_command_rect_multi_color* r = (const struct nk_command_rect_multi_color*)cmd;
			nk_draw_list_fill_rect_multi_color(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),
				r->left, r->top, r->right, r->bottom);
		} break;
		case NK_COMMAND_CIRCLE: {
			const struct nk_command_circle* c = (const struct nk_command_circle*)cmd;
			nk_draw_list_stroke_circle(&ctx->draw_list, nk_vec2((float)c->x + (float)c->w / 2,
				(float)c->y + (float)c->h / 2), (float)c->w / 2, c->color,
				config->circle_segment_count, c->line_thickness);
		} break;
		case NK_COMMAND_CIRCLE_FILLED: {
			const struct nk_command_circle_filled* c = (const struct nk_command_circle_filled*)cmd;
			nk_draw_list_fill_circle(&ctx->draw_list, nk_vec2((float)c->x + (float)c->w / 2,
				(float)c->y + (float)c->h / 2), (float)c->w / 2, c->color,
				config->circle_segment_count);
		} break;
		case NK_COMMAND_ARC: {
			const struct nk_command_arc* c = (const struct nk_command_arc*)cmd;
			nk_draw_list_path_line_to(&ctx->draw_list, nk_vec2(c->cx, c->cy));
			nk_draw_list_path_arc_to(&ctx->draw_list, nk_vec2(c->cx, c->cy), c->r,
				c->a[0], c->a[1], config->arc_segment_count);
			nk_draw_list_path_stroke(&ctx->draw_list, c->color, NK_STROKE_CLOSED, c->line_thickness);
		} break;
		case NK_COMMAND_ARC_FILLED: {
			const struct nk_command_arc_filled* c = (const struct nk_command_arc_filled*)cmd;
			nk_draw_list_path_line_to(&ctx->draw_list, nk_vec2(c->cx, c->cy));
			nk_draw_list_path_arc_to(&ctx->draw_list, nk_vec2(c->cx, c->cy), c->r,
				c->a[0], c->a[1], config->arc_segment_count);
			nk_draw_list_path_fill(&ctx->draw_list, c->color);
		} break;
		case NK_COMMAND_TRIANGLE: {
			const struct nk_command_triangle* t = (const struct nk_command_triangle*)cmd;
			nk_draw_list_stroke_triangle(&ctx->draw_list, nk_vec2(t->a.x, t->a.y),
				nk_vec2(t->b.x, t->b.y), nk_vec2(t->c.x, t->c.y), t->color,
				t->line_thickness);
		} break;
		case NK_COMMAND_TRIANGLE_FILLED: {
			const struct nk_command_triangle_filled* t = (const struct nk_command_triangle_filled*)cmd;
			nk_draw_list_fill_triangle(&ctx->draw_list, nk_vec2(t->a.x, t->a.y),
				nk_vec2(t->b.x, t->b.y), nk_vec2(t->c.x, t->c.y), t->color);
		} break;
		case NK_COMMAND_POLYGON: {
			int i;
			const struct nk_command_polygon* p = (const struct nk_command_polygon*)cmd;
			for (i = 0; i < p->point_count; ++i) {
				struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);
				nk_draw_list_path_line_to(&ctx->draw_list, pnt);
			}
			nk_draw_list_path_stroke(&ctx->draw_list, p->color, NK_STROKE_CLOSED, p->line_thickness);
		} break;
		case NK_COMMAND_POLYGON_FILLED: {
			int i;
			const struct nk_command_polygon_filled* p = (const struct nk_command_polygon_filled*)cmd;
			for (i = 0; i < p->point_count; ++i) {
				struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);
				nk_draw_list_path_line_to(&ctx->draw_list, pnt);
			}
			nk_draw_list_path_fill(&ctx->draw_list, p->color);
		} break;
		case NK_COMMAND_POLYLINE: {
			int i;
			const struct nk_command_polyline* p = (const struct nk_command_polyline*)cmd;
			for (i = 0; i < p->point_count; ++i) {
				struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);
				nk_draw_list_path_line_to(&ctx->draw_list, pnt);
			}
			nk_draw_list_path_stroke(&ctx->draw_list, p->color, NK_STROKE_OPEN, p->line_thickness);
		} break;
		case NK_COMMAND_TEXT: {
			const struct nk_command_text* t = (const struct nk_command_text*)cmd;
			nk_draw_list_add_text(&ctx->draw_list, t->font, nk_rect(t->x, t->y, t->w, t->h),
				t->string, t->length, t->height, t->foreground);
		} break;
		case NK_COMMAND_IMAGE: {
			const struct nk_command_image* i = (const struct nk_command_image*)cmd;
			nk_draw_list_add_image(&ctx->draw_list, i->img, nk_rect(i->x, i->y, i->w, i->h), i->col);
		} break;
		case NK_COMMAND_CUSTOM: {
			const struct nk_command_custom* c = (const struct nk_command_custom*)cmd;
			c->callback(&ctx->draw_list, c->x, c->y, c->w, c->h, c->callback_data);
		} break;
		default: break;
		}
	}
	res |= (cmds->needed > cmds->allocated + (cmds->memory.size - cmds->size)) ? NK_CONVERT_COMMAND_BUFFER_FULL : 0;
	res |= (vertices->needed > vertices->allocated) ? NK_CONVERT_VERTEX_BUFFER_FULL : 0;
	res |= (elements->needed > elements->allocated) ? NK_CONVERT_ELEMENT_BUFFER_FULL : 0;
	return res;
}
NK_API const struct nk_draw_command*
nk__draw_begin(const struct nk_context* ctx,
	const struct nk_buffer* buffer)
{
	return nk__draw_list_begin(&ctx->draw_list, buffer);
}
NK_API const struct nk_draw_command*
nk__draw_end(const struct nk_context* ctx, const struct nk_buffer* buffer)
{
	return nk__draw_list_end(&ctx->draw_list, buffer);
}
NK_API const struct nk_draw_command*
nk__draw_next(const struct nk_draw_command* cmd,
	const struct nk_buffer* buffer, const struct nk_context* ctx)
{
	return nk__draw_list_next(cmd, buffer, &ctx->draw_list);
}
#endif


#ifdef NK_INCLUDE_FONT_BAKING
/* -------------------------------------------------------------
*
*                          RECT PACK
*
* --------------------------------------------------------------*/
/* stb_rect_pack.h - v0.05 - public domain - rectangle packing */
/* Sean Barrett 2014 */
#define NK_RP__MAXVAL  0xffff
typedef unsigned short nk_rp_coord;

struct nk_rp_rect {
	/* reserved for your use: */
	int id;
	/* input: */
	nk_rp_coord w, h;
	/* output: */
	nk_rp_coord x, y;
	int was_packed;
	/* non-zero if valid packing */
}; /* 16 bytes, nominally */

struct nk_rp_node {
	nk_rp_coord  x, y;
	struct nk_rp_node* next;
};

struct nk_rp_context {
	int width;
	int height;
	int align;
	int init_mode;
	int heuristic;
	int num_nodes;
	struct nk_rp_node* active_head;
	struct nk_rp_node* free_head;
	struct nk_rp_node extra[2];
	/* we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2' */
};

struct nk_rp__findresult {
	int x, y;
	struct nk_rp_node** prev_link;
};

enum NK_RP_HEURISTIC {
	NK_RP_HEURISTIC_Skyline_default = 0,
	NK_RP_HEURISTIC_Skyline_BL_sortHeight = NK_RP_HEURISTIC_Skyline_default,
	NK_RP_HEURISTIC_Skyline_BF_sortHeight
};
enum NK_RP_INIT_STATE { NK_RP__INIT_skyline = 1 };

NK_INTERN void
nk_rp_setup_allow_out_of_mem(struct nk_rp_context* context, int allow_out_of_mem)
{
	if (allow_out_of_mem)
		/* if it's ok to run out of memory, then don't bother aligning them; */
		/* this gives better packing, but may fail due to OOM (even though */
		/* the rectangles easily fit). @TODO a smarter approach would be to only */
		/* quantize once we've hit OOM, then we could get rid of this parameter. */
		context->align = 1;
	else {
		/* if it's not ok to run out of memory, then quantize the widths */
		/* so that num_nodes is always enough nodes. */
		/* */
		/* I.e. num_nodes * align >= width */
		/*                  align >= width / num_nodes */
		/*                  align = ceil(width/num_nodes) */
		context->align = (context->width + context->num_nodes - 1) / context->num_nodes;
	}
}
NK_INTERN void
nk_rp_init_target(struct nk_rp_context* context, int width, int height,
	struct nk_rp_node* nodes, int num_nodes)
{
	int i;
#ifndef STBRP_LARGE_RECTS
	NK_ASSERT(width <= 0xffff && height <= 0xffff);
#endif

	for (i = 0; i < num_nodes - 1; ++i)
		nodes[i].next = &nodes[i + 1];
	nodes[i].next = 0;
	context->init_mode = NK_RP__INIT_skyline;
	context->heuristic = NK_RP_HEURISTIC_Skyline_default;
	context->free_head = &nodes[0];
	context->active_head = &context->extra[0];
	context->width = width;
	context->height = height;
	context->num_nodes = num_nodes;
	nk_rp_setup_allow_out_of_mem(context, 0);

	/* node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly) */
	context->extra[0].x = 0;
	context->extra[0].y = 0;
	context->extra[0].next = &context->extra[1];
	context->extra[1].x = (nk_rp_coord)width;
	context->extra[1].y = 65535;
	context->extra[1].next = 0;
}
/* find minimum y position if it starts at x1 */
NK_INTERN int
nk_rp__skyline_find_min_y(struct nk_rp_context* c, struct nk_rp_node* first,
	int x0, int width, int* pwaste)
{
	struct nk_rp_node* node = first;
	int x1 = x0 + width;
	int min_y, visited_width, waste_area;
	NK_ASSERT(first->x <= x0);
	NK_UNUSED(c);

	NK_ASSERT(node->next->x > x0);
	/* we ended up handling this in the caller for efficiency */
	NK_ASSERT(node->x <= x0);

	min_y = 0;
	waste_area = 0;
	visited_width = 0;
	while (node->x < x1)
	{
		if (node->y > min_y) {
			/* raise min_y higher. */
			/* we've accounted for all waste up to min_y, */
			/* but we'll now add more waste for everything we've visited */
			waste_area += visited_width * (node->y - min_y);
			min_y = node->y;
			/* the first time through, visited_width might be reduced */
			if (node->x < x0)
				visited_width += node->next->x - x0;
			else
				visited_width += node->next->x - node->x;
		}
		else {
			/* add waste area */
			int under_width = node->next->x - node->x;
			if (under_width + visited_width > width)
				under_width = width - visited_width;
			waste_area += under_width * (min_y - node->y);
			visited_width += under_width;
		}
		node = node->next;
	}
	*pwaste = waste_area;
	return min_y;
}
NK_INTERN struct nk_rp__findresult
nk_rp__skyline_find_best_pos(struct nk_rp_context* c, int width, int height)
{
	int best_waste = (1 << 30), best_x, best_y = (1 << 30);
	struct nk_rp__findresult fr;
	struct nk_rp_node** prev, * node, * tail, ** best = 0;

	/* align to multiple of c->align */
	width = (width + c->align - 1);
	width -= width % c->align;
	NK_ASSERT(width % c->align == 0);

	node = c->active_head;
	prev = &c->active_head;
	while (node->x + width <= c->width) {
		int y, waste;
		y = nk_rp__skyline_find_min_y(c, node, node->x, width, &waste);
		/* actually just want to test BL */
		if (c->heuristic == NK_RP_HEURISTIC_Skyline_BL_sortHeight) {
			/* bottom left */
			if (y < best_y) {
				best_y = y;
				best = prev;
			}
		}
		else {
			/* best-fit */
			if (y + height <= c->height) {
				/* can only use it if it first vertically */
				if (y < best_y || (y == best_y && waste < best_waste)) {
					best_y = y;
					best_waste = waste;
					best = prev;
				}
			}
		}
		prev = &node->next;
		node = node->next;
	}
	best_x = (best == 0) ? 0 : (*best)->x;

	/* if doing best-fit (BF), we also have to try aligning right edge to each node position */
	/* */
	/* e.g, if fitting */
	/* */
	/*     ____________________ */
	/*    |____________________| */
	/* */
	/*            into */
	/* */
	/*   |                         | */
	/*   |             ____________| */
	/*   |____________| */
	/* */
	/* then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned */
	/* */
	/* This makes BF take about 2x the time */
	if (c->heuristic == NK_RP_HEURISTIC_Skyline_BF_sortHeight)
	{
		tail = c->active_head;
		node = c->active_head;
		prev = &c->active_head;
		/* find first node that's admissible */
		while (tail->x < width)
			tail = tail->next;
		while (tail)
		{
			int xpos = tail->x - width;
			int y, waste;
			NK_ASSERT(xpos >= 0);
			/* find the left position that matches this */
			while (node->next->x <= xpos) {
				prev = &node->next;
				node = node->next;
			}
			NK_ASSERT(node->next->x > xpos&& node->x <= xpos);
			y = nk_rp__skyline_find_min_y(c, node, xpos, width, &waste);
			if (y + height < c->height) {
				if (y <= best_y) {
					if (y < best_y || waste < best_waste || (waste == best_waste && xpos < best_x)) {
						best_x = xpos;
						NK_ASSERT(y <= best_y);
						best_y = y;
						best_waste = waste;
						best = prev;
					}
				}
			}
			tail = tail->next;
		}
	}
	fr.prev_link = best;
	fr.x = best_x;
	fr.y = best_y;
	return fr;
}
NK_INTERN struct nk_rp__findresult
nk_rp__skyline_pack_rectangle(struct nk_rp_context* context, int width, int height)
{
	/* find best position according to heuristic */
	struct nk_rp__findresult res = nk_rp__skyline_find_best_pos(context, width, height);
	struct nk_rp_node* node, * cur;

	/* bail if: */
	/*    1. it failed */
	/*    2. the best node doesn't fit (we don't always check this) */
	/*    3. we're out of memory */
	if (res.prev_link == 0 || res.y + height > context->height || context->free_head == 0) {
		res.prev_link = 0;
		return res;
	}

	/* on success, create new node */
	node = context->free_head;
	node->x = (nk_rp_coord)res.x;
	node->y = (nk_rp_coord)(res.y + height);

	context->free_head = node->next;

	/* insert the new node into the right starting point, and */
	/* let 'cur' point to the remaining nodes needing to be */
	/* stitched back in */
	cur = *res.prev_link;
	if (cur->x < res.x) {
		/* preserve the existing one, so start testing with the next one */
		struct nk_rp_node* next = cur->next;
		cur->next = node;
		cur = next;
	}
	else {
		*res.prev_link = node;
	}

	/* from here, traverse cur and free the nodes, until we get to one */
	/* that shouldn't be freed */
	while (cur->next && cur->next->x <= res.x + width) {
		struct nk_rp_node* next = cur->next;
		/* move the current node to the free list */
		cur->next = context->free_head;
		context->free_head = cur;
		cur = next;
	}
	/* stitch the list back in */
	node->next = cur;

	if (cur->x < res.x + width)
		cur->x = (nk_rp_coord)(res.x + width);
	return res;
}
NK_INTERN int
nk_rect_height_compare(const void* a, const void* b)
{
	const struct nk_rp_rect* p = (const struct nk_rp_rect*) a;
	const struct nk_rp_rect* q = (const struct nk_rp_rect*) b;
	if (p->h > q->h)
		return -1;
	if (p->h < q->h)
		return  1;
	return (p->w > q->w) ? -1 : (p->w < q->w);
}
NK_INTERN int
nk_rect_original_order(const void* a, const void* b)
{
	const struct nk_rp_rect* p = (const struct nk_rp_rect*) a;
	const struct nk_rp_rect* q = (const struct nk_rp_rect*) b;
	return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
}
NK_INTERN void
nk_rp_qsort(struct nk_rp_rect* array, unsigned int len, int(*cmp)(const void*, const void*))
{
	/* iterative quick sort */
#define NK_MAX_SORT_STACK 64
	unsigned right, left = 0, stack[NK_MAX_SORT_STACK], pos = 0;
	unsigned seed = len / 2 * 69069 + 1;
	for (;;) {
		for (; left + 1 < len; len++) {
			struct nk_rp_rect pivot, tmp;
			if (pos == NK_MAX_SORT_STACK) len = stack[pos = 0];
			pivot = array[left + seed % (len - left)];
			seed = seed * 69069 + 1;
			stack[pos++] = len;
			for (right = left - 1;;) {
				while (cmp(&array[++right], &pivot) < 0);
				while (cmp(&pivot, &array[--len]) < 0);
				if (right >= len) break;
				tmp = array[right];
				array[right] = array[len];
				array[len] = tmp;
			}
		}
		if (pos == 0) break;
		left = len;
		len = stack[--pos];
	}
#undef NK_MAX_SORT_STACK
}
NK_INTERN void
nk_rp_pack_rects(struct nk_rp_context* context, struct nk_rp_rect* rects, int num_rects)
{
	int i;
	/* we use the 'was_packed' field internally to allow sorting/unsorting */
	for (i = 0; i < num_rects; ++i) {
		rects[i].was_packed = i;
	}

	/* sort according to heuristic */
	nk_rp_qsort(rects, (unsigned)num_rects, nk_rect_height_compare);

	for (i = 0; i < num_rects; ++i) {
		struct nk_rp__findresult fr = nk_rp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
		if (fr.prev_link) {
			rects[i].x = (nk_rp_coord)fr.x;
			rects[i].y = (nk_rp_coord)fr.y;
		}
		else {
			rects[i].x = rects[i].y = NK_RP__MAXVAL;
		}
	}

	/* unsort */
	nk_rp_qsort(rects, (unsigned)num_rects, nk_rect_original_order);

	/* set was_packed flags */
	for (i = 0; i < num_rects; ++i)
		rects[i].was_packed = !(rects[i].x == NK_RP__MAXVAL && rects[i].y == NK_RP__MAXVAL);
}

/*
 * ==============================================================
 *
 *                          TRUETYPE
 *
 * ===============================================================
 */
 /* stb_truetype.h - v1.07 - public domain */
#define NK_TT_MAX_OVERSAMPLE   8
#define NK_TT__OVER_MASK  (NK_TT_MAX_OVERSAMPLE-1)

struct nk_tt_bakedchar {
	unsigned short x0, y0, x1, y1;
	/* coordinates of bbox in bitmap */
	float xoff, yoff, xadvance;
};

struct nk_tt_aligned_quad {
	float x0, y0, s0, t0; /* top-left */
	float x1, y1, s1, t1; /* bottom-right */
};

struct nk_tt_packedchar {
	unsigned short x0, y0, x1, y1;
	/* coordinates of bbox in bitmap */
	float xoff, yoff, xadvance;
	float xoff2, yoff2;
};

struct nk_tt_pack_range {
	float font_size;
	int first_unicode_codepoint_in_range;
	/* if non-zero, then the chars are continuous, and this is the first codepoint */
	int* array_of_unicode_codepoints;
	/* if non-zero, then this is an array of unicode codepoints */
	int num_chars;
	struct nk_tt_packedchar* chardata_for_range; /* output */
	unsigned char h_oversample, v_oversample;
	/* don't set these, they're used internally */
};

struct nk_tt_pack_context {
	void* pack_info;
	int   width;
	int   height;
	int   stride_in_bytes;
	int   padding;
	unsigned int   h_oversample, v_oversample;
	unsigned char* pixels;
	void* nodes;
};

struct nk_tt_fontinfo {
	const unsigned char* data; /* pointer to .ttf file */
	int fontstart;/* offset of start of font */
	int numGlyphs;/* number of glyphs, needed for range checking */
	int loca, head, glyf, hhea, hmtx, kern; /* table locations as offset from start of .ttf */
	int index_map; /* a cmap mapping for our chosen character encoding */
	int indexToLocFormat; /* format needed to map from glyph index to glyph */
};

enum {
	NK_TT_vmove = 1,
	NK_TT_vline,
	NK_TT_vcurve
};

struct nk_tt_vertex {
	short x, y, cx, cy;
	unsigned char type, padding;
};

struct nk_tt__bitmap {
	int w, h, stride;
	unsigned char* pixels;
};

struct nk_tt__hheap_chunk {
	struct nk_tt__hheap_chunk* next;
};
struct nk_tt__hheap {
	struct nk_allocator alloc;
	struct nk_tt__hheap_chunk* head;
	void* first_free;
	int    num_remaining_in_head_chunk;
};

struct nk_tt__edge {
	float x0, y0, x1, y1;
	int invert;
};

struct nk_tt__active_edge {
	struct nk_tt__active_edge* next;
	float fx, fdx, fdy;
	float direction;
	float sy;
	float ey;
};
struct nk_tt__point { float x, y; };

#define NK_TT_MACSTYLE_DONTCARE     0
#define NK_TT_MACSTYLE_BOLD         1
#define NK_TT_MACSTYLE_ITALIC       2
#define NK_TT_MACSTYLE_UNDERSCORE   4
#define NK_TT_MACSTYLE_NONE         8
/* <= not same as 0, this makes us check the bitfield is 0 */

enum { /* platformID */
	NK_TT_PLATFORM_ID_UNICODE = 0,
	NK_TT_PLATFORM_ID_MAC = 1,
	NK_TT_PLATFORM_ID_ISO = 2,
	NK_TT_PLATFORM_ID_MICROSOFT = 3
};

enum { /* encodingID for NK_TT_PLATFORM_ID_UNICODE */
	NK_TT_UNICODE_EID_UNICODE_1_0 = 0,
	NK_TT_UNICODE_EID_UNICODE_1_1 = 1,
	NK_TT_UNICODE_EID_ISO_10646 = 2,
	NK_TT_UNICODE_EID_UNICODE_2_0_BMP = 3,
	NK_TT_UNICODE_EID_UNICODE_2_0_FULL = 4
};

enum { /* encodingID for NK_TT_PLATFORM_ID_MICROSOFT */
	NK_TT_MS_EID_SYMBOL = 0,
	NK_TT_MS_EID_UNICODE_BMP = 1,
	NK_TT_MS_EID_SHIFTJIS = 2,
	NK_TT_MS_EID_UNICODE_FULL = 10
};

enum { /* encodingID for NK_TT_PLATFORM_ID_MAC; same as Script Manager codes */
	NK_TT_MAC_EID_ROMAN = 0, NK_TT_MAC_EID_ARABIC = 4,
	NK_TT_MAC_EID_JAPANESE = 1, NK_TT_MAC_EID_HEBREW = 5,
	NK_TT_MAC_EID_CHINESE_TRAD = 2, NK_TT_MAC_EID_GREEK = 6,
	NK_TT_MAC_EID_KOREAN = 3, NK_TT_MAC_EID_RUSSIAN = 7
};

enum { /* languageID for NK_TT_PLATFORM_ID_MICROSOFT; same as LCID... */
	   /* problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs */
	NK_TT_MS_LANG_ENGLISH = 0x0409, NK_TT_MS_LANG_ITALIAN = 0x0410,
	NK_TT_MS_LANG_CHINESE = 0x0804, NK_TT_MS_LANG_JAPANESE = 0x0411,
	NK_TT_MS_LANG_DUTCH = 0x0413, NK_TT_MS_LANG_KOREAN = 0x0412,
	NK_TT_MS_LANG_FRENCH = 0x040c, NK_TT_MS_LANG_RUSSIAN = 0x0419,
	NK_TT_MS_LANG_GERMAN = 0x0407, NK_TT_MS_LANG_SPANISH = 0x0409,
	NK_TT_MS_LANG_HEBREW = 0x040d, NK_TT_MS_LANG_SWEDISH = 0x041D
};

enum { /* languageID for NK_TT_PLATFORM_ID_MAC */
	NK_TT_MAC_LANG_ENGLISH = 0, NK_TT_MAC_LANG_JAPANESE = 11,
	NK_TT_MAC_LANG_ARABIC = 12, NK_TT_MAC_LANG_KOREAN = 23,
	NK_TT_MAC_LANG_DUTCH = 4, NK_TT_MAC_LANG_RUSSIAN = 32,
	NK_TT_MAC_LANG_FRENCH = 1, NK_TT_MAC_LANG_SPANISH = 6,
	NK_TT_MAC_LANG_GERMAN = 2, NK_TT_MAC_LANG_SWEDISH = 5,
	NK_TT_MAC_LANG_HEBREW = 10, NK_TT_MAC_LANG_CHINESE_SIMPLIFIED = 33,
	NK_TT_MAC_LANG_ITALIAN = 3, NK_TT_MAC_LANG_CHINESE_TRAD = 19
};

#define nk_ttBYTE(p)     (* (const nk_byte *) (p))
#define nk_ttCHAR(p)     (* (const char *) (p))

#if defined(NK_BIGENDIAN) && !defined(NK_ALLOW_UNALIGNED_TRUETYPE)
#define nk_ttUSHORT(p)   (* (nk_ushort *) (p))
#define nk_ttSHORT(p)    (* (nk_short *) (p))
#define nk_ttULONG(p)    (* (nk_uint *) (p))
#define nk_ttLONG(p)     (* (nk_int *) (p))
#else
static nk_ushort nk_ttUSHORT(const nk_byte* p) { return (nk_ushort)(p[0] * 256 + p[1]); }
static nk_short nk_ttSHORT(const nk_byte* p) { return (nk_short)(p[0] * 256 + p[1]); }
static nk_uint nk_ttULONG(const nk_byte* p) { return (nk_uint)((p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]); }
#endif

#define nk_tt_tag4(p,c0,c1,c2,c3)\
    ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define nk_tt_tag(p,str) nk_tt_tag4(p,str[0],str[1],str[2],str[3])

NK_INTERN int nk_tt_GetGlyphShape(const struct nk_tt_fontinfo* info, struct nk_allocator* alloc,
	int glyph_index, struct nk_tt_vertex** pvertices);

NK_INTERN nk_uint
nk_tt__find_table(const nk_byte* data, nk_uint fontstart, const char* tag)
{
	/* @OPTIMIZE: binary search */
	nk_int num_tables = nk_ttUSHORT(data + fontstart + 4);
	nk_uint tabledir = fontstart + 12;
	nk_int i;
	for (i = 0; i < num_tables; ++i) {
		nk_uint loc = tabledir + (nk_uint)(16 * i);
		if (nk_tt_tag(data + loc + 0, tag))
			return nk_ttULONG(data + loc + 8);
	}
	return 0;
}
NK_INTERN int
nk_tt_InitFont(struct nk_tt_fontinfo* info, const unsigned char* data2, int fontstart)
{
	nk_uint cmap, t;
	nk_int i, numTables;
	const nk_byte* data = (const nk_byte*)data2;

	info->data = data;
	info->fontstart = fontstart;

	cmap = nk_tt__find_table(data, (nk_uint)fontstart, "cmap");       /* required */
	info->loca = (int)nk_tt__find_table(data, (nk_uint)fontstart, "loca"); /* required */
	info->head = (int)nk_tt__find_table(data, (nk_uint)fontstart, "head"); /* required */
	info->glyf = (int)nk_tt__find_table(data, (nk_uint)fontstart, "glyf"); /* required */
	info->hhea = (int)nk_tt__find_table(data, (nk_uint)fontstart, "hhea"); /* required */
	info->hmtx = (int)nk_tt__find_table(data, (nk_uint)fontstart, "hmtx"); /* required */
	info->kern = (int)nk_tt__find_table(data, (nk_uint)fontstart, "kern"); /* not required */
	if (!cmap || !info->loca || !info->head || !info->glyf || !info->hhea || !info->hmtx)
		return 0;

	t = nk_tt__find_table(data, (nk_uint)fontstart, "maxp");
	if (t) info->numGlyphs = nk_ttUSHORT(data + t + 4);
	else info->numGlyphs = 0xffff;

	/* find a cmap encoding table we understand *now* to avoid searching */
	/* later. (todo: could make this installable) */
	/* the same regardless of glyph. */
	numTables = nk_ttUSHORT(data + cmap + 2);
	info->index_map = 0;
	for (i = 0; i < numTables; ++i)
	{
		nk_uint encoding_record = cmap + 4 + 8 * (nk_uint)i;
		/* find an encoding we understand: */
		switch (nk_ttUSHORT(data + encoding_record)) {
		case NK_TT_PLATFORM_ID_MICROSOFT:
			switch (nk_ttUSHORT(data + encoding_record + 2)) {
			case NK_TT_MS_EID_UNICODE_BMP:
			case NK_TT_MS_EID_UNICODE_FULL:
				/* MS/Unicode */
				info->index_map = (int)(cmap + nk_ttULONG(data + encoding_record + 4));
				break;
			default: break;
			} break;
		case NK_TT_PLATFORM_ID_UNICODE:
			/* Mac/iOS has these */
			/* all the encodingIDs are unicode, so we don't bother to check it */
			info->index_map = (int)(cmap + nk_ttULONG(data + encoding_record + 4));
			break;
		default: break;
		}
	}
	if (info->index_map == 0)
		return 0;
	info->indexToLocFormat = nk_ttUSHORT(data + info->head + 50);
	return 1;
}
NK_INTERN int
nk_tt_FindGlyphIndex(const struct nk_tt_fontinfo* info, int unicode_codepoint)
{
	const nk_byte* data = info->data;
	nk_uint index_map = (nk_uint)info->index_map;

	nk_ushort format = nk_ttUSHORT(data + index_map + 0);
	if (format == 0) { /* apple byte encoding */
		nk_int bytes = nk_ttUSHORT(data + index_map + 2);
		if (unicode_codepoint < bytes - 6)
			return nk_ttBYTE(data + index_map + 6 + unicode_codepoint);
		return 0;
	}
	else if (format == 6) {
		nk_uint first = nk_ttUSHORT(data + index_map + 6);
		nk_uint count = nk_ttUSHORT(data + index_map + 8);
		if ((nk_uint)unicode_codepoint >= first && (nk_uint)unicode_codepoint < first + count)
			return nk_ttUSHORT(data + index_map + 10 + (unicode_codepoint - (int)first) * 2);
		return 0;
	}
	else if (format == 2) {
		NK_ASSERT(0); /* @TODO: high-byte mapping for japanese/chinese/korean */
		return 0;
	}
	else if (format == 4) { /* standard mapping for windows fonts: binary search collection of ranges */
		nk_ushort segcount = nk_ttUSHORT(data + index_map + 6) >> 1;
		nk_ushort searchRange = nk_ttUSHORT(data + index_map + 8) >> 1;
		nk_ushort entrySelector = nk_ttUSHORT(data + index_map + 10);
		nk_ushort rangeShift = nk_ttUSHORT(data + index_map + 12) >> 1;

		/* do a binary search of the segments */
		nk_uint endCount = index_map + 14;
		nk_uint search = endCount;

		if (unicode_codepoint > 0xffff)
			return 0;

		/* they lie from endCount .. endCount + segCount */
		/* but searchRange is the nearest power of two, so... */
		if (unicode_codepoint >= nk_ttUSHORT(data + search + rangeShift * 2))
			search += (nk_uint)(rangeShift * 2);

		/* now decrement to bias correctly to find smallest */
		search -= 2;
		while (entrySelector) {
			nk_ushort end;
			searchRange >>= 1;
			end = nk_ttUSHORT(data + search + searchRange * 2);
			if (unicode_codepoint > end)
				search += (nk_uint)(searchRange * 2);
			--entrySelector;
		}
		search += 2;

		{
			nk_ushort offset, start;
			nk_ushort item = (nk_ushort)((search - endCount) >> 1);

			NK_ASSERT(unicode_codepoint <= nk_ttUSHORT(data + endCount + 2 * item));
			start = nk_ttUSHORT(data + index_map + 14 + segcount * 2 + 2 + 2 * item);
			if (unicode_codepoint < start)
				return 0;

			offset = nk_ttUSHORT(data + index_map + 14 + segcount * 6 + 2 + 2 * item);
			if (offset == 0)
				return (nk_ushort)(unicode_codepoint + nk_ttSHORT(data + index_map + 14 + segcount * 4 + 2 + 2 * item));

			return nk_ttUSHORT(data + offset + (unicode_codepoint - start) * 2 + index_map + 14 + segcount * 6 + 2 + 2 * item);
		}
	}
	else if (format == 12 || format == 13) {
		nk_uint ngroups = nk_ttULONG(data + index_map + 12);
		nk_int low, high;
		low = 0; high = (nk_int)ngroups;
		/* Binary search the right group. */
		while (low < high) {
			nk_int mid = low + ((high - low) >> 1); /* rounds down, so low <= mid < high */
			nk_uint start_char = nk_ttULONG(data + index_map + 16 + mid * 12);
			nk_uint end_char = nk_ttULONG(data + index_map + 16 + mid * 12 + 4);
			if ((nk_uint)unicode_codepoint < start_char)
				high = mid;
			else if ((nk_uint)unicode_codepoint > end_char)
				low = mid + 1;
			else {
				nk_uint start_glyph = nk_ttULONG(data + index_map + 16 + mid * 12 + 8);
				if (format == 12)
					return (int)start_glyph + (int)unicode_codepoint - (int)start_char;
				else /* format == 13 */
					return (int)start_glyph;
			}
		}
		return 0; /* not found */
	}
	/* @TODO */
	NK_ASSERT(0);
	return 0;
}
NK_INTERN void
nk_tt_setvertex(struct nk_tt_vertex* v, nk_byte type, nk_int x, nk_int y, nk_int cx, nk_int cy)
{
	v->type = type;
	v->x = (nk_short)x;
	v->y = (nk_short)y;
	v->cx = (nk_short)cx;
	v->cy = (nk_short)cy;
}
NK_INTERN int
nk_tt__GetGlyfOffset(const struct nk_tt_fontinfo* info, int glyph_index)
{
	int g1, g2;
	if (glyph_index >= info->numGlyphs) return -1; /* glyph index out of range */
	if (info->indexToLocFormat >= 2)    return -1; /* unknown index->glyph map format */

	if (info->indexToLocFormat == 0) {
		g1 = info->glyf + nk_ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
		g2 = info->glyf + nk_ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
	}
	else {
		g1 = info->glyf + (int)nk_ttULONG(info->data + info->loca + glyph_index * 4);
		g2 = info->glyf + (int)nk_ttULONG(info->data + info->loca + glyph_index * 4 + 4);
	}
	return g1 == g2 ? -1 : g1; /* if length is 0, return -1 */
}
NK_INTERN int
nk_tt_GetGlyphBox(const struct nk_tt_fontinfo* info, int glyph_index,
	int* x0, int* y0, int* x1, int* y1)
{
	int g = nk_tt__GetGlyfOffset(info, glyph_index);
	if (g < 0) return 0;

	if (x0) *x0 = nk_ttSHORT(info->data + g + 2);
	if (y0) *y0 = nk_ttSHORT(info->data + g + 4);
	if (x1) *x1 = nk_ttSHORT(info->data + g + 6);
	if (y1) *y1 = nk_ttSHORT(info->data + g + 8);
	return 1;
}
NK_INTERN int
nk_tt__close_shape(struct nk_tt_vertex* vertices, int num_vertices, int was_off,
	int start_off, nk_int sx, nk_int sy, nk_int scx, nk_int scy, nk_int cx, nk_int cy)
{
	if (start_off) {
		if (was_off)
			nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, (cx + scx) >> 1, (cy + scy) >> 1, cx, cy);
		nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, sx, sy, scx, scy);
	}
	else {
		if (was_off)
			nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, sx, sy, cx, cy);
		else
			nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vline, sx, sy, 0, 0);
	}
	return num_vertices;
}
NK_INTERN int
nk_tt_GetGlyphShape(const struct nk_tt_fontinfo* info, struct nk_allocator* alloc,
	int glyph_index, struct nk_tt_vertex** pvertices)
{
	nk_short numberOfContours;
	const nk_byte* endPtsOfContours;
	const nk_byte* data = info->data;
	struct nk_tt_vertex* vertices = 0;
	int num_vertices = 0;
	int g = nk_tt__GetGlyfOffset(info, glyph_index);
	*pvertices = 0;

	if (g < 0) return 0;
	numberOfContours = nk_ttSHORT(data + g);
	if (numberOfContours > 0) {
		nk_byte flags = 0, flagcount;
		nk_int ins, i, j = 0, m, n, next_move, was_off = 0, off, start_off = 0;
		nk_int x, y, cx, cy, sx, sy, scx, scy;
		const nk_byte* points;
		endPtsOfContours = (data + g + 10);
		ins = nk_ttUSHORT(data + g + 10 + numberOfContours * 2);
		points = data + g + 10 + numberOfContours * 2 + 2 + ins;

		n = 1 + nk_ttUSHORT(endPtsOfContours + numberOfContours * 2 - 2);
		m = n + 2 * numberOfContours;  /* a loose bound on how many vertices we might need */
		vertices = (struct nk_tt_vertex*)alloc->alloc(alloc->userdata, 0, (nk_size)m * sizeof(vertices[0]));
		if (vertices == 0)
			return 0;

		next_move = 0;
		flagcount = 0;

		/* in first pass, we load uninterpreted data into the allocated array */
		/* above, shifted to the end of the array so we won't overwrite it when */
		/* we create our final data starting from the front */
		off = m - n; /* starting offset for uninterpreted data, regardless of how m ends up being calculated */

		/* first load flags */
		for (i = 0; i < n; ++i) {
			if (flagcount == 0) {
				flags = *points++;
				if (flags & 8)
					flagcount = *points++;
			}
			else --flagcount;
			vertices[off + i].type = flags;
		}

		/* now load x coordinates */
		x = 0;
		for (i = 0; i < n; ++i) {
			flags = vertices[off + i].type;
			if (flags & 2) {
				nk_short dx = *points++;
				x += (flags & 16) ? dx : -dx; /* ??? */
			}
			else {
				if (!(flags & 16)) {
					x = x + (nk_short)(points[0] * 256 + points[1]);
					points += 2;
				}
			}
			vertices[off + i].x = (nk_short)x;
		}

		/* now load y coordinates */
		y = 0;
		for (i = 0; i < n; ++i) {
			flags = vertices[off + i].type;
			if (flags & 4) {
				nk_short dy = *points++;
				y += (flags & 32) ? dy : -dy; /* ??? */
			}
			else {
				if (!(flags & 32)) {
					y = y + (nk_short)(points[0] * 256 + points[1]);
					points += 2;
				}
			}
			vertices[off + i].y = (nk_short)y;
		}

		/* now convert them to our format */
		num_vertices = 0;
		sx = sy = cx = cy = scx = scy = 0;
		for (i = 0; i < n; ++i)
		{
			flags = vertices[off + i].type;
			x = (nk_short)vertices[off + i].x;
			y = (nk_short)vertices[off + i].y;

			if (next_move == i) {
				if (i != 0)
					num_vertices = nk_tt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy);

				/* now start the new one                */
				start_off = !(flags & 1);
				if (start_off) {
					/* if we start off with an off-curve point, then when we need to find a point on the curve */
					/* where we can start, and we need to save some state for when we wraparound. */
					scx = x;
					scy = y;
					if (!(vertices[off + i + 1].type & 1)) {
						/* next point is also a curve point, so interpolate an on-point curve */
						sx = (x + (nk_int)vertices[off + i + 1].x) >> 1;
						sy = (y + (nk_int)vertices[off + i + 1].y) >> 1;
					}
					else {
						/* otherwise just use the next point as our start point */
						sx = (nk_int)vertices[off + i + 1].x;
						sy = (nk_int)vertices[off + i + 1].y;
						++i; /* we're using point i+1 as the starting point, so skip it */
					}
				}
				else {
					sx = x;
					sy = y;
				}
				nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vmove, sx, sy, 0, 0);
				was_off = 0;
				next_move = 1 + nk_ttUSHORT(endPtsOfContours + j * 2);
				++j;
			}
			else {
				if (!(flags & 1))
				{ /* if it's a curve */
					if (was_off) /* two off-curve control points in a row means interpolate an on-curve midpoint */
						nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, (cx + x) >> 1, (cy + y) >> 1, cx, cy);
					cx = x;
					cy = y;
					was_off = 1;
				}
				else {
					if (was_off)
						nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, x, y, cx, cy);
					else nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vline, x, y, 0, 0);
					was_off = 0;
				}
			}
		}
		num_vertices = nk_tt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy);
	}
	else if (numberOfContours == -1) {
		/* Compound shapes. */
		int more = 1;
		const nk_byte* comp = data + g + 10;
		num_vertices = 0;
		vertices = 0;

		while (more)
		{
			nk_ushort flags, gidx;
			int comp_num_verts = 0, i;
			struct nk_tt_vertex* comp_verts = 0, * tmp = 0;
			float mtx[6] = { 1,0,0,1,0,0 }, m, n;

			flags = (nk_ushort)nk_ttSHORT(comp); comp += 2;
			gidx = (nk_ushort)nk_ttSHORT(comp); comp += 2;

			if (flags & 2) { /* XY values */
				if (flags & 1) { /* shorts */
					mtx[4] = nk_ttSHORT(comp); comp += 2;
					mtx[5] = nk_ttSHORT(comp); comp += 2;
				}
				else {
					mtx[4] = nk_ttCHAR(comp); comp += 1;
					mtx[5] = nk_ttCHAR(comp); comp += 1;
				}
			}
			else {
				/* @TODO handle matching point */
				NK_ASSERT(0);
			}
			if (flags & (1 << 3)) { /* WE_HAVE_A_SCALE */
				mtx[0] = mtx[3] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = mtx[2] = 0;
			}
			else if (flags & (1 << 6)) { /* WE_HAVE_AN_X_AND_YSCALE */
				mtx[0] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = mtx[2] = 0;
				mtx[3] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
			}
			else if (flags & (1 << 7)) { /* WE_HAVE_A_TWO_BY_TWO */
				mtx[0] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[2] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[3] = nk_ttSHORT(comp) / 16384.0f; comp += 2;
			}

			/* Find transformation scales. */
			m = (float)NK_SQRT(mtx[0] * mtx[0] + mtx[1] * mtx[1]);
			n = (float)NK_SQRT(mtx[2] * mtx[2] + mtx[3] * mtx[3]);

			/* Get indexed glyph. */
			comp_num_verts = nk_tt_GetGlyphShape(info, alloc, gidx, &comp_verts);
			if (comp_num_verts > 0)
			{
				/* Transform vertices. */
				for (i = 0; i < comp_num_verts; ++i) {
					struct nk_tt_vertex* v = &comp_verts[i];
					short x, y;
					x = v->x; y = v->y;
					v->x = (short)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
					v->y = (short)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
					x = v->cx; y = v->cy;
					v->cx = (short)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
					v->cy = (short)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
				}
				/* Append vertices. */
				tmp = (struct nk_tt_vertex*)alloc->alloc(alloc->userdata, 0,
					(nk_size)(num_vertices + comp_num_verts) * sizeof(struct nk_tt_vertex));
				if (!tmp) {
					if (vertices) alloc->free(alloc->userdata, vertices);
					if (comp_verts) alloc->free(alloc->userdata, comp_verts);
					return 0;
				}
				if (num_vertices > 0) NK_MEMCPY(tmp, vertices, (nk_size)num_vertices * sizeof(struct nk_tt_vertex));
				NK_MEMCPY(tmp + num_vertices, comp_verts, (nk_size)comp_num_verts * sizeof(struct nk_tt_vertex));
				if (vertices) alloc->free(alloc->userdata, vertices);
				vertices = tmp;
				alloc->free(alloc->userdata, comp_verts);
				num_vertices += comp_num_verts;
			}
			/* More components ? */
			more = flags & (1 << 5);
		}
	}
	else if (numberOfContours < 0) {
		/* @TODO other compound variations? */
		NK_ASSERT(0);
	}
	else {
		/* numberOfCounters == 0, do nothing */
	}
	*pvertices = vertices;
	return num_vertices;
}
NK_INTERN void
nk_tt_GetGlyphHMetrics(const struct nk_tt_fontinfo* info, int glyph_index,
	int* advanceWidth, int* leftSideBearing)
{
	nk_ushort numOfLongHorMetrics = nk_ttUSHORT(info->data + info->hhea + 34);
	if (glyph_index < numOfLongHorMetrics) {
		if (advanceWidth)
			*advanceWidth = nk_ttSHORT(info->data + info->hmtx + 4 * glyph_index);
		if (leftSideBearing)
			*leftSideBearing = nk_ttSHORT(info->data + info->hmtx + 4 * glyph_index + 2);
	}
	else {
		if (advanceWidth)
			*advanceWidth = nk_ttSHORT(info->data + info->hmtx + 4 * (numOfLongHorMetrics - 1));
		if (leftSideBearing)
			*leftSideBearing = nk_ttSHORT(info->data + info->hmtx + 4 * numOfLongHorMetrics + 2 * (glyph_index - numOfLongHorMetrics));
	}
}
NK_INTERN void
nk_tt_GetFontVMetrics(const struct nk_tt_fontinfo* info,
	int* ascent, int* descent, int* lineGap)
{
	if (ascent) *ascent = nk_ttSHORT(info->data + info->hhea + 4);
	if (descent) *descent = nk_ttSHORT(info->data + info->hhea + 6);
	if (lineGap) *lineGap = nk_ttSHORT(info->data + info->hhea + 8);
}
NK_INTERN float
nk_tt_ScaleForPixelHeight(const struct nk_tt_fontinfo* info, float height)
{
	int fheight = nk_ttSHORT(info->data + info->hhea + 4) - nk_ttSHORT(info->data + info->hhea + 6);
	return (float)height / (float)fheight;
}
NK_INTERN float
nk_tt_ScaleForMappingEmToPixels(const struct nk_tt_fontinfo* info, float pixels)
{
	int unitsPerEm = nk_ttUSHORT(info->data + info->head + 18);
	return pixels / (float)unitsPerEm;
}

/*-------------------------------------------------------------
 *            antialiasing software rasterizer
 * --------------------------------------------------------------*/
NK_INTERN void
nk_tt_GetGlyphBitmapBoxSubpixel(const struct nk_tt_fontinfo* font,
	int glyph, float scale_x, float scale_y, float shift_x, float shift_y,
	int* ix0, int* iy0, int* ix1, int* iy1)
{
	int x0, y0, x1, y1;
	if (!nk_tt_GetGlyphBox(font, glyph, &x0, &y0, &x1, &y1)) {
		/* e.g. space character */
		if (ix0) *ix0 = 0;
		if (iy0) *iy0 = 0;
		if (ix1) *ix1 = 0;
		if (iy1) *iy1 = 0;
	}
	else {
		/* move to integral bboxes (treating pixels as little squares, what pixels get touched)? */
		if (ix0) *ix0 = nk_ifloorf((float)x0 * scale_x + shift_x);
		if (iy0) *iy0 = nk_ifloorf((float)-y1 * scale_y + shift_y);
		if (ix1) *ix1 = nk_iceilf((float)x1 * scale_x + shift_x);
		if (iy1) *iy1 = nk_iceilf((float)-y0 * scale_y + shift_y);
	}
}
NK_INTERN void
nk_tt_GetGlyphBitmapBox(const struct nk_tt_fontinfo* font, int glyph,
	float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1)
{
	nk_tt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y, 0.0f, 0.0f, ix0, iy0, ix1, iy1);
}

/*-------------------------------------------------------------
 *                          Rasterizer
 * --------------------------------------------------------------*/
NK_INTERN void*
nk_tt__hheap_alloc(struct nk_tt__hheap* hh, nk_size size)
{
	if (hh->first_free) {
		void* p = hh->first_free;
		hh->first_free = *(void**)p;
		return p;
	}
	else {
		if (hh->num_remaining_in_head_chunk == 0) {
			int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
			struct nk_tt__hheap_chunk* c = (struct nk_tt__hheap_chunk*)
				hh->alloc.alloc(hh->alloc.userdata, 0,
					sizeof(struct nk_tt__hheap_chunk) + size * (nk_size)count);
			if (c == 0) return 0;
			c->next = hh->head;
			hh->head = c;
			hh->num_remaining_in_head_chunk = count;
		}
		--hh->num_remaining_in_head_chunk;
		return (char*)(hh->head) + size * (nk_size)hh->num_remaining_in_head_chunk;
	}
}
NK_INTERN void
nk_tt__hheap_free(struct nk_tt__hheap* hh, void* p)
{
	*(void**)p = hh->first_free;
	hh->first_free = p;
}
NK_INTERN void
nk_tt__hheap_cleanup(struct nk_tt__hheap* hh)
{
	struct nk_tt__hheap_chunk* c = hh->head;
	while (c) {
		struct nk_tt__hheap_chunk* n = c->next;
		hh->alloc.free(hh->alloc.userdata, c);
		c = n;
	}
}
NK_INTERN struct nk_tt__active_edge*
nk_tt__new_active(struct nk_tt__hheap* hh, struct nk_tt__edge* e,
	int off_x, float start_point)
{
	struct nk_tt__active_edge* z = (struct nk_tt__active_edge*)
		nk_tt__hheap_alloc(hh, sizeof(*z));
	float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
	/*STBTT_assert(e->y0 <= start_point); */
	if (!z) return z;
	z->fdx = dxdy;
	z->fdy = (dxdy != 0) ? (1 / dxdy) : 0;
	z->fx = e->x0 + dxdy * (start_point - e->y0);
	z->fx -= (float)off_x;
	z->direction = e->invert ? 1.0f : -1.0f;
	z->sy = e->y0;
	z->ey = e->y1;
	z->next = 0;
	return z;
}
NK_INTERN void
nk_tt__handle_clipped_edge(float* scanline, int x, struct nk_tt__active_edge* e,
	float x0, float y0, float x1, float y1)
{
	if (y0 == y1) return;
	NK_ASSERT(y0 < y1);
	NK_ASSERT(e->sy <= e->ey);
	if (y0 > e->ey) return;
	if (y1 < e->sy) return;
	if (y0 < e->sy) {
		x0 += (x1 - x0) * (e->sy - y0) / (y1 - y0);
		y0 = e->sy;
	}
	if (y1 > e->ey) {
		x1 += (x1 - x0) * (e->ey - y1) / (y1 - y0);
		y1 = e->ey;
	}

	if (x0 == x) NK_ASSERT(x1 <= x + 1);
	else if (x0 == x + 1) NK_ASSERT(x1 >= x);
	else if (x0 <= x) NK_ASSERT(x1 <= x);
	else if (x0 >= x + 1) NK_ASSERT(x1 >= x + 1);
	else NK_ASSERT(x1 >= x && x1 <= x + 1);

	if (x0 <= x && x1 <= x)
		scanline[x] += e->direction * (y1 - y0);
	else if (x0 >= x + 1 && x1 >= x + 1);
	else {
		NK_ASSERT(x0 >= x && x0 <= x + 1 && x1 >= x && x1 <= x + 1);
		/* coverage = 1 - average x position */
		scanline[x] += (float)e->direction * (float)(y1 - y0) * (1.0f - ((x0 - (float)x) + (x1 - (float)x)) / 2.0f);
	}
}
NK_INTERN void
nk_tt__fill_active_edges_new(float* scanline, float* scanline_fill, int len,
	struct nk_tt__active_edge* e, float y_top)
{
	float y_bottom = y_top + 1;
	while (e)
	{
		/* brute force every pixel */
		/* compute intersection points with top & bottom */
		NK_ASSERT(e->ey >= y_top);
		if (e->fdx == 0) {
			float x0 = e->fx;
			if (x0 < len) {
				if (x0 >= 0) {
					nk_tt__handle_clipped_edge(scanline, (int)x0, e, x0, y_top, x0, y_bottom);
					nk_tt__handle_clipped_edge(scanline_fill - 1, (int)x0 + 1, e, x0, y_top, x0, y_bottom);
				}
				else {
					nk_tt__handle_clipped_edge(scanline_fill - 1, 0, e, x0, y_top, x0, y_bottom);
				}
			}
		}
		else {
			float x0 = e->fx;
			float dx = e->fdx;
			float xb = x0 + dx;
			float x_top, x_bottom;
			float y0, y1;
			float dy = e->fdy;
			NK_ASSERT(e->sy <= y_bottom && e->ey >= y_top);

			/* compute endpoints of line segment clipped to this scanline (if the */
			/* line segment starts on this scanline. x0 is the intersection of the */
			/* line with y_top, but that may be off the line segment. */
			if (e->sy > y_top) {
				x_top = x0 + dx * (e->sy - y_top);
				y0 = e->sy;
			}
			else {
				x_top = x0;
				y0 = y_top;
			}

			if (e->ey < y_bottom) {
				x_bottom = x0 + dx * (e->ey - y_top);
				y1 = e->ey;
			}
			else {
				x_bottom = xb;
				y1 = y_bottom;
			}

			if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len)
			{
				/* from here on, we don't have to range check x values */
				if ((int)x_top == (int)x_bottom) {
					float height;
					/* simple case, only spans one pixel */
					int x = (int)x_top;
					height = y1 - y0;
					NK_ASSERT(x >= 0 && x < len);
					scanline[x] += e->direction * (1.0f - (((float)x_top - (float)x) + ((float)x_bottom - (float)x)) / 2.0f) * (float)height;
					scanline_fill[x] += e->direction * (float)height; /* everything right of this pixel is filled */
				}
				else {
					int x, x1, x2;
					float y_crossing, step, sign, area;
					/* covers 2+ pixels */
					if (x_top > x_bottom)
					{
						/* flip scanline vertically; signed area is the same */
						float t;
						y0 = y_bottom - (y0 - y_top);
						y1 = y_bottom - (y1 - y_top);
						t = y0; y0 = y1; y1 = t;
						t = x_bottom; x_bottom = x_top; x_top = t;
						dx = -dx;
						dy = -dy;
						t = x0; x0 = xb; xb = t;
					}

					x1 = (int)x_top;
					x2 = (int)x_bottom;
					/* compute intersection with y axis at x1+1 */
					y_crossing = ((float)x1 + 1 - (float)x0) * (float)dy + (float)y_top;

					sign = e->direction;
					/* area of the rectangle covered from y0..y_crossing */
					area = sign * (y_crossing - y0);
					/* area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing) */
					scanline[x1] += area * (1.0f - ((float)((float)x_top - (float)x1) + (float)(x1 + 1 - x1)) / 2.0f);

					step = sign * dy;
					for (x = x1 + 1; x < x2; ++x) {
						scanline[x] += area + step / 2;
						area += step;
					}
					y_crossing += (float)dy * (float)(x2 - (x1 + 1));

					scanline[x2] += area + sign * (1.0f - ((float)(x2 - x2) + ((float)x_bottom - (float)x2)) / 2.0f) * (y1 - y_crossing);
					scanline_fill[x2] += sign * (y1 - y0);
				}
			}
			else
			{
				/* if edge goes outside of box we're drawing, we require */
				/* clipping logic. since this does not match the intended use */
				/* of this library, we use a different, very slow brute */
				/* force implementation */
				int x;
				for (x = 0; x < len; ++x)
				{
					/* cases: */
					/* */
					/* there can be up to two intersections with the pixel. any intersection */
					/* with left or right edges can be handled by splitting into two (or three) */
					/* regions. intersections with top & bottom do not necessitate case-wise logic. */
					/* */
					/* the old way of doing this found the intersections with the left & right edges, */
					/* then used some simple logic to produce up to three segments in sorted order */
					/* from top-to-bottom. however, this had a problem: if an x edge was epsilon */
					/* across the x border, then the corresponding y position might not be distinct */
					/* from the other y segment, and it might ignored as an empty segment. to avoid */
					/* that, we need to explicitly produce segments based on x positions. */

					/* rename variables to clear pairs */
					float ya = y_top;
					float x1 = (float)(x);
					float x2 = (float)(x + 1);
					float x3 = xb;
					float y3 = y_bottom;
					float yb, y2;

					yb = ((float)x - x0) / dx + y_top;
					y2 = ((float)x + 1 - x0) / dx + y_top;

					if (x0 < x1 && x3 > x2) {         /* three segments descending down-right */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x1, yb);
						nk_tt__handle_clipped_edge(scanline, x, e, x1, yb, x2, y2);
						nk_tt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else if (x3 < x1 && x0 > x2) {  /* three segments descending down-left */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x2, y2);
						nk_tt__handle_clipped_edge(scanline, x, e, x2, y2, x1, yb);
						nk_tt__handle_clipped_edge(scanline, x, e, x1, yb, x3, y3);
					}
					else if (x0 < x1 && x3 > x1) {  /* two segments across x, down-right */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x1, yb);
						nk_tt__handle_clipped_edge(scanline, x, e, x1, yb, x3, y3);
					}
					else if (x3 < x1 && x0 > x1) {  /* two segments across x, down-left */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x1, yb);
						nk_tt__handle_clipped_edge(scanline, x, e, x1, yb, x3, y3);
					}
					else if (x0 < x2 && x3 > x2) {  /* two segments across x+1, down-right */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x2, y2);
						nk_tt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else if (x3 < x2 && x0 > x2) {  /* two segments across x+1, down-left */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x2, y2);
						nk_tt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else {  /* one segment */
						nk_tt__handle_clipped_edge(scanline, x, e, x0, ya, x3, y3);
					}
				}
			}
		}
		e = e->next;
	}
}
NK_INTERN void
nk_tt__rasterize_sorted_edges(struct nk_tt__bitmap* result, struct nk_tt__edge* e,
	int n, int vsubsample, int off_x, int off_y, struct nk_allocator* alloc)
{
	/* directly AA rasterize edges w/o supersampling */
	struct nk_tt__hheap hh;
	struct nk_tt__active_edge* active = 0;
	int y, j = 0, i;
	float scanline_data[129], * scanline, * scanline2;

	NK_UNUSED(vsubsample);
	nk_zero_struct(hh);
	hh.alloc = *alloc;

	if (result->w > 64)
		scanline = (float*)alloc->alloc(alloc->userdata, 0, (nk_size)(result->w * 2 + 1) * sizeof(float));
	else scanline = scanline_data;

	scanline2 = scanline + result->w;
	y = off_y;
	e[n].y0 = (float)(off_y + result->h) + 1;

	while (j < result->h)
	{
		/* find center of pixel for this scanline */
		float scan_y_top = (float)y + 0.0f;
		float scan_y_bottom = (float)y + 1.0f;
		struct nk_tt__active_edge** step = &active;

		NK_MEMSET(scanline, 0, (nk_size)result->w * sizeof(scanline[0]));
		NK_MEMSET(scanline2, 0, (nk_size)(result->w + 1) * sizeof(scanline[0]));

		/* update all active edges; */
		/* remove all active edges that terminate before the top of this scanline */
		while (*step) {
			struct nk_tt__active_edge* z = *step;
			if (z->ey <= scan_y_top) {
				*step = z->next; /* delete from list */
				NK_ASSERT(z->direction);
				z->direction = 0;
				nk_tt__hheap_free(&hh, z);
			}
			else {
				step = &((*step)->next); /* advance through list */
			}
		}

		/* insert all edges that start before the bottom of this scanline */
		while (e->y0 <= scan_y_bottom) {
			if (e->y0 != e->y1) {
				struct nk_tt__active_edge* z = nk_tt__new_active(&hh, e, off_x, scan_y_top);
				if (z != 0) {
					NK_ASSERT(z->ey >= scan_y_top);
					/* insert at front */
					z->next = active;
					active = z;
				}
			}
			++e;
		}

		/* now process all active edges */
		if (active)
			nk_tt__fill_active_edges_new(scanline, scanline2 + 1, result->w, active, scan_y_top);

		{
			float sum = 0;
			for (i = 0; i < result->w; ++i) {
				float k;
				int m;
				sum += scanline2[i];
				k = scanline[i] + sum;
				k = (float)NK_ABS(k) * 255.0f + 0.5f;
				m = (int)k;
				if (m > 255) m = 255;
				result->pixels[j * result->stride + i] = (unsigned char)m;
			}
		}
		/* advance all the edges */
		step = &active;
		while (*step) {
			struct nk_tt__active_edge* z = *step;
			z->fx += z->fdx; /* advance to position for current scanline */
			step = &((*step)->next); /* advance through list */
		}
		++y;
		++j;
	}
	nk_tt__hheap_cleanup(&hh);
	if (scanline != scanline_data)
		alloc->free(alloc->userdata, scanline);
}
NK_INTERN void
nk_tt__sort_edges_ins_sort(struct nk_tt__edge* p, int n)
{
	int i, j;
#define NK_TT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
	for (i = 1; i < n; ++i) {
		struct nk_tt__edge t = p[i], * a = &t;
		j = i;
		while (j > 0) {
			struct nk_tt__edge* b = &p[j - 1];
			int c = NK_TT__COMPARE(a, b);
			if (!c) break;
			p[j] = p[j - 1];
			--j;
		}
		if (i != j)
			p[j] = t;
	}
}
NK_INTERN void
nk_tt__sort_edges_quicksort(struct nk_tt__edge* p, int n)
{
	/* threshold for transitioning to insertion sort */
	while (n > 12) {
		struct nk_tt__edge t;
		int c01, c12, c, m, i, j;

		/* compute median of three */
		m = n >> 1;
		c01 = NK_TT__COMPARE(&p[0], &p[m]);
		c12 = NK_TT__COMPARE(&p[m], &p[n - 1]);

		/* if 0 >= mid >= end, or 0 < mid < end, then use mid */
		if (c01 != c12) {
			/* otherwise, we'll need to swap something else to middle */
			int z;
			c = NK_TT__COMPARE(&p[0], &p[n - 1]);
			/* 0>mid && mid<n:  0>n => n; 0<n => 0 */
			/* 0<mid && mid>n:  0>n => 0; 0<n => n */
			z = (c == c12) ? 0 : n - 1;
			t = p[z];
			p[z] = p[m];
			p[m] = t;
		}

		/* now p[m] is the median-of-three */
		/* swap it to the beginning so it won't move around */
		t = p[0];
		p[0] = p[m];
		p[m] = t;

		/* partition loop */
		i = 1;
		j = n - 1;
		for (;;) {
			/* handling of equality is crucial here */
			/* for sentinels & efficiency with duplicates */
			for (;; ++i) {
				if (!NK_TT__COMPARE(&p[i], &p[0])) break;
			}
			for (;; --j) {
				if (!NK_TT__COMPARE(&p[0], &p[j])) break;
			}

			/* make sure we haven't crossed */
			if (i >= j) break;
			t = p[i];
			p[i] = p[j];
			p[j] = t;

			++i;
			--j;

		}

		/* recurse on smaller side, iterate on larger */
		if (j < (n - i)) {
			nk_tt__sort_edges_quicksort(p, j);
			p = p + i;
			n = n - i;
		}
		else {
			nk_tt__sort_edges_quicksort(p + i, n - i);
			n = j;
		}
	}
}
NK_INTERN void
nk_tt__sort_edges(struct nk_tt__edge* p, int n)
{
	nk_tt__sort_edges_quicksort(p, n);
	nk_tt__sort_edges_ins_sort(p, n);
}
NK_INTERN void
nk_tt__rasterize(struct nk_tt__bitmap* result, struct nk_tt__point* pts,
	int* wcount, int windings, float scale_x, float scale_y,
	float shift_x, float shift_y, int off_x, int off_y, int invert,
	struct nk_allocator* alloc)
{
	float y_scale_inv = invert ? -scale_y : scale_y;
	struct nk_tt__edge* e;
	int n, i, j, k, m;
	int vsubsample = 1;
	/* vsubsample should divide 255 evenly; otherwise we won't reach full opacity */

	/* now we have to blow out the windings into explicit edge lists */
	n = 0;
	for (i = 0; i < windings; ++i)
		n += wcount[i];

	e = (struct nk_tt__edge*)
		alloc->alloc(alloc->userdata, 0, (sizeof(*e) * (nk_size)(n + 1)));
	if (e == 0) return;
	n = 0;

	m = 0;
	for (i = 0; i < windings; ++i)
	{
		struct nk_tt__point* p = pts + m;
		m += wcount[i];
		j = wcount[i] - 1;
		for (k = 0; k < wcount[i]; j = k++) {
			int a = k, b = j;
			/* skip the edge if horizontal */
			if (p[j].y == p[k].y)
				continue;

			/* add edge from j to k to the list */
			e[n].invert = 0;
			if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
				e[n].invert = 1;
				a = j, b = k;
			}
			e[n].x0 = p[a].x * scale_x + shift_x;
			e[n].y0 = (p[a].y * y_scale_inv + shift_y) * (float)vsubsample;
			e[n].x1 = p[b].x * scale_x + shift_x;
			e[n].y1 = (p[b].y * y_scale_inv + shift_y) * (float)vsubsample;
			++n;
		}
	}

	/* now sort the edges by their highest point (should snap to integer, and then by x) */
	/*STBTT_sort(e, n, sizeof(e[0]), nk_tt__edge_compare); */
	nk_tt__sort_edges(e, n);
	/* now, traverse the scanlines and find the intersections on each scanline, use xor winding rule */
	nk_tt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, alloc);
	alloc->free(alloc->userdata, e);
}
NK_INTERN void
nk_tt__add_point(struct nk_tt__point* points, int n, float x, float y)
{
	if (!points) return; /* during first pass, it's unallocated */
	points[n].x = x;
	points[n].y = y;
}
NK_INTERN int
nk_tt__tesselate_curve(struct nk_tt__point* points, int* num_points,
	float x0, float y0, float x1, float y1, float x2, float y2,
	float objspace_flatness_squared, int n)
{
	/* tesselate until threshold p is happy...
	 * @TODO warped to compensate for non-linear stretching */
	 /* midpoint */
	float mx = (x0 + 2 * x1 + x2) / 4;
	float my = (y0 + 2 * y1 + y2) / 4;
	/* versus directly drawn line */
	float dx = (x0 + x2) / 2 - mx;
	float dy = (y0 + y2) / 2 - my;
	if (n > 16) /* 65536 segments on one curve better be enough! */
		return 1;

	/* half-pixel error allowed... need to be smaller if AA */
	if (dx * dx + dy * dy > objspace_flatness_squared) {
		nk_tt__tesselate_curve(points, num_points, x0, y0,
			(x0 + x1) / 2.0f, (y0 + y1) / 2.0f, mx, my, objspace_flatness_squared, n + 1);
		nk_tt__tesselate_curve(points, num_points, mx, my,
			(x1 + x2) / 2.0f, (y1 + y2) / 2.0f, x2, y2, objspace_flatness_squared, n + 1);
	}
	else {
		nk_tt__add_point(points, *num_points, x2, y2);
		*num_points = *num_points + 1;
	}
	return 1;
}
NK_INTERN struct nk_tt__point*
nk_tt_FlattenCurves(struct nk_tt_vertex* vertices, int num_verts,
	float objspace_flatness, int** contour_lengths, int* num_contours,
	struct nk_allocator* alloc)
{
	/* returns number of contours */
	struct nk_tt__point* points = 0;
	int num_points = 0;
	float objspace_flatness_squared = objspace_flatness * objspace_flatness;
	int i;
	int n = 0;
	int start = 0;
	int pass;

	/* count how many "moves" there are to get the contour count */
	for (i = 0; i < num_verts; ++i)
		if (vertices[i].type == NK_TT_vmove) ++n;

	*num_contours = n;
	if (n == 0) return 0;

	*contour_lengths = (int*)
		alloc->alloc(alloc->userdata, 0, (sizeof(**contour_lengths) * (nk_size)n));
	if (*contour_lengths == 0) {
		*num_contours = 0;
		return 0;
	}

	/* make two passes through the points so we don't need to realloc */
	for (pass = 0; pass < 2; ++pass)
	{
		float x = 0, y = 0;
		if (pass == 1) {
			points = (struct nk_tt__point*)
				alloc->alloc(alloc->userdata, 0, (nk_size)num_points * sizeof(points[0]));
			if (points == 0) goto error;
		}
		num_points = 0;
		n = -1;

		for (i = 0; i < num_verts; ++i)
		{
			switch (vertices[i].type) {
			case NK_TT_vmove:
				/* start the next contour */
				if (n >= 0)
					(*contour_lengths)[n] = num_points - start;
				++n;
				start = num_points;

				x = vertices[i].x, y = vertices[i].y;
				nk_tt__add_point(points, num_points++, x, y);
				break;
			case NK_TT_vline:
				x = vertices[i].x, y = vertices[i].y;
				nk_tt__add_point(points, num_points++, x, y);
				break;
			case NK_TT_vcurve:
				nk_tt__tesselate_curve(points, &num_points, x, y,
					vertices[i].cx, vertices[i].cy,
					vertices[i].x, vertices[i].y,
					objspace_flatness_squared, 0);
				x = vertices[i].x, y = vertices[i].y;
				break;
			default: break;
			}
		}
		(*contour_lengths)[n] = num_points - start;
	}
	return points;

error:
	alloc->free(alloc->userdata, points);
	alloc->free(alloc->userdata, *contour_lengths);
	*contour_lengths = 0;
	*num_contours = 0;
	return 0;
}
NK_INTERN void
nk_tt_Rasterize(struct nk_tt__bitmap* result, float flatness_in_pixels,
	struct nk_tt_vertex* vertices, int num_verts,
	float scale_x, float scale_y, float shift_x, float shift_y,
	int x_off, int y_off, int invert, struct nk_allocator* alloc)
{
	float scale = scale_x > scale_y ? scale_y : scale_x;
	int winding_count, * winding_lengths;
	struct nk_tt__point* windings = nk_tt_FlattenCurves(vertices, num_verts,
		flatness_in_pixels / scale, &winding_lengths, &winding_count, alloc);

	NK_ASSERT(alloc);
	if (windings) {
		nk_tt__rasterize(result, windings, winding_lengths, winding_count,
			scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, alloc);
		alloc->free(alloc->userdata, winding_lengths);
		alloc->free(alloc->userdata, windings);
	}
}
NK_INTERN void
nk_tt_MakeGlyphBitmapSubpixel(const struct nk_tt_fontinfo* info, unsigned char* output,
	int out_w, int out_h, int out_stride, float scale_x, float scale_y,
	float shift_x, float shift_y, int glyph, struct nk_allocator* alloc)
{
	int ix0, iy0;
	struct nk_tt_vertex* vertices;
	int num_verts = nk_tt_GetGlyphShape(info, alloc, glyph, &vertices);
	struct nk_tt__bitmap gbm;

	nk_tt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x,
		shift_y, &ix0, &iy0, 0, 0);
	gbm.pixels = output;
	gbm.w = out_w;
	gbm.h = out_h;
	gbm.stride = out_stride;

	if (gbm.w && gbm.h)
		nk_tt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y,
			shift_x, shift_y, ix0, iy0, 1, alloc);
	alloc->free(alloc->userdata, vertices);
}

/*-------------------------------------------------------------
 *                          Bitmap baking
 * --------------------------------------------------------------*/
NK_INTERN int
nk_tt_PackBegin(struct nk_tt_pack_context* spc, unsigned char* pixels,
	int pw, int ph, int stride_in_bytes, int padding, struct nk_allocator* alloc)
{
	int num_nodes = pw - padding;
	struct nk_rp_context* context = (struct nk_rp_context*)
		alloc->alloc(alloc->userdata, 0, sizeof(*context));
	struct nk_rp_node* nodes = (struct nk_rp_node*)
		alloc->alloc(alloc->userdata, 0, (sizeof(*nodes) * (nk_size)num_nodes));

	if (context == 0 || nodes == 0) {
		if (context != 0) alloc->free(alloc->userdata, context);
		if (nodes != 0) alloc->free(alloc->userdata, nodes);
		return 0;
	}

	spc->width = pw;
	spc->height = ph;
	spc->pixels = pixels;
	spc->pack_info = context;
	spc->nodes = nodes;
	spc->padding = padding;
	spc->stride_in_bytes = (stride_in_bytes != 0) ? stride_in_bytes : pw;
	spc->h_oversample = 1;
	spc->v_oversample = 1;

	nk_rp_init_target(context, pw - padding, ph - padding, nodes, num_nodes);
	if (pixels)
		NK_MEMSET(pixels, 0, (nk_size)(pw * ph)); /* background of 0 around pixels */
	return 1;
}
NK_INTERN void
nk_tt_PackEnd(struct nk_tt_pack_context* spc, struct nk_allocator* alloc)
{
	alloc->free(alloc->userdata, spc->nodes);
	alloc->free(alloc->userdata, spc->pack_info);
}
NK_INTERN void
nk_tt_PackSetOversampling(struct nk_tt_pack_context* spc,
	unsigned int h_oversample, unsigned int v_oversample)
{
	NK_ASSERT(h_oversample <= NK_TT_MAX_OVERSAMPLE);
	NK_ASSERT(v_oversample <= NK_TT_MAX_OVERSAMPLE);
	if (h_oversample <= NK_TT_MAX_OVERSAMPLE)
		spc->h_oversample = h_oversample;
	if (v_oversample <= NK_TT_MAX_OVERSAMPLE)
		spc->v_oversample = v_oversample;
}
NK_INTERN void
nk_tt__h_prefilter(unsigned char* pixels, int w, int h, int stride_in_bytes,
	int kernel_width)
{
	unsigned char buffer[NK_TT_MAX_OVERSAMPLE];
	int safe_w = w - kernel_width;
	int j;

	for (j = 0; j < h; ++j)
	{
		int i;
		unsigned int total;
		NK_MEMSET(buffer, 0, (nk_size)kernel_width);

		total = 0;

		/* make kernel_width a constant in common cases so compiler can optimize out the divide */
		switch (kernel_width) {
		case 2:
			for (i = 0; i <= safe_w; ++i) {
				total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 2);
			}
			break;
		case 3:
			for (i = 0; i <= safe_w; ++i) {
				total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 3);
			}
			break;
		case 4:
			for (i = 0; i <= safe_w; ++i) {
				total += (unsigned int)pixels[i] - buffer[i & NK_TT__OVER_MASK];
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 4);
			}
			break;
		case 5:
			for (i = 0; i <= safe_w; ++i) {
				total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 5);
			}
			break;
		default:
			for (i = 0; i <= safe_w; ++i) {
				total += (unsigned int)(pixels[i] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / (unsigned int)kernel_width);
			}
			break;
		}

		for (; i < w; ++i) {
			NK_ASSERT(pixels[i] == 0);
			total -= (unsigned int)(buffer[i & NK_TT__OVER_MASK]);
			pixels[i] = (unsigned char)(total / (unsigned int)kernel_width);
		}
		pixels += stride_in_bytes;
	}
}
NK_INTERN void
nk_tt__v_prefilter(unsigned char* pixels, int w, int h, int stride_in_bytes,
	int kernel_width)
{
	unsigned char buffer[NK_TT_MAX_OVERSAMPLE];
	int safe_h = h - kernel_width;
	int j;

	for (j = 0; j < w; ++j)
	{
		int i;
		unsigned int total;
		NK_MEMSET(buffer, 0, (nk_size)kernel_width);

		total = 0;

		/* make kernel_width a constant in common cases so compiler can optimize out the divide */
		switch (kernel_width) {
		case 2:
			for (i = 0; i <= safe_h; ++i) {
				total += (unsigned int)(pixels[i * stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 2);
			}
			break;
		case 3:
			for (i = 0; i <= safe_h; ++i) {
				total += (unsigned int)(pixels[i * stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 3);
			}
			break;
		case 4:
			for (i = 0; i <= safe_h; ++i) {
				total += (unsigned int)(pixels[i * stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 4);
			}
			break;
		case 5:
			for (i = 0; i <= safe_h; ++i) {
				total += (unsigned int)(pixels[i * stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 5);
			}
			break;
		default:
			for (i = 0; i <= safe_h; ++i) {
				total += (unsigned int)(pixels[i * stride_in_bytes] - buffer[i & NK_TT__OVER_MASK]);
				buffer[(i + kernel_width) & NK_TT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / (unsigned int)kernel_width);
			}
			break;
		}

		for (; i < h; ++i) {
			NK_ASSERT(pixels[i * stride_in_bytes] == 0);
			total -= (unsigned int)(buffer[i & NK_TT__OVER_MASK]);
			pixels[i * stride_in_bytes] = (unsigned char)(total / (unsigned int)kernel_width);
		}
		pixels += 1;
	}
}
NK_INTERN float
nk_tt__oversample_shift(int oversample)
{
	if (!oversample)
		return 0.0f;

	/* The prefilter is a box filter of width "oversample", */
	/* which shifts phase by (oversample - 1)/2 pixels in */
	/* oversampled space. We want to shift in the opposite */
	/* direction to counter this. */
	return (float)-(oversample - 1) / (2.0f * (float)oversample);
}
NK_INTERN int
nk_tt_PackFontRangesGatherRects(struct nk_tt_pack_context* spc,
	struct nk_tt_fontinfo* info, struct nk_tt_pack_range* ranges,
	int num_ranges, struct nk_rp_rect* rects)
{
	/* rects array must be big enough to accommodate all characters in the given ranges */
	int i, j, k;
	k = 0;

	for (i = 0; i < num_ranges; ++i) {
		float fh = ranges[i].font_size;
		float scale = (fh > 0) ? nk_tt_ScaleForPixelHeight(info, fh) :
			nk_tt_ScaleForMappingEmToPixels(info, -fh);
		ranges[i].h_oversample = (unsigned char)spc->h_oversample;
		ranges[i].v_oversample = (unsigned char)spc->v_oversample;
		for (j = 0; j < ranges[i].num_chars; ++j) {
			int x0, y0, x1, y1;
			int codepoint = ranges[i].first_unicode_codepoint_in_range ?
				ranges[i].first_unicode_codepoint_in_range + j :
				ranges[i].array_of_unicode_codepoints[j];

			int glyph = nk_tt_FindGlyphIndex(info, codepoint);
			nk_tt_GetGlyphBitmapBoxSubpixel(info, glyph, scale * (float)spc->h_oversample,
				scale * (float)spc->v_oversample, 0, 0, &x0, &y0, &x1, &y1);
			rects[k].w = (nk_rp_coord)(x1 - x0 + spc->padding + (int)spc->h_oversample - 1);
			rects[k].h = (nk_rp_coord)(y1 - y0 + spc->padding + (int)spc->v_oversample - 1);
			++k;
		}
	}
	return k;
}
NK_INTERN int
nk_tt_PackFontRangesRenderIntoRects(struct nk_tt_pack_context* spc,
	struct nk_tt_fontinfo* info, struct nk_tt_pack_range* ranges,
	int num_ranges, struct nk_rp_rect* rects, struct nk_allocator* alloc)
{
	int i, j, k, return_value = 1;
	/* save current values */
	int old_h_over = (int)spc->h_oversample;
	int old_v_over = (int)spc->v_oversample;
	/* rects array must be big enough to accommodate all characters in the given ranges */

	k = 0;
	for (i = 0; i < num_ranges; ++i)
	{
		float fh = ranges[i].font_size;
		float recip_h, recip_v, sub_x, sub_y;
		float scale = fh > 0 ? nk_tt_ScaleForPixelHeight(info, fh) :
			nk_tt_ScaleForMappingEmToPixels(info, -fh);

		spc->h_oversample = ranges[i].h_oversample;
		spc->v_oversample = ranges[i].v_oversample;

		recip_h = 1.0f / (float)spc->h_oversample;
		recip_v = 1.0f / (float)spc->v_oversample;

		sub_x = nk_tt__oversample_shift((int)spc->h_oversample);
		sub_y = nk_tt__oversample_shift((int)spc->v_oversample);

		for (j = 0; j < ranges[i].num_chars; ++j)
		{
			struct nk_rp_rect* r = &rects[k];
			if (r->was_packed)
			{
				struct nk_tt_packedchar* bc = &ranges[i].chardata_for_range[j];
				int advance, lsb, x0, y0, x1, y1;
				int codepoint = ranges[i].first_unicode_codepoint_in_range ?
					ranges[i].first_unicode_codepoint_in_range + j :
					ranges[i].array_of_unicode_codepoints[j];
				int glyph = nk_tt_FindGlyphIndex(info, codepoint);
				nk_rp_coord pad = (nk_rp_coord)spc->padding;

				/* pad on left and top */
				r->x = (nk_rp_coord)((int)r->x + (int)pad);
				r->y = (nk_rp_coord)((int)r->y + (int)pad);
				r->w = (nk_rp_coord)((int)r->w - (int)pad);
				r->h = (nk_rp_coord)((int)r->h - (int)pad);

				nk_tt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
				nk_tt_GetGlyphBitmapBox(info, glyph, scale * (float)spc->h_oversample,
					(scale * (float)spc->v_oversample), &x0, &y0, &x1, &y1);
				nk_tt_MakeGlyphBitmapSubpixel(info, spc->pixels + r->x + r->y * spc->stride_in_bytes,
					(int)(r->w - spc->h_oversample + 1), (int)(r->h - spc->v_oversample + 1),
					spc->stride_in_bytes, scale * (float)spc->h_oversample,
					scale * (float)spc->v_oversample, 0, 0, glyph, alloc);

				if (spc->h_oversample > 1)
					nk_tt__h_prefilter(spc->pixels + r->x + r->y * spc->stride_in_bytes,
						r->w, r->h, spc->stride_in_bytes, (int)spc->h_oversample);

				if (spc->v_oversample > 1)
					nk_tt__v_prefilter(spc->pixels + r->x + r->y * spc->stride_in_bytes,
						r->w, r->h, spc->stride_in_bytes, (int)spc->v_oversample);

				bc->x0 = (nk_ushort)r->x;
				bc->y0 = (nk_ushort)r->y;
				bc->x1 = (nk_ushort)(r->x + r->w);
				bc->y1 = (nk_ushort)(r->y + r->h);
				bc->xadvance = scale * (float)advance;
				bc->xoff = (float)x0 * recip_h + sub_x;
				bc->yoff = (float)y0 * recip_v + sub_y;
				bc->xoff2 = ((float)x0 + r->w) * recip_h + sub_x;
				bc->yoff2 = ((float)y0 + r->h) * recip_v + sub_y;
			}
			else {
				return_value = 0; /* if any fail, report failure */
			}
			++k;
		}
	}
	/* restore original values */
	spc->h_oversample = (unsigned int)old_h_over;
	spc->v_oversample = (unsigned int)old_v_over;
	return return_value;
}
NK_INTERN void
nk_tt_GetPackedQuad(struct nk_tt_packedchar* chardata, int pw, int ph,
	int char_index, float* xpos, float* ypos, struct nk_tt_aligned_quad* q,
	int align_to_integer)
{
	float ipw = 1.0f / (float)pw, iph = 1.0f / (float)ph;
	struct nk_tt_packedchar* b = (struct nk_tt_packedchar*)(chardata + char_index);
	if (align_to_integer) {
		int tx = nk_ifloorf((*xpos + b->xoff) + 0.5f);
		int ty = nk_ifloorf((*ypos + b->yoff) + 0.5f);

		float x = (float)tx;
		float y = (float)ty;

		q->x0 = x;
		q->y0 = y;
		q->x1 = x + b->xoff2 - b->xoff;
		q->y1 = y + b->yoff2 - b->yoff;
	}
	else {
		q->x0 = *xpos + b->xoff;
		q->y0 = *ypos + b->yoff;
		q->x1 = *xpos + b->xoff2;
		q->y1 = *ypos + b->yoff2;
	}
	q->s0 = b->x0 * ipw;
	q->t0 = b->y0 * iph;
	q->s1 = b->x1 * ipw;
	q->t1 = b->y1 * iph;
	*xpos += b->xadvance;
}

/* -------------------------------------------------------------
 *
 *                          FONT BAKING
 *
 * --------------------------------------------------------------*/
struct nk_font_bake_data {
	struct nk_tt_fontinfo info;
	struct nk_rp_rect* rects;
	struct nk_tt_pack_range* ranges;
	nk_rune range_count;
};

struct nk_font_baker {
	struct nk_allocator alloc;
	struct nk_tt_pack_context spc;
	struct nk_font_bake_data* build;
	struct nk_tt_packedchar* packed_chars;
	struct nk_rp_rect* rects;
	struct nk_tt_pack_range* ranges;
};

NK_GLOBAL const nk_size nk_rect_align = NK_ALIGNOF(struct nk_rp_rect);
NK_GLOBAL const nk_size nk_range_align = NK_ALIGNOF(struct nk_tt_pack_range);
NK_GLOBAL const nk_size nk_char_align = NK_ALIGNOF(struct nk_tt_packedchar);
NK_GLOBAL const nk_size nk_build_align = NK_ALIGNOF(struct nk_font_bake_data);
NK_GLOBAL const nk_size nk_baker_align = NK_ALIGNOF(struct nk_font_baker);

NK_INTERN int
nk_range_count(const nk_rune* range)
{
	const nk_rune* iter = range;
	NK_ASSERT(range);
	if (!range) return 0;
	while (*(iter++) != 0);
	return (iter == range) ? 0 : (int)((iter - range) / 2);
}
NK_INTERN int
nk_range_glyph_count(const nk_rune* range, int count)
{
	int i = 0;
	int total_glyphs = 0;
	for (i = 0; i < count; ++i) {
		int diff;
		nk_rune f = range[(i * 2) + 0];
		nk_rune t = range[(i * 2) + 1];
		NK_ASSERT(t >= f);
		diff = (int)((t - f) + 1);
		total_glyphs += diff;
	}
	return total_glyphs;
}
NK_API const nk_rune*
nk_font_default_glyph_ranges(void)
{
	NK_STORAGE const nk_rune ranges[] = { 0x0020, 0x00FF, 0 };
	return ranges;
}
NK_API const nk_rune*
nk_font_chinese_glyph_ranges(void)
{
	NK_STORAGE const nk_rune ranges[] = {
		0x0020, 0x00FF,
		0x3000, 0x30FF,
		0x31F0, 0x31FF,
		0xFF00, 0xFFEF,
		0x4e00, 0x9FAF,
		0
	};
	return ranges;
}
NK_API const nk_rune*
nk_font_cyrillic_glyph_ranges(void)
{
	NK_STORAGE const nk_rune ranges[] = {
		0x0020, 0x00FF,
		0x0400, 0x052F,
		0x2DE0, 0x2DFF,
		0xA640, 0xA69F,
		0
	};
	return ranges;
}
NK_API const nk_rune*
nk_font_korean_glyph_ranges(void)
{
	NK_STORAGE const nk_rune ranges[] = {
		0x0020, 0x00FF,
		0x3131, 0x3163,
		0xAC00, 0xD79D,
		0
	};
	return ranges;
}
NK_INTERN void
nk_font_baker_memory(nk_size* temp, int* glyph_count,
	struct nk_font_config* config_list, int count)
{
	int range_count = 0;
	int total_range_count = 0;
	struct nk_font_config* iter, * i;

	NK_ASSERT(config_list);
	NK_ASSERT(glyph_count);
	if (!config_list) {
		*temp = 0;
		*glyph_count = 0;
		return;
	}
	*glyph_count = 0;
	for (iter = config_list; iter; iter = iter->next) {
		i = iter;
		do {
			if (!i->range) iter->range = nk_font_default_glyph_ranges();
			range_count = nk_range_count(i->range);
			total_range_count += range_count;
			*glyph_count += nk_range_glyph_count(i->range, range_count);
		} while ((i = i->n) != iter);
	}
	*temp = (nk_size)*glyph_count * sizeof(struct nk_rp_rect);
	*temp += (nk_size)total_range_count * sizeof(struct nk_tt_pack_range);
	*temp += (nk_size)*glyph_count * sizeof(struct nk_tt_packedchar);
	*temp += (nk_size)count * sizeof(struct nk_font_bake_data);
	*temp += sizeof(struct nk_font_baker);
	*temp += nk_rect_align + nk_range_align + nk_char_align;
	*temp += nk_build_align + nk_baker_align;
}
NK_INTERN struct nk_font_baker*
nk_font_baker(void* memory, int glyph_count, int count, struct nk_allocator* alloc)
{
	struct nk_font_baker* baker;
	if (!memory) return 0;
	/* setup baker inside a memory block  */
	baker = (struct nk_font_baker*)NK_ALIGN_PTR(memory, nk_baker_align);
	baker->build = (struct nk_font_bake_data*)NK_ALIGN_PTR((baker + 1), nk_build_align);
	baker->packed_chars = (struct nk_tt_packedchar*)NK_ALIGN_PTR((baker->build + count), nk_char_align);
	baker->rects = (struct nk_rp_rect*)NK_ALIGN_PTR((baker->packed_chars + glyph_count), nk_rect_align);
	baker->ranges = (struct nk_tt_pack_range*)NK_ALIGN_PTR((baker->rects + glyph_count), nk_range_align);
	baker->alloc = *alloc;
	return baker;
}
NK_INTERN int
nk_font_bake_pack(struct nk_font_baker* baker,
	nk_size* image_memory, int* width, int* height, struct nk_recti* custom,
	const struct nk_font_config* config_list, int count,
	struct nk_allocator* alloc)
{
	NK_STORAGE const nk_size max_height = 1024 * 32;
	const struct nk_font_config* config_iter, * it;
	int total_glyph_count = 0;
	int total_range_count = 0;
	int range_count = 0;
	int i = 0;

	NK_ASSERT(image_memory);
	NK_ASSERT(width);
	NK_ASSERT(height);
	NK_ASSERT(config_list);
	NK_ASSERT(count);
	NK_ASSERT(alloc);

	if (!image_memory || !width || !height || !config_list || !count) return nk_false;
	for (config_iter = config_list; config_iter; config_iter = config_iter->next) {
		it = config_iter;
		do {
			range_count = nk_range_count(it->range);
			total_range_count += range_count;
			total_glyph_count += nk_range_glyph_count(it->range, range_count);
		} while ((it = it->n) != config_iter);
	}
	/* setup font baker from temporary memory */
	for (config_iter = config_list; config_iter; config_iter = config_iter->next) {
		it = config_iter;
		do {
			if (!nk_tt_InitFont(&baker->build[i++].info, (const unsigned char*)it->ttf_blob, 0))
				return nk_false;
		} while ((it = it->n) != config_iter);
	}
	*height = 0;
	*width = (total_glyph_count > 1000) ? 1024 : 512;
	nk_tt_PackBegin(&baker->spc, 0, (int)*width, (int)max_height, 0, 1, alloc);
	{
		int input_i = 0;
		int range_n = 0;
		int rect_n = 0;
		int char_n = 0;

		if (custom) {
			/* pack custom user data first so it will be in the upper left corner*/
			struct nk_rp_rect custom_space;
			nk_zero(&custom_space, sizeof(custom_space));
			custom_space.w = (nk_rp_coord)(custom->w);
			custom_space.h = (nk_rp_coord)(custom->h);

			nk_tt_PackSetOversampling(&baker->spc, 1, 1);
			nk_rp_pack_rects((struct nk_rp_context*)baker->spc.pack_info, &custom_space, 1);
			*height = NK_MAX(*height, (int)(custom_space.y + custom_space.h));

			custom->x = (short)custom_space.x;
			custom->y = (short)custom_space.y;
			custom->w = (short)custom_space.w;
			custom->h = (short)custom_space.h;
		}

		/* first font pass: pack all glyphs */
		for (input_i = 0, config_iter = config_list; input_i < count && config_iter;
			config_iter = config_iter->next) {
			it = config_iter;
			do {
				int n = 0;
				int glyph_count;
				const nk_rune* in_range;
				const struct nk_font_config* cfg = it;
				struct nk_font_bake_data* tmp = &baker->build[input_i++];

				/* count glyphs + ranges in current font */
				glyph_count = 0; range_count = 0;
				for (in_range = cfg->range; in_range[0] && in_range[1]; in_range += 2) {
					glyph_count += (int)(in_range[1] - in_range[0]) + 1;
					range_count++;
				}

				/* setup ranges  */
				tmp->ranges = baker->ranges + range_n;
				tmp->range_count = (nk_rune)range_count;
				range_n += range_count;
				for (i = 0; i < range_count; ++i) {
					in_range = &cfg->range[i * 2];
					tmp->ranges[i].font_size = cfg->size;
					tmp->ranges[i].first_unicode_codepoint_in_range = (int)in_range[0];
					tmp->ranges[i].num_chars = (int)(in_range[1] - in_range[0]) + 1;
					tmp->ranges[i].chardata_for_range = baker->packed_chars + char_n;
					char_n += tmp->ranges[i].num_chars;
				}

				/* pack */
				tmp->rects = baker->rects + rect_n;
				rect_n += glyph_count;
				nk_tt_PackSetOversampling(&baker->spc, cfg->oversample_h, cfg->oversample_v);
				n = nk_tt_PackFontRangesGatherRects(&baker->spc, &tmp->info,
					tmp->ranges, (int)tmp->range_count, tmp->rects);
				nk_rp_pack_rects((struct nk_rp_context*)baker->spc.pack_info, tmp->rects, (int)n);

				/* texture height */
				for (i = 0; i < n; ++i) {
					if (tmp->rects[i].was_packed)
						*height = NK_MAX(*height, tmp->rects[i].y + tmp->rects[i].h);
				}
			} while ((it = it->n) != config_iter);
		}
		NK_ASSERT(rect_n == total_glyph_count);
		NK_ASSERT(char_n == total_glyph_count);
		NK_ASSERT(range_n == total_range_count);
	}
	*height = (int)nk_round_up_pow2((nk_uint)*height);
	*image_memory = (nk_size)(*width) * (nk_size)(*height);
	return nk_true;
}
NK_INTERN void
nk_font_bake(struct nk_font_baker* baker, void* image_memory, int width, int height,
	struct nk_font_glyph* glyphs, int glyphs_count,
	const struct nk_font_config* config_list, int font_count)
{
	int input_i = 0;
	nk_rune glyph_n = 0;
	const struct nk_font_config* config_iter;
	const struct nk_font_config* it;

	NK_ASSERT(image_memory);
	NK_ASSERT(width);
	NK_ASSERT(height);
	NK_ASSERT(config_list);
	NK_ASSERT(baker);
	NK_ASSERT(font_count);
	NK_ASSERT(glyphs_count);
	if (!image_memory || !width || !height || !config_list ||
		!font_count || !glyphs || !glyphs_count)
		return;

	/* second font pass: render glyphs */
	nk_zero(image_memory, (nk_size)((nk_size)width * (nk_size)height));
	baker->spc.pixels = (unsigned char*)image_memory;
	baker->spc.height = (int)height;
	for (input_i = 0, config_iter = config_list; input_i < font_count && config_iter;
		config_iter = config_iter->next) {
		it = config_iter;
		do {
			const struct nk_font_config* cfg = it;
			struct nk_font_bake_data* tmp = &baker->build[input_i++];
			nk_tt_PackSetOversampling(&baker->spc, cfg->oversample_h, cfg->oversample_v);
			nk_tt_PackFontRangesRenderIntoRects(&baker->spc, &tmp->info, tmp->ranges,
				(int)tmp->range_count, tmp->rects, &baker->alloc);
		} while ((it = it->n) != config_iter);
	} nk_tt_PackEnd(&baker->spc, &baker->alloc);

	/* third pass: setup font and glyphs */
	for (input_i = 0, config_iter = config_list; input_i < font_count && config_iter;
		config_iter = config_iter->next) {
		it = config_iter;
		do {
			nk_size i = 0;
			int char_idx = 0;
			nk_rune glyph_count = 0;
			const struct nk_font_config* cfg = it;
			struct nk_font_bake_data* tmp = &baker->build[input_i++];
			struct nk_baked_font* dst_font = cfg->font;

			float font_scale = nk_tt_ScaleForPixelHeight(&tmp->info, cfg->size);
			int unscaled_ascent, unscaled_descent, unscaled_line_gap;
			nk_tt_GetFontVMetrics(&tmp->info, &unscaled_ascent, &unscaled_descent,
				&unscaled_line_gap);

			/* fill baked font */
			if (!cfg->merge_mode) {
				dst_font->ranges = cfg->range;
				dst_font->height = cfg->size;
				dst_font->ascent = ((float)unscaled_ascent * font_scale);
				dst_font->descent = ((float)unscaled_descent * font_scale);
				dst_font->glyph_offset = glyph_n;
			}

			/* fill own baked font glyph array */
			for (i = 0; i < tmp->range_count; ++i) {
				struct nk_tt_pack_range* range = &tmp->ranges[i];
				for (char_idx = 0; char_idx < range->num_chars; char_idx++)
				{
					nk_rune codepoint = 0;
					float dummy_x = 0, dummy_y = 0;
					struct nk_tt_aligned_quad q;
					struct nk_font_glyph* glyph;

					/* query glyph bounds from stb_truetype */
					const struct nk_tt_packedchar* pc = &range->chardata_for_range[char_idx];
					if (!pc->x0 && !pc->x1 && !pc->y0 && !pc->y1) continue;
					codepoint = (nk_rune)(range->first_unicode_codepoint_in_range + char_idx);
					nk_tt_GetPackedQuad(range->chardata_for_range, (int)width,
						(int)height, char_idx, &dummy_x, &dummy_y, &q, 0);

					/* fill own glyph type with data */
					glyph = &glyphs[dst_font->glyph_offset + dst_font->glyph_count + (unsigned int)glyph_count];
					glyph->codepoint = codepoint;
					glyph->x0 = q.x0; glyph->y0 = q.y0;
					glyph->x1 = q.x1; glyph->y1 = q.y1;
					glyph->y0 += (dst_font->ascent + 0.5f);
					glyph->y1 += (dst_font->ascent + 0.5f);
					glyph->w = glyph->x1 - glyph->x0 + 0.5f;
					glyph->h = glyph->y1 - glyph->y0;

					if (cfg->coord_type == NK_COORD_PIXEL) {
						glyph->u0 = q.s0 * (float)width;
						glyph->v0 = q.t0 * (float)height;
						glyph->u1 = q.s1 * (float)width;
						glyph->v1 = q.t1 * (float)height;
					}
					else {
						glyph->u0 = q.s0;
						glyph->v0 = q.t0;
						glyph->u1 = q.s1;
						glyph->v1 = q.t1;
					}
					glyph->xadvance = (pc->xadvance + cfg->spacing.x);
					if (cfg->pixel_snap)
						glyph->xadvance = (float)(int)(glyph->xadvance + 0.5f);
					glyph_count++;
				}
			}
			dst_font->glyph_count += glyph_count;
			glyph_n += glyph_count;
		} while ((it = it->n) != config_iter);
	}
}
NK_INTERN void
nk_font_bake_custom_data(void* img_memory, int img_width, int img_height,
	struct nk_recti img_dst, const char* texture_data_mask, int tex_width,
	int tex_height, char white, char black)
{
	nk_byte* pixels;
	int y = 0;
	int x = 0;
	int n = 0;

	NK_ASSERT(img_memory);
	NK_ASSERT(img_width);
	NK_ASSERT(img_height);
	NK_ASSERT(texture_data_mask);
	NK_UNUSED(tex_height);
	if (!img_memory || !img_width || !img_height || !texture_data_mask)
		return;

	pixels = (nk_byte*)img_memory;
	for (y = 0, n = 0; y < tex_height; ++y) {
		for (x = 0; x < tex_width; ++x, ++n) {
			const int off0 = ((img_dst.x + x) + (img_dst.y + y) * img_width);
			const int off1 = off0 + 1 + tex_width;
			pixels[off0] = (texture_data_mask[n] == white) ? 0xFF : 0x00;
			pixels[off1] = (texture_data_mask[n] == black) ? 0xFF : 0x00;
		}
	}
}
NK_INTERN void
nk_font_bake_convert(void* out_memory, int img_width, int img_height,
	const void* in_memory)
{
	int n = 0;
	nk_rune* dst;
	const nk_byte* src;

	NK_ASSERT(out_memory);
	NK_ASSERT(in_memory);
	NK_ASSERT(img_width);
	NK_ASSERT(img_height);
	if (!out_memory || !in_memory || !img_height || !img_width) return;

	dst = (nk_rune*)out_memory;
	src = (const nk_byte*)in_memory;
	for (n = (int)(img_width * img_height); n > 0; n--)
		*dst++ = ((nk_rune)(*src++) << 24) | 0x00FFFFFF;
}

/* -------------------------------------------------------------
 *
 *                          FONT
 *
 * --------------------------------------------------------------*/
NK_INTERN float
nk_font_text_width(nk_handle handle, float height, const char* text, int len)
{
	nk_rune unicode;
	int text_len = 0;
	float text_width = 0;
	int glyph_len = 0;
	float scale = 0;

	struct nk_font* font = (struct nk_font*)handle.ptr;
	NK_ASSERT(font);
	NK_ASSERT(font->glyphs);
	if (!font || !text || !len)
		return 0;

	scale = height / font->info.height;
	glyph_len = text_len = nk_utf_decode(text, &unicode, (int)len);
	if (!glyph_len) return 0;
	while (text_len <= (int)len && glyph_len) {
		const struct nk_font_glyph* g;
		if (unicode == NK_UTF_INVALID) break;

		/* query currently drawn glyph information */
		g = nk_font_find_glyph(font, unicode);
		text_width += g->xadvance * scale;

		/* offset next glyph */
		glyph_len = nk_utf_decode(text + text_len, &unicode, (int)len - text_len);
		text_len += glyph_len;
	}
	return text_width;
}
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
NK_INTERN void
nk_font_query_font_glyph(nk_handle handle, float height,
	struct nk_user_font_glyph* glyph, nk_rune codepoint, nk_rune next_codepoint)
{
	float scale;
	const struct nk_font_glyph* g;
	struct nk_font* font;

	NK_ASSERT(glyph);
	NK_UNUSED(next_codepoint);

	font = (struct nk_font*)handle.ptr;
	NK_ASSERT(font);
	NK_ASSERT(font->glyphs);
	if (!font || !glyph)
		return;

	scale = height / font->info.height;
	g = nk_font_find_glyph(font, codepoint);
	glyph->width = (g->x1 - g->x0) * scale;
	glyph->height = (g->y1 - g->y0) * scale;
	glyph->offset = nk_vec2(g->x0 * scale, g->y0 * scale);
	glyph->xadvance = (g->xadvance * scale);
	glyph->uv[0] = nk_vec2(g->u0, g->v0);
	glyph->uv[1] = nk_vec2(g->u1, g->v1);
}
#endif
NK_API const struct nk_font_glyph*
nk_font_find_glyph(struct nk_font* font, nk_rune unicode)
{
	int i = 0;
	int count;
	int total_glyphs = 0;
	const struct nk_font_glyph* glyph = 0;
	const struct nk_font_config* iter = 0;

	NK_ASSERT(font);
	NK_ASSERT(font->glyphs);
	NK_ASSERT(font->info.ranges);
	if (!font || !font->glyphs) return 0;

	glyph = font->fallback;
	iter = font->config;
	do {
		count = nk_range_count(iter->range);
		for (i = 0; i < count; ++i) {
			nk_rune f = iter->range[(i * 2) + 0];
			nk_rune t = iter->range[(i * 2) + 1];
			int diff = (int)((t - f) + 1);
			if (unicode >= f && unicode <= t)
				return &font->glyphs[((nk_rune)total_glyphs + (unicode - f))];
			total_glyphs += diff;
		}
	} while ((iter = iter->n) != font->config);
	return glyph;
}
NK_INTERN void
nk_font_init(struct nk_font* font, float pixel_height,
	nk_rune fallback_codepoint, struct nk_font_glyph* glyphs,
	const struct nk_baked_font* baked_font, nk_handle atlas)
{
	struct nk_baked_font baked;
	NK_ASSERT(font);
	NK_ASSERT(glyphs);
	NK_ASSERT(baked_font);
	if (!font || !glyphs || !baked_font)
		return;

	baked = *baked_font;
	font->fallback = 0;
	font->info = baked;
	font->scale = (float)pixel_height / (float)font->info.height;
	font->glyphs = &glyphs[baked_font->glyph_offset];
	font->texture = atlas;
	font->fallback_codepoint = fallback_codepoint;
	font->fallback = nk_font_find_glyph(font, fallback_codepoint);

	font->handle.height = font->info.height * font->scale;
	font->handle.width = nk_font_text_width;
	font->handle.userdata.ptr = font;
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
	font->handle.query = nk_font_query_font_glyph;
	font->handle.texture = font->texture;
#endif
}

/* ---------------------------------------------------------------------------
 *
 *                          DEFAULT FONT
 *
 * ProggyClean.ttf
 * Copyright (c) 2004, 2005 Tristan Grimmer
 * MIT license (see License.txt in http://www.upperbounds.net/download/ProggyClean.ttf.zip)
 * Download and more information at http://upperbounds.net
 *-----------------------------------------------------------------------------*/
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Woverlength-strings"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverlength-strings"
#endif

#ifdef NK_INCLUDE_DEFAULT_FONT

NK_GLOBAL const char nk_proggy_clean_ttf_compressed_data_base85[11980 + 1] =
"7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/"
"2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"
"`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"
"i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N"
"kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"
"*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"
"tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"
"ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc."
"x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"
"CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)"
"U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"
"'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"
"_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"
"Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"
"/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"
"%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"
"OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("
"h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"
"o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"
"j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"
"sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"
"eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"
"M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%"
"LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"
"%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"
"Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"
"a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("
"$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<"
"nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"
"7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;"
")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"
"D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("
"P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs"
"bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q"
"h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-"
"V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"
"sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7"
".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@"
"$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"
"hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u"
"@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"
"w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#"
"u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"
"d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"
"6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#"
"b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"
":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+"
"tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"
"$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"
":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"
"7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"
"u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT"
"LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M"
":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>"
"_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"
"hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"
"^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"
"+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%"
"9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"
"CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"
"hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"
"8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"
"S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"
"0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"
"+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"
"M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V"
"?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"
"Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"
">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"
"[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I"
"wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#"
"Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"
"MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"
"i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"
"1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"
"iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"
"URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"
";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"
"w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#"
"d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"
"A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
"/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"
"m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
"TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"
"GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
"O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";

#endif /* NK_INCLUDE_DEFAULT_FONT */

#define NK_CURSOR_DATA_W 90
#define NK_CURSOR_DATA_H 27
NK_GLOBAL const char nk_custom_cursor_data[NK_CURSOR_DATA_W * NK_CURSOR_DATA_H + 1] =
{
	"..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX"
	"..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X"
	"---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X"
	"X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X"
	"XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X"
	"X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X"
	"X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX"
	"X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      "
	"X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       "
	"X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        "
	"X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         "
	"X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          "
	"X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           "
	"X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            "
	"X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           "
	"X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          "
	"X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          "
	"X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       ------------------------------------"
	"X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           "
	"XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           "
	"      X..X          -  X...X  -         X...X         -  X..X           X..X  -           "
	"       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           "
	"------------        -    X    -           X           -X.....................X-           "
	"                    ----------------------------------- X...XXXXXXXXXXXXX...X -           "
	"                                                      -  X..X           X..X  -           "
	"                                                      -   X.X           X.X   -           "
	"                                                      -    XX           XX    -           "
};

#ifdef __clang__
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif

NK_GLOBAL unsigned char* nk__barrier;
NK_GLOBAL unsigned char* nk__barrier2;
NK_GLOBAL unsigned char* nk__barrier3;
NK_GLOBAL unsigned char* nk__barrier4;
NK_GLOBAL unsigned char* nk__dout;

NK_INTERN unsigned int
nk_decompress_length(unsigned char* input)
{
	return (unsigned int)((input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11]);
}
NK_INTERN void
nk__match(unsigned char* data, unsigned int length)
{
	/* INVERSE of memmove... write each byte before copying the next...*/
	NK_ASSERT(nk__dout + length <= nk__barrier);
	if (nk__dout + length > nk__barrier) { nk__dout += length; return; }
	if (data < nk__barrier4) { nk__dout = nk__barrier + 1; return; }
	while (length--)*nk__dout++ = *data++;
}
NK_INTERN void
nk__lit(unsigned char* data, unsigned int length)
{
	NK_ASSERT(nk__dout + length <= nk__barrier);
	if (nk__dout + length > nk__barrier) { nk__dout += length; return; }
	if (data < nk__barrier2) { nk__dout = nk__barrier + 1; return; }
	NK_MEMCPY(nk__dout, data, length);
	nk__dout += length;
}
NK_INTERN unsigned char*
nk_decompress_token(unsigned char* i)
{
#define nk__in2(x)   ((i[x] << 8) + i[(x)+1])
#define nk__in3(x)   ((i[x] << 16) + nk__in2((x)+1))
#define nk__in4(x)   ((i[x] << 24) + nk__in3((x)+1))

	if (*i >= 0x20) { /* use fewer if's for cases that expand small */
		if (*i >= 0x80)       nk__match(nk__dout - i[1] - 1, (unsigned int)i[0] - 0x80 + 1), i += 2;
		else if (*i >= 0x40)  nk__match(nk__dout - (nk__in2(0) - 0x4000 + 1), (unsigned int)i[2] + 1), i += 3;
		else /* *i >= 0x20 */ nk__lit(i + 1, (unsigned int)i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
	}
	else { /* more ifs for cases that expand large, since overhead is amortized */
		if (*i >= 0x18)       nk__match(nk__dout - (unsigned int)(nk__in3(0) - 0x180000 + 1), (unsigned int)i[3] + 1), i += 4;
		else if (*i >= 0x10)  nk__match(nk__dout - (unsigned int)(nk__in3(0) - 0x100000 + 1), (unsigned int)nk__in2(3) + 1), i += 5;
		else if (*i >= 0x08)  nk__lit(i + 2, (unsigned int)nk__in2(0) - 0x0800 + 1), i += 2 + (nk__in2(0) - 0x0800 + 1);
		else if (*i == 0x07)  nk__lit(i + 3, (unsigned int)nk__in2(1) + 1), i += 3 + (nk__in2(1) + 1);
		else if (*i == 0x06)  nk__match(nk__dout - (unsigned int)(nk__in3(1) + 1), i[4] + 1u), i += 5;
		else if (*i == 0x04)  nk__match(nk__dout - (unsigned int)(nk__in3(1) + 1), (unsigned int)nk__in2(4) + 1u), i += 6;
	}
	return i;
}
NK_INTERN unsigned int
nk_adler32(unsigned int adler32, unsigned char* buffer, unsigned int buflen)
{
	const unsigned long ADLER_MOD = 65521;
	unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
	unsigned long blocklen, i;

	blocklen = buflen % 5552;
	while (buflen) {
		for (i = 0; i + 7 < blocklen; i += 8) {
			s1 += buffer[0]; s2 += s1;
			s1 += buffer[1]; s2 += s1;
			s1 += buffer[2]; s2 += s1;
			s1 += buffer[3]; s2 += s1;
			s1 += buffer[4]; s2 += s1;
			s1 += buffer[5]; s2 += s1;
			s1 += buffer[6]; s2 += s1;
			s1 += buffer[7]; s2 += s1;
			buffer += 8;
		}
		for (; i < blocklen; ++i) {
			s1 += *buffer++; s2 += s1;
		}

		s1 %= ADLER_MOD; s2 %= ADLER_MOD;
		buflen -= (unsigned int)blocklen;
		blocklen = 5552;
	}
	return (unsigned int)(s2 << 16) + (unsigned int)s1;
}
NK_INTERN unsigned int
nk_decompress(unsigned char* output, unsigned char* i, unsigned int length)
{
	unsigned int olen;
	if (nk__in4(0) != 0x57bC0000) return 0;
	if (nk__in4(4) != 0)          return 0; /* error! stream is > 4GB */
	olen = nk_decompress_length(i);
	nk__barrier2 = i;
	nk__barrier3 = i + length;
	nk__barrier = output + olen;
	nk__barrier4 = output;
	i += 16;

	nk__dout = output;
	for (;;) {
		unsigned char* old_i = i;
		i = nk_decompress_token(i);
		if (i == old_i) {
			if (*i == 0x05 && i[1] == 0xfa) {
				NK_ASSERT(nk__dout == output + olen);
				if (nk__dout != output + olen) return 0;
				if (nk_adler32(1, output, olen) != (unsigned int)nk__in4(2))
					return 0;
				return olen;
			}
			else {
				NK_ASSERT(0); /* NOTREACHED */
				return 0;
			}
		}
		NK_ASSERT(nk__dout <= output + olen);
		if (nk__dout > output + olen)
			return 0;
	}
}
NK_INTERN unsigned int
nk_decode_85_byte(char c)
{
	return (unsigned int)((c >= '\\') ? c - 36 : c - 35);
}
NK_INTERN void
nk_decode_85(unsigned char* dst, const unsigned char* src)
{
	while (*src)
	{
		unsigned int tmp =
			nk_decode_85_byte((char)src[0]) +
			85 * (nk_decode_85_byte((char)src[1]) +
				85 * (nk_decode_85_byte((char)src[2]) +
					85 * (nk_decode_85_byte((char)src[3]) +
						85 * nk_decode_85_byte((char)src[4]))));

		/* we can't assume little-endianess. */
		dst[0] = (unsigned char)((tmp >> 0) & 0xFF);
		dst[1] = (unsigned char)((tmp >> 8) & 0xFF);
		dst[2] = (unsigned char)((tmp >> 16) & 0xFF);
		dst[3] = (unsigned char)((tmp >> 24) & 0xFF);

		src += 5;
		dst += 4;
	}
}

/* -------------------------------------------------------------
 *
 *                          FONT ATLAS
 *
 * --------------------------------------------------------------*/
NK_API struct nk_font_config
nk_font_config(float pixel_height)
{
	struct nk_font_config cfg;
	nk_zero_struct(cfg);
	cfg.ttf_blob = 0;
	cfg.ttf_size = 0;
	cfg.ttf_data_owned_by_atlas = 0;
	cfg.size = pixel_height;
	cfg.oversample_h = 3;
	cfg.oversample_v = 1;
	cfg.pixel_snap = 0;
	cfg.coord_type = NK_COORD_UV;
	cfg.spacing = nk_vec2(0, 0);
	cfg.range = nk_font_default_glyph_ranges();
	cfg.merge_mode = 0;
	cfg.fallback_glyph = '?';
	cfg.font = 0;
	cfg.n = 0;
	return cfg;
}
#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR
NK_API void
nk_font_atlas_init_default(struct nk_font_atlas* atlas)
{
	NK_ASSERT(atlas);
	if (!atlas) return;
	nk_zero_struct(*atlas);
	atlas->temporary.userdata.ptr = 0;
	atlas->temporary.alloc = nk_malloc;
	atlas->temporary.free = nk_mfree;
	atlas->permanent.userdata.ptr = 0;
	atlas->permanent.alloc = nk_malloc;
	atlas->permanent.free = nk_mfree;
}
#endif
NK_API void
nk_font_atlas_init(struct nk_font_atlas* atlas, struct nk_allocator* alloc)
{
	NK_ASSERT(atlas);
	NK_ASSERT(alloc);
	if (!atlas || !alloc) return;
	nk_zero_struct(*atlas);
	atlas->permanent = *alloc;
	atlas->temporary = *alloc;
}
NK_API void
nk_font_atlas_init_custom(struct nk_font_atlas* atlas,
	struct nk_allocator* permanent, struct nk_allocator* temporary)
{
	NK_ASSERT(atlas);
	NK_ASSERT(permanent);
	NK_ASSERT(temporary);
	if (!atlas || !permanent || !temporary) return;
	nk_zero_struct(*atlas);
	atlas->permanent = *permanent;
	atlas->temporary = *temporary;
}
NK_API void
nk_font_atlas_begin(struct nk_font_atlas* atlas)
{
	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc && atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc && atlas->permanent.free);
	if (!atlas || !atlas->permanent.alloc || !atlas->permanent.free ||
		!atlas->temporary.alloc || !atlas->temporary.free) return;
	if (atlas->glyphs) {
		atlas->permanent.free(atlas->permanent.userdata, atlas->glyphs);
		atlas->glyphs = 0;
	}
	if (atlas->pixel) {
		atlas->permanent.free(atlas->permanent.userdata, atlas->pixel);
		atlas->pixel = 0;
	}
}
NK_API struct nk_font*
nk_font_atlas_add(struct nk_font_atlas* atlas, const struct nk_font_config* config)
{
	struct nk_font* font = 0;
	struct nk_font_config* cfg;

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);

	NK_ASSERT(config);
	NK_ASSERT(config->ttf_blob);
	NK_ASSERT(config->ttf_size);
	NK_ASSERT(config->size > 0.0f);

	if (!atlas || !config || !config->ttf_blob || !config->ttf_size || config->size <= 0.0f ||
		!atlas->permanent.alloc || !atlas->permanent.free ||
		!atlas->temporary.alloc || !atlas->temporary.free)
		return 0;

	/* allocate font config  */
	cfg = (struct nk_font_config*)
		atlas->permanent.alloc(atlas->permanent.userdata, 0, sizeof(struct nk_font_config));
	NK_MEMCPY(cfg, config, sizeof(*config));
	cfg->n = cfg;
	cfg->p = cfg;

	if (!config->merge_mode) {
		/* insert font config into list */
		if (!atlas->config) {
			atlas->config = cfg;
			cfg->next = 0;
		}
		else {
			struct nk_font_config* i = atlas->config;
			while (i->next) i = i->next;
			i->next = cfg;
			cfg->next = 0;
		}
		/* allocate new font */
		font = (struct nk_font*)
			atlas->permanent.alloc(atlas->permanent.userdata, 0, sizeof(struct nk_font));
		NK_ASSERT(font);
		nk_zero(font, sizeof(*font));
		if (!font) return 0;
		font->config = cfg;

		/* insert font into list */
		if (!atlas->fonts) {
			atlas->fonts = font;
			font->next = 0;
		}
		else {
			struct nk_font* i = atlas->fonts;
			while (i->next) i = i->next;
			i->next = font;
			font->next = 0;
		}
		cfg->font = &font->info;
	}
	else {
		/* extend previously added font */
		struct nk_font* f = 0;
		struct nk_font_config* c = 0;
		NK_ASSERT(atlas->font_num);
		f = atlas->fonts;
		c = f->config;
		cfg->font = &f->info;

		cfg->n = c;
		cfg->p = c->p;
		c->p->n = cfg;
		c->p = cfg;
	}
	/* create own copy of .TTF font blob */
	if (!config->ttf_data_owned_by_atlas) {
		cfg->ttf_blob = atlas->permanent.alloc(atlas->permanent.userdata, 0, cfg->ttf_size);
		NK_ASSERT(cfg->ttf_blob);
		if (!cfg->ttf_blob) {
			atlas->font_num++;
			return 0;
		}
		NK_MEMCPY(cfg->ttf_blob, config->ttf_blob, cfg->ttf_size);
		cfg->ttf_data_owned_by_atlas = 1;
	}
	atlas->font_num++;
	return font;
}
NK_API struct nk_font*
nk_font_atlas_add_from_memory(struct nk_font_atlas* atlas, void* memory,
	nk_size size, float height, const struct nk_font_config* config)
{
	struct nk_font_config cfg;
	NK_ASSERT(memory);
	NK_ASSERT(size);

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);
	if (!atlas || !atlas->temporary.alloc || !atlas->temporary.free || !memory || !size ||
		!atlas->permanent.alloc || !atlas->permanent.free)
		return 0;

	cfg = (config) ? *config : nk_font_config(height);
	cfg.ttf_blob = memory;
	cfg.ttf_size = size;
	cfg.size = height;
	cfg.ttf_data_owned_by_atlas = 0;
	return nk_font_atlas_add(atlas, &cfg);
}
#ifdef NK_INCLUDE_STANDARD_IO
NK_API struct nk_font*
nk_font_atlas_add_from_file(struct nk_font_atlas* atlas, const char* file_path,
	float height, const struct nk_font_config* config)
{
	nk_size size;
	char* memory;
	struct nk_font_config cfg;

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);

	if (!atlas || !file_path) return 0;
	memory = nk_file_load(file_path, &size, &atlas->permanent);
	if (!memory) return 0;

	cfg = (config) ? *config : nk_font_config(height);
	cfg.ttf_blob = memory;
	cfg.ttf_size = size;
	cfg.size = height;
	cfg.ttf_data_owned_by_atlas = 1;
	return nk_font_atlas_add(atlas, &cfg);
}
#endif
NK_API struct nk_font*
nk_font_atlas_add_compressed(struct nk_font_atlas* atlas,
	void* compressed_data, nk_size compressed_size, float height,
	const struct nk_font_config* config)
{
	unsigned int decompressed_size;
	void* decompressed_data;
	struct nk_font_config cfg;

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);

	NK_ASSERT(compressed_data);
	NK_ASSERT(compressed_size);
	if (!atlas || !compressed_data || !atlas->temporary.alloc || !atlas->temporary.free ||
		!atlas->permanent.alloc || !atlas->permanent.free)
		return 0;

	decompressed_size = nk_decompress_length((unsigned char*)compressed_data);
	decompressed_data = atlas->permanent.alloc(atlas->permanent.userdata, 0, decompressed_size);
	NK_ASSERT(decompressed_data);
	if (!decompressed_data) return 0;
	nk_decompress((unsigned char*)decompressed_data, (unsigned char*)compressed_data,
		(unsigned int)compressed_size);

	cfg = (config) ? *config : nk_font_config(height);
	cfg.ttf_blob = decompressed_data;
	cfg.ttf_size = decompressed_size;
	cfg.size = height;
	cfg.ttf_data_owned_by_atlas = 1;
	return nk_font_atlas_add(atlas, &cfg);
}
NK_API struct nk_font*
nk_font_atlas_add_compressed_base85(struct nk_font_atlas* atlas,
	const char* data_base85, float height, const struct nk_font_config* config)
{
	int compressed_size;
	void* compressed_data;
	struct nk_font* font;

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);

	NK_ASSERT(data_base85);
	if (!atlas || !data_base85 || !atlas->temporary.alloc || !atlas->temporary.free ||
		!atlas->permanent.alloc || !atlas->permanent.free)
		return 0;

	compressed_size = (((int)nk_strlen(data_base85) + 4) / 5) * 4;
	compressed_data = atlas->temporary.alloc(atlas->temporary.userdata, 0, (nk_size)compressed_size);
	NK_ASSERT(compressed_data);
	if (!compressed_data) return 0;
	nk_decode_85((unsigned char*)compressed_data, (const unsigned char*)data_base85);
	font = nk_font_atlas_add_compressed(atlas, compressed_data,
		(nk_size)compressed_size, height, config);
	atlas->temporary.free(atlas->temporary.userdata, compressed_data);
	return font;
}

#ifdef NK_INCLUDE_DEFAULT_FONT
NK_API struct nk_font*
nk_font_atlas_add_default(struct nk_font_atlas* atlas,
	float pixel_height, const struct nk_font_config* config)
{
	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);
	return nk_font_atlas_add_compressed_base85(atlas,
		nk_proggy_clean_ttf_compressed_data_base85, pixel_height, config);
}
#endif
NK_API const void*
nk_font_atlas_bake(struct nk_font_atlas* atlas, int* width, int* height,
	enum nk_font_atlas_format fmt)
{
	int i = 0;
	void* tmp = 0;
	nk_size tmp_size, img_size;
	struct nk_font* font_iter;
	struct nk_font_baker* baker;

	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);

	NK_ASSERT(width);
	NK_ASSERT(height);
	if (!atlas || !width || !height ||
		!atlas->temporary.alloc || !atlas->temporary.free ||
		!atlas->permanent.alloc || !atlas->permanent.free)
		return 0;

#ifdef NK_INCLUDE_DEFAULT_FONT
	/* no font added so just use default font */
	if (!atlas->font_num)
		atlas->default_font = nk_font_atlas_add_default(atlas, 13.0f, 0);
#endif
	NK_ASSERT(atlas->font_num);
	if (!atlas->font_num) return 0;

	/* allocate temporary baker memory required for the baking process */
	nk_font_baker_memory(&tmp_size, &atlas->glyph_count, atlas->config, atlas->font_num);
	tmp = atlas->temporary.alloc(atlas->temporary.userdata, 0, tmp_size);
	NK_ASSERT(tmp);
	if (!tmp) goto failed;

	/* allocate glyph memory for all fonts */
	baker = nk_font_baker(tmp, atlas->glyph_count, atlas->font_num, &atlas->temporary);
	atlas->glyphs = (struct nk_font_glyph*)atlas->permanent.alloc(
		atlas->permanent.userdata, 0, sizeof(struct nk_font_glyph) * (nk_size)atlas->glyph_count);
	NK_ASSERT(atlas->glyphs);
	if (!atlas->glyphs)
		goto failed;

	/* pack all glyphs into a tight fit space */
	atlas->custom.w = (NK_CURSOR_DATA_W * 2) + 1;
	atlas->custom.h = NK_CURSOR_DATA_H + 1;
	if (!nk_font_bake_pack(baker, &img_size, width, height, &atlas->custom,
		atlas->config, atlas->font_num, &atlas->temporary))
		goto failed;

	/* allocate memory for the baked image font atlas */
	atlas->pixel = atlas->temporary.alloc(atlas->temporary.userdata, 0, img_size);
	NK_ASSERT(atlas->pixel);
	if (!atlas->pixel)
		goto failed;

	/* bake glyphs and custom white pixel into image */
	nk_font_bake(baker, atlas->pixel, *width, *height,
		atlas->glyphs, atlas->glyph_count, atlas->config, atlas->font_num);
	nk_font_bake_custom_data(atlas->pixel, *width, *height, atlas->custom,
		nk_custom_cursor_data, NK_CURSOR_DATA_W, NK_CURSOR_DATA_H, '.', 'X');

	if (fmt == NK_FONT_ATLAS_RGBA32) {
		/* convert alpha8 image into rgba32 image */
		void* img_rgba = atlas->temporary.alloc(atlas->temporary.userdata, 0,
			(nk_size)(*width * *height * 4));
		NK_ASSERT(img_rgba);
		if (!img_rgba) goto failed;
		nk_font_bake_convert(img_rgba, *width, *height, atlas->pixel);
		atlas->temporary.free(atlas->temporary.userdata, atlas->pixel);
		atlas->pixel = img_rgba;
	}
	atlas->tex_width = *width;
	atlas->tex_height = *height;

	/* initialize each font */
	for (font_iter = atlas->fonts; font_iter; font_iter = font_iter->next) {
		struct nk_font* font = font_iter;
		struct nk_font_config* config = font->config;
		nk_font_init(font, config->size, config->fallback_glyph, atlas->glyphs,
			config->font, nk_handle_ptr(0));
	}

	/* initialize each cursor */
	{NK_STORAGE const struct nk_vec2 nk_cursor_data[NK_CURSOR_COUNT][3] = {
		/* Pos      Size        Offset */
		{{ 0, 3},   {12,19},    { 0, 0}},
		{{13, 0},   { 7,16},    { 4, 8}},
		{{31, 0},   {23,23},    {11,11}},
		{{21, 0},   { 9, 23},   { 5,11}},
		{{55,18},   {23, 9},    {11, 5}},
		{{73, 0},   {17,17},    { 9, 9}},
		{{55, 0},   {17,17},    { 9, 9}}
	};
	for (i = 0; i < NK_CURSOR_COUNT; ++i) {
		struct nk_cursor* cursor = &atlas->cursors[i];
		cursor->img.w = (unsigned short)*width;
		cursor->img.h = (unsigned short)*height;
		cursor->img.region[0] = (unsigned short)(atlas->custom.x + nk_cursor_data[i][0].x);
		cursor->img.region[1] = (unsigned short)(atlas->custom.y + nk_cursor_data[i][0].y);
		cursor->img.region[2] = (unsigned short)nk_cursor_data[i][1].x;
		cursor->img.region[3] = (unsigned short)nk_cursor_data[i][1].y;
		cursor->size = nk_cursor_data[i][1];
		cursor->offset = nk_cursor_data[i][2];
	}}
	/* free temporary memory */
	atlas->temporary.free(atlas->temporary.userdata, tmp);
	return atlas->pixel;

failed:
	/* error so cleanup all memory */
	if (tmp) atlas->temporary.free(atlas->temporary.userdata, tmp);
	if (atlas->glyphs) {
		atlas->permanent.free(atlas->permanent.userdata, atlas->glyphs);
		atlas->glyphs = 0;
	}
	if (atlas->pixel) {
		atlas->temporary.free(atlas->temporary.userdata, atlas->pixel);
		atlas->pixel = 0;
	}
	return 0;
}
NK_API void
nk_font_atlas_end(struct nk_font_atlas* atlas, nk_handle texture,
	struct nk_draw_null_texture* null)
{
	int i = 0;
	struct nk_font* font_iter;
	NK_ASSERT(atlas);
	if (!atlas) {
		if (!null) return;
		null->texture = texture;
		null->uv = nk_vec2(0.5f, 0.5f);
	}
	if (null) {
		null->texture = texture;
		null->uv.x = (atlas->custom.x + 0.5f) / (float)atlas->tex_width;
		null->uv.y = (atlas->custom.y + 0.5f) / (float)atlas->tex_height;
	}
	for (font_iter = atlas->fonts; font_iter; font_iter = font_iter->next) {
		font_iter->texture = texture;
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
		font_iter->handle.texture = texture;
#endif
	}
	for (i = 0; i < NK_CURSOR_COUNT; ++i)
		atlas->cursors[i].img.handle = texture;

	atlas->temporary.free(atlas->temporary.userdata, atlas->pixel);
	atlas->pixel = 0;
	atlas->tex_width = 0;
	atlas->tex_height = 0;
	atlas->custom.x = 0;
	atlas->custom.y = 0;
	atlas->custom.w = 0;
	atlas->custom.h = 0;
}
NK_API void
nk_font_atlas_cleanup(struct nk_font_atlas* atlas)
{
	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);
	if (!atlas || !atlas->permanent.alloc || !atlas->permanent.free) return;
	if (atlas->config) {
		struct nk_font_config* iter;
		for (iter = atlas->config; iter; iter = iter->next) {
			struct nk_font_config* i;
			for (i = iter->n; i != iter; i = i->n) {
				atlas->permanent.free(atlas->permanent.userdata, i->ttf_blob);
				i->ttf_blob = 0;
			}
			atlas->permanent.free(atlas->permanent.userdata, iter->ttf_blob);
			iter->ttf_blob = 0;
		}
	}
}
NK_API void
nk_font_atlas_clear(struct nk_font_atlas* atlas)
{
	NK_ASSERT(atlas);
	NK_ASSERT(atlas->temporary.alloc);
	NK_ASSERT(atlas->temporary.free);
	NK_ASSERT(atlas->permanent.alloc);
	NK_ASSERT(atlas->permanent.free);
	if (!atlas || !atlas->permanent.alloc || !atlas->permanent.free) return;

	if (atlas->config) {
		struct nk_font_config* iter, * next;
		for (iter = atlas->config; iter; iter = next) {
			struct nk_font_config* i, * n;
			for (i = iter->n; i != iter; i = n) {
				n = i->n;
				if (i->ttf_blob)
					atlas->permanent.free(atlas->permanent.userdata, i->ttf_blob);
				atlas->permanent.free(atlas->permanent.userdata, i);
			}
			next = iter->next;
			if (i->ttf_blob)
				atlas->permanent.free(atlas->permanent.userdata, iter->ttf_blob);
			atlas->permanent.free(atlas->permanent.userdata, iter);
		}
		atlas->config = 0;
	}
	if (atlas->fonts) {
		struct nk_font* iter, * next;
		for (iter = atlas->fonts; iter; iter = next) {
			next = iter->next;
			atlas->permanent.free(atlas->permanent.userdata, iter);
		}
		atlas->fonts = 0;
	}
	if (atlas->glyphs)
		atlas->permanent.free(atlas->permanent.userdata, atlas->glyphs);
	nk_zero_struct(*atlas);
}
#endif





/* ===============================================================
 *
 *                          INPUT
 *
 * ===============================================================*/
NK_API void nk_input_begin(struct nk_context* ctx) {
	int i;
	struct nk_input* in;
	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;
	for (i = 0; i < NK_BUTTON_MAX; ++i)
		in->mouse.buttons[i].clicked = 0;

	in->keyboard.text_len = 0;
	in->mouse.scroll_delta = nk_vec2(0, 0);
	in->mouse.prev.x = in->mouse.pos.x;
	in->mouse.prev.y = in->mouse.pos.y;
	in->mouse.delta.x = 0;
	in->mouse.delta.y = 0;
	for (i = 0; i < NK_KEY_MAX; i++)
		in->keyboard.keys[i].clicked = 0;
}

NK_API void nk_input_end(struct nk_context* ctx) {
	struct nk_input* in;
	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;
	if (in->mouse.grab)
		in->mouse.grab = 0;
	if (in->mouse.ungrab) {
		in->mouse.grabbed = 0;
		in->mouse.ungrab = 0;
		in->mouse.grab = 0;
	}
}

NK_API void nk_input_motion(struct nk_context* ctx, int x, int y) {
	struct nk_input* in;
	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;
	in->mouse.pos.x = (float)x;
	in->mouse.pos.y = (float)y;
	in->mouse.delta.x = in->mouse.pos.x - in->mouse.prev.x;
	in->mouse.delta.y = in->mouse.pos.y - in->mouse.prev.y;
}

NK_API void nk_input_key(struct nk_context* ctx, enum nk_keys key, int down) {
	struct nk_input* in;
	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;
	if (in->keyboard.keys[key].down != down)
		in->keyboard.keys[key].clicked++;
	in->keyboard.keys[key].down = down;
}

NK_API void nk_input_button(struct nk_context* ctx, enum nk_buttons id, int x, int y, int down) {
	struct nk_mouse_button* btn;
	struct nk_input* in;
	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;
	if (in->mouse.buttons[id].down == down) return;

	btn = &in->mouse.buttons[id];
	btn->clicked_pos.x = (float)x;
	btn->clicked_pos.y = (float)y;
	btn->down = down;
	btn->clicked++;
}

NK_API void nk_input_scroll(struct nk_context* ctx, struct nk_vec2 val) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	ctx->input.mouse.scroll_delta.x += val.x;
	ctx->input.mouse.scroll_delta.y += val.y;
}

NK_API void nk_input_glyph(struct nk_context* ctx, const nk_glyph glyph) {
	int len = 0;
	nk_rune unicode;
	struct nk_input* in;

	NK_ASSERT(ctx);
	if (!ctx) return;
	in = &ctx->input;

	len = nk_utf_decode(glyph, &unicode, NK_UTF_SIZE);
	if (len && ((in->keyboard.text_len + len) < NK_INPUT_MAX)) {
		nk_utf_encode(unicode, &in->keyboard.text[in->keyboard.text_len], NK_INPUT_MAX - in->keyboard.text_len);
		in->keyboard.text_len += len;
	}
}

NK_API void nk_input_char(struct nk_context* ctx, char c) {
	nk_glyph glyph;
	NK_ASSERT(ctx);
	if (!ctx) return;
	glyph[0] = c;
	nk_input_glyph(ctx, glyph);
}

NK_API void nk_input_unicode(struct nk_context* ctx, nk_rune unicode) {
	nk_glyph rune;
	NK_ASSERT(ctx);
	if (!ctx) return;
	nk_utf_encode(unicode, rune, NK_UTF_SIZE);
	nk_input_glyph(ctx, rune);
}

NK_API int nk_input_has_mouse_click(const struct nk_input* i, enum nk_buttons id) {
	const struct nk_mouse_button* btn;
	if (!i) return nk_false;
	btn = &i->mouse.buttons[id];
	return (btn->clicked && btn->down == nk_false) ? nk_true : nk_false;
}

NK_API int nk_input_has_mouse_click_in_rect(const struct nk_input* i, enum nk_buttons id, struct nk_rect b) {
	const struct nk_mouse_button* btn;
	if (!i) return nk_false;
	btn = &i->mouse.buttons[id];
	if (!NK_INBOX(btn->clicked_pos.x, btn->clicked_pos.y, b.x, b.y, b.w, b.h))
		return nk_false;
	return nk_true;
}

NK_API int
nk_input_has_mouse_click_down_in_rect(const struct nk_input* i, enum nk_buttons id, struct nk_rect b, int down) {
	const struct nk_mouse_button* btn;
	if (!i) return nk_false;
	btn = &i->mouse.buttons[id];
	return nk_input_has_mouse_click_in_rect(i, id, b) && (btn->down == down);
}

NK_API int nk_input_is_mouse_click_in_rect(const struct nk_input* i, enum nk_buttons id, struct nk_rect b) {
	const struct nk_mouse_button* btn;
	if (!i) return nk_false;
	btn = &i->mouse.buttons[id];
	return (nk_input_has_mouse_click_down_in_rect(i, id, b, nk_false) && btn->clicked) ? nk_true : nk_false;
}

NK_API int
nk_input_is_mouse_click_down_in_rect(const struct nk_input* i, enum nk_buttons id, struct nk_rect b, int down) {
	const struct nk_mouse_button* btn;
	if (!i) return nk_false;
	btn = &i->mouse.buttons[id];
	return (nk_input_has_mouse_click_down_in_rect(i, id, b, down) && btn->clicked) ? nk_true : nk_false;
}

NK_API int nk_input_any_mouse_click_in_rect(const struct nk_input* in, struct nk_rect b) {
	int i, down = 0;
	for (i = 0; i < NK_BUTTON_MAX; ++i)
		down = down || nk_input_is_mouse_click_in_rect(in, (enum nk_buttons) i, b);
	return down;
}

NK_API int nk_input_is_mouse_hovering_rect(const struct nk_input* i, struct nk_rect rect) {
	if (!i) return nk_false;
	return NK_INBOX(i->mouse.pos.x, i->mouse.pos.y, rect.x, rect.y, rect.w, rect.h);
}

NK_API int nk_input_is_mouse_prev_hovering_rect(const struct nk_input* i, struct nk_rect rect) {
	if (!i) return nk_false;
	return NK_INBOX(i->mouse.prev.x, i->mouse.prev.y, rect.x, rect.y, rect.w, rect.h);
}

NK_API int nk_input_mouse_clicked(const struct nk_input* i, enum nk_buttons id, struct nk_rect rect) {
	if (!i) return nk_false;
	if (!nk_input_is_mouse_hovering_rect(i, rect)) return nk_false;
	return nk_input_is_mouse_click_in_rect(i, id, rect);
}

NK_API int nk_input_is_mouse_down(const struct nk_input* i, enum nk_buttons id) {
	if (!i) return nk_false;
	return i->mouse.buttons[id].down;
}

NK_API int nk_input_is_mouse_pressed(const struct nk_input* i, enum nk_buttons id) {
	const struct nk_mouse_button* b;
	if (!i) return nk_false;
	b = &i->mouse.buttons[id];
	if (b->down && b->clicked)
		return nk_true;
	return nk_false;
}

NK_API int nk_input_is_mouse_released(const struct nk_input* i, enum nk_buttons id) {
	if (!i) return nk_false;
	return (!i->mouse.buttons[id].down && i->mouse.buttons[id].clicked);
}

NK_API int nk_input_is_key_pressed(const struct nk_input* i, enum nk_keys key) {
	const struct nk_key* k;
	if (!i) return nk_false;
	k = &i->keyboard.keys[key];
	if ((k->down && k->clicked) || (!k->down && k->clicked >= 2))
		return nk_true;
	return nk_false;
}

NK_API int nk_input_is_key_released(const struct nk_input* i, enum nk_keys key) {
	const struct nk_key* k;
	if (!i) return nk_false;
	k = &i->keyboard.keys[key];
	if ((!k->down && k->clicked) || (k->down && k->clicked >= 2))
		return nk_true;
	return nk_false;
}

NK_API int nk_input_is_key_down(const struct nk_input* i, enum nk_keys key) {
	const struct nk_key* k;
	if (!i) return nk_false;
	k = &i->keyboard.keys[key];
	if (k->down) return nk_true;
	return nk_false;
}





/* ===============================================================
 *
 *                              STYLE
 *
 * ===============================================================*/
NK_API void nk_style_default(struct nk_context* ctx) { nk_style_from_table(ctx, 0); }

#define NK_COLOR_MAP(NK_COLOR)\
    NK_COLOR(NK_COLOR_TEXT,                     175,175,175,255) \
    NK_COLOR(NK_COLOR_WINDOW,                   45, 45, 45, 255) \
    NK_COLOR(NK_COLOR_HEADER,                   40, 40, 40, 255) \
    NK_COLOR(NK_COLOR_BORDER,                   65, 65, 65, 255) \
    NK_COLOR(NK_COLOR_BUTTON,                   50, 50, 50, 255) \
    NK_COLOR(NK_COLOR_BUTTON_HOVER,             40, 40, 40, 255) \
    NK_COLOR(NK_COLOR_BUTTON_ACTIVE,            35, 35, 35, 255) \
    NK_COLOR(NK_COLOR_TOGGLE,                   100,100,100,255) \
    NK_COLOR(NK_COLOR_TOGGLE_HOVER,             120,120,120,255) \
    NK_COLOR(NK_COLOR_TOGGLE_CURSOR,            45, 45, 45, 255) \
    NK_COLOR(NK_COLOR_SELECT,                   45, 45, 45, 255) \
    NK_COLOR(NK_COLOR_SELECT_ACTIVE,            35, 35, 35,255) \
    NK_COLOR(NK_COLOR_SLIDER,                   38, 38, 38, 255) \
    NK_COLOR(NK_COLOR_SLIDER_CURSOR,            100,100,100,255) \
    NK_COLOR(NK_COLOR_SLIDER_CURSOR_HOVER,      120,120,120,255) \
    NK_COLOR(NK_COLOR_SLIDER_CURSOR_ACTIVE,     150,150,150,255) \
    NK_COLOR(NK_COLOR_PROPERTY,                 38, 38, 38, 255) \
    NK_COLOR(NK_COLOR_EDIT,                     38, 38, 38, 255)  \
    NK_COLOR(NK_COLOR_EDIT_CURSOR,              175,175,175,255) \
    NK_COLOR(NK_COLOR_COMBO,                    45, 45, 45, 255) \
    NK_COLOR(NK_COLOR_CHART,                    120,120,120,255) \
    NK_COLOR(NK_COLOR_CHART_COLOR,              45, 45, 45, 255) \
    NK_COLOR(NK_COLOR_CHART_COLOR_HIGHLIGHT,    255, 0,  0, 255) \
    NK_COLOR(NK_COLOR_SCROLLBAR,                40, 40, 40, 255) \
    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR,         100,100,100,255) \
    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR_HOVER,   120,120,120,255) \
    NK_COLOR(NK_COLOR_SCROLLBAR_CURSOR_ACTIVE,  150,150,150,255) \
    NK_COLOR(NK_COLOR_TAB_HEADER,               40, 40, 40,255)

NK_GLOBAL const struct nk_color nk_default_color_style[NK_COLOR_COUNT] = {
#define NK_COLOR(a, b, c, d, e) {b,c,d,e},
		NK_COLOR_MAP(NK_COLOR)
#undef NK_COLOR
};
NK_GLOBAL const char* nk_color_names[NK_COLOR_COUNT] = {
#define NK_COLOR(a, b, c, d, e) #a,
		NK_COLOR_MAP(NK_COLOR)
#undef NK_COLOR
};

NK_API const char* nk_style_get_color_by_name(enum nk_style_colors c) {
	return nk_color_names[c];
}

NK_API struct nk_style_item nk_style_item_image(struct nk_image img) {
	struct nk_style_item i;
	i.type = NK_STYLE_ITEM_IMAGE;
	i.data.image = img;
	return i;
}

NK_API struct nk_style_item nk_style_item_color(struct nk_color col) {
	struct nk_style_item i;
	i.type = NK_STYLE_ITEM_COLOR;
	i.data.color = col;
	return i;
}

NK_API struct nk_style_item nk_style_item_hide(void) {
	struct nk_style_item i;
	i.type = NK_STYLE_ITEM_COLOR;
	i.data.color = nk_rgba(0, 0, 0, 0);
	return i;
}

NK_API void nk_style_from_table(struct nk_context* ctx, const struct nk_color* table) {
	struct nk_style* style;
	struct nk_style_text* text;
	struct nk_style_button* button;
	struct nk_style_toggle* toggle;
	struct nk_style_selectable* select;
	struct nk_style_slider* slider;
	struct nk_style_progress* prog;
	struct nk_style_scrollbar* scroll;
	struct nk_style_edit* edit;
	struct nk_style_property* property;
	struct nk_style_combo* combo;
	struct nk_style_chart* chart;
	struct nk_style_tab* tab;
	struct nk_style_window* win;

	NK_ASSERT(ctx);
	if (!ctx) return;
	style = &ctx->style;
	table = (!table) ? nk_default_color_style : table;

	/* default text */
	text = &style->text;
	text->color = table[NK_COLOR_TEXT];
	text->padding = nk_vec2(0, 0);

	/* default button */
	button = &style->button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_BUTTON]);
	button->hover = nk_style_item_color(table[NK_COLOR_BUTTON_HOVER]);
	button->active = nk_style_item_color(table[NK_COLOR_BUTTON_ACTIVE]);
	button->border_color = table[NK_COLOR_BORDER];
	button->text_background = table[NK_COLOR_BUTTON];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->image_padding = nk_vec2(0.0f, 0.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 1.0f;
	button->rounding = 4.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* contextual button */
	button = &style->contextual_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->hover = nk_style_item_color(table[NK_COLOR_BUTTON_HOVER]);
	button->active = nk_style_item_color(table[NK_COLOR_BUTTON_ACTIVE]);
	button->border_color = table[NK_COLOR_WINDOW];
	button->text_background = table[NK_COLOR_WINDOW];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* menu button */
	button = &style->menu_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->hover = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->active = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->border_color = table[NK_COLOR_WINDOW];
	button->text_background = table[NK_COLOR_WINDOW];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 1.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* checkbox toggle */
	toggle = &style->checkbox;
	nk_zero_struct(*toggle);
	toggle->normal = nk_style_item_color(table[NK_COLOR_TOGGLE]);
	toggle->hover = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
	toggle->active = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
	toggle->cursor_normal = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
	toggle->cursor_hover = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
	toggle->userdata = nk_handle_ptr(0);
	toggle->text_background = table[NK_COLOR_WINDOW];
	toggle->text_normal = table[NK_COLOR_TEXT];
	toggle->text_hover = table[NK_COLOR_TEXT];
	toggle->text_active = table[NK_COLOR_TEXT];
	toggle->padding = nk_vec2(2.0f, 2.0f);
	toggle->touch_padding = nk_vec2(0, 0);
	toggle->border_color = nk_rgba(0, 0, 0, 0);
	toggle->border = 0.0f;
	toggle->spacing = 4;

	/* option toggle */
	toggle = &style->option;
	nk_zero_struct(*toggle);
	toggle->normal = nk_style_item_color(table[NK_COLOR_TOGGLE]);
	toggle->hover = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
	toggle->active = nk_style_item_color(table[NK_COLOR_TOGGLE_HOVER]);
	toggle->cursor_normal = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
	toggle->cursor_hover = nk_style_item_color(table[NK_COLOR_TOGGLE_CURSOR]);
	toggle->userdata = nk_handle_ptr(0);
	toggle->text_background = table[NK_COLOR_WINDOW];
	toggle->text_normal = table[NK_COLOR_TEXT];
	toggle->text_hover = table[NK_COLOR_TEXT];
	toggle->text_active = table[NK_COLOR_TEXT];
	toggle->padding = nk_vec2(3.0f, 3.0f);
	toggle->touch_padding = nk_vec2(0, 0);
	toggle->border_color = nk_rgba(0, 0, 0, 0);
	toggle->border = 0.0f;
	toggle->spacing = 4;

	/* selectable */
	select = &style->selectable;
	nk_zero_struct(*select);
	select->normal = nk_style_item_color(table[NK_COLOR_SELECT]);
	select->hover = nk_style_item_color(table[NK_COLOR_SELECT]);
	select->pressed = nk_style_item_color(table[NK_COLOR_SELECT]);
	select->normal_active = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
	select->hover_active = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
	select->pressed_active = nk_style_item_color(table[NK_COLOR_SELECT_ACTIVE]);
	select->text_normal = table[NK_COLOR_TEXT];
	select->text_hover = table[NK_COLOR_TEXT];
	select->text_pressed = table[NK_COLOR_TEXT];
	select->text_normal_active = table[NK_COLOR_TEXT];
	select->text_hover_active = table[NK_COLOR_TEXT];
	select->text_pressed_active = table[NK_COLOR_TEXT];
	select->padding = nk_vec2(2.0f, 2.0f);
	select->image_padding = nk_vec2(2.0f, 2.0f);
	select->touch_padding = nk_vec2(0, 0);
	select->userdata = nk_handle_ptr(0);
	select->rounding = 0.0f;
	select->draw_begin = 0;
	select->draw_end = 0;

	/* slider */
	slider = &style->slider;
	nk_zero_struct(*slider);
	slider->normal = nk_style_item_hide();
	slider->hover = nk_style_item_hide();
	slider->active = nk_style_item_hide();
	slider->bar_normal = table[NK_COLOR_SLIDER];
	slider->bar_hover = table[NK_COLOR_SLIDER];
	slider->bar_active = table[NK_COLOR_SLIDER];
	slider->bar_filled = table[NK_COLOR_SLIDER_CURSOR];
	slider->cursor_normal = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR]);
	slider->cursor_hover = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_HOVER]);
	slider->cursor_active = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_ACTIVE]);
	slider->inc_symbol = NK_SYMBOL_TRIANGLE_RIGHT;
	slider->dec_symbol = NK_SYMBOL_TRIANGLE_LEFT;
	slider->cursor_size = nk_vec2(16, 16);
	slider->padding = nk_vec2(2, 2);
	slider->spacing = nk_vec2(2, 2);
	slider->userdata = nk_handle_ptr(0);
	slider->show_buttons = nk_false;
	slider->bar_height = 8;
	slider->rounding = 0;
	slider->draw_begin = 0;
	slider->draw_end = 0;

	/* slider buttons */
	button = &style->slider.inc_button;
	button->normal = nk_style_item_color(nk_rgb(40, 40, 40));
	button->hover = nk_style_item_color(nk_rgb(42, 42, 42));
	button->active = nk_style_item_color(nk_rgb(44, 44, 44));
	button->border_color = nk_rgb(65, 65, 65);
	button->text_background = nk_rgb(40, 40, 40);
	button->text_normal = nk_rgb(175, 175, 175);
	button->text_hover = nk_rgb(175, 175, 175);
	button->text_active = nk_rgb(175, 175, 175);
	button->padding = nk_vec2(8.0f, 8.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 1.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;
	style->slider.dec_button = style->slider.inc_button;

	/* progressbar */
	prog = &style->progress;
	nk_zero_struct(*prog);
	prog->normal = nk_style_item_color(table[NK_COLOR_SLIDER]);
	prog->hover = nk_style_item_color(table[NK_COLOR_SLIDER]);
	prog->active = nk_style_item_color(table[NK_COLOR_SLIDER]);
	prog->cursor_normal = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR]);
	prog->cursor_hover = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_HOVER]);
	prog->cursor_active = nk_style_item_color(table[NK_COLOR_SLIDER_CURSOR_ACTIVE]);
	prog->border_color = nk_rgba(0, 0, 0, 0);
	prog->cursor_border_color = nk_rgba(0, 0, 0, 0);
	prog->userdata = nk_handle_ptr(0);
	prog->padding = nk_vec2(4, 4);
	prog->rounding = 0;
	prog->border = 0;
	prog->cursor_rounding = 0;
	prog->cursor_border = 0;
	prog->draw_begin = 0;
	prog->draw_end = 0;

	/* scrollbars */
	scroll = &style->scrollh;
	nk_zero_struct(*scroll);
	scroll->normal = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
	scroll->hover = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
	scroll->active = nk_style_item_color(table[NK_COLOR_SCROLLBAR]);
	scroll->cursor_normal = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR]);
	scroll->cursor_hover = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR_HOVER]);
	scroll->cursor_active = nk_style_item_color(table[NK_COLOR_SCROLLBAR_CURSOR_ACTIVE]);
	scroll->dec_symbol = NK_SYMBOL_CIRCLE_SOLID;
	scroll->inc_symbol = NK_SYMBOL_CIRCLE_SOLID;
	scroll->userdata = nk_handle_ptr(0);
	scroll->border_color = table[NK_COLOR_SCROLLBAR];
	scroll->cursor_border_color = table[NK_COLOR_SCROLLBAR];
	scroll->padding = nk_vec2(0, 0);
	scroll->show_buttons = nk_false;
	scroll->border = 0;
	scroll->rounding = 0;
	scroll->border_cursor = 0;
	scroll->rounding_cursor = 0;
	scroll->draw_begin = 0;
	scroll->draw_end = 0;
	style->scrollv = style->scrollh;

	/* scrollbars buttons */
	button = &style->scrollh.inc_button;
	button->normal = nk_style_item_color(nk_rgb(40, 40, 40));
	button->hover = nk_style_item_color(nk_rgb(42, 42, 42));
	button->active = nk_style_item_color(nk_rgb(44, 44, 44));
	button->border_color = nk_rgb(65, 65, 65);
	button->text_background = nk_rgb(40, 40, 40);
	button->text_normal = nk_rgb(175, 175, 175);
	button->text_hover = nk_rgb(175, 175, 175);
	button->text_active = nk_rgb(175, 175, 175);
	button->padding = nk_vec2(4.0f, 4.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 1.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;
	style->scrollh.dec_button = style->scrollh.inc_button;
	style->scrollv.inc_button = style->scrollh.inc_button;
	style->scrollv.dec_button = style->scrollh.inc_button;

	/* edit */
	edit = &style->edit;
	nk_zero_struct(*edit);
	edit->normal = nk_style_item_color(table[NK_COLOR_EDIT]);
	edit->hover = nk_style_item_color(table[NK_COLOR_EDIT]);
	edit->active = nk_style_item_color(table[NK_COLOR_EDIT]);
	edit->cursor_normal = table[NK_COLOR_TEXT];
	edit->cursor_hover = table[NK_COLOR_TEXT];
	edit->cursor_text_normal = table[NK_COLOR_EDIT];
	edit->cursor_text_hover = table[NK_COLOR_EDIT];
	edit->border_color = table[NK_COLOR_BORDER];
	edit->text_normal = table[NK_COLOR_TEXT];
	edit->text_hover = table[NK_COLOR_TEXT];
	edit->text_active = table[NK_COLOR_TEXT];
	edit->selected_normal = table[NK_COLOR_TEXT];
	edit->selected_hover = table[NK_COLOR_TEXT];
	edit->selected_text_normal = table[NK_COLOR_EDIT];
	edit->selected_text_hover = table[NK_COLOR_EDIT];
	edit->scrollbar_size = nk_vec2(10, 10);
	edit->scrollbar = style->scrollv;
	edit->padding = nk_vec2(4, 4);
	edit->row_padding = 2;
	edit->cursor_size = 4;
	edit->border = 1;
	edit->rounding = 0;

	/* property */
	property = &style->property;
	nk_zero_struct(*property);
	property->normal = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	property->hover = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	property->active = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	property->border_color = table[NK_COLOR_BORDER];
	property->label_normal = table[NK_COLOR_TEXT];
	property->label_hover = table[NK_COLOR_TEXT];
	property->label_active = table[NK_COLOR_TEXT];
	property->sym_left = NK_SYMBOL_TRIANGLE_LEFT;
	property->sym_right = NK_SYMBOL_TRIANGLE_RIGHT;
	property->userdata = nk_handle_ptr(0);
	property->padding = nk_vec2(4, 4);
	property->border = 1;
	property->rounding = 10;
	property->draw_begin = 0;
	property->draw_end = 0;

	/* property buttons */
	button = &style->property.dec_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	button->hover = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	button->active = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_PROPERTY];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(0.0f, 0.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;
	style->property.inc_button = style->property.dec_button;

	/* property edit */
	edit = &style->property.edit;
	nk_zero_struct(*edit);
	edit->normal = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	edit->hover = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	edit->active = nk_style_item_color(table[NK_COLOR_PROPERTY]);
	edit->border_color = nk_rgba(0, 0, 0, 0);
	edit->cursor_normal = table[NK_COLOR_TEXT];
	edit->cursor_hover = table[NK_COLOR_TEXT];
	edit->cursor_text_normal = table[NK_COLOR_EDIT];
	edit->cursor_text_hover = table[NK_COLOR_EDIT];
	edit->text_normal = table[NK_COLOR_TEXT];
	edit->text_hover = table[NK_COLOR_TEXT];
	edit->text_active = table[NK_COLOR_TEXT];
	edit->selected_normal = table[NK_COLOR_TEXT];
	edit->selected_hover = table[NK_COLOR_TEXT];
	edit->selected_text_normal = table[NK_COLOR_EDIT];
	edit->selected_text_hover = table[NK_COLOR_EDIT];
	edit->padding = nk_vec2(0, 0);
	edit->cursor_size = 8;
	edit->border = 0;
	edit->rounding = 0;

	/* chart */
	chart = &style->chart;
	nk_zero_struct(*chart);
	chart->background = nk_style_item_color(table[NK_COLOR_CHART]);
	chart->border_color = table[NK_COLOR_BORDER];
	chart->selected_color = table[NK_COLOR_CHART_COLOR_HIGHLIGHT];
	chart->color = table[NK_COLOR_CHART_COLOR];
	chart->padding = nk_vec2(4, 4);
	chart->border = 0;
	chart->rounding = 0;

	/* combo */
	combo = &style->combo;
	combo->normal = nk_style_item_color(table[NK_COLOR_COMBO]);
	combo->hover = nk_style_item_color(table[NK_COLOR_COMBO]);
	combo->active = nk_style_item_color(table[NK_COLOR_COMBO]);
	combo->border_color = table[NK_COLOR_BORDER];
	combo->label_normal = table[NK_COLOR_TEXT];
	combo->label_hover = table[NK_COLOR_TEXT];
	combo->label_active = table[NK_COLOR_TEXT];
	combo->sym_normal = NK_SYMBOL_TRIANGLE_DOWN;
	combo->sym_hover = NK_SYMBOL_TRIANGLE_DOWN;
	combo->sym_active = NK_SYMBOL_TRIANGLE_DOWN;
	combo->content_padding = nk_vec2(4, 4);
	combo->button_padding = nk_vec2(0, 4);
	combo->spacing = nk_vec2(4, 0);
	combo->border = 1;
	combo->rounding = 0;

	/* combo button */
	button = &style->combo.button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_COMBO]);
	button->hover = nk_style_item_color(table[NK_COLOR_COMBO]);
	button->active = nk_style_item_color(table[NK_COLOR_COMBO]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_COMBO];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* tab */
	tab = &style->tab;
	tab->background = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
	tab->border_color = table[NK_COLOR_BORDER];
	tab->text = table[NK_COLOR_TEXT];
	tab->sym_minimize = NK_SYMBOL_TRIANGLE_RIGHT;
	tab->sym_maximize = NK_SYMBOL_TRIANGLE_DOWN;
	tab->padding = nk_vec2(4, 4);
	tab->spacing = nk_vec2(4, 4);
	tab->indent = 10.0f;
	tab->border = 1;
	tab->rounding = 0;

	/* tab button */
	button = &style->tab.tab_minimize_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
	button->hover = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
	button->active = nk_style_item_color(table[NK_COLOR_TAB_HEADER]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_TAB_HEADER];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;
	style->tab.tab_maximize_button = *button;

	/* node button */
	button = &style->tab.node_minimize_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->hover = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->active = nk_style_item_color(table[NK_COLOR_WINDOW]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_TAB_HEADER];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(2.0f, 2.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;
	style->tab.node_maximize_button = *button;

	/* window header */
	win = &style->window;
	win->header.align = NK_HEADER_RIGHT;
	win->header.close_symbol = NK_SYMBOL_X;
	win->header.minimize_symbol = NK_SYMBOL_MINUS;
	win->header.maximize_symbol = NK_SYMBOL_PLUS;
	win->header.normal = nk_style_item_color(table[NK_COLOR_HEADER]);
	win->header.hover = nk_style_item_color(table[NK_COLOR_HEADER]);
	win->header.active = nk_style_item_color(table[NK_COLOR_HEADER]);
	win->header.label_normal = table[NK_COLOR_TEXT];
	win->header.label_hover = table[NK_COLOR_TEXT];
	win->header.label_active = table[NK_COLOR_TEXT];
	win->header.label_padding = nk_vec2(4, 4);
	win->header.padding = nk_vec2(4, 4);
	win->header.spacing = nk_vec2(0, 0);

	/* window header close button */
	button = &style->window.header.close_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->hover = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->active = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_HEADER];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(0.0f, 0.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* window header minimize button */
	button = &style->window.header.minimize_button;
	nk_zero_struct(*button);
	button->normal = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->hover = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->active = nk_style_item_color(table[NK_COLOR_HEADER]);
	button->border_color = nk_rgba(0, 0, 0, 0);
	button->text_background = table[NK_COLOR_HEADER];
	button->text_normal = table[NK_COLOR_TEXT];
	button->text_hover = table[NK_COLOR_TEXT];
	button->text_active = table[NK_COLOR_TEXT];
	button->padding = nk_vec2(0.0f, 0.0f);
	button->touch_padding = nk_vec2(0.0f, 0.0f);
	button->userdata = nk_handle_ptr(0);
	button->text_alignment = NK_TEXT_CENTERED;
	button->border = 0.0f;
	button->rounding = 0.0f;
	button->draw_begin = 0;
	button->draw_end = 0;

	/* window */
	win->background = table[NK_COLOR_WINDOW];
	win->fixed_background = nk_style_item_color(table[NK_COLOR_WINDOW]);
	win->border_color = table[NK_COLOR_BORDER];
	win->popup_border_color = table[NK_COLOR_BORDER];
	win->combo_border_color = table[NK_COLOR_BORDER];
	win->contextual_border_color = table[NK_COLOR_BORDER];
	win->menu_border_color = table[NK_COLOR_BORDER];
	win->group_border_color = table[NK_COLOR_BORDER];
	win->tooltip_border_color = table[NK_COLOR_BORDER];
	win->scaler = nk_style_item_color(table[NK_COLOR_TEXT]);

	win->rounding = 0.0f;
	win->spacing = nk_vec2(4, 4);
	win->scrollbar_size = nk_vec2(10, 10);
	win->min_size = nk_vec2(64, 64);

	win->combo_border = 1.0f;
	win->contextual_border = 1.0f;
	win->menu_border = 1.0f;
	win->group_border = 1.0f;
	win->tooltip_border = 1.0f;
	win->popup_border = 1.0f;
	win->border = 2.0f;
	win->min_row_height_padding = 8;

	win->padding = nk_vec2(4, 4);
	win->group_padding = nk_vec2(4, 4);
	win->popup_padding = nk_vec2(4, 4);
	win->combo_padding = nk_vec2(4, 4);
	win->contextual_padding = nk_vec2(4, 4);
	win->menu_padding = nk_vec2(4, 4);
	win->tooltip_padding = nk_vec2(4, 4);
}

NK_API void nk_style_set_font(struct nk_context* ctx, const struct nk_user_font* font) {
	struct nk_style* style;
	NK_ASSERT(ctx);

	if (!ctx) return;
	style = &ctx->style;
	style->font = font;
	ctx->stacks.fonts.head = 0;
	if (ctx->current)
		nk_layout_reset_min_row_height(ctx);
}

NK_API int nk_style_push_font(struct nk_context* ctx, const struct nk_user_font* font) {
	struct nk_config_stack_user_font* font_stack;
	struct nk_config_stack_user_font_element* element;

	NK_ASSERT(ctx);
	if (!ctx) return 0;

	font_stack = &ctx->stacks.fonts;
	NK_ASSERT(font_stack->head < (int)NK_LEN(font_stack->elements));
	if (font_stack->head >= (int)NK_LEN(font_stack->elements))
		return 0;

	element = &font_stack->elements[font_stack->head++];
	element->address = &ctx->style.font;
	element->old_value = ctx->style.font;
	ctx->style.font = font;
	return 1;
}

NK_API int nk_style_pop_font(struct nk_context* ctx) {
	struct nk_config_stack_user_font* font_stack;
	struct nk_config_stack_user_font_element* element;

	NK_ASSERT(ctx);
	if (!ctx) return 0;

	font_stack = &ctx->stacks.fonts;
	NK_ASSERT(font_stack->head > 0);
	if (font_stack->head < 1)
		return 0;

	element = &font_stack->elements[--font_stack->head];
	*element->address = element->old_value;
	return 1;
}

#define NK_STYLE_PUSH_IMPLEMENATION(prefix, type, stack) \
nk_style_push_##type(struct nk_context *ctx, prefix##_##type *address, prefix##_##type value)\
{\
    struct nk_config_stack_##type * type_stack;\
    struct nk_config_stack_##type##_element *element;\
    NK_ASSERT(ctx);\
    if (!ctx) return 0;\
    type_stack = &ctx->stacks.stack;\
    NK_ASSERT(type_stack->head < (int)NK_LEN(type_stack->elements));\
    if (type_stack->head >= (int)NK_LEN(type_stack->elements))\
        return 0;\
    element = &type_stack->elements[type_stack->head++];\
    element->address = address;\
    element->old_value = *address;\
    *address = value;\
    return 1;\
}
#define NK_STYLE_POP_IMPLEMENATION(type, stack) \
nk_style_pop_##type(struct nk_context *ctx)\
{\
    struct nk_config_stack_##type *type_stack;\
    struct nk_config_stack_##type##_element *element;\
    NK_ASSERT(ctx);\
    if (!ctx) return 0;\
    type_stack = &ctx->stacks.stack;\
    NK_ASSERT(type_stack->head > 0);\
    if (type_stack->head < 1)\
        return 0;\
    element = &type_stack->elements[--type_stack->head];\
    *element->address = element->old_value;\
    return 1;\
}

NK_API int NK_STYLE_PUSH_IMPLEMENATION(struct nk, style_item, style_items)

NK_API int NK_STYLE_PUSH_IMPLEMENATION(nk, float, floats)

NK_API int NK_STYLE_PUSH_IMPLEMENATION(struct nk, vec2, vectors)

NK_API int NK_STYLE_PUSH_IMPLEMENATION(nk, flags, flags)

NK_API int NK_STYLE_PUSH_IMPLEMENATION(struct nk, color, colors)

NK_API int NK_STYLE_POP_IMPLEMENATION(style_item, style_items)

NK_API int NK_STYLE_POP_IMPLEMENATION(float, floats)

NK_API int NK_STYLE_POP_IMPLEMENATION(vec2, vectors)

NK_API int NK_STYLE_POP_IMPLEMENATION(flags, flags)

NK_API int NK_STYLE_POP_IMPLEMENATION(color, colors)

NK_API int nk_style_set_cursor(struct nk_context* ctx, enum nk_style_cursor c) {
	struct nk_style* style;
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	style = &ctx->style;
	if (style->cursors[c]) {
		style->cursor_active = style->cursors[c];
		return 1;
	}
	return 0;
}

NK_API void nk_style_show_cursor(struct nk_context* ctx) {
	ctx->style.cursor_visible = nk_true;
}

NK_API void nk_style_hide_cursor(struct nk_context* ctx) {
	ctx->style.cursor_visible = nk_false;
}

NK_API void nk_style_load_cursor(struct nk_context* ctx, enum nk_style_cursor cursor, const struct nk_cursor* c) {
	struct nk_style* style;
	NK_ASSERT(ctx);
	if (!ctx) return;
	style = &ctx->style;
	style->cursors[cursor] = c;
}

NK_API void nk_style_load_all_cursors(struct nk_context* ctx, struct nk_cursor* cursors) {
	int i = 0;
	struct nk_style* style;
	NK_ASSERT(ctx);
	if (!ctx) return;
	style = &ctx->style;
	for (i = 0; i < NK_CURSOR_COUNT; ++i)
		style->cursors[i] = &cursors[i];
	style->cursor_visible = nk_true;
}





/* ==============================================================
 *
 *                          CONTEXT
 *
 * ===============================================================*/
NK_INTERN void nk_setup(struct nk_context* ctx, const struct nk_user_font* font) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	nk_zero_struct(*ctx);
	nk_style_default(ctx);
	ctx->seq = 1;
	if (font) ctx->style.font = font;
#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT
	nk_draw_list_init(&ctx->draw_list);
#endif
}

#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

NK_API int nk_init_default(struct nk_context* ctx, const struct nk_user_font* font) {
	struct nk_allocator alloc;
	alloc.userdata.ptr = 0;
	alloc.alloc = nk_malloc;
	alloc.free = nk_mfree;
	return nk_init(ctx, &alloc, font);
}

#endif

NK_API int nk_init_fixed(struct nk_context* ctx, void* memory, nk_size size, const struct nk_user_font* font) {
	NK_ASSERT(memory);
	if (!memory) return 0;
	nk_setup(ctx, font);
	nk_buffer_init_fixed(&ctx->memory, memory, size);
	ctx->use_pool = nk_false;
	return 1;
}

NK_API int nk_init_custom(struct nk_context* ctx, struct nk_buffer* cmds, struct nk_buffer* pool,
	const struct nk_user_font* font) {
	NK_ASSERT(cmds);
	NK_ASSERT(pool);
	if (!cmds || !pool) return 0;

	nk_setup(ctx, font);
	ctx->memory = *cmds;
	if (pool->type == NK_BUFFER_FIXED) {
		/* take memory from buffer and alloc fixed pool */
		nk_pool_init_fixed(&ctx->pool, pool->memory.ptr, pool->memory.size);
	}
	else {
		/* create dynamic pool from buffer allocator */
		struct nk_allocator* alloc = &pool->pool;
		nk_pool_init(&ctx->pool, alloc, NK_POOL_DEFAULT_CAPACITY);
	}
	ctx->use_pool = nk_true;
	return 1;
}

NK_API int nk_init(struct nk_context* ctx, struct nk_allocator* alloc, const struct nk_user_font* font) {
	NK_ASSERT(alloc);
	if (!alloc) return 0;
	nk_setup(ctx, font);
	nk_buffer_init(&ctx->memory, alloc, NK_DEFAULT_COMMAND_BUFFER_SIZE);
	nk_pool_init(&ctx->pool, alloc, NK_POOL_DEFAULT_CAPACITY);
	ctx->use_pool = nk_true;
	return 1;
}

#ifdef NK_INCLUDE_COMMAND_USERDATA
NK_API void
nk_set_user_data(struct nk_context* ctx, nk_handle handle)
{
	if (!ctx) return;
	ctx->userdata = handle;
	if (ctx->current)
		ctx->current->buffer.userdata = handle;
}
#endif

NK_API void nk_free(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	nk_buffer_free(&ctx->memory);
	if (ctx->use_pool)
		nk_pool_free(&ctx->pool);

	nk_zero(&ctx->input, sizeof(ctx->input));
	nk_zero(&ctx->style, sizeof(ctx->style));
	nk_zero(&ctx->memory, sizeof(ctx->memory));

	ctx->seq = 0;
	ctx->build = 0;
	ctx->begin = 0;
	ctx->end = 0;
	ctx->active = 0;
	ctx->current = 0;
	ctx->freelist = 0;
	ctx->count = 0;
}

NK_API void nk_clear(struct nk_context* ctx) {
	struct nk_window* iter;
	struct nk_window* next;
	NK_ASSERT(ctx);

	if (!ctx) return;
	if (ctx->use_pool)
		nk_buffer_clear(&ctx->memory);
	else nk_buffer_reset(&ctx->memory, NK_BUFFER_FRONT);

	ctx->build = 0;
	ctx->memory.calls = 0;
	ctx->last_widget_state = 0;
	ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_ARROW];
	NK_MEMSET(&ctx->overlay, 0, sizeof(ctx->overlay));

	/* garbage collector */
	iter = ctx->begin;
	while (iter) {
		/* make sure valid minimized windows do not get removed */
		if ((iter->flags & NK_WINDOW_MINIMIZED) && !(iter->flags & NK_WINDOW_CLOSED) && iter->seq == ctx->seq) {
			iter = iter->next;
			continue;
		}
		/* remove hotness from hidden or closed windows*/
		if (((iter->flags & NK_WINDOW_HIDDEN) || (iter->flags & NK_WINDOW_CLOSED)) && iter == ctx->active) {
			ctx->active = iter->prev;
			ctx->end = iter->prev;
			if (!ctx->end)
				ctx->begin = 0;
			if (ctx->active)
				ctx->active->flags &= ~(unsigned)NK_WINDOW_ROM;
		}
		/* free unused popup windows */
		if (iter->popup.win && iter->popup.win->seq != ctx->seq) {
			nk_free_window(ctx, iter->popup.win);
			iter->popup.win = 0;
		}
		/* remove unused window state tables */
		{
			struct nk_table* n, * it = iter->tables;
			while (it) {
				n = it->next;
				if (it->seq != ctx->seq) {
					nk_remove_table(iter, it);
					nk_zero(it, sizeof(union nk_page_data));
					nk_free_table(ctx, it);
					if (it == iter->tables)
						iter->tables = n;
				}
				it = n;
			}
		}
		/* window itself is not used anymore so free */
		if (iter->seq != ctx->seq || iter->flags & NK_WINDOW_CLOSED) {
			next = iter->next;
			nk_remove_window(ctx, iter);
			nk_free_window(ctx, iter);
			iter = next;
		}
		else iter = iter->next;
	}
	ctx->seq++;
}

NK_LIB void nk_start_buffer(struct nk_context* ctx, struct nk_command_buffer* buffer) {
	NK_ASSERT(ctx);
	NK_ASSERT(buffer);
	if (!ctx || !buffer) return;
	buffer->begin = ctx->memory.allocated;
	buffer->end = buffer->begin;
	buffer->last = buffer->begin;
	buffer->clip = nk_null_rect;
}

NK_LIB void nk_start(struct nk_context* ctx, struct nk_window* win) {
	NK_ASSERT(ctx);
	NK_ASSERT(win);
	nk_start_buffer(ctx, &win->buffer);
}

NK_LIB void nk_start_popup(struct nk_context* ctx, struct nk_window* win) {
	struct nk_popup_buffer* buf;
	NK_ASSERT(ctx);
	NK_ASSERT(win);
	if (!ctx || !win) return;

	/* save buffer fill state for popup */
	buf = &win->popup.buf;
	buf->begin = win->buffer.end;
	buf->end = win->buffer.end;
	buf->parent = win->buffer.last;
	buf->last = buf->begin;
	buf->active = nk_true;
}

NK_LIB void nk_finish_popup(struct nk_context* ctx, struct nk_window* win) {
	struct nk_popup_buffer* buf;
	NK_ASSERT(ctx);
	NK_ASSERT(win);
	if (!ctx || !win) return;

	buf = &win->popup.buf;
	buf->last = win->buffer.last;
	buf->end = win->buffer.end;
}

NK_LIB void nk_finish_buffer(struct nk_context* ctx, struct nk_command_buffer* buffer) {
	NK_ASSERT(ctx);
	NK_ASSERT(buffer);
	if (!ctx || !buffer) return;
	buffer->end = ctx->memory.allocated;
}

NK_LIB void nk_finish(struct nk_context* ctx, struct nk_window* win) {
	struct nk_popup_buffer* buf;
	struct nk_command* parent_last;
	void* memory;

	NK_ASSERT(ctx);
	NK_ASSERT(win);
	if (!ctx || !win) return;
	nk_finish_buffer(ctx, &win->buffer);
	if (!win->popup.buf.active) return;

	buf = &win->popup.buf;
	memory = ctx->memory.memory.ptr;
	parent_last = nk_ptr_add(struct nk_command, memory, buf->parent);
	parent_last->next = buf->end;
}

NK_LIB void nk_build(struct nk_context* ctx) {
	struct nk_window* it = 0;
	struct nk_command* cmd = 0;
	nk_byte* buffer = 0;

	/* draw cursor overlay */
	if (!ctx->style.cursor_active)
		ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_ARROW];
	if (ctx->style.cursor_active && !ctx->input.mouse.grabbed && ctx->style.cursor_visible) {
		struct nk_rect mouse_bounds;
		const struct nk_cursor* cursor = ctx->style.cursor_active;
		nk_command_buffer_init(&ctx->overlay, &ctx->memory, NK_CLIPPING_OFF);
		nk_start_buffer(ctx, &ctx->overlay);

		mouse_bounds.x = ctx->input.mouse.pos.x - cursor->offset.x;
		mouse_bounds.y = ctx->input.mouse.pos.y - cursor->offset.y;
		mouse_bounds.w = cursor->size.x;
		mouse_bounds.h = cursor->size.y;

		nk_draw_image(&ctx->overlay, mouse_bounds, &cursor->img, nk_white);
		nk_finish_buffer(ctx, &ctx->overlay);
	}
	/* build one big draw command list out of all window buffers */
	it = ctx->begin;
	buffer = (nk_byte*)ctx->memory.memory.ptr;
	while (it != 0) {
		struct nk_window* next = it->next;
		if (it->buffer.last == it->buffer.begin || (it->flags & NK_WINDOW_HIDDEN) || it->seq != ctx->seq)
			goto cont;

		cmd = nk_ptr_add(struct nk_command, buffer, it->buffer.last);
		while (next &&
			((next->buffer.last == next->buffer.begin) || (next->flags & NK_WINDOW_HIDDEN) || next->seq != ctx->seq))
			next = next->next; /* skip empty command buffers */

		if (next) cmd->next = next->buffer.begin;
	cont:
		it = next;
	}
	/* append all popup draw commands into lists */
	it = ctx->begin;
	while (it != 0) {
		struct nk_window* next = it->next;
		struct nk_popup_buffer* buf;
		if (!it->popup.buf.active)
			goto skip;

		buf = &it->popup.buf;
		cmd->next = buf->begin;
		cmd = nk_ptr_add(struct nk_command, buffer, buf->last);
		buf->active = nk_false;
	skip:
		it = next;
	}
	if (cmd) {
		/* append overlay commands */
		if (ctx->overlay.end != ctx->overlay.begin)
			cmd->next = ctx->overlay.begin;
		else cmd->next = ctx->memory.allocated;
	}
}

NK_API const struct nk_command* nk__begin(struct nk_context* ctx) {
	struct nk_window* iter;
	nk_byte* buffer;
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	if (!ctx->count) return 0;

	buffer = (nk_byte*)ctx->memory.memory.ptr;
	if (!ctx->build) {
		nk_build(ctx);
		ctx->build = nk_true;
	}
	iter = ctx->begin;
	while (iter &&
		((iter->buffer.begin == iter->buffer.end) || (iter->flags & NK_WINDOW_HIDDEN) || iter->seq != ctx->seq))
		iter = iter->next;
	if (!iter) return 0;
	return nk_ptr_add_const(struct nk_command, buffer, iter->buffer.begin);
}

NK_API const struct nk_command* nk__next(struct nk_context* ctx, const struct nk_command* cmd) {
	nk_byte* buffer;
	const struct nk_command* next;
	NK_ASSERT(ctx);
	if (!ctx || !cmd || !ctx->count) return 0;
	if (cmd->next >= ctx->memory.allocated) return 0;
	buffer = (nk_byte*)ctx->memory.memory.ptr;
	next = nk_ptr_add_const(struct nk_command, buffer, cmd->next);
	return next;
}






/* ===============================================================
 *
 *                              POOL
 *
 * ===============================================================*/
NK_LIB void nk_pool_init(struct nk_pool* pool, struct nk_allocator* alloc, unsigned int capacity) {
	nk_zero(pool, sizeof(*pool));
	pool->alloc = *alloc;
	pool->capacity = capacity;
	pool->type = NK_BUFFER_DYNAMIC;
	pool->pages = 0;
}

NK_LIB void nk_pool_free(struct nk_pool* pool) {
	struct nk_page* iter = pool->pages;
	if (!pool) return;
	if (pool->type == NK_BUFFER_FIXED) return;
	while (iter) {
		struct nk_page* next = iter->next;
		pool->alloc.free(pool->alloc.userdata, iter);
		iter = next;
	}
}

NK_LIB void nk_pool_init_fixed(struct nk_pool* pool, void* memory, nk_size size) {
	nk_zero(pool, sizeof(*pool));
	NK_ASSERT(size >= sizeof(struct nk_page));
	if (size < sizeof(struct nk_page)) return;
	pool->capacity = (unsigned)(size - sizeof(struct nk_page)) / sizeof(struct nk_page_element);
	pool->pages = (struct nk_page*) memory;
	pool->type = NK_BUFFER_FIXED;
	pool->size = size;
}

NK_LIB struct nk_page_element* nk_pool_alloc(struct nk_pool* pool) {
	if (!pool->pages || pool->pages->size >= pool->capacity) {
		/* allocate new page */
		struct nk_page* page;
		if (pool->type == NK_BUFFER_FIXED) {
			NK_ASSERT(pool->pages);
			if (!pool->pages) return 0;
			NK_ASSERT(pool->pages->size < pool->capacity);
			return 0;
		}
		else {
			nk_size size = sizeof(struct nk_page);
			size += NK_POOL_DEFAULT_CAPACITY * sizeof(union nk_page_data);
			page = (struct nk_page*) pool->alloc.alloc(pool->alloc.userdata, 0, size);
			page->next = pool->pages;
			pool->pages = page;
			page->size = 0;
		}
	}
	return &pool->pages->win[pool->pages->size++];
}





/* ===============================================================
 *
 *                          PAGE ELEMENT
 *
 * ===============================================================*/
NK_LIB struct nk_page_element* nk_create_page_element(struct nk_context* ctx) {
	struct nk_page_element* elem;
	if (ctx->freelist) {
		/* unlink page element from free list */
		elem = ctx->freelist;
		ctx->freelist = elem->next;
	}
	else if (ctx->use_pool) {
		/* allocate page element from memory pool */
		elem = nk_pool_alloc(&ctx->pool);
		NK_ASSERT(elem);
		if (!elem) return 0;
	}
	else {
		/* allocate new page element from back of fixed size memory buffer */
		NK_STORAGE const nk_size size = sizeof(struct nk_page_element);
		NK_STORAGE const nk_size align = NK_ALIGNOF(struct nk_page_element);
		elem = (struct nk_page_element*) nk_buffer_alloc(&ctx->memory, NK_BUFFER_BACK, size, align);
		NK_ASSERT(elem);
		if (!elem) return 0;
	}
	nk_zero_struct(*elem);
	elem->next = 0;
	elem->prev = 0;
	return elem;
}

NK_LIB void nk_link_page_element_into_freelist(struct nk_context* ctx, struct nk_page_element* elem) {
	/* link table into freelist */
	if (!ctx->freelist) {
		ctx->freelist = elem;
	}
	else {
		elem->next = ctx->freelist;
		ctx->freelist = elem;
	}
}

NK_LIB void nk_free_page_element(struct nk_context* ctx, struct nk_page_element* elem) {
	/* we have a pool so just add to free list */
	if (ctx->use_pool) {
		nk_link_page_element_into_freelist(ctx, elem);
		return;
	}
	/* if possible remove last element from back of fixed memory buffer */
	{
		void* elem_end = (void*)(elem + 1);
		void* buffer_end = (nk_byte*)ctx->memory.memory.ptr + ctx->memory.size;
		if (elem_end == buffer_end)
			ctx->memory.size -= sizeof(struct nk_page_element);
		else nk_link_page_element_into_freelist(ctx, elem);
	}
}





/* ===============================================================
 *
 *                              TABLE
 *
 * ===============================================================*/
NK_LIB struct nk_table* nk_create_table(struct nk_context* ctx) {
	struct nk_page_element* elem;
	elem = nk_create_page_element(ctx);
	if (!elem) return 0;
	nk_zero_struct(*elem);
	return &elem->data.tbl;
}

NK_LIB void nk_free_table(struct nk_context* ctx, struct nk_table* tbl) {
	union nk_page_data* pd = NK_CONTAINER_OF(tbl, union nk_page_data, tbl);
	struct nk_page_element* pe = NK_CONTAINER_OF(pd, struct nk_page_element, data);
	nk_free_page_element(ctx, pe);
}

NK_LIB void nk_push_table(struct nk_window* win, struct nk_table* tbl) {
	if (!win->tables) {
		win->tables = tbl;
		tbl->next = 0;
		tbl->prev = 0;
		tbl->size = 0;
		win->table_count = 1;
		return;
	}
	win->tables->prev = tbl;
	tbl->next = win->tables;
	tbl->prev = 0;
	tbl->size = 0;
	win->tables = tbl;
	win->table_count++;
}

NK_LIB void nk_remove_table(struct nk_window* win, struct nk_table* tbl) {
	if (win->tables == tbl)
		win->tables = tbl->next;
	if (tbl->next)
		tbl->next->prev = tbl->prev;
	if (tbl->prev)
		tbl->prev->next = tbl->next;
	tbl->next = 0;
	tbl->prev = 0;
}

NK_LIB nk_uint* nk_add_value(struct nk_context* ctx, struct nk_window* win, nk_hash name, nk_uint value) {
	NK_ASSERT(ctx);
	NK_ASSERT(win);
	if (!win || !ctx) return 0;
	if (!win->tables || win->tables->size >= NK_VALUE_PAGE_CAPACITY) {
		struct nk_table* tbl = nk_create_table(ctx);
		NK_ASSERT(tbl);
		if (!tbl) return 0;
		nk_push_table(win, tbl);
	}
	win->tables->seq = win->seq;
	win->tables->keys[win->tables->size] = name;
	win->tables->values[win->tables->size] = value;
	return &win->tables->values[win->tables->size++];
}

NK_LIB nk_uint* nk_find_value(struct nk_window* win, nk_hash name) {
	struct nk_table* iter = win->tables;
	while (iter) {
		unsigned int i = 0;
		unsigned int size = iter->size;
		for (i = 0; i < size; ++i) {
			if (iter->keys[i] == name) {
				iter->seq = win->seq;
				return &iter->values[i];
			}
		}
		size = NK_VALUE_PAGE_CAPACITY;
		iter = iter->next;
	}
	return 0;
}





/* ===============================================================
 *
 *                              PANEL
 *
 * ===============================================================*/
NK_LIB void* nk_create_panel(struct nk_context* ctx) {
	struct nk_page_element* elem;
	elem = nk_create_page_element(ctx);
	if (!elem) return 0;
	nk_zero_struct(*elem);
	return &elem->data.pan;
}

NK_LIB void nk_free_panel(struct nk_context* ctx, struct nk_panel* pan) {
	union nk_page_data* pd = NK_CONTAINER_OF(pan, union nk_page_data, pan);
	struct nk_page_element* pe = NK_CONTAINER_OF(pd, struct nk_page_element, data);
	nk_free_page_element(ctx, pe);
}

NK_LIB int nk_panel_has_header(nk_flags flags, const char* title) {
	int active = 0;
	active = (flags & (NK_WINDOW_CLOSABLE | NK_WINDOW_MINIMIZABLE));
	active = active || (flags & NK_WINDOW_TITLE);
	active = active && !(flags & NK_WINDOW_HIDDEN) && title;
	return active;
}

NK_LIB struct nk_vec2 nk_panel_get_padding(const struct nk_style* style, enum nk_panel_type type) {
	switch (type) {
	default:
	case NK_PANEL_WINDOW:
		return style->window.padding;
	case NK_PANEL_GROUP:
		return style->window.group_padding;
	case NK_PANEL_POPUP:
		return style->window.popup_padding;
	case NK_PANEL_CONTEXTUAL:
		return style->window.contextual_padding;
	case NK_PANEL_COMBO:
		return style->window.combo_padding;
	case NK_PANEL_MENU:
		return style->window.menu_padding;
	case NK_PANEL_TOOLTIP:
		return style->window.menu_padding;
	}
}

NK_LIB float nk_panel_get_border(const struct nk_style* style, nk_flags flags, enum nk_panel_type type) {
	if (flags & NK_WINDOW_BORDER) {
		switch (type) {
		default:
		case NK_PANEL_WINDOW:
			return style->window.border;
		case NK_PANEL_GROUP:
			return style->window.group_border;
		case NK_PANEL_POPUP:
			return style->window.popup_border;
		case NK_PANEL_CONTEXTUAL:
			return style->window.contextual_border;
		case NK_PANEL_COMBO:
			return style->window.combo_border;
		case NK_PANEL_MENU:
			return style->window.menu_border;
		case NK_PANEL_TOOLTIP:
			return style->window.menu_border;
		}
	}
	else return 0;
}

NK_LIB struct nk_color nk_panel_get_border_color(const struct nk_style* style, enum nk_panel_type type) {
	switch (type) {
	default:
	case NK_PANEL_WINDOW:
		return style->window.border_color;
	case NK_PANEL_GROUP:
		return style->window.group_border_color;
	case NK_PANEL_POPUP:
		return style->window.popup_border_color;
	case NK_PANEL_CONTEXTUAL:
		return style->window.contextual_border_color;
	case NK_PANEL_COMBO:
		return style->window.combo_border_color;
	case NK_PANEL_MENU:
		return style->window.menu_border_color;
	case NK_PANEL_TOOLTIP:
		return style->window.menu_border_color;
	}
}

NK_LIB int nk_panel_is_sub(enum nk_panel_type type) {
	return (type & NK_PANEL_SET_SUB) ? 1 : 0;
}

NK_LIB int nk_panel_is_nonblock(enum nk_panel_type type) {
	return (type & NK_PANEL_SET_NONBLOCK) ? 1 : 0;
}

NK_LIB int nk_panel_begin(struct nk_context* ctx, const char* title, enum nk_panel_type panel_type) {
	struct nk_input* in;
	struct nk_window* win;
	struct nk_panel* layout;
	struct nk_command_buffer* out;
	const struct nk_style* style;
	const struct nk_user_font* font;

	struct nk_vec2 scrollbar_size;
	struct nk_vec2 panel_padding;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return 0;
	nk_zero(ctx->current->layout, sizeof(*ctx->current->layout));
	if ((ctx->current->flags & NK_WINDOW_HIDDEN) || (ctx->current->flags & NK_WINDOW_CLOSED)) {
		nk_zero(ctx->current->layout, sizeof(struct nk_panel));
		ctx->current->layout->type = panel_type;
		return 0;
	}
	/* pull state into local stack */
	style = &ctx->style;
	font = style->font;
	win = ctx->current;
	layout = win->layout;
	out = &win->buffer;
	in = (win->flags & NK_WINDOW_NO_INPUT) ? 0 : &ctx->input;
#ifdef NK_INCLUDE_COMMAND_USERDATA
	win->buffer.userdata = ctx->userdata;
#endif
	/* pull style configuration into local stack */
	scrollbar_size = style->window.scrollbar_size;
	panel_padding = nk_panel_get_padding(style, panel_type);

	/* window movement */
	if ((win->flags & NK_WINDOW_MOVABLE) && !(win->flags & NK_WINDOW_ROM)) {
		int left_mouse_down;
		int left_mouse_clicked;
		int left_mouse_click_in_cursor;

		/* calculate draggable window space */
		struct nk_rect header;
		header.x = win->bounds.x;
		header.y = win->bounds.y;
		header.w = win->bounds.w;
		if (nk_panel_has_header(win->flags, title)) {
			header.h = font->height + 2.0f * style->window.header.padding.y;
			header.h += 2.0f * style->window.header.label_padding.y;
		}
		else header.h = panel_padding.y;

		/* window movement by dragging */
		left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
		left_mouse_clicked = (int)in->mouse.buttons[NK_BUTTON_LEFT].clicked;
		left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, header, nk_true);
		if (left_mouse_down && left_mouse_click_in_cursor && !left_mouse_clicked) {
			win->bounds.x = win->bounds.x + in->mouse.delta.x;
			win->bounds.y = win->bounds.y + in->mouse.delta.y;
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x += in->mouse.delta.x;
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y += in->mouse.delta.y;
			ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_MOVE];
		}
	}

	/* setup panel */
	layout->type = panel_type;
	layout->flags = win->flags;
	layout->bounds = win->bounds;
	layout->bounds.x += panel_padding.x;
	layout->bounds.w -= 2 * panel_padding.x;
	if (win->flags & NK_WINDOW_BORDER) {
		layout->border = nk_panel_get_border(style, win->flags, panel_type);
		layout->bounds = nk_shrink_rect(layout->bounds, layout->border);
	}
	else layout->border = 0;
	layout->at_y = layout->bounds.y;
	layout->at_x = layout->bounds.x;
	layout->max_x = 0;
	layout->header_height = 0;
	layout->footer_height = 0;
	nk_layout_reset_min_row_height(ctx);
	layout->row.index = 0;
	layout->row.columns = 0;
	layout->row.ratio = 0;
	layout->row.item_width = 0;
	layout->row.tree_depth = 0;
	layout->row.height = panel_padding.y;
	layout->has_scrolling = nk_true;
	if (!(win->flags & NK_WINDOW_NO_SCROLLBAR))
		layout->bounds.w -= scrollbar_size.x;
	if (!nk_panel_is_nonblock(panel_type)) {
		layout->footer_height = 0;
		if (!(win->flags & NK_WINDOW_NO_SCROLLBAR) || win->flags & NK_WINDOW_SCALABLE)
			layout->footer_height = scrollbar_size.y;
		layout->bounds.h -= layout->footer_height;
	}

	/* panel header */
	if (nk_panel_has_header(win->flags, title)) {
		struct nk_text text;
		struct nk_rect header;
		const struct nk_style_item* background = 0;

		/* calculate header bounds */
		header.x = win->bounds.x;
		header.y = win->bounds.y;
		header.w = win->bounds.w;
		header.h = font->height + 2.0f * style->window.header.padding.y;
		header.h += (2.0f * style->window.header.label_padding.y);

		/* shrink panel by header */
		layout->header_height = header.h;
		layout->bounds.y += header.h;
		layout->bounds.h -= header.h;
		layout->at_y += header.h;

		/* select correct header background and text color */
		if (ctx->active == win) {
			background = &style->window.header.active;
			text.text = style->window.header.label_active;
		}
		else if (nk_input_is_mouse_hovering_rect(&ctx->input, header)) {
			background = &style->window.header.hover;
			text.text = style->window.header.label_hover;
		}
		else {
			background = &style->window.header.normal;
			text.text = style->window.header.label_normal;
		}

		/* draw header background */
		header.h += 1.0f;
		if (background->type == NK_STYLE_ITEM_IMAGE) {
			text.background = nk_rgba(0, 0, 0, 0);
			nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
		}
		else {
			text.background = background->data.color;
			nk_fill_rect(out, header, 0, background->data.color);
		}

		/* window close button */
		{
			struct nk_rect button;
			button.y = header.y + style->window.header.padding.y;
			button.h = header.h - 2 * style->window.header.padding.y;
			button.w = button.h;
			if (win->flags & NK_WINDOW_CLOSABLE) {
				nk_flags ws = 0;
				if (style->window.header.align == NK_HEADER_RIGHT) {
					button.x = (header.w + header.x) - (button.w + style->window.header.padding.x);
					header.w -= button.w + style->window.header.spacing.x + style->window.header.padding.x;
				}
				else {
					button.x = header.x + style->window.header.padding.x;
					header.x += button.w + style->window.header.spacing.x + style->window.header.padding.x;
				}

				if (nk_do_button_symbol(&ws, &win->buffer, button, style->window.header.close_symbol, NK_BUTTON_DEFAULT,
					&style->window.header.close_button, in, style->font) &&
					!(win->flags & NK_WINDOW_ROM)) {
					layout->flags |= NK_WINDOW_HIDDEN;
					layout->flags &= (nk_flags)~NK_WINDOW_MINIMIZED;
				}
			}

			/* window minimize button */
			if (win->flags & NK_WINDOW_MINIMIZABLE) {
				nk_flags ws = 0;
				if (style->window.header.align == NK_HEADER_RIGHT) {
					button.x = (header.w + header.x) - button.w;
					if (!(win->flags & NK_WINDOW_CLOSABLE)) {
						button.x -= style->window.header.padding.x;
						header.w -= style->window.header.padding.x;
					}
					header.w -= button.w + style->window.header.spacing.x;
				}
				else {
					button.x = header.x;
					header.x += button.w + style->window.header.spacing.x + style->window.header.padding.x;
				}
				if (nk_do_button_symbol(&ws, &win->buffer, button,
					(layout->flags & NK_WINDOW_MINIMIZED) ? style->window.header.maximize_symbol
					: style->window.header.minimize_symbol,
					NK_BUTTON_DEFAULT, &style->window.header.minimize_button, in, style->font) &&
					!(win->flags & NK_WINDOW_ROM))
					layout->flags = (layout->flags & NK_WINDOW_MINIMIZED) ? layout->flags &
					(nk_flags)~NK_WINDOW_MINIMIZED :
					layout->flags | NK_WINDOW_MINIMIZED;
			}
		}

		{/* window header title */
			int text_len = nk_strlen(title);
			struct nk_rect label = { 0, 0, 0, 0 };
			float t = font->width(font->userdata, font->height, title, text_len);
			text.padding = nk_vec2(0, 0);

			label.x = header.x + style->window.header.padding.x;
			label.x += style->window.header.label_padding.x;
			label.y = header.y + style->window.header.label_padding.y;
			label.h = font->height + 2 * style->window.header.label_padding.y;
			label.w = t + 2 * style->window.header.spacing.x;
			label.w = NK_CLAMP(0, label.w, header.x + header.w - label.x);
			nk_widget_text(out, label, (const char*)title, text_len, &text, NK_TEXT_LEFT, font);
		}
	}

	/* draw window background */
	if (!(layout->flags & NK_WINDOW_MINIMIZED) && !(layout->flags & NK_WINDOW_DYNAMIC)) {
		struct nk_rect body;
		body.x = win->bounds.x;
		body.w = win->bounds.w;
		body.y = (win->bounds.y + layout->header_height);
		body.h = (win->bounds.h - layout->header_height);
		if (style->window.fixed_background.type == NK_STYLE_ITEM_IMAGE)
			nk_draw_image(out, body, &style->window.fixed_background.data.image, nk_white);
		else nk_fill_rect(out, body, 0, style->window.fixed_background.data.color);
	}

	/* set clipping rectangle */
	{
		struct nk_rect clip;
		layout->clip = layout->bounds;
		nk_unify(&clip, &win->buffer.clip, layout->clip.x, layout->clip.y, layout->clip.x + layout->clip.w,
			layout->clip.y + layout->clip.h);
		nk_push_scissor(out, clip);
		layout->clip = clip;
	}
	return !(layout->flags & NK_WINDOW_HIDDEN) && !(layout->flags & NK_WINDOW_MINIMIZED);
}

NK_LIB void nk_panel_end(struct nk_context* ctx) {
	struct nk_input* in;
	struct nk_window* window;
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_command_buffer* out;

	struct nk_vec2 scrollbar_size;
	struct nk_vec2 panel_padding;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	window = ctx->current;
	layout = window->layout;
	style = &ctx->style;
	out = &window->buffer;
	in = (layout->flags & NK_WINDOW_ROM || layout->flags & NK_WINDOW_NO_INPUT) ? 0 : &ctx->input;
	if (!nk_panel_is_sub(layout->type))
		nk_push_scissor(out, nk_null_rect);

	/* cache configuration data */
	scrollbar_size = style->window.scrollbar_size;
	panel_padding = nk_panel_get_padding(style, layout->type);

	/* update the current cursor Y-position to point over the last added widget */
	layout->at_y += layout->row.height;

	/* dynamic panels */
	if (layout->flags & NK_WINDOW_DYNAMIC && !(layout->flags & NK_WINDOW_MINIMIZED)) {
		/* update panel height to fit dynamic growth */
		struct nk_rect empty_space;
		if (layout->at_y < (layout->bounds.y + layout->bounds.h))
			layout->bounds.h = layout->at_y - layout->bounds.y;

		/* fill top empty space */
		empty_space.x = window->bounds.x;
		empty_space.y = layout->bounds.y;
		empty_space.h = panel_padding.y;
		empty_space.w = window->bounds.w;
		nk_fill_rect(out, empty_space, 0, style->window.background);

		/* fill left empty space */
		empty_space.x = window->bounds.x;
		empty_space.y = layout->bounds.y;
		empty_space.w = panel_padding.x + layout->border;
		empty_space.h = layout->bounds.h;
		nk_fill_rect(out, empty_space, 0, style->window.background);

		/* fill right empty space */
		empty_space.x = layout->bounds.x + layout->bounds.w - layout->border;
		empty_space.y = layout->bounds.y;
		empty_space.w = panel_padding.x + layout->border;
		empty_space.h = layout->bounds.h;
		if (*layout->offset_y == 0 && !(layout->flags & NK_WINDOW_NO_SCROLLBAR))
			empty_space.w += scrollbar_size.x;
		nk_fill_rect(out, empty_space, 0, style->window.background);

		/* fill bottom empty space */
		if (layout->footer_height > 0) {
			empty_space.x = window->bounds.x;
			empty_space.y = layout->bounds.y + layout->bounds.h;
			empty_space.w = window->bounds.w;
			empty_space.h = layout->footer_height;
			nk_fill_rect(out, empty_space, 0, style->window.background);
		}
	}

	/* scrollbars */
	if (!(layout->flags & NK_WINDOW_NO_SCROLLBAR) && !(layout->flags & NK_WINDOW_MINIMIZED) &&
		window->scrollbar_hiding_timer < NK_SCROLLBAR_HIDING_TIMEOUT) {
		struct nk_rect scroll;
		int scroll_has_scrolling;
		float scroll_target;
		float scroll_offset;
		float scroll_step;
		float scroll_inc;

		/* mouse wheel scrolling */
		if (nk_panel_is_sub(layout->type)) {
			/* sub-window mouse wheel scrolling */
			struct nk_window* root_window = window;
			struct nk_panel* root_panel = window->layout;
			while (root_panel->parent)
				root_panel = root_panel->parent;
			while (root_window->parent)
				root_window = root_window->parent;

			/* only allow scrolling if parent window is active */
			scroll_has_scrolling = 0;
			if ((root_window == ctx->active) && layout->has_scrolling) {
				/* and panel is being hovered and inside clip rect*/
				if (nk_input_is_mouse_hovering_rect(in, layout->bounds) &&
					NK_INTERSECT(layout->bounds.x, layout->bounds.y, layout->bounds.w, layout->bounds.h,
						root_panel->clip.x, root_panel->clip.y, root_panel->clip.w, root_panel->clip.h)) {
					/* deactivate all parent scrolling */
					root_panel = window->layout;
					while (root_panel->parent) {
						root_panel->has_scrolling = nk_false;
						root_panel = root_panel->parent;
					}
					root_panel->has_scrolling = nk_false;
					scroll_has_scrolling = nk_true;
				}
			}
		}
		else if (!nk_panel_is_sub(layout->type)) {
			/* window mouse wheel scrolling */
			scroll_has_scrolling = (window == ctx->active) && layout->has_scrolling;
			if (in && (in->mouse.scroll_delta.y > 0 || in->mouse.scroll_delta.x > 0) && scroll_has_scrolling)
				window->scrolled = nk_true;
			else window->scrolled = nk_false;
		}
		else scroll_has_scrolling = nk_false;

		{
			/* vertical scrollbar */
			nk_flags state = 0;
			scroll.x = layout->bounds.x + layout->bounds.w + panel_padding.x;
			scroll.y = layout->bounds.y;
			scroll.w = scrollbar_size.x;
			scroll.h = layout->bounds.h;

			scroll_offset = (float)*layout->offset_y;
			scroll_step = scroll.h * 0.10f;
			scroll_inc = scroll.h * 0.01f;
			scroll_target = (float)(int)(layout->at_y - scroll.y);
			scroll_offset = nk_do_scrollbarv(&state, out, scroll, scroll_has_scrolling, scroll_offset, scroll_target,
				scroll_step, scroll_inc, &ctx->style.scrollv, in, style->font);
			*layout->offset_y = (nk_uint)scroll_offset;
			if (in && scroll_has_scrolling)
				in->mouse.scroll_delta.y = 0;
		}
		{
			/* horizontal scrollbar */
			nk_flags state = 0;
			scroll.x = layout->bounds.x;
			scroll.y = layout->bounds.y + layout->bounds.h;
			scroll.w = layout->bounds.w;
			scroll.h = scrollbar_size.y;

			scroll_offset = (float)*layout->offset_x;
			scroll_target = (float)(int)(layout->max_x - scroll.x);
			scroll_step = layout->max_x * 0.05f;
			scroll_inc = layout->max_x * 0.005f;
			scroll_offset = nk_do_scrollbarh(&state, out, scroll, scroll_has_scrolling, scroll_offset, scroll_target,
				scroll_step, scroll_inc, &ctx->style.scrollh, in, style->font);
			*layout->offset_x = (nk_uint)scroll_offset;
		}
	}

	/* hide scroll if no user input */
	if (window->flags & NK_WINDOW_SCROLL_AUTO_HIDE) {
		int has_input =
			ctx->input.mouse.delta.x != 0 || ctx->input.mouse.delta.y != 0 || ctx->input.mouse.scroll_delta.y != 0;
		int is_window_hovered = nk_window_is_hovered(ctx);
		int any_item_active = (ctx->last_widget_state & NK_WIDGET_STATE_MODIFIED);
		if ((!has_input && is_window_hovered) || (!is_window_hovered && !any_item_active))
			window->scrollbar_hiding_timer += ctx->delta_time_seconds;
		else window->scrollbar_hiding_timer = 0;
	}
	else window->scrollbar_hiding_timer = 0;

	/* window border */
	if (layout->flags & NK_WINDOW_BORDER) {
		struct nk_color border_color = nk_panel_get_border_color(style, layout->type);
		const float padding_y = (layout->flags & NK_WINDOW_MINIMIZED) ? (style->window.border + window->bounds.y +
			layout->header_height) : ((layout->flags &
				NK_WINDOW_DYNAMIC)
				? (layout->bounds.y +
					layout->bounds.h +
					layout->footer_height)
				: (window->bounds.y +
					window->bounds.h));
		struct nk_rect b = window->bounds;
		b.h = padding_y - window->bounds.y;
		nk_stroke_rect(out, b, 0, layout->border, border_color);
	}

	/* scaler */
	if ((layout->flags & NK_WINDOW_SCALABLE) && in && !(layout->flags & NK_WINDOW_MINIMIZED)) {
		/* calculate scaler bounds */
		struct nk_rect scaler;
		scaler.w = scrollbar_size.x;
		scaler.h = scrollbar_size.y;
		scaler.y = layout->bounds.y + layout->bounds.h;
		if (layout->flags & NK_WINDOW_SCALE_LEFT)
			scaler.x = layout->bounds.x - panel_padding.x * 0.5f;
		else scaler.x = layout->bounds.x + layout->bounds.w + panel_padding.x;
		if (layout->flags & NK_WINDOW_NO_SCROLLBAR)
			scaler.x -= scaler.w;

		/* draw scaler */
		{
			const struct nk_style_item* item = &style->window.scaler;
			if (item->type == NK_STYLE_ITEM_IMAGE)
				nk_draw_image(out, scaler, &item->data.image, nk_white);
			else {
				if (layout->flags & NK_WINDOW_SCALE_LEFT) {
					nk_fill_triangle(out, scaler.x, scaler.y, scaler.x, scaler.y + scaler.h, scaler.x + scaler.w,
						scaler.y + scaler.h, item->data.color);
				}
				else {
					nk_fill_triangle(out, scaler.x + scaler.w, scaler.y, scaler.x + scaler.w, scaler.y + scaler.h,
						scaler.x, scaler.y + scaler.h, item->data.color);
				}
			}
		}

		/* do window scaling */
		if (!(window->flags & NK_WINDOW_ROM)) {
			struct nk_vec2 window_size = style->window.min_size;
			int left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
			int left_mouse_click_in_scaler = nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, scaler, nk_true);

			if (left_mouse_down && left_mouse_click_in_scaler) {
				float delta_x = in->mouse.delta.x;
				if (layout->flags & NK_WINDOW_SCALE_LEFT) {
					delta_x = -delta_x;
					window->bounds.x += in->mouse.delta.x;
				}
				/* dragging in x-direction  */
				if (window->bounds.w + delta_x >= window_size.x) {
					if ((delta_x < 0) || (delta_x > 0 && in->mouse.pos.x >= scaler.x)) {
						window->bounds.w = window->bounds.w + delta_x;
						scaler.x += in->mouse.delta.x;
					}
				}
				/* dragging in y-direction (only possible if static window) */
				if (!(layout->flags & NK_WINDOW_DYNAMIC)) {
					if (window_size.y < window->bounds.h + in->mouse.delta.y) {
						if ((in->mouse.delta.y < 0) || (in->mouse.delta.y > 0 && in->mouse.pos.y >= scaler.y)) {
							window->bounds.h = window->bounds.h + in->mouse.delta.y;
							scaler.y += in->mouse.delta.y;
						}
					}
				}
				ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT];
				in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = scaler.x + scaler.w / 2.0f;
				in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y = scaler.y + scaler.h / 2.0f;
			}
		}
	}
	if (!nk_panel_is_sub(layout->type)) {
		/* window is hidden so clear command buffer  */
		if (layout->flags & NK_WINDOW_HIDDEN)
			nk_command_buffer_reset(&window->buffer);
		/* window is visible and not tab */
		else nk_finish(ctx, window);
	}

	/* NK_WINDOW_REMOVE_ROM flag was set so remove NK_WINDOW_ROM */
	if (layout->flags & NK_WINDOW_REMOVE_ROM) {
		layout->flags &= ~(nk_flags)NK_WINDOW_ROM;
		layout->flags &= ~(nk_flags)NK_WINDOW_REMOVE_ROM;
	}
	window->flags = layout->flags;

	/* property garbage collector */
	if (window->property.active && window->property.old != window->property.seq &&
		window->property.active == window->property.prev) {
		nk_zero(&window->property, sizeof(window->property));
	}
	else {
		window->property.old = window->property.seq;
		window->property.prev = window->property.active;
		window->property.seq = 0;
	}
	/* edit garbage collector */
	if (window->edit.active && window->edit.old != window->edit.seq && window->edit.active == window->edit.prev) {
		nk_zero(&window->edit, sizeof(window->edit));
	}
	else {
		window->edit.old = window->edit.seq;
		window->edit.prev = window->edit.active;
		window->edit.seq = 0;
	}
	/* contextual garbage collector */
	if (window->popup.active_con && window->popup.con_old != window->popup.con_count) {
		window->popup.con_count = 0;
		window->popup.con_old = 0;
		window->popup.active_con = 0;
	}
	else {
		window->popup.con_old = window->popup.con_count;
		window->popup.con_count = 0;
	}
	window->popup.combo_count = 0;
	/* helper to make sure you have a 'nk_tree_push' for every 'nk_tree_pop' */
	NK_ASSERT(!layout->row.tree_depth);
}





/* ===============================================================
 *
 *                              WINDOW
 *
 * ===============================================================*/
NK_LIB void* nk_create_window(struct nk_context* ctx) {
	struct nk_page_element* elem;
	elem = nk_create_page_element(ctx);
	if (!elem) return 0;
	elem->data.win.seq = ctx->seq;
	return &elem->data.win;
}

NK_LIB void nk_free_window(struct nk_context* ctx, struct nk_window* win) {
	/* unlink windows from list */
	struct nk_table* it = win->tables;
	if (win->popup.win) {
		nk_free_window(ctx, win->popup.win);
		win->popup.win = 0;
	}
	win->next = 0;
	win->prev = 0;

	while (it) {
		/*free window state tables */
		struct nk_table* n = it->next;
		nk_remove_table(win, it);
		nk_free_table(ctx, it);
		if (it == win->tables)
			win->tables = n;
		it = n;
	}

	/* link windows into freelist */
	{
		union nk_page_data* pd = NK_CONTAINER_OF(win, union nk_page_data, win);
		struct nk_page_element* pe = NK_CONTAINER_OF(pd, struct nk_page_element, data);
		nk_free_page_element(ctx, pe);
	}
}

NK_LIB struct nk_window* nk_find_window(struct nk_context* ctx, nk_hash hash, const char* name) {
	struct nk_window* iter;
	iter = ctx->begin;
	while (iter) {
		NK_ASSERT(iter != iter->next);
		if (iter->name == hash) {
			int max_len = nk_strlen(iter->name_string);
			if (!nk_stricmpn(iter->name_string, name, max_len))
				return iter;
		}
		iter = iter->next;
	}
	return 0;
}

NK_LIB void nk_insert_window(struct nk_context* ctx, struct nk_window* win, enum nk_window_insert_location loc) {
	const struct nk_window* iter;
	NK_ASSERT(ctx);
	NK_ASSERT(win);
	if (!win || !ctx) return;

	iter = ctx->begin;
	while (iter) {
		NK_ASSERT(iter != iter->next);
		NK_ASSERT(iter != win);
		if (iter == win) return;
		iter = iter->next;
	}

	if (!ctx->begin) {
		win->next = 0;
		win->prev = 0;
		ctx->begin = win;
		ctx->end = win;
		ctx->count = 1;
		return;
	}
	if (loc == NK_INSERT_BACK) {
		struct nk_window* end;
		end = ctx->end;
		end->flags |= NK_WINDOW_ROM;
		end->next = win;
		win->prev = ctx->end;
		win->next = 0;
		ctx->end = win;
		ctx->active = ctx->end;
		ctx->end->flags &= ~(nk_flags)NK_WINDOW_ROM;
	}
	else {
		/*ctx->end->flags |= NK_WINDOW_ROM;*/
		ctx->begin->prev = win;
		win->next = ctx->begin;
		win->prev = 0;
		ctx->begin = win;
		ctx->begin->flags &= ~(nk_flags)NK_WINDOW_ROM;
	}
	ctx->count++;
}

NK_LIB void nk_remove_window(struct nk_context* ctx, struct nk_window* win) {
	if (win == ctx->begin || win == ctx->end) {
		if (win == ctx->begin) {
			ctx->begin = win->next;
			if (win->next)
				win->next->prev = 0;
		}
		if (win == ctx->end) {
			ctx->end = win->prev;
			if (win->prev)
				win->prev->next = 0;
		}
	}
	else {
		if (win->next)
			win->next->prev = win->prev;
		if (win->prev)
			win->prev->next = win->next;
	}
	if (win == ctx->active || !ctx->active) {
		ctx->active = ctx->end;
		if (ctx->end)
			ctx->end->flags &= ~(nk_flags)NK_WINDOW_ROM;
	}
	win->next = 0;
	win->prev = 0;
	ctx->count--;
}

NK_API int nk_begin(struct nk_context* ctx, const char* title, struct nk_rect bounds, nk_flags flags) {
	return nk_begin_titled(ctx, title, title, bounds, flags);
}

NK_API int
nk_begin_titled(struct nk_context* ctx, const char* name, const char* title, struct nk_rect bounds, nk_flags flags) {
	struct nk_window* win;
	struct nk_style* style;
	nk_hash name_hash;
	int name_len;
	int ret = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(name);
	NK_ASSERT(title);
	NK_ASSERT(ctx->style.font && ctx->style.font->width && "if this triggers you forgot to add a font");
	NK_ASSERT(!ctx->current && "if this triggers you missed a `nk_end` call");
	if (!ctx || ctx->current || !title || !name)
		return 0;

	/* find or create window */
	style = &ctx->style;
	name_len = (int)nk_strlen(name);
	name_hash = nk_murmur_hash(name, (int)name_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, name_hash, name);
	if (!win) {
		/* create new window */
		nk_size name_length = (nk_size)name_len;
		win = (struct nk_window*) nk_create_window(ctx);
		NK_ASSERT(win);
		if (!win) return 0;

		if (flags & NK_WINDOW_BACKGROUND)
			nk_insert_window(ctx, win, NK_INSERT_FRONT);
		else nk_insert_window(ctx, win, NK_INSERT_BACK);
		nk_command_buffer_init(&win->buffer, &ctx->memory, NK_CLIPPING_ON);

		win->flags = flags;
		win->bounds = bounds;
		win->name = name_hash;
		name_length = NK_MIN(name_length, NK_WINDOW_MAX_NAME - 1);
		NK_MEMCPY(win->name_string, name, name_length);
		win->name_string[name_length] = 0;
		win->popup.win = 0;
		if (!ctx->active)
			ctx->active = win;
	}
	else {
		/* update window */
		win->flags &= ~(nk_flags)(NK_WINDOW_PRIVATE - 1);
		win->flags |= flags;
		if (!(win->flags & (NK_WINDOW_MOVABLE | NK_WINDOW_SCALABLE)))
			win->bounds = bounds;
		/* If this assert triggers you either:
		 *
		 * I.) Have more than one window with the same name or
		 * II.) You forgot to actually draw the window.
		 *      More specific you did not call `nk_clear` (nk_clear will be
		 *      automatically called for you if you are using one of the
		 *      provided demo backends). */
		NK_ASSERT(win->seq != ctx->seq);
		win->seq = ctx->seq;
		if (!ctx->active && !(win->flags & NK_WINDOW_HIDDEN)) {
			ctx->active = win;
			ctx->end = win;
		}
	}
	if (win->flags & NK_WINDOW_HIDDEN) {
		ctx->current = win;
		win->layout = 0;
		return 0;
	}
	else nk_start(ctx, win);

	/* window overlapping */
	if (!(win->flags & NK_WINDOW_HIDDEN) && !(win->flags & NK_WINDOW_NO_INPUT)) {
		int inpanel, ishovered;
		struct nk_window* iter = win;
		float h = ctx->style.font->height + 2.0f * style->window.header.padding.y +
			(2.0f * style->window.header.label_padding.y);
		struct nk_rect win_bounds = (!(win->flags & NK_WINDOW_MINIMIZED)) ? win->bounds : nk_rect(win->bounds.x,
			win->bounds.y,
			win->bounds.w, h);

		/* activate window if hovered and no other window is overlapping this window */
		inpanel = nk_input_has_mouse_click_down_in_rect(&ctx->input, NK_BUTTON_LEFT, win_bounds, nk_true);
		inpanel = inpanel && ctx->input.mouse.buttons[NK_BUTTON_LEFT].clicked;
		ishovered = nk_input_is_mouse_hovering_rect(&ctx->input, win_bounds);
		if ((win != ctx->active) && ishovered && !ctx->input.mouse.buttons[NK_BUTTON_LEFT].down) {
			iter = win->next;
			while (iter) {
				struct nk_rect iter_bounds = (!(iter->flags & NK_WINDOW_MINIMIZED)) ? iter->bounds : nk_rect(
					iter->bounds.x, iter->bounds.y, iter->bounds.w, h);
				if (NK_INTERSECT(win_bounds.x, win_bounds.y, win_bounds.w, win_bounds.h, iter_bounds.x, iter_bounds.y,
					iter_bounds.w, iter_bounds.h) && (!(iter->flags & NK_WINDOW_HIDDEN)))
					break;

				if (iter->popup.win && iter->popup.active && !(iter->flags & NK_WINDOW_HIDDEN) &&
					NK_INTERSECT(win->bounds.x, win_bounds.y, win_bounds.w, win_bounds.h, iter->popup.win->bounds.x,
						iter->popup.win->bounds.y, iter->popup.win->bounds.w, iter->popup.win->bounds.h))
					break;
				iter = iter->next;
			}
		}

		/* activate window if clicked */
		if (iter && inpanel && (win != ctx->end)) {
			iter = win->next;
			while (iter) {
				/* try to find a panel with higher priority in the same position */
				struct nk_rect iter_bounds = (!(iter->flags & NK_WINDOW_MINIMIZED)) ? iter->bounds : nk_rect(
					iter->bounds.x, iter->bounds.y, iter->bounds.w, h);
				if (NK_INBOX(ctx->input.mouse.pos.x, ctx->input.mouse.pos.y, iter_bounds.x, iter_bounds.y,
					iter_bounds.w, iter_bounds.h) && !(iter->flags & NK_WINDOW_HIDDEN))
					break;
				if (iter->popup.win && iter->popup.active && !(iter->flags & NK_WINDOW_HIDDEN) &&
					NK_INTERSECT(win_bounds.x, win_bounds.y, win_bounds.w, win_bounds.h, iter->popup.win->bounds.x,
						iter->popup.win->bounds.y, iter->popup.win->bounds.w, iter->popup.win->bounds.h))
					break;
				iter = iter->next;
			}
		}
		if (iter && !(win->flags & NK_WINDOW_ROM) && (win->flags & NK_WINDOW_BACKGROUND)) {
			win->flags |= (nk_flags)NK_WINDOW_ROM;
			iter->flags &= ~(nk_flags)NK_WINDOW_ROM;
			ctx->active = iter;
			if (!(iter->flags & NK_WINDOW_BACKGROUND)) {
				/* current window is active in that position so transfer to top
				 * at the highest priority in stack */
				nk_remove_window(ctx, iter);
				nk_insert_window(ctx, iter, NK_INSERT_BACK);
			}
		}
		else {
			if (!iter && ctx->end != win) {
				if (!(win->flags & NK_WINDOW_BACKGROUND)) {
					/* current window is active in that position so transfer to top
					 * at the highest priority in stack */
					nk_remove_window(ctx, win);
					nk_insert_window(ctx, win, NK_INSERT_BACK);
				}
				win->flags &= ~(nk_flags)NK_WINDOW_ROM;
				ctx->active = win;
			}
			if (ctx->end != win && !(win->flags & NK_WINDOW_BACKGROUND))
				win->flags |= NK_WINDOW_ROM;
		}
	}
	win->layout = (struct nk_panel*) nk_create_panel(ctx);
	ctx->current = win;
	ret = nk_panel_begin(ctx, title, NK_PANEL_WINDOW);
	win->layout->offset_x = &win->scrollbar.x;
	win->layout->offset_y = &win->scrollbar.y;
	return ret;
}

NK_API void nk_end(struct nk_context* ctx) {
	struct nk_panel* layout;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current && "if this triggers you forgot to call `nk_begin`");
	if (!ctx || !ctx->current)
		return;

	layout = ctx->current->layout;
	if (!layout || (layout->type == NK_PANEL_WINDOW && (ctx->current->flags & NK_WINDOW_HIDDEN))) {
		ctx->current = 0;
		return;
	}
	nk_panel_end(ctx);
	nk_free_panel(ctx, ctx->current->layout);
	ctx->current = 0;
}

NK_API struct nk_rect nk_window_get_bounds(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return nk_rect(0, 0, 0, 0);
	return ctx->current->bounds;
}

NK_API struct nk_vec2 nk_window_get_position(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return nk_vec2(0, 0);
	return nk_vec2(ctx->current->bounds.x, ctx->current->bounds.y);
}

NK_API struct nk_vec2 nk_window_get_size(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return nk_vec2(0, 0);
	return nk_vec2(ctx->current->bounds.w, ctx->current->bounds.h);
}

NK_API float nk_window_get_width(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return 0;
	return ctx->current->bounds.w;
}

NK_API float nk_window_get_height(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return 0;
	return ctx->current->bounds.h;
}

NK_API struct nk_rect nk_window_get_content_region(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return nk_rect(0, 0, 0, 0);
	return ctx->current->layout->clip;
}

NK_API struct nk_vec2 nk_window_get_content_region_min(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current) return nk_vec2(0, 0);
	return nk_vec2(ctx->current->layout->clip.x, ctx->current->layout->clip.y);
}

NK_API struct nk_vec2 nk_window_get_content_region_max(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current) return nk_vec2(0, 0);
	return nk_vec2(ctx->current->layout->clip.x + ctx->current->layout->clip.w,
		ctx->current->layout->clip.y + ctx->current->layout->clip.h);
}

NK_API struct nk_vec2 nk_window_get_content_region_size(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current) return nk_vec2(0, 0);
	return nk_vec2(ctx->current->layout->clip.w, ctx->current->layout->clip.h);
}

NK_API struct nk_command_buffer* nk_window_get_canvas(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current) return 0;
	return &ctx->current->buffer;
}

NK_API struct nk_panel* nk_window_get_panel(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return 0;
	return ctx->current->layout;
}

NK_API int nk_window_has_focus(const struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current) return 0;
	return ctx->current == ctx->active;
}

NK_API int nk_window_is_hovered(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return 0;
	if (ctx->current->flags & NK_WINDOW_HIDDEN)
		return 0;
	return nk_input_is_mouse_hovering_rect(&ctx->input, ctx->current->bounds);
}

NK_API int nk_window_is_any_hovered(struct nk_context* ctx) {
	struct nk_window* iter;
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	iter = ctx->begin;
	while (iter) {
		/* check if window is being hovered */
		if (!(iter->flags & NK_WINDOW_HIDDEN)) {
			/* check if window popup is being hovered */
			if (iter->popup.active && iter->popup.win &&
				nk_input_is_mouse_hovering_rect(&ctx->input, iter->popup.win->bounds))
				return 1;

			if (iter->flags & NK_WINDOW_MINIMIZED) {
				struct nk_rect header = iter->bounds;
				header.h = ctx->style.font->height + 2 * ctx->style.window.header.padding.y;
				if (nk_input_is_mouse_hovering_rect(&ctx->input, header))
					return 1;
			}
			else if (nk_input_is_mouse_hovering_rect(&ctx->input, iter->bounds)) {
				return 1;
			}
		}
		iter = iter->next;
	}
	return 0;
}

NK_API int nk_item_is_any_active(struct nk_context* ctx) {
	int any_hovered = nk_window_is_any_hovered(ctx);
	int any_active = (ctx->last_widget_state & NK_WIDGET_STATE_MODIFIED);
	return any_hovered || any_active;
}

NK_API int nk_window_is_collapsed(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return 0;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return 0;
	return win->flags & NK_WINDOW_MINIMIZED;
}

NK_API int nk_window_is_closed(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return 1;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return 1;
	return (win->flags & NK_WINDOW_CLOSED);
}

NK_API int nk_window_is_hidden(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return 1;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return 1;
	return (win->flags & NK_WINDOW_HIDDEN);
}

NK_API int nk_window_is_active(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return 0;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return 0;
	return win == ctx->active;
}

NK_API struct nk_window* nk_window_find(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	return nk_find_window(ctx, title_hash, name);
}

NK_API void nk_window_close(struct nk_context* ctx, const char* name) {
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return;
	win = nk_window_find(ctx, name);
	if (!win) return;
	NK_ASSERT(ctx->current != win && "You cannot close a currently active window");
	if (ctx->current == win) return;
	win->flags |= NK_WINDOW_HIDDEN;
	win->flags |= NK_WINDOW_CLOSED;
}

NK_API void nk_window_set_bounds(struct nk_context* ctx, const char* name, struct nk_rect bounds) {
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return;
	win = nk_window_find(ctx, name);
	if (!win) return;
	NK_ASSERT(ctx->current != win && "You cannot update a currently in procecss window");
	win->bounds = bounds;
}

NK_API void nk_window_set_position(struct nk_context* ctx, const char* name, struct nk_vec2 pos) {
	struct nk_window* win = nk_window_find(ctx, name);
	if (!win) return;
	win->bounds.x = pos.x;
	win->bounds.y = pos.y;
}

NK_API void nk_window_set_size(struct nk_context* ctx, const char* name, struct nk_vec2 size) {
	struct nk_window* win = nk_window_find(ctx, name);
	if (!win) return;
	win->bounds.w = size.x;
	win->bounds.h = size.y;
}

NK_API void nk_window_collapse(struct nk_context* ctx, const char* name, enum nk_collapse_states c) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return;
	if (c == NK_MINIMIZED)
		win->flags |= NK_WINDOW_MINIMIZED;
	else win->flags &= ~(nk_flags)NK_WINDOW_MINIMIZED;
}

NK_API void nk_window_collapse_if(struct nk_context* ctx, const char* name, enum nk_collapse_states c, int cond) {
	NK_ASSERT(ctx);
	if (!ctx || !cond) return;
	nk_window_collapse(ctx, name, c);
}

NK_API void nk_window_show(struct nk_context* ctx, const char* name, enum nk_show_states s) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (!win) return;
	if (s == NK_HIDDEN) {
		win->flags |= NK_WINDOW_HIDDEN;
	}
	else win->flags &= ~(nk_flags)NK_WINDOW_HIDDEN;
}

NK_API void nk_window_show_if(struct nk_context* ctx, const char* name, enum nk_show_states s, int cond) {
	NK_ASSERT(ctx);
	if (!ctx || !cond) return;
	nk_window_show(ctx, name, s);
}

NK_API void nk_window_set_focus(struct nk_context* ctx, const char* name) {
	int title_len;
	nk_hash title_hash;
	struct nk_window* win;
	NK_ASSERT(ctx);
	if (!ctx) return;

	title_len = (int)nk_strlen(name);
	title_hash = nk_murmur_hash(name, (int)title_len, NK_WINDOW_TITLE);
	win = nk_find_window(ctx, title_hash, name);
	if (win && ctx->end != win) {
		nk_remove_window(ctx, win);
		nk_insert_window(ctx, win, NK_INSERT_BACK);
	}
	ctx->active = win;
}





/* ===============================================================
 *
 *                              POPUP
 *
 * ===============================================================*/
NK_API int nk_popup_begin(struct nk_context* ctx, enum nk_popup_type type, const char* title, nk_flags flags,
	struct nk_rect rect) {
	struct nk_window* popup;
	struct nk_window* win;
	struct nk_panel* panel;

	int title_len;
	nk_hash title_hash;
	nk_size allocated;

	NK_ASSERT(ctx);
	NK_ASSERT(title);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	panel = win->layout;
	NK_ASSERT(!(panel->type & NK_PANEL_SET_POPUP) && "popups are not allowed to have popups");
	(void)panel;
	title_len = (int)nk_strlen(title);
	title_hash = nk_murmur_hash(title, (int)title_len, NK_PANEL_POPUP);

	popup = win->popup.win;
	if (!popup) {
		popup = (struct nk_window*) nk_create_window(ctx);
		popup->parent = win;
		win->popup.win = popup;
		win->popup.active = 0;
		win->popup.type = NK_PANEL_POPUP;
	}

	/* make sure we have correct popup */
	if (win->popup.name != title_hash) {
		if (!win->popup.active) {
			nk_zero(popup, sizeof(*popup));
			win->popup.name = title_hash;
			win->popup.active = 1;
			win->popup.type = NK_PANEL_POPUP;
		}
		else return 0;
	}

	/* popup position is local to window */
	ctx->current = popup;
	rect.x += win->layout->clip.x;
	rect.y += win->layout->clip.y;

	/* setup popup data */
	popup->parent = win;
	popup->bounds = rect;
	popup->seq = ctx->seq;
	popup->layout = (struct nk_panel*) nk_create_panel(ctx);
	popup->flags = flags;
	popup->flags |= NK_WINDOW_BORDER;
	if (type == NK_POPUP_DYNAMIC)
		popup->flags |= NK_WINDOW_DYNAMIC;

	popup->buffer = win->buffer;
	nk_start_popup(ctx, win);
	allocated = ctx->memory.allocated;
	nk_push_scissor(&popup->buffer, nk_null_rect);

	if (nk_panel_begin(ctx, title, NK_PANEL_POPUP)) {
		/* popup is running therefore invalidate parent panels */
		struct nk_panel* root;
		root = win->layout;
		while (root) {
			root->flags |= NK_WINDOW_ROM;
			root->flags &= ~(nk_flags)NK_WINDOW_REMOVE_ROM;
			root = root->parent;
		}
		win->popup.active = 1;
		popup->layout->offset_x = &popup->scrollbar.x;
		popup->layout->offset_y = &popup->scrollbar.y;
		popup->layout->parent = win->layout;
		return 1;
	}
	else {
		/* popup was closed/is invalid so cleanup */
		struct nk_panel* root;
		root = win->layout;
		while (root) {
			root->flags |= NK_WINDOW_REMOVE_ROM;
			root = root->parent;
		}
		win->popup.buf.active = 0;
		win->popup.active = 0;
		ctx->memory.allocated = allocated;
		ctx->current = win;
		nk_free_panel(ctx, popup->layout);
		popup->layout = 0;
		return 0;
	}
}

NK_LIB int nk_nonblock_begin(struct nk_context* ctx, nk_flags flags, struct nk_rect body, struct nk_rect header,
	enum nk_panel_type panel_type) {
	struct nk_window* popup;
	struct nk_window* win;
	struct nk_panel* panel;
	int is_active = nk_true;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	/* popups cannot have popups */
	win = ctx->current;
	panel = win->layout;
	NK_ASSERT(!(panel->type & NK_PANEL_SET_POPUP));
	(void)panel;
	popup = win->popup.win;
	if (!popup) {
		/* create window for nonblocking popup */
		popup = (struct nk_window*) nk_create_window(ctx);
		popup->parent = win;
		win->popup.win = popup;
		win->popup.type = panel_type;
		nk_command_buffer_init(&popup->buffer, &ctx->memory, NK_CLIPPING_ON);
	}
	else {
		/* close the popup if user pressed outside or in the header */
		int pressed, in_body, in_header;
		pressed = nk_input_is_mouse_pressed(&ctx->input, NK_BUTTON_LEFT);
		in_body = nk_input_is_mouse_hovering_rect(&ctx->input, body);
		in_header = nk_input_is_mouse_hovering_rect(&ctx->input, header);
		if (pressed && (!in_body || in_header))
			is_active = nk_false;
	}
	win->popup.header = header;

	if (!is_active) {
		/* remove read only mode from all parent panels */
		struct nk_panel* root = win->layout;
		while (root) {
			root->flags |= NK_WINDOW_REMOVE_ROM;
			root = root->parent;
		}
		return is_active;
	}
	popup->bounds = body;
	popup->parent = win;
	popup->layout = (struct nk_panel*) nk_create_panel(ctx);
	popup->flags = flags;
	popup->flags |= NK_WINDOW_BORDER;
	popup->flags |= NK_WINDOW_DYNAMIC;
	popup->seq = ctx->seq;
	win->popup.active = 1;
	NK_ASSERT(popup->layout);

	nk_start_popup(ctx, win);
	popup->buffer = win->buffer;
	nk_push_scissor(&popup->buffer, nk_null_rect);
	ctx->current = popup;

	nk_panel_begin(ctx, 0, panel_type);
	win->buffer = popup->buffer;
	popup->layout->parent = win->layout;
	popup->layout->offset_x = &popup->scrollbar.x;
	popup->layout->offset_y = &popup->scrollbar.y;

	/* set read only mode to all parent panels */
	{
		struct nk_panel* root;
		root = win->layout;
		while (root) {
			root->flags |= NK_WINDOW_ROM;
			root = root->parent;
		}
	}
	return is_active;
}

NK_API void nk_popup_close(struct nk_context* ctx) {
	struct nk_window* popup;
	NK_ASSERT(ctx);
	if (!ctx || !ctx->current) return;

	popup = ctx->current;
	NK_ASSERT(popup->parent);
	NK_ASSERT(popup->layout->type & NK_PANEL_SET_POPUP);
	popup->flags |= NK_WINDOW_HIDDEN;
}

NK_API void nk_popup_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_window* popup;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	popup = ctx->current;
	if (!popup->parent) return;
	win = popup->parent;
	if (popup->flags & NK_WINDOW_HIDDEN) {
		struct nk_panel* root;
		root = win->layout;
		while (root) {
			root->flags |= NK_WINDOW_REMOVE_ROM;
			root = root->parent;
		}
		win->popup.active = 0;
	}
	nk_push_scissor(&popup->buffer, nk_null_rect);
	nk_end(ctx);

	win->buffer = popup->buffer;
	nk_finish_popup(ctx, win);
	ctx->current = win;
	nk_push_scissor(&win->buffer, win->layout->clip);
}





/* ==============================================================
 *
 *                          CONTEXTUAL
 *
 * ===============================================================*/
NK_API int
nk_contextual_begin(struct nk_context* ctx, nk_flags flags, struct nk_vec2 size, struct nk_rect trigger_bounds) {
	struct nk_window* win;
	struct nk_window* popup;
	struct nk_rect body;

	NK_STORAGE const struct nk_rect null_rect = { -1, -1, 0, 0 };
	int is_clicked = 0;
	int is_open = 0;
	int ret = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	++win->popup.con_count;
	if (ctx->current != ctx->active)
		return 0;

	/* check if currently active contextual is active */
	popup = win->popup.win;
	is_open = (popup && win->popup.type == NK_PANEL_CONTEXTUAL);
	is_clicked = nk_input_mouse_clicked(&ctx->input, NK_BUTTON_RIGHT, trigger_bounds);
	if (win->popup.active_con && win->popup.con_count != win->popup.active_con)
		return 0;
	if (!is_open && win->popup.active_con)
		win->popup.active_con = 0;
	if ((!is_open && !is_clicked))
		return 0;

	/* calculate contextual position on click */
	win->popup.active_con = win->popup.con_count;
	if (is_clicked) {
		body.x = ctx->input.mouse.pos.x;
		body.y = ctx->input.mouse.pos.y;
	}
	else {
		body.x = popup->bounds.x;
		body.y = popup->bounds.y;
	}
	body.w = size.x;
	body.h = size.y;

	/* start nonblocking contextual popup */
	ret = nk_nonblock_begin(ctx, flags | NK_WINDOW_NO_SCROLLBAR, body, null_rect, NK_PANEL_CONTEXTUAL);
	if (ret) win->popup.type = NK_PANEL_CONTEXTUAL;
	else {
		win->popup.active_con = 0;
		win->popup.type = NK_PANEL_NONE;
		if (win->popup.win)
			win->popup.win->flags = 0;
	}
	return ret;
}

NK_API int nk_contextual_item_text(struct nk_context* ctx, const char* text, int len, nk_flags alignment) {
	struct nk_window* win;
	const struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	state = nk_widget_fitting(&bounds, ctx, style->contextual_button.padding);
	if (!state) return nk_false;

	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text(&ctx->last_widget_state, &win->buffer, bounds, text, len, alignment, NK_BUTTON_DEFAULT,
		&style->contextual_button, in, style->font)) {
		nk_contextual_close(ctx);
		return nk_true;
	}
	return nk_false;
}

NK_API int nk_contextual_item_label(struct nk_context* ctx, const char* label, nk_flags align) {
	return nk_contextual_item_text(ctx, label, nk_strlen(label), align);
}

NK_API int
nk_contextual_item_image_text(struct nk_context* ctx, struct nk_image img, const char* text, int len, nk_flags align) {
	struct nk_window* win;
	const struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	state = nk_widget_fitting(&bounds, ctx, style->contextual_button.padding);
	if (!state) return nk_false;

	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text_image(&ctx->last_widget_state, &win->buffer, bounds, img, text, len, align, NK_BUTTON_DEFAULT,
		&style->contextual_button, style->font, in)) {
		nk_contextual_close(ctx);
		return nk_true;
	}
	return nk_false;
}

NK_API int
nk_contextual_item_image_label(struct nk_context* ctx, struct nk_image img, const char* label, nk_flags align) {
	return nk_contextual_item_image_text(ctx, img, label, nk_strlen(label), align);
}

NK_API int nk_contextual_item_symbol_text(struct nk_context* ctx, enum nk_symbol_type symbol, const char* text, int len,
	nk_flags align) {
	struct nk_window* win;
	const struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	state = nk_widget_fitting(&bounds, ctx, style->contextual_button.padding);
	if (!state) return nk_false;

	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text_symbol(&ctx->last_widget_state, &win->buffer, bounds, symbol, text, len, align,
		NK_BUTTON_DEFAULT, &style->contextual_button, style->font, in)) {
		nk_contextual_close(ctx);
		return nk_true;
	}
	return nk_false;
}

NK_API int
nk_contextual_item_symbol_label(struct nk_context* ctx, enum nk_symbol_type symbol, const char* text, nk_flags align) {
	return nk_contextual_item_symbol_text(ctx, symbol, text, nk_strlen(text), align);
}

NK_API void nk_contextual_close(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return;
	nk_popup_close(ctx);
}

NK_API void nk_contextual_end(struct nk_context* ctx) {
	struct nk_window* popup;
	struct nk_panel* panel;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return;

	popup = ctx->current;
	panel = popup->layout;
	NK_ASSERT(popup->parent);
	NK_ASSERT(panel->type & NK_PANEL_SET_POPUP);
	if (panel->flags & NK_WINDOW_DYNAMIC) {
		/* Close behavior
		This is a bit of a hack solution since we do not know before we end our popup
		how big it will be. We therefore do not directly know when a
		click outside the non-blocking popup must close it at that direct frame.
		Instead it will be closed in the next frame.*/
		struct nk_rect body = { 0, 0, 0, 0 };
		if (panel->at_y < (panel->bounds.y + panel->bounds.h)) {
			struct nk_vec2 padding = nk_panel_get_padding(&ctx->style, panel->type);
			body = panel->bounds;
			body.y = (panel->at_y + panel->footer_height + panel->border + padding.y + panel->row.height);
			body.h = (panel->bounds.y + panel->bounds.h) - body.y;
		}
		{
			int pressed = nk_input_is_mouse_pressed(&ctx->input, NK_BUTTON_LEFT);
			int in_body = nk_input_is_mouse_hovering_rect(&ctx->input, body);
			if (pressed && in_body)
				popup->flags |= NK_WINDOW_HIDDEN;
		}
	}
	if (popup->flags & NK_WINDOW_HIDDEN)
		popup->seq = 0;
	nk_popup_end(ctx);
	return;
}





/* ===============================================================
 *
 *                              MENU
 *
 * ===============================================================*/
NK_API void nk_menubar_begin(struct nk_context* ctx) {
	struct nk_panel* layout;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	layout = ctx->current->layout;
	NK_ASSERT(layout->at_y == layout->bounds.y);
	/* if this assert triggers you allocated space between nk_begin and nk_menubar_begin.
	If you want a menubar the first nuklear function after `nk_begin` has to be a
	`nk_menubar_begin` call. Inside the menubar you then have to allocate space for
	widgets (also supports multiple rows).
	Example:
		if (nk_begin(...)) {
			nk_menubar_begin(...);
				nk_layout_xxxx(...);
				nk_button(...);
				nk_layout_xxxx(...);
				nk_button(...);
			nk_menubar_end(...);
		}
		nk_end(...);
	*/
	if (layout->flags & NK_WINDOW_HIDDEN || layout->flags & NK_WINDOW_MINIMIZED)
		return;

	layout->menu.x = layout->at_x;
	layout->menu.y = layout->at_y + layout->row.height;
	layout->menu.w = layout->bounds.w;
	layout->menu.offset.x = *layout->offset_x;
	layout->menu.offset.y = *layout->offset_y;
	*layout->offset_y = 0;
}

NK_API void nk_menubar_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;
	struct nk_command_buffer* out;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	out = &win->buffer;
	layout = win->layout;
	if (layout->flags & NK_WINDOW_HIDDEN || layout->flags & NK_WINDOW_MINIMIZED)
		return;

	layout->menu.h = layout->at_y - layout->menu.y;
	layout->bounds.y += layout->menu.h + ctx->style.window.spacing.y + layout->row.height;
	layout->bounds.h -= layout->menu.h + ctx->style.window.spacing.y + layout->row.height;

	*layout->offset_x = layout->menu.offset.x;
	*layout->offset_y = layout->menu.offset.y;
	layout->at_y = layout->bounds.y - layout->row.height;

	layout->clip.y = layout->bounds.y;
	layout->clip.h = layout->bounds.h;
	nk_push_scissor(out, layout->clip);
}

NK_INTERN int
nk_menu_begin(struct nk_context* ctx, struct nk_window* win, const char* id, int is_clicked, struct nk_rect header,
	struct nk_vec2 size) {
	int is_open = 0;
	int is_active = 0;
	struct nk_rect body;
	struct nk_window* popup;
	nk_hash hash = nk_murmur_hash(id, (int)nk_strlen(id), NK_PANEL_MENU);

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	body.x = header.x;
	body.w = size.x;
	body.y = header.y + header.h;
	body.h = size.y;

	popup = win->popup.win;
	is_open = popup ? nk_true : nk_false;
	is_active = (popup && (win->popup.name == hash) && win->popup.type == NK_PANEL_MENU);
	if ((is_clicked && is_open && !is_active) || (is_open && !is_active) ||
		(!is_open && !is_active && !is_clicked))
		return 0;
	if (!nk_nonblock_begin(ctx, NK_WINDOW_NO_SCROLLBAR, body, header, NK_PANEL_MENU))
		return 0;

	win->popup.type = NK_PANEL_MENU;
	win->popup.name = hash;
	return 1;
}

NK_API int nk_menu_begin_text(struct nk_context* ctx, const char* title, int len, nk_flags align, struct nk_vec2 size) {
	struct nk_window* win;
	const struct nk_input* in;
	struct nk_rect header;
	int is_clicked = nk_false;
	nk_flags state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	state = nk_widget(&header, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || win->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text(&ctx->last_widget_state, &win->buffer, header, title, len, align, NK_BUTTON_DEFAULT,
		&ctx->style.menu_button, in, ctx->style.font))
		is_clicked = nk_true;
	return nk_menu_begin(ctx, win, title, is_clicked, header, size);
}

NK_API int nk_menu_begin_label(struct nk_context* ctx, const char* text, nk_flags align, struct nk_vec2 size) {
	return nk_menu_begin_text(ctx, text, nk_strlen(text), align, size);
}

NK_API int nk_menu_begin_image(struct nk_context* ctx, const char* id, struct nk_image img, struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_rect header;
	const struct nk_input* in;
	int is_clicked = nk_false;
	nk_flags state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	state = nk_widget(&header, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_image(&ctx->last_widget_state, &win->buffer, header, img, NK_BUTTON_DEFAULT,
		&ctx->style.menu_button, in))
		is_clicked = nk_true;
	return nk_menu_begin(ctx, win, id, is_clicked, header, size);
}

NK_API int nk_menu_begin_symbol(struct nk_context* ctx, const char* id, enum nk_symbol_type sym, struct nk_vec2 size) {
	struct nk_window* win;
	const struct nk_input* in;
	struct nk_rect header;
	int is_clicked = nk_false;
	nk_flags state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	state = nk_widget(&header, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_symbol(&ctx->last_widget_state, &win->buffer, header, sym, NK_BUTTON_DEFAULT,
		&ctx->style.menu_button, in, ctx->style.font))
		is_clicked = nk_true;
	return nk_menu_begin(ctx, win, id, is_clicked, header, size);
}

NK_API int
nk_menu_begin_image_text(struct nk_context* ctx, const char* title, int len, nk_flags align, struct nk_image img,
	struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_rect header;
	const struct nk_input* in;
	int is_clicked = nk_false;
	nk_flags state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	state = nk_widget(&header, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text_image(&ctx->last_widget_state, &win->buffer, header, img, title, len, align,
		NK_BUTTON_DEFAULT, &ctx->style.menu_button, ctx->style.font, in))
		is_clicked = nk_true;
	return nk_menu_begin(ctx, win, title, is_clicked, header, size);
}

NK_API int nk_menu_begin_image_label(struct nk_context* ctx, const char* title, nk_flags align, struct nk_image img,
	struct nk_vec2 size) {
	return nk_menu_begin_image_text(ctx, title, nk_strlen(title), align, img, size);
}

NK_API int
nk_menu_begin_symbol_text(struct nk_context* ctx, const char* title, int len, nk_flags align, enum nk_symbol_type sym,
	struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_rect header;
	const struct nk_input* in;
	int is_clicked = nk_false;
	nk_flags state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	state = nk_widget(&header, ctx);
	if (!state) return 0;

	in = (state == NK_WIDGET_ROM || win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	if (nk_do_button_text_symbol(&ctx->last_widget_state, &win->buffer, header, sym, title, len, align,
		NK_BUTTON_DEFAULT, &ctx->style.menu_button, ctx->style.font, in))
		is_clicked = nk_true;
	return nk_menu_begin(ctx, win, title, is_clicked, header, size);
}

NK_API int
nk_menu_begin_symbol_label(struct nk_context* ctx, const char* title, nk_flags align, enum nk_symbol_type sym,
	struct nk_vec2 size) {
	return nk_menu_begin_symbol_text(ctx, title, nk_strlen(title), align, sym, size);
}

NK_API int nk_menu_item_text(struct nk_context* ctx, const char* title, int len, nk_flags align) {
	return nk_contextual_item_text(ctx, title, len, align);
}

NK_API int nk_menu_item_label(struct nk_context* ctx, const char* label, nk_flags align) {
	return nk_contextual_item_label(ctx, label, align);
}

NK_API int nk_menu_item_image_label(struct nk_context* ctx, struct nk_image img, const char* label, nk_flags align) {
	return nk_contextual_item_image_label(ctx, img, label, align);
}

NK_API int
nk_menu_item_image_text(struct nk_context* ctx, struct nk_image img, const char* text, int len, nk_flags align) {
	return nk_contextual_item_image_text(ctx, img, text, len, align);
}

NK_API int
nk_menu_item_symbol_text(struct nk_context* ctx, enum nk_symbol_type sym, const char* text, int len, nk_flags align) {
	return nk_contextual_item_symbol_text(ctx, sym, text, len, align);
}

NK_API int
nk_menu_item_symbol_label(struct nk_context* ctx, enum nk_symbol_type sym, const char* label, nk_flags align) {
	return nk_contextual_item_symbol_label(ctx, sym, label, align);
}

NK_API void nk_menu_close(struct nk_context* ctx) {
	nk_contextual_close(ctx);
}

NK_API void nk_menu_end(struct nk_context* ctx) {
	nk_contextual_end(ctx);
}





/* ===============================================================
 *
 *                          LAYOUT
 *
 * ===============================================================*/
NK_API void nk_layout_set_min_row_height(struct nk_context* ctx, float height) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	layout->row.min_height = height;
}

NK_API void nk_layout_reset_min_row_height(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	layout->row.min_height = ctx->style.font->height;
	layout->row.min_height += ctx->style.text.padding.y * 2;
	layout->row.min_height += ctx->style.window.min_row_height_padding * 2;
}

NK_LIB float
nk_layout_row_calculate_usable_space(const struct nk_style* style, enum nk_panel_type type, float total_space,
	int columns) {
	float panel_padding;
	float panel_spacing;
	float panel_space;

	struct nk_vec2 spacing;
	struct nk_vec2 padding;

	spacing = style->window.spacing;
	padding = nk_panel_get_padding(style, type);

	/* calculate the usable panel space */
	panel_padding = 2 * padding.x;
	panel_spacing = (float)NK_MAX(columns - 1, 0) * spacing.x;
	panel_space = total_space - panel_padding - panel_spacing;
	return panel_space;
}

NK_LIB void nk_panel_layout(const struct nk_context* ctx, struct nk_window* win, float height, int cols) {
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_command_buffer* out;

	struct nk_vec2 item_spacing;
	struct nk_color color;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	/* prefetch some configuration data */
	layout = win->layout;
	style = &ctx->style;
	out = &win->buffer;
	color = style->window.background;
	item_spacing = style->window.spacing;

	/*  if one of these triggers you forgot to add an `if` condition around either
		a window, group, popup, combobox or contextual menu `begin` and `end` block.
		Example:
			if (nk_begin(...) {...} nk_end(...); or
			if (nk_group_begin(...) { nk_group_end(...);} */
	NK_ASSERT(!(layout->flags & NK_WINDOW_MINIMIZED));
	NK_ASSERT(!(layout->flags & NK_WINDOW_HIDDEN));
	NK_ASSERT(!(layout->flags & NK_WINDOW_CLOSED));

	/* update the current row and set the current row layout */
	layout->row.index = 0;
	layout->at_y += layout->row.height;
	layout->row.columns = cols;
	if (height == 0.0f)
		layout->row.height = NK_MAX(height, layout->row.min_height) + item_spacing.y;
	else layout->row.height = height + item_spacing.y;

	layout->row.item_offset = 0;
	if (layout->flags & NK_WINDOW_DYNAMIC) {
		/* draw background for dynamic panels */
		struct nk_rect background;
		background.x = win->bounds.x;
		background.w = win->bounds.w;
		background.y = layout->at_y - 1.0f;
		background.h = layout->row.height + 1.0f;
		nk_fill_rect(out, background, 0, color);
	}
}

NK_LIB void nk_row_layout(struct nk_context* ctx, enum nk_layout_format fmt, float height, int cols, int width) {
	/* update the current row and set the current row layout */
	struct nk_window* win;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	nk_panel_layout(ctx, win, height, cols);
	if (fmt == NK_DYNAMIC)
		win->layout->row.type = NK_LAYOUT_DYNAMIC_FIXED;
	else win->layout->row.type = NK_LAYOUT_STATIC_FIXED;

	win->layout->row.ratio = 0;
	win->layout->row.filled = 0;
	win->layout->row.item_offset = 0;
	win->layout->row.item_width = (float)width;
}

NK_API float nk_layout_ratio_from_pixel(struct nk_context* ctx, float pixel_width) {
	struct nk_window* win;
	NK_ASSERT(ctx);
	NK_ASSERT(pixel_width);
	if (!ctx || !ctx->current || !ctx->current->layout) return 0;
	win = ctx->current;
	return NK_CLAMP(0.0f, pixel_width / win->bounds.x, 1.0f);
}

NK_API void nk_layout_row_dynamic(struct nk_context* ctx, float height, int cols) {
	nk_row_layout(ctx, NK_DYNAMIC, height, cols, 0);
}

NK_API void nk_layout_row_static(struct nk_context* ctx, float height, int item_width, int cols) {
	nk_row_layout(ctx, NK_STATIC, height, cols, item_width);
}

NK_API void nk_layout_row_begin(struct nk_context* ctx, enum nk_layout_format fmt, float row_height, int cols) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	nk_panel_layout(ctx, win, row_height, cols);
	if (fmt == NK_DYNAMIC)
		layout->row.type = NK_LAYOUT_DYNAMIC_ROW;
	else layout->row.type = NK_LAYOUT_STATIC_ROW;

	layout->row.ratio = 0;
	layout->row.filled = 0;
	layout->row.item_width = 0;
	layout->row.item_offset = 0;
	layout->row.columns = cols;
}

NK_API void nk_layout_row_push(struct nk_context* ctx, float ratio_or_width) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_STATIC_ROW || layout->row.type == NK_LAYOUT_DYNAMIC_ROW);
	if (layout->row.type != NK_LAYOUT_STATIC_ROW && layout->row.type != NK_LAYOUT_DYNAMIC_ROW)
		return;

	if (layout->row.type == NK_LAYOUT_DYNAMIC_ROW) {
		float ratio = ratio_or_width;
		if ((ratio + layout->row.filled) > 1.0f) return;
		if (ratio > 0.0f)
			layout->row.item_width = NK_SATURATE(ratio);
		else layout->row.item_width = 1.0f - layout->row.filled;
	}
	else layout->row.item_width = ratio_or_width;
}

NK_API void nk_layout_row_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_STATIC_ROW || layout->row.type == NK_LAYOUT_DYNAMIC_ROW);
	if (layout->row.type != NK_LAYOUT_STATIC_ROW && layout->row.type != NK_LAYOUT_DYNAMIC_ROW)
		return;
	layout->row.item_width = 0;
	layout->row.item_offset = 0;
}

NK_API void
nk_layout_row(struct nk_context* ctx, enum nk_layout_format fmt, float height, int cols, const float* ratio) {
	int i;
	int n_undef = 0;
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	nk_panel_layout(ctx, win, height, cols);
	if (fmt == NK_DYNAMIC) {
		/* calculate width of undefined widget ratios */
		float r = 0;
		layout->row.ratio = ratio;
		for (i = 0; i < cols; ++i) {
			if (ratio[i] < 0.0f)
				n_undef++;
			else r += ratio[i];
		}
		r = NK_SATURATE(1.0f - r);
		layout->row.type = NK_LAYOUT_DYNAMIC;
		layout->row.item_width = (r > 0 && n_undef > 0) ? (r / (float)n_undef) : 0;
	}
	else {
		layout->row.ratio = ratio;
		layout->row.type = NK_LAYOUT_STATIC;
		layout->row.item_width = 0;
		layout->row.item_offset = 0;
	}
	layout->row.item_offset = 0;
	layout->row.filled = 0;
}

NK_API void nk_layout_row_template_begin(struct nk_context* ctx, float height) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	nk_panel_layout(ctx, win, height, 1);
	layout->row.type = NK_LAYOUT_TEMPLATE;
	layout->row.columns = 0;
	layout->row.ratio = 0;
	layout->row.item_width = 0;
	layout->row.item_height = 0;
	layout->row.item_offset = 0;
	layout->row.filled = 0;
	layout->row.item.x = 0;
	layout->row.item.y = 0;
	layout->row.item.w = 0;
	layout->row.item.h = 0;
}

NK_API void nk_layout_row_template_push_dynamic(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
	NK_ASSERT(layout->row.columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
	if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
	if (layout->row.columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS) return;
	layout->row.templates[layout->row.columns++] = -1.0f;
}

NK_API void nk_layout_row_template_push_variable(struct nk_context* ctx, float min_width) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
	NK_ASSERT(layout->row.columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
	if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
	if (layout->row.columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS) return;
	layout->row.templates[layout->row.columns++] = -min_width;
}

NK_API void nk_layout_row_template_push_static(struct nk_context* ctx, float width) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
	NK_ASSERT(layout->row.columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
	if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
	if (layout->row.columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS) return;
	layout->row.templates[layout->row.columns++] = width;
}

NK_API void nk_layout_row_template_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	int i = 0;
	int variable_count = 0;
	int min_variable_count = 0;
	float min_fixed_width = 0.0f;
	float total_fixed_width = 0.0f;
	float max_variable_width = 0.0f;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	NK_ASSERT(layout->row.type == NK_LAYOUT_TEMPLATE);
	if (layout->row.type != NK_LAYOUT_TEMPLATE) return;
	for (i = 0; i < layout->row.columns; ++i) {
		float width = layout->row.templates[i];
		if (width >= 0.0f) {
			total_fixed_width += width;
			min_fixed_width += width;
		}
		else if (width < -1.0f) {
			width = -width;
			total_fixed_width += width;
			max_variable_width = NK_MAX(max_variable_width, width);
			variable_count++;
		}
		else {
			min_variable_count++;
			variable_count++;
		}
	}
	if (variable_count) {
		float space = nk_layout_row_calculate_usable_space(&ctx->style, layout->type, layout->bounds.w,
			layout->row.columns);
		float var_width = (NK_MAX(space - min_fixed_width, 0.0f)) / (float)variable_count;
		int enough_space = var_width >= max_variable_width;
		if (!enough_space)
			var_width = (NK_MAX(space - total_fixed_width, 0)) / (float)min_variable_count;
		for (i = 0; i < layout->row.columns; ++i) {
			float* width = &layout->row.templates[i];
			*width = (*width >= 0.0f) ? *width : (*width < -1.0f && !enough_space) ? -(*width) : var_width;
		}
	}
}

NK_API void nk_layout_space_begin(struct nk_context* ctx, enum nk_layout_format fmt, float height, int widget_count) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	nk_panel_layout(ctx, win, height, widget_count);
	if (fmt == NK_STATIC)
		layout->row.type = NK_LAYOUT_STATIC_FREE;
	else layout->row.type = NK_LAYOUT_DYNAMIC_FREE;

	layout->row.ratio = 0;
	layout->row.filled = 0;
	layout->row.item_width = 0;
	layout->row.item_offset = 0;
}

NK_API void nk_layout_space_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	layout->row.item_width = 0;
	layout->row.item_height = 0;
	layout->row.item_offset = 0;
	nk_zero(&layout->row.item, sizeof(layout->row.item));
}

NK_API void nk_layout_space_push(struct nk_context* ctx, struct nk_rect rect) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	layout->row.item = rect;
}

NK_API struct nk_rect nk_layout_space_bounds(struct nk_context* ctx) {
	struct nk_rect ret;
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x = layout->clip.x;
	ret.y = layout->clip.y;
	ret.w = layout->clip.w;
	ret.h = layout->row.height;
	return ret;
}

NK_API struct nk_rect nk_layout_widget_bounds(struct nk_context* ctx) {
	struct nk_rect ret;
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x = layout->at_x;
	ret.y = layout->at_y;
	ret.w = layout->bounds.w - NK_MAX(layout->at_x - layout->bounds.x, 0);
	ret.h = layout->row.height;
	return ret;
}

NK_API struct nk_vec2 nk_layout_space_to_screen(struct nk_context* ctx, struct nk_vec2 ret) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x += layout->at_x - (float)*layout->offset_x;
	ret.y += layout->at_y - (float)*layout->offset_y;
	return ret;
}

NK_API struct nk_vec2 nk_layout_space_to_local(struct nk_context* ctx, struct nk_vec2 ret) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x += -layout->at_x + (float)*layout->offset_x;
	ret.y += -layout->at_y + (float)*layout->offset_y;
	return ret;
}

NK_API struct nk_rect nk_layout_space_rect_to_screen(struct nk_context* ctx, struct nk_rect ret) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x += layout->at_x - (float)*layout->offset_x;
	ret.y += layout->at_y - (float)*layout->offset_y;
	return ret;
}

NK_API struct nk_rect nk_layout_space_rect_to_local(struct nk_context* ctx, struct nk_rect ret) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	win = ctx->current;
	layout = win->layout;

	ret.x += -layout->at_x + (float)*layout->offset_x;
	ret.y += -layout->at_y + (float)*layout->offset_y;
	return ret;
}

NK_LIB void nk_panel_alloc_row(const struct nk_context* ctx, struct nk_window* win) {
	struct nk_panel* layout = win->layout;
	struct nk_vec2 spacing = ctx->style.window.spacing;
	const float row_height = layout->row.height - spacing.y;
	nk_panel_layout(ctx, win, row_height, layout->row.columns);
}

NK_LIB void
nk_layout_widget_space(struct nk_rect* bounds, const struct nk_context* ctx, struct nk_window* win, int modify) {
	struct nk_panel* layout;
	const struct nk_style* style;

	struct nk_vec2 spacing;
	struct nk_vec2 padding;

	float item_offset = 0;
	float item_width = 0;
	float item_spacing = 0;
	float panel_space = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	style = &ctx->style;
	NK_ASSERT(bounds);

	spacing = style->window.spacing;
	padding = nk_panel_get_padding(style, layout->type);
	panel_space = nk_layout_row_calculate_usable_space(&ctx->style, layout->type, layout->bounds.w,
		layout->row.columns);

#define NK_FRAC(x) (x - (int)x) /* will be used to remove fookin gaps */
	/* calculate the width of one item inside the current layout space */
	switch (layout->row.type) {
	case NK_LAYOUT_DYNAMIC_FIXED: {
		/* scaling fixed size widgets item width */
		float w = NK_MAX(1.0f, panel_space) / (float)layout->row.columns;
		item_offset = (float)layout->row.index * w;
		item_width = w + NK_FRAC(item_offset);
		item_spacing = (float)layout->row.index * spacing.x;
	}
								break;
	case NK_LAYOUT_DYNAMIC_ROW: {
		/* scaling single ratio widget width */
		float w = layout->row.item_width * panel_space;
		item_offset = layout->row.item_offset;
		item_width = w + NK_FRAC(item_offset);
		item_spacing = 0;

		if (modify) {
			layout->row.item_offset += w + spacing.x;
			layout->row.filled += layout->row.item_width;
			layout->row.index = 0;
		}
	}
							  break;
	case NK_LAYOUT_DYNAMIC_FREE: {
		/* panel width depended free widget placing */
		bounds->x = layout->at_x + (layout->bounds.w * layout->row.item.x);
		bounds->x -= (float)*layout->offset_x;
		bounds->y = layout->at_y + (layout->row.height * layout->row.item.y);
		bounds->y -= (float)*layout->offset_y;
		bounds->w = layout->bounds.w * layout->row.item.w + NK_FRAC(bounds->x);
		bounds->h = layout->row.height * layout->row.item.h + NK_FRAC(bounds->y);
		return;
	}
	case NK_LAYOUT_DYNAMIC: {
		/* scaling arrays of panel width ratios for every widget */
		float ratio, w;
		NK_ASSERT(layout->row.ratio);
		ratio = (layout->row.ratio[layout->row.index] < 0) ? layout->row.item_width
			: layout->row.ratio[layout->row.index];

		w = (ratio * panel_space);
		item_spacing = (float)layout->row.index * spacing.x;
		item_offset = layout->row.item_offset;
		item_width = w + NK_FRAC(item_offset);

		if (modify) {
			layout->row.item_offset += w;
			layout->row.filled += ratio;
		}
	}
						  break;
	case NK_LAYOUT_STATIC_FIXED: {
		/* non-scaling fixed widgets item width */
		item_width = layout->row.item_width;
		item_offset = (float)layout->row.index * item_width;
		item_spacing = (float)layout->row.index * spacing.x;
	}
							   break;
	case NK_LAYOUT_STATIC_ROW: {
		/* scaling single ratio widget width */
		item_width = layout->row.item_width;
		item_offset = layout->row.item_offset;
		item_spacing = (float)layout->row.index * spacing.x;
		if (modify) layout->row.item_offset += item_width;
	}
							 break;
	case NK_LAYOUT_STATIC_FREE: {
		/* free widget placing */
		bounds->x = layout->at_x + layout->row.item.x;
		bounds->w = layout->row.item.w;
		if (((bounds->x + bounds->w) > layout->max_x) && modify)
			layout->max_x = (bounds->x + bounds->w);
		bounds->x -= (float)*layout->offset_x;
		bounds->y = layout->at_y + layout->row.item.y;
		bounds->y -= (float)*layout->offset_y;
		bounds->h = layout->row.item.h;
		return;
	}
	case NK_LAYOUT_STATIC: {
		/* non-scaling array of panel pixel width for every widget */
		item_spacing = (float)layout->row.index * spacing.x;
		item_width = layout->row.ratio[layout->row.index];
		item_offset = layout->row.item_offset;
		if (modify) layout->row.item_offset += item_width;
	}
						 break;
	case NK_LAYOUT_TEMPLATE: {
		/* stretchy row layout with combined dynamic/static widget width*/
		float w;
		NK_ASSERT(layout->row.index < layout->row.columns);
		NK_ASSERT(layout->row.index < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS);
		w = layout->row.templates[layout->row.index];
		item_offset = layout->row.item_offset;
		item_width = w + NK_FRAC(item_offset);
		item_spacing = (float)layout->row.index * spacing.x;
		if (modify) layout->row.item_offset += w;
	}
						   break;
#undef NK_FRAC
	default:
		NK_ASSERT(0);
		break;
	};

	/* set the bounds of the newly allocated widget */
	bounds->w = item_width;
	bounds->h = layout->row.height - spacing.y;
	bounds->y = layout->at_y - (float)*layout->offset_y;
	bounds->x = layout->at_x + item_offset + item_spacing + padding.x;
	if (((bounds->x + bounds->w) > layout->max_x) && modify)
		layout->max_x = bounds->x + bounds->w;
	bounds->x -= (float)*layout->offset_x;
}

NK_LIB void nk_panel_alloc_space(struct nk_rect* bounds, const struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	/* check if the end of the row has been hit and begin new row if so */
	win = ctx->current;
	layout = win->layout;
	if (layout->row.index >= layout->row.columns)
		nk_panel_alloc_row(ctx, win);

	/* calculate widget position and size */
	nk_layout_widget_space(bounds, ctx, win, nk_true);
	layout->row.index++;
}

NK_LIB void nk_layout_peek(struct nk_rect* bounds, struct nk_context* ctx) {
	float y;
	int index;
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	y = layout->at_y;
	index = layout->row.index;
	if (layout->row.index >= layout->row.columns) {
		layout->at_y += layout->row.height;
		layout->row.index = 0;
	}
	nk_layout_widget_space(bounds, ctx, win, nk_false);
	if (!layout->row.index) {
		bounds->x -= layout->row.item_offset;
	}
	layout->at_y = y;
	layout->row.index = index;
}





/* ===============================================================
 *
 *                              TREE
 *
 * ===============================================================*/
NK_INTERN int
nk_tree_state_base(struct nk_context* ctx, enum nk_tree_type type, struct nk_image* img, const char* title,
	enum nk_collapse_states* state) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_command_buffer* out;
	const struct nk_input* in;
	const struct nk_style_button* button;
	enum nk_symbol_type symbol;
	float row_height;

	struct nk_vec2 item_spacing;
	struct nk_rect header = { 0, 0, 0, 0 };
	struct nk_rect sym = { 0, 0, 0, 0 };
	struct nk_text text;

	nk_flags ws = 0;
	enum nk_widget_layout_states widget_state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	/* cache some data */
	win = ctx->current;
	layout = win->layout;
	out = &win->buffer;
	style = &ctx->style;
	item_spacing = style->window.spacing;

	/* calculate header bounds and draw background */
	row_height = style->font->height + 2 * style->tab.padding.y;
	nk_layout_set_min_row_height(ctx, row_height);
	nk_layout_row_dynamic(ctx, row_height, 1);
	nk_layout_reset_min_row_height(ctx);

	widget_state = nk_widget(&header, ctx);
	if (type == NK_TREE_TAB) {
		const struct nk_style_item* background = &style->tab.background;
		if (background->type == NK_STYLE_ITEM_IMAGE) {
			nk_draw_image(out, header, &background->data.image, nk_white);
			text.background = nk_rgba(0, 0, 0, 0);
		}
		else {
			text.background = background->data.color;
			nk_fill_rect(out, header, 0, style->tab.border_color);
			nk_fill_rect(out, nk_shrink_rect(header, style->tab.border), style->tab.rounding, background->data.color);
		}
	}
	else text.background = style->window.background;

	/* update node state */
	in = (!(layout->flags & NK_WINDOW_ROM)) ? &ctx->input : 0;
	in = (in && widget_state == NK_WIDGET_VALID) ? &ctx->input : 0;
	if (nk_button_behavior(&ws, header, in, NK_BUTTON_DEFAULT))
		*state = (*state == NK_MAXIMIZED) ? NK_MINIMIZED : NK_MAXIMIZED;

	/* select correct button style */
	if (*state == NK_MAXIMIZED) {
		symbol = style->tab.sym_maximize;
		if (type == NK_TREE_TAB)
			button = &style->tab.tab_maximize_button;
		else button = &style->tab.node_maximize_button;
	}
	else {
		symbol = style->tab.sym_minimize;
		if (type == NK_TREE_TAB)
			button = &style->tab.tab_minimize_button;
		else button = &style->tab.node_minimize_button;
	}

	{/* draw triangle button */
		sym.w = sym.h = style->font->height;
		sym.y = header.y + style->tab.padding.y;
		sym.x = header.x + style->tab.padding.x;
		nk_do_button_symbol(&ws, &win->buffer, sym, symbol, NK_BUTTON_DEFAULT, button, 0, style->font);

		if (img) {
			/* draw optional image icon */
			sym.x = sym.x + sym.w + 4 * item_spacing.x;
			nk_draw_image(&win->buffer, sym, img, nk_white);
			sym.w = style->font->height + style->tab.spacing.x;
		}
	}

	{/* draw label */
		struct nk_rect label;
		header.w = NK_MAX(header.w, sym.w + item_spacing.x);
		label.x = sym.x + sym.w + item_spacing.x;
		label.y = sym.y;
		label.w = header.w - (sym.w + item_spacing.y + style->tab.indent);
		label.h = style->font->height;
		text.text = style->tab.text;
		text.padding = nk_vec2(0, 0);
		nk_widget_text(out, label, title, nk_strlen(title), &text, NK_TEXT_LEFT, style->font);
	}

	/* increase x-axis cursor widget position pointer */
	if (*state == NK_MAXIMIZED) {
		layout->at_x = header.x + (float)*layout->offset_x + style->tab.indent;
		layout->bounds.w = NK_MAX(layout->bounds.w, style->tab.indent);
		layout->bounds.w -= (style->tab.indent + style->window.padding.x);
		layout->row.tree_depth++;
		return nk_true;
	}
	else return nk_false;
}

NK_INTERN int nk_tree_base(struct nk_context* ctx, enum nk_tree_type type, struct nk_image* img, const char* title,
	enum nk_collapse_states initial_state, const char* hash, int len, int line) {
	struct nk_window* win = ctx->current;
	int title_len = 0;
	nk_hash tree_hash = 0;
	nk_uint* state = 0;

	/* retrieve tree state from internal widget state tables */
	if (!hash) {
		title_len = (int)nk_strlen(title);
		tree_hash = nk_murmur_hash(title, (int)title_len, (nk_hash)line);
	}
	else tree_hash = nk_murmur_hash(hash, len, (nk_hash)line);
	state = nk_find_value(win, tree_hash);
	if (!state) {
		state = nk_add_value(ctx, win, tree_hash, 0);
		*state = initial_state;
	}
	return nk_tree_state_base(ctx, type, img, title, (enum nk_collapse_states*) state);
}

NK_API int
nk_tree_state_push(struct nk_context* ctx, enum nk_tree_type type, const char* title, enum nk_collapse_states* state) {
	return nk_tree_state_base(ctx, type, 0, title, state);
}

NK_API int
nk_tree_state_image_push(struct nk_context* ctx, enum nk_tree_type type, struct nk_image img, const char* title,
	enum nk_collapse_states* state) {
	return nk_tree_state_base(ctx, type, &img, title, state);
}

NK_API void nk_tree_state_pop(struct nk_context* ctx) {
	struct nk_window* win = 0;
	struct nk_panel* layout = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	layout->at_x -= ctx->style.tab.indent + ctx->style.window.padding.x;
	layout->bounds.w += ctx->style.tab.indent + ctx->style.window.padding.x;
	NK_ASSERT(layout->row.tree_depth);
	layout->row.tree_depth--;
}

NK_API int nk_tree_push_hashed(struct nk_context* ctx, enum nk_tree_type type, const char* title,
	enum nk_collapse_states initial_state, const char* hash, int len, int line) {
	return nk_tree_base(ctx, type, 0, title, initial_state, hash, len, line);
}

NK_API int
nk_tree_image_push_hashed(struct nk_context* ctx, enum nk_tree_type type, struct nk_image img, const char* title,
	enum nk_collapse_states initial_state, const char* hash, int len, int seed) {
	return nk_tree_base(ctx, type, &img, title, initial_state, hash, len, seed);
}

NK_API void nk_tree_pop(struct nk_context* ctx) {
	nk_tree_state_pop(ctx);
}

NK_INTERN int
nk_tree_element_image_push_hashed_base(struct nk_context* ctx, enum nk_tree_type type, struct nk_image* img,
	const char* title, int title_len, enum nk_collapse_states* state,
	int* selected) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_command_buffer* out;
	const struct nk_input* in;
	const struct nk_style_button* button;
	enum nk_symbol_type symbol;
	float row_height;
	struct nk_vec2 padding;

	int text_len;
	float text_width;

	struct nk_vec2 item_spacing;
	struct nk_rect header = { 0, 0, 0, 0 };
	struct nk_rect sym = { 0, 0, 0, 0 };
	struct nk_text text;

	nk_flags ws = 0;
	enum nk_widget_layout_states widget_state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	/* cache some data */
	win = ctx->current;
	layout = win->layout;
	out = &win->buffer;
	style = &ctx->style;
	item_spacing = style->window.spacing;
	padding = style->selectable.padding;

	/* calculate header bounds and draw background */
	row_height = style->font->height + 2 * style->tab.padding.y;
	nk_layout_set_min_row_height(ctx, row_height);
	nk_layout_row_dynamic(ctx, row_height, 1);
	nk_layout_reset_min_row_height(ctx);

	widget_state = nk_widget(&header, ctx);
	if (type == NK_TREE_TAB) {
		const struct nk_style_item* background = &style->tab.background;
		if (background->type == NK_STYLE_ITEM_IMAGE) {
			nk_draw_image(out, header, &background->data.image, nk_white);
			text.background = nk_rgba(0, 0, 0, 0);
		}
		else {
			text.background = background->data.color;
			nk_fill_rect(out, header, 0, style->tab.border_color);
			nk_fill_rect(out, nk_shrink_rect(header, style->tab.border), style->tab.rounding, background->data.color);
		}
	}
	else text.background = style->window.background;

	in = (!(layout->flags & NK_WINDOW_ROM)) ? &ctx->input : 0;
	in = (in && widget_state == NK_WIDGET_VALID) ? &ctx->input : 0;

	/* select correct button style */
	if (*state == NK_MAXIMIZED) {
		symbol = style->tab.sym_maximize;
		if (type == NK_TREE_TAB)
			button = &style->tab.tab_maximize_button;
		else button = &style->tab.node_maximize_button;
	}
	else {
		symbol = style->tab.sym_minimize;
		if (type == NK_TREE_TAB)
			button = &style->tab.tab_minimize_button;
		else button = &style->tab.node_minimize_button;
	}
	{/* draw triangle button */
		sym.w = sym.h = style->font->height;
		sym.y = header.y + style->tab.padding.y;
		sym.x = header.x + style->tab.padding.x;
		if (nk_do_button_symbol(&ws, &win->buffer, sym, symbol, NK_BUTTON_DEFAULT, button, in, style->font))
			*state = (*state == NK_MAXIMIZED) ? NK_MINIMIZED : NK_MAXIMIZED;
	}

	/* draw label */
	{
		nk_flags dummy = 0;
		struct nk_rect label;
		/* calculate size of the text and tooltip */
		text_len = nk_strlen(title);
		text_width = style->font->width(style->font->userdata, style->font->height, title, text_len);
		text_width += (4 * padding.x);

		header.w = NK_MAX(header.w, sym.w + item_spacing.x);
		label.x = sym.x + sym.w + item_spacing.x;
		label.y = sym.y;
		label.w = NK_MIN(header.w - (sym.w + item_spacing.y + style->tab.indent), text_width);
		label.h = style->font->height;

		if (img) {
			nk_do_selectable_image(&dummy, &win->buffer, label, title, title_len, NK_TEXT_LEFT, selected, img,
				&style->selectable, in, style->font);
		}
		else
			nk_do_selectable(&dummy, &win->buffer, label, title, title_len, NK_TEXT_LEFT, selected, &style->selectable,
				in, style->font);
	}
	/* increase x-axis cursor widget position pointer */
	if (*state == NK_MAXIMIZED) {
		layout->at_x = header.x + (float)*layout->offset_x + style->tab.indent;
		layout->bounds.w = NK_MAX(layout->bounds.w, style->tab.indent);
		layout->bounds.w -= (style->tab.indent + style->window.padding.x);
		layout->row.tree_depth++;
		return nk_true;
	}
	else return nk_false;
}

NK_INTERN int
nk_tree_element_base(struct nk_context* ctx, enum nk_tree_type type, struct nk_image* img, const char* title,
	enum nk_collapse_states initial_state, int* selected, const char* hash, int len, int line) {
	struct nk_window* win = ctx->current;
	int title_len = 0;
	nk_hash tree_hash = 0;
	nk_uint* state = 0;

	/* retrieve tree state from internal widget state tables */
	if (!hash) {
		title_len = (int)nk_strlen(title);
		tree_hash = nk_murmur_hash(title, (int)title_len, (nk_hash)line);
	}
	else tree_hash = nk_murmur_hash(hash, len, (nk_hash)line);
	state = nk_find_value(win, tree_hash);
	if (!state) {
		state = nk_add_value(ctx, win, tree_hash, 0);
		*state = initial_state;
	}
	return nk_tree_element_image_push_hashed_base(ctx, type, img, title, nk_strlen(title),
		(enum nk_collapse_states*) state, selected);
}

NK_API int nk_tree_element_push_hashed(struct nk_context* ctx, enum nk_tree_type type, const char* title,
	enum nk_collapse_states initial_state, int* selected, const char* hash, int len,
	int seed) {
	return nk_tree_element_base(ctx, type, 0, title, initial_state, selected, hash, len, seed);
}

NK_API int nk_tree_element_image_push_hashed(struct nk_context* ctx, enum nk_tree_type type, struct nk_image img,
	const char* title, enum nk_collapse_states initial_state, int* selected,
	const char* hash, int len, int seed) {
	return nk_tree_element_base(ctx, type, &img, title, initial_state, selected, hash, len, seed);
}

NK_API void nk_tree_element_pop(struct nk_context* ctx) {
	nk_tree_state_pop(ctx);
}





/* ===============================================================
 *
 *                          GROUP
 *
 * ===============================================================*/
NK_API int
nk_group_scrolled_offset_begin(struct nk_context* ctx, nk_uint* x_offset, nk_uint* y_offset, const char* title,
	nk_flags flags) {
	struct nk_rect bounds;
	struct nk_window panel;
	struct nk_window* win;

	win = ctx->current;
	nk_panel_alloc_space(&bounds, ctx);
	{
		const struct nk_rect* c = &win->layout->clip;
		if (!NK_INTERSECT(c->x, c->y, c->w, c->h, bounds.x, bounds.y, bounds.w, bounds.h) &&
			!(flags & NK_WINDOW_MOVABLE)) {
			return 0;
		}
	}
	if (win->flags & NK_WINDOW_ROM)
		flags |= NK_WINDOW_ROM;

	/* initialize a fake window to create the panel from */
	nk_zero(&panel, sizeof(panel));
	panel.bounds = bounds;
	panel.flags = flags;
	panel.scrollbar.x = *x_offset;
	panel.scrollbar.y = *y_offset;
	panel.buffer = win->buffer;
	panel.layout = (struct nk_panel*) nk_create_panel(ctx);
	ctx->current = &panel;
	nk_panel_begin(ctx, (flags & NK_WINDOW_TITLE) ? title : 0, NK_PANEL_GROUP);

	win->buffer = panel.buffer;
	win->buffer.clip = panel.layout->clip;
	panel.layout->offset_x = x_offset;
	panel.layout->offset_y = y_offset;
	panel.layout->parent = win->layout;
	win->layout = panel.layout;

	ctx->current = win;
	if ((panel.layout->flags & NK_WINDOW_CLOSED) || (panel.layout->flags & NK_WINDOW_MINIMIZED)) {
		nk_flags f = panel.layout->flags;
		nk_group_scrolled_end(ctx);
		if (f & NK_WINDOW_CLOSED)
			return NK_WINDOW_CLOSED;
		if (f & NK_WINDOW_MINIMIZED)
			return NK_WINDOW_MINIMIZED;
	}
	return 1;
}

NK_API void nk_group_scrolled_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_panel* parent;
	struct nk_panel* g;

	struct nk_rect clip;
	struct nk_window pan;
	struct nk_vec2 panel_padding;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return;

	/* make sure nk_group_begin was called correctly */
	NK_ASSERT(ctx->current);
	win = ctx->current;
	NK_ASSERT(win->layout);
	g = win->layout;
	NK_ASSERT(g->parent);
	parent = g->parent;

	/* dummy window */
	nk_zero_struct(pan);
	panel_padding = nk_panel_get_padding(&ctx->style, NK_PANEL_GROUP);
	pan.bounds.y = g->bounds.y - (g->header_height + g->menu.h);
	pan.bounds.x = g->bounds.x - panel_padding.x;
	pan.bounds.w = g->bounds.w + 2 * panel_padding.x;
	pan.bounds.h = g->bounds.h + g->header_height + g->menu.h;
	if (g->flags & NK_WINDOW_BORDER) {
		pan.bounds.x -= g->border;
		pan.bounds.y -= g->border;
		pan.bounds.w += 2 * g->border;
		pan.bounds.h += 2 * g->border;
	}
	if (!(g->flags & NK_WINDOW_NO_SCROLLBAR)) {
		pan.bounds.w += ctx->style.window.scrollbar_size.x;
		pan.bounds.h += ctx->style.window.scrollbar_size.y;
	}
	pan.scrollbar.x = *g->offset_x;
	pan.scrollbar.y = *g->offset_y;
	pan.flags = g->flags;
	pan.buffer = win->buffer;
	pan.layout = g;
	pan.parent = win;
	ctx->current = &pan;

	/* make sure group has correct clipping rectangle */
	nk_unify(&clip, &parent->clip, pan.bounds.x, pan.bounds.y, pan.bounds.x + pan.bounds.w,
		pan.bounds.y + pan.bounds.h + panel_padding.x);
	nk_push_scissor(&pan.buffer, clip);
	nk_end(ctx);

	win->buffer = pan.buffer;
	nk_push_scissor(&win->buffer, parent->clip);
	ctx->current = win;
	win->layout = parent;
	g->bounds = pan.bounds;
	return;
}

NK_API int
nk_group_scrolled_begin(struct nk_context* ctx, struct nk_scroll* scroll, const char* title, nk_flags flags) {
	return nk_group_scrolled_offset_begin(ctx, &scroll->x, &scroll->y, title, flags);
}

NK_API int nk_group_begin_titled(struct nk_context* ctx, const char* id, const char* title, nk_flags flags) {
	int id_len;
	nk_hash id_hash;
	struct nk_window* win;
	nk_uint* x_offset;
	nk_uint* y_offset;

	NK_ASSERT(ctx);
	NK_ASSERT(id);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !id)
		return 0;

	/* find persistent group scrollbar value */
	win = ctx->current;
	id_len = (int)nk_strlen(id);
	id_hash = nk_murmur_hash(id, (int)id_len, NK_PANEL_GROUP);
	x_offset = nk_find_value(win, id_hash);
	if (!x_offset) {
		x_offset = nk_add_value(ctx, win, id_hash, 0);
		y_offset = nk_add_value(ctx, win, id_hash + 1, 0);

		NK_ASSERT(x_offset);
		NK_ASSERT(y_offset);
		if (!x_offset || !y_offset) return 0;
		*x_offset = *y_offset = 0;
	}
	else y_offset = nk_find_value(win, id_hash + 1);
	return nk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags);
}

NK_API int nk_group_begin(struct nk_context* ctx, const char* title, nk_flags flags) {
	return nk_group_begin_titled(ctx, title, title, flags);
}

NK_API void nk_group_end(struct nk_context* ctx) {
	nk_group_scrolled_end(ctx);
}





/* ===============================================================
 *
 *                          LIST VIEW
 *
 * ===============================================================*/
NK_API int
nk_list_view_begin(struct nk_context* ctx, struct nk_list_view* view, const char* title, nk_flags flags, int row_height,
	int row_count) {
	int title_len;
	nk_hash title_hash;
	nk_uint* x_offset;
	nk_uint* y_offset;

	int result;
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_vec2 item_spacing;

	NK_ASSERT(ctx);
	NK_ASSERT(view);
	NK_ASSERT(title);
	if (!ctx || !view || !title) return 0;

	win = ctx->current;
	style = &ctx->style;
	item_spacing = style->window.spacing;
	row_height += NK_MAX(0, (int)item_spacing.y);

	/* find persistent list view scrollbar offset */
	title_len = (int)nk_strlen(title);
	title_hash = nk_murmur_hash(title, (int)title_len, NK_PANEL_GROUP);
	x_offset = nk_find_value(win, title_hash);
	if (!x_offset) {
		x_offset = nk_add_value(ctx, win, title_hash, 0);
		y_offset = nk_add_value(ctx, win, title_hash + 1, 0);

		NK_ASSERT(x_offset);
		NK_ASSERT(y_offset);
		if (!x_offset || !y_offset) return 0;
		*x_offset = *y_offset = 0;
	}
	else y_offset = nk_find_value(win, title_hash + 1);
	view->scroll_value = *y_offset;
	view->scroll_pointer = y_offset;

	*y_offset = 0;
	result = nk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags);
	win = ctx->current;
	layout = win->layout;

	view->total_height = row_height * NK_MAX(row_count, 1);
	view->begin = (int)NK_MAX(((float)view->scroll_value / (float)row_height), 0.0f);
	view->count = (int)NK_MAX(nk_iceilf((layout->clip.h) / (float)row_height), 0);
	view->count = NK_MIN(view->count, row_count - view->begin);
	view->end = view->begin + view->count;
	view->ctx = ctx;
	return result;
}

NK_API void nk_list_view_end(struct nk_list_view* view) {
	struct nk_context* ctx;
	struct nk_window* win;
	struct nk_panel* layout;

	NK_ASSERT(view);
	NK_ASSERT(view->ctx);
	NK_ASSERT(view->scroll_pointer);
	if (!view || !view->ctx) return;

	ctx = view->ctx;
	win = ctx->current;
	layout = win->layout;
	layout->at_y = layout->bounds.y + (float)view->total_height;
	*view->scroll_pointer = *view->scroll_pointer + view->scroll_value;
	nk_group_end(view->ctx);
}





/* ===============================================================
 *
 *                              WIDGET
 *
 * ===============================================================*/
NK_API struct nk_rect nk_widget_bounds(struct nk_context* ctx) {
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return nk_rect(0, 0, 0, 0);
	nk_layout_peek(&bounds, ctx);
	return bounds;
}

NK_API struct nk_vec2 nk_widget_position(struct nk_context* ctx) {
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return nk_vec2(0, 0);

	nk_layout_peek(&bounds, ctx);
	return nk_vec2(bounds.x, bounds.y);
}

NK_API struct nk_vec2 nk_widget_size(struct nk_context* ctx) {
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return nk_vec2(0, 0);

	nk_layout_peek(&bounds, ctx);
	return nk_vec2(bounds.w, bounds.h);
}

NK_API float nk_widget_width(struct nk_context* ctx) {
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return 0;

	nk_layout_peek(&bounds, ctx);
	return bounds.w;
}

NK_API float nk_widget_height(struct nk_context* ctx) {
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return 0;

	nk_layout_peek(&bounds, ctx);
	return bounds.h;
}

NK_API int nk_widget_is_hovered(struct nk_context* ctx) {
	struct nk_rect c, v;
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current || ctx->active != ctx->current)
		return 0;

	c = ctx->current->layout->clip;
	c.x = (float)((int)c.x);
	c.y = (float)((int)c.y);
	c.w = (float)((int)c.w);
	c.h = (float)((int)c.h);

	nk_layout_peek(&bounds, ctx);
	nk_unify(&v, &c, bounds.x, bounds.y, bounds.x + bounds.w, bounds.y + bounds.h);
	if (!NK_INTERSECT(c.x, c.y, c.w, c.h, bounds.x, bounds.y, bounds.w, bounds.h))
		return 0;
	return nk_input_is_mouse_hovering_rect(&ctx->input, bounds);
}

NK_API int nk_widget_is_mouse_clicked(struct nk_context* ctx, enum nk_buttons btn) {
	struct nk_rect c, v;
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current || ctx->active != ctx->current)
		return 0;

	c = ctx->current->layout->clip;
	c.x = (float)((int)c.x);
	c.y = (float)((int)c.y);
	c.w = (float)((int)c.w);
	c.h = (float)((int)c.h);

	nk_layout_peek(&bounds, ctx);
	nk_unify(&v, &c, bounds.x, bounds.y, bounds.x + bounds.w, bounds.y + bounds.h);
	if (!NK_INTERSECT(c.x, c.y, c.w, c.h, bounds.x, bounds.y, bounds.w, bounds.h))
		return 0;
	return nk_input_mouse_clicked(&ctx->input, btn, bounds);
}

NK_API int nk_widget_has_mouse_click_down(struct nk_context* ctx, enum nk_buttons btn, int down) {
	struct nk_rect c, v;
	struct nk_rect bounds;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current || ctx->active != ctx->current)
		return 0;

	c = ctx->current->layout->clip;
	c.x = (float)((int)c.x);
	c.y = (float)((int)c.y);
	c.w = (float)((int)c.w);
	c.h = (float)((int)c.h);

	nk_layout_peek(&bounds, ctx);
	nk_unify(&v, &c, bounds.x, bounds.y, bounds.x + bounds.w, bounds.y + bounds.h);
	if (!NK_INTERSECT(c.x, c.y, c.w, c.h, bounds.x, bounds.y, bounds.w, bounds.h))
		return 0;
	return nk_input_has_mouse_click_down_in_rect(&ctx->input, btn, bounds, down);
}

NK_API enum nk_widget_layout_states nk_widget(struct nk_rect* bounds, const struct nk_context* ctx) {
	struct nk_rect c, v;
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return NK_WIDGET_INVALID;

	/* allocate space and check if the widget needs to be updated and drawn */
	nk_panel_alloc_space(bounds, ctx);
	win = ctx->current;
	layout = win->layout;
	in = &ctx->input;
	c = layout->clip;

	/*  if one of these triggers you forgot to add an `if` condition around either
		a window, group, popup, combobox or contextual menu `begin` and `end` block.
		Example:
			if (nk_begin(...) {...} nk_end(...); or
			if (nk_group_begin(...) { nk_group_end(...);} */
	NK_ASSERT(!(layout->flags & NK_WINDOW_MINIMIZED));
	NK_ASSERT(!(layout->flags & NK_WINDOW_HIDDEN));
	NK_ASSERT(!(layout->flags & NK_WINDOW_CLOSED));

	/* need to convert to int here to remove floating point errors */
	bounds->x = (float)((int)bounds->x);
	bounds->y = (float)((int)bounds->y);
	bounds->w = (float)((int)bounds->w);
	bounds->h = (float)((int)bounds->h);

	c.x = (float)((int)c.x);
	c.y = (float)((int)c.y);
	c.w = (float)((int)c.w);
	c.h = (float)((int)c.h);

	nk_unify(&v, &c, bounds->x, bounds->y, bounds->x + bounds->w, bounds->y + bounds->h);
	if (!NK_INTERSECT(c.x, c.y, c.w, c.h, bounds->x, bounds->y, bounds->w, bounds->h))
		return NK_WIDGET_INVALID;
	if (!NK_INBOX(in->mouse.pos.x, in->mouse.pos.y, v.x, v.y, v.w, v.h))
		return NK_WIDGET_ROM;
	return NK_WIDGET_VALID;
}

NK_API enum nk_widget_layout_states
nk_widget_fitting(struct nk_rect* bounds, struct nk_context* ctx, struct nk_vec2 item_padding) {
	/* update the bounds to stand without padding  */
	struct nk_window* win;
	struct nk_style* style;
	struct nk_panel* layout;
	enum nk_widget_layout_states state;
	struct nk_vec2 panel_padding;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return NK_WIDGET_INVALID;

	win = ctx->current;
	style = &ctx->style;
	layout = win->layout;
	state = nk_widget(bounds, ctx);

	panel_padding = nk_panel_get_padding(style, layout->type);
	if (layout->row.index == 1) {
		bounds->w += panel_padding.x;
		bounds->x -= panel_padding.x;
	}
	else bounds->x -= item_padding.x;

	if (layout->row.index == layout->row.columns)
		bounds->w += panel_padding.x;
	else bounds->w += item_padding.x;
	return state;
}

NK_API void nk_spacing(struct nk_context* ctx, int cols) {
	struct nk_window* win;
	struct nk_panel* layout;
	struct nk_rect none;
	int i, index, rows;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	/* spacing over row boundaries */
	win = ctx->current;
	layout = win->layout;
	index = (layout->row.index + cols) % layout->row.columns;
	rows = (layout->row.index + cols) / layout->row.columns;
	if (rows) {
		for (i = 0; i < rows; ++i)
			nk_panel_alloc_row(ctx, win);
		cols = index;
	}
	/* non table layout need to allocate space */
	if (layout->row.type != NK_LAYOUT_DYNAMIC_FIXED && layout->row.type != NK_LAYOUT_STATIC_FIXED) {
		for (i = 0; i < cols; ++i)
			nk_panel_alloc_space(&none, ctx);
	}
	layout->row.index = index;
}





/* ===============================================================
 *
 *                              TEXT
 *
 * ===============================================================*/
NK_LIB void
nk_widget_text(struct nk_command_buffer* o, struct nk_rect b, const char* string, int len, const struct nk_text* t,
	nk_flags a, const struct nk_user_font* f) {
	struct nk_rect label;
	float text_width;

	NK_ASSERT(o);
	NK_ASSERT(t);
	if (!o || !t) return;

	b.h = NK_MAX(b.h, 2 * t->padding.y);
	label.x = 0;
	label.w = 0;
	label.y = b.y + t->padding.y;
	label.h = NK_MIN(f->height, b.h - 2 * t->padding.y);

	text_width = f->width(f->userdata, f->height, (const char*)string, len);
	text_width += (2.0f * t->padding.x);

	/* align in x-axis */
	if (a & NK_TEXT_ALIGN_LEFT) {
		label.x = b.x + t->padding.x;
		label.w = NK_MAX(0, b.w - 2 * t->padding.x);
	}
	else if (a & NK_TEXT_ALIGN_CENTERED) {
		label.w = NK_MAX(1, 2 * t->padding.x + (float)text_width);
		label.x = (b.x + t->padding.x + ((b.w - 2 * t->padding.x) - label.w) / 2);
		label.x = NK_MAX(b.x + t->padding.x, label.x);
		label.w = NK_MIN(b.x + b.w, label.x + label.w);
		if (label.w >= label.x) label.w -= label.x;
	}
	else if (a & NK_TEXT_ALIGN_RIGHT) {
		label.x = NK_MAX(b.x + t->padding.x, (b.x + b.w) - (2 * t->padding.x + (float)text_width));
		label.w = (float)text_width + 2 * t->padding.x;
	}
	else return;

	/* align in y-axis */
	if (a & NK_TEXT_ALIGN_MIDDLE) {
		label.y = b.y + b.h / 2.0f - (float)f->height / 2.0f;
		label.h = NK_MAX(b.h / 2.0f, b.h - (b.h / 2.0f + f->height / 2.0f));
	}
	else if (a & NK_TEXT_ALIGN_BOTTOM) {
		label.y = b.y + b.h - f->height;
		label.h = f->height;
	}
	nk_draw_text(o, label, (const char*)string, len, f, t->background, t->text);
}

NK_LIB void
nk_widget_text_wrap(struct nk_command_buffer* o, struct nk_rect b, const char* string, int len, const struct nk_text* t,
	const struct nk_user_font* f) {
	float width;
	int glyphs = 0;
	int fitting = 0;
	int done = 0;
	struct nk_rect line;
	struct nk_text text;
	NK_INTERN nk_rune seperator[] = { ' ' };

	NK_ASSERT(o);
	NK_ASSERT(t);
	if (!o || !t) return;

	text.padding = nk_vec2(0, 0);
	text.background = t->background;
	text.text = t->text;

	b.w = NK_MAX(b.w, 2 * t->padding.x);
	b.h = NK_MAX(b.h, 2 * t->padding.y);
	b.h = b.h - 2 * t->padding.y;

	line.x = b.x + t->padding.x;
	line.y = b.y + t->padding.y;
	line.w = b.w - 2 * t->padding.x;
	line.h = 2 * t->padding.y + f->height;

	fitting = nk_text_clamp(f, string, len, line.w, &glyphs, &width, seperator, NK_LEN(seperator));
	while (done < len) {
		if (!fitting || line.y + line.h >= (b.y + b.h)) break;
		nk_widget_text(o, line, &string[done], fitting, &text, NK_TEXT_LEFT, f);
		done += fitting;
		line.y += f->height + 2 * t->padding.y;
		fitting = nk_text_clamp(f, &string[done], len - done, line.w, &glyphs, &width, seperator, NK_LEN(seperator));
	}
}

NK_API void
nk_text_colored(struct nk_context* ctx, const char* str, int len, nk_flags alignment, struct nk_color color) {
	struct nk_window* win;
	const struct nk_style* style;

	struct nk_vec2 item_padding;
	struct nk_rect bounds;
	struct nk_text text;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return;

	win = ctx->current;
	style = &ctx->style;
	nk_panel_alloc_space(&bounds, ctx);
	item_padding = style->text.padding;

	text.padding.x = item_padding.x;
	text.padding.y = item_padding.y;
	text.background = style->window.background;
	text.text = color;
	nk_widget_text(&win->buffer, bounds, str, len, &text, alignment, style->font);
}

NK_API void nk_text_wrap_colored(struct nk_context* ctx, const char* str, int len, struct nk_color color) {
	struct nk_window* win;
	const struct nk_style* style;

	struct nk_vec2 item_padding;
	struct nk_rect bounds;
	struct nk_text text;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return;

	win = ctx->current;
	style = &ctx->style;
	nk_panel_alloc_space(&bounds, ctx);
	item_padding = style->text.padding;

	text.padding.x = item_padding.x;
	text.padding.y = item_padding.y;
	text.background = style->window.background;
	text.text = color;
	nk_widget_text_wrap(&win->buffer, bounds, str, len, &text, style->font);
}

#ifdef NK_INCLUDE_STANDARD_VARARGS

NK_API void nk_labelf_colored(struct nk_context* ctx, nk_flags flags, struct nk_color color, const char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	nk_labelfv_colored(ctx, flags, color, fmt, args);
	va_end(args);
}

NK_API void nk_labelf_colored_wrap(struct nk_context* ctx, struct nk_color color, const char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	nk_labelfv_colored_wrap(ctx, color, fmt, args);
	va_end(args);
}

NK_API void nk_labelf(struct nk_context* ctx, nk_flags flags, const char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	nk_labelfv(ctx, flags, fmt, args);
	va_end(args);
}

NK_API void nk_labelf_wrap(struct nk_context* ctx, const char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	nk_labelfv_wrap(ctx, fmt, args);
	va_end(args);
}

NK_API void
nk_labelfv_colored(struct nk_context* ctx, nk_flags flags, struct nk_color color, const char* fmt, va_list args) {
	char buf[256];
	nk_strfmt(buf, NK_LEN(buf), fmt, args);
	nk_label_colored(ctx, buf, flags, color);
}

NK_API void nk_labelfv_colored_wrap(struct nk_context* ctx, struct nk_color color, const char* fmt, va_list args) {
	char buf[256];
	nk_strfmt(buf, NK_LEN(buf), fmt, args);
	nk_label_colored_wrap(ctx, buf, color);
}

NK_API void nk_labelfv(struct nk_context* ctx, nk_flags flags, const char* fmt, va_list args) {
	char buf[256];
	nk_strfmt(buf, NK_LEN(buf), fmt, args);
	nk_label(ctx, buf, flags);
}

NK_API void nk_labelfv_wrap(struct nk_context* ctx, const char* fmt, va_list args) {
	char buf[256];
	nk_strfmt(buf, NK_LEN(buf), fmt, args);
	nk_label_wrap(ctx, buf);
}

NK_API void nk_value_bool(struct nk_context* ctx, const char* prefix, int value) {
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: %s", prefix, ((value) ? "true" : "false"));
}

NK_API void nk_value_int(struct nk_context* ctx, const char* prefix, int value) {
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: %d", prefix, value);
}

NK_API void nk_value_uint(struct nk_context* ctx, const char* prefix, unsigned int value) {
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: %u", prefix, value);
}

NK_API void nk_value_float(struct nk_context* ctx, const char* prefix, float value) {
	double double_value = (double)value;
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: %.3f", prefix, double_value);
}

NK_API void nk_value_color_byte(struct nk_context* ctx, const char* p, struct nk_color c) {
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: (%d, %d, %d, %d)", p, c.r, c.g, c.b, c.a);
}

NK_API void nk_value_color_float(struct nk_context* ctx, const char* p, struct nk_color color) {
	double c[4];
	nk_color_dv(c, color);
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: (%.2f, %.2f, %.2f, %.2f)", p, c[0], c[1], c[2], c[3]);
}

NK_API void nk_value_color_hex(struct nk_context* ctx, const char* prefix, struct nk_color color) {
	char hex[16];
	nk_color_hex_rgba(hex, color);
	nk_labelf(ctx, NK_TEXT_LEFT, "%s: %s", prefix, hex);
}

#endif

NK_API void nk_text(struct nk_context* ctx, const char* str, int len, nk_flags alignment) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	nk_text_colored(ctx, str, len, alignment, ctx->style.text.color);
}

NK_API void nk_text_wrap(struct nk_context* ctx, const char* str, int len) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	nk_text_wrap_colored(ctx, str, len, ctx->style.text.color);
}

NK_API void nk_label(struct nk_context* ctx, const char* str, nk_flags alignment) {
	nk_text(ctx, str, nk_strlen(str), alignment);
}

NK_API void nk_label_colored(struct nk_context* ctx, const char* str, nk_flags align, struct nk_color color) {
	nk_text_colored(ctx, str, nk_strlen(str), align, color);
}

NK_API void nk_label_wrap(struct nk_context* ctx, const char* str) {
	nk_text_wrap(ctx, str, nk_strlen(str));
}

NK_API void nk_label_colored_wrap(struct nk_context* ctx, const char* str, struct nk_color color) {
	nk_text_wrap_colored(ctx, str, nk_strlen(str), color);
}





/* ===============================================================
 *
 *                          IMAGE
 *
 * ===============================================================*/
NK_API nk_handle nk_handle_ptr(void* ptr) {
	nk_handle handle = { 0 };
	handle.ptr = ptr;
	return handle;
}

NK_API nk_handle nk_handle_id(int id) {
	nk_handle handle;
	nk_zero_struct(handle);
	handle.id = id;
	return handle;
}

NK_API struct nk_image nk_subimage_ptr(void* ptr, unsigned short w, unsigned short h, struct nk_rect r) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	s.handle.ptr = ptr;
	s.w = w;
	s.h = h;
	s.region[0] = (unsigned short)r.x;
	s.region[1] = (unsigned short)r.y;
	s.region[2] = (unsigned short)r.w;
	s.region[3] = (unsigned short)r.h;
	return s;
}

NK_API struct nk_image nk_subimage_id(int id, unsigned short w, unsigned short h, struct nk_rect r) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	s.handle.id = id;
	s.w = w;
	s.h = h;
	s.region[0] = (unsigned short)r.x;
	s.region[1] = (unsigned short)r.y;
	s.region[2] = (unsigned short)r.w;
	s.region[3] = (unsigned short)r.h;
	return s;
}

NK_API struct nk_image nk_subimage_handle(nk_handle handle, unsigned short w, unsigned short h, struct nk_rect r) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	s.handle = handle;
	s.w = w;
	s.h = h;
	s.region[0] = (unsigned short)r.x;
	s.region[1] = (unsigned short)r.y;
	s.region[2] = (unsigned short)r.w;
	s.region[3] = (unsigned short)r.h;
	return s;
}

NK_API struct nk_image nk_image_handle(nk_handle handle) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	s.handle = handle;
	s.w = 0;
	s.h = 0;
	s.region[0] = 0;
	s.region[1] = 0;
	s.region[2] = 0;
	s.region[3] = 0;
	return s;
}

NK_API struct nk_image nk_image_ptr(void* ptr) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	NK_ASSERT(ptr);
	s.handle.ptr = ptr;
	s.w = 0;
	s.h = 0;
	s.region[0] = 0;
	s.region[1] = 0;
	s.region[2] = 0;
	s.region[3] = 0;
	return s;
}

NK_API struct nk_image nk_image_id(int id) {
	struct nk_image s;
	nk_zero(&s, sizeof(s));
	s.handle.id = id;
	s.w = 0;
	s.h = 0;
	s.region[0] = 0;
	s.region[1] = 0;
	s.region[2] = 0;
	s.region[3] = 0;
	return s;
}

NK_API int nk_image_is_subimage(const struct nk_image* img) {
	NK_ASSERT(img);
	return !(img->w == 0 && img->h == 0);
}

NK_API void nk_image(struct nk_context* ctx, struct nk_image img) {
	struct nk_window* win;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return;

	win = ctx->current;
	if (!nk_widget(&bounds, ctx)) return;
	nk_draw_image(&win->buffer, bounds, &img, nk_white);
}

NK_API void nk_image_color(struct nk_context* ctx, struct nk_image img, struct nk_color col) {
	struct nk_window* win;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout) return;

	win = ctx->current;
	if (!nk_widget(&bounds, ctx)) return;
	nk_draw_image(&win->buffer, bounds, &img, col);
}





/* ==============================================================
 *
 *                          BUTTON
 *
 * ===============================================================*/
NK_LIB void nk_draw_symbol(struct nk_command_buffer* out, enum nk_symbol_type type, struct nk_rect content,
	struct nk_color background, struct nk_color foreground, float border_width,
	const struct nk_user_font* font) {
	switch (type) {
	case NK_SYMBOL_X:
	case NK_SYMBOL_UNDERSCORE:
	case NK_SYMBOL_PLUS:
	case NK_SYMBOL_MINUS: {
		/* single character text symbol */
		const char* X = (type == NK_SYMBOL_X) ? "x" : (type == NK_SYMBOL_UNDERSCORE) ? "_" : (type ==
			NK_SYMBOL_PLUS) ? "+"
			: "-";
		struct nk_text text;
		text.padding = nk_vec2(0, 0);
		text.background = background;
		text.text = foreground;
		nk_widget_text(out, content, X, 1, &text, NK_TEXT_CENTERED, font);
	}
						break;
	case NK_SYMBOL_CIRCLE_SOLID:
	case NK_SYMBOL_CIRCLE_OUTLINE:
	case NK_SYMBOL_RECT_SOLID:
	case NK_SYMBOL_RECT_OUTLINE: {
		/* simple empty/filled shapes */
		if (type == NK_SYMBOL_RECT_SOLID || type == NK_SYMBOL_RECT_OUTLINE) {
			nk_fill_rect(out, content, 0, foreground);
			if (type == NK_SYMBOL_RECT_OUTLINE)
				nk_fill_rect(out, nk_shrink_rect(content, border_width), 0, background);
		}
		else {
			nk_fill_circle(out, content, foreground);
			if (type == NK_SYMBOL_CIRCLE_OUTLINE)
				nk_fill_circle(out, nk_shrink_rect(content, 1), background);
		}
	}
							   break;
	case NK_SYMBOL_TRIANGLE_UP:
	case NK_SYMBOL_TRIANGLE_DOWN:
	case NK_SYMBOL_TRIANGLE_LEFT:
	case NK_SYMBOL_TRIANGLE_RIGHT: {
		enum nk_heading heading;
		struct nk_vec2 points[3];
		heading = (type == NK_SYMBOL_TRIANGLE_RIGHT) ? NK_RIGHT : (type == NK_SYMBOL_TRIANGLE_LEFT) ? NK_LEFT
			: (type ==
				NK_SYMBOL_TRIANGLE_UP)
			? NK_UP
			: NK_DOWN;
		nk_triangle_from_direction(points, content, 0, 0, heading);
		nk_fill_triangle(out, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y,
			foreground);
	}
								 break;
	default:
	case NK_SYMBOL_NONE:
	case NK_SYMBOL_MAX:
		break;
	}
}

NK_LIB int
nk_button_behavior(nk_flags* state, struct nk_rect r, const struct nk_input* i, enum nk_button_behavior behavior) {
	int ret = 0;
	nk_widget_state_reset(state);
	if (!i) return 0;
	if (nk_input_is_mouse_hovering_rect(i, r)) {
		*state = NK_WIDGET_STATE_HOVERED;
		if (nk_input_is_mouse_down(i, NK_BUTTON_LEFT))
			*state = NK_WIDGET_STATE_ACTIVE;
		if (nk_input_has_mouse_click_in_rect(i, NK_BUTTON_LEFT, r)) {
			ret = (behavior != NK_BUTTON_DEFAULT) ? nk_input_is_mouse_down(i, NK_BUTTON_LEFT) :
#ifdef NK_BUTTON_TRIGGER_ON_RELEASE
				nk_input_is_mouse_released(i, NK_BUTTON_LEFT);
#else
				nk_input_is_mouse_pressed(i, NK_BUTTON_LEFT);
#endif
		}
	}
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(i, r))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(i, r))
		*state |= NK_WIDGET_STATE_LEFT;
	return ret;
}

NK_LIB const struct nk_style_item*
nk_draw_button(struct nk_command_buffer* out, const struct nk_rect* bounds, nk_flags state,
	const struct nk_style_button* style) {
	const struct nk_style_item* background;
	if (state & NK_WIDGET_STATE_HOVER)
		background = &style->hover;
	else if (state & NK_WIDGET_STATE_ACTIVED)
		background = &style->active;
	else background = &style->normal;

	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(out, *bounds, &background->data.image, nk_white);
	}
	else {
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
	}
	return background;
}

NK_LIB int
nk_do_button(nk_flags* state, struct nk_command_buffer* out, struct nk_rect r, const struct nk_style_button* style,
	const struct nk_input* in, enum nk_button_behavior behavior, struct nk_rect* content) {
	struct nk_rect bounds;
	NK_ASSERT(style);
	NK_ASSERT(state);
	NK_ASSERT(out);
	if (!out || !style)
		return nk_false;

	/* calculate button content space */
	content->x = r.x + style->padding.x + style->border + style->rounding;
	content->y = r.y + style->padding.y + style->border + style->rounding;
	content->w = r.w - (2 * style->padding.x + style->border + style->rounding * 2);
	content->h = r.h - (2 * style->padding.y + style->border + style->rounding * 2);

	/* execute button behavior */
	bounds.x = r.x - style->touch_padding.x;
	bounds.y = r.y - style->touch_padding.y;
	bounds.w = r.w + 2 * style->touch_padding.x;
	bounds.h = r.h + 2 * style->touch_padding.y;
	return nk_button_behavior(state, bounds, in, behavior);
}

NK_LIB void
nk_draw_button_text(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, const char* txt, int len,
	nk_flags text_alignment, const struct nk_user_font* font) {
	struct nk_text text;
	const struct nk_style_item* background;
	background = nk_draw_button(out, bounds, state, style);

	/* select correct colors/images */
	if (background->type == NK_STYLE_ITEM_COLOR)
		text.background = background->data.color;
	else text.background = style->text_background;
	if (state & NK_WIDGET_STATE_HOVER)
		text.text = style->text_hover;
	else if (state & NK_WIDGET_STATE_ACTIVED)
		text.text = style->text_active;
	else text.text = style->text_normal;

	text.padding = nk_vec2(0, 0);
	nk_widget_text(out, *content, txt, len, &text, text_alignment, font);
}

NK_LIB int
nk_do_button_text(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* string, int len,
	nk_flags align, enum nk_button_behavior behavior, const struct nk_style_button* style,
	const struct nk_input* in, const struct nk_user_font* font) {
	struct nk_rect content;
	int ret = nk_false;

	NK_ASSERT(state);
	NK_ASSERT(style);
	NK_ASSERT(out);
	NK_ASSERT(string);
	NK_ASSERT(font);
	if (!out || !style || !font || !string)
		return nk_false;

	ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_button_text(out, &bounds, &content, *state, style, string, len, align, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return ret;
}

NK_LIB void
nk_draw_button_symbol(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, enum nk_symbol_type type,
	const struct nk_user_font* font) {
	struct nk_color sym, bg;
	const struct nk_style_item* background;

	/* select correct colors/images */
	background = nk_draw_button(out, bounds, state, style);
	if (background->type == NK_STYLE_ITEM_COLOR)
		bg = background->data.color;
	else bg = style->text_background;

	if (state & NK_WIDGET_STATE_HOVER)
		sym = style->text_hover;
	else if (state & NK_WIDGET_STATE_ACTIVED)
		sym = style->text_active;
	else sym = style->text_normal;
	nk_draw_symbol(out, type, *content, bg, sym, 1, font);
}

NK_LIB int
nk_do_button_symbol(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, enum nk_symbol_type symbol,
	enum nk_button_behavior behavior, const struct nk_style_button* style, const struct nk_input* in,
	const struct nk_user_font* font) {
	int ret;
	struct nk_rect content;

	NK_ASSERT(state);
	NK_ASSERT(style);
	NK_ASSERT(font);
	NK_ASSERT(out);
	if (!out || !style || !font || !state)
		return nk_false;

	ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_button_symbol(out, &bounds, &content, *state, style, symbol, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return ret;
}

NK_LIB void
nk_draw_button_image(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* content,
	nk_flags state, const struct nk_style_button* style, const struct nk_image* img) {
	nk_draw_button(out, bounds, state, style);
	nk_draw_image(out, *content, img, nk_white);
}

NK_LIB int
nk_do_button_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, struct nk_image img,
	enum nk_button_behavior b, const struct nk_style_button* style, const struct nk_input* in) {
	int ret;
	struct nk_rect content;

	NK_ASSERT(state);
	NK_ASSERT(style);
	NK_ASSERT(out);
	if (!out || !style || !state)
		return nk_false;

	ret = nk_do_button(state, out, bounds, style, in, b, &content);
	content.x += style->image_padding.x;
	content.y += style->image_padding.y;
	content.w -= 2 * style->image_padding.x;
	content.h -= 2 * style->image_padding.y;

	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_button_image(out, &bounds, &content, *state, style, &img);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return ret;
}

NK_LIB void
nk_draw_button_text_symbol(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* label,
	const struct nk_rect* symbol, nk_flags state, const struct nk_style_button* style,
	const char* str, int len, enum nk_symbol_type type, const struct nk_user_font* font) {
	struct nk_color sym;
	struct nk_text text;
	const struct nk_style_item* background;

	/* select correct background colors/images */
	background = nk_draw_button(out, bounds, state, style);
	if (background->type == NK_STYLE_ITEM_COLOR)
		text.background = background->data.color;
	else text.background = style->text_background;

	/* select correct text colors */
	if (state & NK_WIDGET_STATE_HOVER) {
		sym = style->text_hover;
		text.text = style->text_hover;
	}
	else if (state & NK_WIDGET_STATE_ACTIVED) {
		sym = style->text_active;
		text.text = style->text_active;
	}
	else {
		sym = style->text_normal;
		text.text = style->text_normal;
	}

	text.padding = nk_vec2(0, 0);
	nk_draw_symbol(out, type, *symbol, style->text_background, sym, 0, font);
	nk_widget_text(out, *label, str, len, &text, NK_TEXT_CENTERED, font);
}

NK_LIB int nk_do_button_text_symbol(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds,
	enum nk_symbol_type symbol, const char* str, int len, nk_flags align,
	enum nk_button_behavior behavior, const struct nk_style_button* style,
	const struct nk_user_font* font, const struct nk_input* in) {
	int ret;
	struct nk_rect tri = { 0, 0, 0, 0 };
	struct nk_rect content;

	NK_ASSERT(style);
	NK_ASSERT(out);
	NK_ASSERT(font);
	if (!out || !style || !font)
		return nk_false;

	ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
	tri.y = content.y + (content.h / 2) - font->height / 2;
	tri.w = font->height;
	tri.h = font->height;
	if (align & NK_TEXT_ALIGN_LEFT) {
		tri.x = (content.x + content.w) - (2 * style->padding.x + tri.w);
		tri.x = NK_MAX(tri.x, 0);
	}
	else tri.x = content.x + 2 * style->padding.x;

	/* draw button */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_button_text_symbol(out, &bounds, &content, &tri, *state, style, str, len, symbol, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return ret;
}

NK_LIB void
nk_draw_button_text_image(struct nk_command_buffer* out, const struct nk_rect* bounds, const struct nk_rect* label,
	const struct nk_rect* image, nk_flags state, const struct nk_style_button* style,
	const char* str, int len, const struct nk_user_font* font, const struct nk_image* img) {
	struct nk_text text;
	const struct nk_style_item* background;
	background = nk_draw_button(out, bounds, state, style);

	/* select correct colors */
	if (background->type == NK_STYLE_ITEM_COLOR)
		text.background = background->data.color;
	else text.background = style->text_background;
	if (state & NK_WIDGET_STATE_HOVER)
		text.text = style->text_hover;
	else if (state & NK_WIDGET_STATE_ACTIVED)
		text.text = style->text_active;
	else text.text = style->text_normal;

	text.padding = nk_vec2(0, 0);
	nk_widget_text(out, *label, str, len, &text, NK_TEXT_CENTERED, font);
	nk_draw_image(out, *image, img, nk_white);
}

NK_LIB int
nk_do_button_text_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, struct nk_image img,
	const char* str, int len, nk_flags align, enum nk_button_behavior behavior,
	const struct nk_style_button* style, const struct nk_user_font* font,
	const struct nk_input* in) {
	int ret;
	struct nk_rect icon;
	struct nk_rect content;

	NK_ASSERT(style);
	NK_ASSERT(state);
	NK_ASSERT(font);
	NK_ASSERT(out);
	if (!out || !font || !style || !str)
		return nk_false;

	ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
	icon.y = bounds.y + style->padding.y;
	icon.w = icon.h = bounds.h - 2 * style->padding.y;
	if (align & NK_TEXT_ALIGN_LEFT) {
		icon.x = (bounds.x + bounds.w) - (2 * style->padding.x + icon.w);
		icon.x = NK_MAX(icon.x, 0);
	}
	else icon.x = bounds.x + 2 * style->padding.x;

	icon.x += style->image_padding.x;
	icon.y += style->image_padding.y;
	icon.w -= 2 * style->image_padding.x;
	icon.h -= 2 * style->image_padding.y;

	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_button_text_image(out, &bounds, &content, &icon, *state, style, str, len, font, &img);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return ret;
}

NK_API void nk_button_set_behavior(struct nk_context* ctx, enum nk_button_behavior behavior) {
	NK_ASSERT(ctx);
	if (!ctx) return;
	ctx->button_behavior = behavior;
}

NK_API int nk_button_push_behavior(struct nk_context* ctx, enum nk_button_behavior behavior) {
	struct nk_config_stack_button_behavior* button_stack;
	struct nk_config_stack_button_behavior_element* element;

	NK_ASSERT(ctx);
	if (!ctx) return 0;

	button_stack = &ctx->stacks.button_behaviors;
	NK_ASSERT(button_stack->head < (int)NK_LEN(button_stack->elements));
	if (button_stack->head >= (int)NK_LEN(button_stack->elements))
		return 0;

	element = &button_stack->elements[button_stack->head++];
	element->address = &ctx->button_behavior;
	element->old_value = ctx->button_behavior;
	ctx->button_behavior = behavior;
	return 1;
}

NK_API int nk_button_pop_behavior(struct nk_context* ctx) {
	struct nk_config_stack_button_behavior* button_stack;
	struct nk_config_stack_button_behavior_element* element;

	NK_ASSERT(ctx);
	if (!ctx) return 0;

	button_stack = &ctx->stacks.button_behaviors;
	NK_ASSERT(button_stack->head > 0);
	if (button_stack->head < 1)
		return 0;

	element = &button_stack->elements[--button_stack->head];
	*element->address = element->old_value;
	return 1;
}

NK_API int
nk_button_text_styled(struct nk_context* ctx, const struct nk_style_button* style, const char* title, int len) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(style);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!style || !ctx || !ctx->current || !ctx->current->layout) return 0;

	win = ctx->current;
	layout = win->layout;
	state = nk_widget(&bounds, ctx);

	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_button_text(&ctx->last_widget_state, &win->buffer, bounds, title, len, style->text_alignment,
		ctx->button_behavior, style, in, ctx->style.font);
}

NK_API int nk_button_text(struct nk_context* ctx, const char* title, int len) {
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	return nk_button_text_styled(ctx, &ctx->style.button, title, len);
}

NK_API int nk_button_label_styled(struct nk_context* ctx, const struct nk_style_button* style, const char* title) {
	return nk_button_text_styled(ctx, style, title, nk_strlen(title));
}

NK_API int nk_button_label(struct nk_context* ctx, const char* title) {
	return nk_button_text(ctx, title, nk_strlen(title));
}

NK_API int nk_button_color(struct nk_context* ctx, struct nk_color color) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	struct nk_style_button button;

	int ret = 0;
	struct nk_rect bounds;
	struct nk_rect content;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;

	button = ctx->style.button;
	button.normal = nk_style_item_color(color);
	button.hover = nk_style_item_color(color);
	button.active = nk_style_item_color(color);
	ret = nk_do_button(&ctx->last_widget_state, &win->buffer, bounds, &button, in, ctx->button_behavior, &content);
	nk_draw_button(&win->buffer, &bounds, ctx->last_widget_state, &button);
	return ret;
}

NK_API int
nk_button_symbol_styled(struct nk_context* ctx, const struct nk_style_button* style, enum nk_symbol_type symbol) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	layout = win->layout;
	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_button_symbol(&ctx->last_widget_state, &win->buffer, bounds, symbol, ctx->button_behavior, style, in,
		ctx->style.font);
}

NK_API int nk_button_symbol(struct nk_context* ctx, enum nk_symbol_type symbol) {
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	return nk_button_symbol_styled(ctx, &ctx->style.button, symbol);
}

NK_API int nk_button_image_styled(struct nk_context* ctx, const struct nk_style_button* style, struct nk_image img) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_button_image(&ctx->last_widget_state, &win->buffer, bounds, img, ctx->button_behavior, style, in);
}

NK_API int nk_button_image(struct nk_context* ctx, struct nk_image img) {
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	return nk_button_image_styled(ctx, &ctx->style.button, img);
}

NK_API int
nk_button_symbol_text_styled(struct nk_context* ctx, const struct nk_style_button* style, enum nk_symbol_type symbol,
	const char* text, int len, nk_flags align) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_button_text_symbol(&ctx->last_widget_state, &win->buffer, bounds, symbol, text, len, align,
		ctx->button_behavior, style, ctx->style.font, in);
}

NK_API int
nk_button_symbol_text(struct nk_context* ctx, enum nk_symbol_type symbol, const char* text, int len, nk_flags align) {
	NK_ASSERT(ctx);
	if (!ctx) return 0;
	return nk_button_symbol_text_styled(ctx, &ctx->style.button, symbol, text, len, align);
}

NK_API int
nk_button_symbol_label(struct nk_context* ctx, enum nk_symbol_type symbol, const char* label, nk_flags align) {
	return nk_button_symbol_text(ctx, symbol, label, nk_strlen(label), align);
}

NK_API int
nk_button_symbol_label_styled(struct nk_context* ctx, const struct nk_style_button* style, enum nk_symbol_type symbol,
	const char* title, nk_flags align) {
	return nk_button_symbol_text_styled(ctx, style, symbol, title, nk_strlen(title), align);
}

NK_API int nk_button_image_text_styled(struct nk_context* ctx, const struct nk_style_button* style, struct nk_image img,
	const char* text, int len, nk_flags align) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_button_text_image(&ctx->last_widget_state, &win->buffer, bounds, img, text, len, align,
		ctx->button_behavior, style, ctx->style.font, in);
}

NK_API int
nk_button_image_text(struct nk_context* ctx, struct nk_image img, const char* text, int len, nk_flags align) {
	return nk_button_image_text_styled(ctx, &ctx->style.button, img, text, len, align);
}

NK_API int nk_button_image_label(struct nk_context* ctx, struct nk_image img, const char* label, nk_flags align) {
	return nk_button_image_text(ctx, img, label, nk_strlen(label), align);
}

NK_API int
nk_button_image_label_styled(struct nk_context* ctx, const struct nk_style_button* style, struct nk_image img,
	const char* label, nk_flags text_alignment) {
	return nk_button_image_text_styled(ctx, style, img, label, nk_strlen(label), text_alignment);
}





/* ===============================================================
 *
 *                              TOGGLE
 *
 * ===============================================================*/
NK_LIB int nk_toggle_behavior(const struct nk_input* in, struct nk_rect select, nk_flags* state, int active) {
	nk_widget_state_reset(state);
	if (nk_button_behavior(state, select, in, NK_BUTTON_DEFAULT)) {
		*state = NK_WIDGET_STATE_ACTIVE;
		active = !active;
	}
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, select))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, select))
		*state |= NK_WIDGET_STATE_LEFT;
	return active;
}

NK_LIB void
nk_draw_checkbox(struct nk_command_buffer* out, nk_flags state, const struct nk_style_toggle* style, int active,
	const struct nk_rect* label, const struct nk_rect* selector, const struct nk_rect* cursors,
	const char* string, int len, const struct nk_user_font* font) {
	const struct nk_style_item* background;
	const struct nk_style_item* cursor;
	struct nk_text text;

	/* select correct colors/images */
	if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		cursor = &style->cursor_hover;
		text.text = style->text_hover;
	}
	else if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->hover;
		cursor = &style->cursor_hover;
		text.text = style->text_active;
	}
	else {
		background = &style->normal;
		cursor = &style->cursor_normal;
		text.text = style->text_normal;
	}

	/* draw background and cursor */
	if (background->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_rect(out, *selector, 0, style->border_color);
		nk_fill_rect(out, nk_shrink_rect(*selector, style->border), 0, background->data.color);
	}
	else nk_draw_image(out, *selector, &background->data.image, nk_white);
	if (active) {
		if (cursor->type == NK_STYLE_ITEM_IMAGE)
			nk_draw_image(out, *cursors, &cursor->data.image, nk_white);
		else nk_fill_rect(out, *cursors, 0, cursor->data.color);
	}

	text.padding.x = 0;
	text.padding.y = 0;
	text.background = style->text_background;
	nk_widget_text(out, *label, string, len, &text, NK_TEXT_LEFT, font);
}

NK_LIB void
nk_draw_option(struct nk_command_buffer* out, nk_flags state, const struct nk_style_toggle* style, int active,
	const struct nk_rect* label, const struct nk_rect* selector, const struct nk_rect* cursors,
	const char* string, int len, const struct nk_user_font* font) {
	const struct nk_style_item* background;
	const struct nk_style_item* cursor;
	struct nk_text text;

	/* select correct colors/images */
	if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		cursor = &style->cursor_hover;
		text.text = style->text_hover;
	}
	else if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->hover;
		cursor = &style->cursor_hover;
		text.text = style->text_active;
	}
	else {
		background = &style->normal;
		cursor = &style->cursor_normal;
		text.text = style->text_normal;
	}

	/* draw background and cursor */
	if (background->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_circle(out, *selector, style->border_color);
		nk_fill_circle(out, nk_shrink_rect(*selector, style->border), background->data.color);
	}
	else nk_draw_image(out, *selector, &background->data.image, nk_white);
	if (active) {
		if (cursor->type == NK_STYLE_ITEM_IMAGE)
			nk_draw_image(out, *cursors, &cursor->data.image, nk_white);
		else nk_fill_circle(out, *cursors, cursor->data.color);
	}

	text.padding.x = 0;
	text.padding.y = 0;
	text.background = style->text_background;
	nk_widget_text(out, *label, string, len, &text, NK_TEXT_LEFT, font);
}

NK_LIB int
nk_do_toggle(nk_flags* state, struct nk_command_buffer* out, struct nk_rect r, int* active, const char* str, int len,
	enum nk_toggle_type type, const struct nk_style_toggle* style, const struct nk_input* in,
	const struct nk_user_font* font) {
	int was_active;
	struct nk_rect bounds;
	struct nk_rect select;
	struct nk_rect cursor;
	struct nk_rect label;

	NK_ASSERT(style);
	NK_ASSERT(out);
	NK_ASSERT(font);
	if (!out || !style || !font || !active)
		return 0;

	r.w = NK_MAX(r.w, font->height + 2 * style->padding.x);
	r.h = NK_MAX(r.h, font->height + 2 * style->padding.y);

	/* add additional touch padding for touch screen devices */
	bounds.x = r.x - style->touch_padding.x;
	bounds.y = r.y - style->touch_padding.y;
	bounds.w = r.w + 2 * style->touch_padding.x;
	bounds.h = r.h + 2 * style->touch_padding.y;

	/* calculate the selector space */
	select.w = font->height;
	select.h = select.w;
	select.y = r.y + r.h / 2.0f - select.h / 2.0f;
	select.x = r.x;

	/* calculate the bounds of the cursor inside the selector */
	cursor.x = select.x + style->padding.x + style->border;
	cursor.y = select.y + style->padding.y + style->border;
	cursor.w = select.w - (2 * style->padding.x + 2 * style->border);
	cursor.h = select.h - (2 * style->padding.y + 2 * style->border);

	/* label behind the selector */
	label.x = select.x + select.w + style->spacing;
	label.y = select.y;
	label.w = NK_MAX(r.x + r.w, label.x) - label.x;
	label.h = select.w;

	/* update selector */
	was_active = *active;
	*active = nk_toggle_behavior(in, bounds, state, *active);

	/* draw selector */
	if (style->draw_begin)
		style->draw_begin(out, style->userdata);
	if (type == NK_TOGGLE_CHECK) {
		nk_draw_checkbox(out, *state, style, *active, &label, &select, &cursor, str, len, font);
	}
	else {
		nk_draw_option(out, *state, style, *active, &label, &select, &cursor, str, len, font);
	}
	if (style->draw_end)
		style->draw_end(out, style->userdata);
	return (was_active != *active);
}
/*----------------------------------------------------------------
 *
 *                          CHECKBOX
 *
 * --------------------------------------------------------------*/
NK_API int nk_check_text(struct nk_context* ctx, const char* text, int len, int active) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return active;

	win = ctx->current;
	style = &ctx->style;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return active;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	nk_do_toggle(&ctx->last_widget_state, &win->buffer, bounds, &active, text, len, NK_TOGGLE_CHECK, &style->checkbox,
		in, style->font);
	return active;
}

NK_API unsigned int
nk_check_flags_text(struct nk_context* ctx, const char* text, int len, unsigned int flags, unsigned int value) {
	int old_active;
	NK_ASSERT(ctx);
	NK_ASSERT(text);
	if (!ctx || !text) return flags;
	old_active = (int)((flags & value) & value);
	if (nk_check_text(ctx, text, len, old_active))
		flags |= value;
	else flags &= ~value;
	return flags;
}

NK_API int nk_checkbox_text(struct nk_context* ctx, const char* text, int len, int* active) {
	int old_val;
	NK_ASSERT(ctx);
	NK_ASSERT(text);
	NK_ASSERT(active);
	if (!ctx || !text || !active) return 0;
	old_val = *active;
	*active = nk_check_text(ctx, text, len, *active);
	return old_val != *active;
}

NK_API int
nk_checkbox_flags_text(struct nk_context* ctx, const char* text, int len, unsigned int* flags, unsigned int value) {
	int active;
	NK_ASSERT(ctx);
	NK_ASSERT(text);
	NK_ASSERT(flags);
	if (!ctx || !text || !flags) return 0;

	active = (int)((*flags & value) & value);
	if (nk_checkbox_text(ctx, text, len, &active)) {
		if (active) *flags |= value;
		else *flags &= ~value;
		return 1;
	}
	return 0;
}

NK_API int nk_check_label(struct nk_context* ctx, const char* label, int active) {
	return nk_check_text(ctx, label, nk_strlen(label), active);
}

NK_API unsigned int
nk_check_flags_label(struct nk_context* ctx, const char* label, unsigned int flags, unsigned int value) {
	return nk_check_flags_text(ctx, label, nk_strlen(label), flags, value);
}

NK_API int nk_checkbox_label(struct nk_context* ctx, const char* label, int* active) {
	return nk_checkbox_text(ctx, label, nk_strlen(label), active);
}

NK_API int nk_checkbox_flags_label(struct nk_context* ctx, const char* label, unsigned int* flags, unsigned int value) {
	return nk_checkbox_flags_text(ctx, label, nk_strlen(label), flags, value);
}
/*----------------------------------------------------------------
 *
 *                          OPTION
 *
 * --------------------------------------------------------------*/
NK_API int nk_option_text(struct nk_context* ctx, const char* text, int len, int is_active) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return is_active;

	win = ctx->current;
	style = &ctx->style;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return (int)state;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	nk_do_toggle(&ctx->last_widget_state, &win->buffer, bounds, &is_active, text, len, NK_TOGGLE_OPTION, &style->option,
		in, style->font);
	return is_active;
}

NK_API int nk_radio_text(struct nk_context* ctx, const char* text, int len, int* active) {
	int old_value;
	NK_ASSERT(ctx);
	NK_ASSERT(text);
	NK_ASSERT(active);
	if (!ctx || !text || !active) return 0;
	old_value = *active;
	*active = nk_option_text(ctx, text, len, old_value);
	return old_value != *active;
}

NK_API int nk_option_label(struct nk_context* ctx, const char* label, int active) {
	return nk_option_text(ctx, label, nk_strlen(label), active);
}

NK_API int nk_radio_label(struct nk_context* ctx, const char* label, int* active) {
	return nk_radio_text(ctx, label, nk_strlen(label), active);
}





/* ===============================================================
 *
 *                              SELECTABLE
 *
 * ===============================================================*/
NK_LIB void
nk_draw_selectable(struct nk_command_buffer* out, nk_flags state, const struct nk_style_selectable* style, int active,
	const struct nk_rect* bounds, const struct nk_rect* icon, const struct nk_image* img,
	enum nk_symbol_type sym, const char* string, int len, nk_flags align,
	const struct nk_user_font* font) {
	const struct nk_style_item* background;
	struct nk_text text;
	text.padding = style->padding;

	/* select correct colors/images */
	if (!active) {
		if (state & NK_WIDGET_STATE_ACTIVED) {
			background = &style->pressed;
			text.text = style->text_pressed;
		}
		else if (state & NK_WIDGET_STATE_HOVER) {
			background = &style->hover;
			text.text = style->text_hover;
		}
		else {
			background = &style->normal;
			text.text = style->text_normal;
		}
	}
	else {
		if (state & NK_WIDGET_STATE_ACTIVED) {
			background = &style->pressed_active;
			text.text = style->text_pressed_active;
		}
		else if (state & NK_WIDGET_STATE_HOVER) {
			background = &style->hover_active;
			text.text = style->text_hover_active;
		}
		else {
			background = &style->normal_active;
			text.text = style->text_normal_active;
		}
	}
	/* draw selectable background and text */
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(out, *bounds, &background->data.image, nk_white);
		text.background = nk_rgba(0, 0, 0, 0);
	}
	else {
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		text.background = background->data.color;
	}
	if (icon) {
		if (img) nk_draw_image(out, *icon, img, nk_white);
		else nk_draw_symbol(out, sym, *icon, text.background, text.text, 1, font);
	}
	nk_widget_text(out, *bounds, string, len, &text, align, font);
}

NK_LIB int
nk_do_selectable(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* str, int len,
	nk_flags align, int* value, const struct nk_style_selectable* style, const struct nk_input* in,
	const struct nk_user_font* font) {
	int old_value;
	struct nk_rect touch;

	NK_ASSERT(state);
	NK_ASSERT(out);
	NK_ASSERT(str);
	NK_ASSERT(len);
	NK_ASSERT(value);
	NK_ASSERT(style);
	NK_ASSERT(font);

	if (!state || !out || !str || !len || !value || !style || !font) return 0;
	old_value = *value;

	/* remove padding */
	touch.x = bounds.x - style->touch_padding.x;
	touch.y = bounds.y - style->touch_padding.y;
	touch.w = bounds.w + style->touch_padding.x * 2;
	touch.h = bounds.h + style->touch_padding.y * 2;

	/* update button */
	if (nk_button_behavior(state, touch, in, NK_BUTTON_DEFAULT))
		*value = !(*value);

	/* draw selectable */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_selectable(out, *state, style, *value, &bounds, 0, 0, NK_SYMBOL_NONE, str, len, align, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return old_value != *value;
}

NK_LIB int
nk_do_selectable_image(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* str, int len,
	nk_flags align, int* value, const struct nk_image* img, const struct nk_style_selectable* style,
	const struct nk_input* in, const struct nk_user_font* font) {
	int old_value;
	struct nk_rect touch;
	struct nk_rect icon;

	NK_ASSERT(state);
	NK_ASSERT(out);
	NK_ASSERT(str);
	NK_ASSERT(len);
	NK_ASSERT(value);
	NK_ASSERT(style);
	NK_ASSERT(font);

	if (!state || !out || !str || !len || !value || !style || !font) return 0;
	old_value = *value;

	/* toggle behavior */
	touch.x = bounds.x - style->touch_padding.x;
	touch.y = bounds.y - style->touch_padding.y;
	touch.w = bounds.w + style->touch_padding.x * 2;
	touch.h = bounds.h + style->touch_padding.y * 2;
	if (nk_button_behavior(state, touch, in, NK_BUTTON_DEFAULT))
		*value = !(*value);

	icon.y = bounds.y + style->padding.y;
	icon.w = icon.h = bounds.h - 2 * style->padding.y;
	if (align & NK_TEXT_ALIGN_LEFT) {
		icon.x = (bounds.x + bounds.w) - (2 * style->padding.x + icon.w);
		icon.x = NK_MAX(icon.x, 0);
	}
	else icon.x = bounds.x + 2 * style->padding.x;

	icon.x += style->image_padding.x;
	icon.y += style->image_padding.y;
	icon.w -= 2 * style->image_padding.x;
	icon.h -= 2 * style->image_padding.y;

	/* draw selectable */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_selectable(out, *state, style, *value, &bounds, &icon, img, NK_SYMBOL_NONE, str, len, align, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return old_value != *value;
}

NK_LIB int
nk_do_selectable_symbol(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, const char* str, int len,
	nk_flags align, int* value, enum nk_symbol_type sym, const struct nk_style_selectable* style,
	const struct nk_input* in, const struct nk_user_font* font) {
	int old_value;
	struct nk_rect touch;
	struct nk_rect icon;

	NK_ASSERT(state);
	NK_ASSERT(out);
	NK_ASSERT(str);
	NK_ASSERT(len);
	NK_ASSERT(value);
	NK_ASSERT(style);
	NK_ASSERT(font);

	if (!state || !out || !str || !len || !value || !style || !font) return 0;
	old_value = *value;

	/* toggle behavior */
	touch.x = bounds.x - style->touch_padding.x;
	touch.y = bounds.y - style->touch_padding.y;
	touch.w = bounds.w + style->touch_padding.x * 2;
	touch.h = bounds.h + style->touch_padding.y * 2;
	if (nk_button_behavior(state, touch, in, NK_BUTTON_DEFAULT))
		*value = !(*value);

	icon.y = bounds.y + style->padding.y;
	icon.w = icon.h = bounds.h - 2 * style->padding.y;
	if (align & NK_TEXT_ALIGN_LEFT) {
		icon.x = (bounds.x + bounds.w) - (2 * style->padding.x + icon.w);
		icon.x = NK_MAX(icon.x, 0);
	}
	else icon.x = bounds.x + 2 * style->padding.x;

	icon.x += style->image_padding.x;
	icon.y += style->image_padding.y;
	icon.w -= 2 * style->image_padding.x;
	icon.h -= 2 * style->image_padding.y;

	/* draw selectable */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_selectable(out, *state, style, *value, &bounds, &icon, 0, sym, str, len, align, font);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return old_value != *value;
}

NK_API int nk_selectable_text(struct nk_context* ctx, const char* str, int len, nk_flags align, int* value) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	const struct nk_style* style;

	enum nk_widget_layout_states state;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(value);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !value)
		return 0;

	win = ctx->current;
	layout = win->layout;
	style = &ctx->style;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_selectable(&ctx->last_widget_state, &win->buffer, bounds, str, len, align, value, &style->selectable,
		in, style->font);
}

NK_API int
nk_selectable_image_text(struct nk_context* ctx, struct nk_image img, const char* str, int len, nk_flags align,
	int* value) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	const struct nk_style* style;

	enum nk_widget_layout_states state;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(value);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !value)
		return 0;

	win = ctx->current;
	layout = win->layout;
	style = &ctx->style;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_selectable_image(&ctx->last_widget_state, &win->buffer, bounds, str, len, align, value, &img,
		&style->selectable, in, style->font);
}

NK_API int
nk_selectable_symbol_text(struct nk_context* ctx, enum nk_symbol_type sym, const char* str, int len, nk_flags align,
	int* value) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_input* in;
	const struct nk_style* style;

	enum nk_widget_layout_states state;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(value);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !value)
		return 0;

	win = ctx->current;
	layout = win->layout;
	style = &ctx->style;

	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_selectable_symbol(&ctx->last_widget_state, &win->buffer, bounds, str, len, align, value, sym,
		&style->selectable, in, style->font);
}

NK_API int
nk_selectable_symbol_label(struct nk_context* ctx, enum nk_symbol_type sym, const char* title, nk_flags align,
	int* value) {
	return nk_selectable_symbol_text(ctx, sym, title, nk_strlen(title), align, value);
}

NK_API int nk_select_text(struct nk_context* ctx, const char* str, int len, nk_flags align, int value) {
	nk_selectable_text(ctx, str, len, align, &value);
	return value;
}

NK_API int nk_selectable_label(struct nk_context* ctx, const char* str, nk_flags align, int* value) {
	return nk_selectable_text(ctx, str, nk_strlen(str), align, value);
}

NK_API int
nk_selectable_image_label(struct nk_context* ctx, struct nk_image img, const char* str, nk_flags align, int* value) {
	return nk_selectable_image_text(ctx, img, str, nk_strlen(str), align, value);
}

NK_API int nk_select_label(struct nk_context* ctx, const char* str, nk_flags align, int value) {
	nk_selectable_text(ctx, str, nk_strlen(str), align, &value);
	return value;
}

NK_API int
nk_select_image_label(struct nk_context* ctx, struct nk_image img, const char* str, nk_flags align, int value) {
	nk_selectable_image_text(ctx, img, str, nk_strlen(str), align, &value);
	return value;
}

NK_API int
nk_select_image_text(struct nk_context* ctx, struct nk_image img, const char* str, int len, nk_flags align, int value) {
	nk_selectable_image_text(ctx, img, str, len, align, &value);
	return value;
}

NK_API int
nk_select_symbol_text(struct nk_context* ctx, enum nk_symbol_type sym, const char* title, int title_len, nk_flags align,
	int value) {
	nk_selectable_symbol_text(ctx, sym, title, title_len, align, &value);
	return value;
}

NK_API int
nk_select_symbol_label(struct nk_context* ctx, enum nk_symbol_type sym, const char* title, nk_flags align, int value) {
	return nk_select_symbol_text(ctx, sym, title, nk_strlen(title), align, value);
}





/* ===============================================================
 *
 *                              SLIDER
 *
 * ===============================================================*/
NK_LIB float
nk_slider_behavior(nk_flags* state, struct nk_rect* logical_cursor, struct nk_rect* visual_cursor, struct nk_input* in,
	struct nk_rect bounds, float slider_min, float slider_max, float slider_value, float slider_step,
	float slider_steps) {
	int left_mouse_down;
	int left_mouse_click_in_cursor;

	/* check if visual cursor is being dragged */
	nk_widget_state_reset(state);
	left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;
	left_mouse_click_in_cursor =
		in && nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, *visual_cursor, nk_true);

	if (left_mouse_down && left_mouse_click_in_cursor) {
		float ratio = 0;
		const float d = in->mouse.pos.x - (visual_cursor->x + visual_cursor->w * 0.5f);
		const float pxstep = bounds.w / slider_steps;

		/* only update value if the next slider step is reached */
		*state = NK_WIDGET_STATE_ACTIVE;
		if (NK_ABS(d) >= pxstep) {
			const float steps = (float)((int)(NK_ABS(d) / pxstep));
			slider_value += (d > 0) ? (slider_step * steps) : -(slider_step * steps);
			slider_value = NK_CLAMP(slider_min, slider_value, slider_max);
			ratio = (slider_value - slider_min) / slider_step;
			logical_cursor->x = bounds.x + (logical_cursor->w * ratio);
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = logical_cursor->x;
		}
	}

	/* slider widget state */
	if (nk_input_is_mouse_hovering_rect(in, bounds))
		*state = NK_WIDGET_STATE_HOVERED;
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, bounds))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, bounds))
		*state |= NK_WIDGET_STATE_LEFT;
	return slider_value;
}

NK_LIB void nk_draw_slider(struct nk_command_buffer* out, nk_flags state, const struct nk_style_slider* style,
	const struct nk_rect* bounds, const struct nk_rect* visual_cursor, float min, float value,
	float max) {
	struct nk_rect fill;
	struct nk_rect bar;
	const struct nk_style_item* background;

	/* select correct slider images/colors */
	struct nk_color bar_color;
	const struct nk_style_item* cursor;

	NK_UNUSED(min);
	NK_UNUSED(max);
	NK_UNUSED(value);

	if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->active;
		bar_color = style->bar_active;
		cursor = &style->cursor_active;
	}
	else if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		bar_color = style->bar_hover;
		cursor = &style->cursor_hover;
	}
	else {
		background = &style->normal;
		bar_color = style->bar_normal;
		cursor = &style->cursor_normal;
	}
	/* calculate slider background bar */
	bar.x = bounds->x;
	bar.y = (visual_cursor->y + visual_cursor->h / 2) - bounds->h / 12;
	bar.w = bounds->w;
	bar.h = bounds->h / 6;

	/* filled background bar style */
	fill.w = (visual_cursor->x + (visual_cursor->w / 2.0f)) - bar.x;
	fill.x = bar.x;
	fill.y = bar.y;
	fill.h = bar.h;

	/* draw background */
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(out, *bounds, &background->data.image, nk_white);
	}
	else {
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
	}

	/* draw slider bar */
	nk_fill_rect(out, bar, style->rounding, bar_color);
	nk_fill_rect(out, fill, style->rounding, style->bar_filled);

	/* draw cursor */
	if (cursor->type == NK_STYLE_ITEM_IMAGE)
		nk_draw_image(out, *visual_cursor, &cursor->data.image, nk_white);
	else nk_fill_circle(out, *visual_cursor, cursor->data.color);
}

NK_LIB float
nk_do_slider(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, float min, float val, float max,
	float step, const struct nk_style_slider* style, struct nk_input* in, const struct nk_user_font* font) {
	float slider_range;
	float slider_min;
	float slider_max;
	float slider_value;
	float slider_steps;
	float cursor_offset;

	struct nk_rect visual_cursor;
	struct nk_rect logical_cursor;

	NK_ASSERT(style);
	NK_ASSERT(out);
	if (!out || !style)
		return 0;

	/* remove padding from slider bounds */
	bounds.x = bounds.x + style->padding.x;
	bounds.y = bounds.y + style->padding.y;
	bounds.h = NK_MAX(bounds.h, 2 * style->padding.y);
	bounds.w = NK_MAX(bounds.w, 2 * style->padding.x + style->cursor_size.x);
	bounds.w -= 2 * style->padding.x;
	bounds.h -= 2 * style->padding.y;

	/* optional buttons */
	if (style->show_buttons) {
		nk_flags ws;
		struct nk_rect button;
		button.y = bounds.y;
		button.w = bounds.h;
		button.h = bounds.h;

		/* decrement button */
		button.x = bounds.x;
		if (nk_do_button_symbol(&ws, out, button, style->dec_symbol, NK_BUTTON_DEFAULT, &style->dec_button, in, font))
			val -= step;

		/* increment button */
		button.x = (bounds.x + bounds.w) - button.w;
		if (nk_do_button_symbol(&ws, out, button, style->inc_symbol, NK_BUTTON_DEFAULT, &style->inc_button, in, font))
			val += step;

		bounds.x = bounds.x + button.w + style->spacing.x;
		bounds.w = bounds.w - (2 * button.w + 2 * style->spacing.x);
	}

	/* remove one cursor size to support visual cursor */
	bounds.x += style->cursor_size.x * 0.5f;
	bounds.w -= style->cursor_size.x;

	/* make sure the provided values are correct */
	slider_max = NK_MAX(min, max);
	slider_min = NK_MIN(min, max);
	slider_value = NK_CLAMP(slider_min, val, slider_max);
	slider_range = slider_max - slider_min;
	slider_steps = slider_range / step;
	cursor_offset = (slider_value - slider_min) / step;

	/* calculate cursor
	Basically you have two cursors. One for visual representation and interaction
	and one for updating the actual cursor value. */
	logical_cursor.h = bounds.h;
	logical_cursor.w = bounds.w / slider_steps;
	logical_cursor.x = bounds.x + (logical_cursor.w * cursor_offset);
	logical_cursor.y = bounds.y;

	visual_cursor.h = style->cursor_size.y;
	visual_cursor.w = style->cursor_size.x;
	visual_cursor.y = (bounds.y + bounds.h * 0.5f) - visual_cursor.h * 0.5f;
	visual_cursor.x = logical_cursor.x - visual_cursor.w * 0.5f;

	slider_value = nk_slider_behavior(state, &logical_cursor, &visual_cursor, in, bounds, slider_min, slider_max,
		slider_value, step, slider_steps);
	visual_cursor.x = logical_cursor.x - visual_cursor.w * 0.5f;

	/* draw slider */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_slider(out, *state, style, &bounds, &visual_cursor, slider_min, slider_value, slider_max);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return slider_value;
}

NK_API int nk_slider_float(struct nk_context* ctx, float min_value, float* value, float max_value, float value_step) {
	struct nk_window* win;
	struct nk_panel* layout;
	struct nk_input* in;
	const struct nk_style* style;

	int ret = 0;
	float old_value;
	struct nk_rect bounds;
	enum nk_widget_layout_states state;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	NK_ASSERT(value);
	if (!ctx || !ctx->current || !ctx->current->layout || !value)
		return ret;

	win = ctx->current;
	style = &ctx->style;
	layout = win->layout;

	state = nk_widget(&bounds, ctx);
	if (!state) return ret;
	in = (/*state == NK_WIDGET_ROM || */ layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;

	old_value = *value;
	*value = nk_do_slider(&ctx->last_widget_state, &win->buffer, bounds, min_value, old_value, max_value, value_step,
		&style->slider, in, style->font);
	return (old_value > * value || old_value < *value);
}

NK_API float nk_slide_float(struct nk_context* ctx, float min, float val, float max, float step) {
	nk_slider_float(ctx, min, &val, max, step);
	return val;
}

NK_API int nk_slide_int(struct nk_context* ctx, int min, int val, int max, int step) {
	float value = (float)val;
	nk_slider_float(ctx, (float)min, &value, (float)max, (float)step);
	return (int)value;
}

NK_API int nk_slider_int(struct nk_context* ctx, int min, int* val, int max, int step) {
	int ret;
	float value = (float)*val;
	ret = nk_slider_float(ctx, (float)min, &value, (float)max, (float)step);
	*val = (int)value;
	return ret;
}





/* ===============================================================
 *
 *                          PROGRESS
 *
 * ===============================================================*/
NK_LIB nk_size
nk_progress_behavior(nk_flags* state, struct nk_input* in, struct nk_rect r, struct nk_rect cursor, nk_size max,
	nk_size value, int modifiable) {
	int left_mouse_down = 0;
	int left_mouse_click_in_cursor = 0;

	nk_widget_state_reset(state);
	if (!in || !modifiable) return value;
	left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;
	left_mouse_click_in_cursor = in && nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, cursor, nk_true);
	if (nk_input_is_mouse_hovering_rect(in, r))
		*state = NK_WIDGET_STATE_HOVERED;

	if (in && left_mouse_down && left_mouse_click_in_cursor) {
		if (left_mouse_down && left_mouse_click_in_cursor) {
			float ratio = NK_MAX(0, (float)(in->mouse.pos.x - cursor.x)) / (float)cursor.w;
			value = (nk_size)NK_CLAMP(0, (float)max * ratio, (float)max);
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = cursor.x + cursor.w / 2.0f;
			*state |= NK_WIDGET_STATE_ACTIVE;
		}
	}
	/* set progressbar widget state */
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, r))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, r))
		*state |= NK_WIDGET_STATE_LEFT;
	return value;
}

NK_LIB void nk_draw_progress(struct nk_command_buffer* out, nk_flags state, const struct nk_style_progress* style,
	const struct nk_rect* bounds, const struct nk_rect* scursor, nk_size value, nk_size max) {
	const struct nk_style_item* background;
	const struct nk_style_item* cursor;

	NK_UNUSED(max);
	NK_UNUSED(value);

	/* select correct colors/images to draw */
	if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->active;
		cursor = &style->cursor_active;
	}
	else if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		cursor = &style->cursor_hover;
	}
	else {
		background = &style->normal;
		cursor = &style->cursor_normal;
	}

	/* draw background */
	if (background->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
	}
	else nk_draw_image(out, *bounds, &background->data.image, nk_white);

	/* draw cursor */
	if (cursor->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_rect(out, *scursor, style->rounding, cursor->data.color);
		nk_stroke_rect(out, *scursor, style->rounding, style->border, style->border_color);
	}
	else nk_draw_image(out, *scursor, &cursor->data.image, nk_white);
}

NK_LIB nk_size
nk_do_progress(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, nk_size value, nk_size max,
	int modifiable, const struct nk_style_progress* style, struct nk_input* in) {
	float prog_scale;
	nk_size prog_value;
	struct nk_rect cursor;

	NK_ASSERT(style);
	NK_ASSERT(out);
	if (!out || !style) return 0;

	/* calculate progressbar cursor */
	cursor.w = NK_MAX(bounds.w, 2 * style->padding.x + 2 * style->border);
	cursor.h = NK_MAX(bounds.h, 2 * style->padding.y + 2 * style->border);
	cursor = nk_pad_rect(bounds, nk_vec2(style->padding.x + style->border, style->padding.y + style->border));
	prog_scale = (float)value / (float)max;

	/* update progressbar */
	prog_value = NK_MIN(value, max);
	prog_value = nk_progress_behavior(state, in, bounds, cursor, max, prog_value, modifiable);
	cursor.w = cursor.w * prog_scale;

	/* draw progressbar */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_progress(out, *state, style, &bounds, &cursor, value, max);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return prog_value;
}

NK_API int nk_progress(struct nk_context* ctx, nk_size* cur, nk_size max, int is_modifyable) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_style* style;
	struct nk_input* in;

	struct nk_rect bounds;
	enum nk_widget_layout_states state;
	nk_size old_value;

	NK_ASSERT(ctx);
	NK_ASSERT(cur);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !cur)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	layout = win->layout;
	state = nk_widget(&bounds, ctx);
	if (!state) return 0;

	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	old_value = *cur;
	*cur = nk_do_progress(&ctx->last_widget_state, &win->buffer, bounds, *cur, max, is_modifyable, &style->progress,
		in);
	return (*cur != old_value);
}

NK_API nk_size nk_prog(struct nk_context* ctx, nk_size cur, nk_size max, int modifyable) {
	nk_progress(ctx, &cur, max, modifyable);
	return cur;
}





/* ===============================================================
 *
 *                              SCROLLBAR
 *
 * ===============================================================*/
NK_LIB float
nk_scrollbar_behavior(nk_flags* state, struct nk_input* in, int has_scrolling, const struct nk_rect* scroll,
	const struct nk_rect* cursor, const struct nk_rect* empty0, const struct nk_rect* empty1,
	float scroll_offset, float target, float scroll_step, enum nk_orientation o) {
	nk_flags ws = 0;
	int left_mouse_down;
	int left_mouse_clicked;
	int left_mouse_click_in_cursor;
	float scroll_delta;

	nk_widget_state_reset(state);
	if (!in) return scroll_offset;

	left_mouse_down = in->mouse.buttons[NK_BUTTON_LEFT].down;
	left_mouse_clicked = in->mouse.buttons[NK_BUTTON_LEFT].clicked;
	left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, *cursor, nk_true);
	if (nk_input_is_mouse_hovering_rect(in, *scroll))
		*state = NK_WIDGET_STATE_HOVERED;

	scroll_delta = (o == NK_VERTICAL) ? in->mouse.scroll_delta.y : in->mouse.scroll_delta.x;
	if (left_mouse_down && left_mouse_click_in_cursor && !left_mouse_clicked) {
		/* update cursor by mouse dragging */
		float pixel, delta;
		*state = NK_WIDGET_STATE_ACTIVE;
		if (o == NK_VERTICAL) {
			float cursor_y;
			pixel = in->mouse.delta.y;
			delta = (pixel / scroll->h) * target;
			scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->h);
			cursor_y = scroll->y + ((scroll_offset / target) * scroll->h);
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.y = cursor_y + cursor->h / 2.0f;
		}
		else {
			float cursor_x;
			pixel = in->mouse.delta.x;
			delta = (pixel / scroll->w) * target;
			scroll_offset = NK_CLAMP(0, scroll_offset + delta, target - scroll->w);
			cursor_x = scroll->x + ((scroll_offset / target) * scroll->w);
			in->mouse.buttons[NK_BUTTON_LEFT].clicked_pos.x = cursor_x + cursor->w / 2.0f;
		}
	}
	else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_UP) && o == NK_VERTICAL && has_scrolling) ||
		nk_button_behavior(&ws, *empty0, in, NK_BUTTON_DEFAULT)) {
		/* scroll page up by click on empty space or shortcut */
		if (o == NK_VERTICAL)
			scroll_offset = NK_MAX(0, scroll_offset - scroll->h);
		else scroll_offset = NK_MAX(0, scroll_offset - scroll->w);
	}
	else if ((nk_input_is_key_pressed(in, NK_KEY_SCROLL_DOWN) && o == NK_VERTICAL && has_scrolling) ||
		nk_button_behavior(&ws, *empty1, in, NK_BUTTON_DEFAULT)) {
		/* scroll page down by click on empty space or shortcut */
		if (o == NK_VERTICAL)
			scroll_offset = NK_MIN(scroll_offset + scroll->h, target - scroll->h);
		else scroll_offset = NK_MIN(scroll_offset + scroll->w, target - scroll->w);
	}
	else if (has_scrolling) {
		if ((scroll_delta < 0 || (scroll_delta > 0))) {
			/* update cursor by mouse scrolling */
			scroll_offset = scroll_offset + scroll_step * (-scroll_delta);
			if (o == NK_VERTICAL)
				scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->h);
			else scroll_offset = NK_CLAMP(0, scroll_offset, target - scroll->w);
		}
		else if (nk_input_is_key_pressed(in, NK_KEY_SCROLL_START)) {
			/* update cursor to the beginning  */
			if (o == NK_VERTICAL) scroll_offset = 0;
		}
		else if (nk_input_is_key_pressed(in, NK_KEY_SCROLL_END)) {
			/* update cursor to the end */
			if (o == NK_VERTICAL) scroll_offset = target - scroll->h;
		}
	}
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, *scroll))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, *scroll))
		*state |= NK_WIDGET_STATE_LEFT;
	return scroll_offset;
}

NK_LIB void nk_draw_scrollbar(struct nk_command_buffer* out, nk_flags state, const struct nk_style_scrollbar* style,
	const struct nk_rect* bounds, const struct nk_rect* scroll) {
	const struct nk_style_item* background;
	const struct nk_style_item* cursor;

	/* select correct colors/images to draw */
	if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->active;
		cursor = &style->cursor_active;
	}
	else if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		cursor = &style->cursor_hover;
	}
	else {
		background = &style->normal;
		cursor = &style->cursor_normal;
	}

	/* draw background */
	if (background->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		nk_stroke_rect(out, *bounds, style->rounding, style->border, style->border_color);
	}
	else {
		nk_draw_image(out, *bounds, &background->data.image, nk_white);
	}

	/* draw cursor */
	if (cursor->type == NK_STYLE_ITEM_COLOR) {
		nk_fill_rect(out, *scroll, style->rounding_cursor, cursor->data.color);
		nk_stroke_rect(out, *scroll, style->rounding_cursor, style->border_cursor, style->cursor_border_color);
	}
	else nk_draw_image(out, *scroll, &cursor->data.image, nk_white);
}

NK_LIB float
nk_do_scrollbarv(nk_flags* state, struct nk_command_buffer* out, struct nk_rect scroll, int has_scrolling, float offset,
	float target, float step, float button_pixel_inc, const struct nk_style_scrollbar* style,
	struct nk_input* in, const struct nk_user_font* font) {
	struct nk_rect empty_north;
	struct nk_rect empty_south;
	struct nk_rect cursor;

	float scroll_step;
	float scroll_offset;
	float scroll_off;
	float scroll_ratio;

	NK_ASSERT(out);
	NK_ASSERT(style);
	NK_ASSERT(state);
	if (!out || !style) return 0;

	scroll.w = NK_MAX(scroll.w, 1);
	scroll.h = NK_MAX(scroll.h, 0);
	if (target <= scroll.h) return 0;

	/* optional scrollbar buttons */
	if (style->show_buttons) {
		nk_flags ws;
		float scroll_h;
		struct nk_rect button;

		button.x = scroll.x;
		button.w = scroll.w;
		button.h = scroll.w;

		scroll_h = NK_MAX(scroll.h - 2 * button.h, 0);
		scroll_step = NK_MIN(step, button_pixel_inc);

		/* decrement button */
		button.y = scroll.y;
		if (nk_do_button_symbol(&ws, out, button, style->dec_symbol, NK_BUTTON_REPEATER, &style->dec_button, in, font))
			offset = offset - scroll_step;

		/* increment button */
		button.y = scroll.y + scroll.h - button.h;
		if (nk_do_button_symbol(&ws, out, button, style->inc_symbol, NK_BUTTON_REPEATER, &style->inc_button, in, font))
			offset = offset + scroll_step;

		scroll.y = scroll.y + button.h;
		scroll.h = scroll_h;
	}

	/* calculate scrollbar constants */
	scroll_step = NK_MIN(step, scroll.h);
	scroll_offset = NK_CLAMP(0, offset, target - scroll.h);
	scroll_ratio = scroll.h / target;
	scroll_off = scroll_offset / target;

	/* calculate scrollbar cursor bounds */
	cursor.h = NK_MAX((scroll_ratio * scroll.h) - (2 * style->border + 2 * style->padding.y), 0);
	cursor.y = scroll.y + (scroll_off * scroll.h) + style->border + style->padding.y;
	cursor.w = scroll.w - (2 * style->border + 2 * style->padding.x);
	cursor.x = scroll.x + style->border + style->padding.x;

	/* calculate empty space around cursor */
	empty_north.x = scroll.x;
	empty_north.y = scroll.y;
	empty_north.w = scroll.w;
	empty_north.h = NK_MAX(cursor.y - scroll.y, 0);

	empty_south.x = scroll.x;
	empty_south.y = cursor.y + cursor.h;
	empty_south.w = scroll.w;
	empty_south.h = NK_MAX((scroll.y + scroll.h) - (cursor.y + cursor.h), 0);

	/* update scrollbar */
	scroll_offset = nk_scrollbar_behavior(state, in, has_scrolling, &scroll, &cursor, &empty_north, &empty_south,
		scroll_offset, target, scroll_step, NK_VERTICAL);
	scroll_off = scroll_offset / target;
	cursor.y = scroll.y + (scroll_off * scroll.h) + style->border_cursor + style->padding.y;

	/* draw scrollbar */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_scrollbar(out, *state, style, &scroll, &cursor);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return scroll_offset;
}

NK_LIB float
nk_do_scrollbarh(nk_flags* state, struct nk_command_buffer* out, struct nk_rect scroll, int has_scrolling, float offset,
	float target, float step, float button_pixel_inc, const struct nk_style_scrollbar* style,
	struct nk_input* in, const struct nk_user_font* font) {
	struct nk_rect cursor;
	struct nk_rect empty_west;
	struct nk_rect empty_east;

	float scroll_step;
	float scroll_offset;
	float scroll_off;
	float scroll_ratio;

	NK_ASSERT(out);
	NK_ASSERT(style);
	if (!out || !style) return 0;

	/* scrollbar background */
	scroll.h = NK_MAX(scroll.h, 1);
	scroll.w = NK_MAX(scroll.w, 2 * scroll.h);
	if (target <= scroll.w) return 0;

	/* optional scrollbar buttons */
	if (style->show_buttons) {
		nk_flags ws;
		float scroll_w;
		struct nk_rect button;
		button.y = scroll.y;
		button.w = scroll.h;
		button.h = scroll.h;

		scroll_w = scroll.w - 2 * button.w;
		scroll_step = NK_MIN(step, button_pixel_inc);

		/* decrement button */
		button.x = scroll.x;
		if (nk_do_button_symbol(&ws, out, button, style->dec_symbol, NK_BUTTON_REPEATER, &style->dec_button, in, font))
			offset = offset - scroll_step;

		/* increment button */
		button.x = scroll.x + scroll.w - button.w;
		if (nk_do_button_symbol(&ws, out, button, style->inc_symbol, NK_BUTTON_REPEATER, &style->inc_button, in, font))
			offset = offset + scroll_step;

		scroll.x = scroll.x + button.w;
		scroll.w = scroll_w;
	}

	/* calculate scrollbar constants */
	scroll_step = NK_MIN(step, scroll.w);
	scroll_offset = NK_CLAMP(0, offset, target - scroll.w);
	scroll_ratio = scroll.w / target;
	scroll_off = scroll_offset / target;

	/* calculate cursor bounds */
	cursor.w = (scroll_ratio * scroll.w) - (2 * style->border + 2 * style->padding.x);
	cursor.x = scroll.x + (scroll_off * scroll.w) + style->border + style->padding.x;
	cursor.h = scroll.h - (2 * style->border + 2 * style->padding.y);
	cursor.y = scroll.y + style->border + style->padding.y;

	/* calculate empty space around cursor */
	empty_west.x = scroll.x;
	empty_west.y = scroll.y;
	empty_west.w = cursor.x - scroll.x;
	empty_west.h = scroll.h;

	empty_east.x = cursor.x + cursor.w;
	empty_east.y = scroll.y;
	empty_east.w = (scroll.x + scroll.w) - (cursor.x + cursor.w);
	empty_east.h = scroll.h;

	/* update scrollbar */
	scroll_offset = nk_scrollbar_behavior(state, in, has_scrolling, &scroll, &cursor, &empty_west, &empty_east,
		scroll_offset, target, scroll_step, NK_HORIZONTAL);
	scroll_off = scroll_offset / target;
	cursor.x = scroll.x + (scroll_off * scroll.w);

	/* draw scrollbar */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_scrollbar(out, *state, style, &scroll, &cursor);
	if (style->draw_end) style->draw_end(out, style->userdata);
	return scroll_offset;
}





/* ===============================================================
 *
 *                          TEXT EDITOR
 *
 * ===============================================================*/
 /* stb_textedit.h - v1.8  - public domain - Sean Barrett */
struct nk_text_find {
	float x, y;    /* position of n'th character */
	float height; /* height of line */
	int first_char, length; /* first char of row, and length */
	int prev_first;  /*_ first char of previous row */
};

struct nk_text_edit_row {
	float x0, x1;
	/* starting x location, end x location (allows for align=right, etc) */
	float baseline_y_delta;
	/* position of baseline relative to previous row's baseline*/
	float ymin, ymax;
	/* height of row above and below baseline */
	int num_chars;
};

/* forward declarations */
NK_INTERN void nk_textedit_makeundo_delete(struct nk_text_edit*, int, int);

NK_INTERN void nk_textedit_makeundo_insert(struct nk_text_edit*, int, int);

NK_INTERN void nk_textedit_makeundo_replace(struct nk_text_edit*, int, int, int);

#define NK_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)

NK_INTERN float
nk_textedit_get_width(const struct nk_text_edit* edit, int line_start, int char_id, const struct nk_user_font* font) {
	int len = 0;
	nk_rune unicode = 0;
	const char* str = nk_str_at_const(&edit->string, line_start + char_id, &unicode, &len);
	return font->width(font->userdata, font->height, str, len);
}

NK_INTERN void
nk_textedit_layout_row(struct nk_text_edit_row* r, struct nk_text_edit* edit, int line_start_id, float row_height,
	const struct nk_user_font* font) {
	int l;
	int glyphs = 0;
	nk_rune unicode;
	const char* remaining;
	int len = nk_str_len_char(&edit->string);
	const char* end = nk_str_get_const(&edit->string) + len;
	const char* text = nk_str_at_const(&edit->string, line_start_id, &unicode, &l);
	const struct nk_vec2 size = nk_text_calculate_text_bounds(font, text, (int)(end - text), row_height, &remaining, 0,
		&glyphs, NK_STOP_ON_NEW_LINE);

	r->x0 = 0.0f;
	r->x1 = size.x;
	r->baseline_y_delta = size.y;
	r->ymin = 0.0f;
	r->ymax = size.y;
	r->num_chars = glyphs;
}

NK_INTERN int nk_textedit_locate_coord(struct nk_text_edit* edit, float x, float y, const struct nk_user_font* font,
	float row_height) {
	struct nk_text_edit_row r;
	int n = edit->string.len;
	float base_y = 0, prev_x;
	int i = 0, k;

	r.x0 = r.x1 = 0;
	r.ymin = r.ymax = 0;
	r.num_chars = 0;

	/* search rows to find one that straddles 'y' */
	while (i < n) {
		nk_textedit_layout_row(&r, edit, i, row_height, font);
		if (r.num_chars <= 0)
			return n;

		if (i == 0 && y < base_y + r.ymin)
			return 0;

		if (y < base_y + r.ymax)
			break;

		i += r.num_chars;
		base_y += r.baseline_y_delta;
	}

	/* below all text, return 'after' last character */
	if (i >= n)
		return n;

	/* check if it's before the beginning of the line */
	if (x < r.x0)
		return i;

	/* check if it's before the end of the line */
	if (x < r.x1) {
		/* search characters in row for one that straddles 'x' */
		k = i;
		prev_x = r.x0;
		for (i = 0; i < r.num_chars; ++i) {
			float w = nk_textedit_get_width(edit, k, i, font);
			if (x < prev_x + w) {
				if (x < prev_x + w / 2)
					return k + i;
				else return k + i + 1;
			}
			prev_x += w;
		}
		/* shouldn't happen, but if it does, fall through to end-of-line case */
	}

	/* if the last character is a newline, return that.
	 * otherwise return 'after' the last character */
	if (nk_str_rune_at(&edit->string, i + r.num_chars - 1) == '\n')
		return i + r.num_chars - 1;
	else return i + r.num_chars;
}

NK_LIB void
nk_textedit_click(struct nk_text_edit* state, float x, float y, const struct nk_user_font* font, float row_height) {
	/* API click: on mouse down, move the cursor to the clicked location,
	 * and reset the selection */
	state->cursor = nk_textedit_locate_coord(state, x, y, font, row_height);
	state->select_start = state->cursor;
	state->select_end = state->cursor;
	state->has_preferred_x = 0;
}

NK_LIB void
nk_textedit_drag(struct nk_text_edit* state, float x, float y, const struct nk_user_font* font, float row_height) {
	/* API drag: on mouse drag, move the cursor and selection endpoint
	 * to the clicked location */
	int p = nk_textedit_locate_coord(state, x, y, font, row_height);
	if (state->select_start == state->select_end)
		state->select_start = state->cursor;
	state->cursor = state->select_end = p;
}

NK_INTERN void nk_textedit_find_charpos(struct nk_text_find* find, struct nk_text_edit* state, int n, int single_line,
	const struct nk_user_font* font, float row_height) {
	/* find the x/y location of a character, and remember info about the previous
	 * row in case we get a move-up event (for page up, we'll have to rescan) */
	struct nk_text_edit_row r;
	int prev_start = 0;
	int z = state->string.len;
	int i = 0, first;

	nk_zero_struct(r);
	if (n == z) {
		/* if it's at the end, then find the last line -- simpler than trying to
		explicitly handle this case in the regular code */
		nk_textedit_layout_row(&r, state, 0, row_height, font);
		if (single_line) {
			find->first_char = 0;
			find->length = z;
		}
		else {
			while (i < z) {
				prev_start = i;
				i += r.num_chars;
				nk_textedit_layout_row(&r, state, i, row_height, font);
			}

			find->first_char = i;
			find->length = r.num_chars;
		}
		find->x = r.x1;
		find->y = r.ymin;
		find->height = r.ymax - r.ymin;
		find->prev_first = prev_start;
		return;
	}

	/* search rows to find the one that straddles character n */
	find->y = 0;

	for (;;) {
		nk_textedit_layout_row(&r, state, i, row_height, font);
		if (n < i + r.num_chars) break;
		prev_start = i;
		i += r.num_chars;
		find->y += r.baseline_y_delta;
	}

	find->first_char = first = i;
	find->length = r.num_chars;
	find->height = r.ymax - r.ymin;
	find->prev_first = prev_start;

	/* now scan to find xpos */
	find->x = r.x0;
	for (i = 0; first + i < n; ++i)
		find->x += nk_textedit_get_width(state, first, i, font);
}

NK_INTERN void nk_textedit_clamp(struct nk_text_edit* state) {
	/* make the selection/cursor state valid if client altered the string */
	int n = state->string.len;
	if (NK_TEXT_HAS_SELECTION(state)) {
		if (state->select_start > n) state->select_start = n;
		if (state->select_end > n) state->select_end = n;
		/* if clamping forced them to be equal, move the cursor to match */
		if (state->select_start == state->select_end)
			state->cursor = state->select_start;
	}
	if (state->cursor > n) state->cursor = n;
}

NK_API void nk_textedit_delete(struct nk_text_edit* state, int where, int len) {
	/* delete characters while updating undo */
	nk_textedit_makeundo_delete(state, where, len);
	nk_str_delete_runes(&state->string, where, len);
	state->has_preferred_x = 0;
}

NK_API void nk_textedit_delete_selection(struct nk_text_edit* state) {
	/* delete the section */
	nk_textedit_clamp(state);
	if (NK_TEXT_HAS_SELECTION(state)) {
		if (state->select_start < state->select_end) {
			nk_textedit_delete(state, state->select_start, state->select_end - state->select_start);
			state->select_end = state->cursor = state->select_start;
		}
		else {
			nk_textedit_delete(state, state->select_end, state->select_start - state->select_end);
			state->select_start = state->cursor = state->select_end;
		}
		state->has_preferred_x = 0;
	}
}

NK_INTERN void nk_textedit_sortselection(struct nk_text_edit* state) {
	/* canonicalize the selection so start <= end */
	if (state->select_end < state->select_start) {
		int temp = state->select_end;
		state->select_end = state->select_start;
		state->select_start = temp;
	}
}

NK_INTERN void nk_textedit_move_to_first(struct nk_text_edit* state) {
	/* move cursor to first character of selection */
	if (NK_TEXT_HAS_SELECTION(state)) {
		nk_textedit_sortselection(state);
		state->cursor = state->select_start;
		state->select_end = state->select_start;
		state->has_preferred_x = 0;
	}
}

NK_INTERN void nk_textedit_move_to_last(struct nk_text_edit* state) {
	/* move cursor to last character of selection */
	if (NK_TEXT_HAS_SELECTION(state)) {
		nk_textedit_sortselection(state);
		nk_textedit_clamp(state);
		state->cursor = state->select_end;
		state->select_start = state->select_end;
		state->has_preferred_x = 0;
	}
}

NK_INTERN int nk_is_word_boundary(struct nk_text_edit* state, int idx) {
	int len;
	nk_rune c;
	if (idx <= 0) return 1;
	if (!nk_str_at_rune(&state->string, idx, &c, &len)) return 1;
	return (c == ' ' || c == '\t' || c == 0x3000 || c == ',' || c == ';' || c == '(' || c == ')' || c == '{' ||
		c == '}' || c == '[' || c == ']' || c == '|');
}

NK_INTERN int nk_textedit_move_to_word_previous(struct nk_text_edit* state) {
	int c = state->cursor - 1;
	while (c >= 0 && !nk_is_word_boundary(state, c))
		--c;

	if (c < 0)
		c = 0;

	return c;
}

NK_INTERN int nk_textedit_move_to_word_next(struct nk_text_edit* state) {
	const int len = state->string.len;
	int c = state->cursor + 1;
	while (c < len && !nk_is_word_boundary(state, c))
		++c;

	if (c > len)
		c = len;

	return c;
}

NK_INTERN void nk_textedit_prep_selection_at_cursor(struct nk_text_edit* state) {
	/* update selection and cursor to match each other */
	if (!NK_TEXT_HAS_SELECTION(state))
		state->select_start = state->select_end = state->cursor;
	else state->cursor = state->select_end;
}

NK_API int nk_textedit_cut(struct nk_text_edit* state) {
	/* API cut: delete selection */
	if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
		return 0;
	if (NK_TEXT_HAS_SELECTION(state)) {
		nk_textedit_delete_selection(state); /* implicitly clamps */
		state->has_preferred_x = 0;
		return 1;
	}
	return 0;
}

NK_API int nk_textedit_paste(struct nk_text_edit* state, char const* ctext, int len) {
	/* API paste: replace existing selection with passed-in text */
	int glyphs;
	const char* text = (const char*)ctext;
	if (state->mode == NK_TEXT_EDIT_MODE_VIEW) return 0;

	/* if there's a selection, the paste should delete it */
	nk_textedit_clamp(state);
	nk_textedit_delete_selection(state);

	/* try to insert the characters */
	glyphs = nk_utf_len(ctext, len);
	if (nk_str_insert_text_char(&state->string, state->cursor, text, len)) {
		nk_textedit_makeundo_insert(state, state->cursor, glyphs);
		state->cursor += len;
		state->has_preferred_x = 0;
		return 1;
	}
	/* remove the undo since we didn't actually insert the characters */
	if (state->undo.undo_point)
		--state->undo.undo_point;
	return 0;
}

NK_API void nk_textedit_text(struct nk_text_edit* state, const char* text, int total_len) {
	nk_rune unicode;
	int glyph_len;
	int text_len = 0;

	NK_ASSERT(state);
	NK_ASSERT(text);
	if (!text || !total_len || state->mode == NK_TEXT_EDIT_MODE_VIEW) return;

	glyph_len = nk_utf_decode(text, &unicode, total_len);
	while ((text_len < total_len) && glyph_len) {
		/* don't insert a backward delete, just process the event */
		if (unicode == 127) goto next;
		/* can't add newline in single-line mode */
		if (unicode == '\n' && state->single_line) goto next;
		/* filter incoming text */
		if (state->filter && !state->filter(state, unicode)) goto next;

		if (!NK_TEXT_HAS_SELECTION(state) && state->cursor < state->string.len) {
			if (state->mode == NK_TEXT_EDIT_MODE_REPLACE) {
				nk_textedit_makeundo_replace(state, state->cursor, 1, 1);
				nk_str_delete_runes(&state->string, state->cursor, 1);
			}
			if (nk_str_insert_text_utf8(&state->string, state->cursor, text + text_len, 1)) {
				++state->cursor;
				state->has_preferred_x = 0;
			}
		}
		else {
			nk_textedit_delete_selection(state); /* implicitly clamps */
			if (nk_str_insert_text_utf8(&state->string, state->cursor, text + text_len, 1)) {
				nk_textedit_makeundo_insert(state, state->cursor, 1);
				++state->cursor;
				state->has_preferred_x = 0;
			}
		}
	next:
		text_len += glyph_len;
		glyph_len = nk_utf_decode(text + text_len, &unicode, total_len - text_len);
	}
}

NK_LIB void
nk_textedit_key(struct nk_text_edit* state, enum nk_keys key, int shift_mod, const struct nk_user_font* font,
	float row_height) {
retry:
	switch (key) {
	case NK_KEY_NONE:
	case NK_KEY_CTRL:
	case NK_KEY_ENTER:
	case NK_KEY_SHIFT:
	case NK_KEY_TAB:
	case NK_KEY_COPY:
	case NK_KEY_CUT:
	case NK_KEY_PASTE:
	case NK_KEY_MAX:
	default:
		break;
	case NK_KEY_TEXT_UNDO:
		nk_textedit_undo(state);
		state->has_preferred_x = 0;
		break;

	case NK_KEY_TEXT_REDO:
		nk_textedit_redo(state);
		state->has_preferred_x = 0;
		break;

	case NK_KEY_TEXT_SELECT_ALL:
		nk_textedit_select_all(state);
		state->has_preferred_x = 0;
		break;

	case NK_KEY_TEXT_INSERT_MODE:
		if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
			state->mode = NK_TEXT_EDIT_MODE_INSERT;
		break;
	case NK_KEY_TEXT_REPLACE_MODE:
		if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
			state->mode = NK_TEXT_EDIT_MODE_REPLACE;
		break;
	case NK_KEY_TEXT_RESET_MODE:
		if (state->mode == NK_TEXT_EDIT_MODE_INSERT || state->mode == NK_TEXT_EDIT_MODE_REPLACE)
			state->mode = NK_TEXT_EDIT_MODE_VIEW;
		break;

	case NK_KEY_LEFT:
		if (shift_mod) {
			nk_textedit_clamp(state);
			nk_textedit_prep_selection_at_cursor(state);
			/* move selection left */
			if (state->select_end > 0)
				--state->select_end;
			state->cursor = state->select_end;
			state->has_preferred_x = 0;
		}
		else {
			/* if currently there's a selection,
		 * move cursor to start of selection */
			if (NK_TEXT_HAS_SELECTION(state))
				nk_textedit_move_to_first(state);
			else if (state->cursor > 0)
				--state->cursor;
			state->has_preferred_x = 0;
		}
		break;

	case NK_KEY_RIGHT:
		if (shift_mod) {
			nk_textedit_prep_selection_at_cursor(state);
			/* move selection right */
			++state->select_end;
			nk_textedit_clamp(state);
			state->cursor = state->select_end;
			state->has_preferred_x = 0;
		}
		else {
			/* if currently there's a selection,
		 * move cursor to end of selection */
			if (NK_TEXT_HAS_SELECTION(state))
				nk_textedit_move_to_last(state);
			else ++state->cursor;
			nk_textedit_clamp(state);
			state->has_preferred_x = 0;
		}
		break;

	case NK_KEY_TEXT_WORD_LEFT:
		if (shift_mod) {
			if (!NK_TEXT_HAS_SELECTION(state))
				nk_textedit_prep_selection_at_cursor(state);
			state->cursor = nk_textedit_move_to_word_previous(state);
			state->select_end = state->cursor;
			nk_textedit_clamp(state);
		}
		else {
			if (NK_TEXT_HAS_SELECTION(state))
				nk_textedit_move_to_first(state);
			else {
				state->cursor = nk_textedit_move_to_word_previous(state);
				nk_textedit_clamp(state);
			}
		}
		break;

	case NK_KEY_TEXT_WORD_RIGHT:
		if (shift_mod) {
			if (!NK_TEXT_HAS_SELECTION(state))
				nk_textedit_prep_selection_at_cursor(state);
			state->cursor = nk_textedit_move_to_word_next(state);
			state->select_end = state->cursor;
			nk_textedit_clamp(state);
		}
		else {
			if (NK_TEXT_HAS_SELECTION(state))
				nk_textedit_move_to_last(state);
			else {
				state->cursor = nk_textedit_move_to_word_next(state);
				nk_textedit_clamp(state);
			}
		}
		break;

	case NK_KEY_DOWN: {
		struct nk_text_find find;
		struct nk_text_edit_row row;
		int i, sel = shift_mod;

		if (state->single_line) {
			/* on windows, up&down in single-line behave like left&right */
			key = NK_KEY_RIGHT;
			goto retry;
		}

		if (sel)
			nk_textedit_prep_selection_at_cursor(state);
		else if (NK_TEXT_HAS_SELECTION(state))
			nk_textedit_move_to_last(state);

		/* compute current position of cursor point */
		nk_textedit_clamp(state);
		nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);

		/* now find character position down a row */
		if (find.length) {
			float x;
			float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
			int start = find.first_char + find.length;

			state->cursor = start;
			nk_textedit_layout_row(&row, state, state->cursor, row_height, font);
			x = row.x0;

			for (i = 0; i < row.num_chars && x < row.x1; ++i) {
				float dx = nk_textedit_get_width(state, start, i, font);
				x += dx;
				if (x > goal_x)
					break;
				++state->cursor;
			}
			nk_textedit_clamp(state);

			state->has_preferred_x = 1;
			state->preferred_x = goal_x;
			if (sel)
				state->select_end = state->cursor;
		}
	}
					break;

	case NK_KEY_UP: {
		struct nk_text_find find;
		struct nk_text_edit_row row;
		int i, sel = shift_mod;

		if (state->single_line) {
			/* on windows, up&down become left&right */
			key = NK_KEY_LEFT;
			goto retry;
		}

		if (sel)
			nk_textedit_prep_selection_at_cursor(state);
		else if (NK_TEXT_HAS_SELECTION(state))
			nk_textedit_move_to_first(state);

		/* compute current position of cursor point */
		nk_textedit_clamp(state);
		nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);

		/* can only go up if there's a previous row */
		if (find.prev_first != find.first_char) {
			/* now find character position up a row */
			float x;
			float goal_x = state->has_preferred_x ? state->preferred_x : find.x;

			state->cursor = find.prev_first;
			nk_textedit_layout_row(&row, state, state->cursor, row_height, font);
			x = row.x0;

			for (i = 0; i < row.num_chars && x < row.x1; ++i) {
				float dx = nk_textedit_get_width(state, find.prev_first, i, font);
				x += dx;
				if (x > goal_x)
					break;
				++state->cursor;
			}
			nk_textedit_clamp(state);

			state->has_preferred_x = 1;
			state->preferred_x = goal_x;
			if (sel) state->select_end = state->cursor;
		}
	}
				  break;

	case NK_KEY_DEL:
		if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
			break;
		if (NK_TEXT_HAS_SELECTION(state))
			nk_textedit_delete_selection(state);
		else {
			int n = state->string.len;
			if (state->cursor < n)
				nk_textedit_delete(state, state->cursor, 1);
		}
		state->has_preferred_x = 0;
		break;

	case NK_KEY_BACKSPACE:
		if (state->mode == NK_TEXT_EDIT_MODE_VIEW)
			break;
		if (NK_TEXT_HAS_SELECTION(state))
			nk_textedit_delete_selection(state);
		else {
			nk_textedit_clamp(state);
			if (state->cursor > 0) {
				nk_textedit_delete(state, state->cursor - 1, 1);
				--state->cursor;
			}
		}
		state->has_preferred_x = 0;
		break;

	case NK_KEY_TEXT_START:
		if (shift_mod) {
			nk_textedit_prep_selection_at_cursor(state);
			state->cursor = state->select_end = 0;
			state->has_preferred_x = 0;
		}
		else {
			state->cursor = state->select_start = state->select_end = 0;
			state->has_preferred_x = 0;
		}
		break;

	case NK_KEY_TEXT_END:
		if (shift_mod) {
			nk_textedit_prep_selection_at_cursor(state);
			state->cursor = state->select_end = state->string.len;
			state->has_preferred_x = 0;
		}
		else {
			state->cursor = state->string.len;
			state->select_start = state->select_end = 0;
			state->has_preferred_x = 0;
		}
		break;

	case NK_KEY_TEXT_LINE_START: {
		if (shift_mod) {
			struct nk_text_find find;
			nk_textedit_clamp(state);
			nk_textedit_prep_selection_at_cursor(state);
			if (state->string.len && state->cursor == state->string.len)
				--state->cursor;
			nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);
			state->cursor = state->select_end = find.first_char;
			state->has_preferred_x = 0;
		}
		else {
			struct nk_text_find find;
			if (state->string.len && state->cursor == state->string.len)
				--state->cursor;
			nk_textedit_clamp(state);
			nk_textedit_move_to_first(state);
			nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);
			state->cursor = find.first_char;
			state->has_preferred_x = 0;
		}
	}
							   break;

	case NK_KEY_TEXT_LINE_END: {
		if (shift_mod) {
			struct nk_text_find find;
			nk_textedit_clamp(state);
			nk_textedit_prep_selection_at_cursor(state);
			nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);
			state->has_preferred_x = 0;
			state->cursor = find.first_char + find.length;
			if (find.length > 0 && nk_str_rune_at(&state->string, state->cursor - 1) == '\n')
				--state->cursor;
			state->select_end = state->cursor;
		}
		else {
			struct nk_text_find find;
			nk_textedit_clamp(state);
			nk_textedit_move_to_first(state);
			nk_textedit_find_charpos(&find, state, state->cursor, state->single_line, font, row_height);

			state->has_preferred_x = 0;
			state->cursor = find.first_char + find.length;
			if (find.length > 0 && nk_str_rune_at(&state->string, state->cursor - 1) == '\n')
				--state->cursor;
		}
	}
							 break;
	}
}

NK_INTERN void nk_textedit_flush_redo(struct nk_text_undo_state* state) {
	state->redo_point = NK_TEXTEDIT_UNDOSTATECOUNT;
	state->redo_char_point = NK_TEXTEDIT_UNDOCHARCOUNT;
}

NK_INTERN void nk_textedit_discard_undo(struct nk_text_undo_state* state) {
	/* discard the oldest entry in the undo list */
	if (state->undo_point > 0) {
		/* if the 0th undo state has characters, clean those up */
		if (state->undo_rec[0].char_storage >= 0) {
			int n = state->undo_rec[0].insert_length, i;
			/* delete n characters from all other records */
			state->undo_char_point = (short)(state->undo_char_point - n);
			NK_MEMCPY(state->undo_char, state->undo_char + n, (nk_size)state->undo_char_point * sizeof(nk_rune));
			for (i = 0; i < state->undo_point; ++i) {
				if (state->undo_rec[i].char_storage >= 0)
					state->undo_rec[i].char_storage = (short)(state->undo_rec[i].char_storage - n);
			}
		}
		--state->undo_point;
		NK_MEMCPY(state->undo_rec, state->undo_rec + 1,
			(nk_size)((nk_size)state->undo_point * sizeof(state->undo_rec[0])));
	}
}

NK_INTERN void nk_textedit_discard_redo(struct nk_text_undo_state* state) {
	/*  discard the oldest entry in the redo list--it's bad if this
		ever happens, but because undo & redo have to store the actual
		characters in different cases, the redo character buffer can
		fill up even though the undo buffer didn't */
	nk_size num;
	int k = NK_TEXTEDIT_UNDOSTATECOUNT - 1;
	if (state->redo_point <= k) {
		/* if the k'th undo state has characters, clean those up */
		if (state->undo_rec[k].char_storage >= 0) {
			int n = state->undo_rec[k].insert_length, i;
			/* delete n characters from all other records */
			state->redo_char_point = (short)(state->redo_char_point + n);
			num = (nk_size)(NK_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point);
			NK_MEMCPY(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point - n,
				num * sizeof(char));
			for (i = state->redo_point; i < k; ++i) {
				if (state->undo_rec[i].char_storage >= 0) {
					state->undo_rec[i].char_storage = (short)(state->undo_rec[i].char_storage + n);
				}
			}
		}
		++state->redo_point;
		num = (nk_size)(NK_TEXTEDIT_UNDOSTATECOUNT - state->redo_point);
		if (num)
			NK_MEMCPY(state->undo_rec + state->redo_point - 1, state->undo_rec + state->redo_point,
				num * sizeof(state->undo_rec[0]));
	}
}

NK_INTERN struct nk_text_undo_record* nk_textedit_create_undo_record(struct nk_text_undo_state* state, int numchars) {
	/* any time we create a new undo record, we discard redo*/
	nk_textedit_flush_redo(state);

	/* if we have no free records, we have to make room,
	 * by sliding the existing records down */
	if (state->undo_point == NK_TEXTEDIT_UNDOSTATECOUNT)
		nk_textedit_discard_undo(state);

	/* if the characters to store won't possibly fit in the buffer,
	 * we can't undo */
	if (numchars > NK_TEXTEDIT_UNDOCHARCOUNT) {
		state->undo_point = 0;
		state->undo_char_point = 0;
		return 0;
	}

	/* if we don't have enough free characters in the buffer,
	 * we have to make room */
	while (state->undo_char_point + numchars > NK_TEXTEDIT_UNDOCHARCOUNT)
		nk_textedit_discard_undo(state);
	return &state->undo_rec[state->undo_point++];
}

NK_INTERN nk_rune* nk_textedit_createundo(struct nk_text_undo_state* state, int pos, int insert_len, int delete_len) {
	struct nk_text_undo_record* r = nk_textedit_create_undo_record(state, insert_len);
	if (r == 0)
		return 0;

	r->where = pos;
	r->insert_length = (short)insert_len;
	r->delete_length = (short)delete_len;

	if (insert_len == 0) {
		r->char_storage = -1;
		return 0;
	}
	else {
		r->char_storage = state->undo_char_point;
		state->undo_char_point = (short)(state->undo_char_point + insert_len);
		return &state->undo_char[r->char_storage];
	}
}

NK_API void nk_textedit_undo(struct nk_text_edit* state) {
	struct nk_text_undo_state* s = &state->undo;
	struct nk_text_undo_record u, * r;
	if (s->undo_point == 0)
		return;

	/* we need to do two things: apply the undo record, and create a redo record */
	u = s->undo_rec[s->undo_point - 1];
	r = &s->undo_rec[s->redo_point - 1];
	r->char_storage = -1;

	r->insert_length = u.delete_length;
	r->delete_length = u.insert_length;
	r->where = u.where;

	if (u.delete_length) {
		/*   if the undo record says to delete characters, then the redo record will
			need to re-insert the characters that get deleted, so we need to store
			them.
			there are three cases:
				- there's enough room to store the characters
				- characters stored for *redoing* don't leave room for redo
				- characters stored for *undoing* don't leave room for redo
			if the last is true, we have to bail */
		if (s->undo_char_point + u.delete_length >= NK_TEXTEDIT_UNDOCHARCOUNT) {
			/* the undo records take up too much character space; there's no space
			* to store the redo characters */
			r->insert_length = 0;
		}
		else {
			int i;
			/* there's definitely room to store the characters eventually */
			while (s->undo_char_point + u.delete_length > s->redo_char_point) {
				/* there's currently not enough room, so discard a redo record */
				nk_textedit_discard_redo(s);
				/* should never happen: */
				if (s->redo_point == NK_TEXTEDIT_UNDOSTATECOUNT)
					return;
			}

			r = &s->undo_rec[s->redo_point - 1];
			r->char_storage = (short)(s->redo_char_point - u.delete_length);
			s->redo_char_point = (short)(s->redo_char_point - u.delete_length);

			/* now save the characters */
			for (i = 0; i < u.delete_length; ++i)
				s->undo_char[r->char_storage + i] = nk_str_rune_at(&state->string, u.where + i);
		}
		/* now we can carry out the deletion */
		nk_str_delete_runes(&state->string, u.where, u.delete_length);
	}

	/* check type of recorded action: */
	if (u.insert_length) {
		/* easy case: was a deletion, so we need to insert n characters */
		nk_str_insert_text_runes(&state->string, u.where, &s->undo_char[u.char_storage], u.insert_length);
		s->undo_char_point = (short)(s->undo_char_point - u.insert_length);
	}
	state->cursor = (short)(u.where + u.insert_length);

	s->undo_point--;
	s->redo_point--;
}

NK_API void nk_textedit_redo(struct nk_text_edit* state) {
	struct nk_text_undo_state* s = &state->undo;
	struct nk_text_undo_record* u, r;
	if (s->redo_point == NK_TEXTEDIT_UNDOSTATECOUNT)
		return;

	/* we need to do two things: apply the redo record, and create an undo record */
	u = &s->undo_rec[s->undo_point];
	r = s->undo_rec[s->redo_point];

	/* we KNOW there must be room for the undo record, because the redo record
	was derived from an undo record */
	u->delete_length = r.insert_length;
	u->insert_length = r.delete_length;
	u->where = r.where;
	u->char_storage = -1;

	if (r.delete_length) {
		/* the redo record requires us to delete characters, so the undo record
		needs to store the characters */
		if (s->undo_char_point + u->insert_length > s->redo_char_point) {
			u->insert_length = 0;
			u->delete_length = 0;
		}
		else {
			int i;
			u->char_storage = s->undo_char_point;
			s->undo_char_point = (short)(s->undo_char_point + u->insert_length);

			/* now save the characters */
			for (i = 0; i < u->insert_length; ++i) {
				s->undo_char[u->char_storage + i] = nk_str_rune_at(&state->string, u->where + i);
			}
		}
		nk_str_delete_runes(&state->string, r.where, r.delete_length);
	}

	if (r.insert_length) {
		/* easy case: need to insert n characters */
		nk_str_insert_text_runes(&state->string, r.where, &s->undo_char[r.char_storage], r.insert_length);
	}
	state->cursor = r.where + r.insert_length;

	s->undo_point++;
	s->redo_point++;
}

NK_INTERN void nk_textedit_makeundo_insert(struct nk_text_edit* state, int where, int length) {
	nk_textedit_createundo(&state->undo, where, 0, length);
}

NK_INTERN void nk_textedit_makeundo_delete(struct nk_text_edit* state, int where, int length) {
	int i;
	nk_rune* p = nk_textedit_createundo(&state->undo, where, length, 0);
	if (p) {
		for (i = 0; i < length; ++i)
			p[i] = nk_str_rune_at(&state->string, where + i);
	}
}

NK_INTERN void nk_textedit_makeundo_replace(struct nk_text_edit* state, int where, int old_length, int new_length) {
	int i;
	nk_rune* p = nk_textedit_createundo(&state->undo, where, old_length, new_length);
	if (p) {
		for (i = 0; i < old_length; ++i)
			p[i] = nk_str_rune_at(&state->string, where + i);
	}
}

NK_LIB void nk_textedit_clear_state(struct nk_text_edit* state, enum nk_text_edit_type type, nk_plugin_filter filter) {
	/* reset the state to default */
	state->undo.undo_point = 0;
	state->undo.undo_char_point = 0;
	state->undo.redo_point = NK_TEXTEDIT_UNDOSTATECOUNT;
	state->undo.redo_char_point = NK_TEXTEDIT_UNDOCHARCOUNT;
	state->select_end = state->select_start = 0;
	state->cursor = 0;
	state->has_preferred_x = 0;
	state->preferred_x = 0;
	state->cursor_at_end_of_line = 0;
	state->initialized = 1;
	state->single_line = (unsigned char)(type == NK_TEXT_EDIT_SINGLE_LINE);
	state->mode = NK_TEXT_EDIT_MODE_VIEW;
	state->filter = filter;
	state->scrollbar = nk_vec2(0, 0);
}

NK_API void nk_textedit_init_fixed(struct nk_text_edit* state, void* memory, nk_size size) {
	NK_ASSERT(state);
	NK_ASSERT(memory);
	if (!state || !memory || !size) return;
	NK_MEMSET(state, 0, sizeof(struct nk_text_edit));
	nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, 0);
	nk_str_init_fixed(&state->string, memory, size);
}

NK_API void nk_textedit_init(struct nk_text_edit* state, struct nk_allocator* alloc, nk_size size) {
	NK_ASSERT(state);
	NK_ASSERT(alloc);
	if (!state || !alloc) return;
	NK_MEMSET(state, 0, sizeof(struct nk_text_edit));
	nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, 0);
	nk_str_init(&state->string, alloc, size);
}

#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR

NK_API void nk_textedit_init_default(struct nk_text_edit* state) {
	NK_ASSERT(state);
	if (!state) return;
	NK_MEMSET(state, 0, sizeof(struct nk_text_edit));
	nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, 0);
	nk_str_init_default(&state->string);
}

#endif

NK_API void nk_textedit_select_all(struct nk_text_edit* state) {
	NK_ASSERT(state);
	state->select_start = 0;
	state->select_end = state->string.len;
}

NK_API void nk_textedit_free(struct nk_text_edit* state) {
	NK_ASSERT(state);
	if (!state) return;
	nk_str_free(&state->string);
}





/* ===============================================================
 *
 *                          FILTER
 *
 * ===============================================================*/
NK_API int nk_filter_default(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(unicode);
	NK_UNUSED(box);
	return nk_true;
}

NK_API int nk_filter_ascii(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if (unicode > 128) return nk_false;
	else return nk_true;
}

NK_API int nk_filter_float(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if ((unicode < '0' || unicode > '9') && unicode != '.' && unicode != '-')
		return nk_false;
	else return nk_true;
}

NK_API int nk_filter_decimal(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if ((unicode < '0' || unicode > '9') && unicode != '-')
		return nk_false;
	else return nk_true;
}

NK_API int nk_filter_hex(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if ((unicode < '0' || unicode > '9') && (unicode < 'a' || unicode > 'f') && (unicode < 'A' || unicode > 'F'))
		return nk_false;
	else return nk_true;
}

NK_API int nk_filter_oct(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if (unicode < '0' || unicode > '7')
		return nk_false;
	else return nk_true;
}

NK_API int nk_filter_binary(const struct nk_text_edit* box, nk_rune unicode) {
	NK_UNUSED(box);
	if (unicode != '0' && unicode != '1')
		return nk_false;
	else return nk_true;
}

/* ===============================================================
 *
 *                          EDIT
 *
 * ===============================================================*/
NK_LIB void
nk_edit_draw_text(struct nk_command_buffer* out, const struct nk_style_edit* style, float pos_x, float pos_y,
	float x_offset, const char* text, int byte_len, float row_height, const struct nk_user_font* font,
	struct nk_color background, struct nk_color foreground, int is_selected) {
	NK_ASSERT(out);
	NK_ASSERT(font);
	NK_ASSERT(style);
	if (!text || !byte_len || !out || !style) return;

	{
		int glyph_len = 0;
		nk_rune unicode = 0;
		int text_len = 0;
		float line_width = 0;
		float glyph_width;
		const char* line = text;
		float line_offset = 0;
		int line_count = 0;

		struct nk_text txt;
		txt.padding = nk_vec2(0, 0);
		txt.background = background;
		txt.text = foreground;

		glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len - text_len);
		if (!glyph_len) return;
		while ((text_len < byte_len) && glyph_len) {
			if (unicode == '\n') {
				/* new line separator so draw previous line */
				struct nk_rect label;
				label.y = pos_y + line_offset;
				label.h = row_height;
				label.w = line_width;
				label.x = pos_x;
				if (!line_count)
					label.x += x_offset;

				if (is_selected) /* selection needs to draw different background color */
					nk_fill_rect(out, label, 0, background);
				nk_widget_text(out, label, line, (int)((text + text_len) - line), &txt, NK_TEXT_CENTERED, font);

				text_len++;
				line_count++;
				line_width = 0;
				line = text + text_len;
				line_offset += row_height;
				glyph_len = nk_utf_decode(text + text_len, &unicode, (int)(byte_len - text_len));
				continue;
			}
			if (unicode == '\r') {
				text_len++;
				glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len - text_len);
				continue;
			}
			glyph_width = font->width(font->userdata, font->height, text + text_len, glyph_len);
			line_width += (float)glyph_width;
			text_len += glyph_len;
			glyph_len = nk_utf_decode(text + text_len, &unicode, byte_len - text_len);
			continue;
		}
		if (line_width > 0) {
			/* draw last line */
			struct nk_rect label;
			label.y = pos_y + line_offset;
			label.h = row_height;
			label.w = line_width;
			label.x = pos_x;
			if (!line_count)
				label.x += x_offset;

			if (is_selected)
				nk_fill_rect(out, label, 0, background);
			nk_widget_text(out, label, line, (int)((text + text_len) - line), &txt, NK_TEXT_LEFT, font);
		}
	}
}

NK_LIB nk_flags nk_do_edit(nk_flags* state, struct nk_command_buffer* out, struct nk_rect bounds, nk_flags flags,
	nk_plugin_filter filter, struct nk_text_edit* edit, const struct nk_style_edit* style,
	struct nk_input* in, const struct nk_user_font* font) {
	struct nk_rect area;
	nk_flags ret = 0;
	float row_height;
	char prev_state = 0;
	char is_hovered = 0;
	char select_all = 0;
	char cursor_follow = 0;
	struct nk_rect old_clip;
	struct nk_rect clip;

	NK_ASSERT(state);
	NK_ASSERT(out);
	NK_ASSERT(style);
	if (!state || !out || !style)
		return ret;

	/* visible text area calculation */
	area.x = bounds.x + style->padding.x + style->border;
	area.y = bounds.y + style->padding.y + style->border;
	area.w = bounds.w - (2.0f * style->padding.x + 2 * style->border);
	area.h = bounds.h - (2.0f * style->padding.y + 2 * style->border);
	if (flags & NK_EDIT_MULTILINE)
		area.w = NK_MAX(0, area.w - style->scrollbar_size.x);
	row_height = (flags & NK_EDIT_MULTILINE) ? font->height + style->row_padding : area.h;

	/* calculate clipping rectangle */
	old_clip = out->clip;
	nk_unify(&clip, &old_clip, area.x, area.y, area.x + area.w, area.y + area.h);

	/* update edit state */
	prev_state = (char)edit->active;
	is_hovered = (char)nk_input_is_mouse_hovering_rect(in, bounds);
	if (in && in->mouse.buttons[NK_BUTTON_LEFT].clicked && in->mouse.buttons[NK_BUTTON_LEFT].down) {
		edit->active = NK_INBOX(in->mouse.pos.x, in->mouse.pos.y, bounds.x, bounds.y, bounds.w, bounds.h);
	}

	/* (de)activate text editor */
	if (!prev_state && edit->active) {
		const enum nk_text_edit_type type = (flags & NK_EDIT_MULTILINE) ? NK_TEXT_EDIT_MULTI_LINE
			: NK_TEXT_EDIT_SINGLE_LINE;
		nk_textedit_clear_state(edit, type, filter);
		if (flags & NK_EDIT_AUTO_SELECT)
			select_all = nk_true;
		if (flags & NK_EDIT_GOTO_END_ON_ACTIVATE) {
			edit->cursor = edit->string.len;
			in = 0;
		}
	}
	else if (!edit->active) edit->mode = NK_TEXT_EDIT_MODE_VIEW;
	if (flags & NK_EDIT_READ_ONLY)
		edit->mode = NK_TEXT_EDIT_MODE_VIEW;
	else if (flags & NK_EDIT_ALWAYS_INSERT_MODE)
		edit->mode = NK_TEXT_EDIT_MODE_INSERT;

	ret = (edit->active) ? NK_EDIT_ACTIVE : NK_EDIT_INACTIVE;
	if (prev_state != edit->active)
		ret |= (edit->active) ? NK_EDIT_ACTIVATED : NK_EDIT_DEACTIVATED;

	/* handle user input */
	if (edit->active && in) {
		int shift_mod = in->keyboard.keys[NK_KEY_SHIFT].down;
		const float mouse_x = (in->mouse.pos.x - area.x) + edit->scrollbar.x;
		const float mouse_y = (in->mouse.pos.y - area.y) + edit->scrollbar.y;

		/* mouse click handler */
		is_hovered = (char)nk_input_is_mouse_hovering_rect(in, area);
		if (select_all) {
			nk_textedit_select_all(edit);
		}
		else if (is_hovered && in->mouse.buttons[NK_BUTTON_LEFT].down && in->mouse.buttons[NK_BUTTON_LEFT].clicked) {
			nk_textedit_click(edit, mouse_x, mouse_y, font, row_height);
		}
		else if (is_hovered && in->mouse.buttons[NK_BUTTON_LEFT].down &&
			(in->mouse.delta.x != 0.0f || in->mouse.delta.y != 0.0f)) {
			nk_textedit_drag(edit, mouse_x, mouse_y, font, row_height);
			cursor_follow = nk_true;
		}
		else if (is_hovered && in->mouse.buttons[NK_BUTTON_RIGHT].clicked &&
			in->mouse.buttons[NK_BUTTON_RIGHT].down) {
			nk_textedit_key(edit, NK_KEY_TEXT_WORD_LEFT, nk_false, font, row_height);
			nk_textedit_key(edit, NK_KEY_TEXT_WORD_RIGHT, nk_true, font, row_height);
			cursor_follow = nk_true;
		}

		{
			int i; /* keyboard input */
			int old_mode = edit->mode;
			for (i = 0; i < NK_KEY_MAX; ++i) {
				if (i == NK_KEY_ENTER || i == NK_KEY_TAB) continue; /* special case */
				if (nk_input_is_key_pressed(in, (enum nk_keys) i)) {
					nk_textedit_key(edit, (enum nk_keys) i, shift_mod, font, row_height);
					cursor_follow = nk_true;
				}
			}
			if (old_mode != edit->mode) {
				in->keyboard.text_len = 0;
			}
		}

		/* text input */
		edit->filter = filter;
		if (in->keyboard.text_len) {
			nk_textedit_text(edit, in->keyboard.text, in->keyboard.text_len);
			cursor_follow = nk_true;
			in->keyboard.text_len = 0;
		}

		/* enter key handler */
		if (nk_input_is_key_pressed(in, NK_KEY_ENTER)) {
			cursor_follow = nk_true;
			if (flags & NK_EDIT_CTRL_ENTER_NEWLINE && shift_mod)
				nk_textedit_text(edit, "\n", 1);
			else if (flags & NK_EDIT_SIG_ENTER)
				ret |= NK_EDIT_COMMITED;
			else nk_textedit_text(edit, "\n", 1);
		}

		/* cut & copy handler */
		{
			int copy = nk_input_is_key_pressed(in, NK_KEY_COPY);
			int cut = nk_input_is_key_pressed(in, NK_KEY_CUT);
			if ((copy || cut) && (flags & NK_EDIT_CLIPBOARD)) {
				int glyph_len;
				nk_rune unicode;
				const char* text;
				int b = edit->select_start;
				int e = edit->select_end;

				int begin = NK_MIN(b, e);
				int end = NK_MAX(b, e);
				text = nk_str_at_const(&edit->string, begin, &unicode, &glyph_len);
				if (edit->clip.copy)
					edit->clip.copy(edit->clip.userdata, text, end - begin);
				if (cut && !(flags & NK_EDIT_READ_ONLY)) {
					nk_textedit_cut(edit);
					cursor_follow = nk_true;
				}
			}
		}

		/* paste handler */
		{
			int paste = nk_input_is_key_pressed(in, NK_KEY_PASTE);
			if (paste && (flags & NK_EDIT_CLIPBOARD) && edit->clip.paste) {
				edit->clip.paste(edit->clip.userdata, edit);
				cursor_follow = nk_true;
			}
		}

		/* tab handler */
		{
			int tab = nk_input_is_key_pressed(in, NK_KEY_TAB);
			if (tab && (flags & NK_EDIT_ALLOW_TAB)) {
				nk_textedit_text(edit, "    ", 4);
				cursor_follow = nk_true;
			}
		}
	}

	/* set widget state */
	if (edit->active)
		*state = NK_WIDGET_STATE_ACTIVE;
	else nk_widget_state_reset(state);

	if (is_hovered)
		*state |= NK_WIDGET_STATE_HOVERED;

	/* DRAW EDIT */
	{
		const char* text = nk_str_get_const(&edit->string);
		int len = nk_str_len_char(&edit->string);

		{/* select background colors/images  */
			const struct nk_style_item* background;
			if (*state & NK_WIDGET_STATE_ACTIVED)
				background = &style->active;
			else if (*state & NK_WIDGET_STATE_HOVER)
				background = &style->hover;
			else background = &style->normal;

			/* draw background frame */
			if (background->type == NK_STYLE_ITEM_COLOR) {
				nk_stroke_rect(out, bounds, style->rounding, style->border, style->border_color);
				nk_fill_rect(out, bounds, style->rounding, background->data.color);
			}
			else nk_draw_image(out, bounds, &background->data.image, nk_white);
		}

		area.w = NK_MAX(0, area.w - style->cursor_size);
		if (edit->active) {
			int total_lines = 1;
			struct nk_vec2 text_size = nk_vec2(0, 0);

			/* text pointer positions */
			const char* cursor_ptr = 0;
			const char* select_begin_ptr = 0;
			const char* select_end_ptr = 0;

			/* 2D pixel positions */
			struct nk_vec2 cursor_pos = nk_vec2(0, 0);
			struct nk_vec2 selection_offset_start = nk_vec2(0, 0);
			struct nk_vec2 selection_offset_end = nk_vec2(0, 0);

			int selection_begin = NK_MIN(edit->select_start, edit->select_end);
			int selection_end = NK_MAX(edit->select_start, edit->select_end);

			/* calculate total line count + total space + cursor/selection position */
			float line_width = 0.0f;
			if (text && len) {
				/* utf8 encoding */
				float glyph_width;
				int glyph_len = 0;
				nk_rune unicode = 0;
				int text_len = 0;
				int glyphs = 0;
				int row_begin = 0;

				glyph_len = nk_utf_decode(text, &unicode, len);
				glyph_width = font->width(font->userdata, font->height, text, glyph_len);
				line_width = 0;

				/* iterate all lines */
				while ((text_len < len) && glyph_len) {
					/* set cursor 2D position and line */
					if (!cursor_ptr && glyphs == edit->cursor) {
						int glyph_offset;
						struct nk_vec2 out_offset;
						struct nk_vec2 row_size;
						const char* remaining;

						/* calculate 2d position */
						cursor_pos.y = (float)(total_lines - 1) * row_height;
						row_size = nk_text_calculate_text_bounds(font, text + row_begin, text_len - row_begin,
							row_height, &remaining, &out_offset, &glyph_offset,
							NK_STOP_ON_NEW_LINE);
						cursor_pos.x = row_size.x;
						cursor_ptr = text + text_len;
					}

					/* set start selection 2D position and line */
					if (!select_begin_ptr && edit->select_start != edit->select_end && glyphs == selection_begin) {
						int glyph_offset;
						struct nk_vec2 out_offset;
						struct nk_vec2 row_size;
						const char* remaining;

						/* calculate 2d position */
						selection_offset_start.y = (float)(NK_MAX(total_lines - 1, 0)) * row_height;
						row_size = nk_text_calculate_text_bounds(font, text + row_begin, text_len - row_begin,
							row_height, &remaining, &out_offset, &glyph_offset,
							NK_STOP_ON_NEW_LINE);
						selection_offset_start.x = row_size.x;
						select_begin_ptr = text + text_len;
					}

					/* set end selection 2D position and line */
					if (!select_end_ptr && edit->select_start != edit->select_end && glyphs == selection_end) {
						int glyph_offset;
						struct nk_vec2 out_offset;
						struct nk_vec2 row_size;
						const char* remaining;

						/* calculate 2d position */
						selection_offset_end.y = (float)(total_lines - 1) * row_height;
						row_size = nk_text_calculate_text_bounds(font, text + row_begin, text_len - row_begin,
							row_height, &remaining, &out_offset, &glyph_offset,
							NK_STOP_ON_NEW_LINE);
						selection_offset_end.x = row_size.x;
						select_end_ptr = text + text_len;
					}
					if (unicode == '\n') {
						text_size.x = NK_MAX(text_size.x, line_width);
						total_lines++;
						line_width = 0;
						text_len++;
						glyphs++;
						row_begin = text_len;
						glyph_len = nk_utf_decode(text + text_len, &unicode, len - text_len);
						glyph_width = font->width(font->userdata, font->height, text + text_len, glyph_len);
						continue;
					}

					glyphs++;
					text_len += glyph_len;
					line_width += (float)glyph_width;

					glyph_len = nk_utf_decode(text + text_len, &unicode, len - text_len);
					glyph_width = font->width(font->userdata, font->height, text + text_len, glyph_len);
					continue;
				}
				text_size.y = (float)total_lines * row_height;

				/* handle case when cursor is at end of text buffer */
				if (!cursor_ptr && edit->cursor == edit->string.len) {
					cursor_pos.x = line_width;
					cursor_pos.y = text_size.y - row_height;
				}
			}
			{
				/* scrollbar */
				if (cursor_follow) {
					/* update scrollbar to follow cursor */
					if (!(flags & NK_EDIT_NO_HORIZONTAL_SCROLL)) {
						/* horizontal scroll */
						const float scroll_increment = area.w * 0.25f;
						if (cursor_pos.x < edit->scrollbar.x)
							edit->scrollbar.x = (float)(int)NK_MAX(0.0f, cursor_pos.x - scroll_increment);
						if (cursor_pos.x >= edit->scrollbar.x + area.w)
							edit->scrollbar.x = (float)(int)NK_MAX(0.0f, edit->scrollbar.x + scroll_increment);
					}
					else edit->scrollbar.x = 0;

					if (flags & NK_EDIT_MULTILINE) {
						/* vertical scroll */
						if (cursor_pos.y < edit->scrollbar.y)
							edit->scrollbar.y = NK_MAX(0.0f, cursor_pos.y - row_height);
						if (cursor_pos.y >= edit->scrollbar.y + area.h)
							edit->scrollbar.y = edit->scrollbar.y + row_height;
					}
					else edit->scrollbar.y = 0;
				}

				/* scrollbar widget */
				if (flags & NK_EDIT_MULTILINE) {
					nk_flags ws;
					struct nk_rect scroll;
					float scroll_target;
					float scroll_offset;
					float scroll_step;
					float scroll_inc;

					scroll = area;
					scroll.x = (bounds.x + bounds.w - style->border) - style->scrollbar_size.x;
					scroll.w = style->scrollbar_size.x;

					scroll_offset = edit->scrollbar.y;
					scroll_step = scroll.h * 0.10f;
					scroll_inc = scroll.h * 0.01f;
					scroll_target = text_size.y;
					edit->scrollbar.y = nk_do_scrollbarv(&ws, out, scroll, 0, scroll_offset, scroll_target, scroll_step,
						scroll_inc, &style->scrollbar, in, font);
				}
			}

			/* draw text */
			{
				struct nk_color background_color;
				struct nk_color text_color;
				struct nk_color sel_background_color;
				struct nk_color sel_text_color;
				struct nk_color cursor_color;
				struct nk_color cursor_text_color;
				const struct nk_style_item* background;
				nk_push_scissor(out, clip);

				/* select correct colors to draw */
				if (*state & NK_WIDGET_STATE_ACTIVED) {
					background = &style->active;
					text_color = style->text_active;
					sel_text_color = style->selected_text_hover;
					sel_background_color = style->selected_hover;
					cursor_color = style->cursor_hover;
					cursor_text_color = style->cursor_text_hover;
				}
				else if (*state & NK_WIDGET_STATE_HOVER) {
					background = &style->hover;
					text_color = style->text_hover;
					sel_text_color = style->selected_text_hover;
					sel_background_color = style->selected_hover;
					cursor_text_color = style->cursor_text_hover;
					cursor_color = style->cursor_hover;
				}
				else {
					background = &style->normal;
					text_color = style->text_normal;
					sel_text_color = style->selected_text_normal;
					sel_background_color = style->selected_normal;
					cursor_color = style->cursor_normal;
					cursor_text_color = style->cursor_text_normal;
				}
				if (background->type == NK_STYLE_ITEM_IMAGE)
					background_color = nk_rgba(0, 0, 0, 0);
				else background_color = background->data.color;


				if (edit->select_start == edit->select_end) {
					/* no selection so just draw the complete text */
					const char* begin = nk_str_get_const(&edit->string);
					int l = nk_str_len_char(&edit->string);
					nk_edit_draw_text(out, style, area.x - edit->scrollbar.x, area.y - edit->scrollbar.y, 0, begin, l,
						row_height, font, background_color, text_color, nk_false);
				}
				else {
					/* edit has selection so draw 1-3 text chunks */
					if (edit->select_start != edit->select_end && selection_begin > 0) {
						/* draw unselected text before selection */
						const char* begin = nk_str_get_const(&edit->string);
						NK_ASSERT(select_begin_ptr);
						nk_edit_draw_text(out, style, area.x - edit->scrollbar.x, area.y - edit->scrollbar.y, 0, begin,
							(int)(select_begin_ptr - begin), row_height, font, background_color,
							text_color, nk_false);
					}
					if (edit->select_start != edit->select_end) {
						/* draw selected text */
						NK_ASSERT(select_begin_ptr);
						if (!select_end_ptr) {
							const char* begin = nk_str_get_const(&edit->string);
							select_end_ptr = begin + nk_str_len_char(&edit->string);
						}
						nk_edit_draw_text(out, style, area.x - edit->scrollbar.x,
							area.y + selection_offset_start.y - edit->scrollbar.y,
							selection_offset_start.x, select_begin_ptr,
							(int)(select_end_ptr - select_begin_ptr), row_height, font,
							sel_background_color, sel_text_color, nk_true);
					}
					if ((edit->select_start != edit->select_end && selection_end < edit->string.len)) {
						/* draw unselected text after selected text */
						const char* begin = select_end_ptr;
						const char* end = nk_str_get_const(&edit->string) + nk_str_len_char(&edit->string);
						NK_ASSERT(select_end_ptr);
						nk_edit_draw_text(out, style, area.x - edit->scrollbar.x,
							area.y + selection_offset_end.y - edit->scrollbar.y, selection_offset_end.x,
							begin, (int)(end - begin), row_height, font, background_color, text_color,
							nk_true);
					}
				}

				/* cursor */
				if (edit->select_start == edit->select_end) {
					if (edit->cursor >= nk_str_len(&edit->string) || (cursor_ptr && *cursor_ptr == '\n')) {
						/* draw cursor at end of line */
						struct nk_rect cursor;
						cursor.w = style->cursor_size;
						cursor.h = font->height;
						cursor.x = area.x + cursor_pos.x - edit->scrollbar.x;
						cursor.y = area.y + cursor_pos.y + row_height / 2.0f - cursor.h / 2.0f;
						cursor.y -= edit->scrollbar.y;
						nk_fill_rect(out, cursor, 0, cursor_color);
					}
					else {
						/* draw cursor inside text */
						int glyph_len;
						struct nk_rect label;
						struct nk_text txt;

						nk_rune unicode;
						NK_ASSERT(cursor_ptr);
						glyph_len = nk_utf_decode(cursor_ptr, &unicode, 4);

						label.x = area.x + cursor_pos.x - edit->scrollbar.x;
						label.y = area.y + cursor_pos.y - edit->scrollbar.y;
						label.w = font->width(font->userdata, font->height, cursor_ptr, glyph_len);
						label.h = row_height;

						txt.padding = nk_vec2(0, 0);
						txt.background = cursor_color;;
						txt.text = cursor_text_color;
						nk_fill_rect(out, label, 0, cursor_color);
						nk_widget_text(out, label, cursor_ptr, glyph_len, &txt, NK_TEXT_LEFT, font);
					}
				}
			}
		}
		else {
			/* not active so just draw text */
			int l = nk_str_len_char(&edit->string);
			const char* begin = nk_str_get_const(&edit->string);

			const struct nk_style_item* background;
			struct nk_color background_color;
			struct nk_color text_color;
			nk_push_scissor(out, clip);
			if (*state & NK_WIDGET_STATE_ACTIVED) {
				background = &style->active;
				text_color = style->text_active;
			}
			else if (*state & NK_WIDGET_STATE_HOVER) {
				background = &style->hover;
				text_color = style->text_hover;
			}
			else {
				background = &style->normal;
				text_color = style->text_normal;
			}
			if (background->type == NK_STYLE_ITEM_IMAGE)
				background_color = nk_rgba(0, 0, 0, 0);
			else background_color = background->data.color;
			nk_edit_draw_text(out, style, area.x - edit->scrollbar.x, area.y - edit->scrollbar.y, 0, begin, l,
				row_height, font, background_color, text_color, nk_false);
		}
		nk_push_scissor(out, old_clip);
	}
	return ret;
}

NK_API void nk_edit_focus(struct nk_context* ctx, nk_flags flags) {
	nk_hash hash;
	struct nk_window* win;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return;

	win = ctx->current;
	hash = win->edit.seq;
	win->edit.active = nk_true;
	win->edit.name = hash;
	if (flags & NK_EDIT_ALWAYS_INSERT_MODE)
		win->edit.mode = NK_TEXT_EDIT_MODE_INSERT;
}

NK_API void nk_edit_unfocus(struct nk_context* ctx) {
	struct nk_window* win;
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return;

	win = ctx->current;
	win->edit.active = nk_false;
	win->edit.name = 0;
}

NK_API nk_flags
nk_edit_string(struct nk_context* ctx, nk_flags flags, char* memory, int* len, int max, nk_plugin_filter filter) {
	nk_hash hash;
	nk_flags state;
	struct nk_text_edit* edit;
	struct nk_window* win;

	NK_ASSERT(ctx);
	NK_ASSERT(memory);
	NK_ASSERT(len);
	if (!ctx || !memory || !len)
		return 0;

	filter = (!filter) ? nk_filter_default : filter;
	win = ctx->current;
	hash = win->edit.seq;
	edit = &ctx->text_edit;
	nk_textedit_clear_state(&ctx->text_edit,
		(flags & NK_EDIT_MULTILINE) ? NK_TEXT_EDIT_MULTI_LINE : NK_TEXT_EDIT_SINGLE_LINE, filter);

	if (win->edit.active && hash == win->edit.name) {
		if (flags & NK_EDIT_NO_CURSOR)
			edit->cursor = nk_utf_len(memory, *len);
		else edit->cursor = win->edit.cursor;
		if (!(flags & NK_EDIT_SELECTABLE)) {
			edit->select_start = win->edit.cursor;
			edit->select_end = win->edit.cursor;
		}
		else {
			edit->select_start = win->edit.sel_start;
			edit->select_end = win->edit.sel_end;
		}
		edit->mode = win->edit.mode;
		edit->scrollbar.x = (float)win->edit.scrollbar.x;
		edit->scrollbar.y = (float)win->edit.scrollbar.y;
		edit->active = nk_true;
	}
	else edit->active = nk_false;

	max = NK_MAX(1, max);
	*len = NK_MIN(*len, max - 1);
	nk_str_init_fixed(&edit->string, memory, (nk_size)max);
	edit->string.buffer.allocated = (nk_size)*len;
	edit->string.len = nk_utf_len(memory, *len);
	state = nk_edit_buffer(ctx, flags, edit, filter);
	*len = (int)edit->string.buffer.allocated;

	if (edit->active) {
		win->edit.cursor = edit->cursor;
		win->edit.sel_start = edit->select_start;
		win->edit.sel_end = edit->select_end;
		win->edit.mode = edit->mode;
		win->edit.scrollbar.x = (nk_uint)edit->scrollbar.x;
		win->edit.scrollbar.y = (nk_uint)edit->scrollbar.y;
	}
	return state;
}

NK_API nk_flags
nk_edit_buffer(struct nk_context* ctx, nk_flags flags, struct nk_text_edit* edit, nk_plugin_filter filter) {
	struct nk_window* win;
	struct nk_style* style;
	struct nk_input* in;

	enum nk_widget_layout_states state;
	struct nk_rect bounds;

	nk_flags ret_flags = 0;
	unsigned char prev_state;
	nk_hash hash;

	/* make sure correct values */
	NK_ASSERT(ctx);
	NK_ASSERT(edit);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	state = nk_widget(&bounds, ctx);
	if (!state) return state;
	in = (win->layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;

	/* check if edit is currently hot item */
	hash = win->edit.seq++;
	if (win->edit.active && hash == win->edit.name) {
		if (flags & NK_EDIT_NO_CURSOR)
			edit->cursor = edit->string.len;
		if (!(flags & NK_EDIT_SELECTABLE)) {
			edit->select_start = edit->cursor;
			edit->select_end = edit->cursor;
		}
		if (flags & NK_EDIT_CLIPBOARD)
			edit->clip = ctx->clip;
		edit->active = (unsigned char)win->edit.active;
	}
	else edit->active = nk_false;
	edit->mode = win->edit.mode;

	filter = (!filter) ? nk_filter_default : filter;
	prev_state = (unsigned char)edit->active;
	in = (flags & NK_EDIT_READ_ONLY) ? 0 : in;
	ret_flags = nk_do_edit(&ctx->last_widget_state, &win->buffer, bounds, flags, filter, edit, &style->edit, in,
		style->font);

	if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
		ctx->style.cursor_active = ctx->style.cursors[NK_CURSOR_TEXT];
	if (edit->active && prev_state != edit->active) {
		/* current edit is now hot */
		win->edit.active = nk_true;
		win->edit.name = hash;
	}
	else if (prev_state && !edit->active) {
		/* current edit is now cold */
		win->edit.active = nk_false;
	}
	return ret_flags;
}

NK_API nk_flags
nk_edit_string_zero_terminated(struct nk_context* ctx, nk_flags flags, char* buffer, int max, nk_plugin_filter filter) {
	nk_flags result;
	int len = nk_strlen(buffer);
	result = nk_edit_string(ctx, flags, buffer, &len, max, filter);
	buffer[NK_MIN(NK_MAX(max - 1, 0), len)] = '\0';
	return result;
}





/* ===============================================================
 *
 *                              PROPERTY
 *
 * ===============================================================*/
NK_LIB void
nk_drag_behavior(nk_flags* state, const struct nk_input* in, struct nk_rect drag, struct nk_property_variant* variant,
	float inc_per_pixel) {
	int left_mouse_down = in && in->mouse.buttons[NK_BUTTON_LEFT].down;
	int left_mouse_click_in_cursor = in && nk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, drag, nk_true);

	nk_widget_state_reset(state);
	if (nk_input_is_mouse_hovering_rect(in, drag))
		*state = NK_WIDGET_STATE_HOVERED;

	if (left_mouse_down && left_mouse_click_in_cursor) {
		float delta, pixels;
		pixels = in->mouse.delta.x;
		delta = pixels * inc_per_pixel;
		switch (variant->kind) {
		default:
			break;
		case NK_PROPERTY_INT:
			variant->value.i = variant->value.i + (int)delta;
			variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i, variant->max_value.i);
			break;
		case NK_PROPERTY_FLOAT:
			variant->value.f = variant->value.f + (float)delta;
			variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f, variant->max_value.f);
			break;
		case NK_PROPERTY_DOUBLE:
			variant->value.d = variant->value.d + (double)delta;
			variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d, variant->max_value.d);
			break;
		}
		*state = NK_WIDGET_STATE_ACTIVE;
	}
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, drag))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, drag))
		*state |= NK_WIDGET_STATE_LEFT;
}

NK_LIB void nk_property_behavior(nk_flags* ws, const struct nk_input* in, struct nk_rect property, struct nk_rect label,
	struct nk_rect edit, struct nk_rect empty, int* state,
	struct nk_property_variant* variant, float inc_per_pixel) {
	if (in && *state == NK_PROPERTY_DEFAULT) {
		if (nk_button_behavior(ws, edit, in, NK_BUTTON_DEFAULT))
			*state = NK_PROPERTY_EDIT;
		else if (nk_input_is_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, label, nk_true))
			*state = NK_PROPERTY_DRAG;
		else if (nk_input_is_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, empty, nk_true))
			*state = NK_PROPERTY_DRAG;
	}
	if (*state == NK_PROPERTY_DRAG) {
		nk_drag_behavior(ws, in, property, variant, inc_per_pixel);
		if (!(*ws & NK_WIDGET_STATE_ACTIVED)) *state = NK_PROPERTY_DEFAULT;
	}
}

NK_LIB void
nk_draw_property(struct nk_command_buffer* out, const struct nk_style_property* style, const struct nk_rect* bounds,
	const struct nk_rect* label, nk_flags state, const char* name, int len,
	const struct nk_user_font* font) {
	struct nk_text text;
	const struct nk_style_item* background;

	/* select correct background and text color */
	if (state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->active;
		text.text = style->label_active;
	}
	else if (state & NK_WIDGET_STATE_HOVER) {
		background = &style->hover;
		text.text = style->label_hover;
	}
	else {
		background = &style->normal;
		text.text = style->label_normal;
	}

	/* draw background */
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(out, *bounds, &background->data.image, nk_white);
		text.background = nk_rgba(0, 0, 0, 0);
	}
	else {
		text.background = background->data.color;
		nk_fill_rect(out, *bounds, style->rounding, background->data.color);
		nk_stroke_rect(out, *bounds, style->rounding, style->border, background->data.color);
	}

	/* draw label */
	text.padding = nk_vec2(0, 0);
	nk_widget_text(out, *label, name, len, &text, NK_TEXT_CENTERED, font);
}

NK_LIB void nk_do_property(nk_flags* ws, struct nk_command_buffer* out, struct nk_rect property, const char* name,
	struct nk_property_variant* variant, float inc_per_pixel, char* buffer, int* len, int* state,
	int* cursor, int* select_begin, int* select_end, const struct nk_style_property* style,
	enum nk_property_filter filter, struct nk_input* in, const struct nk_user_font* font,
	struct nk_text_edit* text_edit, enum nk_button_behavior behavior) {
	const nk_plugin_filter filters[] = { nk_filter_decimal, nk_filter_float };
	int active, old;
	int num_len, name_len;
	char string[NK_MAX_NUMBER_BUFFER];
	float size;

	char* dst = 0;
	int* length;

	struct nk_rect left;
	struct nk_rect right;
	struct nk_rect label;
	struct nk_rect edit;
	struct nk_rect empty;

	/* left decrement button */
	left.h = font->height / 2;
	left.w = left.h;
	left.x = property.x + style->border + style->padding.x;
	left.y = property.y + style->border + property.h / 2.0f - left.h / 2;

	/* text label */
	name_len = nk_strlen(name);
	size = font->width(font->userdata, font->height, name, name_len);
	label.x = left.x + left.w + style->padding.x;
	label.w = (float)size + 2 * style->padding.x;
	label.y = property.y + style->border + style->padding.y;
	label.h = property.h - (2 * style->border + 2 * style->padding.y);

	/* right increment button */
	right.y = left.y;
	right.w = left.w;
	right.h = left.h;
	right.x = property.x + property.w - (right.w + style->padding.x);

	/* edit */
	if (*state == NK_PROPERTY_EDIT) {
		size = font->width(font->userdata, font->height, buffer, *len);
		size += style->edit.cursor_size;
		length = len;
		dst = buffer;
	}
	else {
		switch (variant->kind) {
		default:
			break;
		case NK_PROPERTY_INT:
			nk_itoa(string, variant->value.i);
			num_len = nk_strlen(string);
			break;
		case NK_PROPERTY_FLOAT:
			NK_DTOA(string, (double)variant->value.f);
			num_len = nk_string_float_limit(string, NK_MAX_FLOAT_PRECISION);
			break;
		case NK_PROPERTY_DOUBLE:
			NK_DTOA(string, variant->value.d);
			num_len = nk_string_float_limit(string, NK_MAX_FLOAT_PRECISION);
			break;
		}
		size = font->width(font->userdata, font->height, string, num_len);
		dst = string;
		length = &num_len;
	}

	edit.w = (float)size + 2 * style->padding.x;
	edit.w = NK_MIN(edit.w, right.x - (label.x + label.w));
	edit.x = right.x - (edit.w + style->padding.x);
	edit.y = property.y + style->border;
	edit.h = property.h - (2 * style->border);

	/* empty left space activator */
	empty.w = edit.x - (label.x + label.w);
	empty.x = label.x + label.w;
	empty.y = property.y;
	empty.h = property.h;

	/* update property */
	old = (*state == NK_PROPERTY_EDIT);
	nk_property_behavior(ws, in, property, label, edit, empty, state, variant, inc_per_pixel);

	/* draw property */
	if (style->draw_begin) style->draw_begin(out, style->userdata);
	nk_draw_property(out, style, &property, &label, *ws, name, name_len, font);
	if (style->draw_end) style->draw_end(out, style->userdata);

	/* execute right button  */
	if (nk_do_button_symbol(ws, out, left, style->sym_left, behavior, &style->dec_button, in, font)) {
		switch (variant->kind) {
		default:
			break;
		case NK_PROPERTY_INT:
			variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i - variant->step.i,
				variant->max_value.i);
			break;
		case NK_PROPERTY_FLOAT:
			variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f - variant->step.f,
				variant->max_value.f);
			break;
		case NK_PROPERTY_DOUBLE:
			variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d - variant->step.d,
				variant->max_value.d);
			break;
		}
	}
	/* execute left button  */
	if (nk_do_button_symbol(ws, out, right, style->sym_right, behavior, &style->inc_button, in, font)) {
		switch (variant->kind) {
		default:
			break;
		case NK_PROPERTY_INT:
			variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i + variant->step.i,
				variant->max_value.i);
			break;
		case NK_PROPERTY_FLOAT:
			variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f + variant->step.f,
				variant->max_value.f);
			break;
		case NK_PROPERTY_DOUBLE:
			variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d + variant->step.d,
				variant->max_value.d);
			break;
		}
	}
	if (old != NK_PROPERTY_EDIT && (*state == NK_PROPERTY_EDIT)) {
		/* property has been activated so setup buffer */
		NK_MEMCPY(buffer, dst, (nk_size)*length);
		*cursor = nk_utf_len(buffer, *length);
		*len = *length;
		length = len;
		dst = buffer;
		active = 0;
	}
	else active = (*state == NK_PROPERTY_EDIT);

	/* execute and run text edit field */
	nk_textedit_clear_state(text_edit, NK_TEXT_EDIT_SINGLE_LINE, filters[filter]);
	text_edit->active = (unsigned char)active;
	text_edit->string.len = *length;
	text_edit->cursor = NK_CLAMP(0, *cursor, *length);
	text_edit->select_start = NK_CLAMP(0, *select_begin, *length);
	text_edit->select_end = NK_CLAMP(0, *select_end, *length);
	text_edit->string.buffer.allocated = (nk_size)*length;
	text_edit->string.buffer.memory.size = NK_MAX_NUMBER_BUFFER;
	text_edit->string.buffer.memory.ptr = dst;
	text_edit->string.buffer.size = NK_MAX_NUMBER_BUFFER;
	text_edit->mode = NK_TEXT_EDIT_MODE_INSERT;
	nk_do_edit(ws, out, edit, NK_EDIT_FIELD | NK_EDIT_AUTO_SELECT, filters[filter], text_edit, &style->edit,
		(*state == NK_PROPERTY_EDIT) ? in : 0, font);

	*length = text_edit->string.len;
	*cursor = text_edit->cursor;
	*select_begin = text_edit->select_start;
	*select_end = text_edit->select_end;
	if (text_edit->active && nk_input_is_key_pressed(in, NK_KEY_ENTER))
		text_edit->active = nk_false;

	if (active && !text_edit->active) {
		/* property is now not active so convert edit text to value*/
		*state = NK_PROPERTY_DEFAULT;
		buffer[*len] = '\0';
		switch (variant->kind) {
		default:
			break;
		case NK_PROPERTY_INT:
			variant->value.i = nk_strtoi(buffer, 0);
			variant->value.i = NK_CLAMP(variant->min_value.i, variant->value.i, variant->max_value.i);
			break;
		case NK_PROPERTY_FLOAT:
			nk_string_float_limit(buffer, NK_MAX_FLOAT_PRECISION);
			variant->value.f = nk_strtof(buffer, 0);
			variant->value.f = NK_CLAMP(variant->min_value.f, variant->value.f, variant->max_value.f);
			break;
		case NK_PROPERTY_DOUBLE:
			nk_string_float_limit(buffer, NK_MAX_FLOAT_PRECISION);
			variant->value.d = nk_strtod(buffer, 0);
			variant->value.d = NK_CLAMP(variant->min_value.d, variant->value.d, variant->max_value.d);
			break;
		}
	}
}

NK_LIB struct nk_property_variant nk_property_variant_int(int value, int min_value, int max_value, int step) {
	struct nk_property_variant result;
	result.kind = NK_PROPERTY_INT;
	result.value.i = value;
	result.min_value.i = min_value;
	result.max_value.i = max_value;
	result.step.i = step;
	return result;
}

NK_LIB struct nk_property_variant nk_property_variant_float(float value, float min_value, float max_value, float step) {
	struct nk_property_variant result;
	result.kind = NK_PROPERTY_FLOAT;
	result.value.f = value;
	result.min_value.f = min_value;
	result.max_value.f = max_value;
	result.step.f = step;
	return result;
}

NK_LIB struct nk_property_variant
nk_property_variant_double(double value, double min_value, double max_value, double step) {
	struct nk_property_variant result;
	result.kind = NK_PROPERTY_DOUBLE;
	result.value.d = value;
	result.min_value.d = min_value;
	result.max_value.d = max_value;
	result.step.d = step;
	return result;
}

NK_LIB void
nk_property(struct nk_context* ctx, const char* name, struct nk_property_variant* variant, float inc_per_pixel,
	const enum nk_property_filter filter) {
	struct nk_window* win;
	struct nk_panel* layout;
	struct nk_input* in;
	const struct nk_style* style;

	struct nk_rect bounds;
	enum nk_widget_layout_states s;

	int* state = 0;
	nk_hash hash = 0;
	char* buffer = 0;
	int* len = 0;
	int* cursor = 0;
	int* select_begin = 0;
	int* select_end = 0;
	int old_state;

	char dummy_buffer[NK_MAX_NUMBER_BUFFER];
	int dummy_state = NK_PROPERTY_DEFAULT;
	int dummy_length = 0;
	int dummy_cursor = 0;
	int dummy_select_begin = 0;
	int dummy_select_end = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return;

	win = ctx->current;
	layout = win->layout;
	style = &ctx->style;
	s = nk_widget(&bounds, ctx);
	if (!s) return;

	/* calculate hash from name */
	if (name[0] == '#') {
		hash = nk_murmur_hash(name, (int)nk_strlen(name), win->property.seq++);
		name++; /* special number hash */
	}
	else hash = nk_murmur_hash(name, (int)nk_strlen(name), 42);

	/* check if property is currently hot item */
	if (win->property.active && hash == win->property.name) {
		buffer = win->property.buffer;
		len = &win->property.length;
		cursor = &win->property.cursor;
		state = &win->property.state;
		select_begin = &win->property.select_start;
		select_end = &win->property.select_end;
	}
	else {
		buffer = dummy_buffer;
		len = &dummy_length;
		cursor = &dummy_cursor;
		state = &dummy_state;
		select_begin = &dummy_select_begin;
		select_end = &dummy_select_end;
	}

	/* execute property widget */
	old_state = *state;
	ctx->text_edit.clip = ctx->clip;
	in = ((s == NK_WIDGET_ROM && !win->property.active) || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	nk_do_property(&ctx->last_widget_state, &win->buffer, bounds, name, variant, inc_per_pixel, buffer, len, state,
		cursor, select_begin, select_end, &style->property, filter, in, style->font, &ctx->text_edit,
		ctx->button_behavior);

	if (in && *state != NK_PROPERTY_DEFAULT && !win->property.active) {
		/* current property is now hot */
		win->property.active = 1;
		NK_MEMCPY(win->property.buffer, buffer, (nk_size)*len);
		win->property.length = *len;
		win->property.cursor = *cursor;
		win->property.state = *state;
		win->property.name = hash;
		win->property.select_start = *select_begin;
		win->property.select_end = *select_end;
		if (*state == NK_PROPERTY_DRAG) {
			ctx->input.mouse.grab = nk_true;
			ctx->input.mouse.grabbed = nk_true;
		}
	}
	/* check if previously active property is now inactive */
	if (*state == NK_PROPERTY_DEFAULT && old_state != NK_PROPERTY_DEFAULT) {
		if (old_state == NK_PROPERTY_DRAG) {
			ctx->input.mouse.grab = nk_false;
			ctx->input.mouse.grabbed = nk_false;
			ctx->input.mouse.ungrab = nk_true;
		}
		win->property.select_start = 0;
		win->property.select_end = 0;
		win->property.active = 0;
	}
}

NK_API void
nk_property_int(struct nk_context* ctx, const char* name, int min, int* val, int max, int step, float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);
	NK_ASSERT(val);

	if (!ctx || !ctx->current || !name || !val) return;
	variant = nk_property_variant_int(*val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_INT);
	*val = variant.value.i;
}

NK_API void nk_property_float(struct nk_context* ctx, const char* name, float min, float* val, float max, float step,
	float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);
	NK_ASSERT(val);

	if (!ctx || !ctx->current || !name || !val) return;
	variant = nk_property_variant_float(*val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_FLOAT);
	*val = variant.value.f;
}

NK_API void
nk_property_double(struct nk_context* ctx, const char* name, double min, double* val, double max, double step,
	float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);
	NK_ASSERT(val);

	if (!ctx || !ctx->current || !name || !val) return;
	variant = nk_property_variant_double(*val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_FLOAT);
	*val = variant.value.d;
}

NK_API int
nk_propertyi(struct nk_context* ctx, const char* name, int min, int val, int max, int step, float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);

	if (!ctx || !ctx->current || !name) return val;
	variant = nk_property_variant_int(val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_INT);
	val = variant.value.i;
	return val;
}

NK_API float nk_propertyf(struct nk_context* ctx, const char* name, float min, float val, float max, float step,
	float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);

	if (!ctx || !ctx->current || !name) return val;
	variant = nk_property_variant_float(val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_FLOAT);
	val = variant.value.f;
	return val;
}

NK_API double nk_propertyd(struct nk_context* ctx, const char* name, double min, double val, double max, double step,
	float inc_per_pixel) {
	struct nk_property_variant variant;
	NK_ASSERT(ctx);
	NK_ASSERT(name);

	if (!ctx || !ctx->current || !name) return val;
	variant = nk_property_variant_double(val, min, max, step);
	nk_property(ctx, name, &variant, inc_per_pixel, NK_FILTER_FLOAT);
	val = variant.value.d;
	return val;
}





/* ==============================================================
 *
 *                          CHART
 *
 * ===============================================================*/
NK_API int nk_chart_begin_colored(struct nk_context* ctx, enum nk_chart_type type, struct nk_color color,
	struct nk_color highlight, int count, float min_value, float max_value) {
	struct nk_window* win;
	struct nk_chart* chart;
	const struct nk_style* config;
	const struct nk_style_chart* style;

	const struct nk_style_item* background;
	struct nk_rect bounds = { 0, 0, 0, 0 };

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);

	if (!ctx || !ctx->current || !ctx->current->layout) return 0;
	if (!nk_widget(&bounds, ctx)) {
		chart = &ctx->current->layout->chart;
		nk_zero(chart, sizeof(*chart));
		return 0;
	}

	win = ctx->current;
	config = &ctx->style;
	chart = &win->layout->chart;
	style = &config->chart;

	/* setup basic generic chart  */
	nk_zero(chart, sizeof(*chart));
	chart->x = bounds.x + style->padding.x;
	chart->y = bounds.y + style->padding.y;
	chart->w = bounds.w - 2 * style->padding.x;
	chart->h = bounds.h - 2 * style->padding.y;
	chart->w = NK_MAX(chart->w, 2 * style->padding.x);
	chart->h = NK_MAX(chart->h, 2 * style->padding.y);

	/* add first slot into chart */
	{
		struct nk_chart_slot* slot = &chart->slots[chart->slot++];
		slot->type = type;
		slot->count = count;
		slot->color = color;
		slot->highlight = highlight;
		slot->min = NK_MIN(min_value, max_value);
		slot->max = NK_MAX(min_value, max_value);
		slot->range = slot->max - slot->min;
	}

	/* draw chart background */
	background = &style->background;
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(&win->buffer, bounds, &background->data.image, nk_white);
	}
	else {
		nk_fill_rect(&win->buffer, bounds, style->rounding, style->border_color);
		nk_fill_rect(&win->buffer, nk_shrink_rect(bounds, style->border), style->rounding,
			style->background.data.color);
	}
	return 1;
}

NK_API int
nk_chart_begin(struct nk_context* ctx, const enum nk_chart_type type, int count, float min_value, float max_value) {
	return nk_chart_begin_colored(ctx, type, ctx->style.chart.color, ctx->style.chart.selected_color, count, min_value,
		max_value);
}

NK_API void nk_chart_add_slot_colored(struct nk_context* ctx, const enum nk_chart_type type, struct nk_color color,
	struct nk_color highlight, int count, float min_value, float max_value) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	NK_ASSERT(ctx->current->layout->chart.slot < NK_CHART_MAX_SLOT);
	if (!ctx || !ctx->current || !ctx->current->layout) return;
	if (ctx->current->layout->chart.slot >= NK_CHART_MAX_SLOT) return;

	/* add another slot into the graph */
	{
		struct nk_chart* chart = &ctx->current->layout->chart;
		struct nk_chart_slot* slot = &chart->slots[chart->slot++];
		slot->type = type;
		slot->count = count;
		slot->color = color;
		slot->highlight = highlight;
		slot->min = NK_MIN(min_value, max_value);
		slot->max = NK_MAX(min_value, max_value);
		slot->range = slot->max - slot->min;
	}
}

NK_API void
nk_chart_add_slot(struct nk_context* ctx, const enum nk_chart_type type, int count, float min_value, float max_value) {
	nk_chart_add_slot_colored(ctx, type, ctx->style.chart.color, ctx->style.chart.selected_color, count, min_value,
		max_value);
}

NK_INTERN nk_flags
nk_chart_push_line(struct nk_context* ctx, struct nk_window* win, struct nk_chart* g, float value, int slot) {
	struct nk_panel* layout = win->layout;
	const struct nk_input* i = &ctx->input;
	struct nk_command_buffer* out = &win->buffer;

	nk_flags ret = 0;
	struct nk_vec2 cur;
	struct nk_rect bounds;
	struct nk_color color;
	float step;
	float range;
	float ratio;

	NK_ASSERT(slot >= 0 && slot < NK_CHART_MAX_SLOT);
	step = g->w / (float)g->slots[slot].count;
	range = g->slots[slot].max - g->slots[slot].min;
	ratio = (value - g->slots[slot].min) / range;

	if (g->slots[slot].index == 0) {
		/* first data point does not have a connection */
		g->slots[slot].last.x = g->x;
		g->slots[slot].last.y = (g->y + g->h) - ratio * (float)g->h;

		bounds.x = g->slots[slot].last.x - 2;
		bounds.y = g->slots[slot].last.y - 2;
		bounds.w = bounds.h = 4;

		color = g->slots[slot].color;
		if (!(layout->flags & NK_WINDOW_ROM) &&
			NK_INBOX(i->mouse.pos.x, i->mouse.pos.y, g->slots[slot].last.x - 3, g->slots[slot].last.y - 3, 6, 6)) {
			ret = nk_input_is_mouse_hovering_rect(i, bounds) ? NK_CHART_HOVERING : 0;
			ret |= (i->mouse.buttons[NK_BUTTON_LEFT].down && i->mouse.buttons[NK_BUTTON_LEFT].clicked)
				? NK_CHART_CLICKED : 0;
			color = g->slots[slot].highlight;
		}
		nk_fill_rect(out, bounds, 0, color);
		g->slots[slot].index += 1;
		return ret;
	}

	/* draw a line between the last data point and the new one */
	color = g->slots[slot].color;
	cur.x = g->x + (float)(step * (float)g->slots[slot].index);
	cur.y = (g->y + g->h) - (ratio * (float)g->h);
	nk_stroke_line(out, g->slots[slot].last.x, g->slots[slot].last.y, cur.x, cur.y, 1.0f, color);

	bounds.x = cur.x - 3;
	bounds.y = cur.y - 3;
	bounds.w = bounds.h = 6;

	/* user selection of current data point */
	if (!(layout->flags & NK_WINDOW_ROM)) {
		if (nk_input_is_mouse_hovering_rect(i, bounds)) {
			ret = NK_CHART_HOVERING;
			ret |= (!i->mouse.buttons[NK_BUTTON_LEFT].down && i->mouse.buttons[NK_BUTTON_LEFT].clicked)
				? NK_CHART_CLICKED : 0;
			color = g->slots[slot].highlight;
		}
	}
	nk_fill_rect(out, nk_rect(cur.x - 2, cur.y - 2, 4, 4), 0, color);

	/* save current data point position */
	g->slots[slot].last.x = cur.x;
	g->slots[slot].last.y = cur.y;
	g->slots[slot].index += 1;
	return ret;
}

NK_INTERN nk_flags
nk_chart_push_column(const struct nk_context* ctx, struct nk_window* win, struct nk_chart* chart, float value,
	int slot) {
	struct nk_command_buffer* out = &win->buffer;
	const struct nk_input* in = &ctx->input;
	struct nk_panel* layout = win->layout;

	float ratio;
	nk_flags ret = 0;
	struct nk_color color;
	struct nk_rect item = { 0, 0, 0, 0 };

	NK_ASSERT(slot >= 0 && slot < NK_CHART_MAX_SLOT);
	if (chart->slots[slot].index >= chart->slots[slot].count)
		return nk_false;
	if (chart->slots[slot].count) {
		float padding = (float)(chart->slots[slot].count - 1);
		item.w = (chart->w - padding) / (float)(chart->slots[slot].count);
	}

	/* calculate bounds of current bar chart entry */
	color = chart->slots[slot].color;;
	item.h = chart->h * NK_ABS((value / chart->slots[slot].range));
	if (value >= 0) {
		ratio = (value + NK_ABS(chart->slots[slot].min)) / NK_ABS(chart->slots[slot].range);
		item.y = (chart->y + chart->h) - chart->h * ratio;
	}
	else {
		ratio = (value - chart->slots[slot].max) / chart->slots[slot].range;
		item.y = chart->y + (chart->h * NK_ABS(ratio)) - item.h;
	}
	item.x = chart->x + ((float)chart->slots[slot].index * item.w);
	item.x = item.x + ((float)chart->slots[slot].index);

	/* user chart bar selection */
	if (!(layout->flags & NK_WINDOW_ROM) &&
		NK_INBOX(in->mouse.pos.x, in->mouse.pos.y, item.x, item.y, item.w, item.h)) {
		ret = NK_CHART_HOVERING;
		ret |= (!in->mouse.buttons[NK_BUTTON_LEFT].down && in->mouse.buttons[NK_BUTTON_LEFT].clicked) ? NK_CHART_CLICKED
			: 0;
		color = chart->slots[slot].highlight;
	}
	nk_fill_rect(out, item, 0, color);
	chart->slots[slot].index += 1;
	return ret;
}

NK_API nk_flags nk_chart_push_slot(struct nk_context* ctx, float value, int slot) {
	nk_flags flags;
	struct nk_window* win;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(slot >= 0 && slot < NK_CHART_MAX_SLOT);
	NK_ASSERT(slot < ctx->current->layout->chart.slot);
	if (!ctx || !ctx->current || slot >= NK_CHART_MAX_SLOT) return nk_false;
	if (slot >= ctx->current->layout->chart.slot) return nk_false;

	win = ctx->current;
	if (win->layout->chart.slot < slot) return nk_false;
	switch (win->layout->chart.slots[slot].type) {
	case NK_CHART_LINES:
		flags = nk_chart_push_line(ctx, win, &win->layout->chart, value, slot);
		break;
	case NK_CHART_COLUMN:
		flags = nk_chart_push_column(ctx, win, &win->layout->chart, value, slot);
		break;
	default:
	case NK_CHART_MAX:
		flags = 0;
	}
	return flags;
}

NK_API nk_flags nk_chart_push(struct nk_context* ctx, float value) {
	return nk_chart_push_slot(ctx, value, 0);
}

NK_API void nk_chart_end(struct nk_context* ctx) {
	struct nk_window* win;
	struct nk_chart* chart;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current)
		return;

	win = ctx->current;
	chart = &win->layout->chart;
	NK_MEMSET(chart, 0, sizeof(*chart));
	return;
}

NK_API void nk_plot(struct nk_context* ctx, enum nk_chart_type type, const float* values, int count, int offset) {
	int i = 0;
	float min_value;
	float max_value;

	NK_ASSERT(ctx);
	NK_ASSERT(values);
	if (!ctx || !values || !count) return;

	min_value = values[offset];
	max_value = values[offset];
	for (i = 0; i < count; ++i) {
		min_value = NK_MIN(values[i + offset], min_value);
		max_value = NK_MAX(values[i + offset], max_value);
	}

	if (nk_chart_begin(ctx, type, count, min_value, max_value)) {
		for (i = 0; i < count; ++i)
			nk_chart_push(ctx, values[i + offset]);
		nk_chart_end(ctx);
	}
}

NK_API void nk_plot_function(struct nk_context* ctx, enum nk_chart_type type, void* userdata,
	float(*value_getter)(void* user, int index), int count, int offset) {
	int i = 0;
	float min_value;
	float max_value;

	NK_ASSERT(ctx);
	NK_ASSERT(value_getter);
	if (!ctx || !value_getter || !count) return;

	max_value = min_value = value_getter(userdata, offset);
	for (i = 0; i < count; ++i) {
		float value = value_getter(userdata, i + offset);
		min_value = NK_MIN(value, min_value);
		max_value = NK_MAX(value, max_value);
	}

	if (nk_chart_begin(ctx, type, count, min_value, max_value)) {
		for (i = 0; i < count; ++i)
			nk_chart_push(ctx, value_getter(userdata, i + offset));
		nk_chart_end(ctx);
	}
}





/* ==============================================================
 *
 *                          COLOR PICKER
 *
 * ===============================================================*/
NK_LIB int nk_color_picker_behavior(nk_flags* state, const struct nk_rect* bounds, const struct nk_rect* matrix,
	const struct nk_rect* hue_bar, const struct nk_rect* alpha_bar,
	struct nk_colorf* color, const struct nk_input* in) {
	float hsva[4];
	int value_changed = 0;
	int hsv_changed = 0;

	NK_ASSERT(state);
	NK_ASSERT(matrix);
	NK_ASSERT(hue_bar);
	NK_ASSERT(color);

	/* color matrix */
	nk_colorf_hsva_fv(hsva, *color);
	if (nk_button_behavior(state, *matrix, in, NK_BUTTON_REPEATER)) {
		hsva[1] = NK_SATURATE((in->mouse.pos.x - matrix->x) / (matrix->w - 1));
		hsva[2] = 1.0f - NK_SATURATE((in->mouse.pos.y - matrix->y) / (matrix->h - 1));
		value_changed = hsv_changed = 1;
	}
	/* hue bar */
	if (nk_button_behavior(state, *hue_bar, in, NK_BUTTON_REPEATER)) {
		hsva[0] = NK_SATURATE((in->mouse.pos.y - hue_bar->y) / (hue_bar->h - 1));
		value_changed = hsv_changed = 1;
	}
	/* alpha bar */
	if (alpha_bar) {
		if (nk_button_behavior(state, *alpha_bar, in, NK_BUTTON_REPEATER)) {
			hsva[3] = 1.0f - NK_SATURATE((in->mouse.pos.y - alpha_bar->y) / (alpha_bar->h - 1));
			value_changed = 1;
		}
	}
	nk_widget_state_reset(state);
	if (hsv_changed) {
		*color = nk_hsva_colorfv(hsva);
		*state = NK_WIDGET_STATE_ACTIVE;
	}
	if (value_changed) {
		color->a = hsva[3];
		*state = NK_WIDGET_STATE_ACTIVE;
	}
	/* set color picker widget state */
	if (nk_input_is_mouse_hovering_rect(in, *bounds))
		*state = NK_WIDGET_STATE_HOVERED;
	if (*state & NK_WIDGET_STATE_HOVER && !nk_input_is_mouse_prev_hovering_rect(in, *bounds))
		*state |= NK_WIDGET_STATE_ENTERED;
	else if (nk_input_is_mouse_prev_hovering_rect(in, *bounds))
		*state |= NK_WIDGET_STATE_LEFT;
	return value_changed;
}

NK_LIB void
nk_draw_color_picker(struct nk_command_buffer* o, const struct nk_rect* matrix, const struct nk_rect* hue_bar,
	const struct nk_rect* alpha_bar, struct nk_colorf col) {
	NK_STORAGE const struct nk_color black = { 0, 0, 0, 255 };
	NK_STORAGE const struct nk_color white = { 255, 255, 255, 255 };
	NK_STORAGE const struct nk_color black_trans = { 0, 0, 0, 0 };

	const float crosshair_size = 7.0f;
	struct nk_color temp;
	float hsva[4];
	float line_y;
	int i;

	NK_ASSERT(o);
	NK_ASSERT(matrix);
	NK_ASSERT(hue_bar);

	/* draw hue bar */
	nk_colorf_hsva_fv(hsva, col);
	for (i = 0; i < 6; ++i) {
		NK_GLOBAL const struct nk_color hue_colors[] = { {255, 0,   0,   255},
														{255, 255, 0,   255},
														{0,   255, 0,   255},
														{0,   255, 255, 255},
														{0,   0,   255, 255},
														{255, 0,   255, 255},
														{255, 0,   0,   255} };
		nk_fill_rect_multi_color(o, nk_rect(hue_bar->x, hue_bar->y + (float)i * (hue_bar->h / 6.0f) + 0.5f, hue_bar->w,
			(hue_bar->h / 6.0f) + 0.5f), hue_colors[i], hue_colors[i],
			hue_colors[i + 1], hue_colors[i + 1]);
	}
	line_y = (float)(int)(hue_bar->y + hsva[0] * matrix->h + 0.5f);
	nk_stroke_line(o, hue_bar->x - 1, line_y, hue_bar->x + hue_bar->w + 2, line_y, 1, nk_rgb(255, 255, 255));

	/* draw alpha bar */
	if (alpha_bar) {
		float alpha = NK_SATURATE(col.a);
		line_y = (float)(int)(alpha_bar->y + (1.0f - alpha) * matrix->h + 0.5f);

		nk_fill_rect_multi_color(o, *alpha_bar, white, white, black, black);
		nk_stroke_line(o, alpha_bar->x - 1, line_y, alpha_bar->x + alpha_bar->w + 2, line_y, 1, nk_rgb(255, 255, 255));
	}

	/* draw color matrix */
	temp = nk_hsv_f(hsva[0], 1.0f, 1.0f);
	nk_fill_rect_multi_color(o, *matrix, white, temp, temp, white);
	nk_fill_rect_multi_color(o, *matrix, black_trans, black_trans, black, black);

	/* draw cross-hair */
	{
		struct nk_vec2 p;
		float S = hsva[1];
		float V = hsva[2];
		p.x = (float)(int)(matrix->x + S * matrix->w);
		p.y = (float)(int)(matrix->y + (1.0f - V) * matrix->h);
		nk_stroke_line(o, p.x - crosshair_size, p.y, p.x - 2, p.y, 1.0f, white);
		nk_stroke_line(o, p.x + crosshair_size + 1, p.y, p.x + 3, p.y, 1.0f, white);
		nk_stroke_line(o, p.x, p.y + crosshair_size + 1, p.x, p.y + 3, 1.0f, white);
		nk_stroke_line(o, p.x, p.y - crosshair_size, p.x, p.y - 2, 1.0f, white);
	}
}

NK_LIB int
nk_do_color_picker(nk_flags* state, struct nk_command_buffer* out, struct nk_colorf* col, enum nk_color_format fmt,
	struct nk_rect bounds, struct nk_vec2 padding, const struct nk_input* in,
	const struct nk_user_font* font) {
	int ret = 0;
	struct nk_rect matrix;
	struct nk_rect hue_bar;
	struct nk_rect alpha_bar;
	float bar_w;

	NK_ASSERT(out);
	NK_ASSERT(col);
	NK_ASSERT(state);
	NK_ASSERT(font);
	if (!out || !col || !state || !font)
		return ret;

	bar_w = font->height;
	bounds.x += padding.x;
	bounds.y += padding.x;
	bounds.w -= 2 * padding.x;
	bounds.h -= 2 * padding.y;

	matrix.x = bounds.x;
	matrix.y = bounds.y;
	matrix.h = bounds.h;
	matrix.w = bounds.w - (3 * padding.x + 2 * bar_w);

	hue_bar.w = bar_w;
	hue_bar.y = bounds.y;
	hue_bar.h = matrix.h;
	hue_bar.x = matrix.x + matrix.w + padding.x;

	alpha_bar.x = hue_bar.x + hue_bar.w + padding.x;
	alpha_bar.y = bounds.y;
	alpha_bar.w = bar_w;
	alpha_bar.h = matrix.h;

	ret = nk_color_picker_behavior(state, &bounds, &matrix, &hue_bar, (fmt == NK_RGBA) ? &alpha_bar : 0, col, in);
	nk_draw_color_picker(out, &matrix, &hue_bar, (fmt == NK_RGBA) ? &alpha_bar : 0, *col);
	return ret;
}

NK_API int nk_color_pick(struct nk_context* ctx, struct nk_colorf* color, enum nk_color_format fmt) {
	struct nk_window* win;
	struct nk_panel* layout;
	const struct nk_style* config;
	const struct nk_input* in;

	enum nk_widget_layout_states state;
	struct nk_rect bounds;

	NK_ASSERT(ctx);
	NK_ASSERT(color);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !color)
		return 0;

	win = ctx->current;
	config = &ctx->style;
	layout = win->layout;
	state = nk_widget(&bounds, ctx);
	if (!state) return 0;
	in = (state == NK_WIDGET_ROM || layout->flags & NK_WINDOW_ROM) ? 0 : &ctx->input;
	return nk_do_color_picker(&ctx->last_widget_state, &win->buffer, color, fmt, bounds, nk_vec2(0, 0), in,
		config->font);
}

NK_API struct nk_colorf nk_color_picker(struct nk_context* ctx, struct nk_colorf color, enum nk_color_format fmt) {
	nk_color_pick(ctx, &color, fmt);
	return color;
}





/* ==============================================================
 *
 *                          COMBO
 *
 * ===============================================================*/
NK_INTERN int nk_combo_begin(struct nk_context* ctx, struct nk_window* win, struct nk_vec2 size, int is_clicked,
	struct nk_rect header) {
	struct nk_window* popup;
	int is_open = 0;
	int is_active = 0;
	struct nk_rect body;
	nk_hash hash;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	popup = win->popup.win;
	body.x = header.x;
	body.w = size.x;
	body.y = header.y + header.h - ctx->style.window.combo_border;
	body.h = size.y;

	hash = win->popup.combo_count++;
	is_open = (popup) ? nk_true : nk_false;
	is_active = (popup && (win->popup.name == hash) && win->popup.type == NK_PANEL_COMBO);
	if ((is_clicked && is_open && !is_active) || (is_open && !is_active) ||
		(!is_open && !is_active && !is_clicked))
		return 0;
	if (!nk_nonblock_begin(ctx, 0, body, (is_clicked && is_open) ? nk_rect(0, 0, 0, 0) : header, NK_PANEL_COMBO))
		return 0;

	win->popup.type = NK_PANEL_COMBO;
	win->popup.name = hash;
	return 1;
}

NK_API int nk_combo_begin_text(struct nk_context* ctx, const char* selected, int len, struct nk_vec2 size) {
	const struct nk_input* in;
	struct nk_window* win;
	struct nk_style* style;

	enum nk_widget_layout_states s;
	int is_clicked = nk_false;
	struct nk_rect header;
	const struct nk_style_item* background;
	struct nk_text text;

	NK_ASSERT(ctx);
	NK_ASSERT(selected);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout || !selected)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (s == NK_WIDGET_INVALID)
		return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->combo.active;
		text.text = style->combo.label_active;
	}
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
		background = &style->combo.hover;
		text.text = style->combo.label_hover;
	}
	else {
		background = &style->combo.normal;
		text.text = style->combo.label_normal;
	}
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		text.background = nk_rgba(0, 0, 0, 0);
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		text.background = background->data.color;
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		/* print currently selected text item */
		struct nk_rect label;
		struct nk_rect button;
		struct nk_rect content;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;

		/* draw selected label */
		text.padding = nk_vec2(0, 0);
		label.x = header.x + style->combo.content_padding.x;
		label.y = header.y + style->combo.content_padding.y;
		label.w = button.x - (style->combo.content_padding.x + style->combo.spacing.x) - label.x;;
		label.h = header.h - 2 * style->combo.content_padding.y;
		nk_widget_text(&win->buffer, label, selected, len, &text, NK_TEXT_LEFT, ctx->style.font);

		/* draw open/close button */
		nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_label(struct nk_context* ctx, const char* selected, struct nk_vec2 size) {
	return nk_combo_begin_text(ctx, selected, nk_strlen(selected), size);
}

NK_API int nk_combo_begin_color(struct nk_context* ctx, struct nk_color color, struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_style* style;
	const struct nk_input* in;

	struct nk_rect header;
	int is_clicked = nk_false;
	enum nk_widget_layout_states s;
	const struct nk_style_item* background;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (s == NK_WIDGET_INVALID)
		return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED)
		background = &style->combo.active;
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
		background = &style->combo.hover;
	else background = &style->combo.normal;

	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		struct nk_rect content;
		struct nk_rect button;
		struct nk_rect bounds;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;

		/* draw color */
		bounds.h = header.h - 4 * style->combo.content_padding.y;
		bounds.y = header.y + 2 * style->combo.content_padding.y;
		bounds.x = header.x + 2 * style->combo.content_padding.x;
		bounds.w = (button.x - (style->combo.content_padding.x + style->combo.spacing.x)) - bounds.x;
		nk_fill_rect(&win->buffer, bounds, 0, color);

		/* draw open/close button */
		nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_symbol(struct nk_context* ctx, enum nk_symbol_type symbol, struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_style* style;
	const struct nk_input* in;

	struct nk_rect header;
	int is_clicked = nk_false;
	enum nk_widget_layout_states s;
	const struct nk_style_item* background;
	struct nk_color sym_background;
	struct nk_color symbol_color;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (s == NK_WIDGET_INVALID)
		return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->combo.active;
		symbol_color = style->combo.symbol_active;
	}
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
		background = &style->combo.hover;
		symbol_color = style->combo.symbol_hover;
	}
	else {
		background = &style->combo.normal;
		symbol_color = style->combo.symbol_hover;
	}

	if (background->type == NK_STYLE_ITEM_IMAGE) {
		sym_background = nk_rgba(0, 0, 0, 0);
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		sym_background = background->data.color;
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		struct nk_rect bounds = { 0, 0, 0, 0 };
		struct nk_rect content;
		struct nk_rect button;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.y;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;

		/* draw symbol */
		bounds.h = header.h - 2 * style->combo.content_padding.y;
		bounds.y = header.y + style->combo.content_padding.y;
		bounds.x = header.x + style->combo.content_padding.x;
		bounds.w = (button.x - style->combo.content_padding.y) - bounds.x;
		nk_draw_symbol(&win->buffer, symbol, bounds, sym_background, symbol_color, 1.0f, style->font);

		/* draw open/close button */
		nk_draw_button_symbol(&win->buffer, &bounds, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_symbol_text(struct nk_context* ctx, const char* selected, int len, enum nk_symbol_type symbol,
	struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_style* style;
	struct nk_input* in;

	struct nk_rect header;
	int is_clicked = nk_false;
	enum nk_widget_layout_states s;
	const struct nk_style_item* background;
	struct nk_color symbol_color;
	struct nk_text text;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (!s) return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->combo.active;
		symbol_color = style->combo.symbol_active;
		text.text = style->combo.label_active;
	}
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
		background = &style->combo.hover;
		symbol_color = style->combo.symbol_hover;
		text.text = style->combo.label_hover;
	}
	else {
		background = &style->combo.normal;
		symbol_color = style->combo.symbol_normal;
		text.text = style->combo.label_normal;
	}
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		text.background = nk_rgba(0, 0, 0, 0);
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		text.background = background->data.color;
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		struct nk_rect content;
		struct nk_rect button;
		struct nk_rect label;
		struct nk_rect image;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;
		nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);

		/* draw symbol */
		image.x = header.x + style->combo.content_padding.x;
		image.y = header.y + style->combo.content_padding.y;
		image.h = header.h - 2 * style->combo.content_padding.y;
		image.w = image.h;
		nk_draw_symbol(&win->buffer, symbol, image, text.background, symbol_color, 1.0f, style->font);

		/* draw label */
		text.padding = nk_vec2(0, 0);
		label.x = image.x + image.w + style->combo.spacing.x + style->combo.content_padding.x;
		label.y = header.y + style->combo.content_padding.y;
		label.w = (button.x - style->combo.content_padding.x) - label.x;
		label.h = header.h - 2 * style->combo.content_padding.y;
		nk_widget_text(&win->buffer, label, selected, len, &text, NK_TEXT_LEFT, style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_image(struct nk_context* ctx, struct nk_image img, struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_style* style;
	const struct nk_input* in;

	struct nk_rect header;
	int is_clicked = nk_false;
	enum nk_widget_layout_states s;
	const struct nk_style_item* background;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (s == NK_WIDGET_INVALID)
		return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED)
		background = &style->combo.active;
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
		background = &style->combo.hover;
	else background = &style->combo.normal;

	if (background->type == NK_STYLE_ITEM_IMAGE) {
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		struct nk_rect bounds = { 0, 0, 0, 0 };
		struct nk_rect content;
		struct nk_rect button;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.y;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;

		/* draw image */
		bounds.h = header.h - 2 * style->combo.content_padding.y;
		bounds.y = header.y + style->combo.content_padding.y;
		bounds.x = header.x + style->combo.content_padding.x;
		bounds.w = (button.x - style->combo.content_padding.y) - bounds.x;
		nk_draw_image(&win->buffer, bounds, &img, nk_white);

		/* draw open/close button */
		nk_draw_button_symbol(&win->buffer, &bounds, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_image_text(struct nk_context* ctx, const char* selected, int len, struct nk_image img,
	struct nk_vec2 size) {
	struct nk_window* win;
	struct nk_style* style;
	struct nk_input* in;

	struct nk_rect header;
	int is_clicked = nk_false;
	enum nk_widget_layout_states s;
	const struct nk_style_item* background;
	struct nk_text text;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	win = ctx->current;
	style = &ctx->style;
	s = nk_widget(&header, ctx);
	if (!s) return 0;

	in = (win->layout->flags & NK_WINDOW_ROM || s == NK_WIDGET_ROM) ? 0 : &ctx->input;
	if (nk_button_behavior(&ctx->last_widget_state, header, in, NK_BUTTON_DEFAULT))
		is_clicked = nk_true;

	/* draw combo box header background and border */
	if (ctx->last_widget_state & NK_WIDGET_STATE_ACTIVED) {
		background = &style->combo.active;
		text.text = style->combo.label_active;
	}
	else if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER) {
		background = &style->combo.hover;
		text.text = style->combo.label_hover;
	}
	else {
		background = &style->combo.normal;
		text.text = style->combo.label_normal;
	}
	if (background->type == NK_STYLE_ITEM_IMAGE) {
		text.background = nk_rgba(0, 0, 0, 0);
		nk_draw_image(&win->buffer, header, &background->data.image, nk_white);
	}
	else {
		text.background = background->data.color;
		nk_fill_rect(&win->buffer, header, style->combo.rounding, background->data.color);
		nk_stroke_rect(&win->buffer, header, style->combo.rounding, style->combo.border, style->combo.border_color);
	}
	{
		struct nk_rect content;
		struct nk_rect button;
		struct nk_rect label;
		struct nk_rect image;

		enum nk_symbol_type sym;
		if (ctx->last_widget_state & NK_WIDGET_STATE_HOVER)
			sym = style->combo.sym_hover;
		else if (is_clicked)
			sym = style->combo.sym_active;
		else sym = style->combo.sym_normal;

		/* calculate button */
		button.w = header.h - 2 * style->combo.button_padding.y;
		button.x = (header.x + header.w - header.h) - style->combo.button_padding.x;
		button.y = header.y + style->combo.button_padding.y;
		button.h = button.w;

		content.x = button.x + style->combo.button.padding.x;
		content.y = button.y + style->combo.button.padding.y;
		content.w = button.w - 2 * style->combo.button.padding.x;
		content.h = button.h - 2 * style->combo.button.padding.y;
		nk_draw_button_symbol(&win->buffer, &button, &content, ctx->last_widget_state, &ctx->style.combo.button, sym,
			style->font);

		/* draw image */
		image.x = header.x + style->combo.content_padding.x;
		image.y = header.y + style->combo.content_padding.y;
		image.h = header.h - 2 * style->combo.content_padding.y;
		image.w = image.h;
		nk_draw_image(&win->buffer, image, &img, nk_white);

		/* draw label */
		text.padding = nk_vec2(0, 0);
		label.x = image.x + image.w + style->combo.spacing.x + style->combo.content_padding.x;
		label.y = header.y + style->combo.content_padding.y;
		label.w = (button.x - style->combo.content_padding.x) - label.x;
		label.h = header.h - 2 * style->combo.content_padding.y;
		nk_widget_text(&win->buffer, label, selected, len, &text, NK_TEXT_LEFT, style->font);
	}
	return nk_combo_begin(ctx, win, size, is_clicked, header);
}

NK_API int nk_combo_begin_symbol_label(struct nk_context* ctx, const char* selected, enum nk_symbol_type type,
	struct nk_vec2 size) {
	return nk_combo_begin_symbol_text(ctx, selected, nk_strlen(selected), type, size);
}

NK_API int
nk_combo_begin_image_label(struct nk_context* ctx, const char* selected, struct nk_image img, struct nk_vec2 size) {
	return nk_combo_begin_image_text(ctx, selected, nk_strlen(selected), img, size);
}

NK_API int nk_combo_item_text(struct nk_context* ctx, const char* text, int len, nk_flags align) {
	return nk_contextual_item_text(ctx, text, len, align);
}

NK_API int nk_combo_item_label(struct nk_context* ctx, const char* label, nk_flags align) {
	return nk_contextual_item_label(ctx, label, align);
}

NK_API int
nk_combo_item_image_text(struct nk_context* ctx, struct nk_image img, const char* text, int len, nk_flags alignment) {
	return nk_contextual_item_image_text(ctx, img, text, len, alignment);
}

NK_API int
nk_combo_item_image_label(struct nk_context* ctx, struct nk_image img, const char* text, nk_flags alignment) {
	return nk_contextual_item_image_label(ctx, img, text, alignment);
}

NK_API int nk_combo_item_symbol_text(struct nk_context* ctx, enum nk_symbol_type sym, const char* text, int len,
	nk_flags alignment) {
	return nk_contextual_item_symbol_text(ctx, sym, text, len, alignment);
}

NK_API int
nk_combo_item_symbol_label(struct nk_context* ctx, enum nk_symbol_type sym, const char* label, nk_flags alignment) {
	return nk_contextual_item_symbol_label(ctx, sym, label, alignment);
}

NK_API void nk_combo_end(struct nk_context* ctx) {
	nk_contextual_end(ctx);
}

NK_API void nk_combo_close(struct nk_context* ctx) {
	nk_contextual_close(ctx);
}

NK_API int
nk_combo(struct nk_context* ctx, const char** items, int count, int selected, int item_height, struct nk_vec2 size) {
	int i = 0;
	int max_height;
	struct nk_vec2 item_spacing;
	struct nk_vec2 window_padding;

	NK_ASSERT(ctx);
	NK_ASSERT(items);
	NK_ASSERT(ctx->current);
	if (!ctx || !items || !count)
		return selected;

	item_spacing = ctx->style.window.spacing;
	window_padding = nk_panel_get_padding(&ctx->style, ctx->current->layout->type);
	max_height = count * item_height + count * (int)item_spacing.y;
	max_height += (int)item_spacing.y * 2 + (int)window_padding.y * 2;
	size.y = NK_MIN(size.y, (float)max_height);
	if (nk_combo_begin_label(ctx, items[selected], size)) {
		nk_layout_row_dynamic(ctx, (float)item_height, 1);
		for (i = 0; i < count; ++i) {
			if (nk_combo_item_label(ctx, items[i], NK_TEXT_LEFT))
				selected = i;
		}
		nk_combo_end(ctx);
	}
	return selected;
}

NK_API int
nk_combo_separator(struct nk_context* ctx, const char* items_separated_by_separator, int separator, int selected,
	int count, int item_height, struct nk_vec2 size) {
	int i;
	int max_height;
	struct nk_vec2 item_spacing;
	struct nk_vec2 window_padding;
	const char* current_item;
	const char* iter;
	int length = 0;

	NK_ASSERT(ctx);
	NK_ASSERT(items_separated_by_separator);
	if (!ctx || !items_separated_by_separator)
		return selected;

	/* calculate popup window */
	item_spacing = ctx->style.window.spacing;
	window_padding = nk_panel_get_padding(&ctx->style, ctx->current->layout->type);
	max_height = count * item_height + count * (int)item_spacing.y;
	max_height += (int)item_spacing.y * 2 + (int)window_padding.y * 2;
	size.y = NK_MIN(size.y, (float)max_height);

	/* find selected item */
	current_item = items_separated_by_separator;
	for (i = 0; i < count; ++i) {
		iter = current_item;
		while (*iter && *iter != separator) iter++;
		length = (int)(iter - current_item);
		if (i == selected) break;
		current_item = iter + 1;
	}

	if (nk_combo_begin_text(ctx, current_item, length, size)) {
		current_item = items_separated_by_separator;
		nk_layout_row_dynamic(ctx, (float)item_height, 1);
		for (i = 0; i < count; ++i) {
			iter = current_item;
			while (*iter && *iter != separator) iter++;
			length = (int)(iter - current_item);
			if (nk_combo_item_text(ctx, current_item, length, NK_TEXT_LEFT))
				selected = i;
			current_item = current_item + length + 1;
		}
		nk_combo_end(ctx);
	}
	return selected;
}

NK_API int
nk_combo_string(struct nk_context* ctx, const char* items_separated_by_zeros, int selected, int count, int item_height,
	struct nk_vec2 size) {
	return nk_combo_separator(ctx, items_separated_by_zeros, '\0', selected, count, item_height, size);
}

NK_API int
nk_combo_callback(struct nk_context* ctx, void(*item_getter)(void*, int, const char**), void* userdata, int selected,
	int count, int item_height, struct nk_vec2 size) {
	int i;
	int max_height;
	struct nk_vec2 item_spacing;
	struct nk_vec2 window_padding;
	const char* item;

	NK_ASSERT(ctx);
	NK_ASSERT(item_getter);
	if (!ctx || !item_getter)
		return selected;

	/* calculate popup window */
	item_spacing = ctx->style.window.spacing;
	window_padding = nk_panel_get_padding(&ctx->style, ctx->current->layout->type);
	max_height = count * item_height + count * (int)item_spacing.y;
	max_height += (int)item_spacing.y * 2 + (int)window_padding.y * 2;
	size.y = NK_MIN(size.y, (float)max_height);

	item_getter(userdata, selected, &item);
	if (nk_combo_begin_label(ctx, item, size)) {
		nk_layout_row_dynamic(ctx, (float)item_height, 1);
		for (i = 0; i < count; ++i) {
			item_getter(userdata, i, &item);
			if (nk_combo_item_label(ctx, item, NK_TEXT_LEFT))
				selected = i;
		}
		nk_combo_end(ctx);
	}
	return selected;
}

NK_API void nk_combobox(struct nk_context* ctx, const char** items, int count, int* selected, int item_height,
	struct nk_vec2 size) {
	*selected = nk_combo(ctx, items, count, *selected, item_height, size);
}

NK_API void nk_combobox_string(struct nk_context* ctx, const char* items_separated_by_zeros, int* selected, int count,
	int item_height, struct nk_vec2 size) {
	*selected = nk_combo_string(ctx, items_separated_by_zeros, *selected, count, item_height, size);
}

NK_API void
nk_combobox_separator(struct nk_context* ctx, const char* items_separated_by_separator, int separator, int* selected,
	int count, int item_height, struct nk_vec2 size) {
	*selected = nk_combo_separator(ctx, items_separated_by_separator, separator, *selected, count, item_height, size);
}

NK_API void nk_combobox_callback(struct nk_context* ctx, void(*item_getter)(void* data, int id, const char** out_text),
	void* userdata, int* selected, int count, int item_height, struct nk_vec2 size) {
	*selected = nk_combo_callback(ctx, item_getter, userdata, *selected, count, item_height, size);
}





/* ===============================================================
 *
 *                              TOOLTIP
 *
 * ===============================================================*/
NK_API int nk_tooltip_begin(struct nk_context* ctx, float width) {
	int x, y, w, h;
	struct nk_window* win;
	const struct nk_input* in;
	struct nk_rect bounds;
	int ret;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	if (!ctx || !ctx->current || !ctx->current->layout)
		return 0;

	/* make sure that no nonblocking popup is currently active */
	win = ctx->current;
	in = &ctx->input;
	if (win->popup.win && (win->popup.type & NK_PANEL_SET_NONBLOCK))
		return 0;

	w = nk_iceilf(width);
	h = nk_iceilf(nk_null_rect.h);
	x = nk_ifloorf(in->mouse.pos.x + 1) - (int)win->layout->clip.x;
	y = nk_ifloorf(in->mouse.pos.y + 1) - (int)win->layout->clip.y;

	bounds.x = (float)x;
	bounds.y = (float)y;
	bounds.w = (float)w;
	bounds.h = (float)h;

	ret = nk_popup_begin(ctx, NK_POPUP_DYNAMIC, "__##Tooltip##__", NK_WINDOW_NO_SCROLLBAR | NK_WINDOW_BORDER, bounds);
	if (ret) win->layout->flags &= ~(nk_flags)NK_WINDOW_ROM;
	win->popup.type = NK_PANEL_TOOLTIP;
	ctx->current->layout->type = NK_PANEL_TOOLTIP;
	return ret;
}

NK_API void nk_tooltip_end(struct nk_context* ctx) {
	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	if (!ctx || !ctx->current) return;
	ctx->current->seq--;
	nk_popup_close(ctx);
	nk_popup_end(ctx);
}

NK_API void nk_tooltip(struct nk_context* ctx, const char* text) {
	const struct nk_style* style;
	struct nk_vec2 padding;

	int text_len;
	float text_width;
	float text_height;

	NK_ASSERT(ctx);
	NK_ASSERT(ctx->current);
	NK_ASSERT(ctx->current->layout);
	NK_ASSERT(text);
	if (!ctx || !ctx->current || !ctx->current->layout || !text)
		return;

	/* fetch configuration data */
	style = &ctx->style;
	padding = style->window.padding;

	/* calculate size of the text and tooltip */
	text_len = nk_strlen(text);
	text_width = style->font->width(style->font->userdata, style->font->height, text, text_len);
	text_width += (4 * padding.x);
	text_height = (style->font->height + 2 * padding.y);

	/* execute tooltip and fill with text */
	if (nk_tooltip_begin(ctx, (float)text_width)) {
		nk_layout_row_dynamic(ctx, (float)text_height, 1);
		nk_text(ctx, text, text_len, NK_TEXT_LEFT);
		nk_tooltip_end(ctx);
	}
}

#ifdef NK_INCLUDE_STANDARD_VARARGS

NK_API void nk_tooltipf(struct nk_context* ctx, const char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	nk_tooltipfv(ctx, fmt, args);
	va_end(args);
}

NK_API void nk_tooltipfv(struct nk_context* ctx, const char* fmt, va_list args) {
	char buf[256];
	nk_strfmt(buf, NK_LEN(buf), fmt, args);
	nk_tooltip(ctx, buf);
}

#endif


#endif /* NK_IMPLEMENTATION */

/*
/// ## License
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~none
///    ------------------------------------------------------------------------------
///    This software is available under 2 licenses -- choose whichever you prefer.
///    ------------------------------------------------------------------------------
///    ALTERNATIVE A - MIT License
///    Copyright (c) 2016-2018 Micha Mettke
///    Permission is hereby granted, free of charge, to any person obtaining a copy of
///    this software and associated documentation files (the "Software"), to deal in
///    the Software without restriction, including without limitation the rights to
///    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
///    of the Software, and to permit persons to whom the Software is furnished to do
///    so, subject to the following conditions:
///    The above copyright notice and this permission notice shall be included in all
///    copies or substantial portions of the Software.
///    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
///    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
///    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
///    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
///    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
///    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
///    SOFTWARE.
///    ------------------------------------------------------------------------------
///    ALTERNATIVE B - Public Domain (www.unlicense.org)
///    This is free and unencumbered software released into the public domain.
///    Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
///    software, either in source code form or as a compiled binary, for any purpose,
///    commercial or non-commercial, and by any means.
///    In jurisdictions that recognize copyright laws, the author or authors of this
///    software dedicate any and all copyright interest in the software to the public
///    domain. We make this dedication for the benefit of the public at large and to
///    the detriment of our heirs and successors. We intend this dedication to be an
///    overt act of relinquishment in perpetuity of all present and future rights to
///    this software under copyright law.
///    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
///    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
///    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
///    AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
///    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
///    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///    ------------------------------------------------------------------------------
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/// ## Changelog
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~none
/// [date][x.yy.zz]-[description]
/// -[date]: date on which the change has been pushed
/// -[x.yy.zz]: Numerical version string representation. Each version number on the right
///             resets back to zero if version on the left is incremented.
///    - [x]: Major version with API and library breaking changes
///    - [yy]: Minor version with non-breaking API and library changes
///    - [zz]: Bug fix version with no direct changes to API
///
/// - 2018/04/01 (4.00.1) - Fixed calling `nk_convert` multiple time per single frame
/// - 2018/04/01 (4.00.0) - BREAKING CHANGE: nk_draw_list_clear no longer tries to
///                         clear provided buffers. So make sure to either free
///                         or clear each passed buffer after calling nk_convert.
/// - 2018/02/23 (3.00.6) - Fixed slider dragging behavior
/// - 2018/01/31 (3.00.5) - Fixed overcalculation of cursor data in font baking process
/// - 2018/01/31 (3.00.4) - Removed name collision with stb_truetype
/// - 2018/01/28 (3.00.3) - Fixed panel window border drawing bug
/// - 2018/01/12 (3.00.2) - Added `nk_group_begin_titled` for separed group identifier and title
/// - 2018/01/07 (3.00.1) - Started to change documentation style
/// - 2018/01/05 (3.00.0) - BREAKING CHANGE: The previous color picker API was broken
///                        because of conversions between float and byte color representation.
///                        Color pickers now use floating point values to represent
///                        HSV values. To get back the old behavior I added some additional
///                        color conversion functions to cast between nk_color and
///                        nk_colorf.
/// - 2017/12/23 (2.00.7) - Fixed small warning
/// - 2017/12/23 (2.00.7) - Fixed nk_edit_buffer behavior if activated to allow input
/// - 2017/12/23 (2.00.7) - Fixed modifyable progressbar dragging visuals and input behavior
/// - 2017/12/04 (2.00.6) - Added formated string tooltip widget
/// - 2017/11/18 (2.00.5) - Fixed window becoming hidden with flag NK_WINDOW_NO_INPUT
/// - 2017/11/15 (2.00.4) - Fixed font merging
/// - 2017/11/07 (2.00.3) - Fixed window size and position modifier functions
/// - 2017/09/14 (2.00.2) - Fixed nk_edit_buffer and nk_edit_focus behavior
/// - 2017/09/14 (2.00.1) - Fixed window closing behavior
/// - 2017/09/14 (2.00.0) - BREAKING CHANGE: Modifing window position and size funtions now
///                        require the name of the window and must happen outside the window
///                        building process (between function call nk_begin and nk_end).
/// - 2017/09/11 (1.40.9) - Fixed window background flag if background window is declared last
/// - 2017/08/27 (1.40.8) - Fixed `nk_item_is_any_active` for hidden windows
/// - 2017/08/27 (1.40.7) - Fixed window background flag
/// - 2017/07/07 (1.40.6) - Fixed missing clipping rect check for hovering/clicked
///                        query for widgets
/// - 2017/07/07 (1.40.5) - Fixed drawing bug for vertex output for lines and stroked
///                        and filled rectangles
/// - 2017/07/07 (1.40.4) - Fixed bug in nk_convert trying to add windows that are in
///                        process of being destroyed.
/// - 2017/07/07 (1.40.3) - Fixed table internal bug caused by storing table size in
///                        window instead of directly in table.
/// - 2017/06/30 (1.40.2) - Removed unneeded semicolon in C++ NK_ALIGNOF macro
/// - 2017/06/30 (1.40.1) - Fixed drawing lines smaller or equal zero
/// - 2017/06/08 (1.40.0) - Removed the breaking part of last commit. Auto layout now only
///                        comes in effect if you pass in zero was row height argument
/// - 2017/06/08 (1.40.0) - BREAKING CHANGE: while not directly API breaking it will change
///                        how layouting works. From now there will be an internal minimum
///                        row height derived from font height. If you need a row smaller than
///                        that you can directly set it by `nk_layout_set_min_row_height` and
///                        reset the value back by calling `nk_layout_reset_min_row_height.
/// - 2017/06/08 (1.39.1) - Fixed property text edit handling bug caused by past `nk_widget` fix
/// - 2017/06/08 (1.39.0) - Added function to retrieve window space without calling a nk_layout_xxx function
/// - 2017/06/06 (1.38.5) - Fixed `nk_convert` return flag for command buffer
/// - 2017/05/23 (1.38.4) - Fixed activation behavior for widgets partially clipped
/// - 2017/05/10 (1.38.3) - Fixed wrong min window size mouse scaling over boundries
/// - 2017/05/09 (1.38.2) - Fixed vertical scrollbar drawing with not enough space
/// - 2017/05/09 (1.38.1) - Fixed scaler dragging behavior if window size hits minimum size
/// - 2017/05/06 (1.38.0) - Added platform double-click support
/// - 2017/04/20 (1.37.1) - Fixed key repeat found inside glfw demo backends
/// - 2017/04/20 (1.37.0) - Extended properties with selection and clipbard support
/// - 2017/04/20 (1.36.2) - Fixed #405 overlapping rows with zero padding and spacing
/// - 2017/04/09 (1.36.1) - Fixed #403 with another widget float error
/// - 2017/04/09 (1.36.0) - Added window `NK_WINDOW_NO_INPUT` and `NK_WINDOW_NOT_INTERACTIVE` flags
/// - 2017/04/09 (1.35.3) - Fixed buffer heap corruption
/// - 2017/03/25 (1.35.2) - Fixed popup overlapping for `NK_WINDOW_BACKGROUND` windows
/// - 2017/03/25 (1.35.1) - Fixed windows closing behavior
/// - 2017/03/18 (1.35.0) - Added horizontal scroll requested in #377
/// - 2017/03/18 (1.34.3) - Fixed long window header titles
/// - 2017/03/04 (1.34.2) - Fixed text edit filtering
/// - 2017/03/04 (1.34.1) - Fixed group closable flag
/// - 2017/02/25 (1.34.0) - Added custom draw command for better language binding support
/// - 2017/01/24 (1.33.0) - Added programatic way of remove edit focus
/// - 2017/01/24 (1.32.3) - Fixed wrong define for basic type definitions for windows
/// - 2017/01/21 (1.32.2) - Fixed input capture from hidden or closed windows
/// - 2017/01/21 (1.32.1) - Fixed slider behavior and drawing
/// - 2017/01/13 (1.32.0) - Added flag to put scaler into the bottom left corner
/// - 2017/01/13 (1.31.0) - Added additional row layouting method to combine both
///                        dynamic and static widgets.
/// - 2016/12/31 (1.30.0) - Extended scrollbar offset from 16-bit to 32-bit
/// - 2016/12/31 (1.29.2)- Fixed closing window bug of minimized windows
/// - 2016/12/03 (1.29.1)- Fixed wrapped text with no seperator and C89 error
/// - 2016/12/03 (1.29.0) - Changed text wrapping to process words not characters
/// - 2016/11/22 (1.28.6)- Fixed window minimized closing bug
/// - 2016/11/19 (1.28.5)- Fixed abstract combo box closing behavior
/// - 2016/11/19 (1.28.4)- Fixed tooltip flickering
/// - 2016/11/19 (1.28.3)- Fixed memory leak caused by popup repeated closing
/// - 2016/11/18 (1.28.2)- Fixed memory leak caused by popup panel allocation
/// - 2016/11/10 (1.28.1)- Fixed some warnings and C++ error
/// - 2016/11/10 (1.28.0)- Added additional `nk_button` versions which allows to directly
///                        pass in a style struct to change buttons visual.
/// - 2016/11/10 (1.27.0)- Added additional 'nk_tree' versions to support external state
///                        storage. Just like last the `nk_group` commit the main
///                        advantage is that you optionally can minimize nuklears runtime
///                        memory consumption or handle hash collisions.
/// - 2016/11/09 (1.26.0)- Added additional `nk_group` version to support external scrollbar
///                        offset storage. Main advantage is that you can externalize
///                        the memory management for the offset. It could also be helpful
///                        if you have a hash collision in `nk_group_begin` but really
///                        want the name. In addition I added `nk_list_view` which allows
///                        to draw big lists inside a group without actually having to
///                        commit the whole list to nuklear (issue #269).
/// - 2016/10/30 (1.25.1)- Fixed clipping rectangle bug inside `nk_draw_list`
/// - 2016/10/29 (1.25.0)- Pulled `nk_panel` memory management into nuklear and out of
///                        the hands of the user. From now on users don't have to care
///                        about panels unless they care about some information. If you
///                        still need the panel just call `nk_window_get_panel`.
/// - 2016/10/21 (1.24.0)- Changed widget border drawing to stroked rectangle from filled
///                        rectangle for less overdraw and widget background transparency.
/// - 2016/10/18 (1.23.0)- Added `nk_edit_focus` for manually edit widget focus control
/// - 2016/09/29 (1.22.7)- Fixed deduction of basic type in non `<stdint.h>` compilation
/// - 2016/09/29 (1.22.6)- Fixed edit widget UTF-8 text cursor drawing bug
/// - 2016/09/28 (1.22.5)- Fixed edit widget UTF-8 text appending/inserting/removing
/// - 2016/09/28 (1.22.4)- Fixed drawing bug inside edit widgets which offset all text
///                        text in every edit widget if one of them is scrolled.
/// - 2016/09/28 (1.22.3)- Fixed small bug in edit widgets if not active. The wrong
///                        text length is passed. It should have been in bytes but
///                        was passed as glyphes.
/// - 2016/09/20 (1.22.2)- Fixed color button size calculation
/// - 2016/09/20 (1.22.1)- Fixed some `nk_vsnprintf` behavior bugs and removed
///                        `<stdio.h>` again from `NK_INCLUDE_STANDARD_VARARGS`.
/// - 2016/09/18 (1.22.0)- C89 does not support vsnprintf only C99 and newer as well
///                        as C++11 and newer. In addition to use vsnprintf you have
///                        to include <stdio.h>. So just defining `NK_INCLUDE_STD_VAR_ARGS`
///                        is not enough. That behavior is now fixed. By default if
///                        both varargs as well as stdio is selected I try to use
///                        vsnprintf if not possible I will revert to vsprintf. If
///                        varargs but not stdio was defined I will use my own function.
/// - 2016/09/15 (1.21.2)- Fixed panel `close` behavior for deeper panel levels
/// - 2016/09/15 (1.21.1)- Fixed C++ errors and wrong argument to `nk_panel_get_xxxx`
/// - 2016/09/13 (1.21.0) - !BREAKING! Fixed nonblocking popup behavior in menu, combo,
///                        and contextual which prevented closing in y-direction if
///                        popup did not reach max height.
///                        In addition the height parameter was changed into vec2
///                        for width and height to have more control over the popup size.
/// - 2016/09/13 (1.20.3) - Cleaned up and extended type selection
/// - 2016/09/13 (1.20.2)- Fixed slider behavior hopefully for the last time. This time
///                        all calculation are correct so no more hackery.
/// - 2016/09/13 (1.20.1)- Internal change to divide window/panel flags into panel flags and types.
///                        Suprisinly spend years in C and still happened to confuse types
///                        with flags. Probably something to take note.
/// - 2016/09/08 (1.20.0)- Added additional helper function to make it easier to just
///                        take the produced buffers from `nk_convert` and unplug the
///                        iteration process from `nk_context`. So now you can
///                        just use the vertex,element and command buffer + two pointer
///                        inside the command buffer retrieved by calls `nk__draw_begin`
///                        and `nk__draw_end` and macro `nk_draw_foreach_bounded`.
/// - 2016/09/08 (1.19.0)- Added additional asserts to make sure every `nk_xxx_begin` call
///                        for windows, popups, combobox, menu and contextual is guarded by
///                        `if` condition and does not produce false drawing output.
/// - 2016/09/08 (1.18.0)- Changed confusing name for `NK_SYMBOL_RECT_FILLED`, `NK_SYMBOL_RECT`
///                        to hopefully easier to understand `NK_SYMBOL_RECT_FILLED` and
///                        `NK_SYMBOL_RECT_OUTLINE`.
/// - 2016/09/08 (1.17.0)- Changed confusing name for `NK_SYMBOL_CIRLCE_FILLED`, `NK_SYMBOL_CIRCLE`
///                        to hopefully easier to understand `NK_SYMBOL_CIRCLE_FILLED` and
///                        `NK_SYMBOL_CIRCLE_OUTLINE`.
/// - 2016/09/08 (1.16.0)- Added additional checks to select correct types if `NK_INCLUDE_FIXED_TYPES`
///                        is not defined by supporting the biggest compiler GCC, clang and MSVC.
/// - 2016/09/07 (1.15.3)- Fixed `NK_INCLUDE_COMMAND_USERDATA` define to not cause an error
/// - 2016/09/04 (1.15.2)- Fixed wrong combobox height calculation
/// - 2016/09/03 (1.15.1)- Fixed gaps inside combo boxes in OpenGL
/// - 2016/09/02 (1.15.0) - Changed nuklear to not have any default vertex layout and
///                        instead made it user provided. The range of types to convert
///                        to is quite limited at the moment, but I would be more than
///                        happy to accept PRs to add additional.
/// - 2016/08/30 (1.14.2) - Removed unused variables
/// - 2016/08/30 (1.14.1) - Fixed C++ build errors
/// - 2016/08/30 (1.14.0) - Removed mouse dragging from SDL demo since it does not work correctly
/// - 2016/08/30 (1.13.4) - Tweaked some default styling variables
/// - 2016/08/30 (1.13.3) - Hopefully fixed drawing bug in slider, in general I would
///                        refrain from using slider with a big number of steps.
/// - 2016/08/30 (1.13.2) - Fixed close and minimize button which would fire even if the
///                        window was in Read Only Mode.
/// - 2016/08/30 (1.13.1) - Fixed popup panel padding handling which was previously just
///                        a hack for combo box and menu.
/// - 2016/08/30 (1.13.0) - Removed `NK_WINDOW_DYNAMIC` flag from public API since
///                        it is bugged and causes issues in window selection.
/// - 2016/08/30 (1.12.0) - Removed scaler size. The size of the scaler is now
///                        determined by the scrollbar size
/// - 2016/08/30 (1.11.2) - Fixed some drawing bugs caused by changes from 1.11
/// - 2016/08/30 (1.11.1) - Fixed overlapping minimized window selection
/// - 2016/08/30 (1.11.0) - Removed some internal complexity and overly complex code
///                        handling panel padding and panel border.
/// - 2016/08/29 (1.10.0) - Added additional height parameter to `nk_combobox_xxx`
/// - 2016/08/29 (1.10.0) - Fixed drawing bug in dynamic popups
/// - 2016/08/29 (1.10.0) - Added experimental mouse scrolling to popups, menus and comboboxes
/// - 2016/08/26 (1.10.0) - Added window name string prepresentation to account for
///                        hash collisions. Currently limited to NK_WINDOW_MAX_NAME
///                        which in term can be redefined if not big enough.
/// - 2016/08/26 (1.10.0) - Added stacks for temporary style/UI changes in code
/// - 2016/08/25 (1.10.0) - Changed `nk_input_is_key_pressed` and 'nk_input_is_key_released'
///                        to account for key press and release happening in one frame.
/// - 2016/08/25 (1.10.0) - Added additional nk_edit flag to directly jump to the end on activate
/// - 2016/08/17 (1.09.6)- Removed invalid check for value zero in nk_propertyx
/// - 2016/08/16 (1.09.5)- Fixed ROM mode for deeper levels of popup windows parents.
/// - 2016/08/15 (1.09.4)- Editbox are now still active if enter was pressed with flag
///                        `NK_EDIT_SIG_ENTER`. Main reasoning is to be able to keep
///                        typing after commiting.
/// - 2016/08/15 (1.09.4)- Removed redundant code
/// - 2016/08/15 (1.09.4)- Fixed negative numbers in `nk_strtoi` and remove unused variable
/// - 2016/08/15 (1.09.3)- Fixed `NK_WINDOW_BACKGROUND` flag behavior to select a background
///                        window only as selected by hovering and not by clicking.
/// - 2016/08/14 (1.09.2)- Fixed a bug in font atlas which caused wrong loading
///                        of glyphes for font with multiple ranges.
/// - 2016/08/12 (1.09.1)- Added additional function to check if window is currently
///                        hidden and therefore not visible.
/// - 2016/08/12 (1.09.1)- nk_window_is_closed now queries the correct flag `NK_WINDOW_CLOSED`
///                        instead of the old flag `NK_WINDOW_HIDDEN`
/// - 2016/08/09 (1.09.0) - Added additional double version to nk_property and changed
///                        the underlying implementation to not cast to float and instead
///                        work directly on the given values.
/// - 2016/08/09 (1.08.0) - Added additional define to overwrite library internal
///                        floating pointer number to string conversion for additional
///                        precision.
/// - 2016/08/09 (1.08.0) - Added additional define to overwrite library internal
///                        string to floating point number conversion for additional
///                        precision.
/// - 2016/08/08 (1.07.2)- Fixed compiling error without define NK_INCLUDE_FIXED_TYPE
/// - 2016/08/08 (1.07.1)- Fixed possible floating point error inside `nk_widget` leading
///                        to wrong wiget width calculation which results in widgets falsly
///                        becomming tagged as not inside window and cannot be accessed.
/// - 2016/08/08 (1.07.0) - Nuklear now differentiates between hiding a window (NK_WINDOW_HIDDEN) and
///                        closing a window (NK_WINDOW_CLOSED). A window can be hidden/shown
///                        by using `nk_window_show` and closed by either clicking the close
///                        icon in a window or by calling `nk_window_close`. Only closed
///                        windows get removed at the end of the frame while hidden windows
///                        remain.
/// - 2016/08/08 (1.06.0) - Added `nk_edit_string_zero_terminated` as a second option to
///                        `nk_edit_string` which takes, edits and outputs a '\0' terminated string.
/// - 2016/08/08 (1.05.4)- Fixed scrollbar auto hiding behavior
/// - 2016/08/08 (1.05.3)- Fixed wrong panel padding selection in `nk_layout_widget_space`
/// - 2016/08/07 (1.05.2)- Fixed old bug in dynamic immediate mode layout API, calculating
///                        wrong item spacing and panel width.
///- 2016/08/07 (1.05.1)- Hopefully finally fixed combobox popup drawing bug
///- 2016/08/07 (1.05.0) - Split varargs away from NK_INCLUDE_STANDARD_IO into own
///                        define NK_INCLUDE_STANDARD_VARARGS to allow more fine
///                        grained controlled over library includes.
/// - 2016/08/06 (1.04.5)- Changed memset calls to NK_MEMSET
/// - 2016/08/04 (1.04.4)- Fixed fast window scaling behavior
/// - 2016/08/04 (1.04.3)- Fixed window scaling, movement bug which appears if you
///                        move/scale a window and another window is behind it.
///                        If you are fast enough then the window behind gets activated
///                        and the operation is blocked. I now require activating
///                        by hovering only if mouse is not pressed.
/// - 2016/08/04 (1.04.2)- Fixed changing fonts
/// - 2016/08/03 (1.04.1)- Fixed `NK_WINDOW_BACKGROUND` behavior
/// - 2016/08/03 (1.04.0) - Added color parameter to `nk_draw_image`
/// - 2016/08/03 (1.04.0) - Added additional window padding style attributes for
///                        sub windows (combo, menu, ...)
/// - 2016/08/03 (1.04.0) - Added functions to show/hide software cursor
/// - 2016/08/03 (1.04.0) - Added `NK_WINDOW_BACKGROUND` flag to force a window
///                        to be always in the background of the screen
/// - 2016/08/03 (1.03.2)- Removed invalid assert macro for NK_RGB color picker
/// - 2016/08/01 (1.03.1)- Added helper macros into header include guard
/// - 2016/07/29 (1.03.0) - Moved the window/table pool into the header part to
///                        simplify memory management by removing the need to
///                        allocate the pool.
/// - 2016/07/29 (1.02.0) - Added auto scrollbar hiding window flag which if enabled
///                        will hide the window scrollbar after NK_SCROLLBAR_HIDING_TIMEOUT
///                        seconds without window interaction. To make it work
///                        you have to also set a delta time inside the `nk_context`.
/// - 2016/07/25 (1.01.1) - Fixed small panel and panel border drawing bugs
/// - 2016/07/15 (1.01.0) - Added software cursor to `nk_style` and `nk_context`
/// - 2016/07/15 (1.01.0) - Added const correctness to `nk_buffer_push' data argument
/// - 2016/07/15 (1.01.0) - Removed internal font baking API and simplified
///                        font atlas memory management by converting pointer
///                        arrays for fonts and font configurations to lists.
/// - 2016/07/15 (1.00.0) - Changed button API to use context dependend button
///                        behavior instead of passing it for every function call.
/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/// ## Gallery
/// ![Figure [blue]: Feature overview with blue color styling](https://cloud.githubusercontent.com/assets/8057201/13538240/acd96876-e249-11e5-9547-5ac0b19667a0.png)
/// ![Figure [red]: Feature overview with red color styling](https://cloud.githubusercontent.com/assets/8057201/13538243/b04acd4c-e249-11e5-8fd2-ad7744a5b446.png)
/// ![Figure [widgets]: Widget overview](https://cloud.githubusercontent.com/assets/8057201/11282359/3325e3c6-8eff-11e5-86cb-cf02b0596087.png)
/// ![Figure [blackwhite]: Black and white](https://cloud.githubusercontent.com/assets/8057201/11033668/59ab5d04-86e5-11e5-8091-c56f16411565.png)
/// ![Figure [filexp]: File explorer](https://cloud.githubusercontent.com/assets/8057201/10718115/02a9ba08-7b6b-11e5-950f-adacdd637739.png)
/// ![Figure [opengl]: OpenGL Editor](https://cloud.githubusercontent.com/assets/8057201/12779619/2a20d72c-ca69-11e5-95fe-4edecf820d5c.png)
/// ![Figure [nodedit]: Node Editor](https://cloud.githubusercontent.com/assets/8057201/9976995/e81ac04a-5ef7-11e5-872b-acd54fbeee03.gif)
/// ![Figure [skinning]: Using skinning in Nuklear](https://cloud.githubusercontent.com/assets/8057201/15991632/76494854-30b8-11e6-9555-a69840d0d50b.png)
/// ![Figure [bf]: Heavy modified version](https://cloud.githubusercontent.com/assets/8057201/14902576/339926a8-0d9c-11e6-9fee-a8b73af04473.png)
///
/// ## Credits
/// Developed by Micha Mettke and every direct or indirect github contributor. <br /><br />
///
/// Embeds [stb_texedit](https://github.com/nothings/stb/blob/master/stb_textedit.h), [stb_truetype](https://github.com/nothings/stb/blob/master/stb_truetype.h) and [stb_rectpack](https://github.com/nothings/stb/blob/master/stb_rect_pack.h) by Sean Barret (public domain) <br />
/// Uses [stddoc.c](https://github.com/r-lyeh/stddoc.c) from r-lyeh@github.com for documentation generation <br /><br />
/// Embeds ProggyClean.ttf font by Tristan Grimmer (MIT license). <br />
///
/// Big thank you to Omar Cornut (ocornut@github) for his [imgui library](https://github.com/ocornut/imgui) and
/// giving me the inspiration for this library, Casey Muratori for handmade hero
/// and his original immediate mode graphical user interface idea and Sean
/// Barret for his amazing single header libraries which restored my faith
/// in libraries and brought me to create some of my own. Finally Apoorva Joshi
/// for his single header file packer.
*/

delete <<
```

`Private Esp/EspUI/nuklear_d3d11.cpp`:

```cpp
#include "nuklear_d3d11.h"

#define NK_IMPLEMENTATION
#include "nuklear.h"

NK_API void
nk_d3d11_render(ID3D11DeviceContext* context, enum nk_anti_aliasing AA) {
	const float blend_factor[4] = { 0.0f, 0.0f, 0.0f, 0.0f };
	const UINT stride = sizeof(struct nk_d3d11_vertex);
	const UINT offset = 0;
	s
	context->IASetInputLayout(d3d11.input_layout);
	context->IASetVertexBuffers(0, 1, &d3d11.vertex_buffer, &stride, &offset);
	context->IASetIndexBuffer(d3d11.index_buffer, DXGI_FORMAT_R16_UINT, 0);
	context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	context->VSSetShader(d3d11.vertex_shader, NULL, 0);
	context->VSSetConstantBuffers(0, 1, &d3d11.const_buffer);

	context->PSSetShader(d3d11.pixel_shader, NULL, 0);
	context->PSSetSamplers(0, 1, &d3d11.sampler_state);

	context->OMSetBlendState(d3d11.blend_state, blend_factor, 0xffffffff);
	context->RSSetState(d3d11.rasterizer_state);
	context->RSSetViewports(1, &d3d11.viewport);

	/* Convert from command queue into draw list and draw to screen */
	{/* load draw vertices & elements directly into vertex + element buffer */
		D3D11_MAPPED_SUBRESOURCE vertices;
		D3D11_MAPPED_SUBRESOURCE indices;
		const struct nk_draw_command* cmd;
		UINT offset = 0;
		HRESULT hr;

		hr = context->Map((ID3D11Resource*)d3d11.vertex_buffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &vertices);
		NK_ASSERT(SUCCEEDED(hr));
		hr = context->Map((ID3D11Resource*)d3d11.index_buffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &indices);
		NK_ASSERT(SUCCEEDED(hr));

		{/* fill converting configuration */
			struct nk_convert_config config;
			NK_STORAGE const struct nk_draw_vertex_layout_element vertex_layout[] = {
				{NK_VERTEX_POSITION, NK_FORMAT_FLOAT, NK_OFFSETOF(struct nk_d3d11_vertex, position)},
				{NK_VERTEX_TEXCOORD, NK_FORMAT_FLOAT, NK_OFFSETOF(struct nk_d3d11_vertex, uv)},
				{NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, NK_OFFSETOF(struct nk_d3d11_vertex, col)},
				{NK_VERTEX_LAYOUT_END}
			};
			memset(&config, 0, sizeof(config));
			config.vertex_layout = vertex_layout;
			config.vertex_size = sizeof(struct nk_d3d11_vertex);
			config.vertex_alignment = NK_ALIGNOF(struct nk_d3d11_vertex);
			config.global_alpha = 1.0f;
			config.shape_AA = AA;
			config.line_AA = AA;
			config.circle_segment_count = 22;
			config.curve_segment_count = 22;
			config.arc_segment_count = 22;
			config.null = d3d11.null;

			{/* setup buffers to load vertices and elements */
				struct nk_buffer vbuf, ibuf;
				nk_buffer_init_fixed(&vbuf, vertices.pData, (size_t)d3d11.max_vertex_buffer);
				nk_buffer_init_fixed(&ibuf, indices.pData, (size_t)d3d11.max_index_buffer);
				nk_convert(&d3d11.ctx, &d3d11.cmds, &vbuf, &ibuf, &config);
			}
		}

		context->Unmap((ID3D11Resource*)d3d11.vertex_buffer, 0);
		context->Unmap((ID3D11Resource*)d3d11.index_buffer, 0);

		/* iterate over and execute each draw command */
		nk_draw_foreach(cmd, &d3d11.ctx, &d3d11.cmds) {
			D3D11_RECT scissor;
			ID3D11ShaderResourceView* texture_view = (ID3D11ShaderResourceView*)cmd->texture.ptr;
			if (!cmd->elem_count) continue;

			scissor.left = (LONG)cmd->clip_rect.x;
			scissor.right = (LONG)(cmd->clip_rect.x + cmd->clip_rect.w);
			scissor.top = (LONG)cmd->clip_rect.y;
			scissor.bottom = (LONG)(cmd->clip_rect.y + cmd->clip_rect.h);

			context->PSSetShaderResources(0, 1, &texture_view);
			context->RSSetScissorRects(1, &scissor);
			context->DrawIndexed((UINT)cmd->elem_count, offset, 0);
			offset += cmd->elem_count;
		}
		nk_clear(&d3d11.ctx);
	}
}

static void
nk_d3d11_get_projection_matrix(int width, int height, float* result) {
	const float L = 0.0f;
	const float R = (float)width;
	const float T = 0.0f;
	const float B = (float)height;
	float matrix[4][4] =
	{
		{    2.0f / (R - L),              0.0f, 0.0f, 0.0f },
		{              0.0f,    2.0f / (T - B), 0.0f, 0.0f },
		{              0.0f,              0.0f, 0.5f, 0.0f },
		{ (R + L) / (L - R), (T + B) / (B - T), 0.5f, 1.0f },
	};
	memcpy(result, matrix, sizeof(matrix));
}

NK_API void
nk_d3d11_resize(ID3D11DeviceContext* context, int width, int height) {
	D3D11_MAPPED_SUBRESOURCE mapped;
	if (SUCCEEDED(context->Map((ID3D11Resource*)d3d11.const_buffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped))) {
		nk_d3d11_get_projection_matrix(width, height, (float*)mapped.pData);
		context->Unmap((ID3D11Resource*)d3d11.const_buffer, 0);

		d3d11.viewport.Width = (float)width;
		d3d11.viewport.Height = (float)height;
	}
}

//
// TODO: Implement health check on mouse x & mouse y so application doesn't crash for being out of bounds.
//

NK_API int
nk_d3d11_handle_event(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam) {
	switch (msg) {
	case WM_KEYDOWN:
	case WM_KEYUP:
	case WM_SYSKEYDOWN:
	case WM_SYSKEYUP:
	{
		int down = !((lparam >> 31) & 1);
		int ctrl = 0;

		switch (wparam) {
		case VK_SHIFT:
		case VK_LSHIFT:
		case VK_RSHIFT:
			nk_input_key(&d3d11.ctx, NK_KEY_SHIFT, down);
			return 1;

		case VK_DELETE:
			nk_input_key(&d3d11.ctx, NK_KEY_DEL, down);
			return 1;

		case VK_RETURN:
			nk_input_key(&d3d11.ctx, NK_KEY_ENTER, down);
			return 1;

		case VK_TAB:
			nk_input_key(&d3d11.ctx, NK_KEY_TAB, down);
			return 1;

		case VK_LEFT:
			if (ctrl)
				nk_input_key(&d3d11.ctx, NK_KEY_TEXT_WORD_LEFT, down);
			else
				nk_input_key(&d3d11.ctx, NK_KEY_LEFT, down);
			return 1;

		case VK_RIGHT:
			if (ctrl)
				nk_input_key(&d3d11.ctx, NK_KEY_TEXT_WORD_RIGHT, down);
			else
				nk_input_key(&d3d11.ctx, NK_KEY_RIGHT, down);
			return 1;

		case VK_BACK:
			nk_input_key(&d3d11.ctx, NK_KEY_BACKSPACE, down);
			return 1;

		case VK_HOME:
			nk_input_key(&d3d11.ctx, NK_KEY_TEXT_START, down);
			nk_input_key(&d3d11.ctx, NK_KEY_SCROLL_START, down);
			return 1;

		case VK_END:
			nk_input_key(&d3d11.ctx, NK_KEY_TEXT_END, down);
			nk_input_key(&d3d11.ctx, NK_KEY_SCROLL_END, down);
			return 1;

		case VK_NEXT:
			nk_input_key(&d3d11.ctx, NK_KEY_SCROLL_DOWN, down);
			return 1;

		case VK_PRIOR:
			nk_input_key(&d3d11.ctx, NK_KEY_SCROLL_UP, down);
			return 1;

		case 'C':
			if (ctrl) {
				nk_input_key(&d3d11.ctx, NK_KEY_COPY, down);
				return 1;
			}
			break;

		case 'V':
			if (ctrl) {
				nk_input_key(&d3d11.ctx, NK_KEY_PASTE, down);
				return 1;
			}
			break;

		case 'X':
			if (ctrl) {
				nk_input_key(&d3d11.ctx, NK_KEY_CUT, down);
				return 1;
			}
			break;

		case 'Z':
			if (ctrl) {
				nk_input_key(&d3d11.ctx, NK_KEY_TEXT_UNDO, down);
				return 1;
			}
			break;

		case 'R':
			if (ctrl) {
				nk_input_key(&d3d11.ctx, NK_KEY_TEXT_REDO, down);
				return 1;
			}
			break;
		}
		return 0;
	}

	case WM_CHAR:
		if (wparam >= 32) {
			nk_input_unicode(&d3d11.ctx, (nk_rune)wparam);
			return 1;
		}
		break;

	case WM_LBUTTONDOWN:
		nk_input_button(&d3d11.ctx, NK_BUTTON_LEFT, (short)LOWORD(lparam), (short)HIWORD(lparam), 1);
		SetCapture(wnd);
		return 1;

	case WM_LBUTTONUP:
		nk_input_button(&d3d11.ctx, NK_BUTTON_DOUBLE, (short)LOWORD(lparam), (short)HIWORD(lparam), 0);
		nk_input_button(&d3d11.ctx, NK_BUTTON_LEFT, (short)LOWORD(lparam), (short)HIWORD(lparam), 0);
		ReleaseCapture();
		return 1;

	case WM_RBUTTONDOWN:
		nk_input_button(&d3d11.ctx, NK_BUTTON_RIGHT, (short)LOWORD(lparam), (short)HIWORD(lparam), 1);
		SetCapture(wnd);
		return 1;

	case WM_RBUTTONUP:
		nk_input_button(&d3d11.ctx, NK_BUTTON_RIGHT, (short)LOWORD(lparam), (short)HIWORD(lparam), 0);
		ReleaseCapture();
		return 1;

	case WM_MBUTTONDOWN:
		nk_input_button(&d3d11.ctx, NK_BUTTON_MIDDLE, (short)LOWORD(lparam), (short)HIWORD(lparam), 1);
		SetCapture(wnd);
		return 1;

	case WM_MBUTTONUP:
		nk_input_button(&d3d11.ctx, NK_BUTTON_MIDDLE, (short)LOWORD(lparam), (short)HIWORD(lparam), 0);
		ReleaseCapture();
		return 1;

	case WM_MOUSEWHEEL:
		nk_input_scroll(&d3d11.ctx, nk_vec2(0, (float)(short)HIWORD(wparam) / WHEEL_DELTA));
		return 1;

	case WM_MOUSEMOVE:
		nk_input_motion(&d3d11.ctx, (short)LOWORD(lparam), (short)HIWORD(lparam));
		return 1;

	case WM_LBUTTONDBLCLK:
		nk_input_button(&d3d11.ctx, NK_BUTTON_DOUBLE, (short)LOWORD(lparam), (short)HIWORD(lparam), 1);
		return 1;
	}

	return 0;
}

static void
nk_d3d11_clipboard_paste(nk_handle usr, struct nk_text_edit* edit) {
	(void)usr;
	if (IsClipboardFormatAvailable(CF_UNICODETEXT) && OpenClipboard(NULL)) {
		HGLOBAL mem = GetClipboardData(CF_UNICODETEXT);
		if (mem) {
			SIZE_T size = GlobalSize(mem) - 1;
			if (size) {
				LPCWSTR wstr = (LPCWSTR)GlobalLock(mem);
				if (wstr) {
					int utf8size = WideCharToMultiByte(CP_UTF8, 0, wstr, size / sizeof(wchar_t), NULL, 0, NULL, NULL);
					if (utf8size) {
						char* utf8 = (char*)malloc(utf8size);
						if (utf8) {
							WideCharToMultiByte(CP_UTF8, 0, wstr, size / sizeof(wchar_t), utf8, utf8size, NULL, NULL);
							nk_textedit_paste(edit, utf8, utf8size);
							free(utf8);
						}
					}
					GlobalUnlock(mem);
				}
			}
		}
		CloseClipboard();
	}
}

static void
nk_d3d11_clipboard_copy(nk_handle usr, const char* text, int len) {
	(void)usr;
	if (OpenClipboard(NULL)) {
		int wsize = MultiByteToWideChar(CP_UTF8, 0, text, len, NULL, 0);
		if (wsize) {
			HGLOBAL mem = GlobalAlloc(GMEM_MOVEABLE, (wsize + 1) * sizeof(wchar_t));
			if (mem) {
				wchar_t* wstr = (wchar_t*)GlobalLock(mem);
				if (wstr) {
					MultiByteToWideChar(CP_UTF8, 0, text, len, wstr, wsize);
					wstr[wsize] = 0;
					GlobalUnlock(mem);
					SetClipboardData(CF_UNICODETEXT, mem);
				}
			}
		}
		CloseClipboard();
	}
}

NK_API struct nk_context*
nk_d3d11_init(ID3D11Device* device, int width, int height, unsigned int max_vertex_buffer, unsigned int max_index_buffer) {
	HRESULT hr;
	d3d11.max_vertex_buffer = max_vertex_buffer;
	d3d11.max_index_buffer = max_index_buffer;
	d3d11.device = device;
	device->AddRef();

	nk_init_default(&d3d11.ctx, 0);
	d3d11.ctx.clip.copy = nk_d3d11_clipboard_copy;
	d3d11.ctx.clip.paste = nk_d3d11_clipboard_paste;
	d3d11.ctx.clip.userdata = nk_handle_ptr(0);

	nk_buffer_init_default(&d3d11.cmds);

	{/* rasterizer state */
		D3D11_RASTERIZER_DESC desc;
		memset(&desc, 0, sizeof(desc));
		desc.FillMode = D3D11_FILL_SOLID;
		desc.CullMode = D3D11_CULL_NONE;
		desc.FrontCounterClockwise = FALSE;
		desc.DepthBias = 0;
		desc.DepthBiasClamp = 0;
		desc.SlopeScaledDepthBias = 0.0f;
		desc.DepthClipEnable = TRUE;
		desc.ScissorEnable = TRUE;
		desc.MultisampleEnable = FALSE;
		desc.AntialiasedLineEnable = FALSE;
		hr = device->CreateRasterizerState(&desc, &d3d11.rasterizer_state);
		NK_ASSERT(SUCCEEDED(hr));
	}

	/* vertex shader */
	{
		hr = device->CreateVertexShader(nk_d3d11_vertex_shader, sizeof(nk_d3d11_vertex_shader), NULL, &d3d11.vertex_shader);
		NK_ASSERT(SUCCEEDED(hr));
	}

	/* input layout */
	{
		const D3D11_INPUT_ELEMENT_DESC layout[] = {
		   { "POSITION", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, offsetof(struct nk_d3d11_vertex, position), D3D11_INPUT_PER_VERTEX_DATA, 0 },
		   { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT,       0, offsetof(struct nk_d3d11_vertex, uv),       D3D11_INPUT_PER_VERTEX_DATA, 0 },
		   { "COLOR",    0, DXGI_FORMAT_R8G8B8A8_UNORM,     0, offsetof(struct nk_d3d11_vertex, col),      D3D11_INPUT_PER_VERTEX_DATA, 0 },
		};
		hr = device->CreateInputLayout(layout, ARRAYSIZE(layout), nk_d3d11_vertex_shader, sizeof(nk_d3d11_vertex_shader), &d3d11.input_layout);
		NK_ASSERT(SUCCEEDED(hr));
	}

	/* constant buffer */
	{
		float matrix[4 * 4];
		D3D11_BUFFER_DESC desc;
		memset(&desc, 0, sizeof(desc));
		desc.ByteWidth = sizeof(matrix);
		desc.Usage = D3D11_USAGE_DYNAMIC;
		desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		desc.MiscFlags = 0;

		{
			D3D11_SUBRESOURCE_DATA data;
			data.pSysMem = matrix;
			data.SysMemPitch = 0;
			data.SysMemSlicePitch = 0;

			nk_d3d11_get_projection_matrix(width, height, matrix);
			hr = device->CreateBuffer(&desc, &data, &d3d11.const_buffer);
			NK_ASSERT(SUCCEEDED(hr));
		}
	}

	/* pixel shader */
	{
		hr = device->CreatePixelShader(nk_d3d11_pixel_shader, sizeof(nk_d3d11_pixel_shader), NULL, &d3d11.pixel_shader);
		NK_ASSERT(SUCCEEDED(hr));
	}

	{/* blend state */
		D3D11_BLEND_DESC desc;
		memset(&desc, 0, sizeof(desc));
		desc.AlphaToCoverageEnable = FALSE;
		desc.RenderTarget[0].BlendEnable = TRUE;
		desc.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
		desc.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
		desc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
		desc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_INV_SRC_ALPHA;
		desc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO;
		desc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
		desc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
		hr = device->CreateBlendState(&desc, &d3d11.blend_state);
		NK_ASSERT(SUCCEEDED(hr));
	}

	/* vertex buffer */
	{
		D3D11_BUFFER_DESC desc;
		memset(&desc, 0, sizeof(desc));
		desc.Usage = D3D11_USAGE_DYNAMIC;
		desc.ByteWidth = max_vertex_buffer;
		desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		desc.MiscFlags = 0;
		hr = device->CreateBuffer(&desc, NULL, &d3d11.vertex_buffer);
		NK_ASSERT(SUCCEEDED(hr));
	}

	/* index buffer */
	{
		D3D11_BUFFER_DESC desc;
		memset(&desc, 0, sizeof(desc));
		desc.Usage = D3D11_USAGE_DYNAMIC;
		desc.ByteWidth = max_index_buffer;
		desc.BindFlags = D3D11_BIND_INDEX_BUFFER;
		desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		hr = device->CreateBuffer(&desc, NULL, &d3d11.index_buffer);
		NK_ASSERT(SUCCEEDED(hr));
	}

	/* sampler state */
	{
		D3D11_SAMPLER_DESC desc;
		memset(&desc, 0, sizeof(desc));
		desc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
		desc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
		desc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
		desc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
		desc.MipLODBias = 0.0f;
		desc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
		desc.MinLOD = 0.0f;
		desc.MaxLOD = FLT_MAX;
		hr = device->CreateSamplerState(&desc, &d3d11.sampler_state);
		NK_ASSERT(SUCCEEDED(hr));
	}

	/* viewport */
	{
		d3d11.viewport.TopLeftX = 0.0f;
		d3d11.viewport.TopLeftY = 0.0f;
		d3d11.viewport.Width = (float)width;
		d3d11.viewport.Height = (float)height;
		d3d11.viewport.MinDepth = 0.0f;
		d3d11.viewport.MaxDepth = 1.0f;
	}
	return &d3d11.ctx;
}

NK_API void
nk_d3d11_font_stash_begin(struct nk_font_atlas** atlas) {
	nk_font_atlas_init_default(&d3d11.atlas);
	nk_font_atlas_begin(&d3d11.atlas);
	*atlas = &d3d11.atlas;
}

NK_API void
nk_d3d11_font_stash_end(void) {
	const void* image; int w, h;
	image = nk_font_atlas_bake(&d3d11.atlas, &w, &h, NK_FONT_ATLAS_RGBA32);

	/* upload font to texture and create texture view */
	{
		ID3D11Texture2D* font_texture;
		HRESULT hr;

		D3D11_TEXTURE2D_DESC desc;
		memset(&desc, 0, sizeof(desc));
		desc.Width = (UINT)w;
		desc.Height = (UINT)h;
		desc.MipLevels = 1;
		desc.ArraySize = 1;
		desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		desc.SampleDesc.Count = 1;
		desc.SampleDesc.Quality = 0;
		desc.Usage = D3D11_USAGE_DEFAULT;
		desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
		desc.CPUAccessFlags = 0;

		{
			D3D11_SUBRESOURCE_DATA data;
			data.pSysMem = image;
			data.SysMemPitch = (UINT)(w * 4);
			data.SysMemSlicePitch = 0;
			hr = d3d11.device->CreateTexture2D(&desc, &data, &font_texture);
			assert(SUCCEEDED(hr));
		}

		{
			D3D11_SHADER_RESOURCE_VIEW_DESC srv;
			memset(&srv, 0, sizeof(srv));
			srv.Format = desc.Format;
			srv.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
			srv.Texture2D.MipLevels = 1;
			srv.Texture2D.MostDetailedMip = 0;
			hr = d3d11.device->CreateShaderResourceView((ID3D11Resource*)font_texture, &srv, &d3d11.font_texture_view);
			assert(SUCCEEDED(hr));
		}
		font_texture->Release();
	}

	nk_font_atlas_end(&d3d11.atlas, nk_handle_ptr(d3d11.font_texture_view), &d3d11.null);
	if (d3d11.atlas.default_font)
		nk_style_set_font(&d3d11.ctx, &d3d11.atlas.default_font->handle);
}

NK_API
void nk_d3d11_shutdown(void) {
	nk_font_atlas_clear(&d3d11.atlas);
	nk_buffer_free(&d3d11.cmds);
	nk_free(&d3d11.ctx);

	d3d11.sampler_state->Release();
	d3d11.font_texture_view->Release();
	d3d11.vertex_buffer->Release();
	d3d11.index_buffer->Release();
	d3d11.blend_state->Release();
	d3d11.pixel_shader->Release();
	d3d11.const_buffer->Release();
	d3d11.vertex_shader->Release();
	d3d11.input_layout->Release();
	d3d11.rasterizer_state->Release();
	d3d11.device->Release();
}

NK_API
void
set_style(struct nk_context* ctx, enum theme theme)
{
	struct nk_color table[NK_COLOR_COUNT];
	if (theme == THEME_WHITE) {
		table[NK_COLOR_TEXT] = nk_rgba(70, 70, 70, 255);
		table[NK_COLOR_WINDOW] = nk_rgba(175, 175, 175, 255);
		table[NK_COLOR_HEADER] = nk_rgba(175, 175, 175, 255);
		table[NK_COLOR_BORDER] = nk_rgba(0, 0, 0, 255);
		table[NK_COLOR_BUTTON] = nk_rgba(185, 185, 185, 255);
		table[NK_COLOR_BUTTON_HOVER] = nk_rgba(170, 170, 170, 255);
		table[NK_COLOR_BUTTON_ACTIVE] = nk_rgba(160, 160, 160, 255);
		table[NK_COLOR_TOGGLE] = nk_rgba(150, 150, 150, 255);
		table[NK_COLOR_TOGGLE_HOVER] = nk_rgba(120, 120, 120, 255);
		table[NK_COLOR_TOGGLE_CURSOR] = nk_rgba(175, 175, 175, 255);
		table[NK_COLOR_SELECT] = nk_rgba(190, 190, 190, 255);
		table[NK_COLOR_SELECT_ACTIVE] = nk_rgba(175, 175, 175, 255);
		table[NK_COLOR_SLIDER] = nk_rgba(190, 190, 190, 255);
		table[NK_COLOR_SLIDER_CURSOR] = nk_rgba(80, 80, 80, 255);
		table[NK_COLOR_SLIDER_CURSOR_HOVER] = nk_rgba(70, 70, 70, 255);
		table[NK_COLOR_SLIDER_CURSOR_ACTIVE] = nk_rgba(60, 60, 60, 255);
		table[NK_COLOR_PROPERTY] = nk_rgba(175, 175, 175, 255);
		table[NK_COLOR_EDIT] = nk_rgba(150, 150, 150, 255);
		table[NK_COLOR_EDIT_CURSOR] = nk_rgba(0, 0, 0, 255);
		table[NK_COLOR_COMBO] = nk_rgba(175, 175, 175, 255);
		table[NK_COLOR_CHART] = nk_rgba(160, 160, 160, 255);
		table[NK_COLOR_CHART_COLOR] = nk_rgba(45, 45, 45, 255);
		table[NK_COLOR_CHART_COLOR_HIGHLIGHT] = nk_rgba(255, 0, 0, 255);
		table[NK_COLOR_SCROLLBAR] = nk_rgba(180, 180, 180, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR] = nk_rgba(140, 140, 140, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR_HOVER] = nk_rgba(150, 150, 150, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR_ACTIVE] = nk_rgba(160, 160, 160, 255);
		table[NK_COLOR_TAB_HEADER] = nk_rgba(180, 180, 180, 255);
		nk_style_from_table(ctx, table);
	}
	else if (theme == THEME_RED) {
		table[NK_COLOR_TEXT] = nk_rgba(190, 190, 190, 255);
		table[NK_COLOR_WINDOW] = nk_rgba(30, 33, 40, 215);
		table[NK_COLOR_HEADER] = nk_rgba(181, 45, 69, 220);
		table[NK_COLOR_BORDER] = nk_rgba(51, 55, 67, 255);
		table[NK_COLOR_BUTTON] = nk_rgba(181, 45, 69, 255);
		table[NK_COLOR_BUTTON_HOVER] = nk_rgba(190, 50, 70, 255);
		table[NK_COLOR_BUTTON_ACTIVE] = nk_rgba(195, 55, 75, 255);
		table[NK_COLOR_TOGGLE] = nk_rgba(51, 55, 67, 255);
		table[NK_COLOR_TOGGLE_HOVER] = nk_rgba(45, 60, 60, 255);
		table[NK_COLOR_TOGGLE_CURSOR] = nk_rgba(181, 45, 69, 255);
		table[NK_COLOR_SELECT] = nk_rgba(51, 55, 67, 255);
		table[NK_COLOR_SELECT_ACTIVE] = nk_rgba(181, 45, 69, 255);
		table[NK_COLOR_SLIDER] = nk_rgba(51, 55, 67, 255);
		table[NK_COLOR_SLIDER_CURSOR] = nk_rgba(181, 45, 69, 255);
		table[NK_COLOR_SLIDER_CURSOR_HOVER] = nk_rgba(186, 50, 74, 255);
		table[NK_COLOR_SLIDER_CURSOR_ACTIVE] = nk_rgba(191, 55, 79, 255);
		table[NK_COLOR_PROPERTY] = nk_rgba(51, 55, 67, 255);
		table[NK_COLOR_EDIT] = nk_rgba(51, 55, 67, 225);
		table[NK_COLOR_EDIT_CURSOR] = nk_rgba(190, 190, 190, 255);
		table[NK_COLOR_COMBO] = nk_rgba(51, 55, 67, 255);
		table[NK_COLOR_CHART] = nk_rgba(51, 55, 67, 255);
		table[NK_COLOR_CHART_COLOR] = nk_rgba(170, 40, 60, 255);
		table[NK_COLOR_CHART_COLOR_HIGHLIGHT] = nk_rgba(255, 0, 0, 255);
		table[NK_COLOR_SCROLLBAR] = nk_rgba(30, 33, 40, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR] = nk_rgba(64, 84, 95, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR_HOVER] = nk_rgba(70, 90, 100, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR_ACTIVE] = nk_rgba(75, 95, 105, 255);
		table[NK_COLOR_TAB_HEADER] = nk_rgba(181, 45, 69, 220);
		nk_style_from_table(ctx, table);
	}
	else if (theme == THEME_BLUE) {
		table[NK_COLOR_TEXT] = nk_rgba(20, 20, 20, 255);
		table[NK_COLOR_WINDOW] = nk_rgba(202, 212, 214, 215);
		table[NK_COLOR_HEADER] = nk_rgba(137, 182, 224, 220);
		table[NK_COLOR_BORDER] = nk_rgba(140, 159, 173, 255);
		table[NK_COLOR_BUTTON] = nk_rgba(137, 182, 224, 255);
		table[NK_COLOR_BUTTON_HOVER] = nk_rgba(142, 187, 229, 255);
		table[NK_COLOR_BUTTON_ACTIVE] = nk_rgba(147, 192, 234, 255);
		table[NK_COLOR_TOGGLE] = nk_rgba(177, 210, 210, 255);
		table[NK_COLOR_TOGGLE_HOVER] = nk_rgba(182, 215, 215, 255);
		table[NK_COLOR_TOGGLE_CURSOR] = nk_rgba(137, 182, 224, 255);
		table[NK_COLOR_SELECT] = nk_rgba(177, 210, 210, 255);
		table[NK_COLOR_SELECT_ACTIVE] = nk_rgba(137, 182, 224, 255);
		table[NK_COLOR_SLIDER] = nk_rgba(177, 210, 210, 255);
		table[NK_COLOR_SLIDER_CURSOR] = nk_rgba(137, 182, 224, 245);
		table[NK_COLOR_SLIDER_CURSOR_HOVER] = nk_rgba(142, 188, 229, 255);
		table[NK_COLOR_SLIDER_CURSOR_ACTIVE] = nk_rgba(147, 193, 234, 255);
		table[NK_COLOR_PROPERTY] = nk_rgba(210, 210, 210, 255);
		table[NK_COLOR_EDIT] = nk_rgba(210, 210, 210, 225);
		table[NK_COLOR_EDIT_CURSOR] = nk_rgba(20, 20, 20, 255);
		table[NK_COLOR_COMBO] = nk_rgba(210, 210, 210, 255);
		table[NK_COLOR_CHART] = nk_rgba(210, 210, 210, 255);
		table[NK_COLOR_CHART_COLOR] = nk_rgba(137, 182, 224, 255);
		table[NK_COLOR_CHART_COLOR_HIGHLIGHT] = nk_rgba(255, 0, 0, 255);
		table[NK_COLOR_SCROLLBAR] = nk_rgba(190, 200, 200, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR] = nk_rgba(64, 84, 95, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR_HOVER] = nk_rgba(70, 90, 100, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR_ACTIVE] = nk_rgba(75, 95, 105, 255);
		table[NK_COLOR_TAB_HEADER] = nk_rgba(156, 193, 220, 255);
		nk_style_from_table(ctx, table);
	}
	else if (theme == THEME_DARK) {
		table[NK_COLOR_TEXT] = nk_rgba(210, 210, 210, 255);
		table[NK_COLOR_WINDOW] = nk_rgba(57, 67, 71, 215);
		table[NK_COLOR_HEADER] = nk_rgba(51, 51, 56, 150);
		table[NK_COLOR_BORDER] = nk_rgba(39, 250, 0, 255);
		table[NK_COLOR_BUTTON] = nk_rgba(48, 83, 111, 255);
		table[NK_COLOR_BUTTON_HOVER] = nk_rgba(58, 93, 121, 255);
		table[NK_COLOR_BUTTON_ACTIVE] = nk_rgba(63, 98, 126, 255);
		table[NK_COLOR_TOGGLE] = nk_rgba(50, 58, 61, 255);
		table[NK_COLOR_TOGGLE_HOVER] = nk_rgba(45, 53, 56, 255);
		table[NK_COLOR_TOGGLE_CURSOR] = nk_rgba(48, 83, 111, 255);
		table[NK_COLOR_SELECT] = nk_rgba(57, 67, 61, 255);
		table[NK_COLOR_SELECT_ACTIVE] = nk_rgba(48, 83, 111, 255);
		table[NK_COLOR_SLIDER] = nk_rgba(50, 58, 61, 255);
		table[NK_COLOR_SLIDER_CURSOR] = nk_rgba(48, 83, 111, 245);
		table[NK_COLOR_SLIDER_CURSOR_HOVER] = nk_rgba(53, 88, 116, 255);
		table[NK_COLOR_SLIDER_CURSOR_ACTIVE] = nk_rgba(58, 93, 121, 255);
		table[NK_COLOR_PROPERTY] = nk_rgba(50, 58, 61, 255);
		table[NK_COLOR_EDIT] = nk_rgba(50, 58, 61, 225);
		table[NK_COLOR_EDIT_CURSOR] = nk_rgba(210, 210, 210, 255);
		table[NK_COLOR_COMBO] = nk_rgba(50, 58, 61, 255);
		table[NK_COLOR_CHART] = nk_rgba(50, 58, 61, 255);
		table[NK_COLOR_CHART_COLOR] = nk_rgba(48, 83, 111, 255);
		table[NK_COLOR_CHART_COLOR_HIGHLIGHT] = nk_rgba(255, 0, 0, 255);
		table[NK_COLOR_SCROLLBAR] = nk_rgba(50, 58, 61, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR] = nk_rgba(48, 83, 111, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR_HOVER] = nk_rgba(53, 88, 116, 255);
		table[NK_COLOR_SCROLLBAR_CURSOR_ACTIVE] = nk_rgba(58, 93, 121, 255);
		table[NK_COLOR_TAB_HEADER] = nk_rgba(48, 83, 111, 255);
		nk_style_from_table(ctx, table);
	}
	else if (theme == THEME_CUSTOM) {
		// Place your custom theme "config" here.
		table[NK_COLOR_TEXT] = nk_rgba(210, 210, 210, 255);
		nk_style_from_table(ctx, table);
	}
	else {
		nk_style_default(ctx);
	}
}
```

`Private Esp/EspUI/nuklear_d3d11.h`:

```h
#ifndef NK_D3D11_H_
#define NK_D3D11_H_

#define WIN32_LEAN_AND_MEAN
#define COBJMACROS
#include <d3d11.h>
#include <windows.h>s

#include <stddef.h>
#include <string.h>
#include <float.h>
#include <assert.h>


#define NK_INCLUDE_DEFAULT_ALLOCATOR
#define MAX_VERTEX_BUFFER 512 * 1024
#define MAX_INDEX_BUFFER 128 * 1024
#define NK_INCLUDE_FIXED_TYPES
#define NK_INCLUDE_FONT_BAKING
#define NK_INCLUDE_VERTEX_BUFFER_OUTPUT
#define NK_INCLUDE_DEFAULT_FONT
#define NK_D3D11_IMPLEMENTATION

#include "nuklear.h"
#include "nuklear_d3d11_vertex_shader.h"
#include "nuklear_d3d11_pixel_shader.h"

typedef struct ID3D11Device ID3D11Device;
typedef struct ID3D11DeviceContext ID3D11DeviceContext;

struct nk_d3d11_vertex {
	float position[2];
	float uv[2];
	nk_byte col[4];
};

static struct
{
	struct nk_context ctx;
	struct nk_font_atlas atlas;
	struct nk_buffer cmds;

	struct nk_draw_null_texture null;
	unsigned int max_vertex_buffer;
	unsigned int max_index_buffer;

	D3D11_VIEWPORT viewport;
	ID3D11Device* device;
	ID3D11RasterizerState* rasterizer_state;
	ID3D11VertexShader* vertex_shader;
	ID3D11InputLayout* input_layout;
	ID3D11Buffer* const_buffer;
	ID3D11PixelShader* pixel_shader;
	ID3D11BlendState* blend_state;
	ID3D11Buffer* index_buffer;
	ID3D11Buffer* vertex_buffer;
	ID3D11ShaderResourceView* font_texture_view;
	ID3D11SamplerState* sampler_state;
} d3d11;

NK_API void
nk_d3d11_render(ID3D11DeviceContext* context, enum nk_anti_aliasing AA);

static void
nk_d3d11_get_projection_matrix(int width, int height, float* result);

NK_API void
nk_d3d11_resize(ID3D11DeviceContext* context, int width, int height);

NK_API int
nk_d3d11_handle_event(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam);

static void
nk_d3d11_clipboard_paste(nk_handle usr, struct nk_text_edit* edit);

static void
nk_d3d11_clipboard_copy(nk_handle usr, const char* text, int len);

NK_API struct nk_context*
nk_d3d11_init(ID3D11Device* device, int width, int height, unsigned int max_vertex_buffer, unsigned int max_index_buffer);

NK_API void
nk_d3d11_font_stash_begin(struct nk_font_atlas** atlas);

NK_API void
nk_d3d11_font_stash_end(void);

NK_API
void nk_d3d11_shutdown(void);

static
enum theme { THEME_BLACK, THEME_WHITE, THEME_RED, THEME_BLUE, THEME_DARK, THEME_CUSTOM };

NK_API void
set_style(struct nk_context* ctx, enum theme theme);

#endif
```

`Private Esp/imgui/imconfig.h`:

```h
//-----------------------------------------------------------------------------
// COMPILE-TIME OPTIONS FOR DEAR IMGUI
// Runtime options (clipboard callbacks, enabling various features, etc.) can generally be set via the ImGuiIO structure.
// You can use ImGui::SetAllocatorFunctions() before calling ImGui::CreateContext() to rewire memory allocation functions.
//-----------------------------------------------------------------------------
// A) You may edit imconfig.h (and not overwrite it when updating imgui, or maintain a patch/branch with your modifications to imconfig.h)
// B) or add configuration directives in your own file and compile with #define IMGUI_USER_CONFIG "myfilename.h"
// If you do so you need to make sure that configuration settings are defined consistently _everywhere_ dear imgui is used, which include
// the imgui*.cpp files but also _any_ of your code that uses imgui. This is because some compile-time options have an affect on data structures.
// Defining those options in imconfig.h will ensure every compilation unit gets to see the same data structure layouts.
// Call IMGUI_CHECKVERSION() from your .cpp files to verify that the data structures your files are using are matching the ones imgui.cpp is using.
//-----------------------------------------------------------------------------

#pragma once

//---- Define assertion handler. Defaults to calling assert().
//#define IM_ASSERT(_EXPR)  MyAssert(_EXPR)
//#define IM_ASSERT(_EXPR)  ((void)(_EXPR))     // Disable asserts

//---- Define attributes of all API symbols declarations, e.g. for DLL under Windows.
//#define IMGUI_API __declspec( dllexport )
//#define IMGUI_API __declspec( dllimport )

//---- Don't define obsolete functions/enums names. Consider enabling from time to time after updating to avoid using soon-to-be obsolete function/names.
//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS

//---- Don't implement demo windows functionality (ShowDemoWindow()/ShowStyleEditor()/ShowUserGuide() methods will be empty)
//---- It is very strongly recommended to NOT disable the demo windows during development. Please read the comments in imgui_demo.cpp.
//#define IMGUI_DISABLE_DEMO_WINDOWS

//---- Don't implement some functions to reduce linkage requirements.
//#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc.
//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] Don't implement default IME handler. Won't use and link with ImmGetContext/ImmSetCompositionWindow.
//#define IMGUI_DISABLE_WIN32_FUNCTIONS                     // [Win32] Won't use and link with any Win32 function.
//#define IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS             // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself if you don't want to link with vsnprintf.
//#define IMGUI_DISABLE_MATH_FUNCTIONS                      // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 wrapper so you can implement them yourself. Declare your prototypes in imconfig.h.
//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().

//---- Include imgui_user.h at the end of imgui.h as a convenience
//#define IMGUI_INCLUDE_IMGUI_USER_H

//---- Pack colors to BGRA8 instead of RGBA8 (to avoid converting from one to another)
//#define IMGUI_USE_BGRA_PACKED_COLOR

//---- Avoid multiple STB libraries implementations, or redefine path/filenames to prioritize another version
// By default the embedded implementations are declared static and not available outside of imgui cpp files.
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

//---- Define constructor and implicit cast operators to convert back<>forth between your math types and ImVec2/ImVec4.
// This will be inlined as part of ImVec2 and ImVec4 class declarations.
/*
#define IM_VEC2_CLASS_EXTRA                                                 \
        ImVec2(const MyVec2& f) { x = f.x; y = f.y; }                       \
        operator MyVec2() const { return MyVec2(x,y); }

#define IM_VEC4_CLASS_EXTRA                                                 \
        ImVec4(const MyVec4& f) { x = f.x; y = f.y; z = f.z; w = f.w; }     \
        operator MyVec4() const { return MyVec4(x,y,z,w); }
*/

//---- Use 32-bit vertex indices (default is 16-bit) to allow meshes with more than 64K vertices. Render function needs to support it.
//#define ImDrawIdx unsigned int

//---- Tip: You can add extra functions within the ImGui:: namespace, here or in your own headers files.
/*
namespace ImGui
{
    void MyFunction(const char* name, const MyMatrix44& v);
}
*/

```

`Private Esp/imgui/imgui.cpp`:

```cpp
// dear imgui, v1.67 WIP
// (main code and documentation)

// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.
// Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.
// Get latest version at https://github.com/ocornut/imgui
// Releases change-log at https://github.com/ocornut/imgui/releases
// Technical Support for Getting LoopCallbacked https://discourse.dearimgui.org/c/getting-started
// Gallery (please post your screenshots/video there!): https://github.com/ocornut/imgui/issues/1269
// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// This library is free but I need your support to sustain development and maintenance.
// If you work for a company, please consider financial support, see README. For individuals: https://www.patreon.com/imgui

// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

Index of this file:

DOCUMENTATION

- MISSION STATEMENT
- END-USER GUIDE
- PROGRAMMER GUIDE (read me!)
  - Read first
  - How to update to a newer version of Dear ImGui
  - Getting started with integrating Dear ImGui in your code/engine
  - This is how a simple application may look like (2 variations)
  - This is how a simple rendering function may look like
  - Using gamepad/keyboard navigation controls
- API BREAKING CHANGES (read me when you update!)
- FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
  - How can I tell whether to dispatch mouse/keyboard to imgui or to my application?
  - How can I display an image? What is ImTextureID, how does it works?
  - How can I have multiple widgets with the same label or without a label? A primer on labels and the ID Stack.
  - How can I use my own math types instead of ImVec2/ImVec4? 
  - How can I load a different font than the default?
  - How can I easily use icons in my application?
  - How can I load multiple fonts?
  - How can I display and input non-latin characters such as Chinese, Japanese, Korean, Cyrillic?
  - How can I use the drawing facilities without an ImGui window? (using ImDrawList API)
  - I integrated Dear ImGui in my engine and the text or lines are blurry..
  - I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..
  - How can I help?

CODE 
(search for "[SECTION]" in the code to find them)

// [SECTION] FORWARD DECLARATIONS
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
// [SECTION] MISC HELPER/UTILITIES (Maths, String, Format, Hash, File functions)
// [SECTION] MISC HELPER/UTILITIES (ImText* functions)
// [SECTION] MISC HELPER/UTILITIES (Color functions)
// [SECTION] ImGuiStorage
// [SECTION] ImGuiTextFilter
// [SECTION] ImGuiTextBuffer
// [SECTION] ImGuiListClipper
// [SECTION] RENDER HELPERS
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
// [SECTION] TOOLTIPS
// [SECTION] POPUPS
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
// [SECTION] COLUMNS
// [SECTION] DRAG AND DROP
// [SECTION] LOGGING/CAPTURING
// [SECTION] SETTINGS
// [SECTION] PLATFORM DEPENDENT HELPERS
// [SECTION] METRICS/DEBUG WINDOW

*/

//-----------------------------------------------------------------------------
// DOCUMENTATION
//-----------------------------------------------------------------------------

/*

 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools
 - Easy to hack and improve
 - Minimize screen real-estate usage
 - Minimize setup and maintenance
 - Minimize state storage on user side
 - Portable, minimize dependencies, run on target (consoles, phones, etc.)
 - Efficient runtime and memory consumption (NB- we do allocate when "growing" content e.g. creating a window,
   opening a tree node for the first time, etc. but a typical frame should not allocate anything)

 Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:
 - Doesn't look fancy, doesn't animate
 - Limited layout features, intricate layouts are typically crafted in code


 END-USER GUIDE
 ==============

 - Double-click on title bar to collapse window.
 - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().
 - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).
 - Click and drag on any empty space to move window.
 - TAB/SHIFT+TAB to cycle through keyboard editable fields.
 - CTRL+Click on a slider or drag box to input value as text.
 - Use mouse wheel to scroll.
 - Text editor:
   - Hold SHIFT or use mouse to select text.
   - CTRL+Left/Right to word jump.
   - CTRL+Shift+Left/Right to select words.
   - CTRL+A our Double-Click to select all.
   - CTRL+X,CTRL+C,CTRL+V to use OS clipboard/
   - CTRL+Z,CTRL+Y to undo/redo.
   - ESCAPE to revert text to its original value.
   - You can apply arithmetic operators +,*,/ on numerical values. Use +- to subtract (because - would set a negative value!)
   - Controls are automatically adjusted for OSX to match standard OSX text editing operations.
 - General Keyboard controls: enable with ImGuiConfigFlags_NavEnableKeyboard.
 - General Gamepad controls: enable with ImGuiConfigFlags_NavEnableGamepad. See suggested mappings in imgui.h ImGuiNavInput_ + download PNG/PSD at http://goo.gl/9LgVZW


 PROGRAMMER GUIDE
 ================

 READ FIRST

 - Read the FAQ below this section!
 - Your code creates the UI, if your code doesn't run the UI is gone! The UI can be highly dynamic, there are no construction
   or destruction steps, less superfluous data retention on your side, less state duplication, less state synchronization, less bugs.
 - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.
 - You can learn about immediate-mode GUI principles at http://www.johno.se/book/imgui.html or watch http://mollyrocket.com/861
   See README.md for more links describing the IMGUI paradigm. Dear ImGui is an implementation of the IMGUI paradigm.

 HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI

 - Overwrite all the sources files except for imconfig.h (if you have made modification to your copy of imconfig.h)
 - Or maintain your own branch where you have imconfig.h modified.
 - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
   likely be a comment about it. Please report any issue to the GitHub page!
 - Try to keep your copy of dear imgui reasonably up to date.

 GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE

 - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.
 - Add the Dear ImGui source files to your projects or using your preferred build system.
   It is recommended you build and statically link the .cpp files as part of your project and not as shared library (DLL).
 - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating imgui types with your own maths types.
 - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
 - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
   phases of your own application. All rendering informatioe are stored into command-lists that you will retrieve after calling ImGui::Render().
 - Refer to the bindings and demo applications in the examples/ folder for instruction on how to setup your code.
 - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.

 HOW A SIMPLE APPLICATION MAY LOOK LIKE
 EXHIBIT 1: USING THE EXAMPLE BINDINGS (imgui_impl_XXX.cpp files from the examples/ folder)

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Initialize helper Platform and Renderer bindings (here we are using imgui_impl_win32 and imgui_impl_dx11)
     ImGui_ImplWin32_Init(hwnd);
     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

     // Application main loop
     while (true)
     {
         // Feed inputs to dear imgui, start new frame
         ImGui_ImplDX11_NewFrame();
         ImGui_ImplWin32_NewFrame();
         ImGui::NewFrame();

         // Any application code here
         ImGui::Text("Hello, world!");

         // Render dear imgui into screen
         ImGui::Render();
         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
         g_pSwapChain->Present(1, 0);
     }
     
     // Shutdown
     ImGui_ImplDX11_Shutdown();
     ImGui_ImplWin32_Shutdown();
     ImGui::DestroyContext();

 HOW A SIMPLE APPLICATION MAY LOOK LIKE
 EXHIBIT 2: IMPLEMENTING CUSTOM BINDING / CUSTOM ENGINE

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Build and load the texture atlas into a texture
     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)
     int width, height;
     unsigned char* pixels = NULL;
     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

     // At this point you've got the texture data and you need to upload that your your graphic system:
     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.
     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ below for details about ImTextureID.
     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
     io.Fonts->TexID = (void*)texture;

     // Application main loop
     while (true)
     {
        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform bindings)
        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
        io.DisplaySize.x = 1920.0f;             // set the current display width
        io.DisplaySize.y = 1280.0f;             // set the current display height here
        io.MousePos = my_mouse_pos;             // set the mouse position
        io.MouseDown[0] = my_mouse_buttons[0];  // set the mouse button states
        io.MouseDown[1] = my_mouse_buttons[1];

        // Call NewFrame(), after this point you can use ImGui::* functions anytime
        // (So you want to try calling NewFrame() as early as you can in your mainloop to be able to use imgui everywhere)
        ImGui::NewFrame();

        // Most of your application code here
        ImGui::Text("Hello, world!");
        MyGameUpdate(); // may use any ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
        MyGameRender(); // may use any ImGui functions as well!

        // Render imgui, swap buffers
        // (You want to try calling EndFrame/Render as late as you can, to be able to use imgui in your own game rendering code)
        ImGui::EndFrame();
        ImGui::Render();
        ImDrawData* draw_data = ImGui::GetDrawData();
        MyImGuiRenderFunction(draw_data);
        SwapBuffers();
     }

     // Shutdown
     ImGui::DestroyContext();

 HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE

    void void MyImGuiRenderFunction(ImDrawData* draw_data)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
       // TODO: Setup viewport using draw_data->DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
       for (int n = 0; n < draw_data->CmdListsCount; n++)
       {
          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui
          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui
          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
          {
             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
             if (pcmd->UserCallback)
             {
                 pcmd->UserCallback(cmd_list, pcmd);
             }
             else
             {
                 // The texture for the draw call is specified by pcmd->TextureId.
                 // The vast majority of draw calls will use the imgui texture atlas, which value you have set yourself during initialization.
                 MyEngineBindTexture((MyTexture*)pcmd->TextureId);

                 // We are using scissoring to clip some objects. All low-level graphics API should supports it.
                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
                 //   (some elements visible outside their bounds) but you can fix that once everything else works!
                 // - Clipping coordinates are provided in imgui coordinates space (from draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize)
                 //   In a single viewport application, draw_data->DisplayPos will always be (0,0) and draw_data->DisplaySize will always be == io.DisplaySize.
                 //   However, in the interest of supporting multi-viewport applications in the future (see 'viewport' branch on github), 
                 //   always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
                 ImVec2 pos = draw_data->DisplayPos;
                 MyEngineScissor((int)(pcmd->ClipRect.x - pos.x), (int)(pcmd->ClipRect.y - pos.y), (int)(pcmd->ClipRect.z - pos.x), (int)(pcmd->ClipRect.w - pos.y));

                 // Render 'pcmd->ElemCount/3' indexed triangles.
                 // By default the indices ImDrawIdx are 16-bits, you can change them to 32-bits in imconfig.h if your engine doesn't support 16-bits indices.
                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);
             }
             idx_buffer += pcmd->ElemCount;
          }
       }
    }

 - The examples/ folders contains many actual implementation of the pseudo-codes above.
 - When calling NewFrame(), the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags are updated.
   They tell you if Dear ImGui intends to use your inputs. When a flag is set you want to hide the corresponding inputs 
   from the rest of your application. In every cases you need to pass on the inputs to imgui. Refer to the FAQ for more information.
 - Please read the FAQ below!. Amusingly, it is called a FAQ because people frequently run into the same issues!

 USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS

 - The gamepad/keyboard navigation is fairly functional and keeps being improved. 
 - Gamepad support is particularly useful to use dear imgui on a console system (e.g. PS4, Switch, XB1) without a mouse!
 - You can ask questions and report issues at https://github.com/ocornut/imgui/issues/787
 - The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable.
 - Gamepad:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable.
    - Backend: Set io.BackendFlags |= ImGuiBackendFlags_HasGamepad + fill the io.NavInputs[] fields before calling NewFrame().
      Note that io.NavInputs[] is cleared by EndFrame().
    - See 'enum ImGuiNavInput_' in imgui.h for a description of inputs. For each entry of io.NavInputs[], set the following values:
         0.0f= not held. 1.0f= fully held. Pass intermediate 0.0f..1.0f values for analog triggers/sticks.
    - We uses a simple >0.0f test for activation testing, and won't attempt to test for a dead-zone.
      Your code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
    - You can download PNG/PSD files depicting the gamepad controls for common controllers at: http://goo.gl/9LgVZW.
    - If you need to share inputs between your game and the imgui parts, the easiest approach is to go all-or-nothing, with a buttons combo
      to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.
 - Keyboard:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable.
      NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
    - When keyboard navigation is active (io.NavActive + ImGuiConfigFlags_NavEnableKeyboard), the io.WantCaptureKeyboard flag
      will be set. For more advanced uses, you may want to read from:
       - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
       - io.NavVisible: true when the navigation cursor is visible (and usually goes false when mouse is used).
       - or query focus information with e.g. IsWindowFocused(ImGuiFocusedFlags_AnyWindow), IsItemFocused() etc. functions.
      Please reach out if you think the game vs navigation input sharing could be improved.
 - Mouse:
    - PS4 users: Consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback.
    - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + uSynergy.c (on your console/tablet/phone app) to share your PC mouse/keyboard.
    - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the ImGuiConfigFlags_NavEnableSetMousePos flag.
      Enabling ImGuiConfigFlags_NavEnableSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs dear imgui to move your mouse cursor along with navigation movements.
      When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
      When that happens your back-end NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the binding in examples/ do that.
      (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, imgui will misbehave as it will see your mouse as moving back and forth!)
      (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
       to set a boolean to ignore your other external mouse positions until the external source is moved again.)


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
 Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
 When you are not sure about a old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.
 You can read releases logs https://github.com/ocornut/imgui/releases for more details.

 - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.
 - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.
 - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).
 - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h. 
                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.
 - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)
 - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.
                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.
                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.
 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
 - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details. 
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.
                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
                       consistent with other functions. Kept redirection functions (will obsolete).
 - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some binding ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.
 - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.
                       - removed Shutdown() function, as DestroyContext() serve this purpose.
                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
 - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
 - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
 - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.
                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your binding if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2(-1,-1)" with "io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.
 - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
 - 2017/08/13 (1.51) - renamed ImGuiCol_Columns*** to ImGuiCol_Separator***. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed ImGuiSetCond_*** types and flags to ImGuiCond_***. Kept redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0))'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetId() and use it instead of passing string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.
                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you.
                       If your TitleBg/TitleBgActive alpha was <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color.
                           ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col)
                           {
                               float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a;
                               return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a);
                           }
                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref github issue #337).
 - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
                     - if you are using a vanilla copy of one of the imgui_impl_XXXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
                     - the signature of the io.RenderDrawListsFn handler has changed!
                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
                         argument:   'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely be used. Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
 - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
              (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
                       font init:  const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); <..Upload texture to GPU..>
                       became:     unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); <..Upload texture to GPU>; io.Fonts->TexId = YourTextureIdentifier;
                       you now more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs.
                       it is now recommended that you sample the font texture with bilinear interpolation.
              (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to set io.Fonts->TexID.
              (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
              (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes


 FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
 ======================================

 Q: How can I tell whether to dispatch mouse/keyboard to imgui or to my application?
 A: You can read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags from the ImGuiIO structure (e.g. if (ImGui::GetIO().WantCaptureMouse) { ... } )
    - When 'io.WantCaptureMouse' is set, imgui wants to use your mouse state, and you may want to discard/hide the inputs from the rest of your application.
    - When 'io.WantCaptureKeyboard' is set, imgui wants to use your keyboard state, and you may want to discard/hide the inputs from the rest of your application.
    - When 'io.WantTextInput' is set to may want to notify your OS to popup an on-screen keyboard, if available (e.g. on a mobile phone, or console OS).
    Note: you should always pass your mouse/keyboard inputs to imgui, even when the io.WantCaptureXXX flag are set false.
     This is because imgui needs to detect that you clicked in the void to unfocus its own windows.
    Note: The 'io.WantCaptureMouse' is more accurate that any attempt to "check if the mouse is hovering a window" (don't do that!).
     It handle mouse dragging correctly (both dragging that started over your application or over an imgui window) and handle e.g. modal windows blocking inputs.
     Those flags are updated by ImGui::NewFrame(). Preferably read the flags after calling NewFrame() if you can afford it, but reading them before is also
     perfectly fine, as the bool toggle fairly rarely. If you have on a touch device, you might find use for an early call to UpdateHoveredWindowAndCaptureFlags().
    Note: Text input widget releases focus on "Return KeyDown", so the subsequent "Return KeyUp" event that your application receive will typically
     have 'io.WantCaptureKeyboard=false'. Depending on your application logic it may or not be inconvenient. You might want to track which key-downs
     were targeted for Dear ImGui, e.g. with an array of bool, and filter out the corresponding key-ups.)

 Q: How can I display an image? What is ImTextureID, how does it works?
 A: Short explanation:
    - You may use functions such as ImGui::Image(), ImGui::ImageButton() or lower-level ImDrawList::AddImage() to emit draw calls that will use your own textures.
    - Actual textures are identified in a way that is up to the user/engine. Those identifiers are stored and passed as ImTextureID (void*) value.
    - Loading image files from the disk and turning them into a texture is not within the scope of Dear ImGui (for a good reason). 
      Please read documentations or tutorials on your graphics API to understand how to display textures on the screen before moving onward.

    Long explanation:
    - Dear ImGui's job is to create "meshes", defined in a renderer-agnostic format made of draw commands and vertices.
      At the end of the frame those meshes (ImDrawList) will be displayed by your rendering function. They are made up of textured polygons and the code
      to render them is generally fairly short (a few dozen lines). In the examples/ folder we provide functions for popular graphics API (OpenGL, DirectX, etc.).
    - Each rendering function decides on a data type to represent "textures". The concept of what is a "texture" is entirely tied to your underlying engine/graphics API.
      We carry the information to identify a "texture" in the ImTextureID type. 
      ImTextureID is nothing more that a void*, aka 4/8 bytes worth of data: just enough to store 1 pointer or 1 integer of your choice.
      Dear ImGui doesn't know or understand what you are storing in ImTextureID, it merely pass ImTextureID values until they reach your rendering function.
    - In the examples/ bindings, for each graphics API binding we decided on a type that is likely to be a good representation for specifying 
      an image from the end-user perspective. This is what the _examples_ rendering functions are using:

         OpenGL:     ImTextureID = GLuint                       (see ImGui_ImplGlfwGL3_RenderDrawData() function in imgui_impl_glfw_gl3.cpp)
         DirectX9:   ImTextureID = LPDIRECT3DTEXTURE9           (see ImGui_ImplDX9_RenderDrawData()     function in imgui_impl_dx9.cpp)
         DirectX11:  ImTextureID = ID3D11ShaderResourceView*    (see ImGui_ImplDX11_RenderDrawData()    function in imgui_impl_dx11.cpp)
         DirectX12:  ImTextureID = D3D12_GPU_DESCRIPTOR_HANDLE  (see ImGui_ImplDX12_RenderDrawData()    function in imgui_impl_dx12.cpp)

      For example, in the OpenGL example binding we store raw OpenGL texture identifier (GLuint) inside ImTextureID. 
      Whereas in the DirectX11 example binding we store a pointer to ID3D11ShaderResourceView inside ImTextureID, which is a higher-level structure 
      tying together both the texture and information about its format and how to read it.
    - If you have a custom engine built over e.g. OpenGL, instead of passing GLuint around you may decide to use a high-level data type to carry information about
      the texture as well as how to display it (shaders, etc.). The decision of what to use as ImTextureID can always be made better knowing how your codebase
      is designed. If your engine has high-level data types for "textures" and "material" then you may want to use them.
      If you are starting with OpenGL or DirectX or Vulkan and haven't built much of a rendering engine over them, keeping the default ImTextureID 
      representation suggested by the example bindings is probably the best choice.
      (Advanced users may also decide to keep a low-level type in ImTextureID, and use ImDrawList callback and pass information to their renderer)

    User code may do:

        // Cast our texture type to ImTextureID / void*
        MyTexture* texture = g_CoffeeTableTexture;
        ImGui::Image((void*)texture, ImVec2(texture->Width, texture->Height)); 

    The renderer function called after ImGui::Render() will receive that same value that the user code passed:

        // Cast ImTextureID / void* stored in the draw command as our texture type
        MyTexture* texture = (MyTexture*)pcmd->TextureId;
        MyEngineBindTexture2D(texture);

    Once you understand this design you will understand that loading image files and turning them into displayable textures is not within the scope of Dear ImGui.
    This is by design and is actually a good thing, because it means your code has full control over your data types and how you display them.
    If you want to display an image file (e.g. PNG file) into the screen, please refer to documentation and tutorials for the graphics API you are using.

    Here's a simplified OpenGL example using stb_image.h:

        // Use stb_image.h to load a PNG from disk and turn it into raw RGBA pixel data:
        #define STB_IMAGE_IMPLEMENTATION
        #include <stb_image.h>
        [...]
        int my_image_width, my_image_height;
        unsigned char* my_image_data = stbi_load("my_image.png", &my_image_width, &my_image_height, NULL, 4);

        // Turn the RGBA pixel data into an OpenGL texture:
        GLuint my_opengl_texture;
        glGenTextures(1, &my_opengl_texture);
        glBindTexture(GL_TEXTURE_2D, my_opengl_texture);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image_width, image_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);

        // Now that we have an OpenGL texture, assuming our imgui rendering function (imgui_impl_xxx.cpp file) takes GLuint as ImTextureID, we can display it:
        ImGui::Image((void*)(intptr_t)my_opengl_texture, ImVec2(my_image_width, my_image_height));

    C/C++ tip: a void* is pointer-sized storage. You may safely store any pointer or integer into it by casting your value to ImTexture / void*, and vice-versa. 
    Because both end-points (user code and rendering function) are under your control, you know exactly what is stored inside the ImTexture / void*.
    Examples:

        GLuint my_tex = XXX;
        void* my_void_ptr;
        my_void_ptr = (void*)(intptr_t)my_tex;                  // cast a GLuint into a void* (we don't take its address! we literally store the value inside the pointer)
        my_tex = (GLuint)(intptr_t)my_void_ptr;                 // cast a void* into a GLuint

        ID3D11ShaderResourceView* my_dx11_srv = XXX;
        void* my_void_ptr;
        my_void_ptr = (void*)my_dx11_srv;                       // cast a ID3D11ShaderResourceView* into an opaque void*
        my_dx11_srv = (ID3D11ShaderResourceView*)my_void_ptr;   // cast a void* into a ID3D11ShaderResourceView*

    Finally, you may call ImGui::ShowMetricsWindow() to explore/visualize/understand how the ImDrawList are generated.

 Q: How can I have multiple widgets with the same label or without a label?
 Q: I have multiple widgets with the same label, and only the first one works. Why is that?
 A: A primer on labels and the ID Stack...

    Dear ImGui internally need to uniquely identify UI elements.
    Elements that are typically not clickable (such as calls to the Text functions) don't need an ID.
    Interactive widgets (such as calls to Button buttons) need a unique ID. 
    Unique ID are used internally to track active widgets and occasionally associate state to widgets.
    Unique ID are implicitly built from the hash of multiple elements that identify the "path" to the UI element.

   - Unique ID are often derived from a string label:

       Button("OK");          // Label = "OK",     ID = hash of (..., "OK")
       Button("Cancel");      // Label = "Cancel", ID = hash of (..., "Cancel")

   - ID are uniquely scoped within windows, tree nodes, etc. which all pushes to the ID stack. Having
     two buttons labeled "OK" in different windows or different tree locations is fine.
     We used "..." above to signify whatever was already pushed to the ID stack previously:

       Begin("MyWindow");
       Button("OK");          // Label = "OK",     ID = hash of ("MyWindow", "OK")
       End();

   - If you have a same ID twice in the same location, you'll have a conflict:

       Button("OK");
       Button("OK");          // ID collision! Interacting with either button will trigger the first one.

     Fear not! this is easy to solve and there are many ways to solve it!

   - Solving ID conflict in a simple/local context:
     When passing a label you can optionally specify extra ID information within string itself.
     Use "##" to pass a complement to the ID that won't be visible to the end-user.
     This helps solving the simple collision cases when you know e.g. at compilation time which items
     are going to be created:

       Begin("MyWindow");
       Button("Play");        // Label = "Play",   ID = hash of ("MyWindow", "Play")
       Button("Play##foo1");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo1")  // Different from above
       Button("Play##foo2");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo2")  // Different from above
       End();

   - If you want to completely hide the label, but still need an ID:

       Checkbox("##On", &b);  // Label = "",       ID = hash of (..., "##On")   // No visible label, just a checkbox!

   - Occasionally/rarely you might want change a label while preserving a constant ID. This allows
     you to animate labels. For example you may want to include varying information in a window title bar,
     but windows are uniquely identified by their ID. Use "###" to pass a label that isn't part of ID:

       Button("Hello###ID");  // Label = "Hello",  ID = hash of (..., "ID")
       Button("World###ID");  // Label = "World",  ID = hash of (..., "ID")     // Same as above, even though the label looks different

       sprintf(buf, "My game (%f FPS)###MyGame", fps);
       Begin(buf);            // Variable title,   ID = hash of "MyGame"

   - Solving ID conflict in a more general manner:
     Use PushID() / PopID() to create scopes and manipulate the ID stack, as to avoid ID conflicts
     within the same window. This is the most convenient way of distinguishing ID when iterating and
     creating many UI elements programmatically.
     You can push a pointer, a string or an integer value into the ID stack.
     Remember that ID are formed from the concatenation of _everything_ in the ID stack!

       Begin("Window");
       for (int i = 0; i < 100; i++)
       {
         PushID(i);         // Push i to the id tack
         Button("Click");   // Label = "Click",  ID = Hash of ("Window", i, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj);
         Button("Click");   // Label = "Click",  ID = Hash of ("Window", obj pointer, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj->Name);
         Button("Click");   // Label = "Click",  ID = Hash of ("Window", obj->Name, "Click")
         PopID();
       }
       End();

   - More example showing that you can stack multiple prefixes into the ID stack:

       Button("Click");     // Label = "Click",  ID = hash of (..., "Click")
       PushID("node");
       Button("Click");     // Label = "Click",  ID = hash of (..., "node", "Click")
         PushID(my_ptr);
           Button("Click"); // Label = "Click",  ID = hash of (..., "node", my_ptr, "Click")
         PopID();
       PopID();

   - Tree nodes implicitly creates a scope for you by calling PushID().

       Button("Click");     // Label = "Click",  ID = hash of (..., "Click")
       if (TreeNode("node"))
       {
         Button("Click");   // Label = "Click",  ID = hash of (..., "node", "Click")
         TreePop();
       }

   - When working with trees, ID are used to preserve the open/close state of each tree node.
     Depending on your use cases you may want to use strings, indices or pointers as ID.
      e.g. when following a single pointer that may change over time, using a static string as ID
       will preserve your node open/closed state when the targeted object change.
      e.g. when displaying a list of objects, using indices or pointers as ID will preserve the
       node open/closed state differently. See what makes more sense in your situation!

 Q: How can I use my own math types instead of ImVec2/ImVec4? 
 A: You can edit imconfig.h and setup the IM_VEC2_CLASS_EXTRA/IM_VEC4_CLASS_EXTRA macros to add implicit type conversions.
    This way you'll be able to use your own types everywhere, e.g. passsing glm::vec2 to ImGui functions instead of ImVec2.

 Q: How can I load a different font than the default?
 A: Use the font atlas to load the TTF/OTF file you want:
      ImGuiIO& io = ImGui::GetIO();
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
    Default is ProggyClean.ttf, rendered at size 13, embedded in dear imgui's source code.
    (Read the 'misc/fonts/README.txt' file for more details about font loading.)

    New programmers: remember that in C/C++ and most programming languages if you want to use a
    backslash \ within a string literal, you need to write it double backslash "\\":
      io.Fonts->AddFontFromFileTTF("MyDataFolder\MyFontFile.ttf", size_in_pixels);   // WRONG (you are escape the M here!)
      io.Fonts->AddFontFromFileTTF("MyDataFolder\\MyFontFile.ttf", size_in_pixels);  // CORRECT
      io.Fonts->AddFontFromFileTTF("MyDataFolder/MyFontFile.ttf", size_in_pixels);   // ALSO CORRECT

 Q: How can I easily use icons in my application?
 A: The most convenient and practical way is to merge an icon font such as FontAwesome inside you
    main font. Then you can refer to icons within your strings. 
    (Read the 'misc/fonts/README.txt' file for more details about icons font loading.)

 Q: How can I load multiple fonts?
 A: Use the font atlas to pack them into a single texture:
    (Read the 'misc/fonts/README.txt' file and the code in ImFontAtlas for more details.)

      ImGuiIO& io = ImGui::GetIO();
      ImFont* font0 = io.Fonts->AddFontDefault();
      ImFont* font1 = io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
      ImFont* font2 = io.Fonts->AddFontFromFileTTF("myfontfile2.ttf", size_in_pixels);
      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
      // the first loaded font gets used by default
      // use ImGui::PushFont()/ImGui::PopFont() to change the font at runtime

      // Options
      ImFontConfig config;
      config.OversampleH = 3;
      config.OversampleV = 1;
      config.GlyphOffset.y -= 2.0f;      // Move everything by 2 pixels up
      config.GlyphExtraSpacing.x = 1.0f; // Increase spacing between characters
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_pixels, &config);

      // Combine multiple fonts into one (e.g. for icon fonts)
      static ImWchar ranges[] = { 0xf000, 0xf3ff, 0 };
      ImFontConfig config;
      config.MergeMode = true;
      io.Fonts->AddFontDefault();
      io.Fonts->AddFontFromFileTTF("fontawesome-webfont.ttf", 16.0f, &config, ranges); // Merge icon font
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_pixels, NULL, &config, io.Fonts->GetGlyphRangesJapanese()); // Merge japanese glyphs

 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
 A: When loading a font, pass custom Unicode ranges to specify the glyphs to load.

      // Add default Japanese ranges
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, io.Fonts->GetGlyphRangesJapanese());

      // Or create your own custom ranges (e.g. for a game you can feed your entire game script and only build the characters the game need)
      ImVector<ImWchar> ranges;
      ImFontAtlas::GlyphRangesBuilder builder;
      builder.AddText("Hello world");                        // Add a string (here "Hello world" contains 7 unique characters)
      builder.AddChar(0x7262);                               // Add a specific character
      builder.AddRanges(io.Fonts->GetGlyphRangesJapanese()); // Add one of the default ranges
      builder.BuildRanges(&ranges);                          // Build the final result (ordered ranges with all the unique characters submitted)
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, ranges.Data);

    All your strings needs to use UTF-8 encoding. In C++11 you can encode a string literal in UTF-8
    by using the u8"hello" syntax. Specifying literal in your source code using a local code page
    (such as CP-923 for Japanese or CP-1251 for Cyrillic) will NOT work!
    Otherwise you can convert yourself to UTF-8 or load text data from file already saved as UTF-8.

    Text input: it is up to your application to pass the right character code by calling io.AddInputCharacter(). 
    The applications in examples/ are doing that. 
    Windows: you can use the WM_CHAR or WM_UNICHAR or WM_IME_CHAR message (depending if your app is built using Unicode or MultiByte mode).
    You may also use MultiByteToWideChar() or ToUnicode() to retrieve Unicode codepoints from MultiByte characters or keyboard state.
    Windows: if your language is relying on an Input Method Editor (IME), you copy the HWND of your window to io.ImeWindowHandle in order for 
    the default implementation of io.ImeSetInputScreenPosFn() to set your Microsoft IME position correctly.

 Q: How can I use the drawing facilities without an ImGui window? (using ImDrawList API)
 A: - You can create a dummy window. Call Begin() with the NoBackground | NoDecoration | NoSavedSettings | NoInputs flags.
      (The ImGuiWindowFlags_NoDecoration flag itself is a shortcut for NoTitleBar | NoResize | NoScrollbar | NoCollapse)
      Then you can retrieve the ImDrawList* via GetWindowDrawList() and draw to it in any way you like.
    - You can call ImGui::GetOverlayDrawList() and use this draw list to display contents over every other imgui windows.
    - You can create your own ImDrawList instance. You'll need to initialize them ImGui::GetDrawListSharedData(), or create your own ImDrawListSharedData,
      and then call your rendered code with your own ImDrawList or ImDrawData data.

 Q: I integrated Dear ImGui in my engine and the text or lines are blurry..
 A: In your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f).
    Also make sure your orthographic projection matrix and io.DisplaySize matches your actual framebuffer dimension.

 Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..
 A: You are probably mishandling the clipping rectangles in your render function.
    Rectangles provided by ImGui are defined as (x1=left,y1=top,x2=right,y2=bottom) and NOT as (x1,y1,width,height).

 Q: How can I help?
 A: - If you are experienced with Dear ImGui and C++, look at the github issues, or docs/TODO.txt and see how you want/can help!
    - Convince your company to sponsor/fund development! Individual users: you can also become a Patron (patreon.com/imgui) or donate on PayPal! See README.
    - Disclose your usage of dear imgui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
      You may post screenshot or links in the gallery threads (github.com/ocornut/imgui/issues/1269). Visuals are ideal as they inspire other programmers.
      But even without visuals, disclosing your use of dear imgui help the library grow credibility, and help other teams and programmers with taking decisions.
    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on github or privately).

 - tip: you can call Begin() multiple times with the same name during the same frame, it will keep appending to the same window.
        this is also useful to set yourself in the context of another window (to get/set other settings)
 - tip: you can create widgets without a Begin()/End() block, they will go in an implicit window called "Debug".
 - tip: the ImGuiOnceUponAFrame helper will allow run the block of code only once a frame. You can use it to quickly add custom UI in the middle
        of a deep nested inner loop in your code.
 - tip: you can call Render() multiple times (e.g for VR renders).
 - tip: call and read the ShowDemoWindow() code in imgui_demo.cpp for more example of how to use ImGui!

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

#include <ctype.h>      // toupper, isprint
#include <stdio.h>      // vsnprintf, sscanf, printf
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// Debug options
#define IMGUI_DEBUG_NAV_SCORING     0
#define IMGUI_DEBUG_NAV_RECTS       0

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)     // condition expression is constant
#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wunknown-pragmas"        // warning : unknown warning group '-Wformat-pedantic *'        // not all warnings are known by all clang versions.. so ignoring warnings triggers new warnings on some configuration. great!
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wexit-time-destructors"  // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#pragma clang diagnostic ignored "-Wformat-pedantic"        // warning : format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast" // warning : cast to 'void *' from smaller integer type 'int'
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"      // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wstrict-overflow"          // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif
#endif

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
static const float NAV_WINDOWING_HIGHLIGHT_DELAY            = 0.20f;    // Time before the highlight and screen dimming starts fading in
static const float NAV_WINDOWING_LIST_APPEAR_DELAY          = 0.15f;    // Time before the window list starts to appear

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by back-end)
static const float WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS = 4.0f;     // Extend outside and inside windows. Affect FindHoveredWindow().
static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    // Reduce visual noise by only highlighting the border after a certain time.

//-------------------------------------------------------------------------
// [SECTION] FORWARD DECLARATIONS
//-------------------------------------------------------------------------

static void             SetCurrentWindow(ImGuiWindow* window);
static void             SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond);
static void             SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond);
static void             SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond);
static void             FindHoveredWindow();
static ImGuiWindow*     CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags);
static void             CheckStacksSize(ImGuiWindow* window, bool write);
static ImVec2           CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges);

static void             AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list);
static void             AddWindowToDrawData(ImVector<ImDrawList*>* out_list, ImGuiWindow* window);
static void             AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window);

static ImRect           GetViewportRect();

// Settings
static void*            SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name);
static void             SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line);
static void             SettingsHandlerWindow_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf);

// Platform Dependents default implementation for IO functions
static const char*      GetClipboardTextFn_DefaultImpl(void* user_data);
static void             SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);
static void             ImeSetInputScreenPosFn_DefaultImpl(int x, int y);

namespace ImGui
{
static bool             BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags);

// Navigation
static void             NavUpdate();
static void             NavUpdateWindowing();
static void             NavUpdateWindowingList();
static void             NavUpdateMoveResult();
static float            NavUpdatePageUpPageDown(int allowed_dir_flags);
static inline void      NavUpdateAnyRequestFlag();
static void             NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id);
static ImVec2           NavCalcPreferredRefPos();
static void             NavSaveLastChildNavWindow(ImGuiWindow* nav_window);
static ImGuiWindow*     NavRestoreLastChildNavWindow(ImGuiWindow* window);

// Misc
static void             UpdateMouseInputs();
static void             UpdateMouseWheel();
static void             UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4]);
}

//-----------------------------------------------------------------------------
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
//-----------------------------------------------------------------------------

// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.
// CreateContext() will automatically set this pointer if it is NULL. Change to a different context by calling ImGui::SetCurrentContext().
// If you use DLL hotreloading you might need to call SetCurrentContext() after reloading code from this file.
// ImGui functions are not thread-safe because of this pointer. If you want thread-safety to allow N threads to access N different contexts, you can:
// - Change this variable to use thread local storage. You may #define GImGui in imconfig.h for that purpose. Future development aim to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
// - Having multiple instances of the ImGui code compiled inside different namespace (easiest/safest, if you have a finite number of contexts)
#ifndef GImGui
ImGuiContext*   GImGui = NULL;
#endif

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// If you use DLL hotreloading you might need to call SetAllocatorFunctions() after reloading code from this file.
// Otherwise, you probably don't want to modify them mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS
static void*   MallocWrapper(size_t size, void* user_data)    { (void)user_data; return malloc(size); }
static void    FreeWrapper(void* ptr, void* user_data)        { (void)user_data; free(ptr); }
#else
static void*   MallocWrapper(size_t size, void* user_data)    { (void)user_data; (void)size; IM_ASSERT(0); return NULL; }
static void    FreeWrapper(void* ptr, void* user_data)        { (void)user_data; (void)ptr; IM_ASSERT(0); }
#endif

static void*  (*GImAllocatorAllocFunc)(size_t size, void* user_data) = MallocWrapper;
static void   (*GImAllocatorFreeFunc)(void* ptr, void* user_data) = FreeWrapper;
static void*    GImAllocatorUserData = NULL;

//-----------------------------------------------------------------------------
// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
//-----------------------------------------------------------------------------

ImGuiStyle::ImGuiStyle()
{
    Alpha                   = 1.0f;             // Global alpha applies to everything in ImGui
    WindowPadding           = ImVec2(8,8);      // Padding within a window
    WindowRounding          = 7.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows
    WindowBorderSize        = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    WindowMinSize           = ImVec2(32,32);    // Minimum window size
    WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text
    ChildRounding           = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
    ChildBorderSize         = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    PopupRounding           = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
    PopupBorderSize         = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
    FrameRounding           = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
    FrameBorderSize         = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
    ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
    ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
    TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
    IndentSpacing           = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
    ColumnsMinSpacing       = 6.0f;             // Minimum horizontal spacing between two columns
    ScrollbarSize           = 16.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
    ScrollbarRounding       = 9.0f;             // Radius of grab corners rounding for scrollbar
    GrabMinSize             = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar
    GrabRounding            = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
    TabRounding             = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
    TabBorderSize           = 0.0f;             // Thickness of border around tabs.
    ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
    DisplayWindowPadding    = ImVec2(19,19);    // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.
    DisplaySafeAreaPadding  = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
    MouseCursorScale        = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
    AntiAliasedLines        = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.
    AntiAliasedFill         = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
    CurveTessellationTol    = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.

    // Default theme
    ImGui::StyleColorsDark(this);
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
void ImGuiStyle::ScaleAllSizes(float scale_factor)
{
    WindowPadding = ImFloor(WindowPadding * scale_factor);
    WindowRounding = ImFloor(WindowRounding * scale_factor);
    WindowMinSize = ImFloor(WindowMinSize * scale_factor);
    ChildRounding = ImFloor(ChildRounding * scale_factor);
    PopupRounding = ImFloor(PopupRounding * scale_factor);
    FramePadding = ImFloor(FramePadding * scale_factor);
    FrameRounding = ImFloor(FrameRounding * scale_factor);
    TabRounding = ImFloor(TabRounding * scale_factor);
    ItemSpacing = ImFloor(ItemSpacing * scale_factor);
    ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);
    TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);
    IndentSpacing = ImFloor(IndentSpacing * scale_factor);
    ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);
    ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);
    ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);
    GrabMinSize = ImFloor(GrabMinSize * scale_factor);
    GrabRounding = ImFloor(GrabRounding * scale_factor);
    DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);
    DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);
    MouseCursorScale = ImFloor(MouseCursorScale * scale_factor);
}

ImGuiIO::ImGuiIO()
{
    // Most fields are initialized with zero
    memset(this, 0, sizeof(*this));

    // Settings
    ConfigFlags = ImGuiConfigFlags_None;
    BackendFlags = ImGuiBackendFlags_None;
    DisplaySize = ImVec2(-1.0f, -1.0f);
    DeltaTime = 1.0f/60.0f;
    IniSavingRate = 5.0f;
    IniFilename = "imgui.ini";
    LogFilename = "imgui_log.txt";
    MouseDoubleClickTime = 0.30f;
    MouseDoubleClickMaxDist = 6.0f;
    for (int i = 0; i < ImGuiKey_COUNT; i++)
        KeyMap[i] = -1;
    KeyRepeatDelay = 0.250f;
    KeyRepeatRate = 0.050f;
    UserData = NULL;

    Fonts = NULL;
    FontGlobalScale = 1.0f;
    FontDefault = NULL;
    FontAllowUserScaling = false;
    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);
    DisplayVisibleMin = DisplayVisibleMax = ImVec2(0.0f, 0.0f);

    // Miscellaneous configuration options
#ifdef __APPLE__
    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
#else
    ConfigMacOSXBehaviors = false;
#endif
    ConfigInputTextCursorBlink = true;
    ConfigWindowsResizeFromEdges = true;
    ConfigWindowsMoveFromTitleBarOnly = false;

    // Platform Functions
    BackendPlatformName = BackendRendererName = NULL;
    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations
    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
    ClipboardUserData = NULL;
    ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;
    ImeWindowHandle = NULL;

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    RenderDrawListsFn = NULL;
#endif

    // Input (NB: we already have memset zero the entire structure!)
    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
    MouseDragThreshold = 6.0f;
    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i]  = KeysDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(NavInputsDownDuration); i++) NavInputsDownDuration[i] = -1.0f;
}

// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
void ImGuiIO::AddInputCharacter(ImWchar c)
{
    const int n = ImStrlenW(InputCharacters);
    if (n + 1 < IM_ARRAYSIZE(InputCharacters))
    {
        InputCharacters[n] = c;
        InputCharacters[n+1] = '\0';
    }
}

void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)
{
    // We can't pass more wchars than ImGuiIO::InputCharacters[] can hold so don't convert more
    const int wchars_buf_len = sizeof(ImGuiIO::InputCharacters) / sizeof(ImWchar);
    ImWchar wchars[wchars_buf_len];
    ImTextStrFromUtf8(wchars, wchars_buf_len, utf8_chars, NULL);
    for (int i = 0; i < wchars_buf_len && wchars[i] != 0; i++)
        AddInputCharacter(wchars[i]);
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPER/UTILITIES (Maths, String, Format, Hash, File functions)
//-----------------------------------------------------------------------------

ImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)
{
    ImVec2 ap = p - a;
    ImVec2 ab_dir = b - a;
    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
    if (dot < 0.0f)
        return a;
    float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
    if (dot > ab_len_sqr)
        return b;
    return a + ab_dir * dot / ab_len_sqr;
}

bool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;
    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;
    return ((b1 == b2) && (b2 == b3));
}

void ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)
{
    ImVec2 v0 = b - a;
    ImVec2 v1 = c - a;
    ImVec2 v2 = p - a;
    const float denom = v0.x * v1.y - v1.x * v0.y;
    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
    out_u = 1.0f - out_v - out_w;
}

ImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    ImVec2 proj_ab = ImLineClosestPoint(a, b, p);
    ImVec2 proj_bc = ImLineClosestPoint(b, c, p);
    ImVec2 proj_ca = ImLineClosestPoint(c, a, p);
    float dist2_ab = ImLengthSqr(p - proj_ab);
    float dist2_bc = ImLengthSqr(p - proj_bc);
    float dist2_ca = ImLengthSqr(p - proj_ca);
    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));
    if (m == dist2_ab)
        return proj_ab;
    if (m == dist2_bc)
        return proj_bc;
    return proj_ca;
}

int ImStricmp(const char* str1, const char* str2)
{
    int d;
    while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }
    return d;
}

int ImStrnicmp(const char* str1, const char* str2, size_t count)
{
    int d = 0;
    while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }
    return d;
}

void ImStrncpy(char* dst, const char* src, size_t count)
{
    if (count < 1) return;
    strncpy(dst, src, count);
    dst[count-1] = 0;
}

char* ImStrdup(const char *str)
{
    size_t len = strlen(str) + 1;
    void* buf = ImGui::MemAlloc(len);
    return (char*)memcpy(buf, (const void*)str, len);
}

const char* ImStrchrRange(const char* str, const char* str_end, char c)
{
    const char* p = (const char*)memchr(str, (int)c, str_end - str);
    return p;
}

int ImStrlenW(const ImWchar* str)
{
    //return (int)wcslen((const wchar_t*)str);	// FIXME-OPT: Could use this when wchar_t are 16-bits
    int n = 0;
    while (*str++) n++;
    return n;
}

// Find end-of-line. Return pointer will point to either first \n, either str_end.
const char* ImStreolRange(const char* str, const char* str_end)
{
    const char* p = (const char*)memchr(str, '\n', str_end - str);
    return p ? p : str_end;
}

const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) // find beginning-of-line
{
    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')
        buf_mid_line--;
    return buf_mid_line;
}

const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
{
    if (!needle_end)
        needle_end = needle + strlen(needle);

    const char un0 = (char)toupper(*needle);
    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))
    {
        if (toupper(*haystack) == un0)
        {
            const char* b = needle + 1;
            for (const char* a = haystack + 1; b < needle_end; a++, b++)
                if (toupper(*a) != toupper(*b))
                    break;
            if (b == needle_end)
                return haystack;
        }
        haystack++;
    }
    return NULL;
}

// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.
void ImStrTrimBlanks(char* buf)
{
    char* p = buf;
    while (p[0] == ' ' || p[0] == '\t')     // Leading blanks
        p++;
    char* p_start = p;
    while (*p != 0)                         // Find end of string
        p++;
    while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))  // Trailing blanks
        p--;
    if (p_start != buf)                     // Copy memory if we had leading blanks
        memmove(buf, p_start, p - p_start);
    buf[p - p_start] = 0;                   // Zero terminate
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
// B) When buf==NULL vsnprintf() will return the output size.
#ifndef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS

#if defined(_MSC_VER) && !defined(vsnprintf)
#define vsnprintf _vsnprintf
#endif

int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    int w = vsnprintf(buf, buf_size, fmt, args);
    va_end(args);
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}

int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)
{
    int w = vsnprintf(buf, buf_size, fmt, args);
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}
#endif // #ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS

// Pass data_size==0 for zero-terminated strings
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImU32 ImHash(const void* data, int data_size, ImU32 seed)
{
    static ImU32 crc32_lut[256] = { 0 };
    if (!crc32_lut[1])
    {
        const ImU32 polynomial = 0xEDB88320;
        for (ImU32 i = 0; i < 256; i++)
        {
            ImU32 crc = i;
            for (ImU32 j = 0; j < 8; j++)
                crc = (crc >> 1) ^ (ImU32(-int(crc & 1)) & polynomial);
            crc32_lut[i] = crc;
        }
    }

    seed = ~seed;
    ImU32 crc = seed;
    const unsigned char* current = (const unsigned char*)data;

    if (data_size > 0)
    {
        // Known size
        while (data_size--)
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *current++];
    }
    else
    {
        // Zero-terminated string
        while (unsigned char c = *current++)
        {
            // We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
            // Because this syntax is rarely used we are optimizing for the common case.
            // - If we reach ### in the string we discard the hash so far and reset to the seed.
            // - We don't do 'current += 2; continue;' after handling ### to keep the code smaller.
            if (c == '#' && current[0] == '#' && current[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    }
    return ~crc;
}

FILE* ImFileOpen(const char* filename, const char* mode)
{
#if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__GNUC__)
    // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames. Converting both strings from UTF-8 to wchar format (using a single allocation, because we can)
    const int filename_wsize = ImTextCountCharsFromUtf8(filename, NULL) + 1;
    const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;
    ImVector<ImWchar> buf;
    buf.resize(filename_wsize + mode_wsize);
    ImTextStrFromUtf8(&buf[0], filename_wsize, filename, NULL);
    ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);
    return _wfopen((wchar_t*)&buf[0], (wchar_t*)&buf[filename_wsize]);
#else
    return fopen(filename, mode);
#endif
}

// Load file content into memory
// Memory allocated with ImGui::MemAlloc(), must be freed by user using ImGui::MemFree()
void* ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size, int padding_bytes)
{
    IM_ASSERT(filename && file_open_mode);
    if (out_file_size)
        *out_file_size = 0;

    FILE* f;
    if ((f = ImFileOpen(filename, file_open_mode)) == NULL)
        return NULL;

    long file_size_signed;
    if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))
    {
        fclose(f);
        return NULL;
    }

    size_t file_size = (size_t)file_size_signed;
    void* file_data = ImGui::MemAlloc(file_size + padding_bytes);
    if (file_data == NULL)
    {
        fclose(f);
        return NULL;
    }
    if (fread(file_data, 1, file_size, f) != file_size)
    {
        fclose(f);
        ImGui::MemFree(file_data);
        return NULL;
    }
    if (padding_bytes > 0)
        memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);

    fclose(f);
    if (out_file_size)
        *out_file_size = file_size;

    return file_data;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
//-----------------------------------------------------------------------------

// Convert UTF-8 to 32-bits character, process single character input.
// Based on stb_from_utf8() from github.com/nothings/stb/
// We handle UTF-8 decoding error by skipping forward.
int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
{
    unsigned int c = (unsigned int)-1;
    const unsigned char* str = (const unsigned char*)in_text;
    if (!(*str & 0x80))
    {
        c = (unsigned int)(*str++);
        *out_char = c;
        return 1;
    }
    if ((*str & 0xe0) == 0xc0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 2) return 1;
        if (*str < 0xc2) return 2;
        c = (unsigned int)((*str++ & 0x1f) << 6);
        if ((*str & 0xc0) != 0x80) return 2;
        c += (*str++ & 0x3f);
        *out_char = c;
        return 2;
    }
    if ((*str & 0xf0) == 0xe0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 3) return 1;
        if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return 3;
        if (*str == 0xed && str[1] > 0x9f) return 3; // str[1] < 0x80 is checked below
        c = (unsigned int)((*str++ & 0x0f) << 12);
        if ((*str & 0xc0) != 0x80) return 3;
        c += (unsigned int)((*str++ & 0x3f) << 6);
        if ((*str & 0xc0) != 0x80) return 3;
        c += (*str++ & 0x3f);
        *out_char = c;
        return 3;
    }
    if ((*str & 0xf8) == 0xf0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 4) return 1;
        if (*str > 0xf4) return 4;
        if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return 4;
        if (*str == 0xf4 && str[1] > 0x8f) return 4; // str[1] < 0x80 is checked below
        c = (unsigned int)((*str++ & 0x07) << 18);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (unsigned int)((*str++ & 0x3f) << 12);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (unsigned int)((*str++ & 0x3f) << 6);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (*str++ & 0x3f);
        // utf-8 encodings of values used in surrogate pairs are invalid
        if ((c & 0xFFFFF800) == 0xD800) return 4;
        *out_char = c;
        return 4;
    }
    *out_char = 0;
    return 0;
}

int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
{
    ImWchar* buf_out = buf;
    ImWchar* buf_end = buf + buf_size;
    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        if (c < 0x10000)    // FIXME: Losing characters that don't fit in 2 bytes
            *buf_out++ = (ImWchar)c;
    }
    *buf_out = 0;
    if (in_text_remaining)
        *in_text_remaining = in_text;
    return (int)(buf_out - buf);
}

int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)
{
    int char_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        if (c < 0x10000)
            char_count++;
    }
    return char_count;
}

// Based on stb_to_utf8() from github.com/nothings/stb/
static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)
{
    if (c < 0x80)
    {
        buf[0] = (char)c;
        return 1;
    }
    if (c < 0x800)
    {
        if (buf_size < 2) return 0;
        buf[0] = (char)(0xc0 + (c >> 6));
        buf[1] = (char)(0x80 + (c & 0x3f));
        return 2;
    }
    if (c >= 0xdc00 && c < 0xe000)
    {
        return 0;
    }
    if (c >= 0xd800 && c < 0xdc00)
    {
        if (buf_size < 4) return 0;
        buf[0] = (char)(0xf0 + (c >> 18));
        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
        buf[3] = (char)(0x80 + ((c ) & 0x3f));
        return 4;
    }
    //else if (c < 0x10000)
    {
        if (buf_size < 3) return 0;
        buf[0] = (char)(0xe0 + (c >> 12));
        buf[1] = (char)(0x80 + ((c>> 6) & 0x3f));
        buf[2] = (char)(0x80 + ((c ) & 0x3f));
        return 3;
    }
}

// Not optimal but we very rarely use this function.
int ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)
{
    unsigned int dummy = 0;
    return ImTextCharFromUtf8(&dummy, in_text, in_text_end);
}

static inline int ImTextCountUtf8BytesFromChar(unsigned int c)
{
    if (c < 0x80) return 1;
    if (c < 0x800) return 2;
    if (c >= 0xdc00 && c < 0xe000) return 0;
    if (c >= 0xd800 && c < 0xdc00) return 4;
    return 3;
}

int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
{
    char* buf_out = buf;
    const char* buf_end = buf + buf_size;
    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            *buf_out++ = (char)c;
        else
            buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end-buf_out-1), c);
    }
    *buf_out = 0;
    return (int)(buf_out - buf);
}

int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)
{
    int bytes_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            bytes_count++;
        else
            bytes_count += ImTextCountUtf8BytesFromChar(c);
    }
    return bytes_count;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPER/UTILTIES (Color functions)
// Note: The Convert functions are early design which are not consistent with other API.
//-----------------------------------------------------------------------------

ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)
{
    float s = 1.0f/255.0f;
    return ImVec4(
        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
}

ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)
{
    ImU32 out;
    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
    return out;
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
{
    float K = 0.f;
    if (g < b)
    {
        ImSwap(g, b);
        K = -1.f;
    }
    if (r < g)
    {
        ImSwap(r, g);
        K = -2.f / 6.f - K;
    }

    const float chroma = r - (g < b ? g : b);
    out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));
    out_s = chroma / (r + 1e-20f);
    out_v = r;
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)
{
    if (s == 0.0f)
    {
        // gray
        out_r = out_g = out_b = v;
        return;
    }

    h = ImFmod(h, 1.0f) / (60.0f/360.0f);
    int   i = (int)h;
    float f = h - (float)i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - s * f);
    float t = v * (1.0f - s * (1.0f - f));

    switch (i)
    {
    case 0: out_r = v; out_g = t; out_b = p; break;
    case 1: out_r = q; out_g = v; out_b = p; break;
    case 2: out_r = p; out_g = v; out_b = t; break;
    case 3: out_r = p; out_g = q; out_b = v; break;
    case 4: out_r = t; out_g = p; out_b = v; break;
    case 5: default: out_r = v; out_g = p; out_b = q; break;
    }
}

ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = style.Colors[idx];
    c.w *= style.Alpha * alpha_mul;
    return ColorConvertFloat4ToU32(c);
}

ImU32 ImGui::GetColorU32(const ImVec4& col)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = col;
    c.w *= style.Alpha;
    return ColorConvertFloat4ToU32(c);
}

const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)
{
    ImGuiStyle& style = GImGui->Style;
    return style.Colors[idx];
}

ImU32 ImGui::GetColorU32(ImU32 col)
{
    float style_alpha = GImGui->Style.Alpha;
    if (style_alpha >= 1.0f)
        return col;
    ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;
    a = (ImU32)(a * style_alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.
    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiStorage
// Helper: Key->value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
static ImVector<ImGuiStorage::Pair>::iterator LowerBound(ImVector<ImGuiStorage::Pair>& data, ImGuiID key)
{
    ImVector<ImGuiStorage::Pair>::iterator first = data.begin();
    ImVector<ImGuiStorage::Pair>::iterator last = data.end();
    size_t count = (size_t)(last - first);
    while (count > 0)
    {
        size_t count2 = count >> 1;
        ImVector<ImGuiStorage::Pair>::iterator mid = first + count2;
        if (mid->key < key)
        {
            first = ++mid;
            count -= count2 + 1;
        }
        else
        {
            count = count2;
        }
    }
    return first;
}

// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
void ImGuiStorage::BuildSortByKey()
{
    struct StaticFunc
    {
        static int IMGUI_CDECL PairCompareByID(const void* lhs, const void* rhs)
        {
            // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
            if (((const Pair*)lhs)->key > ((const Pair*)rhs)->key) return +1;
            if (((const Pair*)lhs)->key < ((const Pair*)rhs)->key) return -1;
            return 0;
        }
    };
    if (Data.Size > 1)
        ImQsort(Data.Data, (size_t)Data.Size, sizeof(Pair), StaticFunc::PairCompareByID);
}

int ImGuiStorage::GetInt(ImGuiID key, int default_val) const
{
    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_i;
}

bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const
{
    return GetInt(key, default_val ? 1 : 0) != 0;
}

float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const
{
    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_f;
}

void* ImGuiStorage::GetVoidPtr(ImGuiID key) const
{
    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return NULL;
    return it->val_p;
}

// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_i;
}

bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)
{
    return (bool*)GetIntRef(key, default_val ? 1 : 0);
}

float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_f;
}

void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_p;
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
void ImGuiStorage::SetInt(ImGuiID key, int val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_i = val;
}

void ImGuiStorage::SetBool(ImGuiID key, bool val)
{
    SetInt(key, val ? 1 : 0);
}

void ImGuiStorage::SetFloat(ImGuiID key, float val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_f = val;
}

void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_p = val;
}

void ImGuiStorage::SetAllInt(int v)
{
    for (int i = 0; i < Data.Size; i++)
        Data[i].val_i = v;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)
{
    if (default_filter)
    {
        ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));
        Build();
    }
    else
    {
        InputBuf[0] = 0;
        CountGrep = 0;
    }
}

bool ImGuiTextFilter::Draw(const char* label, float width)
{
    if (width != 0.0f)
        ImGui::PushItemWidth(width);
    bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));
    if (width != 0.0f)
        ImGui::PopItemWidth();
    if (value_changed)
        Build();
    return value_changed;
}

void ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>* out) const
{
    out->resize(0);
    const char* wb = b;
    const char* we = wb;
    while (we < e)
    {
        if (*we == separator)
        {
            out->push_back(TextRange(wb, we));
            wb = we + 1;
        }
        we++;
    }
    if (wb != we)
        out->push_back(TextRange(wb, we));
}

void ImGuiTextFilter::Build()
{
    Filters.resize(0);
    TextRange input_range(InputBuf, InputBuf+strlen(InputBuf));
    input_range.split(',', &Filters);

    CountGrep = 0;
    for (int i = 0; i != Filters.Size; i++)
    {
        TextRange& f = Filters[i];
        while (f.b < f.e && ImCharIsBlankA(f.b[0]))
            f.b++;
        while (f.e > f.b && ImCharIsBlankA(f.e[-1]))
            f.e--;
        if (f.empty())
            continue;
        if (Filters[i].b[0] != '-')
            CountGrep += 1;
    }
}

bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const
{
    if (Filters.empty())
        return true;

    if (text == NULL)
        text = "";

    for (int i = 0; i != Filters.Size; i++)
    {
        const TextRange& f = Filters[i];
        if (f.empty())
            continue;
        if (f.b[0] == '-')
        {
            // Subtract
            if (ImStristr(text, text_end, f.begin()+1, f.end()) != NULL)
                return false;
        }
        else
        {
            // Grep
            if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)
                return true;
        }
    }

    // Implicit * grep
    if (CountGrep == 0)
        return true;

    return false;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextBuffer
//-----------------------------------------------------------------------------

// On some platform vsnprintf() takes va_list by reference and modifies it.
// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.
#ifndef va_copy
#if defined(__GNUC__) || defined(__clang__)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#else
#define va_copy(dest, src) (dest = src)
#endif
#endif

char ImGuiTextBuffer::EmptyString[1] = { 0 };

// Helper: Text buffer for logging/accumulating text
void ImGuiTextBuffer::appendfv(const char* fmt, va_list args)
{
    va_list args_copy;
    va_copy(args_copy, args);

    int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
    if (len <= 0)
    {
        va_end(args_copy);
        return;
    }

    // Add zero-terminator the first time
    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int double_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > double_capacity ? needed_sz : double_capacity);
    }

    Buf.resize(needed_sz);
    ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
    va_end(args_copy);
}

void ImGuiTextBuffer::appendf(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    appendfv(fmt, args);
    va_end(args);
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiListClipper
// This is currently not as flexible/powerful as it should be, needs some rework (see TODO)
//-----------------------------------------------------------------------------

static void SetCursorPosYAndSetupDummyPrevLine(float pos_y, float line_height)
{
    // Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
    // The clipper should probably have a 4th step to display the last item in a regular manner.
    ImGui::SetCursorPosY(pos_y);
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;      // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.
    window->DC.PrevLineSize.y = (line_height - GImGui->Style.ItemSpacing.y);    // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
    if (window->DC.ColumnsSet)
        window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;           // Setting this so that cell Y position are set properly
}

// Use case A: Begin() called from constructor with items_height<0, then called again from Sync() in StepNo 1
// Use case B: Begin() called from constructor with items_height>0
// FIXME-LEGACY: Ideally we should remove the Begin/End functions but they are part of the legacy API we still support. This is why some of the code in Step() calling Begin() and reassign some fields, spaghetti style.
void ImGuiListClipper::Begin(int count, float items_height)
{
    LoopCallbackPosY = ImGui::GetCursorPosY();
    ItemsHeight = items_height;
    ItemsCount = count;
    StepNo = 0;
    DisplayEnd = DisplayLoopCallback = -1;
    if (ItemsHeight > 0.0f)
    {
        ImGui::CalcListClipping(ItemsCount, ItemsHeight, &DisplayLoopCallback, &DisplayEnd); // calculate how many to clip/display
        if (DisplayLoopCallback > 0)
            SetCursorPosYAndSetupDummyPrevLine(LoopCallbackPosY + DisplayLoopCallback * ItemsHeight, ItemsHeight); // advance cursor
        StepNo = 2;
    }
}

void ImGuiListClipper::End()
{
    if (ItemsCount < 0)
        return;
    // In theory here we should assert that ImGui::GetCursorPosY() == LoopCallbackPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.
    if (ItemsCount < INT_MAX)
        SetCursorPosYAndSetupDummyPrevLine(LoopCallbackPosY + ItemsCount * ItemsHeight, ItemsHeight); // advance cursor
    ItemsCount = -1;
    StepNo = 3;
}

bool ImGuiListClipper::Step()
{
    if (ItemsCount == 0 || ImGui::GetCurrentWindowRead()->SkipItems)
    {
        ItemsCount = -1;
        return false;
    }
    if (StepNo == 0) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.
    {
        DisplayLoopCallback = 0;
        DisplayEnd = 1;
        LoopCallbackPosY = ImGui::GetCursorPosY();
        StepNo = 1;
        return true;
    }
    if (StepNo == 1) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
    {
        if (ItemsCount == 1) { ItemsCount = -1; return false; }
        float items_height = ImGui::GetCursorPosY() - LoopCallbackPosY;
        IM_ASSERT(items_height > 0.0f);   // If this triggers, it means Item 0 hasn't moved the cursor vertically
        Begin(ItemsCount-1, items_height);
        DisplayLoopCallback++;
        DisplayEnd++;
        StepNo = 3;
        return true;
    }
    if (StepNo == 2) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.
    {
        IM_ASSERT(DisplayLoopCallback >= 0 && DisplayEnd >= 0);
        StepNo = 3;
        return true;
    }
    if (StepNo == 3) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
        End();
    return false;
}

//-----------------------------------------------------------------------------
// [SECTION] RENDER HELPERS
// Those (internal) functions are currently quite a legacy mess - their signature and behavior will change.
// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: state.
//-----------------------------------------------------------------------------

const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)
{
    const char* text_display_end = text;
    if (!text_end)
        text_end = (const char*)-1;

    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
        text_display_end++;
    return text_display_end;
}

// Internal ImGui functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // Hide anything after a '##' string
    const char* text_display_end;
    if (hide_text_after_hash)
    {
        text_display_end = FindRenderedTextEnd(text, text_end);
    }
    else
    {
        if (!text_end)
            text_end = text + strlen(text); // FIXME-OPT
        text_display_end = text_end;
    }

    if (text != text_display_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_display_end);
    }
}

void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = text + strlen(text); // FIXME-OPT

    if (text != text_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_end);
    }
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
void ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{
    // Perform CPU side clipping for single clipped element to avoid using scissor state
    ImVec2 pos = pos_min;
    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);

    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);

    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

    // Render
    if (need_clipping)
    {
        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
    }
    else
    {
        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
    }
}

void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{
    // Hide anything after a '##' string
    const char* text_display_end = FindRenderedTextEnd(text, text_end);
    const int text_len = (int)(text_display_end - text);
    if (text_len == 0)
        return;

    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
    if (g.LogEnabled)
        LogRenderedText(&pos_min, text, text_display_end);
}

// Render a rectangle shaped with optional rounding and borders
void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
    const float border_size = g.Style.FrameBorderSize;
    if (border && border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);
    }
}

void ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const float border_size = g.Style.FrameBorderSize;
    if (border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);
    }
}

// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
void ImGui::RenderArrow(ImVec2 p_min, ImGuiDir dir, float scale)
{
    ImGuiContext& g = *GImGui;

    const float h = g.FontSize * 1.00f;
    float r = h * 0.40f * scale;
    ImVec2 center = p_min + ImVec2(h * 0.50f, h * 0.50f * scale);

    ImVec2 a, b, c;
    switch (dir)
    {
    case ImGuiDir_Up:
    case ImGuiDir_Down:
        if (dir == ImGuiDir_Up) r = -r;
        a = ImVec2(+0.000f,+0.750f) * r;
        b = ImVec2(-0.866f,-0.750f) * r;
        c = ImVec2(+0.866f,-0.750f) * r;
        break;
    case ImGuiDir_Left:
    case ImGuiDir_Right:
        if (dir == ImGuiDir_Left) r = -r;
        a = ImVec2(+0.750f,+0.000f) * r;
        b = ImVec2(-0.750f,+0.866f) * r;
        c = ImVec2(-0.750f,-0.866f) * r;
        break;
    case ImGuiDir_None:
    case ImGuiDir_COUNT:
        IM_ASSERT(0);
        break;
    }

    g.CurrentWindow->DrawList->AddTriangleFilled(center + a, center + b, center + c, GetColorU32(ImGuiCol_Text));
}

void ImGui::RenderBullet(ImVec2 pos)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DrawList->AddCircleFilled(pos, g.FontSize*0.20f, GetColorU32(ImGuiCol_Text), 8);
}

void ImGui::RenderCheckMark(ImVec2 pos, ImU32 col, float sz)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    float thickness = ImMax(sz / 5.0f, 1.0f);
    sz -= thickness*0.5f;
    pos += ImVec2(thickness*0.25f, thickness*0.25f);

    float third = sz / 3.0f;
    float bx = pos.x + third;
    float by = pos.y + sz - third*0.5f;
    window->DrawList->PathLineTo(ImVec2(bx - third, by - third));
    window->DrawList->PathLineTo(ImVec2(bx, by));
    window->DrawList->PathLineTo(ImVec2(bx + third*2, by - third*2));
    window->DrawList->PathStroke(col, false, thickness);
}

void ImGui::RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (id != g.NavId)
        return;
    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
        return;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->DC.NavHideHighlightOneFrame)
        return;

    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
    ImRect display_rect = bb;
    display_rect.ClipWith(window->ClipRect);
    if (flags & ImGuiNavHighlightFlags_TypeDefault)
    {
        const float THICKNESS = 2.0f;
        const float DISTANCE = 3.0f + THICKNESS * 0.5f;
        display_rect.Expand(ImVec2(DISTANCE,DISTANCE));
        bool fully_visible = window->ClipRect.Contains(display_rect);
        if (!fully_visible)
            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
        window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), display_rect.Max - ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, ImDrawCornerFlags_All, THICKNESS);
        if (!fully_visible)
            window->DrawList->PopClipRect();
    }
    if (flags & ImGuiNavHighlightFlags_TypeThin)
    {
        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, ~0, 1.0f);
    }
}

//-----------------------------------------------------------------------------
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
//-----------------------------------------------------------------------------

// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
ImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name)
    : DrawListInst(&context->DrawListSharedData)
{
    Name = ImStrdup(name);
    ID = ImHash(name, 0);
    IDStack.push_back(ID);
    Flags = ImGuiWindowFlags_None;
    Pos = ImVec2(0.0f, 0.0f);
    Size = SizeFull = ImVec2(0.0f, 0.0f);
    SizeContents = SizeContentsExplicit = ImVec2(0.0f, 0.0f);
    WindowPadding = ImVec2(0.0f, 0.0f);
    WindowRounding = 0.0f;
    WindowBorderSize = 0.0f;
    MoveId = GetID("#MOVE");
    ChildId = 0;
    Scroll = ImVec2(0.0f, 0.0f);
    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
    ScrollbarSizes = ImVec2(0.0f, 0.0f);
    ScrollbarX = ScrollbarY = false;
    Active = WasActive = false;
    WriteAccessed = false;
    Collapsed = false;
    WantCollapseToggle = false;
    SkipItems = false;
    Appearing = false;
    Hidden = false;
    HasCloseButton = false;
    BeginCount = 0;
    BeginOrderWithinParent = -1;
    BeginOrderWithinContext = -1;
    PopupId = 0;
    AutoFitFramesX = AutoFitFramesY = -1;
    AutoFitOnlyGrows = false;
    AutoFitChildAxises = 0x00;
    AutoPosLastDirection = ImGuiDir_None;
    HiddenFramesRegular = HiddenFramesForResize = 0;
    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);

    LastFrameActive = -1;
    ItemWidthDefault = 0.0f;
    FontWindowScale = 1.0f;
    SettingsIdx = -1;

    DrawList = &DrawListInst;
    DrawList->_OwnerName = Name;
    ParentWindow = NULL;
    RootWindow = NULL;
    RootWindowForTitleBarHighlight = NULL;
    RootWindowForNav = NULL;

    NavLastIds[0] = NavLastIds[1] = 0;
    NavRectRel[0] = NavRectRel[1] = ImRect();
    NavLastChildNavWindow = NULL;

    FocusIdxAllCounter = FocusIdxTabCounter = -1;
    FocusIdxAllRequestCurrent = FocusIdxTabRequestCurrent = INT_MAX;
    FocusIdxAllRequestNext = FocusIdxTabRequestNext = INT_MAX;
}

ImGuiWindow::~ImGuiWindow()
{
    IM_ASSERT(DrawList == &DrawListInst);
    IM_DELETE(Name);
    for (int i = 0; i != ColumnsStorage.Size; i++)
        ColumnsStorage[i].~ImGuiColumnsSet();
}

ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHash(str, str_end ? (int)(str_end - str) : 0, seed);
    ImGui::KeepAliveID(id);
    return id;
}

ImGuiID ImGuiWindow::GetID(const void* ptr)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHash(&ptr, sizeof(void*), seed);
    ImGui::KeepAliveID(id);
    return id;
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)
{
    ImGuiID seed = IDStack.back();
    return ImHash(str, str_end ? (int)(str_end - str) : 0, seed);
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const void* ptr)
{
    ImGuiID seed = IDStack.back();
    return ImHash(&ptr, sizeof(void*), seed);
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)
{
    ImGuiID seed = IDStack.back();
    const int r_rel[4] = { (int)(r_abs.Min.x - Pos.x), (int)(r_abs.Min.y - Pos.y), (int)(r_abs.Max.x - Pos.x), (int)(r_abs.Max.y - Pos.y) };
    ImGuiID id = ImHash(&r_rel, sizeof(r_rel), seed);
    ImGui::KeepAliveID(id);
    return id;
}

static void SetCurrentWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow = window;
    if (window)
        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

void ImGui::SetNavID(ImGuiID id, int nav_layer)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindow);
    IM_ASSERT(nav_layer == 0 || nav_layer == 1);
    g.NavId = id;
    g.NavWindow->NavLastIds[nav_layer] = id;
}

void ImGui::SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel)
{
    ImGuiContext& g = *GImGui;
    SetNavID(id, nav_layer);
    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
    g.NavMousePosDirty = true;
    g.NavDisableHighlight = false;
    g.NavDisableMouseHover = true;
}

void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.ActiveIdIsJustActivated = (g.ActiveId != id);
    if (g.ActiveIdIsJustActivated)
    {
        g.ActiveIdTimer = 0.0f;
        g.ActiveIdHasBeenEdited = false;
        if (id != 0)
        {
            g.LastActiveId = id;
            g.LastActiveIdTimer = 0.0f;
        }
    }
    g.ActiveId = id;
    g.ActiveIdAllowNavDirFlags = 0;
    g.ActiveIdAllowOverlap = false;
    g.ActiveIdWindow = window;
    if (id)
    {
        g.ActiveIdIsAlive = id;
        g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id || g.NavJustTabbedId == id || g.NavJustMovedToId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;
    }
}

void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(id != 0);

    // Assume that SetFocusID() is called in the context where its NavLayer is the current layer, which is the case everywhere we call it.
    const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;
    if (g.NavWindow != window)
        g.NavInitRequest = false;
    g.NavId = id;
    g.NavWindow = window;
    g.NavLayer = nav_layer;
    window->NavLastIds[nav_layer] = id;
    if (window->DC.LastItemId == id)
        window->NavRectRel[nav_layer] = ImRect(window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos);

    if (g.ActiveIdSource == ImGuiInputSource_Nav)
        g.NavDisableMouseHover = true;
    else
        g.NavDisableHighlight = true;
}

void ImGui::ClearActiveID()
{
    SetActiveID(0, NULL);
}

void ImGui::SetHoveredID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.HoveredId = id;
    g.HoveredIdAllowOverlap = false;
    if (id != 0 && g.HoveredIdPreviousFrame != id)
        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
}

ImGuiID ImGui::GetHoveredID()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
}

void ImGui::KeepAliveID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId == id)
        g.ActiveIdIsAlive = id;
    if (g.ActiveIdPreviousFrame == id)
        g.ActiveIdPreviousFrameIsAlive = true;
}

void ImGui::MarkItemEdited(ImGuiID id)
{
    // This marking is solely to be able to provide info for IsItemDeactivatedAfterEdit().
    // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need need to fill the data.
    (void)id; // Avoid unused variable warnings when asserts are compiled out.
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive);
    //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
    g.ActiveIdHasBeenEdited = true;
    g.CurrentWindow->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Edited;
}

static inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)
{
    // An active popup disable hovering on other windows (apart from its own children)
    // FIXME-OPT: This could be cached/stored within the window.
    ImGuiContext& g = *GImGui;
    if (g.NavWindow)
        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)
            if (focused_root_window->WasActive && focused_root_window != window->RootWindow)
            {
                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
                // NB: The order of those two tests is important because Modal windows are also Popups.
                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
                    return false;
                if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
                    return false;
            }

    return true;
}

// Advance cursor given item size for layout.
void ImGui::ItemSize(const ImVec2& size, float text_offset_y)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    // Always align ourselves on pixel boundaries
    const float line_height = ImMax(window->DC.CurrentLineSize.y, size.y);
    const float text_base_offset = ImMax(window->DC.CurrentLineTextBaseOffset, text_offset_y);
    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
    window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);
    window->DC.CursorPos = ImVec2((float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x), (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y));
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

    window->DC.PrevLineSize.y = line_height;
    window->DC.PrevLineTextBaseOffset = text_base_offset;
    window->DC.CurrentLineSize.y = window->DC.CurrentLineTextBaseOffset = 0.0f;

    // Horizontal layout mode
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
        SameLine();
}

void ImGui::ItemSize(const ImRect& bb, float text_offset_y)
{
    ItemSize(bb.GetSize(), text_offset_y);
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and then use a larger region for drawing/interaction, which is passed to ItemAdd().
bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (id != 0)
    {
        // Navigation processing runs prior to clipping early-out
        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests unfortunately, but it is still limited to one window.
        //      it may not scale very well for windows with ten of thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick)
        window->DC.NavLayerActiveMaskNext |= window->DC.NavLayerCurrentMask;
        if (g.NavId == id || g.NavAnyRequest)
            if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
                if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
                    NavProcessItem(window, nav_bb_arg ? *nav_bb_arg : bb, id);
    }

    window->DC.LastItemId = id;
    window->DC.LastItemRect = bb;
    window->DC.LastItemStatusFlags = ImGuiItemStatusFlags_None;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiTestEngineHook_ItemAdd(bb, id);
#endif

    // Clipping test
    const bool is_clipped = IsClippedEx(bb, id, false);
    if (is_clipped)
        return false;
    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]

    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
    if (IsMouseHoveringRect(bb.Min, bb.Max))
        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredRect;
    return true;
}

// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
bool ImGui::IsItemHovered(ImGuiHoveredFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavDisableMouseHover && !g.NavDisableHighlight)
        return IsItemFocused();

    // Test for bounding box overlap, as updated as ItemAdd()
    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))
        return false;
    IM_ASSERT((flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows)) == 0);   // Flags not supported by this function

    // Test if we are hovering the right window (our window could be behind another window)
    // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable to use IsItemHovered() after EndChild() itself.
    // Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has been running for a long while.
    //if (g.HoveredWindow != window)
    //    return false;
    if (g.HoveredRootWindow != window->RootWindow && !(flags & ImGuiHoveredFlags_AllowWhenOverlapped))
        return false;

    // Test if another item is active (e.g. being dragged)
    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)
            return false;

    // Test if interactions on this window are blocked by an active popup or modal
    if (!IsWindowContentHoverable(window, flags))
        return false;

    // Test if the item is disabled
    if ((window->DC.ItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))
        return false;

    // Special handling for the 1st item after Begin() which represent the title bar. When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect tht case.
    if (window->DC.LastItemId == window->MoveId && window->WriteAccessed)
        return false;
    return true;
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (g.HoveredWindow != window)
        return false;
    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
        return false;
    if (!IsMouseHoveringRect(bb.Min, bb.Max))
        return false;
    if (g.NavDisableMouseHover || !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))
        return false;
    if (window->DC.ItemFlags & ImGuiItemFlags_Disabled)
        return false;

    SetHoveredID(id);
    return true;
}

bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!bb.Overlaps(window->ClipRect))
        if (id == 0 || id != g.ActiveId)
            if (clip_even_when_logged || !g.LogEnabled)
                return true;
    return false;
}

bool ImGui::FocusableItemRegister(ImGuiWindow* window, ImGuiID id, bool tab_stop)
{
    ImGuiContext& g = *GImGui;

    const bool is_tab_stop = (window->DC.ItemFlags & (ImGuiItemFlags_NoTabStop | ImGuiItemFlags_Disabled)) == 0;
    window->FocusIdxAllCounter++;
    if (is_tab_stop)
        window->FocusIdxTabCounter++;

    // Process keyboard input at this point: TAB/Shift-TAB to tab out of the currently focused item.
    // Note that we can always TAB out of a widget that doesn't allow tabbing in.
    if (tab_stop && (g.ActiveId == id) && window->FocusIdxAllRequestNext == INT_MAX && window->FocusIdxTabRequestNext == INT_MAX && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab))
        window->FocusIdxTabRequestNext = window->FocusIdxTabCounter + (g.IO.KeyShift ? (is_tab_stop ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.

    if (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent)
        return true;
    if (is_tab_stop && window->FocusIdxTabCounter == window->FocusIdxTabRequestCurrent)
    {
        g.NavJustTabbedId = id;
        return true;
    }

    return false;
}

void ImGui::FocusableItemUnregister(ImGuiWindow* window)
{
    window->FocusIdxAllCounter--;
    window->FocusIdxTabCounter--;
}

ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_x, float default_y)
{
    ImGuiContext& g = *GImGui;
    ImVec2 content_max;
    if (size.x < 0.0f || size.y < 0.0f)
        content_max = g.CurrentWindow->Pos + GetContentRegionMax();
    if (size.x <= 0.0f)
        size.x = (size.x == 0.0f) ? default_x : ImMax(content_max.x - g.CurrentWindow->DC.CursorPos.x, 4.0f) + size.x;
    if (size.y <= 0.0f)
        size.y = (size.y == 0.0f) ? default_y : ImMax(content_max.y - g.CurrentWindow->DC.CursorPos.y, 4.0f) + size.y;
    return size;
}

float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)
{
    if (wrap_pos_x < 0.0f)
        return 0.0f;

    ImGuiWindow* window = GetCurrentWindowRead();
    if (wrap_pos_x == 0.0f)
        wrap_pos_x = GetContentRegionMax().x + window->Pos.x;
    else if (wrap_pos_x > 0.0f)
        wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space

    return ImMax(wrap_pos_x - pos.x, 1.0f);
}

void* ImGui::MemAlloc(size_t size)
{
    if (ImGuiContext* ctx = GImGui)
        ctx->IO.MetricsActiveAllocations++;
    return GImAllocatorAllocFunc(size, GImAllocatorUserData);
}

void ImGui::MemFree(void* ptr)
{
    if (ptr) 
        if (ImGuiContext* ctx = GImGui)
            ctx->IO.MetricsActiveAllocations--;
    return GImAllocatorFreeFunc(ptr, GImAllocatorUserData);
}

const char* ImGui::GetClipboardText()
{
    return GImGui->IO.GetClipboardTextFn ? GImGui->IO.GetClipboardTextFn(GImGui->IO.ClipboardUserData) : "";
}

void ImGui::SetClipboardText(const char* text)
{
    if (GImGui->IO.SetClipboardTextFn)
        GImGui->IO.SetClipboardTextFn(GImGui->IO.ClipboardUserData, text);
}

const char* ImGui::GetVersion()
{
    return IMGUI_VERSION;
}

// Internal state access - if you want to share ImGui state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
ImGuiContext* ImGui::GetCurrentContext()
{
    return GImGui;
}

void ImGui::SetCurrentContext(ImGuiContext* ctx)
{
#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
#else
    GImGui = ctx;
#endif
}

// Helper function to verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit
// If the user has inconsistent compilation settings, imgui configuration #define, packing pragma, etc. you may see different structures from what imgui.cpp sees which is highly problematic.
bool ImGui::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert)
{
    bool error = false;
    if (strcmp(version, IMGUI_VERSION)!=0) { error = true; IM_ASSERT(strcmp(version,IMGUI_VERSION)==0 && "Mismatched version string!");  }
    if (sz_io    != sizeof(ImGuiIO))       { error = true; IM_ASSERT(sz_io    == sizeof(ImGuiIO)      && "Mismatched struct layout!"); }
    if (sz_style != sizeof(ImGuiStyle))    { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle)   && "Mismatched struct layout!"); }
    if (sz_vec2  != sizeof(ImVec2))        { error = true; IM_ASSERT(sz_vec2  == sizeof(ImVec2)       && "Mismatched struct layout!"); }
    if (sz_vec4  != sizeof(ImVec4))        { error = true; IM_ASSERT(sz_vec4  == sizeof(ImVec4)       && "Mismatched struct layout!"); }
    if (sz_vert  != sizeof(ImDrawVert))    { error = true; IM_ASSERT(sz_vert  == sizeof(ImDrawVert)   && "Mismatched struct layout!"); }
    return !error;
}

void ImGui::SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void(*free_func)(void* ptr, void* user_data), void* user_data)
{
    GImAllocatorAllocFunc = alloc_func;
    GImAllocatorFreeFunc = free_func;
    GImAllocatorUserData = user_data;
}

ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)
{
    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
    if (GImGui == NULL)
        SetCurrentContext(ctx);
    Initialize(ctx);
    return ctx;
}

void ImGui::DestroyContext(ImGuiContext* ctx)
{
    if (ctx == NULL)
        ctx = GImGui;
    Shutdown(ctx);
    if (GImGui == ctx)
        SetCurrentContext(NULL);
    IM_DELETE(ctx);
}

ImGuiIO& ImGui::GetIO()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
    return GImGui->IO;
}

ImGuiStyle& ImGui::GetStyle()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
    return GImGui->Style;
}

// Same value as passed to the old io.RenderDrawListsFn function. Valid after Render() and until the next call to NewFrame()
ImDrawData* ImGui::GetDrawData()
{
    ImGuiContext& g = *GImGui;
    return g.DrawData.Valid ? &g.DrawData : NULL;
}

double ImGui::GetTime()
{
    return GImGui->Time;
}

int ImGui::GetFrameCount()
{
    return GImGui->FrameCount;
}

static ImDrawList* GetOverlayDrawList(ImGuiWindow*)
{
    // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'viewport' branches.
    return &GImGui->OverlayDrawList;
}

ImDrawList* ImGui::GetOverlayDrawList()
{
    return &GImGui->OverlayDrawList;
}

ImDrawListSharedData* ImGui::GetDrawListSharedData()
{
    return &GImGui->DrawListSharedData;
}

void ImGui::LoopCallbackMouseMovingWindow(ImGuiWindow* window)
{
    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
    // This is because we want ActiveId to be set even when the window is stuck from moving.
    ImGuiContext& g = *GImGui;
    FocusWindow(window);
    SetActiveID(window->MoveId, window);
    g.NavDisableHighlight = true;
    g.ActiveIdClickOffset = g.IO.MousePos - window->RootWindow->Pos;
    if (!(window->Flags & ImGuiWindowFlags_NoMove) && !(window->RootWindow->Flags & ImGuiWindowFlags_NoMove))
        g.MovingWindow = window;
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
void ImGui::UpdateMouseMovingWindow()
{
    ImGuiContext& g = *GImGui;
    if (g.MovingWindow != NULL)
    {
        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
        KeepAliveID(g.ActiveId);
        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);
        ImGuiWindow* moving_window = g.MovingWindow->RootWindow;
        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos))
        {
            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)
            {
                MarkIniSettingsDirty(moving_window);
                SetWindowPos(moving_window, pos, ImGuiCond_Always);
            }
            FocusWindow(g.MovingWindow);
        }
        else
        {
            ClearActiveID();
            g.MovingWindow = NULL;
        }
    }
    else
    {
        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
        {
            KeepAliveID(g.ActiveId);
            if (!g.IO.MouseDown[0])
                ClearActiveID();
        }
    }
}

static bool IsWindowActiveAndVisible(ImGuiWindow* window)
{
    return (window->Active) && (!window->Hidden);
}

static void ImGui::UpdateMouseInputs()
{
    ImGuiContext& g = *GImGui;

    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
    if (IsMousePosValid(&g.IO.MousePos))
        g.IO.MousePos = g.LastValidMousePos = ImFloor(g.IO.MousePos);

    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
    if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MousePosPrev))
        g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;
    else
        g.IO.MouseDelta = ImVec2(0.0f, 0.0f);
    if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)
        g.NavDisableMouseHover = false;

    g.IO.MousePosPrev = g.IO.MousePos;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;
        g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;
        g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];
        g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;
        g.IO.MouseDoubleClicked[i] = false;
        if (g.IO.MouseClicked[i])
        {
            if ((float)(g.Time - g.IO.MouseClickedTime[i]) < g.IO.MouseDoubleClickTime)
            {
                ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
                if (ImLengthSqr(delta_from_click_pos) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)
                    g.IO.MouseDoubleClicked[i] = true;
                g.IO.MouseClickedTime[i] = -FLT_MAX;    // so the third click isn't turned into a double-click
            }
            else
            {
                g.IO.MouseClickedTime[i] = g.Time;
            }
            g.IO.MouseClickedPos[i] = g.IO.MousePos;
            g.IO.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;
        }
        else if (g.IO.MouseDown[i])
        {
            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
            ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
            g.IO.MouseDragMaxDistanceAbs[i].x = ImMax(g.IO.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
            g.IO.MouseDragMaxDistanceAbs[i].y = ImMax(g.IO.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
        }
        if (g.IO.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
            g.NavDisableMouseHover = false;
    }
}

void ImGui::UpdateMouseWheel()
{
    ImGuiContext& g = *GImGui;
    if (!g.HoveredWindow || g.HoveredWindow->Collapsed)
        return;
    if (g.IO.MouseWheel == 0.0f && g.IO.MouseWheelH == 0.0f)
        return;

    // If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent (unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set).
    ImGuiWindow* window = g.HoveredWindow;
    ImGuiWindow* scroll_window = window;
    while ((scroll_window->Flags & ImGuiWindowFlags_ChildWindow) && (scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoScrollbar) && !(scroll_window->Flags & ImGuiWindowFlags_NoMouseInputs) && scroll_window->ParentWindow)
        scroll_window = scroll_window->ParentWindow;
    const bool scroll_allowed = !(scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoMouseInputs);

    if (g.IO.MouseWheel != 0.0f)
    {
        if (g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
        {
            // Zoom / Scale window
            const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
            const float scale = new_font_scale / window->FontWindowScale;
            window->FontWindowScale = new_font_scale;

            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
            window->Pos += offset;
            window->Size *= scale;
            window->SizeFull *= scale;
        }
        else if (!g.IO.KeyCtrl && scroll_allowed)
        {
            // Mouse wheel vertical scrolling
            float scroll_amount = 5 * scroll_window->CalcFontSize();
            scroll_amount = (float)(int)ImMin(scroll_amount, (scroll_window->ContentsRegionRect.GetHeight() + scroll_window->WindowPadding.y * 2.0f) * 0.67f);
            SetWindowScrollY(scroll_window, scroll_window->Scroll.y - g.IO.MouseWheel * scroll_amount);
        }
    }
    if (g.IO.MouseWheelH != 0.0f && scroll_allowed && !g.IO.KeyCtrl)
    {
        // Mouse wheel horizontal scrolling (for hardware that supports it)
        float scroll_amount = scroll_window->CalcFontSize();
        SetWindowScrollX(scroll_window, scroll_window->Scroll.x - g.IO.MouseWheelH * scroll_amount);
    }
}

// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
void ImGui::UpdateHoveredWindowAndCaptureFlags()
{
    ImGuiContext& g = *GImGui;

    // Find the window hovered by mouse:
    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
    FindHoveredWindow();

    // Modal windows prevents cursor from hovering behind them.
    ImGuiWindow* modal_window = GetFrontMostPopupModal();
    if (modal_window)
        if (g.HoveredRootWindow && !IsWindowChildOf(g.HoveredRootWindow, modal_window))
            g.HoveredRootWindow = g.HoveredWindow = NULL;

    // Disabled mouse?
    if (g.IO.ConfigFlags & ImGuiConfigFlags_NoMouse)
        g.HoveredWindow = g.HoveredRootWindow = NULL;

    // We track click ownership. When clicked outside of a window the click is owned by the application and won't report hovering nor request capture even while dragging over our windows afterward.
    int mouse_earliest_button_down = -1;
    bool mouse_any_down = false;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        if (g.IO.MouseClicked[i])
            g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());
        mouse_any_down |= g.IO.MouseDown[i];
        if (g.IO.MouseDown[i])
            if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[mouse_earliest_button_down])
                mouse_earliest_button_down = i;
    }
    const bool mouse_avail_to_imgui = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];

    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
    if (!mouse_avail_to_imgui && !mouse_dragging_extern_payload)
        g.HoveredWindow = g.HoveredRootWindow = NULL;

    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to imgui, false = dispatch mouse info to imgui + app)
    if (g.WantCaptureMouseNextFrame != -1)
        g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);
    else
        g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (!g.OpenPopupStack.empty());

    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to imgui, false = dispatch keyboard info to imgui + app)
    if (g.WantCaptureKeyboardNextFrame != -1)
        g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
    else
        g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
    if (g.IO.NavActive && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
        g.IO.WantCaptureKeyboard = true;

    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
    g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
}

void ImGui::NewFrame()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
    ImGuiContext& g = *GImGui;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiTestEngineHook_PreNewFrame();
#endif

    // Check user data
    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
    IM_ASSERT(g.Initialized);
    IM_ASSERT(g.IO.DeltaTime >= 0.0f                                    && "Need a positive DeltaTime (zero is tolerated but will cause some timing issues)");
    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value");
    IM_ASSERT(g.IO.Fonts->Fonts.Size > 0                                && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
    IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded()                          && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting");
    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)");
    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
    for (int n = 0; n < ImGuiKey_COUNT; n++)
        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < IM_ARRAYSIZE(g.IO.KeysDown) && "io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)");

    // Perform simple check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only recently added in 1.60 WIP)
    if (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)
        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");

    // Perform simple check: the beta io.ConfigWindowsResizeFromEdges option requires back-end to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
    if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))
        g.IO.ConfigWindowsResizeFromEdges = false;

    // Load settings on first frame (if not explicitly loaded manually before)
    if (!g.SettingsLoaded)
    {
        IM_ASSERT(g.SettingsWindows.empty());
        if (g.IO.IniFilename)
            LoadIniSettingsFromDisk(g.IO.IniFilename);
        g.SettingsLoaded = true;
    }

    // Save settings (with a delay after the last modification, so we don't spam disk too much)
    if (g.SettingsDirtyTimer > 0.0f)
    {
        g.SettingsDirtyTimer -= g.IO.DeltaTime;
        if (g.SettingsDirtyTimer <= 0.0f)
        {
            if (g.IO.IniFilename != NULL)
                SaveIniSettingsToDisk(g.IO.IniFilename);
            else
                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
            g.SettingsDirtyTimer = 0.0f;
        }
    }

    g.Time += g.IO.DeltaTime;
    g.FrameScopeActive = true;
    g.FrameCount += 1;
    g.TooltipOverrideCount = 0;
    g.WindowsActiveCount = 0;

    // Setup current font and draw list
    g.IO.Fonts->Locked = true;
    SetCurrentFont(GetDefaultFont());
    IM_ASSERT(g.Font->IsLoaded());
    g.DrawListSharedData.ClipRectFullscreen = ImVec4(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;

    g.OverlayDrawList.Clear();
    g.OverlayDrawList.PushTextureID(g.IO.Fonts->TexID);
    g.OverlayDrawList.PushClipRectFullScreen();
    g.OverlayDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

    // Mark rendering data as invalid to prevent user who may have a handle on it to use it
    g.DrawData.Clear();

    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
        KeepAliveID(g.DragDropPayload.SourceId);

    // Clear reference to active widget if the widget isn't alive anymore
    if (!g.HoveredIdPreviousFrame)
        g.HoveredIdTimer = 0.0f;
    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
        g.HoveredIdNotActiveTimer = 0.0f;
    if (g.HoveredId)
        g.HoveredIdTimer += g.IO.DeltaTime;
    if (g.HoveredId && g.ActiveId != g.HoveredId)
        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
    g.HoveredIdPreviousFrame = g.HoveredId;
    g.HoveredId = 0;
    g.HoveredIdAllowOverlap = false;
    if (g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)
        ClearActiveID();
    if (g.ActiveId)
        g.ActiveIdTimer += g.IO.DeltaTime;
    g.LastActiveIdTimer += g.IO.DeltaTime;
    g.ActiveIdPreviousFrame = g.ActiveId;
    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
    g.ActiveIdPreviousFrameHasBeenEdited = g.ActiveIdHasBeenEdited;
    g.ActiveIdIsAlive = 0;
    g.ActiveIdPreviousFrameIsAlive = false;
    g.ActiveIdIsJustActivated = false;
    if (g.ScalarAsInputTextId && g.ActiveId != g.ScalarAsInputTextId)
        g.ScalarAsInputTextId = 0;

    // Drag and drop
    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
    g.DragDropAcceptIdCurr = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropWithinSourceOrTarget = false;

    // Update keyboard input state
    memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)
        g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;

    // Update gamepad/keyboard directional navigation
    NavUpdate();

    // Update mouse input state
    UpdateMouseInputs();

    // Calculate frame-rate for the user, as a purely luxurious feature
    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame))) : FLT_MAX;

    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
    UpdateMouseMovingWindow();
    UpdateHoveredWindowAndCaptureFlags();

    // Background darkening/whitening
    if (GetFrontMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
    else
        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);

    g.MouseCursor = ImGuiMouseCursor_Arrow;
    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
    g.PlatformImePos = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default

    // Mouse wheel scrolling, scale
    UpdateMouseWheel();

    // Pressing TAB activate widget focus
    if (g.ActiveId == 0 && g.NavWindow != NULL && g.NavWindow->Active && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab, false))
    {
        if (g.NavId != 0 && g.NavIdTabCounter != INT_MAX)
            g.NavWindow->FocusIdxTabRequestNext = g.NavIdTabCounter + 1 + (g.IO.KeyShift ? -1 : 1);
        else
            g.NavWindow->FocusIdxTabRequestNext = g.IO.KeyShift ? -1 : 0;
    }
    g.NavIdTabCounter = INT_MAX;

    // Mark all windows as not visible
    IM_ASSERT(g.WindowsFocusOrder.Size == g.Windows.Size);
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        window->WasActive = window->Active;
        window->Active = false;
        window->WriteAccessed = false;
    }

    // Closing the focused window restore focus to the first active root window in descending z-order
    if (g.NavWindow && !g.NavWindow->WasActive)
        FocusPreviousWindowIgnoringOne(NULL);

    // No window should be open at the beginning of the frame.
    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
    g.CurrentWindowStack.resize(0);
    g.BeginPopupStack.resize(0);
    ClosePopupsOverWindow(g.NavWindow);

    // Create implicit/fallback window - which we will only render it if the user has added something to it.
    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
    // This fallback is particularly important as it avoid ImGui:: calls from crashing.
    SetNextWindowSize(ImVec2(400,400), ImGuiCond_FirstUseEver);
    Begin("Debug##Default");

#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiTestEngineHook_PostNewFrame();
#endif
}

void ImGui::Initialize(ImGuiContext* context)
{
    ImGuiContext& g = *context;
    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);

    // Add .ini handle for ImGuiWindow type
    ImGuiSettingsHandler ini_handler;
    ini_handler.TypeName = "Window";
    ini_handler.TypeHash = ImHash("Window", 0, 0);
    ini_handler.ReadOpenFn = SettingsHandlerWindow_ReadOpen;
    ini_handler.ReadLineFn = SettingsHandlerWindow_ReadLine;
    ini_handler.WriteAllFn = SettingsHandlerWindow_WriteAll;
    g.SettingsHandlers.push_front(ini_handler);

    g.Initialized = true;
}

// This function is merely here to free heap allocations.
void ImGui::Shutdown(ImGuiContext* context)
{
    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
    ImGuiContext& g = *context;
    if (g.IO.Fonts && g.FontAtlasOwnedByContext)
    {
        g.IO.Fonts->Locked = false;
        IM_DELETE(g.IO.Fonts);
    }
    g.IO.Fonts = NULL;

    // Cleanup of other data are conditional on actually having initialized ImGui.
    if (!g.Initialized)
        return;

    // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
    if (g.SettingsLoaded && g.IO.IniFilename != NULL)
    {
        ImGuiContext* backup_context = GImGui;
        SetCurrentContext(context);
        SaveIniSettingsToDisk(g.IO.IniFilename);
        SetCurrentContext(backup_context);
    }

    // Clear everything else
    for (int i = 0; i < g.Windows.Size; i++)
        IM_DELETE(g.Windows[i]);
    g.Windows.clear();
    g.WindowsFocusOrder.clear();
    g.WindowsSortBuffer.clear();
    g.CurrentWindow = NULL;
    g.CurrentWindowStack.clear();
    g.WindowsById.Clear();
    g.NavWindow = NULL;
    g.HoveredWindow = NULL;
    g.HoveredRootWindow = NULL;
    g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;
    g.MovingWindow = NULL;
    g.ColorModifiers.clear();
    g.StyleModifiers.clear();
    g.FontStack.clear();
    g.OpenPopupStack.clear();
    g.BeginPopupStack.clear();
    g.DrawDataBuilder.ClearFreeMemory();
    g.OverlayDrawList.ClearFreeMemory();
    g.PrivateClipboard.clear();
    g.InputTextState.TextW.clear();
    g.InputTextState.InitialText.clear();
    g.InputTextState.TempBuffer.clear();

    for (int i = 0; i < g.SettingsWindows.Size; i++)
        IM_DELETE(g.SettingsWindows[i].Name);
    g.SettingsWindows.clear();
    g.SettingsHandlers.clear();

    if (g.LogFile && g.LogFile != stdout)
    {
        fclose(g.LogFile);
        g.LogFile = NULL;
    }
    g.LogClipboard.clear();

    g.Initialized = false;
}

// FIXME: Add a more explicit sort order in the window structure.
static int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)
{
    const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;
    const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;
    if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))
        return d;
    if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))
        return d;
    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
}

static void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)
{
    out_sorted_windows->push_back(window);
    if (window->Active)
    {
        int count = window->DC.ChildWindows.Size;
        if (count > 1)
            ImQsort(window->DC.ChildWindows.begin(), (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
        for (int i = 0; i < count; i++)
        {
            ImGuiWindow* child = window->DC.ChildWindows[i];
            if (child->Active)
                AddWindowToSortBuffer(out_sorted_windows, child);
        }
    }
}

static void AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)
{
    if (draw_list->CmdBuffer.empty())
        return;

    // Remove trailing command if unused
    ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();
    if (last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL)
    {
        draw_list->CmdBuffer.pop_back();
        if (draw_list->CmdBuffer.empty())
            return;
    }

    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc. May trigger for you if you are using PrimXXX functions incorrectly.
    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
    IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);

    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
    // If this assert triggers because you are drawing lots of stuff manually:
    // A) Make sure you are coarse clipping, because ImDrawList let all your vertices pass. You can use the Metrics window to inspect draw list contents.
    // B) If you need/want meshes with more than 64K vertices, uncomment the '#define ImDrawIdx unsigned int' line in imconfig.h to set the index size to 4 bytes.
    //    You'll need to handle the 4-bytes indices to your renderer. For example, the OpenGL example code detect index size at compile-time by doing:
    //      glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
    //    Your own engine or render API may use different parameters or function calls to specify index sizes. 2 and 4 bytes indices are generally supported by most API.
    // C) If for some reason you cannot use 4 bytes indices or don't want to, a workaround is to call BeginChild()/EndChild() before reaching the 64K limit to split your draw commands in multiple draw lists.
    if (sizeof(ImDrawIdx) == 2)
        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");

    out_list->push_back(draw_list);
}

static void AddWindowToDrawData(ImVector<ImDrawList*>* out_render_list, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.IO.MetricsRenderWindows++;
    AddDrawListToDrawData(out_render_list, window->DrawList);
    for (int i = 0; i < window->DC.ChildWindows.Size; i++)
    {
        ImGuiWindow* child = window->DC.ChildWindows[i];
        if (IsWindowActiveAndVisible(child)) // clipped children may have been marked not active
            AddWindowToDrawData(out_render_list, child);
    }
}

static void AddWindowToDrawDataSelectLayer(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (window->Flags & ImGuiWindowFlags_Tooltip)
        AddWindowToDrawData(&g.DrawDataBuilder.Layers[1], window);
    else
        AddWindowToDrawData(&g.DrawDataBuilder.Layers[0], window);
}

void ImDrawDataBuilder::FlattenIntoSingleLayer()
{
    int n = Layers[0].Size;
    int size = n;
    for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)
        size += Layers[i].Size;
    Layers[0].resize(size);
    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)
    {
        ImVector<ImDrawList*>& layer = Layers[layer_n];
        if (layer.empty())
            continue;
        memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));
        n += layer.Size;
        layer.resize(0);
    }
}

static void SetupDrawData(ImVector<ImDrawList*>* draw_lists, ImDrawData* draw_data)
{
    ImGuiIO& io = ImGui::GetIO();
    draw_data->Valid = true;
    draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;
    draw_data->CmdListsCount = draw_lists->Size;
    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
    draw_data->DisplayPos = ImVec2(0.0f, 0.0f);
    draw_data->DisplaySize = io.DisplaySize;
    for (int n = 0; n < draw_lists->Size; n++)
    {
        draw_data->TotalVtxCount += draw_lists->Data[n]->VtxBuffer.Size;
        draw_data->TotalIdxCount += draw_lists->Data[n]->IdxBuffer.Size;
    }
}

// When using this function it is sane to ensure that float are perfectly rounded to integer values, to that e.g. (int)(max.x-min.x) in user's render produce correct result.
void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

void ImGui::PopClipRect()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PopClipRect();
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
void ImGui::EndFrame()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);
    if (g.FrameCountEnded == g.FrameCount)          // Don't process EndFrame() multiple times.
        return;
    IM_ASSERT(g.FrameScopeActive && "Forgot to call ImGui::NewFrame()");

    // Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
    if (g.IO.ImeSetInputScreenPosFn && ImLengthSqr(g.PlatformImeLastPos - g.PlatformImePos) > 0.0001f)
    {
        g.IO.ImeSetInputScreenPosFn((int)g.PlatformImePos.x, (int)g.PlatformImePos.y);
        g.PlatformImeLastPos = g.PlatformImePos;
    }

    // Hide implicit "Debug" window if it hasn't been used
    IM_ASSERT(g.CurrentWindowStack.Size == 1);    // Mismatched Begin()/End() calls, did you forget to call end on g.CurrentWindow->Name?
    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
        g.CurrentWindow->Active = false;
    End();

    // Show CTRL+TAB list
    if (g.NavWindowingTarget)
        NavUpdateWindowingList();

    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
    if (g.DragDropActive)
    {
        bool is_delivered = g.DragDropPayload.Delivery;
        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
        if (is_delivered || is_elapsed)
            ClearDragDrop();
    }

    // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount)
    {
        g.DragDropWithinSourceOrTarget = true;
        SetTooltip("...");
        g.DragDropWithinSourceOrTarget = false;
    }

    // Initiate moving window
    if (g.ActiveId == 0 && g.HoveredId == 0)
    {
        if (!g.NavWindow || !g.NavWindow->Appearing) // Unless we just made a window/popup appear
        {
            // Click to focus window and start moving (after we're done with all our widgets)
            if (g.IO.MouseClicked[0])
            {
                if (g.HoveredRootWindow != NULL)
                {
                    LoopCallbackMouseMovingWindow(g.HoveredWindow);
                    if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(g.HoveredRootWindow->Flags & ImGuiWindowFlags_NoTitleBar))
                        if (!g.HoveredRootWindow->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
                            g.MovingWindow = NULL;
                }
                else if (g.NavWindow != NULL && GetFrontMostPopupModal() == NULL)
                {
                    FocusWindow(NULL);  // Clicking on void disable focus
                }
            }

            // With right mouse button we close popups without changing focus
            // (The left mouse button path calls FocusWindow which will lead NewFrame->ClosePopupsOverWindow to trigger)
            if (g.IO.MouseClicked[1])
            {
                // Find the top-most window between HoveredWindow and the front most Modal Window.
                // This is where we can trim the popup stack.
                ImGuiWindow* modal = GetFrontMostPopupModal();
                bool hovered_window_above_modal = false;
                if (modal == NULL)
                    hovered_window_above_modal = true;
                for (int i = g.Windows.Size - 1; i >= 0 && hovered_window_above_modal == false; i--)
                {
                    ImGuiWindow* window = g.Windows[i];
                    if (window == modal)
                        break;
                    if (window == g.HoveredWindow)
                        hovered_window_above_modal = true;
                }
                ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal);
            }
        }
    }

    // Sort the window list so that all child windows are after their parent
    // We cannot do that on FocusWindow() because childs may not exist yet
    g.WindowsSortBuffer.resize(0);
    g.WindowsSortBuffer.reserve(g.Windows.Size);
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
            continue;
        AddWindowToSortBuffer(&g.WindowsSortBuffer, window);
    }

    IM_ASSERT(g.Windows.Size == g.WindowsSortBuffer.Size);  // we done something wrong
    g.Windows.swap(g.WindowsSortBuffer);
    g.IO.MetricsActiveWindows = g.WindowsActiveCount;

    // Unlock font atlas
    g.IO.Fonts->Locked = false;

    // Clear Input data for next frame
    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
    memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));
    memset(g.IO.NavInputs, 0, sizeof(g.IO.NavInputs));

    g.FrameScopeActive = false;
    g.FrameCountEnded = g.FrameCount;
}

void ImGui::Render()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);

    if (g.FrameCountEnded != g.FrameCount)
        EndFrame();
    g.FrameCountRendered = g.FrameCount;

    // Gather ImDrawList to render (for each active window)
    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = g.IO.MetricsRenderWindows = 0;
    g.DrawDataBuilder.Clear();
    ImGuiWindow* windows_to_render_front_most[2];
    windows_to_render_front_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindow : NULL;
    windows_to_render_front_most[1] = g.NavWindowingTarget ? g.NavWindowingList : NULL;
    for (int n = 0; n != g.Windows.Size; n++)
    {
        ImGuiWindow* window = g.Windows[n];
        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_front_most[0] && window != windows_to_render_front_most[1])
            AddWindowToDrawDataSelectLayer(window);
    }
    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_front_most); n++)
        if (windows_to_render_front_most[n] && IsWindowActiveAndVisible(windows_to_render_front_most[n])) // NavWindowingTarget is always temporarily displayed as the front-most window
            AddWindowToDrawDataSelectLayer(windows_to_render_front_most[n]);
    g.DrawDataBuilder.FlattenIntoSingleLayer();

    // Draw software mouse cursor if requested
    if (g.IO.MouseDrawCursor)
        RenderMouseCursor(&g.OverlayDrawList, g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor);

    if (!g.OverlayDrawList.VtxBuffer.empty())
        AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.OverlayDrawList);

    // Setup ImDrawData structure for end-user
    SetupDrawData(&g.DrawDataBuilder.Layers[0], &g.DrawData);
    g.IO.MetricsRenderVertices = g.DrawData.TotalVtxCount;
    g.IO.MetricsRenderIndices = g.DrawData.TotalIdxCount;

    // Render. If user hasn't set a callback then they may retrieve the draw data via GetDrawData()
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    if (g.DrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL)
        g.IO.RenderDrawListsFn(&g.DrawData);
#endif
}

// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return ImVec2(0.0f, GImGui->FontSize)
ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
{
    ImGuiContext& g = *GImGui;

    const char* text_display_end;
    if (hide_text_after_double_hash)
        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
    else
        text_display_end = text_end;

    ImFont* font = g.Font;
    const float font_size = g.FontSize;
    if (text == text_display_end)
        return ImVec2(0.0f, font_size);
    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

    // Cancel out character spacing for the last character of a line (it is baked into glyph->AdvanceX field)
    const float font_scale = font_size / font->FontSize;
    const float character_spacing_x = 1.0f * font_scale;
    if (text_size.x > 0.0f)
        text_size.x -= character_spacing_x;
    text_size.x = (float)(int)(text_size.x + 0.95f);

    return text_size;
}

// Helper to calculate coarse clipping of large list of evenly sized items.
// NB: Prefer using the ImGuiListClipper higher-level helper if you can! Read comments and instructions there on how those use this sort of pattern.
// NB: 'items_count' is only used to clamp the result, if you don't know your count you can use INT_MAX
void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.LogEnabled)
    {
        // If logging is active, do not perform any clipping
        *out_items_display_start = 0;
        *out_items_display_end = items_count;
        return;
    }
    if (window->SkipItems)
    {
        *out_items_display_start = *out_items_display_end = 0;
        return;
    }

    // We create the union of the ClipRect and the NavScoringRect which at worst should be 1 page away from ClipRect
    ImRect unclipped_rect = window->ClipRect;
    if (g.NavMoveRequest)
        unclipped_rect.Add(g.NavScoringRectScreen);

    const ImVec2 pos = window->DC.CursorPos;
    int start = (int)((unclipped_rect.Min.y - pos.y) / items_height);
    int end = (int)((unclipped_rect.Max.y - pos.y) / items_height);

    // When performing a navigation request, ensure we have one item extra in the direction we are moving to
    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Up)
        start--;
    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Down)
        end++;

    start = ImClamp(start, 0, items_count);
    end = ImClamp(end + 1, start, items_count);
    *out_items_display_start = start;
    *out_items_display_end = end;
}

// Find window given position, search front-to-back
// FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programatically 
// with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is 
// called, aka before the next Begin(). Moving window isn't affected.
static void FindHoveredWindow()
{
    ImGuiContext& g = *GImGui;

    ImGuiWindow* hovered_window = NULL;
    if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
        hovered_window = g.MovingWindow;

    ImVec2 padding_regular = g.Style.TouchExtraPadding;
    ImVec2 padding_for_resize_from_edges = g.IO.ConfigWindowsResizeFromEdges ? ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS)) : padding_regular;
    for (int i = g.Windows.Size - 1; i >= 0; i--)
    {
        ImGuiWindow* window = g.Windows[i];
        if (!window->Active || window->Hidden)
            continue;
        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
            continue;

        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
        ImRect bb(window->OuterRectClipped);
        if ((window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_NoResize))
            bb.Expand(padding_regular);
        else
            bb.Expand(padding_for_resize_from_edges);
        if (!bb.Contains(g.IO.MousePos))
            continue;

        // Those seemingly unnecessary extra tests are because the code here is a little different in viewport/docking branches.
        if (hovered_window == NULL)
            hovered_window = window;
        if (hovered_window)
            break;
    }

    g.HoveredWindow = hovered_window;
    g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;

}

// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)
{
    ImGuiContext& g = *GImGui;

    // Clip
    ImRect rect_clipped(r_min, r_max);
    if (clip)
        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);

    // Expand for touch input
    const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);
    if (!rect_for_touch.Contains(g.IO.MousePos))
        return false;
    return true;
}

int ImGui::GetKeyIndex(ImGuiKey imgui_key)
{
    IM_ASSERT(imgui_key >= 0 && imgui_key < ImGuiKey_COUNT);
    return GImGui->IO.KeyMap[imgui_key];
}

// Note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your back-end/engine stored them into io.KeysDown[]!
bool ImGui::IsKeyDown(int user_key_index)
{
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(GImGui->IO.KeysDown));
    return GImGui->IO.KeysDown[user_key_index];
}

int ImGui::CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate)
{
    if (t == 0.0f)
        return 1;
    if (t <= repeat_delay || repeat_rate <= 0.0f)
        return 0;
    const int count = (int)((t - repeat_delay) / repeat_rate) - (int)((t_prev - repeat_delay) / repeat_rate);
    return (count > 0) ? count : 0;
}

int ImGui::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)
{
    ImGuiContext& g = *GImGui;
    if (key_index < 0) return false;
    IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[key_index];
    return CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, repeat_delay, repeat_rate);
}

bool ImGui::IsKeyPressed(int user_key_index, bool repeat)
{
    ImGuiContext& g = *GImGui;
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[user_key_index];
    if (t == 0.0f)
        return true;
    if (repeat && t > g.IO.KeyRepeatDelay)
        return GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
    return false;
}

bool ImGui::IsKeyReleased(int user_key_index)
{
    ImGuiContext& g = *GImGui;
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    return g.IO.KeysDownDurationPrev[user_key_index] >= 0.0f && !g.IO.KeysDown[user_key_index];
}

bool ImGui::IsMouseDown(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDown[button];
}

bool ImGui::IsAnyMouseDown()
{
    ImGuiContext& g = *GImGui;
    for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)
        if (g.IO.MouseDown[n])
            return true;
    return false;
}

bool ImGui::IsMouseClicked(int button, bool repeat)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    const float t = g.IO.MouseDownDuration[button];
    if (t == 0.0f)
        return true;

    if (repeat && t > g.IO.KeyRepeatDelay)
    {
        float delay = g.IO.KeyRepeatDelay, rate = g.IO.KeyRepeatRate;
        if ((ImFmod(t - delay, rate) > rate*0.5f) != (ImFmod(t - delay - g.IO.DeltaTime, rate) > rate*0.5f))
            return true;
    }

    return false;
}

bool ImGui::IsMouseReleased(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseReleased[button];
}

bool ImGui::IsMouseDoubleClicked(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDoubleClicked[button];
}

bool ImGui::IsMouseDragging(int button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (!g.IO.MouseDown[button])
        return false;
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
}

ImVec2 ImGui::GetMousePos()
{
    return GImGui->IO.MousePos;
}

// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    if (g.BeginPopupStack.Size > 0)
        return g.OpenPopupStack[g.BeginPopupStack.Size-1].OpenMousePos;
    return g.IO.MousePos;
}

// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position
bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)
{
    if (mouse_pos == NULL)
        mouse_pos = &GImGui->IO.MousePos;
    const float MOUSE_INVALID = -256000.0f;
    return mouse_pos->x >= MOUSE_INVALID && mouse_pos->y >= MOUSE_INVALID;
}

// NB: This is only valid if IsMousePosValid(). Back-ends in theory should always keep mouse position valid when dragging even outside the client window.
ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    if (g.IO.MouseDown[button])
        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
            return g.IO.MousePos - g.IO.MouseClickedPos[button];     // Assume we can only get active with left-mouse button (at the moment).
    return ImVec2(0.0f, 0.0f);
}

void ImGui::ResetMouseDragDelta(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
    g.IO.MouseClickedPos[button] = g.IO.MousePos;
}

ImGuiMouseCursor ImGui::GetMouseCursor()
{
    return GImGui->MouseCursor;
}

void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)
{
    GImGui->MouseCursor = cursor_type;
}

void ImGui::CaptureKeyboardFromApp(bool capture)
{
    GImGui->WantCaptureKeyboardNextFrame = capture ? 1 : 0;
}

void ImGui::CaptureMouseFromApp(bool capture)
{
    GImGui->WantCaptureMouseNextFrame = capture ? 1 : 0;
}

bool ImGui::IsItemActive()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId)
    {
        ImGuiWindow* window = g.CurrentWindow;
        return g.ActiveId == window->DC.LastItemId;
    }
    return false;
}

bool ImGui::IsItemDeactivated()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    return (g.ActiveIdPreviousFrame == window->DC.LastItemId && g.ActiveIdPreviousFrame != 0 && g.ActiveId != window->DC.LastItemId);
}

bool ImGui::IsItemDeactivatedAfterEdit()
{
    ImGuiContext& g = *GImGui;
    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEdited || (g.ActiveId == 0 && g.ActiveIdHasBeenEdited));
}

bool ImGui::IsItemFocused()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    return g.NavId && !g.NavDisableHighlight && g.NavId == window->DC.LastItemId;
}

bool ImGui::IsItemClicked(int mouse_button)
{
    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);
}

bool ImGui::IsAnyItemHovered()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

bool ImGui::IsAnyItemActive()
{
    ImGuiContext& g = *GImGui;
    return g.ActiveId != 0;
}

bool ImGui::IsAnyItemFocused()
{
    ImGuiContext& g = *GImGui;
    return g.NavId != 0 && !g.NavDisableHighlight;
}

bool ImGui::IsItemVisible()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ClipRect.Overlaps(window->DC.LastItemRect);
}

bool ImGui::IsItemEdited()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_Edited) != 0;
}

// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.
void ImGui::SetItemAllowOverlap()
{
    ImGuiContext& g = *GImGui;
    if (g.HoveredId == g.CurrentWindow->DC.LastItemId)
        g.HoveredIdAllowOverlap = true;
    if (g.ActiveId == g.CurrentWindow->DC.LastItemId)
        g.ActiveIdAllowOverlap = true;
}

ImVec2 ImGui::GetItemRectMin()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Min;
}

ImVec2 ImGui::GetItemRectMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Max;
}

ImVec2 ImGui::GetItemRectSize()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.GetSize();
}

static ImRect GetViewportRect()
{
    ImGuiContext& g = *GImGui;
    if (g.IO.DisplayVisibleMin.x != g.IO.DisplayVisibleMax.x && g.IO.DisplayVisibleMin.y != g.IO.DisplayVisibleMax.y)
        return ImRect(g.IO.DisplayVisibleMin, g.IO.DisplayVisibleMax);
    return ImRect(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
}

static bool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;

    flags |= ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_ChildWindow;
    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag

    // Size
    const ImVec2 content_avail = GetContentRegionAvail();
    ImVec2 size = ImFloor(size_arg);
    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);
    if (size.x <= 0.0f)
        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
    if (size.y <= 0.0f)
        size.y = ImMax(content_avail.y + size.y, 4.0f);
    SetNextWindowSize(size);

    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
    char title[256];
    if (name)
        ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s_%08X", parent_window->Name, name, id);
    else
        ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);

    const float backup_border_size = g.Style.ChildBorderSize;
    if (!border)
        g.Style.ChildBorderSize = 0.0f;
    bool ret = Begin(title, NULL, flags);
    g.Style.ChildBorderSize = backup_border_size;

    ImGuiWindow* child_window = g.CurrentWindow;
    child_window->ChildId = id;
    child_window->AutoFitChildAxises = auto_fit_axises;

    // Process navigation-in immediately so NavInit can run on first frame
    if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll))
    {
        FocusWindow(child_window);
        NavInitWindow(child_window, false);
        SetActiveID(id+1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item
        g.ActiveIdSource = ImGuiInputSource_Nav;
    }
    return ret;
}

bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    IM_ASSERT(id != 0);
    return BeginChildEx(NULL, id, size_arg, border, extra_flags);
}

void ImGui::EndChild()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss
    if (window->BeginCount > 1)
    {
        End();
    }
    else
    {
        ImVec2 sz = window->Size;
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
            sz.x = ImMax(4.0f, sz.x);
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))
            sz.y = ImMax(4.0f, sz.y);
        End();

        ImGuiWindow* parent_window = g.CurrentWindow;
        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
        ItemSize(sz);
        if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))
        {
            ItemAdd(bb, window->ChildId);
            RenderNavHighlight(bb, window->ChildId);

            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child
            if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)
                RenderNavHighlight(ImRect(bb.Min - ImVec2(2,2), bb.Max + ImVec2(2,2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);
        }
        else
        {
            // Not navigable into
            ItemAdd(bb, 0);
        }
    }
}

// Helper to create a child window / scrolling region that looks like a normal widget frame.
bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);
    PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);
    PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);
    PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);
    bool ret = BeginChild(id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);
    PopStyleVar(3);
    PopStyleColor();
    return ret;
}

void ImGui::EndChildFrame()
{
    EndChild();
}

// Save and compare stack sizes on Begin()/End() to detect usage errors
static void CheckStacksSize(ImGuiWindow* window, bool write)
{
    // NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
    ImGuiContext& g = *GImGui;
    short* p_backup = &window->DC.StackSizesBackup[0];
    { int current = window->IDStack.Size;       if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "PushID/PopID or TreeNode/TreePop Mismatch!");   p_backup++; }    // Too few or too many PopID()/TreePop()
    { int current = window->DC.GroupStack.Size; if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginGroup/EndGroup Mismatch!");                p_backup++; }    // Too few or too many EndGroup()
    { int current = g.BeginPopupStack.Size;     if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch"); p_backup++;}// Too few or too many EndMenu()/EndPopup()
    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
    { int current = g.ColorModifiers.Size;      if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleColor/PopStyleColor Mismatch!");       p_backup++; }    // Too few or too many PopStyleColor()
    { int current = g.StyleModifiers.Size;      if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleVar/PopStyleVar Mismatch!");           p_backup++; }    // Too few or too many PopStyleVar()
    { int current = g.FontStack.Size;           if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushFont/PopFont Mismatch!");                   p_backup++; }    // Too few or too many PopFont()
    IM_ASSERT(p_backup == window->DC.StackSizesBackup + IM_ARRAYSIZE(window->DC.StackSizesBackup));
}

static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)
{
    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
}

ImGuiWindow* ImGui::FindWindowByID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
}

ImGuiWindow* ImGui::FindWindowByName(const char* name)
{
    ImGuiID id = ImHash(name, 0);
    return FindWindowByID(id);
}

static ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;

    // Create window the first time
    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
    window->Flags = flags;
    g.WindowsById.SetVoidPtr(window->ID, window);

    // Default/arbitrary window position. Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
    window->Pos = ImVec2(60, 60);

    // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.
    if (!(flags & ImGuiWindowFlags_NoSavedSettings))
        if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))
        {
            // Retrieve settings from .ini file
            window->SettingsIdx = g.SettingsWindows.index_from_pointer(settings);
            SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
            window->Pos = ImFloor(settings->Pos);
            window->Collapsed = settings->Collapsed;
            if (ImLengthSqr(settings->Size) > 0.00001f)
                size = ImFloor(settings->Size);
        }
    window->Size = window->SizeFull = window->SizeFullAtLastBegin = ImFloor(size);
    window->DC.CursorMaxPos = window->Pos; // So first call to CalcSizeContents() doesn't return crazy values

    if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
    {
        window->AutoFitFramesX = window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
    else
    {
        if (window->Size.x <= 0.0f)
            window->AutoFitFramesX = 2;
        if (window->Size.y <= 0.0f)
            window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
    }

    g.WindowsFocusOrder.push_back(window);
    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
        g.Windows.push_front(window); // Quite slow but rare and only once
    else
        g.Windows.push_back(window);
    return window;
}

static ImVec2 CalcSizeAfterConstraint(ImGuiWindow* window, ImVec2 new_size)
{
    ImGuiContext& g = *GImGui;
    if (g.NextWindowData.SizeConstraintCond != 0)
    {
        // Using -1,-1 on either X/Y axis to preserve the current size.
        ImRect cr = g.NextWindowData.SizeConstraintRect;
        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
        if (g.NextWindowData.SizeCallback)
        {
            ImGuiSizeCallbackData data;
            data.UserData = g.NextWindowData.SizeCallbackUserData;
            data.Pos = window->Pos;
            data.CurrentSize = window->SizeFull;
            data.DesiredSize = new_size;
            g.NextWindowData.SizeCallback(&data);
            new_size = data.DesiredSize;
        }
    }

    // Minimum size
    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))
    {
        new_size = ImMax(new_size, g.Style.WindowMinSize);
        new_size.y = ImMax(new_size.y, window->TitleBarHeight() + window->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f)); // Reduce artifacts with very small windows
    }
    return new_size;
}

static ImVec2 CalcSizeContents(ImGuiWindow* window)
{
    if (window->Collapsed)
        return window->SizeContents;
    if (window->Hidden && window->HiddenFramesForResize == 0 && window->HiddenFramesRegular > 0)
        return window->SizeContents;

    ImVec2 sz;
    sz.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : (window->DC.CursorMaxPos.x - window->Pos.x + window->Scroll.x));
    sz.y = (float)(int)((window->SizeContentsExplicit.y != 0.0f) ? window->SizeContentsExplicit.y : (window->DC.CursorMaxPos.y - window->Pos.y + window->Scroll.y));
    return sz + window->WindowPadding;
}

static ImVec2 CalcSizeAutoFit(ImGuiWindow* window, const ImVec2& size_contents)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {
        // Tooltip always resize
        return size_contents;
    }
    else
    {
        // When the window cannot fit all contents (either because of constraints, either because screen is too small): we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than DisplaySize-WindowPadding.
        const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;
        const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;
        ImVec2 size_min = style.WindowMinSize;
        if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
            size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));
        ImVec2 size_auto_fit = ImClamp(size_contents, size_min, ImMax(size_min, g.IO.DisplaySize - style.DisplaySafeAreaPadding * 2.0f));
        ImVec2 size_auto_fit_after_constraint = CalcSizeAfterConstraint(window, size_auto_fit);
        if (size_auto_fit_after_constraint.x < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar))
            size_auto_fit.y += style.ScrollbarSize;
        if (size_auto_fit_after_constraint.y < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar))
            size_auto_fit.x += style.ScrollbarSize;
        return size_auto_fit;
    }
}

ImVec2 ImGui::CalcWindowExpectedSize(ImGuiWindow* window)
{
    ImVec2 size_contents = CalcSizeContents(window);
    return CalcSizeAfterConstraint(window, CalcSizeAutoFit(window, size_contents));
}

float ImGui::GetWindowScrollMaxX(ImGuiWindow* window)
{
    return ImMax(0.0f, window->SizeContents.x - (window->SizeFull.x - window->ScrollbarSizes.x));
}

float ImGui::GetWindowScrollMaxY(ImGuiWindow* window)
{
    return ImMax(0.0f, window->SizeContents.y - (window->SizeFull.y - window->ScrollbarSizes.y));
}

static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges)
{
    ImGuiContext& g = *GImGui;
    ImVec2 scroll = window->Scroll;
    if (window->ScrollTarget.x < FLT_MAX)
    {
        float cr_x = window->ScrollTargetCenterRatio.x;
        scroll.x = window->ScrollTarget.x - cr_x * (window->SizeFull.x - window->ScrollbarSizes.x);
    }
    if (window->ScrollTarget.y < FLT_MAX)
    {
        // 'snap_on_edges' allows for a discontinuity at the edge of scrolling limits to take account of WindowPadding so that scrolling to make the last item visible scroll far enough to see the padding.
        float cr_y = window->ScrollTargetCenterRatio.y;
        float target_y = window->ScrollTarget.y;
        if (snap_on_edges && cr_y <= 0.0f && target_y <= window->WindowPadding.y)
            target_y = 0.0f;
        if (snap_on_edges && cr_y >= 1.0f && target_y >= window->SizeContents.y - window->WindowPadding.y + g.Style.ItemSpacing.y)
            target_y = window->SizeContents.y;
        scroll.y = target_y - (1.0f - cr_y) * (window->TitleBarHeight() + window->MenuBarHeight()) - cr_y * (window->SizeFull.y - window->ScrollbarSizes.y);
    }
    scroll = ImMax(scroll, ImVec2(0.0f, 0.0f));
    if (!window->Collapsed && !window->SkipItems)
    {
        scroll.x = ImMin(scroll.x, ImGui::GetWindowScrollMaxX(window));
        scroll.y = ImMin(scroll.y, ImGui::GetWindowScrollMaxY(window));
    }
    return scroll;
}

static ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags flags)
{
    if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
        return ImGuiCol_PopupBg;
    if (flags & ImGuiWindowFlags_ChildWindow)
        return ImGuiCol_ChildBg;
    return ImGuiCol_WindowBg;
}

static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)
{
    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left
    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
    ImVec2 size_expected = pos_max - pos_min;
    ImVec2 size_constrained = CalcSizeAfterConstraint(window, size_expected);
    *out_pos = pos_min;
    if (corner_norm.x == 0.0f)
        out_pos->x -= (size_constrained.x - size_expected.x);
    if (corner_norm.y == 0.0f)
        out_pos->y -= (size_constrained.y - size_expected.y);
    *out_size = size_constrained;
}

struct ImGuiResizeGripDef
{
    ImVec2  CornerPos;
    ImVec2  InnerDir;
    int     AngleMin12, AngleMax12;
};

const ImGuiResizeGripDef resize_grip_def[4] =
{
    { ImVec2(1,1), ImVec2(-1,-1), 0, 3 }, // Lower right
    { ImVec2(0,1), ImVec2(+1,-1), 3, 6 }, // Lower left
    { ImVec2(0,0), ImVec2(+1,+1), 6, 9 }, // Upper left
    { ImVec2(1,0), ImVec2(-1,+1), 9,12 }, // Upper right
};

static ImRect GetResizeBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)
{
    ImRect rect = window->Rect();
    if (thickness == 0.0f) rect.Max -= ImVec2(1,1);
    if (border_n == 0) return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness,    rect.Max.x - perp_padding, rect.Min.y + thickness);
    if (border_n == 1) return ImRect(rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x + thickness,    rect.Max.y - perp_padding);
    if (border_n == 2) return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y + thickness);
    if (border_n == 3) return ImRect(rect.Min.x - thickness,    rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding);
    IM_ASSERT(0);
    return ImRect();
}

// Handle resize for: Resize Grips, Borders, Gamepad
static void ImGui::UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4])
{
    ImGuiContext& g = *GImGui;
    ImGuiWindowFlags flags = window->Flags;
    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        return;
    if (window->WasActive == false) // Early out to avoid running this code for e.g. an hidden implicit/fallback Debug window.
        return;

    const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;
    const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);
    const float grip_hover_inner_size = (float)(int)(grip_draw_size * 0.75f);
    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS : 0.0f;

    ImVec2 pos_target(FLT_MAX, FLT_MAX);
    ImVec2 size_target(FLT_MAX, FLT_MAX);

    // Manual resize grips
    PushID("#RESIZE");
    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
    {
        const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPos);

        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
        ImRect resize_rect(corner - grip.InnerDir * grip_hover_outer_size, corner + grip.InnerDir * grip_hover_inner_size);
        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
        bool hovered, held;
        ButtonBehavior(resize_rect, window->GetID((void*)(intptr_t)resize_grip_n), &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
        //GetOverlayDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
        if (hovered || held)
            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;

        if (held && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)
        {
            // Manual auto-fit when double-clicking
            size_target = CalcSizeAfterConstraint(window, size_auto_fit);
            ClearActiveID();
        }
        else if (held)
        {
            // Resize from any of the four corners
            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(grip.InnerDir * grip_hover_outer_size, grip.InnerDir * -grip_hover_inner_size, grip.CornerPos); // Corner of the window corresponding to our corner grip
            CalcResizePosSizeFromAnyCorner(window, corner_target, grip.CornerPos, &pos_target, &size_target);
        }
        if (resize_grip_n == 0 || held || hovered)
            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
    }
    for (int border_n = 0; border_n < resize_border_count; border_n++)
    {
        bool hovered, held;
        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS);
        ButtonBehavior(border_rect, window->GetID((void*)(intptr_t)(border_n + 4)), &hovered, &held, ImGuiButtonFlags_FlattenChildren);
        //GetOverlayDrawList(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
        if ((hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER) || held)
        {
            g.MouseCursor = (border_n & 1) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
            if (held) *border_held = border_n;
        }
        if (held)
        {
            ImVec2 border_target = window->Pos;
            ImVec2 border_posn;
            if (border_n == 0) { border_posn = ImVec2(0, 0); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); }
            if (border_n == 1) { border_posn = ImVec2(1, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); }
            if (border_n == 2) { border_posn = ImVec2(0, 1); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); }
            if (border_n == 3) { border_posn = ImVec2(0, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); }
            CalcResizePosSizeFromAnyCorner(window, border_target, border_posn, &pos_target, &size_target);
        }
    }
    PopID();

    // Navigation resize (keyboard/gamepad)
    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window)
    {
        ImVec2 nav_resize_delta;
        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && g.IO.KeyShift)
            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
        if (g.NavInputSource == ImGuiInputSource_NavGamepad)
            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_Down);
        if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)
        {
            const float NAV_RESIZE_SPEED = 600.0f;
            nav_resize_delta *= ImFloor(NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));
            g.NavWindowingToggleLayer = false;
            g.NavDisableMouseHover = true;
            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
            // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
            size_target = CalcSizeAfterConstraint(window, window->SizeFull + nav_resize_delta);
        }
    }

    // Apply back modified position/size to window
    if (size_target.x != FLT_MAX)
    {
        window->SizeFull = size_target;
        MarkIniSettingsDirty(window);
    }
    if (pos_target.x != FLT_MAX)
    {
        window->Pos = ImFloor(pos_target);
        MarkIniSettingsDirty(window);
    }

    window->Size = window->SizeFull;
}

void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)
{
    window->ParentWindow = parent_window;
    window->RootWindow = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
        window->RootWindow = parent_window->RootWindow;
    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))
        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
    while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
}

// Push a new ImGui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    IM_ASSERT(name != NULL);                        // Window name required
    IM_ASSERT(g.FrameScopeActive);                  // Forgot to call ImGui::NewFrame()
    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

    // Find or create
    ImGuiWindow* window = FindWindowByName(name);
    const bool window_just_created = (window == NULL);
    if (window_just_created)
    {
        ImVec2 size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : ImVec2(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
        window = CreateNewWindow(name, size_on_first_use, flags);
    }

    // Automatically disable manual moving/resizing when NoInputs is set
    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;

    if (flags & ImGuiWindowFlags_NavFlattened)
        IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);

    const int current_frame = g.FrameCount;
    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

    // Update Flags, LastFrameActive, BeginOrderXXX fields
    if (first_begin_of_the_frame)
        window->Flags = (ImGuiWindowFlags)flags;
    else
        flags = window->Flags;

    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
    ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
    window->HasCloseButton = (p_open != NULL);

    // Update the Appearing flag
    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
    const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesForResize > 0);
    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
        window_just_activated_by_user |= (window != popup_ref.Window);
    }
    window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);

    // Add to stack
    g.CurrentWindowStack.push_back(window);
    SetCurrentWindow(window);
    CheckStacksSize(window, true);
    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        popup_ref.Window = window;
        g.BeginPopupStack.push_back(popup_ref);
        window->PopupId = popup_ref.PopupId;
    }

    if (window_just_appearing_after_hidden_for_resize && !(flags & ImGuiWindowFlags_ChildWindow))
        window->NavLastIds[0] = 0;

    // Process SetNextWindow***() calls
    bool window_pos_set_by_api = false;
    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
    if (g.NextWindowData.PosCond)
    {
        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
        {
            // May be processed on the next frame if this is our first frame and we are measuring size
            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
            window->SetWindowPosVal = g.NextWindowData.PosVal;
            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        }
        else
        {
            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
        }
    }
    if (g.NextWindowData.SizeCond)
    {
        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
    }
    if (g.NextWindowData.ContentSizeCond)
    {
        // Adjust passed "client size" to become a "window size"
        window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
        if (window->SizeContentsExplicit.y != 0.0f)
            window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
    }
    else if (first_begin_of_the_frame)
    {
        window->SizeContentsExplicit = ImVec2(0.0f, 0.0f);
    }
    if (g.NextWindowData.CollapsedCond)
        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
    if (g.NextWindowData.FocusCond)
        FocusWindow(window);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);

    // When reusing window again multiple times a frame, just append content (don't need to setup again)
    if (first_begin_of_the_frame)
    {
        // Initialize
        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
        UpdateWindowParentAndRootLinks(window, flags, parent_window);

        window->Active = true;
        window->BeginOrderWithinParent = 0;
        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
        window->BeginCount = 0;
        window->ClipRect = ImVec4(-FLT_MAX,-FLT_MAX,+FLT_MAX,+FLT_MAX);
        window->LastFrameActive = current_frame;
        window->IDStack.resize(1);

        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

        // Update contents size from last frame for auto-fitting (or use explicit size)
        window->SizeContents = CalcSizeContents(window);
        if (window->HiddenFramesRegular > 0)
            window->HiddenFramesRegular--;
        if (window->HiddenFramesForResize > 0)
            window->HiddenFramesForResize--;

        // Hide new windows for one frame until they calculate their size
        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
            window->HiddenFramesForResize = 1;

        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
        // We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
        {
            window->HiddenFramesForResize = 1;
            if (flags & ImGuiWindowFlags_AlwaysAutoResize)
            {
                if (!window_size_x_set_by_api)
                    window->Size.x = window->SizeFull.x = 0.f;
                if (!window_size_y_set_by_api)
                    window->Size.y = window->SizeFull.y = 0.f;
                window->SizeContents = ImVec2(0.f, 0.f);
            }
        }

        SetCurrentWindow(window);

        // Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
        window->WindowBorderSize = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildBorderSize : ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
        window->WindowPadding = style.WindowPadding;
        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

        // Collapse window by double-clicking on title bar
        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))
        {
            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
            ImRect title_bar_rect = window->TitleBarRect();
            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
                window->WantCollapseToggle = true;
            if (window->WantCollapseToggle)
            {
                window->Collapsed = !window->Collapsed;
                MarkIniSettingsDirty(window);
                FocusWindow(window);
            }
        }
        else
        {
            window->Collapsed = false;
        }
        window->WantCollapseToggle = false;

        // SIZE

        // Calculate auto-fit size, handle automatic resize
        const ImVec2 size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
        ImVec2 size_full_modified(FLT_MAX, FLT_MAX);
        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
        {
            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
            if (!window_size_x_set_by_api)
                window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
            if (!window_size_y_set_by_api)
                window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
        }
        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        {
            // Auto-fit may only grow window during the first few frames
            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
                window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
                window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
            if (!window->Collapsed)
                MarkIniSettingsDirty(window);
        }

        // Apply minimum/maximum window size constraints and final size
        window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

        // SCROLLBAR STATUS

        // Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
        if (!window->Collapsed)
        {
            // When reading the current size we need to read it after size constraints have been applied
            float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
            float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
            if (window->ScrollbarX && !window->ScrollbarY)
                window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);
            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
        }

        // POSITION

        // Popup latch its initial position, will position itself when it appears next frame
        if (window_just_activated_by_user)
        {
            window->AutoPosLastDirection = ImGuiDir_None;
            if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api)
                window->Pos = g.BeginPopupStack.back().OpenPopupPos;
        }

        // Position child window
        if (flags & ImGuiWindowFlags_ChildWindow)
        {
            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
            parent_window->DC.ChildWindows.push_back(window);
            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
                window->Pos = parent_window->DC.CursorPos;
        }

        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesForResize == 0);
        if (window_pos_with_pivot)
            SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
            window->Pos = FindBestWindowPosForPopup(window);

        // Clamp position so it stays visible
        if (!(flags & ImGuiWindowFlags_ChildWindow))
        {
            if (!window_pos_set_by_api && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
            {
                ImVec2 padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
                ImVec2 size_for_clamping = ((g.IO.ConfigWindowsMoveFromTitleBarOnly) && !(window->Flags & ImGuiWindowFlags_NoTitleBar)) ? ImVec2(window->Size.x, window->TitleBarHeight()) : window->Size;
                window->Pos = ImMax(window->Pos + size_for_clamping, padding) - size_for_clamping;
                window->Pos = ImMin(window->Pos, g.IO.DisplaySize - padding);
            }
        }
        window->Pos = ImFloor(window->Pos);

        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
        window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

        // Prepare for item focus requests
        window->FocusIdxAllRequestCurrent = (window->FocusIdxAllRequestNext == INT_MAX || window->FocusIdxAllCounter == -1) ? INT_MAX : (window->FocusIdxAllRequestNext + (window->FocusIdxAllCounter+1)) % (window->FocusIdxAllCounter+1);
        window->FocusIdxTabRequestCurrent = (window->FocusIdxTabRequestNext == INT_MAX || window->FocusIdxTabCounter == -1) ? INT_MAX : (window->FocusIdxTabRequestNext + (window->FocusIdxTabCounter+1)) % (window->FocusIdxTabCounter+1);
        window->FocusIdxAllCounter = window->FocusIdxTabCounter = -1;
        window->FocusIdxAllRequestNext = window->FocusIdxTabRequestNext = INT_MAX;

        // Apply scrolling
        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

        // Apply window focus (new and reactivated windows are moved to front)
        bool want_focus = false;
        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
            if (!(flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) || (flags & ImGuiWindowFlags_Popup))
                want_focus = true;

        // Handle manual resize: Resize Grips, Borders, Gamepad
        int border_held = -1;
        ImU32 resize_grip_col[4] = { 0 };
        const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
        const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);
        if (!window->Collapsed)
            UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);

        // Default item width. Make it proportional to window size if window manually resizes
        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
            window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
        else
            window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

        // DRAWING

        // Setup draw list and outer clipping rectangle
        window->DrawList->Clear();
        window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
        ImRect viewport_rect(GetViewportRect());
        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
            PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
        else
            PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

        // Draw modal window background (darkens what is behind them, all viewports)
        const bool dim_bg_for_modal = (flags & ImGuiWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesForResize <= 0;
        const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
        if (dim_bg_for_modal || dim_bg_for_window_list)
        {
            const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
            window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
        }

        // Draw navigation selection/windowing rectangle background
        if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
        {
            ImRect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
                window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
        }

        // Draw window + handle manual resize
        const float window_rounding = window->WindowRounding;
        const float window_border_size = window->WindowBorderSize;
        const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
        const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
        const ImRect title_bar_rect = window->TitleBarRect();
        if (window->Collapsed)
        {
            // Title bar only
            float backup_border_size = style.FrameBorderSize;
            g.Style.FrameBorderSize = window->WindowBorderSize;
            ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
            RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
            g.Style.FrameBorderSize = backup_border_size;
        }
        else
        {
            // Window background
            if (!(flags & ImGuiWindowFlags_NoBackground))
            {
                ImU32 bg_col = GetColorU32(GetWindowBgColorIdxFromFlags(flags));
                if (g.NextWindowData.BgAlphaCond != 0)
                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(g.NextWindowData.BgAlphaVal) << IM_COL32_A_SHIFT);
                window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Bot);
            }
            g.NextWindowData.BgAlphaCond = 0;

            // Title bar
            if (!(flags & ImGuiWindowFlags_NoTitleBar))
            {
                ImU32 title_bar_col = GetColorU32(window->Collapsed ? ImGuiCol_TitleBgCollapsed : title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
                window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
            }

            // Menu bar
            if (flags & ImGuiWindowFlags_MenuBar)
            {
                ImRect menu_bar_rect = window->MenuBarRect();
                menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
                window->DrawList->AddRectFilled(menu_bar_rect.Min, menu_bar_rect.Max, GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
                if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
                    window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
            }

            // Scrollbars
            if (window->ScrollbarX)
                Scrollbar(ImGuiLayoutType_Horizontal);
            if (window->ScrollbarY)
                Scrollbar(ImGuiLayoutType_Vertical);

            // Render resize grips (after their input handling so we don't have a frame of latency)
            if (!(flags & ImGuiWindowFlags_NoResize))
            {
                for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
                {
                    const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
                    const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPos);
                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, grip_draw_size) : ImVec2(grip_draw_size, window_border_size)));
                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(grip_draw_size, window_border_size) : ImVec2(window_border_size, grip_draw_size)));
                    window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
                    window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
                }
            }

            // Borders
            if (window_border_size > 0.0f && !(flags & ImGuiWindowFlags_NoBackground))
                window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), window_rounding, ImDrawCornerFlags_All, window_border_size);
            if (border_held != -1)
            {
                ImRect border = GetResizeBorderRect(window, border_held, grip_draw_size, 0.0f);
                window->DrawList->AddLine(border.Min, border.Max, GetColorU32(ImGuiCol_SeparatorActive), ImMax(1.0f, window_border_size));
            }
            if (style.FrameBorderSize > 0 && !(flags & ImGuiWindowFlags_NoTitleBar))
                window->DrawList->AddLine(title_bar_rect.GetBL() + ImVec2(style.WindowBorderSize, -1), title_bar_rect.GetBR() + ImVec2(-style.WindowBorderSize, -1), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
        }

        // Draw navigation selection/windowing rectangle border
        if (g.NavWindowingTargetAnim == window)
        {
            float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
            ImRect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
            {
                bb.Expand(-g.FontSize - 1.0f);
                rounding = window->WindowRounding;
            }
            window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
        }

        // Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
        window->SizeFullAtLastBegin = window->SizeFull;

        // Update various regions. Variables they depends on are set above in this function.
        // FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
        window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
        window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
        window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
        window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

        // Setup drawing context
        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
        window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
        window->DC.GroupOffset.x = 0.0f;
        window->DC.ColumnsOffset.x = 0.0f;
        window->DC.CursorLoopCallbackPos = window->Pos + ImVec2(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
        window->DC.CursorPos = window->DC.CursorLoopCallbackPos;
        window->DC.CursorPosPrevLine = window->DC.CursorPos;
        window->DC.CursorMaxPos = window->DC.CursorLoopCallbackPos;
        window->DC.CurrentLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
        window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
        window->DC.NavHideHighlightOneFrame = false;
        window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
        window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
        window->DC.NavLayerActiveMaskNext = 0x00;
        window->DC.MenuBarAppending = false;
        window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;
        window->DC.ChildWindows.resize(0);
        window->DC.LayoutType = ImGuiLayoutType_Vertical;
        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
        window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : ImGuiItemFlags_Default_;
        window->DC.ItemWidth = window->ItemWidthDefault;
        window->DC.TextWrapPos = -1.0f; // disabled
        window->DC.ItemFlagsStack.resize(0);
        window->DC.ItemWidthStack.resize(0);
        window->DC.TextWrapPosStack.resize(0);
        window->DC.ColumnsSet = NULL;
        window->DC.TreeDepth = 0;
        window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
        window->DC.StateStorage = &window->StateStorage;
        window->DC.GroupStack.resize(0);
        window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

        if ((flags & ImGuiWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
        {
            window->DC.ItemFlags = parent_window->DC.ItemFlags;
            window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
        }

        if (window->AutoFitFramesX > 0)
            window->AutoFitFramesX--;
        if (window->AutoFitFramesY > 0)
            window->AutoFitFramesY--;

        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorLoopCallbackPos so our initial navigation reference rectangle can start around there)
        if (want_focus)
        {
            FocusWindow(window);
            NavInitWindow(window, false);
        }

        // Title bar
        if (!(flags & ImGuiWindowFlags_NoTitleBar))
        {
            // Close & collapse button are on layer 1 (same as menus) and don't default focus
            const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
            window->DC.ItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
            window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
            window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);

            // Collapse button
            if (!(flags & ImGuiWindowFlags_NoCollapse))
                if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
                    window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

            // Close button
            if (p_open != NULL)
            {
                const float pad = style.FramePadding.y;
                const float rad = g.FontSize * 0.5f;
                if (CloseButton(window->GetID("#CLOSE"), window->Rect().GetTR() + ImVec2(-pad - rad, pad + rad), rad + 1))
                    *p_open = false;
            }

            window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
            window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);
            window->DC.ItemFlags = item_flags_backup;

            // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
            // FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
            const char* UNSAVED_DOCUMENT_MARKER = "*";
            float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
            ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);
            ImRect text_r = title_bar_rect;
            float pad_left = (flags & ImGuiWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
            float pad_right = (p_open == NULL)                     ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
            if (style.WindowTitleAlign.x > 0.0f)
                pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
            text_r.Min.x += pad_left;
            text_r.Max.x -= pad_right;
            ImRect clip_rect = text_r;
            clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
            RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
            if (flags & ImGuiWindowFlags_UnsavedDocument)
            {
                ImVec2 marker_pos = ImVec2(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + ImVec2(2 - marker_size_x, 0.0f);
                ImVec2 off = ImVec2(0.0f, (float)(int)(-g.FontSize * 0.25f));
                RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, ImVec2(0, style.WindowTitleAlign.y), &clip_rect);
            }
        }

        // Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
        window->OuterRectClipped = window->Rect();
        window->OuterRectClipped.ClipWith(window->ClipRect);

        // Pressing CTRL+C while holding on a window copy its content to the clipboard
        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
        // Maybe we can support CTRL+C on every element?
        /*
        if (g.ActiveId == move_id)
            if (g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_C))
                LogToClipboard();
        */

        // Inner rectangle
        // We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
        window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
        window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
        window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
        window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
        //window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

        // Inner clipping rectangle
        // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x*0.5f - window->WindowBorderSize)));
        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x*0.5f - window->WindowBorderSize)));
        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

        // After Begin() we fill the last item / hovered data based on title bar data. It is a standard behavior (to allow creation of context menus on title bar only, etc.).
        window->DC.LastItemId = window->MoveId;
        window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0;
        window->DC.LastItemRect = title_bar_rect;
    }

    PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
    if (first_begin_of_the_frame)
        window->WriteAccessed = false;

    window->BeginCount++;
    g.NextWindowData.Clear();

    if (flags & ImGuiWindowFlags_ChildWindow)
    {
        // Child window can be out of sight and have "negative" clip windows.
        // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
        IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);

        if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
            if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
                window->HiddenFramesRegular = 1;

        // Completely hide along with parent or if parent is collapsed
        if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
            window->HiddenFramesRegular = 1;
    }

    // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
    if (style.Alpha <= 0.0f)
        window->HiddenFramesRegular = 1;

    // Update the Hidden flag
    window->Hidden = (window->HiddenFramesRegular > 0) || (window->HiddenFramesForResize > 0);

    // Return false if we don't intend to display anything to allow user to perform an early out optimization
    window->SkipItems = (window->Collapsed || !window->Active || window->Hidden) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesForResize <= 0;

    return !window->SkipItems;
}

// Old Begin() API with 5 parameters, avoid calling this version directly! Use SetNextWindowSize()/SetNextWindowBgAlpha() + Begin() instead.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
bool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_first_use, float bg_alpha_override, ImGuiWindowFlags flags)
{
    // Old API feature: we could pass the initial window size as a parameter. This was misleading because it only had an effect if the window didn't have data in the .ini file.
    if (size_first_use.x != 0.0f || size_first_use.y != 0.0f)
        SetNextWindowSize(size_first_use, ImGuiCond_FirstUseEver);

    // Old API feature: override the window background alpha with a parameter.
    if (bg_alpha_override >= 0.0f)
        SetNextWindowBgAlpha(bg_alpha_override);

    return Begin(name, p_open, flags);
}
#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

void ImGui::End()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (window->DC.ColumnsSet != NULL)
        EndColumns();
    PopClipRect();   // Inner window clip rectangle

    // Stop logging
    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
        LogFinish();

    // Pop from window stack
    g.CurrentWindowStack.pop_back();
    if (window->Flags & ImGuiWindowFlags_Popup)
        g.BeginPopupStack.pop_back();
    CheckStacksSize(window, false);
    SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());
}

void ImGui::BringWindowToFocusFront(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.WindowsFocusOrder.back() == window)
        return;
    for (int i = g.WindowsFocusOrder.Size - 2; i >= 0; i--) // We can ignore the front most window
        if (g.WindowsFocusOrder[i] == window)
        {
            memmove(&g.WindowsFocusOrder[i], &g.WindowsFocusOrder[i + 1], (size_t)(g.WindowsFocusOrder.Size - i - 1) * sizeof(ImGuiWindow*));
            g.WindowsFocusOrder[g.WindowsFocusOrder.Size - 1] = window;
            break;
        }
}

void ImGui::BringWindowToDisplayFront(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* current_front_window = g.Windows.back();
    if (current_front_window == window || current_front_window->RootWindow == window)
        return;
    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the front most window
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
            g.Windows[g.Windows.Size - 1] = window;
            break;
        }
}

void ImGui::BringWindowToDisplayBack(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.Windows[0] == window)
        return;
    for (int i = 0; i < g.Windows.Size; i++)
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));
            g.Windows[0] = window;
            break;
        }
}

// Moving window to front of display and set focus (which happens to be back of our sorted list)
void ImGui::FocusWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    if (g.NavWindow != window)
    {
        g.NavWindow = window;
        if (window && g.NavDisableMouseHover)
            g.NavMousePosDirty = true;
        g.NavInitRequest = false;
        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
        g.NavIdIsAlive = false;
        g.NavLayer = ImGuiNavLayer_Main;
        //printf("[%05d] FocusWindow(\"%s\")\n", g.FrameCount, window ? window->Name : NULL);
    }

    // Passing NULL allow to disable keyboard focus
    if (!window)
        return;

    // Move the root window to the top of the pile
    if (window->RootWindow)
        window = window->RootWindow;

    // Steal focus on active widgets
    if (window->Flags & ImGuiWindowFlags_Popup) // FIXME: This statement should be unnecessary. Need further testing before removing it..
        if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != window)
            ClearActiveID();

    // Bring to front
    BringWindowToFocusFront(window);
    if (!(window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus))
        BringWindowToDisplayFront(window);
}

void ImGui::FocusPreviousWindowIgnoringOne(ImGuiWindow* ignore_window)
{
    ImGuiContext& g = *GImGui;
    for (int i = g.WindowsFocusOrder.Size - 1; i >= 0; i--)
    {
        // We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
        ImGuiWindow* window = g.WindowsFocusOrder[i];
        if (window != ignore_window && window->WasActive && !(window->Flags & ImGuiWindowFlags_ChildWindow))
            if ((window->Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs))
            {
                ImGuiWindow* focus_window = NavRestoreLastChildNavWindow(window);
                FocusWindow(focus_window);
                return;
            }
    }
}

void ImGui::PushItemWidth(float item_width)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);
    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);
}

void ImGui::PushMultiItemsWidths(int components, float w_full)
{
    ImGuiWindow* window = GetCurrentWindow();
    const ImGuiStyle& style = GImGui->Style;
    if (w_full <= 0.0f)
        w_full = CalcItemWidth();
    const float w_item_one  = ImMax(1.0f, (float)(int)((w_full - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));
    const float w_item_last = ImMax(1.0f, (float)(int)(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));
    window->DC.ItemWidthStack.push_back(w_item_last);
    for (int i = 0; i < components-1; i++)
        window->DC.ItemWidthStack.push_back(w_item_one);
    window->DC.ItemWidth = window->DC.ItemWidthStack.back();
}

void ImGui::PopItemWidth()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemWidthStack.pop_back();
    window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();
}

float ImGui::CalcItemWidth()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    float w = window->DC.ItemWidth;
    if (w < 0.0f)
    {
        // Align to a right-side limit. We include 1 frame padding in the calculation because this is how the width is always used (we add 2 frame padding to it), but we could move that responsibility to the widget as well.
        float width_to_right_edge = GetContentRegionAvail().x;
        w = ImMax(1.0f, width_to_right_edge + w);
    }
    w = (float)(int)w;
    return w;
}

void ImGui::SetCurrentFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
    IM_ASSERT(font->Scale > 0.0f);
    g.Font = font;
    g.FontBaseSize = g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale;
    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

    ImFontAtlas* atlas = g.Font->ContainerAtlas;
    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
    g.DrawListSharedData.Font = g.Font;
    g.DrawListSharedData.FontSize = g.FontSize;
}

void ImGui::PushFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    if (!font)
        font = GetDefaultFont();
    SetCurrentFont(font);
    g.FontStack.push_back(font);
    g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);
}

void  ImGui::PopFont()
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow->DrawList->PopTextureID();
    g.FontStack.pop_back();
    SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());
}

void ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (enabled)
        window->DC.ItemFlags |= option;
    else
        window->DC.ItemFlags &= ~option;
    window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
}

void ImGui::PopItemFlag()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemFlagsStack.pop_back();
    window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();
}

// FIXME: Look into renaming this once we have settled the new Focus/Activation/TabStop system.
void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)
{
    PushItemFlag(ImGuiItemFlags_NoTabStop, !allow_keyboard_focus);
}

void ImGui::PopAllowKeyboardFocus()
{
    PopItemFlag();
}

void ImGui::PushButtonRepeat(bool repeat)
{
    PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);
}

void ImGui::PopButtonRepeat()
{
    PopItemFlag();
}

void ImGui::PushTextWrapPos(float wrap_pos_x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPos = wrap_pos_x;
    window->DC.TextWrapPosStack.push_back(wrap_pos_x);
}

void ImGui::PopTextWrapPos()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPosStack.pop_back();
    window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();
}

// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
void ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorModifiers.push_back(backup);
    g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
}

void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorModifiers.push_back(backup);
    g.Style.Colors[idx] = col;
}

void ImGui::PopStyleColor(int count)
{
    ImGuiContext& g = *GImGui;
    while (count > 0)
    {
        ImGuiColorMod& backup = g.ColorModifiers.back();
        g.Style.Colors[backup.Col] = backup.BackupValue;
        g.ColorModifiers.pop_back();
        count--;
    }
}

struct ImGuiStyleVarInfo
{
    ImGuiDataType   Type;
    ImU32           Count;
    ImU32           Offset;
    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }
};

static const ImGuiStyleVarInfo GStyleVarInfo[] =
{
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, Alpha) },              // ImGuiStyleVar_Alpha
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowPadding) },      // ImGuiStyleVar_WindowPadding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowRounding) },     // ImGuiStyleVar_WindowRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowBorderSize) },   // ImGuiStyleVar_WindowBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowMinSize) },      // ImGuiStyleVar_WindowMinSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowTitleAlign) },   // ImGuiStyleVar_WindowTitleAlign
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildRounding) },      // ImGuiStyleVar_ChildRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildBorderSize) },    // ImGuiStyleVar_ChildBorderSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupRounding) },      // ImGuiStyleVar_PopupRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupBorderSize) },    // ImGuiStyleVar_PopupBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, FramePadding) },       // ImGuiStyleVar_FramePadding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameRounding) },      // ImGuiStyleVar_FrameRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameBorderSize) },    // ImGuiStyleVar_FrameBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemSpacing) },        // ImGuiStyleVar_ItemSpacing
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemInnerSpacing) },   // ImGuiStyleVar_ItemInnerSpacing
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, IndentSpacing) },      // ImGuiStyleVar_IndentSpacing
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarSize) },      // ImGuiStyleVar_ScrollbarSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarRounding) },  // ImGuiStyleVar_ScrollbarRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabMinSize) },        // ImGuiStyleVar_GrabMinSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabRounding) },       // ImGuiStyleVar_GrabRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, TabRounding) },        // ImGuiStyleVar_TabRounding
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ButtonTextAlign) },    // ImGuiStyleVar_ButtonTextAlign
};

static const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)
{
    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
    return &GStyleVarInfo[idx];
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)
    {
        ImGuiContext& g = *GImGui;
        float* pvar = (float*)var_info->GetVarPtr(&g.Style);
        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0); // Called function with wrong-type? Variable is not a float.
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
    {
        ImGuiContext& g = *GImGui;
        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0); // Called function with wrong-type? Variable is not a ImVec2.
}

void ImGui::PopStyleVar(int count)
{
    ImGuiContext& g = *GImGui;
    while (count > 0)
    {
        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
        ImGuiStyleMod& backup = g.StyleModifiers.back();
        const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);
        void* data = info->GetVarPtr(&g.Style);
        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
        g.StyleModifiers.pop_back();
        count--;
    }
}

const char* ImGui::GetStyleColorName(ImGuiCol idx)
{
    // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
    switch (idx)
    {
    case ImGuiCol_Text: return "Text";
    case ImGuiCol_TextDisabled: return "TextDisabled";
    case ImGuiCol_WindowBg: return "WindowBg";
    case ImGuiCol_ChildBg: return "ChildBg";
    case ImGuiCol_PopupBg: return "PopupBg";
    case ImGuiCol_Border: return "Border";
    case ImGuiCol_BorderShadow: return "BorderShadow";
    case ImGuiCol_FrameBg: return "FrameBg";
    case ImGuiCol_FrameBgHovered: return "FrameBgHovered";
    case ImGuiCol_FrameBgActive: return "FrameBgActive";
    case ImGuiCol_TitleBg: return "TitleBg";
    case ImGuiCol_TitleBgActive: return "TitleBgActive";
    case ImGuiCol_TitleBgCollapsed: return "TitleBgCollapsed";
    case ImGuiCol_MenuBarBg: return "MenuBarBg";
    case ImGuiCol_ScrollbarBg: return "ScrollbarBg";
    case ImGuiCol_ScrollbarGrab: return "ScrollbarGrab";
    case ImGuiCol_ScrollbarGrabHovered: return "ScrollbarGrabHovered";
    case ImGuiCol_ScrollbarGrabActive: return "ScrollbarGrabActive";
    case ImGuiCol_CheckMark: return "CheckMark";
    case ImGuiCol_SliderGrab: return "SliderGrab";
    case ImGuiCol_SliderGrabActive: return "SliderGrabActive";
    case ImGuiCol_Button: return "Button";
    case ImGuiCol_ButtonHovered: return "ButtonHovered";
    case ImGuiCol_ButtonActive: return "ButtonActive";
    case ImGuiCol_Header: return "Header";
    case ImGuiCol_HeaderHovered: return "HeaderHovered";
    case ImGuiCol_HeaderActive: return "HeaderActive";
    case ImGuiCol_Separator: return "Separator";
    case ImGuiCol_SeparatorHovered: return "SeparatorHovered";
    case ImGuiCol_SeparatorActive: return "SeparatorActive";
    case ImGuiCol_ResizeGrip: return "ResizeGrip";
    case ImGuiCol_ResizeGripHovered: return "ResizeGripHovered";
    case ImGuiCol_ResizeGripActive: return "ResizeGripActive";
    case ImGuiCol_Tab: return "Tab";
    case ImGuiCol_TabHovered: return "TabHovered";
    case ImGuiCol_TabActive: return "TabActive";
    case ImGuiCol_TabUnfocused: return "TabUnfocused";
    case ImGuiCol_TabUnfocusedActive: return "TabUnfocusedActive";
    case ImGuiCol_PlotLines: return "PlotLines";
    case ImGuiCol_PlotLinesHovered: return "PlotLinesHovered";
    case ImGuiCol_PlotHistogram: return "PlotHistogram";
    case ImGuiCol_PlotHistogramHovered: return "PlotHistogramHovered";
    case ImGuiCol_TextSelectedBg: return "TextSelectedBg";
    case ImGuiCol_DragDropTarget: return "DragDropTarget";
    case ImGuiCol_NavHighlight: return "NavHighlight";
    case ImGuiCol_NavWindowingHighlight: return "NavWindowingHighlight";
    case ImGuiCol_NavWindowingDimBg: return "NavWindowingDimBg";
    case ImGuiCol_ModalWindowDimBg: return "ModalWindowDimBg";
    }
    IM_ASSERT(0);
    return "Unknown";
}

bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent)
{
    if (window->RootWindow == potential_parent)
        return true;
    while (window != NULL)
    {
        if (window == potential_parent)
            return true;
        window = window->ParentWindow;
    }
    return false;
}

bool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)
{
    IM_ASSERT((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0);   // Flags not supported by this function
    ImGuiContext& g = *GImGui;

    if (flags & ImGuiHoveredFlags_AnyWindow)
    {
        if (g.HoveredWindow == NULL)
            return false;
    }
    else
    {
        switch (flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows))
        {
        case ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows:
            if (g.HoveredRootWindow != g.CurrentWindow->RootWindow)
                return false;
            break;
        case ImGuiHoveredFlags_RootWindow:
            if (g.HoveredWindow != g.CurrentWindow->RootWindow)
                return false;
            break;
        case ImGuiHoveredFlags_ChildWindows:
            if (g.HoveredWindow == NULL || !IsWindowChildOf(g.HoveredWindow, g.CurrentWindow))
                return false;
            break;
        default:
            if (g.HoveredWindow != g.CurrentWindow)
                return false;
            break;
        }
    }

    if (!IsWindowContentHoverable(g.HoveredRootWindow, flags))
        return false;
    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId)
            return false;
    return true;
}

bool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)
{
    ImGuiContext& g = *GImGui;

    if (flags & ImGuiFocusedFlags_AnyWindow)
        return g.NavWindow != NULL;

    IM_ASSERT(g.CurrentWindow);     // Not inside a Begin()/End()
    switch (flags & (ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows))
    {
    case ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows:
        return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_RootWindow:
        return g.NavWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_ChildWindows:
        return g.NavWindow && IsWindowChildOf(g.NavWindow, g.CurrentWindow);
    default:
        return g.NavWindow == g.CurrentWindow;
    }
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmaticaly.
// If you want a window to never be focused, you may use the e.g. NoInputs flag.
bool ImGui::IsWindowNavFocusable(ImGuiWindow* window)
{
    return window->Active && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);
}

float ImGui::GetWindowWidth()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.x;
}

float ImGui::GetWindowHeight()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.y;
}

ImVec2 ImGui::GetWindowPos()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    return window->Pos;
}

void ImGui::SetWindowScrollX(ImGuiWindow* window, float new_scroll_x)
{
    window->DC.CursorMaxPos.x += window->Scroll.x; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
    window->Scroll.x = new_scroll_x;
    window->DC.CursorMaxPos.x -= window->Scroll.x;
}

void ImGui::SetWindowScrollY(ImGuiWindow* window, float new_scroll_y)
{
    window->DC.CursorMaxPos.y += window->Scroll.y; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
    window->Scroll.y = new_scroll_y;
    window->DC.CursorMaxPos.y -= window->Scroll.y;
}

static void SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);

    // Set
    const ImVec2 old_pos = window->Pos;
    window->Pos = ImFloor(pos);
    window->DC.CursorPos += (window->Pos - old_pos);    // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
    window->DC.CursorMaxPos += (window->Pos - old_pos); // And more importantly we need to adjust this so size calculation doesn't get affected.
}

void ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    SetWindowPos(window, pos, cond);
}

void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowPos(window, pos, cond);
}

ImVec2 ImGui::GetWindowSize()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Size;
}

static void SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Set
    if (size.x > 0.0f)
    {
        window->AutoFitFramesX = 0;
        window->SizeFull.x = ImFloor(size.x);
    }
    else
    {
        window->AutoFitFramesX = 2;
        window->AutoFitOnlyGrows = false;
    }
    if (size.y > 0.0f)
    {
        window->AutoFitFramesY = 0;
        window->SizeFull.y = ImFloor(size.y);
    }
    else
    {
        window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
}

void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)
{
    SetWindowSize(GImGui->CurrentWindow, size, cond);
}

void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowSize(window, size, cond);
}

static void SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)
        return;
    window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Set
    window->Collapsed = collapsed;
}

void ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);
}

bool ImGui::IsWindowCollapsed()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Collapsed;
}

bool ImGui::IsWindowAppearing()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Appearing;
}

void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowCollapsed(window, collapsed, cond);
}

void ImGui::SetWindowFocus()
{
    FocusWindow(GImGui->CurrentWindow);
}

void ImGui::SetWindowFocus(const char* name)
{
    if (name)
    {
        if (ImGuiWindow* window = FindWindowByName(name))
            FocusWindow(window);
    }
    else
    {
        FocusWindow(NULL);
    }
}

void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.PosVal = pos;
    g.NextWindowData.PosPivotVal = pivot;
    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.SizeVal = size;
    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.SizeConstraintCond = ImGuiCond_Always;
    g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);
    g.NextWindowData.SizeCallback = custom_callback;
    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}

void ImGui::SetNextWindowContentSize(const ImVec2& size)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.ContentSizeVal = size;  // In Begin() we will add the size of window decorations (title bar, menu etc.) to that to form a SizeContents value.
    g.NextWindowData.ContentSizeCond = ImGuiCond_Always;
}

void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.CollapsedVal = collapsed;
    g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowFocus()
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.FocusCond = ImGuiCond_Always;   // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

void ImGui::SetNextWindowBgAlpha(float alpha)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.BgAlphaVal = alpha;
    g.NextWindowData.BgAlphaCond = ImGuiCond_Always; // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

// In window space (not screen space!)
ImVec2 ImGui::GetContentRegionMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImVec2 mx = window->ContentsRegionRect.Max - window->Pos;
    if (window->DC.ColumnsSet)
        mx.x = GetColumnOffset(window->DC.ColumnsSet->Current + 1) - window->WindowPadding.x;
    return mx;
}

ImVec2 ImGui::GetContentRegionAvail()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return GetContentRegionMax() - (window->DC.CursorPos - window->Pos);
}

float ImGui::GetContentRegionAvailWidth()
{
    return GetContentRegionAvail().x;
}

// In window space (not screen space!)
ImVec2 ImGui::GetWindowContentRegionMin()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.Min - window->Pos;
}

ImVec2 ImGui::GetWindowContentRegionMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.Max - window->Pos;
}

float ImGui::GetWindowContentRegionWidth()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.GetWidth();
}

float ImGui::GetTextLineHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize;
}

float ImGui::GetTextLineHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.ItemSpacing.y;
}

float ImGui::GetFrameHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f;
}

float ImGui::GetFrameHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
}

ImDrawList* ImGui::GetWindowDrawList()
{
    ImGuiWindow* window = GetCurrentWindow();
    return window->DrawList;
}

ImFont* ImGui::GetFont()
{
    return GImGui->Font;
}

float ImGui::GetFontSize()
{
    return GImGui->FontSize;
}

ImVec2 ImGui::GetFontTexUvWhitePixel()
{
    return GImGui->DrawListSharedData.TexUvWhitePixel;
}

void ImGui::SetWindowFontScale(float scale)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->FontWindowScale = scale;
    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
ImVec2 ImGui::GetCursorPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos - window->Pos + window->Scroll;
}

float ImGui::GetCursorPosX()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
}

float ImGui::GetCursorPosY()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
}

void ImGui::SetCursorPos(const ImVec2& local_pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = window->Pos - window->Scroll + local_pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

void ImGui::SetCursorPosX(float x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
}

void ImGui::SetCursorPosY(float y)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
}

ImVec2 ImGui::GetCursorLoopCallbackPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorLoopCallbackPos - window->Pos;
}

ImVec2 ImGui::GetCursorScreenPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos;
}

void ImGui::SetCursorScreenPos(const ImVec2& screen_pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = screen_pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

float ImGui::GetScrollX()
{
    return GImGui->CurrentWindow->Scroll.x;
}

float ImGui::GetScrollY()
{
    return GImGui->CurrentWindow->Scroll.y;
}

float ImGui::GetScrollMaxX()
{
    return GetWindowScrollMaxX(GImGui->CurrentWindow);
}

float ImGui::GetScrollMaxY()
{
    return GetWindowScrollMaxY(GImGui->CurrentWindow);
}

void ImGui::SetScrollX(float scroll_x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->ScrollTarget.x = scroll_x;
    window->ScrollTargetCenterRatio.x = 0.0f;
}

void ImGui::SetScrollY(float scroll_y)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->ScrollTarget.y = scroll_y + window->TitleBarHeight() + window->MenuBarHeight(); // title bar height canceled out when using ScrollTargetRelY
    window->ScrollTargetCenterRatio.y = 0.0f;
}

void ImGui::SetScrollFromPosY(float pos_y, float center_y_ratio)
{
    // We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
    window->ScrollTarget.y = (float)(int)(pos_y + window->Scroll.y);
    window->ScrollTargetCenterRatio.y = center_y_ratio;
}

// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
void ImGui::SetScrollHereY(float center_y_ratio)
{
    ImGuiWindow* window = GetCurrentWindow();
    float target_y = window->DC.CursorPosPrevLine.y - window->Pos.y; // Top of last item, in window space
    target_y += (window->DC.PrevLineSize.y * center_y_ratio) + (GImGui->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.
    SetScrollFromPosY(target_y, center_y_ratio);
}

void ImGui::ActivateItem(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.NavNextActivateId = id;
}

void ImGui::SetKeyboardFocusHere(int offset)
{
    IM_ASSERT(offset >= -1);    // -1 is allowed but not below
    ImGuiWindow* window = GetCurrentWindow();
    window->FocusIdxAllRequestNext = window->FocusIdxAllCounter + 1 + offset;
    window->FocusIdxTabRequestNext = INT_MAX;
}

void ImGui::SetItemDefaultFocus()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!window->Appearing)
        return;
    if (g.NavWindow == window->RootWindowForNav && (g.NavInitRequest || g.NavInitResultId != 0) && g.NavLayer == g.NavWindow->DC.NavLayerCurrent)
    {
        g.NavInitRequest = false;
        g.NavInitResultId = g.NavWindow->DC.LastItemId;
        g.NavInitResultRectRel = ImRect(g.NavWindow->DC.LastItemRect.Min - g.NavWindow->Pos, g.NavWindow->DC.LastItemRect.Max - g.NavWindow->Pos);
        NavUpdateAnyRequestFlag();
        if (!IsItemVisible())
            SetScrollHereY();
    }
}

void ImGui::SetStateStorage(ImGuiStorage* tree)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.StateStorage = tree ? tree : &window->StateStorage;
}

ImGuiStorage* ImGui::GetStateStorage()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.StateStorage;
}

void ImGui::PushID(const char* str_id)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id));
}

void ImGui::PushID(const char* str_id_begin, const char* str_id_end)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id_begin, str_id_end));
}

void ImGui::PushID(const void* ptr_id)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));
}

void ImGui::PushID(int int_id)
{
    const void* ptr_id = (void*)(intptr_t)int_id;
    ImGuiWindow* window = GetCurrentWindowRead();
    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));
}

void ImGui::PopID()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    window->IDStack.pop_back();
}

ImGuiID ImGui::GetID(const char* str_id)
{
    return GImGui->CurrentWindow->GetID(str_id);
}

ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)
{
    return GImGui->CurrentWindow->GetID(str_id_begin, str_id_end);
}

ImGuiID ImGui::GetID(const void* ptr_id)
{
    return GImGui->CurrentWindow->GetID(ptr_id);
}

bool ImGui::IsRectVisible(const ImVec2& size)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));
}

bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));
}

// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
void ImGui::BeginGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    window->DC.GroupStack.resize(window->DC.GroupStack.Size + 1);
    ImGuiGroupData& group_data = window->DC.GroupStack.back();
    group_data.BackupCursorPos = window->DC.CursorPos;
    group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
    group_data.BackupIndent = window->DC.Indent;
    group_data.BackupGroupOffset = window->DC.GroupOffset;
    group_data.BackupCurrentLineSize = window->DC.CurrentLineSize;
    group_data.BackupCurrentLineTextBaseOffset = window->DC.CurrentLineTextBaseOffset;
    group_data.BackupLogLinePosY = window->DC.LogLinePosY;
    group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
    group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
    group_data.AdvanceCursor = true;

    window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
    window->DC.Indent = window->DC.GroupOffset;
    window->DC.CursorMaxPos = window->DC.CursorPos;
    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);
    window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f; // To enforce Log carriage return
}

void ImGui::EndGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(!window->DC.GroupStack.empty());    // Mismatched BeginGroup()/EndGroup() calls

    ImGuiGroupData& group_data = window->DC.GroupStack.back();

    ImRect group_bb(group_data.BackupCursorPos, window->DC.CursorMaxPos);
    group_bb.Max = ImMax(group_bb.Min, group_bb.Max);

    window->DC.CursorPos = group_data.BackupCursorPos;
    window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);
    window->DC.Indent = group_data.BackupIndent;
    window->DC.GroupOffset = group_data.BackupGroupOffset;
    window->DC.CurrentLineSize = group_data.BackupCurrentLineSize;
    window->DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;
    window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f; // To enforce Log carriage return

    if (group_data.AdvanceCursor)
    {
        window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrentLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
        ItemSize(group_bb.GetSize(), group_data.BackupCurrentLineTextBaseOffset);
        ItemAdd(group_bb, 0);
    }

    // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
    // It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
    // (and if you grep for LastItemId you'll notice it is only used in that context.
    if ((group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId) // && g.ActiveIdWindow->RootWindow == window->RootWindow)
        window->DC.LastItemId = g.ActiveId;
    else if (!group_data.BackupActiveIdPreviousFrameIsAlive && g.ActiveIdPreviousFrameIsAlive) // && g.ActiveIdPreviousFrameWindow->RootWindow == window->RootWindow)
        window->DC.LastItemId = g.ActiveIdPreviousFrame;
    window->DC.LastItemRect = group_bb;

    window->DC.GroupStack.pop_back();

    //window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
}

// Gets back to previous line and continue with horizontal layout
//      pos_x == 0      : follow right after previous item
//      pos_x != 0      : align to specified x position (relative to window/group left)
//      spacing_w < 0   : use default spacing if pos_x == 0, no spacing if pos_x != 0
//      spacing_w >= 0  : enforce spacing amount
void ImGui::SameLine(float pos_x, float spacing_w)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    if (pos_x != 0.0f)
    {
        if (spacing_w < 0.0f) spacing_w = 0.0f;
        window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + pos_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    else
    {
        if (spacing_w < 0.0f) spacing_w = g.Style.ItemSpacing.x;
        window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    window->DC.CurrentLineSize = window->DC.PrevLineSize;
    window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
}

void ImGui::Indent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

void ImGui::Unindent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

//-----------------------------------------------------------------------------
// [SECTION] TOOLTIPS
//-----------------------------------------------------------------------------

void ImGui::BeginTooltip()
{
    ImGuiContext& g = *GImGui;
    if (g.DragDropWithinSourceOrTarget)
    {
        // The default tooltip position is a little offset to give space to see the context menu (it's also clamped within the current viewport/monitor)
        // In the context of a dragging tooltip we try to reduce that offset and we enforce following the cursor.
        // Whatever we do we want to call SetNextWindowPos() to enforce a tooltip position and disable clipping the tooltip without our display area, like regular tooltip do.
        //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
        ImVec2 tooltip_pos = g.IO.MousePos + ImVec2(16 * g.Style.MouseCursorScale, 8 * g.Style.MouseCursorScale);
        SetNextWindowPos(tooltip_pos);
        SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);
        //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
        BeginTooltipEx(0, true);
    }
    else
    {
        BeginTooltipEx(0, false);
    }
}

// Not exposed publicly as BeginTooltip() because bool parameters are evil. Let's see if other needs arise first.
void ImGui::BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip)
{
    ImGuiContext& g = *GImGui;
    char window_name[16];
    ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", g.TooltipOverrideCount);
    if (override_previous_tooltip)
        if (ImGuiWindow* window = FindWindowByName(window_name))
            if (window->Active)
            {
                // Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
                window->Hidden = true;
                window->HiddenFramesRegular = 1;
                ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", ++g.TooltipOverrideCount);
            }
    ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip|ImGuiWindowFlags_NoInputs|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_AlwaysAutoResize;
    Begin(window_name, NULL, flags | extra_flags);
}

void ImGui::EndTooltip()
{
    IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
    End();
}

void ImGui::SetTooltipV(const char* fmt, va_list args)
{
    ImGuiContext& g = *GImGui;
    if (g.DragDropWithinSourceOrTarget)
        BeginTooltip();
    else
        BeginTooltipEx(0, true);
    TextV(fmt, args);
    EndTooltip();
}

void ImGui::SetTooltip(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    SetTooltipV(fmt, args);
    va_end(args);
}

//-----------------------------------------------------------------------------
// [SECTION] POPUPS
//-----------------------------------------------------------------------------

bool ImGui::IsPopupOpen(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
}

bool ImGui::IsPopupOpen(const char* str_id)
{
    ImGuiContext& g = *GImGui;
    return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == g.CurrentWindow->GetID(str_id);
}

ImGuiWindow* ImGui::GetFrontMostPopupModal()
{
    ImGuiContext& g = *GImGui;
    for (int n = g.OpenPopupStack.Size-1; n >= 0; n--)
        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
            if (popup->Flags & ImGuiWindowFlags_Modal)
                return popup;
    return NULL;
}

void ImGui::OpenPopup(const char* str_id)
{
    ImGuiContext& g = *GImGui;
    OpenPopupEx(g.CurrentWindow->GetID(str_id));
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
void ImGui::OpenPopupEx(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;
    int current_stack_size = g.BeginPopupStack.Size;
    ImGuiPopupRef popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
    popup_ref.PopupId = id;
    popup_ref.Window = NULL;
    popup_ref.ParentWindow = parent_window;
    popup_ref.OpenFrameCount = g.FrameCount;
    popup_ref.OpenParentId = parent_window->IDStack.back();
    popup_ref.OpenPopupPos = NavCalcPreferredRefPos();
    popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;

    //printf("[%05d] OpenPopupEx(0x%08X)\n", g.FrameCount, id);
    if (g.OpenPopupStack.Size < current_stack_size + 1)
    {
        g.OpenPopupStack.push_back(popup_ref);
    }
    else
    {
        // Gently handle the user mistakenly calling OpenPopup() every frame. It is a programming mistake! However, if we were to run the regular code path, the ui
        // would become completely unusable because the popup will always be in hidden-while-calculating-size state _while_ claiming focus. Which would be a very confusing
        // situation for the programmer. Instead, we silently allow the popup to proceed, it will keep reappearing and the programming error will be more obvious to understand.
        if (g.OpenPopupStack[current_stack_size].PopupId == id && g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)
        {
            g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
        }
        else
        {
            // Close child popups if any, then flag popup for open/reopen
            g.OpenPopupStack.resize(current_stack_size + 1);
            g.OpenPopupStack[current_stack_size] = popup_ref;
        }

        // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
        // This is equivalent to what ClosePopupToLevel() does.
        //if (g.OpenPopupStack[current_stack_size].PopupId == id)
        //    FocusWindow(parent_window);
    }
}

bool ImGui::OpenPopupOnItemClick(const char* str_id, int mouse_button)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
    {
        ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
        IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
        OpenPopupEx(id);
        return true;
    }
    return false;
}

void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.empty())
        return;

    // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
    // Don't close our own child popup windows.
    int popup_count_to_keep = 0;
    if (ref_window)
    {
        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
        {
            ImGuiPopupRef& popup = g.OpenPopupStack[popup_count_to_keep];
            if (!popup.Window)
                continue;
            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)
                continue;

            // Trim the stack if popups are not direct descendant of the reference window (which is often the NavWindow)
            bool popup_or_descendent_has_focus = false;
            for (int m = popup_count_to_keep; m < g.OpenPopupStack.Size && !popup_or_descendent_has_focus; m++)
                if (g.OpenPopupStack[m].Window && g.OpenPopupStack[m].Window->RootWindow == ref_window->RootWindow)
                    popup_or_descendent_has_focus = true;
            if (!popup_or_descendent_has_focus)
                break;
        }
    }
    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
    {
        //IMGUI_DEBUG_LOG("ClosePopupsOverWindow(%s) -> ClosePopupToLevel(%d)\n", ref_window->Name, popup_count_to_keep);
        ClosePopupToLevel(popup_count_to_keep);
    }
}

void ImGui::ClosePopupToLevel(int remaining)
{
    IM_ASSERT(remaining >= 0);
    ImGuiContext& g = *GImGui;
    ImGuiWindow* focus_window = (remaining > 0) ? g.OpenPopupStack[remaining-1].Window : g.OpenPopupStack[0].ParentWindow;
    if (g.NavLayer == 0)
        focus_window = NavRestoreLastChildNavWindow(focus_window);
    FocusWindow(focus_window);
    focus_window->DC.NavHideHighlightOneFrame = true;
    g.OpenPopupStack.resize(remaining);
}

// Close the popup we have begin-ed into.
void ImGui::CloseCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    int popup_idx = g.BeginPopupStack.Size - 1;
    if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)
        return;
    while (popup_idx > 0 && g.OpenPopupStack[popup_idx].Window && (g.OpenPopupStack[popup_idx].Window->Flags & ImGuiWindowFlags_ChildMenu))
        popup_idx--;
    ClosePopupToLevel(popup_idx);
}

bool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags)
{
    ImGuiContext& g = *GImGui;
    if (!IsPopupOpen(id))
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }

    char name[20];
    if (extra_flags & ImGuiWindowFlags_ChildMenu)
        ImFormatString(name, IM_ARRAYSIZE(name), "##Menu_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth
    else
        ImFormatString(name, IM_ARRAYSIZE(name), "##Popup_%08x", id); // Not recycling, so we can close/open during the same frame

    bool is_open = Begin(name, NULL, extra_flags | ImGuiWindowFlags_Popup);
    if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)
        EndPopup();

    return is_open;
}

bool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }
    flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
    return BeginPopupEx(g.CurrentWindow->GetID(str_id), flags);
}

// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.
// Note that popup visibility status is owned by imgui (and manipulated with e.g. OpenPopup) so the actual value of *p_open is meaningless here.
bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const ImGuiID id = window->GetID(name);
    if (!IsPopupOpen(id))
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }

    // Center modal windows by default
    // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
    if (g.NextWindowData.PosCond == 0)
        SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

    flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings;
    const bool is_open = Begin(name, p_open, flags);
    if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    {
        EndPopup();
        if (is_open)
            ClosePopupToLevel(g.BeginPopupStack.Size);
        return false;
    }
    return is_open;
}

void ImGui::EndPopup()
{
    ImGuiContext& g = *GImGui; (void)g;
    IM_ASSERT(g.CurrentWindow->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls
    IM_ASSERT(g.BeginPopupStack.Size > 0);

    // Make all menus and popups wrap around for now, may need to expose that policy.
    NavMoveRequestTryWrapping(g.CurrentWindow, ImGuiNavMoveFlags_LoopY);

    End();
}

// This is a helper to handle the simplest case of associating one named popup to one given widget.
// You may want to handle this on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
// You can pass a NULL str_id to use the identifier of the last item.
bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
    IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextWindow(const char* str_id, int mouse_button, bool also_over_items)
{
    if (!str_id)
        str_id = "window_context";
    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);
    if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        if (also_over_items || !IsAnyItemHovered())
            OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)
{
    if (!str_id)
        str_id = "void_context";
    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);
    if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
        OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

ImRect ImGui::GetWindowAllowedExtentRect(ImGuiWindow*)
{
    ImVec2 padding = GImGui->Style.DisplaySafeAreaPadding;
    ImRect r_screen = GetViewportRect();
    r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));
    return r_screen;
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
ImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy)
{
    ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);
    //GImGui->OverlayDrawList.AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
    //GImGui->OverlayDrawList.AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

    // Combo Box policy (we want a connecting edge)
    if (policy == ImGuiPopupPositionPolicy_ComboBox)
    {
        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };
        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
        {
            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
            if (n != -1 && dir == *last_dir) // Already tried this direction?
                continue;
            ImVec2 pos;
            if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)
            if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right
            if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left
            if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left
            if (!r_outer.Contains(ImRect(pos, pos + size)))
                continue;
            *last_dir = dir;
            return pos;
        }
    }

    // Default popup policy
    const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };
    for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
    {
        const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
        if (n != -1 && dir == *last_dir) // Already tried this direction?
            continue;
        float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);
        float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);
        if (avail_w < size.x || avail_h < size.y)
            continue;
        ImVec2 pos;
        pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;
        pos.y = (dir == ImGuiDir_Up)   ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down)  ? r_avoid.Max.y : base_pos_clamped.y;
        *last_dir = dir;
        return pos;
    }

    // Fallback, try to keep within display
    *last_dir = ImGuiDir_None;
    ImVec2 pos = ref_pos;
    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
    return pos;
}

ImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    ImRect r_outer = GetWindowAllowedExtentRect(window);
    if (window->Flags & ImGuiWindowFlags_ChildMenu)
    {
        // Child menus typically request _any_ position within the parent menu item, and then our FindBestWindowPosForPopup() function will move the new menu outside the parent bounds.
        // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
        IM_ASSERT(g.CurrentWindow == window);
        ImGuiWindow* parent_window = g.CurrentWindowStack[g.CurrentWindowStack.Size - 2];
        float horizontal_overlap = g.Style.ItemSpacing.x;       // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
        ImRect r_avoid;
        if (parent_window->DC.MenuBarAppending)
            r_avoid = ImRect(-FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight(), FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight() + parent_window->MenuBarHeight());
        else
            r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
    }
    if (window->Flags & ImGuiWindowFlags_Popup)
    {
        ImRect r_avoid = ImRect(window->Pos.x - 1, window->Pos.y - 1, window->Pos.x + 1, window->Pos.y + 1);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
    }
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {
        // Position tooltip (always follows mouse)
        float sc = g.Style.MouseCursorScale;
        ImVec2 ref_pos = NavCalcPreferredRefPos();
        ImRect r_avoid;
        if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
        else
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
        ImVec2 pos = FindBestWindowPosForPopupEx(ref_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
        if (window->AutoPosLastDirection == ImGuiDir_None)
            pos = ref_pos + ImVec2(2, 2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
        return pos;
    }
    IM_ASSERT(0);
    return window->Pos;
}

//-----------------------------------------------------------------------------
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
//-----------------------------------------------------------------------------

// (this section is filled in the 'viewport' and 'docking' branches)

//-----------------------------------------------------------------------------
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
//-----------------------------------------------------------------------------

ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)
{
    if (ImFabs(dx) > ImFabs(dy))
        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;
    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;
}

static float inline NavScoreItemDistInterval(float a0, float a1, float b0, float b1)
{
    if (a1 < b0)
        return a1 - b0;
    if (b1 < a0)
        return a0 - b1;
    return 0.0f;
}

static void inline NavClampRectToVisibleAreaForMoveDir(ImGuiDir move_dir, ImRect& r, const ImRect& clip_rect)
{
    if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
    {
        r.Min.y = ImClamp(r.Min.y, clip_rect.Min.y, clip_rect.Max.y);
        r.Max.y = ImClamp(r.Max.y, clip_rect.Min.y, clip_rect.Max.y);
    }
    else
    {
        r.Min.x = ImClamp(r.Min.x, clip_rect.Min.x, clip_rect.Max.x);
        r.Max.x = ImClamp(r.Max.x, clip_rect.Min.x, clip_rect.Max.x);
    }
}

// Scoring function for directional navigation. Based on https://gist.github.com/rygorous/6981057
static bool NavScoreItem(ImGuiNavMoveResult* result, ImRect cand)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavLayer != window->DC.NavLayerCurrent)
        return false;

    const ImRect& curr = g.NavScoringRectScreen; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
    g.NavScoringCount++;

    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
    if (window->ParentWindow == g.NavWindow)
    {
        IM_ASSERT((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened);
        if (!window->ClipRect.Contains(cand))
            return false;
        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
    }

    // We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
    // For example, this ensure that items in one column are not reached when moving vertically from items in another column.
    NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);

    // Compute distance between boxes
    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
    if (dby != 0.0f && dbx != 0.0f)
       dbx = (dbx/1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
    float dist_box = ImFabs(dbx) + ImFabs(dby);

    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)

    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
    ImGuiDir quadrant;
    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
    if (dbx != 0.0f || dby != 0.0f)
    {
        // For non-overlapping boxes, use distance between boxes
        dax = dbx;
        day = dby;
        dist_axial = dist_box;
        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
    }
    else if (dcx != 0.0f || dcy != 0.0f)
    {
        // For overlapping boxes with different centers, use distance between centers
        dax = dcx;
        day = dcy;
        dist_axial = dist_center;
        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
    }
    else
    {
        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
        quadrant = (window->DC.LastItemId < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
    }

#if IMGUI_DEBUG_NAV_SCORING
    char buf[128];
    if (ImGui::IsMouseHoveringRect(cand.Min, cand.Max))
    {
        ImFormatString(buf, IM_ARRAYSIZE(buf), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[g.NavMoveDir], "WENS"[quadrant]);
        ImDrawList* draw_list = ImGui::GetOverlayDrawList(window);
        draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255,200,0,100));
        draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255,255,0,200));
        draw_list->AddRectFilled(cand.Max-ImVec2(4,4), cand.Max+ImGui::CalcTextSize(buf)+ImVec2(4,4), IM_COL32(40,0,0,150));
        draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Max, ~0U, buf);
    }
    else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.
    {
        if (ImGui::IsKeyPressedMap(ImGuiKey_C)) { g.NavMoveDirLast = (ImGuiDir)((g.NavMoveDirLast + 1) & 3); g.IO.KeysDownDuration[g.IO.KeyMap[ImGuiKey_C]] = 0.01f; }
        if (quadrant == g.NavMoveDir)
        {
            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
            ImDrawList* draw_list = ImGui::GetOverlayDrawList(window);
            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));
            draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Min, IM_COL32(255, 255, 255, 255), buf);
        }
    }
 #endif

    // Is it in the quadrant we're interesting in moving to?
    bool new_best = false;
    if (quadrant == g.NavMoveDir)
    {
        // Does it beat the current best candidate?
        if (dist_box < result->DistBox)
        {
            result->DistBox = dist_box;
            result->DistCenter = dist_center;
            return true;
        }
        if (dist_box == result->DistBox)
        {
            // Try using distance between center points to break ties
            if (dist_center < result->DistCenter)
            {
                result->DistCenter = dist_center;
                new_best = true;
            }
            else if (dist_center == result->DistCenter)
            {
                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
                if (((g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
                    new_best = true;
            }
        }
    }

    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
        if (g.NavLayer == 1 && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
            if ((g.NavMoveDir == ImGuiDir_Left && dax < 0.0f) || (g.NavMoveDir == ImGuiDir_Right && dax > 0.0f) || (g.NavMoveDir == ImGuiDir_Up && day < 0.0f) || (g.NavMoveDir == ImGuiDir_Down && day > 0.0f))
            {
                result->DistAxial = dist_axial;
                new_best = true;
            }

    return new_best;
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
static void ImGui::NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    //if (!g.IO.NavActive)  // [2017/10/06] Removed this possibly redundant test but I am not sure of all the side-effects yet. Some of the feature here will need to work regardless of using a _NoNavInputs flag.
    //    return;

    const ImGuiItemFlags item_flags = window->DC.ItemFlags;
    const ImRect nav_bb_rel(nav_bb.Min - window->Pos, nav_bb.Max - window->Pos);

    // Process Init Request
    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent)
    {
        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus) || g.NavInitResultId == 0)
        {
            g.NavInitResultId = id;
            g.NavInitResultRectRel = nav_bb_rel;
        }
        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus))
        {
            g.NavInitRequest = false; // Found a match, clear request
            NavUpdateAnyRequestFlag();
        }
    }

    // Process Move Request (scoring for navigation)
    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRectScreen + scoring from a rect wrapped according to current wrapping policy)
    if ((g.NavId != id || (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) && !(item_flags & ImGuiItemFlags_NoNav))
    {
        ImGuiNavMoveResult* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
#if IMGUI_DEBUG_NAV_SCORING
        // [DEBUG] Score all items in NavWindow at all times
        if (!g.NavMoveRequest)
            g.NavMoveDir = g.NavMoveDirLast;
        bool new_best = NavScoreItem(result, nav_bb) && g.NavMoveRequest;
#else
        bool new_best = g.NavMoveRequest && NavScoreItem(result, nav_bb);
#endif
        if (new_best)
        {
            result->ID = id;
            result->Window = window;
            result->RectRel = nav_bb_rel;
        }

        const float VISIBLE_RATIO = 0.70f;
        if ((g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
            if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
                if (NavScoreItem(&g.NavMoveResultLocalVisibleSet, nav_bb))
                {
                    result = &g.NavMoveResultLocalVisibleSet;
                    result->ID = id;
                    result->Window = window;
                    result->RectRel = nav_bb_rel;
                }
    }

    // Update window-relative bounding box of navigated item
    if (g.NavId == id)
    {
        g.NavWindow = window;                                           // Always refresh g.NavWindow, because some operations such as FocusItem() don't have a window.
        g.NavLayer = window->DC.NavLayerCurrent;
        g.NavIdIsAlive = true;
        g.NavIdTabCounter = window->FocusIdxTabCounter;
        window->NavRectRel[window->DC.NavLayerCurrent] = nav_bb_rel;    // Store item bounding box (relative to window position)
    }
}

bool ImGui::NavMoveRequestButNoResultYet()
{
    ImGuiContext& g = *GImGui;
    return g.NavMoveRequest && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
}

void ImGui::NavMoveRequestCancel()
{
    ImGuiContext& g = *GImGui;
    g.NavMoveRequest = false;
    NavUpdateAnyRequestFlag();
}

void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_None);
    ImGui::NavMoveRequestCancel();
    g.NavMoveDir = move_dir;
    g.NavMoveClipDir = clip_dir;
    g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
    g.NavMoveRequestFlags = move_flags;
    g.NavWindow->NavRectRel[g.NavLayer] = bb_rel;
}

void ImGui::NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags)
{
    ImGuiContext& g = *GImGui;
    if (g.NavWindow != window || !NavMoveRequestButNoResultYet() || g.NavMoveRequestForward != ImGuiNavForward_None || g.NavLayer != 0)
        return;
    IM_ASSERT(move_flags != 0); // No points calling this with no wrapping
    ImRect bb_rel = window->NavRectRel[0];

    ImGuiDir clip_dir = g.NavMoveDir;
    if (g.NavMoveDir == ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = ImMax(window->SizeFull.x, window->SizeContents.x) - window->Scroll.x;
        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(-bb_rel.GetHeight()); clip_dir = ImGuiDir_Up; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = -window->Scroll.x;
        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(+bb_rel.GetHeight()); clip_dir = ImGuiDir_Down; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = ImMax(window->SizeFull.y, window->SizeContents.y) - window->Scroll.y;
        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(-bb_rel.GetWidth()); clip_dir = ImGuiDir_Left; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = -window->Scroll.y;
        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(+bb_rel.GetWidth()); clip_dir = ImGuiDir_Right; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
}

static void ImGui::NavSaveLastChildNavWindow(ImGuiWindow* nav_window)
{
    ImGuiWindow* parent_window = nav_window;
    while (parent_window && (parent_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (parent_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
        parent_window = parent_window->ParentWindow;
    if (parent_window && parent_window != nav_window)
        parent_window->NavLastChildNavWindow = nav_window;
}

// Call when we are expected to land on Layer 0 after FocusWindow()
static ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)
{
    return window->NavLastChildNavWindow ? window->NavLastChildNavWindow : window;
}

static void NavRestoreLayer(ImGuiNavLayer layer)
{
    ImGuiContext& g = *GImGui;
    g.NavLayer = layer;
    if (layer == 0)
        g.NavWindow = ImGui::NavRestoreLastChildNavWindow(g.NavWindow);
    if (layer == 0 && g.NavWindow->NavLastIds[0] != 0)
        ImGui::SetNavIDWithRectRel(g.NavWindow->NavLastIds[0], layer, g.NavWindow->NavRectRel[0]);
    else
        ImGui::NavInitWindow(g.NavWindow, true);
}

static inline void ImGui::NavUpdateAnyRequestFlag()
{
    ImGuiContext& g = *GImGui;
    g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
    if (g.NavAnyRequest)
        IM_ASSERT(g.NavWindow != NULL);
}

// This needs to be called before we submit any widget (aka in or before Begin)
void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(window == g.NavWindow);
    bool init_for_nav = false;
    if (!(window->Flags & ImGuiWindowFlags_NoNavInputs))
        if (!(window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
            init_for_nav = true;
    if (init_for_nav)
    {
        SetNavID(0, g.NavLayer);
        g.NavInitRequest = true;
        g.NavInitRequestFromMove = false;
        g.NavInitResultId = 0;
        g.NavInitResultRectRel = ImRect();
        NavUpdateAnyRequestFlag();
    }
    else
    {
        g.NavId = window->NavLastIds[0];
    }
}

static ImVec2 ImGui::NavCalcPreferredRefPos()
{
    ImGuiContext& g = *GImGui;
    if (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow)
    {
        // Mouse (we need a fallback in case the mouse becomes invalid after being used)
        if (IsMousePosValid(&g.IO.MousePos))
            return g.IO.MousePos;
        return g.LastValidMousePos;
    }
    else
    {
        // When navigation is active and mouse is disabled, decide on an arbitrary position around the bottom left of the currently navigated item.
        const ImRect& rect_rel = g.NavWindow->NavRectRel[g.NavLayer];
        ImVec2 pos = g.NavWindow->Pos + ImVec2(rect_rel.Min.x + ImMin(g.Style.FramePadding.x * 4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));
        ImRect visible_rect = GetViewportRect();
        return ImFloor(ImClamp(pos, visible_rect.Min, visible_rect.Max));   // ImFloor() is important because non-integer mouse position application in back-end might be lossy and result in undesirable non-zero delta.
    }
}

float ImGui::GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode)
{
    ImGuiContext& g = *GImGui;
    if (mode == ImGuiInputReadMode_Down)
        return g.IO.NavInputs[n];                         // Instant, read analog input (0.0f..1.0f, as provided by user)

    const float t = g.IO.NavInputsDownDuration[n];
    if (t < 0.0f && mode == ImGuiInputReadMode_Released)  // Return 1.0f when just released, no repeat, ignore analog input.
        return (g.IO.NavInputsDownDurationPrev[n] >= 0.0f ? 1.0f : 0.0f);
    if (t < 0.0f)
        return 0.0f;
    if (mode == ImGuiInputReadMode_Pressed)               // Return 1.0f when just pressed, no repeat, ignore analog input.
        return (t == 0.0f) ? 1.0f : 0.0f;
    if (mode == ImGuiInputReadMode_Repeat)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.80f);
    if (mode == ImGuiInputReadMode_RepeatSlow)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 1.00f, g.IO.KeyRepeatRate * 2.00f);
    if (mode == ImGuiInputReadMode_RepeatFast)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.30f);
    return 0.0f;
}

ImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor)
{
    ImVec2 delta(0.0f, 0.0f);
    if (dir_sources & ImGuiNavDirSourceFlags_Keyboard)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_KeyRight_, mode)   - GetNavInputAmount(ImGuiNavInput_KeyLeft_,   mode), GetNavInputAmount(ImGuiNavInput_KeyDown_,   mode) - GetNavInputAmount(ImGuiNavInput_KeyUp_,   mode));
    if (dir_sources & ImGuiNavDirSourceFlags_PadDPad)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_DpadRight, mode)   - GetNavInputAmount(ImGuiNavInput_DpadLeft,   mode), GetNavInputAmount(ImGuiNavInput_DpadDown,   mode) - GetNavInputAmount(ImGuiNavInput_DpadUp,   mode));
    if (dir_sources & ImGuiNavDirSourceFlags_PadLStick)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_LStickRight, mode) - GetNavInputAmount(ImGuiNavInput_LStickLeft, mode), GetNavInputAmount(ImGuiNavInput_LStickDown, mode) - GetNavInputAmount(ImGuiNavInput_LStickUp, mode));
    if (slow_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakSlow))
        delta *= slow_factor;
    if (fast_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakFast))
        delta *= fast_factor;
    return delta;
}

// Scroll to keep newly navigated item fully into view
// NB: We modify rect_rel by the amount we scrolled for, so it is immediately updated.
static void NavScrollToBringItemIntoView(ImGuiWindow* window, const ImRect& item_rect)
{
    ImRect window_rect(window->InnerMainRect.Min - ImVec2(1, 1), window->InnerMainRect.Max + ImVec2(1, 1));
    //GetOverlayDrawList(window)->AddRect(window_rect.Min, window_rect.Max, IM_COL32_WHITE); // [DEBUG]
    if (window_rect.Contains(item_rect))
        return;

    ImGuiContext& g = *GImGui;
    if (window->ScrollbarX && item_rect.Min.x < window_rect.Min.x)
    {
        window->ScrollTarget.x = item_rect.Min.x - window->Pos.x + window->Scroll.x - g.Style.ItemSpacing.x;
        window->ScrollTargetCenterRatio.x = 0.0f;
    }
    else if (window->ScrollbarX && item_rect.Max.x >= window_rect.Max.x)
    {
        window->ScrollTarget.x = item_rect.Max.x - window->Pos.x + window->Scroll.x + g.Style.ItemSpacing.x;
        window->ScrollTargetCenterRatio.x = 1.0f;
    }
    if (item_rect.Min.y < window_rect.Min.y)
    {
        window->ScrollTarget.y = item_rect.Min.y - window->Pos.y + window->Scroll.y - g.Style.ItemSpacing.y;
        window->ScrollTargetCenterRatio.y = 0.0f;
    }
    else if (item_rect.Max.y >= window_rect.Max.y)
    {
        window->ScrollTarget.y = item_rect.Max.y - window->Pos.y + window->Scroll.y + g.Style.ItemSpacing.y;
        window->ScrollTargetCenterRatio.y = 1.0f;
    }
}

static void ImGui::NavUpdate()
{
    ImGuiContext& g = *GImGui;
    g.IO.WantSetMousePos = false;
#if 0
    if (g.NavScoringCount > 0) printf("[%05d] NavScoringCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.FrameCount, g.NavScoringCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
#endif

    // Set input source as Gamepad when buttons are pressed before we map Keyboard (some features differs when used with Gamepad vs Keyboard)
    bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    if (nav_gamepad_active)
        if (g.IO.NavInputs[ImGuiNavInput_Activate] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Input] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Cancel] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Menu] > 0.0f)
            g.NavInputSource = ImGuiInputSource_NavGamepad;

    // Update Keyboard->Nav inputs mapping
    if (nav_keyboard_active)
    {
        #define NAV_MAP_KEY(_KEY, _NAV_INPUT) if (IsKeyDown(g.IO.KeyMap[_KEY])) { g.IO.NavInputs[_NAV_INPUT] = 1.0f; g.NavInputSource = ImGuiInputSource_NavKeyboard; }
        NAV_MAP_KEY(ImGuiKey_Space,     ImGuiNavInput_Activate );
        NAV_MAP_KEY(ImGuiKey_Enter,     ImGuiNavInput_Input    );
        NAV_MAP_KEY(ImGuiKey_Escape,    ImGuiNavInput_Cancel   );
        NAV_MAP_KEY(ImGuiKey_LeftArrow, ImGuiNavInput_KeyLeft_ );
        NAV_MAP_KEY(ImGuiKey_RightArrow,ImGuiNavInput_KeyRight_);
        NAV_MAP_KEY(ImGuiKey_UpArrow,   ImGuiNavInput_KeyUp_   );
        NAV_MAP_KEY(ImGuiKey_DownArrow, ImGuiNavInput_KeyDown_ );
        if (g.IO.KeyCtrl)   g.IO.NavInputs[ImGuiNavInput_TweakSlow] = 1.0f;
        if (g.IO.KeyShift)  g.IO.NavInputs[ImGuiNavInput_TweakFast] = 1.0f;
        if (g.IO.KeyAlt)    g.IO.NavInputs[ImGuiNavInput_KeyMenu_]  = 1.0f;
        #undef NAV_MAP_KEY
    }
    memcpy(g.IO.NavInputsDownDurationPrev, g.IO.NavInputsDownDuration, sizeof(g.IO.NavInputsDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.NavInputs); i++)
        g.IO.NavInputsDownDuration[i] = (g.IO.NavInputs[i] > 0.0f) ? (g.IO.NavInputsDownDuration[i] < 0.0f ? 0.0f : g.IO.NavInputsDownDuration[i] + g.IO.DeltaTime) : -1.0f;

    // Process navigation init request (select first/default focus)
    if (g.NavInitResultId != 0 && (!g.NavDisableHighlight || g.NavInitRequestFromMove))
    {
        // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
        IM_ASSERT(g.NavWindow);
        if (g.NavInitRequestFromMove)
            SetNavIDWithRectRel(g.NavInitResultId, g.NavLayer, g.NavInitResultRectRel);
        else
            SetNavID(g.NavInitResultId, g.NavLayer);
        g.NavWindow->NavRectRel[g.NavLayer] = g.NavInitResultRectRel;
    }
    g.NavInitRequest = false;
    g.NavInitRequestFromMove = false;
    g.NavInitResultId = 0;
    g.NavJustMovedToId = 0;

    // Process navigation move request
    if (g.NavMoveRequest)
        NavUpdateMoveResult();

    // When a forwarded move request failed, we restore the highlight that we disabled during the forward frame
    if (g.NavMoveRequestForward == ImGuiNavForward_ForwardActive)
    {
        IM_ASSERT(g.NavMoveRequest);
        if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
            g.NavDisableHighlight = false;
        g.NavMoveRequestForward = ImGuiNavForward_None;
    }

    // Apply application mouse position movement, after we had a chance to process move request result.
    if (g.NavMousePosDirty && g.NavIdIsAlive)
    {
        // Set mouse position given our knowledge of the navigated item position from last frame
        if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (g.IO.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
        {
            if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
            {
                g.IO.MousePos = g.IO.MousePosPrev = NavCalcPreferredRefPos();
                g.IO.WantSetMousePos = true;
            }
        }
        g.NavMousePosDirty = false;
    }
    g.NavIdIsAlive = false;
    g.NavJustTabbedId = 0;
    IM_ASSERT(g.NavLayer == 0 || g.NavLayer == 1);

    // Store our return window (for returning from Layer 1 to Layer 0) and clear it as soon as we step back in our own Layer 0
    if (g.NavWindow)
        NavSaveLastChildNavWindow(g.NavWindow);
    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == 0)
        g.NavWindow->NavLastChildNavWindow = NULL;

    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
    NavUpdateWindowing();

    // Set output flags for user application
    g.IO.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
    g.IO.NavVisible = (g.IO.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL) || g.NavInitRequest;

    // Process NavCancel input (to close a popup, get back to parent, clear focus)
    if (IsNavInputPressed(ImGuiNavInput_Cancel, ImGuiInputReadMode_Pressed))
    {
        if (g.ActiveId != 0)
        {
            ClearActiveID();
        }
        else if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow) && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)
        {
            // Exit child window
            ImGuiWindow* child_window = g.NavWindow;
            ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
            IM_ASSERT(child_window->ChildId != 0);
            FocusWindow(parent_window);
            SetNavID(child_window->ChildId, 0);
            g.NavIdIsAlive = false;
            if (g.NavDisableMouseHover)
                g.NavMousePosDirty = true;
        }
        else if (g.OpenPopupStack.Size > 0)
        {
            // Close open popup/menu
            if (!(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
                ClosePopupToLevel(g.OpenPopupStack.Size - 1);
        }
        else if (g.NavLayer != 0)
        {
            // Leave the "menu" layer
            NavRestoreLayer(ImGuiNavLayer_Main);
        }
        else
        {
            // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
            if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
                g.NavWindow->NavLastIds[0] = 0;
            g.NavId = 0;
        }
    }

    // Process manual activation request
    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = 0;
    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
    {
        bool activate_down = IsNavInputDown(ImGuiNavInput_Activate);
        bool activate_pressed = activate_down && IsNavInputPressed(ImGuiNavInput_Activate, ImGuiInputReadMode_Pressed);
        if (g.ActiveId == 0 && activate_pressed)
            g.NavActivateId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)
            g.NavActivateDownId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)
            g.NavActivatePressedId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && IsNavInputPressed(ImGuiNavInput_Input, ImGuiInputReadMode_Pressed))
            g.NavInputId = g.NavId;
    }
    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        g.NavDisableHighlight = true;
    if (g.NavActivateId != 0)
        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
    g.NavMoveRequest = false;

    // Process programmatic activation request
    if (g.NavNextActivateId != 0)
        g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;
    g.NavNextActivateId = 0;

    // Initiate directional inputs request
    const int allowed_dir_flags = (g.ActiveId == 0) ? ~0 : g.ActiveIdAllowNavDirFlags;
    if (g.NavMoveRequestForward == ImGuiNavForward_None)
    {
        g.NavMoveDir = ImGuiDir_None;
        g.NavMoveRequestFlags = ImGuiNavMoveFlags_None;
        if (g.NavWindow && !g.NavWindowingTarget && allowed_dir_flags && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        {
            if ((allowed_dir_flags & (1<<ImGuiDir_Left))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadLeft, ImGuiNavInput_KeyLeft_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Left;
            if ((allowed_dir_flags & (1<<ImGuiDir_Right)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadRight,ImGuiNavInput_KeyRight_,ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Right;
            if ((allowed_dir_flags & (1<<ImGuiDir_Up))    && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadUp,   ImGuiNavInput_KeyUp_,   ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Up;
            if ((allowed_dir_flags & (1<<ImGuiDir_Down))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadDown, ImGuiNavInput_KeyDown_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Down;
        }
        g.NavMoveClipDir = g.NavMoveDir;
    }
    else
    {
        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
        // (Preserve g.NavMoveRequestFlags, g.NavMoveClipDir which were set by the NavMoveRequestForward() function)
        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
        IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_ForwardQueued);
        g.NavMoveRequestForward = ImGuiNavForward_ForwardActive;
    }

    // Update PageUp/PageDown scroll
    float nav_scoring_rect_offset_y = 0.0f;
    if (nav_keyboard_active)
        nav_scoring_rect_offset_y = NavUpdatePageUpPageDown(allowed_dir_flags);

    // If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match
    if (g.NavMoveDir != ImGuiDir_None)
    {
        g.NavMoveRequest = true;
        g.NavMoveDirLast = g.NavMoveDir;
    }
    if (g.NavMoveRequest && g.NavId == 0)
    {
        g.NavInitRequest = g.NavInitRequestFromMove = true;
        g.NavInitResultId = 0;
        g.NavDisableHighlight = false;
    }
    NavUpdateAnyRequestFlag();

    // Scrolling
    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
    {
        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
        ImGuiWindow* window = g.NavWindow;
        const float scroll_speed = ImFloor(window->CalcFontSize() * 100 * g.IO.DeltaTime + 0.5f); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
        if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll && g.NavMoveRequest)
        {
            if (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right)
                SetWindowScrollX(window, ImFloor(window->Scroll.x + ((g.NavMoveDir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
            if (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down)
                SetWindowScrollY(window, ImFloor(window->Scroll.y + ((g.NavMoveDir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
        }

        // *Normal* Manual scroll with NavScrollXXX keys
        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
        ImVec2 scroll_dir = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down, 1.0f/10.0f, 10.0f);
        if (scroll_dir.x != 0.0f && window->ScrollbarX)
        {
            SetWindowScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed));
            g.NavMoveFromClampedRefRect = true;
        }
        if (scroll_dir.y != 0.0f)
        {
            SetWindowScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed));
            g.NavMoveFromClampedRefRect = true;
        }
    }

    // Reset search results
    g.NavMoveResultLocal.Clear();
    g.NavMoveResultLocalVisibleSet.Clear();
    g.NavMoveResultOther.Clear();

    // When we have manually scrolled (without using navigation) and NavId becomes out of bounds, we project its bounding box to the visible area to restart navigation within visible items
    if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)
    {
        ImGuiWindow* window = g.NavWindow;
        ImRect window_rect_rel(window->InnerMainRect.Min - window->Pos - ImVec2(1,1), window->InnerMainRect.Max - window->Pos + ImVec2(1,1));
        if (!window_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
        {
            float pad = window->CalcFontSize() * 0.5f;
            window_rect_rel.Expand(ImVec2(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intent of starting navigation from first fully visible item
            window->NavRectRel[g.NavLayer].ClipWith(window_rect_rel);
            g.NavId = 0;
        }
        g.NavMoveFromClampedRefRect = false;
    }

    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
    ImRect nav_rect_rel = (g.NavWindow && !g.NavWindow->NavRectRel[g.NavLayer].IsInverted()) ? g.NavWindow->NavRectRel[g.NavLayer] : ImRect(0,0,0,0);
    g.NavScoringRectScreen = g.NavWindow ? ImRect(g.NavWindow->Pos + nav_rect_rel.Min, g.NavWindow->Pos + nav_rect_rel.Max) : GetViewportRect();
    g.NavScoringRectScreen.TranslateY(nav_scoring_rect_offset_y);
    g.NavScoringRectScreen.Min.x = ImMin(g.NavScoringRectScreen.Min.x + 1.0f, g.NavScoringRectScreen.Max.x);
    g.NavScoringRectScreen.Max.x = g.NavScoringRectScreen.Min.x;
    IM_ASSERT(!g.NavScoringRectScreen.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allows us to remove extraneous ImFabs() calls in NavScoreItem().
    //g.OverlayDrawList.AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]
    g.NavScoringCount = 0;
#if IMGUI_DEBUG_NAV_RECTS
    if (g.NavWindow) { for (int layer = 0; layer < 2; layer++) GetOverlayDrawList(g.NavWindow)->AddRect(g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Min, g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Max, IM_COL32(255,200,0,255)); } // [DEBUG]
    if (g.NavWindow) { ImU32 col = (!g.NavWindow->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); GetOverlayDrawList(g.NavWindow)->AddCircleFilled(p, 3.0f, col); GetOverlayDrawList(g.NavWindow)->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
#endif
}

// Apply result from previous frame navigation directional move request
static void ImGui::NavUpdateMoveResult()
{
    ImGuiContext& g = *GImGui;
    if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
    {
        // In a situation when there is no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
        if (g.NavId != 0)
        {
            g.NavDisableHighlight = false;
            g.NavDisableMouseHover = true;
        }
        return;
    }

    // Select which result to use
    ImGuiNavMoveResult* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;

    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
    if (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
        if (g.NavMoveResultLocalVisibleSet.ID != 0 && g.NavMoveResultLocalVisibleSet.ID != g.NavId)
            result = &g.NavMoveResultLocalVisibleSet;

    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
            result = &g.NavMoveResultOther;
    IM_ASSERT(g.NavWindow && result->Window);

    // Scroll to keep newly navigated item fully into view.
    if (g.NavLayer == 0)
    {
        ImRect rect_abs = ImRect(result->RectRel.Min + result->Window->Pos, result->RectRel.Max + result->Window->Pos);
        NavScrollToBringItemIntoView(result->Window, rect_abs);

        // Estimate upcoming scroll so we can offset our result position so mouse position can be applied immediately after in NavUpdate()
        ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(result->Window, false);
        ImVec2 delta_scroll = result->Window->Scroll - next_scroll;
        result->RectRel.Translate(delta_scroll);

        // Also scroll parent window to keep us into view if necessary (we could/should technically recurse back the whole the parent hierarchy).
        if (result->Window->Flags & ImGuiWindowFlags_ChildWindow)
            NavScrollToBringItemIntoView(result->Window->ParentWindow, ImRect(rect_abs.Min + delta_scroll, rect_abs.Max + delta_scroll));
    }

    ClearActiveID();
    g.NavWindow = result->Window;
    SetNavIDWithRectRel(result->ID, g.NavLayer, result->RectRel);
    g.NavJustMovedToId = result->ID;
    g.NavMoveFromClampedRefRect = false;
}

static float ImGui::NavUpdatePageUpPageDown(int allowed_dir_flags)
{
    ImGuiContext& g = *GImGui;
    if (g.NavMoveDir == ImGuiDir_None && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget && g.NavLayer == 0)
    {
        ImGuiWindow* window = g.NavWindow;
        bool page_up_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageUp]) && (allowed_dir_flags & (1 << ImGuiDir_Up));
        bool page_down_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageDown]) && (allowed_dir_flags & (1 << ImGuiDir_Down));
        if ((page_up_held && !page_down_held) || (page_down_held && !page_up_held))
        {
            if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll)
            {
                // Fallback manual-scroll when window has no navigable item
                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))
                    SetWindowScrollY(window, window->Scroll.y - window->InnerClipRect.GetHeight());
                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))
                    SetWindowScrollY(window, window->Scroll.y + window->InnerClipRect.GetHeight());
            }
            else
            {
                const ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];
                const float page_offset_y = ImMax(0.0f, window->InnerClipRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
                float nav_scoring_rect_offset_y = 0.0f;
                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))
                {
                    nav_scoring_rect_offset_y = -page_offset_y;
                    g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)
                    g.NavMoveClipDir = ImGuiDir_Up;
                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
                }
                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))
                {
                    nav_scoring_rect_offset_y = +page_offset_y;
                    g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)
                    g.NavMoveClipDir = ImGuiDir_Down;
                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
                }
                return nav_scoring_rect_offset_y;
            }
        }
    }
    return 0.0f;
}

static int FindWindowFocusIndex(ImGuiWindow* window) // FIXME-OPT O(N)
{
    ImGuiContext& g = *GImGui;
    for (int i = g.WindowsFocusOrder.Size-1; i >= 0; i--)
        if (g.WindowsFocusOrder[i] == window)
            return i;
    return -1;
}

static ImGuiWindow* FindWindowNavFocusable(int i_start, int i_stop, int dir) // FIXME-OPT O(N)
{
    ImGuiContext& g = *GImGui;
    for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)
        if (ImGui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))
            return g.WindowsFocusOrder[i];
    return NULL;
}

static void NavUpdateWindowingHighlightWindow(int focus_change_dir)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindowingTarget);
    if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)
        return;

    const int i_current = FindWindowFocusIndex(g.NavWindowingTarget);
    ImGuiWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);
    if (!window_target)
        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);
    if (window_target) // Don't reset windowing target if there's a single window in the list
        g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
    g.NavWindowingToggleLayer = false;
}

// Window management mode (hold to: change focus/move/resize, tap to: toggle menu layer)
static void ImGui::NavUpdateWindowing()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* apply_focus_window = NULL;
    bool apply_toggle_layer = false;

    ImGuiWindow* modal_window = GetFrontMostPopupModal();
    if (modal_window != NULL)
    {
        g.NavWindowingTarget = NULL;
        return;
    }

    // Fade out
    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
    {
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - g.IO.DeltaTime * 10.0f, 0.0f);
        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
            g.NavWindowingTargetAnim = NULL;
    }

    // LoopCallback CTRL-TAB or Square+L/R window selection
    bool start_windowing_with_gamepad = !g.NavWindowingTarget && IsNavInputPressed(ImGuiNavInput_Menu, ImGuiInputReadMode_Pressed);
    bool start_windowing_with_keyboard = !g.NavWindowingTarget && g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab) && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard);
    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
        {
            g.NavWindowingTarget = g.NavWindowingTargetAnim = window;
            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
            g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;
            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_NavKeyboard : ImGuiInputSource_NavGamepad;
        }

    // Gamepad update
    g.NavWindowingTimer += g.IO.DeltaTime;
    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavGamepad)
    {
        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));

        // Select window to focus
        const int focus_change_dir = (int)IsNavInputPressed(ImGuiNavInput_FocusPrev, ImGuiInputReadMode_RepeatSlow) - (int)IsNavInputPressed(ImGuiNavInput_FocusNext, ImGuiInputReadMode_RepeatSlow);
        if (focus_change_dir != 0)
        {
            NavUpdateWindowingHighlightWindow(focus_change_dir);
            g.NavWindowingHighlightAlpha = 1.0f;
        }

        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered front-most)
        if (!IsNavInputDown(ImGuiNavInput_Menu))
        {
            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
            if (g.NavWindowingToggleLayer && g.NavWindow)
                apply_toggle_layer = true;
            else if (!g.NavWindowingToggleLayer)
                apply_focus_window = g.NavWindowingTarget;
            g.NavWindowingTarget = NULL;
        }
    }

    // Keyboard: Focus
    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavKeyboard)
    {
        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
        if (IsKeyPressedMap(ImGuiKey_Tab, true))
            NavUpdateWindowingHighlightWindow(g.IO.KeyShift ? +1 : -1);
        if (!g.IO.KeyCtrl)
            apply_focus_window = g.NavWindowingTarget;
    }

    // Keyboard: Press and Release ALT to toggle menu layer
    // FIXME: We lack an explicit IO variable for "is the imgui window focused", so compare mouse validity to detect the common case of back-end clearing releases all keys on ALT-TAB
    if ((g.ActiveId == 0 || g.ActiveIdAllowOverlap) && IsNavInputPressed(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Released))
        if (IsMousePosValid(&g.IO.MousePos) == IsMousePosValid(&g.IO.MousePosPrev))
            apply_toggle_layer = true;

    // Move window
    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
    {
        ImVec2 move_delta;
        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && !g.IO.KeyShift)
            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
        if (g.NavInputSource == ImGuiInputSource_NavGamepad)
            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down);
        if (move_delta.x != 0.0f || move_delta.y != 0.0f)
        {
            const float NAV_MOVE_SPEED = 800.0f;
            const float move_speed = ImFloor(NAV_MOVE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y)); // FIXME: Doesn't code variable framerate very well
            g.NavWindowingTarget->RootWindow->Pos += move_delta * move_speed;
            g.NavDisableMouseHover = true;
            MarkIniSettingsDirty(g.NavWindowingTarget);
        }
    }

    // Apply final focus
    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
    {
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;
        apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);
        ClosePopupsOverWindow(apply_focus_window);
        FocusWindow(apply_focus_window);
        if (apply_focus_window->NavLastIds[0] == 0)
            NavInitWindow(apply_focus_window, false);

        // If the window only has a menu layer, select it directly
        if (apply_focus_window->DC.NavLayerActiveMask == (1 << ImGuiNavLayer_Menu))
            g.NavLayer = ImGuiNavLayer_Menu;
    }
    if (apply_focus_window)
        g.NavWindowingTarget = NULL;

    // Apply menu/layer toggle
    if (apply_toggle_layer && g.NavWindow)
    {
        // Move to parent menu if necessary
        ImGuiWindow* new_nav_window = g.NavWindow;
        while ((new_nav_window->DC.NavLayerActiveMask & (1 << 1)) == 0 
            && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
            && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
            new_nav_window = new_nav_window->ParentWindow;
        if (new_nav_window != g.NavWindow)
        {
            ImGuiWindow* old_nav_window = g.NavWindow;
            FocusWindow(new_nav_window);
            new_nav_window->NavLastChildNavWindow = old_nav_window;
        }
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;
        NavRestoreLayer((g.NavWindow->DC.NavLayerActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main);
    }
}

// Window has already passed the IsWindowNavFocusable()
static const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)
{
    if (window->Flags & ImGuiWindowFlags_Popup)
        return "(Popup)";
    if ((window->Flags & ImGuiWindowFlags_MenuBar) && strcmp(window->Name, "##MainMenuBar") == 0)
        return "(Main menu bar)";
    return "(Untitled)";
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
void ImGui::NavUpdateWindowingList()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindowingTarget != NULL);

    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)
        return;

    if (g.NavWindowingList == NULL)
        g.NavWindowingList = FindWindowByName("###NavWindowingList");
    SetNextWindowSizeConstraints(ImVec2(g.IO.DisplaySize.x * 0.20f, g.IO.DisplaySize.y * 0.20f), ImVec2(FLT_MAX, FLT_MAX));
    SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Always, ImVec2(0.5f, 0.5f));
    PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);
    Begin("###NavWindowingList", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);
    for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--)
    {
        ImGuiWindow* window = g.WindowsFocusOrder[n];
        if (!IsWindowNavFocusable(window))
            continue;
        const char* label = window->Name;
        if (label == FindRenderedTextEnd(label))
            label = GetFallbackWindowNameForWindowingList(window);
        Selectable(label, g.NavWindowingTarget == window);
    }
    End();
    PopStyleVar();
}

//-----------------------------------------------------------------------------
// [SECTION] COLUMNS
// In the current version, Columns are very weak. Needs to be replaced with a more full-featured system.
//-----------------------------------------------------------------------------

void ImGui::NextColumn()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems || window->DC.ColumnsSet == NULL)
        return;

    ImGuiContext& g = *GImGui;
    PopItemWidth();
    PopClipRect();

    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    if (++columns->Current < columns->Count)
    {
        // Columns 1+ cancel out IndentX
        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + g.Style.ItemSpacing.x;
        window->DrawList->ChannelsSetCurrent(columns->Current);
    }
    else
    {
        window->DC.ColumnsOffset.x = 0.0f;
        window->DrawList->ChannelsSetCurrent(0);
        columns->Current = 0;
        columns->LineMinY = columns->LineMaxY;
    }
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->DC.CursorPos.y = columns->LineMinY;
    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);
    window->DC.CurrentLineTextBaseOffset = 0.0f;

    PushColumnClipRect();
    PushItemWidth(GetColumnWidth() * 0.65f);  // FIXME: Move on columns setup
}

int ImGui::GetColumnIndex()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.ColumnsSet ? window->DC.ColumnsSet->Current : 0;
}

int ImGui::GetColumnsCount()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.ColumnsSet ? window->DC.ColumnsSet->Count : 1;
}

static float OffsetNormToPixels(const ImGuiColumnsSet* columns, float offset_norm)
{
    return offset_norm * (columns->MaxX - columns->MinX);
}

static float PixelsToOffsetNorm(const ImGuiColumnsSet* columns, float offset)
{
    return offset / (columns->MaxX - columns->MinX);
}

static inline float GetColumnsRectHalfWidth() { return 4.0f; }

static float GetDraggedColumnOffset(ImGuiColumnsSet* columns, int column_index)
{
    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));

    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + GetColumnsRectHalfWidth() - window->Pos.x;
    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
    if ((columns->Flags & ImGuiColumnsFlags_NoPreserveWidths))
        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

    return x;
}

float ImGui::GetColumnOffset(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const float t = columns->Columns[column_index].OffsetNorm;
    const float x_offset = ImLerp(columns->MinX, columns->MaxX, t);
    return x_offset;
}

static float GetColumnWidthEx(ImGuiColumnsSet* columns, int column_index, bool before_resize = false)
{
    if (column_index < 0)
        column_index = columns->Current;

    float offset_norm;
    if (before_resize)
        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;
    else
        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;
    return OffsetNormToPixels(columns, offset_norm);
}

float ImGui::GetColumnWidth(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    return OffsetNormToPixels(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);
}

void ImGui::SetColumnOffset(int column_index, float offset)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const bool preserve_width = !(columns->Flags & ImGuiColumnsFlags_NoPreserveWidths) && (column_index < columns->Count-1);
    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

    if (!(columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow))
        offset = ImMin(offset, columns->MaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));
    columns->Columns[column_index].OffsetNorm = PixelsToOffsetNorm(columns, offset - columns->MinX);

    if (preserve_width)
        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));
}

void ImGui::SetColumnWidth(int column_index, float width)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
}

void ImGui::PushColumnClipRect(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    if (column_index < 0)
        column_index = columns->Current;

    PushClipRect(columns->Columns[column_index].ClipRect.Min, columns->Columns[column_index].ClipRect.Max, false);
}

static ImGuiColumnsSet* FindOrAddColumnsSet(ImGuiWindow* window, ImGuiID id)
{
    for (int n = 0; n < window->ColumnsStorage.Size; n++)
        if (window->ColumnsStorage[n].ID == id)
            return &window->ColumnsStorage[n];

    window->ColumnsStorage.push_back(ImGuiColumnsSet());
    ImGuiColumnsSet* columns = &window->ColumnsStorage.back();
    columns->ID = id;
    return columns;
}

void ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiColumnsFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    IM_ASSERT(columns_count > 1);
    IM_ASSERT(window->DC.ColumnsSet == NULL); // Nested columns are currently not supported

    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
    PushID(0x11223347 + (str_id ? 0 : columns_count));
    ImGuiID id = window->GetID(str_id ? str_id : "columns");
    PopID();

    // Acquire storage for the columns set
    ImGuiColumnsSet* columns = FindOrAddColumnsSet(window, id);
    IM_ASSERT(columns->ID == id);
    columns->Current = 0;
    columns->Count = columns_count;
    columns->Flags = flags;
    window->DC.ColumnsSet = columns;

    // Set state for first column
    const float content_region_width = (window->SizeContentsExplicit.x != 0.0f) ? (window->SizeContentsExplicit.x) : (window->InnerClipRect.Max.x - window->Pos.x);
    columns->MinX = window->DC.Indent.x - g.Style.ItemSpacing.x; // Lock our horizontal range
    columns->MaxX = ImMax(content_region_width - window->Scroll.x, columns->MinX + 1.0f);
    columns->LoopCallbackPosY = window->DC.CursorPos.y;
    columns->LoopCallbackMaxPosX = window->DC.CursorMaxPos.x;
    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

    // Clear data if columns count changed
    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
        columns->Columns.resize(0);

    // Initialize defaults
    columns->IsFirstFrame = (columns->Columns.Size == 0);
    if (columns->Columns.Size == 0)
    {
        columns->Columns.reserve(columns_count + 1);
        for (int n = 0; n < columns_count + 1; n++)
        {
            ImGuiColumnData column;
            column.OffsetNorm = n / (float)columns_count;
            columns->Columns.push_back(column);
        }
    }

    for (int n = 0; n < columns_count; n++)
    {
        // Compute clipping rectangle
        ImGuiColumnData* column = &columns->Columns[n];
        float clip_x1 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n) - 1.0f);
        float clip_x2 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
        column->ClipRect.ClipWith(window->ClipRect);
    }

    window->DrawList->ChannelsSplit(columns->Count);
    PushColumnClipRect();
    PushItemWidth(GetColumnWidth() * 0.65f);
}

void ImGui::EndColumns()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    PopItemWidth();
    PopClipRect();
    window->DrawList->ChannelsMerge();

    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    window->DC.CursorPos.y = columns->LineMaxY;
    if (!(columns->Flags & ImGuiColumnsFlags_GrowParentContentsSize))
        window->DC.CursorMaxPos.x = columns->LoopCallbackMaxPosX;  // Restore cursor max pos, as columns don't grow parent

    // Draw columns borders and handle resize
    bool is_being_resized = false;
    if (!(columns->Flags & ImGuiColumnsFlags_NoBorder) && !window->SkipItems)
    {
        const float y1 = columns->LoopCallbackPosY;
        const float y2 = window->DC.CursorPos.y;
        int dragging_column = -1;
        for (int n = 1; n < columns->Count; n++)
        {
            float x = window->Pos.x + GetColumnOffset(n);
            const ImGuiID column_id = columns->ID + ImGuiID(n);
            const float column_hw = GetColumnsRectHalfWidth(); // Half-width for interaction
            const ImRect column_rect(ImVec2(x - column_hw, y1), ImVec2(x + column_hw, y2));
            KeepAliveID(column_id);
            if (IsClippedEx(column_rect, column_id, false))
                continue;

            bool hovered = false, held = false;
            if (!(columns->Flags & ImGuiColumnsFlags_NoResize))
            {
                ButtonBehavior(column_rect, column_id, &hovered, &held);
                if (hovered || held)
                    g.MouseCursor = ImGuiMouseCursor_ResizeEW;
                if (held && !(columns->Columns[n].Flags & ImGuiColumnsFlags_NoResize))
                    dragging_column = n;
            }

            // Draw column (we clip the Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.)
            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
            const float xi = (float)(int)x;
            window->DrawList->AddLine(ImVec2(xi, ImMax(y1 + 1.0f, window->ClipRect.Min.y)), ImVec2(xi, ImMin(y2, window->ClipRect.Max.y)), col);
        }

        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
        if (dragging_column != -1)
        {
            if (!columns->IsBeingResized)
                for (int n = 0; n < columns->Count + 1; n++)
                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;
            columns->IsBeingResized = is_being_resized = true;
            float x = GetDraggedColumnOffset(columns, dragging_column);
            SetColumnOffset(dragging_column, x);
        }
    }
    columns->IsBeingResized = is_being_resized;

    window->DC.ColumnsSet = NULL;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
}

// [2018-03: This is currently the only public API, while we are working on making BeginColumns/EndColumns user-facing]
void ImGui::Columns(int columns_count, const char* id, bool border)
{
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(columns_count >= 1);

    ImGuiColumnsFlags flags = (border ? 0 : ImGuiColumnsFlags_NoBorder);
    //flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior
    if (window->DC.ColumnsSet != NULL && window->DC.ColumnsSet->Count == columns_count && window->DC.ColumnsSet->Flags == flags)
        return;

    if (window->DC.ColumnsSet != NULL)
        EndColumns();

    if (columns_count != 1)
        BeginColumns(id, columns_count, flags);
}

//-----------------------------------------------------------------------------
// [SECTION] DRAG AND DROP
//-----------------------------------------------------------------------------

void ImGui::ClearDragDrop()
{
    ImGuiContext& g = *GImGui;
    g.DragDropActive = false;
    g.DragDropPayload.Clear();
    g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropAcceptFrameCount = -1;

    g.DragDropPayloadBufHeap.clear();
    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
}

// Call when current ID is active.
// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
bool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    bool source_drag_active = false;
    ImGuiID source_id = 0;
    ImGuiID source_parent_id = 0;
    int mouse_button = 0;
    if (!(flags & ImGuiDragDropFlags_SourceExtern))
    {
        source_id = window->DC.LastItemId;
        if (source_id != 0 && g.ActiveId != source_id) // Early out for most common case
            return false;
        if (g.IO.MouseDown[mouse_button] == false)
            return false;

        if (source_id == 0)
        {
            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.
            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
            {
                IM_ASSERT(0);
                return false;
            }

            // Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()
            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
            bool is_hovered = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) != 0;
            if (!is_hovered && (g.ActiveId == 0 || g.ActiveIdWindow != window))
                return false;
            source_id = window->DC.LastItemId = window->GetIDFromRectangle(window->DC.LastItemRect);
            if (is_hovered)
                SetHoveredID(source_id);
            if (is_hovered && g.IO.MouseClicked[mouse_button])
            {
                SetActiveID(source_id, window);
                FocusWindow(window);
            }
            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
                g.ActiveIdAllowOverlap = is_hovered;
        }
        else
        {
            g.ActiveIdAllowOverlap = false;
        }
        if (g.ActiveId != source_id)
            return false;
        source_parent_id = window->IDStack.back();
        source_drag_active = IsMouseDragging(mouse_button);
    }
    else
    {
        window = NULL;
        source_id = ImHash("#SourceExtern", 0);
        source_drag_active = true;
    }

    if (source_drag_active)
    {
        if (!g.DragDropActive)
        {
            IM_ASSERT(source_id != 0);
            ClearDragDrop();
            ImGuiPayload& payload = g.DragDropPayload;
            payload.SourceId = source_id;
            payload.SourceParentId = source_parent_id;
            g.DragDropActive = true;
            g.DragDropSourceFlags = flags;
            g.DragDropMouseButton = mouse_button;
        }
        g.DragDropSourceFrameCount = g.FrameCount;
        g.DragDropWithinSourceOrTarget = true;

        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        {
            // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
            // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents. 
            BeginTooltip();
            if (g.DragDropActive && g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
            {
                ImGuiWindow* tooltip_window = g.CurrentWindow;
                tooltip_window->SkipItems = true;
                tooltip_window->HiddenFramesRegular = 1;
            }
        }

        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
            window->DC.LastItemStatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;

        return true;
    }
    return false;
}

void ImGui::EndDragDropSource()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinSourceOrTarget && "Not after a BeginDragDropSource()?");

    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        EndTooltip();

    // Discard the drag if have not called SetDragDropPayload()
    if (g.DragDropPayload.DataFrameCount == -1)
        ClearDragDrop();
    g.DragDropWithinSourceOrTarget = false;
}

// Use 'cond' to choose to submit payload on drag start or every frame
bool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    ImGuiPayload& payload = g.DragDropPayload;
    if (cond == 0)
        cond = ImGuiCond_Always;

    IM_ASSERT(type != NULL);
    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
    IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()

    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
    {
        // Copy payload
        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
        g.DragDropPayloadBufHeap.resize(0);
        if (data_size > sizeof(g.DragDropPayloadBufLocal))
        {
            // Store in heap
            g.DragDropPayloadBufHeap.resize((int)data_size);
            payload.Data = g.DragDropPayloadBufHeap.Data;
            memcpy(payload.Data, data, data_size);
        }
        else if (data_size > 0)
        {
            // Store locally
            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
            payload.Data = g.DragDropPayloadBufLocal;
            memcpy(payload.Data, data, data_size);
        }
        else
        {
            payload.Data = NULL;
        }
        payload.DataSize = (int)data_size;
    }
    payload.DataFrameCount = g.FrameCount;

    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
}

bool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
        return false;
    IM_ASSERT(id != 0);
    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
        return false;
    if (window->SkipItems)
        return false;

    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
    g.DragDropTargetRect = bb;
    g.DragDropTargetId = id;
    g.DragDropWithinSourceOrTarget = true;
    return true;
}

// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemRectHoveredRect which handles items that pushes a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
bool ImGui::BeginDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))
        return false;
    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
        return false;

    const ImRect& display_rect = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? window->DC.LastItemDisplayRect : window->DC.LastItemRect;
    ImGuiID id = window->DC.LastItemId;
    if (id == 0)
        id = window->GetIDFromRectangle(display_rect);
    if (g.DragDropPayload.SourceId == id)
        return false;

    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
    g.DragDropTargetRect = display_rect;
    g.DragDropTargetId = id;
    g.DragDropWithinSourceOrTarget = true;
    return true;
}

bool ImGui::IsDragDropPayloadBeingAccepted()
{
    ImGuiContext& g = *GImGui;
    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
}

const ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiPayload& payload = g.DragDropPayload;
    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
    if (type != NULL && !payload.IsDataType(type))
        return NULL;

    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
    ImRect r = g.DragDropTargetRect;
    float r_surface = r.GetWidth() * r.GetHeight();
    if (r_surface < g.DragDropAcceptIdCurrRectSurface)
    {
        g.DragDropAcceptFlags = flags;
        g.DragDropAcceptIdCurr = g.DragDropTargetId;
        g.DragDropAcceptIdCurrRectSurface = r_surface;
    }

    // Render default drop visuals
    payload.Preview = was_accepted_previously;
    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)
    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
    {
        // FIXME-DRAG: Settle on a proper default visuals for drop target.
        r.Expand(3.5f);
        bool push_clip_rect = !window->ClipRect.Contains(r);
        if (push_clip_rect) window->DrawList->PushClipRect(r.Min-ImVec2(1,1), r.Max+ImVec2(1,1));
        window->DrawList->AddRect(r.Min, r.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, ~0, 2.0f);
        if (push_clip_rect) window->DrawList->PopClipRect();
    }

    g.DragDropAcceptFrameCount = g.FrameCount;
    payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))
        return NULL;

    return &payload;
}

const ImGuiPayload* ImGui::GetDragDropPayload()
{
    ImGuiContext& g = *GImGui;
    return g.DragDropActive ? &g.DragDropPayload : NULL;
}

// We don't really use/need this now, but added it for the sake of consistency and because we might need it later.
void ImGui::EndDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinSourceOrTarget);
    g.DragDropWithinSourceOrTarget = false;
}

//-----------------------------------------------------------------------------
// [SECTION] DOCKING
//-----------------------------------------------------------------------------

// (this section is filled in the 'docking' branch)

//-----------------------------------------------------------------------------
// [SECTION] LOGGING/CAPTURING
//-----------------------------------------------------------------------------

// Pass text data straight to log (without being displayed)
void ImGui::LogText(const char* fmt, ...)
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    va_list args;
    va_start(args, fmt);
    if (g.LogFile)
        vfprintf(g.LogFile, fmt, args);
    else
        g.LogClipboard.appendfv(fmt, args);
    va_end(args);
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
void ImGui::LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = FindRenderedTextEnd(text, text_end);

    const bool log_new_line = ref_pos && (ref_pos->y > window->DC.LogLinePosY + 1);
    if (ref_pos)
        window->DC.LogLinePosY = ref_pos->y;

    const char* text_remaining = text;
    if (g.LogLoopCallbackDepth > window->DC.TreeDepth)  // Re-adjust padding if we have popped out of our starting depth
        g.LogLoopCallbackDepth = window->DC.TreeDepth;
    const int tree_depth = (window->DC.TreeDepth - g.LogLoopCallbackDepth);
    for (;;)
    {
        // Split the string. Each new line (after a '\n') is followed by spacing corresponding to the current depth of our log entry.
        const char* line_start = text_remaining;
        const char* line_end = ImStreolRange(line_start, text_end);
        const bool is_first_line = (line_start == text);
        const bool is_last_line = (line_end == text_end);
        if (!is_last_line || (line_start != line_end))
        {
            const int char_count = (int)(line_end - line_start);
            if (log_new_line || !is_first_line)
                LogText(IM_NEWLINE "%*s%.*s", tree_depth*4, "", char_count, line_start);
            else
                LogText(" %.*s", char_count, line_start);
        }

        if (is_last_line)
            break;
        text_remaining = line_end + 1;
    }
}

// LoopCallback logging ImGui output to TTY
void ImGui::LogToTTY(int max_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    ImGuiWindow* window = g.CurrentWindow;

    IM_ASSERT(g.LogFile == NULL);
    g.LogFile = stdout;
    g.LogEnabled = true;
    g.LogLoopCallbackDepth = window->DC.TreeDepth;
    if (max_depth >= 0)
        g.LogAutoExpandMaxDepth = max_depth;
}

// LoopCallback logging ImGui output to given file
void ImGui::LogToFile(int max_depth, const char* filename)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    ImGuiWindow* window = g.CurrentWindow;

    if (!filename)
    {
        filename = g.IO.LogFilename;
        if (!filename)
            return;
    }

    IM_ASSERT(g.LogFile == NULL);
    g.LogFile = ImFileOpen(filename, "ab");
    if (!g.LogFile)
    {
        IM_ASSERT(g.LogFile != NULL); // Consider this an error
        return;
    }
    g.LogEnabled = true;
    g.LogLoopCallbackDepth = window->DC.TreeDepth;
    if (max_depth >= 0)
        g.LogAutoExpandMaxDepth = max_depth;
}

// LoopCallback logging ImGui output to clipboard
void ImGui::LogToClipboard(int max_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    ImGuiWindow* window = g.CurrentWindow;

    IM_ASSERT(g.LogFile == NULL);
    g.LogFile = NULL;
    g.LogEnabled = true;
    g.LogLoopCallbackDepth = window->DC.TreeDepth;
    if (max_depth >= 0)
        g.LogAutoExpandMaxDepth = max_depth;
}

void ImGui::LogFinish()
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    LogText(IM_NEWLINE);
    if (g.LogFile != NULL)
    {
        if (g.LogFile == stdout)
            fflush(g.LogFile);
        else
            fclose(g.LogFile);
        g.LogFile = NULL;
    }
    if (g.LogClipboard.size() > 1)
    {
        SetClipboardText(g.LogClipboard.begin());
        g.LogClipboard.clear();
    }
    g.LogEnabled = false;
}

// Helper to display logging buttons
void ImGui::LogButtons()
{
    ImGuiContext& g = *GImGui;

    PushID("LogButtons");
    const bool log_to_tty = Button("Log To TTY"); SameLine();
    const bool log_to_file = Button("Log To File"); SameLine();
    const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();
    PushItemWidth(80.0f);
    PushAllowKeyboardFocus(false);
    SliderInt("Depth", &g.LogAutoExpandMaxDepth, 0, 9, NULL);
    PopAllowKeyboardFocus();
    PopItemWidth();
    PopID();

    // LoopCallback logging at the end of the function so that the buttons don't appear in the log
    if (log_to_tty)
        LogToTTY(g.LogAutoExpandMaxDepth);
    if (log_to_file)
        LogToFile(g.LogAutoExpandMaxDepth, g.IO.LogFilename);
    if (log_to_clipboard)
        LogToClipboard(g.LogAutoExpandMaxDepth);
}

//-----------------------------------------------------------------------------
// [SECTION] SETTINGS
//-----------------------------------------------------------------------------

void ImGui::MarkIniSettingsDirty()
{
    ImGuiContext& g = *GImGui;
    if (g.SettingsDirtyTimer <= 0.0f)
        g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

void ImGui::MarkIniSettingsDirty(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
        if (g.SettingsDirtyTimer <= 0.0f)
            g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

ImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)
{
    ImGuiContext& g = *GImGui;
    g.SettingsWindows.push_back(ImGuiWindowSettings());
    ImGuiWindowSettings* settings = &g.SettingsWindows.back();
    settings->Name = ImStrdup(name);
    settings->ID = ImHash(name, 0);
    return settings;
}

ImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    for (int i = 0; i != g.SettingsWindows.Size; i++)
        if (g.SettingsWindows[i].ID == id)
            return &g.SettingsWindows[i];
    return NULL;
}

void ImGui::LoadIniSettingsFromDisk(const char* ini_filename)
{
    size_t file_data_size = 0;
    char* file_data = (char*)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);
    if (!file_data)
        return;
    LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
    ImGui::MemFree(file_data);
}

ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)
{
    ImGuiContext& g = *GImGui;
    const ImGuiID type_hash = ImHash(type_name, 0, 0);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)
            return &g.SettingsHandlers[handler_n];
    return NULL;
}

// Zero-tolerance, no error reporting, cheap .ini parsing
void ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);
    IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);

    // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
    // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
    if (ini_size == 0)
        ini_size = strlen(ini_data);
    char* buf = (char*)ImGui::MemAlloc(ini_size + 1);
    char* buf_end = buf + ini_size;
    memcpy(buf, ini_data, ini_size);
    buf[ini_size] = 0;

    void* entry_data = NULL;
    ImGuiSettingsHandler* entry_handler = NULL;

    char* line_end = NULL;
    for (char* line = buf; line < buf_end; line = line_end + 1)
    {
        // Skip new lines markers, then find end of the line
        while (*line == '\n' || *line == '\r')
            line++;
        line_end = line;
        while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
            line_end++;
        line_end[0] = 0;
        if (line[0] == ';')
            continue;
        if (line[0] == '[' && line_end > line && line_end[-1] == ']')
        {
            // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
            line_end[-1] = 0;
            const char* name_end = line_end - 1;
            const char* type_start = line + 1;
            char* type_end = (char*)(intptr_t)ImStrchrRange(type_start, name_end, ']');
            const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;
            if (!type_end || !name_start)
            {
                name_start = type_start; // Import legacy entries that have no type
                type_start = "Window";
            }
            else
            {
                *type_end = 0; // Overwrite first ']'
                name_start++;  // Skip second '['
            }
            entry_handler = FindSettingsHandler(type_start);
            entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;
        }
        else if (entry_handler != NULL && entry_data != NULL)
        {
            // Let type handler parse the line
            entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
        }
    }
    ImGui::MemFree(buf);
    g.SettingsLoaded = true;
}

void ImGui::SaveIniSettingsToDisk(const char* ini_filename)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    if (!ini_filename)
        return;

    size_t ini_data_size = 0;
    const char* ini_data = SaveIniSettingsToMemory(&ini_data_size);
    FILE* f = ImFileOpen(ini_filename, "wt");
    if (!f)
        return;
    fwrite(ini_data, sizeof(char), ini_data_size, f);
    fclose(f);
}

// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
const char* ImGui::SaveIniSettingsToMemory(size_t* out_size)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    g.SettingsIniData.Buf.resize(0);
    g.SettingsIniData.Buf.push_back(0);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
    {
        ImGuiSettingsHandler* handler = &g.SettingsHandlers[handler_n];
        handler->WriteAllFn(&g, handler, &g.SettingsIniData);
    }
    if (out_size)
        *out_size = (size_t)g.SettingsIniData.size();
    return g.SettingsIniData.c_str();
}

static void* SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
{
    ImGuiWindowSettings* settings = ImGui::FindWindowSettings(ImHash(name, 0));
    if (!settings)
        settings = ImGui::CreateNewWindowSettings(name);
    return (void*)settings;
}

static void SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
{
    ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;
    float x, y;
    int i;
    if (sscanf(line, "Pos=%f,%f", &x, &y) == 2)         settings->Pos = ImVec2(x, y);
    else if (sscanf(line, "Size=%f,%f", &x, &y) == 2)   settings->Size = ImMax(ImVec2(x, y), GImGui->Style.WindowMinSize);
    else if (sscanf(line, "Collapsed=%d", &i) == 1)     settings->Collapsed = (i != 0);
}

static void SettingsHandlerWindow_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
{
    // Gather data from windows that were active during this session
    // (if a window wasn't opened in this session we preserve its settings)
    ImGuiContext& g = *imgui_ctx;
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)
            continue;

        ImGuiWindowSettings* settings = (window->SettingsIdx != -1) ? &g.SettingsWindows[window->SettingsIdx] : ImGui::FindWindowSettings(window->ID);
        if (!settings)
        {
            settings = ImGui::CreateNewWindowSettings(window->Name);
            window->SettingsIdx = g.SettingsWindows.index_from_pointer(settings);
        }
        IM_ASSERT(settings->ID == window->ID);
        settings->Pos = window->Pos;
        settings->Size = window->SizeFull;
        settings->Collapsed = window->Collapsed;
    }

    // Write to text buffer
    buf->reserve(buf->size() + g.SettingsWindows.Size * 96); // ballpark reserve
    for (int i = 0; i != g.SettingsWindows.Size; i++)
    {
        const ImGuiWindowSettings* settings = &g.SettingsWindows[i];
        if (settings->Pos.x == FLT_MAX)
            continue;
        const char* name = settings->Name;
        if (const char* p = strstr(name, "###"))  // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
            name = p;
        buf->appendf("[%s][%s]\n", handler->TypeName, name);
        buf->appendf("Pos=%d,%d\n", (int)settings->Pos.x, (int)settings->Pos.y);
        buf->appendf("Size=%d,%d\n", (int)settings->Size.x, (int)settings->Size.y);
        buf->appendf("Collapsed=%d\n", settings->Collapsed);
        buf->appendf("\n");
    }
}

//-----------------------------------------------------------------------------
// [SECTION] PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------

#if defined(_WIN32) && !defined(_WINDOWS_) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && (!defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) || !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS))
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef __MINGW32__
#include <Windows.h>
#else
#include <windows.h>
#endif
#endif

// Win32 API clipboard implementation
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)

#ifdef _MSC_VER
#pragma comment(lib, "user32")
#endif

static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    static ImVector<char> buf_local;
    buf_local.clear();
    if (!::OpenClipboard(NULL))
        return NULL;
    HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return NULL;
    }
    if (ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle))
    {
        int buf_len = ImTextCountUtf8BytesFromStr(wbuf_global, NULL) + 1;
        buf_local.resize(buf_len);
        ImTextStrToUtf8(buf_local.Data, buf_len, wbuf_global, NULL);
    }
    ::GlobalUnlock(wbuf_handle);
    ::CloseClipboard();
    return buf_local.Data;
}

static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    if (!::OpenClipboard(NULL))
        return;
    const int wbuf_length = ImTextCountCharsFromUtf8(text, NULL) + 1;
    HGLOBAL wbuf_handle = ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(ImWchar));
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return;
    }
    ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle);
    ImTextStrFromUtf8(wbuf_global, wbuf_length, text, NULL);
    ::GlobalUnlock(wbuf_handle);
    ::EmptyClipboard();
    if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)
        ::GlobalFree(wbuf_handle);
    ::CloseClipboard();
}

#else

// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers
static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    ImGuiContext& g = *GImGui;
    return g.PrivateClipboard.empty() ? NULL : g.PrivateClipboard.begin();
}

// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers
static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    ImGuiContext& g = *GImGui;
    g.PrivateClipboard.clear();
    const char* text_end = text + strlen(text);
    g.PrivateClipboard.resize((int)(text_end - text) + 1);
    memcpy(&g.PrivateClipboard[0], text, (size_t)(text_end - text));
    g.PrivateClipboard[(int)(text_end - text)] = 0;
}

#endif

// Win32 API IME support (for Asian languages, etc.)
#if defined(_WIN32) && !defined(__GNUC__) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)

#include <imm.h>
#ifdef _MSC_VER
#pragma comment(lib, "imm32")
#endif

static void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)
{
    // Notify OS Input Method Editor of text input position
    if (HWND hwnd = (HWND)GImGui->IO.ImeWindowHandle)
        if (HIMC himc = ::ImmGetContext(hwnd))
        {
            COMPOSITIONFORM cf;
            cf.ptCurrentPos.x = x;
            cf.ptCurrentPos.y = y;
            cf.dwStyle = CFS_FORCE_POSITION;
            ::ImmSetCompositionWindow(himc, &cf);
            ::ImmReleaseContext(hwnd, himc);
        }
}

#else

static void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}

#endif

//-----------------------------------------------------------------------------
// [SECTION] METRICS/DEBUG WINDOW
//-----------------------------------------------------------------------------

void ImGui::ShowMetricsWindow(bool* p_open)
{
    if (!ImGui::Begin("ImGui Metrics", p_open))
    {
        ImGui::End();
        return;
    }

    static bool show_draw_cmd_clip_rects = true;
    static bool show_window_begin_order = false;
    ImGuiIO& io = ImGui::GetIO();
    ImGui::Text("Dear ImGui %s", ImGui::GetVersion());
    ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
    ImGui::Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);
    ImGui::Text("%d active windows (%d visible)", io.MetricsActiveWindows, io.MetricsRenderWindows);
    ImGui::Text("%d allocations", io.MetricsActiveAllocations);
    ImGui::Checkbox("Show clipping rectangles when hovering draw commands", &show_draw_cmd_clip_rects);
    ImGui::Checkbox("Ctrl shows window begin order", &show_window_begin_order);
    ImGui::Separator();

    struct Funcs
    {
        static void NodeDrawList(ImGuiWindow* window, ImDrawList* draw_list, const char* label)
        {
            bool node_open = ImGui::TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);
            if (draw_list == ImGui::GetWindowDrawList())
            {
                ImGui::SameLine();
                ImGui::TextColored(ImColor(255,100,100), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
                if (node_open) ImGui::TreePop();
                return;
            }

            ImDrawList* overlay_draw_list = GetOverlayDrawList(window); // Render additional visuals into the top-most draw list
            if (window && IsItemHovered())
                overlay_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
            if (!node_open)
                return;

            int elem_offset = 0;
            for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)
            {
                if (pcmd->UserCallback == NULL && pcmd->ElemCount == 0)
                    continue;
                if (pcmd->UserCallback)
                {
                    ImGui::BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
                    continue;
                }
                ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
                bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "Draw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0f)", pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? "indexed" : "non-indexed", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
                if (show_draw_cmd_clip_rects && ImGui::IsItemHovered())
                {
                    ImRect clip_rect = pcmd->ClipRect;
                    ImRect vtxs_rect;
                    for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)
                        vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);
                    clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));
                    vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));
                }
                if (!pcmd_node_open)
                    continue;

                // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
                ImGuiListClipper clipper(pcmd->ElemCount/3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
                while (clipper.Step())
                    for (int prim = clipper.DisplayLoopCallback, vtx_i = elem_offset + clipper.DisplayLoopCallback*3; prim < clipper.DisplayEnd; prim++)
                    {
                        char buf[300];
                        char *buf_p = buf, *buf_end = buf + IM_ARRAYSIZE(buf);
                        ImVec2 triangles_pos[3];
                        for (int n = 0; n < 3; n++, vtx_i++)
                        {
                            ImDrawVert& v = draw_list->VtxBuffer[idx_buffer ? idx_buffer[vtx_i] : vtx_i];
                            triangles_pos[n] = v.pos;
                            buf_p += ImFormatString(buf_p, (int)(buf_end - buf_p), "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n", (n == 0) ? "vtx" : "   ", vtx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
                        }
                        ImGui::Selectable(buf, false);
                        if (ImGui::IsItemHovered())
                        {
                            ImDrawListFlags backup_flags = overlay_draw_list->Flags;
                            overlay_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines at is more readable for very large and thin triangles.
                            overlay_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255,255,0,255), true, 1.0f);
                            overlay_draw_list->Flags = backup_flags;
                        }
                    }
                ImGui::TreePop();
            }
            ImGui::TreePop();
        }

        static void NodeWindows(ImVector<ImGuiWindow*>& windows, const char* label)
        {
            if (!ImGui::TreeNode(label, "%s (%d)", label, windows.Size))
                return;
            for (int i = 0; i < windows.Size; i++)
                Funcs::NodeWindow(windows[i], "Window");
            ImGui::TreePop();
        }

        static void NodeWindow(ImGuiWindow* window, const char* label)
        {
            if (!ImGui::TreeNode(window, "%s '%s', %d @ 0x%p", label, window->Name, window->Active || window->WasActive, window))
                return;
            ImGuiWindowFlags flags = window->Flags;
            NodeDrawList(window, window->DrawList, "DrawList");
            ImGui::BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);
            ImGui::BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags,
                (flags & ImGuiWindowFlags_ChildWindow)  ? "Child " : "",      (flags & ImGuiWindowFlags_Tooltip)     ? "Tooltip "   : "",  (flags & ImGuiWindowFlags_Popup) ? "Popup " : "",
                (flags & ImGuiWindowFlags_Modal)        ? "Modal " : "",      (flags & ImGuiWindowFlags_ChildMenu)   ? "ChildMenu " : "",  (flags & ImGuiWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "",
                (flags & ImGuiWindowFlags_NoMouseInputs)? "NoMouseInputs":"", (flags & ImGuiWindowFlags_NoNavInputs) ? "NoNavInputs" : "", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "");
            ImGui::BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f)", window->Scroll.x, GetWindowScrollMaxX(window), window->Scroll.y, GetWindowScrollMaxY(window));
            ImGui::BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);
            ImGui::BulletText("Appearing: %d, Hidden: %d (Reg %d Resize %d), SkipItems: %d", window->Appearing, window->Hidden, window->HiddenFramesRegular, window->HiddenFramesForResize, window->SkipItems);
            ImGui::BulletText("NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X", window->NavLastIds[0], window->NavLastIds[1], window->DC.NavLayerActiveMask);
            ImGui::BulletText("NavLastChildNavWindow: %s", window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL");
            if (!window->NavRectRel[0].IsInverted())
                ImGui::BulletText("NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)", window->NavRectRel[0].Min.x, window->NavRectRel[0].Min.y, window->NavRectRel[0].Max.x, window->NavRectRel[0].Max.y);
            else
                ImGui::BulletText("NavRectRel[0]: <None>");
            if (window->RootWindow != window) NodeWindow(window->RootWindow, "RootWindow");
            if (window->ParentWindow != NULL) NodeWindow(window->ParentWindow, "ParentWindow");
            if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, "ChildWindows");
            if (window->ColumnsStorage.Size > 0 && ImGui::TreeNode("Columns", "Columns sets (%d)", window->ColumnsStorage.Size))
            {
                for (int n = 0; n < window->ColumnsStorage.Size; n++)
                {
                    const ImGuiColumnsSet* columns = &window->ColumnsStorage[n];
                    if (ImGui::TreeNode((void*)(uintptr_t)columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags))
                    {
                        ImGui::BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns->MaxX - columns->MinX, columns->MinX, columns->MaxX);
                        for (int column_n = 0; column_n < columns->Columns.Size; column_n++)
                            ImGui::BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", column_n, columns->Columns[column_n].OffsetNorm, OffsetNormToPixels(columns, columns->Columns[column_n].OffsetNorm));
                        ImGui::TreePop();
                    }
                }
                ImGui::TreePop();
            }
            ImGui::BulletText("Storage: %d bytes", window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));
            ImGui::TreePop();
        }

        static void NodeTabBar(ImGuiTabBar* tab_bar)
        {
            // Standalone tab bars (not associated to docking/windows functionality) currently hold no discernable strings.
            char buf[256];
            char* p = buf;
            const char* buf_end = buf + IM_ARRAYSIZE(buf);
            p += ImFormatString(p, buf_end - p, "TabBar (%d tabs)%s",
                tab_bar->Tabs.Size, (tab_bar->PrevFrameVisible < ImGui::GetFrameCount() - 2) ? " *Inactive*" : "");
            if (ImGui::TreeNode(tab_bar, "%s", buf))
            {
                for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
                {
                    const ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
                    ImGui::PushID(tab);
                    if (ImGui::SmallButton("<")) { TabBarQueueChangeTabOrder(tab_bar, tab, -1); } ImGui::SameLine(0, 2);
                    if (ImGui::SmallButton(">")) { TabBarQueueChangeTabOrder(tab_bar, tab, +1); } ImGui::SameLine();
                    ImGui::Text("%02d%c Tab 0x%08X", tab_n, (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID);
                    ImGui::PopID();
                }
                ImGui::TreePop();
            }
        }
    };

    // Access private state, we are going to display the draw lists from last frame
    ImGuiContext& g = *GImGui;
    Funcs::NodeWindows(g.Windows, "Windows");
    if (ImGui::TreeNode("DrawList", "Active DrawLists (%d)", g.DrawDataBuilder.Layers[0].Size))
    {
        for (int i = 0; i < g.DrawDataBuilder.Layers[0].Size; i++)
            Funcs::NodeDrawList(NULL, g.DrawDataBuilder.Layers[0][i], "DrawList");
        ImGui::TreePop();
    }
    if (ImGui::TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size))
    {
        for (int i = 0; i < g.OpenPopupStack.Size; i++)
        {
            ImGuiWindow* window = g.OpenPopupStack[i].Window;
            ImGui::BulletText("PopupID: %08x, Window: '%s'%s%s", g.OpenPopupStack[i].PopupId, window ? window->Name : "NULL", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? " ChildWindow" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? " ChildMenu" : "");
        }
        ImGui::TreePop();
    }
    if (ImGui::TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.Data.Size))
    {
        for (int n = 0; n < g.TabBars.Data.Size; n++)
            Funcs::NodeTabBar(g.TabBars.GetByIndex(n));
        ImGui::TreePop();
    }
    if (ImGui::TreeNode("Internal state"))
    {
        const char* input_source_names[] = { "None", "Mouse", "Nav", "NavKeyboard", "NavGamepad" }; IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_COUNT);
        ImGui::Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");
        ImGui::Text("HoveredRootWindow: '%s'", g.HoveredRootWindow ? g.HoveredRootWindow->Name : "NULL");
        ImGui::Text("HoveredId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Data is "in-flight" so depending on when the Metrics window is called we may see current frame information or not
        ImGui::Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, input_source_names[g.ActiveIdSource]);
        ImGui::Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");
        ImGui::Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");
        ImGui::Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");
        ImGui::Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
        ImGui::Text("NavInputSource: %s", input_source_names[g.NavInputSource]);
        ImGui::Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
        ImGui::Text("NavActivateId: 0x%08X, NavInputId: 0x%08X", g.NavActivateId, g.NavInputId);
        ImGui::Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);
        ImGui::Text("NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL");
        ImGui::Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
        ImGui::TreePop();
    }


    if (g.IO.KeyCtrl && show_window_begin_order)
    {
        for (int n = 0; n < g.Windows.Size; n++)
        {
            ImGuiWindow* window = g.Windows[n];
            if ((window->Flags & ImGuiWindowFlags_ChildWindow) || !window->WasActive)
                continue;
            char buf[32];
            ImFormatString(buf, IM_ARRAYSIZE(buf), "%d", window->BeginOrderWithinContext);
            float font_size = ImGui::GetFontSize() * 2;
            ImDrawList* overlay_draw_list = GetOverlayDrawList(window);
            overlay_draw_list->AddRectFilled(window->Pos, window->Pos + ImVec2(font_size, font_size), IM_COL32(200, 100, 100, 255));
            overlay_draw_list->AddText(NULL, font_size, window->Pos, IM_COL32(255, 255, 255, 255), buf);
        }
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------

// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.
// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.
#ifdef IMGUI_INCLUDE_IMGUI_USER_INL
#include "imgui_user.inl"
#endif

//-----------------------------------------------------------------------------

```

`Private Esp/imgui/imgui.h`:

```h
// dear imgui, v1.67 WIP
// (headers)

// See imgui.cpp file for documentation.
// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.
// Read 'Programmer guide' in imgui.cpp for notes on how to setup ImGui in your codebase.
// Get latest version at https://github.com/ocornut/imgui

/*

Index of this file:
// Header mess
// Forward declarations and basic types
// ImGui API (Dear ImGui end-user API)
// Flags & Enumerations
// ImGuiStyle
// ImGuiIO
// Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)
// Obsolete functions
// Helpers (ImVector, ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor)
// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)
// Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFont)

*/

#pragma once

// Configuration file (edit imconfig.h or define IMGUI_USER_CONFIG to your own filename)
#ifdef IMGUI_USER_CONFIG
#include IMGUI_USER_CONFIG
#endif
#if !defined(IMGUI_DISABLE_INCLUDE_IMCONFIG_H) || defined(IMGUI_INCLUDE_IMCONFIG_H)
#include "imconfig.h"
#endif

//-----------------------------------------------------------------------------
// Header mess
//-----------------------------------------------------------------------------

#include <float.h>                  // FLT_MAX
#include <stdarg.h>                 // va_list
#include <stddef.h>                 // ptrdiff_t, NULL
#include <string.h>                 // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp

// Version
// (Integer encoded as XYYZZ for use in #if preprocessor conditionals. Work in progress versions typically starts at XYY00 then bounced up to XYY01 when release tagging happens)
#define IMGUI_VERSION               "1.67 WIP"
#define IMGUI_VERSION_NUM           16602
#define IMGUI_CHECKVERSION()        ImGui::DebugCheckVersionAndDataLayout(IMGUI_VERSION, sizeof(ImGuiIO), sizeof(ImGuiStyle), sizeof(ImVec2), sizeof(ImVec4), sizeof(ImDrawVert))

// Define attributes of all API symbols declarations (e.g. for DLL under Windows)
// IMGUI_API is used for core imgui functions, IMGUI_IMPL_API is used for the default bindings files (imgui_impl_xxx.h)
#ifndef IMGUI_API
#define IMGUI_API
#endif
#ifndef IMGUI_IMPL_API
#define IMGUI_IMPL_API              IMGUI_API
#endif

// Helper Macros
#ifndef IM_ASSERT
#include <assert.h>
#define IM_ASSERT(_EXPR)            assert(_EXPR)                               // You can override the default assert handler by editing imconfig.h
#endif
#if defined(__clang__) || defined(__GNUC__)
#define IM_FMTARGS(FMT)             __attribute__((format(printf, FMT, FMT+1))) // Apply printf-style warnings to user functions.
#define IM_FMTLIST(FMT)             __attribute__((format(printf, FMT, 0)))
#else
#define IM_FMTARGS(FMT)
#define IM_FMTLIST(FMT)
#endif
#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR)/sizeof(*_ARR)))         // Size of a static C-style array. Don't use on pointers!
#define IM_OFFSETOF(_TYPE,_MEMBER)  ((size_t)&(((_TYPE*)0)->_MEMBER))           // Offset of _MEMBER within _TYPE. Standardized as offsetof() in modern C++.

// Warnings
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wold-style-cast"
#elif defined(__GNUC__) && __GNUC__ >= 8
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wclass-memaccess"
#endif

//-----------------------------------------------------------------------------
// Forward declarations and basic types
//-----------------------------------------------------------------------------

struct ImDrawChannel;               // Temporary storage for outputting drawing commands out of order, used by ImDrawList::ChannelsSplit()
struct ImDrawCmd;                   // A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call)
struct ImDrawData;                  // All draw command lists required to render the frame
struct ImDrawList;                  // A single draw command list (generally one per window, conceptually you may see this as a dynamic "mesh" builder)
struct ImDrawListSharedData;        // Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)
struct ImDrawVert;                  // A single vertex (20 bytes by default, override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)
struct ImFont;                      // Runtime data for a single font within a parent ImFontAtlas
struct ImFontAtlas;                 // Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader
struct ImFontConfig;                // Configuration data when adding a font or merging fonts
struct ImColor;                     // Helper functions to create a color that can be converted to either u32 or float4 (*obsolete* please avoid using)
#ifndef ImTextureID
typedef void* ImTextureID;          // User data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)
#endif
struct ImGuiContext;                // ImGui context (opaque)
struct ImGuiIO;                     // Main configuration and I/O between your application and ImGui
struct ImGuiInputTextCallbackData;  // Shared state of InputText() when using custom ImGuiInputTextCallback (rare/advanced use)
struct ImGuiListClipper;            // Helper to manually clip large list of items
struct ImGuiOnceUponAFrame;         // Helper for running a block of code not more than once a frame, used by IMGUI_ONCE_UPON_A_FRAME macro
struct ImGuiPayload;                // User data payload for drag and drop operations
struct ImGuiSizeCallbackData;       // Callback data when using SetNextWindowSizeConstraints() (rare/advanced use)
struct ImGuiStorage;                // Helper for key->value storage
struct ImGuiStyle;                  // Runtime data for styling/colors
struct ImGuiTextFilter;             // Helper to parse and apply text filters (e.g. "aaaaa[,bbbb][,ccccc]")
struct ImGuiTextBuffer;             // Helper to hold and append into a text buffer (~string builder)

// Typedefs and Enums/Flags (declared as int for compatibility with old C++, to allow using as flags and to not pollute the top of this file)
// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
typedef unsigned int ImGuiID;       // Unique ID used by widgets (typically hashed from a stack of string)
typedef unsigned short ImWchar;     // Character for keyboard input/display
typedef int ImGuiCol;               // -> enum ImGuiCol_             // Enum: A color identifier for styling
typedef int ImGuiCond;              // -> enum ImGuiCond_            // Enum: A condition for Set*()
typedef int ImGuiDataType;          // -> enum ImGuiDataType_        // Enum: A primary data type
typedef int ImGuiDir;               // -> enum ImGuiDir_             // Enum: A cardinal direction
typedef int ImGuiKey;               // -> enum ImGuiKey_             // Enum: A key identifier (ImGui-side enum)
typedef int ImGuiNavInput;          // -> enum ImGuiNavInput_        // Enum: An input identifier for navigation
typedef int ImGuiMouseCursor;       // -> enum ImGuiMouseCursor_     // Enum: A mouse cursor identifier
typedef int ImGuiStyleVar;          // -> enum ImGuiStyleVar_        // Enum: A variable identifier for styling
typedef int ImDrawCornerFlags;      // -> enum ImDrawCornerFlags_    // Flags: for ImDrawList::AddRect*() etc.
typedef int ImDrawListFlags;        // -> enum ImDrawListFlags_      // Flags: for ImDrawList
typedef int ImFontAtlasFlags;       // -> enum ImFontAtlasFlags_     // Flags: for ImFontAtlas
typedef int ImGuiBackendFlags;      // -> enum ImGuiBackendFlags_    // Flags: for io.BackendFlags
typedef int ImGuiColorEditFlags;    // -> enum ImGuiColorEditFlags_  // Flags: for ColorEdit*(), ColorPicker*()
typedef int ImGuiColumnsFlags;      // -> enum ImGuiColumnsFlags_    // Flags: for Columns(), BeginColumns()
typedef int ImGuiConfigFlags;       // -> enum ImGuiConfigFlags_     // Flags: for io.ConfigFlags
typedef int ImGuiComboFlags;        // -> enum ImGuiComboFlags_      // Flags: for BeginCombo()
typedef int ImGuiDragDropFlags;     // -> enum ImGuiDragDropFlags_   // Flags: for *DragDrop*()
typedef int ImGuiFocusedFlags;      // -> enum ImGuiFocusedFlags_    // Flags: for IsWindowFocused()
typedef int ImGuiHoveredFlags;      // -> enum ImGuiHoveredFlags_    // Flags: for IsItemHovered(), IsWindowHovered() etc.
typedef int ImGuiInputTextFlags;    // -> enum ImGuiInputTextFlags_  // Flags: for InputText*()
typedef int ImGuiSelectableFlags;   // -> enum ImGuiSelectableFlags_ // Flags: for Selectable()
typedef int ImGuiTabBarFlags;       // -> enum ImGuiTabBarFlags_     // Flags: for BeginTabBar()
typedef int ImGuiTabItemFlags;      // -> enum ImGuiTabItemFlags_    // Flags: for BeginTabItem()
typedef int ImGuiTreeNodeFlags;     // -> enum ImGuiTreeNodeFlags_   // Flags: for TreeNode*(),CollapsingHeader()
typedef int ImGuiWindowFlags;       // -> enum ImGuiWindowFlags_     // Flags: for Begin*()
typedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData *data);
typedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);

// Scalar data types
typedef signed int          ImS32;  // 32-bit signed integer == int
typedef unsigned int        ImU32;  // 32-bit unsigned integer (often used to store packed colors)
#if defined(_MSC_VER) && !defined(__clang__)
typedef signed   __int64    ImS64;  // 64-bit signed integer (pre and post C++11 with Visual Studio)
typedef unsigned __int64    ImU64;  // 64-bit unsigned integer (pre and post C++11 with Visual Studio)
#elif (defined(__clang__) || defined(__GNUC__)) && (__cplusplus < 201100)
#include <stdint.h>
typedef int64_t             ImS64;  // 64-bit signed integer (pre C++11)
typedef uint64_t            ImU64;  // 64-bit unsigned integer (pre C++11)
#else
typedef signed   long long  ImS64;  // 64-bit signed integer (post C++11)
typedef unsigned long long  ImU64;  // 64-bit unsigned integer (post C++11)
#endif

// 2D vector (often used to store positions, sizes, etc.)
struct ImVec2
{
    float     x, y;
    ImVec2()  { x = y = 0.0f; }
    ImVec2(float _x, float _y) { x = _x; y = _y; }
    float operator[] (size_t i) const { IM_ASSERT(i <= 1); return (&x)[i]; }    // We very rarely use this [] operator, the assert overhead is fine.
#ifdef IM_VEC2_CLASS_EXTRA
    IM_VEC2_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec2.
#endif
};

// 4D vector (often used to store floating-point colors)
struct ImVec4
{
    float     x, y, z, w;
    ImVec4()  { x = y = z = w = 0.0f; }
    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }
#ifdef IM_VEC4_CLASS_EXTRA
    IM_VEC4_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec4.
#endif
};

//-----------------------------------------------------------------------------
// ImGui: Dear ImGui end-user API
// (Inside a namespace so you can add extra functions in your own separate file. Please don't modify imgui.cpp/.h!)
//-----------------------------------------------------------------------------

namespace ImGui
{
    // Context creation and access
    // Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts.
    // All those functions are not reliant on the current context.
    IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);
    IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context
    IMGUI_API ImGuiContext* GetCurrentContext();
    IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);
    IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert);

    // Main
    IMGUI_API ImGuiIO&      GetIO();                                    // access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
    IMGUI_API ImGuiStyle&   GetStyle();                                 // access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame.
    IMGUI_API void          NewFrame();                                 // start a new ImGui frame, you can submit any command from this point until Render()/EndFrame().
    IMGUI_API void          EndFrame();                                 // ends the ImGui frame. automatically called by Render(), you likely don't need to call that yourself directly. If you don't need to render data (skipping rendering) you may call EndFrame() but you'll have wasted CPU already! If you don't need to render, better to not create any imgui windows and not call NewFrame() at all!
    IMGUI_API void          Render();                                   // ends the ImGui frame, finalize the draw data. (Obsolete: optionally call io.RenderDrawListsFn if set. Nowadays, prefer calling your render function yourself.)
    IMGUI_API ImDrawData*   GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render. (Obsolete: this used to be passed to your io.RenderDrawListsFn() function.)

    // Demo, Debug, Information
    IMGUI_API void          ShowDemoWindow(bool* p_open = NULL);        // create demo/test window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!
    IMGUI_API void          ShowAboutWindow(bool* p_open = NULL);       // create about window. display Dear ImGui version, credits and build/system information.
    IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // create metrics window. display Dear ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc.
    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)
    IMGUI_API bool          ShowStyleSelector(const char* label);       // add style selector block (not a window), essentially a combo listing the default styles.
    IMGUI_API void          ShowFontSelector(const char* label);        // add font selector block (not a window), essentially a combo listing the loaded fonts.
    IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).
    IMGUI_API const char*   GetVersion();                               // get the compiled version string e.g. "1.23"

    // Styles
    IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // new, recommended style (default)
    IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style
    IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font

    // Windows
    // - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.
    // - You may append multiple times to the same window during the same frame.
    // - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window, 
    //   which clicking will set the boolean to false when clicked.
    // - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
    //   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value!
    //   [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. 
    //    where the EndXXX call should only be called if the corresponding BeginXXX function returned true.]
    // - Note that the bottom of window stack always contains a window called "Debug".
    IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);
    IMGUI_API void          End();

    // Child Windows
    // - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.
    // - For each independent axis of 'size': ==0.0f: use remaining host window size / >0.0f: fixed size / <0.0f: use remaining window size minus abs(size) / Each axis can use a different mode, e.g. ImVec2(0,400).
    // - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.
    //   Always call a matching EndChild() for each BeginChild() call, regardless of its return value [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function returned true.]
    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);
    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);
    IMGUI_API void          EndChild();

    // Windows Utilities
    // "current window" = the window we are appending into while inside a Begin()/End() block. "next window" = next window we will Begin() into.
    IMGUI_API bool          IsWindowAppearing();
    IMGUI_API bool          IsWindowCollapsed();
    IMGUI_API bool          IsWindowFocused(ImGuiFocusedFlags flags=0); // is current window focused? or its root/child, depending on flags. see flags for options.
    IMGUI_API bool          IsWindowHovered(ImGuiHoveredFlags flags=0); // is current window hovered (and typically: not blocked by a popup/modal)? see flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ!
    IMGUI_API ImDrawList*   GetWindowDrawList();                        // get draw list associated to the window, to append your own drawing primitives
    IMGUI_API ImVec2        GetWindowPos();                             // get current window position in screen space (useful if you want to do your own drawing via the DrawList API)
    IMGUI_API ImVec2        GetWindowSize();                            // get current window size
    IMGUI_API float         GetWindowWidth();                           // get current window width (shortcut for GetWindowSize().x)
    IMGUI_API float         GetWindowHeight();                          // get current window height (shortcut for GetWindowSize().y)
    IMGUI_API ImVec2        GetContentRegionMax();                      // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates
    IMGUI_API ImVec2        GetContentRegionAvail();                    // == GetContentRegionMax() - GetCursorPos()
    IMGUI_API float         GetContentRegionAvailWidth();               //
    IMGUI_API ImVec2        GetWindowContentRegionMin();                // content boundaries min (roughly (0,0)-Scroll), in window coordinates
    IMGUI_API ImVec2        GetWindowContentRegionMax();                // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates
    IMGUI_API float         GetWindowContentRegionWidth();              //

    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0,0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);                  // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
    IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Use callback to apply non-trivial programmatic constraints.
    IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                               // set next window content size (~ enforce the range of scrollbars). not including window decorations (title bar, menu bar, etc.). set an axis to 0.0f to leave it automatic. call before Begin()
    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                 // set next window collapsed state. call before Begin()
    IMGUI_API void          SetNextWindowFocus();                                                       // set next window to be focused / front-most. call before Begin()
    IMGUI_API void          SetNextWindowBgAlpha(float alpha);                                          // set next window background color alpha. helper to easily modify ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                        // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);                      // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                     // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
    IMGUI_API void          SetWindowFocus();                                                           // (not recommended) set current window to be focused / front-most. prefer using SetNextWindowFocus().
    IMGUI_API void          SetWindowFontScale(float scale);                                            // set font scale. Adjust IO.FontGlobalScale if you want to scale all windows
    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.
    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.
    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state
    IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / front-most. use NULL to remove focus.

    // Windows Scrolling
    IMGUI_API float         GetScrollX();                                                   // get scrolling amount [0..GetScrollMaxX()]
    IMGUI_API float         GetScrollY();                                                   // get scrolling amount [0..GetScrollMaxY()]
    IMGUI_API float         GetScrollMaxX();                                                // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X
    IMGUI_API float         GetScrollMaxY();                                                // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y
    IMGUI_API void          SetScrollX(float scroll_x);                                     // set scrolling amount [0..GetScrollMaxX()]
    IMGUI_API void          SetScrollY(float scroll_y);                                     // set scrolling amount [0..GetScrollMaxY()]
    IMGUI_API void          SetScrollHereY(float center_y_ratio = 0.5f);                     // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
    IMGUI_API void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);    // adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorLoopCallbackPos()+offset to get valid positions.

    // Parameters stacks (shared)
    IMGUI_API void          PushFont(ImFont* font);                                         // use NULL as a shortcut to push default font
    IMGUI_API void          PopFont();
    IMGUI_API void          PushStyleColor(ImGuiCol idx, ImU32 col);
    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);
    IMGUI_API void          PopStyleColor(int count = 1);
    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);
    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
    IMGUI_API void          PopStyleVar(int count = 1);
    IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.
    IMGUI_API ImFont*       GetFont();                                                      // get current font
    IMGUI_API float         GetFontSize();                                                  // get current font size (= height in pixels) of current font with current scale applied
    IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                       // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API
    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);              // retrieve given style color with style alpha applied and optional extra alpha multiplier
    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                 // retrieve given color with style alpha applied
    IMGUI_API ImU32         GetColorU32(ImU32 col);                                         // retrieve given color with style alpha applied

    // Parameters stacks (current window)
    IMGUI_API void          PushItemWidth(float item_width);                                // width of items for the common item+label case, pixels. 0.0f = default to ~2/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)
    IMGUI_API void          PopItemWidth();
    IMGUI_API float         CalcItemWidth();                                                // width of item given pushed settings and current cursor position
    IMGUI_API void          PushTextWrapPos(float wrap_pos_x = 0.0f);                       // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
    IMGUI_API void          PopTextWrapPos();
    IMGUI_API void          PushAllowKeyboardFocus(bool allow_keyboard_focus);              // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets
    IMGUI_API void          PopAllowKeyboardFocus();
    IMGUI_API void          PushButtonRepeat(bool repeat);                                  // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.
    IMGUI_API void          PopButtonRepeat();

    // Cursor / Layout
    IMGUI_API void          Separator();                                                    // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.
    IMGUI_API void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);          // call between widgets or groups to layout them horizontally
    IMGUI_API void          NewLine();                                                      // undo a SameLine()
    IMGUI_API void          Spacing();                                                      // add vertical spacing
    IMGUI_API void          Dummy(const ImVec2& size);                                      // add a dummy item of given size
    IMGUI_API void          Indent(float indent_w = 0.0f);                                  // move content position toward the right, by style.IndentSpacing or indent_w if != 0
    IMGUI_API void          Unindent(float indent_w = 0.0f);                                // move content position back to the left, by style.IndentSpacing or indent_w if != 0
    IMGUI_API void          BeginGroup();                                                   // lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
    IMGUI_API void          EndGroup();
    IMGUI_API ImVec2        GetCursorPos();                                                 // cursor position is relative to window position
    IMGUI_API float         GetCursorPosX();                                                // "
    IMGUI_API float         GetCursorPosY();                                                // "
    IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                          // "
    IMGUI_API void          SetCursorPosX(float x);                                         // "
    IMGUI_API void          SetCursorPosY(float y);                                         // "
    IMGUI_API ImVec2        GetCursorLoopCallbackPos();                                            // initial cursor position
    IMGUI_API ImVec2        GetCursorScreenPos();                                           // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)
    IMGUI_API void          SetCursorScreenPos(const ImVec2& screen_pos);                   // cursor position in absolute screen coordinates [0..io.DisplaySize]
    IMGUI_API void          AlignTextToFramePadding();                                      // vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)
    IMGUI_API float         GetTextLineHeight();                                            // ~ FontSize
    IMGUI_API float         GetTextLineHeightWithSpacing();                                 // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
    IMGUI_API float         GetFrameHeight();                                               // ~ FontSize + style.FramePadding.y * 2
    IMGUI_API float         GetFrameHeightWithSpacing();                                    // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)

    // ID stack/scopes
    // Read the FAQ for more details about how ID are handled in dear imgui. If you are creating widgets in a loop you most
    // likely want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
    // You can also use the "##foobar" syntax within widget label to distinguish them from each others.
    // In this header file we use the "label"/"name" terminology to denote a string that will be displayed and used as an ID,
    // whereas "str_id" denote a string that is only used as an ID and not aimed to be displayed.
    IMGUI_API void          PushID(const char* str_id);                                     // push identifier into the ID stack. IDs are hash of the entire stack!
    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);
    IMGUI_API void          PushID(const void* ptr_id);
    IMGUI_API void          PushID(int int_id);
    IMGUI_API void          PopID();
    IMGUI_API ImGuiID       GetID(const char* str_id);                                      // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);
    IMGUI_API ImGuiID       GetID(const void* ptr_id);

    // Widgets: Text
    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);                // raw text without formatting. Roughly equivalent to Text("%s", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.
    IMGUI_API void          Text(const char* fmt, ...)                                      IM_FMTARGS(1); // simple formatted text
    IMGUI_API void          TextV(const char* fmt, va_list args)                            IM_FMTLIST(1);
    IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...)            IM_FMTARGS(2); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();
    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args)  IM_FMTLIST(2);
    IMGUI_API void          TextDisabled(const char* fmt, ...)                              IM_FMTARGS(1); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();
    IMGUI_API void          TextDisabledV(const char* fmt, va_list args)                    IM_FMTLIST(1);
    IMGUI_API void          TextWrapped(const char* fmt, ...)                               IM_FMTARGS(1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().
    IMGUI_API void          TextWrappedV(const char* fmt, va_list args)                     IM_FMTLIST(1);
    IMGUI_API void          LabelText(const char* label, const char* fmt, ...)              IM_FMTARGS(2); // display text+label aligned the same way as value+label widgets
    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args)    IM_FMTLIST(2);
    IMGUI_API void          BulletText(const char* fmt, ...)                                IM_FMTARGS(1); // shortcut for Bullet()+Text()
    IMGUI_API void          BulletTextV(const char* fmt, va_list args)                      IM_FMTLIST(1);

    // Widgets: Main
    // Most widgets return true when the value has been changed or when pressed/selected
    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));    // button
    IMGUI_API bool          SmallButton(const char* label);                                 // button with FramePadding=(0,0) to easily embed within text
    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);        // button behavior without the visuals, useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)
    IMGUI_API bool          ArrowButton(const char* str_id, ImGuiDir dir);                  // square button with an arrow shape
    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));
    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    // <0 frame_padding uses default frame padding settings. 0 for no padding
    IMGUI_API bool          Checkbox(const char* label, bool* v);
    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);
    IMGUI_API bool          RadioButton(const char* label, bool active);                    // use with e.g. if (RadioButton("one", my_value==1)) { my_value = 1; }
    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);           // shortcut to handle the above pattern when value is an integer
    IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);
    IMGUI_API void          Bullet();                                                       // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses

    // Widgets: Combo Box
    // The new BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items.
    // The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose.
    IMGUI_API bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);
    IMGUI_API void          EndCombo(); // only call EndCombo() if BeginCombo() returns true!
    IMGUI_API bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);
    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \0 within a string, end item-list with \0\0. e.g. "One\0Two\0Three\0"
    IMGUI_API bool          Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);

    // Widgets: Drags (tip: ctrl+click on a drag box to input with keyboard. manually input values aren't clamped, can go off-bounds)
    // For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x
    // Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
    // Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).
    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);     // If v_min >= v_max we have no bound
    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", const char* format_max = NULL, float power = 1.0f);
    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");                                       // If v_min >= v_max we have no bound
    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", const char* format_max = NULL);
    IMGUI_API bool          DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);

    // Widgets: Sliders (tip: ctrl+click on a slider to input with keyboard. manually input values aren't clamped, can go off-bounds)
    // Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for power curve sliders
    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = "%.0f deg");
    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);

    // Widgets: Input with Keyboard
    // If you want to use InputText() with a dynamic string type such as std::string or your own, see misc/cpp/imgui_stdlib.h
    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = "%.3f", ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool          InputFloat2(const char* label, float v[2], const char* format = "%.3f", ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool          InputFloat3(const char* label, float v[3], const char* format = "%.3f", ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool          InputFloat4(const char* label, float v[4], const char* format = "%.3f", ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool          InputDouble(const char* label, double* v, double step = 0.0f, double step_fast = 0.0f, const char* format = "%.6f", ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool          InputScalar(const char* label, ImGuiDataType data_type, void* v, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool          InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags extra_flags = 0);

    // Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu.)
    // Note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can the pass the address of a first float element out of a contiguous structure, e.g. &myvector.x
    IMGUI_API bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL);
    IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0));  // display a colored square/button, hover for details, return true when pressed.
    IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                     // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.

    // Widgets: Trees
    // TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents.
    IMGUI_API bool          TreeNode(const char* label);
    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_FMTARGS(2);   // helper variation to completely decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().
    IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_FMTARGS(2);   // "
    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) IM_FMTLIST(2);
    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) IM_FMTLIST(2);
    IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);
    IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);
    IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);
    IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);
    IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);
    IMGUI_API void          TreePush(const char* str_id);                                       // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.
    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                // "
    IMGUI_API void          TreePop();                                                          // ~ Unindent()+PopId()
    IMGUI_API void          TreeAdvanceToLabelPos();                                            // advance cursor x position by GetTreeNodeToLabelSpacing()
    IMGUI_API float         GetTreeNodeToLabelSpacing();                                        // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode
    IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiCond cond = 0);              // set next TreeNode/CollapsingHeader open state.
    IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);  // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().
    IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header

    // Widgets: Selectables
    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  // "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height
    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));       // "bool* p_selected" point to the selection state (read-write), as a convenient helper.

    // Widgets: List Boxes
    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);
    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);
    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); // use if you want to reimplement ListBox() will custom data or interactions. if the function return true, you can output elements then call ListBoxFooter() afterwards.
    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); // "
    IMGUI_API void          ListBoxFooter();                                                    // terminate the scrolling region. only call ListBoxFooter() if ListBoxHeader() returned true!

    // Widgets: Data Plotting
    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    IMGUI_API void          PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));
    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    IMGUI_API void          PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));

    // Widgets: Value() Helpers. Simple shortcut to calling Text() with a format string. Output single value in "name: value" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)
    IMGUI_API void          Value(const char* prefix, bool b);
    IMGUI_API void          Value(const char* prefix, int v);
    IMGUI_API void          Value(const char* prefix, unsigned int v);
    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);

    // Widgets: Menus
    IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar.
    IMGUI_API void          EndMainMenuBar();                                                   // only call EndMainMenuBar() if BeginMainMenuBar() returns true!
    IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).
    IMGUI_API void          EndMenuBar();                                                       // only call EndMenuBar() if BeginMenuBar() returns true!
    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!
    IMGUI_API void          EndMenu();                                                          // only call EndMenu() if BeginMenu() returns true!
    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment
    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL

    // Tooltips
    IMGUI_API void          BeginTooltip();                                                     // begin/append a tooltip window. to create full-featured tooltip (with any kind of items).
    IMGUI_API void          EndTooltip();
    IMGUI_API void          SetTooltip(const char* fmt, ...) IM_FMTARGS(1);                     // set a text-only tooltip, typically use with ImGui::IsItemHovered(). overidde any previous call to SetTooltip().
    IMGUI_API void          SetTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);

    // Popups, Modals
    // The properties of popups windows are:
    // - They block normal mouse hovering detection outside them. (*)
    // - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
    // - Their visibility state (~bool) is held internally by imgui instead of being held by the programmer as we are used to with regular Begin() calls.
    //   User can manipulate the visibility state by calling OpenPopup().
    // (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even when normally blocked by a popup.
    // Those three properties are connected. The library needs to hold their visibility state because it can close popups at any time.
    IMGUI_API void          OpenPopup(const char* str_id);                                      // call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
    IMGUI_API bool          BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);                                             // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returns true!
    IMGUI_API bool          BeginPopupContextItem(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
    IMGUI_API bool          BeginPopupContextWindow(const char* str_id = NULL, int mouse_button = 1, bool also_over_items = true);  // helper to open and begin popup when clicked on current window.
    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked in void (where there are no imgui windows).
    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                     // modal dialog (regular window with title bar, block interactions behind the modal window, can't close the modal window by clicking outside)
    IMGUI_API void          EndPopup();                                                                                             // only call EndPopup() if BeginPopupXXX() returns true!
    IMGUI_API bool          OpenPopupOnItemClick(const char* str_id = NULL, int mouse_button = 1);                                  // helper to open popup when clicked on last item (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors). return true when just opened.
    IMGUI_API bool          IsPopupOpen(const char* str_id);                                    // return true if the popup is open at the current begin-ed level of the popup stack.
    IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.

    // Columns
    // You can also use SameLine(pos_x) to mimic simplified columns. The columns API is work-in-progress and rather lacking (columns are arguably the worst part of dear imgui at the moment!)
    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);
    IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished
    IMGUI_API int           GetColumnIndex();                                                   // get current column index
    IMGUI_API float         GetColumnWidth(int column_index = -1);                              // get column width (in pixels). pass -1 to use current column
    IMGUI_API void          SetColumnWidth(int column_index, float width);                      // set column width (in pixels). pass -1 to use current column
    IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f
    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column
    IMGUI_API int           GetColumnsCount();

    // Tab Bars, Tabs
    // [BETA API] API may evolve!
    IMGUI_API bool          BeginTabBar(const char* str_id, ImGuiTabBarFlags flags = 0);        // create and append into a TabBar
    IMGUI_API void          EndTabBar();                                                        // only call EndTabBar() if BeginTabBar() returns true!
    IMGUI_API bool          BeginTabItem(const char* label, bool* p_open = NULL, ImGuiTabItemFlags flags = 0);// create a Tab. Returns true if the Tab is selected.
    IMGUI_API void          EndTabItem();                                                       // only call EndTabItem() if BeginTabItem() returns true!
    IMGUI_API void          SetTabItemClosed(const char* tab_or_docked_window_label);           // notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.

    // Logging/Capture: all text output from interface is captured to tty/file/clipboard. By default, tree nodes are automatically opened during logging.
    IMGUI_API void          LogToTTY(int max_depth = -1);                                       // start logging to tty (stdout)
    IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         // start logging to file
    IMGUI_API void          LogToClipboard(int max_depth = -1);                                 // start logging to OS clipboard
    IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)
    IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard
    IMGUI_API void          LogText(const char* fmt, ...) IM_FMTARGS(1);                        // pass text data straight to log (without being displayed)

    // Drag and Drop
    // [BETA API] Missing Demo code. API may evolve!
    IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0);                                      // call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()
    IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t size, ImGuiCond cond = 0);// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.
    IMGUI_API void          EndDragDropSource();                                                                    // only call EndDragDropSource() if BeginDragDropSource() returns true!
    IMGUI_API bool                  BeginDragDropTarget();                                                          // call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
    IMGUI_API const ImGuiPayload*   AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);          // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
    IMGUI_API void                  EndDragDropTarget();                                                            // only call EndDragDropTarget() if BeginDragDropTarget() returns true!
    IMGUI_API const ImGuiPayload*   GetDragDropPayload();                                                           // peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.
    
    // Clipping
    IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
    IMGUI_API void          PopClipRect();

    // Focus, Activation
    // Prefer using "SetItemDefaultFocus()" over "if (IsWindowAppearing()) SetScrollHereY()" when applicable to signify "this is the default item"
    IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window.
    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.

    // Item/Widgets Utilities
    // Most of the functions are referring to the last/previous item we submitted.
    // See Demo Window under "Widgets->Querying Status" for an interactive visualization of most of those functions.
    IMGUI_API bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
    IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)
    IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?
    IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                // is the last item clicked? (e.g. button/node just clicked on) == IsMouseClicked(mouse_button) && IsItemHovered()
    IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (items may be out of sight because of clipping/scrolling)
    IMGUI_API bool          IsItemEdited();                                                     // did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.
    IMGUI_API bool          IsItemDeactivated();                                                // was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing.
    IMGUI_API bool          IsItemDeactivatedAfterEdit();                                       // was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).
    IMGUI_API bool          IsAnyItemHovered();
    IMGUI_API bool          IsAnyItemActive();
    IMGUI_API bool          IsAnyItemFocused();
    IMGUI_API ImVec2        GetItemRectMin();                                                   // get bounding rectangle of last item, in screen space
    IMGUI_API ImVec2        GetItemRectMax();                                                   // "
    IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item, in screen space
    IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.

    // Miscellaneous Utilities
    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.
    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
    IMGUI_API double        GetTime();                                                          // get global imgui time. incremented by io.DeltaTime every frame.
    IMGUI_API int           GetFrameCount();                                                    // get global imgui frame count. incremented by 1 every frame.
    IMGUI_API ImDrawList*   GetOverlayDrawList();                                               // this draw list will be the last rendered one, useful to quickly draw overlays shapes/text
    IMGUI_API ImDrawListSharedData* GetDrawListSharedData();                                    // you may use this when creating your own ImDrawList instances
    IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);
    IMGUI_API void          SetStateStorage(ImGuiStorage* storage);                             // replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
    IMGUI_API ImGuiStorage* GetStateStorage();
    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);
    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.
    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags flags = 0); // helper to create a child window / scrolling region that looks like a normal widget frame
    IMGUI_API void          EndChildFrame();                                                    // always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window)

    // Color Utilities
    IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);
    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);
    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);
    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);

    // Inputs Utilities
    IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    // map ImGuiKey_* values into user's key index. == io.KeyMap[key]
    IMGUI_API bool          IsKeyDown(int user_key_index);                                      // is key being held. == io.KeysDown[user_key_index]. note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your backend/engine stored them into io.KeysDown[]!
    IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               // was key pressed (went from !Down to Down). if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
    IMGUI_API bool          IsKeyReleased(int user_key_index);                                  // was key released (went from Down to !Down)..
    IMGUI_API int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
    IMGUI_API bool          IsMouseDown(int button);                                            // is mouse button held (0=left, 1=right, 2=middle)
    IMGUI_API bool          IsAnyMouseDown();                                                   // is any mouse button held
    IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    // did mouse button clicked (went from !Down to Down) (0=left, 1=right, 2=middle)
    IMGUI_API bool          IsMouseDoubleClicked(int button);                                   // did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.
    IMGUI_API bool          IsMouseReleased(int button);                                        // did mouse button released (went from Down to !Down)
    IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      // is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold
    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  // is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but  disregarding of other consideration of focus/window ordering/popup-block.
    IMGUI_API bool          IsMousePosValid(const ImVec2* mouse_pos = NULL);                    //
    IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
    IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve backup of mouse position at the time of opening popup we have BeginPopup() into
    IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    // dragging amount since clicking. if lock_threshold < -1.0f uses io.MouseDraggingThreshold
    IMGUI_API void          ResetMouseDragDelta(int button = 0);                                //
    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              // set desired cursor type
    IMGUI_API void          CaptureKeyboardFromApp(bool want_capture_keyboard_value = true);    // attention: misleading name! manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application to handle). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard_value"; after the next NewFrame() call. 
    IMGUI_API void          CaptureMouseFromApp(bool want_capture_mouse_value = true);          // attention: misleading name! manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application to handle). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse_value;" after the next NewFrame() call. 

    // Clipboard Utilities (also see the LogToClipboard() function to capture or output text data to the clipboard)
    IMGUI_API const char*   GetClipboardText();
    IMGUI_API void          SetClipboardText(const char* text);

    // Settings/.Ini Utilities
    // The disk functions are automatically called if io.IniFilename != NULL (default is "imgui.ini").
    // Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.
    IMGUI_API void          LoadIniSettingsFromDisk(const char* ini_filename);                  // call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
    IMGUI_API void          LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0); // call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.
    IMGUI_API void          SaveIniSettingsToDisk(const char* ini_filename);
    IMGUI_API const char*   SaveIniSettingsToMemory(size_t* out_ini_size = NULL);               // return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.

    // Memory Utilities
    // All those functions are not reliant on the current context.
    // If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again.
    IMGUI_API void          SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void(*free_func)(void* ptr, void* user_data), void* user_data = NULL);
    IMGUI_API void*         MemAlloc(size_t size);
    IMGUI_API void          MemFree(void* ptr);

} // namespace ImGui

//-----------------------------------------------------------------------------
// Flags & Enumerations
//-----------------------------------------------------------------------------

// Flags for ImGui::Begin()
enum ImGuiWindowFlags_
{
    ImGuiWindowFlags_None                   = 0,
    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar
    ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip
    ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window
    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programatically)
    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
    ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it
    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame
    ImGuiWindowFlags_NoBackground           = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file
    ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   // Disable catching mouse, hovering test with pass through.
    ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar
    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)
    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
    ImGuiWindowFlags_NoNavInputs            = 1 << 18,  // No gamepad/keyboard navigation within the window
    ImGuiWindowFlags_NoNavFocus             = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
    ImGuiWindowFlags_UnsavedDocument        = 1 << 20,  // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.
    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,

    // [Internal]
    ImGuiWindowFlags_NavFlattened           = 1 << 23,  // [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)
    ImGuiWindowFlags_ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()
    ImGuiWindowFlags_Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()
    ImGuiWindowFlags_Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()
    ImGuiWindowFlags_Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()
    ImGuiWindowFlags_ChildMenu              = 1 << 28   // Don't use! For internal use by BeginMenu()

    // [Obsolete]
    //ImGuiWindowFlags_ShowBorders          = 1 << 7,   // --> Set style.FrameBorderSize=1.0f / style.WindowBorderSize=1.0f to enable borders around windows and items
    //ImGuiWindowFlags_ResizeFromAnySide    = 1 << 17,  // --> Set io.ConfigWindowsResizeFromEdges and make sure mouse cursors are supported by back-end (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)
};

// Flags for ImGui::InputText()
enum ImGuiInputTextFlags_
{
    ImGuiInputTextFlags_None                = 0,
    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   // Allow 0123456789.+-*/
    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   // Allow 0123456789ABCDEFabcdef
    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   // Turn a..z into A..Z
    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   // Filter out spaces, tabs
    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   // Select entire text when first taking mouse focus
    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to when the value was modified)
    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   // Callback on pressing TAB (for completion handling)
    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   // Callback on pressing Up/Down arrows (for history handling)
    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   // Callback on each iteration. User code may query cursor position, modify text buffer.
    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  // Pressing TAB input a '\t' character into the text field
    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  // Disable following the cursor horizontally
    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  // Insert mode
    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  // Read-only mode
    ImGuiInputTextFlags_Password            = 1 << 15,  // Password mode, display all characters as '*'
    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
    ImGuiInputTextFlags_CharsScientific     = 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)
    ImGuiInputTextFlags_CallbackResize      = 1 << 18,  // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)
    // [Internal]
    ImGuiInputTextFlags_Multiline           = 1 << 20   // For internal use by InputTextMultiline()
};

// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()
enum ImGuiTreeNodeFlags_
{
    ImGuiTreeNodeFlags_None                 = 0,
    ImGuiTreeNodeFlags_Selected             = 1 << 0,   // Draw as selected
    ImGuiTreeNodeFlags_Framed               = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)
    ImGuiTreeNodeFlags_AllowItemOverlap     = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one
    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   // Default node to be open
    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   // Need double-click to open node
    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).
    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   // Display a bullet instead of arrow
    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().
    //ImGuITreeNodeFlags_SpanAllAvailWidth  = 1 << 11,  // FIXME: TODO: Extend hit box horizontally even if not framed
    //ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 12,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible
    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiTreeNodeFlags_AllowOverlapMode = ImGuiTreeNodeFlags_AllowItemOverlap
#endif
};

// Flags for ImGui::Selectable()
enum ImGuiSelectableFlags_
{
    ImGuiSelectableFlags_None               = 0,
    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   // Clicking this don't close parent popup window
    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)
    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2,   // Generate press events on double clicks too
    ImGuiSelectableFlags_Disabled           = 1 << 3    // Cannot be selected, display greyed out text
};

// Flags for ImGui::BeginCombo()
enum ImGuiComboFlags_
{
    ImGuiComboFlags_None                    = 0,
    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   // Align the popup toward the left by default
    ImGuiComboFlags_HeightSmall             = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
    ImGuiComboFlags_HeightRegular           = 1 << 2,   // Max ~8 items visible (default)
    ImGuiComboFlags_HeightLarge             = 1 << 3,   // Max ~20 items visible
    ImGuiComboFlags_HeightLargest           = 1 << 4,   // As many fitting items as possible
    ImGuiComboFlags_NoArrowButton           = 1 << 5,   // Display on the preview box without the square arrow button
    ImGuiComboFlags_NoPreview               = 1 << 6,   // Display only a square arrow button
    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest
};

// Flags for ImGui::BeginTabBar()
enum ImGuiTabBarFlags_
{
    ImGuiTabBarFlags_None                           = 0,
    ImGuiTabBarFlags_Reorderable                    = 1 << 0,   // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list
    ImGuiTabBarFlags_AutoSelectNewTabs              = 1 << 1,   // Automatically select new tabs when they appear
    ImGuiTabBarFlags_NoCloseWithMiddleMouseButton   = 1 << 2,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
    ImGuiTabBarFlags_NoTabListPopupButton           = 1 << 3,
    ImGuiTabBarFlags_NoTabListScrollingButtons      = 1 << 4,
    ImGuiTabBarFlags_FittingPolicyResizeDown        = 1 << 5,   // Resize tabs when they don't fit
    ImGuiTabBarFlags_FittingPolicyScroll            = 1 << 6,   // Add scroll buttons when tabs don't fit
    ImGuiTabBarFlags_FittingPolicyMask_             = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,
    ImGuiTabBarFlags_FittingPolicyDefault_          = ImGuiTabBarFlags_FittingPolicyResizeDown
};  

// Flags for ImGui::BeginTabItem()
enum ImGuiTabItemFlags_
{
    ImGuiTabItemFlags_None                          = 0,
    ImGuiTabItemFlags_UnsavedDocument               = 1 << 0,   // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker.
    ImGuiTabItemFlags_SetSelected                   = 1 << 1,   // Trigger flag to programatically make the tab selected when calling BeginTabItem()
    ImGuiTabItemFlags_NoCloseWithMiddleMouseButton  = 1 << 2,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
    ImGuiTabItemFlags_NoPushId                      = 1 << 3    // Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()
};

// Flags for ImGui::IsWindowFocused()
enum ImGuiFocusedFlags_
{
    ImGuiFocusedFlags_None                          = 0,
    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused
    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)
    ImGuiFocusedFlags_AnyWindow                     = 1 << 2,   // IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use ImGui::GetIO().WantCaptureMouse instead.
    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows
};

// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()
// Note: if you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that. Please read the FAQ!
// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.
enum ImGuiHoveredFlags_
{
    ImGuiHoveredFlags_None                          = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered
    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
    ImGuiHoveredFlags_AnyWindow                     = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered
    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window
    //ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.
    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
    ImGuiHoveredFlags_AllowWhenOverlapped           = 1 << 6,   // Return true even if the position is overlapped by another window
    ImGuiHoveredFlags_AllowWhenDisabled             = 1 << 7,   // Return true even if the item is disabled
    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows
};

// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()
enum ImGuiDragDropFlags_
{
    ImGuiDragDropFlags_None                         = 0,
    // BeginDragDropSource() flags
    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,   // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.
    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,   // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.
    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,   // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,   // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,   // External source (from outside of imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
    ImGuiDragDropFlags_SourceAutoExpirePayload      = 1 << 5,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)
    // AcceptDragDropPayload() flags
    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,  // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,  // Do not draw the default highlight rectangle when hovering over target.
    ImGuiDragDropFlags_AcceptNoPreviewTooltip       = 1 << 12,  // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.
    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  // For peeking ahead and inspecting the payload before delivery.
};

// Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui.
#define IMGUI_PAYLOAD_TYPE_COLOR_3F     "_COL3F"    // float[3]: Standard type for colors, without alpha. User code may use this type.
#define IMGUI_PAYLOAD_TYPE_COLOR_4F     "_COL4F"    // float[4]: Standard type for colors. User code may use this type.

// A primary data type
enum ImGuiDataType_
{
    ImGuiDataType_S32,      // int
    ImGuiDataType_U32,      // unsigned int
    ImGuiDataType_S64,      // long long, __int64
    ImGuiDataType_U64,      // unsigned long long, unsigned __int64
    ImGuiDataType_Float,    // float
    ImGuiDataType_Double,   // double
    ImGuiDataType_COUNT
};

// A cardinal direction
enum ImGuiDir_
{
    ImGuiDir_None    = -1,
    ImGuiDir_Left    = 0,
    ImGuiDir_Right   = 1,
    ImGuiDir_Up      = 2,
    ImGuiDir_Down    = 3,
    ImGuiDir_COUNT
};

// User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array
enum ImGuiKey_
{
    ImGuiKey_Tab,
    ImGuiKey_LeftArrow,
    ImGuiKey_RightArrow,
    ImGuiKey_UpArrow,
    ImGuiKey_DownArrow,
    ImGuiKey_PageUp,
    ImGuiKey_PageDown,
    ImGuiKey_Home,
    ImGuiKey_End,
    ImGuiKey_Insert,
    ImGuiKey_Delete,
    ImGuiKey_Backspace,
    ImGuiKey_Space,
    ImGuiKey_Enter,
    ImGuiKey_Escape,
    ImGuiKey_A,         // for text edit CTRL+A: select all
    ImGuiKey_C,         // for text edit CTRL+C: copy
    ImGuiKey_V,         // for text edit CTRL+V: paste
    ImGuiKey_X,         // for text edit CTRL+X: cut
    ImGuiKey_Y,         // for text edit CTRL+Y: redo
    ImGuiKey_Z,         // for text edit CTRL+Z: undo
    ImGuiKey_COUNT
};

// Gamepad/Keyboard directional navigation
// Keyboard: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
// Gamepad:  Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable. Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[] fields before calling NewFrame(). Note that io.NavInputs[] is cleared by EndFrame().
// Read instructions in imgui.cpp for more details. Download PNG/PSD at http://goo.gl/9LgVZW.
enum ImGuiNavInput_
{
    // Gamepad Mapping
    ImGuiNavInput_Activate,      // activate / open / toggle / tweak value       // e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)
    ImGuiNavInput_Cancel,        // cancel / close / exit                        // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)
    ImGuiNavInput_Input,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)
    ImGuiNavInput_Menu,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)
    ImGuiNavInput_DpadLeft,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)
    ImGuiNavInput_DpadRight,     //
    ImGuiNavInput_DpadUp,        //
    ImGuiNavInput_DpadDown,      //
    ImGuiNavInput_LStickLeft,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down
    ImGuiNavInput_LStickRight,   //
    ImGuiNavInput_LStickUp,      //
    ImGuiNavInput_LStickDown,    //
    ImGuiNavInput_FocusPrev,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
    ImGuiNavInput_FocusNext,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)
    ImGuiNavInput_TweakSlow,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
    ImGuiNavInput_TweakFast,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)

    // [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.
    // Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) will be directly reading from io.KeysDown[] instead of io.NavInputs[].
    ImGuiNavInput_KeyMenu_,      // toggle menu                                  // = io.KeyAlt
    ImGuiNavInput_KeyLeft_,      // move left                                    // = Arrow keys
    ImGuiNavInput_KeyRight_,     // move right
    ImGuiNavInput_KeyUp_,        // move up
    ImGuiNavInput_KeyDown_,      // move down
    ImGuiNavInput_COUNT,
    ImGuiNavInput_InternalLoopCallback_ = ImGuiNavInput_KeyMenu_
};

// Configuration flags stored in io.ConfigFlags. Set by user/application.
enum ImGuiConfigFlags_
{
    ImGuiConfigFlags_None                   = 0,
    ImGuiConfigFlags_NavEnableKeyboard      = 1 << 0,   // Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[].
    ImGuiConfigFlags_NavEnableGamepad       = 1 << 1,   // Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad.
    ImGuiConfigFlags_NavEnableSetMousePos   = 1 << 2,   // Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.
    ImGuiConfigFlags_NavNoCaptureKeyboard   = 1 << 3,   // Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.
    ImGuiConfigFlags_NoMouse                = 1 << 4,   // Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the back-end.
    ImGuiConfigFlags_NoMouseCursorChange    = 1 << 5,   // Instruct back-end to not alter mouse cursor shape and visibility. Use if the back-end cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.

    // User storage (to allow your back-end/engine to communicate to code that may be shared between multiple projects. Those flags are not used by core ImGui)
    ImGuiConfigFlags_IsSRGB                 = 1 << 20,  // Application is SRGB-aware.
    ImGuiConfigFlags_IsTouchScreen          = 1 << 21   // Application is using a touch screen instead of a mouse.
};

// Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end.
enum ImGuiBackendFlags_
{
    ImGuiBackendFlags_None                  = 0,
    ImGuiBackendFlags_HasGamepad            = 1 << 0,   // Back-end supports gamepad and currently has one connected.
    ImGuiBackendFlags_HasMouseCursors       = 1 << 1,   // Back-end supports honoring GetMouseCursor() value to change the OS cursor shape.
    ImGuiBackendFlags_HasSetMousePos        = 1 << 2    // Back-end supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).
};

// Enumeration for PushStyleColor() / PopStyleColor()
enum ImGuiCol_
{
    ImGuiCol_Text,
    ImGuiCol_TextDisabled,
    ImGuiCol_WindowBg,              // Background of normal windows
    ImGuiCol_ChildBg,               // Background of child windows
    ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows
    ImGuiCol_Border,
    ImGuiCol_BorderShadow,
    ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input
    ImGuiCol_FrameBgHovered,
    ImGuiCol_FrameBgActive,
    ImGuiCol_TitleBg,
    ImGuiCol_TitleBgActive,
    ImGuiCol_TitleBgCollapsed,
    ImGuiCol_MenuBarBg,
    ImGuiCol_ScrollbarBg,
    ImGuiCol_ScrollbarGrab,
    ImGuiCol_ScrollbarGrabHovered,
    ImGuiCol_ScrollbarGrabActive,
    ImGuiCol_CheckMark,
    ImGuiCol_SliderGrab,
    ImGuiCol_SliderGrabActive,
    ImGuiCol_Button,
    ImGuiCol_ButtonHovered,
    ImGuiCol_ButtonActive,
    ImGuiCol_Header,
    ImGuiCol_HeaderHovered,
    ImGuiCol_HeaderActive,
    ImGuiCol_Separator,
    ImGuiCol_SeparatorHovered,
    ImGuiCol_SeparatorActive,
    ImGuiCol_ResizeGrip,
    ImGuiCol_ResizeGripHovered,
    ImGuiCol_ResizeGripActive,
    ImGuiCol_Tab,
    ImGuiCol_TabHovered,
    ImGuiCol_TabActive,
    ImGuiCol_TabUnfocused,
    ImGuiCol_TabUnfocusedActive,
    ImGuiCol_PlotLines,
    ImGuiCol_PlotLinesHovered,
    ImGuiCol_PlotHistogram,
    ImGuiCol_PlotHistogramHovered,
    ImGuiCol_TextSelectedBg,
    ImGuiCol_DragDropTarget,
    ImGuiCol_NavHighlight,          // Gamepad/keyboard: current highlighted item
    ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB
    ImGuiCol_NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active
    ImGuiCol_ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active
    ImGuiCol_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiCol_ChildWindowBg = ImGuiCol_ChildBg, ImGuiCol_Column = ImGuiCol_Separator, ImGuiCol_ColumnHovered = ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive = ImGuiCol_SeparatorActive
    , ImGuiCol_ModalWindowDarkening = ImGuiCol_ModalWindowDimBg
    //ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered, // [unused since 1.60+] the close button now uses regular button colors.
    //ImGuiCol_ComboBg,                                                              // [unused since 1.53+] ComboBg has been merged with PopupBg, so a redirect isn't accurate.
#endif
};

// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.
// NB: the enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code. During initialization, feel free to just poke into ImGuiStyle directly.
// NB: if changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.
enum ImGuiStyleVar_
{
    // Enum name ......................// Member in ImGuiStyle structure (see ImGuiStyle for descriptions)
    ImGuiStyleVar_Alpha,               // float     Alpha
    ImGuiStyleVar_WindowPadding,       // ImVec2    WindowPadding
    ImGuiStyleVar_WindowRounding,      // float     WindowRounding
    ImGuiStyleVar_WindowBorderSize,    // float     WindowBorderSize
    ImGuiStyleVar_WindowMinSize,       // ImVec2    WindowMinSize
    ImGuiStyleVar_WindowTitleAlign,    // ImVec2    WindowTitleAlign
    ImGuiStyleVar_ChildRounding,       // float     ChildRounding
    ImGuiStyleVar_ChildBorderSize,     // float     ChildBorderSize
    ImGuiStyleVar_PopupRounding,       // float     PopupRounding
    ImGuiStyleVar_PopupBorderSize,     // float     PopupBorderSize
    ImGuiStyleVar_FramePadding,        // ImVec2    FramePadding
    ImGuiStyleVar_FrameRounding,       // float     FrameRounding
    ImGuiStyleVar_FrameBorderSize,     // float     FrameBorderSize
    ImGuiStyleVar_ItemSpacing,         // ImVec2    ItemSpacing
    ImGuiStyleVar_ItemInnerSpacing,    // ImVec2    ItemInnerSpacing
    ImGuiStyleVar_IndentSpacing,       // float     IndentSpacing
    ImGuiStyleVar_ScrollbarSize,       // float     ScrollbarSize
    ImGuiStyleVar_ScrollbarRounding,   // float     ScrollbarRounding
    ImGuiStyleVar_GrabMinSize,         // float     GrabMinSize
    ImGuiStyleVar_GrabRounding,        // float     GrabRounding
    ImGuiStyleVar_TabRounding,         // float     TabRounding
    ImGuiStyleVar_ButtonTextAlign,     // ImVec2    ButtonTextAlign
    ImGuiStyleVar_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiStyleVar_Count_ = ImGuiStyleVar_COUNT, ImGuiStyleVar_ChildWindowRounding = ImGuiStyleVar_ChildRounding
#endif
};

// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()
enum ImGuiColorEditFlags_
{
    ImGuiColorEditFlags_None            = 0,
    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (read 3 components from the input pointer).
    ImGuiColorEditFlags_NoPicker        = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.
    ImGuiColorEditFlags_NoOptions       = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)
    ImGuiColorEditFlags_NoInputs        = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).
    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
    ImGuiColorEditFlags_NoLabel         = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.
    ImGuiColorEditFlags_NoDragDrop      = 1 << 9,   //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.

    // User Options (right-click on widget to change some of them). You can set application defaults using SetColorEditOptions(). The idea is that you probably don't want to override them in most of your calls, let the user choose and/or call SetColorEditOptions() during startup.
    ImGuiColorEditFlags_AlphaBar        = 1 << 16,  //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
    ImGuiColorEditFlags_AlphaPreview    = 1 << 17,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
    ImGuiColorEditFlags_HDR             = 1 << 19,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).
    ImGuiColorEditFlags_RGB             = 1 << 20,  // [Inputs]     // ColorEdit: choose one among RGB/HSV/HEX. ColorPicker: choose any combination using RGB/HSV/HEX.
    ImGuiColorEditFlags_HSV             = 1 << 21,  // [Inputs]     // "
    ImGuiColorEditFlags_HEX             = 1 << 22,  // [Inputs]     // "
    ImGuiColorEditFlags_Uint8           = 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
    ImGuiColorEditFlags_Float           = 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
    ImGuiColorEditFlags_PickerHueBar    = 1 << 25,  // [PickerMode] // ColorPicker: bar for Hue, rectangle for Sat/Value.
    ImGuiColorEditFlags_PickerHueWheel  = 1 << 26,  // [PickerMode] // ColorPicker: wheel for Hue, triangle for Sat/Value.

    // [Internal] Masks
    ImGuiColorEditFlags__InputsMask     = ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_HSV|ImGuiColorEditFlags_HEX,
    ImGuiColorEditFlags__DataTypeMask   = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_Float,
    ImGuiColorEditFlags__PickerMask     = ImGuiColorEditFlags_PickerHueWheel|ImGuiColorEditFlags_PickerHueBar,
    ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_PickerHueBar    // Change application default using SetColorEditOptions()
};

// Enumeration for GetMouseCursor()
// User code may request binding to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here
enum ImGuiMouseCursor_
{
    ImGuiMouseCursor_None = -1,
    ImGuiMouseCursor_Arrow = 0,
    ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.
    ImGuiMouseCursor_ResizeAll,         // (Unused by imgui functions)
    ImGuiMouseCursor_ResizeNS,          // When hovering over an horizontal border
    ImGuiMouseCursor_ResizeEW,          // When hovering over a vertical border or a column
    ImGuiMouseCursor_ResizeNESW,        // When hovering over the bottom-left corner of a window
    ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window
    ImGuiMouseCursor_Hand,              // (Unused by imgui functions. Use for e.g. hyperlinks)
    ImGuiMouseCursor_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiMouseCursor_Count_ = ImGuiMouseCursor_COUNT
#endif
};

// Enumateration for ImGui::SetWindow***(), SetNextWindow***(), SetNextTreeNode***() functions
// Represent a condition.
// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.
enum ImGuiCond_
{
    ImGuiCond_Always        = 1 << 0,   // Set the variable
    ImGuiCond_Once          = 1 << 1,   // Set the variable once per runtime session (only the first call with succeed)
    ImGuiCond_FirstUseEver  = 1 << 2,   // Set the variable if the object/window has no persistently saved data (no entry in .ini file)
    ImGuiCond_Appearing     = 1 << 3    // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiSetCond_Always = ImGuiCond_Always, ImGuiSetCond_Once = ImGuiCond_Once, ImGuiSetCond_FirstUseEver = ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing = ImGuiCond_Appearing
#endif
};

//-----------------------------------------------------------------------------
// ImGuiStyle
// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().
// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values, 
// and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.
//-----------------------------------------------------------------------------

struct ImGuiStyle
{
    float       Alpha;                      // Global alpha applies to everything in ImGui.
    ImVec2      WindowPadding;              // Padding within a window.
    float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows.
    float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      WindowMinSize;              // Minimum window size. This is a global setting. If you want to constraint individual windows, use SetNextWindowSizeConstraints().
    ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
    float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
    float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    float       PopupRounding;              // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)
    float       PopupBorderSize;            // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets).
    float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
    float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines.
    ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
    ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
    float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
    float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns.
    float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar.
    float       ScrollbarRounding;          // Radius of grab corners for scrollbar.
    float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.
    float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
    float       TabRounding;                // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
    float       TabBorderSize;              // Thickness of border around tabs. 
    ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f,0.5f) for horizontally+vertically centered.
    ImVec2      DisplayWindowPadding;       // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.
    ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly!
    float       MouseCursorScale;           // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
    bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.
    bool        AntiAliasedFill;            // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
    float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
    ImVec4      Colors[ImGuiCol_COUNT];

    IMGUI_API ImGuiStyle();
    IMGUI_API void ScaleAllSizes(float scale_factor);
};

//-----------------------------------------------------------------------------
// ImGuiIO
// Communicate most settings and inputs/outputs to Dear ImGui using this structure. 
// Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.
//-----------------------------------------------------------------------------

struct ImGuiIO
{
    //------------------------------------------------------------------
    // Configuration (fill once)            // Default value:
    //------------------------------------------------------------------

    ImGuiConfigFlags   ConfigFlags;         // = 0                  // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
    ImGuiBackendFlags  BackendFlags;        // = 0                  // See ImGuiBackendFlags_ enum. Set by back-end (imgui_impl_xxx files or custom back-end) to communicate features supported by the back-end.
    ImVec2        DisplaySize;              // <unset>              // Main display size, in pixels. For clamping windows positions.
    float         DeltaTime;                // = 1.0f/60.0f         // Time elapsed since last frame, in seconds.
    float         IniSavingRate;            // = 5.0f               // Minimum time between saving positions/sizes to .ini file, in seconds.
    const char*   IniFilename;              // = "imgui.ini"        // Path to .ini file. Set NULL to disable automatic .ini loading/saving, if e.g. you want to manually load/save from memory.
    const char*   LogFilename;              // = "imgui_log.txt"    // Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
    float         MouseDoubleClickTime;     // = 0.30f              // Time for a double-click, in seconds.
    float         MouseDoubleClickMaxDist;  // = 6.0f               // Distance threshold to stay in to validate a double-click, in pixels.
    float         MouseDragThreshold;       // = 6.0f               // Distance threshold before considering we are dragging.
    int           KeyMap[ImGuiKey_COUNT];   // <unset>              // Map of indices into the KeysDown[512] entries array which represent your "native" keyboard state.
    float         KeyRepeatDelay;           // = 0.250f             // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
    float         KeyRepeatRate;            // = 0.050f             // When holding a key/button, rate at which it repeats, in seconds.
    void*         UserData;                 // = NULL               // Store your own data for retrieval by callbacks.

    ImFontAtlas*  Fonts;                    // <auto>               // Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.
    float         FontGlobalScale;          // = 1.0f               // Global scale all fonts
    bool          FontAllowUserScaling;     // = false              // Allow user scaling text of individual window with CTRL+Wheel.
    ImFont*       FontDefault;              // = NULL               // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
    ImVec2        DisplayFramebufferScale;  // = (1.0f,1.0f)        // For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.
    ImVec2        DisplayVisibleMin;        // <unset> (0.0f,0.0f)  // [OBSOLETE] If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin/Max to the visible area.
    ImVec2        DisplayVisibleMax;        // <unset> (0.0f,0.0f)  // [OBSOLETE: just use io.DisplaySize!] If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize

    // Miscellaneous configuration options
    bool          MouseDrawCursor;                  // = false      // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by back-end implementations.
    bool          ConfigMacOSXBehaviors;            // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text LoopCallback and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl (was called io.OptMacOSXBehaviors prior to 1.63)
    bool          ConfigInputTextCursorBlink;       // = true       // Set to false to disable blinking cursor, for users who consider it distracting. (was called: io.OptCursorBlink prior to 1.63)
    bool          ConfigWindowsResizeFromEdges;     // = true       // Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be the a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
    bool          ConfigWindowsMoveFromTitleBarOnly;// = false      // [BETA] Set to true to only allow moving windows when clicked+dragged from the title bar. Windows without a title bar are not affected.

    //------------------------------------------------------------------
    // Platform Functions
    // (the imgui_impl_xxxx back-end files are setting those up for you)
    //------------------------------------------------------------------

    // Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window)
    const char* BackendPlatformName;
    const char* BackendRendererName;

    // Optional: Access OS clipboard
    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
    const char* (*GetClipboardTextFn)(void* user_data);
    void        (*SetClipboardTextFn)(void* user_data, const char* text);
    void*       ClipboardUserData;

    // Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)
    // (default to use native imm32 api on Windows)
    void        (*ImeSetInputScreenPosFn)(int x, int y);
    void*       ImeWindowHandle;                // (Windows) Set this to your HWND to get automatic IME cursor positioning.

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    // [OBSOLETE since 1.60+] Rendering function, will be automatically called in Render(). Please call your rendering function yourself now!
    // You can obtain the ImDrawData* by calling ImGui::GetDrawData() after Render(). See example applications if you are unsure of how to implement this.
    void        (*RenderDrawListsFn)(ImDrawData* data);
#else
    // This is only here to keep ImGuiIO the same size, so that IMGUI_DISABLE_OBSOLETE_FUNCTIONS can exceptionally be used outside of imconfig.h.
    void*       RenderDrawListsFnUnused;
#endif

    //------------------------------------------------------------------
    // Input - Fill before calling NewFrame()
    //------------------------------------------------------------------

    ImVec2      MousePos;                       // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)
    bool        MouseDown[5];                   // Mouse buttons: 0=left, 1=right, 2=middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
    float       MouseWheel;                     // Mouse wheel Vertical: 1 unit scrolls about 5 lines text.
    float       MouseWheelH;                    // Mouse wheel Horizontal. Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.
    bool        KeyCtrl;                        // Keyboard modifier pressed: Control
    bool        KeyShift;                       // Keyboard modifier pressed: Shift
    bool        KeyAlt;                         // Keyboard modifier pressed: Alt
    bool        KeySuper;                       // Keyboard modifier pressed: Cmd/Super/Windows
    bool        KeysDown[512];                  // Keyboard keys that are pressed (ideally left in the "native" order your engine has access to keyboard keys, so you can use your own defines/enums for keys).
    ImWchar     InputCharacters[16+1];          // List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.
    float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs (keyboard keys will be auto-mapped and be written here by ImGui::NewFrame, all values will be cleared back to zero in ImGui::EndFrame)

    // Functions
    IMGUI_API void AddInputCharacter(ImWchar c);                        // Add new character into InputCharacters[]
    IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      // Add new characters into InputCharacters[] from an UTF-8 string
    inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   // Clear the text input buffer manually

    //------------------------------------------------------------------
    // Output - Retrieve after calling NewFrame()
    //------------------------------------------------------------------

    bool        WantCaptureMouse;           // When io.WantCaptureMouse is true, imgui will use the mouse inputs, do not dispatch them to your main game/application (in both cases, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
    bool        WantCaptureKeyboard;        // When io.WantCaptureKeyboard is true, imgui will use the keyboard inputs, do not dispatch them to your main game/application (in both cases, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
    bool        WantTextInput;              // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
    bool        WantSetMousePos;            // MousePos has been altered, back-end should reposition mouse on next frame. Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.
    bool        WantSaveIniSettings;        // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.
    bool        NavActive;                  // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
    bool        NavVisible;                 // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).
    float       Framerate;                  // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames
    int         MetricsRenderVertices;      // Vertices output during last call to Render()
    int         MetricsRenderIndices;       // Indices output during last call to Render() = number of triangles * 3
    int         MetricsRenderWindows;       // Number of visible windows
    int         MetricsActiveWindows;       // Number of active windows
    int         MetricsActiveAllocations;   // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.
    ImVec2      MouseDelta;                 // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.

    //------------------------------------------------------------------
    // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!
    //------------------------------------------------------------------

    ImVec2      MousePosPrev;               // Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
    ImVec2      MouseClickedPos[5];         // Position at time of clicking
    double      MouseClickedTime[5];        // Time of last click (used to figure out double-click)
    bool        MouseClicked[5];            // Mouse button went from !Down to Down
    bool        MouseDoubleClicked[5];      // Has mouse button been double-clicked?
    bool        MouseReleased[5];           // Mouse button went from Down to !Down
    bool        MouseDownOwned[5];          // Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.
    float       MouseDownDuration[5];       // Duration the mouse button has been down (0.0f == just clicked)
    float       MouseDownDurationPrev[5];   // Previous time the mouse button has been down
    ImVec2      MouseDragMaxDistanceAbs[5]; // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
    float       MouseDragMaxDistanceSqr[5]; // Squared maximum distance of how much mouse has traveled from the clicking point
    float       KeysDownDuration[512];      // Duration the keyboard key has been down (0.0f == just pressed)
    float       KeysDownDurationPrev[512];  // Previous duration the key has been down
    float       NavInputsDownDuration[ImGuiNavInput_COUNT];
    float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];

    IMGUI_API   ImGuiIO();
};

//-----------------------------------------------------------------------------
// Misc data structures
//-----------------------------------------------------------------------------

// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.
// The callback function should return 0 by default.
// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)
// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB
// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows
// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration
// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. 
struct ImGuiInputTextCallbackData
{
    ImGuiInputTextFlags EventFlag;      // One ImGuiInputTextFlags_Callback*    // Read-only
    ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only
    void*               UserData;       // What user passed to InputText()      // Read-only

    // Arguments for the different callback events
    // - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.
    // - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.
    ImWchar             EventChar;      // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
    ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
    char*               Buf;            // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
    int                 BufTextLen;     // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
    int                 BufSize;        // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
    bool                BufDirty;       // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
    int                 CursorPos;      //                                      // Read-write   // [Completion,History,Always]
    int                 SelectionLoopCallback; //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
    int                 SelectionEnd;   //                                      // Read-write   // [Completion,History,Always]

    // Helper functions for text manipulation.
    // Use those function to benefit from the CallbackResize behaviors. Calling those function reset the selection.
    IMGUI_API ImGuiInputTextCallbackData();
    IMGUI_API void      DeleteChars(int pos, int bytes_count);
    IMGUI_API void      InsertChars(int pos, const char* text, const char* text_end = NULL);
    bool                HasSelection() const { return SelectionLoopCallback != SelectionEnd; }
};

// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
struct ImGuiSizeCallbackData
{
    void*   UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints()
    ImVec2  Pos;            // Read-only.   Window position, for reference.
    ImVec2  CurrentSize;    // Read-only.   Current window size.
    ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
};

// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()
struct ImGuiPayload
{
    // Members
    void*           Data;               // Data (copied and owned by dear imgui)
    int             DataSize;           // Data size

    // [Internal]
    ImGuiID         SourceId;           // Source item id
    ImGuiID         SourceParentId;     // Source parent id (if available)
    int             DataFrameCount;     // Data timestamp
    char            DataType[32+1];     // Data type tag (short user-supplied string, 32 characters max)
    bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
    bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.

    ImGuiPayload()  { Clear(); }
    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
    bool IsPreview() const                  { return Preview; }
    bool IsDelivery() const                 { return Delivery; }
};

//-----------------------------------------------------------------------------
// Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)
//-----------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
namespace ImGui
{
    // OBSOLETED in 1.66 (from Sep 2018)
    static inline void  SetScrollHere(float center_ratio=0.5f){ SetScrollHereY(center_ratio); }
    // OBSOLETED in 1.63 (from Aug 2018)
    static inline bool  IsItemDeactivatedAfterChange()        { return IsItemDeactivatedAfterEdit(); }
    // OBSOLETED in 1.61 (from Apr 2018)
    IMGUI_API bool      InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags = 0); // Use the 'const char* format' version instead of 'decimal_precision'!
    IMGUI_API bool      InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool      InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags = 0);
    IMGUI_API bool      InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags = 0);
    // OBSOLETED in 1.60 (from Dec 2017)
    static inline bool  IsAnyWindowFocused()                  { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }
    static inline bool  IsAnyWindowHovered()                  { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }
    static inline ImVec2 CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = 0.f) { (void)on_edge; (void)outward; IM_ASSERT(0); return pos; }
    // OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)
    static inline void  ShowTestWindow()                      { return ShowDemoWindow(); }
    static inline bool  IsRootWindowFocused()                 { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); }
    static inline bool  IsRootWindowOrAnyChildFocused()       { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); }
    static inline void  SetNextWindowContentWidth(float w)    { SetNextWindowContentSize(ImVec2(w, 0.0f)); }
    static inline float GetItemsLineHeightWithSpacing()       { return GetFrameHeightWithSpacing(); }
    // OBSOLETED in 1.52 (between Aug 2017 and Oct 2017)
    IMGUI_API bool      Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha_override = -1.0f, ImGuiWindowFlags flags = 0); // Use SetNextWindowSize(size, ImGuiCond_FirstUseEver) + SetNextWindowBgAlpha() instead.
    static inline bool  IsRootWindowOrAnyChildHovered()       { return IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows); }
    static inline void  AlignFirstTextHeightToWidgets()       { AlignTextToFramePadding(); }
    static inline void  SetNextWindowPosCenter(ImGuiCond c=0) { ImGuiIO& io = GetIO(); SetNextWindowPos(ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f), c, ImVec2(0.5f, 0.5f)); }
    // OBSOLETED in 1.51 (between Jun 2017 and Aug 2017)
    static inline bool  IsItemHoveredRect()                   { return IsItemHovered(ImGuiHoveredFlags_RectOnly); }
    static inline bool  IsPosHoveringAnyWindow(const ImVec2&) { IM_ASSERT(0); return false; } // This was misleading and partly broken. You probably want to use the ImGui::GetIO().WantCaptureMouse flag instead.
    static inline bool  IsMouseHoveringAnyWindow()            { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }
    static inline bool  IsMouseHoveringWindow()               { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); }
}
typedef ImGuiInputTextCallback      ImGuiTextEditCallback;      // OBSOLETE in 1.63 (from Aug 2018): made the names consistent
typedef ImGuiInputTextCallbackData  ImGuiTextEditCallbackData;
#endif

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

// Helper: Lightweight std::vector<> like class to avoid dragging dependencies (also: Windows implementation of STL with debug enabled is absurdly slow, so let's bypass it so our code runs fast in debug).
// *Important* Our implementation does NOT call C++ constructors/destructors. This is intentional, we do not require it but you have to be mindful of that. Do _not_ use this class as a std::vector replacement in your code!
template<typename T>
class ImVector
{
public:
    int                         Size;
    int                         Capacity;
    T*                          Data;

    typedef T                   value_type;
    typedef value_type*         iterator;
    typedef const value_type*   const_iterator;

    inline ImVector()           { Size = Capacity = 0; Data = NULL; }
    inline ~ImVector()          { if (Data) ImGui::MemFree(Data); }
    inline ImVector(const ImVector<T>& src)                     { Size = Capacity = 0; Data = NULL; operator=(src); }
    inline ImVector<T>& operator=(const ImVector<T>& src)       { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(value_type)); return *this; }

    inline bool                 empty() const                   { return Size == 0; }
    inline int                  size() const                    { return Size; }
    inline int                  capacity() const                { return Capacity; }
    inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }
    inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }

    inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }
    inline iterator             begin()                         { return Data; }
    inline const_iterator       begin() const                   { return Data; }
    inline iterator             end()                           { return Data + Size; }
    inline const_iterator       end() const                     { return Data + Size; }
    inline value_type&          front()                         { IM_ASSERT(Size > 0); return Data[0]; }
    inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }
    inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size - 1]; }
    inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size - 1]; }
    inline void                 swap(ImVector<value_type>& rhs) { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

    inline int          _grow_capacity(int sz) const            { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }
    inline void         resize(int new_size)                    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
    inline void         resize(int new_size,const value_type& v){ if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
    inline void         reserve(int new_capacity)
    {
        if (new_capacity <= Capacity)
            return;
        value_type* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));
        if (Data)
        {
            memcpy(new_data, Data, (size_t)Size * sizeof(value_type));
            ImGui::MemFree(Data);
        }
        Data = new_data;
        Capacity = new_capacity;
    }

    // NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.
    inline void         push_back(const value_type& v)                  { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
    inline void         pop_back()                                      { IM_ASSERT(Size > 0); Size--; }
    inline void         push_front(const value_type& v)                 { if (Size == 0) push_back(v); else insert(Data, v); }
    inline iterator     erase(const_iterator it)                        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }
    inline iterator     erase(const_iterator it, const_iterator it_last){ IM_ASSERT(it >= Data && it < Data+Size && it_last > it && it_last <= Data+Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - count) * sizeof(value_type)); Size -= (int)count; return Data + off; }
    inline iterator     erase_unsorted(const_iterator it)               { IM_ASSERT(it >= Data && it < Data+Size);  const ptrdiff_t off = it - Data; if (it < Data+Size-1) memcpy(Data + off, Data + Size - 1, sizeof(value_type)); Size--; return Data + off; }
    inline iterator     insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
    inline bool         contains(const value_type& v) const             { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
    inline int          index_from_pointer(const_iterator it) const     { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; return (int)off; }
};

// Helper: IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE() macros to call MemAlloc + Placement New, Placement Delete + MemFree
// We call C++ constructor on own allocated memory via the placement "new(ptr) Type()" syntax.
// Defining a custom placement new() with a dummy parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.
struct ImNewDummy {};
inline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }
inline void  operator delete(void*, ImNewDummy, void*)   {} // This is only required so we can use the symetrical new()
#define IM_PLACEMENT_NEW(_PTR)              new(ImNewDummy(), _PTR)
#define IM_NEW(_TYPE)                       new(ImNewDummy(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame.
// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");
struct ImGuiOnceUponAFrame
{
    ImGuiOnceUponAFrame() { RefFrame = -1; }
    mutable int RefFrame;
    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }
};

// Helper: Macro for ImGuiOnceUponAFrame. Attention: The macro expands into 2 statement so make sure you don't use it within e.g. an if() statement without curly braces.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS    // Will obsolete
#define IMGUI_ONCE_UPON_A_FRAME     static ImGuiOnceUponAFrame imgui_oaf; if (imgui_oaf)
#endif

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
struct ImGuiTextFilter
{
    IMGUI_API           ImGuiTextFilter(const char* default_filter = "");
    IMGUI_API bool      Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);    // Helper calling InputText+Build
    IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;
    IMGUI_API void      Build();
    void                Clear()          { InputBuf[0] = 0; Build(); }
    bool                IsActive() const { return !Filters.empty(); }

    // [Internal]
    struct TextRange
    {
        const char* b;
        const char* e;

        TextRange() { b = e = NULL; }
        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }
        const char*     begin() const   { return b; }
        const char*     end () const    { return e; }
        bool            empty() const   { return b == e; }
        IMGUI_API void  split(char separator, ImVector<TextRange>* out) const;
    };
    char                InputBuf[256];
    ImVector<TextRange> Filters;
    int                 CountGrep;
};

// Helper: Growable text buffer for logging/accumulating text
// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')
struct ImGuiTextBuffer
{
    ImVector<char>      Buf;
    static char         EmptyString[1];

    ImGuiTextBuffer()   { }
    inline char         operator[](int i)       { IM_ASSERT(Buf.Data != NULL); return Buf.Data[i]; }
    const char*         begin() const           { return Buf.Data ? &Buf.front() : EmptyString; }
    const char*         end() const             { return Buf.Data ? &Buf.back() : EmptyString; }   // Buf is zero-terminated, so end() will point on the zero-terminator
    int                 size() const            { return Buf.Data ? Buf.Size - 1 : 0; }
    bool                empty()                 { return Buf.Size <= 1; }
    void                clear()                 { Buf.clear(); }
    void                reserve(int capacity)   { Buf.reserve(capacity); }
    const char*         c_str() const           { return Buf.Data ? Buf.Data : EmptyString; }
    IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);
    IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);
};

// Helper: Key->Value storage
// Typically you don't have to worry about this since a storage is held within each Window.
// We use it to e.g. store collapse state for a tree (Int 0/1)
// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
// You can use it as custom user storage for temporary values. Declare your own storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
struct ImGuiStorage
{
    struct Pair
    {
        ImGuiID key;
        union { int val_i; float val_f; void* val_p; };
        Pair(ImGuiID _key, int _val_i)   { key = _key; val_i = _val_i; }
        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }
        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }
    };
    ImVector<Pair>      Data;

    // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
    // - Set***() functions find pair, insertion on demand if missing.
    // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
    void                Clear() { Data.clear(); }
    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;
    IMGUI_API void      SetInt(ImGuiID key, int val);
    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;
    IMGUI_API void      SetBool(ImGuiID key, bool val);
    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;
    IMGUI_API void      SetFloat(ImGuiID key, float val);
    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL
    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);

    // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
    // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
    // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
    //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);
    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);
    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);
    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);

    // Use on your own storage if you know only integer are being stored (open/close all tree nodes)
    IMGUI_API void      SetAllInt(int val);

    // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
    IMGUI_API void      BuildSortByKey();
};

// Helper: Manually clip large list of items.
// If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null.
// Usage:
//     ImGuiListClipper clipper(1000);  // we have 1000 elements, evenly spaced.
//     while (clipper.Step())
//         for (int i = clipper.DisplayLoopCallback; i < clipper.DisplayEnd; i++)
//             ImGui::Text("line number %d", i);
// - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor).
// - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
// - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.)
// - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
struct ImGuiListClipper
{
    float   LoopCallbackPosY;
    float   ItemsHeight;
    int     ItemsCount, StepNo, DisplayLoopCallback, DisplayEnd;

    // items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).
    // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().
    // If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().
    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).
    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.

    IMGUI_API bool Step();                                              // Call until it returns false. The DisplayLoopCallback/DisplayEnd fields will be set and you can process/draw those items.
    IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.
    IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.
};

// Helpers macros to generate 32-bits encoded colors
#ifdef IMGUI_USE_BGRA_PACKED_COLOR
#define IM_COL32_R_SHIFT    16
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    0
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#else
#define IM_COL32_R_SHIFT    0
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    16
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#endif
#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black
#define IM_COL32_BLACK_TRANS IM_COL32(0,0,0,0)          // Transparent black = 0x00000000

// Helper: ImColor() implicity converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)
// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.
// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.
// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.
struct ImColor
{
    ImVec4              Value;

    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }
    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }
    ImColor(ImU32 rgba)                                             { float sc = 1.0f/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }
    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }
    ImColor(const ImVec4& col)                                      { Value = col; }
    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }
    inline operator ImVec4() const                                  { return Value; }

    // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }
    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }
};

//-----------------------------------------------------------------------------
// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)
// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.
//-----------------------------------------------------------------------------

// Draw callbacks for advanced uses.
// NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering,
// you can poke into the draw list for that! Draw callback may be useful for example to: A) Change your GPU render state, 
// B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc.
// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'
typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);

// Typically, 1 command = 1 GPU draw call (unless command is a callback)
struct ImDrawCmd
{
    unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
    ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates
    ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
    ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
    void*           UserCallbackData;       // The draw callback code can access this.

    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = (ImTextureID)NULL; UserCallback = NULL; UserCallbackData = NULL; }
};

// Vertex index (override with '#define ImDrawIdx unsigned int' in imconfig.h)
#ifndef ImDrawIdx
typedef unsigned short ImDrawIdx;
#endif

// Vertex layout
#ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT
struct ImDrawVert
{
    ImVec2  pos;
    ImVec2  uv;
    ImU32   col;
};
#else
// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h
// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.
// The type has to be described within the macro (you can either declare the struct or use a typedef)
// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.
IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;
#endif

// Draw channels are used by the Columns API to "split" the render list into different channels while building, so items of each column can be batched together.
// You can also use them to simulate drawing layers and submit primitives in a different order than how they will be rendered.
struct ImDrawChannel
{
    ImVector<ImDrawCmd>     CmdBuffer;
    ImVector<ImDrawIdx>     IdxBuffer;
};

enum ImDrawCornerFlags_
{
    ImDrawCornerFlags_TopLeft   = 1 << 0, // 0x1
    ImDrawCornerFlags_TopRight  = 1 << 1, // 0x2
    ImDrawCornerFlags_BotLeft   = 1 << 2, // 0x4
    ImDrawCornerFlags_BotRight  = 1 << 3, // 0x8
    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   // 0x3
    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   // 0xC
    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    // 0x5
    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  // 0xA
    ImDrawCornerFlags_All       = 0xF     // In your function calls you may use ~0 (= all bits sets) instead of ImDrawCornerFlags_All, as a convenience
};

enum ImDrawListFlags_
{
    ImDrawListFlags_None             = 0,
    ImDrawListFlags_AntiAliasedLines = 1 << 0,  // Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles)
    ImDrawListFlags_AntiAliasedFill  = 1 << 1   // Filled shapes have anti-aliased edges (*2 the number of vertices)
};

// Draw command list
// This is the low-level list of polygons that ImGui functions are filling. At the end of the frame, all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each ImGui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), but you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
struct ImDrawList
{
    // This is what you have to render
    ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
    ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those
    ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.
    ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.

    // [Internal, used while building lists]
    const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
    const char*             _OwnerName;         // Pointer to owner window's name for debugging
    unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size
    ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    ImVector<ImVec4>        _ClipRectStack;     // [Internal]
    ImVector<ImTextureID>   _TextureIdStack;    // [Internal]
    ImVector<ImVec2>        _Path;              // [Internal] current path building
    int                     _ChannelsCurrent;   // [Internal] current channel number (0)
    int                     _ChannelsCount;     // [Internal] number of active channels (1+)
    ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)

    // If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)
    ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }
    ~ImDrawList() { ClearFreeMemory(); }
    IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
    IMGUI_API void  PushClipRectFullScreen();
    IMGUI_API void  PopClipRect();
    IMGUI_API void  PushTextureID(ImTextureID texture_id);
    IMGUI_API void  PopTextureID();
    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }

    // Primitives
    IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round
    IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right
    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
    IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);
    IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);
    IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);
    IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);
    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);
    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);
    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);
    IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);
    IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);
    IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);
    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col); // Note: Anti-aliased filling requires points to be in clockwise order.
    IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);

    // Stateful path API, add points then finish with PathFillConvex() or PathStroke()
    inline    void  PathClear()                                                 { _Path.resize(0); }
    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }
    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); PathClear(); }  // Note: Anti-aliased filling requires points to be in clockwise order.
    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); PathClear(); }
    IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);
    IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                            // Use precomputed angles for a 12 steps circle
    IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);
    IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);

    // Channels
    // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)
    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)
    IMGUI_API void  ChannelsSplit(int channels_count);
    IMGUI_API void  ChannelsMerge();
    IMGUI_API void  ChannelsSetCurrent(int channel_index);

    // Advanced
    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.
    IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
    IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.

    // Internal helpers
    // NB: all primitives needs to be reserved via PrimReserve() beforehand!
    IMGUI_API void  Clear();
    IMGUI_API void  ClearFreeMemory();
    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);
    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)
    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
    IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }
    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }
    IMGUI_API void  UpdateClipRect();
    IMGUI_API void  UpdateTextureID();
};

// All draw data to render an ImGui frame
// (NB: the style and the naming convention here is a little inconsistent but we preserve them for backward compatibility purpose)
struct ImDrawData
{
    bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.
    ImDrawList**    CmdLists;               // Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.
    int             CmdListsCount;          // Number of ImDrawList* to render
    int             TotalIdxCount;          // For convenience, sum of all ImDrawList's IdxBuffer.Size
    int             TotalVtxCount;          // For convenience, sum of all ImDrawList's VtxBuffer.Size
    ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)
    ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)

    // Functions
    ImDrawData()    { Valid = false; Clear(); }
    ~ImDrawData()   { Clear(); }
    void Clear()    { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; DisplayPos = DisplaySize = ImVec2(0.f, 0.f); } // The ImDrawList are owned by ImGuiContext!
    IMGUI_API void  DeIndexAllBuffers();                // Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
    IMGUI_API void  ScaleClipRects(const ImVec2& sc);   // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
};

//-----------------------------------------------------------------------------
// Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFont)
//-----------------------------------------------------------------------------

struct ImFontConfig
{
    void*           FontData;               //          // TTF/OTF data
    int             FontDataSize;           //          // TTF/OTF data size
    bool            FontDataOwnedByAtlas;   // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
    int             FontNo;                 // 0        // Index of font within TTF/OTF file
    float           SizePixels;             //          // Size in pixels for rasterizer (more or less maps to the resulting font height).
    int             OversampleH;            // 3        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
    int             OversampleV;            // 1        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
    bool            PixelSnapH;             // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
    ImVec2          GlyphExtraSpacing;      // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
    ImVec2          GlyphOffset;            // 0, 0     // Offset all glyphs from this font input.
    const ImWchar*  GlyphRanges;            // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
    float           GlyphMinAdvanceX;       // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
    float           GlyphMaxAdvanceX;       // FLT_MAX  // Maximum AdvanceX for glyphs
    bool            MergeMode;              // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
    unsigned int    RasterizerFlags;        // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
    float           RasterizerMultiply;     // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.

    // [Internal]
    char            Name[40];               // Name (strictly to ease debugging)
    ImFont*         DstFont;

    IMGUI_API ImFontConfig();
};

struct ImFontGlyph
{
    ImWchar         Codepoint;          // 0x0000..0xFFFF
    float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
    float           X0, Y0, X1, Y1;     // Glyph corners
    float           U0, V0, U1, V1;     // Texture coordinates
};

enum ImFontAtlasFlags_
{
    ImFontAtlasFlags_None               = 0,
    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two
    ImFontAtlasFlags_NoMouseCursors     = 1 << 1    // Don't build software mouse cursors into the atlas
};

// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:
//  - One or more fonts.
//  - Custom graphics data needed to render the shapes needed by Dear ImGui.
//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).
// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.
//  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.
//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.
//  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)
//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API. 
//    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.
// Common pitfalls:
// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the 
//   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.
// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.
//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed, 
// - Even though many functions are suffixed with "TTF", OTF data is supported just as well.
// - This is an old API and it is currently awkward for those and and various other reasons! We will address them in the future!
struct ImFontAtlas
{
    IMGUI_API ImFontAtlas();
    IMGUI_API ~ImFontAtlas();
    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);
    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);
    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);
    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.
    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
    IMGUI_API void              ClearInputData();           // Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.
    IMGUI_API void              ClearTexData();             // Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.
    IMGUI_API void              ClearFonts();               // Clear output font data (glyphs storage, UV coordinates).
    IMGUI_API void              Clear();                    // Clear all input and output.

    // Build atlas, retrieve pixel data.
    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
    // The pitch is always = Width * BytesPerPixels (1 or 4)
    // Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into 
    // the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.
    IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.
    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel
    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel
    bool                        IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }
    void                        SetTexID(ImTextureID id)    { TexID = id; }

    //-------------------------------------------
    // Glyph Ranges
    //-------------------------------------------

    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
    // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.
    // NB: Consider using GlyphRangesBuilder to build glyph ranges from textual data.
    IMGUI_API const ImWchar*    GetGlyphRangesDefault();                // Basic Latin, Extended Latin
    IMGUI_API const ImWchar*    GetGlyphRangesKorean();                 // Default + Korean characters
    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();               // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs
    IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
    IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();               // Default + about 400 Cyrillic characters
    IMGUI_API const ImWchar*    GetGlyphRangesThai();                   // Default + Thai characters

    // Helpers to build glyph ranges from text data. Feed your application strings/characters to it then call BuildRanges().
    struct GlyphRangesBuilder
    {
        ImVector<unsigned char> UsedChars;  // Store 1-bit per Unicode code point (0=unused, 1=used)
        GlyphRangesBuilder()                { UsedChars.resize(0x10000 / 8); memset(UsedChars.Data, 0, 0x10000 / 8); }
        bool           GetBit(int n) const  { return (UsedChars[n >> 3] & (1 << (n & 7))) != 0; }
        void           SetBit(int n)        { UsedChars[n >> 3] |= 1 << (n & 7); }  // Set bit 'c' in the array
        void           AddChar(ImWchar c)   { SetBit(c); }                          // Add character
        IMGUI_API void AddText(const char* text, const char* text_end = NULL);      // Add string (each character of the UTF-8 string are added)
        IMGUI_API void AddRanges(const ImWchar* ranges);                            // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext
        IMGUI_API void BuildRanges(ImVector<ImWchar>* out_ranges);                  // Output new ranges
    };

    //-------------------------------------------
    // Custom Rectangles/Glyphs API
    //-------------------------------------------

    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.
    // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.
    struct CustomRect
    {
        unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.
        unsigned short  Width, Height;  // Input    // Desired rectangle dimension
        unsigned short  X, Y;           // Output   // Packed position in Atlas
        float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance
        ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset
        ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font
        CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }
        bool IsPacked() const   { return X != 0xFFFF; }
    };

    IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList
    IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.
    const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }

    // [Internal]
    IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);
    IMGUI_API bool      GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);

    //-------------------------------------------
    // Members
    //-------------------------------------------

    bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
    ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)
    ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
    int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
    int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1.

    // [Internal]
    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
    unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
    unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
    int                         TexWidth;           // Texture width calculated during Build().
    int                         TexHeight;          // Texture height calculated during Build().
    ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)
    ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel
    ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
    ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.
    ImVector<ImFontConfig>      ConfigData;         // Internal data
    int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList
};

// Font runtime data and rendering
// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
struct ImFont
{
    // Members: Hot ~62/78 bytes
    float                       FontSize;           // <user set>   // Height of characters, set during loading (don't change after loading)
    float                       Scale;              // = 1.f        // Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()
    ImVec2                      DisplayOffset;      // = (0.f,0.f)  // Offset font rendering by xx pixels
    ImVector<ImFontGlyph>       Glyphs;             //              // All glyphs.
    ImVector<float>             IndexAdvanceX;      //              // Sparse. Glyphs->AdvanceX in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).
    ImVector<ImWchar>           IndexLookup;        //              // Sparse. Index glyphs by Unicode code-point.
    const ImFontGlyph*          FallbackGlyph;      // == FindGlyph(FontFallbackChar)
    float                       FallbackAdvanceX;   // == FallbackGlyph->AdvanceX
    ImWchar                     FallbackChar;       // = '?'        // Replacement glyph if one isn't found. Only set via SetFallbackChar()

    // Members: Cold ~18/26 bytes
    short                       ConfigDataCount;    // ~ 1          // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
    ImFontConfig*               ConfigData;         //              // Pointer within ContainerAtlas->ConfigData
    ImFontAtlas*                ContainerAtlas;     //              // What we has been loaded into
    float                       Ascent, Descent;    //              // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
    bool                        DirtyLookupTables;
    int                         MetricsTotalSurface;//              // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)

    // Methods
    IMGUI_API ImFont();
    IMGUI_API ~ImFont();
    IMGUI_API void              ClearOutputData();
    IMGUI_API void              BuildLookupTable();
    IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;
    IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
    IMGUI_API void              SetFallbackChar(ImWchar c);
    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }

    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8
    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
    IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const;
    IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;

    // [Internal]
    IMGUI_API void              GrowIndex(int new_size);
    IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
    IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    typedef ImFontGlyph Glyph; // OBSOLETE 1.52+
#endif
};

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) && __GNUC__ >= 8
#pragma GCC diagnostic pop
#endif

// Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h)
#ifdef IMGUI_INCLUDE_IMGUI_USER_H
#include "imgui_user.h"
#endif

```

`Private Esp/imgui/imgui_demo.cpp`:

```cpp
// dear imgui, v1.67 WIP
// (demo code)

// Message to the person tempted to delete this file when integrating Dear ImGui into their code base:
// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other coders
// will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of 
// your game/app! Removing this file from your project is hindering access to documentation for everyone in your team, 
// likely leading you to poorer usage of the library.
// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().
// If you want to link core Dear ImGui in your shipped builds but want an easy guarantee that the demo will not be linked, 
// you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.
// In other situation, whenever you have Dear ImGui available you probably want this to be available for reference.
// Thank you,
// -Your beloved friend, imgui_demo.cpp (that you won't delete)

// Message to beginner C/C++ programmers about the meaning of the 'static' keyword: 
// In this demo code, we frequently we use 'static' variables inside functions. A static variable persist across calls, so it is 
// essentially like a global variable but declared inside the scope of the function. We do this as a way to gather code and data 
// in the same place, to make the demo source code faster to read, faster to write, and smaller in size.
// It also happens to be a convenient way of storing simple UI related information as long as your function doesn't need to be reentrant
// or used in threads. This might be a pattern you will want to use in your code, but most of the real data you would be editing is 
// likely going to be stored outside your functions.

/*

Index of this file:

// [SECTION] Forward Declarations, Helpers
// [SECTION] Demo Window / ShowDemoWindow()
// [SECTION] About Window / ShowAboutWindow()
// [SECTION] Style Editor / ShowStyleEditor()
// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()
// [SECTION] Example App: Debug Console / ShowExampleAppConsole()
// [SECTION] Example App: Debug Log / ShowExampleAppLog()
// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()
// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()
// [SECTION] Example App: Long Text / ShowExampleAppLongText()
// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()
// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()
// [SECTION] Example App: Simple Overlay / ShowExampleAppSimpleOverlay()
// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()
// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()
// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#include <ctype.h>          // toupper, isprint
#include <limits.h>         // INT_MIN, INT_MAX
#include <math.h>           // sqrtf, powf, cosf, sinf, floorf, ceilf
#include <stdio.h>          // vsnprintf, sscanf, printf
#include <stdlib.h>         // NULL, malloc, free, atoi
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>         // intptr_t
#else
#include <stdint.h>         // intptr_t
#endif

#ifdef _MSC_VER
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#define vsnprintf _vsnprintf
#endif
#ifdef __clang__
#pragma clang diagnostic ignored "-Wold-style-cast"             // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wdeprecated-declarations"    // warning : 'xx' is deprecated: The POSIX name for this item.. // for strdup used in demo code (so user can copy & paste the code)
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"   // warning : cast to 'void *' from smaller integer type 'int'
#pragma clang diagnostic ignored "-Wformat-security"            // warning : warning: format string is not a string literal
#pragma clang diagnostic ignored "-Wexit-time-destructors"      // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
#if __has_warning("-Wreserved-id-macro")
#pragma clang diagnostic ignored "-Wreserved-id-macro"          // warning : macro name is a reserved identifier                //
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"          // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat-security"              // warning : format string is not a string literal (potentially insecure)
#pragma GCC diagnostic ignored "-Wdouble-promotion"             // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"                   // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#if (__GNUC__ >= 6)
#pragma GCC diagnostic ignored "-Wmisleading-indentation"       // warning: this 'if' clause does not guard this statement      // GCC 6.0+ only. See #883 on GitHub.
#endif
#endif

// Play it nice with Windows users. Notepad in 2017 still doesn't display text data with Unix-style \n.
#ifdef _WIN32
#define IM_NEWLINE "\r\n"
#else
#define IM_NEWLINE "\n"
#endif

#define IM_MAX(_A,_B)       (((_A) >= (_B)) ? (_A) : (_B))

//-----------------------------------------------------------------------------
// [SECTION] Forward Declarations, Helpers
//-----------------------------------------------------------------------------

#if !defined(IMGUI_DISABLE_OBSOLETE_FUNCTIONS) && defined(IMGUI_DISABLE_TEST_WINDOWS) && !defined(IMGUI_DISABLE_DEMO_WINDOWS)   // Obsolete name since 1.53, TEST->DEMO
#define IMGUI_DISABLE_DEMO_WINDOWS
#endif

#if !defined(IMGUI_DISABLE_DEMO_WINDOWS)

// Forward Declarations
static void ShowExampleAppDocuments(bool* p_open);
static void ShowExampleAppMainMenuBar();
static void ShowExampleAppConsole(bool* p_open);
static void ShowExampleAppLog(bool* p_open);
static void ShowExampleAppLayout(bool* p_open);
static void ShowExampleAppPropertyEditor(bool* p_open);
static void ShowExampleAppLongText(bool* p_open);
static void ShowExampleAppAutoResize(bool* p_open);
static void ShowExampleAppConstrainedResize(bool* p_open);
static void ShowExampleAppSimpleOverlay(bool* p_open);
static void ShowExampleAppWindowTitles(bool* p_open);
static void ShowExampleAppCustomRendering(bool* p_open);
static void ShowExampleMenuFile();

// Helper to display a little (?) mark which shows a tooltip when hovered.
static void ShowHelpMarker(const char* desc)
{
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

// Helper to display basic user controls.
void ImGui::ShowUserGuide()
{
    ImGui::BulletText("Double-click on title bar to collapse window.");
    ImGui::BulletText("Click and drag on lower right corner to resize window\n(double-click to auto fit window to its contents).");
    ImGui::BulletText("Click and drag on any empty space to move window.");
    ImGui::BulletText("TAB/SHIFT+TAB to cycle through keyboard editable fields.");
    ImGui::BulletText("CTRL+Click on a slider or drag box to input value as text.");
    if (ImGui::GetIO().FontAllowUserScaling)
        ImGui::BulletText("CTRL+Mouse Wheel to zoom window contents.");
    ImGui::BulletText("Mouse Wheel to scroll.");
    ImGui::BulletText("While editing text:\n");
    ImGui::Indent();
    ImGui::BulletText("Hold SHIFT or use mouse to select text.");
    ImGui::BulletText("CTRL+Left/Right to word jump.");
    ImGui::BulletText("CTRL+A or double-click to select all.");
    ImGui::BulletText("CTRL+X,CTRL+C,CTRL+V to use clipboard.");
    ImGui::BulletText("CTRL+Z,CTRL+Y to undo/redo.");
    ImGui::BulletText("ESCAPE to revert.");
    ImGui::BulletText("You can apply arithmetic operators +,*,/ on numerical values.\nUse +- to subtract.");
    ImGui::Unindent();
}

//-----------------------------------------------------------------------------
// [SECTION] Demo Window / ShowDemoWindow()
//-----------------------------------------------------------------------------

// We split the contents of the big ShowDemoWindow() function into smaller functions (because the link time of very large functions grow non-linearly)
static void ShowDemoWindowWidgets();
static void ShowDemoWindowLayout();
static void ShowDemoWindowPopups();
static void ShowDemoWindowColumns();
static void ShowDemoWindowMisc();

// Demonstrate most Dear ImGui features (this is big function!)
// You may execute this function to experiment with the UI and understand what it does. You may then search for keywords in the code when you are interested by a specific feature.
void ImGui::ShowDemoWindow(bool* p_open)
{
    // Examples Apps (accessible from the "Examples" menu)
    static bool show_app_documents = false;
    static bool show_app_main_menu_bar = false;
    static bool show_app_console = false;
    static bool show_app_log = false;
    static bool show_app_layout = false;
    static bool show_app_property_editor = false;
    static bool show_app_long_text = false;
    static bool show_app_auto_resize = false;
    static bool show_app_constrained_resize = false;
    static bool show_app_simple_overlay = false;
    static bool show_app_window_titles = false;
    static bool show_app_custom_rendering = false;

    if (show_app_documents)           ShowExampleAppDocuments(&show_app_documents);     // Process the Document app next, as it may also use a DockSpace()
    if (show_app_main_menu_bar)       ShowExampleAppMainMenuBar();
    if (show_app_console)             ShowExampleAppConsole(&show_app_console);
    if (show_app_log)                 ShowExampleAppLog(&show_app_log);
    if (show_app_layout)              ShowExampleAppLayout(&show_app_layout);
    if (show_app_property_editor)     ShowExampleAppPropertyEditor(&show_app_property_editor);
    if (show_app_long_text)           ShowExampleAppLongText(&show_app_long_text);
    if (show_app_auto_resize)         ShowExampleAppAutoResize(&show_app_auto_resize);
    if (show_app_constrained_resize)  ShowExampleAppConstrainedResize(&show_app_constrained_resize);
    if (show_app_simple_overlay)      ShowExampleAppSimpleOverlay(&show_app_simple_overlay);
    if (show_app_window_titles)       ShowExampleAppWindowTitles(&show_app_window_titles);
    if (show_app_custom_rendering)    ShowExampleAppCustomRendering(&show_app_custom_rendering);

    // Dear ImGui Apps (accessible from the "Help" menu)
    static bool show_app_metrics = false;
    static bool show_app_style_editor = false;
    static bool show_app_about = false;

    if (show_app_metrics)             { ImGui::ShowMetricsWindow(&show_app_metrics); }
    if (show_app_style_editor)        { ImGui::Begin("Style Editor", &show_app_style_editor); ImGui::ShowStyleEditor(); ImGui::End(); }
    if (show_app_about)               { ImGui::ShowAboutWindow(&show_app_about); }

    // Demonstrate the various window flags. Typically you would just use the default!
    static bool no_titlebar = false;
    static bool no_scrollbar = false;
    static bool no_menu = false;
    static bool no_move = false;
    static bool no_resize = false;
    static bool no_collapse = false;
    static bool no_close = false;
    static bool no_nav = false;
    static bool no_background = false;
    static bool no_bring_to_front = false;

    ImGuiWindowFlags window_flags = 0;
    if (no_titlebar)        window_flags |= ImGuiWindowFlags_NoTitleBar;
    if (no_scrollbar)       window_flags |= ImGuiWindowFlags_NoScrollbar;
    if (!no_menu)           window_flags |= ImGuiWindowFlags_MenuBar;
    if (no_move)            window_flags |= ImGuiWindowFlags_NoMove;
    if (no_resize)          window_flags |= ImGuiWindowFlags_NoResize;
    if (no_collapse)        window_flags |= ImGuiWindowFlags_NoCollapse;
    if (no_nav)             window_flags |= ImGuiWindowFlags_NoNav;
    if (no_background)      window_flags |= ImGuiWindowFlags_NoBackground;
    if (no_bring_to_front)  window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus;
    if (no_close)           p_open = NULL; // Don't pass our bool* to Begin

    // We specify a default position/size in case there's no data in the .ini file. Typically this isn't required! We only do it to make the Demo applications a little more welcoming.
    ImGui::SetNextWindowPos(ImVec2(650, 20), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowSize(ImVec2(550, 680), ImGuiCond_FirstUseEver);

    // Main body of the Demo window starts here.
    if (!ImGui::Begin("ImGui Demo", p_open, window_flags))
    {
        // Early out if the window is collapsed, as an optimization.
        ImGui::End();
        return;
    }
    ImGui::Text("dear imgui says hello. (%s)", IMGUI_VERSION);

    // Most "big" widgets share a common width settings by default.
    //ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.65f);    // Use 2/3 of the space for widgets and 1/3 for labels (default)
    ImGui::PushItemWidth(ImGui::GetFontSize() * -12);           // Use fixed width for labels (by passing a negative value), the rest goes to widgets. We choose a width proportional to our font size.

    // Menu
    if (ImGui::BeginMenuBar())
    {
        if (ImGui::BeginMenu("Menu"))
        {
            ShowExampleMenuFile();
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Examples"))
        {
            ImGui::MenuItem("Main menu bar", NULL, &show_app_main_menu_bar);
            ImGui::MenuItem("Console", NULL, &show_app_console);
            ImGui::MenuItem("Log", NULL, &show_app_log);
            ImGui::MenuItem("Simple layout", NULL, &show_app_layout);
            ImGui::MenuItem("Property editor", NULL, &show_app_property_editor);
            ImGui::MenuItem("Long text display", NULL, &show_app_long_text);
            ImGui::MenuItem("Auto-resizing window", NULL, &show_app_auto_resize);
            ImGui::MenuItem("Constrained-resizing window", NULL, &show_app_constrained_resize);
            ImGui::MenuItem("Simple overlay", NULL, &show_app_simple_overlay);
            ImGui::MenuItem("Manipulating window titles", NULL, &show_app_window_titles);
            ImGui::MenuItem("Custom rendering", NULL, &show_app_custom_rendering);
            ImGui::MenuItem("Documents", NULL, &show_app_documents);
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Help"))
        {
            ImGui::MenuItem("Metrics", NULL, &show_app_metrics);
            ImGui::MenuItem("Style Editor", NULL, &show_app_style_editor);
            ImGui::MenuItem("About Dear ImGui", NULL, &show_app_about);
            ImGui::EndMenu();
        }
        ImGui::EndMenuBar();
    }

    ImGui::Spacing();
    if (ImGui::CollapsingHeader("Help"))
    {
        ImGui::Text("PROGRAMMER GUIDE:");
        ImGui::BulletText("Please see the ShowDemoWindow() code in imgui_demo.cpp. <- you are here!");
        ImGui::BulletText("Please see the comments in imgui.cpp.");
        ImGui::BulletText("Please see the examples/ in application.");
        ImGui::BulletText("Enable 'io.ConfigFlags |= NavEnableKeyboard' for keyboard controls.");
        ImGui::BulletText("Enable 'io.ConfigFlags |= NavEnableGamepad' for gamepad controls.");
        ImGui::Separator();

        ImGui::Text("USER GUIDE:");
        ImGui::ShowUserGuide();
    }

    if (ImGui::CollapsingHeader("Configuration"))
    {
        ImGuiIO& io = ImGui::GetIO();

        if (ImGui::TreeNode("Configuration##2"))
        {
            ImGui::CheckboxFlags("io.ConfigFlags: NavEnableKeyboard", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableKeyboard);
            ImGui::CheckboxFlags("io.ConfigFlags: NavEnableGamepad", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableGamepad);
            ImGui::SameLine(); ShowHelpMarker("Required back-end to feed in gamepad inputs in io.NavInputs[] and set io.BackendFlags |= ImGuiBackendFlags_HasGamepad.\n\nRead instructions in imgui.cpp for details.");
            ImGui::CheckboxFlags("io.ConfigFlags: NavEnableSetMousePos", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableSetMousePos);
            ImGui::SameLine(); ShowHelpMarker("Instruct navigation to move the mouse cursor. See comment for ImGuiConfigFlags_NavEnableSetMousePos.");
            ImGui::CheckboxFlags("io.ConfigFlags: NoMouse", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NoMouse);
            if (io.ConfigFlags & ImGuiConfigFlags_NoMouse) // Create a way to restore this flag otherwise we could be stuck completely!
            {
                if (fmodf((float)ImGui::GetTime(), 0.40f) < 0.20f)
                {
                    ImGui::SameLine();
                    ImGui::Text("<<PRESS SPACE TO DISABLE>>");
                }
                if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Space)))
                    io.ConfigFlags &= ~ImGuiConfigFlags_NoMouse;
            }
            ImGui::CheckboxFlags("io.ConfigFlags: NoMouseCursorChange", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NoMouseCursorChange);
            ImGui::SameLine(); ShowHelpMarker("Instruct back-end to not alter mouse cursor shape and visibility.");
            ImGui::Checkbox("io.ConfigInputTextCursorBlink", &io.ConfigInputTextCursorBlink);
            ImGui::SameLine(); ShowHelpMarker("Set to false to disable blinking cursor, for users who consider it distracting");
            ImGui::Checkbox("io.ConfigWindowsResizeFromEdges", &io.ConfigWindowsResizeFromEdges);
            ImGui::SameLine(); ShowHelpMarker("Enable resizing of windows from their edges and from the lower-left corner.\nThis requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback.");
            ImGui::Checkbox("io.ConfigWindowsMoveFromTitleBarOnly", &io.ConfigWindowsMoveFromTitleBarOnly);
            ImGui::Checkbox("io.MouseDrawCursor", &io.MouseDrawCursor);
            ImGui::SameLine(); ShowHelpMarker("Instruct Dear ImGui to render a mouse cursor for you. Note that a mouse cursor rendered via your application GPU rendering path will feel more laggy than hardware cursor, but will be more in sync with your other visuals.\n\nSome desktop applications may use both kinds of cursors (e.g. enable software cursor only when resizing/dragging something).");
            ImGui::TreePop();
            ImGui::Separator();
        }

        if (ImGui::TreeNode("Backend Flags"))
        {
            ImGuiBackendFlags backend_flags = io.BackendFlags; // Make a local copy to avoid modifying the back-end flags.
            ImGui::CheckboxFlags("io.BackendFlags: HasGamepad", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasGamepad);
            ImGui::CheckboxFlags("io.BackendFlags: HasMouseCursors", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasMouseCursors);
            ImGui::CheckboxFlags("io.BackendFlags: HasSetMousePos", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasSetMousePos);
            ImGui::TreePop();
            ImGui::Separator();
        }

        if (ImGui::TreeNode("Style"))
        {
            ImGui::ShowStyleEditor();
            ImGui::TreePop();
            ImGui::Separator();
        }

        if (ImGui::TreeNode("Capture/Logging"))
        {
            ImGui::TextWrapped("The logging API redirects all text output so you can easily capture the content of a window or a block. Tree nodes can be automatically expanded.");
            ShowHelpMarker("Try opening any of the contents below in this window and then click one of the \"Log To\" button.");
            ImGui::LogButtons();
            ImGui::TextWrapped("You can also call ImGui::LogText() to output directly to the log without a visual output.");
            if (ImGui::Button("Copy \"Hello, world!\" to clipboard"))
            {
                ImGui::LogToClipboard();
                ImGui::LogText("Hello, world!");
                ImGui::LogFinish();
            }
            ImGui::TreePop();
        }
    }

    if (ImGui::CollapsingHeader("Window options"))
    {
        ImGui::Checkbox("No titlebar", &no_titlebar); ImGui::SameLine(150);
        ImGui::Checkbox("No scrollbar", &no_scrollbar); ImGui::SameLine(300);
        ImGui::Checkbox("No menu", &no_menu);
        ImGui::Checkbox("No move", &no_move); ImGui::SameLine(150);
        ImGui::Checkbox("No resize", &no_resize); ImGui::SameLine(300);
        ImGui::Checkbox("No collapse", &no_collapse);
        ImGui::Checkbox("No close", &no_close); ImGui::SameLine(150);
        ImGui::Checkbox("No nav", &no_nav); ImGui::SameLine(300);
        ImGui::Checkbox("No background", &no_background);
        ImGui::Checkbox("No bring to front", &no_bring_to_front);
    }

    // All demo contents
    ShowDemoWindowWidgets();
    ShowDemoWindowLayout();
    ShowDemoWindowPopups();
    ShowDemoWindowColumns();
    ShowDemoWindowMisc();

    // End of ShowDemoWindow()
    ImGui::End();
}

static void ShowDemoWindowWidgets()
{
    if (!ImGui::CollapsingHeader("Widgets"))
        return;

    if (ImGui::TreeNode("Basic"))
    {
        static int clicked = 0;
        if (ImGui::Button("Button"))
            clicked++;
        if (clicked & 1)
        {
            ImGui::SameLine();
            ImGui::Text("Thanks for clicking me!");
        }

        static bool check = true;
        ImGui::Checkbox("checkbox", &check);

        static int e = 0;
        ImGui::RadioButton("radio a", &e, 0); ImGui::SameLine();
        ImGui::RadioButton("radio b", &e, 1); ImGui::SameLine();
        ImGui::RadioButton("radio c", &e, 2);

        // Color buttons, demonstrate using PushID() to add unique identifier in the ID stack, and changing style.
        for (int i = 0; i < 7; i++)
        {
            if (i > 0) 
                ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(i/7.0f, 0.6f, 0.6f));
            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(i/7.0f, 0.7f, 0.7f));
            ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(i/7.0f, 0.8f, 0.8f));
            ImGui::Button("Click");
            ImGui::PopStyleColor(3);
            ImGui::PopID();
        }

        // Use AlignTextToFramePadding() to align text baseline to the baseline of framed elements (otherwise a Text+SameLine+Button sequence will have the text a little too high by default)
        ImGui::AlignTextToFramePadding();
        ImGui::Text("Hold to repeat:");
        ImGui::SameLine();

        // Arrow buttons with Repeater
        static int counter = 0;
        float spacing = ImGui::GetStyle().ItemInnerSpacing.x;
        ImGui::PushButtonRepeat(true);
        if (ImGui::ArrowButton("##left", ImGuiDir_Left)) { counter--; }
        ImGui::SameLine(0.0f, spacing);
        if (ImGui::ArrowButton("##right", ImGuiDir_Right)) { counter++; }
        ImGui::PopButtonRepeat();
        ImGui::SameLine();
        ImGui::Text("%d", counter);

        ImGui::Text("Hover over me");
        if (ImGui::IsItemHovered())
            ImGui::SetTooltip("I am a tooltip");

        ImGui::SameLine();
        ImGui::Text("- or me");
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            ImGui::Text("I am a fancy tooltip");
            static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };
            ImGui::PlotLines("Curve", arr, IM_ARRAYSIZE(arr));
            ImGui::EndTooltip();
        }

        ImGui::Separator();

        ImGui::LabelText("label", "Value");

        {
            // Using the _simplified_ one-liner Combo() api here
            // See "Combo" section for examples of how to use the more complete BeginCombo()/EndCombo() api.
            const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG", "HHHH", "IIII", "JJJJ", "KKKK", "LLLLLLL", "MMMM", "OOOOOOO" };
            static int item_current = 0;
            ImGui::Combo("combo", &item_current, items, IM_ARRAYSIZE(items));
            ImGui::SameLine(); ShowHelpMarker("Refer to the \"Combo\" section below for an explanation of the full BeginCombo/EndCombo API, and demonstration of various flags.\n");
        }

        {
            static char str0[128] = "Hello, world!";
            static int i0 = 123;
            ImGui::InputText("input text", str0, IM_ARRAYSIZE(str0));
            ImGui::SameLine(); ShowHelpMarker("USER:\nHold SHIFT or use mouse to select text.\n" "CTRL+Left/Right to word jump.\n" "CTRL+A or double-click to select all.\n" "CTRL+X,CTRL+C,CTRL+V clipboard.\n" "CTRL+Z,CTRL+Y undo/redo.\n" "ESCAPE to revert.\n\nPROGRAMMER:\nYou can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputText() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example (this is not demonstrated in imgui_demo.cpp).");

            ImGui::InputInt("input int", &i0);
            ImGui::SameLine(); ShowHelpMarker("You can apply arithmetic operators +,*,/ on numerical values.\n  e.g. [ 100 ], input \'*2\', result becomes [ 200 ]\nUse +- to subtract.\n");

            static float f0 = 0.001f;
            ImGui::InputFloat("input float", &f0, 0.01f, 1.0f);

            static double d0 = 999999.00000001;
            ImGui::InputDouble("input double", &d0, 0.01f, 1.0f, "%.8f");

            static float f1 = 1.e10f;
            ImGui::InputFloat("input scientific", &f1, 0.0f, 0.0f, "%e");
            ImGui::SameLine(); ShowHelpMarker("You can input value using the scientific notation,\n  e.g. \"1e+8\" becomes \"100000000\".\n");

            static float vec4a[4] = { 0.10f, 0.20f, 0.30f, 0.44f };
            ImGui::InputFloat3("input float3", vec4a);
        }

        {
            static int i1 = 50, i2 = 42;
            ImGui::DragInt("drag int", &i1, 1);
            ImGui::SameLine(); ShowHelpMarker("Click and drag to edit value.\nHold SHIFT/ALT for faster/slower edit.\nDouble-click or CTRL+click to input value.");

            ImGui::DragInt("drag int 0..100", &i2, 1, 0, 100, "%d%%");

            static float f1=1.00f, f2=0.0067f;
            ImGui::DragFloat("drag float", &f1, 0.005f);
            ImGui::DragFloat("drag small float", &f2, 0.0001f, 0.0f, 0.0f, "%.06f ns");
        }

        {
            static int i1=0;
            ImGui::SliderInt("slider int", &i1, -1, 3);
            ImGui::SameLine(); ShowHelpMarker("CTRL+click to input value.");

            static float f1=0.123f, f2=0.0f;
            ImGui::SliderFloat("slider float", &f1, 0.0f, 1.0f, "ratio = %.3f");
            ImGui::SliderFloat("slider float (curve)", &f2, -10.0f, 10.0f, "%.4f", 2.0f);
            static float angle = 0.0f;
            ImGui::SliderAngle("slider angle", &angle);
        }

        {
            static float col1[3] = { 1.0f,0.0f,0.2f };
            static float col2[4] = { 0.4f,0.7f,0.0f,0.5f };
            ImGui::ColorEdit3("color 1", col1);
            ImGui::SameLine(); ShowHelpMarker("Click on the colored square to open a color picker.\nClick and hold to use drag and drop.\nRight-click on the colored square to show options.\nCTRL+click on individual component to input value.\n");

            ImGui::ColorEdit4("color 2", col2);
        }

        {
            // List box
            const char* listbox_items[] = { "Apple", "Banana", "Cherry", "Kiwi", "Mango", "Orange", "Pineapple", "Strawberry", "Watermelon" };
            static int listbox_item_current = 1;
            ImGui::ListBox("listbox\n(single select)", &listbox_item_current, listbox_items, IM_ARRAYSIZE(listbox_items), 4);

            //static int listbox_item_current2 = 2;
            //ImGui::PushItemWidth(-1);
            //ImGui::ListBox("##listbox2", &listbox_item_current2, listbox_items, IM_ARRAYSIZE(listbox_items), 4);
            //ImGui::PopItemWidth();
        }

        ImGui::TreePop();
    }

    // Testing ImGuiOnceUponAFrame helper.
    //static ImGuiOnceUponAFrame once;
    //for (int i = 0; i < 5; i++)
    //    if (once)
    //        ImGui::Text("This will be displayed only once.");

    if (ImGui::TreeNode("Trees"))
    {
        if (ImGui::TreeNode("Basic trees"))
        {
            for (int i = 0; i < 5; i++)
                if (ImGui::TreeNode((void*)(intptr_t)i, "Child %d", i))
                {
                    ImGui::Text("blah blah");
                    ImGui::SameLine();
                    if (ImGui::SmallButton("button")) { };
                    ImGui::TreePop();
                }
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Advanced, with Selectable nodes"))
        {
            ShowHelpMarker("This is a more standard looking tree with selectable nodes.\nClick to select, CTRL+Click to toggle, click on arrows or double-click to open.");
            static bool align_label_with_current_x_position = false;
            ImGui::Checkbox("Align label with current X position)", &align_label_with_current_x_position);
            ImGui::Text("Hello!");
            if (align_label_with_current_x_position)
                ImGui::Unindent(ImGui::GetTreeNodeToLabelSpacing());

            static int selection_mask = (1 << 2); // Dumb representation of what may be user-side selection state. You may carry selection state inside or outside your objects in whatever format you see fit.
            int node_clicked = -1;                // Temporary storage of what node we have clicked to process selection at the end of the loop. May be a pointer to your own node type, etc.
            ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, ImGui::GetFontSize()*3); // Increase spacing to differentiate leaves from expanded contents.
            for (int i = 0; i < 6; i++)
            {
                // Disable the default open on single-click behavior and pass in Selected flag according to our selection state.
                ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ((selection_mask & (1 << i)) ? ImGuiTreeNodeFlags_Selected : 0);
                if (i < 3)
                {
                    // Node
                    bool node_open = ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, "Selectable Node %d", i);
                    if (ImGui::IsItemClicked())
                        node_clicked = i;
                    if (node_open)
                    {
                        ImGui::Text("Blah blah\nBlah Blah");
                        ImGui::TreePop();
                    }
                }
                else
                {
                    // Leaf: The only reason we have a TreeNode at all is to allow selection of the leaf. Otherwise we can use BulletText() or TreeAdvanceToLabelPos()+Text().
                    node_flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen; // ImGuiTreeNodeFlags_Bullet
                    ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, "Selectable Leaf %d", i);
                    if (ImGui::IsItemClicked())
                        node_clicked = i;
                }
            }
            if (node_clicked != -1)
            {
                // Update selection state. Process outside of tree loop to avoid visual inconsistencies during the clicking-frame.
                if (ImGui::GetIO().KeyCtrl)
                    selection_mask ^= (1 << node_clicked);          // CTRL+click to toggle
                else //if (!(selection_mask & (1 << node_clicked))) // Depending on selection behavior you want, this commented bit preserve selection when clicking on item that is part of the selection
                    selection_mask = (1 << node_clicked);           // Click to single-select
            }
            ImGui::PopStyleVar();
            if (align_label_with_current_x_position)
                ImGui::Indent(ImGui::GetTreeNodeToLabelSpacing());
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Collapsing Headers"))
    {
        static bool closable_group = true;
        ImGui::Checkbox("Enable extra group", &closable_group);
        if (ImGui::CollapsingHeader("Header"))
        {
            ImGui::Text("IsItemHovered: %d", ImGui::IsItemHovered());
            for (int i = 0; i < 5; i++)
                ImGui::Text("Some content %d", i);
        }
        if (ImGui::CollapsingHeader("Header with a close button", &closable_group))
        {
            ImGui::Text("IsItemHovered: %d", ImGui::IsItemHovered());
            for (int i = 0; i < 5; i++)
                ImGui::Text("More content %d", i);
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Bullets"))
    {
        ImGui::BulletText("Bullet point 1");
        ImGui::BulletText("Bullet point 2\nOn multiple lines");
        ImGui::Bullet(); ImGui::Text("Bullet point 3 (two calls)");
        ImGui::Bullet(); ImGui::SmallButton("Button");
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Text"))
    {
        if (ImGui::TreeNode("Colored Text"))
        {
            // Using shortcut. You can use PushStyleColor()/PopStyleColor() for more flexibility.
            ImGui::TextColored(ImVec4(1.0f,0.0f,1.0f,1.0f), "Pink");
            ImGui::TextColored(ImVec4(1.0f,1.0f,0.0f,1.0f), "Yellow");
            ImGui::TextDisabled("Disabled");
            ImGui::SameLine(); ShowHelpMarker("The TextDisabled color is stored in ImGuiStyle.");
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Word Wrapping"))
        {
            // Using shortcut. You can use PushTextWrapPos()/PopTextWrapPos() for more flexibility.
            ImGui::TextWrapped("This text should automatically wrap on the edge of the window. The current implementation for text wrapping follows simple rules suitable for English and possibly other languages.");
            ImGui::Spacing();

            static float wrap_width = 200.0f;
            ImGui::SliderFloat("Wrap width", &wrap_width, -20, 600, "%.0f");

            ImGui::Text("Test paragraph 1:");
            ImVec2 pos = ImGui::GetCursorScreenPos();
            ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));
            ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);
            ImGui::Text("The lazy dog is a good dog. This paragraph is made to fit within %.0f pixels. Testing a 1 character word. The quick brown fox jumps over the lazy dog.", wrap_width);
            ImGui::GetWindowDrawList()->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255,255,0,255));
            ImGui::PopTextWrapPos();

            ImGui::Text("Test paragraph 2:");
            pos = ImGui::GetCursorScreenPos();
            ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));
            ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);
            ImGui::Text("aaaaaaaa bbbbbbbb, c cccccccc,dddddddd. d eeeeeeee   ffffffff. gggggggg!hhhhhhhh");
            ImGui::GetWindowDrawList()->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255,255,0,255));
            ImGui::PopTextWrapPos();

            ImGui::TreePop();
        }

        if (ImGui::TreeNode("UTF-8 Text"))
        {
            // UTF-8 test with Japanese characters
            // (Needs a suitable font, try Noto, or Arial Unicode, or M+ fonts. Read misc/fonts/README.txt for details.)
            // - From C++11 you can use the u8"my text" syntax to encode literal strings as UTF-8
            // - For earlier compiler, you may be able to encode your sources as UTF-8 (e.g. Visual Studio save your file as 'UTF-8 without signature')
            // - FOR THIS DEMO FILE ONLY, BECAUSE WE WANT TO SUPPORT OLD COMPILERS, WE ARE *NOT* INCLUDING RAW UTF-8 CHARACTERS IN THIS SOURCE FILE.
            //   Instead we are encoding a few strings with hexadecimal constants. Don't do this in your application!
            //   Please use u8"text in any language" in your application!
            // Note that characters values are preserved even by InputText() if the font cannot be displayed, so you can safely copy & paste garbled characters into another application.
            ImGui::TextWrapped("CJK text will only appears if the font was loaded with the appropriate CJK character ranges. Call io.Font->AddFontFromFileTTF() manually to load extra character ranges. Read misc/fonts/README.txt for details.");
            ImGui::Text("Hiragana: \xe3\x81\x8b\xe3\x81\x8d\xe3\x81\x8f\xe3\x81\x91\xe3\x81\x93 (kakikukeko)"); // Normally we would use u8"blah blah" with the proper characters directly in the string.
            ImGui::Text("Kanjis: \xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e (nihongo)");
            static char buf[32] = "\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e";
            //static char buf[32] = u8"NIHONGO"; // <- this is how you would write it with C++11, using real kanjis
            ImGui::InputText("UTF-8 input", buf, IM_ARRAYSIZE(buf));
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Images"))
    {
        ImGuiIO& io = ImGui::GetIO();
        ImGui::TextWrapped("Below we are displaying the font texture (which is the only texture we have access to in this demo). Use the 'ImTextureID' type as storage to pass pointers or identifier to your own texture data. Hover the texture for a zoomed view!");

        // Here we are grabbing the font texture because that's the only one we have access to inside the demo code.
        // Remember that ImTextureID is just storage for whatever you want it to be, it is essentially a value that will be passed to the render function inside the ImDrawCmd structure.
        // If you use one of the default imgui_impl_XXXX.cpp renderer, they all have comments at the top of their file to specify what they expect to be stored in ImTextureID.
        // (for example, the imgui_impl_dx11.cpp renderer expect a 'ID3D11ShaderResourceView*' pointer. The imgui_impl_glfw_gl3.cpp renderer expect a GLuint OpenGL texture identifier etc.)
        // If you decided that ImTextureID = MyEngineTexture*, then you can pass your MyEngineTexture* pointers to ImGui::Image(), and gather width/height through your own functions, etc.
        // Using ShowMetricsWindow() as a "debugger" to inspect the draw data that are being passed to your render will help you debug issues if you are confused about this.
        // Consider using the lower-level ImDrawList::AddImage() API, via ImGui::GetWindowDrawList()->AddImage().
        ImTextureID my_tex_id = io.Fonts->TexID;
        float my_tex_w = (float)io.Fonts->TexWidth;
        float my_tex_h = (float)io.Fonts->TexHeight;

        ImGui::Text("%.0fx%.0f", my_tex_w, my_tex_h);
        ImVec2 pos = ImGui::GetCursorScreenPos();
        ImGui::Image(my_tex_id, ImVec2(my_tex_w, my_tex_h), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            float region_sz = 32.0f;
            float region_x = io.MousePos.x - pos.x - region_sz * 0.5f; if (region_x < 0.0f) region_x = 0.0f; else if (region_x > my_tex_w - region_sz) region_x = my_tex_w - region_sz;
            float region_y = io.MousePos.y - pos.y - region_sz * 0.5f; if (region_y < 0.0f) region_y = 0.0f; else if (region_y > my_tex_h - region_sz) region_y = my_tex_h - region_sz;
            float zoom = 4.0f;
            ImGui::Text("Min: (%.2f, %.2f)", region_x, region_y);
            ImGui::Text("Max: (%.2f, %.2f)", region_x + region_sz, region_y + region_sz);
            ImVec2 uv0 = ImVec2((region_x) / my_tex_w, (region_y) / my_tex_h);
            ImVec2 uv1 = ImVec2((region_x + region_sz) / my_tex_w, (region_y + region_sz) / my_tex_h);
            ImGui::Image(my_tex_id, ImVec2(region_sz * zoom, region_sz * zoom), uv0, uv1, ImColor(255,255,255,255), ImColor(255,255,255,128));
            ImGui::EndTooltip();
        }
        ImGui::TextWrapped("And now some textured buttons..");
        static int pressed_count = 0;
        for (int i = 0; i < 8; i++)
        {
            ImGui::PushID(i);
            int frame_padding = -1 + i;     // -1 = uses default padding
            if (ImGui::ImageButton(my_tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/my_tex_w,32/my_tex_h), frame_padding, ImColor(0,0,0,255)))
                pressed_count += 1;
            ImGui::PopID();
            ImGui::SameLine();
        }
        ImGui::NewLine();
        ImGui::Text("Pressed %d times.", pressed_count);
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Combo"))
    {
        // Expose flags as checkbox for the demo
        static ImGuiComboFlags flags = 0;
        ImGui::CheckboxFlags("ImGuiComboFlags_PopupAlignLeft", (unsigned int*)&flags, ImGuiComboFlags_PopupAlignLeft);
        if (ImGui::CheckboxFlags("ImGuiComboFlags_NoArrowButton", (unsigned int*)&flags, ImGuiComboFlags_NoArrowButton))
            flags &= ~ImGuiComboFlags_NoPreview;     // Clear the other flag, as we cannot combine both
        if (ImGui::CheckboxFlags("ImGuiComboFlags_NoPreview", (unsigned int*)&flags, ImGuiComboFlags_NoPreview))
            flags &= ~ImGuiComboFlags_NoArrowButton; // Clear the other flag, as we cannot combine both

        // General BeginCombo() API, you have full control over your selection data and display type.
        // (your selection data could be an index, a pointer to the object, an id for the object, a flag stored in the object itself, etc.)
        const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG", "HHHH", "IIII", "JJJJ", "KKKK", "LLLLLLL", "MMMM", "OOOOOOO" };
        static const char* item_current = items[0];            // Here our selection is a single pointer stored outside the object.
        if (ImGui::BeginCombo("combo 1", item_current, flags)) // The second parameter is the label previewed before opening the combo.
        {
            for (int n = 0; n < IM_ARRAYSIZE(items); n++)
            {
                bool is_selected = (item_current == items[n]);
                if (ImGui::Selectable(items[n], is_selected))
                    item_current = items[n];
                if (is_selected)
                    ImGui::SetItemDefaultFocus();   // Set the initial focus when opening the combo (scrolling + for keyboard navigation support in the upcoming navigation branch)
            }
            ImGui::EndCombo();
        }

        // Simplified one-liner Combo() API, using values packed in a single constant string
        static int item_current_2 = 0;
        ImGui::Combo("combo 2 (one-liner)", &item_current_2, "aaaa\0bbbb\0cccc\0dddd\0eeee\0\0");

        // Simplified one-liner Combo() using an array of const char*
        static int item_current_3 = -1; // If the selection isn't within 0..count, Combo won't display a preview
        ImGui::Combo("combo 3 (array)", &item_current_3, items, IM_ARRAYSIZE(items));

        // Simplified one-liner Combo() using an accessor function
        struct FuncHolder { static bool ItemGetter(void* data, int idx, const char** out_str) { *out_str = ((const char**)data)[idx]; return true; } };
        static int item_current_4 = 0;
        ImGui::Combo("combo 4 (function)", &item_current_4, &FuncHolder::ItemGetter, items, IM_ARRAYSIZE(items));

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Selectables"))
    {
        // Selectable() has 2 overloads:
        // - The one taking "bool selected" as a read-only selection information. When Selectable() has been clicked is returns true and you can alter selection state accordingly.
        // - The one taking "bool* p_selected" as a read-write selection information (convenient in some cases)
        // The earlier is more flexible, as in real application your selection may be stored in a different manner (in flags within objects, as an external list, etc).
        if (ImGui::TreeNode("Basic"))
        {
            static bool selection[5] = { false, true, false, false, false };
            ImGui::Selectable("1. I am selectable", &selection[0]);
            ImGui::Selectable("2. I am selectable", &selection[1]);
            ImGui::Text("3. I am not selectable");
            ImGui::Selectable("4. I am selectable", &selection[3]);
            if (ImGui::Selectable("5. I am double clickable", selection[4], ImGuiSelectableFlags_AllowDoubleClick))
                if (ImGui::IsMouseDoubleClicked(0))
                    selection[4] = !selection[4];
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Selection State: Single Selection"))
        {
            static int selected = -1;
            for (int n = 0; n < 5; n++)
            {
                char buf[32];
                sprintf(buf, "Object %d", n);
                if (ImGui::Selectable(buf, selected == n))
                    selected = n;
            }
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Selection State: Multiple Selection"))
        {
            ShowHelpMarker("Hold CTRL and click to select multiple items.");
            static bool selection[5] = { false, false, false, false, false };
            for (int n = 0; n < 5; n++)
            {
                char buf[32];
                sprintf(buf, "Object %d", n);
                if (ImGui::Selectable(buf, selection[n]))
                {
                    if (!ImGui::GetIO().KeyCtrl)    // Clear selection when CTRL is not held
                        memset(selection, 0, sizeof(selection));
                    selection[n] ^= 1;
                }
            }
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Rendering more text into the same line"))
        {
            // Using the Selectable() override that takes "bool* p_selected" parameter and toggle your booleans automatically.
            static bool selected[3] = { false, false, false };
            ImGui::Selectable("main.c",    &selected[0]); ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");
            ImGui::Selectable("Hello.cpp", &selected[1]); ImGui::SameLine(300); ImGui::Text("12,345 bytes");
            ImGui::Selectable("Hello.h",   &selected[2]); ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("In columns"))
        {
            ImGui::Columns(3, NULL, false);
            static bool selected[16] = { 0 };
            for (int i = 0; i < 16; i++)
            {
                char label[32]; sprintf(label, "Item %d", i);
                if (ImGui::Selectable(label, &selected[i])) {}
                ImGui::NextColumn();
            }
            ImGui::Columns(1);
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Grid"))
        {
            static bool selected[16] = { true, false, false, false, false, true, false, false, false, false, true, false, false, false, false, true };
            for (int i = 0; i < 16; i++)
            {
                ImGui::PushID(i);
                if (ImGui::Selectable("Sailor", &selected[i], 0, ImVec2(50,50)))
                {
                    int x = i % 4, y = i / 4;
                    if (x > 0) selected[i - 1] ^= 1;
                    if (x < 3) selected[i + 1] ^= 1;
                    if (y > 0) selected[i - 4] ^= 1;
                    if (y < 3) selected[i + 4] ^= 1;
                }
                if ((i % 4) < 3) ImGui::SameLine();
                ImGui::PopID();
            }
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Filtered Text Input"))
    {
        static char buf1[64] = ""; ImGui::InputText("default", buf1, 64);
        static char buf2[64] = ""; ImGui::InputText("decimal", buf2, 64, ImGuiInputTextFlags_CharsDecimal);
        static char buf3[64] = ""; ImGui::InputText("hexadecimal", buf3, 64, ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase);
        static char buf4[64] = ""; ImGui::InputText("uppercase", buf4, 64, ImGuiInputTextFlags_CharsUppercase);
        static char buf5[64] = ""; ImGui::InputText("no blank", buf5, 64, ImGuiInputTextFlags_CharsNoBlank);
        struct TextFilters { static int FilterImGuiLetters(ImGuiInputTextCallbackData* data) { if (data->EventChar < 256 && strchr("imgui", (char)data->EventChar)) return 0; return 1; } };
        static char buf6[64] = ""; ImGui::InputText("\"imgui\" letters", buf6, 64, ImGuiInputTextFlags_CallbackCharFilter, TextFilters::FilterImGuiLetters);

        ImGui::Text("Password input");
        static char bufpass[64] = "password123";
        ImGui::InputText("password", bufpass, 64, ImGuiInputTextFlags_Password | ImGuiInputTextFlags_CharsNoBlank);
        ImGui::SameLine(); ShowHelpMarker("Display all characters as '*'.\nDisable clipboard cut and copy.\nDisable logging.\n");
        ImGui::InputText("password (clear)", bufpass, 64, ImGuiInputTextFlags_CharsNoBlank);

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Multi-line Text Input"))
    {
        // Note: we are using a fixed-sized buffer for simplicity here. See ImGuiInputTextFlags_CallbackResize 
        // and the code in misc/cpp/imgui_stdlib.h for how to setup InputText() for dynamically resizing strings.
        static bool read_only = false;
        static char text[1024*16] =
            "/*\n"
            " The Pentium F00F bug, shorthand for F0 0F C7 C8,\n"
            " the hexadecimal encoding of one offending instruction,\n"
            " more formally, the invalid operand with locked CMPXCHG8B\n"
            " instruction bug, is a design flaw in the majority of\n"
            " Intel Pentium, Pentium MMX, and Pentium OverDrive\n"
            " processors (all in the P5 microarchitecture).\n"
            "*/\n\n"
            "label:\n"
            "\tlock cmpxchg8b eax\n";

        ShowHelpMarker("You can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputTextMultiline() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example. (This is not demonstrated in imgui_demo.cpp)");
        ImGui::Checkbox("Read-only", &read_only);
        ImGuiInputTextFlags flags = ImGuiInputTextFlags_AllowTabInput | (read_only ? ImGuiInputTextFlags_ReadOnly : 0);
        ImGui::InputTextMultiline("##source", text, IM_ARRAYSIZE(text), ImVec2(-1.0f, ImGui::GetTextLineHeight() * 16), flags);
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Plots Widgets"))
    {
        static bool animate = true;
        ImGui::Checkbox("Animate", &animate);

        static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };
        ImGui::PlotLines("Frame Times", arr, IM_ARRAYSIZE(arr));

        // Create a dummy array of contiguous float values to plot
        // Tip: If your float aren't contiguous but part of a structure, you can pass a pointer to your first float and the sizeof() of your structure in the Stride parameter.
        static float values[90] = { 0 };
        static int values_offset = 0;
        static double refresh_time = 0.0;
        if (!animate || refresh_time == 0.0f)
            refresh_time = ImGui::GetTime();
        while (refresh_time < ImGui::GetTime()) // Create dummy data at fixed 60 hz rate for the demo
        {
            static float phase = 0.0f;
            values[values_offset] = cosf(phase);
            values_offset = (values_offset+1) % IM_ARRAYSIZE(values);
            phase += 0.10f*values_offset;
            refresh_time += 1.0f/60.0f;
        }
        ImGui::PlotLines("Lines", values, IM_ARRAYSIZE(values), values_offset, "avg 0.0", -1.0f, 1.0f, ImVec2(0,80));
        ImGui::PlotHistogram("Histogram", arr, IM_ARRAYSIZE(arr), 0, NULL, 0.0f, 1.0f, ImVec2(0,80));

        // Use functions to generate output
        // FIXME: This is rather awkward because current plot API only pass in indices. We probably want an API passing floats and user provide sample rate/count.
        struct Funcs
        {
            static float Sin(void*, int i) { return sinf(i * 0.1f); }
            static float Saw(void*, int i) { return (i & 1) ? 1.0f : -1.0f; }
        };
        static int func_type = 0, display_count = 70;
        ImGui::Separator();
        ImGui::PushItemWidth(100); ImGui::Combo("func", &func_type, "Sin\0Saw\0"); ImGui::PopItemWidth();
        ImGui::SameLine();
        ImGui::SliderInt("Sample count", &display_count, 1, 400);
        float (*func)(void*, int) = (func_type == 0) ? Funcs::Sin : Funcs::Saw;
        ImGui::PlotLines("Lines", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0,80));
        ImGui::PlotHistogram("Histogram", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0,80));
        ImGui::Separator();

        // Animate a simple progress bar
        static float progress = 0.0f, progress_dir = 1.0f;
        if (animate)
        {
            progress += progress_dir * 0.4f * ImGui::GetIO().DeltaTime;
            if (progress >= +1.1f) { progress = +1.1f; progress_dir *= -1.0f; }
            if (progress <= -0.1f) { progress = -0.1f; progress_dir *= -1.0f; }
        }

        // Typically we would use ImVec2(-1.0f,0.0f) to use all available width, or ImVec2(width,0.0f) for a specified width. ImVec2(0.0f,0.0f) uses ItemWidth.
        ImGui::ProgressBar(progress, ImVec2(0.0f,0.0f));
        ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);
        ImGui::Text("Progress Bar");

        float progress_saturated = (progress < 0.0f) ? 0.0f : (progress > 1.0f) ? 1.0f : progress;
        char buf[32];
        sprintf(buf, "%d/%d", (int)(progress_saturated*1753), 1753);
        ImGui::ProgressBar(progress, ImVec2(0.f,0.f), buf);
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Color/Picker Widgets"))
    {
        static ImVec4 color = ImColor(114, 144, 154, 200);

        static bool alpha_preview = true;
        static bool alpha_half_preview = false;
        static bool drag_and_drop = true;
        static bool options_menu = true;
        static bool hdr = false;
        ImGui::Checkbox("With Alpha Preview", &alpha_preview);
        ImGui::Checkbox("With Half Alpha Preview", &alpha_half_preview);
        ImGui::Checkbox("With Drag and Drop", &drag_and_drop);
        ImGui::Checkbox("With Options Menu", &options_menu); ImGui::SameLine(); ShowHelpMarker("Right-click on the individual color widget to show options.");
        ImGui::Checkbox("With HDR", &hdr); ImGui::SameLine(); ShowHelpMarker("Currently all this does is to lift the 0..1 limits on dragging widgets.");
        int misc_flags = (hdr ? ImGuiColorEditFlags_HDR : 0) | (drag_and_drop ? 0 : ImGuiColorEditFlags_NoDragDrop) | (alpha_half_preview ? ImGuiColorEditFlags_AlphaPreviewHalf : (alpha_preview ? ImGuiColorEditFlags_AlphaPreview : 0)) | (options_menu ? 0 : ImGuiColorEditFlags_NoOptions);

        ImGui::Text("Color widget:");
        ImGui::SameLine(); ShowHelpMarker("Click on the colored square to open a color picker.\nCTRL+click on individual component to input value.\n");
        ImGui::ColorEdit3("MyColor##1", (float*)&color, misc_flags);

        ImGui::Text("Color widget HSV with Alpha:");
        ImGui::ColorEdit4("MyColor##2", (float*)&color, ImGuiColorEditFlags_HSV | misc_flags);

        ImGui::Text("Color widget with Float Display:");
        ImGui::ColorEdit4("MyColor##2f", (float*)&color, ImGuiColorEditFlags_Float | misc_flags);

        ImGui::Text("Color button with Picker:");
        ImGui::SameLine(); ShowHelpMarker("With the ImGuiColorEditFlags_NoInputs flag you can hide all the slider/text inputs.\nWith the ImGuiColorEditFlags_NoLabel flag you can pass a non-empty label which will only be used for the tooltip and picker popup.");
        ImGui::ColorEdit4("MyColor##3", (float*)&color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel | misc_flags);

        ImGui::Text("Color button with Custom Picker Popup:");

        // Generate a dummy palette
        static bool saved_palette_inited = false;
        static ImVec4 saved_palette[32];
        if (!saved_palette_inited)
            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)
            {
                ImGui::ColorConvertHSVtoRGB(n / 31.0f, 0.8f, 0.8f, saved_palette[n].x, saved_palette[n].y, saved_palette[n].z);
                saved_palette[n].w = 1.0f; // Alpha
            }
        saved_palette_inited = true;

        static ImVec4 backup_color;
        bool open_popup = ImGui::ColorButton("MyColor##3b", color, misc_flags);
        ImGui::SameLine();
        open_popup |= ImGui::Button("Palette");
        if (open_popup)
        {
            ImGui::OpenPopup("mypicker");
            backup_color = color;
        }
        if (ImGui::BeginPopup("mypicker"))
        {
            // FIXME: Adding a drag and drop example here would be perfect!
            ImGui::Text("MY CUSTOM COLOR PICKER WITH AN AMAZING PALETTE!");
            ImGui::Separator();
            ImGui::ColorPicker4("##picker", (float*)&color, misc_flags | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoSmallPreview);
            ImGui::SameLine();
            ImGui::BeginGroup();
            ImGui::Text("Current");
            ImGui::ColorButton("##current", color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60,40));
            ImGui::Text("Previous");
            if (ImGui::ColorButton("##previous", backup_color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60,40)))
                color = backup_color;
            ImGui::Separator();
            ImGui::Text("Palette");
            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)
            {
                ImGui::PushID(n);
                if ((n % 8) != 0)
                    ImGui::SameLine(0.0f, ImGui::GetStyle().ItemSpacing.y);
                if (ImGui::ColorButton("##palette", saved_palette[n], ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_NoTooltip, ImVec2(20,20)))
                    color = ImVec4(saved_palette[n].x, saved_palette[n].y, saved_palette[n].z, color.w); // Preserve alpha!

                if (ImGui::BeginDragDropTarget())
                {
                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))
                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 3);
                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))
                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 4);
                    ImGui::EndDragDropTarget();
                }

                ImGui::PopID();
            }
            ImGui::EndGroup();
            ImGui::EndPopup();
        }

        ImGui::Text("Color button only:");
        ImGui::ColorButton("MyColor##3c", *(ImVec4*)&color, misc_flags, ImVec2(80,80));

        ImGui::Text("Color picker:");
        static bool alpha = true;
        static bool alpha_bar = true;
        static bool side_preview = true;
        static bool ref_color = false;
        static ImVec4 ref_color_v(1.0f,0.0f,1.0f,0.5f);
        static int inputs_mode = 2;
        static int picker_mode = 0;
        ImGui::Checkbox("With Alpha", &alpha);
        ImGui::Checkbox("With Alpha Bar", &alpha_bar);
        ImGui::Checkbox("With Side Preview", &side_preview);
        if (side_preview)
        {
            ImGui::SameLine();
            ImGui::Checkbox("With Ref Color", &ref_color);
            if (ref_color)
            {
                ImGui::SameLine();
                ImGui::ColorEdit4("##RefColor", &ref_color_v.x, ImGuiColorEditFlags_NoInputs | misc_flags);
            }
        }
        ImGui::Combo("Inputs Mode", &inputs_mode, "All Inputs\0No Inputs\0RGB Input\0HSV Input\0HEX Input\0");
        ImGui::Combo("Picker Mode", &picker_mode, "Auto/Current\0Hue bar + SV rect\0Hue wheel + SV triangle\0");
        ImGui::SameLine(); ShowHelpMarker("User can right-click the picker to change mode.");
        ImGuiColorEditFlags flags = misc_flags;
        if (!alpha) flags |= ImGuiColorEditFlags_NoAlpha; // This is by default if you call ColorPicker3() instead of ColorPicker4()
        if (alpha_bar) flags |= ImGuiColorEditFlags_AlphaBar;
        if (!side_preview) flags |= ImGuiColorEditFlags_NoSidePreview;
        if (picker_mode == 1) flags |= ImGuiColorEditFlags_PickerHueBar;
        if (picker_mode == 2) flags |= ImGuiColorEditFlags_PickerHueWheel;
        if (inputs_mode == 1) flags |= ImGuiColorEditFlags_NoInputs;
        if (inputs_mode == 2) flags |= ImGuiColorEditFlags_RGB;
        if (inputs_mode == 3) flags |= ImGuiColorEditFlags_HSV;
        if (inputs_mode == 4) flags |= ImGuiColorEditFlags_HEX;
        ImGui::ColorPicker4("MyColor##4", (float*)&color, flags, ref_color ? &ref_color_v.x : NULL);

        ImGui::Text("Programmatically set defaults:");
        ImGui::SameLine(); ShowHelpMarker("SetColorEditOptions() is designed to allow you to set boot-time default.\nWe don't have Push/Pop functions because you can force options on a per-widget basis if needed, and the user can change non-forced ones with the options menu.\nWe don't have a getter to avoid encouraging you to persistently save values that aren't forward-compatible.");
        if (ImGui::Button("Default: Uint8 + HSV + Hue Bar"))
            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_HSV | ImGuiColorEditFlags_PickerHueBar);
        if (ImGui::Button("Default: Float + HDR + Hue Wheel"))
            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Float | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_PickerHueWheel);

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Range Widgets"))
    {
        static float begin = 10, end = 90;
        static int begin_i = 100, end_i = 1000;
        ImGui::DragFloatRange2("range", &begin, &end, 0.25f, 0.0f, 100.0f, "Min: %.1f %%", "Max: %.1f %%");
        ImGui::DragIntRange2("range int (no bounds)", &begin_i, &end_i, 5, 0, 0, "Min: %d units", "Max: %d units");
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Data Types"))
    {
        // The DragScalar/InputScalar/SliderScalar functions allow various data types: signed/unsigned int/long long and float/double
        // To avoid polluting the public API with all possible combinations, we use the ImGuiDataType enum to pass the type, 
        // and passing all arguments by address. 
        // This is the reason the test code below creates local variables to hold "zero" "one" etc. for each types.
        // In practice, if you frequently use a given type that is not covered by the normal API entry points, you can wrap it 
        // yourself inside a 1 line function which can take typed argument as value instead of void*, and then pass their address 
        // to the generic function. For example:
        //   bool MySliderU64(const char *label, u64* value, u64 min = 0, u64 max = 0, const char* format = "%lld") 
        //   { 
        //      return SliderScalar(label, ImGuiDataType_U64, value, &min, &max, format); 
        //   }

        // Limits (as helper variables that we can take the address of)
        // Note that the SliderScalar function has a maximum usable range of half the natural type maximum, hence the /2 below.
        #ifndef LLONG_MIN
        ImS64 LLONG_MIN = -9223372036854775807LL - 1;
        ImS64 LLONG_MAX = 9223372036854775807LL;
        ImU64 ULLONG_MAX = (2ULL * 9223372036854775807LL + 1);
        #endif
        const ImS32   s32_zero = 0,   s32_one = 1,   s32_fifty = 50, s32_min = INT_MIN/2,   s32_max = INT_MAX/2,    s32_hi_a = INT_MAX/2 - 100,    s32_hi_b = INT_MAX/2;
        const ImU32   u32_zero = 0,   u32_one = 1,   u32_fifty = 50, u32_min = 0,           u32_max = UINT_MAX/2,   u32_hi_a = UINT_MAX/2 - 100,   u32_hi_b = UINT_MAX/2;
        const ImS64   s64_zero = 0,   s64_one = 1,   s64_fifty = 50, s64_min = LLONG_MIN/2, s64_max = LLONG_MAX/2,  s64_hi_a = LLONG_MAX/2 - 100,  s64_hi_b = LLONG_MAX/2;
        const ImU64   u64_zero = 0,   u64_one = 1,   u64_fifty = 50, u64_min = 0,           u64_max = ULLONG_MAX/2, u64_hi_a = ULLONG_MAX/2 - 100, u64_hi_b = ULLONG_MAX/2;
        const float   f32_zero = 0.f, f32_one = 1.f, f32_lo_a = -10000000000.0f, f32_hi_a = +10000000000.0f;
        const double  f64_zero = 0.,  f64_one = 1.,  f64_lo_a = -1000000000000000.0, f64_hi_a = +1000000000000000.0;

        // State
        static ImS32  s32_v = -1;
        static ImU32  u32_v = (ImU32)-1;
        static ImS64  s64_v = -1;
        static ImU64  u64_v = (ImU64)-1;
        static float  f32_v = 0.123f;
        static double f64_v = 90000.01234567890123456789;

        const float drag_speed = 0.2f;
        static bool drag_clamp = false;
        ImGui::Text("Drags:");
        ImGui::Checkbox("Clamp integers to 0..50", &drag_clamp); ImGui::SameLine(); ShowHelpMarker("As with every widgets in dear imgui, we never modify values unless there is a user interaction.\nYou can override the clamping limits by using CTRL+Click to input a value.");
        ImGui::DragScalar("drag s32",       ImGuiDataType_S32,    &s32_v, drag_speed, drag_clamp ? &s32_zero : NULL, drag_clamp ? &s32_fifty : NULL);
        ImGui::DragScalar("drag u32",       ImGuiDataType_U32,    &u32_v, drag_speed, drag_clamp ? &u32_zero : NULL, drag_clamp ? &u32_fifty : NULL, "%u ms");
        ImGui::DragScalar("drag s64",       ImGuiDataType_S64,    &s64_v, drag_speed, drag_clamp ? &s64_zero : NULL, drag_clamp ? &s64_fifty : NULL);
        ImGui::DragScalar("drag u64",       ImGuiDataType_U64,    &u64_v, drag_speed, drag_clamp ? &u64_zero : NULL, drag_clamp ? &u64_fifty : NULL);
        ImGui::DragScalar("drag float",     ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, "%f", 1.0f);
        ImGui::DragScalar("drag float ^2",  ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, "%f", 2.0f); ImGui::SameLine(); ShowHelpMarker("You can use the 'power' parameter to increase tweaking precision on one side of the range.");
        ImGui::DragScalar("drag double",    ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, NULL,     "%.10f grams", 1.0f);
        ImGui::DragScalar("drag double ^2", ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, &f64_one, "0 < %.10f < 1", 2.0f);

        ImGui::Text("Sliders");
        ImGui::SliderScalar("slider s32 low",     ImGuiDataType_S32,    &s32_v, &s32_zero, &s32_fifty,"%d");
        ImGui::SliderScalar("slider s32 high",    ImGuiDataType_S32,    &s32_v, &s32_hi_a, &s32_hi_b, "%d");
        ImGui::SliderScalar("slider s32 full",    ImGuiDataType_S32,    &s32_v, &s32_min,  &s32_max,  "%d");
        ImGui::SliderScalar("slider u32 low",     ImGuiDataType_U32,    &u32_v, &u32_zero, &u32_fifty,"%u");
        ImGui::SliderScalar("slider u32 high",    ImGuiDataType_U32,    &u32_v, &u32_hi_a, &u32_hi_b, "%u");
        ImGui::SliderScalar("slider u32 full",    ImGuiDataType_U32,    &u32_v, &u32_min,  &u32_max,  "%u");
        ImGui::SliderScalar("slider s64 low",     ImGuiDataType_S64,    &s64_v, &s64_zero, &s64_fifty,"%I64d");
        ImGui::SliderScalar("slider s64 high",    ImGuiDataType_S64,    &s64_v, &s64_hi_a, &s64_hi_b, "%I64d");
        ImGui::SliderScalar("slider s64 full",    ImGuiDataType_S64,    &s64_v, &s64_min,  &s64_max,  "%I64d");
        ImGui::SliderScalar("slider u64 low",     ImGuiDataType_U64,    &u64_v, &u64_zero, &u64_fifty,"%I64u ms");
        ImGui::SliderScalar("slider u64 high",    ImGuiDataType_U64,    &u64_v, &u64_hi_a, &u64_hi_b, "%I64u ms");
        ImGui::SliderScalar("slider u64 full",    ImGuiDataType_U64,    &u64_v, &u64_min,  &u64_max,  "%I64u ms");
        ImGui::SliderScalar("slider float low",   ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one);
        ImGui::SliderScalar("slider float low^2", ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one,  "%.10f", 2.0f);
        ImGui::SliderScalar("slider float high",  ImGuiDataType_Float,  &f32_v, &f32_lo_a, &f32_hi_a, "%e");
        ImGui::SliderScalar("slider double low",  ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  "%.10f grams", 1.0f);
        ImGui::SliderScalar("slider double low^2",ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  "%.10f", 2.0f);
        ImGui::SliderScalar("slider double high", ImGuiDataType_Double, &f64_v, &f64_lo_a, &f64_hi_a, "%e grams", 1.0f);

        static bool inputs_step = true;
        ImGui::Text("Inputs");
        ImGui::Checkbox("Show step buttons", &inputs_step);
        ImGui::InputScalar("input s32",     ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, "%d");
        ImGui::InputScalar("input s32 hex", ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, "%08X", ImGuiInputTextFlags_CharsHexadecimal);
        ImGui::InputScalar("input u32",     ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, "%u");
        ImGui::InputScalar("input u32 hex", ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, "%08X", ImGuiInputTextFlags_CharsHexadecimal);
        ImGui::InputScalar("input s64",     ImGuiDataType_S64,    &s64_v, inputs_step ? &s64_one : NULL);
        ImGui::InputScalar("input u64",     ImGuiDataType_U64,    &u64_v, inputs_step ? &u64_one : NULL);
        ImGui::InputScalar("input float",   ImGuiDataType_Float,  &f32_v, inputs_step ? &f32_one : NULL);
        ImGui::InputScalar("input double",  ImGuiDataType_Double, &f64_v, inputs_step ? &f64_one : NULL);

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Multi-component Widgets"))
    {
        static float vec4f[4] = { 0.10f, 0.20f, 0.30f, 0.44f };
        static int vec4i[4] = { 1, 5, 100, 255 };

        ImGui::InputFloat2("input float2", vec4f);
        ImGui::DragFloat2("drag float2", vec4f, 0.01f, 0.0f, 1.0f);
        ImGui::SliderFloat2("slider float2", vec4f, 0.0f, 1.0f);
        ImGui::InputInt2("input int2", vec4i);
        ImGui::DragInt2("drag int2", vec4i, 1, 0, 255);
        ImGui::SliderInt2("slider int2", vec4i, 0, 255);
        ImGui::Spacing();

        ImGui::InputFloat3("input float3", vec4f);
        ImGui::DragFloat3("drag float3", vec4f, 0.01f, 0.0f, 1.0f);
        ImGui::SliderFloat3("slider float3", vec4f, 0.0f, 1.0f);
        ImGui::InputInt3("input int3", vec4i);
        ImGui::DragInt3("drag int3", vec4i, 1, 0, 255);
        ImGui::SliderInt3("slider int3", vec4i, 0, 255);
        ImGui::Spacing();

        ImGui::InputFloat4("input float4", vec4f);
        ImGui::DragFloat4("drag float4", vec4f, 0.01f, 0.0f, 1.0f);
        ImGui::SliderFloat4("slider float4", vec4f, 0.0f, 1.0f);
        ImGui::InputInt4("input int4", vec4i);
        ImGui::DragInt4("drag int4", vec4i, 1, 0, 255);
        ImGui::SliderInt4("slider int4", vec4i, 0, 255);

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Vertical Sliders"))
    {
        const float spacing = 4;
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));

        static int int_value = 0;
        ImGui::VSliderInt("##int", ImVec2(18,160), &int_value, 0, 5);
        ImGui::SameLine();

        static float values[7] = { 0.0f, 0.60f, 0.35f, 0.9f, 0.70f, 0.20f, 0.0f };
        ImGui::PushID("set1");
        for (int i = 0; i < 7; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)ImColor::HSV(i/7.0f, 0.5f, 0.5f));
            ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, (ImVec4)ImColor::HSV(i/7.0f, 0.6f, 0.5f));
            ImGui::PushStyleColor(ImGuiCol_FrameBgActive, (ImVec4)ImColor::HSV(i/7.0f, 0.7f, 0.5f));
            ImGui::PushStyleColor(ImGuiCol_SliderGrab, (ImVec4)ImColor::HSV(i/7.0f, 0.9f, 0.9f));
            ImGui::VSliderFloat("##v", ImVec2(18,160), &values[i], 0.0f, 1.0f, "");
            if (ImGui::IsItemActive() || ImGui::IsItemHovered())
                ImGui::SetTooltip("%.3f", values[i]);
            ImGui::PopStyleColor(4);
            ImGui::PopID();
        }
        ImGui::PopID();

        ImGui::SameLine();
        ImGui::PushID("set2");
        static float values2[4] = { 0.20f, 0.80f, 0.40f, 0.25f };
        const int rows = 3;
        const ImVec2 small_slider_size(18, (160.0f-(rows-1)*spacing)/rows);
        for (int nx = 0; nx < 4; nx++)
        {
            if (nx > 0) ImGui::SameLine();
            ImGui::BeginGroup();
            for (int ny = 0; ny < rows; ny++)
            {
                ImGui::PushID(nx*rows+ny);
                ImGui::VSliderFloat("##v", small_slider_size, &values2[nx], 0.0f, 1.0f, "");
                if (ImGui::IsItemActive() || ImGui::IsItemHovered())
                    ImGui::SetTooltip("%.3f", values2[nx]);
                ImGui::PopID();
            }
            ImGui::EndGroup();
        }
        ImGui::PopID();

        ImGui::SameLine();
        ImGui::PushID("set3");
        for (int i = 0; i < 4; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::PushStyleVar(ImGuiStyleVar_GrabMinSize, 40);
            ImGui::VSliderFloat("##v", ImVec2(40,160), &values[i], 0.0f, 1.0f, "%.2f\nsec");
            ImGui::PopStyleVar();
            ImGui::PopID();
        }
        ImGui::PopID();
        ImGui::PopStyleVar();
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Drag and Drop"))
    {
        {
            // ColorEdit widgets automatically act as drag source and drag target.
            // They are using standardized payload strings IMGUI_PAYLOAD_TYPE_COLOR_3F and IMGUI_PAYLOAD_TYPE_COLOR_4F to allow your own widgets
            // to use colors in their drag and drop interaction. Also see the demo in Color Picker -> Palette demo.
            ImGui::BulletText("Drag and drop in standard widgets");
            ImGui::Indent();
            static float col1[3] = { 1.0f,0.0f,0.2f };
            static float col2[4] = { 0.4f,0.7f,0.0f,0.5f };
            ImGui::ColorEdit3("color 1", col1);
            ImGui::ColorEdit4("color 2", col2);
            ImGui::Unindent();
        }

        {
            ImGui::BulletText("Drag and drop to copy/swap items");
            ImGui::Indent();
            enum Mode
            {
                Mode_Copy,
                Mode_Move,
                Mode_Swap
            };
            static int mode = 0;
            if (ImGui::RadioButton("Copy", mode == Mode_Copy)) { mode = Mode_Copy; } ImGui::SameLine();
            if (ImGui::RadioButton("Move", mode == Mode_Move)) { mode = Mode_Move; } ImGui::SameLine();
            if (ImGui::RadioButton("Swap", mode == Mode_Swap)) { mode = Mode_Swap; } 
            static const char* names[9] = { "Bobby", "Beatrice", "Betty", "Brianna", "Barry", "Bernard", "Bibi", "Blaine", "Bryn" };
            for (int n = 0; n < IM_ARRAYSIZE(names); n++)
            {
                ImGui::PushID(n);
                if ((n % 3) != 0)
                    ImGui::SameLine();
                ImGui::Button(names[n], ImVec2(60,60));

                // Our buttons are both drag sources and drag targets here!
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    ImGui::SetDragDropPayload("DND_DEMO_CELL", &n, sizeof(int));        // Set payload to carry the index of our item (could be anything)
                    if (mode == Mode_Copy) { ImGui::Text("Copy %s", names[n]); }        // Display preview (could be anything, e.g. when dragging an image we could decide to display the filename and a small preview of the image, etc.)
                    if (mode == Mode_Move) { ImGui::Text("Move %s", names[n]); }
                    if (mode == Mode_Swap) { ImGui::Text("Swap %s", names[n]); }
                    ImGui::EndDragDropSource();
                }
                if (ImGui::BeginDragDropTarget())
                {
                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_DEMO_CELL"))
                    {
                        IM_ASSERT(payload->DataSize == sizeof(int));
                        int payload_n = *(const int*)payload->Data;
                        if (mode == Mode_Copy)
                        {
                            names[n] = names[payload_n];
                        }
                        if (mode == Mode_Move)
                        {
                            names[n] = names[payload_n];
                            names[payload_n] = "";
                        }
                        if (mode == Mode_Swap)
                        {
                            const char* tmp = names[n];
                            names[n] = names[payload_n];
                            names[payload_n] = tmp;
                        }
                    }
                    ImGui::EndDragDropTarget();
                }
                ImGui::PopID();
            }
            ImGui::Unindent();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Querying Status (Active/Focused/Hovered etc.)"))
    {
        // Display the value of IsItemHovered() and other common item state functions. Note that the flags can be combined.
        // (because BulletText is an item itself and that would affect the output of IsItemHovered() we pass all state in a single call to simplify the code).
        static int item_type = 1;
        static bool b = false;
        static float col4f[4] = { 1.0f, 0.5, 0.0f, 1.0f };
        ImGui::RadioButton("Text", &item_type, 0);
        ImGui::RadioButton("Button", &item_type, 1);
        ImGui::RadioButton("CheckBox", &item_type, 2);
        ImGui::RadioButton("SliderFloat", &item_type, 3);
        ImGui::RadioButton("ColorEdit4", &item_type, 4);
        ImGui::RadioButton("ListBox", &item_type, 5);
        ImGui::Separator();
        bool ret = false;
        if (item_type == 0) { ImGui::Text("ITEM: Text"); }                                              // Testing text items with no identifier/interaction
        if (item_type == 1) { ret = ImGui::Button("ITEM: Button"); }                                    // Testing button
        if (item_type == 2) { ret = ImGui::Checkbox("ITEM: CheckBox", &b); }                            // Testing checkbox
        if (item_type == 3) { ret = ImGui::SliderFloat("ITEM: SliderFloat", &col4f[0], 0.0f, 1.0f); }   // Testing basic item
        if (item_type == 4) { ret = ImGui::ColorEdit4("ITEM: ColorEdit4", col4f); }                     // Testing multi-component items (IsItemXXX flags are reported merged)
        if (item_type == 5) { const char* items[] = { "Apple", "Banana", "Cherry", "Kiwi" }; static int current = 1; ret = ImGui::ListBox("ITEM: ListBox", &current, items, IM_ARRAYSIZE(items), IM_ARRAYSIZE(items)); }
        ImGui::BulletText(
            "Return value = %d\n"
            "IsItemFocused() = %d\n"
            "IsItemHovered() = %d\n"
            "IsItemHovered(_AllowWhenBlockedByPopup) = %d\n"
            "IsItemHovered(_AllowWhenBlockedByActiveItem) = %d\n"
            "IsItemHovered(_AllowWhenOverlapped) = %d\n"
            "IsItemHovered(_RectOnly) = %d\n"
            "IsItemActive() = %d\n"
            "IsItemEdited() = %d\n"
            "IsItemDeactivated() = %d\n"
            "IsItemDeactivatedEdit() = %d\n"
            "IsItemVisible() = %d\n"
            "GetItemRectMin() = (%.1f, %.1f)\n"
            "GetItemRectMax() = (%.1f, %.1f)\n"
            "GetItemRectSize() = (%.1f, %.1f)",
            ret,
            ImGui::IsItemFocused(),
            ImGui::IsItemHovered(),
            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),
            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenOverlapped),
            ImGui::IsItemHovered(ImGuiHoveredFlags_RectOnly),
            ImGui::IsItemActive(),
            ImGui::IsItemEdited(),
            ImGui::IsItemDeactivated(),
            ImGui::IsItemDeactivatedAfterEdit(),
            ImGui::IsItemVisible(),
            ImGui::GetItemRectMin().x, ImGui::GetItemRectMin().y,
            ImGui::GetItemRectMax().x, ImGui::GetItemRectMax().y,
            ImGui::GetItemRectSize().x, ImGui::GetItemRectSize().y
        );

        static bool embed_all_inside_a_child_window = false;
        ImGui::Checkbox("Embed everything inside a child window (for additional testing)", &embed_all_inside_a_child_window);
        if (embed_all_inside_a_child_window)
            ImGui::BeginChild("outer_child", ImVec2(0, ImGui::GetFontSize() * 20), true);

        // Testing IsWindowFocused() function with its various flags. Note that the flags can be combined.
        ImGui::BulletText(
            "IsWindowFocused() = %d\n"
            "IsWindowFocused(_ChildWindows) = %d\n"
            "IsWindowFocused(_ChildWindows|_RootWindow) = %d\n"
            "IsWindowFocused(_RootWindow) = %d\n"
            "IsWindowFocused(_AnyWindow) = %d\n",
            ImGui::IsWindowFocused(),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows | ImGuiFocusedFlags_RootWindow),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_RootWindow),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow));

        // Testing IsWindowHovered() function with its various flags. Note that the flags can be combined.
        ImGui::BulletText(
            "IsWindowHovered() = %d\n"
            "IsWindowHovered(_AllowWhenBlockedByPopup) = %d\n"
            "IsWindowHovered(_AllowWhenBlockedByActiveItem) = %d\n"
            "IsWindowHovered(_ChildWindows) = %d\n"
            "IsWindowHovered(_ChildWindows|_RootWindow) = %d\n"
            "IsWindowHovered(_RootWindow) = %d\n"
            "IsWindowHovered(_AnyWindow) = %d\n",
            ImGui::IsWindowHovered(),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_RootWindow),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_RootWindow),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow));

        ImGui::BeginChild("child", ImVec2(0, 50), true);
        ImGui::Text("This is another child window for testing with the _ChildWindows flag.");
        ImGui::EndChild();
        if (embed_all_inside_a_child_window)
            ImGui::EndChild();

        // Calling IsItemHovered() after begin returns the hovered status of the title bar. 
        // This is useful in particular if you want to create a context menu (with BeginPopupContextItem) associated to the title bar of a window.
        static bool test_window = false;
        ImGui::Checkbox("Hovered/Active tests after Begin() for title bar testing", &test_window);
        if (test_window)
        {
            ImGui::Begin("Title bar Hovered/Active tests", &test_window);
            if (ImGui::BeginPopupContextItem()) // <-- This is using IsItemHovered()
            {
                if (ImGui::MenuItem("Close")) { test_window = false; }
                ImGui::EndPopup();
            }
            ImGui::Text(
                "IsItemHovered() after begin = %d (== is title bar hovered)\n"
                "IsItemActive() after begin = %d (== is window being clicked/moved)\n",
                ImGui::IsItemHovered(), ImGui::IsItemActive());
            ImGui::End();
        }

        ImGui::TreePop();
    }
}

static void ShowDemoWindowLayout()
{
    if (!ImGui::CollapsingHeader("Layout"))
        return;

    if (ImGui::TreeNode("Child regions"))
    {
        static bool disable_mouse_wheel = false;
        static bool disable_menu = false;
        ImGui::Checkbox("Disable Mouse Wheel", &disable_mouse_wheel);
        ImGui::Checkbox("Disable Menu", &disable_menu);

        static int line = 50;
        bool goto_line = ImGui::Button("Goto");
        ImGui::SameLine();
        ImGui::PushItemWidth(100);
        goto_line |= ImGui::InputInt("##Line", &line, 0, 0, ImGuiInputTextFlags_EnterReturnsTrue);
        ImGui::PopItemWidth();

        // Child 1: no border, enable horizontal scrollbar
        {
            ImGui::BeginChild("Child1", ImVec2(ImGui::GetWindowContentRegionWidth() * 0.5f, 300), false, ImGuiWindowFlags_HorizontalScrollbar | (disable_mouse_wheel ? ImGuiWindowFlags_NoScrollWithMouse : 0));
            for (int i = 0; i < 100; i++)
            {
                ImGui::Text("%04d: scrollable region", i);
                if (goto_line && line == i)
                    ImGui::SetScrollHereY();
            }
            if (goto_line && line >= 100)
                ImGui::SetScrollHereY();
            ImGui::EndChild();
        }

        ImGui::SameLine();

        // Child 2: rounded border
        {
            ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 5.0f);
            ImGui::BeginChild("Child2", ImVec2(0, 300), true, (disable_mouse_wheel ? ImGuiWindowFlags_NoScrollWithMouse : 0) | (disable_menu ? 0 : ImGuiWindowFlags_MenuBar));
            if (!disable_menu && ImGui::BeginMenuBar())
            {
                if (ImGui::BeginMenu("Menu"))
                {
                    ShowExampleMenuFile();
                    ImGui::EndMenu();
                }
                ImGui::EndMenuBar();
            }
            ImGui::Columns(2);
            for (int i = 0; i < 100; i++)
            {
                char buf[32];
                sprintf(buf, "%03d", i);
                ImGui::Button(buf, ImVec2(-1.0f, 0.0f));
                ImGui::NextColumn();
            }
            ImGui::EndChild();
            ImGui::PopStyleVar();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Widgets Width"))
    {
        static float f = 0.0f;
        ImGui::Text("PushItemWidth(100)");
        ImGui::SameLine(); ShowHelpMarker("Fixed width.");
        ImGui::PushItemWidth(100);
        ImGui::DragFloat("float##1", &f);
        ImGui::PopItemWidth();

        ImGui::Text("PushItemWidth(GetWindowWidth() * 0.5f)");
        ImGui::SameLine(); ShowHelpMarker("Half of window width.");
        ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.5f);
        ImGui::DragFloat("float##2", &f);
        ImGui::PopItemWidth();

        ImGui::Text("PushItemWidth(GetContentRegionAvailWidth() * 0.5f)");
        ImGui::SameLine(); ShowHelpMarker("Half of available width.\n(~ right-cursor_pos)\n(works within a column set)");
        ImGui::PushItemWidth(ImGui::GetContentRegionAvailWidth() * 0.5f);
        ImGui::DragFloat("float##3", &f);
        ImGui::PopItemWidth();

        ImGui::Text("PushItemWidth(-100)");
        ImGui::SameLine(); ShowHelpMarker("Align to right edge minus 100");
        ImGui::PushItemWidth(-100);
        ImGui::DragFloat("float##4", &f);
        ImGui::PopItemWidth();

        ImGui::Text("PushItemWidth(-1)");
        ImGui::SameLine(); ShowHelpMarker("Align to right edge");
        ImGui::PushItemWidth(-1);
        ImGui::DragFloat("float##5", &f);
        ImGui::PopItemWidth();

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Basic Horizontal Layout"))
    {
        ImGui::TextWrapped("(Use ImGui::SameLine() to keep adding items to the right of the preceding item)");

        // Text
        ImGui::Text("Two items: Hello"); ImGui::SameLine();
        ImGui::TextColored(ImVec4(1,1,0,1), "Sailor");

        // Adjust spacing
        ImGui::Text("More spacing: Hello"); ImGui::SameLine(0, 20);
        ImGui::TextColored(ImVec4(1,1,0,1), "Sailor");

        // Button
        ImGui::AlignTextToFramePadding();
        ImGui::Text("Normal buttons"); ImGui::SameLine();
        ImGui::Button("Banana"); ImGui::SameLine();
        ImGui::Button("Apple"); ImGui::SameLine();
        ImGui::Button("Corniflower");

        // Button
        ImGui::Text("Small buttons"); ImGui::SameLine();
        ImGui::SmallButton("Like this one"); ImGui::SameLine();
        ImGui::Text("can fit within a text block.");

        // Aligned to arbitrary position. Easy/cheap column.
        ImGui::Text("Aligned");
        ImGui::SameLine(150); ImGui::Text("x=150");
        ImGui::SameLine(300); ImGui::Text("x=300");
        ImGui::Text("Aligned");
        ImGui::SameLine(150); ImGui::SmallButton("x=150");
        ImGui::SameLine(300); ImGui::SmallButton("x=300");

        // Checkbox
        static bool c1 = false, c2 = false, c3 = false, c4 = false;
        ImGui::Checkbox("My", &c1); ImGui::SameLine();
        ImGui::Checkbox("Tailor", &c2); ImGui::SameLine();
        ImGui::Checkbox("Is", &c3); ImGui::SameLine();
        ImGui::Checkbox("Rich", &c4);

        // Various
        static float f0 = 1.0f, f1 = 2.0f, f2 = 3.0f;
        ImGui::PushItemWidth(80);
        const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD" };
        static int item = -1;
        ImGui::Combo("Combo", &item, items, IM_ARRAYSIZE(items)); ImGui::SameLine();
        ImGui::SliderFloat("X", &f0, 0.0f, 5.0f); ImGui::SameLine();
        ImGui::SliderFloat("Y", &f1, 0.0f, 5.0f); ImGui::SameLine();
        ImGui::SliderFloat("Z", &f2, 0.0f, 5.0f);
        ImGui::PopItemWidth();

        ImGui::PushItemWidth(80);
        ImGui::Text("Lists:");
        static int selection[4] = { 0, 1, 2, 3 };
        for (int i = 0; i < 4; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::ListBox("", &selection[i], items, IM_ARRAYSIZE(items));
            ImGui::PopID();
            //if (ImGui::IsItemHovered()) ImGui::SetTooltip("ListBox %d hovered", i);
        }
        ImGui::PopItemWidth();

        // Dummy
        ImVec2 button_sz(40, 40);
        ImGui::Button("A", button_sz); ImGui::SameLine();
        ImGui::Dummy(button_sz); ImGui::SameLine();
        ImGui::Button("B", button_sz);

        // Manually wrapping (we should eventually provide this as an automatic layout feature, but for now you can do it manually)
        ImGui::Text("Manually wrapping:");
        ImGuiStyle& style = ImGui::GetStyle();
        int buttons_count = 20;
        float window_visible_x2 = ImGui::GetWindowPos().x + ImGui::GetWindowContentRegionMax().x;
        for (int n = 0; n < buttons_count; n++)
        {
            ImGui::PushID(n);
            ImGui::Button("Box", button_sz);
            float last_button_x2 = ImGui::GetItemRectMax().x;
            float next_button_x2 = last_button_x2 + style.ItemSpacing.x + button_sz.x; // Expected position if next button was on same line
            if (n + 1 < buttons_count && next_button_x2 < window_visible_x2)
                ImGui::SameLine();
            ImGui::PopID();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Tabs"))
    {
        if (ImGui::TreeNode("Basic"))
        {
            ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
            if (ImGui::BeginTabBar("MyTabBar", tab_bar_flags))
            {
                if (ImGui::BeginTabItem("Avocado"))
                {
                    ImGui::Text("This is the Avocado tab!\nblah blah blah blah blah");
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Broccoli"))
                {
                    ImGui::Text("This is the Broccoli tab!\nblah blah blah blah blah");
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Cucumber"))
                {
                    ImGui::Text("This is the Cucumber tab!\nblah blah blah blah blah");
                    ImGui::EndTabItem();
                }
                ImGui::EndTabBar();
            }
            ImGui::Separator();
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Advanced & Close Button"))
        {
            // Expose a couple of the available flags. In most cases you may just call BeginTabBar() with no flags (0).
            static ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_Reorderable;
            ImGui::CheckboxFlags("ImGuiTabBarFlags_Reorderable", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_Reorderable);
            ImGui::CheckboxFlags("ImGuiTabBarFlags_AutoSelectNewTabs", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_AutoSelectNewTabs);
            ImGui::CheckboxFlags("ImGuiTabBarFlags_NoCloseWithMiddleMouseButton", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_NoCloseWithMiddleMouseButton);
            if ((tab_bar_flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)
                tab_bar_flags |= ImGuiTabBarFlags_FittingPolicyDefault_;
            if (ImGui::CheckboxFlags("ImGuiTabBarFlags_FittingPolicyResizeDown", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_FittingPolicyResizeDown))
                tab_bar_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyResizeDown);
            if (ImGui::CheckboxFlags("ImGuiTabBarFlags_FittingPolicyScroll", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_FittingPolicyScroll))
                tab_bar_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyScroll);

            // Tab Bar
            const char* names[4] = { "Artichoke", "Beetroot", "Celery", "Daikon" };
            static bool opened[4] = { true, true, true, true }; // Persistent user state
            for (int n = 0; n < IM_ARRAYSIZE(opened); n++)
            {
                if (n > 0) { ImGui::SameLine(); }
                ImGui::Checkbox(names[n], &opened[n]);
            }

            // Passing a bool* to BeginTabItem() is similar to passing one to Begin(): the underlying bool will be set to false when the tab is closed.
            if (ImGui::BeginTabBar("MyTabBar", tab_bar_flags))
            {
                for (int n = 0; n < IM_ARRAYSIZE(opened); n++)
                    if (opened[n] && ImGui::BeginTabItem(names[n], &opened[n]))
                    {
                        ImGui::Text("This is the %s tab!", names[n]);
                        if (n & 1)
                            ImGui::Text("I am an odd tab.");
                        ImGui::EndTabItem();
                    }
                ImGui::EndTabBar();
            }
            ImGui::Separator();
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Groups"))
    {
        ImGui::TextWrapped("(Using ImGui::BeginGroup()/EndGroup() to layout items. BeginGroup() basically locks the horizontal position. EndGroup() bundles the whole group so that you can use functions such as IsItemHovered() on it.)");
        ImGui::BeginGroup();
        {
            ImGui::BeginGroup();
            ImGui::Button("AAA");
            ImGui::SameLine();
            ImGui::Button("BBB");
            ImGui::SameLine();
            ImGui::BeginGroup();
            ImGui::Button("CCC");
            ImGui::Button("DDD");
            ImGui::EndGroup();
            ImGui::SameLine();
            ImGui::Button("EEE");
            ImGui::EndGroup();
            if (ImGui::IsItemHovered())
                ImGui::SetTooltip("First group hovered");
        }
        // Capture the group size and create widgets using the same size
        ImVec2 size = ImGui::GetItemRectSize();
        const float values[5] = { 0.5f, 0.20f, 0.80f, 0.60f, 0.25f };
        ImGui::PlotHistogram("##values", values, IM_ARRAYSIZE(values), 0, NULL, 0.0f, 1.0f, size);

        ImGui::Button("ACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f, size.y));
        ImGui::SameLine();
        ImGui::Button("REACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f, size.y));
        ImGui::EndGroup();
        ImGui::SameLine();

        ImGui::Button("LEVERAGE\nBUZZWORD", size);
        ImGui::SameLine();

        if (ImGui::ListBoxHeader("List", size))
        {
            ImGui::Selectable("Selected", true);
            ImGui::Selectable("Not Selected", false);
            ImGui::ListBoxFooter();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Text Baseline Alignment"))
    {
        ImGui::TextWrapped("(This is testing the vertical alignment that occurs on text to keep it at the same baseline as widgets. Lines only composed of text or \"small\" widgets fit in less vertical spaces than lines with normal widgets)");

        ImGui::Text("One\nTwo\nThree"); ImGui::SameLine();
        ImGui::Text("Hello\nWorld"); ImGui::SameLine();
        ImGui::Text("Banana");

        ImGui::Text("Banana"); ImGui::SameLine();
        ImGui::Text("Hello\nWorld"); ImGui::SameLine();
        ImGui::Text("One\nTwo\nThree");

        ImGui::Button("HOP##1"); ImGui::SameLine();
        ImGui::Text("Banana"); ImGui::SameLine();
        ImGui::Text("Hello\nWorld"); ImGui::SameLine();
        ImGui::Text("Banana");

        ImGui::Button("HOP##2"); ImGui::SameLine();
        ImGui::Text("Hello\nWorld"); ImGui::SameLine();
        ImGui::Text("Banana");

        ImGui::Button("TEST##1"); ImGui::SameLine();
        ImGui::Text("TEST"); ImGui::SameLine();
        ImGui::SmallButton("TEST##2");

        ImGui::AlignTextToFramePadding(); // If your line starts with text, call this to align it to upcoming widgets.
        ImGui::Text("Text aligned to Widget"); ImGui::SameLine();
        ImGui::Button("Widget##1"); ImGui::SameLine();
        ImGui::Text("Widget"); ImGui::SameLine();
        ImGui::SmallButton("Widget##2"); ImGui::SameLine();
        ImGui::Button("Widget##3");

        // Tree
        const float spacing = ImGui::GetStyle().ItemInnerSpacing.x;
        ImGui::Button("Button##1");
        ImGui::SameLine(0.0f, spacing);
        if (ImGui::TreeNode("Node##1")) { for (int i = 0; i < 6; i++) ImGui::BulletText("Item %d..", i); ImGui::TreePop(); }    // Dummy tree data

        ImGui::AlignTextToFramePadding();         // Vertically align text node a bit lower so it'll be vertically centered with upcoming widget. Otherwise you can use SmallButton (smaller fit).
        bool node_open = ImGui::TreeNode("Node##2");  // Common mistake to avoid: if we want to SameLine after TreeNode we need to do it before we add child content.
        ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##2");
        if (node_open) { for (int i = 0; i < 6; i++) ImGui::BulletText("Item %d..", i); ImGui::TreePop(); }   // Dummy tree data

        // Bullet
        ImGui::Button("Button##3");
        ImGui::SameLine(0.0f, spacing);
        ImGui::BulletText("Bullet text");

        ImGui::AlignTextToFramePadding();
        ImGui::BulletText("Node");
        ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##4");

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Scrolling"))
    {
        ImGui::TextWrapped("(Use SetScrollHereY() or SetScrollFromPosY() to scroll to a given position.)");
        static bool track = true;
        static int track_line = 50, scroll_to_px = 200;
        ImGui::Checkbox("Track", &track);
        ImGui::PushItemWidth(100);
        ImGui::SameLine(130); track |= ImGui::DragInt("##line", &track_line, 0.25f, 0, 99, "Line = %d");
        bool scroll_to = ImGui::Button("Scroll To Pos");
        ImGui::SameLine(130); scroll_to |= ImGui::DragInt("##pos_y", &scroll_to_px, 1.00f, 0, 9999, "Y = %d px");
        ImGui::PopItemWidth();
        if (scroll_to) track = false;

        for (int i = 0; i < 5; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::BeginGroup();
            ImGui::Text("%s", i == 0 ? "Top" : i == 1 ? "25%" : i == 2 ? "Center" : i == 3 ? "75%" : "Bottom");
            ImGui::BeginChild(ImGui::GetID((void*)(intptr_t)i), ImVec2(ImGui::GetWindowWidth() * 0.17f, 200.0f), true);
            if (scroll_to)
                ImGui::SetScrollFromPosY(ImGui::GetCursorLoopCallbackPos().y + scroll_to_px, i * 0.25f);
            for (int line = 0; line < 100; line++)
            {
                if (track && line == track_line)
                {
                    ImGui::TextColored(ImVec4(1,1,0,1), "Line %d", line);
                    ImGui::SetScrollHereY(i * 0.25f); // 0.0f:top, 0.5f:center, 1.0f:bottom
                }
                else
                {
                    ImGui::Text("Line %d", line);
                }
            }
            float scroll_y = ImGui::GetScrollY(), scroll_max_y = ImGui::GetScrollMaxY();
            ImGui::EndChild();
            ImGui::Text("%.0f/%0.f", scroll_y, scroll_max_y);
            ImGui::EndGroup();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Horizontal Scrolling"))
    {
        ImGui::Bullet(); ImGui::TextWrapped("Horizontal scrolling for a window has to be enabled explicitly via the ImGuiWindowFlags_HorizontalScrollbar flag.");
        ImGui::Bullet(); ImGui::TextWrapped("You may want to explicitly specify content width by calling SetNextWindowContentWidth() before Begin().");
        static int lines = 7;
        ImGui::SliderInt("Lines", &lines, 1, 15);
        ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 3.0f);
        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2.0f, 1.0f));
        ImGui::BeginChild("scrolling", ImVec2(0, ImGui::GetFrameHeightWithSpacing() * 7 + 30), true, ImGuiWindowFlags_HorizontalScrollbar);
        for (int line = 0; line < lines; line++)
        {
            // Display random stuff (for the sake of this trivial demo we are using basic Button+SameLine. If you want to create your own time line for a real application you may be better off
            // manipulating the cursor position yourself, aka using SetCursorPos/SetCursorScreenPos to position the widgets yourself. You may also want to use the lower-level ImDrawList API)
            int num_buttons = 10 + ((line & 1) ? line * 9 : line * 3);
            for (int n = 0; n < num_buttons; n++)
            {
                if (n > 0) ImGui::SameLine();
                ImGui::PushID(n + line * 1000);
                char num_buf[16];
                sprintf(num_buf, "%d", n);
                const char* label = (!(n%15)) ? "FizzBuzz" : (!(n%3)) ? "Fizz" : (!(n%5)) ? "Buzz" : num_buf;
                float hue = n*0.05f;
                ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(hue, 0.6f, 0.6f));
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(hue, 0.7f, 0.7f));
                ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(hue, 0.8f, 0.8f));
                ImGui::Button(label, ImVec2(40.0f + sinf((float)(line + n)) * 20.0f, 0.0f));
                ImGui::PopStyleColor(3);
                ImGui::PopID();
            }
        }
        float scroll_x = ImGui::GetScrollX(), scroll_max_x = ImGui::GetScrollMaxX();
        ImGui::EndChild();
        ImGui::PopStyleVar(2);
        float scroll_x_delta = 0.0f;
        ImGui::SmallButton("<<"); if (ImGui::IsItemActive()) scroll_x_delta = -ImGui::GetIO().DeltaTime * 1000.0f; ImGui::SameLine();
        ImGui::Text("Scroll from code"); ImGui::SameLine();
        ImGui::SmallButton(">>"); if (ImGui::IsItemActive()) scroll_x_delta = +ImGui::GetIO().DeltaTime * 1000.0f; ImGui::SameLine();
        ImGui::Text("%.0f/%.0f", scroll_x, scroll_max_x);
        if (scroll_x_delta != 0.0f)
        {
            ImGui::BeginChild("scrolling"); // Demonstrate a trick: you can use Begin to set yourself in the context of another window (here we are already out of your child window)
            ImGui::SetScrollX(ImGui::GetScrollX() + scroll_x_delta);
            ImGui::End();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Clipping"))
    {
        static ImVec2 size(100, 100), offset(50, 20);
        ImGui::TextWrapped("On a per-widget basis we are occasionally clipping text CPU-side if it won't fit in its frame. Otherwise we are doing coarser clipping + passing a scissor rectangle to the renderer. The system is designed to try minimizing both execution and CPU/GPU rendering cost.");
        ImGui::DragFloat2("size", (float*)&size, 0.5f, 0.0f, 200.0f, "%.0f");
        ImGui::TextWrapped("(Click and drag)");
        ImVec2 pos = ImGui::GetCursorScreenPos();
        ImVec4 clip_rect(pos.x, pos.y, pos.x + size.x, pos.y + size.y);
        ImGui::InvisibleButton("##dummy", size);
        if (ImGui::IsItemActive() && ImGui::IsMouseDragging()) { offset.x += ImGui::GetIO().MouseDelta.x; offset.y += ImGui::GetIO().MouseDelta.y; }
        ImGui::GetWindowDrawList()->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), IM_COL32(90, 90, 120, 255));
        ImGui::GetWindowDrawList()->AddText(ImGui::GetFont(), ImGui::GetFontSize()*2.0f, ImVec2(pos.x + offset.x, pos.y + offset.y), IM_COL32(255, 255, 255, 255), "Line 1 hello\nLine 2 clip me!", NULL, 0.0f, &clip_rect);
        ImGui::TreePop();
    }
}

static void ShowDemoWindowPopups()
{
    if (!ImGui::CollapsingHeader("Popups & Modal windows"))
        return;

    // The properties of popups windows are:
    // - They block normal mouse hovering detection outside them. (*)
    // - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
    // - Their visibility state (~bool) is held internally by imgui instead of being held by the programmer as we are used to with regular Begin() calls.
    //   User can manipulate the visibility state by calling OpenPopup().
    // (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even when normally blocked by a popup.
    // Those three properties are connected. The library needs to hold their visibility state because it can close popups at any time.

    // Typical use for regular windows:
    //   bool my_tool_is_active = false; if (ImGui::Button("Open")) my_tool_is_active = true; [...] if (my_tool_is_active) Begin("My Tool", &my_tool_is_active) { [...] } End();
    // Typical use for popups:
    //   if (ImGui::Button("Open")) ImGui::OpenPopup("MyPopup"); if (ImGui::BeginPopup("MyPopup") { [...] EndPopup(); }

    // With popups we have to go through a library call (here OpenPopup) to manipulate the visibility state.
    // This may be a bit confusing at first but it should quickly make sense. Follow on the examples below. 

    if (ImGui::TreeNode("Popups"))
    {
        ImGui::TextWrapped("When a popup is active, it inhibits interacting with windows that are behind the popup. Clicking outside the popup closes it.");

        static int selected_fish = -1;
        const char* names[] = { "Bream", "Haddock", "Mackerel", "Pollock", "Tilefish" };
        static bool toggles[] = { true, false, false, false, false };

        // Simple selection popup
        // (If you want to show the current selection inside the Button itself, you may want to build a string using the "###" operator to preserve a constant ID with a variable label)
        if (ImGui::Button("Select.."))
            ImGui::OpenPopup("my_select_popup");
        ImGui::SameLine();
        ImGui::TextUnformatted(selected_fish == -1 ? "<None>" : names[selected_fish]);
        if (ImGui::BeginPopup("my_select_popup"))
        {
            ImGui::Text("Aquarium");
            ImGui::Separator();
            for (int i = 0; i < IM_ARRAYSIZE(names); i++)
                if (ImGui::Selectable(names[i]))
                    selected_fish = i;
            ImGui::EndPopup();
        }

        // Showing a menu with toggles
        if (ImGui::Button("Toggle.."))
            ImGui::OpenPopup("my_toggle_popup");
        if (ImGui::BeginPopup("my_toggle_popup"))
        {
            for (int i = 0; i < IM_ARRAYSIZE(names); i++)
                ImGui::MenuItem(names[i], "", &toggles[i]);
            if (ImGui::BeginMenu("Sub-menu"))
            {
                ImGui::MenuItem("Click me");
                ImGui::EndMenu();
            }

            ImGui::Separator();
            ImGui::Text("Tooltip here");
            if (ImGui::IsItemHovered())
                ImGui::SetTooltip("I am a tooltip over a popup");

            if (ImGui::Button("Stacked Popup"))
                ImGui::OpenPopup("another popup");
            if (ImGui::BeginPopup("another popup"))
            {
                for (int i = 0; i < IM_ARRAYSIZE(names); i++)
                    ImGui::MenuItem(names[i], "", &toggles[i]);
                if (ImGui::BeginMenu("Sub-menu"))
                {
                    ImGui::MenuItem("Click me");
                    ImGui::EndMenu();
                }
                ImGui::EndPopup();
            }
            ImGui::EndPopup();
        }

        // Call the more complete ShowExampleMenuFile which we use in various places of this demo
        if (ImGui::Button("File Menu.."))
            ImGui::OpenPopup("my_file_popup");
        if (ImGui::BeginPopup("my_file_popup"))
        {
            ShowExampleMenuFile();
            ImGui::EndPopup();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Context menus"))
    {
        // BeginPopupContextItem() is a helper to provide common/simple popup behavior of essentially doing:
        //    if (IsItemHovered() && IsMouseReleased(0))
        //       OpenPopup(id);
        //    return BeginPopup(id);
        // For more advanced uses you may want to replicate and cuztomize this code. This the comments inside BeginPopupContextItem() implementation.
        static float value = 0.5f;
        ImGui::Text("Value = %.3f (<-- right-click here)", value);
        if (ImGui::BeginPopupContextItem("item context menu"))
        {
            if (ImGui::Selectable("Set to zero")) value = 0.0f;
            if (ImGui::Selectable("Set to PI")) value = 3.1415f;
            ImGui::PushItemWidth(-1);
            ImGui::DragFloat("##Value", &value, 0.1f, 0.0f, 0.0f);
            ImGui::PopItemWidth();
            ImGui::EndPopup();
        }

        // We can also use OpenPopupOnItemClick() which is the same as BeginPopupContextItem() but without the Begin call.
        // So here we will make it that clicking on the text field with the right mouse button (1) will toggle the visibility of the popup above.
        ImGui::Text("(You can also right-click me to the same popup as above.)");
        ImGui::OpenPopupOnItemClick("item context menu", 1);

        // When used after an item that has an ID (here the Button), we can skip providing an ID to BeginPopupContextItem(). 
        // BeginPopupContextItem() will use the last item ID as the popup ID.
        // In addition here, we want to include your editable label inside the button label. We use the ### operator to override the ID (read FAQ about ID for details)
        static char name[32] = "Label1";
        char buf[64]; sprintf(buf, "Button: %s###Button", name); // ### operator override ID ignoring the preceding label
        ImGui::Button(buf);
        if (ImGui::BeginPopupContextItem())
        {
            ImGui::Text("Edit name:");
            ImGui::InputText("##edit", name, IM_ARRAYSIZE(name));
            if (ImGui::Button("Close"))
                ImGui::CloseCurrentPopup();
            ImGui::EndPopup();
        }
        ImGui::SameLine(); ImGui::Text("(<-- right-click here)");

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Modals"))
    {
        ImGui::TextWrapped("Modal windows are like popups but the user cannot close them by clicking outside the window.");

        if (ImGui::Button("Delete.."))
            ImGui::OpenPopup("Delete?");

        if (ImGui::BeginPopupModal("Delete?", NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::Text("All those beautiful files will be deleted.\nThis operation cannot be undone!\n\n");
            ImGui::Separator();

            //static int dummy_i = 0;
            //ImGui::Combo("Combo", &dummy_i, "Delete\0Delete harder\0");

            static bool dont_ask_me_next_time = false;
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
            ImGui::Checkbox("Don't ask me next time", &dont_ask_me_next_time);
            ImGui::PopStyleVar();

            if (ImGui::Button("OK", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }
            ImGui::SetItemDefaultFocus();
            ImGui::SameLine();
            if (ImGui::Button("Cancel", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }
            ImGui::EndPopup();
        }

        if (ImGui::Button("Stacked modals.."))
            ImGui::OpenPopup("Stacked 1");
        if (ImGui::BeginPopupModal("Stacked 1"))
        {
            ImGui::Text("Hello from Stacked The First\nUsing style.Colors[ImGuiCol_ModalWindowDimBg] behind it.");
            static int item = 1;
            ImGui::Combo("Combo", &item, "aaaa\0bbbb\0cccc\0dddd\0eeee\0\0");
            static float color[4] = { 0.4f,0.7f,0.0f,0.5f };
            ImGui::ColorEdit4("color", color);  // This is to test behavior of stacked regular popups over a modal

            if (ImGui::Button("Add another modal.."))
                ImGui::OpenPopup("Stacked 2");

            // Also demonstrate passing a bool* to BeginPopupModal(), this will create a regular close button which will close the popup.
            // Note that the visibility state of popups is owned by imgui, so the input value of the bool actually doesn't matter here.
            bool dummy_open = true;
            if (ImGui::BeginPopupModal("Stacked 2", &dummy_open))
            {
                ImGui::Text("Hello from Stacked The Second!");
                if (ImGui::Button("Close"))
                    ImGui::CloseCurrentPopup();
                ImGui::EndPopup();
            }

            if (ImGui::Button("Close"))
                ImGui::CloseCurrentPopup();
            ImGui::EndPopup();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Menus inside a regular window"))
    {
        ImGui::TextWrapped("Below we are testing adding menu items to a regular window. It's rather unusual but should work!");
        ImGui::Separator();
        // NB: As a quirk in this very specific example, we want to differentiate the parent of this menu from the parent of the various popup menus above.
        // To do so we are encloding the items in a PushID()/PopID() block to make them two different menusets. If we don't, opening any popup above and hovering our menu here
        // would open it. This is because once a menu is active, we allow to switch to a sibling menu by just hovering on it, which is the desired behavior for regular menus.
        ImGui::PushID("foo");
        ImGui::MenuItem("Menu item", "CTRL+M");
        if (ImGui::BeginMenu("Menu inside a regular window"))
        {
            ShowExampleMenuFile();
            ImGui::EndMenu();
        }
        ImGui::PopID();
        ImGui::Separator();
        ImGui::TreePop();
    }
}

static void ShowDemoWindowColumns()
{
    if (!ImGui::CollapsingHeader("Columns"))
        return;

    ImGui::PushID("Columns");

    // Basic columns
    if (ImGui::TreeNode("Basic"))
    {
        ImGui::Text("Without border:");
        ImGui::Columns(3, "mycolumns3", false);  // 3-ways, no border
        ImGui::Separator();
        for (int n = 0; n < 14; n++)
        {
            char label[32];
            sprintf(label, "Item %d", n);
            if (ImGui::Selectable(label)) {}
            //if (ImGui::Button(label, ImVec2(-1,0))) {}
            ImGui::NextColumn();
        }
        ImGui::Columns(1);
        ImGui::Separator();

        ImGui::Text("With border:");
        ImGui::Columns(4, "mycolumns"); // 4-ways, with border
        ImGui::Separator();
        ImGui::Text("ID"); ImGui::NextColumn();
        ImGui::Text("Name"); ImGui::NextColumn();
        ImGui::Text("Path"); ImGui::NextColumn();
        ImGui::Text("Hovered"); ImGui::NextColumn();
        ImGui::Separator();
        const char* names[3] = { "One", "Two", "Three" };
        const char* paths[3] = { "/path/one", "/path/two", "/path/three" };
        static int selected = -1;
        for (int i = 0; i < 3; i++)
        {
            char label[32];
            sprintf(label, "%04d", i);
            if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SpanAllColumns))
                selected = i;
            bool hovered = ImGui::IsItemHovered();
            ImGui::NextColumn();
            ImGui::Text(names[i]); ImGui::NextColumn();
            ImGui::Text(paths[i]); ImGui::NextColumn();
            ImGui::Text("%d", hovered); ImGui::NextColumn();
        }
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::TreePop();
    }

    // Create multiple items in a same cell before switching to next column
    if (ImGui::TreeNode("Mixed items"))
    {
        ImGui::Columns(3, "mixed");
        ImGui::Separator();

        ImGui::Text("Hello");
        ImGui::Button("Banana");
        ImGui::NextColumn();

        ImGui::Text("ImGui");
        ImGui::Button("Apple");
        static float foo = 1.0f;
        ImGui::InputFloat("red", &foo, 0.05f, 0, "%.3f");
        ImGui::Text("An extra line here.");
        ImGui::NextColumn();

        ImGui::Text("Sailor");
        ImGui::Button("Corniflower");
        static float bar = 1.0f;
        ImGui::InputFloat("blue", &bar, 0.05f, 0, "%.3f");
        ImGui::NextColumn();

        if (ImGui::CollapsingHeader("Category A")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();
        if (ImGui::CollapsingHeader("Category B")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();
        if (ImGui::CollapsingHeader("Category C")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::TreePop();
    }

    // Word wrapping
    if (ImGui::TreeNode("Word-wrapping"))
    {
        ImGui::Columns(2, "word-wrapping");
        ImGui::Separator();
        ImGui::TextWrapped("The quick brown fox jumps over the lazy dog.");
        ImGui::TextWrapped("Hello Left");
        ImGui::NextColumn();
        ImGui::TextWrapped("The quick brown fox jumps over the lazy dog.");
        ImGui::TextWrapped("Hello Right");
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Borders"))
    {
        // NB: Future columns API should allow automatic horizontal borders.
        static bool h_borders = true;
        static bool v_borders = true;
        ImGui::Checkbox("horizontal", &h_borders);
        ImGui::SameLine();
        ImGui::Checkbox("vertical", &v_borders);
        ImGui::Columns(4, NULL, v_borders);
        for (int i = 0; i < 4*3; i++)
        {
            if (h_borders && ImGui::GetColumnIndex() == 0)
                ImGui::Separator();
            ImGui::Text("%c%c%c", 'a'+i, 'a'+i, 'a'+i);
            ImGui::Text("Width %.2f\nOffset %.2f", ImGui::GetColumnWidth(), ImGui::GetColumnOffset());
            ImGui::NextColumn();
        }
        ImGui::Columns(1);
        if (h_borders)
            ImGui::Separator();
        ImGui::TreePop();
    }

    // Scrolling columns
    /*
    if (ImGui::TreeNode("Vertical Scrolling"))
    {
        ImGui::BeginChild("##header", ImVec2(0, ImGui::GetTextLineHeightWithSpacing()+ImGui::GetStyle().ItemSpacing.y));
        ImGui::Columns(3);
        ImGui::Text("ID"); ImGui::NextColumn();
        ImGui::Text("Name"); ImGui::NextColumn();
        ImGui::Text("Path"); ImGui::NextColumn();
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::EndChild();
        ImGui::BeginChild("##scrollingregion", ImVec2(0, 60));
        ImGui::Columns(3);
        for (int i = 0; i < 10; i++)
        {
            ImGui::Text("%04d", i); ImGui::NextColumn();
            ImGui::Text("Foobar"); ImGui::NextColumn();
            ImGui::Text("/path/foobar/%04d/", i); ImGui::NextColumn();
        }
        ImGui::Columns(1);
        ImGui::EndChild();
        ImGui::TreePop();
    }
    */

    if (ImGui::TreeNode("Horizontal Scrolling"))
    {
        ImGui::SetNextWindowContentSize(ImVec2(1500.0f, 0.0f));
        ImGui::BeginChild("##ScrollingRegion", ImVec2(0, ImGui::GetFontSize() * 20), false, ImGuiWindowFlags_HorizontalScrollbar);
        ImGui::Columns(10);
        int ITEMS_COUNT = 2000;
        ImGuiListClipper clipper(ITEMS_COUNT);  // Also demonstrate using the clipper for large list
        while (clipper.Step())
        {
            for (int i = clipper.DisplayLoopCallback; i < clipper.DisplayEnd; i++)
                for (int j = 0; j < 10; j++)
                {
                    ImGui::Text("Line %d Column %d...", i, j);
                    ImGui::NextColumn();
                }
        }
        ImGui::Columns(1);
        ImGui::EndChild();
        ImGui::TreePop();
    }

    bool node_open = ImGui::TreeNode("Tree within single cell");
    ImGui::SameLine(); ShowHelpMarker("NB: Tree node must be poped before ending the cell. There's no storage of state per-cell.");
    if (node_open)
    {
        ImGui::Columns(2, "tree items");
        ImGui::Separator();
        if (ImGui::TreeNode("Hello")) { ImGui::BulletText("Sailor"); ImGui::TreePop(); } ImGui::NextColumn();
        if (ImGui::TreeNode("Bonjour")) { ImGui::BulletText("Marin"); ImGui::TreePop(); } ImGui::NextColumn();
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::TreePop();
    }
    ImGui::PopID();
}

static void ShowDemoWindowMisc()
{
    if (ImGui::CollapsingHeader("Filtering"))
    {
        static ImGuiTextFilter filter;
        ImGui::Text("Filter usage:\n"
                    "  \"\"         display all lines\n"
                    "  \"xxx\"      display lines containing \"xxx\"\n"
                    "  \"xxx,yyy\"  display lines containing \"xxx\" or \"yyy\"\n"
                    "  \"-xxx\"     hide lines containing \"xxx\"");
        filter.Draw();
        const char* lines[] = { "aaa1.c", "bbb1.c", "ccc1.c", "aaa2.cpp", "bbb2.cpp", "ccc2.cpp", "abc.h", "hello, world" };
        for (int i = 0; i < IM_ARRAYSIZE(lines); i++)
            if (filter.PassFilter(lines[i]))
                ImGui::BulletText("%s", lines[i]);
    }

    if (ImGui::CollapsingHeader("Inputs, Navigation & Focus"))
    {
        ImGuiIO& io = ImGui::GetIO();

        ImGui::Text("WantCaptureMouse: %d", io.WantCaptureMouse);
        ImGui::Text("WantCaptureKeyboard: %d", io.WantCaptureKeyboard);
        ImGui::Text("WantTextInput: %d", io.WantTextInput);
        ImGui::Text("WantSetMousePos: %d", io.WantSetMousePos);
        ImGui::Text("NavActive: %d, NavVisible: %d", io.NavActive, io.NavVisible);

        if (ImGui::TreeNode("Keyboard, Mouse & Navigation State"))
        {
            if (ImGui::IsMousePosValid())
                ImGui::Text("Mouse pos: (%g, %g)", io.MousePos.x, io.MousePos.y);
            else
                ImGui::Text("Mouse pos: <INVALID>");
            ImGui::Text("Mouse delta: (%g, %g)", io.MouseDelta.x, io.MouseDelta.y);
            ImGui::Text("Mouse down:");     for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (io.MouseDownDuration[i] >= 0.0f)   { ImGui::SameLine(); ImGui::Text("b%d (%.02f secs)", i, io.MouseDownDuration[i]); }
            ImGui::Text("Mouse clicked:");  for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseClicked(i))          { ImGui::SameLine(); ImGui::Text("b%d", i); }
            ImGui::Text("Mouse dbl-clicked:"); for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseDoubleClicked(i)) { ImGui::SameLine(); ImGui::Text("b%d", i); }
            ImGui::Text("Mouse released:"); for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseReleased(i))         { ImGui::SameLine(); ImGui::Text("b%d", i); }
            ImGui::Text("Mouse wheel: %.1f", io.MouseWheel);

            ImGui::Text("Keys down:");      for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (io.KeysDownDuration[i] >= 0.0f)     { ImGui::SameLine(); ImGui::Text("%d (%.02f secs)", i, io.KeysDownDuration[i]); }
            ImGui::Text("Keys pressed:");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyPressed(i))             { ImGui::SameLine(); ImGui::Text("%d", i); }
            ImGui::Text("Keys release:");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyReleased(i))            { ImGui::SameLine(); ImGui::Text("%d", i); }
            ImGui::Text("Keys mods: %s%s%s%s", io.KeyCtrl ? "CTRL " : "", io.KeyShift ? "SHIFT " : "", io.KeyAlt ? "ALT " : "", io.KeySuper ? "SUPER " : "");

            ImGui::Text("NavInputs down:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputs[i] > 0.0f)                    { ImGui::SameLine(); ImGui::Text("[%d] %.2f", i, io.NavInputs[i]); }
            ImGui::Text("NavInputs pressed:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputsDownDuration[i] == 0.0f)    { ImGui::SameLine(); ImGui::Text("[%d]", i); }
            ImGui::Text("NavInputs duration:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputsDownDuration[i] >= 0.0f)   { ImGui::SameLine(); ImGui::Text("[%d] %.2f", i, io.NavInputsDownDuration[i]); }

            ImGui::Button("Hovering me sets the\nkeyboard capture flag");
            if (ImGui::IsItemHovered())
                ImGui::CaptureKeyboardFromApp(true);
            ImGui::SameLine();
            ImGui::Button("Holding me clears the\nthe keyboard capture flag");
            if (ImGui::IsItemActive())
                ImGui::CaptureKeyboardFromApp(false);

            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Tabbing"))
        {
            ImGui::Text("Use TAB/SHIFT+TAB to cycle through keyboard editable fields.");
            static char buf[32] = "dummy";
            ImGui::InputText("1", buf, IM_ARRAYSIZE(buf));
            ImGui::InputText("2", buf, IM_ARRAYSIZE(buf));
            ImGui::InputText("3", buf, IM_ARRAYSIZE(buf));
            ImGui::PushAllowKeyboardFocus(false);
            ImGui::InputText("4 (tab skip)", buf, IM_ARRAYSIZE(buf));
            //ImGui::SameLine(); ShowHelperMarker("Use ImGui::PushAllowKeyboardFocus(bool)\nto disable tabbing through certain widgets.");
            ImGui::PopAllowKeyboardFocus();
            ImGui::InputText("5", buf, IM_ARRAYSIZE(buf));
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Focus from code"))
        {
            bool focus_1 = ImGui::Button("Focus on 1"); ImGui::SameLine();
            bool focus_2 = ImGui::Button("Focus on 2"); ImGui::SameLine();
            bool focus_3 = ImGui::Button("Focus on 3");
            int has_focus = 0;
            static char buf[128] = "click on a button to set focus";

            if (focus_1) ImGui::SetKeyboardFocusHere();
            ImGui::InputText("1", buf, IM_ARRAYSIZE(buf));
            if (ImGui::IsItemActive()) has_focus = 1;

            if (focus_2) ImGui::SetKeyboardFocusHere();
            ImGui::InputText("2", buf, IM_ARRAYSIZE(buf));
            if (ImGui::IsItemActive()) has_focus = 2;

            ImGui::PushAllowKeyboardFocus(false);
            if (focus_3) ImGui::SetKeyboardFocusHere();
            ImGui::InputText("3 (tab skip)", buf, IM_ARRAYSIZE(buf));
            if (ImGui::IsItemActive()) has_focus = 3;
            ImGui::PopAllowKeyboardFocus();

            if (has_focus)
                ImGui::Text("Item with focus: %d", has_focus);
            else
                ImGui::Text("Item with focus: <none>");

            // Use >= 0 parameter to SetKeyboardFocusHere() to focus an upcoming item
            static float f3[3] = { 0.0f, 0.0f, 0.0f };
            int focus_ahead = -1;
            if (ImGui::Button("Focus on X")) focus_ahead = 0; ImGui::SameLine();
            if (ImGui::Button("Focus on Y")) focus_ahead = 1; ImGui::SameLine();
            if (ImGui::Button("Focus on Z")) focus_ahead = 2;
            if (focus_ahead != -1) ImGui::SetKeyboardFocusHere(focus_ahead);
            ImGui::SliderFloat3("Float3", &f3[0], 0.0f, 1.0f);

            ImGui::TextWrapped("NB: Cursor & selection are preserved when refocusing last used item in code.");
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Dragging"))
        {
            ImGui::TextWrapped("You can use ImGui::GetMouseDragDelta(0) to query for the dragged amount on any widget.");
            for (int button = 0; button < 3; button++)
                ImGui::Text("IsMouseDragging(%d):\n  w/ default threshold: %d,\n  w/ zero threshold: %d\n  w/ large threshold: %d",
                    button, ImGui::IsMouseDragging(button), ImGui::IsMouseDragging(button, 0.0f), ImGui::IsMouseDragging(button, 20.0f));
            ImGui::Button("Drag Me");
            if (ImGui::IsItemActive())
            {
                // Draw a line between the button and the mouse cursor
                ImDrawList* draw_list = ImGui::GetWindowDrawList();
                draw_list->PushClipRectFullScreen();
                draw_list->AddLine(io.MouseClickedPos[0], io.MousePos, ImGui::GetColorU32(ImGuiCol_Button), 4.0f);
                draw_list->PopClipRect();

                // Drag operations gets "unlocked" when the mouse has moved past a certain threshold (the default threshold is stored in io.MouseDragThreshold)
                // You can request a lower or higher threshold using the second parameter of IsMouseDragging() and GetMouseDragDelta()
                ImVec2 value_raw = ImGui::GetMouseDragDelta(0, 0.0f);
                ImVec2 value_with_lock_threshold = ImGui::GetMouseDragDelta(0);
                ImVec2 mouse_delta = io.MouseDelta;
                ImGui::SameLine(); ImGui::Text("Raw (%.1f, %.1f), WithLockThresold (%.1f, %.1f), MouseDelta (%.1f, %.1f)", value_raw.x, value_raw.y, value_with_lock_threshold.x, value_with_lock_threshold.y, mouse_delta.x, mouse_delta.y);
            }
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Mouse cursors"))
        {
            const char* mouse_cursors_names[] = { "Arrow", "TextInput", "Move", "ResizeNS", "ResizeEW", "ResizeNESW", "ResizeNWSE", "Hand" };
            IM_ASSERT(IM_ARRAYSIZE(mouse_cursors_names) == ImGuiMouseCursor_COUNT);

            ImGui::Text("Current mouse cursor = %d: %s", ImGui::GetMouseCursor(), mouse_cursors_names[ImGui::GetMouseCursor()]);
            ImGui::Text("Hover to see mouse cursors:");
            ImGui::SameLine(); ShowHelpMarker("Your application can render a different mouse cursor based on what ImGui::GetMouseCursor() returns. If software cursor rendering (io.MouseDrawCursor) is set ImGui will draw the right cursor for you, otherwise your backend needs to handle it.");
            for (int i = 0; i < ImGuiMouseCursor_COUNT; i++)
            {
                char label[32];
                sprintf(label, "Mouse cursor %d: %s", i, mouse_cursors_names[i]);
                ImGui::Bullet(); ImGui::Selectable(label, false);
                if (ImGui::IsItemHovered() || ImGui::IsItemFocused())
                    ImGui::SetMouseCursor(i);
            }
            ImGui::TreePop();
        }
    }
}

//-----------------------------------------------------------------------------
// [SECTION] About Window / ShowAboutWindow()
// Access from ImGui Demo -> Help -> About
//-----------------------------------------------------------------------------

void ImGui::ShowAboutWindow(bool* p_open)
{
    if (!ImGui::Begin("About Dear ImGui", p_open, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::End();
        return;
    }
    ImGui::Text("Dear ImGui %s", ImGui::GetVersion());
    ImGui::Separator();
    ImGui::Text("By Omar Cornut and all dear imgui contributors.");
    ImGui::Text("Dear ImGui is licensed under the MIT License, see LICENSE for more information.");

    static bool show_config_info = false;
    ImGui::Checkbox("Config/Build Information", &show_config_info);
    if (show_config_info)
    {
        ImGuiIO& io = ImGui::GetIO();
        ImGuiStyle& style = ImGui::GetStyle();

        bool copy_to_clipboard = ImGui::Button("Copy to clipboard");
        ImGui::BeginChildFrame(ImGui::GetID("cfginfos"), ImVec2(0, ImGui::GetTextLineHeightWithSpacing() * 18), ImGuiWindowFlags_NoMove);
        if (copy_to_clipboard)
            ImGui::LogToClipboard();

        ImGui::Text("Dear ImGui %s (%d)", IMGUI_VERSION, IMGUI_VERSION_NUM);
        ImGui::Separator();
        ImGui::Text("sizeof(size_t): %d, sizeof(ImDrawIdx): %d, sizeof(ImDrawVert): %d", (int)sizeof(size_t), (int)sizeof(ImDrawIdx), (int)sizeof(ImDrawVert));
        ImGui::Text("define: __cplusplus=%d", (int)__cplusplus);
#ifdef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_OBSOLETE_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_WIN32_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_WIN32_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_MATH_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_MATH_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_DEFAULT_ALLOCATORS
        ImGui::Text("define: IMGUI_DISABLE_DEFAULT_ALLOCATORS");
#endif
#ifdef IMGUI_USE_BGRA_PACKED_COLOR
        ImGui::Text("define: IMGUI_USE_BGRA_PACKED_COLOR");
#endif
#ifdef _WIN32
        ImGui::Text("define: _WIN32");
#endif
#ifdef _WIN64
        ImGui::Text("define: _WIN64");
#endif
#ifdef __linux__
        ImGui::Text("define: __linux__");
#endif
#ifdef __APPLE__
        ImGui::Text("define: __APPLE__");
#endif
#ifdef _MSC_VER
        ImGui::Text("define: _MSC_VER=%d", _MSC_VER);
#endif
#ifdef __MINGW32__
        ImGui::Text("define: __MINGW32__");
#endif
#ifdef __MINGW64__
        ImGui::Text("define: __MINGW64__");
#endif
#ifdef __GNUC__
        ImGui::Text("define: __GNUC__=%d", (int)__GNUC__);
#endif
#ifdef __clang_version__
        ImGui::Text("define: __clang_version__=%s", __clang_version__);
#endif
        ImGui::Separator();
        ImGui::Text("io.BackendPlatformName: %s", io.BackendPlatformName ? io.BackendPlatformName : "NULL");
        ImGui::Text("io.BackendRendererName: %s", io.BackendRendererName ? io.BackendRendererName : "NULL");
        ImGui::Text("io.ConfigFlags: 0x%08X", io.ConfigFlags);
        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)        ImGui::Text(" NavEnableKeyboard");
        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad)         ImGui::Text(" NavEnableGamepad");
        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos)     ImGui::Text(" NavEnableSetMousePos");
        if (io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard)     ImGui::Text(" NavNoCaptureKeyboard");
        if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)                  ImGui::Text(" NoMouse");
        if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)      ImGui::Text(" NoMouseCursorChange");
        if (io.MouseDrawCursor)                                         ImGui::Text("io.MouseDrawCursor");
        if (io.ConfigMacOSXBehaviors)                                   ImGui::Text("io.ConfigMacOSXBehaviors");
        if (io.ConfigInputTextCursorBlink)                              ImGui::Text("io.ConfigInputTextCursorBlink");
        if (io.ConfigWindowsResizeFromEdges)                            ImGui::Text("io.ConfigWindowsResizeFromEdges");
        if (io.ConfigWindowsMoveFromTitleBarOnly)                       ImGui::Text("io.ConfigWindowsMoveFromTitleBarOnly");
        ImGui::Text("io.BackendFlags: 0x%08X", io.BackendFlags);
        if (io.BackendFlags & ImGuiBackendFlags_HasGamepad)             ImGui::Text(" HasGamepad");
        if (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)        ImGui::Text(" HasMouseCursors");
        if (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos)         ImGui::Text(" HasSetMousePos");
        ImGui::Separator();
        ImGui::Text("io.Fonts: %d fonts, Flags: 0x%08X, TexSize: %d,%d", io.Fonts->Fonts.Size, io.Fonts->Flags, io.Fonts->TexWidth, io.Fonts->TexHeight);
        ImGui::Text("io.DisplaySize: %.2f,%.2f", io.DisplaySize.x, io.DisplaySize.y);
        ImGui::Separator();
        ImGui::Text("style.WindowPadding: %.2f,%.2f", style.WindowPadding.x, style.WindowPadding.y);
        ImGui::Text("style.WindowBorderSize: %.2f", style.WindowBorderSize);
        ImGui::Text("style.FramePadding: %.2f,%.2f", style.FramePadding.x, style.FramePadding.y);
        ImGui::Text("style.FrameRounding: %.2f", style.FrameRounding);
        ImGui::Text("style.FrameBorderSize: %.2f", style.FrameBorderSize);
        ImGui::Text("style.ItemSpacing: %.2f,%.2f", style.ItemSpacing.x, style.ItemSpacing.y);
        ImGui::Text("style.ItemInnerSpacing: %.2f,%.2f", style.ItemInnerSpacing.x, style.ItemInnerSpacing.y);

        if (copy_to_clipboard)
            ImGui::LogFinish();
        ImGui::EndChildFrame();
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Style Editor / ShowStyleEditor()
//-----------------------------------------------------------------------------

// Demo helper function to select among default colors. See ShowStyleEditor() for more advanced options.
// Here we use the simplified Combo() api that packs items into a single literal string. Useful for quick combo boxes where the choices are known locally.
bool ImGui::ShowStyleSelector(const char* label)
{
    static int style_idx = -1;
    if (ImGui::Combo(label, &style_idx, "Classic\0Dark\0Light\0"))
    {
        switch (style_idx)
        {
        case 0: ImGui::StyleColorsClassic(); break;
        case 1: ImGui::StyleColorsDark(); break;
        case 2: ImGui::StyleColorsLight(); break;
        }
        return true;
    }
    return false;
}

// Demo helper function to select among loaded fonts.
// Here we use the regular BeginCombo()/EndCombo() api which is more the more flexible one.
void ImGui::ShowFontSelector(const char* label)
{
    ImGuiIO& io = ImGui::GetIO();
    ImFont* font_current = ImGui::GetFont();
    if (ImGui::BeginCombo(label, font_current->GetDebugName()))
    {
        for (int n = 0; n < io.Fonts->Fonts.Size; n++)
            if (ImGui::Selectable(io.Fonts->Fonts[n]->GetDebugName(), io.Fonts->Fonts[n] == font_current))
                io.FontDefault = io.Fonts->Fonts[n];
        ImGui::EndCombo();
    }
    ImGui::SameLine();
    ShowHelpMarker(
        "- Load additional fonts with io.Fonts->AddFontFromFileTTF().\n"
        "- The font atlas is built when calling io.Fonts->GetTexDataAsXXXX() or io.Fonts->Build().\n"
        "- Read FAQ and documentation in misc/fonts/ for more details.\n"
        "- If you need to add/remove fonts at runtime (e.g. for DPI change), do it before calling NewFrame().");
}

void ImGui::ShowStyleEditor(ImGuiStyle* ref)
{
    // You can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it compares to an internally stored reference)
    ImGuiStyle& style = ImGui::GetStyle();
    static ImGuiStyle ref_saved_style;

    // Default to using internal storage as reference
    static bool init = true;
    if (init && ref == NULL)
        ref_saved_style = style;
    init = false;
    if (ref == NULL)
        ref = &ref_saved_style;

    ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.50f);

    if (ImGui::ShowStyleSelector("Colors##Selector"))
        ref_saved_style = style;
    ImGui::ShowFontSelector("Fonts##Selector");

    // Simplified Settings
    if (ImGui::SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f"))
        style.GrabRounding = style.FrameRounding; // Make GrabRounding always the same value as FrameRounding
    { bool window_border = (style.WindowBorderSize > 0.0f); if (ImGui::Checkbox("WindowBorder", &window_border)) style.WindowBorderSize = window_border ? 1.0f : 0.0f; }
    ImGui::SameLine();
    { bool frame_border = (style.FrameBorderSize > 0.0f); if (ImGui::Checkbox("FrameBorder", &frame_border)) style.FrameBorderSize = frame_border ? 1.0f : 0.0f; }
    ImGui::SameLine();
    { bool popup_border = (style.PopupBorderSize > 0.0f); if (ImGui::Checkbox("PopupBorder", &popup_border)) style.PopupBorderSize = popup_border ? 1.0f : 0.0f; }

    // Save/Revert button
    if (ImGui::Button("Save Ref"))
        *ref = ref_saved_style = style;
    ImGui::SameLine();
    if (ImGui::Button("Revert Ref"))
        style = *ref;
    ImGui::SameLine();
    ShowHelpMarker("Save/Revert in local non-persistent storage. Default Colors definition are not affected. Use \"Export Colors\" below to save them somewhere.");

    ImGui::Separator();

    if (ImGui::BeginTabBar("##tabs", ImGuiTabBarFlags_None))
    {
        if (ImGui::BeginTabItem("Sizes"))
        {
            ImGui::Text("Main");
            ImGui::SliderFloat2("WindowPadding", (float*)&style.WindowPadding, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat("PopupRounding", &style.PopupRounding, 0.0f, 16.0f, "%.0f");
            ImGui::SliderFloat2("FramePadding", (float*)&style.FramePadding, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("ItemSpacing", (float*)&style.ItemSpacing, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("ItemInnerSpacing", (float*)&style.ItemInnerSpacing, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("TouchExtraPadding", (float*)&style.TouchExtraPadding, 0.0f, 10.0f, "%.0f");
            ImGui::SliderFloat("IndentSpacing", &style.IndentSpacing, 0.0f, 30.0f, "%.0f");
            ImGui::SliderFloat("ScrollbarSize", &style.ScrollbarSize, 1.0f, 20.0f, "%.0f");
            ImGui::SliderFloat("GrabMinSize", &style.GrabMinSize, 1.0f, 20.0f, "%.0f");
            ImGui::Text("Borders");
            ImGui::SliderFloat("WindowBorderSize", &style.WindowBorderSize, 0.0f, 1.0f, "%.0f");
            ImGui::SliderFloat("ChildBorderSize", &style.ChildBorderSize, 0.0f, 1.0f, "%.0f");
            ImGui::SliderFloat("PopupBorderSize", &style.PopupBorderSize, 0.0f, 1.0f, "%.0f");
            ImGui::SliderFloat("FrameBorderSize", &style.FrameBorderSize, 0.0f, 1.0f, "%.0f");
            ImGui::SliderFloat("TabBorderSize", &style.TabBorderSize, 0.0f, 1.0f, "%.0f");
            ImGui::Text("Rounding");
            ImGui::SliderFloat("WindowRounding", &style.WindowRounding, 0.0f, 14.0f, "%.0f");
            ImGui::SliderFloat("ChildRounding", &style.ChildRounding, 0.0f, 16.0f, "%.0f");
            ImGui::SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f");
            ImGui::SliderFloat("ScrollbarRounding", &style.ScrollbarRounding, 0.0f, 12.0f, "%.0f");
            ImGui::SliderFloat("GrabRounding", &style.GrabRounding, 0.0f, 12.0f, "%.0f");
            ImGui::SliderFloat("TabRounding", &style.TabRounding, 0.0f, 12.0f, "%.0f");
            ImGui::Text("Alignment");
            ImGui::SliderFloat2("WindowTitleAlign", (float*)&style.WindowTitleAlign, 0.0f, 1.0f, "%.2f");
            ImGui::SliderFloat2("ButtonTextAlign", (float*)&style.ButtonTextAlign, 0.0f, 1.0f, "%.2f"); ImGui::SameLine(); ShowHelpMarker("Alignment applies when a button is larger than its text content.");
            ImGui::Text("Safe Area Padding"); ImGui::SameLine(); ShowHelpMarker("Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).");
            ImGui::SliderFloat2("DisplaySafeAreaPadding", (float*)&style.DisplaySafeAreaPadding, 0.0f, 30.0f, "%.0f");
            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("Colors"))
        {
            static int output_dest = 0;
            static bool output_only_modified = true;
            if (ImGui::Button("Export Unsaved"))
            {
                if (output_dest == 0)
                    ImGui::LogToClipboard();
                else
                    ImGui::LogToTTY();
                ImGui::LogText("ImVec4* colors = ImGui::GetStyle().Colors;" IM_NEWLINE);
                for (int i = 0; i < ImGuiCol_COUNT; i++)
                {
                    const ImVec4& col = style.Colors[i];
                    const char* name = ImGui::GetStyleColorName(i);
                    if (!output_only_modified || memcmp(&col, &ref->Colors[i], sizeof(ImVec4)) != 0)
                        ImGui::LogText("colors[ImGuiCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);" IM_NEWLINE, name, 23 - (int)strlen(name), "", col.x, col.y, col.z, col.w);
                }
                ImGui::LogFinish();
            }
            ImGui::SameLine(); ImGui::PushItemWidth(120); ImGui::Combo("##output_type", &output_dest, "To Clipboard\0To TTY\0"); ImGui::PopItemWidth();
            ImGui::SameLine(); ImGui::Checkbox("Only Modified Colors", &output_only_modified);

            static ImGuiTextFilter filter;
            filter.Draw("Filter colors", ImGui::GetFontSize() * 16);

            static ImGuiColorEditFlags alpha_flags = 0;
            ImGui::RadioButton("Opaque", &alpha_flags, 0); ImGui::SameLine();
            ImGui::RadioButton("Alpha", &alpha_flags, ImGuiColorEditFlags_AlphaPreview); ImGui::SameLine();
            ImGui::RadioButton("Both", &alpha_flags, ImGuiColorEditFlags_AlphaPreviewHalf); ImGui::SameLine();
            ShowHelpMarker("In the color list:\nLeft-click on colored square to open color picker,\nRight-click to open edit options menu.");

            ImGui::BeginChild("##colors", ImVec2(0, 0), true, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar | ImGuiWindowFlags_NavFlattened);
            ImGui::PushItemWidth(-160);
            for (int i = 0; i < ImGuiCol_COUNT; i++)
            {
                const char* name = ImGui::GetStyleColorName(i);
                if (!filter.PassFilter(name))
                    continue;
                ImGui::PushID(i);
                ImGui::ColorEdit4("##color", (float*)&style.Colors[i], ImGuiColorEditFlags_AlphaBar | alpha_flags);
                if (memcmp(&style.Colors[i], &ref->Colors[i], sizeof(ImVec4)) != 0)
                {
                    // Tips: in a real user application, you may want to merge and use an icon font into the main font, so instead of "Save"/"Revert" you'd use icons.
                    // Read the FAQ and misc/fonts/README.txt about using icon fonts. It's really easy and super convenient!
                    ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Save")) ref->Colors[i] = style.Colors[i];
                    ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Revert")) style.Colors[i] = ref->Colors[i];
                }
                ImGui::SameLine(0.0f, style.ItemInnerSpacing.x);
                ImGui::TextUnformatted(name);
                ImGui::PopID();
            }
            ImGui::PopItemWidth();
            ImGui::EndChild();

            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("Fonts"))
        {
            ImFontAtlas* atlas = ImGui::GetIO().Fonts;
            ShowHelpMarker("Read FAQ and misc/fonts/README.txt for details on font loading.");
            ImGui::PushItemWidth(120);
            for (int i = 0; i < atlas->Fonts.Size; i++)
            {
                ImFont* font = atlas->Fonts[i];
                ImGui::PushID(font);
                bool font_details_opened = ImGui::TreeNode(font, "Font %d: \"%s\"\n%.2f px, %d glyphs, %d file(s)", i, font->ConfigData ? font->ConfigData[0].Name : "", font->FontSize, font->Glyphs.Size, font->ConfigDataCount);
                ImGui::SameLine(); if (ImGui::SmallButton("Set as default")) ImGui::GetIO().FontDefault = font;
                if (font_details_opened)
                {
                    ImGui::PushFont(font);
                    ImGui::Text("The quick brown fox jumps over the lazy dog");
                    ImGui::PopFont();
                    ImGui::DragFloat("Font scale", &font->Scale, 0.005f, 0.3f, 2.0f, "%.1f");   // Scale only this font
                    ImGui::SameLine(); ShowHelpMarker("Note than the default embedded font is NOT meant to be scaled.\n\nFont are currently rendered into bitmaps at a given size at the time of building the atlas. You may oversample them to get some flexibility with scaling. You can also render at multiple sizes and select which one to use at runtime.\n\n(Glimmer of hope: the atlas system should hopefully be rewritten in the future to make scaling more natural and automatic.)");
                    ImGui::InputFloat("Font offset", &font->DisplayOffset.y, 1, 1, "%.0f");
                    ImGui::Text("Ascent: %f, Descent: %f, Height: %f", font->Ascent, font->Descent, font->Ascent - font->Descent);
                    ImGui::Text("Fallback character: '%c' (%d)", font->FallbackChar, font->FallbackChar);
                    ImGui::Text("Texture surface: %d pixels (approx) ~ %dx%d", font->MetricsTotalSurface, (int)sqrtf((float)font->MetricsTotalSurface), (int)sqrtf((float)font->MetricsTotalSurface));
                    for (int config_i = 0; config_i < font->ConfigDataCount; config_i++)
                        if (ImFontConfig* cfg = &font->ConfigData[config_i])
                            ImGui::BulletText("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d", config_i, cfg->Name, cfg->OversampleH, cfg->OversampleV, cfg->PixelSnapH);
                    if (ImGui::TreeNode("Glyphs", "Glyphs (%d)", font->Glyphs.Size))
                    {
                        // Display all glyphs of the fonts in separate pages of 256 characters
                        for (int base = 0; base < 0x10000; base += 256)
                        {
                            int count = 0;
                            for (int n = 0; n < 256; n++)
                                count += font->FindGlyphNoFallback((ImWchar)(base + n)) ? 1 : 0;
                            if (count > 0 && ImGui::TreeNode((void*)(intptr_t)base, "U+%04X..U+%04X (%d %s)", base, base + 255, count, count > 1 ? "glyphs" : "glyph"))
                            {
                                float cell_size = font->FontSize * 1;
                                float cell_spacing = style.ItemSpacing.y;
                                ImVec2 base_pos = ImGui::GetCursorScreenPos();
                                ImDrawList* draw_list = ImGui::GetWindowDrawList();
                                for (int n = 0; n < 256; n++)
                                {
                                    ImVec2 cell_p1(base_pos.x + (n % 16) * (cell_size + cell_spacing), base_pos.y + (n / 16) * (cell_size + cell_spacing));
                                    ImVec2 cell_p2(cell_p1.x + cell_size, cell_p1.y + cell_size);
                                    const ImFontGlyph* glyph = font->FindGlyphNoFallback((ImWchar)(base + n));
                                    draw_list->AddRect(cell_p1, cell_p2, glyph ? IM_COL32(255, 255, 255, 100) : IM_COL32(255, 255, 255, 50));
                                    if (glyph)
                                        font->RenderChar(draw_list, cell_size, cell_p1, ImGui::GetColorU32(ImGuiCol_Text), (ImWchar)(base + n)); // We use ImFont::RenderChar as a shortcut because we don't have UTF-8 conversion functions available to generate a string.
                                    if (glyph && ImGui::IsMouseHoveringRect(cell_p1, cell_p2))
                                    {
                                        ImGui::BeginTooltip();
                                        ImGui::Text("Codepoint: U+%04X", base + n);
                                        ImGui::Separator();
                                        ImGui::Text("AdvanceX: %.1f", glyph->AdvanceX);
                                        ImGui::Text("Pos: (%.2f,%.2f)->(%.2f,%.2f)", glyph->X0, glyph->Y0, glyph->X1, glyph->Y1);
                                        ImGui::Text("UV: (%.3f,%.3f)->(%.3f,%.3f)", glyph->U0, glyph->V0, glyph->U1, glyph->V1);
                                        ImGui::EndTooltip();
                                    }
                                }
                                ImGui::Dummy(ImVec2((cell_size + cell_spacing) * 16, (cell_size + cell_spacing) * 16));
                                ImGui::TreePop();
                            }
                        }
                        ImGui::TreePop();
                    }
                    ImGui::TreePop();
                }
                ImGui::PopID();
            }
            if (ImGui::TreeNode("Atlas texture", "Atlas texture (%dx%d pixels)", atlas->TexWidth, atlas->TexHeight))
            {
                ImGui::Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0, 0), ImVec2(1, 1), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 128));
                ImGui::TreePop();
            }

            static float window_scale = 1.0f;
            if (ImGui::DragFloat("this window scale", &window_scale, 0.005f, 0.3f, 2.0f, "%.1f"))           // scale only this window
                ImGui::SetWindowFontScale(window_scale);
            ImGui::DragFloat("global scale", &ImGui::GetIO().FontGlobalScale, 0.005f, 0.3f, 2.0f, "%.1f");  // scale everything
            ImGui::PopItemWidth();

            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("Rendering"))
        {
            ImGui::Checkbox("Anti-aliased lines", &style.AntiAliasedLines); ImGui::SameLine(); ShowHelpMarker("When disabling anti-aliasing lines, you'll probably want to disable borders in your style as well.");
            ImGui::Checkbox("Anti-aliased fill", &style.AntiAliasedFill);
            ImGui::PushItemWidth(100);
            ImGui::DragFloat("Curve Tessellation Tolerance", &style.CurveTessellationTol, 0.02f, 0.10f, FLT_MAX, "%.2f", 2.0f);
            if (style.CurveTessellationTol < 0.10f) style.CurveTessellationTol = 0.10f;
            ImGui::DragFloat("Global Alpha", &style.Alpha, 0.005f, 0.20f, 1.0f, "%.2f"); // Not exposing zero here so user doesn't "lose" the UI (zero alpha clips all widgets). But application code could have a toggle to switch between zero and non-zero.
            ImGui::PopItemWidth();

            ImGui::EndTabItem();
        }

        ImGui::EndTabBar();
    }

    ImGui::PopItemWidth();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()
//-----------------------------------------------------------------------------

// Demonstrate creating a fullscreen menu bar and populating it.
static void ShowExampleAppMainMenuBar()
{
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            ShowExampleMenuFile();
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Edit"))
        {
            if (ImGui::MenuItem("Undo", "CTRL+Z")) {}
            if (ImGui::MenuItem("Redo", "CTRL+Y", false, false)) {}  // Disabled item
            ImGui::Separator();
            if (ImGui::MenuItem("Cut", "CTRL+X")) {}
            if (ImGui::MenuItem("Copy", "CTRL+C")) {}
            if (ImGui::MenuItem("Paste", "CTRL+V")) {}
            ImGui::EndMenu();
        }
        ImGui::EndMainMenuBar();
    }
}

static void ShowExampleMenuFile()
{
    ImGui::MenuItem("(dummy menu)", NULL, false, false);
    if (ImGui::MenuItem("New")) {}
    if (ImGui::MenuItem("Open", "Ctrl+O")) {}
    if (ImGui::BeginMenu("Open Recent"))
    {
        ImGui::MenuItem("fish_hat.c");
        ImGui::MenuItem("fish_hat.inl");
        ImGui::MenuItem("fish_hat.h");
        if (ImGui::BeginMenu("More.."))
        {
            ImGui::MenuItem("Hello");
            ImGui::MenuItem("Sailor");
            if (ImGui::BeginMenu("Recurse.."))
            {
                ShowExampleMenuFile();
                ImGui::EndMenu();
            }
            ImGui::EndMenu();
        }
        ImGui::EndMenu();
    }
    if (ImGui::MenuItem("Save", "Ctrl+S")) {}
    if (ImGui::MenuItem("Save As..")) {}
    ImGui::Separator();
    if (ImGui::BeginMenu("Options"))
    {
        static bool enabled = true;
        ImGui::MenuItem("Enabled", "", &enabled);
        ImGui::BeginChild("child", ImVec2(0, 60), true);
        for (int i = 0; i < 10; i++)
            ImGui::Text("Scrolling Text %d", i);
        ImGui::EndChild();
        static float f = 0.5f;
        static int n = 0;
        static bool b = true;
        ImGui::SliderFloat("Value", &f, 0.0f, 1.0f);
        ImGui::InputFloat("Input", &f, 0.1f);
        ImGui::Combo("Combo", &n, "Yes\0No\0Maybe\0\0");
        ImGui::Checkbox("Check", &b);
        ImGui::EndMenu();
    }
    if (ImGui::BeginMenu("Colors"))
    {
        float sz = ImGui::GetTextLineHeight();
        for (int i = 0; i < ImGuiCol_COUNT; i++)
        {
            const char* name = ImGui::GetStyleColorName((ImGuiCol)i);
            ImVec2 p = ImGui::GetCursorScreenPos();
            ImGui::GetWindowDrawList()->AddRectFilled(p, ImVec2(p.x+sz, p.y+sz), ImGui::GetColorU32((ImGuiCol)i));
            ImGui::Dummy(ImVec2(sz, sz));
            ImGui::SameLine();
            ImGui::MenuItem(name);
        }
        ImGui::EndMenu();
    }
    if (ImGui::BeginMenu("Disabled", false)) // Disabled
    {
        IM_ASSERT(0);
    }
    if (ImGui::MenuItem("Checked", NULL, true)) {}
    if (ImGui::MenuItem("Quit", "Alt+F4")) {}
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Debug Console / ShowExampleAppConsole()
//-----------------------------------------------------------------------------

// Demonstrate creating a simple console window, with scrolling, filtering, completion and history.
// For the console example, here we are using a more C++ like approach of declaring a class to hold the data and the functions.
struct ExampleAppConsole
{
    char                  InputBuf[256];
    ImVector<char*>       Items;
    bool                  ScrollToBottom;
    ImVector<char*>       History;
    int                   HistoryPos;    // -1: new line, 0..History.Size-1 browsing history.
    ImVector<const char*> Commands;

    ExampleAppConsole()
    {
        ClearLog();
        memset(InputBuf, 0, sizeof(InputBuf));
        HistoryPos = -1;
        Commands.push_back("HELP");
        Commands.push_back("HISTORY");
        Commands.push_back("CLEAR");
        Commands.push_back("CLASSIFY");  // "classify" is only here to provide an example of "C"+[tab] completing to "CL" and displaying matches.
        AddLog("Welcome to Dear ImGui!");
    }
    ~ExampleAppConsole()
    {
        ClearLog();
        for (int i = 0; i < History.Size; i++)
            free(History[i]);
    }

    // Portable helpers
    static int   Stricmp(const char* str1, const char* str2)         { int d; while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; } return d; }
    static int   Strnicmp(const char* str1, const char* str2, int n) { int d = 0; while (n > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; n--; } return d; }
    static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buff = malloc(len); return (char*)memcpy(buff, (const void*)str, len); }
    static void  Strtrim(char* str)                                  { char* str_end = str + strlen(str); while (str_end > str && str_end[-1] == ' ') str_end--; *str_end = 0; }

    void    ClearLog()
    {
        for (int i = 0; i < Items.Size; i++)
            free(Items[i]);
        Items.clear();
        ScrollToBottom = true;
    }

    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)
    {
        // FIXME-OPT
        char buf[1024];
        va_list args;
        va_start(args, fmt);
        vsnprintf(buf, IM_ARRAYSIZE(buf), fmt, args);
        buf[IM_ARRAYSIZE(buf)-1] = 0;
        va_end(args);
        Items.push_back(Strdup(buf));
        ScrollToBottom = true;
    }

    void    Draw(const char* title, bool* p_open)
    {
        ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiCond_FirstUseEver);
        if (!ImGui::Begin(title, p_open))
        {
            ImGui::End();
            return;
        }

        // As a specific feature guaranteed by the library, after calling Begin() the last Item represent the title bar. So e.g. IsItemHovered() will return true when hovering the title bar.
        // Here we create a context menu only available from the title bar.
        if (ImGui::BeginPopupContextItem())
        {
            if (ImGui::MenuItem("Close Console"))
                *p_open = false;
            ImGui::EndPopup();
        }

        ImGui::TextWrapped("This example implements a console with basic coloring, completion and history. A more elaborate implementation may want to store entries along with extra data such as timestamp, emitter, etc.");
        ImGui::TextWrapped("Enter 'HELP' for help, press TAB to use text completion.");

        // TODO: display items starting from the bottom

        if (ImGui::SmallButton("Add Dummy Text")) { AddLog("%d some text", Items.Size); AddLog("some more text"); AddLog("display very important message here!"); } ImGui::SameLine();
        if (ImGui::SmallButton("Add Dummy Error")) { AddLog("[error] something went wrong"); } ImGui::SameLine();
        if (ImGui::SmallButton("Clear")) { ClearLog(); } ImGui::SameLine();
        bool copy_to_clipboard = ImGui::SmallButton("Copy"); ImGui::SameLine();
        if (ImGui::SmallButton("Scroll to bottom")) ScrollToBottom = true;
        //static float t = 0.0f; if (ImGui::GetTime() - t > 0.02f) { t = ImGui::GetTime(); AddLog("Spam %f", t); }

        ImGui::Separator();

        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0,0));
        static ImGuiTextFilter filter;
        filter.Draw("Filter (\"incl,-excl\") (\"error\")", 180);
        ImGui::PopStyleVar();
        ImGui::Separator();

        const float footer_height_to_reserve = ImGui::GetStyle().ItemSpacing.y + ImGui::GetFrameHeightWithSpacing(); // 1 separator, 1 input text
        ImGui::BeginChild("ScrollingRegion", ImVec2(0, -footer_height_to_reserve), false, ImGuiWindowFlags_HorizontalScrollbar); // Leave room for 1 separator + 1 InputText
        if (ImGui::BeginPopupContextWindow())
        {
            if (ImGui::Selectable("Clear")) ClearLog();
            ImGui::EndPopup();
        }

        // Display every line as a separate entry so we can change their color or add custom widgets. If you only want raw text you can use ImGui::TextUnformatted(log.begin(), log.end());
        // NB- if you have thousands of entries this approach may be too inefficient and may require user-side clipping to only process visible items.
        // You can seek and display only the lines that are visible using the ImGuiListClipper helper, if your elements are evenly spaced and you have cheap random access to the elements.
        // To use the clipper we could replace the 'for (int i = 0; i < Items.Size; i++)' loop with:
        //     ImGuiListClipper clipper(Items.Size);
        //     while (clipper.Step())
        //         for (int i = clipper.DisplayLoopCallback; i < clipper.DisplayEnd; i++)
        // However, note that you can not use this code as is if a filter is active because it breaks the 'cheap random-access' property. We would need random-access on the post-filtered list.
        // A typical application wanting coarse clipping and filtering may want to pre-compute an array of indices that passed the filtering test, recomputing this array when user changes the filter,
        // and appending newly elements as they are inserted. This is left as a task to the user until we can manage to improve this example code!
        // If your items are of variable size you may want to implement code similar to what ImGuiListClipper does. Or split your data into fixed height items to allow random-seeking into your list.
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4,1)); // Tighten spacing
        if (copy_to_clipboard)
            ImGui::LogToClipboard();
        ImVec4 col_default_text = ImGui::GetStyleColorVec4(ImGuiCol_Text);
        for (int i = 0; i < Items.Size; i++)
        {
            const char* item = Items[i];
            if (!filter.PassFilter(item))
                continue;
            ImVec4 col = col_default_text;
            if (strstr(item, "[error]")) col = ImColor(1.0f,0.4f,0.4f,1.0f);
            else if (strncmp(item, "# ", 2) == 0) col = ImColor(1.0f,0.78f,0.58f,1.0f);
            ImGui::PushStyleColor(ImGuiCol_Text, col);
            ImGui::TextUnformatted(item);
            ImGui::PopStyleColor();
        }
        if (copy_to_clipboard)
            ImGui::LogFinish();
        if (ScrollToBottom)
            ImGui::SetScrollHereY(1.0f);
        ScrollToBottom = false;
        ImGui::PopStyleVar();
        ImGui::EndChild();
        ImGui::Separator();

        // Command-line
        bool reclaim_focus = false;
        if (ImGui::InputText("Input", InputBuf, IM_ARRAYSIZE(InputBuf), ImGuiInputTextFlags_EnterReturnsTrue|ImGuiInputTextFlags_CallbackCompletion|ImGuiInputTextFlags_CallbackHistory, &TextEditCallbackStub, (void*)this))
        {
            char* s = InputBuf;
            Strtrim(s);
            if (s[0])
                ExecCommand(s);
            strcpy(s, "");
            reclaim_focus = true;
        }

        // Auto-focus on window apparition
        ImGui::SetItemDefaultFocus();
        if (reclaim_focus)
            ImGui::SetKeyboardFocusHere(-1); // Auto focus previous widget

        ImGui::End();
    }

    void    ExecCommand(const char* command_line)
    {
        AddLog("# %s\n", command_line);

        // Insert into history. First find match and delete it so it can be pushed to the back. This isn't trying to be smart or optimal.
        HistoryPos = -1;
        for (int i = History.Size-1; i >= 0; i--)
            if (Stricmp(History[i], command_line) == 0)
            {
                free(History[i]);
                History.erase(History.begin() + i);
                break;
            }
        History.push_back(Strdup(command_line));

        // Process command
        if (Stricmp(command_line, "CLEAR") == 0)
        {
            ClearLog();
        }
        else if (Stricmp(command_line, "HELP") == 0)
        {
            AddLog("Commands:");
            for (int i = 0; i < Commands.Size; i++)
                AddLog("- %s", Commands[i]);
        }
        else if (Stricmp(command_line, "HISTORY") == 0)
        {
            int first = History.Size - 10;
            for (int i = first > 0 ? first : 0; i < History.Size; i++)
                AddLog("%3d: %s\n", i, History[i]);
        }
        else
        {
            AddLog("Unknown command: '%s'\n", command_line);
        }
    }

    static int TextEditCallbackStub(ImGuiInputTextCallbackData* data) // In C++11 you are better off using lambdas for this sort of forwarding callbacks
    {
        ExampleAppConsole* console = (ExampleAppConsole*)data->UserData;
        return console->TextEditCallback(data);
    }

    int     TextEditCallback(ImGuiInputTextCallbackData* data)
    {
        //AddLog("cursor: %d, selection: %d-%d", data->CursorPos, data->SelectionLoopCallback, data->SelectionEnd);
        switch (data->EventFlag)
        {
        case ImGuiInputTextFlags_CallbackCompletion:
            {
                // Example of TEXT COMPLETION

                // Locate beginning of current word
                const char* word_end = data->Buf + data->CursorPos;
                const char* word_start = word_end;
                while (word_start > data->Buf)
                {
                    const char c = word_start[-1];
                    if (c == ' ' || c == '\t' || c == ',' || c == ';')
                        break;
                    word_start--;
                }

                // Build a list of candidates
                ImVector<const char*> candidates;
                for (int i = 0; i < Commands.Size; i++)
                    if (Strnicmp(Commands[i], word_start, (int)(word_end-word_start)) == 0)
                        candidates.push_back(Commands[i]);

                if (candidates.Size == 0)
                {
                    // No match
                    AddLog("No match for \"%.*s\"!\n", (int)(word_end-word_start), word_start);
                }
                else if (candidates.Size == 1)
                {
                    // Single match. Delete the beginning of the word and replace it entirely so we've got nice casing
                    data->DeleteChars((int)(word_start-data->Buf), (int)(word_end-word_start));
                    data->InsertChars(data->CursorPos, candidates[0]);
                    data->InsertChars(data->CursorPos, " ");
                }
                else
                {
                    // Multiple matches. Complete as much as we can, so inputing "C" will complete to "CL" and display "CLEAR" and "CLASSIFY"
                    int match_len = (int)(word_end - word_start);
                    for (;;)
                    {
                        int c = 0;
                        bool all_candidates_matches = true;
                        for (int i = 0; i < candidates.Size && all_candidates_matches; i++)
                            if (i == 0)
                                c = toupper(candidates[i][match_len]);
                            else if (c == 0 || c != toupper(candidates[i][match_len]))
                                all_candidates_matches = false;
                        if (!all_candidates_matches)
                            break;
                        match_len++;
                    }

                    if (match_len > 0)
                    {
                        data->DeleteChars((int)(word_start - data->Buf), (int)(word_end-word_start));
                        data->InsertChars(data->CursorPos, candidates[0], candidates[0] + match_len);
                    }

                    // List matches
                    AddLog("Possible matches:\n");
                    for (int i = 0; i < candidates.Size; i++)
                        AddLog("- %s\n", candidates[i]);
                }

                break;
            }
        case ImGuiInputTextFlags_CallbackHistory:
            {
                // Example of HISTORY
                const int prev_history_pos = HistoryPos;
                if (data->EventKey == ImGuiKey_UpArrow)
                {
                    if (HistoryPos == -1)
                        HistoryPos = History.Size - 1;
                    else if (HistoryPos > 0)
                        HistoryPos--;
                }
                else if (data->EventKey == ImGuiKey_DownArrow)
                {
                    if (HistoryPos != -1)
                        if (++HistoryPos >= History.Size)
                            HistoryPos = -1;
                }

                // A better implementation would preserve the data on the current input line along with cursor position.
                if (prev_history_pos != HistoryPos)
                {
                    const char* history_str = (HistoryPos >= 0) ? History[HistoryPos] : "";
                    data->DeleteChars(0, data->BufTextLen);
                    data->InsertChars(0, history_str);
                }
            }
        }
        return 0;
    }
};

static void ShowExampleAppConsole(bool* p_open)
{
    static ExampleAppConsole console;
    console.Draw("Example: Console", p_open);
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Debug Log / ShowExampleAppLog()
//-----------------------------------------------------------------------------

// Usage:
//  static ExampleAppLog my_log;
//  my_log.AddLog("Hello %d world\n", 123);
//  my_log.Draw("title");
struct ExampleAppLog
{
    ImGuiTextBuffer     Buf;
    ImGuiTextFilter     Filter;
    ImVector<int>       LineOffsets;        // Index to lines offset
    bool                ScrollToBottom;

    void    Clear()     { Buf.clear(); LineOffsets.clear(); }

    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)
    {
        int old_size = Buf.size();
        va_list args;
        va_start(args, fmt);
        Buf.appendfv(fmt, args);
        va_end(args);
        for (int new_size = Buf.size(); old_size < new_size; old_size++)
            if (Buf[old_size] == '\n')
                LineOffsets.push_back(old_size);
        ScrollToBottom = true;
    }

    void    Draw(const char* title, bool* p_open = NULL)
    {
        ImGui::SetNextWindowSize(ImVec2(500,400), ImGuiCond_FirstUseEver);
        if (!ImGui::Begin(title, p_open))
        {
            ImGui::End();
            return;
        }
        if (ImGui::Button("Clear")) Clear();
        ImGui::SameLine();
        bool copy = ImGui::Button("Copy");
        ImGui::SameLine();
        Filter.Draw("Filter", -100.0f);
        ImGui::Separator();
        ImGui::BeginChild("scrolling", ImVec2(0,0), false, ImGuiWindowFlags_HorizontalScrollbar);
        if (copy) ImGui::LogToClipboard();

        if (Filter.IsActive())
        {
            const char* buf_begin = Buf.begin();
            const char* line = buf_begin;
            for (int line_no = 0; line != NULL; line_no++)
            {
                const char* line_end = (line_no < LineOffsets.Size) ? buf_begin + LineOffsets[line_no] : NULL;
                if (Filter.PassFilter(line, line_end))
                    ImGui::TextUnformatted(line, line_end);
                line = line_end && line_end[1] ? line_end + 1 : NULL;
            }
        }
        else
        {
            ImGui::TextUnformatted(Buf.begin());
        }

        if (ScrollToBottom)
            ImGui::SetScrollHereY(1.0f);
        ScrollToBottom = false;
        ImGui::EndChild();
        ImGui::End();
    }
};

// Demonstrate creating a simple log window with basic filtering.
static void ShowExampleAppLog(bool* p_open)
{
    static ExampleAppLog log;

    // Demo: add random items (unless Ctrl is held)
    static double last_time = -1.0;
    double time = ImGui::GetTime();
    if (time - last_time >= 0.20f && !ImGui::GetIO().KeyCtrl)
    {
        const char* random_words[] = { "system", "info", "warning", "error", "fatal", "notice", "log" };
        log.AddLog("[%s] Hello, time is %.1f, frame count is %d\n", random_words[rand() % IM_ARRAYSIZE(random_words)], time, ImGui::GetFrameCount());
        last_time = time;
    }

    log.Draw("Example: Log", p_open);
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()
//-----------------------------------------------------------------------------

// Demonstrate create a window with multiple child windows.
static void ShowExampleAppLayout(bool* p_open)
{
    ImGui::SetNextWindowSize(ImVec2(500, 440), ImGuiCond_FirstUseEver);
    if (ImGui::Begin("Example: Simple layout", p_open, ImGuiWindowFlags_MenuBar))
    {
        if (ImGui::BeginMenuBar())
        {
            if (ImGui::BeginMenu("File"))
            {
                if (ImGui::MenuItem("Close")) *p_open = false;
                ImGui::EndMenu();
            }
            ImGui::EndMenuBar();
        }

        // left
        static int selected = 0;
        ImGui::BeginChild("left pane", ImVec2(150, 0), true);
        for (int i = 0; i < 100; i++)
        {
            char label[128];
            sprintf(label, "MyObject %d", i);
            if (ImGui::Selectable(label, selected == i))
                selected = i;
        }
        ImGui::EndChild();
        ImGui::SameLine();

        // right
        ImGui::BeginGroup();
            ImGui::BeginChild("item view", ImVec2(0, -ImGui::GetFrameHeightWithSpacing())); // Leave room for 1 line below us
                ImGui::Text("MyObject: %d", selected);
                ImGui::Separator();
                if (ImGui::BeginTabBar("##Tabs", ImGuiTabBarFlags_None))
                {
                    if (ImGui::BeginTabItem("Description"))
                    {
                        ImGui::TextWrapped("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ");
                        ImGui::EndTabItem();
                    }
                    if (ImGui::BeginTabItem("Details"))
                    {
                        ImGui::Text("ID: 0123456789");
                        ImGui::EndTabItem();
                    }
                    ImGui::EndTabBar();
                }
            ImGui::EndChild();
            if (ImGui::Button("Revert")) {}
            ImGui::SameLine();
            if (ImGui::Button("Save")) {}
        ImGui::EndGroup();
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()
//-----------------------------------------------------------------------------

// Demonstrate create a simple property editor.
static void ShowExampleAppPropertyEditor(bool* p_open)
{
    ImGui::SetNextWindowSize(ImVec2(430,450), ImGuiCond_FirstUseEver);
    if (!ImGui::Begin("Example: Property editor", p_open))
    {
        ImGui::End();
        return;
    }

    ShowHelpMarker("This example shows how you may implement a property editor using two columns.\nAll objects/fields data are dummies here.\nRemember that in many simple cases, you can use ImGui::SameLine(xxx) to position\nyour cursor horizontally instead of using the Columns() API.");

    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2,2));
    ImGui::Columns(2);
    ImGui::Separator();

    struct funcs
    {
        static void ShowDummyObject(const char* prefix, int uid)
        {
            ImGui::PushID(uid);                      // Use object uid as identifier. Most commonly you could also use the object pointer as a base ID.
            ImGui::AlignTextToFramePadding();  // Text and Tree nodes are less high than regular widgets, here we add vertical spacing to make the tree lines equal high.
            bool node_open = ImGui::TreeNode("Object", "%s_%u", prefix, uid);
            ImGui::NextColumn();
            ImGui::AlignTextToFramePadding();
            ImGui::Text("my sailor is rich");
            ImGui::NextColumn();
            if (node_open)
            {
                static float dummy_members[8] = { 0.0f,0.0f,1.0f,3.1416f,100.0f,999.0f };
                for (int i = 0; i < 8; i++)
                {
                    ImGui::PushID(i); // Use field index as identifier.
                    if (i < 2)
                    {
                        ShowDummyObject("Child", 424242);
                    }
                    else
                    {
                        // Here we use a TreeNode to highlight on hover (we could use e.g. Selectable as well)
                        ImGui::AlignTextToFramePadding();
                        ImGui::TreeNodeEx("Field", ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_Bullet, "Field_%d", i);
                        ImGui::NextColumn();
                        ImGui::PushItemWidth(-1);
                        if (i >= 5)
                            ImGui::InputFloat("##value", &dummy_members[i], 1.0f);
                        else
                            ImGui::DragFloat("##value", &dummy_members[i], 0.01f);
                        ImGui::PopItemWidth();
                        ImGui::NextColumn();
                    }
                    ImGui::PopID();
                }
                ImGui::TreePop();
            }
            ImGui::PopID();
        }
    };

    // Iterate dummy objects with dummy members (all the same data)
    for (int obj_i = 0; obj_i < 3; obj_i++)
        funcs::ShowDummyObject("Object", obj_i);

    ImGui::Columns(1);
    ImGui::Separator();
    ImGui::PopStyleVar();
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Long Text / ShowExampleAppLongText()
//-----------------------------------------------------------------------------

// Demonstrate/test rendering huge amount of text, and the incidence of clipping.
static void ShowExampleAppLongText(bool* p_open)
{
    ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiCond_FirstUseEver);
    if (!ImGui::Begin("Example: Long text display", p_open))
    {
        ImGui::End();
        return;
    }

    static int test_type = 0;
    static ImGuiTextBuffer log;
    static int lines = 0;
    ImGui::Text("Printing unusually long amount of text.");
    ImGui::Combo("Test type", &test_type, "Single call to TextUnformatted()\0Multiple calls to Text(), clipped manually\0Multiple calls to Text(), not clipped (slow)\0");
    ImGui::Text("Buffer contents: %d lines, %d bytes", lines, log.size());
    if (ImGui::Button("Clear")) { log.clear(); lines = 0; }
    ImGui::SameLine();
    if (ImGui::Button("Add 1000 lines"))
    {
        for (int i = 0; i < 1000; i++)
            log.appendf("%i The quick brown fox jumps over the lazy dog\n", lines+i);
        lines += 1000;
    }
    ImGui::BeginChild("Log");
    switch (test_type)
    {
    case 0:
        // Single call to TextUnformatted() with a big buffer
        ImGui::TextUnformatted(log.begin(), log.end());
        break;
    case 1:
        {
            // Multiple calls to Text(), manually coarsely clipped - demonstrate how to use the ImGuiListClipper helper.
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));
            ImGuiListClipper clipper(lines);
            while (clipper.Step())
                for (int i = clipper.DisplayLoopCallback; i < clipper.DisplayEnd; i++)
                    ImGui::Text("%i The quick brown fox jumps over the lazy dog", i);
            ImGui::PopStyleVar();
            break;
        }
    case 2:
        // Multiple calls to Text(), not clipped (slow)
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));
        for (int i = 0; i < lines; i++)
            ImGui::Text("%i The quick brown fox jumps over the lazy dog", i);
        ImGui::PopStyleVar();
        break;
    }
    ImGui::EndChild();
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()
//-----------------------------------------------------------------------------

// Demonstrate creating a window which gets auto-resized according to its content.
static void ShowExampleAppAutoResize(bool* p_open)
{
    if (!ImGui::Begin("Example: Auto-resizing window", p_open, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::End();
        return;
    }

    static int lines = 10;
    ImGui::Text("Window will resize every-frame to the size of its content.\nNote that you probably don't want to query the window size to\noutput your content because that would create a feedback loop.");
    ImGui::SliderInt("Number of lines", &lines, 1, 20);
    for (int i = 0; i < lines; i++)
        ImGui::Text("%*sThis is line %d", i * 4, "", i); // Pad with space to extend size horizontally
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()
//-----------------------------------------------------------------------------

// Demonstrate creating a window with custom resize constraints.
static void ShowExampleAppConstrainedResize(bool* p_open)
{
    struct CustomConstraints // Helper functions to demonstrate programmatic constraints
    {
        static void Square(ImGuiSizeCallbackData* data) { data->DesiredSize = ImVec2(IM_MAX(data->DesiredSize.x, data->DesiredSize.y), IM_MAX(data->DesiredSize.x, data->DesiredSize.y)); }
        static void Step(ImGuiSizeCallbackData* data)   { float step = (float)(int)(intptr_t)data->UserData; data->DesiredSize = ImVec2((int)(data->DesiredSize.x / step + 0.5f) * step, (int)(data->DesiredSize.y / step + 0.5f) * step); }
    };

    static bool auto_resize = false;
    static int type = 0;
    static int display_lines = 10;
    if (type == 0) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 0),    ImVec2(-1, FLT_MAX));      // Vertical only
    if (type == 1) ImGui::SetNextWindowSizeConstraints(ImVec2(0, -1),    ImVec2(FLT_MAX, -1));      // Horizontal only
    if (type == 2) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(FLT_MAX, FLT_MAX)); // Width > 100, Height > 100
    if (type == 3) ImGui::SetNextWindowSizeConstraints(ImVec2(400, -1),  ImVec2(500, -1));          // Width 400-500
    if (type == 4) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 400),  ImVec2(-1, 500));          // Height 400-500
    if (type == 5) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Square);          // Always Square
    if (type == 6) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Step, (void*)100);// Fixed Step

    ImGuiWindowFlags flags = auto_resize ? ImGuiWindowFlags_AlwaysAutoResize : 0;
    if (ImGui::Begin("Example: Constrained Resize", p_open, flags))
    {
        const char* desc[] =
        {
            "Resize vertical only",
            "Resize horizontal only",
            "Width > 100, Height > 100",
            "Width 400-500",
            "Height 400-500",
            "Custom: Always Square",
            "Custom: Fixed Steps (100)",
        };
        if (ImGui::Button("200x200")) { ImGui::SetWindowSize(ImVec2(200, 200)); } ImGui::SameLine();
        if (ImGui::Button("500x500")) { ImGui::SetWindowSize(ImVec2(500, 500)); } ImGui::SameLine();
        if (ImGui::Button("800x200")) { ImGui::SetWindowSize(ImVec2(800, 200)); }
        ImGui::PushItemWidth(200);
        ImGui::Combo("Constraint", &type, desc, IM_ARRAYSIZE(desc));
        ImGui::DragInt("Lines", &display_lines, 0.2f, 1, 100);
        ImGui::PopItemWidth();
        ImGui::Checkbox("Auto-resize", &auto_resize);
        for (int i = 0; i < display_lines; i++)
            ImGui::Text("%*sHello, sailor! Making this line long enough for the example.", i * 4, "");
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Simple Overlay / ShowExampleAppSimpleOverlay()
//-----------------------------------------------------------------------------

// Demonstrate creating a simple static window with no decoration + a context-menu to choose which corner of the screen to use.
static void ShowExampleAppSimpleOverlay(bool* p_open)
{
    const float DISTANCE = 10.0f;
    static int corner = 0;
    ImVec2 window_pos = ImVec2((corner & 1) ? ImGui::GetIO().DisplaySize.x - DISTANCE : DISTANCE, (corner & 2) ? ImGui::GetIO().DisplaySize.y - DISTANCE : DISTANCE);
    ImVec2 window_pos_pivot = ImVec2((corner & 1) ? 1.0f : 0.0f, (corner & 2) ? 1.0f : 0.0f);
    if (corner != -1)
        ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);
    ImGui::SetNextWindowBgAlpha(0.3f); // Transparent background
    if (ImGui::Begin("Example: Simple overlay", p_open, (corner != -1 ? ImGuiWindowFlags_NoMove : 0) | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav))
    {
        ImGui::Text("Simple overlay\n" "in the corner of the screen.\n" "(right-click to change position)");
        ImGui::Separator();
        if (ImGui::IsMousePosValid())
            ImGui::Text("Mouse Position: (%.1f,%.1f)", ImGui::GetIO().MousePos.x, ImGui::GetIO().MousePos.y);
        else
            ImGui::Text("Mouse Position: <invalid>");
        if (ImGui::BeginPopupContextWindow())
        {
            if (ImGui::MenuItem("Custom",       NULL, corner == -1)) corner = -1;
            if (ImGui::MenuItem("Top-left",     NULL, corner == 0)) corner = 0;
            if (ImGui::MenuItem("Top-right",    NULL, corner == 1)) corner = 1;
            if (ImGui::MenuItem("Bottom-left",  NULL, corner == 2)) corner = 2;
            if (ImGui::MenuItem("Bottom-right", NULL, corner == 3)) corner = 3;
            if (p_open && ImGui::MenuItem("Close")) *p_open = false;
            ImGui::EndPopup();
        }
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()
//-----------------------------------------------------------------------------

// Demonstrate using "##" and "###" in identifiers to manipulate ID generation.
// This apply to all regular items as well. Read FAQ section "How can I have multiple widgets with the same label? Can I have widget without a label? (Yes). A primer on the purpose of labels/IDs." for details.
static void ShowExampleAppWindowTitles(bool*)
{
    // By default, Windows are uniquely identified by their title.
    // You can use the "##" and "###" markers to manipulate the display/ID.

    // Using "##" to display same title but have unique identifier.
    ImGui::SetNextWindowPos(ImVec2(100, 100), ImGuiCond_FirstUseEver);
    ImGui::Begin("Same title as another window##1");
    ImGui::Text("This is window 1.\nMy title is the same as window 2, but my identifier is unique.");
    ImGui::End();

    ImGui::SetNextWindowPos(ImVec2(100, 200), ImGuiCond_FirstUseEver);
    ImGui::Begin("Same title as another window##2");
    ImGui::Text("This is window 2.\nMy title is the same as window 1, but my identifier is unique.");
    ImGui::End();

    // Using "###" to display a changing title but keep a static identifier "AnimatedTitle"
    char buf[128];
    sprintf(buf, "Animated title %c %d###AnimatedTitle", "|/-\\"[(int)(ImGui::GetTime() / 0.25f) & 3], ImGui::GetFrameCount());
    ImGui::SetNextWindowPos(ImVec2(100, 300), ImGuiCond_FirstUseEver);
    ImGui::Begin(buf);
    ImGui::Text("This window has a changing title.");
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()
//-----------------------------------------------------------------------------

// Demonstrate using the low-level ImDrawList to draw custom shapes.
static void ShowExampleAppCustomRendering(bool* p_open)
{
    ImGui::SetNextWindowSize(ImVec2(350, 560), ImGuiCond_FirstUseEver);
    if (!ImGui::Begin("Example: Custom rendering", p_open))
    {
        ImGui::End();
        return;
    }

    // Tip: If you do a lot of custom rendering, you probably want to use your own geometrical types and benefit of overloaded operators, etc.
    // Define IM_VEC2_CLASS_EXTRA in imconfig.h to create implicit conversions between your types and ImVec2/ImVec4.
    // ImGui defines overloaded operators but they are internal to imgui.cpp and not exposed outside (to avoid messing with your types)
    // In this example we are not using the maths operators!
    ImDrawList* draw_list = ImGui::GetWindowDrawList();

    // Primitives
    ImGui::Text("Primitives");
    static float sz = 36.0f;
    static float thickness = 4.0f;
    static ImVec4 col = ImVec4(1.0f, 1.0f, 0.4f, 1.0f);
    ImGui::DragFloat("Size", &sz, 0.2f, 2.0f, 72.0f, "%.0f");
    ImGui::DragFloat("Thickness", &thickness, 0.05f, 1.0f, 8.0f, "%.02f");
    ImGui::ColorEdit3("Color", &col.x);
    {
        const ImVec2 p = ImGui::GetCursorScreenPos();
        const ImU32 col32 = ImColor(col);
        float x = p.x + 4.0f, y = p.y + 4.0f, spacing = 8.0f;
        for (int n = 0; n < 2; n++)
        {
            float curr_thickness = (n == 0) ? 1.0f : thickness;
            draw_list->AddCircle(ImVec2(x+sz*0.5f, y+sz*0.5f), sz*0.5f, col32, 20, curr_thickness); x += sz+spacing;
            draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 0.0f, ImDrawCornerFlags_All, curr_thickness); x += sz+spacing;
            draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f, ImDrawCornerFlags_All, curr_thickness); x += sz+spacing;
            draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotRight, curr_thickness); x += sz+spacing;
            draw_list->AddTriangle(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32, curr_thickness); x += sz+spacing;
            draw_list->AddLine(ImVec2(x, y), ImVec2(x+sz, y   ), col32, curr_thickness); x += sz+spacing;   // Horizontal line (note: drawing a filled rectangle will be faster!)
            draw_list->AddLine(ImVec2(x, y), ImVec2(x,    y+sz), col32, curr_thickness); x += spacing;      // Vertical line (note: drawing a filled rectangle will be faster!)
            draw_list->AddLine(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, curr_thickness); x += sz+spacing;   // Diagonal line
            draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x+sz*1.3f,y+sz*0.3f), ImVec2(x+sz-sz*1.3f,y+sz-sz*0.3f), ImVec2(x+sz, y+sz), col32, curr_thickness);
            x = p.x + 4;
            y += sz+spacing;
        }
        draw_list->AddCircleFilled(ImVec2(x+sz*0.5f, y+sz*0.5f), sz*0.5f, col32, 32); x += sz+spacing;
        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32); x += sz+spacing;
        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f); x += sz+spacing;
        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotRight); x += sz+spacing;
        draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32); x += sz+spacing;
        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+thickness), col32); x += sz+spacing;          // Horizontal line (faster than AddLine, but only handle integer thickness)
        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+thickness, y+sz), col32); x += spacing+spacing;     // Vertical line (faster than AddLine, but only handle integer thickness)
        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+1, y+1), col32);          x += sz;                  // Pixel (faster than AddLine)
        draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x+sz, y+sz), IM_COL32(0,0,0,255), IM_COL32(255,0,0,255), IM_COL32(255,255,0,255), IM_COL32(0,255,0,255));
        ImGui::Dummy(ImVec2((sz+spacing)*8, (sz+spacing)*3));
    }
    ImGui::Separator();
    {
        static ImVector<ImVec2> points;
        static bool adding_line = false;
        ImGui::Text("Canvas example");
        if (ImGui::Button("Clear")) points.clear();
        if (points.Size >= 2) { ImGui::SameLine(); if (ImGui::Button("Undo")) { points.pop_back(); points.pop_back(); } }
        ImGui::Text("Left-click and drag to add lines,\nRight-click to undo");

        // Here we are using InvisibleButton() as a convenience to 1) advance the cursor and 2) allows us to use IsItemHovered()
        // But you can also draw directly and poll mouse/keyboard by yourself. You can manipulate the cursor using GetCursorPos() and SetCursorPos().
        // If you only use the ImDrawList API, you can notify the owner window of its extends by using SetCursorPos(max).
        ImVec2 canvas_pos = ImGui::GetCursorScreenPos();            // ImDrawList API uses screen coordinates!
        ImVec2 canvas_size = ImGui::GetContentRegionAvail();        // Resize canvas to what's available
        if (canvas_size.x < 50.0f) canvas_size.x = 50.0f;
        if (canvas_size.y < 50.0f) canvas_size.y = 50.0f;
        draw_list->AddRectFilledMultiColor(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), IM_COL32(50, 50, 50, 255), IM_COL32(50, 50, 60, 255), IM_COL32(60, 60, 70, 255), IM_COL32(50, 50, 60, 255));
        draw_list->AddRect(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), IM_COL32(255, 255, 255, 255));

        bool adding_preview = false;
        ImGui::InvisibleButton("canvas", canvas_size);
        ImVec2 mouse_pos_in_canvas = ImVec2(ImGui::GetIO().MousePos.x - canvas_pos.x, ImGui::GetIO().MousePos.y - canvas_pos.y);
        if (adding_line)
        {
            adding_preview = true;
            points.push_back(mouse_pos_in_canvas);
            if (!ImGui::IsMouseDown(0))
                adding_line = adding_preview = false;
        }
        if (ImGui::IsItemHovered())
        {
            if (!adding_line && ImGui::IsMouseClicked(0))
            {
                points.push_back(mouse_pos_in_canvas);
                adding_line = true;
            }
            if (ImGui::IsMouseClicked(1) && !points.empty())
            {
                adding_line = adding_preview = false;
                points.pop_back();
                points.pop_back();
            }
        }
        draw_list->PushClipRect(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), true);      // clip lines within the canvas (if we resize it, etc.)
        for (int i = 0; i < points.Size - 1; i += 2)
            draw_list->AddLine(ImVec2(canvas_pos.x + points[i].x, canvas_pos.y + points[i].y), ImVec2(canvas_pos.x + points[i + 1].x, canvas_pos.y + points[i + 1].y), IM_COL32(255, 255, 0, 255), 2.0f);
        draw_list->PopClipRect();
        if (adding_preview)
            points.pop_back();
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()
//-----------------------------------------------------------------------------

// Simplified structure to mimic a Document model
struct MyDocument
{
    const char* Name;           // Document title
    bool        Open;           // Set when the document is open (in this demo, we keep an array of all available documents to simplify the demo)
    bool        OpenPrev;       // Copy of Open from last update.
    bool        Dirty;          // Set when the document has been modified
    bool        WantClose;      // Set when the document 
    ImVec4      Color;          // An arbitrary variable associated to the document

    MyDocument(const char* name, bool open = true, const ImVec4& color = ImVec4(1.0f,1.0f,1.0f,1.0f))
    { 
        Name = name; 
        Open = OpenPrev = open; 
        Dirty = false; 
        WantClose = false; 
        Color = color; 
    }
    void DoOpen()       { Open = true; }
    void DoQueueClose() { WantClose = true; }
    void DoForceClose() { Open = false; Dirty = false; }
    void DoSave()       { Dirty = false; }

    // Display dummy contents for the Document
    static void DisplayContents(MyDocument* doc)
    {
        ImGui::PushID(doc);
        ImGui::Text("Document \"%s\"", doc->Name);
        ImGui::PushStyleColor(ImGuiCol_Text, doc->Color);
        ImGui::TextWrapped("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.");
        ImGui::PopStyleColor();
        if (ImGui::Button("Modify", ImVec2(100, 0)))
            doc->Dirty = true;
        ImGui::SameLine();
        if (ImGui::Button("Save", ImVec2(100, 0)))
            doc->DoSave();
        ImGui::ColorEdit3("color", &doc->Color.x);  // Useful to test drag and drop and hold-dragged-to-open-tab behavior.
        ImGui::PopID();
    }

    // Display context menu for the Document
    static void DisplayContextMenu(MyDocument* doc)
    {
        if (!ImGui::BeginPopupContextItem())
            return;

        char buf[256];
        sprintf(buf, "Save %s", doc->Name);
        if (ImGui::MenuItem(buf, "CTRL+S", false, doc->Open))
            doc->DoSave();
        if (ImGui::MenuItem("Close", "CTRL+W", false, doc->Open))
            doc->DoQueueClose();
        ImGui::EndPopup();
    }
};

struct ExampleAppDocuments
{
    ImVector<MyDocument> Documents;

    ExampleAppDocuments()
    {
        Documents.push_back(MyDocument("Lettuce",             true,  ImVec4(0.4f, 0.8f, 0.4f, 1.0f)));
        Documents.push_back(MyDocument("Eggplant",            true,  ImVec4(0.8f, 0.5f, 1.0f, 1.0f)));
        Documents.push_back(MyDocument("Carrot",              true,  ImVec4(1.0f, 0.8f, 0.5f, 1.0f)));
        Documents.push_back(MyDocument("Tomato",              false, ImVec4(1.0f, 0.3f, 0.4f, 1.0f)));
        Documents.push_back(MyDocument("A Rather Long Title", false));
        Documents.push_back(MyDocument("Some Document",       false));
    }
};

// [Optional] Notify the system of Tabs/Windows closure that happened outside the regular tab interface.
// If a tab has been closed programmatically (aka closed from another source such as the Checkbox() in the demo, as opposed
// to clicking on the regular tab closing button) and stops being submitted, it will take a frame for the tab bar to notice its absence. 
// During this frame there will be a gap in the tab bar, and if the tab that has disappeared was the selected one, the tab bar 
// will report no selected tab during the frame. This will effectively give the impression of a flicker for one frame.
// We call SetTabItemClosed() to manually notify the Tab Bar or Docking system of removed tabs to avoid this glitch.
// Note that this completely optional, and only affect tab bars with the ImGuiTabBarFlags_Reorderable flag.
static void NotifyOfDocumentsClosedElsewhere(ExampleAppDocuments& app)
{
    for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
    {
        MyDocument* doc = &app.Documents[doc_n];
        if (!doc->Open && doc->OpenPrev)
            ImGui::SetTabItemClosed(doc->Name);
        doc->OpenPrev = doc->Open;
    }
}

void ShowExampleAppDocuments(bool* p_open)
{
    static ExampleAppDocuments app;

    if (!ImGui::Begin("Examples: Documents", p_open, ImGuiWindowFlags_MenuBar))
    {
        ImGui::End();
        return;
    }

    // Options
    static bool opt_reorderable = true;
    static ImGuiTabBarFlags opt_fitting_flags = ImGuiTabBarFlags_FittingPolicyDefault_;

    // Menu
    if (ImGui::BeginMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            int open_count = 0;
            for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
                open_count += app.Documents[doc_n].Open ? 1 : 0;

            if (ImGui::BeginMenu("Open", open_count < app.Documents.Size))
            {
                for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
                {
                    MyDocument* doc = &app.Documents[doc_n];
                    if (!doc->Open)
                        if (ImGui::MenuItem(doc->Name))
                            doc->DoOpen();
                }
                ImGui::EndMenu();
            }
            if (ImGui::MenuItem("Close All Documents", NULL, false, open_count > 0))
                for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
                    app.Documents[doc_n].DoQueueClose();
            if (ImGui::MenuItem("Exit", "Alt+F4")) {}
            ImGui::EndMenu();
        }
        ImGui::EndMenuBar();
    }

    // [Debug] List documents with one checkbox for each
    for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
    {
        MyDocument* doc = &app.Documents[doc_n];
        if (doc_n > 0)
            ImGui::SameLine();
        ImGui::PushID(doc);
        if (ImGui::Checkbox(doc->Name, &doc->Open))
            if (!doc->Open)
                doc->DoForceClose();
        ImGui::PopID();
    }

    ImGui::Separator();

    // Submit Tab Bar and Tabs
    {
        ImGuiTabBarFlags tab_bar_flags = (opt_fitting_flags) | (opt_reorderable ? ImGuiTabBarFlags_Reorderable : 0);
        if (ImGui::BeginTabBar("##tabs", tab_bar_flags))
        {
            if (opt_reorderable)
                NotifyOfDocumentsClosedElsewhere(app);

            // [DEBUG] Stress tests
            //if ((ImGui::GetFrameCount() % 30) == 0) docs[1].Open ^= 1;            // [DEBUG] Automatically show/hide a tab. Test various interactions e.g. dragging with this on.
            //if (ImGui::GetIO().KeyCtrl) ImGui::SetTabItemSelected(docs[1].Name);  // [DEBUG] Test SetTabItemSelected(), probably not very useful as-is anyway..

            // Submit Tabs
            for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
            {
                MyDocument* doc = &app.Documents[doc_n];
                if (!doc->Open)
                    continue;

                ImGuiTabItemFlags tab_flags = (doc->Dirty ? ImGuiTabItemFlags_UnsavedDocument : 0);
                bool visible = ImGui::BeginTabItem(doc->Name, &doc->Open, tab_flags);

                // Cancel attempt to close when unsaved add to save queue so we can display a popup.
                if (!doc->Open && doc->Dirty)
                {
                    doc->Open = true;
                    doc->DoQueueClose();
                }

                MyDocument::DisplayContextMenu(doc);
                if (visible)
                {
                    MyDocument::DisplayContents(doc);
                    ImGui::EndTabItem();
                }
            }

            ImGui::EndTabBar();
        }
    }

    // Update closing queue
    static ImVector<MyDocument*> close_queue;
    if (close_queue.empty())
    {
        // Close queue is locked once we started a popup
        for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
        {
            MyDocument* doc = &app.Documents[doc_n];
            if (doc->WantClose)
            {
                doc->WantClose = false;
                close_queue.push_back(doc);
            }
        }
    }

    // Display closing confirmation UI
    if (!close_queue.empty())
    {
        int close_queue_unsaved_documents = 0;
        for (int n = 0; n < close_queue.Size; n++)
            if (close_queue[n]->Dirty)
                close_queue_unsaved_documents++;

        if (close_queue_unsaved_documents == 0)
        {
            // Close documents when all are unsaved
            for (int n = 0; n < close_queue.Size; n++)
                close_queue[n]->DoForceClose();
            close_queue.clear();
        }
        else
        {
            if (!ImGui::IsPopupOpen("Save?"))
                ImGui::OpenPopup("Save?");
            if (ImGui::BeginPopupModal("Save?"))
            {
                ImGui::Text("Save change to the following items?");
                ImGui::PushItemWidth(-1.0f);
                ImGui::ListBoxHeader("##", close_queue_unsaved_documents, 6);
                for (int n = 0; n < close_queue.Size; n++)
                    if (close_queue[n]->Dirty)
                        ImGui::Text("%s", close_queue[n]->Name);
                ImGui::ListBoxFooter();

                if (ImGui::Button("Yes", ImVec2(80, 0)))
                {
                    for (int n = 0; n < close_queue.Size; n++)
                    {
                        if (close_queue[n]->Dirty)
                            close_queue[n]->DoSave();
                        close_queue[n]->DoForceClose();
                    }
                    close_queue.clear();
                    ImGui::CloseCurrentPopup();
                }
                ImGui::SameLine();
                if (ImGui::Button("No", ImVec2(80, 0)))
                {
                    for (int n = 0; n < close_queue.Size; n++)
                        close_queue[n]->DoForceClose();
                    close_queue.clear();
                    ImGui::CloseCurrentPopup();
                }
                ImGui::SameLine();
                if (ImGui::Button("Cancel", ImVec2(80, 0)))
                {
                    close_queue.clear();
                    ImGui::CloseCurrentPopup();
                }
                ImGui::EndPopup();
            }
        }
    }

    ImGui::End();
}

// End of Demo code
#else

void ImGui::ShowAboutWindow(bool*) {}
void ImGui::ShowDemoWindow(bool*) {}
void ImGui::ShowUserGuide() {}
void ImGui::ShowStyleEditor(ImGuiStyle*) {}

#endif

```

`Private Esp/imgui/imgui_draw.cpp`:

```cpp
// dear imgui, v1.67 WIP
// (drawing and font code)

/*

Index of this file:

// [SECTION] STB libraries implementation
// [SECTION] Style functions
// [SECTION] ImDrawList
// [SECTION] ImDrawData
// [SECTION] Helpers ShadeVertsXXX functions
// [SECTION] ImFontConfig
// [SECTION] ImFontAtlas
// [SECTION] ImFontAtlas glyph ranges helpers + GlyphRangesBuilder
// [SECTION] ImFont
// [SECTION] Internal Render Helpers
// [SECTION] Decompression code
// [SECTION] Default font data (ProggyClean.ttf)

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

#include <stdio.h>      // vsnprintf, sscanf, printf
#if !defined(alloca)
#if defined(__GLIBC__) || defined(__sun) || defined(__CYGWIN__) || defined(__APPLE__)
#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)
#elif defined(_WIN32)
#include <malloc.h>     // alloca
#if !defined(alloca)
#define alloca _alloca  // for clang with MS Codegen
#endif
#else
#include <stdlib.h>     // alloca
#endif
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants ok.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#if __has_warning("-Wcomma")
#pragma clang diagnostic ignored "-Wcomma"                  // warning : possible misuse of comma operator here             //
#endif
#if __has_warning("-Wreserved-id-macro")
#pragma clang diagnostic ignored "-Wreserved-id-macro"      // warning : macro name is a reserved identifier                //
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif
#endif

//-------------------------------------------------------------------------
// [SECTION] STB libraries implementation
//-------------------------------------------------------------------------

// Compile time options:
//#define IMGUI_STB_NAMESPACE           ImGuiStb
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

#ifdef IMGUI_STB_NAMESPACE
namespace IMGUI_STB_NAMESPACE
{
#endif

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#pragma clang diagnostic ignored "-Wcast-qual"              // warning : cast from 'const xxxx *' to 'xxx *' drops const qualifier //
#endif

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits"              // warning: comparison is always true due to limited range of data type [-Wtype-limits]
#pragma GCC diagnostic ignored "-Wcast-qual"                // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers
#endif

#ifndef STB_RECT_PACK_IMPLEMENTATION                        // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION
#define STBRP_STATIC
#define STBRP_ASSERT(x)     IM_ASSERT(x)
#define STBRP_SORT          ImQsort
#define STB_RECT_PACK_IMPLEMENTATION
#endif
#ifdef IMGUI_STB_RECT_PACK_FILENAME
#include IMGUI_STB_RECT_PACK_FILENAME
#else
#include "imstb_rectpack.h"
#endif
#endif

#ifndef STB_TRUETYPE_IMPLEMENTATION                         // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
#define STBTT_malloc(x,u)   ((void)(u), ImGui::MemAlloc(x))
#define STBTT_free(x,u)     ((void)(u), ImGui::MemFree(x))
#define STBTT_assert(x)     IM_ASSERT(x)
#define STBTT_fmod(x,y)     ImFmod(x,y)
#define STBTT_sqrt(x)       ImSqrt(x)
#define STBTT_pow(x,y)      ImPow(x,y)
#define STBTT_fabs(x)       ImFabs(x)
#define STBTT_ifloor(x)     ((int)ImFloorStd(x))
#define STBTT_iceil(x)      ((int)ImCeil(x))
#define STBTT_STATIC
#define STB_TRUETYPE_IMPLEMENTATION
#else
#define STBTT_DEF extern
#endif
#ifdef IMGUI_STB_TRUETYPE_FILENAME
#include IMGUI_STB_TRUETYPE_FILENAME
#else
#include "imstb_truetype.h"
#endif
#endif

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning (pop)
#endif

#ifdef IMGUI_STB_NAMESPACE
} // namespace ImGuiStb
using namespace IMGUI_STB_NAMESPACE;
#endif

//-----------------------------------------------------------------------------
// [SECTION] Style functions
//-----------------------------------------------------------------------------

void ImGui::StyleColorsDark(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
    colors[ImGuiCol_ChildBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.25f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
    colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
}

void ImGui::StyleColorsClassic(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.00f, 0.00f, 0.00f, 0.70f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);
    colors[ImGuiCol_Border]                 = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
    colors[ImGuiCol_Button]                 = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);
    colors[ImGuiCol_Separator]              = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(1.00f, 1.00f, 1.00f, 0.16f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_PlotLines]              = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
    colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
}

// Those light colors are better suited with a thicker font than the default one + FrameBorder
void ImGui::StyleColorsLight(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);
    colors[ImGuiCol_Border]                 = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);
    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Separator]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.80f, 0.80f, 0.80f, 0.56f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.90f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_PlotLines]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
}

//-----------------------------------------------------------------------------
// ImDrawList
//-----------------------------------------------------------------------------

ImDrawListSharedData::ImDrawListSharedData()
{
    Font = NULL;
    FontSize = 0.0f;
    CurveTessellationTol = 0.0f;
    ClipRectFullscreen = ImVec4(-8192.0f, -8192.0f, +8192.0f, +8192.0f);

    // Const data
    for (int i = 0; i < IM_ARRAYSIZE(CircleVtx12); i++)
    {
        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(CircleVtx12);
        CircleVtx12[i] = ImVec2(ImCos(a), ImSin(a));
    }
}

void ImDrawList::Clear()
{
    CmdBuffer.resize(0);
    IdxBuffer.resize(0);
    VtxBuffer.resize(0);
    Flags = ImDrawListFlags_AntiAliasedLines | ImDrawListFlags_AntiAliasedFill;
    _VtxCurrentIdx = 0;
    _VtxWritePtr = NULL;
    _IdxWritePtr = NULL;
    _ClipRectStack.resize(0);
    _TextureIdStack.resize(0);
    _Path.resize(0);
    _ChannelsCurrent = 0;
    _ChannelsCount = 1;
    // NB: Do not clear channels so our allocations are re-used after the first frame.
}

void ImDrawList::ClearFreeMemory()
{
    CmdBuffer.clear();
    IdxBuffer.clear();
    VtxBuffer.clear();
    _VtxCurrentIdx = 0;
    _VtxWritePtr = NULL;
    _IdxWritePtr = NULL;
    _ClipRectStack.clear();
    _TextureIdStack.clear();
    _Path.clear();
    _ChannelsCurrent = 0;
    _ChannelsCount = 1;
    for (int i = 0; i < _Channels.Size; i++)
    {
        if (i == 0) memset(&_Channels[0], 0, sizeof(_Channels[0]));  // channel 0 is a copy of CmdBuffer/IdxBuffer, don't destruct again
        _Channels[i].CmdBuffer.clear();
        _Channels[i].IdxBuffer.clear();
    }
    _Channels.clear();
}

ImDrawList* ImDrawList::CloneOutput() const
{
    ImDrawList* dst = IM_NEW(ImDrawList(NULL));
    dst->CmdBuffer = CmdBuffer;
    dst->IdxBuffer = IdxBuffer;
    dst->VtxBuffer = VtxBuffer;
    dst->Flags = Flags;
    return dst;
}

// Using macros because C++ is a terrible language, we want guaranteed inline, no code in header, and no overhead in Debug builds
#define GetCurrentClipRect()    (_ClipRectStack.Size ? _ClipRectStack.Data[_ClipRectStack.Size-1]  : _Data->ClipRectFullscreen)
#define GetCurrentTextureId()   (_TextureIdStack.Size ? _TextureIdStack.Data[_TextureIdStack.Size-1] : NULL)

void ImDrawList::AddDrawCmd()
{
    ImDrawCmd draw_cmd;
    draw_cmd.ClipRect = GetCurrentClipRect();
    draw_cmd.TextureId = GetCurrentTextureId();

    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
    CmdBuffer.push_back(draw_cmd);
}

void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)
{
    ImDrawCmd* current_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;
    if (!current_cmd || current_cmd->ElemCount != 0 || current_cmd->UserCallback != NULL)
    {
        AddDrawCmd();
        current_cmd = &CmdBuffer.back();
    }
    current_cmd->UserCallback = callback;
    current_cmd->UserCallbackData = callback_data;

    AddDrawCmd(); // Force a new command after us (see comment below)
}

// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.
// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.
void ImDrawList::UpdateClipRect()
{
    // If current command is used with different settings we need to add a new command
    const ImVec4 curr_clip_rect = GetCurrentClipRect();
    ImDrawCmd* curr_cmd = CmdBuffer.Size > 0 ? &CmdBuffer.Data[CmdBuffer.Size-1] : NULL;
    if (!curr_cmd || (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) != 0) || curr_cmd->UserCallback != NULL)
    {
        AddDrawCmd();
        return;
    }

    // Try to merge with previous command if it matches, else use current command
    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
    if (curr_cmd->ElemCount == 0 && prev_cmd && memcmp(&prev_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) == 0 && prev_cmd->TextureId == GetCurrentTextureId() && prev_cmd->UserCallback == NULL)
        CmdBuffer.pop_back();
    else
        curr_cmd->ClipRect = curr_clip_rect;
}

void ImDrawList::UpdateTextureID()
{
    // If current command is used with different settings we need to add a new command
    const ImTextureID curr_texture_id = GetCurrentTextureId();
    ImDrawCmd* curr_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;
    if (!curr_cmd || (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != curr_texture_id) || curr_cmd->UserCallback != NULL)
    {
        AddDrawCmd();
        return;
    }

    // Try to merge with previous command if it matches, else use current command
    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
    if (curr_cmd->ElemCount == 0 && prev_cmd && prev_cmd->TextureId == curr_texture_id && memcmp(&prev_cmd->ClipRect, &GetCurrentClipRect(), sizeof(ImVec4)) == 0 && prev_cmd->UserCallback == NULL)
        CmdBuffer.pop_back();
    else
        curr_cmd->TextureId = curr_texture_id;
}

#undef GetCurrentClipRect
#undef GetCurrentTextureId

// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
void ImDrawList::PushClipRect(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)
{
    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
    if (intersect_with_current_clip_rect && _ClipRectStack.Size)
    {
        ImVec4 current = _ClipRectStack.Data[_ClipRectStack.Size-1];
        if (cr.x < current.x) cr.x = current.x;
        if (cr.y < current.y) cr.y = current.y;
        if (cr.z > current.z) cr.z = current.z;
        if (cr.w > current.w) cr.w = current.w;
    }
    cr.z = ImMax(cr.x, cr.z);
    cr.w = ImMax(cr.y, cr.w);

    _ClipRectStack.push_back(cr);
    UpdateClipRect();
}

void ImDrawList::PushClipRectFullScreen()
{
    PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));
}

void ImDrawList::PopClipRect()
{
    IM_ASSERT(_ClipRectStack.Size > 0);
    _ClipRectStack.pop_back();
    UpdateClipRect();
}

void ImDrawList::PushTextureID(ImTextureID texture_id)
{
    _TextureIdStack.push_back(texture_id);
    UpdateTextureID();
}

void ImDrawList::PopTextureID()
{
    IM_ASSERT(_TextureIdStack.Size > 0);
    _TextureIdStack.pop_back();
    UpdateTextureID();
}

void ImDrawList::ChannelsSplit(int channels_count)
{
    IM_ASSERT(_ChannelsCurrent == 0 && _ChannelsCount == 1);
    int old_channels_count = _Channels.Size;
    if (old_channels_count < channels_count)
        _Channels.resize(channels_count);
    _ChannelsCount = channels_count;

    // _Channels[] (24/32 bytes each) hold storage that we'll swap with this->_CmdBuffer/_IdxBuffer
    // The content of _Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
    // When we switch to the next channel, we'll copy _CmdBuffer/_IdxBuffer into _Channels[0] and then _Channels[1] into _CmdBuffer/_IdxBuffer
    memset(&_Channels[0], 0, sizeof(ImDrawChannel));
    for (int i = 1; i < channels_count; i++)
    {
        if (i >= old_channels_count)
        {
            IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();
        }
        else
        {
            _Channels[i].CmdBuffer.resize(0);
            _Channels[i].IdxBuffer.resize(0);
        }
        if (_Channels[i].CmdBuffer.Size == 0)
        {
            ImDrawCmd draw_cmd;
            draw_cmd.ClipRect = _ClipRectStack.back();
            draw_cmd.TextureId = _TextureIdStack.back();
            _Channels[i].CmdBuffer.push_back(draw_cmd);
        }
    }
}

void ImDrawList::ChannelsMerge()
{
    // Note that we never use or rely on channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
    if (_ChannelsCount <= 1)
        return;

    ChannelsSetCurrent(0);
    if (CmdBuffer.Size && CmdBuffer.back().ElemCount == 0)
        CmdBuffer.pop_back();

    int new_cmd_buffer_count = 0, new_idx_buffer_count = 0;
    for (int i = 1; i < _ChannelsCount; i++)
    {
        ImDrawChannel& ch = _Channels[i];
        if (ch.CmdBuffer.Size && ch.CmdBuffer.back().ElemCount == 0)
            ch.CmdBuffer.pop_back();
        new_cmd_buffer_count += ch.CmdBuffer.Size;
        new_idx_buffer_count += ch.IdxBuffer.Size;
    }
    CmdBuffer.resize(CmdBuffer.Size + new_cmd_buffer_count);
    IdxBuffer.resize(IdxBuffer.Size + new_idx_buffer_count);

    ImDrawCmd* cmd_write = CmdBuffer.Data + CmdBuffer.Size - new_cmd_buffer_count;
    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size - new_idx_buffer_count;
    for (int i = 1; i < _ChannelsCount; i++)
    {
        ImDrawChannel& ch = _Channels[i];
        if (int sz = ch.CmdBuffer.Size) { memcpy(cmd_write, ch.CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }
        if (int sz = ch.IdxBuffer.Size) { memcpy(_IdxWritePtr, ch.IdxBuffer.Data, sz * sizeof(ImDrawIdx)); _IdxWritePtr += sz; }
    }
    UpdateClipRect(); // We call this instead of AddDrawCmd(), so that empty channels won't produce an extra draw call.
    _ChannelsCount = 1;
}

void ImDrawList::ChannelsSetCurrent(int idx)
{
    IM_ASSERT(idx < _ChannelsCount);
    if (_ChannelsCurrent == idx) return;
    memcpy(&_Channels.Data[_ChannelsCurrent].CmdBuffer, &CmdBuffer, sizeof(CmdBuffer)); // copy 12 bytes, four times
    memcpy(&_Channels.Data[_ChannelsCurrent].IdxBuffer, &IdxBuffer, sizeof(IdxBuffer));
    _ChannelsCurrent = idx;
    memcpy(&CmdBuffer, &_Channels.Data[_ChannelsCurrent].CmdBuffer, sizeof(CmdBuffer));
    memcpy(&IdxBuffer, &_Channels.Data[_ChannelsCurrent].IdxBuffer, sizeof(IdxBuffer));
    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size;
}

// NB: this can be called with negative count for removing primitives (as long as the result does not underflow)
void ImDrawList::PrimReserve(int idx_count, int vtx_count)
{
    ImDrawCmd& draw_cmd = CmdBuffer.Data[CmdBuffer.Size-1];
    draw_cmd.ElemCount += idx_count;

    int vtx_buffer_old_size = VtxBuffer.Size;
    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

    int idx_buffer_old_size = IdxBuffer.Size;
    IdxBuffer.resize(idx_buffer_old_size + idx_count);
    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
}

// Fully unrolled with inline call to keep our debug builds decently fast.
void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)
{
    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
{
    ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

void ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
{
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

// TODO: Thickness anti-aliased lines cap are missing their AA fringe.
void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness)
{
    if (points_count < 2)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;

    int count = points_count;
    if (!closed)
        count = points_count-1;

    const bool thick_line = thickness > 1.0f;
    if (Flags & ImDrawListFlags_AntiAliasedLines)
    {
        // Anti-aliased stroke
        const float AA_SIZE = 1.0f;
        const ImU32 col_trans = col & ~IM_COL32_A_MASK;

        const int idx_count = thick_line ? count*18 : count*12;
        const int vtx_count = thick_line ? points_count*4 : points_count*3;
        PrimReserve(idx_count, vtx_count);

        // Temporary buffer
        ImVec2* temp_normals = (ImVec2*)alloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2));
        ImVec2* temp_points = temp_normals + points_count;

        for (int i1 = 0; i1 < count; i1++)
        {
            const int i2 = (i1+1) == points_count ? 0 : i1+1;
            ImVec2 diff = points[i2] - points[i1];
            diff *= ImInvLength(diff, 1.0f);
            temp_normals[i1].x = diff.y;
            temp_normals[i1].y = -diff.x;
        }
        if (!closed)
            temp_normals[points_count-1] = temp_normals[points_count-2];

        if (!thick_line)
        {
            if (!closed)
            {
                temp_points[0] = points[0] + temp_normals[0] * AA_SIZE;
                temp_points[1] = points[0] - temp_normals[0] * AA_SIZE;
                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * AA_SIZE;
                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * AA_SIZE;
            }

            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
            unsigned int idx1 = _VtxCurrentIdx;
            for (int i1 = 0; i1 < count; i1++)
            {
                const int i2 = (i1+1) == points_count ? 0 : i1+1;
                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+3;

                // Average normals
                ImVec2 dm = (temp_normals[i1] + temp_normals[i2]) * 0.5f;
                float dmr2 = dm.x*dm.x + dm.y*dm.y;
                if (dmr2 > 0.000001f)
                {
                    float scale = 1.0f / dmr2;
                    if (scale > 100.0f) scale = 100.0f;
                    dm *= scale;
                }
                dm *= AA_SIZE;
                temp_points[i2*2+0] = points[i2] + dm;
                temp_points[i2*2+1] = points[i2] - dm;

                // Add indexes
                _IdxWritePtr[0] = (ImDrawIdx)(idx2+0); _IdxWritePtr[1] = (ImDrawIdx)(idx1+0); _IdxWritePtr[2] = (ImDrawIdx)(idx1+2);
                _IdxWritePtr[3] = (ImDrawIdx)(idx1+2); _IdxWritePtr[4] = (ImDrawIdx)(idx2+2); _IdxWritePtr[5] = (ImDrawIdx)(idx2+0);
                _IdxWritePtr[6] = (ImDrawIdx)(idx2+1); _IdxWritePtr[7] = (ImDrawIdx)(idx1+1); _IdxWritePtr[8] = (ImDrawIdx)(idx1+0);
                _IdxWritePtr[9] = (ImDrawIdx)(idx1+0); _IdxWritePtr[10]= (ImDrawIdx)(idx2+0); _IdxWritePtr[11]= (ImDrawIdx)(idx2+1);
                _IdxWritePtr += 12;

                idx1 = idx2;
            }

            // Add vertexes
            for (int i = 0; i < points_count; i++)
            {
                _VtxWritePtr[0].pos = points[i];          _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
                _VtxWritePtr[1].pos = temp_points[i*2+0]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;
                _VtxWritePtr[2].pos = temp_points[i*2+1]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col_trans;
                _VtxWritePtr += 3;
            }
        }
        else
        {
            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
            if (!closed)
            {
                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
                temp_points[(points_count-1)*4+0] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);
                temp_points[(points_count-1)*4+1] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness);
                temp_points[(points_count-1)*4+2] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness);
                temp_points[(points_count-1)*4+3] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);
            }

            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
            unsigned int idx1 = _VtxCurrentIdx;
            for (int i1 = 0; i1 < count; i1++)
            {
                const int i2 = (i1+1) == points_count ? 0 : i1+1;
                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+4;

                // Average normals
                ImVec2 dm = (temp_normals[i1] + temp_normals[i2]) * 0.5f;
                float dmr2 = dm.x*dm.x + dm.y*dm.y;
                if (dmr2 > 0.000001f)
                {
                    float scale = 1.0f / dmr2;
                    if (scale > 100.0f) scale = 100.0f;
                    dm *= scale;
                }
                ImVec2 dm_out = dm * (half_inner_thickness + AA_SIZE);
                ImVec2 dm_in = dm * half_inner_thickness;
                temp_points[i2*4+0] = points[i2] + dm_out;
                temp_points[i2*4+1] = points[i2] + dm_in;
                temp_points[i2*4+2] = points[i2] - dm_in;
                temp_points[i2*4+3] = points[i2] - dm_out;

                // Add indexes
                _IdxWritePtr[0]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1+2);
                _IdxWritePtr[3]  = (ImDrawIdx)(idx1+2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2+2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2+1);
                _IdxWritePtr[6]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1+0);
                _IdxWritePtr[9]  = (ImDrawIdx)(idx1+0); _IdxWritePtr[10] = (ImDrawIdx)(idx2+0); _IdxWritePtr[11] = (ImDrawIdx)(idx2+1);
                _IdxWritePtr[12] = (ImDrawIdx)(idx2+2); _IdxWritePtr[13] = (ImDrawIdx)(idx1+2); _IdxWritePtr[14] = (ImDrawIdx)(idx1+3);
                _IdxWritePtr[15] = (ImDrawIdx)(idx1+3); _IdxWritePtr[16] = (ImDrawIdx)(idx2+3); _IdxWritePtr[17] = (ImDrawIdx)(idx2+2);
                _IdxWritePtr += 18;

                idx1 = idx2;
            }

            // Add vertexes
            for (int i = 0; i < points_count; i++)
            {
                _VtxWritePtr[0].pos = temp_points[i*4+0]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col_trans;
                _VtxWritePtr[1].pos = temp_points[i*4+1]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
                _VtxWritePtr[2].pos = temp_points[i*4+2]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
                _VtxWritePtr[3].pos = temp_points[i*4+3]; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col_trans;
                _VtxWritePtr += 4;
            }
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
    else
    {
        // Non Anti-aliased Stroke
        const int idx_count = count*6;
        const int vtx_count = count*4;      // FIXME-OPT: Not sharing edges
        PrimReserve(idx_count, vtx_count);

        for (int i1 = 0; i1 < count; i1++)
        {
            const int i2 = (i1+1) == points_count ? 0 : i1+1;
            const ImVec2& p1 = points[i1];
            const ImVec2& p2 = points[i2];
            ImVec2 diff = p2 - p1;
            diff *= ImInvLength(diff, 1.0f);

            const float dx = diff.x * (thickness * 0.5f);
            const float dy = diff.y * (thickness * 0.5f);
            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
            _VtxWritePtr += 4;

            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+2);
            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx+2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx+3);
            _IdxWritePtr += 6;
            _VtxCurrentIdx += 4;
        }
    }
}

void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)
{
    if (points_count < 3)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;

    if (Flags & ImDrawListFlags_AntiAliasedFill)
    {
        // Anti-aliased Fill
        const float AA_SIZE = 1.0f;
        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
        const int idx_count = (points_count-2)*3 + points_count*6;
        const int vtx_count = (points_count*2);
        PrimReserve(idx_count, vtx_count);

        // Add indexes for fill
        unsigned int vtx_inner_idx = _VtxCurrentIdx;
        unsigned int vtx_outer_idx = _VtxCurrentIdx+1;
        for (int i = 2; i < points_count; i++)
        {
            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+((i-1)<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx+(i<<1));
            _IdxWritePtr += 3;
        }

        // Compute normals
        ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2));
        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            const ImVec2& p0 = points[i0];
            const ImVec2& p1 = points[i1];
            ImVec2 diff = p1 - p0;
            diff *= ImInvLength(diff, 1.0f);
            temp_normals[i0].x = diff.y;
            temp_normals[i0].y = -diff.x;
        }

        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            // Average normals
            const ImVec2& n0 = temp_normals[i0];
            const ImVec2& n1 = temp_normals[i1];
            ImVec2 dm = (n0 + n1) * 0.5f;
            float dmr2 = dm.x*dm.x + dm.y*dm.y;
            if (dmr2 > 0.000001f)
            {
                float scale = 1.0f / dmr2;
                if (scale > 100.0f) scale = 100.0f;
                dm *= scale;
            }
            dm *= AA_SIZE * 0.5f;

            // Add vertices
            _VtxWritePtr[0].pos = (points[i1] - dm); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
            _VtxWritePtr[1].pos = (points[i1] + dm); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
            _VtxWritePtr += 2;

            // Add indexes for fringes
            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx+(i1<<1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+(i0<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx+(i0<<1));
            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx+(i0<<1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx+(i1<<1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx+(i1<<1));
            _IdxWritePtr += 6;
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
    else
    {
        // Non Anti-aliased Fill
        const int idx_count = (points_count-2)*3;
        const int vtx_count = points_count;
        PrimReserve(idx_count, vtx_count);
        for (int i = 0; i < vtx_count; i++)
        {
            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
            _VtxWritePtr++;
        }
        for (int i = 2; i < points_count; i++)
        {
            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+i-1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+i);
            _IdxWritePtr += 3;
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
}

void ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)
{
    if (radius == 0.0f || a_min_of_12 > a_max_of_12)
    {
        _Path.push_back(centre);
        return;
    }
    _Path.reserve(_Path.Size + (a_max_of_12 - a_min_of_12 + 1));
    for (int a = a_min_of_12; a <= a_max_of_12; a++)
    {
        const ImVec2& c = _Data->CircleVtx12[a % IM_ARRAYSIZE(_Data->CircleVtx12)];
        _Path.push_back(ImVec2(centre.x + c.x * radius, centre.y + c.y * radius));
    }
}

void ImDrawList::PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments)
{
    if (radius == 0.0f)
    {
        _Path.push_back(centre);
        return;
    }
    _Path.reserve(_Path.Size + (num_segments + 1));
    for (int i = 0; i <= num_segments; i++)
    {
        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
        _Path.push_back(ImVec2(centre.x + ImCos(a) * radius, centre.y + ImSin(a) * radius));
    }
}

static void PathBezierToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)
{
    float dx = x4 - x1;
    float dy = y4 - y1;
    float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);
    float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);
    d2 = (d2 >= 0) ? d2 : -d2;
    d3 = (d3 >= 0) ? d3 : -d3;
    if ((d2+d3) * (d2+d3) < tess_tol * (dx*dx + dy*dy))
    {
        path->push_back(ImVec2(x4, y4));
    }
    else if (level < 10)
    {
        float x12 = (x1+x2)*0.5f,       y12 = (y1+y2)*0.5f;
        float x23 = (x2+x3)*0.5f,       y23 = (y2+y3)*0.5f;
        float x34 = (x3+x4)*0.5f,       y34 = (y3+y4)*0.5f;
        float x123 = (x12+x23)*0.5f,    y123 = (y12+y23)*0.5f;
        float x234 = (x23+x34)*0.5f,    y234 = (y23+y34)*0.5f;
        float x1234 = (x123+x234)*0.5f, y1234 = (y123+y234)*0.5f;

        PathBezierToCasteljau(path, x1,y1,        x12,y12,    x123,y123,  x1234,y1234, tess_tol, level+1);
        PathBezierToCasteljau(path, x1234,y1234,  x234,y234,  x34,y34,    x4,y4,       tess_tol, level+1);
    }
}

void ImDrawList::PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)
{
    ImVec2 p1 = _Path.back();
    if (num_segments == 0)
    {
        // Auto-tessellated
        PathBezierToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0);
    }
    else
    {
        float t_step = 1.0f / (float)num_segments;
        for (int i_step = 1; i_step <= num_segments; i_step++)
        {
            float t = t_step * i_step;
            float u = 1.0f - t;
            float w1 = u*u*u;
            float w2 = 3*u*u*t;
            float w3 = 3*u*t*t;
            float w4 = t*t*t;
            _Path.push_back(ImVec2(w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x, w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y));
        }
    }
}

void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)
{
    rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((rounding_corners & ImDrawCornerFlags_Top)  == ImDrawCornerFlags_Top)  || ((rounding_corners & ImDrawCornerFlags_Bot)   == ImDrawCornerFlags_Bot)   ? 0.5f : 1.0f ) - 1.0f);
    rounding = ImMin(rounding, ImFabs(b.y - a.y) * ( ((rounding_corners & ImDrawCornerFlags_Left) == ImDrawCornerFlags_Left) || ((rounding_corners & ImDrawCornerFlags_Right) == ImDrawCornerFlags_Right) ? 0.5f : 1.0f ) - 1.0f);

    if (rounding <= 0.0f || rounding_corners == 0)
    {
        PathLineTo(a);
        PathLineTo(ImVec2(b.x, a.y));
        PathLineTo(b);
        PathLineTo(ImVec2(a.x, b.y));
    }
    else
    {
        const float rounding_tl = (rounding_corners & ImDrawCornerFlags_TopLeft) ? rounding : 0.0f;
        const float rounding_tr = (rounding_corners & ImDrawCornerFlags_TopRight) ? rounding : 0.0f;
        const float rounding_br = (rounding_corners & ImDrawCornerFlags_BotRight) ? rounding : 0.0f;
        const float rounding_bl = (rounding_corners & ImDrawCornerFlags_BotLeft) ? rounding : 0.0f;
        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
    }
}

void ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    PathLineTo(a + ImVec2(0.5f,0.5f));
    PathLineTo(b + ImVec2(0.5f,0.5f));
    PathStroke(col, false, thickness);
}

// a: upper-left, b: lower-right. we don't render 1 px sized rectangles properly.
void ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    if (Flags & ImDrawListFlags_AntiAliasedLines)
        PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.50f,0.50f), rounding, rounding_corners_flags);
    else
        PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.49f,0.49f), rounding, rounding_corners_flags); // Better looking lower-right corner and rounded non-AA shapes.
    PathStroke(col, true, thickness);
}

void ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    if (rounding > 0.0f)
    {
        PathRect(a, b, rounding, rounding_corners_flags);
        PathFillConvex(col);
    }
    else
    {
        PrimReserve(6, 4);
        PrimRect(a, b, col);
    }
}

void ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
{
    if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;
    PrimReserve(6, 4);
    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2));
    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+3));
    PrimWriteVtx(a, uv, col_upr_left);
    PrimWriteVtx(ImVec2(c.x, a.y), uv, col_upr_right);
    PrimWriteVtx(c, uv, col_bot_right);
    PrimWriteVtx(ImVec2(a.x, c.y), uv, col_bot_left);
}

void ImDrawList::AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathLineTo(d);
    PathStroke(col, true, thickness);
}

void ImDrawList::AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathLineTo(d);
    PathFillConvex(col);
}

void ImDrawList::AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathStroke(col, true, thickness);
}

void ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathFillConvex(col);
}

void ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
    PathArcTo(centre, radius-0.5f, 0.0f, a_max, num_segments);
    PathStroke(col, true, thickness);
}

void ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
    PathArcTo(centre, radius, 0.0f, a_max, num_segments);
    PathFillConvex(col);
}

void ImDrawList::AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(pos0);
    PathBezierCurveTo(cp0, cp1, pos1, num_segments);
    PathStroke(col, false, thickness);
}

void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    if (text_end == NULL)
        text_end = text_begin + strlen(text_begin);
    if (text_begin == text_end)
        return;

    // Pull default font/size from the shared ImDrawListSharedData instance
    if (font == NULL)
        font = _Data->Font;
    if (font_size == 0.0f)
        font_size = _Data->FontSize;

    IM_ASSERT(font->ContainerAtlas->TexID == _TextureIdStack.back());  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.

    ImVec4 clip_rect = _ClipRectStack.back();
    if (cpu_fine_clip_rect)
    {
        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
    }
    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
}

void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
{
    AddText(NULL, 0.0f, pos, col, text_begin, text_end);
}

void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
    if (push_texture_id)
        PushTextureID(user_texture_id);

    PrimReserve(6, 4);
    PrimRectUV(a, b, uv_a, uv_b, col);

    if (push_texture_id)
        PopTextureID();
}

void ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
    if (push_texture_id)
        PushTextureID(user_texture_id);

    PrimReserve(6, 4);
    PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);

    if (push_texture_id)
        PopTextureID();
}

void ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    if (rounding <= 0.0f || (rounding_corners & ImDrawCornerFlags_All) == 0)
    {
        AddImage(user_texture_id, a, b, uv_a, uv_b, col);
        return;
    }

    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
    if (push_texture_id)
        PushTextureID(user_texture_id);

    int vert_start_idx = VtxBuffer.Size;
    PathRect(a, b, rounding, rounding_corners);
    PathFillConvex(col);
    int vert_end_idx = VtxBuffer.Size;
    ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, a, b, uv_a, uv_b, true);

    if (push_texture_id)
        PopTextureID();
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawData
//-----------------------------------------------------------------------------

// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
void ImDrawData::DeIndexAllBuffers()
{
    ImVector<ImDrawVert> new_vtx_buffer;
    TotalVtxCount = TotalIdxCount = 0;
    for (int i = 0; i < CmdListsCount; i++)
    {
        ImDrawList* cmd_list = CmdLists[i];
        if (cmd_list->IdxBuffer.empty())
            continue;
        new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);
        for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)
            new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];
        cmd_list->VtxBuffer.swap(new_vtx_buffer);
        cmd_list->IdxBuffer.resize(0);
        TotalVtxCount += cmd_list->VtxBuffer.Size;
    }
}

// Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
void ImDrawData::ScaleClipRects(const ImVec2& scale)
{
    for (int i = 0; i < CmdListsCount; i++)
    {
        ImDrawList* cmd_list = CmdLists[i];
        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            ImDrawCmd* cmd = &cmd_list->CmdBuffer[cmd_i];
            cmd->ClipRect = ImVec4(cmd->ClipRect.x * scale.x, cmd->ClipRect.y * scale.y, cmd->ClipRect.z * scale.x, cmd->ClipRect.w * scale.y);
        }
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Helpers ShadeVertsXXX functions
//-----------------------------------------------------------------------------

// Generic linear color gradient, write to RGB fields, leave A untouched.
void ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)
{
    ImVec2 gradient_extent = gradient_p1 - gradient_p0;
    float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);
    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)
    {
        float d = ImDot(vert->pos - gradient_p0, gradient_extent);
        float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);
        int r = ImLerp((int)(col0 >> IM_COL32_R_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_R_SHIFT) & 0xFF, t);
        int g = ImLerp((int)(col0 >> IM_COL32_G_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_G_SHIFT) & 0xFF, t);
        int b = ImLerp((int)(col0 >> IM_COL32_B_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_B_SHIFT) & 0xFF, t);
        vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);
    }
}

// Distribute UV over (a, b) rectangle
void ImGui::ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)
{
    const ImVec2 size = b - a;
    const ImVec2 uv_size = uv_b - uv_a;
    const ImVec2 scale = ImVec2(
        size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,
        size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);

    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    if (clamp)
    {
        const ImVec2 min = ImMin(uv_a, uv_b);
        const ImVec2 max = ImMax(uv_a, uv_b);
        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
            vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);
    }
    else
    {
        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
            vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);
    }
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontConfig
//-----------------------------------------------------------------------------

ImFontConfig::ImFontConfig()
{
    FontData = NULL;
    FontDataSize = 0;
    FontDataOwnedByAtlas = true;
    FontNo = 0;
    SizePixels = 0.0f;
    OversampleH = 3;
    OversampleV = 1;
    PixelSnapH = false;
    GlyphExtraSpacing = ImVec2(0.0f, 0.0f);
    GlyphOffset = ImVec2(0.0f, 0.0f);
    GlyphRanges = NULL;
    GlyphMinAdvanceX = 0.0f;
    GlyphMaxAdvanceX = FLT_MAX;
    MergeMode = false;
    RasterizerFlags = 0x00;
    RasterizerMultiply = 1.0f;
    memset(Name, 0, sizeof(Name));
    DstFont = NULL;
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontAtlas
//-----------------------------------------------------------------------------

// A work of art lies ahead! (. = white layer, X = black layer, others are blank)
// The white texels on the top left are the ones we'll use everywhere in ImGui to render filled shapes.
const int FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF = 108;
const int FONT_ATLAS_DEFAULT_TEX_DATA_H      = 27;
const unsigned int FONT_ATLAS_DEFAULT_TEX_DATA_ID = 0x80000000;
static const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =
{
    "..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          "
    "..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         "
    "---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         "
    "X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         "
    "XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         "
    "X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       "
    "X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    "
    "X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  "
    "X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X "
    "X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X"
    "X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X"
    "X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X"
    "X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X"
    "X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X"
    "X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X"
    "X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X"
    "X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X "
    "X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X "
    "X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X "
    "XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  "
    "      X..X          -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  "
    "       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  "
    "------------        -    X    -           X           -X.....................X-           ------------------"
    "                    ----------------------------------- X...XXXXXXXXXXXXX...X -                             "
    "                                                      -  X..X           X..X  -                             "
    "                                                      -   X.X           X.X   -                             "
    "                                                      -    XX           XX    -                             "
};

static const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] =
{
    // Pos ........ Size ......... Offset ......
    { ImVec2( 0,3), ImVec2(12,19), ImVec2( 0, 0) }, // ImGuiMouseCursor_Arrow
    { ImVec2(13,0), ImVec2( 7,16), ImVec2( 1, 8) }, // ImGuiMouseCursor_TextInput
    { ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_ResizeAll
    { ImVec2(21,0), ImVec2( 9,23), ImVec2( 4,11) }, // ImGuiMouseCursor_ResizeNS
    { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW
    { ImVec2(73,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNESW
    { ImVec2(55,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNWSE
    { ImVec2(91,0), ImVec2(17,22), ImVec2( 5, 0) }, // ImGuiMouseCursor_Hand
};

ImFontAtlas::ImFontAtlas()
{
    Locked = false;
    Flags = ImFontAtlasFlags_None;
    TexID = (ImTextureID)NULL;
    TexDesiredWidth = 0;
    TexGlyphPadding = 1;

    TexPixelsAlpha8 = NULL;
    TexPixelsRGBA32 = NULL;
    TexWidth = TexHeight = 0;
    TexUvScale = ImVec2(0.0f, 0.0f);
    TexUvWhitePixel = ImVec2(0.0f, 0.0f);
    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)
        CustomRectIds[n] = -1;
}

ImFontAtlas::~ImFontAtlas()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    Clear();
}

void    ImFontAtlas::ClearInputData()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    for (int i = 0; i < ConfigData.Size; i++)
        if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)
        {
            ImGui::MemFree(ConfigData[i].FontData);
            ConfigData[i].FontData = NULL;
        }

    // When clearing this we lose access to the font name and other information used to build the font.
    for (int i = 0; i < Fonts.Size; i++)
        if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)
        {
            Fonts[i]->ConfigData = NULL;
            Fonts[i]->ConfigDataCount = 0;
        }
    ConfigData.clear();
    CustomRects.clear();
    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)
        CustomRectIds[n] = -1;
}

void    ImFontAtlas::ClearTexData()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    if (TexPixelsAlpha8)
        ImGui::MemFree(TexPixelsAlpha8);
    if (TexPixelsRGBA32)
        ImGui::MemFree(TexPixelsRGBA32);
    TexPixelsAlpha8 = NULL;
    TexPixelsRGBA32 = NULL;
}

void    ImFontAtlas::ClearFonts()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    for (int i = 0; i < Fonts.Size; i++)
        IM_DELETE(Fonts[i]);
    Fonts.clear();
}

void    ImFontAtlas::Clear()
{
    ClearInputData();
    ClearTexData();
    ClearFonts();
}

void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
{
    // Build atlas on demand
    if (TexPixelsAlpha8 == NULL)
    {
        if (ConfigData.empty())
            AddFontDefault();
        Build();
    }

    *out_pixels = TexPixelsAlpha8;
    if (out_width) *out_width = TexWidth;
    if (out_height) *out_height = TexHeight;
    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
}

void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
{
    // Convert to RGBA32 format on demand
    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
    if (!TexPixelsRGBA32)
    {
        unsigned char* pixels = NULL;
        GetTexDataAsAlpha8(&pixels, NULL, NULL);
        if (pixels)
        {
            TexPixelsRGBA32 = (unsigned int*)ImGui::MemAlloc((size_t)(TexWidth * TexHeight * 4));
            const unsigned char* src = pixels;
            unsigned int* dst = TexPixelsRGBA32;
            for (int n = TexWidth * TexHeight; n > 0; n--)
                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
        }
    }

    *out_pixels = (unsigned char*)TexPixelsRGBA32;
    if (out_width) *out_width = TexWidth;
    if (out_height) *out_height = TexHeight;
    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
}

ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
    IM_ASSERT(font_cfg->SizePixels > 0.0f);

    // Create new font
    if (!font_cfg->MergeMode)
        Fonts.push_back(IM_NEW(ImFont));
    else
        IM_ASSERT(!Fonts.empty()); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.

    ConfigData.push_back(*font_cfg);
    ImFontConfig& new_font_cfg = ConfigData.back();
    if (!new_font_cfg.DstFont)
        new_font_cfg.DstFont = Fonts.back();
    if (!new_font_cfg.FontDataOwnedByAtlas)
    {
        new_font_cfg.FontData = ImGui::MemAlloc(new_font_cfg.FontDataSize);
        new_font_cfg.FontDataOwnedByAtlas = true;
        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
    }

    // Invalidate texture
    ClearTexData();
    return new_font_cfg.DstFont;
}

// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)
static unsigned int stb_decompress_length(const unsigned char *input);
static unsigned int stb_decompress(unsigned char *output, const unsigned char *input, unsigned int length);
static const char*  GetDefaultCompressedFontDataTTFBase85();
static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }
static void         Decode85(const unsigned char* src, unsigned char* dst)
{
    while (*src)
    {
        unsigned int tmp = Decode85Byte(src[0]) + 85*(Decode85Byte(src[1]) + 85*(Decode85Byte(src[2]) + 85*(Decode85Byte(src[3]) + 85*Decode85Byte(src[4]))));
        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
        src += 5;
        dst += 4;
    }
}

// Load embedded ProggyClean.ttf at size 13, disable oversampling
ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)
{
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    if (!font_cfg_template)
    {
        font_cfg.OversampleH = font_cfg.OversampleV = 1;
        font_cfg.PixelSnapH = true;
    }
    if (font_cfg.Name[0] == '\0') strcpy(font_cfg.Name, "ProggyClean.ttf, 13px");
    if (font_cfg.SizePixels <= 0.0f) font_cfg.SizePixels = 13.0f;

    const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
    ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
    font->DisplayOffset.y = 1.0f;
    return font;
}

ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    size_t data_size = 0;
    void* data = ImFileLoadToMemory(filename, "rb", &data_size, 0);
    if (!data)
    {
        IM_ASSERT(0); // Could not load file.
        return NULL;
    }
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    if (font_cfg.Name[0] == '\0')
    {
        // Store a short copy of filename into into the font name for convenience
        const char* p;
        for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}
        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);
    }
    return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);
}

// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().
ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    IM_ASSERT(font_cfg.FontData == NULL);
    font_cfg.FontData = ttf_data;
    font_cfg.FontDataSize = ttf_size;
    font_cfg.SizePixels = size_pixels;
    if (glyph_ranges)
        font_cfg.GlyphRanges = glyph_ranges;
    return AddFont(&font_cfg);
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
    unsigned char* buf_decompressed_data = (unsigned char *)ImGui::MemAlloc(buf_decompressed_size);
    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);

    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    IM_ASSERT(font_cfg.FontData == NULL);
    font_cfg.FontDataOwnedByAtlas = true;
    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
{
    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
    void* compressed_ttf = ImGui::MemAlloc((size_t)compressed_ttf_size);
    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
    ImGui::MemFree(compressed_ttf);
    return font;
}

int ImFontAtlas::AddCustomRectRegular(unsigned int id, int width, int height)
{
    IM_ASSERT(id >= 0x10000);
    IM_ASSERT(width > 0 && width <= 0xFFFF);
    IM_ASSERT(height > 0 && height <= 0xFFFF);
    CustomRect r;
    r.ID = id;
    r.Width = (unsigned short)width;
    r.Height = (unsigned short)height;
    CustomRects.push_back(r);
    return CustomRects.Size - 1; // Return index
}

int ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)
{
    IM_ASSERT(font != NULL);
    IM_ASSERT(width > 0 && width <= 0xFFFF);
    IM_ASSERT(height > 0 && height <= 0xFFFF);
    CustomRect r;
    r.ID = id;
    r.Width = (unsigned short)width;
    r.Height = (unsigned short)height;
    r.GlyphAdvanceX = advance_x;
    r.GlyphOffset = offset;
    r.Font = font;
    CustomRects.push_back(r);
    return CustomRects.Size - 1; // Return index
}

void ImFontAtlas::CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max)
{
    IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates
    IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed
    *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);
    *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);
}

bool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])
{
    if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)
        return false;
    if (Flags & ImFontAtlasFlags_NoMouseCursors)
        return false;

    IM_ASSERT(CustomRectIds[0] != -1);
    ImFontAtlas::CustomRect& r = CustomRects[CustomRectIds[0]];
    IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);
    ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r.X, (float)r.Y);
    ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];
    *out_size = size;
    *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];
    out_uv_border[0] = (pos) * TexUvScale;
    out_uv_border[1] = (pos + size) * TexUvScale;
    pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;
    out_uv_fill[0] = (pos) * TexUvScale;
    out_uv_fill[1] = (pos + size) * TexUvScale;
    return true;
}

bool    ImFontAtlas::Build()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    return ImFontAtlasBuildWithStbTruetype(this);
}

void    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)
{
    for (unsigned int i = 0; i < 256; i++)
    {
        unsigned int value = (unsigned int)(i * in_brighten_factor);
        out_table[i] = value > 255 ? 255 : (value & 0xFF);
    }
}

void    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)
{
    unsigned char* data = pixels + x + y * stride;
    for (int j = h; j > 0; j--, data += stride)
        for (int i = 0; i < w; i++)
            data[i] = table[data[i]];
}

bool    ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)
{
    IM_ASSERT(atlas->ConfigData.Size > 0);

    ImFontAtlasBuildRegisterDefaultCustomRects(atlas);

    atlas->TexID = (ImTextureID)NULL;
    atlas->TexWidth = atlas->TexHeight = 0;
    atlas->TexUvScale = ImVec2(0.0f, 0.0f);
    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
    atlas->ClearTexData();

    // Count glyphs/ranges
    int total_glyphs_count = 0;
    int total_ranges_count = 0;
    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)
    {
        ImFontConfig& cfg = atlas->ConfigData[input_i];
        if (!cfg.GlyphRanges)
            cfg.GlyphRanges = atlas->GetGlyphRangesDefault();
        for (const ImWchar* in_range = cfg.GlyphRanges; in_range[0] && in_range[1]; in_range += 2, total_ranges_count++)
            total_glyphs_count += (in_range[1] - in_range[0]) + 1;
    }

    // We need a width for the skyline algorithm. Using a dumb heuristic here to decide of width. User can override TexDesiredWidth and TexGlyphPadding if they wish.
    // Width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
    atlas->TexWidth = (atlas->TexDesiredWidth > 0) ? atlas->TexDesiredWidth : (total_glyphs_count > 4000) ? 4096 : (total_glyphs_count > 2000) ? 2048 : (total_glyphs_count > 1000) ? 1024 : 512;
    atlas->TexHeight = 0;

    // LoopCallback packing
    const int max_tex_height = 1024*32;
    stbtt_pack_context spc = {};
    if (!stbtt_PackBegin(&spc, NULL, atlas->TexWidth, max_tex_height, 0, atlas->TexGlyphPadding, NULL))
        return false;
    stbtt_PackSetOversampling(&spc, 1, 1);

    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);

    // Initialize font information (so we can error without any cleanup)
    struct ImFontTempBuildData
    {
        stbtt_fontinfo      FontInfo;
        stbrp_rect*         Rects;
        int                 RectsCount;
        stbtt_pack_range*   Ranges;
        int                 RangesCount;
    };
    ImFontTempBuildData* tmp_array = (ImFontTempBuildData*)ImGui::MemAlloc((size_t)atlas->ConfigData.Size * sizeof(ImFontTempBuildData));
    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)
    {
        ImFontConfig& cfg = atlas->ConfigData[input_i];
        ImFontTempBuildData& tmp = tmp_array[input_i];
        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));

        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
        IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
        if (!stbtt_InitFont(&tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
        {
            atlas->TexWidth = atlas->TexHeight = 0; // Reset output on failure
            ImGui::MemFree(tmp_array);
            return false;
        }
    }

    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
    int buf_packedchars_n = 0, buf_rects_n = 0, buf_ranges_n = 0;
    stbtt_packedchar* buf_packedchars = (stbtt_packedchar*)ImGui::MemAlloc(total_glyphs_count * sizeof(stbtt_packedchar));
    stbrp_rect* buf_rects = (stbrp_rect*)ImGui::MemAlloc(total_glyphs_count * sizeof(stbrp_rect));
    stbtt_pack_range* buf_ranges = (stbtt_pack_range*)ImGui::MemAlloc(total_ranges_count * sizeof(stbtt_pack_range));
    memset(buf_packedchars, 0, total_glyphs_count * sizeof(stbtt_packedchar));
    memset(buf_rects, 0, total_glyphs_count * sizeof(stbrp_rect));              // Unnecessary but let's clear this for the sake of sanity.
    memset(buf_ranges, 0, total_ranges_count * sizeof(stbtt_pack_range));

    // First font pass: pack all glyphs (no rendering at this point, we are working with rectangles in an infinitely tall texture at this point)
    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)
    {
        ImFontConfig& cfg = atlas->ConfigData[input_i];
        ImFontTempBuildData& tmp = tmp_array[input_i];

        // Setup ranges
        int font_glyphs_count = 0;
        int font_ranges_count = 0;
        for (const ImWchar* in_range = cfg.GlyphRanges; in_range[0] && in_range[1]; in_range += 2, font_ranges_count++)
            font_glyphs_count += (in_range[1] - in_range[0]) + 1;
        tmp.Ranges = buf_ranges + buf_ranges_n;
        tmp.RangesCount = font_ranges_count;
        buf_ranges_n += font_ranges_count;
        for (int i = 0; i < font_ranges_count; i++)
        {
            const ImWchar* in_range = &cfg.GlyphRanges[i * 2];
            stbtt_pack_range& range = tmp.Ranges[i];
            range.font_size = cfg.SizePixels;
            range.first_unicode_codepoint_in_range = in_range[0];
            range.num_chars = (in_range[1] - in_range[0]) + 1;
            range.chardata_for_range = buf_packedchars + buf_packedchars_n;
            buf_packedchars_n += range.num_chars;
        }

        // Gather the sizes of all rectangle we need
        tmp.Rects = buf_rects + buf_rects_n;
        tmp.RectsCount = font_glyphs_count;
        buf_rects_n += font_glyphs_count;
        stbtt_PackSetOversampling(&spc, cfg.OversampleH, cfg.OversampleV);
        int n = stbtt_PackFontRangesGatherRects(&spc, &tmp.FontInfo, tmp.Ranges, tmp.RangesCount, tmp.Rects);
        IM_ASSERT(n == font_glyphs_count);

        // Detect missing glyphs and replace them with a zero-sized box instead of relying on the default glyphs
        // This allows us merging overlapping icon fonts more easily.
        int rect_i = 0;
        for (int range_i = 0; range_i < tmp.RangesCount; range_i++)
            for (int char_i = 0; char_i < tmp.Ranges[range_i].num_chars; char_i++, rect_i++)
                if (stbtt_FindGlyphIndex(&tmp.FontInfo, tmp.Ranges[range_i].first_unicode_codepoint_in_range + char_i) == 0)
                    tmp.Rects[rect_i].w = tmp.Rects[rect_i].h = 0;

        // Pack
        stbrp_pack_rects((stbrp_context*)spc.pack_info, tmp.Rects, n);

        // Extend texture height
        // Also mark missing glyphs as non-packed so we don't attempt to render into them
        for (int i = 0; i < n; i++)
        {
            if (tmp.Rects[i].w == 0 && tmp.Rects[i].h == 0)
                tmp.Rects[i].was_packed = 0;
            if (tmp.Rects[i].was_packed)
                atlas->TexHeight = ImMax(atlas->TexHeight, tmp.Rects[i].y + tmp.Rects[i].h);
        }
    }
    IM_ASSERT(buf_rects_n == total_glyphs_count);
    IM_ASSERT(buf_packedchars_n == total_glyphs_count);
    IM_ASSERT(buf_ranges_n == total_ranges_count);

    // Create texture
    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
    atlas->TexPixelsAlpha8 = (unsigned char*)ImGui::MemAlloc(atlas->TexWidth * atlas->TexHeight);
    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
    spc.pixels = atlas->TexPixelsAlpha8;
    spc.height = atlas->TexHeight;

    // Second pass: render font characters
    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)
    {
        ImFontConfig& cfg = atlas->ConfigData[input_i];
        ImFontTempBuildData& tmp = tmp_array[input_i];
        stbtt_PackSetOversampling(&spc, cfg.OversampleH, cfg.OversampleV);
        stbtt_PackFontRangesRenderIntoRects(&spc, &tmp.FontInfo, tmp.Ranges, tmp.RangesCount, tmp.Rects);
        if (cfg.RasterizerMultiply != 1.0f)
        {
            unsigned char multiply_table[256];
            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
            for (const stbrp_rect* r = tmp.Rects; r != tmp.Rects + tmp.RectsCount; r++)
                if (r->was_packed)
                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, spc.pixels, r->x, r->y, r->w, r->h, spc.stride_in_bytes);
        }
        tmp.Rects = NULL;
    }

    // End packing
    stbtt_PackEnd(&spc);
    ImGui::MemFree(buf_rects);
    buf_rects = NULL;

    // Third pass: setup ImFont and glyphs for runtime
    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)
    {
        ImFontConfig& cfg = atlas->ConfigData[input_i];
        ImFontTempBuildData& tmp = tmp_array[input_i];
        ImFont* dst_font = cfg.DstFont; // We can have multiple input fonts writing into a same destination font (when using MergeMode=true)
        if (cfg.MergeMode)
            dst_font->BuildLookupTable();

        const float font_scale = stbtt_ScaleForPixelHeight(&tmp.FontInfo, cfg.SizePixels);
        int unscaled_ascent, unscaled_descent, unscaled_line_gap;
        stbtt_GetFontVMetrics(&tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);

        const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));
        const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));
        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
        const float font_off_x = cfg.GlyphOffset.x;
        const float font_off_y = cfg.GlyphOffset.y + (float)(int)(dst_font->Ascent + 0.5f);

        for (int i = 0; i < tmp.RangesCount; i++)
        {
            stbtt_pack_range& range = tmp.Ranges[i];
            for (int char_idx = 0; char_idx < range.num_chars; char_idx += 1)
            {
                const stbtt_packedchar& pc = range.chardata_for_range[char_idx];
                if (!pc.x0 && !pc.x1 && !pc.y0 && !pc.y1)
                    continue;

                const int codepoint = range.first_unicode_codepoint_in_range + char_idx;
                if (cfg.MergeMode && dst_font->FindGlyphNoFallback((ImWchar)codepoint))
                    continue;

                float char_advance_x_org = pc.xadvance;
                float char_advance_x_mod = ImClamp(char_advance_x_org, cfg.GlyphMinAdvanceX, cfg.GlyphMaxAdvanceX);
                float char_off_x = font_off_x;
                if (char_advance_x_org != char_advance_x_mod)
                    char_off_x += cfg.PixelSnapH ? (float)(int)((char_advance_x_mod - char_advance_x_org) * 0.5f) : (char_advance_x_mod - char_advance_x_org) * 0.5f;

                stbtt_aligned_quad q;
                float dummy_x = 0.0f, dummy_y = 0.0f;
                stbtt_GetPackedQuad(range.chardata_for_range, atlas->TexWidth, atlas->TexHeight, char_idx, &dummy_x, &dummy_y, &q, 0);
                dst_font->AddGlyph((ImWchar)codepoint, q.x0 + char_off_x, q.y0 + font_off_y, q.x1 + char_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, char_advance_x_mod);
            }
        }
    }

    // Cleanup temporaries
    ImGui::MemFree(buf_packedchars);
    ImGui::MemFree(buf_ranges);
    ImGui::MemFree(tmp_array);

    ImFontAtlasBuildFinish(atlas);

    return true;
}

void ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas)
{
    if (atlas->CustomRectIds[0] >= 0)
        return;
    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
        atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF*2+1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
    else
        atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, 2, 2);
}

void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)
{
    if (!font_config->MergeMode)
    {
        font->ClearOutputData();
        font->FontSize = font_config->SizePixels;
        font->ConfigData = font_config;
        font->ContainerAtlas = atlas;
        font->Ascent = ascent;
        font->Descent = descent;
    }
    font->ConfigDataCount++;
}

void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* pack_context_opaque)
{
    stbrp_context* pack_context = (stbrp_context*)pack_context_opaque;

    ImVector<ImFontAtlas::CustomRect>& user_rects = atlas->CustomRects;
    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.

    ImVector<stbrp_rect> pack_rects;
    pack_rects.resize(user_rects.Size);
    memset(pack_rects.Data, 0, sizeof(stbrp_rect) * user_rects.Size);
    for (int i = 0; i < user_rects.Size; i++)
    {
        pack_rects[i].w = user_rects[i].Width;
        pack_rects[i].h = user_rects[i].Height;
    }
    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
    for (int i = 0; i < pack_rects.Size; i++)
        if (pack_rects[i].was_packed)
        {
            user_rects[i].X = pack_rects[i].x;
            user_rects[i].Y = pack_rects[i].y;
            IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
        }
}

static void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)
{
    IM_ASSERT(atlas->CustomRectIds[0] >= 0);
    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL);
    ImFontAtlas::CustomRect& r = atlas->CustomRects[atlas->CustomRectIds[0]];
    IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);
    IM_ASSERT(r.IsPacked());

    const int w = atlas->TexWidth;
    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
    {
        // Render/copy pixels
        IM_ASSERT(r.Width == FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1 && r.Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
        for (int y = 0, n = 0; y < FONT_ATLAS_DEFAULT_TEX_DATA_H; y++)
            for (int x = 0; x < FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF; x++, n++)
            {
                const int offset0 = (int)(r.X + x) + (int)(r.Y + y) * w;
                const int offset1 = offset0 + FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;
                atlas->TexPixelsAlpha8[offset0] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == '.' ? 0xFF : 0x00;
                atlas->TexPixelsAlpha8[offset1] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == 'X' ? 0xFF : 0x00;
            }
    }
    else
    {
        IM_ASSERT(r.Width == 2 && r.Height == 2);
        const int offset = (int)(r.X) + (int)(r.Y) * w;
        atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
    }
    atlas->TexUvWhitePixel = ImVec2((r.X + 0.5f) * atlas->TexUvScale.x, (r.Y + 0.5f) * atlas->TexUvScale.y);
}

void ImFontAtlasBuildFinish(ImFontAtlas* atlas)
{
    // Render into our custom data block
    ImFontAtlasBuildRenderDefaultTexData(atlas);

    // Register custom rectangle glyphs
    for (int i = 0; i < atlas->CustomRects.Size; i++)
    {
        const ImFontAtlas::CustomRect& r = atlas->CustomRects[i];
        if (r.Font == NULL || r.ID > 0x10000)
            continue;

        IM_ASSERT(r.Font->ContainerAtlas == atlas);
        ImVec2 uv0, uv1;
        atlas->CalcCustomRectUV(&r, &uv0, &uv1);
        r.Font->AddGlyph((ImWchar)r.ID, r.GlyphOffset.x, r.GlyphOffset.y, r.GlyphOffset.x + r.Width, r.GlyphOffset.y + r.Height, uv0.x, uv0.y, uv1.x, uv1.y, r.GlyphAdvanceX);
    }

    // Build all fonts lookup tables
    for (int i = 0; i < atlas->Fonts.Size; i++)
        if (atlas->Fonts[i]->DirtyLookupTables)
            atlas->Fonts[i]->BuildLookupTable();
}

// Retrieve list of range (2 int per range, values are inclusive)
const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesKorean()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x3131, 0x3163, // Korean alphabets
        0xAC00, 0xD79D, // Korean characters
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesChineseFull()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x3000, 0x30FF, // Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF, // Half-width characters
        0x4e00, 0x9FAF, // CJK Ideograms
        0,
    };
    return &ranges[0];
}

static void UnpackAccumulativeOffsetsIntoRanges(int base_codepoint, const short* accumulative_offsets, int accumulative_offsets_count, ImWchar* out_ranges)
{
    for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2)
    {
        out_ranges[0] = out_ranges[1] = (ImWchar)(base_codepoint + accumulative_offsets[n]);
        base_codepoint += accumulative_offsets[n];
    }
    out_ranges[0] = 0;
}

//-------------------------------------------------------------------------
// [SECTION] ImFontAtlas glyph ranges helpers + GlyphRangesBuilder
//-------------------------------------------------------------------------

const ImWchar*  ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon()
{
    // Store 2500 regularly used characters for Simplified Chinese.
    // Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
    // This table covers 97.97% of all characters used during the month in July, 1987.
    // You can use ImFontAtlas::GlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
    static const short accumulative_offsets_from_0x4E00[] =
    {
        0,1,2,4,1,1,1,1,2,1,3,2,1,2,2,1,1,1,1,1,5,2,1,2,3,3,3,2,2,4,1,1,1,2,1,5,2,3,1,2,1,2,1,1,2,1,1,2,2,1,4,1,1,1,1,5,10,1,2,19,2,1,2,1,2,1,2,1,2,
        1,5,1,6,3,2,1,2,2,1,1,1,4,8,5,1,1,4,1,1,3,1,2,1,5,1,2,1,1,1,10,1,1,5,2,4,6,1,4,2,2,2,12,2,1,1,6,1,1,1,4,1,1,4,6,5,1,4,2,2,4,10,7,1,1,4,2,4,
        2,1,4,3,6,10,12,5,7,2,14,2,9,1,1,6,7,10,4,7,13,1,5,4,8,4,1,1,2,28,5,6,1,1,5,2,5,20,2,2,9,8,11,2,9,17,1,8,6,8,27,4,6,9,20,11,27,6,68,2,2,1,1,
        1,2,1,2,2,7,6,11,3,3,1,1,3,1,2,1,1,1,1,1,3,1,1,8,3,4,1,5,7,2,1,4,4,8,4,2,1,2,1,1,4,5,6,3,6,2,12,3,1,3,9,2,4,3,4,1,5,3,3,1,3,7,1,5,1,1,1,1,2,
        3,4,5,2,3,2,6,1,1,2,1,7,1,7,3,4,5,15,2,2,1,5,3,22,19,2,1,1,1,1,2,5,1,1,1,6,1,1,12,8,2,9,18,22,4,1,1,5,1,16,1,2,7,10,15,1,1,6,2,4,1,2,4,1,6,
        1,1,3,2,4,1,6,4,5,1,2,1,1,2,1,10,3,1,3,2,1,9,3,2,5,7,2,19,4,3,6,1,1,1,1,1,4,3,2,1,1,1,2,5,3,1,1,1,2,2,1,1,2,1,1,2,1,3,1,1,1,3,7,1,4,1,1,2,1,
        1,2,1,2,4,4,3,8,1,1,1,2,1,3,5,1,3,1,3,4,6,2,2,14,4,6,6,11,9,1,15,3,1,28,5,2,5,5,3,1,3,4,5,4,6,14,3,2,3,5,21,2,7,20,10,1,2,19,2,4,28,28,2,3,
        2,1,14,4,1,26,28,42,12,40,3,52,79,5,14,17,3,2,2,11,3,4,6,3,1,8,2,23,4,5,8,10,4,2,7,3,5,1,1,6,3,1,2,2,2,5,28,1,1,7,7,20,5,3,29,3,17,26,1,8,4,
        27,3,6,11,23,5,3,4,6,13,24,16,6,5,10,25,35,7,3,2,3,3,14,3,6,2,6,1,4,2,3,8,2,1,1,3,3,3,4,1,1,13,2,2,4,5,2,1,14,14,1,2,2,1,4,5,2,3,1,14,3,12,
        3,17,2,16,5,1,2,1,8,9,3,19,4,2,2,4,17,25,21,20,28,75,1,10,29,103,4,1,2,1,1,4,2,4,1,2,3,24,2,2,2,1,1,2,1,3,8,1,1,1,2,1,1,3,1,1,1,6,1,5,3,1,1,
        1,3,4,1,1,5,2,1,5,6,13,9,16,1,1,1,1,3,2,3,2,4,5,2,5,2,2,3,7,13,7,2,2,1,1,1,1,2,3,3,2,1,6,4,9,2,1,14,2,14,2,1,18,3,4,14,4,11,41,15,23,15,23,
        176,1,3,4,1,1,1,1,5,3,1,2,3,7,3,1,1,2,1,2,4,4,6,2,4,1,9,7,1,10,5,8,16,29,1,1,2,2,3,1,3,5,2,4,5,4,1,1,2,2,3,3,7,1,6,10,1,17,1,44,4,6,2,1,1,6,
        5,4,2,10,1,6,9,2,8,1,24,1,2,13,7,8,8,2,1,4,1,3,1,3,3,5,2,5,10,9,4,9,12,2,1,6,1,10,1,1,7,7,4,10,8,3,1,13,4,3,1,6,1,3,5,2,1,2,17,16,5,2,16,6,
        1,4,2,1,3,3,6,8,5,11,11,1,3,3,2,4,6,10,9,5,7,4,7,4,7,1,1,4,2,1,3,6,8,7,1,6,11,5,5,3,24,9,4,2,7,13,5,1,8,82,16,61,1,1,1,4,2,2,16,10,3,8,1,1,
        6,4,2,1,3,1,1,1,4,3,8,4,2,2,1,1,1,1,1,6,3,5,1,1,4,6,9,2,1,1,1,2,1,7,2,1,6,1,5,4,4,3,1,8,1,3,3,1,3,2,2,2,2,3,1,6,1,2,1,2,1,3,7,1,8,2,1,2,1,5,
        2,5,3,5,10,1,2,1,1,3,2,5,11,3,9,3,5,1,1,5,9,1,2,1,5,7,9,9,8,1,3,3,3,6,8,2,3,2,1,1,32,6,1,2,15,9,3,7,13,1,3,10,13,2,14,1,13,10,2,1,3,10,4,15,
        2,15,15,10,1,3,9,6,9,32,25,26,47,7,3,2,3,1,6,3,4,3,2,8,5,4,1,9,4,2,2,19,10,6,2,3,8,1,2,2,4,2,1,9,4,4,4,6,4,8,9,2,3,1,1,1,1,3,5,5,1,3,8,4,6,
        2,1,4,12,1,5,3,7,13,2,5,8,1,6,1,2,5,14,6,1,5,2,4,8,15,5,1,23,6,62,2,10,1,1,8,1,2,2,10,4,2,2,9,2,1,1,3,2,3,1,5,3,3,2,1,3,8,1,1,1,11,3,1,1,4,
        3,7,1,14,1,2,3,12,5,2,5,1,6,7,5,7,14,11,1,3,1,8,9,12,2,1,11,8,4,4,2,6,10,9,13,1,1,3,1,5,1,3,2,4,4,1,18,2,3,14,11,4,29,4,2,7,1,3,13,9,2,2,5,
        3,5,20,7,16,8,5,72,34,6,4,22,12,12,28,45,36,9,7,39,9,191,1,1,1,4,11,8,4,9,2,3,22,1,1,1,1,4,17,1,7,7,1,11,31,10,2,4,8,2,3,2,1,4,2,16,4,32,2,
        3,19,13,4,9,1,5,2,14,8,1,1,3,6,19,6,5,1,16,6,2,10,8,5,1,2,3,1,5,5,1,11,6,6,1,3,3,2,6,3,8,1,1,4,10,7,5,7,7,5,8,9,2,1,3,4,1,1,3,1,3,3,2,6,16,
        1,4,6,3,1,10,6,1,3,15,2,9,2,10,25,13,9,16,6,2,2,10,11,4,3,9,1,2,6,6,5,4,30,40,1,10,7,12,14,33,6,3,6,7,3,1,3,1,11,14,4,9,5,12,11,49,18,51,31,
        140,31,2,2,1,5,1,8,1,10,1,4,4,3,24,1,10,1,3,6,6,16,3,4,5,2,1,4,2,57,10,6,22,2,22,3,7,22,6,10,11,36,18,16,33,36,2,5,5,1,1,1,4,10,1,4,13,2,7,
        5,2,9,3,4,1,7,43,3,7,3,9,14,7,9,1,11,1,1,3,7,4,18,13,1,14,1,3,6,10,73,2,2,30,6,1,11,18,19,13,22,3,46,42,37,89,7,3,16,34,2,2,3,9,1,7,1,1,1,2,
        2,4,10,7,3,10,3,9,5,28,9,2,6,13,7,3,1,3,10,2,7,2,11,3,6,21,54,85,2,1,4,2,2,1,39,3,21,2,2,5,1,1,1,4,1,1,3,4,15,1,3,2,4,4,2,3,8,2,20,1,8,7,13,
        4,1,26,6,2,9,34,4,21,52,10,4,4,1,5,12,2,11,1,7,2,30,12,44,2,30,1,1,3,6,16,9,17,39,82,2,2,24,7,1,7,3,16,9,14,44,2,1,2,1,2,3,5,2,4,1,6,7,5,3,
        2,6,1,11,5,11,2,1,18,19,8,1,3,24,29,2,1,3,5,2,2,1,13,6,5,1,46,11,3,5,1,1,5,8,2,10,6,12,6,3,7,11,2,4,16,13,2,5,1,1,2,2,5,2,28,5,2,23,10,8,4,
        4,22,39,95,38,8,14,9,5,1,13,5,4,3,13,12,11,1,9,1,27,37,2,5,4,4,63,211,95,2,2,2,1,3,5,2,1,1,2,2,1,1,1,3,2,4,1,2,1,1,5,2,2,1,1,2,3,1,3,1,1,1,
        3,1,4,2,1,3,6,1,1,3,7,15,5,3,2,5,3,9,11,4,2,22,1,6,3,8,7,1,4,28,4,16,3,3,25,4,4,27,27,1,4,1,2,2,7,1,3,5,2,28,8,2,14,1,8,6,16,25,3,3,3,14,3,
        3,1,1,2,1,4,6,3,8,4,1,1,1,2,3,6,10,6,2,3,18,3,2,5,5,4,3,1,5,2,5,4,23,7,6,12,6,4,17,11,9,5,1,1,10,5,12,1,1,11,26,33,7,3,6,1,17,7,1,5,12,1,11,
        2,4,1,8,14,17,23,1,2,1,7,8,16,11,9,6,5,2,6,4,16,2,8,14,1,11,8,9,1,1,1,9,25,4,11,19,7,2,15,2,12,8,52,7,5,19,2,16,4,36,8,1,16,8,24,26,4,6,2,9,
        5,4,36,3,28,12,25,15,37,27,17,12,59,38,5,32,127,1,2,9,17,14,4,1,2,1,1,8,11,50,4,14,2,19,16,4,17,5,4,5,26,12,45,2,23,45,104,30,12,8,3,10,2,2,
        3,3,1,4,20,7,2,9,6,15,2,20,1,3,16,4,11,15,6,134,2,5,59,1,2,2,2,1,9,17,3,26,137,10,211,59,1,2,4,1,4,1,1,1,2,6,2,3,1,1,2,3,2,3,1,3,4,4,2,3,3,
        1,4,3,1,7,2,2,3,1,2,1,3,3,3,2,2,3,2,1,3,14,6,1,3,2,9,6,15,27,9,34,145,1,1,2,1,1,1,1,2,1,1,1,1,2,2,2,3,1,2,1,1,1,2,3,5,8,3,5,2,4,1,3,2,2,2,12,
        4,1,1,1,10,4,5,1,20,4,16,1,15,9,5,12,2,9,2,5,4,2,26,19,7,1,26,4,30,12,15,42,1,6,8,172,1,1,4,2,1,1,11,2,2,4,2,1,2,1,10,8,1,2,1,4,5,1,2,5,1,8,
        4,1,3,4,2,1,6,2,1,3,4,1,2,1,1,1,1,12,5,7,2,4,3,1,1,1,3,3,6,1,2,2,3,3,3,2,1,2,12,14,11,6,6,4,12,2,8,1,7,10,1,35,7,4,13,15,4,3,23,21,28,52,5,
        26,5,6,1,7,10,2,7,53,3,2,1,1,1,2,163,532,1,10,11,1,3,3,4,8,2,8,6,2,2,23,22,4,2,2,4,2,1,3,1,3,3,5,9,8,2,1,2,8,1,10,2,12,21,20,15,105,2,3,1,1,
        3,2,3,1,1,2,5,1,4,15,11,19,1,1,1,1,5,4,5,1,1,2,5,3,5,12,1,2,5,1,11,1,1,15,9,1,4,5,3,26,8,2,1,3,1,1,15,19,2,12,1,2,5,2,7,2,19,2,20,6,26,7,5,
        2,2,7,34,21,13,70,2,128,1,1,2,1,1,2,1,1,3,2,2,2,15,1,4,1,3,4,42,10,6,1,49,85,8,1,2,1,1,4,4,2,3,6,1,5,7,4,3,211,4,1,2,1,2,5,1,2,4,2,2,6,5,6,
        10,3,4,48,100,6,2,16,296,5,27,387,2,2,3,7,16,8,5,38,15,39,21,9,10,3,7,59,13,27,21,47,5,21,6
    };
    static ImWchar base_ranges[] = // not zero-terminated
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x3000, 0x30FF, // Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF, // Half-width characters
    };
    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };
    if (!full_ranges[0])
    {
        memcpy(full_ranges, base_ranges, sizeof(base_ranges));
        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
    }
    return &full_ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()
{
    // 1946 common ideograms code points for Japanese
    // Sourced from http://theinstructionlimit.com/common-kanji-character-ranges-for-xna-spritefont-rendering
    // FIXME: Source a list of the revised 2136 Joyo Kanji list from 2010 and rebuild this.
    // You can use ImFontAtlas::GlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
    static const short accumulative_offsets_from_0x4E00[] =
    {
        0,1,2,4,1,1,1,1,2,1,6,2,2,1,8,5,7,11,1,2,10,10,8,2,4,20,2,11,8,2,1,2,1,6,2,1,7,5,3,7,1,1,13,7,9,1,4,6,1,2,1,10,1,1,9,2,2,4,5,6,14,1,1,9,3,18,
        5,4,2,2,10,7,1,1,1,3,2,4,3,23,2,10,12,2,14,2,4,13,1,6,10,3,1,7,13,6,4,13,5,2,3,17,2,2,5,7,6,4,1,7,14,16,6,13,9,15,1,1,7,16,4,7,1,19,9,2,7,15,
        2,6,5,13,25,4,14,13,11,25,1,1,1,2,1,2,2,3,10,11,3,3,1,1,4,4,2,1,4,9,1,4,3,5,5,2,7,12,11,15,7,16,4,5,16,2,1,1,6,3,3,1,1,2,7,6,6,7,1,4,7,6,1,1,
        2,1,12,3,3,9,5,8,1,11,1,2,3,18,20,4,1,3,6,1,7,3,5,5,7,2,2,12,3,1,4,2,3,2,3,11,8,7,4,17,1,9,25,1,1,4,2,2,4,1,2,7,1,1,1,3,1,2,6,16,1,2,1,1,3,12,
        20,2,5,20,8,7,6,2,1,1,1,1,6,2,1,2,10,1,1,6,1,3,1,2,1,4,1,12,4,1,3,1,1,1,1,1,10,4,7,5,13,1,15,1,1,30,11,9,1,15,38,14,1,32,17,20,1,9,31,2,21,9,
        4,49,22,2,1,13,1,11,45,35,43,55,12,19,83,1,3,2,3,13,2,1,7,3,18,3,13,8,1,8,18,5,3,7,25,24,9,24,40,3,17,24,2,1,6,2,3,16,15,6,7,3,12,1,9,7,3,3,
        3,15,21,5,16,4,5,12,11,11,3,6,3,2,31,3,2,1,1,23,6,6,1,4,2,6,5,2,1,1,3,3,22,2,6,2,3,17,3,2,4,5,1,9,5,1,1,6,15,12,3,17,2,14,2,8,1,23,16,4,2,23,
        8,15,23,20,12,25,19,47,11,21,65,46,4,3,1,5,6,1,2,5,26,2,1,1,3,11,1,1,1,2,1,2,3,1,1,10,2,3,1,1,1,3,6,3,2,2,6,6,9,2,2,2,6,2,5,10,2,4,1,2,1,2,2,
        3,1,1,3,1,2,9,23,9,2,1,1,1,1,5,3,2,1,10,9,6,1,10,2,31,25,3,7,5,40,1,15,6,17,7,27,180,1,3,2,2,1,1,1,6,3,10,7,1,3,6,17,8,6,2,2,1,3,5,5,8,16,14,
        15,1,1,4,1,2,1,1,1,3,2,7,5,6,2,5,10,1,4,2,9,1,1,11,6,1,44,1,3,7,9,5,1,3,1,1,10,7,1,10,4,2,7,21,15,7,2,5,1,8,3,4,1,3,1,6,1,4,2,1,4,10,8,1,4,5,
        1,5,10,2,7,1,10,1,1,3,4,11,10,29,4,7,3,5,2,3,33,5,2,19,3,1,4,2,6,31,11,1,3,3,3,1,8,10,9,12,11,12,8,3,14,8,6,11,1,4,41,3,1,2,7,13,1,5,6,2,6,12,
        12,22,5,9,4,8,9,9,34,6,24,1,1,20,9,9,3,4,1,7,2,2,2,6,2,28,5,3,6,1,4,6,7,4,2,1,4,2,13,6,4,4,3,1,8,8,3,2,1,5,1,2,2,3,1,11,11,7,3,6,10,8,6,16,16,
        22,7,12,6,21,5,4,6,6,3,6,1,3,2,1,2,8,29,1,10,1,6,13,6,6,19,31,1,13,4,4,22,17,26,33,10,4,15,12,25,6,67,10,2,3,1,6,10,2,6,2,9,1,9,4,4,1,2,16,2,
        5,9,2,3,8,1,8,3,9,4,8,6,4,8,11,3,2,1,1,3,26,1,7,5,1,11,1,5,3,5,2,13,6,39,5,1,5,2,11,6,10,5,1,15,5,3,6,19,21,22,2,4,1,6,1,8,1,4,8,2,4,2,2,9,2,
        1,1,1,4,3,6,3,12,7,1,14,2,4,10,2,13,1,17,7,3,2,1,3,2,13,7,14,12,3,1,29,2,8,9,15,14,9,14,1,3,1,6,5,9,11,3,38,43,20,7,7,8,5,15,12,19,15,81,8,7,
        1,5,73,13,37,28,8,8,1,15,18,20,165,28,1,6,11,8,4,14,7,15,1,3,3,6,4,1,7,14,1,1,11,30,1,5,1,4,14,1,4,2,7,52,2,6,29,3,1,9,1,21,3,5,1,26,3,11,14,
        11,1,17,5,1,2,1,3,2,8,1,2,9,12,1,1,2,3,8,3,24,12,7,7,5,17,3,3,3,1,23,10,4,4,6,3,1,16,17,22,3,10,21,16,16,6,4,10,2,1,1,2,8,8,6,5,3,3,3,39,25,
        15,1,1,16,6,7,25,15,6,6,12,1,22,13,1,4,9,5,12,2,9,1,12,28,8,3,5,10,22,60,1,2,40,4,61,63,4,1,13,12,1,4,31,12,1,14,89,5,16,6,29,14,2,5,49,18,18,
        5,29,33,47,1,17,1,19,12,2,9,7,39,12,3,7,12,39,3,1,46,4,12,3,8,9,5,31,15,18,3,2,2,66,19,13,17,5,3,46,124,13,57,34,2,5,4,5,8,1,1,1,4,3,1,17,5,
        3,5,3,1,8,5,6,3,27,3,26,7,12,7,2,17,3,7,18,78,16,4,36,1,2,1,6,2,1,39,17,7,4,13,4,4,4,1,10,4,2,4,6,3,10,1,19,1,26,2,4,33,2,73,47,7,3,8,2,4,15,
        18,1,29,2,41,14,1,21,16,41,7,39,25,13,44,2,2,10,1,13,7,1,7,3,5,20,4,8,2,49,1,10,6,1,6,7,10,7,11,16,3,12,20,4,10,3,1,2,11,2,28,9,2,4,7,2,15,1,
        27,1,28,17,4,5,10,7,3,24,10,11,6,26,3,2,7,2,2,49,16,10,16,15,4,5,27,61,30,14,38,22,2,7,5,1,3,12,23,24,17,17,3,3,2,4,1,6,2,7,5,1,1,5,1,1,9,4,
        1,3,6,1,8,2,8,4,14,3,5,11,4,1,3,32,1,19,4,1,13,11,5,2,1,8,6,8,1,6,5,13,3,23,11,5,3,16,3,9,10,1,24,3,198,52,4,2,2,5,14,5,4,22,5,20,4,11,6,41,
        1,5,2,2,11,5,2,28,35,8,22,3,18,3,10,7,5,3,4,1,5,3,8,9,3,6,2,16,22,4,5,5,3,3,18,23,2,6,23,5,27,8,1,33,2,12,43,16,5,2,3,6,1,20,4,2,9,7,1,11,2,
        10,3,14,31,9,3,25,18,20,2,5,5,26,14,1,11,17,12,40,19,9,6,31,83,2,7,9,19,78,12,14,21,76,12,113,79,34,4,1,1,61,18,85,10,2,2,13,31,11,50,6,33,159,
        179,6,6,7,4,4,2,4,2,5,8,7,20,32,22,1,3,10,6,7,28,5,10,9,2,77,19,13,2,5,1,4,4,7,4,13,3,9,31,17,3,26,2,6,6,5,4,1,7,11,3,4,2,1,6,2,20,4,1,9,2,6,
        3,7,1,1,1,20,2,3,1,6,2,3,6,2,4,8,1,5,13,8,4,11,23,1,10,6,2,1,3,21,2,2,4,24,31,4,10,10,2,5,192,15,4,16,7,9,51,1,2,1,1,5,1,1,2,1,3,5,3,1,3,4,1,
        3,1,3,3,9,8,1,2,2,2,4,4,18,12,92,2,10,4,3,14,5,25,16,42,4,14,4,2,21,5,126,30,31,2,1,5,13,3,22,5,6,6,20,12,1,14,12,87,3,19,1,8,2,9,9,3,3,23,2,
        3,7,6,3,1,2,3,9,1,3,1,6,3,2,1,3,11,3,1,6,10,3,2,3,1,2,1,5,1,1,11,3,6,4,1,7,2,1,2,5,5,34,4,14,18,4,19,7,5,8,2,6,79,1,5,2,14,8,2,9,2,1,36,28,16,
        4,1,1,1,2,12,6,42,39,16,23,7,15,15,3,2,12,7,21,64,6,9,28,8,12,3,3,41,59,24,51,55,57,294,9,9,2,6,2,15,1,2,13,38,90,9,9,9,3,11,7,1,1,1,5,6,3,2,
        1,2,2,3,8,1,4,4,1,5,7,1,4,3,20,4,9,1,1,1,5,5,17,1,5,2,6,2,4,1,4,5,7,3,18,11,11,32,7,5,4,7,11,127,8,4,3,3,1,10,1,1,6,21,14,1,16,1,7,1,3,6,9,65,
        51,4,3,13,3,10,1,1,12,9,21,110,3,19,24,1,1,10,62,4,1,29,42,78,28,20,18,82,6,3,15,6,84,58,253,15,155,264,15,21,9,14,7,58,40,39, 
    };
    static ImWchar base_ranges[] = // not zero-terminated
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x3000, 0x30FF, // Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF, // Half-width characters
    };
    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00)*2 + 1] = { 0 };
    if (!full_ranges[0])
    {
        memcpy(full_ranges, base_ranges, sizeof(base_ranges));
        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
    }
    return &full_ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
        0x2DE0, 0x2DFF, // Cyrillic Extended-A
        0xA640, 0xA69F, // Cyrillic Extended-B
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesThai()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin
        0x2010, 0x205E, // Punctuations
        0x0E00, 0x0E7F, // Thai
        0,
    };
    return &ranges[0];
}

void ImFontAtlas::GlyphRangesBuilder::AddText(const char* text, const char* text_end)
{
    while (text_end ? (text < text_end) : *text)
    {
        unsigned int c = 0;
        int c_len = ImTextCharFromUtf8(&c, text, text_end);
        text += c_len;
        if (c_len == 0)
            break;
        if (c < 0x10000)
            AddChar((ImWchar)c);
    }
}

void ImFontAtlas::GlyphRangesBuilder::AddRanges(const ImWchar* ranges)
{
    for (; ranges[0]; ranges += 2)
        for (ImWchar c = ranges[0]; c <= ranges[1]; c++)
            AddChar(c);
}

void ImFontAtlas::GlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)
{
    for (int n = 0; n < 0x10000; n++)
        if (GetBit(n))
        {
            out_ranges->push_back((ImWchar)n);
            while (n < 0x10000 && GetBit(n + 1))
                n++;
            out_ranges->push_back((ImWchar)n);
        }
    out_ranges->push_back(0);
}

//-----------------------------------------------------------------------------
// [SECTION] ImFont
//-----------------------------------------------------------------------------

ImFont::ImFont()
{
    Scale = 1.0f;
    FallbackChar = (ImWchar)'?';
    DisplayOffset = ImVec2(0.0f, 0.0f);
    ClearOutputData();
}

ImFont::~ImFont()
{
    // Invalidate active font so that the user gets a clear crash instead of a dangling pointer.
    // If you want to delete fonts you need to do it between Render() and NewFrame().
    // FIXME-CLEANUP
    /*
    ImGuiContext& g = *GImGui;
    if (g.Font == this)
        g.Font = NULL;
    */
    ClearOutputData();
}

void    ImFont::ClearOutputData()
{
    FontSize = 0.0f;
    Glyphs.clear();
    IndexAdvanceX.clear();
    IndexLookup.clear();
    FallbackGlyph = NULL;
    FallbackAdvanceX = 0.0f;
    ConfigDataCount = 0;
    ConfigData = NULL;
    ContainerAtlas = NULL;
    Ascent = Descent = 0.0f;
    DirtyLookupTables = true;
    MetricsTotalSurface = 0;
}

void ImFont::BuildLookupTable()
{
    int max_codepoint = 0;
    for (int i = 0; i != Glyphs.Size; i++)
        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
    IndexAdvanceX.clear();
    IndexLookup.clear();
    DirtyLookupTables = false;
    GrowIndex(max_codepoint + 1);
    for (int i = 0; i < Glyphs.Size; i++)
    {
        int codepoint = (int)Glyphs[i].Codepoint;
        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
        IndexLookup[codepoint] = (ImWchar)i;
    }

    // Create a glyph to handle TAB
    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
    if (FindGlyph((ImWchar)' '))
    {
        if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times
            Glyphs.resize(Glyphs.Size + 1);
        ImFontGlyph& tab_glyph = Glyphs.back();
        tab_glyph = *FindGlyph((ImWchar)' ');
        tab_glyph.Codepoint = '\t';
        tab_glyph.AdvanceX *= 4;
        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
        IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size-1);
    }

    FallbackGlyph = FindGlyphNoFallback(FallbackChar);
    FallbackAdvanceX = FallbackGlyph ? FallbackGlyph->AdvanceX : 0.0f;
    for (int i = 0; i < max_codepoint + 1; i++)
        if (IndexAdvanceX[i] < 0.0f)
            IndexAdvanceX[i] = FallbackAdvanceX;
}

void ImFont::SetFallbackChar(ImWchar c)
{
    FallbackChar = c;
    BuildLookupTable();
}

void ImFont::GrowIndex(int new_size)
{
    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
    if (new_size <= IndexLookup.Size)
        return;
    IndexAdvanceX.resize(new_size, -1.0f);
    IndexLookup.resize(new_size, (ImWchar)-1);
}

// x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.
// Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).
void ImFont::AddGlyph(ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
{
    Glyphs.resize(Glyphs.Size + 1);
    ImFontGlyph& glyph = Glyphs.back();
    glyph.Codepoint = (ImWchar)codepoint;
    glyph.X0 = x0;
    glyph.Y0 = y0;
    glyph.X1 = x1;
    glyph.Y1 = y1;
    glyph.U0 = u0;
    glyph.V0 = v0;
    glyph.U1 = u1;
    glyph.V1 = v1;
    glyph.AdvanceX = advance_x + ConfigData->GlyphExtraSpacing.x;  // Bake spacing into AdvanceX

    if (ConfigData->PixelSnapH)
        glyph.AdvanceX = (float)(int)(glyph.AdvanceX + 0.5f);

    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
    DirtyLookupTables = true;
    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + 1.99f) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + 1.99f);
}

void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)
{
    IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
    int index_size = IndexLookup.Size;

    if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists
        return;
    if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op
        return;

    GrowIndex(dst + 1);
    IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;
    IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;
}

const ImFontGlyph* ImFont::FindGlyph(ImWchar c) const
{
    if (c >= IndexLookup.Size)
        return FallbackGlyph;
    const ImWchar i = IndexLookup[c];
    if (i == (ImWchar)-1)
        return FallbackGlyph;
    return &Glyphs.Data[i];
}

const ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c) const
{
    if (c >= IndexLookup.Size)
        return NULL;
    const ImWchar i = IndexLookup[c];
    if (i == (ImWchar)-1)
        return NULL;
    return &Glyphs.Data[i];
}

const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const
{
    // Simple word-wrapping for English, not full-featured. Please submit failing cases!
    // FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)

    // For references, possible wrap point marked with ^
    //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
    //      ^    ^    ^   ^   ^__    ^    ^

    // List of hardcoded separators: .,;!?'"

    // Skip extra blanks after a line returns (that includes not counting them in width computation)
    // e.g. "Hello    world" --> "Hello" "World"

    // Cut words that cannot possibly fit within one line.
    // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"

    float line_width = 0.0f;
    float word_width = 0.0f;
    float blank_width = 0.0f;
    wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

    const char* word_end = text;
    const char* prev_word_end = NULL;
    bool inside_word = true;

    const char* s = text;
    while (s < text_end)
    {
        unsigned int c = (unsigned int)*s;
        const char* next_s;
        if (c < 0x80)
            next_s = s + 1;
        else
            next_s = s + ImTextCharFromUtf8(&c, s, text_end);
        if (c == 0)
            break;

        if (c < 32)
        {
            if (c == '\n')
            {
                line_width = word_width = blank_width = 0.0f;
                inside_word = true;
                s = next_s;
                continue;
            }
            if (c == '\r')
            {
                s = next_s;
                continue;
            }
        }

        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX[(int)c] : FallbackAdvanceX);
        if (ImCharIsBlankW(c))
        {
            if (inside_word)
            {
                line_width += blank_width;
                blank_width = 0.0f;
                word_end = s;
            }
            blank_width += char_width;
            inside_word = false;
        }
        else
        {
            word_width += char_width;
            if (inside_word)
            {
                word_end = next_s;
            }
            else
            {
                prev_word_end = word_end;
                line_width += word_width + blank_width;
                word_width = blank_width = 0.0f;
            }

            // Allow wrapping after punctuation.
            inside_word = !(c == '.' || c == ',' || c == ';' || c == '!' || c == '?' || c == '\"');
        }

        // We ignore blank width at the end of the line (they can be skipped)
        if (line_width + word_width >= wrap_width)
        {
            // Words that cannot possibly fit within an entire line will be cut anywhere.
            if (word_width < wrap_width)
                s = prev_word_end ? prev_word_end : word_end;
            break;
        }

        s = next_s;
    }

    return s;
}

ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const
{
    if (!text_end)
        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

    const float line_height = size;
    const float scale = size / FontSize;

    ImVec2 text_size = ImVec2(0,0);
    float line_width = 0.0f;

    const bool word_wrap_enabled = (wrap_width > 0.0f);
    const char* word_wrap_eol = NULL;

    const char* s = text_begin;
    while (s < text_end)
    {
        if (word_wrap_enabled)
        {
            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
            if (!word_wrap_eol)
            {
                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);
                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below
            }

            if (s >= word_wrap_eol)
            {
                if (text_size.x < line_width)
                    text_size.x = line_width;
                text_size.y += line_height;
                line_width = 0.0f;
                word_wrap_eol = NULL;

                // Wrapping skips upcoming blanks
                while (s < text_end)
                {
                    const char c = *s;
                    if (ImCharIsBlankA(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }
                }
                continue;
            }
        }

        // Decode and advance source
        const char* prev_s = s;
        unsigned int c = (unsigned int)*s;
        if (c < 0x80)
        {
            s += 1;
        }
        else
        {
            s += ImTextCharFromUtf8(&c, s, text_end);
            if (c == 0) // Malformed UTF-8?
                break;
        }

        if (c < 32)
        {
            if (c == '\n')
            {
                text_size.x = ImMax(text_size.x, line_width);
                text_size.y += line_height;
                line_width = 0.0f;
                continue;
            }
            if (c == '\r')
                continue;
        }

        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX[(int)c] : FallbackAdvanceX) * scale;
        if (line_width + char_width >= max_width)
        {
            s = prev_s;
            break;
        }

        line_width += char_width;
    }

    if (text_size.x < line_width)
        text_size.x = line_width;

    if (line_width > 0 || text_size.y == 0.0f)
        text_size.y += line_height;

    if (remaining)
        *remaining = s;

    return text_size;
}

void ImFont::RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const
{
    if (c == ' ' || c == '\t' || c == '\n' || c == '\r') // Match behavior of RenderText(), those 4 codepoints are hard-coded.
        return;
    if (const ImFontGlyph* glyph = FindGlyph(c))
    {
        float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;
        pos.x = (float)(int)pos.x + DisplayOffset.x;
        pos.y = (float)(int)pos.y + DisplayOffset.y;
        draw_list->PrimReserve(6, 4);
        draw_list->PrimRectUV(ImVec2(pos.x + glyph->X0 * scale, pos.y + glyph->Y0 * scale), ImVec2(pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);
    }
}

void ImFont::RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const
{
    if (!text_end)
        text_end = text_begin + strlen(text_begin); // ImGui functions generally already provides a valid text_end, so this is merely to handle direct calls.

    // Align to be pixel perfect
    pos.x = (float)(int)pos.x + DisplayOffset.x;
    pos.y = (float)(int)pos.y + DisplayOffset.y;
    float x = pos.x;
    float y = pos.y;
    if (y > clip_rect.w)
        return;

    const float scale = size / FontSize;
    const float line_height = FontSize * scale;
    const bool word_wrap_enabled = (wrap_width > 0.0f);
    const char* word_wrap_eol = NULL;

    // Fast-forward to first visible line
    const char* s = text_begin;
    if (y + line_height < clip_rect.y && !word_wrap_enabled)
        while (y + line_height < clip_rect.y && s < text_end)
        {
            s = (const char*)memchr(s, '\n', text_end - s);
            s = s ? s + 1 : text_end;
            y += line_height;
        }

    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
    if (text_end - s > 10000 && !word_wrap_enabled)
    {
        const char* s_end = s;
        float y_end = y;
        while (y_end < clip_rect.w && s_end < text_end)
        {
            s_end = (const char*)memchr(s_end, '\n', text_end - s_end);
            s_end = s_end ? s_end + 1 : text_end;
            y_end += line_height;
        }
        text_end = s_end;
    }
    if (s == text_end)
        return;

    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
    const int vtx_count_max = (int)(text_end - s) * 4;
    const int idx_count_max = (int)(text_end - s) * 6;
    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
    draw_list->PrimReserve(idx_count_max, vtx_count_max);

    ImDrawVert* vtx_write = draw_list->_VtxWritePtr;
    ImDrawIdx* idx_write = draw_list->_IdxWritePtr;
    unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;

    while (s < text_end)
    {
        if (word_wrap_enabled)
        {
            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
            if (!word_wrap_eol)
            {
                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - pos.x));
                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below
            }

            if (s >= word_wrap_eol)
            {
                x = pos.x;
                y += line_height;
                word_wrap_eol = NULL;

                // Wrapping skips upcoming blanks
                while (s < text_end)
                {
                    const char c = *s;
                    if (ImCharIsBlankA(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }
                }
                continue;
            }
        }

        // Decode and advance source
        unsigned int c = (unsigned int)*s;
        if (c < 0x80)
        {
            s += 1;
        }
        else
        {
            s += ImTextCharFromUtf8(&c, s, text_end);
            if (c == 0) // Malformed UTF-8?
                break;
        }

        if (c < 32)
        {
            if (c == '\n')
            {
                x = pos.x;
                y += line_height;
                if (y > clip_rect.w)
                    break; // break out of main loop
                continue;
            }
            if (c == '\r')
                continue;
        }

        float char_width = 0.0f;
        if (const ImFontGlyph* glyph = FindGlyph((ImWchar)c))
        {
            char_width = glyph->AdvanceX * scale;

            // Arbitrarily assume that both space and tabs are empty glyphs as an optimization
            if (c != ' ' && c != '\t')
            {
                // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
                float x1 = x + glyph->X0 * scale;
                float x2 = x + glyph->X1 * scale;
                float y1 = y + glyph->Y0 * scale;
                float y2 = y + glyph->Y1 * scale;
                if (x1 <= clip_rect.z && x2 >= clip_rect.x)
                {
                    // Render a character
                    float u1 = glyph->U0;
                    float v1 = glyph->V0;
                    float u2 = glyph->U1;
                    float v2 = glyph->V1;

                    // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
                    if (cpu_fine_clip)
                    {
                        if (x1 < clip_rect.x)
                        {
                            u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
                            x1 = clip_rect.x;
                        }
                        if (y1 < clip_rect.y)
                        {
                            v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
                            y1 = clip_rect.y;
                        }
                        if (x2 > clip_rect.z)
                        {
                            u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
                            x2 = clip_rect.z;
                        }
                        if (y2 > clip_rect.w)
                        {
                            v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
                            y2 = clip_rect.w;
                        }
                        if (y1 >= y2)
                        {
                            x += char_width;
                            continue;
                        }
                    }

                    // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
                    {
                        idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx+1); idx_write[2] = (ImDrawIdx)(vtx_current_idx+2);
                        idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx+2); idx_write[5] = (ImDrawIdx)(vtx_current_idx+3);
                        vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
                        vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
                        vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
                        vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
                        vtx_write += 4;
                        vtx_current_idx += 4;
                        idx_write += 6;
                    }
                }
            }
        }

        x += char_width;
    }

    // Give back unused vertices
    draw_list->VtxBuffer.resize((int)(vtx_write - draw_list->VtxBuffer.Data));
    draw_list->IdxBuffer.resize((int)(idx_write - draw_list->IdxBuffer.Data));
    draw_list->CmdBuffer[draw_list->CmdBuffer.Size-1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
    draw_list->_VtxWritePtr = vtx_write;
    draw_list->_IdxWritePtr = idx_write;
    draw_list->_VtxCurrentIdx = (unsigned int)draw_list->VtxBuffer.Size;
}

//-----------------------------------------------------------------------------
// [SECTION] Internal Render Helpers
// (progressively moved from imgui.cpp to here when they are redesigned to stop accessing ImGui global state)
//-----------------------------------------------------------------------------
// - RenderMouseCursor()
// - RenderArrowPointingAt()
// - RenderRectFilledRangeH()
// - RenderPixelEllipsis()
//-----------------------------------------------------------------------------

void ImGui::RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor)
{
    if (mouse_cursor == ImGuiMouseCursor_None)
        return;
    IM_ASSERT(mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT);

    const ImU32 col_shadow = IM_COL32(0, 0, 0, 48);
    const ImU32 col_border = IM_COL32(0, 0, 0, 255);          // Black
    const ImU32 col_fill   = IM_COL32(255, 255, 255, 255);    // White

    ImFontAtlas* font_atlas = draw_list->_Data->Font->ContainerAtlas;
    ImVec2 offset, size, uv[4];
    if (font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))
    {
        pos -= offset;
        const ImTextureID tex_id = font_atlas->TexID;
        draw_list->PushTextureID(tex_id);
        draw_list->AddImage(tex_id, pos + ImVec2(1,0)*scale, pos + ImVec2(1,0)*scale + size*scale, uv[2], uv[3], col_shadow);
        draw_list->AddImage(tex_id, pos + ImVec2(2,0)*scale, pos + ImVec2(2,0)*scale + size*scale, uv[2], uv[3], col_shadow);
        draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[2], uv[3], col_border);
        draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[0], uv[1], col_fill);
        draw_list->PopTextureID();
    }
}

// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.
void ImGui::RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)
{
    switch (direction)
    {
    case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;
    case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;
    case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;
    case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;
    case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings
    }
}

static inline float ImAcos01(float x)
{
    if (x <= 0.0f) return IM_PI * 0.5f;
    if (x >= 1.0f) return 0.0f;
    return ImAcos(x);
    //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.
}

// FIXME: Cleanup and move code to ImDrawList.
void ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)
{
    if (x_end_norm == x_start_norm)
        return;
    if (x_start_norm > x_end_norm)
        ImSwap(x_start_norm, x_end_norm);

    ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);
    ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);
    if (rounding == 0.0f)
    {
        draw_list->AddRectFilled(p0, p1, col, 0.0f);
        return;
    }

    rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);
    const float inv_rounding = 1.0f / rounding;
    const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);
    const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);
    const float x0 = ImMax(p0.x, rect.Min.x + rounding);
    if (arc0_b == arc0_e)
    {
        draw_list->PathLineTo(ImVec2(x0, p1.y));
        draw_list->PathLineTo(ImVec2(x0, p0.y));
    }
    else if (arc0_b == 0.0f && arc0_e == IM_PI*0.5f)
    {
        draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL
        draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR
    }
    else
    {
        draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b, 3); // BL
        draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e, 3); // TR
    }
    if (p1.x > rect.Min.x + rounding)
    {
        const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);
        const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);
        const float x1 = ImMin(p1.x, rect.Max.x - rounding);
        if (arc1_b == arc1_e)
        {
            draw_list->PathLineTo(ImVec2(x1, p0.y));
            draw_list->PathLineTo(ImVec2(x1, p1.y));
        }
        else if (arc1_b == 0.0f && arc1_e == IM_PI*0.5f)
        {
            draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR
            draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR
        }
        else
        {
            draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b, 3); // TR
            draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e, 3); // BR
        }
    }
    draw_list->PathFillConvex(col);
}

// FIXME: Rendering an ellipsis "..." is a surprisingly tricky problem for us... we cannot rely on font glyph having it, 
// and regular dot are typically too wide. If we render a dot/shape ourselves it comes with the risk that it wouldn't match 
// the boldness or positioning of what the font uses...
void ImGui::RenderPixelEllipsis(ImDrawList* draw_list, ImFont* font, ImVec2 pos, int count, ImU32 col)
{
    pos.y += (float)(int)(font->DisplayOffset.y + font->Ascent + 0.5f - 1.0f);
    for (int dot_n = 0; dot_n < count; dot_n++)
        draw_list->AddRectFilled(ImVec2(pos.x + dot_n * 2.0f, pos.y), ImVec2(pos.x + dot_n * 2.0f + 1.0f, pos.y + 1.0f), col);
}

//-----------------------------------------------------------------------------
// [SECTION] Decompression code
//-----------------------------------------------------------------------------
// Compressed with stb_compress() then converted to a C array and encoded as base85.
// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.
// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h
//-----------------------------------------------------------------------------

static unsigned int stb_decompress_length(const unsigned char *input)
{
    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
}

static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;
static const unsigned char *stb__barrier_in_b;
static unsigned char *stb__dout;
static void stb__match(const unsigned char *data, unsigned int length)
{
    // INVERSE of memmove... write each byte before copying the next...
    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }
    while (length--) *stb__dout++ = *data++;
}

static void stb__lit(const unsigned char *data, unsigned int length)
{
    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }
    memcpy(stb__dout, data, length);
    stb__dout += length;
}

#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))

static const unsigned char *stb_decompress_token(const unsigned char *i)
{
    if (*i >= 0x20) { // use fewer if's for cases that expand small
        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;
        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;
        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
    } else { // more ifs for cases that expand large, since overhead is amortized
        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;
        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;
        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
    }
    return i;
}

static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)
{
    const unsigned long ADLER_MOD = 65521;
    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
    unsigned long blocklen, i;

    blocklen = buflen % 5552;
    while (buflen) {
        for (i=0; i + 7 < blocklen; i += 8) {
            s1 += buffer[0], s2 += s1;
            s1 += buffer[1], s2 += s1;
            s1 += buffer[2], s2 += s1;
            s1 += buffer[3], s2 += s1;
            s1 += buffer[4], s2 += s1;
            s1 += buffer[5], s2 += s1;
            s1 += buffer[6], s2 += s1;
            s1 += buffer[7], s2 += s1;

            buffer += 8;
        }

        for (; i < blocklen; ++i)
            s1 += *buffer++, s2 += s1;

        s1 %= ADLER_MOD, s2 %= ADLER_MOD;
        buflen -= blocklen;
        blocklen = 5552;
    }
    return (unsigned int)(s2 << 16) + (unsigned int)s1;
}

static unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int /*length*/)
{
    unsigned int olen;
    if (stb__in4(0) != 0x57bC0000) return 0;
    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
    olen = stb_decompress_length(i);
    stb__barrier_in_b = i;
    stb__barrier_out_e = output + olen;
    stb__barrier_out_b = output;
    i += 16;

    stb__dout = output;
    for (;;) {
        const unsigned char *old_i = i;
        i = stb_decompress_token(i);
        if (i == old_i) {
            if (*i == 0x05 && i[1] == 0xfa) {
                IM_ASSERT(stb__dout == output + olen);
                if (stb__dout != output + olen) return 0;
                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
                    return 0;
                return olen;
            } else {
                IM_ASSERT(0); /* NOTREACHED */
                return 0;
            }
        }
        IM_ASSERT(stb__dout <= output + olen);
        if (stb__dout > output + olen)
            return 0;
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Default font data (ProggyClean.ttf)
//-----------------------------------------------------------------------------
// ProggyClean.ttf
// Copyright (c) 2004, 2005 Tristan Grimmer
// MIT license (see License.txt in http://www.upperbounds.net/download/ProggyClean.ttf.zip)
// Download and more information at http://upperbounds.net
//-----------------------------------------------------------------------------
// File: 'ProggyClean.ttf' (41208 bytes)
// Exported using misc/fonts/binary_to_compressed_c.cpp (with compression + base85 string encoding).
// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
//-----------------------------------------------------------------------------
static const char proggy_clean_ttf_compressed_data_base85[11980+1] =
    "7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/"
    "2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"
    "`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"
    "i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N"
    "kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"
    "*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"
    "tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"
    "ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc."
    "x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"
    "CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)"
    "U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"
    "'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"
    "_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"
    "Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"
    "/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"
    "%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"
    "OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("
    "h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"
    "o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"
    "j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"
    "sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"
    "eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"
    "M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%"
    "LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"
    "%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"
    "Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"
    "a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("
    "$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<"
    "nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"
    "7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;"
    ")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"
    "D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("
    "P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs"
    "bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q"
    "h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-"
    "V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"
    "sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7"
    ".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@"
    "$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"
    "hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u"
    "@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"
    "w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#"
    "u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"
    "d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"
    "6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#"
    "b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"
    ":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+"
    "tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"
    "$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"
    ":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"
    "7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"
    "u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT"
    "LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M"
    ":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>"
    "_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"
    "hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"
    "^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"
    "+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%"
    "9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"
    "CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"
    "hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"
    "8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"
    "S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"
    "0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"
    "+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"
    "M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V"
    "?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"
    "Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"
    ">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"
    "[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I"
    "wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#"
    "Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"
    "MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"
    "i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"
    "1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"
    "iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"
    "URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"
    ";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"
    "w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#"
    "d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"
    "A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
    "/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"
    "m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
    "TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"
    "GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
    "O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";

static const char* GetDefaultCompressedFontDataTTFBase85()
{
    return proggy_clean_ttf_compressed_data_base85;
}

```

`Private Esp/imgui/imgui_impl_dx9.cpp`:

```cpp
// dear imgui: Renderer for DirectX9
// This needs to be used along with a Platform Binding (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'LPDIRECT3DTEXTURE9' as ImTextureID. Read the FAQ about ImTextureID in imgui.cpp.

// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.
// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp.
// https://github.com/ocornut/imgui

// CHANGELOG 
// (minor and older changes stripped away, please see git history for details)
//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.
//  2018-06-08: Misc: Extracted imgui_impl_dx9.cpp/.h away from the old combined DX9+Win32 example.
//  2018-06-08: DirectX9: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.
//  2018-05-07: Render: Saving/restoring Transform because they don't seem to be included in the StateBlock. Setting shading mode to Gouraud.
//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX9_RenderDrawData() in the .h file so you can call it yourself.
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.

#include "imgui.h"
#include "imgui_impl_dx9.h"

// DirectX
#include <d3d9.h>
#define DIRECTINPUT_VERSION 0x0800
#include <dinput.h>

// DirectX data
static LPDIRECT3DDEVICE9        g_pd3dDevice = NULL;
static LPDIRECT3DVERTEXBUFFER9  g_pVB = NULL;
static LPDIRECT3DINDEXBUFFER9   g_pIB = NULL;
static LPDIRECT3DTEXTURE9       g_FontTexture = NULL;
static int                      g_VertexBufferSize = 5000, g_IndexBufferSize = 10000;

struct CUSTOMVERTEX
{
    float    pos[3];
    D3DCOLOR col;
    float    uv[2];
};
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)

// Render function.
// (this used to be set in io.RenderDrawListsFn and called by ImGui::Render(), but you can now call this directly from your main loop)
void ImGui_ImplDX9_RenderDrawData(ImDrawData* draw_data)
{
    // Avoid rendering when minimized
    if (draw_data->DisplaySize.x <= 0.0f || draw_data->DisplaySize.y <= 0.0f)
        return;

    // Create and grow buffers if needed
    if (!g_pVB || g_VertexBufferSize < draw_data->TotalVtxCount)
    {
        if (g_pVB) { g_pVB->Release(); g_pVB = NULL; }
        g_VertexBufferSize = draw_data->TotalVtxCount + 5000;
        if (g_pd3dDevice->CreateVertexBuffer(g_VertexBufferSize * sizeof(CUSTOMVERTEX), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX, D3DPOOL_DEFAULT, &g_pVB, NULL) < 0)
            return;
    }
    if (!g_pIB || g_IndexBufferSize < draw_data->TotalIdxCount)
    {
        if (g_pIB) { g_pIB->Release(); g_pIB = NULL; }
        g_IndexBufferSize = draw_data->TotalIdxCount + 10000;
        if (g_pd3dDevice->CreateIndexBuffer(g_IndexBufferSize * sizeof(ImDrawIdx), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, sizeof(ImDrawIdx) == 2 ? D3DFMT_INDEX16 : D3DFMT_INDEX32, D3DPOOL_DEFAULT, &g_pIB, NULL) < 0)
            return;
    }

    // Backup the DX9 state
    IDirect3DStateBlock9* d3d9_state_block = NULL;
    if (g_pd3dDevice->CreateStateBlock(D3DSBT_ALL, &d3d9_state_block) < 0)
        return;

    // Backup the DX9 transform (DX9 documentation suggests that it is included in the StateBlock but it doesn't appear to)
    D3DMATRIX last_world, last_view, last_projection;
    g_pd3dDevice->GetTransform(D3DTS_WORLD, &last_world);
    g_pd3dDevice->GetTransform(D3DTS_VIEW, &last_view);
    g_pd3dDevice->GetTransform(D3DTS_PROJECTION, &last_projection);

    // Copy and convert all vertices into a single contiguous buffer, convert colors to DX9 default format.
    // FIXME-OPT: This is a waste of resource, the ideal is to use imconfig.h and
    //  1) to avoid repacking colors:   #define IMGUI_USE_BGRA_PACKED_COLOR
    //  2) to avoid repacking vertices: #define IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT struct ImDrawVert { ImVec2 pos; float z; ImU32 col; ImVec2 uv; }
    CUSTOMVERTEX* vtx_dst;
    ImDrawIdx* idx_dst;
    if (g_pVB->Lock(0, (UINT)(draw_data->TotalVtxCount * sizeof(CUSTOMVERTEX)), (void**)&vtx_dst, D3DLOCK_DISCARD) < 0)
        return;
    if (g_pIB->Lock(0, (UINT)(draw_data->TotalIdxCount * sizeof(ImDrawIdx)), (void**)&idx_dst, D3DLOCK_DISCARD) < 0)
        return;
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];
        const ImDrawVert* vtx_src = cmd_list->VtxBuffer.Data;
        for (int i = 0; i < cmd_list->VtxBuffer.Size; i++)
        {
            vtx_dst->pos[0] = vtx_src->pos.x;
            vtx_dst->pos[1] = vtx_src->pos.y;
            vtx_dst->pos[2] = 0.0f;
            vtx_dst->col = (vtx_src->col & 0xFF00FF00) | ((vtx_src->col & 0xFF0000) >> 16) | ((vtx_src->col & 0xFF) << 16);     // RGBA --> ARGB for DirectX9
            vtx_dst->uv[0] = vtx_src->uv.x;
            vtx_dst->uv[1] = vtx_src->uv.y;
            vtx_dst++;
            vtx_src++;
        }
        memcpy(idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx));
        idx_dst += cmd_list->IdxBuffer.Size;
    }
    g_pVB->Unlock();
    g_pIB->Unlock();
    g_pd3dDevice->SetStreamSource(0, g_pVB, 0, sizeof(CUSTOMVERTEX));
    g_pd3dDevice->SetIndices(g_pIB);
    g_pd3dDevice->SetFVF(D3DFVF_CUSTOMVERTEX);

    // Setup viewport
    D3DVIEWPORT9 vp;
    vp.X = vp.Y = 0;
    vp.Width = (DWORD)draw_data->DisplaySize.x;
    vp.Height = (DWORD)draw_data->DisplaySize.y;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    g_pd3dDevice->SetViewport(&vp);

    // Setup render state: fixed-pipeline, alpha-blending, no face culling, no depth testing, shade mode (for gradient)
    g_pd3dDevice->SetPixelShader(NULL);
    g_pd3dDevice->SetVertexShader(NULL);
    g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, false);
    g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, false);
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
    g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, false);
    g_pd3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
    g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, true);
    g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    g_pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
    g_pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);

    // Setup orthographic projection matrix
    // Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right).
    // Being agnostic of whether <d3dx9.h> or <DirectXMath.h> can be used, we aren't relying on D3DXMatrixIdentity()/D3DXMatrixOrthoOffCenterLH() or DirectX::XMMatrixIdentity()/DirectX::XMMatrixOrthographicOffCenterLH()
    {
        float L = draw_data->DisplayPos.x + 0.5f;
        float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x + 0.5f;
        float T = draw_data->DisplayPos.y + 0.5f;
        float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y + 0.5f;
        D3DMATRIX mat_identity = { { 1.0f, 0.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 0.0f, 1.0f } };
        D3DMATRIX mat_projection =
        {
            2.0f/(R-L),   0.0f,         0.0f,  0.0f,
            0.0f,         2.0f/(T-B),   0.0f,  0.0f,
            0.0f,         0.0f,         0.5f,  0.0f,
            (L+R)/(L-R),  (T+B)/(B-T),  0.5f,  1.0f,
        };
        g_pd3dDevice->SetTransform(D3DTS_WORLD, &mat_identity);
        g_pd3dDevice->SetTransform(D3DTS_VIEW, &mat_identity);
        g_pd3dDevice->SetTransform(D3DTS_PROJECTION, &mat_projection);
    }

    // Render command lists
    int vtx_offset = 0;
    int idx_offset = 0;
    ImVec2 pos = draw_data->DisplayPos;
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];
        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
            if (pcmd->UserCallback)
            {
                pcmd->UserCallback(cmd_list, pcmd);
            }
            else
            {
                const RECT r = { (LONG)(pcmd->ClipRect.x - pos.x), (LONG)(pcmd->ClipRect.y - pos.y), (LONG)(pcmd->ClipRect.z - pos.x), (LONG)(pcmd->ClipRect.w - pos.y) };
                const LPDIRECT3DTEXTURE9 texture = (LPDIRECT3DTEXTURE9)pcmd->TextureId;
                g_pd3dDevice->SetTexture(0, texture);
                g_pd3dDevice->SetScissorRect(&r);
                g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, vtx_offset, 0, (UINT)cmd_list->VtxBuffer.Size, idx_offset, pcmd->ElemCount/3);
            }
            idx_offset += pcmd->ElemCount;
        }
        vtx_offset += cmd_list->VtxBuffer.Size;
    }

    // Restore the DX9 transform
    g_pd3dDevice->SetTransform(D3DTS_WORLD, &last_world);
    g_pd3dDevice->SetTransform(D3DTS_VIEW, &last_view);
    g_pd3dDevice->SetTransform(D3DTS_PROJECTION, &last_projection);

    // Restore the DX9 state
    d3d9_state_block->Apply();
    d3d9_state_block->Release();
}

bool ImGui_ImplDX9_Init(IDirect3DDevice9* device)
{
    ImGuiIO& io = ImGui::GetIO();
    io.BackendRendererName = "imgui_impl_dx9";

    g_pd3dDevice = device;
    return true;
}

void ImGui_ImplDX9_Shutdown()
{
    ImGui_ImplDX9_InvalidateDeviceObjects();
    g_pd3dDevice = NULL;
}

static bool ImGui_ImplDX9_CreateFontsTexture()
{
    // Build texture atlas
    ImGuiIO& io = ImGui::GetIO();
    unsigned char* pixels;
    int width, height, bytes_per_pixel;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height, &bytes_per_pixel);

    // Upload texture to graphics system
    g_FontTexture = NULL;
    if (g_pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &g_FontTexture, NULL) < 0)
        return false;
    D3DLOCKED_RECT tex_locked_rect;
    if (g_FontTexture->LockRect(0, &tex_locked_rect, NULL, 0) != D3D_OK)
        return false;
    for (int y = 0; y < height; y++)
        memcpy((unsigned char *)tex_locked_rect.pBits + tex_locked_rect.Pitch * y, pixels + (width * bytes_per_pixel) * y, (width * bytes_per_pixel));
    g_FontTexture->UnlockRect(0);

    // Store our identifier
    io.Fonts->TexID = (ImTextureID)g_FontTexture;

    return true;
}

bool ImGui_ImplDX9_CreateDeviceObjects()
{
    if (!g_pd3dDevice)
        return false;
    if (!ImGui_ImplDX9_CreateFontsTexture())
        return false;
    return true;
}

void ImGui_ImplDX9_InvalidateDeviceObjects()
{
    if (!g_pd3dDevice)
        return;
    if (g_pVB)
    {
        g_pVB->Release();
        g_pVB = NULL;
    }
    if (g_pIB)
    {
        g_pIB->Release();
        g_pIB = NULL;
    }

    // At this point note that we set ImGui::GetIO().Fonts->TexID to be == g_FontTexture, so clear both.
    ImGuiIO& io = ImGui::GetIO();
    IM_ASSERT(g_FontTexture == io.Fonts->TexID);
    if (g_FontTexture)
        g_FontTexture->Release();
    g_FontTexture = NULL;
    io.Fonts->TexID = NULL;
}

void ImGui_ImplDX9_NewFrame()
{
    if (!g_FontTexture)
        ImGui_ImplDX9_CreateDeviceObjects();
}

```

`Private Esp/imgui/imgui_impl_dx9.h`:

```h
// dear imgui: Renderer for DirectX9
// This needs to be used along with a Platform Binding (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'LPDIRECT3DTEXTURE9' as ImTextureID. Read the FAQ about ImTextureID in imgui.cpp.

// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.
// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp.
// https://github.com/ocornut/imgui

#pragma once

struct IDirect3DDevice9;

IMGUI_IMPL_API bool     ImGui_ImplDX9_Init(IDirect3DDevice9* device);
IMGUI_IMPL_API void     ImGui_ImplDX9_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplDX9_NewFrame();
IMGUI_IMPL_API void     ImGui_ImplDX9_RenderDrawData(ImDrawData* draw_data);

// Use if you want to reset your rendering device without losing ImGui state.
IMGUI_IMPL_API void     ImGui_ImplDX9_InvalidateDeviceObjects();
IMGUI_IMPL_API bool     ImGui_ImplDX9_CreateDeviceObjects();

```

`Private Esp/imgui/imgui_impl_glfw.cpp`:

```cpp
// dear imgui: Platform Backend for GLFW
// This needs to be used along with a Renderer (e.g. OpenGL3, Vulkan, WebGPU..)
// (Info: GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan graphics context creation, etc.)
// (Requires: GLFW 3.1+)

// Implemented features:
//  [X] Platform: Clipboard support.
//  [X] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange' (note: the resizing cursors requires GLFW 3.4+).
//  [X] Platform: Keyboard arrays indexed using GLFW_KEY_* codes, e.g. ImGui::IsKeyPressed(GLFW_KEY_SPACE).

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this. 
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.
// Read online: https://github.com/ocornut/imgui/tree/master/docs

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2020-01-17: Inputs: Disable error callback while assigning mouse cursors because some X11 setup don't have them and it generates errors.
//  2019-12-05: Inputs: Added support for new mouse cursors added in GLFW 3.4+ (resizing cursors, not allowed cursor).
//  2019-10-18: Misc: Previously installed user callbacks are now restored on shutdown.
//  2019-07-21: Inputs: Added mapping for ImGuiKey_KeyPadEnter.
//  2019-05-11: Inputs: Don't filter value from character callback before calling AddInputCharacter().
//  2019-03-12: Misc: Preserve DisplayFramebufferScale when main window is minimized.
//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.
//  2018-11-07: Inputs: When installing our GLFW callbacks, we save user's previously installed ones - if any - and chain call them.
//  2018-08-01: Inputs: Workaround for Emscripten which doesn't seem to handle focus related calls.
//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.
//  2018-06-08: Misc: Extracted imgui_impl_glfw.cpp/.h away from the old combined GLFW+OpenGL/Vulkan examples.
//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors flag + honor ImGuiConfigFlags_NoMouseCursorChange flag.
//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value, passed to glfwSetCursor()).
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.
//  2018-01-25: Inputs: Added gamepad support if ImGuiConfigFlags_NavEnableGamepad is set.
//  2018-01-25: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).
//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.
//  2018-01-18: Inputs: Added mapping for ImGuiKey_Insert.
//  2017-08-25: Inputs: MousePos set to -FLT_MAX,-FLT_MAX when mouse is unavailable/missing (instead of -1,-1).
//  2016-10-15: Misc: Added a void* user_data parameter to Clipboard function handlers.

#include "imgui.h"
#include "imgui_impl_glfw.h"

// GLFW
#include <GLFW/glfw3.h>
#ifdef _WIN32
#undef APIENTRY
#define GLFW_EXPOSE_NATIVE_WIN32
#include <GLFW/glfw3native.h>   // for glfwGetWin32Window
#endif
#define GLFW_HAS_WINDOW_TOPMOST       (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 >= 3200) // 3.2+ GLFW_FLOATING
#define GLFW_HAS_WINDOW_HOVERED       (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 >= 3300) // 3.3+ GLFW_HOVERED
#define GLFW_HAS_WINDOW_ALPHA         (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 >= 3300) // 3.3+ glfwSetWindowOpacity
#define GLFW_HAS_PER_MONITOR_DPI      (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 >= 3300) // 3.3+ glfwGetMonitorContentScale
#define GLFW_HAS_VULKAN               (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 >= 3200) // 3.2+ glfwCreateWindowSurface
#ifdef GLFW_RESIZE_NESW_CURSOR  // let's be nice to people who pulled GLFW between 2019-04-16 (3.4 define) and 2019-11-29 (cursors defines) // FIXME: Remove when GLFW 3.4 is released?
#define GLFW_HAS_NEW_CURSORS          (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 >= 3400) // 3.4+ GLFW_RESIZE_ALL_CURSOR, GLFW_RESIZE_NESW_CURSOR, GLFW_RESIZE_NWSE_CURSOR, GLFW_NOT_ALLOWED_CURSOR
#else
#define GLFW_HAS_NEW_CURSORS          (0)
#endif

// Data
enum GlfwClientApi
{
    GlfwClientApi_Unknown,
    GlfwClientApi_OpenGL,
    GlfwClientApi_Vulkan
};
static GLFWwindow*          g_Window = NULL;    // Main window
static GlfwClientApi        g_ClientApi = GlfwClientApi_Unknown;
static double               g_Time = 0.0;
static bool                 g_MouseJustPressed[ImGuiMouseButton_COUNT] = {};
static GLFWcursor*          g_MouseCursors[ImGuiMouseCursor_COUNT] = {};
static bool                 g_InstalledCallbacks = false;

// Chain GLFW callbacks: our callbacks will call the user's previously installed callbacks, if any.
static GLFWmousebuttonfun   g_PrevUserCallbackMousebutton = NULL;
static GLFWscrollfun        g_PrevUserCallbackScroll = NULL;
static GLFWkeyfun           g_PrevUserCallbackKey = NULL;
static GLFWcharfun          g_PrevUserCallbackChar = NULL;

static const char* ImGui_ImplGlfw_GetClipboardText(void* user_data)
{
    return glfwGetClipboardString((GLFWwindow*)user_data);
}

static void ImGui_ImplGlfw_SetClipboardText(void* user_data, const char* text)
{
    glfwSetClipboardString((GLFWwindow*)user_data, text);
}

void ImGui_ImplGlfw_MouseButtonCallback(GLFWwindow* window, int button, int action, int mods)
{
    if (g_PrevUserCallbackMousebutton != NULL)
        g_PrevUserCallbackMousebutton(window, button, action, mods);

    if (action == GLFW_PRESS && button >= 0 && button < IM_ARRAYSIZE(g_MouseJustPressed))
        g_MouseJustPressed[button] = true;
}

void ImGui_ImplGlfw_ScrollCallback(GLFWwindow* window, double xoffset, double yoffset)
{
    if (g_PrevUserCallbackScroll != NULL)
        g_PrevUserCallbackScroll(window, xoffset, yoffset);

    ImGuiIO& io = ImGui::GetIO();
    io.MouseWheelH += (float)xoffset;
    io.MouseWheel += (float)yoffset;
}

void ImGui_ImplGlfw_KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    if (g_PrevUserCallbackKey != NULL)
        g_PrevUserCallbackKey(window, key, scancode, action, mods);

    ImGuiIO& io = ImGui::GetIO();
    if (key >= 0 && key < IM_ARRAYSIZE(io.KeysDown))
    {
        if (action == GLFW_PRESS)
            io.KeysDown[key] = true;
        if (action == GLFW_RELEASE)
            io.KeysDown[key] = false;
    }

    // Modifiers are not reliable across systems
    io.KeyCtrl = io.KeysDown[GLFW_KEY_LEFT_CONTROL] || io.KeysDown[GLFW_KEY_RIGHT_CONTROL];
    io.KeyShift = io.KeysDown[GLFW_KEY_LEFT_SHIFT] || io.KeysDown[GLFW_KEY_RIGHT_SHIFT];
    io.KeyAlt = io.KeysDown[GLFW_KEY_LEFT_ALT] || io.KeysDown[GLFW_KEY_RIGHT_ALT];
#ifdef _WIN32
    io.KeySuper = false;
#else
    io.KeySuper = io.KeysDown[GLFW_KEY_LEFT_SUPER] || io.KeysDown[GLFW_KEY_RIGHT_SUPER];
#endif
}

void ImGui_ImplGlfw_CharCallback(GLFWwindow* window, unsigned int c)
{
    if (g_PrevUserCallbackChar != NULL)
        g_PrevUserCallbackChar(window, c);

    ImGuiIO& io = ImGui::GetIO();
    io.AddInputCharacter(c);
}

static bool ImGui_ImplGlfw_Init(GLFWwindow* window, bool install_callbacks, GlfwClientApi client_api)
{
    g_Window = window;
    g_Time = 0.0;

    // Setup backend capabilities flags
    ImGuiIO& io = ImGui::GetIO();
    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)
    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)
    io.BackendPlatformName = "imgui_impl_glfw";

    // Keyboard mapping. Dear ImGui will use those indices to peek into the io.KeysDown[] array.
    io.KeyMap[ImGuiKey_Tab] = GLFW_KEY_TAB;
    io.KeyMap[ImGuiKey_LeftArrow] = GLFW_KEY_LEFT;
    io.KeyMap[ImGuiKey_RightArrow] = GLFW_KEY_RIGHT;
    io.KeyMap[ImGuiKey_UpArrow] = GLFW_KEY_UP;
    io.KeyMap[ImGuiKey_DownArrow] = GLFW_KEY_DOWN;
    io.KeyMap[ImGuiKey_PageUp] = GLFW_KEY_PAGE_UP;
    io.KeyMap[ImGuiKey_PageDown] = GLFW_KEY_PAGE_DOWN;
    io.KeyMap[ImGuiKey_Home] = GLFW_KEY_HOME;
    io.KeyMap[ImGuiKey_End] = GLFW_KEY_END;
    io.KeyMap[ImGuiKey_Insert] = GLFW_KEY_INSERT;
    io.KeyMap[ImGuiKey_Delete] = GLFW_KEY_DELETE;
    io.KeyMap[ImGuiKey_Backspace] = GLFW_KEY_BACKSPACE;
    io.KeyMap[ImGuiKey_Space] = GLFW_KEY_SPACE;
    io.KeyMap[ImGuiKey_Enter] = GLFW_KEY_ENTER;
    io.KeyMap[ImGuiKey_Escape] = GLFW_KEY_ESCAPE;
    io.KeyMap[ImGuiKey_KeyPadEnter] = GLFW_KEY_KP_ENTER;
    io.KeyMap[ImGuiKey_A] = GLFW_KEY_A;
    io.KeyMap[ImGuiKey_C] = GLFW_KEY_C;
    io.KeyMap[ImGuiKey_V] = GLFW_KEY_V;
    io.KeyMap[ImGuiKey_X] = GLFW_KEY_X;
    io.KeyMap[ImGuiKey_Y] = GLFW_KEY_Y;
    io.KeyMap[ImGuiKey_Z] = GLFW_KEY_Z;

    io.SetClipboardTextFn = ImGui_ImplGlfw_SetClipboardText;
    io.GetClipboardTextFn = ImGui_ImplGlfw_GetClipboardText;
    io.ClipboardUserData = g_Window;
#if defined(_WIN32)
    io.ImeWindowHandle = (void*)glfwGetWin32Window(g_Window);
#endif

    // Create mouse cursors
    // (By design, on X11 cursors are user configurable and some cursors may be missing. When a cursor doesn't exist,
    // GLFW will emit an error which will often be printed by the app, so we temporarily disable error reporting.
    // Missing cursors will return NULL and our _UpdateMouseCursor() function will use the Arrow cursor instead.)
    GLFWerrorfun prev_error_callback = glfwSetErrorCallback(NULL);
    g_MouseCursors[ImGuiMouseCursor_Arrow] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
    g_MouseCursors[ImGuiMouseCursor_TextInput] = glfwCreateStandardCursor(GLFW_IBEAM_CURSOR);
    g_MouseCursors[ImGuiMouseCursor_ResizeNS] = glfwCreateStandardCursor(GLFW_VRESIZE_CURSOR);
    g_MouseCursors[ImGuiMouseCursor_ResizeEW] = glfwCreateStandardCursor(GLFW_HRESIZE_CURSOR);
    g_MouseCursors[ImGuiMouseCursor_Hand] = glfwCreateStandardCursor(GLFW_HAND_CURSOR);
#if GLFW_HAS_NEW_CURSORS
    g_MouseCursors[ImGuiMouseCursor_ResizeAll] = glfwCreateStandardCursor(GLFW_RESIZE_ALL_CURSOR);
    g_MouseCursors[ImGuiMouseCursor_ResizeNESW] = glfwCreateStandardCursor(GLFW_RESIZE_NESW_CURSOR);
    g_MouseCursors[ImGuiMouseCursor_ResizeNWSE] = glfwCreateStandardCursor(GLFW_RESIZE_NWSE_CURSOR);
    g_MouseCursors[ImGuiMouseCursor_NotAllowed] = glfwCreateStandardCursor(GLFW_NOT_ALLOWED_CURSOR);
#else
    g_MouseCursors[ImGuiMouseCursor_ResizeAll] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
    g_MouseCursors[ImGuiMouseCursor_ResizeNESW] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
    g_MouseCursors[ImGuiMouseCursor_ResizeNWSE] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
    g_MouseCursors[ImGuiMouseCursor_NotAllowed] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
#endif
    glfwSetErrorCallback(prev_error_callback);

    // Chain GLFW callbacks: our callbacks will call the user's previously installed callbacks, if any.
    g_PrevUserCallbackMousebutton = NULL;
    g_PrevUserCallbackScroll = NULL;
    g_PrevUserCallbackKey = NULL;
    g_PrevUserCallbackChar = NULL;
    if (install_callbacks)
    {
        g_InstalledCallbacks = true;
        g_PrevUserCallbackMousebutton = glfwSetMouseButtonCallback(window, ImGui_ImplGlfw_MouseButtonCallback);
        g_PrevUserCallbackScroll = glfwSetScrollCallback(window, ImGui_ImplGlfw_ScrollCallback);
        g_PrevUserCallbackKey = glfwSetKeyCallback(window, ImGui_ImplGlfw_KeyCallback);
        g_PrevUserCallbackChar = glfwSetCharCallback(window, ImGui_ImplGlfw_CharCallback);
    }

    g_ClientApi = client_api;
    return true;
}

bool ImGui_ImplGlfw_InitForOpenGL(GLFWwindow* window, bool install_callbacks)
{
    return ImGui_ImplGlfw_Init(window, install_callbacks, GlfwClientApi_OpenGL);
}

bool ImGui_ImplGlfw_InitForVulkan(GLFWwindow* window, bool install_callbacks)
{
    return ImGui_ImplGlfw_Init(window, install_callbacks, GlfwClientApi_Vulkan);
}

bool ImGui_ImplGlfw_InitForOther(GLFWwindow* window, bool install_callbacks)
{
    return ImGui_ImplGlfw_Init(window, install_callbacks, GlfwClientApi_Unknown);
}

void ImGui_ImplGlfw_Shutdown()
{
    if (g_InstalledCallbacks)
    {
        glfwSetMouseButtonCallback(g_Window, g_PrevUserCallbackMousebutton);
        glfwSetScrollCallback(g_Window, g_PrevUserCallbackScroll);
        glfwSetKeyCallback(g_Window, g_PrevUserCallbackKey);
        glfwSetCharCallback(g_Window, g_PrevUserCallbackChar);
        g_InstalledCallbacks = false;
    }

    for (ImGuiMouseCursor cursor_n = 0; cursor_n < ImGuiMouseCursor_COUNT; cursor_n++)
    {
        glfwDestroyCursor(g_MouseCursors[cursor_n]);
        g_MouseCursors[cursor_n] = NULL;
    }
    g_ClientApi = GlfwClientApi_Unknown;
}

static void ImGui_ImplGlfw_UpdateMousePosAndButtons()
{
    // Update buttons
    ImGuiIO& io = ImGui::GetIO();
    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
    {
        // If a mouse press event came, always pass it as "mouse held this frame", so we don't miss click-release events that are shorter than 1 frame.
        io.MouseDown[i] = g_MouseJustPressed[i] || glfwGetMouseButton(g_Window, i) != 0;
        g_MouseJustPressed[i] = false;
    }

    // Update mouse position
    const ImVec2 mouse_pos_backup = io.MousePos;
    io.MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
#ifdef __EMSCRIPTEN__
    const bool focused = true; // Emscripten
#else
    const bool focused = glfwGetWindowAttrib(g_Window, GLFW_FOCUSED) != 0;
#endif
    if (focused)
    {
        if (io.WantSetMousePos)
        {
            glfwSetCursorPos(g_Window, (double)mouse_pos_backup.x, (double)mouse_pos_backup.y);
        }
        else
        {
            double mouse_x, mouse_y;
            glfwGetCursorPos(g_Window, &mouse_x, &mouse_y);
            io.MousePos = ImVec2((float)mouse_x, (float)mouse_y);
        }
    }
}

static void ImGui_ImplGlfw_UpdateMouseCursor()
{
    ImGuiIO& io = ImGui::GetIO();
    if ((io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange) || glfwGetInputMode(g_Window, GLFW_CURSOR) == GLFW_CURSOR_DISABLED)
        return;

    ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
    if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)
    {
        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
        glfwSetInputMode(g_Window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);
    }
    else
    {
        // Show OS mouse cursor
        // FIXME-PLATFORM: Unfocused windows seems to fail changing the mouse cursor with GLFW 3.2, but 3.3 works here.
        glfwSetCursor(g_Window, g_MouseCursors[imgui_cursor] ? g_MouseCursors[imgui_cursor] : g_MouseCursors[ImGuiMouseCursor_Arrow]);
        glfwSetInputMode(g_Window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
    }
}

static void ImGui_ImplGlfw_UpdateGamepads()
{
    ImGuiIO& io = ImGui::GetIO();
    memset(io.NavInputs, 0, sizeof(io.NavInputs));
    if ((io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) == 0)
        return;

    // Update gamepad inputs
    #define MAP_BUTTON(NAV_NO, BUTTON_NO)       { if (buttons_count > BUTTON_NO && buttons[BUTTON_NO] == GLFW_PRESS) io.NavInputs[NAV_NO] = 1.0f; }
    #define MAP_ANALOG(NAV_NO, AXIS_NO, V0, V1) { float v = (axes_count > AXIS_NO) ? axes[AXIS_NO] : V0; v = (v - V0) / (V1 - V0); if (v > 1.0f) v = 1.0f; if (io.NavInputs[NAV_NO] < v) io.NavInputs[NAV_NO] = v; }
    int axes_count = 0, buttons_count = 0;
    const float* axes = glfwGetJoystickAxes(GLFW_JOYSTICK_1, &axes_count);
    const unsigned char* buttons = glfwGetJoystickButtons(GLFW_JOYSTICK_1, &buttons_count);
    MAP_BUTTON(ImGuiNavInput_Activate,   0);     // Cross / A
    MAP_BUTTON(ImGuiNavInput_Cancel,     1);     // Circle / B
    MAP_BUTTON(ImGuiNavInput_Menu,       2);     // Square / X
    MAP_BUTTON(ImGuiNavInput_Input,      3);     // Triangle / Y
    MAP_BUTTON(ImGuiNavInput_DpadLeft,   13);    // D-Pad Left
    MAP_BUTTON(ImGuiNavInput_DpadRight,  11);    // D-Pad Right
    MAP_BUTTON(ImGuiNavInput_DpadUp,     10);    // D-Pad Up
    MAP_BUTTON(ImGuiNavInput_DpadDown,   12);    // D-Pad Down
    MAP_BUTTON(ImGuiNavInput_FocusPrev,  4);     // L1 / LB
    MAP_BUTTON(ImGuiNavInput_FocusNext,  5);     // R1 / RB
    MAP_BUTTON(ImGuiNavInput_TweakSlow,  4);     // L1 / LB
    MAP_BUTTON(ImGuiNavInput_TweakFast,  5);     // R1 / RB
    MAP_ANALOG(ImGuiNavInput_LStickLeft, 0,  -0.3f,  -0.9f);
    MAP_ANALOG(ImGuiNavInput_LStickRight,0,  +0.3f,  +0.9f);
    MAP_ANALOG(ImGuiNavInput_LStickUp,   1,  +0.3f,  +0.9f);
    MAP_ANALOG(ImGuiNavInput_LStickDown, 1,  -0.3f,  -0.9f);
    #undef MAP_BUTTON
    #undef MAP_ANALOG
    if (axes_count > 0 && buttons_count > 0)
        io.BackendFlags |= ImGuiBackendFlags_HasGamepad;
    else
        io.BackendFlags &= ~ImGuiBackendFlags_HasGamepad;
}

void ImGui_ImplGlfw_NewFrame()
{
    ImGuiIO& io = ImGui::GetIO();
    IM_ASSERT(io.Fonts->IsBuilt() && "Font atlas not built! It is generally built by the renderer backend. Missing call to renderer _NewFrame() function? e.g. ImGui_ImplOpenGL3_NewFrame().");

    // Setup display size (every frame to accommodate for window resizing)
    int w, h;
    int display_w, display_h;
    glfwGetWindowSize(g_Window, &w, &h);
    glfwGetFramebufferSize(g_Window, &display_w, &display_h);
    io.DisplaySize = ImVec2((float)w, (float)h);
    if (w > 0 && h > 0)
        io.DisplayFramebufferScale = ImVec2((float)display_w / w, (float)display_h / h);

    // Setup time step
    double current_time = glfwGetTime();
    io.DeltaTime = g_Time > 0.0 ? (float)(current_time - g_Time) : (float)(1.0f / 60.0f);
    g_Time = current_time;

    ImGui_ImplGlfw_UpdateMousePosAndButtons();
    ImGui_ImplGlfw_UpdateMouseCursor();

    // Update game controllers (if enabled and available)
    ImGui_ImplGlfw_UpdateGamepads();
}

```

`Private Esp/imgui/imgui_impl_glfw.h`:

```h
// dear imgui: Platform Backend for GLFW
// This needs to be used along with a Renderer (e.g. OpenGL3, Vulkan, WebGPU..)
// (Info: GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan graphics context creation, etc.)

// Implemented features:
//  [X] Platform: Clipboard support.
//  [X] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
//  [x] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'. FIXME: 3 cursors types are missing from GLFW.
//  [X] Platform: Keyboard arrays indexed using GLFW_KEY_* codes, e.g. ImGui::IsKeyPressed(GLFW_KEY_SPACE).

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this. 
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.
// Read online: https://github.com/ocornut/imgui/tree/master/docs

// About GLSL version:
// The 'glsl_version' initialization parameter defaults to "#version 150" if NULL.
// Only override if your GL version doesn't handle this GLSL version. Keep NULL if unsure!

#pragma once
#include "imgui.h"      // IMGUI_IMPL_API

struct GLFWwindow;

IMGUI_IMPL_API bool     ImGui_ImplGlfw_InitForOpenGL(GLFWwindow* window, bool install_callbacks);
IMGUI_IMPL_API bool     ImGui_ImplGlfw_InitForVulkan(GLFWwindow* window, bool install_callbacks);
IMGUI_IMPL_API bool     ImGui_ImplGlfw_InitForOther(GLFWwindow* window, bool install_callbacks);
IMGUI_IMPL_API void     ImGui_ImplGlfw_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplGlfw_NewFrame();

// GLFW callbacks
// - When calling Init with 'install_callbacks=true': GLFW callbacks will be installed for you. They will call user's previously installed callbacks, if any.
// - When calling Init with 'install_callbacks=false': GLFW callbacks won't be installed. You will need to call those function yourself from your own GLFW callbacks.
IMGUI_IMPL_API void     ImGui_ImplGlfw_MouseButtonCallback(GLFWwindow* window, int button, int action, int mods);
IMGUI_IMPL_API void     ImGui_ImplGlfw_ScrollCallback(GLFWwindow* window, double xoffset, double yoffset);
IMGUI_IMPL_API void     ImGui_ImplGlfw_KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);
IMGUI_IMPL_API void     ImGui_ImplGlfw_CharCallback(GLFWwindow* window, unsigned int c);

```

`Private Esp/imgui/imgui_impl_opengl3.cpp`:

```cpp
// dear imgui: Renderer Backend for modern OpenGL with shaders / programmatic pipeline
// - Desktop GL: 2.x 3.x 4.x
// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)
// This needs to be used along with a Platform Backend (e.g. GLFW, SDL, Win32, custom..)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID!
//  [x] Renderer: Desktop GL only: Support for large meshes (64k+ vertices) with 16-bit indices.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.
// Read online: https://github.com/ocornut/imgui/tree/master/docs

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2021-06-21: OpenGL: Destroy individual vertex/fragment shader objects right after they are linked into the main shader.
//  2021-05-24: OpenGL: Access GL_CLIP_ORIGIN when "GL_ARB_clip_control" extension is detected, inside of just OpenGL 4.5 version.
//  2021-05-19: OpenGL: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)
//  2021-04-06: OpenGL: Don't try to read GL_CLIP_ORIGIN unless we're OpenGL 4.5 or greater.
//  2021-02-18: OpenGL: Change blending equation to preserve alpha in output buffer.
//  2021-01-03: OpenGL: Backup, setup and restore GL_STENCIL_TEST state.
//  2020-10-23: OpenGL: Backup, setup and restore GL_PRIMITIVE_RESTART state.
//  2020-10-15: OpenGL: Use glGetString(GL_VERSION) instead of glGetIntegerv(GL_MAJOR_VERSION, ...) when the later returns zero (e.g. Desktop GL 2.x)
//  2020-09-17: OpenGL: Fix to avoid compiling/calling glBindSampler() on ES or pre 3.3 context which have the defines set by a loader.
//  2020-07-10: OpenGL: Added support for glad2 OpenGL loader.
//  2020-05-08: OpenGL: Made default GLSL version 150 (instead of 130) on OSX.
//  2020-04-21: OpenGL: Fixed handling of glClipControl(GL_UPPER_LEFT) by inverting projection matrix.
//  2020-04-12: OpenGL: Fixed context version check mistakenly testing for 4.0+ instead of 3.2+ to enable ImGuiBackendFlags_RendererHasVtxOffset.
//  2020-03-24: OpenGL: Added support for glbinding 2.x OpenGL loader.
//  2020-01-07: OpenGL: Added support for glbinding 3.x OpenGL loader.
//  2019-10-25: OpenGL: Using a combination of GL define and runtime GL version to decide whether to use glDrawElementsBaseVertex(). Fix building with pre-3.2 GL loaders.
//  2019-09-22: OpenGL: Detect default GL loader using __has_include compiler facility.
//  2019-09-16: OpenGL: Tweak initialization code to allow application calling ImGui_ImplOpenGL3_CreateFontsTexture() before the first NewFrame() call.
//  2019-05-29: OpenGL: Desktop GL only: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.
//  2019-04-30: OpenGL: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.
//  2019-03-29: OpenGL: Not calling glBindBuffer more than necessary in the render loop.
//  2019-03-15: OpenGL: Added a GL call + comments in ImGui_ImplOpenGL3_Init() to detect uninitialized GL function loaders early.
//  2019-03-03: OpenGL: Fix support for ES 2.0 (WebGL 1.0).
//  2019-02-20: OpenGL: Fix for OSX not supporting OpenGL 4.5, we don't try to read GL_CLIP_ORIGIN even if defined by the headers/loader.
//  2019-02-11: OpenGL: Projecting clipping rectangles correctly using draw_data->FramebufferScale to allow multi-viewports for retina display.
//  2019-02-01: OpenGL: Using GLSL 410 shaders for any version over 410 (e.g. 430, 450).
//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.
//  2018-11-13: OpenGL: Support for GL 4.5's glClipControl(GL_UPPER_LEFT) / GL_CLIP_ORIGIN.
//  2018-08-29: OpenGL: Added support for more OpenGL loaders: glew and glad, with comments indicative that any loader can be used.
//  2018-08-09: OpenGL: Default to OpenGL ES 3 on iOS and Android. GLSL version default to "#version 300 ES".
//  2018-07-30: OpenGL: Support for GLSL 300 ES and 410 core. Fixes for Emscripten compilation.
//  2018-07-10: OpenGL: Support for more GLSL versions (based on the GLSL version string). Added error output when shaders fail to compile/link.
//  2018-06-08: Misc: Extracted imgui_impl_opengl3.cpp/.h away from the old combined GLFW/SDL+OpenGL3 examples.
//  2018-06-08: OpenGL: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.
//  2018-05-25: OpenGL: Removed unnecessary backup/restore of GL_ELEMENT_ARRAY_BUFFER_BINDING since this is part of the VAO state.
//  2018-05-14: OpenGL: Making the call to glBindSampler() optional so 3.2 context won't fail if the function is a NULL pointer.
//  2018-03-06: OpenGL: Added const char* glsl_version parameter to ImGui_ImplOpenGL3_Init() so user can override the GLSL version e.g. "#version 150".
//  2018-02-23: OpenGL: Create the VAO in the render function so the setup can more easily be used with multiple shared GL context.
//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplSdlGL3_RenderDrawData() in the .h file so you can call it yourself.
//  2018-01-07: OpenGL: Changed GLSL shader version from 330 to 150.
//  2017-09-01: OpenGL: Save and restore current bound sampler. Save and restore current polygon mode.
//  2017-05-01: OpenGL: Fixed save and restore of current blend func state.
//  2017-05-01: OpenGL: Fixed save and restore of current GL_ACTIVE_TEXTURE.
//  2016-09-05: OpenGL: Fixed save and restore of current scissor rectangle.
//  2016-07-29: OpenGL: Explicitly setting GL_UNPACK_ROW_LENGTH to reduce issues because SDL changes it. (#752)

//----------------------------------------
// OpenGL    GLSL      GLSL
// version   version   string
//----------------------------------------
//  2.0       110       "#version 110"
//  2.1       120       "#version 120"
//  3.0       130       "#version 130"
//  3.1       140       "#version 140"
//  3.2       150       "#version 150"
//  3.3       330       "#version 330 core"
//  4.0       400       "#version 400 core"
//  4.1       410       "#version 410 core"
//  4.2       420       "#version 410 core"
//  4.3       430       "#version 430 core"
//  ES 2.0    100       "#version 100"      = WebGL 1.0
//  ES 3.0    300       "#version 300 es"   = WebGL 2.0
//----------------------------------------

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#include "imgui_impl_opengl3.h"
#include <stdio.h>
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// GL includes
#if defined(IMGUI_IMPL_OPENGL_ES2)
#include <GLES2/gl2.h>
#elif defined(IMGUI_IMPL_OPENGL_ES3)
#if (defined(__APPLE__) && (TARGET_OS_IOS || TARGET_OS_TV))
#include <OpenGLES/ES3/gl.h>    // Use GL ES 3
#else
#include <GLES3/gl3.h>          // Use GL ES 3
#endif
#else
// About Desktop OpenGL function loaders:
//  Modern desktop OpenGL doesn't have a standard portable header file to load OpenGL function pointers.
//  Helper libraries are often used for this purpose! Here we are supporting a few common ones (gl3w, glew, glad).
//  You may use another loader/header of your choice (glext, glLoadGen, etc.), or chose to manually implement your own.
#if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W)
#include <GL/gl3w.h>            // Needs to be initialized with gl3wInit() in user's code
#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW)
#include <GL/glew.h>            // Needs to be initialized with glewInit() in user's code.
#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD)
#include <glad/glad.h>          // Needs to be initialized with gladLoadGL() in user's code.
#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD2)
#include <glad/gl.h>            // Needs to be initialized with gladLoadGL(...) or gladLoaderLoadGL() in user's code.
#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING2)
#ifndef GLFW_INCLUDE_NONE
#define GLFW_INCLUDE_NONE       // GLFW including OpenGL headers causes ambiguity or multiple definition errors.
#endif
#include <glbinding/Binding.h>  // Needs to be initialized with glbinding::Binding::initialize() in user's code.
#include <glbinding/gl/gl.h>
using namespace gl;
#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING3)
#ifndef GLFW_INCLUDE_NONE
#define GLFW_INCLUDE_NONE       // GLFW including OpenGL headers causes ambiguity or multiple definition errors.
#endif
#include <glbinding/glbinding.h>// Needs to be initialized with glbinding::initialize() in user's code.
#include <glbinding/gl/gl.h>
using namespace gl;
#else
#include IMGUI_IMPL_OPENGL_LOADER_CUSTOM
#endif
#endif

// Desktop GL 3.2+ has glDrawElementsBaseVertex() which GL ES and WebGL don't have.
#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3) && defined(GL_VERSION_3_2)
#define IMGUI_IMPL_OPENGL_MAY_HAVE_VTX_OFFSET
#endif

// Desktop GL 3.3+ has glBindSampler()
#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3) && defined(GL_VERSION_3_3)
#define IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
#endif

// Desktop GL 3.1+ has GL_PRIMITIVE_RESTART state
#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3) && defined(GL_VERSION_3_1)
#define IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
#endif

// Desktop GL use extension detection
#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3)
#define IMGUI_IMPL_OPENGL_MAY_HAVE_EXTENSIONS
#endif

// OpenGL Data
static GLuint       g_GlVersion = 0;                // Extracted at runtime using GL_MAJOR_VERSION, GL_MINOR_VERSION queries (e.g. 320 for GL 3.2)
static char         g_GlslVersionString[32] = "";   // Specified by user or detected based on compile time GL settings.
static GLuint       g_FontTexture = 0;
static GLuint       g_ShaderHandle = 0;
static GLint        g_AttribLocationTex = 0, g_AttribLocationProjMtx = 0;                                // Uniforms location
static GLuint       g_AttribLocationVtxPos = 0, g_AttribLocationVtxUV = 0, g_AttribLocationVtxColor = 0; // Vertex attributes location
static unsigned int g_VboHandle = 0, g_ElementsHandle = 0;
static bool         g_HasClipOrigin = false;

// Functions
bool    ImGui_ImplOpenGL3_Init(const char* glsl_version)
{
    // Query for GL version (e.g. 320 for GL 3.2)
#if !defined(IMGUI_IMPL_OPENGL_ES2)
    GLint major = 0;
    GLint minor = 0;
    glGetIntegerv(GL_MAJOR_VERSION, &major);
    glGetIntegerv(GL_MINOR_VERSION, &minor);
    if (major == 0 && minor == 0)
    {
        // Query GL_VERSION in desktop GL 2.x, the string will start with "<major>.<minor>"
        const char* gl_version = (const char*)glGetString(GL_VERSION);
        sscanf(gl_version, "%d.%d", &major, &minor);
    }
    g_GlVersion = (GLuint)(major * 100 + minor * 10);
#else
    g_GlVersion = 200; // GLES 2
#endif

    // Setup backend capabilities flags
    ImGuiIO& io = ImGui::GetIO();
    io.BackendRendererName = "imgui_impl_opengl3";
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_VTX_OFFSET
    if (g_GlVersion >= 320)
        io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.
#endif

    // Store GLSL version string so we can refer to it later in case we recreate shaders.
    // Note: GLSL version is NOT the same as GL version. Leave this to NULL if unsure.
#if defined(IMGUI_IMPL_OPENGL_ES2)
    if (glsl_version == NULL)
        glsl_version = "#version 100";
#elif defined(IMGUI_IMPL_OPENGL_ES3)
    if (glsl_version == NULL)
        glsl_version = "#version 300 es";
#elif defined(__APPLE__)
    if (glsl_version == NULL)
        glsl_version = "#version 150";
#else
    if (glsl_version == NULL)
        glsl_version = "#version 130";
#endif
    IM_ASSERT((int)strlen(glsl_version) + 2 < IM_ARRAYSIZE(g_GlslVersionString));
    strcpy(g_GlslVersionString, glsl_version);
    strcat(g_GlslVersionString, "\n");

    // Debugging construct to make it easily visible in the IDE and debugger which GL loader has been selected.
    // The code actually never uses the 'gl_loader' variable! It is only here so you can read it!
    // If auto-detection fails or doesn't select the same GL loader file as used by your application,
    // you are likely to get a crash below.
    // You can explicitly select a loader by using '#define IMGUI_IMPL_OPENGL_LOADER_XXX' in imconfig.h or compiler command-line.
    const char* gl_loader = "Unknown";
    IM_UNUSED(gl_loader);
#if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W)
    gl_loader = "GL3W";
#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW)
    gl_loader = "GLEW";
#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD)
    gl_loader = "GLAD";
#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD2)
    gl_loader = "GLAD2";
#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING2)
    gl_loader = "glbinding2";
#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING3)
    gl_loader = "glbinding3";
#elif defined(IMGUI_IMPL_OPENGL_LOADER_CUSTOM)
    gl_loader = "custom";
#else
    gl_loader = "none";
#endif

    // Make an arbitrary GL call (we don't actually need the result)
    // IF YOU GET A CRASH HERE: it probably means that you haven't initialized the OpenGL function loader used by this code.
    // Desktop OpenGL 3/4 need a function loader. See the IMGUI_IMPL_OPENGL_LOADER_xxx explanation above.
    GLint current_texture;
    glGetIntegerv(GL_TEXTURE_BINDING_2D, &current_texture);

    // Detect extensions we support
    g_HasClipOrigin = (g_GlVersion >= 450);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_EXTENSIONS
    GLint num_extensions = 0;
    glGetIntegerv(GL_NUM_EXTENSIONS, &num_extensions);
    for (GLint i = 0; i < num_extensions; i++)
    {
        const char* extension = (const char*)glGetStringi(GL_EXTENSIONS, i);
        if (extension != NULL && strcmp(extension, "GL_ARB_clip_control") == 0)
            g_HasClipOrigin = true;
    }
#endif

    return true;
}

void    ImGui_ImplOpenGL3_Shutdown()
{
    ImGui_ImplOpenGL3_DestroyDeviceObjects();
}

void    ImGui_ImplOpenGL3_NewFrame()
{
    if (!g_ShaderHandle)
        ImGui_ImplOpenGL3_CreateDeviceObjects();
}

static void ImGui_ImplOpenGL3_SetupRenderState(ImDrawData* draw_data, int fb_width, int fb_height, GLuint vertex_array_object)
{
    // Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled, polygon fill
    glEnable(GL_BLEND);
    glBlendEquation(GL_FUNC_ADD);
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glDisable(GL_STENCIL_TEST);
    glEnable(GL_SCISSOR_TEST);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
    if (g_GlVersion >= 310)
        glDisable(GL_PRIMITIVE_RESTART);
#endif
#ifdef GL_POLYGON_MODE
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
#endif

    // Support for GL 4.5 rarely used glClipControl(GL_UPPER_LEFT)
#if defined(GL_CLIP_ORIGIN)
    bool clip_origin_lower_left = true;
    if (g_HasClipOrigin)
    {
        GLenum current_clip_origin = 0; glGetIntegerv(GL_CLIP_ORIGIN, (GLint*)&current_clip_origin);
        if (current_clip_origin == GL_UPPER_LEFT)
            clip_origin_lower_left = false;
    }
#endif

    // Setup viewport, orthographic projection matrix
    // Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayPos is (0,0) for single viewport apps.
    glViewport(0, 0, (GLsizei)fb_width, (GLsizei)fb_height);
    float L = draw_data->DisplayPos.x;
    float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;
    float T = draw_data->DisplayPos.y;
    float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;
#if defined(GL_CLIP_ORIGIN)
    if (!clip_origin_lower_left) { float tmp = T; T = B; B = tmp; } // Swap top and bottom if origin is upper left
#endif
    const float ortho_projection[4][4] =
    {
        { 2.0f/(R-L),   0.0f,         0.0f,   0.0f },
        { 0.0f,         2.0f/(T-B),   0.0f,   0.0f },
        { 0.0f,         0.0f,        -1.0f,   0.0f },
        { (R+L)/(L-R),  (T+B)/(B-T),  0.0f,   1.0f },
    };
    glUseProgram(g_ShaderHandle);
    glUniform1i(g_AttribLocationTex, 0);
    glUniformMatrix4fv(g_AttribLocationProjMtx, 1, GL_FALSE, &ortho_projection[0][0]);

#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
    if (g_GlVersion >= 330)
        glBindSampler(0, 0); // We use combined texture/sampler state. Applications using GL 3.3 may set that otherwise.
#endif

    (void)vertex_array_object;
#ifndef IMGUI_IMPL_OPENGL_ES2
    glBindVertexArray(vertex_array_object);
#endif

    // Bind vertex/index buffers and setup attributes for ImDrawVert
    glBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_ElementsHandle);
    glEnableVertexAttribArray(g_AttribLocationVtxPos);
    glEnableVertexAttribArray(g_AttribLocationVtxUV);
    glEnableVertexAttribArray(g_AttribLocationVtxColor);
    glVertexAttribPointer(g_AttribLocationVtxPos,   2, GL_FLOAT,         GL_FALSE, sizeof(ImDrawVert), (GLvoid*)IM_OFFSETOF(ImDrawVert, pos));
    glVertexAttribPointer(g_AttribLocationVtxUV,    2, GL_FLOAT,         GL_FALSE, sizeof(ImDrawVert), (GLvoid*)IM_OFFSETOF(ImDrawVert, uv));
    glVertexAttribPointer(g_AttribLocationVtxColor, 4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(ImDrawVert), (GLvoid*)IM_OFFSETOF(ImDrawVert, col));
}

// OpenGL3 Render function.
// Note that this implementation is little overcomplicated because we are saving/setting up/restoring every OpenGL state explicitly.
// This is in order to be able to run within an OpenGL engine that doesn't do so.
void    ImGui_ImplOpenGL3_RenderDrawData(ImDrawData* draw_data)
{
    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
    int fb_width = (int)(draw_data->DisplaySize.x * draw_data->FramebufferScale.x);
    int fb_height = (int)(draw_data->DisplaySize.y * draw_data->FramebufferScale.y);
    if (fb_width <= 0 || fb_height <= 0)
        return;

    // Backup GL state
    GLenum last_active_texture; glGetIntegerv(GL_ACTIVE_TEXTURE, (GLint*)&last_active_texture);
    glActiveTexture(GL_TEXTURE0);
    GLuint last_program; glGetIntegerv(GL_CURRENT_PROGRAM, (GLint*)&last_program);
    GLuint last_texture; glGetIntegerv(GL_TEXTURE_BINDING_2D, (GLint*)&last_texture);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
    GLuint last_sampler; if (g_GlVersion >= 330) { glGetIntegerv(GL_SAMPLER_BINDING, (GLint*)&last_sampler); } else { last_sampler = 0; }
#endif
    GLuint last_array_buffer; glGetIntegerv(GL_ARRAY_BUFFER_BINDING, (GLint*)&last_array_buffer);
#ifndef IMGUI_IMPL_OPENGL_ES2
    GLuint last_vertex_array_object; glGetIntegerv(GL_VERTEX_ARRAY_BINDING, (GLint*)&last_vertex_array_object);
#endif
#ifdef GL_POLYGON_MODE
    GLint last_polygon_mode[2]; glGetIntegerv(GL_POLYGON_MODE, last_polygon_mode);
#endif
    GLint last_viewport[4]; glGetIntegerv(GL_VIEWPORT, last_viewport);
    GLint last_scissor_box[4]; glGetIntegerv(GL_SCISSOR_BOX, last_scissor_box);
    GLenum last_blend_src_rgb; glGetIntegerv(GL_BLEND_SRC_RGB, (GLint*)&last_blend_src_rgb);
    GLenum last_blend_dst_rgb; glGetIntegerv(GL_BLEND_DST_RGB, (GLint*)&last_blend_dst_rgb);
    GLenum last_blend_src_alpha; glGetIntegerv(GL_BLEND_SRC_ALPHA, (GLint*)&last_blend_src_alpha);
    GLenum last_blend_dst_alpha; glGetIntegerv(GL_BLEND_DST_ALPHA, (GLint*)&last_blend_dst_alpha);
    GLenum last_blend_equation_rgb; glGetIntegerv(GL_BLEND_EQUATION_RGB, (GLint*)&last_blend_equation_rgb);
    GLenum last_blend_equation_alpha; glGetIntegerv(GL_BLEND_EQUATION_ALPHA, (GLint*)&last_blend_equation_alpha);
    GLboolean last_enable_blend = glIsEnabled(GL_BLEND);
    GLboolean last_enable_cull_face = glIsEnabled(GL_CULL_FACE);
    GLboolean last_enable_depth_test = glIsEnabled(GL_DEPTH_TEST);
    GLboolean last_enable_stencil_test = glIsEnabled(GL_STENCIL_TEST);
    GLboolean last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
    GLboolean last_enable_primitive_restart = (g_GlVersion >= 310) ? glIsEnabled(GL_PRIMITIVE_RESTART) : GL_FALSE;
#endif

    // Setup desired GL state
    // Recreate the VAO every time (this is to easily allow multiple GL contexts to be rendered to. VAO are not shared among GL contexts)
    // The renderer would actually work without any VAO bound, but then our VertexAttrib calls would overwrite the default one currently bound.
    GLuint vertex_array_object = 0;
#ifndef IMGUI_IMPL_OPENGL_ES2
    glGenVertexArrays(1, &vertex_array_object);
#endif
    ImGui_ImplOpenGL3_SetupRenderState(draw_data, fb_width, fb_height, vertex_array_object);

    // Will project scissor/clipping rectangles into framebuffer space
    ImVec2 clip_off = draw_data->DisplayPos;         // (0,0) unless using multi-viewports
    ImVec2 clip_scale = draw_data->FramebufferScale; // (1,1) unless using retina display which are often (2,2)

    // Render command lists
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];

        // Upload vertex/index buffers
        glBufferData(GL_ARRAY_BUFFER, (GLsizeiptr)cmd_list->VtxBuffer.Size * (int)sizeof(ImDrawVert), (const GLvoid*)cmd_list->VtxBuffer.Data, GL_STREAM_DRAW);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, (GLsizeiptr)cmd_list->IdxBuffer.Size * (int)sizeof(ImDrawIdx), (const GLvoid*)cmd_list->IdxBuffer.Data, GL_STREAM_DRAW);

        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
            if (pcmd->UserCallback != NULL)
            {
                // User callback, registered via ImDrawList::AddCallback()
                // (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to reset render state.)
                if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
                    ImGui_ImplOpenGL3_SetupRenderState(draw_data, fb_width, fb_height, vertex_array_object);
                else
                    pcmd->UserCallback(cmd_list, pcmd);
            }
            else
            {
                // Project scissor/clipping rectangles into framebuffer space
                ImVec4 clip_rect;
                clip_rect.x = (pcmd->ClipRect.x - clip_off.x) * clip_scale.x;
                clip_rect.y = (pcmd->ClipRect.y - clip_off.y) * clip_scale.y;
                clip_rect.z = (pcmd->ClipRect.z - clip_off.x) * clip_scale.x;
                clip_rect.w = (pcmd->ClipRect.w - clip_off.y) * clip_scale.y;

                if (clip_rect.x < fb_width && clip_rect.y < fb_height && clip_rect.z >= 0.0f && clip_rect.w >= 0.0f)
                {
                    // Apply scissor/clipping rectangle
                    glScissor((int)clip_rect.x, (int)(fb_height - clip_rect.w), (int)(clip_rect.z - clip_rect.x), (int)(clip_rect.w - clip_rect.y));

                    // Bind texture, Draw
                    glBindTexture(GL_TEXTURE_2D, (GLuint)(intptr_t)pcmd->GetTexID());
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_VTX_OFFSET
                    if (g_GlVersion >= 320)
                        glDrawElementsBaseVertex(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, (void*)(intptr_t)(pcmd->IdxOffset * sizeof(ImDrawIdx)), (GLint)pcmd->VtxOffset);
                    else
#endif
                    glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, (void*)(intptr_t)(pcmd->IdxOffset * sizeof(ImDrawIdx)));
                }
            }
        }
    }

    // Destroy the temporary VAO
#ifndef IMGUI_IMPL_OPENGL_ES2
    glDeleteVertexArrays(1, &vertex_array_object);
#endif

    // Restore modified GL state
    glUseProgram(last_program);
    glBindTexture(GL_TEXTURE_2D, last_texture);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
    if (g_GlVersion >= 330)
        glBindSampler(0, last_sampler);
#endif
    glActiveTexture(last_active_texture);
#ifndef IMGUI_IMPL_OPENGL_ES2
    glBindVertexArray(last_vertex_array_object);
#endif
    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
    glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);
    glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);
    if (last_enable_blend) glEnable(GL_BLEND); else glDisable(GL_BLEND);
    if (last_enable_cull_face) glEnable(GL_CULL_FACE); else glDisable(GL_CULL_FACE);
    if (last_enable_depth_test) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);
    if (last_enable_stencil_test) glEnable(GL_STENCIL_TEST); else glDisable(GL_STENCIL_TEST);
    if (last_enable_scissor_test) glEnable(GL_SCISSOR_TEST); else glDisable(GL_SCISSOR_TEST);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
    if (g_GlVersion >= 310) { if (last_enable_primitive_restart) glEnable(GL_PRIMITIVE_RESTART); else glDisable(GL_PRIMITIVE_RESTART); }
#endif

#ifdef GL_POLYGON_MODE
    glPolygonMode(GL_FRONT_AND_BACK, (GLenum)last_polygon_mode[0]);
#endif
    glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);
    glScissor(last_scissor_box[0], last_scissor_box[1], (GLsizei)last_scissor_box[2], (GLsizei)last_scissor_box[3]);
}

bool ImGui_ImplOpenGL3_CreateFontsTexture()
{
    // Build texture atlas
    ImGuiIO& io = ImGui::GetIO();
    unsigned char* pixels;
    int width, height;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   // Load as RGBA 32-bit (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.

    // Upload texture to graphics system
    GLint last_texture;
    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
    glGenTextures(1, &g_FontTexture);
    glBindTexture(GL_TEXTURE_2D, g_FontTexture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
#ifdef GL_UNPACK_ROW_LENGTH
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
#endif
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);

    // Store our identifier
    io.Fonts->SetTexID((ImTextureID)(intptr_t)g_FontTexture);

    // Restore state
    glBindTexture(GL_TEXTURE_2D, last_texture);

    return true;
}

void ImGui_ImplOpenGL3_DestroyFontsTexture()
{
    if (g_FontTexture)
    {
        ImGuiIO& io = ImGui::GetIO();
        glDeleteTextures(1, &g_FontTexture);
        io.Fonts->SetTexID(0);
        g_FontTexture = 0;
    }
}

// If you get an error please report on github. You may try different GL context version or GLSL version. See GL<>GLSL version table at the top of this file.
static bool CheckShader(GLuint handle, const char* desc)
{
    GLint status = 0, log_length = 0;
    glGetShaderiv(handle, GL_COMPILE_STATUS, &status);
    glGetShaderiv(handle, GL_INFO_LOG_LENGTH, &log_length);
    if ((GLboolean)status == GL_FALSE)
        fprintf(stderr, "ERROR: ImGui_ImplOpenGL3_CreateDeviceObjects: failed to compile %s!\n", desc);
    if (log_length > 1)
    {
        ImVector<char> buf;
        buf.resize((int)(log_length + 1));
        glGetShaderInfoLog(handle, log_length, NULL, (GLchar*)buf.begin());
        fprintf(stderr, "%s\n", buf.begin());
    }
    return (GLboolean)status == GL_TRUE;
}

// If you get an error please report on GitHub. You may try different GL context version or GLSL version.
static bool CheckProgram(GLuint handle, const char* desc)
{
    GLint status = 0, log_length = 0;
    glGetProgramiv(handle, GL_LINK_STATUS, &status);
    glGetProgramiv(handle, GL_INFO_LOG_LENGTH, &log_length);
    if ((GLboolean)status == GL_FALSE)
        fprintf(stderr, "ERROR: ImGui_ImplOpenGL3_CreateDeviceObjects: failed to link %s! (with GLSL '%s')\n", desc, g_GlslVersionString);
    if (log_length > 1)
    {
        ImVector<char> buf;
        buf.resize((int)(log_length + 1));
        glGetProgramInfoLog(handle, log_length, NULL, (GLchar*)buf.begin());
        fprintf(stderr, "%s\n", buf.begin());
    }
    return (GLboolean)status == GL_TRUE;
}

bool    ImGui_ImplOpenGL3_CreateDeviceObjects()
{
    // Backup GL state
    GLint last_texture, last_array_buffer;
    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
    glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);
#ifndef IMGUI_IMPL_OPENGL_ES2
    GLint last_vertex_array;
    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);
#endif

    // Parse GLSL version string
    int glsl_version = 130;
    sscanf(g_GlslVersionString, "#version %d", &glsl_version);

    const GLchar* vertex_shader_glsl_120 =
        "uniform mat4 ProjMtx;\n"
        "attribute vec2 Position;\n"
        "attribute vec2 UV;\n"
        "attribute vec4 Color;\n"
        "varying vec2 Frag_UV;\n"
        "varying vec4 Frag_Color;\n"
        "void main()\n"
        "{\n"
        "    Frag_UV = UV;\n"
        "    Frag_Color = Color;\n"
        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
        "}\n";

    const GLchar* vertex_shader_glsl_130 =
        "uniform mat4 ProjMtx;\n"
        "in vec2 Position;\n"
        "in vec2 UV;\n"
        "in vec4 Color;\n"
        "out vec2 Frag_UV;\n"
        "out vec4 Frag_Color;\n"
        "void main()\n"
        "{\n"
        "    Frag_UV = UV;\n"
        "    Frag_Color = Color;\n"
        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
        "}\n";

    const GLchar* vertex_shader_glsl_300_es =
        "precision mediump float;\n"
        "layout (location = 0) in vec2 Position;\n"
        "layout (location = 1) in vec2 UV;\n"
        "layout (location = 2) in vec4 Color;\n"
        "uniform mat4 ProjMtx;\n"
        "out vec2 Frag_UV;\n"
        "out vec4 Frag_Color;\n"
        "void main()\n"
        "{\n"
        "    Frag_UV = UV;\n"
        "    Frag_Color = Color;\n"
        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
        "}\n";

    const GLchar* vertex_shader_glsl_410_core =
        "layout (location = 0) in vec2 Position;\n"
        "layout (location = 1) in vec2 UV;\n"
        "layout (location = 2) in vec4 Color;\n"
        "uniform mat4 ProjMtx;\n"
        "out vec2 Frag_UV;\n"
        "out vec4 Frag_Color;\n"
        "void main()\n"
        "{\n"
        "    Frag_UV = UV;\n"
        "    Frag_Color = Color;\n"
        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
        "}\n";

    const GLchar* fragment_shader_glsl_120 =
        "#ifdef GL_ES\n"
        "    precision mediump float;\n"
        "#endif\n"
        "uniform sampler2D Texture;\n"
        "varying vec2 Frag_UV;\n"
        "varying vec4 Frag_Color;\n"
        "void main()\n"
        "{\n"
        "    gl_FragColor = Frag_Color * texture2D(Texture, Frag_UV.st);\n"
        "}\n";

    const GLchar* fragment_shader_glsl_130 =
        "uniform sampler2D Texture;\n"
        "in vec2 Frag_UV;\n"
        "in vec4 Frag_Color;\n"
        "out vec4 Out_Color;\n"
        "void main()\n"
        "{\n"
        "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
        "}\n";

    const GLchar* fragment_shader_glsl_300_es =
        "precision mediump float;\n"
        "uniform sampler2D Texture;\n"
        "in vec2 Frag_UV;\n"
        "in vec4 Frag_Color;\n"
        "layout (location = 0) out vec4 Out_Color;\n"
        "void main()\n"
        "{\n"
        "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
        "}\n";

    const GLchar* fragment_shader_glsl_410_core =
        "in vec2 Frag_UV;\n"
        "in vec4 Frag_Color;\n"
        "uniform sampler2D Texture;\n"
        "layout (location = 0) out vec4 Out_Color;\n"
        "void main()\n"
        "{\n"
        "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
        "}\n";

    // Select shaders matching our GLSL versions
    const GLchar* vertex_shader = NULL;
    const GLchar* fragment_shader = NULL;
    if (glsl_version < 130)
    {
        vertex_shader = vertex_shader_glsl_120;
        fragment_shader = fragment_shader_glsl_120;
    }
    else if (glsl_version >= 410)
    {
        vertex_shader = vertex_shader_glsl_410_core;
        fragment_shader = fragment_shader_glsl_410_core;
    }
    else if (glsl_version == 300)
    {
        vertex_shader = vertex_shader_glsl_300_es;
        fragment_shader = fragment_shader_glsl_300_es;
    }
    else
    {
        vertex_shader = vertex_shader_glsl_130;
        fragment_shader = fragment_shader_glsl_130;
    }

    // Create shaders
    const GLchar* vertex_shader_with_version[2] = { g_GlslVersionString, vertex_shader };
    GLuint vert_handle = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vert_handle, 2, vertex_shader_with_version, NULL);
    glCompileShader(vert_handle);
    CheckShader(vert_handle, "vertex shader");

    const GLchar* fragment_shader_with_version[2] = { g_GlslVersionString, fragment_shader };
    GLuint frag_handle = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(frag_handle, 2, fragment_shader_with_version, NULL);
    glCompileShader(frag_handle);
    CheckShader(frag_handle, "fragment shader");

    // Link
    g_ShaderHandle = glCreateProgram();
    glAttachShader(g_ShaderHandle, vert_handle);
    glAttachShader(g_ShaderHandle, frag_handle);
    glLinkProgram(g_ShaderHandle);
    CheckProgram(g_ShaderHandle, "shader program");

    glDetachShader(g_ShaderHandle, vert_handle);
    glDetachShader(g_ShaderHandle, frag_handle);
    glDeleteShader(vert_handle);
    glDeleteShader(frag_handle);

    g_AttribLocationTex = glGetUniformLocation(g_ShaderHandle, "Texture");
    g_AttribLocationProjMtx = glGetUniformLocation(g_ShaderHandle, "ProjMtx");
    g_AttribLocationVtxPos = (GLuint)glGetAttribLocation(g_ShaderHandle, "Position");
    g_AttribLocationVtxUV = (GLuint)glGetAttribLocation(g_ShaderHandle, "UV");
    g_AttribLocationVtxColor = (GLuint)glGetAttribLocation(g_ShaderHandle, "Color");

    // Create buffers
    glGenBuffers(1, &g_VboHandle);
    glGenBuffers(1, &g_ElementsHandle);

    ImGui_ImplOpenGL3_CreateFontsTexture();

    // Restore modified GL state
    glBindTexture(GL_TEXTURE_2D, last_texture);
    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
#ifndef IMGUI_IMPL_OPENGL_ES2
    glBindVertexArray(last_vertex_array);
#endif

    return true;
}

void    ImGui_ImplOpenGL3_DestroyDeviceObjects()
{
    if (g_VboHandle)        { glDeleteBuffers(1, &g_VboHandle); g_VboHandle = 0; }
    if (g_ElementsHandle)   { glDeleteBuffers(1, &g_ElementsHandle); g_ElementsHandle = 0; }
    if (g_ShaderHandle)     { glDeleteProgram(g_ShaderHandle); g_ShaderHandle = 0; }

    ImGui_ImplOpenGL3_DestroyFontsTexture();
}

```

`Private Esp/imgui/imgui_impl_opengl3.h`:

```h
// dear imgui: Renderer Backend for modern OpenGL with shaders / programmatic pipeline
// - Desktop GL: 2.x 3.x 4.x
// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)
// This needs to be used along with a Platform Backend (e.g. GLFW, SDL, Win32, custom..)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID!
//  [x] Renderer: Desktop GL only: Support for large meshes (64k+ vertices) with 16-bit indices.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this. 
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.
// Read online: https://github.com/ocornut/imgui/tree/master/docs

// About Desktop OpenGL function loaders:
//  Modern Desktop OpenGL doesn't have a standard portable header file to load OpenGL function pointers.
//  Helper libraries are often used for this purpose! Here we are supporting a few common ones (gl3w, glew, glad).
//  You may use another loader/header of your choice (glext, glLoadGen, etc.), or chose to manually implement your own.

// About GLSL version:
//  The 'glsl_version' initialization parameter should be NULL (default) or a "#version XXX" string.
//  On computer platform the GLSL version default to "#version 130". On OpenGL ES 3 platform it defaults to "#version 300 es"
//  Only override if your GL version doesn't handle this GLSL version. See GLSL version table at the top of imgui_impl_opengl3.cpp.

#pragma once
#include "imgui.h"      // IMGUI_IMPL_API

// Backend API
IMGUI_IMPL_API bool     ImGui_ImplOpenGL3_Init(const char* glsl_version = NULL);
IMGUI_IMPL_API void     ImGui_ImplOpenGL3_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplOpenGL3_NewFrame();
IMGUI_IMPL_API void     ImGui_ImplOpenGL3_RenderDrawData(ImDrawData* draw_data);

// (Optional) Called by Init/NewFrame/Shutdown
IMGUI_IMPL_API bool     ImGui_ImplOpenGL3_CreateFontsTexture();
IMGUI_IMPL_API void     ImGui_ImplOpenGL3_DestroyFontsTexture();
IMGUI_IMPL_API bool     ImGui_ImplOpenGL3_CreateDeviceObjects();
IMGUI_IMPL_API void     ImGui_ImplOpenGL3_DestroyDeviceObjects();

// Specific OpenGL ES versions
//#define IMGUI_IMPL_OPENGL_ES2     // Auto-detected on Emscripten
//#define IMGUI_IMPL_OPENGL_ES3     // Auto-detected on iOS/Android

// Attempt to auto-detect the default Desktop GL loader based on available header files.
// If auto-detection fails or doesn't select the same GL loader file as used by your application,
// you are likely to get a crash in ImGui_ImplOpenGL3_Init().
// You can explicitly select a loader by using one of the '#define IMGUI_IMPL_OPENGL_LOADER_XXX' in imconfig.h or compiler command-line.
#if !defined(IMGUI_IMPL_OPENGL_ES2) \
 && !defined(IMGUI_IMPL_OPENGL_ES3) \
 && !defined(IMGUI_IMPL_OPENGL_LOADER_GL3W) \
 && !defined(IMGUI_IMPL_OPENGL_LOADER_GLEW) \
 && !defined(IMGUI_IMPL_OPENGL_LOADER_GLAD) \
 && !defined(IMGUI_IMPL_OPENGL_LOADER_GLAD2) \
 && !defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING2) \
 && !defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING3) \
 && !defined(IMGUI_IMPL_OPENGL_LOADER_CUSTOM)

// Try to detect GLES on matching platforms
#if defined(__APPLE__)
#include "TargetConditionals.h"
#endif
#if (defined(__APPLE__) && (TARGET_OS_IOS || TARGET_OS_TV)) || (defined(__ANDROID__))
#define IMGUI_IMPL_OPENGL_ES3               // iOS, Android  -> GL ES 3, "#version 300 es"
#elif defined(__EMSCRIPTEN__)
#define IMGUI_IMPL_OPENGL_ES2               // Emscripten    -> GL ES 2, "#version 100"

// Otherwise try to detect supported Desktop OpenGL loaders..
#elif defined(__has_include)
#if __has_include(<GL/glew.h>)
    #define IMGUI_IMPL_OPENGL_LOADER_GLEW
#elif __has_include(<glad/glad.h>)
    #define IMGUI_IMPL_OPENGL_LOADER_GLAD
#elif __has_include(<glad/gl.h>)
    #define IMGUI_IMPL_OPENGL_LOADER_GLAD2
#elif __has_include(<GL/gl3w.h>)
    #define IMGUI_IMPL_OPENGL_LOADER_GL3W
#elif __has_include(<glbinding/glbinding.h>)
    #define IMGUI_IMPL_OPENGL_LOADER_GLBINDING3
#elif __has_include(<glbinding/Binding.h>)
    #define IMGUI_IMPL_OPENGL_LOADER_GLBINDING2
#else
    #error "Cannot detect OpenGL loader!"
#endif
#else
    #define IMGUI_IMPL_OPENGL_LOADER_GL3W   // Default to GL3W embedded in our repository
#endif

#endif

```

`Private Esp/imgui/imgui_impl_win32.cpp`:

```cpp
// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.
//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).
// Missing features:
//  [ ] Platform: Gamepad support (best leaving it to user application to fill io.NavInputs[] with gamepad inputs from their source of choice).

#include "imgui.h"
#include "imgui_impl_win32.h"
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <tchar.h>

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.
//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.
//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).
//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.
//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.
//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).
//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.
//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.
//  2018-01-08: Inputs: Added mapping for ImGuiKey_Insert.
//  2018-01-05: Inputs: Added WM_LBUTTONDBLCLK double-click handlers for window classes with the CS_DBLCLKS flag.
//  2017-10-23: Inputs: Added WM_SYSKEYDOWN / WM_SYSKEYUP handlers so e.g. the VK_MENU key can be read.
//  2017-10-23: Inputs: Using Win32 ::SetCapture/::GetCapture() to retrieve mouse positions outside the client area when dragging. 
//  2016-11-12: Inputs: Only call Win32 ::SetCursor(NULL) when io.MouseDrawCursor is set.

// Win32 Data
static HWND                 g_hWnd = 0;
static INT64                g_Time = 0;
static INT64                g_TicksPerSecond = 0;
static ImGuiMouseCursor     g_LastMouseCursor = ImGuiMouseCursor_COUNT;

// Functions
bool    ImGui_ImplWin32_Init(void* hwnd)
{
    if (!::QueryPerformanceFrequency((LARGE_INTEGER *)&g_TicksPerSecond))
        return false;
    if (!::QueryPerformanceCounter((LARGE_INTEGER *)&g_Time))
        return false;

    // Setup back-end capabilities flags
    g_hWnd = (HWND)hwnd;
    ImGuiIO& io = ImGui::GetIO();
    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)
    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)
    io.BackendPlatformName = "imgui_impl_win32";
    io.ImeWindowHandle = hwnd;

    // Keyboard mapping. ImGui will use those indices to peek into the io.KeysDown[] array that we will update during the application lifetime.
    io.KeyMap[ImGuiKey_Tab] = VK_TAB;
    io.KeyMap[ImGuiKey_LeftArrow] = VK_LEFT;
    io.KeyMap[ImGuiKey_RightArrow] = VK_RIGHT;
    io.KeyMap[ImGuiKey_UpArrow] = VK_UP;
    io.KeyMap[ImGuiKey_DownArrow] = VK_DOWN;
    io.KeyMap[ImGuiKey_PageUp] = VK_PRIOR;
    io.KeyMap[ImGuiKey_PageDown] = VK_NEXT;
    io.KeyMap[ImGuiKey_Home] = VK_HOME;
    io.KeyMap[ImGuiKey_End] = VK_END;
    io.KeyMap[ImGuiKey_Insert] = VK_INSERT;
    io.KeyMap[ImGuiKey_Delete] = VK_DELETE;
    io.KeyMap[ImGuiKey_Backspace] = VK_BACK;
    io.KeyMap[ImGuiKey_Space] = VK_SPACE;
    io.KeyMap[ImGuiKey_Enter] = VK_RETURN;
    io.KeyMap[ImGuiKey_Escape] = VK_ESCAPE;
    io.KeyMap[ImGuiKey_A] = 'A';
    io.KeyMap[ImGuiKey_C] = 'C';
    io.KeyMap[ImGuiKey_V] = 'V';
    io.KeyMap[ImGuiKey_X] = 'X';
    io.KeyMap[ImGuiKey_Y] = 'Y';
    io.KeyMap[ImGuiKey_Z] = 'Z';

    return true;
}

void    ImGui_ImplWin32_Shutdown()
{
    g_hWnd = (HWND)0;
}

static bool ImGui_ImplWin32_UpdateMouseCursor()
{
    ImGuiIO& io = ImGui::GetIO();
    if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)
        return false;

    ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
    if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)
    {
        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
        ::SetCursor(NULL);
    }
    else
    {
        // Show OS mouse cursor
        LPTSTR win32_cursor = IDC_ARROW;
        switch (imgui_cursor)
        {
        case ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; break;
        case ImGuiMouseCursor_TextInput:    win32_cursor = IDC_IBEAM; break;
        case ImGuiMouseCursor_ResizeAll:    win32_cursor = IDC_SIZEALL; break;
        case ImGuiMouseCursor_ResizeEW:     win32_cursor = IDC_SIZEWE; break;
        case ImGuiMouseCursor_ResizeNS:     win32_cursor = IDC_SIZENS; break;
        case ImGuiMouseCursor_ResizeNESW:   win32_cursor = IDC_SIZENESW; break;
        case ImGuiMouseCursor_ResizeNWSE:   win32_cursor = IDC_SIZENWSE; break;
        case ImGuiMouseCursor_Hand:         win32_cursor = IDC_HAND; break;
        }
        ::SetCursor(::LoadCursor(NULL, win32_cursor));
    }
    return true;
}

static void ImGui_ImplWin32_UpdateMousePos()
{
    ImGuiIO& io = ImGui::GetIO();

    // Set OS mouse position if requested (rarely used, only when ImGuiConfigFlags_NavEnableSetMousePos is enabled by user)
    if (io.WantSetMousePos)
    {
        POINT pos = { (int)io.MousePos.x, (int)io.MousePos.y };
        ::ClientToScreen(g_hWnd, &pos);
        ::SetCursorPos(pos.x, pos.y);
    }

    // Set mouse position
    io.MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
    POINT pos;
    if (::GetActiveWindow() == g_hWnd && ::GetCursorPos(&pos))
        if (::ScreenToClient(g_hWnd, &pos))
            io.MousePos = ImVec2((float)pos.x, (float)pos.y);
}

void    ImGui_ImplWin32_NewFrame()
{
    ImGuiIO& io = ImGui::GetIO();

    // Setup display size (every frame to accommodate for window resizing)
    RECT rect;
    ::GetClientRect(g_hWnd, &rect);
    io.DisplaySize = ImVec2((float)(rect.right - rect.left), (float)(rect.bottom - rect.top));

    // Setup time step
    INT64 current_time;
    ::QueryPerformanceCounter((LARGE_INTEGER *)&current_time);
    io.DeltaTime = (float)(current_time - g_Time) / g_TicksPerSecond;
    g_Time = current_time;

    // Read keyboard modifiers inputs
    io.KeyCtrl = (::GetKeyState(VK_CONTROL) & 0x8000) != 0;
    io.KeyShift = (::GetKeyState(VK_SHIFT) & 0x8000) != 0;
    io.KeyAlt = (::GetKeyState(VK_MENU) & 0x8000) != 0;
    io.KeySuper = false;
    // io.KeysDown[], io.MousePos, io.MouseDown[], io.MouseWheel: filled by the WndProc handler below.

    // Update OS mouse position
    ImGui_ImplWin32_UpdateMousePos();

    // Update OS mouse cursor with the cursor requested by imgui
    ImGuiMouseCursor mouse_cursor = io.MouseDrawCursor ? ImGuiMouseCursor_None : ImGui::GetMouseCursor();
    if (g_LastMouseCursor != mouse_cursor)
    {
        g_LastMouseCursor = mouse_cursor;
        ImGui_ImplWin32_UpdateMouseCursor();
    }
}

// Allow compilation with old Windows SDK. MinGW doesn't have default _WIN32_WINNT/WINVER versions.
#ifndef WM_MOUSEHWHEEL
#define WM_MOUSEHWHEEL 0x020E
#endif

// Process Win32 mouse/keyboard inputs. 
// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.
// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.
// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.
// PS: In this Win32 handler, we use the capture API (GetCapture/SetCapture/ReleaseCapture) to be able to read mouse coordinations when dragging mouse outside of our window bounds.
// PS: We treat DBLCLK messages as regular mouse down messages, so this code will work on windows classes that have the CS_DBLCLKS flag set. Our own example app code doesn't set this flag.
IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (ImGui::GetCurrentContext() == NULL)
        return 0;

    ImGuiIO& io = ImGui::GetIO();
    switch (msg)
    {
    case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK:
    {
        int button = 0;
        if (msg == WM_LBUTTONDOWN || msg == WM_LBUTTONDBLCLK) button = 0;
        if (msg == WM_RBUTTONDOWN || msg == WM_RBUTTONDBLCLK) button = 1;
        if (msg == WM_MBUTTONDOWN || msg == WM_MBUTTONDBLCLK) button = 2;
        if (!ImGui::IsAnyMouseDown() && ::GetCapture() == NULL)
            ::SetCapture(hwnd);
        io.MouseDown[button] = true;
        return 0;
    }
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    {
        int button = 0;
        if (msg == WM_LBUTTONUP) button = 0;
        if (msg == WM_RBUTTONUP) button = 1;
        if (msg == WM_MBUTTONUP) button = 2;
        io.MouseDown[button] = false;
        if (!ImGui::IsAnyMouseDown() && ::GetCapture() == hwnd)
            ::ReleaseCapture();
        return 0;
    }
    case WM_MOUSEWHEEL:
        io.MouseWheel += (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA;
        return 0;
    case WM_MOUSEHWHEEL:
        io.MouseWheelH += (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA;
        return 0;
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        if (wParam < 256)
            io.KeysDown[wParam] = 1;
        return 0;
    case WM_KEYUP:
    case WM_SYSKEYUP:
        if (wParam < 256)
            io.KeysDown[wParam] = 0;
        return 0;
    case WM_CHAR:
        // You can also use ToAscii()+GetKeyboardState() to retrieve characters.
        if (wParam > 0 && wParam < 0x10000)
            io.AddInputCharacter((unsigned short)wParam);
        return 0;
    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT && ImGui_ImplWin32_UpdateMouseCursor())
            return 1;
        return 0;
    }
    return 0;
}


```

`Private Esp/imgui/imgui_impl_win32.h`:

```h
// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.
//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).
// Missing features:
//  [ ] Platform: Gamepad support (best leaving it to user application to fill io.NavInputs[] with gamepad inputs from their source of choice).

#pragma once

IMGUI_IMPL_API bool     ImGui_ImplWin32_Init(void* hwnd);
IMGUI_IMPL_API void     ImGui_ImplWin32_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplWin32_NewFrame();

// Handler for Win32 messages, update mouse/keyboard data.
// You may or not need this for your implementation, but it can serve as reference for handling inputs.
// Intentionally commented out to avoid dragging dependencies on <windows.h> types. You can COPY this line into your .cpp code instead.
/*
IMGUI_IMPL_API LRESULT  ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
*/

```

`Private Esp/imgui/imgui_internal.h`:

```h
// dear imgui, v1.67 WIP
// (internal structures/api)

// You may use this file to debug, understand or extend ImGui features but we don't provide any guarantee of forward compatibility!
// Set:
//   #define IMGUI_DEFINE_MATH_OPERATORS
// To implement maths operators for ImVec2 (disabled by default to not collide with using IM_VEC2_CLASS_EXTRA along with your own math types+operators)

#pragma once

#ifndef IMGUI_VERSION
#error Must include imgui.h before imgui_internal.h
#endif

#include <stdio.h>      // FILE*
#include <stdlib.h>     // NULL, malloc, free, qsort, atoi, atof
#include <math.h>       // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf
#include <limits.h>     // INT_MIN, INT_MAX

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4251) // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"        // for stb_textedit.h
#pragma clang diagnostic ignored "-Wmissing-prototypes"     // for stb_textedit.h
#pragma clang diagnostic ignored "-Wold-style-cast"
#endif

//-----------------------------------------------------------------------------
// Forward Declarations
//-----------------------------------------------------------------------------

struct ImRect;                      // An axis-aligned rectangle (2 points)
struct ImDrawDataBuilder;           // Helper to build a ImDrawData instance
struct ImDrawListSharedData;        // Data shared between all ImDrawList instances
struct ImGuiColorMod;               // Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColumnData;             // Storage data for a single column
struct ImGuiColumnsSet;             // Storage data for a columns set
struct ImGuiContext;                // Main imgui context
struct ImGuiGroupData;              // Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiInputTextState;         // Internal state of the currently focused/edited text input box
struct ImGuiItemHoveredDataBackup;  // Backup and restore IsItemHovered() internal data
struct ImGuiMenuColumns;            // Simple column measurement, currently used for MenuItem() only
struct ImGuiNavMoveResult;          // Result of a directional navigation move query result
struct ImGuiNextWindowData;         // Storage for SetNexWindow** functions
struct ImGuiPopupRef;               // Storage for current popup stack
struct ImGuiSettingsHandler;        // Storage for one type registered in the .ini file
struct ImGuiStyleMod;               // Stacked style modifier, backup of modified data so we can restore it
struct ImGuiTabBar;                 // Storage for a tab bar
struct ImGuiTabItem;                // Storage for a tab item (within a tab bar)
struct ImGuiWindow;                 // Storage for one window
struct ImGuiWindowTempData;         // Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame)
struct ImGuiWindowSettings;         // Storage for window settings stored in .ini file (we keep one of those even if the actual window wasn't instanced during this session)

// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
typedef int ImGuiLayoutType;        // -> enum ImGuiLayoutType_        // Enum: Horizontal or vertical
typedef int ImGuiButtonFlags;       // -> enum ImGuiButtonFlags_       // Flags: for ButtonEx(), ButtonBehavior()
typedef int ImGuiItemFlags;         // -> enum ImGuiItemFlags_         // Flags: for PushItemFlag()
typedef int ImGuiItemStatusFlags;   // -> enum ImGuiItemStatusFlags_   // Flags: for DC.LastItemStatusFlags
typedef int ImGuiNavHighlightFlags; // -> enum ImGuiNavHighlightFlags_ // Flags: for RenderNavHighlight()
typedef int ImGuiNavDirSourceFlags; // -> enum ImGuiNavDirSourceFlags_ // Flags: for GetNavInputAmount2d()
typedef int ImGuiNavMoveFlags;      // -> enum ImGuiNavMoveFlags_      // Flags: for navigation requests
typedef int ImGuiSeparatorFlags;    // -> enum ImGuiSeparatorFlags_    // Flags: for Separator() - internal
typedef int ImGuiSliderFlags;       // -> enum ImGuiSliderFlags_       // Flags: for SliderBehavior()
typedef int ImGuiDragFlags;         // -> enum ImGuiDragFlags_         // Flags: for DragBehavior()

//-------------------------------------------------------------------------
// STB libraries
//-------------------------------------------------------------------------

namespace ImGuiStb
{

#undef STB_TEXTEDIT_STRING
#undef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_STRING             ImGuiInputTextState
#define STB_TEXTEDIT_CHARTYPE           ImWchar
#define STB_TEXTEDIT_GETWIDTH_NEWLINE   -1.0f
#include "imstb_textedit.h"

} // namespace ImGuiStb

//-----------------------------------------------------------------------------
// Context
//-----------------------------------------------------------------------------

#ifndef GImGui
extern IMGUI_API ImGuiContext* GImGui;  // Current implicit ImGui context pointer
#endif

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

#define IM_PI           3.14159265358979323846f
#ifdef _WIN32
#define IM_NEWLINE      "\r\n"   // Play it nice with Windows users (2018/05 news: Microsoft announced that Notepad will finally display Unix-style carriage returns!)
#else
#define IM_NEWLINE      "\n"
#endif
#define IM_STATIC_ASSERT(_COND)         typedef char static_assertion_##__line__[(_COND)?1:-1]
#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))   // Unsaturated, for display purpose
#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255

// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall
#ifdef _MSC_VER
#define IMGUI_CDECL __cdecl
#else
#define IMGUI_CDECL
#endif

// Helpers: UTF-8 <> wchar
IMGUI_API int           ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end);      // return output UTF-8 bytes count
IMGUI_API int           ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);          // read one character. return input UTF-8 bytes count
IMGUI_API int           ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   // return input UTF-8 bytes count
IMGUI_API int           ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                            // return number of UTF-8 code-points (NOT bytes count)
IMGUI_API int           ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end);                        // return number of bytes to express one char in UTF-8
IMGUI_API int           ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                   // return number of bytes to express string in UTF-8

// Helpers: Misc
IMGUI_API ImU32         ImHash(const void* data, int data_size, ImU32 seed = 0);    // Pass data_size==0 for zero-terminated strings
IMGUI_API void*         ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size = NULL, int padding_bytes = 0);
IMGUI_API FILE*         ImFileOpen(const char* filename, const char* file_open_mode);
static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }
static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }
static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }
static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }
#define ImQsort         qsort

// Helpers: Geometry
IMGUI_API ImVec2        ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p);
IMGUI_API bool          ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API ImVec2        ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API void          ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w);
IMGUI_API ImGuiDir      ImGetDirQuadrantFromDelta(float dx, float dy);

// Helpers: String
IMGUI_API int           ImStricmp(const char* str1, const char* str2);
IMGUI_API int           ImStrnicmp(const char* str1, const char* str2, size_t count);
IMGUI_API void          ImStrncpy(char* dst, const char* src, size_t count);
IMGUI_API char*         ImStrdup(const char* str);
IMGUI_API const char*   ImStrchrRange(const char* str_begin, const char* str_end, char c);
IMGUI_API int           ImStrlenW(const ImWchar* str);
IMGUI_API const char*   ImStreolRange(const char* str, const char* str_end);                // End end-of-line
IMGUI_API const ImWchar*ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin);   // Find beginning-of-line
IMGUI_API const char*   ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);
IMGUI_API void          ImStrTrimBlanks(char* str);
IMGUI_API int           ImFormatString(char* buf, size_t buf_size, const char* fmt, ...) IM_FMTARGS(3);
IMGUI_API int           ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) IM_FMTLIST(3);
IMGUI_API const char*   ImParseFormatFindLoopCallback(const char* format);
IMGUI_API const char*   ImParseFormatFindEnd(const char* format);
IMGUI_API const char*   ImParseFormatTrimDecorations(const char* format, char* buf, int buf_size);
IMGUI_API int           ImParseFormatPrecision(const char* format, int default_value);

// Helpers: ImVec2/ImVec4 operators
// We are keeping those disabled by default so they don't leak in user space, to allow user enabling implicit cast operators between ImVec2 and their own types (using IM_VEC2_CLASS_EXTRA etc.)
// We unfortunately don't have a unary- operator for ImVec2 because this would needs to be defined inside the class itself.
#ifdef IMGUI_DEFINE_MATH_OPERATORS
static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }
static inline ImVec2 operator/(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x/rhs, lhs.y/rhs); }
static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }
static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }
static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }
static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }
static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }
static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }
static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }
static inline ImVec2& operator/=(ImVec2& lhs, const float rhs)                  { lhs.x /= rhs; lhs.y /= rhs; return lhs; }
static inline ImVec4 operator+(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x+rhs.x, lhs.y+rhs.y, lhs.z+rhs.z, lhs.w+rhs.w); }
static inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x-rhs.x, lhs.y-rhs.y, lhs.z-rhs.z, lhs.w-rhs.w); }
static inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x*rhs.x, lhs.y*rhs.y, lhs.z*rhs.z, lhs.w*rhs.w); }
#endif

// Helpers: Maths
// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)
#ifndef IMGUI_DISABLE_MATH_FUNCTIONS
static inline float  ImFabs(float x)                                            { return fabsf(x); }
static inline float  ImSqrt(float x)                                            { return sqrtf(x); }
static inline float  ImPow(float x, float y)                                    { return powf(x, y); }
static inline double ImPow(double x, double y)                                  { return pow(x, y); }
static inline float  ImFmod(float x, float y)                                   { return fmodf(x, y); }
static inline double ImFmod(double x, double y)                                 { return fmod(x, y); }
static inline float  ImCos(float x)                                             { return cosf(x); }
static inline float  ImSin(float x)                                             { return sinf(x); }
static inline float  ImAcos(float x)                                            { return acosf(x); }
static inline float  ImAtan2(float y, float x)                                  { return atan2f(y, x); }
static inline double ImAtof(const char* s)                                      { return atof(s); }
static inline float  ImFloorStd(float x)                                        { return floorf(x); }   // we already uses our own ImFloor() { return (float)(int)v } internally so the standard one wrapper is named differently (it's used by stb_truetype)
static inline float  ImCeil(float x)                                            { return ceilf(x); }
#endif
// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support for variety of types: signed/unsigned int/long long float/double, using templates here but we could also redefine them 6 times
template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }
template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }
// - Misc maths helpers
static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }
static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }
static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }
static inline float  ImLengthSqr(const ImVec4& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y + lhs.z*lhs.z + lhs.w*lhs.w; }
static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / ImSqrt(d); return fail_value; }
static inline float  ImFloor(float f)                                           { return (float)(int)f; }
static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)v.x, (float)(int)v.y); }
static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }
static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }
static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }
static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

// Helper: ImPool<>. Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,
// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.
typedef int ImPoolIdx;
template<typename T>
struct IMGUI_API ImPool
{
    ImVector<T>     Data;       // Contiguous data
    ImGuiStorage    Map;        // ID->Index
    ImPoolIdx       FreeIdx;    // Next free idx to use

    ImPool()    { FreeIdx = 0; }
    ~ImPool()   { Clear(); }
    T*          GetByKey(ImGuiID key)               { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Data[idx] : NULL; }
    T*          GetByIndex(ImPoolIdx n)             { return &Data[n]; }
    ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Data.Data && p < Data.Data + Data.Size); return (ImPoolIdx)(p - Data.Data); }
    T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Data[*p_idx]; *p_idx = FreeIdx; return Add(); }
    void        Clear()                             { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Data[idx].~T(); }  Map.Clear(); Data.clear(); FreeIdx = 0; }
    T*          Add()                               { int idx = FreeIdx; if (idx == Data.Size) { Data.resize(Data.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Data[idx]; } IM_PLACEMENT_NEW(&Data[idx]) T(); return &Data[idx]; }
    void        Remove(ImGuiID key, const T* p)     { Remove(key, GetIndex(p)); }
    void        Remove(ImGuiID key, ImPoolIdx idx)  { Data[idx].~T(); *(int*)&Data[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); }
    void        Reserve(int capacity)               { Data.reserve(capacity); Map.Data.reserve(capacity); }
    int         GetSize() const                     { return Data.Size; }
};

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

// 1D vector (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)
struct ImVec1
{
    float               x;
    ImVec1()            { x = 0.0f; }
    ImVec1(float _x)    { x = _x; }
};

enum ImGuiButtonFlags_
{
    ImGuiButtonFlags_None                   = 0,
    ImGuiButtonFlags_Repeat                 = 1 << 0,   // hold to repeat
    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 1,   // return true on click + release on same item [DEFAULT if no PressedOn* flag is set]
    ImGuiButtonFlags_PressedOnClick         = 1 << 2,   // return true on click (default requires click+release)
    ImGuiButtonFlags_PressedOnRelease       = 1 << 3,   // return true on release (default requires click+release)
    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 4,   // return true on double-click (default requires click+release)
    ImGuiButtonFlags_FlattenChildren        = 1 << 5,   // allow interactions even if a child window is overlapping
    ImGuiButtonFlags_AllowItemOverlap       = 1 << 6,   // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()
    ImGuiButtonFlags_DontClosePopups        = 1 << 7,   // disable automatically closing parent popup on press // [UNUSED]
    ImGuiButtonFlags_Disabled               = 1 << 8,   // disable interactions
    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 9,   // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
    ImGuiButtonFlags_NoKeyModifiers         = 1 << 10,  // disable interaction if a key modifier is held
    ImGuiButtonFlags_NoHoldingActiveID      = 1 << 11,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)
    ImGuiButtonFlags_PressedOnDragDropHold  = 1 << 12,  // press when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
    ImGuiButtonFlags_NoNavFocus             = 1 << 13   // don't override navigation focus when activated
};

enum ImGuiSliderFlags_
{
    ImGuiSliderFlags_None                   = 0,
    ImGuiSliderFlags_Vertical               = 1 << 0
};

enum ImGuiDragFlags_
{
    ImGuiDragFlags_None                     = 0,
    ImGuiDragFlags_Vertical                 = 1 << 0
};

enum ImGuiColumnsFlags_
{
    // Default: 0
    ImGuiColumnsFlags_None                  = 0,
    ImGuiColumnsFlags_NoBorder              = 1 << 0,   // Disable column dividers
    ImGuiColumnsFlags_NoResize              = 1 << 1,   // Disable resizing columns when clicking on the dividers
    ImGuiColumnsFlags_NoPreserveWidths      = 1 << 2,   // Disable column width preservation when adjusting columns
    ImGuiColumnsFlags_NoForceWithinWindow   = 1 << 3,   // Disable forcing columns to fit within window
    ImGuiColumnsFlags_GrowParentContentsSize= 1 << 4    // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.
};

enum ImGuiSelectableFlagsPrivate_
{
    // NB: need to be in sync with last value of ImGuiSelectableFlags_
    ImGuiSelectableFlags_NoHoldingActiveID  = 1 << 10,
    ImGuiSelectableFlags_PressedOnClick     = 1 << 11,
    ImGuiSelectableFlags_PressedOnRelease   = 1 << 12,
    ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 13
};

enum ImGuiSeparatorFlags_
{
    ImGuiSeparatorFlags_None                = 0,
    ImGuiSeparatorFlags_Horizontal          = 1 << 0,   // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar
    ImGuiSeparatorFlags_Vertical            = 1 << 1
};

// Storage for LastItem data
enum ImGuiItemStatusFlags_
{
    ImGuiItemStatusFlags_None               = 0,
    ImGuiItemStatusFlags_HoveredRect        = 1 << 0,
    ImGuiItemStatusFlags_HasDisplayRect     = 1 << 1,
    ImGuiItemStatusFlags_Edited             = 1 << 2    // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)

#ifdef IMGUI_ENABLE_TEST_ENGINE
    , // [imgui-test only]
    ImGuiItemStatusFlags_Openable           = 1 << 10,  // 
    ImGuiItemStatusFlags_Opened             = 1 << 11,  // 
    ImGuiItemStatusFlags_Checkable          = 1 << 12,  // 
    ImGuiItemStatusFlags_Checked            = 1 << 13   //
#endif
};

// FIXME: this is in development, not exposed/functional as a generic feature yet.
enum ImGuiLayoutType_
{
    ImGuiLayoutType_Vertical,
    ImGuiLayoutType_Horizontal
};

enum ImGuiAxis
{
    ImGuiAxis_None = -1,
    ImGuiAxis_X = 0,
    ImGuiAxis_Y = 1
};

enum ImGuiPlotType
{
    ImGuiPlotType_Lines,
    ImGuiPlotType_Histogram
};

enum ImGuiInputSource
{
    ImGuiInputSource_None = 0,
    ImGuiInputSource_Mouse,
    ImGuiInputSource_Nav,
    ImGuiInputSource_NavKeyboard,   // Only used occasionally for storage, not tested/handled by most code
    ImGuiInputSource_NavGamepad,    // "
    ImGuiInputSource_COUNT
};

// FIXME-NAV: Clarify/expose various repeat delay/rate
enum ImGuiInputReadMode
{
    ImGuiInputReadMode_Down,
    ImGuiInputReadMode_Pressed,
    ImGuiInputReadMode_Released,
    ImGuiInputReadMode_Repeat,
    ImGuiInputReadMode_RepeatSlow,
    ImGuiInputReadMode_RepeatFast
};

enum ImGuiNavHighlightFlags_
{
    ImGuiNavHighlightFlags_None         = 0,
    ImGuiNavHighlightFlags_TypeDefault  = 1 << 0,
    ImGuiNavHighlightFlags_TypeThin     = 1 << 1,
    ImGuiNavHighlightFlags_AlwaysDraw   = 1 << 2,
    ImGuiNavHighlightFlags_NoRounding   = 1 << 3
};

enum ImGuiNavDirSourceFlags_
{
    ImGuiNavDirSourceFlags_None         = 0,
    ImGuiNavDirSourceFlags_Keyboard     = 1 << 0,
    ImGuiNavDirSourceFlags_PadDPad      = 1 << 1,
    ImGuiNavDirSourceFlags_PadLStick    = 1 << 2
};

enum ImGuiNavMoveFlags_
{
    ImGuiNavMoveFlags_None                  = 0,
    ImGuiNavMoveFlags_LoopX                 = 1 << 0,   // On failed request, restart from opposite side
    ImGuiNavMoveFlags_LoopY                 = 1 << 1,
    ImGuiNavMoveFlags_WrapX                 = 1 << 2,   // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)
    ImGuiNavMoveFlags_WrapY                 = 1 << 3,   // This is not super useful for provided for completeness
    ImGuiNavMoveFlags_AllowCurrentNavId     = 1 << 4,   // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)
    ImGuiNavMoveFlags_AlsoScoreVisibleSet   = 1 << 5    // Store alternate result in NavMoveResultLocalVisibleSet that only comprise elements that are already fully visible.
};

enum ImGuiNavForward
{
    ImGuiNavForward_None,
    ImGuiNavForward_ForwardQueued,
    ImGuiNavForward_ForwardActive
};

enum ImGuiNavLayer
{
    ImGuiNavLayer_Main  = 0,    // Main scrolling layer
    ImGuiNavLayer_Menu  = 1,    // Menu layer (access with Alt/ImGuiNavInput_Menu)
    ImGuiNavLayer_COUNT
};

enum ImGuiPopupPositionPolicy
{
    ImGuiPopupPositionPolicy_Default,
    ImGuiPopupPositionPolicy_ComboBox
};

// 2D axis aligned bounding-box
// NB: we can't rely on ImVec2 math operators being available here
struct IMGUI_API ImRect
{
    ImVec2      Min;    // Upper-left
    ImVec2      Max;    // Lower-right

    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}
    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}
    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}
    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}

    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
    float       GetWidth() const                    { return Max.x - Min.x; }
    float       GetHeight() const                   { return Max.y - Min.y; }
    ImVec2      GetTL() const                       { return Min; }                   // Top-left
    ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  // Top-right
    ImVec2      GetBL() const                       { return ImVec2(Min.x, Max.y); }  // Bottom-left
    ImVec2      GetBR() const                       { return Max; }                   // Bottom-right
    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }
    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }
    void        Add(const ImVec2& p)                { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }
    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }
    void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }
    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }
    void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }
    void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }
    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }
    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.
    void        Floor()                             { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }
    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }
};

// Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColorMod
{
    ImGuiCol    Col;
    ImVec4      BackupValue;
};

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
struct ImGuiStyleMod
{
    ImGuiStyleVar   VarIdx;
    union           { int BackupInt[2]; float BackupFloat[2]; };
    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }
};

// Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiGroupData
{
    ImVec2      BackupCursorPos;
    ImVec2      BackupCursorMaxPos;
    ImVec1      BackupIndent;
    ImVec1      BackupGroupOffset;
    ImVec2      BackupCurrentLineSize;
    float       BackupCurrentLineTextBaseOffset;
    float       BackupLogLinePosY;
    ImGuiID     BackupActiveIdIsAlive;
    bool        BackupActiveIdPreviousFrameIsAlive;
    bool        AdvanceCursor;
};

// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
struct IMGUI_API ImGuiMenuColumns
{
    int         Count;
    float       Spacing;
    float       Width, NextWidth;
    float       Pos[4], NextWidths[4];

    ImGuiMenuColumns();
    void        Update(int count, float spacing, bool clear);
    float       DeclColumns(float w0, float w1, float w2);
    float       CalcExtraSpace(float avail_w);
};

// Internal state of the currently focused/edited text input box
struct IMGUI_API ImGuiInputTextState
{
    ImGuiID                 ID;                     // widget id owning the text state
    ImVector<ImWchar>       TextW;                  // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.
    ImVector<char>          InitialText;            // backup of end-user buffer at the time of focus (in UTF-8, unaltered)
    ImVector<char>          TempBuffer;             // temporary buffer for callback and other other operations. size=capacity.
    int                     CurLenA, CurLenW;       // we need to maintain our buffer length in both UTF-8 and wchar format.
    int                     BufCapacityA;           // end-user buffer capacity
    float                   ScrollX;
    ImGuiStb::STB_TexteditState StbState;
    float                   CursorAnim;
    bool                    CursorFollow;
    bool                    SelectedAllMouseLock;

    // Temporarily set when active
    ImGuiInputTextFlags     UserFlags;
    ImGuiInputTextCallback  UserCallback;
    void*                   UserCallbackData;

    ImGuiInputTextState()                           { memset(this, 0, sizeof(*this)); }
    void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking
    void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }
    bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }
    void                ClearSelection()            { StbState.select_start = StbState.select_end = StbState.cursor; }
    void                SelectAll()                 { StbState.select_start = 0; StbState.cursor = StbState.select_end = CurLenW; StbState.has_preferred_x = false; }
    void                OnKeyPressed(int key);      // Cannot be inline because we call in code in stb_textedit.h implementation
};

// Windows data saved in imgui.ini file
struct ImGuiWindowSettings
{
    char*       Name;
    ImGuiID     ID;
    ImVec2      Pos;
    ImVec2      Size;
    bool        Collapsed;

    ImGuiWindowSettings() { Name = NULL; ID = 0; Pos = Size = ImVec2(0,0); Collapsed = false; }
};

struct ImGuiSettingsHandler
{
    const char* TypeName;   // Short description stored in .ini file. Disallowed characters: '[' ']'
    ImGuiID     TypeHash;   // == ImHash(TypeName, 0, 0)
    void*       (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);              // Read: Called when entering into a new ini entry e.g. "[Window][Name]"
    void        (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line); // Read: Called for every line of text within an ini entry
    void        (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);      // Write: Output every entries into 'out_buf'
    void*       UserData;

    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
};

// Storage for current popup stack
struct ImGuiPopupRef
{
    ImGuiID             PopupId;        // Set on OpenPopup()
    ImGuiWindow*        Window;         // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
    ImGuiWindow*        ParentWindow;   // Set on OpenPopup()
    int                 OpenFrameCount; // Set on OpenPopup()
    ImGuiID             OpenParentId;   // Set on OpenPopup(), we need this to differenciate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
    ImVec2              OpenPopupPos;   // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
    ImVec2              OpenMousePos;   // Set on OpenPopup(), copy of mouse position at the time of opening popup
};

struct ImGuiColumnData
{
    float               OffsetNorm;         // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
    float               OffsetNormBeforeResize;
    ImGuiColumnsFlags   Flags;              // Not exposed
    ImRect              ClipRect;

    ImGuiColumnData()   { OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = 0; }
};

struct ImGuiColumnsSet
{
    ImGuiID             ID;
    ImGuiColumnsFlags   Flags;
    bool                IsFirstFrame;
    bool                IsBeingResized;
    int                 Current;
    int                 Count;
    float               MinX, MaxX;
    float               LineMinY, LineMaxY;
    float               LoopCallbackPosY;          // Copy of CursorPos
    float               LoopCallbackMaxPosX;       // Copy of CursorMaxPos
    ImVector<ImGuiColumnData> Columns;

    ImGuiColumnsSet()   { Clear(); }
    void Clear()
    {
        ID = 0;
        Flags = 0;
        IsFirstFrame = false;
        IsBeingResized = false;
        Current = 0;
        Count = 1;
        MinX = MaxX = 0.0f;
        LineMinY = LineMaxY = 0.0f;
        LoopCallbackPosY = 0.0f;
        LoopCallbackMaxPosX = 0.0f;
        Columns.clear();
    }
};

// Data shared between all ImDrawList instances
struct IMGUI_API ImDrawListSharedData
{
    ImVec2          TexUvWhitePixel;            // UV of white pixel in the atlas
    ImFont*         Font;                       // Current/default font (optional, for simplified AddText overload)
    float           FontSize;                   // Current/default font size (optional, for simplified AddText overload)
    float           CurveTessellationTol;
    ImVec4          ClipRectFullscreen;         // Value for PushClipRectFullscreen()

    // Const data
    // FIXME: Bake rounded corners fill/borders in atlas
    ImVec2          CircleVtx12[12];

    ImDrawListSharedData();
};

struct ImDrawDataBuilder
{
    ImVector<ImDrawList*>   Layers[2];           // Global layers for: regular, tooltip

    void Clear()            { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }
    void ClearFreeMemory()  { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].clear(); }
    IMGUI_API void FlattenIntoSingleLayer();
};

struct ImGuiNavMoveResult
{
    ImGuiID       ID;           // Best candidate
    ImGuiWindow*  Window;       // Best candidate window
    float         DistBox;      // Best candidate box distance to current NavId
    float         DistCenter;   // Best candidate center distance to current NavId
    float         DistAxial;
    ImRect        RectRel;      // Best candidate bounding box in window relative space

    ImGuiNavMoveResult() { Clear(); }
    void Clear()         { ID = 0; Window = NULL; DistBox = DistCenter = DistAxial = FLT_MAX; RectRel = ImRect(); }
};

// Storage for SetNexWindow** functions
struct ImGuiNextWindowData
{
    ImGuiCond               PosCond;
    ImGuiCond               SizeCond;
    ImGuiCond               ContentSizeCond;
    ImGuiCond               CollapsedCond;
    ImGuiCond               SizeConstraintCond;
    ImGuiCond               FocusCond;
    ImGuiCond               BgAlphaCond;
    ImVec2                  PosVal;
    ImVec2                  PosPivotVal;
    ImVec2                  SizeVal;
    ImVec2                  ContentSizeVal;
    bool                    CollapsedVal;
    ImRect                  SizeConstraintRect;
    ImGuiSizeCallback       SizeCallback;
    void*                   SizeCallbackUserData;
    float                   BgAlphaVal;
    ImVec2                  MenuBarOffsetMinVal;                // This is not exposed publicly, so we don't clear it.

    ImGuiNextWindowData()
    {
        PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;
        PosVal = PosPivotVal = SizeVal = ImVec2(0.0f, 0.0f);
        ContentSizeVal = ImVec2(0.0f, 0.0f);
        CollapsedVal = false;
        SizeConstraintRect = ImRect();
        SizeCallback = NULL;
        SizeCallbackUserData = NULL;
        BgAlphaVal = FLT_MAX;
        MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);
    }

    void    Clear()
    {
        PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;
    }
};

struct ImGuiTabBarSortItem
{
    int         Index;
    float       Width;
};

//-----------------------------------------------------------------------------
// Main imgui context
//-----------------------------------------------------------------------------

struct ImGuiContext
{
    bool                    Initialized;
    bool                    FrameScopeActive;                   // Set by NewFrame(), cleared by EndFrame()/Render()
    bool                    FontAtlasOwnedByContext;            // Io.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
    ImGuiIO                 IO;
    ImGuiStyle              Style;
    ImFont*                 Font;                               // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
    float                   FontSize;                           // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
    float                   FontBaseSize;                       // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
    ImDrawListSharedData    DrawListSharedData;

    double                  Time;
    int                     FrameCount;
    int                     FrameCountEnded;
    int                     FrameCountRendered;
    ImVector<ImGuiWindow*>  Windows;                            // Windows, sorted in display order, back to front
    ImVector<ImGuiWindow*>  WindowsFocusOrder;                  // Windows, sorted in focus order, back to front
    ImVector<ImGuiWindow*>  WindowsSortBuffer;
    ImVector<ImGuiWindow*>  CurrentWindowStack;
    ImGuiStorage            WindowsById;
    int                     WindowsActiveCount;
    ImGuiWindow*            CurrentWindow;                      // Being drawn into
    ImGuiWindow*            HoveredWindow;                      // Will catch mouse inputs
    ImGuiWindow*            HoveredRootWindow;                  // Will catch mouse inputs (for focus/move only)
    ImGuiID                 HoveredId;                          // Hovered widget
    bool                    HoveredIdAllowOverlap;
    ImGuiID                 HoveredIdPreviousFrame;
    float                   HoveredIdTimer;                     // Measure contiguous hovering time
    float                   HoveredIdNotActiveTimer;            // Measure contiguous hovering time where the item has not been active
    ImGuiID                 ActiveId;                           // Active widget
    ImGuiID                 ActiveIdPreviousFrame;
    ImGuiID                 ActiveIdIsAlive;                    // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
    float                   ActiveIdTimer;
    bool                    ActiveIdIsJustActivated;            // Set at the time of activation for one frame
    bool                    ActiveIdAllowOverlap;               // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
    bool                    ActiveIdHasBeenEdited;              // Was the value associated to the widget Edited over the course of the Active state.
    bool                    ActiveIdPreviousFrameIsAlive;
    bool                    ActiveIdPreviousFrameHasBeenEdited;
    int                     ActiveIdAllowNavDirFlags;           // Active widget allows using directional navigation (e.g. can activate a button and move away from it)
    ImVec2                  ActiveIdClickOffset;                // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
    ImGuiWindow*            ActiveIdWindow;
    ImGuiWindow*            ActiveIdPreviousFrameWindow;
    ImGuiInputSource        ActiveIdSource;                     // Activating with mouse or nav (gamepad/keyboard)
    ImGuiID                 LastActiveId;                       // Store the last non-zero ActiveId, useful for animation.
    float                   LastActiveIdTimer;                  // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.
    ImVec2                  LastValidMousePos;
    ImGuiWindow*            MovingWindow;                       // Track the window we clicked on (in order to preserve focus). The actually window that is moved is generally MovingWindow->RootWindow.
    ImVector<ImGuiColorMod> ColorModifiers;                     // Stack for PushStyleColor()/PopStyleColor()
    ImVector<ImGuiStyleMod> StyleModifiers;                     // Stack for PushStyleVar()/PopStyleVar()
    ImVector<ImFont*>       FontStack;                          // Stack for PushFont()/PopFont()
    ImVector<ImGuiPopupRef> OpenPopupStack;                     // Which popups are open (persistent)
    ImVector<ImGuiPopupRef> BeginPopupStack;                    // Which level of BeginPopup() we are in (reset every frame)
    ImGuiNextWindowData     NextWindowData;                     // Storage for SetNextWindow** functions
    bool                    NextTreeNodeOpenVal;                // Storage for SetNextTreeNode** functions
    ImGuiCond               NextTreeNodeOpenCond;

    // Navigation data (for gamepad/keyboard)
    ImGuiWindow*            NavWindow;                          // Focused window for navigation. Could be called 'FocusWindow'
    ImGuiID                 NavId;                              // Focused item for navigation
    ImGuiID                 NavActivateId;                      // ~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()
    ImGuiID                 NavActivateDownId;                  // ~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0
    ImGuiID                 NavActivatePressedId;               // ~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0
    ImGuiID                 NavInputId;                         // ~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0
    ImGuiID                 NavJustTabbedId;                    // Just tabbed to this id.
    ImGuiID                 NavJustMovedToId;                   // Just navigated to this id (result of a successfully MoveRequest)
    ImGuiID                 NavNextActivateId;                  // Set by ActivateItem(), queued until next frame
    ImGuiInputSource        NavInputSource;                     // Keyboard or Gamepad mode? THIS WILL ONLY BE None or NavGamepad or NavKeyboard.
    ImRect                  NavScoringRectScreen;               // Rectangle used for scoring, in screen space. Based of window->DC.NavRefRectRel[], modified for directional navigation scoring.
    int                     NavScoringCount;                    // Metrics for debugging
    ImGuiWindow*            NavWindowingTarget;                 // When selecting a window (holding Menu+FocusPrev/Next, or equivalent of CTRL-TAB) this window is temporarily displayed front-most.
    ImGuiWindow*            NavWindowingTargetAnim;             // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f
    ImGuiWindow*            NavWindowingList;
    float                   NavWindowingTimer;
    float                   NavWindowingHighlightAlpha;
    bool                    NavWindowingToggleLayer;
    ImGuiNavLayer           NavLayer;                           // Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.
    int                     NavIdTabCounter;                    // == NavWindow->DC.FocusIdxTabCounter at time of NavId processing
    bool                    NavIdIsAlive;                       // Nav widget has been seen this frame ~~ NavRefRectRel is valid
    bool                    NavMousePosDirty;                   // When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)
    bool                    NavDisableHighlight;                // When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)
    bool                    NavDisableMouseHover;               // When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.
    bool                    NavAnyRequest;                      // ~~ NavMoveRequest || NavInitRequest
    bool                    NavInitRequest;                     // Init request for appearing window to select first item
    bool                    NavInitRequestFromMove;
    ImGuiID                 NavInitResultId;
    ImRect                  NavInitResultRectRel;
    bool                    NavMoveFromClampedRefRect;          // Set by manual scrolling, if we scroll to a point where NavId isn't visible we reset navigation from visible items
    bool                    NavMoveRequest;                     // Move request for this frame
    ImGuiNavMoveFlags       NavMoveRequestFlags;
    ImGuiNavForward         NavMoveRequestForward;              // None / ForwardQueued / ForwardActive (this is used to navigate sibling parent menus from a child menu)
    ImGuiDir                NavMoveDir, NavMoveDirLast;         // Direction of the move request (left/right/up/down), direction of the previous move request
    ImGuiDir                NavMoveClipDir;
    ImGuiNavMoveResult      NavMoveResultLocal;                 // Best move request candidate within NavWindow
    ImGuiNavMoveResult      NavMoveResultLocalVisibleSet;       // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
    ImGuiNavMoveResult      NavMoveResultOther;                 // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)

    // Render
    ImDrawData              DrawData;                           // Main ImDrawData instance to pass render information to the user
    ImDrawDataBuilder       DrawDataBuilder;
    float                   DimBgRatio;                         // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)
    ImDrawList              OverlayDrawList;                    // Optional software render of mouse cursors, if io.MouseDrawCursor is set + a few debug overlays
    ImGuiMouseCursor        MouseCursor;

    // Drag and Drop
    bool                    DragDropActive;
    bool                    DragDropWithinSourceOrTarget;
    ImGuiDragDropFlags      DragDropSourceFlags;
    int                     DragDropSourceFrameCount;
    int                     DragDropMouseButton;
    ImGuiPayload            DragDropPayload;
    ImRect                  DragDropTargetRect;
    ImGuiID                 DragDropTargetId;
    ImGuiDragDropFlags      DragDropAcceptFlags;
    float                   DragDropAcceptIdCurrRectSurface;    // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
    ImGuiID                 DragDropAcceptIdCurr;               // Target item id (set at the time of accepting the payload)
    ImGuiID                 DragDropAcceptIdPrev;               // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
    int                     DragDropAcceptFrameCount;           // Last time a target expressed a desire to accept the source
    ImVector<unsigned char> DragDropPayloadBufHeap;             // We don't expose the ImVector<> directly
    unsigned char           DragDropPayloadBufLocal[8];         // Local buffer for small payloads

    // Tab bars
    ImPool<ImGuiTabBar>     TabBars;
    ImVector<ImGuiTabBar*>  CurrentTabBar;
    ImVector<ImGuiTabBarSortItem>   TabSortByWidthBuffer;

    // Widget state
    ImGuiInputTextState     InputTextState;
    ImFont                  InputTextPasswordFont;
    ImGuiID                 ScalarAsInputTextId;                // Temporary text input when CTRL+clicking on a slider, etc.
    ImGuiColorEditFlags     ColorEditOptions;                   // Store user options for color edit widgets
    ImVec4                  ColorPickerRef;
    bool                    DragCurrentAccumDirty;
    float                   DragCurrentAccum;                   // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
    float                   DragSpeedDefaultRatio;              // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
    ImVec2                  ScrollbarClickDeltaToGrabCenter;    // Distance between mouse and center of grab box, normalized in parent space. Use storage?
    int                     TooltipOverrideCount;
    ImVector<char>          PrivateClipboard;                   // If no custom clipboard handler is defined

    // Platform support
    ImVec2                  PlatformImePos, PlatformImeLastPos; // Cursor position request & last passed to the OS Input Method Editor

    // Settings
    bool                           SettingsLoaded;
    float                          SettingsDirtyTimer;          // Save .ini Settings to memory when time reaches zero
    ImGuiTextBuffer                SettingsIniData;             // In memory .ini settings
    ImVector<ImGuiSettingsHandler> SettingsHandlers;            // List of .ini settings handlers
    ImVector<ImGuiWindowSettings>  SettingsWindows;             // ImGuiWindow .ini settings entries (parsed from the last loaded .ini file and maintained on saving)

    // Logging
    bool                    LogEnabled;
    FILE*                   LogFile;                            // If != NULL log to stdout/ file
    ImGuiTextBuffer         LogClipboard;                       // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
    int                     LogLoopCallbackDepth;
    int                     LogAutoExpandMaxDepth;

    // Misc
    float                   FramerateSecPerFrame[120];          // Calculate estimate of framerate for user over the last 2 seconds.
    int                     FramerateSecPerFrameIdx;
    float                   FramerateSecPerFrameAccum;
    int                     WantCaptureMouseNextFrame;          // Explicit capture via CaptureKeyboardFromApp()/CaptureMouseFromApp() sets those flags
    int                     WantCaptureKeyboardNextFrame;
    int                     WantTextInputNextFrame;
    char                    TempBuffer[1024*3+1];               // Temporary text buffer

    ImGuiContext(ImFontAtlas* shared_font_atlas) : OverlayDrawList(NULL)
    {
        Initialized = false;
        FrameScopeActive = false;
        Font = NULL;
        FontSize = FontBaseSize = 0.0f;
        FontAtlasOwnedByContext = shared_font_atlas ? false : true;
        IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();

        Time = 0.0f;
        FrameCount = 0;
        FrameCountEnded = FrameCountRendered = -1;
        WindowsActiveCount = 0;
        CurrentWindow = NULL;
        HoveredWindow = NULL;
        HoveredRootWindow = NULL;
        HoveredId = 0;
        HoveredIdAllowOverlap = false;
        HoveredIdPreviousFrame = 0;
        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
        ActiveId = 0;
        ActiveIdPreviousFrame = 0;
        ActiveIdIsAlive = 0;
        ActiveIdTimer = 0.0f;
        ActiveIdIsJustActivated = false;
        ActiveIdAllowOverlap = false;
        ActiveIdHasBeenEdited = false;
        ActiveIdPreviousFrameIsAlive = false;
        ActiveIdPreviousFrameHasBeenEdited = false;
        ActiveIdAllowNavDirFlags = 0;
        ActiveIdClickOffset = ImVec2(-1,-1);
        ActiveIdWindow = ActiveIdPreviousFrameWindow = NULL;
        ActiveIdSource = ImGuiInputSource_None;
        LastActiveId = 0;
        LastActiveIdTimer = 0.0f;
        LastValidMousePos = ImVec2(0.0f, 0.0f);
        MovingWindow = NULL;
        NextTreeNodeOpenVal = false;
        NextTreeNodeOpenCond = 0;

        NavWindow = NULL;
        NavId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavInputId = 0;
        NavJustTabbedId = NavJustMovedToId = NavNextActivateId = 0;
        NavInputSource = ImGuiInputSource_None;
        NavScoringRectScreen = ImRect();
        NavScoringCount = 0;
        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingList = NULL;
        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
        NavWindowingToggleLayer = false;
        NavLayer = ImGuiNavLayer_Main;
        NavIdTabCounter = INT_MAX;
        NavIdIsAlive = false;
        NavMousePosDirty = false;
        NavDisableHighlight = true;
        NavDisableMouseHover = false;
        NavAnyRequest = false;
        NavInitRequest = false;
        NavInitRequestFromMove = false;
        NavInitResultId = 0;
        NavMoveFromClampedRefRect = false;
        NavMoveRequest = false;
        NavMoveRequestFlags = 0;
        NavMoveRequestForward = ImGuiNavForward_None;
        NavMoveDir = NavMoveDirLast = NavMoveClipDir = ImGuiDir_None;

        DimBgRatio = 0.0f;
        OverlayDrawList._Data = &DrawListSharedData;
        OverlayDrawList._OwnerName = "##Overlay"; // Give it a name for debugging
        MouseCursor = ImGuiMouseCursor_Arrow;

        DragDropActive = DragDropWithinSourceOrTarget = false;
        DragDropSourceFlags = 0;
        DragDropSourceFrameCount = -1;
        DragDropMouseButton = -1;
        DragDropTargetId = 0;
        DragDropAcceptFlags = 0;
        DragDropAcceptIdCurrRectSurface = 0.0f;
        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
        DragDropAcceptFrameCount = -1;
        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));

        ScalarAsInputTextId = 0;
        ColorEditOptions = ImGuiColorEditFlags__OptionsDefault;
        DragCurrentAccumDirty = false;
        DragCurrentAccum = 0.0f;
        DragSpeedDefaultRatio = 1.0f / 100.0f;
        ScrollbarClickDeltaToGrabCenter = ImVec2(0.0f, 0.0f);
        TooltipOverrideCount = 0;
        PlatformImePos = PlatformImeLastPos = ImVec2(FLT_MAX, FLT_MAX);

        SettingsLoaded = false;
        SettingsDirtyTimer = 0.0f;

        LogEnabled = false;
        LogFile = NULL;
        LogLoopCallbackDepth = 0;
        LogAutoExpandMaxDepth = 2;

        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
        FramerateSecPerFrameIdx = 0;
        FramerateSecPerFrameAccum = 0.0f;
        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
        memset(TempBuffer, 0, sizeof(TempBuffer));
    }
};

// Transient per-window flags, reset at the beginning of the frame. For child window, inherited from parent on first Begin().
// This is going to be exposed in imgui.h when stabilized enough.
enum ImGuiItemFlags_
{
    ImGuiItemFlags_NoTabStop                    = 1 << 0,  // false
    ImGuiItemFlags_ButtonRepeat                 = 1 << 1,  // false    // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.
    ImGuiItemFlags_Disabled                     = 1 << 2,  // false    // [BETA] Disable interactions but doesn't affect visuals yet. See github.com/ocornut/imgui/issues/211
    ImGuiItemFlags_NoNav                        = 1 << 3,  // false
    ImGuiItemFlags_NoNavDefaultFocus            = 1 << 4,  // false
    ImGuiItemFlags_SelectableDontClosePopup     = 1 << 5,  // false    // MenuItem/Selectable() automatically closes current Popup window
    ImGuiItemFlags_Default_                     = 0
};

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// FIXME: That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered.
struct IMGUI_API ImGuiWindowTempData
{
    ImVec2                  CursorPos;
    ImVec2                  CursorPosPrevLine;
    ImVec2                  CursorLoopCallbackPos;         // Initial position in client area with padding
    ImVec2                  CursorMaxPos;           // Used to implicitly calculate the size of our contents, always growing during the frame. Turned into window->SizeContents at the beginning of next frame
    ImVec2                  CurrentLineSize;
    float                   CurrentLineTextBaseOffset;
    ImVec2                  PrevLineSize;
    float                   PrevLineTextBaseOffset;
    float                   LogLinePosY;
    int                     TreeDepth;
    ImU32                   TreeDepthMayJumpToParentOnPop; // Store a copy of !g.NavIdIsAlive for TreeDepth 0..31
    ImGuiID                 LastItemId;
    ImGuiItemStatusFlags    LastItemStatusFlags;
    ImRect                  LastItemRect;           // Interaction rect
    ImRect                  LastItemDisplayRect;    // End-user display rect (only valid if LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect)
    ImGuiNavLayer           NavLayerCurrent;        // Current layer, 0..31 (we currently only use 0..1)
    int                     NavLayerCurrentMask;    // = (1 << NavLayerCurrent) used by ItemAdd prior to clipping.
    int                     NavLayerActiveMask;     // Which layer have been written to (result from previous frame)
    int                     NavLayerActiveMaskNext; // Which layer have been written to (buffer for current frame)
    bool                    NavHideHighlightOneFrame;
    bool                    NavHasScroll;           // Set when scrolling can be used (ScrollMax > 0.0f)
    bool                    MenuBarAppending;       // FIXME: Remove this
    ImVec2                  MenuBarOffset;          // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
    ImVector<ImGuiWindow*>  ChildWindows;
    ImGuiStorage*           StateStorage;
    ImGuiLayoutType         LayoutType;
    ImGuiLayoutType         ParentLayoutType;       // Layout type of parent window at the time of Begin()

    // We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
    ImGuiItemFlags          ItemFlags;              // == ItemFlagsStack.back() [empty == ImGuiItemFlags_Default]
    float                   ItemWidth;              // == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window
    float                   TextWrapPos;            // == TextWrapPosStack.back() [empty == -1.0f]
    ImVector<ImGuiItemFlags>ItemFlagsStack;
    ImVector<float>         ItemWidthStack;
    ImVector<float>         TextWrapPosStack;
    ImVector<ImGuiGroupData>GroupStack;
    short                   StackSizesBackup[6];    // Store size of various stacks for asserting

    ImVec1                  Indent;                 // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
    ImVec1                  GroupOffset;
    ImVec1                  ColumnsOffset;          // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
    ImGuiColumnsSet*        ColumnsSet;             // Current columns set

    ImGuiWindowTempData()
    {
        CursorPos = CursorPosPrevLine = CursorLoopCallbackPos = CursorMaxPos = ImVec2(0.0f, 0.0f);
        CurrentLineSize = PrevLineSize = ImVec2(0.0f, 0.0f);
        CurrentLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;
        LogLinePosY = -1.0f;
        TreeDepth = 0;
        TreeDepthMayJumpToParentOnPop = 0x00;
        LastItemId = 0;
        LastItemStatusFlags = 0;
        LastItemRect = LastItemDisplayRect = ImRect();
        NavLayerActiveMask = NavLayerActiveMaskNext = 0x00;
        NavLayerCurrent = ImGuiNavLayer_Main;
        NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);
        NavHideHighlightOneFrame = false;
        NavHasScroll = false;
        MenuBarAppending = false;
        MenuBarOffset = ImVec2(0.0f, 0.0f);
        StateStorage = NULL;
        LayoutType = ParentLayoutType = ImGuiLayoutType_Vertical;
        ItemWidth = 0.0f;
        ItemFlags = ImGuiItemFlags_Default_;
        TextWrapPos = -1.0f;
        memset(StackSizesBackup, 0, sizeof(StackSizesBackup));

        Indent = ImVec1(0.0f);
        GroupOffset = ImVec1(0.0f);
        ColumnsOffset = ImVec1(0.0f);
        ColumnsSet = NULL;
    }
};

// Storage for one window
struct IMGUI_API ImGuiWindow
{
    char*                   Name;
    ImGuiID                 ID;                                 // == ImHash(Name)
    ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_
    ImVec2                  Pos;                                // Position (always rounded-up to nearest pixel)
    ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)
    ImVec2                  SizeFull;                           // Size when non collapsed
    ImVec2                  SizeFullAtLastBegin;                // Copy of SizeFull at the end of Begin. This is the reference value we'll use on the next frame to decide if we need scrollbars.
    ImVec2                  SizeContents;                       // Size of contents (== extents reach of the drawing cursor) from previous frame. Include decoration, window title, border, menu, etc.
    ImVec2                  SizeContentsExplicit;               // Size of contents explicitly set by the user via SetNextWindowContentSize()
    ImVec2                  WindowPadding;                      // Window padding at the time of begin.
    float                   WindowRounding;                     // Window rounding at the time of begin.
    float                   WindowBorderSize;                   // Window border size at the time of begin.
    ImGuiID                 MoveId;                             // == window->GetID("#MOVE")
    ImGuiID                 ChildId;                            // ID of corresponding item in parent window (for navigation to return from child window to parent window)
    ImVec2                  Scroll;
    ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
    ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
    ImVec2                  ScrollbarSizes;                     // Size taken by scrollbars on each axis
    bool                    ScrollbarX, ScrollbarY;
    bool                    Active;                             // Set to true on Begin(), unless Collapsed
    bool                    WasActive;
    bool                    WriteAccessed;                      // Set to true when any widget access the current window
    bool                    Collapsed;                          // Set when collapsing window to become only title-bar
    bool                    WantCollapseToggle;
    bool                    SkipItems;                          // Set when items can safely be all clipped (e.g. window not visible or collapsed)
    bool                    Appearing;                          // Set during the frame where the window is appearing (or re-appearing)
    bool                    Hidden;                             // Do not display (== (HiddenFramesForResize > 0) ||
    bool                    HasCloseButton;                     // Set when the window has a close button (p_open != NULL)
    short                   BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
    short                   BeginOrderWithinParent;             // Order within immediate parent window, if we are a child window. Otherwise 0.
    short                   BeginOrderWithinContext;            // Order within entire imgui context. This is mostly used for debugging submission order related issues.
    ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
    int                     AutoFitFramesX, AutoFitFramesY;
    bool                    AutoFitOnlyGrows;
    int                     AutoFitChildAxises;
    ImGuiDir                AutoPosLastDirection;
    int                     HiddenFramesRegular;                // Hide the window for N frames
    int                     HiddenFramesForResize;              // Hide the window for N frames while allowing items to be submitted so we can measure their size
    ImGuiCond               SetWindowPosAllowFlags;             // store acceptable condition flags for SetNextWindowPos() use.
    ImGuiCond               SetWindowSizeAllowFlags;            // store acceptable condition flags for SetNextWindowSize() use.
    ImGuiCond               SetWindowCollapsedAllowFlags;       // store acceptable condition flags for SetNextWindowCollapsed() use.
    ImVec2                  SetWindowPosVal;                    // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
    ImVec2                  SetWindowPosPivot;                  // store window pivot for positioning. ImVec2(0,0) when positioning from top-left corner; ImVec2(0.5f,0.5f) for centering; ImVec2(1,1) for bottom right.

    ImGuiWindowTempData     DC;                                 // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.
    ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack
    ImRect                  ClipRect;                           // Current clipping rectangle. = DrawList->clip_rect_stack.back(). Scissoring / clipping rectangle. x1, y1, x2, y2.
    ImRect                  OuterRectClipped;                   // = WindowRect just after setup in Begin(). == window->Rect() for root window.
    ImRect                  InnerMainRect, InnerClipRect;
    ImRect                  ContentsRegionRect;                 // FIXME: This is currently confusing/misleading. Maximum visible content position ~~ Pos + (SizeContentsExplicit ? SizeContentsExplicit : Size - ScrollbarSizes) - CursorLoopCallbackPos, per axis
    int                     LastFrameActive;                    // Last frame number the window was Active.
    float                   ItemWidthDefault;
    ImGuiMenuColumns        MenuColumns;                        // Simplified columns storage for menu items
    ImGuiStorage            StateStorage;
    ImVector<ImGuiColumnsSet> ColumnsStorage;
    float                   FontWindowScale;                    // User scale multiplier per-window
    int                     SettingsIdx;                        // Index into SettingsWindow[] (indices are always valid as we only grow the array from the back)

    ImDrawList*             DrawList;                           // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
    ImDrawList              DrawListInst;
    ImGuiWindow*            ParentWindow;                       // If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.
    ImGuiWindow*            RootWindow;                         // Point to ourself or first ancestor that is not a child window.
    ImGuiWindow*            RootWindowForTitleBarHighlight;     // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
    ImGuiWindow*            RootWindowForNav;                   // Point to ourself or first ancestor which doesn't have the NavFlattened flag.

    ImGuiWindow*            NavLastChildNavWindow;              // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
    ImGuiID                 NavLastIds[ImGuiNavLayer_COUNT];    // Last known NavId for this window, per layer (0/1)
    ImRect                  NavRectRel[ImGuiNavLayer_COUNT];    // Reference rectangle, in window relative space

    // Navigation / Focus
    // FIXME-NAV: Merge all this with the new Nav system, at least the request variables should be moved to ImGuiContext
    int                     FocusIdxAllCounter;                 // LoopCallback at -1 and increase as assigned via FocusItemRegister()
    int                     FocusIdxTabCounter;                 // (same, but only count widgets which you can Tab through)
    int                     FocusIdxAllRequestCurrent;          // Item being requested for focus
    int                     FocusIdxTabRequestCurrent;          // Tab-able item being requested for focus
    int                     FocusIdxAllRequestNext;             // Item being requested for focus, for next update (relies on layout to be stable between the frame pressing TAB and the next frame)
    int                     FocusIdxTabRequestNext;             // "

public:
    ImGuiWindow(ImGuiContext* context, const char* name);
    ~ImGuiWindow();

    ImGuiID     GetID(const char* str, const char* str_end = NULL);
    ImGuiID     GetID(const void* ptr);
    ImGuiID     GetIDNoKeepAlive(const char* str, const char* str_end = NULL);
    ImGuiID     GetIDNoKeepAlive(const void* ptr);
    ImGuiID     GetIDFromRectangle(const ImRect& r_abs);

    // We don't use g.FontSize because the window may be != g.CurrentWidow.
    ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }
    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }
    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }
    ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }
    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }
    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }
};

// Backup and restore just enough data to be able to use IsItemHovered() on item A after another B in the same window has overwritten the data.
struct ImGuiItemHoveredDataBackup
{
    ImGuiID                 LastItemId;
    ImGuiItemStatusFlags    LastItemStatusFlags;
    ImRect                  LastItemRect;
    ImRect                  LastItemDisplayRect;

    ImGuiItemHoveredDataBackup() { Backup(); }
    void Backup()           { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect; }
    void Restore() const    { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect; }
};

//-----------------------------------------------------------------------------
// Tab Bar, Tab Item
//-----------------------------------------------------------------------------

enum ImGuiTabBarFlagsPrivate_
{
    ImGuiTabBarFlags_DockNode                   = 1 << 20,  // [Docking: Unused in Master Branch] Part of a dock node
    ImGuiTabBarFlags_DockNodeIsDockSpace        = 1 << 21,  // [Docking: Unused in Master Branch] Part of an explicit dockspace node node
    ImGuiTabBarFlags_IsFocused                  = 1 << 22,
    ImGuiTabBarFlags_SaveSettings               = 1 << 23   // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs
};

// Storage for one active tab item (sizeof() 26~32 bytes)
struct ImGuiTabItem
{
    ImGuiID             ID;
    ImGuiTabItemFlags   Flags;
    int                 LastFrameVisible;
    int                 LastFrameSelected;      // This allows us to infer an ordered list of the last activated tabs with little maintenance
    float               Offset;                 // Position relative to beginning of tab
    float               Width;                  // Width currently displayed
    float               WidthContents;          // Width of actual contents, stored during BeginTabItem() call

    ImGuiTabItem()      { ID = Flags = 0; LastFrameVisible = LastFrameSelected = -1; Offset = Width = WidthContents = 0.0f; }
};

// Storage for a tab bar (sizeof() 92~96 bytes)
struct ImGuiTabBar
{
    ImVector<ImGuiTabItem> Tabs;
    ImGuiID             ID;                     // Zero for tab-bars used by docking
    ImGuiID             SelectedTabId;          // Selected tab
    ImGuiID             NextSelectedTabId;
    ImGuiID             VisibleTabId;           // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
    int                 CurrFrameVisible;
    int                 PrevFrameVisible;
    ImRect              BarRect;
    float               ContentsHeight;
    float               OffsetMax;              // Distance from BarRect.Min.x, locked during layout
    float               OffsetNextTab;          // Distance from BarRect.Min.x, incremented with each BeginTabItem() call, not used if ImGuiTabBarFlags_Reorderable if set.
    float               ScrollingAnim;
    float               ScrollingTarget;
    ImGuiTabBarFlags    Flags;
    ImGuiID             ReorderRequestTabId;
    int                 ReorderRequestDir;
    bool                WantLayout;
    bool                VisibleTabWasSubmitted;
    short               LastTabItemIdx;         // For BeginTabItem()/EndTabItem()

    ImGuiTabBar();
    int                 GetTabOrder(const ImGuiTabItem* tab) const { return Tabs.index_from_pointer(tab); }
};

//-----------------------------------------------------------------------------
// Internal API
// No guarantee of forward compatibility here.
//-----------------------------------------------------------------------------

namespace ImGui
{
    // We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)
    // If this ever crash because g.CurrentWindow is NULL it means that either
    // - ImGui::NewFrame() has never been called, which is illegal.
    // - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.
    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }
    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }
    IMGUI_API ImGuiWindow*  FindWindowByID(ImGuiID id);
    IMGUI_API ImGuiWindow*  FindWindowByName(const char* name);
    IMGUI_API void          FocusWindow(ImGuiWindow* window);
    IMGUI_API void          FocusPreviousWindowIgnoringOne(ImGuiWindow* ignore_window);
    IMGUI_API void          BringWindowToFocusFront(ImGuiWindow* window);
    IMGUI_API void          BringWindowToDisplayFront(ImGuiWindow* window);
    IMGUI_API void          BringWindowToDisplayBack(ImGuiWindow* window);
    IMGUI_API void          UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window);
    IMGUI_API ImVec2        CalcWindowExpectedSize(ImGuiWindow* window);
    IMGUI_API bool          IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent);
    IMGUI_API bool          IsWindowNavFocusable(ImGuiWindow* window);
    IMGUI_API void          SetWindowScrollX(ImGuiWindow* window, float new_scroll_x);
    IMGUI_API void          SetWindowScrollY(ImGuiWindow* window, float new_scroll_y);
    IMGUI_API float         GetWindowScrollMaxX(ImGuiWindow* window);
    IMGUI_API float         GetWindowScrollMaxY(ImGuiWindow* window);
    IMGUI_API ImRect        GetWindowAllowedExtentRect(ImGuiWindow* window);

    IMGUI_API void          SetCurrentFont(ImFont* font);
    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }

    // Init
    IMGUI_API void          Initialize(ImGuiContext* context);
    IMGUI_API void          Shutdown(ImGuiContext* context);    // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().

    // NewFrame
    IMGUI_API void          UpdateHoveredWindowAndCaptureFlags();
    IMGUI_API void          LoopCallbackMouseMovingWindow(ImGuiWindow* window);
    IMGUI_API void          UpdateMouseMovingWindow();

    // Settings
    IMGUI_API void                  MarkIniSettingsDirty();
    IMGUI_API void                  MarkIniSettingsDirty(ImGuiWindow* window);
    IMGUI_API ImGuiWindowSettings*  CreateNewWindowSettings(const char* name);
    IMGUI_API ImGuiWindowSettings*  FindWindowSettings(ImGuiID id);
    IMGUI_API ImGuiSettingsHandler* FindSettingsHandler(const char* type_name);

    // Basic Accessors
    inline ImGuiID          GetItemID()     { ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.LastItemId; }
    inline ImGuiID          GetActiveID()   { ImGuiContext& g = *GImGui; return g.ActiveId; }
    inline ImGuiID          GetFocusID()    { ImGuiContext& g = *GImGui; return g.NavId; }
    IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);
    IMGUI_API void          SetFocusID(ImGuiID id, ImGuiWindow* window);
    IMGUI_API void          ClearActiveID();
    IMGUI_API ImGuiID       GetHoveredID();
    IMGUI_API void          SetHoveredID(ImGuiID id);
    IMGUI_API void          KeepAliveID(ImGuiID id);
    IMGUI_API void          MarkItemEdited(ImGuiID id);

    // Basic Helpers for widget code
    IMGUI_API void          ItemSize(const ImVec2& size, float text_offset_y = 0.0f);
    IMGUI_API void          ItemSize(const ImRect& bb, float text_offset_y = 0.0f);
    IMGUI_API bool          ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb = NULL);
    IMGUI_API bool          ItemHoverable(const ImRect& bb, ImGuiID id);
    IMGUI_API bool          IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged);
    IMGUI_API bool          FocusableItemRegister(ImGuiWindow* window, ImGuiID id, bool tab_stop = true);      // Return true if focus is requested
    IMGUI_API void          FocusableItemUnregister(ImGuiWindow* window);
    IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_x, float default_y);
    IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);
    IMGUI_API void          PushMultiItemsWidths(int components, float width_full = 0.0f);
    IMGUI_API void          PushItemFlag(ImGuiItemFlags option, bool enabled);
    IMGUI_API void          PopItemFlag();

    // Popups, Modals, Tooltips
    IMGUI_API void          OpenPopupEx(ImGuiID id);
    IMGUI_API void          ClosePopupToLevel(int remaining);
    IMGUI_API void          ClosePopupsOverWindow(ImGuiWindow* ref_window);
    IMGUI_API bool          IsPopupOpen(ImGuiID id); // Test for id within current popup stack level (currently begin-ed into); this doesn't scan the whole popup stack!
    IMGUI_API bool          BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags);
    IMGUI_API void          BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip = true);
    IMGUI_API ImGuiWindow*  GetFrontMostPopupModal();
    IMGUI_API ImVec2        FindBestWindowPosForPopup(ImGuiWindow* window);
    IMGUI_API ImVec2        FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy = ImGuiPopupPositionPolicy_Default);

    // Navigation
    IMGUI_API void          NavInitWindow(ImGuiWindow* window, bool force_reinit);
    IMGUI_API bool          NavMoveRequestButNoResultYet();
    IMGUI_API void          NavMoveRequestCancel();
    IMGUI_API void          NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags);
    IMGUI_API void          NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags);
    IMGUI_API float         GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode);
    IMGUI_API ImVec2        GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor = 0.0f, float fast_factor = 0.0f);
    IMGUI_API int           CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate);
    IMGUI_API void          ActivateItem(ImGuiID id);   // Remotely activate a button, checkbox, tree node etc. given its unique ID. activation is queued and processed on the next frame when the item is encountered again.
    IMGUI_API void          SetNavID(ImGuiID id, int nav_layer);
    IMGUI_API void          SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel);

    // Inputs
    inline bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true)           { const int key_index = GImGui->IO.KeyMap[key]; return (key_index >= 0) ? IsKeyPressed(key_index, repeat) : false; }
    inline bool             IsNavInputDown(ImGuiNavInput n)                             { return GImGui->IO.NavInputs[n] > 0.0f; }
    inline bool             IsNavInputPressed(ImGuiNavInput n, ImGuiInputReadMode mode) { return GetNavInputAmount(n, mode) > 0.0f; }
    inline bool             IsNavInputPressedAnyOfTwo(ImGuiNavInput n1, ImGuiNavInput n2, ImGuiInputReadMode mode) { return (GetNavInputAmount(n1, mode) + GetNavInputAmount(n2, mode)) > 0.0f; }

    // Drag and Drop
    IMGUI_API bool          BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id);
    IMGUI_API void          ClearDragDrop();
    IMGUI_API bool          IsDragDropPayloadBeingAccepted();

    // New Columns API (FIXME-WIP)
    IMGUI_API void          BeginColumns(const char* str_id, int count, ImGuiColumnsFlags flags = 0); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().
    IMGUI_API void          EndColumns();                                                             // close columns
    IMGUI_API void          PushColumnClipRect(int column_index = -1);

    // Tab Bars
    IMGUI_API bool          BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& bb, ImGuiTabBarFlags flags);
    IMGUI_API ImGuiTabItem* TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    IMGUI_API void          TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    IMGUI_API void          TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
    IMGUI_API void          TabBarQueueChangeTabOrder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir);
    IMGUI_API bool          TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags);
    IMGUI_API ImVec2        TabItemCalcSize(const char* label, bool has_close_button);
    IMGUI_API void          TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col);
    IMGUI_API bool          TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, const char* label, ImGuiID tab_id, ImGuiID close_button_id);

    // Render helpers
    // AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.
    // NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)
    IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);
    IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);
    IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0,0), const ImRect* clip_rect = NULL);
    IMGUI_API void          RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = NULL);
    IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);
    IMGUI_API void          RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);
    IMGUI_API void          RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, int rounding_corners_flags = ~0);
    IMGUI_API void          RenderArrow(ImVec2 pos, ImGuiDir dir, float scale = 1.0f);
    IMGUI_API void          RenderBullet(ImVec2 pos);
    IMGUI_API void          RenderCheckMark(ImVec2 pos, ImU32 col, float sz);
    IMGUI_API void          RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags_TypeDefault); // Navigation highlight
    IMGUI_API const char*   FindRenderedTextEnd(const char* text, const char* text_end = NULL); // Find the optional ## from which we stop displaying text.
    IMGUI_API void          LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end = NULL);

    // Render helpers (those functions don't access any ImGui state!)
    IMGUI_API void          RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor = ImGuiMouseCursor_Arrow);
    IMGUI_API void          RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col);
    IMGUI_API void          RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);
    IMGUI_API void          RenderPixelEllipsis(ImDrawList* draw_list, ImFont* font, ImVec2 pos, int count, ImU32 col);

    // Widgets
    IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0);
    IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos, float radius);
    IMGUI_API bool          CollapseButton(ImGuiID id, const ImVec2& pos);
    IMGUI_API bool          ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags);
    IMGUI_API void          Scrollbar(ImGuiLayoutType direction);
    IMGUI_API void          VerticalSeparator();        // Vertical separator, for menu bars (use current line height). Not exposed because it is misleading and it doesn't have an effect on regular layout.

    // Widgets low-level behaviors
    IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);
    IMGUI_API bool          DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power, ImGuiDragFlags flags);
    IMGUI_API bool          SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    IMGUI_API bool          SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f);
    IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);
    IMGUI_API bool          TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0);                     // Consume previous SetNextTreeNodeOpened() data, if any. May return true when logging
    IMGUI_API void          TreePushRawID(ImGuiID id);

    // Template functions are instantiated in imgui_widgets.cpp for a finite number of types. 
    // To use them externally (for custom widget) you may need an "extern template" statement in your code in order to link to existing instances and silence Clang warnings (see #2036).
    // e.g. " extern template IMGUI_API float RoundScalarWithFormatT<float, float>(const char* format, ImGuiDataType data_type, float v); "
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  DragBehaviorT(ImGuiDataType data_type, T* v, float v_speed, const T v_min, const T v_max, const char* format, float power, ImGuiDragFlags flags);
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, T* v, const T v_min, const T v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    template<typename T, typename FLOAT_T>                      IMGUI_API float SliderCalcRatioFromValueT(ImGuiDataType data_type, T v, T v_min, T v_max, float power, float linear_zero_pos);
    template<typename T, typename SIGNED_T>                     IMGUI_API T     RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, T v);

    // InputText
    IMGUI_API bool          InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputScalarAsWidgetReplacement(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format);

    // Color
    IMGUI_API void          ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);
    IMGUI_API void          ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);
    IMGUI_API void          ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags);

    // Plot
    IMGUI_API void          PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size);

    // Shade functions (write over already created vertices)
    IMGUI_API void          ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);
    IMGUI_API void          ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp);

} // namespace ImGui

// ImFontAtlas internals
IMGUI_API bool              ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);
IMGUI_API void              ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* spc);
IMGUI_API void              ImFontAtlasBuildFinish(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);
IMGUI_API void              ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);

// Test engine hooks (imgui-test)
//#define IMGUI_ENABLE_TEST_ENGINE
#ifdef IMGUI_ENABLE_TEST_ENGINE
extern void                 ImGuiTestEngineHook_PreNewFrame();
extern void                 ImGuiTestEngineHook_PostNewFrame();
extern void                 ImGuiTestEngineHook_ItemAdd(const ImRect& bb, ImGuiID id);
extern void                 ImGuiTestEngineHook_ItemInfo(ImGuiID id, const char* label, int flags);
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS)  ImGuiTestEngineHook_ItemInfo(_ID, _LABEL, _FLAGS)   // Register status flags
#else
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS)  do { } while (0)
#endif

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning (pop)
#endif

```

`Private Esp/imgui/imgui_tables.cpp`:

```cpp
// dear imgui, v1.84 WIP
// (tables and columns code)

/*

Index of this file:

// [SECTION] Commentary
// [SECTION] Header mess
// [SECTION] Tables: Main code
// [SECTION] Tables: Simple accessors
// [SECTION] Tables: Row changes
// [SECTION] Tables: Columns changes
// [SECTION] Tables: Columns width management
// [SECTION] Tables: Drawing
// [SECTION] Tables: Sorting
// [SECTION] Tables: Headers
// [SECTION] Tables: Context Menu
// [SECTION] Tables: Settings (.ini data)
// [SECTION] Tables: Garbage Collection
// [SECTION] Tables: Debugging
// [SECTION] Columns, BeginColumns, EndColumns, etc.

*/

// Navigating this file:
// - In Visual Studio IDE: CTRL+comma ("Edit.NavigateTo") can follow symbols in comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
// - With Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols in comments.

//-----------------------------------------------------------------------------
// [SECTION] Commentary
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typical tables call flow: (root level is generally public API):
//-----------------------------------------------------------------------------
// - BeginTable()                               user begin into a table
//    | BeginChild()                            - (if ScrollX/ScrollY is set)
//    | TableBeginInitMemory()                  - first time table is used
//    | TableResetSettings()                    - on settings reset
//    | TableLoadSettings()                     - on settings load
//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests
//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)
//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width
// - TableSetupColumn()                         user submit columns details (optional)
// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)
//-----------------------------------------------------------------------------
// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().
//    | TableSetupDrawChannels()                - setup ImDrawList channels
//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission
//    | TableDrawContextMenu()                  - draw right-click context menu
//-----------------------------------------------------------------------------
// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)
//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction
//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu
// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)
// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())
//    | TableEndRow()                           - finish existing row
//    | TableBeginRow()                         - add a new row
// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell
//    | TableEndCell()                          - close existing column/cell
//    | TableBeginCell()                        - enter into current column/cell
// - [...]                                      user emit contents
//-----------------------------------------------------------------------------
// - EndTable()                                 user ends the table
//    | TableDrawBorders()                      - draw outer borders, inner vertical borders
//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required
//    | EndChild()                              - (if ScrollX/ScrollY is set)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// TABLE SIZING
//-----------------------------------------------------------------------------
// (Read carefully because this is subtle but it does make sense!)
//-----------------------------------------------------------------------------
// About 'outer_size':
// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.
// Default value is ImVec2(0.0f, 0.0f).
//   X
//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.
//   - outer_size.x  > 0.0f  ->  Set Fixed width.
//   Y with ScrollX/ScrollY disabled: we output table directly in current window
//   - outer_size.y  < 0.0f  ->  Bottom-align (but will auto extend, unless _NoHostExtendY is set). Not meaningful is parent window can vertically scroll.
//   - outer_size.y  = 0.0f  ->  No minimum height (but will auto extend, unless _NoHostExtendY is set)
//   - outer_size.y  > 0.0f  ->  Set Minimum height (but will auto extend, unless _NoHostExtenY is set)
//   Y with ScrollX/ScrollY enabled: using a child window for scrolling
//   - outer_size.y  < 0.0f  ->  Bottom-align. Not meaningful is parent window can vertically scroll.
//   - outer_size.y  = 0.0f  ->  Bottom-align, consistent with BeginChild(). Not recommended unless table is last item in parent window.
//   - outer_size.y  > 0.0f  ->  Set Exact height. Recommended when using Scrolling on any axis.
//-----------------------------------------------------------------------------
// Outer size is also affected by the NoHostExtendX/NoHostExtendY flags.
// Important to that note how the two flags have slightly different behaviors!
//   - ImGuiTableFlags_NoHostExtendX -> Make outer width auto-fit to columns (overriding outer_size.x value). Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.
//   - ImGuiTableFlags_NoHostExtendY -> Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY is disabled. Data below the limit will be clipped and not visible.
// In theory ImGuiTableFlags_NoHostExtendY could be the default and any non-scrolling tables with outer_size.y != 0.0f would use exact height.
// This would be consistent but perhaps less useful and more confusing (as vertically clipped items are not easily noticeable)
//-----------------------------------------------------------------------------
// About 'inner_width':
//   With ScrollX disabled:
//   - inner_width          ->  *ignored*
//   With ScrollX enabled:
//   - inner_width  < 0.0f  ->  *illegal* fit in known width (right align from outer_size.x) <-- weird
//   - inner_width  = 0.0f  ->  fit in outer_width: Fixed size columns will take space they need (if avail, otherwise shrink down), Stretch columns becomes Fixed columns.
//   - inner_width  > 0.0f  ->  override scrolling width, generally to be larger than outer_size.x. Fixed column take space they need (if avail, otherwise shrink down), Stretch columns share remaining space!
//-----------------------------------------------------------------------------
// Details:
// - If you want to use Stretch columns with ScrollX, you generally need to specify 'inner_width' otherwise the concept
//   of "available space" doesn't make sense.
// - Even if not really useful, we allow 'inner_width < outer_size.x' for consistency and to facilitate understanding
//   of what the value does.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// COLUMNS SIZING POLICIES
//-----------------------------------------------------------------------------
// About overriding column sizing policy and width/weight with TableSetupColumn():
// We use a default parameter of 'init_width_or_weight == -1'.
//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  <= 0 (default)  --> width is automatic
//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  >  0 (explicit) --> width is custom
//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight <= 0 (default)  --> weight is 1.0f
//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight >  0 (explicit) --> weight is custom
// Widths are specified _without_ CellPadding. If you specify a width of 100.0f, the column will be cover (100.0f + Padding * 2.0f)
// and you can fit a 100.0f wide item in it without clipping and with full padding.
//-----------------------------------------------------------------------------
// About default sizing policy (if you don't specify a ImGuiTableColumnFlags_WidthXXXX flag)
//   - with Table policy ImGuiTableFlags_SizingFixedFit      --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is equal to contents width
//   - with Table policy ImGuiTableFlags_SizingFixedSame     --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is max of all contents width
//   - with Table policy ImGuiTableFlags_SizingStretchSame   --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is 1.0f
//   - with Table policy ImGuiTableFlags_SizingStretchWeight --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is proportional to contents
// Default Width and default Weight can be overridden when calling TableSetupColumn().
//-----------------------------------------------------------------------------
// About mixing Fixed/Auto and Stretch columns together:
//   - the typical use of mixing sizing policies is: any number of LEADING Fixed columns, followed by one or two TRAILING Stretch columns.
//   - using mixed policies with ScrollX does not make much sense, as using Stretch columns with ScrollX does not make much sense in the first place!
//     that is, unless 'inner_width' is passed to BeginTable() to explicitly provide a total width to layout columns in.
//   - when using ImGuiTableFlags_SizingFixedSame with mixed columns, only the Fixed/Auto columns will match their widths to the width of the maximum contents.
//   - when using ImGuiTableFlags_SizingStretchSame with mixed columns, only the Stretch columns will match their weight/widths.
//-----------------------------------------------------------------------------
// About using column width:
// If a column is manual resizable or has a width specified with TableSetupColumn():
//   - you may use GetContentRegionAvail().x to query the width available in a given column.
//   - right-side alignment features such as SetNextItemWidth(-x) or PushItemWidth(-x) will rely on this width.
// If the column is not resizable and has no width specified with TableSetupColumn():
//   - its width will be automatic and be set to the max of items submitted.
//   - therefore you generally cannot have ALL items of the columns use e.g. SetNextItemWidth(-FLT_MIN).
//   - but if the column has one or more items of known/fixed size, this will become the reference width used by SetNextItemWidth(-FLT_MIN).
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// TABLES CLIPPING/CULLING
//-----------------------------------------------------------------------------
// About clipping/culling of Rows in Tables:
// - For large numbers of rows, it is recommended you use ImGuiListClipper to only submit visible rows.
//   ImGuiListClipper is reliant on the fact that rows are of equal height.
//   See 'Demo->Tables->Vertical Scrolling' or 'Demo->Tables->Advanced' for a demo of using the clipper.
// - Note that auto-resizing columns don't play well with using the clipper.
//   By default a table with _ScrollX but without _Resizable will have column auto-resize.
//   So, if you want to use the clipper, make sure to either enable _Resizable, either setup columns width explicitly with _WidthFixed.
//-----------------------------------------------------------------------------
// About clipping/culling of Columns in Tables:
// - Both TableSetColumnIndex() and TableNextColumn() return true when the column is visible or performing
//   width measurements. Otherwise, you may skip submitting the contents of a cell/column, BUT ONLY if you know
//   it is not going to contribute to row height.
//   In many situations, you may skip submitting contents for every column but one (e.g. the first one).
// - Case A: column is not hidden by user, and at least partially in sight (most common case).
// - Case B: column is clipped / out of sight (because of scrolling or parent ClipRect): TableNextColumn() return false as a hint but we still allow layout output.
// - Case C: column is hidden explicitly by the user (e.g. via the context menu, or _DefaultHide column flag, etc.).
//
//                        [A]         [B]          [C]
//  TableNextColumn():    true        false        false       -> [userland] when TableNextColumn() / TableSetColumnIndex() return false, user can skip submitting items but only if the column doesn't contribute to row height.
//          SkipItems:    false       false        true        -> [internal] when SkipItems is true, most widgets will early out if submitted, resulting is no layout output.
//           ClipRect:    normal      zero-width   zero-width  -> [internal] when ClipRect is zero, ItemAdd() will return false and most widgets will early out mid-way.
//  ImDrawList output:    normal      dummy        dummy       -> [internal] when using the dummy channel, ImDrawList submissions (if any) will be wasted (because cliprect is zero-width anyway).
//
// - We need to distinguish those cases because non-hidden columns that are clipped outside of scrolling bounds should still contribute their height to the row.
//   However, in the majority of cases, the contribution to row height is the same for all columns, or the tallest cells are known by the programmer.
//-----------------------------------------------------------------------------
// About clipping/culling of whole Tables:
// - Scrolling tables with a known outer size can be clipped earlier as BeginTable() will return false.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DISABLE

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

// System includes
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)     // condition expression is constant
#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types
#endif
#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"                // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wold-style-cast"                 // warning: use of old-style cast                            // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wsign-conversion"                // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
#pragma clang diagnostic ignored "-Wdouble-promotion"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#pragma clang diagnostic ignored "-Wenum-enum-conversion"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')
#pragma clang diagnostic ignored "-Wdeprecated-enum-enum-conversion"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"  // warning: implicit conversion from 'xxx' to 'float' may lose precision
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wpragmas"                          // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wformat-nonliteral"                // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wclass-memaccess"                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

//-----------------------------------------------------------------------------
// [SECTION] Tables: Main code
//-----------------------------------------------------------------------------
// - TableFixFlags() [Internal]
// - TableFindByID() [Internal]
// - BeginTable()
// - BeginTableEx() [Internal]
// - TableBeginInitMemory() [Internal]
// - TableBeginApplyRequests() [Internal]
// - TableSetupColumnFlags() [Internal]
// - TableUpdateLayout() [Internal]
// - TableUpdateBorders() [Internal]
// - EndTable()
// - TableSetupColumn()
// - TableSetupScrollFreeze()
//-----------------------------------------------------------------------------

// Configuration
static const int TABLE_DRAW_CHANNEL_BG0 = 0;
static const int TABLE_DRAW_CHANNEL_BG2_FROZEN = 1;
static const int TABLE_DRAW_CHANNEL_NOCLIP = 2;                     // When using ImGuiTableFlags_NoClip (this becomes the last visible channel)
static const float TABLE_BORDER_SIZE                     = 1.0f;    // FIXME-TABLE: Currently hard-coded because of clipping assumptions with outer borders rendering.
static const float TABLE_RESIZE_SEPARATOR_HALF_THICKNESS = 4.0f;    // Extend outside inner borders.
static const float TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER = 0.06f;   // Delay/timer before making the hover feedback (color+cursor) visible because tables/columns tends to be more cramped.

// Helper
inline ImGuiTableFlags TableFixFlags(ImGuiTableFlags flags, ImGuiWindow* outer_window)
{
    // Adjust flags: set default sizing policy
    if ((flags & ImGuiTableFlags_SizingMask_) == 0)
        flags |= ((flags & ImGuiTableFlags_ScrollX) || (outer_window->Flags & ImGuiWindowFlags_AlwaysAutoResize)) ? ImGuiTableFlags_SizingFixedFit : ImGuiTableFlags_SizingStretchSame;

    // Adjust flags: enable NoKeepColumnsVisible when using ImGuiTableFlags_SizingFixedSame
    if ((flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)
        flags |= ImGuiTableFlags_NoKeepColumnsVisible;

    // Adjust flags: enforce borders when resizable
    if (flags & ImGuiTableFlags_Resizable)
        flags |= ImGuiTableFlags_BordersInnerV;

    // Adjust flags: disable NoHostExtendX/NoHostExtendY if we have any scrolling going on
    if (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY))
        flags &= ~(ImGuiTableFlags_NoHostExtendX | ImGuiTableFlags_NoHostExtendY);

    // Adjust flags: NoBordersInBodyUntilResize takes priority over NoBordersInBody
    if (flags & ImGuiTableFlags_NoBordersInBodyUntilResize)
        flags &= ~ImGuiTableFlags_NoBordersInBody;

    // Adjust flags: disable saved settings if there's nothing to save
    if ((flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Sortable)) == 0)
        flags |= ImGuiTableFlags_NoSavedSettings;

    // Inherit _NoSavedSettings from top-level window (child windows always have _NoSavedSettings set)
#ifdef IMGUI_HAS_DOCK
    ImGuiWindow* window_for_settings = outer_window->RootWindowDockStop;
#else
    ImGuiWindow* window_for_settings = outer_window->RootWindow;
#endif
    if (window_for_settings->Flags & ImGuiWindowFlags_NoSavedSettings)
        flags |= ImGuiTableFlags_NoSavedSettings;

    return flags;
}

ImGuiTable* ImGui::TableFindByID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return g.Tables.GetByKey(id);
}

// Read about "TABLE SIZING" at the top of this file.
bool    ImGui::BeginTable(const char* str_id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)
{
    ImGuiID id = GetID(str_id);
    return BeginTableEx(str_id, id, columns_count, flags, outer_size, inner_width);
}

bool    ImGui::BeginTableEx(const char* name, ImGuiID id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* outer_window = GetCurrentWindow();
    if (outer_window->SkipItems) // Consistent with other tables + beneficial side effect that assert on miscalling EndTable() will be more visible.
        return false;

    // Sanity checks
    IM_ASSERT(columns_count > 0 && columns_count <= IMGUI_TABLE_MAX_COLUMNS && "Only 1..64 columns allowed!");
    if (flags & ImGuiTableFlags_ScrollX)
        IM_ASSERT(inner_width >= 0.0f);

    // If an outer size is specified ahead we will be able to early out when not visible. Exact clipping rules may evolve.
    const bool use_child_window = (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) != 0;
    const ImVec2 avail_size = GetContentRegionAvail();
    ImVec2 actual_outer_size = CalcItemSize(outer_size, ImMax(avail_size.x, 1.0f), use_child_window ? ImMax(avail_size.y, 1.0f) : 0.0f);
    ImRect outer_rect(outer_window->DC.CursorPos, outer_window->DC.CursorPos + actual_outer_size);
    if (use_child_window && IsClippedEx(outer_rect, 0, false))
    {
        ItemSize(outer_rect);
        return false;
    }

    // Acquire storage for the table
    ImGuiTable* table = g.Tables.GetOrAddByKey(id);
    const int instance_no = (table->LastFrameActive != g.FrameCount) ? 0 : table->InstanceCurrent + 1;
    const ImGuiID instance_id = id + instance_no;
    const ImGuiTableFlags table_last_flags = table->Flags;
    if (instance_no > 0)
        IM_ASSERT(table->ColumnsCount == columns_count && "BeginTable(): Cannot change columns count mid-frame while preserving same ID");

    // Acquire temporary buffers
    const int table_idx = g.Tables.GetIndex(table);
    g.CurrentTableStackIdx++;
    if (g.CurrentTableStackIdx + 1 > g.TablesTempDataStack.Size)
        g.TablesTempDataStack.resize(g.CurrentTableStackIdx + 1, ImGuiTableTempData());
    ImGuiTableTempData* temp_data = table->TempData = &g.TablesTempDataStack[g.CurrentTableStackIdx];
    temp_data->TableIndex = table_idx;
    table->DrawSplitter = &table->TempData->DrawSplitter;
    table->DrawSplitter->Clear();

    // Fix flags
    table->IsDefaultSizingPolicy = (flags & ImGuiTableFlags_SizingMask_) == 0;
    flags = TableFixFlags(flags, outer_window);

    // Initialize
    table->ID = id;
    table->Flags = flags;
    table->InstanceCurrent = (ImS16)instance_no;
    table->LastFrameActive = g.FrameCount;
    table->OuterWindow = table->InnerWindow = outer_window;
    table->ColumnsCount = columns_count;
    table->IsLayoutLocked = false;
    table->InnerWidth = inner_width;
    temp_data->UserOuterSize = outer_size;

    // When not using a child window, WorkRect.Max will grow as we append contents.
    if (use_child_window)
    {
        // Ensure no vertical scrollbar appears if we only want horizontal one, to make flag consistent
        // (we have no other way to disable vertical scrollbar of a window while keeping the horizontal one showing)
        ImVec2 override_content_size(FLT_MAX, FLT_MAX);
        if ((flags & ImGuiTableFlags_ScrollX) && !(flags & ImGuiTableFlags_ScrollY))
            override_content_size.y = FLT_MIN;

        // Ensure specified width (when not specified, Stretched columns will act as if the width == OuterWidth and
        // never lead to any scrolling). We don't handle inner_width < 0.0f, we could potentially use it to right-align
        // based on the right side of the child window work rect, which would require knowing ahead if we are going to
        // have decoration taking horizontal spaces (typically a vertical scrollbar).
        if ((flags & ImGuiTableFlags_ScrollX) && inner_width > 0.0f)
            override_content_size.x = inner_width;

        if (override_content_size.x != FLT_MAX || override_content_size.y != FLT_MAX)
            SetNextWindowContentSize(ImVec2(override_content_size.x != FLT_MAX ? override_content_size.x : 0.0f, override_content_size.y != FLT_MAX ? override_content_size.y : 0.0f));

        // Reset scroll if we are reactivating it
        if ((table_last_flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) == 0)
            SetNextWindowScroll(ImVec2(0.0f, 0.0f));

        // Create scrolling region (without border and zero window padding)
        ImGuiWindowFlags child_flags = (flags & ImGuiTableFlags_ScrollX) ? ImGuiWindowFlags_HorizontalScrollbar : ImGuiWindowFlags_None;
        BeginChildEx(name, instance_id, outer_rect.GetSize(), false, child_flags);
        table->InnerWindow = g.CurrentWindow;
        table->WorkRect = table->InnerWindow->WorkRect;
        table->OuterRect = table->InnerWindow->Rect();
        table->InnerRect = table->InnerWindow->InnerRect;
        IM_ASSERT(table->InnerWindow->WindowPadding.x == 0.0f && table->InnerWindow->WindowPadding.y == 0.0f && table->InnerWindow->WindowBorderSize == 0.0f);
    }
    else
    {
        // For non-scrolling tables, WorkRect == OuterRect == InnerRect.
        // But at this point we do NOT have a correct value for .Max.y (unless a height has been explicitly passed in). It will only be updated in EndTable().
        table->WorkRect = table->OuterRect = table->InnerRect = outer_rect;
    }

    // Push a standardized ID for both child-using and not-child-using tables
    PushOverrideID(instance_id);

    // Backup a copy of host window members we will modify
    ImGuiWindow* inner_window = table->InnerWindow;
    table->HostIndentX = inner_window->DC.Indent.x;
    table->HostClipRect = inner_window->ClipRect;
    table->HostSkipItems = inner_window->SkipItems;
    temp_data->HostBackupWorkRect = inner_window->WorkRect;
    temp_data->HostBackupParentWorkRect = inner_window->ParentWorkRect;
    temp_data->HostBackupColumnsOffset = outer_window->DC.ColumnsOffset;
    temp_data->HostBackupPrevLineSize = inner_window->DC.PrevLineSize;
    temp_data->HostBackupCurrLineSize = inner_window->DC.CurrLineSize;
    temp_data->HostBackupCursorMaxPos = inner_window->DC.CursorMaxPos;
    temp_data->HostBackupItemWidth = outer_window->DC.ItemWidth;
    temp_data->HostBackupItemWidthStackSize = outer_window->DC.ItemWidthStack.Size;
    inner_window->DC.PrevLineSize = inner_window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);

    // Padding and Spacing
    // - None               ........Content..... Pad .....Content........
    // - PadOuter           | Pad ..Content..... Pad .....Content.. Pad |
    // - PadInner           ........Content.. Pad | Pad ..Content........
    // - PadOuter+PadInner  | Pad ..Content.. Pad | Pad ..Content.. Pad |
    const bool pad_outer_x = (flags & ImGuiTableFlags_NoPadOuterX) ? false : (flags & ImGuiTableFlags_PadOuterX) ? true : (flags & ImGuiTableFlags_BordersOuterV) != 0;
    const bool pad_inner_x = (flags & ImGuiTableFlags_NoPadInnerX) ? false : true;
    const float inner_spacing_for_border = (flags & ImGuiTableFlags_BordersInnerV) ? TABLE_BORDER_SIZE : 0.0f;
    const float inner_spacing_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) == 0) ? g.Style.CellPadding.x : 0.0f;
    const float inner_padding_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) != 0) ? g.Style.CellPadding.x : 0.0f;
    table->CellSpacingX1 = inner_spacing_explicit + inner_spacing_for_border;
    table->CellSpacingX2 = inner_spacing_explicit;
    table->CellPaddingX = inner_padding_explicit;
    table->CellPaddingY = g.Style.CellPadding.y;

    const float outer_padding_for_border = (flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
    const float outer_padding_explicit = pad_outer_x ? g.Style.CellPadding.x : 0.0f;
    table->OuterPaddingX = (outer_padding_for_border + outer_padding_explicit) - table->CellPaddingX;

    table->CurrentColumn = -1;
    table->CurrentRow = -1;
    table->RowBgColorCounter = 0;
    table->LastRowFlags = ImGuiTableRowFlags_None;
    table->InnerClipRect = (inner_window == outer_window) ? table->WorkRect : inner_window->ClipRect;
    table->InnerClipRect.ClipWith(table->WorkRect);     // We need this to honor inner_width
    table->InnerClipRect.ClipWithFull(table->HostClipRect);
    table->InnerClipRect.Max.y = (flags & ImGuiTableFlags_NoHostExtendY) ? ImMin(table->InnerClipRect.Max.y, inner_window->WorkRect.Max.y) : inner_window->ClipRect.Max.y;

    table->RowPosY1 = table->RowPosY2 = table->WorkRect.Min.y; // This is needed somehow
    table->RowTextBaseline = 0.0f; // This will be cleared again by TableBeginRow()
    table->FreezeRowsRequest = table->FreezeRowsCount = 0; // This will be setup by TableSetupScrollFreeze(), if any
    table->FreezeColumnsRequest = table->FreezeColumnsCount = 0;
    table->IsUnfrozenRows = true;
    table->DeclColumnsCount = 0;

    // Using opaque colors facilitate overlapping elements of the grid
    table->BorderColorStrong = GetColorU32(ImGuiCol_TableBorderStrong);
    table->BorderColorLight = GetColorU32(ImGuiCol_TableBorderLight);

    // Make table current
    g.CurrentTable = table;
    outer_window->DC.CurrentTableIdx = table_idx;
    if (inner_window != outer_window) // So EndChild() within the inner window can restore the table properly.
        inner_window->DC.CurrentTableIdx = table_idx;

    if ((table_last_flags & ImGuiTableFlags_Reorderable) && (flags & ImGuiTableFlags_Reorderable) == 0)
        table->IsResetDisplayOrderRequest = true;

    // Mark as used
    if (table_idx >= g.TablesLastTimeActive.Size)
        g.TablesLastTimeActive.resize(table_idx + 1, -1.0f);
    g.TablesLastTimeActive[table_idx] = (float)g.Time;
    temp_data->LastTimeActive = (float)g.Time;
    table->MemoryCompacted = false;

    // Setup memory buffer (clear data if columns count changed)
    ImGuiTableColumn* old_columns_to_preserve = NULL;
    void* old_columns_raw_data = NULL;
    const int old_columns_count = table->Columns.size();
    if (old_columns_count != 0 && old_columns_count != columns_count)
    {
        // Attempt to preserve width on column count change (#4046)
        old_columns_to_preserve = table->Columns.Data;
        old_columns_raw_data = table->RawData;
        table->RawData = NULL;
    }
    if (table->RawData == NULL)
    {
        TableBeginInitMemory(table, columns_count);
        table->IsInitializing = table->IsSettingsRequestLoad = true;
    }
    if (table->IsResetAllRequest)
        TableResetSettings(table);
    if (table->IsInitializing)
    {
        // Initialize
        table->SettingsOffset = -1;
        table->IsSortSpecsDirty = true;
        table->InstanceInteracted = -1;
        table->ContextPopupColumn = -1;
        table->ReorderColumn = table->ResizedColumn = table->LastResizedColumn = -1;
        table->AutoFitSingleColumn = -1;
        table->HoveredColumnBody = table->HoveredColumnBorder = -1;
        for (int n = 0; n < columns_count; n++)
        {
            ImGuiTableColumn* column = &table->Columns[n];
            if (old_columns_to_preserve && n < old_columns_count)
            {
                // FIXME: We don't attempt to preserve column order in this path.
                *column = old_columns_to_preserve[n];
            }
            else
            {
                float width_auto = column->WidthAuto;
                *column = ImGuiTableColumn();
                column->WidthAuto = width_auto;
                column->IsPreserveWidthAuto = true; // Preserve WidthAuto when reinitializing a live table: not technically necessary but remove a visible flicker
                column->IsEnabled = column->IsUserEnabled = column->IsUserEnabledNextFrame = true;
            }
            column->DisplayOrder = table->DisplayOrderToIndex[n] = (ImGuiTableColumnIdx)n;
        }
    }
    if (old_columns_raw_data)
        IM_FREE(old_columns_raw_data);

    // Load settings
    if (table->IsSettingsRequestLoad)
        TableLoadSettings(table);

    // Handle DPI/font resize
    // This is designed to facilitate DPI changes with the assumption that e.g. style.CellPadding has been scaled as well.
    // It will also react to changing fonts with mixed results. It doesn't need to be perfect but merely provide a decent transition.
    // FIXME-DPI: Provide consistent standards for reference size. Perhaps using g.CurrentDpiScale would be more self explanatory.
    // This is will lead us to non-rounded WidthRequest in columns, which should work but is a poorly tested path.
    const float new_ref_scale_unit = g.FontSize; // g.Font->GetCharAdvance('A') ?
    if (table->RefScale != 0.0f && table->RefScale != new_ref_scale_unit)
    {
        const float scale_factor = new_ref_scale_unit / table->RefScale;
        //IMGUI_DEBUG_LOG("[table] %08X RefScaleUnit %.3f -> %.3f, scaling width by %.3f\n", table->ID, table->RefScaleUnit, new_ref_scale_unit, scale_factor);
        for (int n = 0; n < columns_count; n++)
            table->Columns[n].WidthRequest = table->Columns[n].WidthRequest * scale_factor;
    }
    table->RefScale = new_ref_scale_unit;

    // Disable output until user calls TableNextRow() or TableNextColumn() leading to the TableUpdateLayout() call..
    // This is not strictly necessary but will reduce cases were "out of table" output will be misleading to the user.
    // Because we cannot safely assert in EndTable() when no rows have been created, this seems like our best option.
    inner_window->SkipItems = true;

    // Clear names
    // At this point the ->NameOffset field of each column will be invalid until TableUpdateLayout() or the first call to TableSetupColumn()
    if (table->ColumnsNames.Buf.Size > 0)
        table->ColumnsNames.Buf.resize(0);

    // Apply queued resizing/reordering/hiding requests
    TableBeginApplyRequests(table);

    return true;
}

// For reference, the average total _allocation count_ for a table is:
// + 0 (for ImGuiTable instance, we are pooling allocations in g.Tables)
// + 1 (for table->RawData allocated below)
// + 1 (for table->ColumnsNames, if names are used)
// + 1 (for table->Splitter._Channels)
// + 2 * active_channels_count (for ImDrawCmd and ImDrawIdx buffers inside channels)
// Where active_channels_count is variable but often == columns_count or columns_count + 1, see TableSetupDrawChannels() for details.
// Unused channels don't perform their +2 allocations.
void ImGui::TableBeginInitMemory(ImGuiTable* table, int columns_count)
{
    // Allocate single buffer for our arrays
    ImSpanAllocator<3> span_allocator;
    span_allocator.Reserve(0, columns_count * sizeof(ImGuiTableColumn));
    span_allocator.Reserve(1, columns_count * sizeof(ImGuiTableColumnIdx));
    span_allocator.Reserve(2, columns_count * sizeof(ImGuiTableCellData), 4);
    table->RawData = IM_ALLOC(span_allocator.GetArenaSizeInBytes());
    memset(table->RawData, 0, span_allocator.GetArenaSizeInBytes());
    span_allocator.SetArenaBasePtr(table->RawData);
    span_allocator.GetSpan(0, &table->Columns);
    span_allocator.GetSpan(1, &table->DisplayOrderToIndex);
    span_allocator.GetSpan(2, &table->RowCellData);
}

// Apply queued resizing/reordering/hiding requests
void ImGui::TableBeginApplyRequests(ImGuiTable* table)
{
    // Handle resizing request
    // (We process this at the first TableBegin of the frame)
    // FIXME-TABLE: Contains columns if our work area doesn't allow for scrolling?
    if (table->InstanceCurrent == 0)
    {
        if (table->ResizedColumn != -1 && table->ResizedColumnNextWidth != FLT_MAX)
            TableSetColumnWidth(table->ResizedColumn, table->ResizedColumnNextWidth);
        table->LastResizedColumn = table->ResizedColumn;
        table->ResizedColumnNextWidth = FLT_MAX;
        table->ResizedColumn = -1;

        // Process auto-fit for single column, which is a special case for stretch columns and fixed columns with FixedSame policy.
        // FIXME-TABLE: Would be nice to redistribute available stretch space accordingly to other weights, instead of giving it all to siblings.
        if (table->AutoFitSingleColumn != -1)
        {
            TableSetColumnWidth(table->AutoFitSingleColumn, table->Columns[table->AutoFitSingleColumn].WidthAuto);
            table->AutoFitSingleColumn = -1;
        }
    }

    // Handle reordering request
    // Note: we don't clear ReorderColumn after handling the request.
    if (table->InstanceCurrent == 0)
    {
        if (table->HeldHeaderColumn == -1 && table->ReorderColumn != -1)
            table->ReorderColumn = -1;
        table->HeldHeaderColumn = -1;
        if (table->ReorderColumn != -1 && table->ReorderColumnDir != 0)
        {
            // We need to handle reordering across hidden columns.
            // In the configuration below, moving C to the right of E will lead to:
            //    ... C [D] E  --->  ... [D] E  C   (Column name/index)
            //    ... 2  3  4        ...  2  3  4   (Display order)
            const int reorder_dir = table->ReorderColumnDir;
            IM_ASSERT(reorder_dir == -1 || reorder_dir == +1);
            IM_ASSERT(table->Flags & ImGuiTableFlags_Reorderable);
            ImGuiTableColumn* src_column = &table->Columns[table->ReorderColumn];
            ImGuiTableColumn* dst_column = &table->Columns[(reorder_dir == -1) ? src_column->PrevEnabledColumn : src_column->NextEnabledColumn];
            IM_UNUSED(dst_column);
            const int src_order = src_column->DisplayOrder;
            const int dst_order = dst_column->DisplayOrder;
            src_column->DisplayOrder = (ImGuiTableColumnIdx)dst_order;
            for (int order_n = src_order + reorder_dir; order_n != dst_order + reorder_dir; order_n += reorder_dir)
                table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder -= (ImGuiTableColumnIdx)reorder_dir;
            IM_ASSERT(dst_column->DisplayOrder == dst_order - reorder_dir);

            // Display order is stored in both columns->IndexDisplayOrder and table->DisplayOrder[],
            // rebuild the later from the former.
            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;
            table->ReorderColumnDir = 0;
            table->IsSettingsDirty = true;
        }
    }

    // Handle display order reset request
    if (table->IsResetDisplayOrderRequest)
    {
        for (int n = 0; n < table->ColumnsCount; n++)
            table->DisplayOrderToIndex[n] = table->Columns[n].DisplayOrder = (ImGuiTableColumnIdx)n;
        table->IsResetDisplayOrderRequest = false;
        table->IsSettingsDirty = true;
    }
}

// Adjust flags: default width mode + stretch columns are not allowed when auto extending
static void TableSetupColumnFlags(ImGuiTable* table, ImGuiTableColumn* column, ImGuiTableColumnFlags flags_in)
{
    ImGuiTableColumnFlags flags = flags_in;

    // Sizing Policy
    if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0)
    {
        const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);
        if (table_sizing_policy == ImGuiTableFlags_SizingFixedFit || table_sizing_policy == ImGuiTableFlags_SizingFixedSame)
            flags |= ImGuiTableColumnFlags_WidthFixed;
        else
            flags |= ImGuiTableColumnFlags_WidthStretch;
    }
    else
    {
        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_WidthMask_)); // Check that only 1 of each set is used.
    }

    // Resize
    if ((table->Flags & ImGuiTableFlags_Resizable) == 0)
        flags |= ImGuiTableColumnFlags_NoResize;

    // Sorting
    if ((flags & ImGuiTableColumnFlags_NoSortAscending) && (flags & ImGuiTableColumnFlags_NoSortDescending))
        flags |= ImGuiTableColumnFlags_NoSort;

    // Indentation
    if ((flags & ImGuiTableColumnFlags_IndentMask_) == 0)
        flags |= (table->Columns.index_from_ptr(column) == 0) ? ImGuiTableColumnFlags_IndentEnable : ImGuiTableColumnFlags_IndentDisable;

    // Alignment
    //if ((flags & ImGuiTableColumnFlags_AlignMask_) == 0)
    //    flags |= ImGuiTableColumnFlags_AlignCenter;
    //IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_AlignMask_)); // Check that only 1 of each set is used.

    // Preserve status flags
    column->Flags = flags | (column->Flags & ImGuiTableColumnFlags_StatusMask_);

    // Build an ordered list of available sort directions
    column->SortDirectionsAvailCount = column->SortDirectionsAvailMask = column->SortDirectionsAvailList = 0;
    if (table->Flags & ImGuiTableFlags_Sortable)
    {
        int count = 0, mask = 0, list = 0;
        if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  != 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }
        if ((flags & ImGuiTableColumnFlags_PreferSortDescending) != 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }
        if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  == 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }
        if ((flags & ImGuiTableColumnFlags_PreferSortDescending) == 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }
        if ((table->Flags & ImGuiTableFlags_SortTristate) || count == 0) { mask |= 1 << ImGuiSortDirection_None; count++; }
        column->SortDirectionsAvailList = (ImU8)list;
        column->SortDirectionsAvailMask = (ImU8)mask;
        column->SortDirectionsAvailCount = (ImU8)count;
        ImGui::TableFixColumnSortDirection(table, column);
    }
}

// Layout columns for the frame. This is in essence the followup to BeginTable().
// Runs on the first call to TableNextRow(), to give a chance for TableSetupColumn() to be called first.
// FIXME-TABLE: Our width (and therefore our WorkRect) will be minimal in the first frame for _WidthAuto columns.
// Increase feedback side-effect with widgets relying on WorkRect.Max.x... Maybe provide a default distribution for _WidthAuto columns?
void ImGui::TableUpdateLayout(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(table->IsLayoutLocked == false);

    const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);
    table->IsDefaultDisplayOrder = true;
    table->ColumnsEnabledCount = 0;
    table->EnabledMaskByIndex = 0x00;
    table->EnabledMaskByDisplayOrder = 0x00;
    table->LeftMostEnabledColumn = -1;
    table->MinColumnWidth = ImMax(1.0f, g.Style.FramePadding.x * 1.0f); // g.Style.ColumnsMinSpacing; // FIXME-TABLE

    // [Part 1] Apply/lock Enabled and Order states. Calculate auto/ideal width for columns. Count fixed/stretch columns.
    // Process columns in their visible orders as we are building the Prev/Next indices.
    int count_fixed = 0;                // Number of columns that have fixed sizing policies
    int count_stretch = 0;              // Number of columns that have stretch sizing policies
    int prev_visible_column_idx = -1;
    bool has_auto_fit_request = false;
    bool has_resizable = false;
    float stretch_sum_width_auto = 0.0f;
    float fixed_max_width_auto = 0.0f;
    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
    {
        const int column_n = table->DisplayOrderToIndex[order_n];
        if (column_n != order_n)
            table->IsDefaultDisplayOrder = false;
        ImGuiTableColumn* column = &table->Columns[column_n];

        // Clear column setup if not submitted by user. Currently we make it mandatory to call TableSetupColumn() every frame.
        // It would easily work without but we're not ready to guarantee it since e.g. names need resubmission anyway.
        // We take a slight shortcut but in theory we could be calling TableSetupColumn() here with dummy values, it should yield the same effect.
        if (table->DeclColumnsCount <= column_n)
        {
            TableSetupColumnFlags(table, column, ImGuiTableColumnFlags_None);
            column->NameOffset = -1;
            column->UserID = 0;
            column->InitStretchWeightOrWidth = -1.0f;
        }

        // Update Enabled state, mark settings and sort specs dirty
        if (!(table->Flags & ImGuiTableFlags_Hideable) || (column->Flags & ImGuiTableColumnFlags_NoHide))
            column->IsUserEnabledNextFrame = true;
        if (column->IsUserEnabled != column->IsUserEnabledNextFrame)
        {
            column->IsUserEnabled = column->IsUserEnabledNextFrame;
            table->IsSettingsDirty = true;
        }
        column->IsEnabled = column->IsUserEnabled && (column->Flags & ImGuiTableColumnFlags_Disabled) == 0;

        if (column->SortOrder != -1 && !column->IsEnabled)
            table->IsSortSpecsDirty = true;
        if (column->SortOrder > 0 && !(table->Flags & ImGuiTableFlags_SortMulti))
            table->IsSortSpecsDirty = true;

        // Auto-fit unsized columns
        const bool start_auto_fit = (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? (column->WidthRequest < 0.0f) : (column->StretchWeight < 0.0f);
        if (start_auto_fit)
            column->AutoFitQueue = column->CannotSkipItemsQueue = (1 << 3) - 1; // Fit for three frames

        if (!column->IsEnabled)
        {
            column->IndexWithinEnabledSet = -1;
            continue;
        }

        // Mark as enabled and link to previous/next enabled column
        column->PrevEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;
        column->NextEnabledColumn = -1;
        if (prev_visible_column_idx != -1)
            table->Columns[prev_visible_column_idx].NextEnabledColumn = (ImGuiTableColumnIdx)column_n;
        else
            table->LeftMostEnabledColumn = (ImGuiTableColumnIdx)column_n;
        column->IndexWithinEnabledSet = table->ColumnsEnabledCount++;
        table->EnabledMaskByIndex |= (ImU64)1 << column_n;
        table->EnabledMaskByDisplayOrder |= (ImU64)1 << column->DisplayOrder;
        prev_visible_column_idx = column_n;
        IM_ASSERT(column->IndexWithinEnabledSet <= column->DisplayOrder);

        // Calculate ideal/auto column width (that's the width required for all contents to be visible without clipping)
        // Combine width from regular rows + width from headers unless requested not to.
        if (!column->IsPreserveWidthAuto)
            column->WidthAuto = TableGetColumnWidthAuto(table, column);

        // Non-resizable columns keep their requested width (apply user value regardless of IsPreserveWidthAuto)
        const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;
        if (column_is_resizable)
            has_resizable = true;
        if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f && !column_is_resizable)
            column->WidthAuto = column->InitStretchWeightOrWidth;

        if (column->AutoFitQueue != 0x00)
            has_auto_fit_request = true;
        if (column->Flags & ImGuiTableColumnFlags_WidthStretch)
        {
            stretch_sum_width_auto += column->WidthAuto;
            count_stretch++;
        }
        else
        {
            fixed_max_width_auto = ImMax(fixed_max_width_auto, column->WidthAuto);
            count_fixed++;
        }
    }
    if ((table->Flags & ImGuiTableFlags_Sortable) && table->SortSpecsCount == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))
        table->IsSortSpecsDirty = true;
    table->RightMostEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;
    IM_ASSERT(table->LeftMostEnabledColumn >= 0 && table->RightMostEnabledColumn >= 0);

    // [Part 2] Disable child window clipping while fitting columns. This is not strictly necessary but makes it possible
    // to avoid the column fitting having to wait until the first visible frame of the child container (may or not be a good thing).
    // FIXME-TABLE: for always auto-resizing columns may not want to do that all the time.
    if (has_auto_fit_request && table->OuterWindow != table->InnerWindow)
        table->InnerWindow->SkipItems = false;
    if (has_auto_fit_request)
        table->IsSettingsDirty = true;

    // [Part 3] Fix column flags and record a few extra information.
    float sum_width_requests = 0.0f;        // Sum of all width for fixed and auto-resize columns, excluding width contributed by Stretch columns but including spacing/padding.
    float stretch_sum_weights = 0.0f;       // Sum of all weights for stretch columns.
    table->LeftMostStretchedColumn = table->RightMostStretchedColumn = -1;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        if (!(table->EnabledMaskByIndex & ((ImU64)1 << column_n)))
            continue;
        ImGuiTableColumn* column = &table->Columns[column_n];

        const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;
        if (column->Flags & ImGuiTableColumnFlags_WidthFixed)
        {
            // Apply same widths policy
            float width_auto = column->WidthAuto;
            if (table_sizing_policy == ImGuiTableFlags_SizingFixedSame && (column->AutoFitQueue != 0x00 || !column_is_resizable))
                width_auto = fixed_max_width_auto;

            // Apply automatic width
            // Latch initial size for fixed columns and update it constantly for auto-resizing column (unless clipped!)
            if (column->AutoFitQueue != 0x00)
                column->WidthRequest = width_auto;
            else if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !column_is_resizable && (table->RequestOutputMaskByIndex & ((ImU64)1 << column_n)))
                column->WidthRequest = width_auto;

            // FIXME-TABLE: Increase minimum size during init frame to avoid biasing auto-fitting widgets
            // (e.g. TextWrapped) too much. Otherwise what tends to happen is that TextWrapped would output a very
            // large height (= first frame scrollbar display very off + clipper would skip lots of items).
            // This is merely making the side-effect less extreme, but doesn't properly fixes it.
            // FIXME: Move this to ->WidthGiven to avoid temporary lossyless?
            // FIXME: This break IsPreserveWidthAuto from not flickering if the stored WidthAuto was smaller.
            if (column->AutoFitQueue > 0x01 && table->IsInitializing && !column->IsPreserveWidthAuto)
                column->WidthRequest = ImMax(column->WidthRequest, table->MinColumnWidth * 4.0f); // FIXME-TABLE: Another constant/scale?
            sum_width_requests += column->WidthRequest;
        }
        else
        {
            // Initialize stretch weight
            if (column->AutoFitQueue != 0x00 || column->StretchWeight < 0.0f || !column_is_resizable)
            {
                if (column->InitStretchWeightOrWidth > 0.0f)
                    column->StretchWeight = column->InitStretchWeightOrWidth;
                else if (table_sizing_policy == ImGuiTableFlags_SizingStretchProp)
                    column->StretchWeight = (column->WidthAuto / stretch_sum_width_auto) * count_stretch;
                else
                    column->StretchWeight = 1.0f;
            }

            stretch_sum_weights += column->StretchWeight;
            if (table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder > column->DisplayOrder)
                table->LeftMostStretchedColumn = (ImGuiTableColumnIdx)column_n;
            if (table->RightMostStretchedColumn == -1 || table->Columns[table->RightMostStretchedColumn].DisplayOrder < column->DisplayOrder)
                table->RightMostStretchedColumn = (ImGuiTableColumnIdx)column_n;
        }
        column->IsPreserveWidthAuto = false;
        sum_width_requests += table->CellPaddingX * 2.0f;
    }
    table->ColumnsEnabledFixedCount = (ImGuiTableColumnIdx)count_fixed;

    // [Part 4] Apply final widths based on requested widths
    const ImRect work_rect = table->WorkRect;
    const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);
    const float width_avail = ((table->Flags & ImGuiTableFlags_ScrollX) && table->InnerWidth == 0.0f) ? table->InnerClipRect.GetWidth() : work_rect.GetWidth();
    const float width_avail_for_stretched_columns = width_avail - width_spacings - sum_width_requests;
    float width_remaining_for_stretched_columns = width_avail_for_stretched_columns;
    table->ColumnsGivenWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        if (!(table->EnabledMaskByIndex & ((ImU64)1 << column_n)))
            continue;
        ImGuiTableColumn* column = &table->Columns[column_n];

        // Allocate width for stretched/weighted columns (StretchWeight gets converted into WidthRequest)
        if (column->Flags & ImGuiTableColumnFlags_WidthStretch)
        {
            float weight_ratio = column->StretchWeight / stretch_sum_weights;
            column->WidthRequest = IM_FLOOR(ImMax(width_avail_for_stretched_columns * weight_ratio, table->MinColumnWidth) + 0.01f);
            width_remaining_for_stretched_columns -= column->WidthRequest;
        }

        // [Resize Rule 1] The right-most Visible column is not resizable if there is at least one Stretch column
        // See additional comments in TableSetColumnWidth().
        if (column->NextEnabledColumn == -1 && table->LeftMostStretchedColumn != -1)
            column->Flags |= ImGuiTableColumnFlags_NoDirectResize_;

        // Assign final width, record width in case we will need to shrink
        column->WidthGiven = ImFloor(ImMax(column->WidthRequest, table->MinColumnWidth));
        table->ColumnsGivenWidth += column->WidthGiven;
    }

    // [Part 5] Redistribute stretch remainder width due to rounding (remainder width is < 1.0f * number of Stretch column).
    // Using right-to-left distribution (more likely to match resizing cursor).
    if (width_remaining_for_stretched_columns >= 1.0f && !(table->Flags & ImGuiTableFlags_PreciseWidths))
        for (int order_n = table->ColumnsCount - 1; stretch_sum_weights > 0.0f && width_remaining_for_stretched_columns >= 1.0f && order_n >= 0; order_n--)
        {
            if (!(table->EnabledMaskByDisplayOrder & ((ImU64)1 << order_n)))
                continue;
            ImGuiTableColumn* column = &table->Columns[table->DisplayOrderToIndex[order_n]];
            if (!(column->Flags & ImGuiTableColumnFlags_WidthStretch))
                continue;
            column->WidthRequest += 1.0f;
            column->WidthGiven += 1.0f;
            width_remaining_for_stretched_columns -= 1.0f;
        }

    table->HoveredColumnBody = -1;
    table->HoveredColumnBorder = -1;
    const ImRect mouse_hit_rect(table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.Max.x, ImMax(table->OuterRect.Max.y, table->OuterRect.Min.y + table->LastOuterHeight));
    const bool is_hovering_table = ItemHoverable(mouse_hit_rect, 0);

    // [Part 6] Setup final position, offset, skip/clip states and clipping rectangles, detect hovered column
    // Process columns in their visible orders as we are comparing the visible order and adjusting host_clip_rect while looping.
    int visible_n = 0;
    bool offset_x_frozen = (table->FreezeColumnsCount > 0);
    float offset_x = ((table->FreezeColumnsCount > 0) ? table->OuterRect.Min.x : work_rect.Min.x) + table->OuterPaddingX - table->CellSpacingX1;
    ImRect host_clip_rect = table->InnerClipRect;
    //host_clip_rect.Max.x += table->CellPaddingX + table->CellSpacingX2;
    table->VisibleMaskByIndex = 0x00;
    table->RequestOutputMaskByIndex = 0x00;
    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
    {
        const int column_n = table->DisplayOrderToIndex[order_n];
        ImGuiTableColumn* column = &table->Columns[column_n];

        column->NavLayerCurrent = (ImS8)((table->FreezeRowsCount > 0 || column_n < table->FreezeColumnsCount) ? ImGuiNavLayer_Menu : ImGuiNavLayer_Main);

        if (offset_x_frozen && table->FreezeColumnsCount == visible_n)
        {
            offset_x += work_rect.Min.x - table->OuterRect.Min.x;
            offset_x_frozen = false;
        }

        // Clear status flags
        column->Flags &= ~ImGuiTableColumnFlags_StatusMask_;

        if ((table->EnabledMaskByDisplayOrder & ((ImU64)1 << order_n)) == 0)
        {
            // Hidden column: clear a few fields and we are done with it for the remainder of the function.
            // We set a zero-width clip rect but set Min.y/Max.y properly to not interfere with the clipper.
            column->MinX = column->MaxX = column->WorkMinX = column->ClipRect.Min.x = column->ClipRect.Max.x = offset_x;
            column->WidthGiven = 0.0f;
            column->ClipRect.Min.y = work_rect.Min.y;
            column->ClipRect.Max.y = FLT_MAX;
            column->ClipRect.ClipWithFull(host_clip_rect);
            column->IsVisibleX = column->IsVisibleY = column->IsRequestOutput = false;
            column->IsSkipItems = true;
            column->ItemWidth = 1.0f;
            continue;
        }

        // Detect hovered column
        if (is_hovering_table && g.IO.MousePos.x >= column->ClipRect.Min.x && g.IO.MousePos.x < column->ClipRect.Max.x)
            table->HoveredColumnBody = (ImGuiTableColumnIdx)column_n;

        // Lock start position
        column->MinX = offset_x;

        // Lock width based on start position and minimum/maximum width for this position
        float max_width = TableGetMaxColumnWidth(table, column_n);
        column->WidthGiven = ImMin(column->WidthGiven, max_width);
        column->WidthGiven = ImMax(column->WidthGiven, ImMin(column->WidthRequest, table->MinColumnWidth));
        column->MaxX = offset_x + column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;

        // Lock other positions
        // - ClipRect.Min.x: Because merging draw commands doesn't compare min boundaries, we make ClipRect.Min.x match left bounds to be consistent regardless of merging.
        // - ClipRect.Max.x: using WorkMaxX instead of MaxX (aka including padding) makes things more consistent when resizing down, tho slightly detrimental to visibility in very-small column.
        // - ClipRect.Max.x: using MaxX makes it easier for header to receive hover highlight with no discontinuity and display sorting arrow.
        // - FIXME-TABLE: We want equal width columns to have equal (ClipRect.Max.x - WorkMinX) width, which means ClipRect.max.x cannot stray off host_clip_rect.Max.x else right-most column may appear shorter.
        column->WorkMinX = column->MinX + table->CellPaddingX + table->CellSpacingX1;
        column->WorkMaxX = column->MaxX - table->CellPaddingX - table->CellSpacingX2; // Expected max
        column->ItemWidth = ImFloor(column->WidthGiven * 0.65f);
        column->ClipRect.Min.x = column->MinX;
        column->ClipRect.Min.y = work_rect.Min.y;
        column->ClipRect.Max.x = column->MaxX; //column->WorkMaxX;
        column->ClipRect.Max.y = FLT_MAX;
        column->ClipRect.ClipWithFull(host_clip_rect);

        // Mark column as Clipped (not in sight)
        // Note that scrolling tables (where inner_window != outer_window) handle Y clipped earlier in BeginTable() so IsVisibleY really only applies to non-scrolling tables.
        // FIXME-TABLE: Because InnerClipRect.Max.y is conservatively ==outer_window->ClipRect.Max.y, we never can mark columns _Above_ the scroll line as not IsVisibleY.
        // Taking advantage of LastOuterHeight would yield good results there...
        // FIXME-TABLE: Y clipping is disabled because it effectively means not submitting will reduce contents width which is fed to outer_window->DC.CursorMaxPos.x,
        // and this may be used (e.g. typically by outer_window using AlwaysAutoResize or outer_window's horizontal scrollbar, but could be something else).
        // Possible solution to preserve last known content width for clipped column. Test 'table_reported_size' fails when enabling Y clipping and window is resized small.
        column->IsVisibleX = (column->ClipRect.Max.x > column->ClipRect.Min.x);
        column->IsVisibleY = true; // (column->ClipRect.Max.y > column->ClipRect.Min.y);
        const bool is_visible = column->IsVisibleX; //&& column->IsVisibleY;
        if (is_visible)
            table->VisibleMaskByIndex |= ((ImU64)1 << column_n);

        // Mark column as requesting output from user. Note that fixed + non-resizable sets are auto-fitting at all times and therefore always request output.
        column->IsRequestOutput = is_visible || column->AutoFitQueue != 0 || column->CannotSkipItemsQueue != 0;
        if (column->IsRequestOutput)
            table->RequestOutputMaskByIndex |= ((ImU64)1 << column_n);

        // Mark column as SkipItems (ignoring all items/layout)
        column->IsSkipItems = !column->IsEnabled || table->HostSkipItems;
        if (column->IsSkipItems)
            IM_ASSERT(!is_visible);

        // Update status flags
        column->Flags |= ImGuiTableColumnFlags_IsEnabled;
        if (is_visible)
            column->Flags |= ImGuiTableColumnFlags_IsVisible;
        if (column->SortOrder != -1)
            column->Flags |= ImGuiTableColumnFlags_IsSorted;
        if (table->HoveredColumnBody == column_n)
            column->Flags |= ImGuiTableColumnFlags_IsHovered;

        // Alignment
        // FIXME-TABLE: This align based on the whole column width, not per-cell, and therefore isn't useful in
        // many cases (to be able to honor this we might be able to store a log of cells width, per row, for
        // visible rows, but nav/programmatic scroll would have visible artifacts.)
        //if (column->Flags & ImGuiTableColumnFlags_AlignRight)
        //    column->WorkMinX = ImMax(column->WorkMinX, column->MaxX - column->ContentWidthRowsUnfrozen);
        //else if (column->Flags & ImGuiTableColumnFlags_AlignCenter)
        //    column->WorkMinX = ImLerp(column->WorkMinX, ImMax(column->StartX, column->MaxX - column->ContentWidthRowsUnfrozen), 0.5f);

        // Reset content width variables
        column->ContentMaxXFrozen = column->ContentMaxXUnfrozen = column->WorkMinX;
        column->ContentMaxXHeadersUsed = column->ContentMaxXHeadersIdeal = column->WorkMinX;

        // Don't decrement auto-fit counters until container window got a chance to submit its items
        if (table->HostSkipItems == false)
        {
            column->AutoFitQueue >>= 1;
            column->CannotSkipItemsQueue >>= 1;
        }

        if (visible_n < table->FreezeColumnsCount)
            host_clip_rect.Min.x = ImClamp(column->MaxX + TABLE_BORDER_SIZE, host_clip_rect.Min.x, host_clip_rect.Max.x);

        offset_x += column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;
        visible_n++;
    }

    // [Part 7] Detect/store when we are hovering the unused space after the right-most column (so e.g. context menus can react on it)
    // Clear Resizable flag if none of our column are actually resizable (either via an explicit _NoResize flag, either
    // because of using _WidthAuto/_WidthStretch). This will hide the resizing option from the context menu.
    const float unused_x1 = ImMax(table->WorkRect.Min.x, table->Columns[table->RightMostEnabledColumn].ClipRect.Max.x);
    if (is_hovering_table && table->HoveredColumnBody == -1)
    {
        if (g.IO.MousePos.x >= unused_x1)
            table->HoveredColumnBody = (ImGuiTableColumnIdx)table->ColumnsCount;
    }
    if (has_resizable == false && (table->Flags & ImGuiTableFlags_Resizable))
        table->Flags &= ~ImGuiTableFlags_Resizable;

    // [Part 8] Lock actual OuterRect/WorkRect right-most position.
    // This is done late to handle the case of fixed-columns tables not claiming more widths that they need.
    // Because of this we are careful with uses of WorkRect and InnerClipRect before this point.
    if (table->RightMostStretchedColumn != -1)
        table->Flags &= ~ImGuiTableFlags_NoHostExtendX;
    if (table->Flags & ImGuiTableFlags_NoHostExtendX)
    {
        table->OuterRect.Max.x = table->WorkRect.Max.x = unused_x1;
        table->InnerClipRect.Max.x = ImMin(table->InnerClipRect.Max.x, unused_x1);
    }
    table->InnerWindow->ParentWorkRect = table->WorkRect;
    table->BorderX1 = table->InnerClipRect.Min.x;// +((table->Flags & ImGuiTableFlags_BordersOuter) ? 0.0f : -1.0f);
    table->BorderX2 = table->InnerClipRect.Max.x;// +((table->Flags & ImGuiTableFlags_BordersOuter) ? 0.0f : +1.0f);

    // [Part 9] Allocate draw channels and setup background cliprect
    TableSetupDrawChannels(table);

    // [Part 10] Hit testing on borders
    if (table->Flags & ImGuiTableFlags_Resizable)
        TableUpdateBorders(table);
    table->LastFirstRowHeight = 0.0f;
    table->IsLayoutLocked = true;
    table->IsUsingHeaders = false;

    // [Part 11] Context menu
    if (table->IsContextPopupOpen && table->InstanceCurrent == table->InstanceInteracted)
    {
        const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);
        if (BeginPopupEx(context_menu_id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings))
        {
            TableDrawContextMenu(table);
            EndPopup();
        }
        else
        {
            table->IsContextPopupOpen = false;
        }
    }

    // [Part 13] Sanitize and build sort specs before we have a change to use them for display.
    // This path will only be exercised when sort specs are modified before header rows (e.g. init or visibility change)
    if (table->IsSortSpecsDirty && (table->Flags & ImGuiTableFlags_Sortable))
        TableSortSpecsBuild(table);

    // Initial state
    ImGuiWindow* inner_window = table->InnerWindow;
    if (table->Flags & ImGuiTableFlags_NoClip)
        table->DrawSplitter->SetCurrentChannel(inner_window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);
    else
        inner_window->DrawList->PushClipRect(inner_window->ClipRect.Min, inner_window->ClipRect.Max, false);
}

// Process hit-testing on resizing borders. Actual size change will be applied in EndTable()
// - Set table->HoveredColumnBorder with a short delay/timer to reduce feedback noise
// - Submit ahead of table contents and header, use ImGuiButtonFlags_AllowItemOverlap to prioritize widgets
//   overlapping the same area.
void ImGui::TableUpdateBorders(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(table->Flags & ImGuiTableFlags_Resizable);

    // At this point OuterRect height may be zero or under actual final height, so we rely on temporal coherency and
    // use the final height from last frame. Because this is only affecting _interaction_ with columns, it is not
    // really problematic (whereas the actual visual will be displayed in EndTable() and using the current frame height).
    // Actual columns highlight/render will be performed in EndTable() and not be affected.
    const float hit_half_width = TABLE_RESIZE_SEPARATOR_HALF_THICKNESS;
    const float hit_y1 = table->OuterRect.Min.y;
    const float hit_y2_body = ImMax(table->OuterRect.Max.y, hit_y1 + table->LastOuterHeight);
    const float hit_y2_head = hit_y1 + table->LastFirstRowHeight;

    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
    {
        if (!(table->EnabledMaskByDisplayOrder & ((ImU64)1 << order_n)))
            continue;

        const int column_n = table->DisplayOrderToIndex[order_n];
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_))
            continue;

        // ImGuiTableFlags_NoBordersInBodyUntilResize will be honored in TableDrawBorders()
        const float border_y2_hit = (table->Flags & ImGuiTableFlags_NoBordersInBody) ? hit_y2_head : hit_y2_body;
        if ((table->Flags & ImGuiTableFlags_NoBordersInBody) && table->IsUsingHeaders == false)
            continue;

        if (!column->IsVisibleX && table->LastResizedColumn != column_n)
            continue;

        ImGuiID column_id = TableGetColumnResizeID(table, column_n, table->InstanceCurrent);
        ImRect hit_rect(column->MaxX - hit_half_width, hit_y1, column->MaxX + hit_half_width, border_y2_hit);
        //GetForegroundDrawList()->AddRect(hit_rect.Min, hit_rect.Max, IM_COL32(255, 0, 0, 100));
        KeepAliveID(column_id);

        bool hovered = false, held = false;
        bool pressed = ButtonBehavior(hit_rect, column_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnDoubleClick);
        if (pressed && IsMouseDoubleClicked(0))
        {
            TableSetColumnWidthAutoSingle(table, column_n);
            ClearActiveID();
            held = hovered = false;
        }
        if (held)
        {
            if (table->LastResizedColumn == -1)
                table->ResizeLockMinContentsX2 = table->RightMostEnabledColumn != -1 ? table->Columns[table->RightMostEnabledColumn].MaxX : -FLT_MAX;
            table->ResizedColumn = (ImGuiTableColumnIdx)column_n;
            table->InstanceInteracted = table->InstanceCurrent;
        }
        if ((hovered && g.HoveredIdTimer > TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER) || held)
        {
            table->HoveredColumnBorder = (ImGuiTableColumnIdx)column_n;
            SetMouseCursor(ImGuiMouseCursor_ResizeEW);
        }
    }
}

void    ImGui::EndTable()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && "Only call EndTable() if BeginTable() returns true!");

    // This assert would be very useful to catch a common error... unfortunately it would probably trigger in some
    // cases, and for consistency user may sometimes output empty tables (and still benefit from e.g. outer border)
    //IM_ASSERT(table->IsLayoutLocked && "Table unused: never called TableNextRow(), is that the intent?");

    // If the user never got to call TableNextRow() or TableNextColumn(), we call layout ourselves to ensure all our
    // code paths are consistent (instead of just hoping that TableBegin/TableEnd will work), get borders drawn, etc.
    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);

    const ImGuiTableFlags flags = table->Flags;
    ImGuiWindow* inner_window = table->InnerWindow;
    ImGuiWindow* outer_window = table->OuterWindow;
    ImGuiTableTempData* temp_data = table->TempData;
    IM_ASSERT(inner_window == g.CurrentWindow);
    IM_ASSERT(outer_window == inner_window || outer_window == inner_window->ParentWindow);

    if (table->IsInsideRow)
        TableEndRow(table);

    // Context menu in columns body
    if (flags & ImGuiTableFlags_ContextMenuInBody)
        if (table->HoveredColumnBody != -1 && !IsAnyItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
            TableOpenContextMenu((int)table->HoveredColumnBody);

    // Finalize table height
    inner_window->DC.PrevLineSize = temp_data->HostBackupPrevLineSize;
    inner_window->DC.CurrLineSize = temp_data->HostBackupCurrLineSize;
    inner_window->DC.CursorMaxPos = temp_data->HostBackupCursorMaxPos;
    const float inner_content_max_y = table->RowPosY2;
    IM_ASSERT(table->RowPosY2 == inner_window->DC.CursorPos.y);
    if (inner_window != outer_window)
        inner_window->DC.CursorMaxPos.y = inner_content_max_y;
    else if (!(flags & ImGuiTableFlags_NoHostExtendY))
        table->OuterRect.Max.y = table->InnerRect.Max.y = ImMax(table->OuterRect.Max.y, inner_content_max_y); // Patch OuterRect/InnerRect height
    table->WorkRect.Max.y = ImMax(table->WorkRect.Max.y, table->OuterRect.Max.y);
    table->LastOuterHeight = table->OuterRect.GetHeight();

    // Setup inner scrolling range
    // FIXME: This ideally should be done earlier, in BeginTable() SetNextWindowContentSize call, just like writing to inner_window->DC.CursorMaxPos.y,
    // but since the later is likely to be impossible to do we'd rather update both axises together.
    if (table->Flags & ImGuiTableFlags_ScrollX)
    {
        const float outer_padding_for_border = (table->Flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
        float max_pos_x = table->InnerWindow->DC.CursorMaxPos.x;
        if (table->RightMostEnabledColumn != -1)
            max_pos_x = ImMax(max_pos_x, table->Columns[table->RightMostEnabledColumn].WorkMaxX + table->CellPaddingX + table->OuterPaddingX - outer_padding_for_border);
        if (table->ResizedColumn != -1)
            max_pos_x = ImMax(max_pos_x, table->ResizeLockMinContentsX2);
        table->InnerWindow->DC.CursorMaxPos.x = max_pos_x;
    }

    // Pop clipping rect
    if (!(flags & ImGuiTableFlags_NoClip))
        inner_window->DrawList->PopClipRect();
    inner_window->ClipRect = inner_window->DrawList->_ClipRectStack.back();

    // Draw borders
    if ((flags & ImGuiTableFlags_Borders) != 0)
        TableDrawBorders(table);

#if 0
    // Strip out dummy channel draw calls
    // We have no way to prevent user submitting direct ImDrawList calls into a hidden column (but ImGui:: calls will be clipped out)
    // Pros: remove draw calls which will have no effect. since they'll have zero-size cliprect they may be early out anyway.
    // Cons: making it harder for users watching metrics/debugger to spot the wasted vertices.
    if (table->DummyDrawChannel != (ImGuiTableColumnIdx)-1)
    {
        ImDrawChannel* dummy_channel = &table->DrawSplitter._Channels[table->DummyDrawChannel];
        dummy_channel->_CmdBuffer.resize(0);
        dummy_channel->_IdxBuffer.resize(0);
    }
#endif

    // Flatten channels and merge draw calls
    ImDrawListSplitter* splitter = table->DrawSplitter;
    splitter->SetCurrentChannel(inner_window->DrawList, 0);
    if ((table->Flags & ImGuiTableFlags_NoClip) == 0)
        TableMergeDrawChannels(table);
    splitter->Merge(inner_window->DrawList);

    // Update ColumnsAutoFitWidth to get us ahead for host using our size to auto-resize without waiting for next BeginTable()
    const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);
    table->ColumnsAutoFitWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        if (table->EnabledMaskByIndex & ((ImU64)1 << column_n))
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !(column->Flags & ImGuiTableColumnFlags_NoResize))
                table->ColumnsAutoFitWidth += column->WidthRequest;
            else
                table->ColumnsAutoFitWidth += TableGetColumnWidthAuto(table, column);
        }

    // Update scroll
    if ((table->Flags & ImGuiTableFlags_ScrollX) == 0 && inner_window != outer_window)
    {
        inner_window->Scroll.x = 0.0f;
    }
    else if (table->LastResizedColumn != -1 && table->ResizedColumn == -1 && inner_window->ScrollbarX && table->InstanceInteracted == table->InstanceCurrent)
    {
        // When releasing a column being resized, scroll to keep the resulting column in sight
        const float neighbor_width_to_keep_visible = table->MinColumnWidth + table->CellPaddingX * 2.0f;
        ImGuiTableColumn* column = &table->Columns[table->LastResizedColumn];
        if (column->MaxX < table->InnerClipRect.Min.x)
            SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x - neighbor_width_to_keep_visible, 1.0f);
        else if (column->MaxX > table->InnerClipRect.Max.x)
            SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x + neighbor_width_to_keep_visible, 1.0f);
    }

    // Apply resizing/dragging at the end of the frame
    if (table->ResizedColumn != -1 && table->InstanceCurrent == table->InstanceInteracted)
    {
        ImGuiTableColumn* column = &table->Columns[table->ResizedColumn];
        const float new_x2 = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + TABLE_RESIZE_SEPARATOR_HALF_THICKNESS);
        const float new_width = ImFloor(new_x2 - column->MinX - table->CellSpacingX1 - table->CellPaddingX * 2.0f);
        table->ResizedColumnNextWidth = new_width;
    }

    // Pop from id stack
    IM_ASSERT_USER_ERROR(inner_window->IDStack.back() == table->ID + table->InstanceCurrent, "Mismatching PushID/PopID!");
    IM_ASSERT_USER_ERROR(outer_window->DC.ItemWidthStack.Size >= temp_data->HostBackupItemWidthStackSize, "Too many PopItemWidth!");
    PopID();

    // Restore window data that we modified
    const ImVec2 backup_outer_max_pos = outer_window->DC.CursorMaxPos;
    inner_window->WorkRect = temp_data->HostBackupWorkRect;
    inner_window->ParentWorkRect = temp_data->HostBackupParentWorkRect;
    inner_window->SkipItems = table->HostSkipItems;
    outer_window->DC.CursorPos = table->OuterRect.Min;
    outer_window->DC.ItemWidth = temp_data->HostBackupItemWidth;
    outer_window->DC.ItemWidthStack.Size = temp_data->HostBackupItemWidthStackSize;
    outer_window->DC.ColumnsOffset = temp_data->HostBackupColumnsOffset;

    // Layout in outer window
    // (FIXME: To allow auto-fit and allow desirable effect of SameLine() we dissociate 'used' vs 'ideal' size by overriding
    // CursorPosPrevLine and CursorMaxPos manually. That should be a more general layout feature, see same problem e.g. #3414)
    if (inner_window != outer_window)
    {
        EndChild();
    }
    else
    {
        ItemSize(table->OuterRect.GetSize());
        ItemAdd(table->OuterRect, 0);
    }

    // Override declared contents width/height to enable auto-resize while not needlessly adding a scrollbar
    if (table->Flags & ImGuiTableFlags_NoHostExtendX)
    {
        // FIXME-TABLE: Could we remove this section?
        // ColumnsAutoFitWidth may be one frame ahead here since for Fixed+NoResize is calculated from latest contents
        IM_ASSERT((table->Flags & ImGuiTableFlags_ScrollX) == 0);
        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth);
    }
    else if (temp_data->UserOuterSize.x <= 0.0f)
    {
        const float decoration_size = (table->Flags & ImGuiTableFlags_ScrollX) ? inner_window->ScrollbarSizes.x : 0.0f;
        outer_window->DC.IdealMaxPos.x = ImMax(outer_window->DC.IdealMaxPos.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth + decoration_size - temp_data->UserOuterSize.x);
        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, ImMin(table->OuterRect.Max.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth));
    }
    else
    {
        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Max.x);
    }
    if (temp_data->UserOuterSize.y <= 0.0f)
    {
        const float decoration_size = (table->Flags & ImGuiTableFlags_ScrollY) ? inner_window->ScrollbarSizes.y : 0.0f;
        outer_window->DC.IdealMaxPos.y = ImMax(outer_window->DC.IdealMaxPos.y, inner_content_max_y + decoration_size - temp_data->UserOuterSize.y);
        outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, ImMin(table->OuterRect.Max.y, inner_content_max_y));
    }
    else
    {
        // OuterRect.Max.y may already have been pushed downward from the initial value (unless ImGuiTableFlags_NoHostExtendY is set)
        outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, table->OuterRect.Max.y);
    }

    // Save settings
    if (table->IsSettingsDirty)
        TableSaveSettings(table);
    table->IsInitializing = false;

    // Clear or restore current table, if any
    IM_ASSERT(g.CurrentWindow == outer_window && g.CurrentTable == table);
    IM_ASSERT(g.CurrentTableStackIdx >= 0);
    g.CurrentTableStackIdx--;
    temp_data = g.CurrentTableStackIdx >= 0 ? &g.TablesTempDataStack[g.CurrentTableStackIdx] : NULL;
    g.CurrentTable = temp_data ? g.Tables.GetByIndex(temp_data->TableIndex) : NULL;
    if (g.CurrentTable)
    {
        g.CurrentTable->TempData = temp_data;
        g.CurrentTable->DrawSplitter = &temp_data->DrawSplitter;
    }
    outer_window->DC.CurrentTableIdx = g.CurrentTable ? g.Tables.GetIndex(g.CurrentTable) : -1;
}

// See "COLUMN SIZING POLICIES" comments at the top of this file
// If (init_width_or_weight <= 0.0f) it is ignored
void ImGui::TableSetupColumn(const char* label, ImGuiTableColumnFlags flags, float init_width_or_weight, ImGuiID user_id)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && "Need to call TableSetupColumn() after BeginTable()!");
    IM_ASSERT(table->IsLayoutLocked == false && "Need to call call TableSetupColumn() before first row!");
    IM_ASSERT((flags & ImGuiTableColumnFlags_StatusMask_) == 0 && "Illegal to pass StatusMask values to TableSetupColumn()");
    if (table->DeclColumnsCount >= table->ColumnsCount)
    {
        IM_ASSERT_USER_ERROR(table->DeclColumnsCount < table->ColumnsCount, "Called TableSetupColumn() too many times!");
        return;
    }

    ImGuiTableColumn* column = &table->Columns[table->DeclColumnsCount];
    table->DeclColumnsCount++;

    // Assert when passing a width or weight if policy is entirely left to default, to avoid storing width into weight and vice-versa.
    // Give a grace to users of ImGuiTableFlags_ScrollX.
    if (table->IsDefaultSizingPolicy && (flags & ImGuiTableColumnFlags_WidthMask_) == 0 && (flags & ImGuiTableFlags_ScrollX) == 0)
        IM_ASSERT(init_width_or_weight <= 0.0f && "Can only specify width/weight if sizing policy is set explicitly in either Table or Column.");

    // When passing a width automatically enforce WidthFixed policy
    // (whereas TableSetupColumnFlags would default to WidthAuto if table is not Resizable)
    if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0 && init_width_or_weight > 0.0f)
        if ((table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedFit || (table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)
            flags |= ImGuiTableColumnFlags_WidthFixed;

    TableSetupColumnFlags(table, column, flags);
    column->UserID = user_id;
    flags = column->Flags;

    // Initialize defaults
    column->InitStretchWeightOrWidth = init_width_or_weight;
    if (table->IsInitializing)
    {
        // Init width or weight
        if (column->WidthRequest < 0.0f && column->StretchWeight < 0.0f)
        {
            if ((flags & ImGuiTableColumnFlags_WidthFixed) && init_width_or_weight > 0.0f)
                column->WidthRequest = init_width_or_weight;
            if (flags & ImGuiTableColumnFlags_WidthStretch)
                column->StretchWeight = (init_width_or_weight > 0.0f) ? init_width_or_weight : -1.0f;

            // Disable auto-fit if an explicit width/weight has been specified
            if (init_width_or_weight > 0.0f)
                column->AutoFitQueue = 0x00;
        }

        // Init default visibility/sort state
        if ((flags & ImGuiTableColumnFlags_DefaultHide) && (table->SettingsLoadedFlags & ImGuiTableFlags_Hideable) == 0)
            column->IsUserEnabled = column->IsUserEnabledNextFrame = false;
        if (flags & ImGuiTableColumnFlags_DefaultSort && (table->SettingsLoadedFlags & ImGuiTableFlags_Sortable) == 0)
        {
            column->SortOrder = 0; // Multiple columns using _DefaultSort will be reassigned unique SortOrder values when building the sort specs.
            column->SortDirection = (column->Flags & ImGuiTableColumnFlags_PreferSortDescending) ? (ImS8)ImGuiSortDirection_Descending : (ImU8)(ImGuiSortDirection_Ascending);
        }
    }

    // Store name (append with zero-terminator in contiguous buffer)
    column->NameOffset = -1;
    if (label != NULL && label[0] != 0)
    {
        column->NameOffset = (ImS16)table->ColumnsNames.size();
        table->ColumnsNames.append(label, label + strlen(label) + 1);
    }
}

// [Public]
void ImGui::TableSetupScrollFreeze(int columns, int rows)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && "Need to call TableSetupColumn() after BeginTable()!");
    IM_ASSERT(table->IsLayoutLocked == false && "Need to call TableSetupColumn() before first row!");
    IM_ASSERT(columns >= 0 && columns < IMGUI_TABLE_MAX_COLUMNS);
    IM_ASSERT(rows >= 0 && rows < 128); // Arbitrary limit

    table->FreezeColumnsRequest = (table->Flags & ImGuiTableFlags_ScrollX) ? (ImGuiTableColumnIdx)ImMin(columns, table->ColumnsCount) : 0;
    table->FreezeColumnsCount = (table->InnerWindow->Scroll.x != 0.0f) ? table->FreezeColumnsRequest : 0;
    table->FreezeRowsRequest = (table->Flags & ImGuiTableFlags_ScrollY) ? (ImGuiTableColumnIdx)rows : 0;
    table->FreezeRowsCount = (table->InnerWindow->Scroll.y != 0.0f) ? table->FreezeRowsRequest : 0;
    table->IsUnfrozenRows = (table->FreezeRowsCount == 0); // Make sure this is set before TableUpdateLayout() so ImGuiListClipper can benefit from it.b

    // Ensure frozen columns are ordered in their section. We still allow multiple frozen columns to be reordered.
    for (int column_n = 0; column_n < table->FreezeColumnsRequest; column_n++)
    {
        int order_n = table->DisplayOrderToIndex[column_n];
        if (order_n != column_n && order_n >= table->FreezeColumnsRequest)
        {
            ImSwap(table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder, table->Columns[table->DisplayOrderToIndex[column_n]].DisplayOrder);
            ImSwap(table->DisplayOrderToIndex[order_n], table->DisplayOrderToIndex[column_n]);
        }
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Tables: Simple accessors
//-----------------------------------------------------------------------------
// - TableGetColumnCount()
// - TableGetColumnName()
// - TableGetColumnName() [Internal]
// - TableSetColumnEnabled()
// - TableGetColumnFlags()
// - TableGetCellBgRect() [Internal]
// - TableGetColumnResizeID() [Internal]
// - TableGetHoveredColumn() [Internal]
// - TableSetBgColor()
//-----------------------------------------------------------------------------

int ImGui::TableGetColumnCount()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    return table ? table->ColumnsCount : 0;
}

const char* ImGui::TableGetColumnName(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return NULL;
    if (column_n < 0)
        column_n = table->CurrentColumn;
    return TableGetColumnName(table, column_n);
}

const char* ImGui::TableGetColumnName(const ImGuiTable* table, int column_n)
{
    if (table->IsLayoutLocked == false && column_n >= table->DeclColumnsCount)
        return ""; // NameOffset is invalid at this point
    const ImGuiTableColumn* column = &table->Columns[column_n];
    if (column->NameOffset == -1)
        return "";
    return &table->ColumnsNames.Buf[column->NameOffset];
}

// Change user accessible enabled/disabled state of a column (often perceived as "showing/hiding" from users point of view)
// Note that end-user can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)
// - Require table to have the ImGuiTableFlags_Hideable flag because we are manipulating user accessible state.
// - Request will be applied during next layout, which happens on the first call to TableNextRow() after BeginTable().
// - For the getter you can test (TableGetColumnFlags() & ImGuiTableColumnFlags_IsEnabled) != 0.
// - Alternative: the ImGuiTableColumnFlags_Disabled is an overriding/master disable flag which will also hide the column from context menu.
void ImGui::TableSetColumnEnabled(int column_n, bool enabled)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL);
    if (!table)
        return;
    IM_ASSERT(table->Flags & ImGuiTableFlags_Hideable); // See comments above
    if (column_n < 0)
        column_n = table->CurrentColumn;
    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
    ImGuiTableColumn* column = &table->Columns[column_n];
    column->IsUserEnabledNextFrame = enabled;
}

// We allow querying for an extra column in order to poll the IsHovered state of the right-most section
ImGuiTableColumnFlags ImGui::TableGetColumnFlags(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return ImGuiTableColumnFlags_None;
    if (column_n < 0)
        column_n = table->CurrentColumn;
    if (column_n == table->ColumnsCount)
        return (table->HoveredColumnBody == column_n) ? ImGuiTableColumnFlags_IsHovered : ImGuiTableColumnFlags_None;
    return table->Columns[column_n].Flags;
}

// Return the cell rectangle based on currently known height.
// - Important: we generally don't know our row height until the end of the row, so Max.y will be incorrect in many situations.
//   The only case where this is correct is if we provided a min_row_height to TableNextRow() and don't go below it.
// - Important: if ImGuiTableFlags_PadOuterX is set but ImGuiTableFlags_PadInnerX is not set, the outer-most left and right
//   columns report a small offset so their CellBgRect can extend up to the outer border.
ImRect ImGui::TableGetCellBgRect(const ImGuiTable* table, int column_n)
{
    const ImGuiTableColumn* column = &table->Columns[column_n];
    float x1 = column->MinX;
    float x2 = column->MaxX;
    if (column->PrevEnabledColumn == -1)
        x1 -= table->CellSpacingX1;
    if (column->NextEnabledColumn == -1)
        x2 += table->CellSpacingX2;
    return ImRect(x1, table->RowPosY1, x2, table->RowPosY2);
}

// Return the resizing ID for the right-side of the given column.
ImGuiID ImGui::TableGetColumnResizeID(const ImGuiTable* table, int column_n, int instance_no)
{
    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
    ImGuiID id = table->ID + 1 + (instance_no * table->ColumnsCount) + column_n;
    return id;
}

// Return -1 when table is not hovered. return columns_count if the unused space at the right of visible columns is hovered.
int ImGui::TableGetHoveredColumn()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return -1;
    return (int)table->HoveredColumnBody;
}

void ImGui::TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(target != ImGuiTableBgTarget_None);

    if (color == IM_COL32_DISABLE)
        color = 0;

    // We cannot draw neither the cell or row background immediately as we don't know the row height at this point in time.
    switch (target)
    {
    case ImGuiTableBgTarget_CellBg:
    {
        if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
            return;
        if (column_n == -1)
            column_n = table->CurrentColumn;
        if ((table->VisibleMaskByIndex & ((ImU64)1 << column_n)) == 0)
            return;
        if (table->RowCellDataCurrent < 0 || table->RowCellData[table->RowCellDataCurrent].Column != column_n)
            table->RowCellDataCurrent++;
        ImGuiTableCellData* cell_data = &table->RowCellData[table->RowCellDataCurrent];
        cell_data->BgColor = color;
        cell_data->Column = (ImGuiTableColumnIdx)column_n;
        break;
    }
    case ImGuiTableBgTarget_RowBg0:
    case ImGuiTableBgTarget_RowBg1:
    {
        if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
            return;
        IM_ASSERT(column_n == -1);
        int bg_idx = (target == ImGuiTableBgTarget_RowBg1) ? 1 : 0;
        table->RowBgColor[bg_idx] = color;
        break;
    }
    default:
        IM_ASSERT(0);
    }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Row changes
//-------------------------------------------------------------------------
// - TableGetRowIndex()
// - TableNextRow()
// - TableBeginRow() [Internal]
// - TableEndRow() [Internal]
//-------------------------------------------------------------------------

// [Public] Note: for row coloring we use ->RowBgColorCounter which is the same value without counting header rows
int ImGui::TableGetRowIndex()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return 0;
    return table->CurrentRow;
}

// [Public] Starts into the first cell of a new row
void ImGui::TableNextRow(ImGuiTableRowFlags row_flags, float row_min_height)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;

    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);
    if (table->IsInsideRow)
        TableEndRow(table);

    table->LastRowFlags = table->RowFlags;
    table->RowFlags = row_flags;
    table->RowMinHeight = row_min_height;
    TableBeginRow(table);

    // We honor min_row_height requested by user, but cannot guarantee per-row maximum height,
    // because that would essentially require a unique clipping rectangle per-cell.
    table->RowPosY2 += table->CellPaddingY * 2.0f;
    table->RowPosY2 = ImMax(table->RowPosY2, table->RowPosY1 + row_min_height);

    // Disable output until user calls TableNextColumn()
    table->InnerWindow->SkipItems = true;
}

// [Internal] Called by TableNextRow()
void ImGui::TableBeginRow(ImGuiTable* table)
{
    ImGuiWindow* window = table->InnerWindow;
    IM_ASSERT(!table->IsInsideRow);

    // New row
    table->CurrentRow++;
    table->CurrentColumn = -1;
    table->RowBgColor[0] = table->RowBgColor[1] = IM_COL32_DISABLE;
    table->RowCellDataCurrent = -1;
    table->IsInsideRow = true;

    // Begin frozen rows
    float next_y1 = table->RowPosY2;
    if (table->CurrentRow == 0 && table->FreezeRowsCount > 0)
        next_y1 = window->DC.CursorPos.y = table->OuterRect.Min.y;

    table->RowPosY1 = table->RowPosY2 = next_y1;
    table->RowTextBaseline = 0.0f;
    table->RowIndentOffsetX = window->DC.Indent.x - table->HostIndentX; // Lock indent
    window->DC.PrevLineTextBaseOffset = 0.0f;
    window->DC.CursorMaxPos.y = next_y1;

    // Making the header BG color non-transparent will allow us to overlay it multiple times when handling smooth dragging.
    if (table->RowFlags & ImGuiTableRowFlags_Headers)
    {
        TableSetBgColor(ImGuiTableBgTarget_RowBg0, GetColorU32(ImGuiCol_TableHeaderBg));
        if (table->CurrentRow == 0)
            table->IsUsingHeaders = true;
    }
}

// [Internal] Called by TableNextRow()
void ImGui::TableEndRow(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(window == table->InnerWindow);
    IM_ASSERT(table->IsInsideRow);

    if (table->CurrentColumn != -1)
        TableEndCell(table);

    // Logging
    if (g.LogEnabled)
        LogRenderedText(NULL, "|");

    // Position cursor at the bottom of our row so it can be used for e.g. clipping calculation. However it is
    // likely that the next call to TableBeginCell() will reposition the cursor to take account of vertical padding.
    window->DC.CursorPos.y = table->RowPosY2;

    // Row background fill
    const float bg_y1 = table->RowPosY1;
    const float bg_y2 = table->RowPosY2;
    const bool unfreeze_rows_actual = (table->CurrentRow + 1 == table->FreezeRowsCount);
    const bool unfreeze_rows_request = (table->CurrentRow + 1 == table->FreezeRowsRequest);
    if (table->CurrentRow == 0)
        table->LastFirstRowHeight = bg_y2 - bg_y1;

    const bool is_visible = (bg_y2 >= table->InnerClipRect.Min.y && bg_y1 <= table->InnerClipRect.Max.y);
    if (is_visible)
    {
        // Decide of background color for the row
        ImU32 bg_col0 = 0;
        ImU32 bg_col1 = 0;
        if (table->RowBgColor[0] != IM_COL32_DISABLE)
            bg_col0 = table->RowBgColor[0];
        else if (table->Flags & ImGuiTableFlags_RowBg)
            bg_col0 = GetColorU32((table->RowBgColorCounter & 1) ? ImGuiCol_TableRowBgAlt : ImGuiCol_TableRowBg);
        if (table->RowBgColor[1] != IM_COL32_DISABLE)
            bg_col1 = table->RowBgColor[1];

        // Decide of top border color
        ImU32 border_col = 0;
        const float border_size = TABLE_BORDER_SIZE;
        if (table->CurrentRow > 0 || table->InnerWindow == table->OuterWindow)
            if (table->Flags & ImGuiTableFlags_BordersInnerH)
                border_col = (table->LastRowFlags & ImGuiTableRowFlags_Headers) ? table->BorderColorStrong : table->BorderColorLight;

        const bool draw_cell_bg_color = table->RowCellDataCurrent >= 0;
        const bool draw_strong_bottom_border = unfreeze_rows_actual;
        if ((bg_col0 | bg_col1 | border_col) != 0 || draw_strong_bottom_border || draw_cell_bg_color)
        {
            // In theory we could call SetWindowClipRectBeforeSetChannel() but since we know TableEndRow() is
            // always followed by a change of clipping rectangle we perform the smallest overwrite possible here.
            if ((table->Flags & ImGuiTableFlags_NoClip) == 0)
                window->DrawList->_CmdHeader.ClipRect = table->Bg0ClipRectForDrawCmd.ToVec4();
            table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_BG0);
        }

        // Draw row background
        // We soft/cpu clip this so all backgrounds and borders can share the same clipping rectangle
        if (bg_col0 || bg_col1)
        {
            ImRect row_rect(table->WorkRect.Min.x, bg_y1, table->WorkRect.Max.x, bg_y2);
            row_rect.ClipWith(table->BgClipRect);
            if (bg_col0 != 0 && row_rect.Min.y < row_rect.Max.y)
                window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col0);
            if (bg_col1 != 0 && row_rect.Min.y < row_rect.Max.y)
                window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col1);
        }

        // Draw cell background color
        if (draw_cell_bg_color)
        {
            ImGuiTableCellData* cell_data_end = &table->RowCellData[table->RowCellDataCurrent];
            for (ImGuiTableCellData* cell_data = &table->RowCellData[0]; cell_data <= cell_data_end; cell_data++)
            {
                const ImGuiTableColumn* column = &table->Columns[cell_data->Column];
                ImRect cell_bg_rect = TableGetCellBgRect(table, cell_data->Column);
                cell_bg_rect.ClipWith(table->BgClipRect);
                cell_bg_rect.Min.x = ImMax(cell_bg_rect.Min.x, column->ClipRect.Min.x);     // So that first column after frozen one gets clipped
                cell_bg_rect.Max.x = ImMin(cell_bg_rect.Max.x, column->MaxX);
                window->DrawList->AddRectFilled(cell_bg_rect.Min, cell_bg_rect.Max, cell_data->BgColor);
            }
        }

        // Draw top border
        if (border_col && bg_y1 >= table->BgClipRect.Min.y && bg_y1 < table->BgClipRect.Max.y)
            window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y1), ImVec2(table->BorderX2, bg_y1), border_col, border_size);

        // Draw bottom border at the row unfreezing mark (always strong)
        if (draw_strong_bottom_border && bg_y2 >= table->BgClipRect.Min.y && bg_y2 < table->BgClipRect.Max.y)
            window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y2), ImVec2(table->BorderX2, bg_y2), table->BorderColorStrong, border_size);
    }

    // End frozen rows (when we are past the last frozen row line, teleport cursor and alter clipping rectangle)
    // We need to do that in TableEndRow() instead of TableBeginRow() so the list clipper can mark end of row and
    // get the new cursor position.
    if (unfreeze_rows_request)
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            column->NavLayerCurrent = (ImS8)((column_n < table->FreezeColumnsCount) ? ImGuiNavLayer_Menu : ImGuiNavLayer_Main);
        }
    if (unfreeze_rows_actual)
    {
        IM_ASSERT(table->IsUnfrozenRows == false);
        table->IsUnfrozenRows = true;

        // BgClipRect starts as table->InnerClipRect, reduce it now and make BgClipRectForDrawCmd == BgClipRect
        float y0 = ImMax(table->RowPosY2 + 1, window->InnerClipRect.Min.y);
        table->BgClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y = ImMin(y0, window->InnerClipRect.Max.y);
        table->BgClipRect.Max.y = table->Bg2ClipRectForDrawCmd.Max.y = window->InnerClipRect.Max.y;
        table->Bg2DrawChannelCurrent = table->Bg2DrawChannelUnfrozen;
        IM_ASSERT(table->Bg2ClipRectForDrawCmd.Min.y <= table->Bg2ClipRectForDrawCmd.Max.y);

        float row_height = table->RowPosY2 - table->RowPosY1;
        table->RowPosY2 = window->DC.CursorPos.y = table->WorkRect.Min.y + table->RowPosY2 - table->OuterRect.Min.y;
        table->RowPosY1 = table->RowPosY2 - row_height;
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            column->DrawChannelCurrent = column->DrawChannelUnfrozen;
            column->ClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y;
        }

        // Update cliprect ahead of TableBeginCell() so clipper can access to new ClipRect->Min.y
        SetWindowClipRectBeforeSetChannel(window, table->Columns[0].ClipRect);
        table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Columns[0].DrawChannelCurrent);
    }

    if (!(table->RowFlags & ImGuiTableRowFlags_Headers))
        table->RowBgColorCounter++;
    table->IsInsideRow = false;
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns changes
//-------------------------------------------------------------------------
// - TableGetColumnIndex()
// - TableSetColumnIndex()
// - TableNextColumn()
// - TableBeginCell() [Internal]
// - TableEndCell() [Internal]
//-------------------------------------------------------------------------

int ImGui::TableGetColumnIndex()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return 0;
    return table->CurrentColumn;
}

// [Public] Append into a specific column
bool ImGui::TableSetColumnIndex(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return false;

    if (table->CurrentColumn != column_n)
    {
        if (table->CurrentColumn != -1)
            TableEndCell(table);
        IM_ASSERT(column_n >= 0 && table->ColumnsCount);
        TableBeginCell(table, column_n);
    }

    // Return whether the column is visible. User may choose to skip submitting items based on this return value,
    // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
    return (table->RequestOutputMaskByIndex & ((ImU64)1 << column_n)) != 0;
}

// [Public] Append into the next column, wrap and create a new row when already on last column
bool ImGui::TableNextColumn()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return false;

    if (table->IsInsideRow && table->CurrentColumn + 1 < table->ColumnsCount)
    {
        if (table->CurrentColumn != -1)
            TableEndCell(table);
        TableBeginCell(table, table->CurrentColumn + 1);
    }
    else
    {
        TableNextRow();
        TableBeginCell(table, 0);
    }

    // Return whether the column is visible. User may choose to skip submitting items based on this return value,
    // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
    int column_n = table->CurrentColumn;
    return (table->RequestOutputMaskByIndex & ((ImU64)1 << column_n)) != 0;
}


// [Internal] Called by TableSetColumnIndex()/TableNextColumn()
// This is called very frequently, so we need to be mindful of unnecessary overhead.
// FIXME-TABLE FIXME-OPT: Could probably shortcut some things for non-active or clipped columns.
void ImGui::TableBeginCell(ImGuiTable* table, int column_n)
{
    ImGuiTableColumn* column = &table->Columns[column_n];
    ImGuiWindow* window = table->InnerWindow;
    table->CurrentColumn = column_n;

    // Start position is roughly ~~ CellRect.Min + CellPadding + Indent
    float start_x = column->WorkMinX;
    if (column->Flags & ImGuiTableColumnFlags_IndentEnable)
        start_x += table->RowIndentOffsetX; // ~~ += window.DC.Indent.x - table->HostIndentX, except we locked it for the row.

    window->DC.CursorPos.x = start_x;
    window->DC.CursorPos.y = table->RowPosY1 + table->CellPaddingY;
    window->DC.CursorMaxPos.x = window->DC.CursorPos.x;
    window->DC.ColumnsOffset.x = start_x - window->Pos.x - window->DC.Indent.x; // FIXME-WORKRECT
    window->DC.CurrLineTextBaseOffset = table->RowTextBaseline;
    window->DC.NavLayerCurrent = (ImGuiNavLayer)column->NavLayerCurrent;

    window->WorkRect.Min.y = window->DC.CursorPos.y;
    window->WorkRect.Min.x = column->WorkMinX;
    window->WorkRect.Max.x = column->WorkMaxX;
    window->DC.ItemWidth = column->ItemWidth;

    // To allow ImGuiListClipper to function we propagate our row height
    if (!column->IsEnabled)
        window->DC.CursorPos.y = ImMax(window->DC.CursorPos.y, table->RowPosY2);

    window->SkipItems = column->IsSkipItems;
    if (column->IsSkipItems)
    {
        window->DC.LastItemId = 0;
        window->DC.LastItemStatusFlags = 0;
    }

    if (table->Flags & ImGuiTableFlags_NoClip)
    {
        // FIXME: if we end up drawing all borders/bg in EndTable, could remove this and just assert that channel hasn't changed.
        table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);
        //IM_ASSERT(table->DrawSplitter._Current == TABLE_DRAW_CHANNEL_NOCLIP);
    }
    else
    {
        // FIXME-TABLE: Could avoid this if draw channel is dummy channel?
        SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
        table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);
    }

    // Logging
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled && !column->IsSkipItems)
    {
        LogRenderedText(&window->DC.CursorPos, "|");
        g.LogLinePosY = FLT_MAX;
    }
}

// [Internal] Called by TableNextRow()/TableSetColumnIndex()/TableNextColumn()
void ImGui::TableEndCell(ImGuiTable* table)
{
    ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];
    ImGuiWindow* window = table->InnerWindow;

    // Report maximum position so we can infer content size per column.
    float* p_max_pos_x;
    if (table->RowFlags & ImGuiTableRowFlags_Headers)
        p_max_pos_x = &column->ContentMaxXHeadersUsed;  // Useful in case user submit contents in header row that is not a TableHeader() call
    else
        p_max_pos_x = table->IsUnfrozenRows ? &column->ContentMaxXUnfrozen : &column->ContentMaxXFrozen;
    *p_max_pos_x = ImMax(*p_max_pos_x, window->DC.CursorMaxPos.x);
    table->RowPosY2 = ImMax(table->RowPosY2, window->DC.CursorMaxPos.y + table->CellPaddingY);
    column->ItemWidth = window->DC.ItemWidth;

    // Propagate text baseline for the entire row
    // FIXME-TABLE: Here we propagate text baseline from the last line of the cell.. instead of the first one.
    table->RowTextBaseline = ImMax(table->RowTextBaseline, window->DC.PrevLineTextBaseOffset);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns width management
//-------------------------------------------------------------------------
// - TableGetMaxColumnWidth() [Internal]
// - TableGetColumnWidthAuto() [Internal]
// - TableSetColumnWidth()
// - TableSetColumnWidthAutoSingle() [Internal]
// - TableSetColumnWidthAutoAll() [Internal]
// - TableUpdateColumnsWeightFromWidth() [Internal]
//-------------------------------------------------------------------------

// Maximum column content width given current layout. Use column->MinX so this value on a per-column basis.
float ImGui::TableGetMaxColumnWidth(const ImGuiTable* table, int column_n)
{
    const ImGuiTableColumn* column = &table->Columns[column_n];
    float max_width = FLT_MAX;
    const float min_column_distance = table->MinColumnWidth + table->CellPaddingX * 2.0f + table->CellSpacingX1 + table->CellSpacingX2;
    if (table->Flags & ImGuiTableFlags_ScrollX)
    {
        // Frozen columns can't reach beyond visible width else scrolling will naturally break.
        // (we use DisplayOrder as within a set of multiple frozen column reordering is possible)
        if (column->DisplayOrder < table->FreezeColumnsRequest)
        {
            max_width = (table->InnerClipRect.Max.x - (table->FreezeColumnsRequest - column->DisplayOrder) * min_column_distance) - column->MinX;
            max_width = max_width - table->OuterPaddingX - table->CellPaddingX - table->CellSpacingX2;
        }
    }
    else if ((table->Flags & ImGuiTableFlags_NoKeepColumnsVisible) == 0)
    {
        // If horizontal scrolling if disabled, we apply a final lossless shrinking of columns in order to make
        // sure they are all visible. Because of this we also know that all of the columns will always fit in
        // table->WorkRect and therefore in table->InnerRect (because ScrollX is off)
        // FIXME-TABLE: This is solved incorrectly but also quite a difficult problem to fix as we also want ClipRect width to match.
        // See "table_width_distrib" and "table_width_keep_visible" tests
        max_width = table->WorkRect.Max.x - (table->ColumnsEnabledCount - column->IndexWithinEnabledSet - 1) * min_column_distance - column->MinX;
        //max_width -= table->CellSpacingX1;
        max_width -= table->CellSpacingX2;
        max_width -= table->CellPaddingX * 2.0f;
        max_width -= table->OuterPaddingX;
    }
    return max_width;
}

// Note this is meant to be stored in column->WidthAuto, please generally use the WidthAuto field
float ImGui::TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column)
{
    const float content_width_body = ImMax(column->ContentMaxXFrozen, column->ContentMaxXUnfrozen) - column->WorkMinX;
    const float content_width_headers = column->ContentMaxXHeadersIdeal - column->WorkMinX;
    float width_auto = content_width_body;
    if (!(column->Flags & ImGuiTableColumnFlags_NoHeaderWidth))
        width_auto = ImMax(width_auto, content_width_headers);

    // Non-resizable fixed columns preserve their requested width
    if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f)
        if (!(table->Flags & ImGuiTableFlags_Resizable) || (column->Flags & ImGuiTableColumnFlags_NoResize))
            width_auto = column->InitStretchWeightOrWidth;

    return ImMax(width_auto, table->MinColumnWidth);
}

// 'width' = inner column width, without padding
void ImGui::TableSetColumnWidth(int column_n, float width)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && table->IsLayoutLocked == false);
    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
    ImGuiTableColumn* column_0 = &table->Columns[column_n];
    float column_0_width = width;

    // Apply constraints early
    // Compare both requested and actual given width to avoid overwriting requested width when column is stuck (minimum size, bounded)
    IM_ASSERT(table->MinColumnWidth > 0.0f);
    const float min_width = table->MinColumnWidth;
    const float max_width = ImMax(min_width, TableGetMaxColumnWidth(table, column_n));
    column_0_width = ImClamp(column_0_width, min_width, max_width);
    if (column_0->WidthGiven == column_0_width || column_0->WidthRequest == column_0_width)
        return;

    //IMGUI_DEBUG_LOG("TableSetColumnWidth(%d, %.1f->%.1f)\n", column_0_idx, column_0->WidthGiven, column_0_width);
    ImGuiTableColumn* column_1 = (column_0->NextEnabledColumn != -1) ? &table->Columns[column_0->NextEnabledColumn] : NULL;

    // In this surprisingly not simple because of how we support mixing Fixed and multiple Stretch columns.
    // - All fixed: easy.
    // - All stretch: easy.
    // - One or more fixed + one stretch: easy.
    // - One or more fixed + more than one stretch: tricky.
    // Qt when manual resize is enabled only support a single _trailing_ stretch column.

    // When forwarding resize from Wn| to Fn+1| we need to be considerate of the _NoResize flag on Fn+1.
    // FIXME-TABLE: Find a way to rewrite all of this so interactions feel more consistent for the user.
    // Scenarios:
    // - F1 F2 F3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. Subsequent columns will be offset.
    // - F1 F2 F3  resize from F3|          --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered.
    // - F1 F2 W3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered, but it doesn't make much sense as the Stretch column will always be minimal size.
    // - F1 F2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 W2 W3  resize from W1| or W2|   --> ok
    // - W1 W2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 F2 F3  resize from F3|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 F2     resize from F2|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 W2 F3  resize from W1| or W2|   --> ok
    // - W1 F2 W3  resize from W1| or F2|   --> ok
    // - F1 W2 F3  resize from W2|          --> ok
    // - F1 W3 F2  resize from W3|          --> ok
    // - W1 F2 F3  resize from W1|          --> ok: equivalent to resizing |F2. F3 will not move.
    // - W1 F2 F3  resize from F2|          --> ok
    // All resizes from a Wx columns are locking other columns.

    // Possible improvements:
    // - W1 W2 W3  resize W1|               --> to not be stuck, both W2 and W3 would stretch down. Seems possible to fix. Would be most beneficial to simplify resize of all-weighted columns.
    // - W3 F1 F2  resize W3|               --> to not be stuck past F1|, both F1 and F2 would need to stretch down, which would be lossy or ambiguous. Seems hard to fix.

    // [Resize Rule 1] Can't resize from right of right-most visible column if there is any Stretch column. Implemented in TableUpdateLayout().

    // If we have all Fixed columns OR resizing a Fixed column that doesn't come after a Stretch one, we can do an offsetting resize.
    // This is the preferred resize path
    if (column_0->Flags & ImGuiTableColumnFlags_WidthFixed)
        if (!column_1 || table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder >= column_0->DisplayOrder)
        {
            column_0->WidthRequest = column_0_width;
            table->IsSettingsDirty = true;
            return;
        }

    // We can also use previous column if there's no next one (this is used when doing an auto-fit on the right-most stretch column)
    if (column_1 == NULL)
        column_1 = (column_0->PrevEnabledColumn != -1) ? &table->Columns[column_0->PrevEnabledColumn] : NULL;
    if (column_1 == NULL)
        return;

    // Resizing from right-side of a Stretch column before a Fixed column forward sizing to left-side of fixed column.
    // (old_a + old_b == new_a + new_b) --> (new_a == old_a + old_b - new_b)
    float column_1_width = ImMax(column_1->WidthRequest - (column_0_width - column_0->WidthRequest), min_width);
    column_0_width = column_0->WidthRequest + column_1->WidthRequest - column_1_width;
    IM_ASSERT(column_0_width > 0.0f && column_1_width > 0.0f);
    column_0->WidthRequest = column_0_width;
    column_1->WidthRequest = column_1_width;
    if ((column_0->Flags | column_1->Flags) & ImGuiTableColumnFlags_WidthStretch)
        TableUpdateColumnsWeightFromWidth(table);
    table->IsSettingsDirty = true;
}

// Disable clipping then auto-fit, will take 2 frames
// (we don't take a shortcut for unclipped columns to reduce inconsistencies when e.g. resizing multiple columns)
void ImGui::TableSetColumnWidthAutoSingle(ImGuiTable* table, int column_n)
{
    // Single auto width uses auto-fit
    ImGuiTableColumn* column = &table->Columns[column_n];
    if (!column->IsEnabled)
        return;
    column->CannotSkipItemsQueue = (1 << 0);
    table->AutoFitSingleColumn = (ImGuiTableColumnIdx)column_n;
}

void ImGui::TableSetColumnWidthAutoAll(ImGuiTable* table)
{
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (!column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_WidthStretch)) // Cannot reset weight of hidden stretch column
            continue;
        column->CannotSkipItemsQueue = (1 << 0);
        column->AutoFitQueue = (1 << 1);
    }
}

void ImGui::TableUpdateColumnsWeightFromWidth(ImGuiTable* table)
{
    IM_ASSERT(table->LeftMostStretchedColumn != -1 && table->RightMostStretchedColumn != -1);

    // Measure existing quantity
    float visible_weight = 0.0f;
    float visible_width = 0.0f;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))
            continue;
        IM_ASSERT(column->StretchWeight > 0.0f);
        visible_weight += column->StretchWeight;
        visible_width += column->WidthRequest;
    }
    IM_ASSERT(visible_weight > 0.0f && visible_width > 0.0f);

    // Apply new weights
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))
            continue;
        column->StretchWeight = (column->WidthRequest / visible_width) * visible_weight;
        IM_ASSERT(column->StretchWeight > 0.0f);
    }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Drawing
//-------------------------------------------------------------------------
// - TablePushBackgroundChannel() [Internal]
// - TablePopBackgroundChannel() [Internal]
// - TableSetupDrawChannels() [Internal]
// - TableMergeDrawChannels() [Internal]
// - TableDrawBorders() [Internal]
//-------------------------------------------------------------------------

// Bg2 is used by Selectable (and possibly other widgets) to render to the background.
// Unlike our Bg0/1 channel which we uses for RowBg/CellBg/Borders and where we guarantee all shapes to be CPU-clipped, the Bg2 channel being widgets-facing will rely on regular ClipRect.
void ImGui::TablePushBackgroundChannel()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiTable* table = g.CurrentTable;

    // Optimization: avoid SetCurrentChannel() + PushClipRect()
    table->HostBackupInnerClipRect = window->ClipRect;
    SetWindowClipRectBeforeSetChannel(window, table->Bg2ClipRectForDrawCmd);
    table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Bg2DrawChannelCurrent);
}

void ImGui::TablePopBackgroundChannel()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiTable* table = g.CurrentTable;
    ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];

    // Optimization: avoid PopClipRect() + SetCurrentChannel()
    SetWindowClipRectBeforeSetChannel(window, table->HostBackupInnerClipRect);
    table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);
}

// Allocate draw channels. Called by TableUpdateLayout()
// - We allocate them following storage order instead of display order so reordering columns won't needlessly
//   increase overall dormant memory cost.
// - We isolate headers draw commands in their own channels instead of just altering clip rects.
//   This is in order to facilitate merging of draw commands.
// - After crossing FreezeRowsCount, all columns see their current draw channel changed to a second set of channels.
// - We only use the dummy draw channel so we can push a null clipping rectangle into it without affecting other
//   channels, while simplifying per-row/per-cell overhead. It will be empty and discarded when merged.
// - We allocate 1 or 2 background draw channels. This is because we know TablePushBackgroundChannel() is only used for
//   horizontal spanning. If we allowed vertical spanning we'd need one background draw channel per merge group (1-4).
// Draw channel allocation (before merging):
// - NoClip                       --> 2+D+1 channels: bg0/1 + bg2 + foreground (same clip rect == always 1 draw call)
// - Clip                         --> 2+D+N channels
// - FreezeRows                   --> 2+D+N*2 (unless scrolling value is zero)
// - FreezeRows || FreezeColunns  --> 3+D+N*2 (unless scrolling value is zero)
// Where D is 1 if any column is clipped or hidden (dummy channel) otherwise 0.
void ImGui::TableSetupDrawChannels(ImGuiTable* table)
{
    const int freeze_row_multiplier = (table->FreezeRowsCount > 0) ? 2 : 1;
    const int channels_for_row = (table->Flags & ImGuiTableFlags_NoClip) ? 1 : table->ColumnsEnabledCount;
    const int channels_for_bg = 1 + 1 * freeze_row_multiplier;
    const int channels_for_dummy = (table->ColumnsEnabledCount < table->ColumnsCount || table->VisibleMaskByIndex != table->EnabledMaskByIndex) ? +1 : 0;
    const int channels_total = channels_for_bg + (channels_for_row * freeze_row_multiplier) + channels_for_dummy;
    table->DrawSplitter->Split(table->InnerWindow->DrawList, channels_total);
    table->DummyDrawChannel = (ImGuiTableDrawChannelIdx)((channels_for_dummy > 0) ? channels_total - 1 : -1);
    table->Bg2DrawChannelCurrent = TABLE_DRAW_CHANNEL_BG2_FROZEN;
    table->Bg2DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)((table->FreezeRowsCount > 0) ? 2 + channels_for_row : TABLE_DRAW_CHANNEL_BG2_FROZEN);

    int draw_channel_current = 2;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (column->IsVisibleX && column->IsVisibleY)
        {
            column->DrawChannelFrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current);
            column->DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current + (table->FreezeRowsCount > 0 ? channels_for_row + 1 : 0));
            if (!(table->Flags & ImGuiTableFlags_NoClip))
                draw_channel_current++;
        }
        else
        {
            column->DrawChannelFrozen = column->DrawChannelUnfrozen = table->DummyDrawChannel;
        }
        column->DrawChannelCurrent = column->DrawChannelFrozen;
    }

    // Initial draw cmd starts with a BgClipRect that matches the one of its host, to facilitate merge draw commands by default.
    // All our cell highlight are manually clipped with BgClipRect. When unfreezing it will be made smaller to fit scrolling rect.
    // (This technically isn't part of setting up draw channels, but is reasonably related to be done here)
    table->BgClipRect = table->InnerClipRect;
    table->Bg0ClipRectForDrawCmd = table->OuterWindow->ClipRect;
    table->Bg2ClipRectForDrawCmd = table->HostClipRect;
    IM_ASSERT(table->BgClipRect.Min.y <= table->BgClipRect.Max.y);
}

// This function reorder draw channels based on matching clip rectangle, to facilitate merging them. Called by EndTable().
// For simplicity we call it TableMergeDrawChannels() but in fact it only reorder channels + overwrite ClipRect,
// actual merging is done by table->DrawSplitter.Merge() which is called right after TableMergeDrawChannels().
//
// Columns where the contents didn't stray off their local clip rectangle can be merged. To achieve
// this we merge their clip rect and make them contiguous in the channel list, so they can be merged
// by the call to DrawSplitter.Merge() following to the call to this function.
// We reorder draw commands by arranging them into a maximum of 4 distinct groups:
//
//   1 group:               2 groups:              2 groups:              4 groups:
//   [ 0. ] no freeze       [ 0. ] row freeze      [ 01 ] col freeze      [ 01 ] row+col freeze
//   [ .. ]  or no scroll   [ 2. ]  and v-scroll   [ .. ]  and h-scroll   [ 23 ]  and v+h-scroll
//
// Each column itself can use 1 channel (row freeze disabled) or 2 channels (row freeze enabled).
// When the contents of a column didn't stray off its limit, we move its channels into the corresponding group
// based on its position (within frozen rows/columns groups or not).
// At the end of the operation our 1-4 groups will each have a ImDrawCmd using the same ClipRect.
// This function assume that each column are pointing to a distinct draw channel,
// otherwise merge_group->ChannelsCount will not match set bit count of merge_group->ChannelsMask.
//
// Column channels will not be merged into one of the 1-4 groups in the following cases:
// - The contents stray off its clipping rectangle (we only compare the MaxX value, not the MinX value).
//   Direct ImDrawList calls won't be taken into account by default, if you use them make sure the ImGui:: bounds
//   matches, by e.g. calling SetCursorScreenPos().
// - The channel uses more than one draw command itself. We drop all our attempt at merging stuff here..
//   we could do better but it's going to be rare and probably not worth the hassle.
// Columns for which the draw channel(s) haven't been merged with other will use their own ImDrawCmd.
//
// This function is particularly tricky to understand.. take a breath.
void ImGui::TableMergeDrawChannels(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    ImDrawListSplitter* splitter = table->DrawSplitter;
    const bool has_freeze_v = (table->FreezeRowsCount > 0);
    const bool has_freeze_h = (table->FreezeColumnsCount > 0);
    IM_ASSERT(splitter->_Current == 0);

    // Track which groups we are going to attempt to merge, and which channels goes into each group.
    struct MergeGroup
    {
        ImRect  ClipRect;
        int     ChannelsCount;
        ImBitArray<IMGUI_TABLE_MAX_DRAW_CHANNELS> ChannelsMask;

        MergeGroup() { ChannelsCount = 0; }
    };
    int merge_group_mask = 0x00;
    MergeGroup merge_groups[4];

    // 1. Scan channels and take note of those which can be merged
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        if ((table->VisibleMaskByIndex & ((ImU64)1 << column_n)) == 0)
            continue;
        ImGuiTableColumn* column = &table->Columns[column_n];

        const int merge_group_sub_count = has_freeze_v ? 2 : 1;
        for (int merge_group_sub_n = 0; merge_group_sub_n < merge_group_sub_count; merge_group_sub_n++)
        {
            const int channel_no = (merge_group_sub_n == 0) ? column->DrawChannelFrozen : column->DrawChannelUnfrozen;

            // Don't attempt to merge if there are multiple draw calls within the column
            ImDrawChannel* src_channel = &splitter->_Channels[channel_no];
            if (src_channel->_CmdBuffer.Size > 0 && src_channel->_CmdBuffer.back().ElemCount == 0)
                src_channel->_CmdBuffer.pop_back();
            if (src_channel->_CmdBuffer.Size != 1)
                continue;

            // Find out the width of this merge group and check if it will fit in our column
            // (note that we assume that rendering didn't stray on the left direction. we should need a CursorMinPos to detect it)
            if (!(column->Flags & ImGuiTableColumnFlags_NoClip))
            {
                float content_max_x;
                if (!has_freeze_v)
                    content_max_x = ImMax(column->ContentMaxXUnfrozen, column->ContentMaxXHeadersUsed); // No row freeze
                else if (merge_group_sub_n == 0)
                    content_max_x = ImMax(column->ContentMaxXFrozen, column->ContentMaxXHeadersUsed);   // Row freeze: use width before freeze
                else
                    content_max_x = column->ContentMaxXUnfrozen;                                        // Row freeze: use width after freeze
                if (content_max_x > column->ClipRect.Max.x)
                    continue;
            }

            const int merge_group_n = (has_freeze_h && column_n < table->FreezeColumnsCount ? 0 : 1) + (has_freeze_v && merge_group_sub_n == 0 ? 0 : 2);
            IM_ASSERT(channel_no < IMGUI_TABLE_MAX_DRAW_CHANNELS);
            MergeGroup* merge_group = &merge_groups[merge_group_n];
            if (merge_group->ChannelsCount == 0)
                merge_group->ClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
            merge_group->ChannelsMask.SetBit(channel_no);
            merge_group->ChannelsCount++;
            merge_group->ClipRect.Add(src_channel->_CmdBuffer[0].ClipRect);
            merge_group_mask |= (1 << merge_group_n);
        }

        // Invalidate current draw channel
        // (we don't clear DrawChannelFrozen/DrawChannelUnfrozen solely to facilitate debugging/later inspection of data)
        column->DrawChannelCurrent = (ImGuiTableDrawChannelIdx)-1;
    }

    // [DEBUG] Display merge groups
#if 0
    if (g.IO.KeyShift)
        for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)
        {
            MergeGroup* merge_group = &merge_groups[merge_group_n];
            if (merge_group->ChannelsCount == 0)
                continue;
            char buf[32];
            ImFormatString(buf, 32, "MG%d:%d", merge_group_n, merge_group->ChannelsCount);
            ImVec2 text_pos = merge_group->ClipRect.Min + ImVec2(4, 4);
            ImVec2 text_size = CalcTextSize(buf, NULL);
            GetForegroundDrawList()->AddRectFilled(text_pos, text_pos + text_size, IM_COL32(0, 0, 0, 255));
            GetForegroundDrawList()->AddText(text_pos, IM_COL32(255, 255, 0, 255), buf, NULL);
            GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 255, 0, 255));
        }
#endif

    // 2. Rewrite channel list in our preferred order
    if (merge_group_mask != 0)
    {
        // We skip channel 0 (Bg0/Bg1) and 1 (Bg2 frozen) from the shuffling since they won't move - see channels allocation in TableSetupDrawChannels().
        const int LEADING_DRAW_CHANNELS = 2;
        g.DrawChannelsTempMergeBuffer.resize(splitter->_Count - LEADING_DRAW_CHANNELS); // Use shared temporary storage so the allocation gets amortized
        ImDrawChannel* dst_tmp = g.DrawChannelsTempMergeBuffer.Data;
        ImBitArray<IMGUI_TABLE_MAX_DRAW_CHANNELS> remaining_mask;                       // We need 132-bit of storage
        remaining_mask.SetBitRange(LEADING_DRAW_CHANNELS, splitter->_Count);
        remaining_mask.ClearBit(table->Bg2DrawChannelUnfrozen);
        IM_ASSERT(has_freeze_v == false || table->Bg2DrawChannelUnfrozen != TABLE_DRAW_CHANNEL_BG2_FROZEN);
        int remaining_count = splitter->_Count - (has_freeze_v ? LEADING_DRAW_CHANNELS + 1 : LEADING_DRAW_CHANNELS);
        //ImRect host_rect = (table->InnerWindow == table->OuterWindow) ? table->InnerClipRect : table->HostClipRect;
        ImRect host_rect = table->HostClipRect;
        for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)
        {
            if (int merge_channels_count = merge_groups[merge_group_n].ChannelsCount)
            {
                MergeGroup* merge_group = &merge_groups[merge_group_n];
                ImRect merge_clip_rect = merge_group->ClipRect;

                // Extend outer-most clip limits to match those of host, so draw calls can be merged even if
                // outer-most columns have some outer padding offsetting them from their parent ClipRect.
                // The principal cases this is dealing with are:
                // - On a same-window table (not scrolling = single group), all fitting columns ClipRect -> will extend and match host ClipRect -> will merge
                // - Columns can use padding and have left-most ClipRect.Min.x and right-most ClipRect.Max.x != from host ClipRect -> will extend and match host ClipRect -> will merge
                // FIXME-TABLE FIXME-WORKRECT: We are wasting a merge opportunity on tables without scrolling if column doesn't fit
                // within host clip rect, solely because of the half-padding difference between window->WorkRect and window->InnerClipRect.
                if ((merge_group_n & 1) == 0 || !has_freeze_h)
                    merge_clip_rect.Min.x = ImMin(merge_clip_rect.Min.x, host_rect.Min.x);
                if ((merge_group_n & 2) == 0 || !has_freeze_v)
                    merge_clip_rect.Min.y = ImMin(merge_clip_rect.Min.y, host_rect.Min.y);
                if ((merge_group_n & 1) != 0)
                    merge_clip_rect.Max.x = ImMax(merge_clip_rect.Max.x, host_rect.Max.x);
                if ((merge_group_n & 2) != 0 && (table->Flags & ImGuiTableFlags_NoHostExtendY) == 0)
                    merge_clip_rect.Max.y = ImMax(merge_clip_rect.Max.y, host_rect.Max.y);
#if 0
                GetOverlayDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 0, 0, 200), 0.0f, 0, 1.0f);
                GetOverlayDrawList()->AddLine(merge_group->ClipRect.Min, merge_clip_rect.Min, IM_COL32(255, 100, 0, 200));
                GetOverlayDrawList()->AddLine(merge_group->ClipRect.Max, merge_clip_rect.Max, IM_COL32(255, 100, 0, 200));
#endif
                remaining_count -= merge_group->ChannelsCount;
                for (int n = 0; n < IM_ARRAYSIZE(remaining_mask.Storage); n++)
                    remaining_mask.Storage[n] &= ~merge_group->ChannelsMask.Storage[n];
                for (int n = 0; n < splitter->_Count && merge_channels_count != 0; n++)
                {
                    // Copy + overwrite new clip rect
                    if (!merge_group->ChannelsMask.TestBit(n))
                        continue;
                    merge_group->ChannelsMask.ClearBit(n);
                    merge_channels_count--;

                    ImDrawChannel* channel = &splitter->_Channels[n];
                    IM_ASSERT(channel->_CmdBuffer.Size == 1 && merge_clip_rect.Contains(ImRect(channel->_CmdBuffer[0].ClipRect)));
                    channel->_CmdBuffer[0].ClipRect = merge_clip_rect.ToVec4();
                    memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));
                }
            }

            // Make sure Bg2DrawChannelUnfrozen appears in the middle of our groups (whereas Bg0/Bg1 and Bg2 frozen are fixed to 0 and 1)
            if (merge_group_n == 1 && has_freeze_v)
                memcpy(dst_tmp++, &splitter->_Channels[table->Bg2DrawChannelUnfrozen], sizeof(ImDrawChannel));
        }

        // Append unmergeable channels that we didn't reorder at the end of the list
        for (int n = 0; n < splitter->_Count && remaining_count != 0; n++)
        {
            if (!remaining_mask.TestBit(n))
                continue;
            ImDrawChannel* channel = &splitter->_Channels[n];
            memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));
            remaining_count--;
        }
        IM_ASSERT(dst_tmp == g.DrawChannelsTempMergeBuffer.Data + g.DrawChannelsTempMergeBuffer.Size);
        memcpy(splitter->_Channels.Data + LEADING_DRAW_CHANNELS, g.DrawChannelsTempMergeBuffer.Data, (splitter->_Count - LEADING_DRAW_CHANNELS) * sizeof(ImDrawChannel));
    }
}

// FIXME-TABLE: This is a mess, need to redesign how we render borders (as some are also done in TableEndRow)
void ImGui::TableDrawBorders(ImGuiTable* table)
{
    ImGuiWindow* inner_window = table->InnerWindow;
    if (!table->OuterWindow->ClipRect.Overlaps(table->OuterRect))
        return;

    ImDrawList* inner_drawlist = inner_window->DrawList;
    table->DrawSplitter->SetCurrentChannel(inner_drawlist, TABLE_DRAW_CHANNEL_BG0);
    inner_drawlist->PushClipRect(table->Bg0ClipRectForDrawCmd.Min, table->Bg0ClipRectForDrawCmd.Max, false);

    // Draw inner border and resizing feedback
    const float border_size = TABLE_BORDER_SIZE;
    const float draw_y1 = table->InnerRect.Min.y;
    const float draw_y2_body = table->InnerRect.Max.y;
    const float draw_y2_head = table->IsUsingHeaders ? ImMin(table->InnerRect.Max.y, (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y : table->WorkRect.Min.y) + table->LastFirstRowHeight) : draw_y1;
    if (table->Flags & ImGuiTableFlags_BordersInnerV)
    {
        for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
        {
            if (!(table->EnabledMaskByDisplayOrder & ((ImU64)1 << order_n)))
                continue;

            const int column_n = table->DisplayOrderToIndex[order_n];
            ImGuiTableColumn* column = &table->Columns[column_n];
            const bool is_hovered = (table->HoveredColumnBorder == column_n);
            const bool is_resized = (table->ResizedColumn == column_n) && (table->InstanceInteracted == table->InstanceCurrent);
            const bool is_resizable = (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_)) == 0;
            const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);
            if (column->MaxX > table->InnerClipRect.Max.x && !is_resized)
                continue;

            // Decide whether right-most column is visible
            if (column->NextEnabledColumn == -1 && !is_resizable)
                if ((table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame || (table->Flags & ImGuiTableFlags_NoHostExtendX))
                    continue;
            if (column->MaxX <= column->ClipRect.Min.x) // FIXME-TABLE FIXME-STYLE: Assume BorderSize==1, this is problematic if we want to increase the border size..
                continue;

            // Draw in outer window so right-most column won't be clipped
            // Always draw full height border when being resized/hovered, or on the delimitation of frozen column scrolling.
            ImU32 col;
            float draw_y2;
            if (is_hovered || is_resized || is_frozen_separator)
            {
                draw_y2 = draw_y2_body;
                col = is_resized ? GetColorU32(ImGuiCol_SeparatorActive) : is_hovered ? GetColorU32(ImGuiCol_SeparatorHovered) : table->BorderColorStrong;
            }
            else
            {
                draw_y2 = (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)) ? draw_y2_head : draw_y2_body;
                col = (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)) ? table->BorderColorStrong : table->BorderColorLight;
            }

            if (draw_y2 > draw_y1)
                inner_drawlist->AddLine(ImVec2(column->MaxX, draw_y1), ImVec2(column->MaxX, draw_y2), col, border_size);
        }
    }

    // Draw outer border
    // FIXME: could use AddRect or explicit VLine/HLine helper?
    if (table->Flags & ImGuiTableFlags_BordersOuter)
    {
        // Display outer border offset by 1 which is a simple way to display it without adding an extra draw call
        // (Without the offset, in outer_window it would be rendered behind cells, because child windows are above their
        // parent. In inner_window, it won't reach out over scrollbars. Another weird solution would be to display part
        // of it in inner window, and the part that's over scrollbars in the outer window..)
        // Either solution currently won't allow us to use a larger border size: the border would clipped.
        const ImRect outer_border = table->OuterRect;
        const ImU32 outer_col = table->BorderColorStrong;
        if ((table->Flags & ImGuiTableFlags_BordersOuter) == ImGuiTableFlags_BordersOuter)
        {
            inner_drawlist->AddRect(outer_border.Min, outer_border.Max, outer_col, 0.0f, 0, border_size);
        }
        else if (table->Flags & ImGuiTableFlags_BordersOuterV)
        {
            inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Min.x, outer_border.Max.y), outer_col, border_size);
            inner_drawlist->AddLine(ImVec2(outer_border.Max.x, outer_border.Min.y), outer_border.Max, outer_col, border_size);
        }
        else if (table->Flags & ImGuiTableFlags_BordersOuterH)
        {
            inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Max.x, outer_border.Min.y), outer_col, border_size);
            inner_drawlist->AddLine(ImVec2(outer_border.Min.x, outer_border.Max.y), outer_border.Max, outer_col, border_size);
        }
    }
    if ((table->Flags & ImGuiTableFlags_BordersInnerH) && table->RowPosY2 < table->OuterRect.Max.y)
    {
        // Draw bottom-most row border
        const float border_y = table->RowPosY2;
        if (border_y >= table->BgClipRect.Min.y && border_y < table->BgClipRect.Max.y)
            inner_drawlist->AddLine(ImVec2(table->BorderX1, border_y), ImVec2(table->BorderX2, border_y), table->BorderColorLight, border_size);
    }

    inner_drawlist->PopClipRect();
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Sorting
//-------------------------------------------------------------------------
// - TableGetSortSpecs()
// - TableFixColumnSortDirection() [Internal]
// - TableGetColumnNextSortDirection() [Internal]
// - TableSetColumnSortDirection() [Internal]
// - TableSortSpecsSanitize() [Internal]
// - TableSortSpecsBuild() [Internal]
//-------------------------------------------------------------------------

// Return NULL if no sort specs (most often when ImGuiTableFlags_Sortable is not set)
// You can sort your data again when 'SpecsChanged == true'. It will be true with sorting specs have changed since
// last call, or the first time.
// Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable()!
ImGuiTableSortSpecs* ImGui::TableGetSortSpecs()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL);

    if (!(table->Flags & ImGuiTableFlags_Sortable))
        return NULL;

    // Require layout (in case TableHeadersRow() hasn't been called) as it may alter IsSortSpecsDirty in some paths.
    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);

    TableSortSpecsBuild(table);

    return &table->SortSpecs;
}

static inline ImGuiSortDirection TableGetColumnAvailSortDirection(ImGuiTableColumn* column, int n)
{
    IM_ASSERT(n < column->SortDirectionsAvailCount);
    return (column->SortDirectionsAvailList >> (n << 1)) & 0x03;
}

// Fix sort direction if currently set on a value which is unavailable (e.g. activating NoSortAscending/NoSortDescending)
void ImGui::TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column)
{
    if (column->SortOrder == -1 || (column->SortDirectionsAvailMask & (1 << column->SortDirection)) != 0)
        return;
    column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);
    table->IsSortSpecsDirty = true;
}

// Calculate next sort direction that would be set after clicking the column
// - If the PreferSortDescending flag is set, we will default to a Descending direction on the first click.
// - Note that the PreferSortAscending flag is never checked, it is essentially the default and therefore a no-op.
IM_STATIC_ASSERT(ImGuiSortDirection_None == 0 && ImGuiSortDirection_Ascending == 1 && ImGuiSortDirection_Descending == 2);
ImGuiSortDirection ImGui::TableGetColumnNextSortDirection(ImGuiTableColumn* column)
{
    IM_ASSERT(column->SortDirectionsAvailCount > 0);
    if (column->SortOrder == -1)
        return TableGetColumnAvailSortDirection(column, 0);
    for (int n = 0; n < 3; n++)
        if (column->SortDirection == TableGetColumnAvailSortDirection(column, n))
            return TableGetColumnAvailSortDirection(column, (n + 1) % column->SortDirectionsAvailCount);
    IM_ASSERT(0);
    return ImGuiSortDirection_None;
}

// Note that the NoSortAscending/NoSortDescending flags are processed in TableSortSpecsSanitize(), and they may change/revert
// the value of SortDirection. We could technically also do it here but it would be unnecessary and duplicate code.
void ImGui::TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;

    if (!(table->Flags & ImGuiTableFlags_SortMulti))
        append_to_sort_specs = false;
    if (!(table->Flags & ImGuiTableFlags_SortTristate))
        IM_ASSERT(sort_direction != ImGuiSortDirection_None);

    ImGuiTableColumnIdx sort_order_max = 0;
    if (append_to_sort_specs)
        for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
            sort_order_max = ImMax(sort_order_max, table->Columns[other_column_n].SortOrder);

    ImGuiTableColumn* column = &table->Columns[column_n];
    column->SortDirection = (ImU8)sort_direction;
    if (column->SortDirection == ImGuiSortDirection_None)
        column->SortOrder = -1;
    else if (column->SortOrder == -1 || !append_to_sort_specs)
        column->SortOrder = append_to_sort_specs ? sort_order_max + 1 : 0;

    for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
    {
        ImGuiTableColumn* other_column = &table->Columns[other_column_n];
        if (other_column != column && !append_to_sort_specs)
            other_column->SortOrder = -1;
        TableFixColumnSortDirection(table, other_column);
    }
    table->IsSettingsDirty = true;
    table->IsSortSpecsDirty = true;
}

void ImGui::TableSortSpecsSanitize(ImGuiTable* table)
{
    IM_ASSERT(table->Flags & ImGuiTableFlags_Sortable);

    // Clear SortOrder from hidden column and verify that there's no gap or duplicate.
    int sort_order_count = 0;
    ImU64 sort_order_mask = 0x00;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (column->SortOrder != -1 && !column->IsEnabled)
            column->SortOrder = -1;
        if (column->SortOrder == -1)
            continue;
        sort_order_count++;
        sort_order_mask |= ((ImU64)1 << column->SortOrder);
        IM_ASSERT(sort_order_count < (int)sizeof(sort_order_mask) * 8);
    }

    const bool need_fix_linearize = ((ImU64)1 << sort_order_count) != (sort_order_mask + 1);
    const bool need_fix_single_sort_order = (sort_order_count > 1) && !(table->Flags & ImGuiTableFlags_SortMulti);
    if (need_fix_linearize || need_fix_single_sort_order)
    {
        ImU64 fixed_mask = 0x00;
        for (int sort_n = 0; sort_n < sort_order_count; sort_n++)
        {
            // Fix: Rewrite sort order fields if needed so they have no gap or duplicate.
            // (e.g. SortOrder 0 disappeared, SortOrder 1..2 exists --> rewrite then as SortOrder 0..1)
            int column_with_smallest_sort_order = -1;
            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                if ((fixed_mask & ((ImU64)1 << (ImU64)column_n)) == 0 && table->Columns[column_n].SortOrder != -1)
                    if (column_with_smallest_sort_order == -1 || table->Columns[column_n].SortOrder < table->Columns[column_with_smallest_sort_order].SortOrder)
                        column_with_smallest_sort_order = column_n;
            IM_ASSERT(column_with_smallest_sort_order != -1);
            fixed_mask |= ((ImU64)1 << column_with_smallest_sort_order);
            table->Columns[column_with_smallest_sort_order].SortOrder = (ImGuiTableColumnIdx)sort_n;

            // Fix: Make sure only one column has a SortOrder if ImGuiTableFlags_MultiSortable is not set.
            if (need_fix_single_sort_order)
            {
                sort_order_count = 1;
                for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                    if (column_n != column_with_smallest_sort_order)
                        table->Columns[column_n].SortOrder = -1;
                break;
            }
        }
    }

    // Fallback default sort order (if no column had the ImGuiTableColumnFlags_DefaultSort flag)
    if (sort_order_count == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            if (column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_NoSort))
            {
                sort_order_count = 1;
                column->SortOrder = 0;
                column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);
                break;
            }
        }

    table->SortSpecsCount = (ImGuiTableColumnIdx)sort_order_count;
}

void ImGui::TableSortSpecsBuild(ImGuiTable* table)
{
    bool dirty = table->IsSortSpecsDirty;
    if (dirty)
    {
        TableSortSpecsSanitize(table);
        table->SortSpecsMulti.resize(table->SortSpecsCount <= 1 ? 0 : table->SortSpecsCount);
        table->SortSpecs.SpecsDirty = true; // Mark as dirty for user
        table->IsSortSpecsDirty = false; // Mark as not dirty for us
    }

    // Write output
    ImGuiTableColumnSortSpecs* sort_specs = (table->SortSpecsCount == 0) ? NULL : (table->SortSpecsCount == 1) ? &table->SortSpecsSingle : table->SortSpecsMulti.Data;
    if (dirty && sort_specs != NULL)
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            if (column->SortOrder == -1)
                continue;
            IM_ASSERT(column->SortOrder < table->SortSpecsCount);
            ImGuiTableColumnSortSpecs* sort_spec = &sort_specs[column->SortOrder];
            sort_spec->ColumnUserID = column->UserID;
            sort_spec->ColumnIndex = (ImGuiTableColumnIdx)column_n;
            sort_spec->SortOrder = (ImGuiTableColumnIdx)column->SortOrder;
            sort_spec->SortDirection = column->SortDirection;
        }

    table->SortSpecs.Specs = sort_specs;
    table->SortSpecs.SpecsCount = table->SortSpecsCount;
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Headers
//-------------------------------------------------------------------------
// - TableGetHeaderRowHeight() [Internal]
// - TableHeadersRow()
// - TableHeader()
//-------------------------------------------------------------------------

float ImGui::TableGetHeaderRowHeight()
{
    // Caring for a minor edge case:
    // Calculate row height, for the unlikely case that some labels may be taller than others.
    // If we didn't do that, uneven header height would highlight but smaller one before the tallest wouldn't catch input for all height.
    // In your custom header row you may omit this all together and just call TableNextRow() without a height...
    float row_height = GetTextLineHeight();
    int columns_count = TableGetColumnCount();
    for (int column_n = 0; column_n < columns_count; column_n++)
    {
        ImGuiTableColumnFlags flags = TableGetColumnFlags(column_n);
        if ((flags & ImGuiTableColumnFlags_IsEnabled) && !(flags & ImGuiTableColumnFlags_NoHeaderLabel))
            row_height = ImMax(row_height, CalcTextSize(TableGetColumnName(column_n)).y);
    }
    row_height += GetStyle().CellPadding.y * 2.0f;
    return row_height;
}

// [Public] This is a helper to output TableHeader() calls based on the column names declared in TableSetupColumn().
// The intent is that advanced users willing to create customized headers would not need to use this helper
// and can create their own! For example: TableHeader() may be preceeded by Checkbox() or other custom widgets.
// See 'Demo->Tables->Custom headers' for a demonstration of implementing a custom version of this.
// This code is constructed to not make much use of internal functions, as it is intended to be a template to copy.
// FIXME-TABLE: TableOpenContextMenu() and TableGetHeaderRowHeight() are not public.
void ImGui::TableHeadersRow()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && "Need to call TableHeadersRow() after BeginTable()!");

    // Layout if not already done (this is automatically done by TableNextRow, we do it here solely to facilitate stepping in debugger as it is frequent to step in TableUpdateLayout)
    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);

    // Open row
    const float row_y1 = GetCursorScreenPos().y;
    const float row_height = TableGetHeaderRowHeight();
    TableNextRow(ImGuiTableRowFlags_Headers, row_height);
    if (table->HostSkipItems) // Merely an optimization, you may skip in your own code.
        return;

    const int columns_count = TableGetColumnCount();
    for (int column_n = 0; column_n < columns_count; column_n++)
    {
        if (!TableSetColumnIndex(column_n))
            continue;

        // Push an id to allow unnamed labels (generally accidental, but let's behave nicely with them)
        // - in your own code you may omit the PushID/PopID all-together, provided you know they won't collide
        // - table->InstanceCurrent is only >0 when we use multiple BeginTable/EndTable calls with same identifier.
        const char* name = (TableGetColumnFlags(column_n) & ImGuiTableColumnFlags_NoHeaderLabel) ? "" : TableGetColumnName(column_n);
        PushID(table->InstanceCurrent * table->ColumnsCount + column_n);
        TableHeader(name);
        PopID();
    }

    // Allow opening popup from the right-most section after the last column.
    ImVec2 mouse_pos = ImGui::GetMousePos();
    if (IsMouseReleased(1) && TableGetHoveredColumn() == columns_count)
        if (mouse_pos.y >= row_y1 && mouse_pos.y < row_y1 + row_height)
            TableOpenContextMenu(-1); // Will open a non-column-specific popup.
}

// Emit a column header (text + optional sort order)
// We cpu-clip text here so that all columns headers can be merged into a same draw call.
// Note that because of how we cpu-clip and display sorting indicators, you _cannot_ use SameLine() after a TableHeader()
void ImGui::TableHeader(const char* label)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && "Need to call TableHeader() after BeginTable()!");
    IM_ASSERT(table->CurrentColumn != -1);
    const int column_n = table->CurrentColumn;
    ImGuiTableColumn* column = &table->Columns[column_n];

    // Label
    if (label == NULL)
        label = "";
    const char* label_end = FindRenderedTextEnd(label);
    ImVec2 label_size = CalcTextSize(label, label_end, true);
    ImVec2 label_pos = window->DC.CursorPos;

    // If we already got a row height, there's use that.
    // FIXME-TABLE: Padding problem if the correct outer-padding CellBgRect strays off our ClipRect?
    ImRect cell_r = TableGetCellBgRect(table, column_n);
    float label_height = ImMax(label_size.y, table->RowMinHeight - table->CellPaddingY * 2.0f);

    // Calculate ideal size for sort order arrow
    float w_arrow = 0.0f;
    float w_sort_text = 0.0f;
    char sort_order_suf[4] = "";
    const float ARROW_SCALE = 0.65f;
    if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))
    {
        w_arrow = ImFloor(g.FontSize * ARROW_SCALE + g.Style.FramePadding.x);
        if (column->SortOrder > 0)
        {
            ImFormatString(sort_order_suf, IM_ARRAYSIZE(sort_order_suf), "%d", column->SortOrder + 1);
            w_sort_text = g.Style.ItemInnerSpacing.x + CalcTextSize(sort_order_suf).x;
        }
    }

    // We feed our unclipped width to the column without writing on CursorMaxPos, so that column is still considering for merging.
    float max_pos_x = label_pos.x + label_size.x + w_sort_text + w_arrow;
    column->ContentMaxXHeadersUsed = ImMax(column->ContentMaxXHeadersUsed, column->WorkMaxX);
    column->ContentMaxXHeadersIdeal = ImMax(column->ContentMaxXHeadersIdeal, max_pos_x);

    // Keep header highlighted when context menu is open.
    const bool selected = (table->IsContextPopupOpen && table->ContextPopupColumn == column_n && table->InstanceInteracted == table->InstanceCurrent);
    ImGuiID id = window->GetID(label);
    ImRect bb(cell_r.Min.x, cell_r.Min.y, cell_r.Max.x, ImMax(cell_r.Max.y, cell_r.Min.y + label_height + g.Style.CellPadding.y * 2.0f));
    ItemSize(ImVec2(0.0f, label_height)); // Don't declare unclipped width, it'll be fed ContentMaxPosHeadersIdeal
    if (!ItemAdd(bb, id))
        return;

    //GetForegroundDrawList()->AddRect(cell_r.Min, cell_r.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]
    //GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]

    // Using AllowItemOverlap mode because we cover the whole cell, and we want user to be able to submit subsequent items.
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_AllowItemOverlap);
    if (g.ActiveId != id)
        SetItemAllowOverlap();
    if (held || hovered || selected)
    {
        const ImU32 col = GetColorU32(held ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
        //RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
        TableSetBgColor(ImGuiTableBgTarget_CellBg, col, table->CurrentColumn);
    }
    else
    {
        // Submit single cell bg color in the case we didn't submit a full header row
        if ((table->RowFlags & ImGuiTableRowFlags_Headers) == 0)
            TableSetBgColor(ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_TableHeaderBg), table->CurrentColumn);
    }
    RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);
    if (held)
        table->HeldHeaderColumn = (ImGuiTableColumnIdx)column_n;
    window->DC.CursorPos.y -= g.Style.ItemSpacing.y * 0.5f;

    // Drag and drop to re-order columns.
    // FIXME-TABLE: Scroll request while reordering a column and it lands out of the scrolling zone.
    if (held && (table->Flags & ImGuiTableFlags_Reorderable) && IsMouseDragging(0) && !g.DragDropActive)
    {
        // While moving a column it will jump on the other side of the mouse, so we also test for MouseDelta.x
        table->ReorderColumn = (ImGuiTableColumnIdx)column_n;
        table->InstanceInteracted = table->InstanceCurrent;

        // We don't reorder: through the frozen<>unfrozen line, or through a column that is marked with ImGuiTableColumnFlags_NoReorder.
        if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < cell_r.Min.x)
            if (ImGuiTableColumn* prev_column = (column->PrevEnabledColumn != -1) ? &table->Columns[column->PrevEnabledColumn] : NULL)
                if (!((column->Flags | prev_column->Flags) & ImGuiTableColumnFlags_NoReorder))
                    if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (prev_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))
                        table->ReorderColumnDir = -1;
        if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > cell_r.Max.x)
            if (ImGuiTableColumn* next_column = (column->NextEnabledColumn != -1) ? &table->Columns[column->NextEnabledColumn] : NULL)
                if (!((column->Flags | next_column->Flags) & ImGuiTableColumnFlags_NoReorder))
                    if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (next_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))
                        table->ReorderColumnDir = +1;
    }

    // Sort order arrow
    const float ellipsis_max = cell_r.Max.x - w_arrow - w_sort_text;
    if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))
    {
        if (column->SortOrder != -1)
        {
            float x = ImMax(cell_r.Min.x, cell_r.Max.x - w_arrow - w_sort_text);
            float y = label_pos.y;
            if (column->SortOrder > 0)
            {
                PushStyleColor(ImGuiCol_Text, GetColorU32(ImGuiCol_Text, 0.70f));
                RenderText(ImVec2(x + g.Style.ItemInnerSpacing.x, y), sort_order_suf);
                PopStyleColor();
                x += w_sort_text;
            }
            RenderArrow(window->DrawList, ImVec2(x, y), GetColorU32(ImGuiCol_Text), column->SortDirection == ImGuiSortDirection_Ascending ? ImGuiDir_Up : ImGuiDir_Down, ARROW_SCALE);
        }

        // Handle clicking on column header to adjust Sort Order
        if (pressed && table->ReorderColumn != column_n)
        {
            ImGuiSortDirection sort_direction = TableGetColumnNextSortDirection(column);
            TableSetColumnSortDirection(column_n, sort_direction, g.IO.KeyShift);
        }
    }

    // Render clipped label. Clipping here ensure that in the majority of situations, all our header cells will
    // be merged into a single draw call.
    //window->DrawList->AddCircleFilled(ImVec2(ellipsis_max, label_pos.y), 40, IM_COL32_WHITE);
    RenderTextEllipsis(window->DrawList, label_pos, ImVec2(ellipsis_max, label_pos.y + label_height + g.Style.FramePadding.y), ellipsis_max, ellipsis_max, label, label_end, &label_size);

    const bool text_clipped = label_size.x > (ellipsis_max - label_pos.x);
    if (text_clipped && hovered && g.HoveredIdNotActiveTimer > g.TooltipSlowDelay)
        SetTooltip("%.*s", (int)(label_end - label), label);

    // We don't use BeginPopupContextItem() because we want the popup to stay up even after the column is hidden
    if (IsMouseReleased(1) && IsItemHovered())
        TableOpenContextMenu(column_n);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Context Menu
//-------------------------------------------------------------------------
// - TableOpenContextMenu() [Internal]
// - TableDrawContextMenu() [Internal]
//-------------------------------------------------------------------------

// Use -1 to open menu not specific to a given column.
void ImGui::TableOpenContextMenu(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (column_n == -1 && table->CurrentColumn != -1)   // When called within a column automatically use this one (for consistency)
        column_n = table->CurrentColumn;
    if (column_n == table->ColumnsCount)                // To facilitate using with TableGetHoveredColumn()
        column_n = -1;
    IM_ASSERT(column_n >= -1 && column_n < table->ColumnsCount);
    if (table->Flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))
    {
        table->IsContextPopupOpen = true;
        table->ContextPopupColumn = (ImGuiTableColumnIdx)column_n;
        table->InstanceInteracted = table->InstanceCurrent;
        const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);
        OpenPopupEx(context_menu_id, ImGuiPopupFlags_None);
    }
}

// Output context menu into current window (generally a popup)
// FIXME-TABLE: Ideally this should be writable by the user. Full programmatic access to that data?
void ImGui::TableDrawContextMenu(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    bool want_separator = false;
    const int column_n = (table->ContextPopupColumn >= 0 && table->ContextPopupColumn < table->ColumnsCount) ? table->ContextPopupColumn : -1;
    ImGuiTableColumn* column = (column_n != -1) ? &table->Columns[column_n] : NULL;

    // Sizing
    if (table->Flags & ImGuiTableFlags_Resizable)
    {
        if (column != NULL)
        {
            const bool can_resize = !(column->Flags & ImGuiTableColumnFlags_NoResize) && column->IsEnabled;
            if (MenuItem("Size column to fit###SizeOne", NULL, false, can_resize))
                TableSetColumnWidthAutoSingle(table, column_n);
        }

        const char* size_all_desc;
        if (table->ColumnsEnabledFixedCount == table->ColumnsEnabledCount && (table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame)
            size_all_desc = "Size all columns to fit###SizeAll";        // All fixed
        else
            size_all_desc = "Size all columns to default###SizeAll";    // All stretch or mixed
        if (MenuItem(size_all_desc, NULL))
            TableSetColumnWidthAutoAll(table);
        want_separator = true;
    }

    // Ordering
    if (table->Flags & ImGuiTableFlags_Reorderable)
    {
        if (MenuItem("Reset order", NULL, false, !table->IsDefaultDisplayOrder))
            table->IsResetDisplayOrderRequest = true;
        want_separator = true;
    }

    // Reset all (should work but seems unnecessary/noisy to expose?)
    //if (MenuItem("Reset all"))
    //    table->IsResetAllRequest = true;

    // Sorting
    // (modify TableOpenContextMenu() to add _Sortable flag if enabling this)
#if 0
    if ((table->Flags & ImGuiTableFlags_Sortable) && column != NULL && (column->Flags & ImGuiTableColumnFlags_NoSort) == 0)
    {
        if (want_separator)
            Separator();
        want_separator = true;

        bool append_to_sort_specs = g.IO.KeyShift;
        if (MenuItem("Sort in Ascending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Ascending, (column->Flags & ImGuiTableColumnFlags_NoSortAscending) == 0))
            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Ascending, append_to_sort_specs);
        if (MenuItem("Sort in Descending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Descending, (column->Flags & ImGuiTableColumnFlags_NoSortDescending) == 0))
            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Descending, append_to_sort_specs);
    }
#endif

    // Hiding / Visibility
    if (table->Flags & ImGuiTableFlags_Hideable)
    {
        if (want_separator)
            Separator();
        want_separator = true;

        PushItemFlag(ImGuiItemFlags_SelectableDontClosePopup, true);
        for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
        {
            ImGuiTableColumn* other_column = &table->Columns[other_column_n];
            if (other_column->Flags & ImGuiTableColumnFlags_Disabled)
                continue;

            const char* name = TableGetColumnName(table, other_column_n);
            if (name == NULL || name[0] == 0)
                name = "<Unknown>";

            // Make sure we can't hide the last active column
            bool menu_item_active = (other_column->Flags & ImGuiTableColumnFlags_NoHide) ? false : true;
            if (other_column->IsUserEnabled && table->ColumnsEnabledCount <= 1)
                menu_item_active = false;
            if (MenuItem(name, NULL, other_column->IsUserEnabled, menu_item_active))
                other_column->IsUserEnabledNextFrame = !other_column->IsUserEnabled;
        }
        PopItemFlag();
    }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Settings (.ini data)
//-------------------------------------------------------------------------
// FIXME: The binding/finding/creating flow are too confusing.
//-------------------------------------------------------------------------
// - TableSettingsInit() [Internal]
// - TableSettingsCalcChunkSize() [Internal]
// - TableSettingsCreate() [Internal]
// - TableSettingsFindByID() [Internal]
// - TableGetBoundSettings() [Internal]
// - TableResetSettings()
// - TableSaveSettings() [Internal]
// - TableLoadSettings() [Internal]
// - TableSettingsHandler_ClearAll() [Internal]
// - TableSettingsHandler_ApplyAll() [Internal]
// - TableSettingsHandler_ReadOpen() [Internal]
// - TableSettingsHandler_ReadLine() [Internal]
// - TableSettingsHandler_WriteAll() [Internal]
// - TableSettingsInstallHandler() [Internal]
//-------------------------------------------------------------------------
// [Init] 1: TableSettingsHandler_ReadXXXX()   Load and parse .ini file into TableSettings.
// [Main] 2: TableLoadSettings()               When table is created, bind Table to TableSettings, serialize TableSettings data into Table.
// [Main] 3: TableSaveSettings()               When table properties are modified, serialize Table data into bound or new TableSettings, mark .ini as dirty.
// [Main] 4: TableSettingsHandler_WriteAll()   When .ini file is dirty (which can come from other source), save TableSettings into .ini file.
//-------------------------------------------------------------------------

// Clear and initialize empty settings instance
static void TableSettingsInit(ImGuiTableSettings* settings, ImGuiID id, int columns_count, int columns_count_max)
{
    IM_PLACEMENT_NEW(settings) ImGuiTableSettings();
    ImGuiTableColumnSettings* settings_column = settings->GetColumnSettings();
    for (int n = 0; n < columns_count_max; n++, settings_column++)
        IM_PLACEMENT_NEW(settings_column) ImGuiTableColumnSettings();
    settings->ID = id;
    settings->ColumnsCount = (ImGuiTableColumnIdx)columns_count;
    settings->ColumnsCountMax = (ImGuiTableColumnIdx)columns_count_max;
    settings->WantApply = true;
}

static size_t TableSettingsCalcChunkSize(int columns_count)
{
    return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);
}

ImGuiTableSettings* ImGui::TableSettingsCreate(ImGuiID id, int columns_count)
{
    ImGuiContext& g = *GImGui;
    ImGuiTableSettings* settings = g.SettingsTables.alloc_chunk(TableSettingsCalcChunkSize(columns_count));
    TableSettingsInit(settings, id, columns_count, columns_count);
    return settings;
}

// Find existing settings
ImGuiTableSettings* ImGui::TableSettingsFindByID(ImGuiID id)
{
    // FIXME-OPT: Might want to store a lookup map for this?
    ImGuiContext& g = *GImGui;
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
        if (settings->ID == id)
            return settings;
    return NULL;
}

// Get settings for a given table, NULL if none
ImGuiTableSettings* ImGui::TableGetBoundSettings(ImGuiTable* table)
{
    if (table->SettingsOffset != -1)
    {
        ImGuiContext& g = *GImGui;
        ImGuiTableSettings* settings = g.SettingsTables.ptr_from_offset(table->SettingsOffset);
        IM_ASSERT(settings->ID == table->ID);
        if (settings->ColumnsCountMax >= table->ColumnsCount)
            return settings; // OK
        settings->ID = 0; // Invalidate storage, we won't fit because of a count change
    }
    return NULL;
}

// Restore initial state of table (with or without saved settings)
void ImGui::TableResetSettings(ImGuiTable* table)
{
    table->IsInitializing = table->IsSettingsDirty = true;
    table->IsResetAllRequest = false;
    table->IsSettingsRequestLoad = false;                   // Don't reload from ini
    table->SettingsLoadedFlags = ImGuiTableFlags_None;      // Mark as nothing loaded so our initialized data becomes authoritative
}

void ImGui::TableSaveSettings(ImGuiTable* table)
{
    table->IsSettingsDirty = false;
    if (table->Flags & ImGuiTableFlags_NoSavedSettings)
        return;

    // Bind or create settings data
    ImGuiContext& g = *GImGui;
    ImGuiTableSettings* settings = TableGetBoundSettings(table);
    if (settings == NULL)
    {
        settings = TableSettingsCreate(table->ID, table->ColumnsCount);
        table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
    }
    settings->ColumnsCount = (ImGuiTableColumnIdx)table->ColumnsCount;

    // Serialize ImGuiTable/ImGuiTableColumn into ImGuiTableSettings/ImGuiTableColumnSettings
    IM_ASSERT(settings->ID == table->ID);
    IM_ASSERT(settings->ColumnsCount == table->ColumnsCount && settings->ColumnsCountMax >= settings->ColumnsCount);
    ImGuiTableColumn* column = table->Columns.Data;
    ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();

    bool save_ref_scale = false;
    settings->SaveFlags = ImGuiTableFlags_None;
    for (int n = 0; n < table->ColumnsCount; n++, column++, column_settings++)
    {
        const float width_or_weight = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? column->StretchWeight : column->WidthRequest;
        column_settings->WidthOrWeight = width_or_weight;
        column_settings->Index = (ImGuiTableColumnIdx)n;
        column_settings->DisplayOrder = column->DisplayOrder;
        column_settings->SortOrder = column->SortOrder;
        column_settings->SortDirection = column->SortDirection;
        column_settings->IsEnabled = column->IsUserEnabled;
        column_settings->IsStretch = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? 1 : 0;
        if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) == 0)
            save_ref_scale = true;

        // We skip saving some data in the .ini file when they are unnecessary to restore our state.
        // Note that fixed width where initial width was derived from auto-fit will always be saved as InitStretchWeightOrWidth will be 0.0f.
        // FIXME-TABLE: We don't have logic to easily compare SortOrder to DefaultSortOrder yet so it's always saved when present.
        if (width_or_weight != column->InitStretchWeightOrWidth)
            settings->SaveFlags |= ImGuiTableFlags_Resizable;
        if (column->DisplayOrder != n)
            settings->SaveFlags |= ImGuiTableFlags_Reorderable;
        if (column->SortOrder != -1)
            settings->SaveFlags |= ImGuiTableFlags_Sortable;
        if (column->IsUserEnabled != ((column->Flags & ImGuiTableColumnFlags_DefaultHide) == 0))
            settings->SaveFlags |= ImGuiTableFlags_Hideable;
    }
    settings->SaveFlags &= table->Flags;
    settings->RefScale = save_ref_scale ? table->RefScale : 0.0f;

    MarkIniSettingsDirty();
}

void ImGui::TableLoadSettings(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    table->IsSettingsRequestLoad = false;
    if (table->Flags & ImGuiTableFlags_NoSavedSettings)
        return;

    // Bind settings
    ImGuiTableSettings* settings;
    if (table->SettingsOffset == -1)
    {
        settings = TableSettingsFindByID(table->ID);
        if (settings == NULL)
            return;
        if (settings->ColumnsCount != table->ColumnsCount) // Allow settings if columns count changed. We could otherwise decide to return...
            table->IsSettingsDirty = true;
        table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
    }
    else
    {
        settings = TableGetBoundSettings(table);
    }

    table->SettingsLoadedFlags = settings->SaveFlags;
    table->RefScale = settings->RefScale;

    // Serialize ImGuiTableSettings/ImGuiTableColumnSettings into ImGuiTable/ImGuiTableColumn
    ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();
    ImU64 display_order_mask = 0;
    for (int data_n = 0; data_n < settings->ColumnsCount; data_n++, column_settings++)
    {
        int column_n = column_settings->Index;
        if (column_n < 0 || column_n >= table->ColumnsCount)
            continue;

        ImGuiTableColumn* column = &table->Columns[column_n];
        if (settings->SaveFlags & ImGuiTableFlags_Resizable)
        {
            if (column_settings->IsStretch)
                column->StretchWeight = column_settings->WidthOrWeight;
            else
                column->WidthRequest = column_settings->WidthOrWeight;
            column->AutoFitQueue = 0x00;
        }
        if (settings->SaveFlags & ImGuiTableFlags_Reorderable)
            column->DisplayOrder = column_settings->DisplayOrder;
        else
            column->DisplayOrder = (ImGuiTableColumnIdx)column_n;
        display_order_mask |= (ImU64)1 << column->DisplayOrder;
        column->IsUserEnabled = column->IsUserEnabledNextFrame = column_settings->IsEnabled;
        column->SortOrder = column_settings->SortOrder;
        column->SortDirection = column_settings->SortDirection;
    }

    // Validate and fix invalid display order data
    const ImU64 expected_display_order_mask = (settings->ColumnsCount == 64) ? ~0 : ((ImU64)1 << settings->ColumnsCount) - 1;
    if (display_order_mask != expected_display_order_mask)
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
            table->Columns[column_n].DisplayOrder = (ImGuiTableColumnIdx)column_n;

    // Rebuild index
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;
}

static void TableSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    ImGuiContext& g = *ctx;
    for (int i = 0; i != g.Tables.GetMapSize(); i++)
        if (ImGuiTable* table = g.Tables.TryGetMapData(i))
            table->SettingsOffset = -1;
    g.SettingsTables.clear();
}

// Apply to existing windows (if any)
static void TableSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    ImGuiContext& g = *ctx;
    for (int i = 0; i != g.Tables.GetMapSize(); i++)
        if (ImGuiTable* table = g.Tables.TryGetMapData(i))
        {
            table->IsSettingsRequestLoad = true;
            table->SettingsOffset = -1;
        }
}

static void* TableSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
{
    ImGuiID id = 0;
    int columns_count = 0;
    if (sscanf(name, "0x%08X,%d", &id, &columns_count) < 2)
        return NULL;

    if (ImGuiTableSettings* settings = ImGui::TableSettingsFindByID(id))
    {
        if (settings->ColumnsCountMax >= columns_count)
        {
            TableSettingsInit(settings, id, columns_count, settings->ColumnsCountMax); // Recycle
            return settings;
        }
        settings->ID = 0; // Invalidate storage, we won't fit because of a count change
    }
    return ImGui::TableSettingsCreate(id, columns_count);
}

static void TableSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
{
    // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
    ImGuiTableSettings* settings = (ImGuiTableSettings*)entry;
    float f = 0.0f;
    int column_n = 0, r = 0, n = 0;

    if (sscanf(line, "RefScale=%f", &f) == 1) { settings->RefScale = f; return; }

    if (sscanf(line, "Column %d%n", &column_n, &r) == 1)
    {
        if (column_n < 0 || column_n >= settings->ColumnsCount)
            return;
        line = ImStrSkipBlank(line + r);
        char c = 0;
        ImGuiTableColumnSettings* column = settings->GetColumnSettings() + column_n;
        column->Index = (ImGuiTableColumnIdx)column_n;
        if (sscanf(line, "UserID=0x%08X%n", (ImU32*)&n, &r)==1) { line = ImStrSkipBlank(line + r); column->UserID = (ImGuiID)n; }
        if (sscanf(line, "Width=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->WidthOrWeight = (float)n; column->IsStretch = 0; settings->SaveFlags |= ImGuiTableFlags_Resizable; }
        if (sscanf(line, "Weight=%f%n", &f, &r) == 1)           { line = ImStrSkipBlank(line + r); column->WidthOrWeight = f; column->IsStretch = 1; settings->SaveFlags |= ImGuiTableFlags_Resizable; }
        if (sscanf(line, "Visible=%d%n", &n, &r) == 1)          { line = ImStrSkipBlank(line + r); column->IsEnabled = (ImU8)n; settings->SaveFlags |= ImGuiTableFlags_Hideable; }
        if (sscanf(line, "Order=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->DisplayOrder = (ImGuiTableColumnIdx)n; settings->SaveFlags |= ImGuiTableFlags_Reorderable; }
        if (sscanf(line, "Sort=%d%c%n", &n, &c, &r) == 2)       { line = ImStrSkipBlank(line + r); column->SortOrder = (ImGuiTableColumnIdx)n; column->SortDirection = (c == '^') ? ImGuiSortDirection_Descending : ImGuiSortDirection_Ascending; settings->SaveFlags |= ImGuiTableFlags_Sortable; }
    }
}

static void TableSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
{
    ImGuiContext& g = *ctx;
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
    {
        if (settings->ID == 0) // Skip ditched settings
            continue;

        // TableSaveSettings() may clear some of those flags when we establish that the data can be stripped
        // (e.g. Order was unchanged)
        const bool save_size    = (settings->SaveFlags & ImGuiTableFlags_Resizable) != 0;
        const bool save_visible = (settings->SaveFlags & ImGuiTableFlags_Hideable) != 0;
        const bool save_order   = (settings->SaveFlags & ImGuiTableFlags_Reorderable) != 0;
        const bool save_sort    = (settings->SaveFlags & ImGuiTableFlags_Sortable) != 0;
        if (!save_size && !save_visible && !save_order && !save_sort)
            continue;

        buf->reserve(buf->size() + 30 + settings->ColumnsCount * 50); // ballpark reserve
        buf->appendf("[%s][0x%08X,%d]\n", handler->TypeName, settings->ID, settings->ColumnsCount);
        if (settings->RefScale != 0.0f)
            buf->appendf("RefScale=%g\n", settings->RefScale);
        ImGuiTableColumnSettings* column = settings->GetColumnSettings();
        for (int column_n = 0; column_n < settings->ColumnsCount; column_n++, column++)
        {
            // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
            bool save_column = column->UserID != 0 || save_size || save_visible || save_order || (save_sort && column->SortOrder != -1);
            if (!save_column)
                continue;
            buf->appendf("Column %-2d", column_n);
            if (column->UserID != 0)                    buf->appendf(" UserID=%08X", column->UserID);
            if (save_size && column->IsStretch)         buf->appendf(" Weight=%.4f", column->WidthOrWeight);
            if (save_size && !column->IsStretch)        buf->appendf(" Width=%d", (int)column->WidthOrWeight);
            if (save_visible)                           buf->appendf(" Visible=%d", column->IsEnabled);
            if (save_order)                             buf->appendf(" Order=%d", column->DisplayOrder);
            if (save_sort && column->SortOrder != -1)   buf->appendf(" Sort=%d%c", column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? 'v' : '^');
            buf->append("\n");
        }
        buf->append("\n");
    }
}

void ImGui::TableSettingsInstallHandler(ImGuiContext* context)
{
    ImGuiContext& g = *context;
    ImGuiSettingsHandler ini_handler;
    ini_handler.TypeName = "Table";
    ini_handler.TypeHash = ImHashStr("Table");
    ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;
    ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;
    ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;
    ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;
    ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;
    g.SettingsHandlers.push_back(ini_handler);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Garbage Collection
//-------------------------------------------------------------------------
// - TableRemove() [Internal]
// - TableGcCompactTransientBuffers() [Internal]
// - TableGcCompactSettings() [Internal]
//-------------------------------------------------------------------------

// Remove Table (currently only used by TestEngine)
void ImGui::TableRemove(ImGuiTable* table)
{
    //IMGUI_DEBUG_LOG("TableRemove() id=0x%08X\n", table->ID);
    ImGuiContext& g = *GImGui;
    int table_idx = g.Tables.GetIndex(table);
    //memset(table->RawData.Data, 0, table->RawData.size_in_bytes());
    //memset(table, 0, sizeof(ImGuiTable));
    g.Tables.Remove(table->ID, table);
    g.TablesLastTimeActive[table_idx] = -1.0f;
}

// Free up/compact internal Table buffers for when it gets unused
void ImGui::TableGcCompactTransientBuffers(ImGuiTable* table)
{
    //IMGUI_DEBUG_LOG("TableGcCompactTransientBuffers() id=0x%08X\n", table->ID);
    ImGuiContext& g = *GImGui;
    IM_ASSERT(table->MemoryCompacted == false);
    table->SortSpecs.Specs = NULL;
    table->SortSpecsMulti.clear();
    table->IsSortSpecsDirty = true; // FIXME: shouldn't have to leak into user performing a sort
    table->ColumnsNames.clear();
    table->MemoryCompacted = true;
    for (int n = 0; n < table->ColumnsCount; n++)
        table->Columns[n].NameOffset = -1;
    g.TablesLastTimeActive[g.Tables.GetIndex(table)] = -1.0f;
}

void ImGui::TableGcCompactTransientBuffers(ImGuiTableTempData* temp_data)
{
    temp_data->DrawSplitter.ClearFreeMemory();
    temp_data->LastTimeActive = -1.0f;
}

// Compact and remove unused settings data (currently only used by TestEngine)
void ImGui::TableGcCompactSettings()
{
    ImGuiContext& g = *GImGui;
    int required_memory = 0;
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
        if (settings->ID != 0)
            required_memory += (int)TableSettingsCalcChunkSize(settings->ColumnsCount);
    if (required_memory == g.SettingsTables.Buf.Size)
        return;
    ImChunkStream<ImGuiTableSettings> new_chunk_stream;
    new_chunk_stream.Buf.reserve(required_memory);
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
        if (settings->ID != 0)
            memcpy(new_chunk_stream.alloc_chunk(TableSettingsCalcChunkSize(settings->ColumnsCount)), settings, TableSettingsCalcChunkSize(settings->ColumnsCount));
    g.SettingsTables.swap(new_chunk_stream);
}


//-------------------------------------------------------------------------
// [SECTION] Tables: Debugging
//-------------------------------------------------------------------------
// - DebugNodeTable() [Internal]
//-------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_METRICS_WINDOW

static const char* DebugNodeTableGetSizingPolicyDesc(ImGuiTableFlags sizing_policy)
{
    sizing_policy &= ImGuiTableFlags_SizingMask_;
    if (sizing_policy == ImGuiTableFlags_SizingFixedFit)    { return "FixedFit"; }
    if (sizing_policy == ImGuiTableFlags_SizingFixedSame)   { return "FixedSame"; }
    if (sizing_policy == ImGuiTableFlags_SizingStretchProp) { return "StretchProp"; }
    if (sizing_policy == ImGuiTableFlags_SizingStretchSame) { return "StretchSame"; }
    return "N/A";
}

void ImGui::DebugNodeTable(ImGuiTable* table)
{
    char buf[512];
    char* p = buf;
    const char* buf_end = buf + IM_ARRAYSIZE(buf);
    const bool is_active = (table->LastFrameActive >= ImGui::GetFrameCount() - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.
    ImFormatString(p, buf_end - p, "Table 0x%08X (%d columns, in '%s')%s", table->ID, table->ColumnsCount, table->OuterWindow->Name, is_active ? "" : " *Inactive*");
    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
    bool open = TreeNode(table, "%s", buf);
    if (!is_active) { PopStyleColor(); }
    if (IsItemHovered())
        GetForegroundDrawList()->AddRect(table->OuterRect.Min, table->OuterRect.Max, IM_COL32(255, 255, 0, 255));
    if (IsItemVisible() && table->HoveredColumnBody != -1)
        GetForegroundDrawList()->AddRect(GetItemRectMin(), GetItemRectMax(), IM_COL32(255, 255, 0, 255));
    if (!open)
        return;
    bool clear_settings = SmallButton("Clear settings");
    BulletText("OuterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: '%s'", table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.GetWidth(), table->OuterRect.GetHeight(), DebugNodeTableGetSizingPolicyDesc(table->Flags));
    BulletText("ColumnsGivenWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%s", table->ColumnsGivenWidth, table->ColumnsAutoFitWidth, table->InnerWidth, table->InnerWidth == 0.0f ? " (auto)" : "");
    BulletText("CellPaddingX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f", table->CellPaddingX, table->CellSpacingX1, table->CellSpacingX2, table->OuterPaddingX);
    BulletText("HoveredColumnBody: %d, HoveredColumnBorder: %d", table->HoveredColumnBody, table->HoveredColumnBorder);
    BulletText("ResizedColumn: %d, ReorderColumn: %d, HeldHeaderColumn: %d", table->ResizedColumn, table->ReorderColumn, table->HeldHeaderColumn);
    //BulletText("BgDrawChannels: %d/%d", 0, table->BgDrawChannelUnfrozen);
    float sum_weights = 0.0f;
    for (int n = 0; n < table->ColumnsCount; n++)
        if (table->Columns[n].Flags & ImGuiTableColumnFlags_WidthStretch)
            sum_weights += table->Columns[n].StretchWeight;
    for (int n = 0; n < table->ColumnsCount; n++)
    {
        ImGuiTableColumn* column = &table->Columns[n];
        const char* name = TableGetColumnName(table, n);
        ImFormatString(buf, IM_ARRAYSIZE(buf),
            "Column %d order %d '%s': offset %+.2f to %+.2f%s\n"
            "Enabled: %d, VisibleX/Y: %d/%d, RequestOutput: %d, SkipItems: %d, DrawChannels: %d,%d\n"
            "WidthGiven: %.1f, Request/Auto: %.1f/%.1f, StretchWeight: %.3f (%.1f%%)\n"
            "MinX: %.1f, MaxX: %.1f (%+.1f), ClipRect: %.1f to %.1f (+%.1f)\n"
            "ContentWidth: %.1f,%.1f, HeadersUsed/Ideal %.1f/%.1f\n"
            "Sort: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..",
            n, column->DisplayOrder, name, column->MinX - table->WorkRect.Min.x, column->MaxX - table->WorkRect.Min.x, (n < table->FreezeColumnsRequest) ? " (Frozen)" : "",
            column->IsEnabled, column->IsVisibleX, column->IsVisibleY, column->IsRequestOutput, column->IsSkipItems, column->DrawChannelFrozen, column->DrawChannelUnfrozen,
            column->WidthGiven, column->WidthRequest, column->WidthAuto, column->StretchWeight, column->StretchWeight > 0.0f ? (column->StretchWeight / sum_weights) * 100.0f : 0.0f,
            column->MinX, column->MaxX, column->MaxX - column->MinX, column->ClipRect.Min.x, column->ClipRect.Max.x, column->ClipRect.Max.x - column->ClipRect.Min.x,
            column->ContentMaxXFrozen - column->WorkMinX, column->ContentMaxXUnfrozen - column->WorkMinX, column->ContentMaxXHeadersUsed - column->WorkMinX, column->ContentMaxXHeadersIdeal - column->WorkMinX,
            column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? " (Asc)" : (column->SortDirection == ImGuiSortDirection_Descending) ? " (Des)" : "", column->UserID, column->Flags,
            (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? "WidthStretch " : "",
            (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? "WidthFixed " : "",
            (column->Flags & ImGuiTableColumnFlags_NoResize) ? "NoResize " : "");
        Bullet();
        Selectable(buf);
        if (IsItemHovered())
        {
            ImRect r(column->MinX, table->OuterRect.Min.y, column->MaxX, table->OuterRect.Max.y);
            GetForegroundDrawList()->AddRect(r.Min, r.Max, IM_COL32(255, 255, 0, 255));
        }
    }
    if (ImGuiTableSettings* settings = TableGetBoundSettings(table))
        DebugNodeTableSettings(settings);
    if (clear_settings)
        table->IsResetAllRequest = true;
    TreePop();
}

void ImGui::DebugNodeTableSettings(ImGuiTableSettings* settings)
{
    if (!TreeNode((void*)(intptr_t)settings->ID, "Settings 0x%08X (%d columns)", settings->ID, settings->ColumnsCount))
        return;
    BulletText("SaveFlags: 0x%08X", settings->SaveFlags);
    BulletText("ColumnsCount: %d (max %d)", settings->ColumnsCount, settings->ColumnsCountMax);
    for (int n = 0; n < settings->ColumnsCount; n++)
    {
        ImGuiTableColumnSettings* column_settings = &settings->GetColumnSettings()[n];
        ImGuiSortDirection sort_dir = (column_settings->SortOrder != -1) ? (ImGuiSortDirection)column_settings->SortDirection : ImGuiSortDirection_None;
        BulletText("Column %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%08X",
            n, column_settings->DisplayOrder, column_settings->SortOrder,
            (sort_dir == ImGuiSortDirection_Ascending) ? "Asc" : (sort_dir == ImGuiSortDirection_Descending) ? "Des" : "---",
            column_settings->IsEnabled, column_settings->IsStretch ? "Weight" : "Width ", column_settings->WidthOrWeight, column_settings->UserID);
    }
    TreePop();
}

#else // #ifndef IMGUI_DISABLE_METRICS_WINDOW

void ImGui::DebugNodeTable(ImGuiTable*) {}
void ImGui::DebugNodeTableSettings(ImGuiTableSettings*) {}

#endif


//-------------------------------------------------------------------------
// [SECTION] Columns, BeginColumns, EndColumns, etc.
// (This is a legacy API, prefer using BeginTable/EndTable!)
//-------------------------------------------------------------------------
// FIXME: sizing is lossy when columns width is very small (default width may turn negative etc.)
//-------------------------------------------------------------------------
// - SetWindowClipRectBeforeSetChannel() [Internal]
// - GetColumnIndex()
// - GetColumnsCount()
// - GetColumnOffset()
// - GetColumnWidth()
// - SetColumnOffset()
// - SetColumnWidth()
// - PushColumnClipRect() [Internal]
// - PushColumnsBackground() [Internal]
// - PopColumnsBackground() [Internal]
// - FindOrCreateColumns() [Internal]
// - GetColumnsID() [Internal]
// - BeginColumns()
// - NextColumn()
// - EndColumns()
// - Columns()
//-------------------------------------------------------------------------

// [Internal] Small optimization to avoid calls to PopClipRect/SetCurrentChannel/PushClipRect in sequences,
// they would meddle many times with the underlying ImDrawCmd.
// Instead, we do a preemptive overwrite of clipping rectangle _without_ altering the command-buffer and let
// the subsequent single call to SetCurrentChannel() does it things once.
void ImGui::SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, const ImRect& clip_rect)
{
    ImVec4 clip_rect_vec4 = clip_rect.ToVec4();
    window->ClipRect = clip_rect;
    window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;
    window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;
}

int ImGui::GetColumnIndex()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;
}

int ImGui::GetColumnsCount()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;
}

float ImGui::GetColumnOffsetFromNorm(const ImGuiOldColumns* columns, float offset_norm)
{
    return offset_norm * (columns->OffMaxX - columns->OffMinX);
}

float ImGui::GetColumnNormFromOffset(const ImGuiOldColumns* columns, float offset)
{
    return offset / (columns->OffMaxX - columns->OffMinX);
}

static const float COLUMNS_HIT_RECT_HALF_WIDTH = 4.0f;

static float GetDraggedColumnOffset(ImGuiOldColumns* columns, int column_index)
{
    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));

    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;
    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
    if ((columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths))
        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

    return x;
}

float ImGui::GetColumnOffset(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns == NULL)
        return 0.0f;

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const float t = columns->Columns[column_index].OffsetNorm;
    const float x_offset = ImLerp(columns->OffMinX, columns->OffMaxX, t);
    return x_offset;
}

static float GetColumnWidthEx(ImGuiOldColumns* columns, int column_index, bool before_resize = false)
{
    if (column_index < 0)
        column_index = columns->Current;

    float offset_norm;
    if (before_resize)
        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;
    else
        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;
    return ImGui::GetColumnOffsetFromNorm(columns, offset_norm);
}

float ImGui::GetColumnWidth(int column_index)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns == NULL)
        return GetContentRegionAvail().x;

    if (column_index < 0)
        column_index = columns->Current;
    return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);
}

void ImGui::SetColumnOffset(int column_index, float offset)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const bool preserve_width = !(columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths) && (column_index < columns->Count - 1);
    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

    if (!(columns->Flags & ImGuiOldColumnFlags_NoForceWithinWindow))
        offset = ImMin(offset, columns->OffMaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));
    columns->Columns[column_index].OffsetNorm = GetColumnNormFromOffset(columns, offset - columns->OffMinX);

    if (preserve_width)
        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));
}

void ImGui::SetColumnWidth(int column_index, float width)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
}

void ImGui::PushColumnClipRect(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (column_index < 0)
        column_index = columns->Current;

    ImGuiOldColumnData* column = &columns->Columns[column_index];
    PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);
}

// Get into the columns background draw command (which is generally the same draw command as before we called BeginColumns)
void ImGui::PushColumnsBackground()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns->Count == 1)
        return;

    // Optimization: avoid SetCurrentChannel() + PushClipRect()
    columns->HostBackupClipRect = window->ClipRect;
    SetWindowClipRectBeforeSetChannel(window, columns->HostInitialClipRect);
    columns->Splitter.SetCurrentChannel(window->DrawList, 0);
}

void ImGui::PopColumnsBackground()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns->Count == 1)
        return;

    // Optimization: avoid PopClipRect() + SetCurrentChannel()
    SetWindowClipRectBeforeSetChannel(window, columns->HostBackupClipRect);
    columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);
}

ImGuiOldColumns* ImGui::FindOrCreateColumns(ImGuiWindow* window, ImGuiID id)
{
    // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
    for (int n = 0; n < window->ColumnsStorage.Size; n++)
        if (window->ColumnsStorage[n].ID == id)
            return &window->ColumnsStorage[n];

    window->ColumnsStorage.push_back(ImGuiOldColumns());
    ImGuiOldColumns* columns = &window->ColumnsStorage.back();
    columns->ID = id;
    return columns;
}

ImGuiID ImGui::GetColumnsID(const char* str_id, int columns_count)
{
    ImGuiWindow* window = GetCurrentWindow();

    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
    PushID(0x11223347 + (str_id ? 0 : columns_count));
    ImGuiID id = window->GetID(str_id ? str_id : "columns");
    PopID();

    return id;
}

void ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiOldColumnFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    IM_ASSERT(columns_count >= 1);
    IM_ASSERT(window->DC.CurrentColumns == NULL);   // Nested columns are currently not supported

    // Acquire storage for the columns set
    ImGuiID id = GetColumnsID(str_id, columns_count);
    ImGuiOldColumns* columns = FindOrCreateColumns(window, id);
    IM_ASSERT(columns->ID == id);
    columns->Current = 0;
    columns->Count = columns_count;
    columns->Flags = flags;
    window->DC.CurrentColumns = columns;

    columns->HostCursorPosY = window->DC.CursorPos.y;
    columns->HostCursorMaxPosX = window->DC.CursorMaxPos.x;
    columns->HostInitialClipRect = window->ClipRect;
    columns->HostBackupParentWorkRect = window->ParentWorkRect;
    window->ParentWorkRect = window->WorkRect;

    // Set state for first column
    // We aim so that the right-most column will have the same clipping width as other after being clipped by parent ClipRect
    const float column_padding = g.Style.ItemSpacing.x;
    const float half_clip_extend_x = ImFloor(ImMax(window->WindowPadding.x * 0.5f, window->WindowBorderSize));
    const float max_1 = window->WorkRect.Max.x + column_padding - ImMax(column_padding - window->WindowPadding.x, 0.0f);
    const float max_2 = window->WorkRect.Max.x + half_clip_extend_x;
    columns->OffMinX = window->DC.Indent.x - column_padding + ImMax(column_padding - window->WindowPadding.x, 0.0f);
    columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);
    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;

    // Clear data if columns count changed
    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
        columns->Columns.resize(0);

    // Initialize default widths
    columns->IsFirstFrame = (columns->Columns.Size == 0);
    if (columns->Columns.Size == 0)
    {
        columns->Columns.reserve(columns_count + 1);
        for (int n = 0; n < columns_count + 1; n++)
        {
            ImGuiOldColumnData column;
            column.OffsetNorm = n / (float)columns_count;
            columns->Columns.push_back(column);
        }
    }

    for (int n = 0; n < columns_count; n++)
    {
        // Compute clipping rectangle
        ImGuiOldColumnData* column = &columns->Columns[n];
        float clip_x1 = IM_ROUND(window->Pos.x + GetColumnOffset(n));
        float clip_x2 = IM_ROUND(window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
        column->ClipRect.ClipWithFull(window->ClipRect);
    }

    if (columns->Count > 1)
    {
        columns->Splitter.Split(window->DrawList, 1 + columns->Count);
        columns->Splitter.SetCurrentChannel(window->DrawList, 1);
        PushColumnClipRect(0);
    }

    // We don't generally store Indent.x inside ColumnsOffset because it may be manipulated by the user.
    float offset_0 = GetColumnOffset(columns->Current);
    float offset_1 = GetColumnOffset(columns->Current + 1);
    float width = offset_1 - offset_0;
    PushItemWidth(width * 0.65f);
    window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);
    window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
}

void ImGui::NextColumn()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems || window->DC.CurrentColumns == NULL)
        return;

    ImGuiContext& g = *GImGui;
    ImGuiOldColumns* columns = window->DC.CurrentColumns;

    if (columns->Count == 1)
    {
        window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
        IM_ASSERT(columns->Current == 0);
        return;
    }

    // Next column
    if (++columns->Current == columns->Count)
        columns->Current = 0;

    PopItemWidth();

    // Optimization: avoid PopClipRect() + SetCurrentChannel() + PushClipRect()
    // (which would needlessly attempt to update commands in the wrong channel, then pop or overwrite them),
    ImGuiOldColumnData* column = &columns->Columns[columns->Current];
    SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
    columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);

    const float column_padding = g.Style.ItemSpacing.x;
    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    if (columns->Current > 0)
    {
        // Columns 1+ ignore IndentX (by canceling it out)
        // FIXME-COLUMNS: Unnecessary, could be locked?
        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + column_padding;
    }
    else
    {
        // New row/line: column 0 honor IndentX.
        window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);
        columns->LineMinY = columns->LineMaxY;
    }
    window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->DC.CursorPos.y = columns->LineMinY;
    window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
    window->DC.CurrLineTextBaseOffset = 0.0f;

    // FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.
    float offset_0 = GetColumnOffset(columns->Current);
    float offset_1 = GetColumnOffset(columns->Current + 1);
    float width = offset_1 - offset_0;
    PushItemWidth(width * 0.65f);
    window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
}

void ImGui::EndColumns()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    PopItemWidth();
    if (columns->Count > 1)
    {
        PopClipRect();
        columns->Splitter.Merge(window->DrawList);
    }

    const ImGuiOldColumnFlags flags = columns->Flags;
    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    window->DC.CursorPos.y = columns->LineMaxY;
    if (!(flags & ImGuiOldColumnFlags_GrowParentContentsSize))
        window->DC.CursorMaxPos.x = columns->HostCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent

    // Draw columns borders and handle resize
    // The IsBeingResized flag ensure we preserve pre-resize columns width so back-and-forth are not lossy
    bool is_being_resized = false;
    if (!(flags & ImGuiOldColumnFlags_NoBorder) && !window->SkipItems)
    {
        // We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
        const float y1 = ImMax(columns->HostCursorPosY, window->ClipRect.Min.y);
        const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);
        int dragging_column = -1;
        for (int n = 1; n < columns->Count; n++)
        {
            ImGuiOldColumnData* column = &columns->Columns[n];
            float x = window->Pos.x + GetColumnOffset(n);
            const ImGuiID column_id = columns->ID + ImGuiID(n);
            const float column_hit_hw = COLUMNS_HIT_RECT_HALF_WIDTH;
            const ImRect column_hit_rect(ImVec2(x - column_hit_hw, y1), ImVec2(x + column_hit_hw, y2));
            KeepAliveID(column_id);
            if (IsClippedEx(column_hit_rect, column_id, false))
                continue;

            bool hovered = false, held = false;
            if (!(flags & ImGuiOldColumnFlags_NoResize))
            {
                ButtonBehavior(column_hit_rect, column_id, &hovered, &held);
                if (hovered || held)
                    g.MouseCursor = ImGuiMouseCursor_ResizeEW;
                if (held && !(column->Flags & ImGuiOldColumnFlags_NoResize))
                    dragging_column = n;
            }

            // Draw column
            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
            const float xi = IM_FLOOR(x);
            window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);
        }

        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
        if (dragging_column != -1)
        {
            if (!columns->IsBeingResized)
                for (int n = 0; n < columns->Count + 1; n++)
                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;
            columns->IsBeingResized = is_being_resized = true;
            float x = GetDraggedColumnOffset(columns, dragging_column);
            SetColumnOffset(dragging_column, x);
        }
    }
    columns->IsBeingResized = is_being_resized;

    window->WorkRect = window->ParentWorkRect;
    window->ParentWorkRect = columns->HostBackupParentWorkRect;
    window->DC.CurrentColumns = NULL;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
}

void ImGui::Columns(int columns_count, const char* id, bool border)
{
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(columns_count >= 1);

    ImGuiOldColumnFlags flags = (border ? 0 : ImGuiOldColumnFlags_NoBorder);
    //flags |= ImGuiOldColumnFlags_NoPreserveWidths; // NB: Legacy behavior
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)
        return;

    if (columns != NULL)
        EndColumns();

    if (columns_count != 1)
        BeginColumns(id, columns_count, flags);
}

//-------------------------------------------------------------------------

#endif // #ifndef IMGUI_DISABLE

```

`Private Esp/imgui/imgui_widgets.cpp`:

```cpp
// dear imgui, v1.67 WIP
// (widgets code)

/*

Index of this file:

// [SECTION] Forward Declarations
// [SECTION] Widgets: Text, etc.
// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)
// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)
// [SECTION] Widgets: ComboBox
// [SECTION] Data Type and Data Formatting Helpers
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
// [SECTION] Widgets: InputText, InputTextMultiline
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
// [SECTION] Widgets: Selectable
// [SECTION] Widgets: ListBox
// [SECTION] Widgets: PlotLines, PlotHistogram
// [SECTION] Widgets: Value helpers
// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

#include <ctype.h>      // toupper, isprint
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127) // condition expression is constant
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif
#endif

//-------------------------------------------------------------------------
// Data
//-------------------------------------------------------------------------

// Those MIN/MAX values are not define because we need to point to them
static const ImS32  IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);
static const ImS32  IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)
static const ImU32  IM_U32_MIN = 0;
static const ImU32  IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)
#ifdef LLONG_MIN
static const ImS64  IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll);
static const ImS64  IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);
#else
static const ImS64  IM_S64_MIN = -9223372036854775807LL - 1;
static const ImS64  IM_S64_MAX = 9223372036854775807LL;
#endif
static const ImU64  IM_U64_MIN = 0;
#ifdef ULLONG_MAX
static const ImU64  IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);
#else
static const ImU64  IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);
#endif

//-------------------------------------------------------------------------
// [SECTION] Forward Declarations
//-------------------------------------------------------------------------

// Data Type helpers
static inline int       DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format);
static void             DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg_1, const void* arg_2);
static bool             DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format);

// For InputTextEx()
static bool             InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data);
static int              InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);
static ImVec2           InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);

//-------------------------------------------------------------------------
// [SECTION] Widgets: Text, etc.
//-------------------------------------------------------------------------
// - TextUnformatted()
// - Text()
// - TextV()
// - TextColored()
// - TextColoredV()
// - TextDisabled()
// - TextDisabledV()
// - TextWrapped()
// - TextWrappedV()
// - LabelText()
// - LabelTextV()
// - BulletText()
// - BulletTextV()
//-------------------------------------------------------------------------

void ImGui::TextUnformatted(const char* text, const char* text_end)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    IM_ASSERT(text != NULL);
    const char* text_begin = text;
    if (text_end == NULL)
        text_end = text + strlen(text); // FIXME-OPT

    const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);
    const float wrap_pos_x = window->DC.TextWrapPos;
    const bool wrap_enabled = wrap_pos_x >= 0.0f;
    if (text_end - text > 2000 && !wrap_enabled)
    {
        // Long text!
        // Perform manual coarse clipping to optimize for long multi-line text
        // - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
        // - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
        // - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
        const char* line = text;
        const float line_height = GetTextLineHeight();
        const ImRect clip_rect = window->ClipRect;
        ImVec2 text_size(0,0);

        if (text_pos.y <= clip_rect.Max.y)
        {
            ImVec2 pos = text_pos;

            // Lines to skip (can't skip when logging text)
            if (!g.LogEnabled)
            {
                int lines_skippable = (int)((clip_rect.Min.y - text_pos.y) / line_height);
                if (lines_skippable > 0)
                {
                    int lines_skipped = 0;
                    while (line < text_end && lines_skipped < lines_skippable)
                    {
                        const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                        if (!line_end)
                            line_end = text_end;
                        line = line_end + 1;
                        lines_skipped++;
                    }
                    pos.y += lines_skipped * line_height;
                }
            }

            // Lines to render
            if (line < text_end)
            {
                ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));
                while (line < text_end)
                {
                    if (IsClippedEx(line_rect, 0, false))
                        break;

                    const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                    if (!line_end)
                        line_end = text_end;
                    const ImVec2 line_size = CalcTextSize(line, line_end, false);
                    text_size.x = ImMax(text_size.x, line_size.x);
                    RenderText(pos, line, line_end, false);
                    line = line_end + 1;
                    line_rect.Min.y += line_height;
                    line_rect.Max.y += line_height;
                    pos.y += line_height;
                }

                // Count remaining lines
                int lines_skipped = 0;
                while (line < text_end)
                {
                    const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                    if (!line_end)
                        line_end = text_end;
                    line = line_end + 1;
                    lines_skipped++;
                }
                pos.y += lines_skipped * line_height;
            }

            text_size.y += (pos - text_pos).y;
        }

        ImRect bb(text_pos, text_pos + text_size);
        ItemSize(bb);
        ItemAdd(bb, 0);
    }
    else
    {
        const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;
        const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);

        // Account of baseline offset
        ImRect bb(text_pos, text_pos + text_size);
        ItemSize(text_size);
        if (!ItemAdd(bb, 0))
            return;

        // Render (we don't hide text after ## in this end-user function)
        RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);
    }
}

void ImGui::Text(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextV(fmt, args);
    va_end(args);
}

void ImGui::TextV(const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    TextUnformatted(g.TempBuffer, text_end);
}

void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextColoredV(col, fmt, args);
    va_end(args);
}

void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)
{
    PushStyleColor(ImGuiCol_Text, col);
    TextV(fmt, args);
    PopStyleColor();
}

void ImGui::TextDisabled(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextDisabledV(fmt, args);
    va_end(args);
}

void ImGui::TextDisabledV(const char* fmt, va_list args)
{
    PushStyleColor(ImGuiCol_Text, GImGui->Style.Colors[ImGuiCol_TextDisabled]);
    TextV(fmt, args);
    PopStyleColor();
}

void ImGui::TextWrapped(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextWrappedV(fmt, args);
    va_end(args);
}

void ImGui::TextWrappedV(const char* fmt, va_list args)
{
    bool need_wrap = (GImGui->CurrentWindow->DC.TextWrapPos < 0.0f);    // Keep existing wrap position is one ia already set
    if (need_wrap) PushTextWrapPos(0.0f);
    TextV(fmt, args);
    if (need_wrap) PopTextWrapPos();
}

void ImGui::LabelText(const char* label, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    LabelTextV(label, fmt, args);
    va_end(args);
}

// Add a label+text combo aligned to other label+value widgets
void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float w = CalcItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));
    const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, 0))
        return;

    // Render
    const char* value_text_begin = &g.TempBuffer[0];
    const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f,0.5f));
    if (label_size.x > 0.0f)
        RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);
}

void ImGui::BulletText(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    BulletTextV(fmt, args);
    va_end(args);
}

// Text with a little bullet aligned to the typical tree node.
void ImGui::BulletTextV(const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    const char* text_begin = g.TempBuffer;
    const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);
    const float text_base_offset_y = ImMax(0.0f, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x*2) : 0.0f), ImMax(line_height, label_size.y)));  // Empty text doesn't add padding
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
        return;

    // Render
    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));
    RenderText(bb.Min+ImVec2(g.FontSize + style.FramePadding.x*2, text_base_offset_y), text_begin, text_end, false);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Main
//-------------------------------------------------------------------------
// - ButtonBehavior() [Internal]
// - Button()
// - SmallButton()
// - InvisibleButton()
// - ArrowButton()
// - CloseButton() [Internal]
// - CollapseButton() [Internal]
// - Scrollbar() [Internal]
// - Image()
// - ImageButton()
// - Checkbox()
// - CheckboxFlags()
// - RadioButton()
// - ProgressBar()
// - Bullet()
//-------------------------------------------------------------------------

bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    if (flags & ImGuiButtonFlags_Disabled)
    {
        if (out_hovered) *out_hovered = false;
        if (out_held) *out_held = false;
        if (g.ActiveId == id) ClearActiveID();
        return false;
    }

    // Default behavior requires click+release on same spot
    if ((flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick)) == 0)
        flags |= ImGuiButtonFlags_PressedOnClickRelease;

    ImGuiWindow* backup_hovered_window = g.HoveredWindow;
    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)
        g.HoveredWindow = window;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    if (window->DC.LastItemId != id)
        ImGuiTestEngineHook_ItemAdd(bb, id);
#endif

    bool pressed = false;
    bool hovered = ItemHoverable(bb, id);

    // Drag source doesn't report as hovered
    if (hovered && g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))
        hovered = false;

    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        {
            hovered = true;
            SetHoveredID(id);
            if (CalcTypematicPressedRepeatAmount(g.HoveredIdTimer + 0.0001f, g.HoveredIdTimer + 0.0001f - g.IO.DeltaTime, 0.01f, 0.70f)) // FIXME: Our formula for CalcTypematicPressedRepeatAmount() is fishy
            {
                pressed = true;
                FocusWindow(window);
            }
        }

    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)
        g.HoveredWindow = backup_hovered_window;

    // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
    if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))
        hovered = false;

    // Mouse
    if (hovered)
    {
        if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))
        {
            //                        | CLICKING        | HOLDING with ImGuiButtonFlags_Repeat
            // PressedOnClickRelease  |  <on release>*  |  <on repeat> <on repeat> .. (NOT on release)  <-- MOST COMMON! (*) only if both click/release were over bounds
            // PressedOnClick         |  <on click>     |  <on click> <on repeat> <on repeat> ..
            // PressedOnRelease       |  <on release>   |  <on repeat> <on repeat> .. (NOT on release)
            // PressedOnDoubleClick   |  <on dclick>    |  <on dclick> <on repeat> <on repeat> ..
            // FIXME-NAV: We don't honor those different behaviors.
            if ((flags & ImGuiButtonFlags_PressedOnClickRelease) && g.IO.MouseClicked[0])
            {
                SetActiveID(id, window);
                if (!(flags & ImGuiButtonFlags_NoNavFocus))
                    SetFocusID(id, window);
                FocusWindow(window);
            }
            if (((flags & ImGuiButtonFlags_PressedOnClick) && g.IO.MouseClicked[0]) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))
            {
                pressed = true;
                if (flags & ImGuiButtonFlags_NoHoldingActiveID)
                    ClearActiveID();
                else
                    SetActiveID(id, window); // Hold on ID
                FocusWindow(window);
            }
            if ((flags & ImGuiButtonFlags_PressedOnRelease) && g.IO.MouseReleased[0])
            {
                if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>
                    pressed = true;
                ClearActiveID();
            }

            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
            if ((flags & ImGuiButtonFlags_Repeat) && g.ActiveId == id && g.IO.MouseDownDuration[0] > 0.0f && IsMouseClicked(0, true))
                pressed = true;
        }

        if (pressed)
            g.NavDisableHighlight = true;
    }

    // Gamepad/Keyboard navigation
    // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
    if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))
        hovered = true;

    if (g.NavActivateDownId == id)
    {
        bool nav_activated_by_code = (g.NavActivateId == id);
        bool nav_activated_by_inputs = IsNavInputPressed(ImGuiNavInput_Activate, (flags & ImGuiButtonFlags_Repeat) ? ImGuiInputReadMode_Repeat : ImGuiInputReadMode_Pressed);
        if (nav_activated_by_code || nav_activated_by_inputs)
            pressed = true;
        if (nav_activated_by_code || nav_activated_by_inputs || g.ActiveId == id)
        {
            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
            g.NavActivateId = id; // This is so SetActiveId assign a Nav source
            SetActiveID(id, window);
            if (!(flags & ImGuiButtonFlags_NoNavFocus))
                SetFocusID(id, window);
            g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right) | (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
        }
    }

    bool held = false;
    if (g.ActiveId == id)
    {
        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
        {
            if (g.ActiveIdIsJustActivated)
                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;
            if (g.IO.MouseDown[0])
            {
                held = true;
            }
            else
            {
                if (hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease))
                    if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>
                        if (!g.DragDropActive)
                            pressed = true;
                ClearActiveID();
            }
            if (!(flags & ImGuiButtonFlags_NoNavFocus))
                g.NavDisableHighlight = true;
        }
        else if (g.ActiveIdSource == ImGuiInputSource_Nav)
        {
            if (g.NavActivateDownId != id)
                ClearActiveID();
        }
    }

    if (out_hovered) *out_hovered = hovered;
    if (out_held) *out_held = held;

    return pressed;
}

bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    ImVec2 pos = window->DC.CursorPos;
    if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrentLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
        pos.y += window->DC.CurrentLineTextBaseOffset - style.FramePadding.y;
    ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

    const ImRect bb(pos, pos + size);
    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(bb, id))
        return false;

    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)
        flags |= ImGuiButtonFlags_Repeat;
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);
    if (pressed)
        MarkItemEdited(id);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);
    RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

    // Automatically close popups
    //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
    //    CloseCurrentPopup();

    return pressed;
}

bool ImGui::Button(const char* label, const ImVec2& size_arg)
{
    return ButtonEx(label, size_arg, 0);
}

// Small buttons fits within text without additional vertical spacing.
bool ImGui::SmallButton(const char* label)
{
    ImGuiContext& g = *GImGui;
    float backup_padding_y = g.Style.FramePadding.y;
    g.Style.FramePadding.y = 0.0f;
    bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);
    g.Style.FramePadding.y = backup_padding_y;
    return pressed;
}

// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.
// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)
bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
    IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);

    const ImGuiID id = window->GetID(str_id);
    ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(bb);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    return pressed;
}

bool ImGui::ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiID id = window->GetID(str_id);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const float default_size = GetFrameHeight();
    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
    if (!ItemAdd(bb, id))
        return false;

    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)
        flags |= ImGuiButtonFlags_Repeat;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, g.Style.FrameRounding);
    RenderArrow(bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), dir);

    return pressed;
}

bool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)
{
    float sz = GetFrameHeight();
    return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), 0);
}

// Button to close a window
bool ImGui::CloseButton(ImGuiID id, const ImVec2& pos, float radius)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // We intentionally allow interaction when clipped so that a mechanical Alt,Right,Validate sequence close a window.
    // (this isn't the regular behavior of buttons, but it doesn't affect the user much because navigation tends to keep items visible).
    const ImRect bb(pos - ImVec2(radius,radius), pos + ImVec2(radius,radius));
    bool is_clipped = !ItemAdd(bb, id);

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);
    if (is_clipped)
        return pressed;

    // Render
    ImVec2 center = bb.GetCenter();
    if (hovered)
        window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered), 9);

    float cross_extent = (radius * 0.7071f) - 1.0f;
    ImU32 cross_col = GetColorU32(ImGuiCol_Text);
    center -= ImVec2(0.5f, 0.5f);
    window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), cross_col, 1.0f);
    window->DrawList->AddLine(center + ImVec2(+cross_extent,-cross_extent), center + ImVec2(-cross_extent,+cross_extent), cross_col, 1.0f);

    return pressed;
}

bool ImGui::CollapseButton(ImGuiID id, const ImVec2& pos)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);
    ItemAdd(bb, id);
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);

    ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    if (hovered || held)
        window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0.0f, -0.5f), g.FontSize * 0.5f + 1.0f, col, 9);
    RenderArrow(bb.Min + g.Style.FramePadding, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);

    // Switch to moving the window after mouse is moved beyond the initial drag threshold
    if (IsItemActive() && IsMouseDragging())
        LoopCallbackMouseMovingWindow(window);

    return pressed;
}

// Vertical/Horizontal scrollbar
// The entire piece of code below is rather confusing because:
// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)
// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar
// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.
void ImGui::Scrollbar(ImGuiLayoutType direction)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const bool horizontal = (direction == ImGuiLayoutType_Horizontal);
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(horizontal ? "#SCROLLX" : "#SCROLLY");

    // Render background
    bool other_scrollbar = (horizontal ? window->ScrollbarY : window->ScrollbarX);
    float other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0.0f;
    const ImRect window_rect = window->Rect();
    const float border_size = window->WindowBorderSize;
    ImRect bb = horizontal
        ? ImRect(window->Pos.x + border_size, window_rect.Max.y - style.ScrollbarSize, window_rect.Max.x - other_scrollbar_size_w - border_size, window_rect.Max.y - border_size)
        : ImRect(window_rect.Max.x - style.ScrollbarSize, window->Pos.y + border_size, window_rect.Max.x - border_size, window_rect.Max.y - other_scrollbar_size_w - border_size);
    if (!horizontal)
        bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f);
    if (bb.GetWidth() <= 0.0f || bb.GetHeight() <= 0.0f)
        return;

    int window_rounding_corners;
    if (horizontal)
        window_rounding_corners = ImDrawCornerFlags_BotLeft | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);
    else
        window_rounding_corners = (((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar)) ? ImDrawCornerFlags_TopRight : 0) | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);
    window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_ScrollbarBg), window->WindowRounding, window_rounding_corners);
    bb.Expand(ImVec2(-ImClamp((float)(int)((bb.Max.x - bb.Min.x - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb.Max.y - bb.Min.y - 2.0f) * 0.5f), 0.0f, 3.0f)));

    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
    float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();
    float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;
    float win_size_avail_v = (horizontal ? window->SizeFull.x : window->SizeFull.y) - other_scrollbar_size_w;
    float win_size_contents_v = horizontal ? window->SizeContents.x : window->SizeContents.y;

    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
    // But we maintain a minimum size in pixel to allow for the user to still aim inside.
    IM_ASSERT(ImMax(win_size_contents_v, win_size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
    const float win_size_v = ImMax(ImMax(win_size_contents_v, win_size_avail_v), 1.0f);
    const float grab_h_pixels = ImClamp(scrollbar_size_v * (win_size_avail_v / win_size_v), style.GrabMinSize, scrollbar_size_v);
    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
    bool held = false;
    bool hovered = false;
    const bool previously_held = (g.ActiveId == id);
    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);

    float scroll_max = ImMax(1.0f, win_size_contents_v - win_size_avail_v);
    float scroll_ratio = ImSaturate(scroll_v / scroll_max);
    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
    if (held && grab_h_norm < 1.0f)
    {
        float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;
        float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;
        float* click_delta_to_grab_center_v = horizontal ? &g.ScrollbarClickDeltaToGrabCenter.x : &g.ScrollbarClickDeltaToGrabCenter.y;

        // Click position in scrollbar normalized space (0.0f->1.0f)
        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
        SetHoveredID(id);

        bool seek_absolute = false;
        if (!previously_held)
        {
            // On initial click calculate the distance between mouse and the center of the grab
            if (clicked_v_norm >= grab_v_norm && clicked_v_norm <= grab_v_norm + grab_h_norm)
            {
                *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;
            }
            else
            {
                seek_absolute = true;
                *click_delta_to_grab_center_v = 0.0f;
            }
        }

        // Apply scroll
        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of SizeContents and before setting up our starting position
        const float scroll_v_norm = ImSaturate((clicked_v_norm - *click_delta_to_grab_center_v - grab_h_norm*0.5f) / (1.0f - grab_h_norm));
        scroll_v = (float)(int)(0.5f + scroll_v_norm * scroll_max);//(win_size_contents_v - win_size_v));
        if (horizontal)
            window->Scroll.x = scroll_v;
        else
            window->Scroll.y = scroll_v;

        // Update values for rendering
        scroll_ratio = ImSaturate(scroll_v / scroll_max);
        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

        // Update distance to grab now that we have seeked and saturated
        if (seek_absolute)
            *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;
    }

    // Render
    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab);
    ImRect grab_rect;
    if (horizontal)
        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImMin(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, window_rect.Max.x), bb.Max.y);
    else
        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImMin(ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels, window_rect.Max.y));
    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);
}

void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    if (border_col.w > 0.0f)
        bb.Max += ImVec2(2, 2);
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
        return;

    if (border_col.w > 0.0f)
    {
        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);
        window->DrawList->AddImage(user_texture_id, bb.Min + ImVec2(1, 1), bb.Max - ImVec2(1, 1), uv0, uv1, GetColorU32(tint_col));
    }
    else
    {
        window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));
    }
}

// frame_padding < 0: uses FramePadding from style (default)
// frame_padding = 0: no framing
// frame_padding > 0: set framing size
// The color used are the button colors.
bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    // Default to using texture ID as ID. User can still push string/integer prefixes.
    // We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.
    PushID((void*)(intptr_t)user_texture_id);
    const ImGuiID id = window->GetID("#image");
    PopID();

    const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size + padding * 2);
    const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + size);
    ItemSize(bb);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, style.FrameRounding));
    if (bg_col.w > 0.0f)
        window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, GetColorU32(bg_col));
    window->DrawList->AddImage(user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32(tint_col));

    return pressed;
}

bool ImGui::Checkbox(const char* label, bool* v)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2, label_size.y + style.FramePadding.y*2)); // We want a square shape to we use Y twice
    ItemSize(check_bb, style.FramePadding.y);

    ImRect total_bb = check_bb;
    if (label_size.x > 0)
        SameLine(0, style.ItemInnerSpacing.x);
    const ImRect text_bb(window->DC.CursorPos + ImVec2(0,style.FramePadding.y), window->DC.CursorPos + ImVec2(0,style.FramePadding.y) + label_size);
    if (label_size.x > 0)
    {
        ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);
        total_bb = ImRect(ImMin(check_bb.Min, text_bb.Min), ImMax(check_bb.Max, text_bb.Max));
    }

    if (!ItemAdd(total_bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
    if (pressed)
    {
        *v = !(*v);
        MarkItemEdited(id);
    }

    RenderNavHighlight(total_bb, id);
    RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);
    if (*v)
    {
        const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());
        const float pad = ImMax(1.0f, (float)(int)(check_sz / 6.0f));
        RenderCheckMark(check_bb.Min + ImVec2(pad,pad), GetColorU32(ImGuiCol_CheckMark), check_bb.GetWidth() - pad*2.0f);
    }

    if (g.LogEnabled)
        LogRenderedText(&text_bb.Min, *v ? "[x]" : "[ ]");
    if (label_size.x > 0.0f)
        RenderText(text_bb.Min, label);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
    return pressed;
}

bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)
{
    bool v = ((*flags & flags_value) == flags_value);
    bool pressed = Checkbox(label, &v);
    if (pressed)
    {
        if (v)
            *flags |= flags_value;
        else
            *flags &= ~flags_value;
    }

    return pressed;
}

bool ImGui::RadioButton(const char* label, bool active)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2-1, label_size.y + style.FramePadding.y*2-1));
    ItemSize(check_bb, style.FramePadding.y);

    ImRect total_bb = check_bb;
    if (label_size.x > 0)
        SameLine(0, style.ItemInnerSpacing.x);
    const ImRect text_bb(window->DC.CursorPos + ImVec2(0, style.FramePadding.y), window->DC.CursorPos + ImVec2(0, style.FramePadding.y) + label_size);
    if (label_size.x > 0)
    {
        ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);
        total_bb.Add(text_bb);
    }

    if (!ItemAdd(total_bb, id))
        return false;

    ImVec2 center = check_bb.GetCenter();
    center.x = (float)(int)center.x + 0.5f;
    center.y = (float)(int)center.y + 0.5f;
    const float radius = check_bb.GetHeight() * 0.5f;

    bool hovered, held;
    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
    if (pressed)
        MarkItemEdited(id);

    RenderNavHighlight(total_bb, id);
    window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);
    if (active)
    {
        const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());
        const float pad = ImMax(1.0f, (float)(int)(check_sz / 6.0f));
        window->DrawList->AddCircleFilled(center, radius-pad, GetColorU32(ImGuiCol_CheckMark), 16);
    }

    if (style.FrameBorderSize > 0.0f)
    {
        window->DrawList->AddCircle(center+ImVec2(1,1), radius, GetColorU32(ImGuiCol_BorderShadow), 16, style.FrameBorderSize);
        window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16, style.FrameBorderSize);
    }

    if (g.LogEnabled)
        LogRenderedText(&text_bb.Min, active ? "(x)" : "( )");
    if (label_size.x > 0.0f)
        RenderText(text_bb.Min, label);

    return pressed;
}

bool ImGui::RadioButton(const char* label, int* v, int v_button)
{
    const bool pressed = RadioButton(label, *v == v_button);
    if (pressed)
        *v = v_button;
    return pressed;
}

// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size
void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    ImVec2 pos = window->DC.CursorPos;
    ImRect bb(pos, pos + CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y*2.0f));
    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(bb, 0))
        return;

    // Render
    fraction = ImSaturate(fraction);
    RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));
    const ImVec2 fill_br = ImVec2(ImLerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);
    RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), 0.0f, fraction, style.FrameRounding);

    // Default displaying the fraction as percentage string, but user can override it
    char overlay_buf[32];
    if (!overlay)
    {
        ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), "%.0f%%", fraction*100+0.01f);
        overlay = overlay_buf;
    }

    ImVec2 overlay_size = CalcTextSize(overlay, NULL);
    if (overlay_size.x > 0.0f)
        RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);
}

void ImGui::Bullet()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
    {
        SameLine(0, style.FramePadding.x*2);
        return;
    }

    // Render and stay on same line
    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));
    SameLine(0, style.FramePadding.x*2);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Low-level Layout helpers
//-------------------------------------------------------------------------
// - Spacing()
// - Dummy()
// - NewLine()
// - AlignTextToFramePadding()
// - Separator()
// - VerticalSeparator() [Internal]
// - SplitterBehavior() [Internal]
//-------------------------------------------------------------------------

void ImGui::Spacing()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ItemSize(ImVec2(0,0));
}

void ImGui::Dummy(const ImVec2& size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(bb);
    ItemAdd(bb, 0);
}

void ImGui::NewLine()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;
    window->DC.LayoutType = ImGuiLayoutType_Vertical;
    if (window->DC.CurrentLineSize.y > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.
        ItemSize(ImVec2(0,0));
    else
        ItemSize(ImVec2(0.0f, g.FontSize));
    window->DC.LayoutType = backup_layout_type;
}

void ImGui::AlignTextToFramePadding()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    window->DC.CurrentLineSize.y = ImMax(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);
    window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.CurrentLineTextBaseOffset, g.Style.FramePadding.y);
}

// Horizontal/vertical separating line
void ImGui::Separator()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    // Those flags should eventually be overridable by the user
    ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical))));   // Check that only 1 option is selected
    if (flags & ImGuiSeparatorFlags_Vertical)
    {
        VerticalSeparator();
        return;
    }

    // Horizontal Separator
    if (window->DC.ColumnsSet)
        PopClipRect();

    float x1 = window->Pos.x;
    float x2 = window->Pos.x + window->Size.x;
    if (!window->DC.GroupStack.empty())
        x1 += window->DC.Indent.x;

    const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y+1.0f));
    ItemSize(ImVec2(0.0f, 0.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit, we don't provide height to not alter layout.
    if (!ItemAdd(bb, 0))
    {
        if (window->DC.ColumnsSet)
            PushColumnClipRect();
        return;
    }

    window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x,bb.Min.y), GetColorU32(ImGuiCol_Separator));

    if (g.LogEnabled)
        LogRenderedText(&bb.Min, "--------------------------------");

    if (window->DC.ColumnsSet)
    {
        PushColumnClipRect();
        window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;
    }
}

void ImGui::VerticalSeparator()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    float y1 = window->DC.CursorPos.y;
    float y2 = window->DC.CursorPos.y + window->DC.CurrentLineSize.y;
    const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + 1.0f, y2));
    ItemSize(ImVec2(bb.GetWidth(), 0.0f));
    if (!ItemAdd(bb, 0))
        return;

    window->DrawList->AddLine(ImVec2(bb.Min.x, bb.Min.y), ImVec2(bb.Min.x, bb.Max.y), GetColorU32(ImGuiCol_Separator));
    if (g.LogEnabled)
        LogText(" |");
}

// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.
bool ImGui::SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
    window->DC.ItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;
    bool item_add = ItemAdd(bb, id);
    window->DC.ItemFlags = item_flags_backup;
    if (!item_add)
        return false;

    bool hovered, held;
    ImRect bb_interact = bb;
    bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));
    ButtonBehavior(bb_interact, id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap);
    if (g.ActiveId != id)
        SetItemAllowOverlap();

    if (held || (g.HoveredId == id && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))
        SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);

    ImRect bb_render = bb;
    if (held)
    {
        ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;
        float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;

        // Minimum pane size
        float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);
        float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);
        if (mouse_delta < -size_1_maximum_delta)
            mouse_delta = -size_1_maximum_delta;
        if (mouse_delta > size_2_maximum_delta)
            mouse_delta = size_2_maximum_delta;

        // Apply resize
        if (mouse_delta != 0.0f)
        {
            if (mouse_delta < 0.0f)
                IM_ASSERT(*size1 + mouse_delta >= min_size1);
            if (mouse_delta > 0.0f)
                IM_ASSERT(*size2 - mouse_delta >= min_size2);
            *size1 += mouse_delta;
            *size2 -= mouse_delta;
            bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));
            MarkItemEdited(id);
        }
    }

    // Render
    const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
    window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, g.Style.FrameRounding);

    return held;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ComboBox
//-------------------------------------------------------------------------
// - BeginCombo()
// - EndCombo()
// - Combo()
//-------------------------------------------------------------------------

static float CalcMaxPopupHeightFromItemCount(int items_count)
{
    ImGuiContext& g = *GImGui;
    if (items_count <= 0)
        return FLT_MAX;
    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
}

bool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)
{
    // Always consume the SetNextWindowSizeConstraint() call in our early return paths
    ImGuiContext& g = *GImGui;
    ImGuiCond backup_next_window_size_constraint = g.NextWindowData.SizeConstraintCond;
    g.NextWindowData.SizeConstraintCond = 0;

    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together

    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();
    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : CalcItemWidth();
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &frame_bb))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(frame_bb, id, &hovered, &held);
    bool popup_open = IsPopupOpen(id);

    const ImRect value_bb(frame_bb.Min, frame_bb.Max - ImVec2(arrow_size, 0.0f));
    const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    if (!(flags & ImGuiComboFlags_NoPreview))
        window->DrawList->AddRectFilled(frame_bb.Min, ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Max.y), frame_col, style.FrameRounding, ImDrawCornerFlags_Left);
    if (!(flags & ImGuiComboFlags_NoArrowButton))
    {
        window->DrawList->AddRectFilled(ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Min.y), frame_bb.Max, GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button), style.FrameRounding, (w <= arrow_size) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right);
        RenderArrow(ImVec2(frame_bb.Max.x - arrow_size + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), ImGuiDir_Down);
    }
    RenderFrameBorder(frame_bb.Min, frame_bb.Max, style.FrameRounding);
    if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))
        RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, preview_value, NULL, NULL, ImVec2(0.0f,0.0f));
    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    if ((pressed || g.NavActivateId == id) && !popup_open)
    {
        if (window->DC.NavLayerCurrent == 0)
            window->NavLastIds[0] = id;
        OpenPopupEx(id);
        popup_open = true;
    }

    if (!popup_open)
        return false;

    if (backup_next_window_size_constraint)
    {
        g.NextWindowData.SizeConstraintCond = backup_next_window_size_constraint;
        g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);
    }
    else
    {
        if ((flags & ImGuiComboFlags_HeightMask_) == 0)
            flags |= ImGuiComboFlags_HeightRegular;
        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one
        int popup_max_height_in_items = -1;
        if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;
        else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;
        else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;
        SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));
    }

    char name[16];
    ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth

    // Peak into expected window size so we can position it
    if (ImGuiWindow* popup_window = FindWindowByName(name))
        if (popup_window->WasActive)
        {
            ImVec2 size_expected = CalcWindowExpectedSize(popup_window);
            if (flags & ImGuiComboFlags_PopupAlignLeft)
                popup_window->AutoPosLastDirection = ImGuiDir_Left;
            ImRect r_outer = GetWindowAllowedExtentRect(popup_window);
            ImVec2 pos = FindBestWindowPosForPopupEx(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, frame_bb, ImGuiPopupPositionPolicy_ComboBox);
            SetNextWindowPos(pos);
        }

    // Horizontally align ourselves with the framed text
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;
    PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(style.FramePadding.x, style.WindowPadding.y));
    bool ret = Begin(name, NULL, window_flags);
    PopStyleVar();
    if (!ret)
    {
        EndPopup();
        IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above
        return false;
    }
    return true;
}

void ImGui::EndCombo()
{
    EndPopup();
}

// Getter for the old Combo() API: const char*[]
static bool Items_ArrayGetter(void* data, int idx, const char** out_text)
{
    const char* const* items = (const char* const*)data;
    if (out_text)
        *out_text = items[idx];
    return true;
}

// Getter for the old Combo() API: "item1\0item2\0item3\0"
static bool Items_SingleStringGetter(void* data, int idx, const char** out_text)
{
    // FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
    const char* items_separated_by_zeros = (const char*)data;
    int items_count = 0;
    const char* p = items_separated_by_zeros;
    while (*p)
    {
        if (idx == items_count)
            break;
        p += strlen(p) + 1;
        items_count++;
    }
    if (!*p)
        return false;
    if (out_text)
        *out_text = p;
    return true;
}

// Old API, prefer using BeginCombo() nowadays if you can.
bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)
{
    ImGuiContext& g = *GImGui;

    // Call the getter to obtain the preview string which is a parameter to BeginCombo()
    const char* preview_value = NULL;
    if (*current_item >= 0 && *current_item < items_count)
        items_getter(data, *current_item, &preview_value);

    // The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
    if (popup_max_height_in_items != -1 && !g.NextWindowData.SizeConstraintCond)
        SetNextWindowSizeConstraints(ImVec2(0,0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));

    if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))
        return false;

    // Display items
    // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
    bool value_changed = false;
    for (int i = 0; i < items_count; i++)
    {
        PushID((void*)(intptr_t)i);
        const bool item_selected = (i == *current_item);
        const char* item_text;
        if (!items_getter(data, i, &item_text))
            item_text = "*Unknown item*";
        if (Selectable(item_text, item_selected))
        {
            value_changed = true;
            *current_item = i;
        }
        if (item_selected)
            SetItemDefaultFocus();
        PopID();
    }

    EndCombo();
    return value_changed;
}

// Combo box helper allowing to pass an array of strings.
bool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)
{
    const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);
    return value_changed;
}

// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items "item1\0item2\0" 
bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
{
    int items_count = 0;
    const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open
    while (*p)
    {
        p += strlen(p) + 1;
        items_count++;
    }
    bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);
    return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Data Type and Data Formatting Helpers [Internal]
//-------------------------------------------------------------------------
// - PatchFormatStringFloatToInt()
// - DataTypeFormatString()
// - DataTypeApplyOp()
// - DataTypeApplyOpFromText()
// - GetMinimumStepAtDecimalPrecision
// - RoundScalarWithFormat<>()
//-------------------------------------------------------------------------

struct ImGuiDataTypeInfo
{
    size_t      Size;
    const char* PrintFmt;   // Unused
    const char* ScanFmt;
};

static const ImGuiDataTypeInfo GDataTypeInfo[] =
{
    { sizeof(int),          "%d",   "%d"    },
    { sizeof(unsigned int), "%u",   "%u"    },
#ifdef _MSC_VER
    { sizeof(ImS64),        "%I64d","%I64d" },
    { sizeof(ImU64),        "%I64u","%I64u" },
#else
    { sizeof(ImS64),        "%lld", "%lld"  },
    { sizeof(ImU64),        "%llu", "%llu"  },
#endif
    { sizeof(float),        "%f",   "%f"    },  // float are promoted to double in va_arg
    { sizeof(double),       "%f",   "%lf"   },
};
IM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);

// FIXME-LEGACY: Prior to 1.61 our DragInt() function internally used floats and because of this the compile-time default value for format was "%.0f".
// Even though we changed the compile-time default, we expect users to have carried %f around, which would break the display of DragInt() calls.
// To honor backward compatibility we are rewriting the format string, unless IMGUI_DISABLE_OBSOLETE_FUNCTIONS is enabled. What could possibly go wrong?!
static const char* PatchFormatStringFloatToInt(const char* fmt)
{
    if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '0' && fmt[3] == 'f' && fmt[4] == 0) // Fast legacy path for "%.0f" which is expected to be the most common case.
        return "%d";
    const char* fmt_start = ImParseFormatFindLoopCallback(fmt);    // Find % (if any, and ignore %%)
    const char* fmt_end = ImParseFormatFindEnd(fmt_start);  // Find end of format specifier, which itself is an exercise of confidence/recklessness (because snprintf is dependent on libc or user).
    if (fmt_end > fmt_start && fmt_end[-1] == 'f')
    {
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        if (fmt_start == fmt && fmt_end[0] == 0)
            return "%d";
        ImGuiContext& g = *GImGui;
        ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), "%.*s%%d%s", (int)(fmt_start - fmt), fmt, fmt_end); // Honor leading and trailing decorations, but lose alignment/precision.
        return g.TempBuffer;
#else
        IM_ASSERT(0 && "DragInt(): Invalid format string!"); // Old versions used a default parameter of "%.0f", please replace with e.g. "%d"
#endif
    }
    return fmt;
}

static inline int DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format)
{
    if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)   // Signedness doesn't matter when pushing the argument
        return ImFormatString(buf, buf_size, format, *(const ImU32*)data_ptr);
    if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)   // Signedness doesn't matter when pushing the argument
        return ImFormatString(buf, buf_size, format, *(const ImU64*)data_ptr);
    if (data_type == ImGuiDataType_Float)
        return ImFormatString(buf, buf_size, format, *(const float*)data_ptr);
    if (data_type == ImGuiDataType_Double)
        return ImFormatString(buf, buf_size, format, *(const double*)data_ptr);
    IM_ASSERT(0);
    return 0;
}

// FIXME: Adding support for clamping on boundaries of the data type would be nice.
static void DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg1, const void* arg2)
{
    IM_ASSERT(op == '+' || op == '-');
    switch (data_type)
    {
        case ImGuiDataType_S32:
            if (op == '+')      *(int*)output = *(const int*)arg1 + *(const int*)arg2;
            else if (op == '-') *(int*)output = *(const int*)arg1 - *(const int*)arg2;
            return;
        case ImGuiDataType_U32:
            if (op == '+')      *(unsigned int*)output = *(const unsigned int*)arg1 + *(const ImU32*)arg2;
            else if (op == '-') *(unsigned int*)output = *(const unsigned int*)arg1 - *(const ImU32*)arg2;
            return;
        case ImGuiDataType_S64:
            if (op == '+')      *(ImS64*)output = *(const ImS64*)arg1 + *(const ImS64*)arg2;
            else if (op == '-') *(ImS64*)output = *(const ImS64*)arg1 - *(const ImS64*)arg2;
            return;
        case ImGuiDataType_U64:
            if (op == '+')      *(ImU64*)output = *(const ImU64*)arg1 + *(const ImU64*)arg2;
            else if (op == '-') *(ImU64*)output = *(const ImU64*)arg1 - *(const ImU64*)arg2;
            return;
        case ImGuiDataType_Float:
            if (op == '+')      *(float*)output = *(const float*)arg1 + *(const float*)arg2;
            else if (op == '-') *(float*)output = *(const float*)arg1 - *(const float*)arg2;
            return;
        case ImGuiDataType_Double:
            if (op == '+')      *(double*)output = *(const double*)arg1 + *(const double*)arg2;
            else if (op == '-') *(double*)output = *(const double*)arg1 - *(const double*)arg2;
            return;
        case ImGuiDataType_COUNT: break;
    }
    IM_ASSERT(0);
}

// User can input math operators (e.g. +100) to edit a numerical values.
// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..
static bool DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format)
{
    while (ImCharIsBlankA(*buf))
        buf++;

    // We don't support '-' op because it would conflict with inputing negative value.
    // Instead you can use +-100 to subtract from an existing value
    char op = buf[0];
    if (op == '+' || op == '*' || op == '/')
    {
        buf++;
        while (ImCharIsBlankA(*buf))
            buf++;
    }
    else
    {
        op = 0;
    }
    if (!buf[0])
        return false;

    // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
    IM_ASSERT(data_type < ImGuiDataType_COUNT);
    int data_backup[2];
    IM_ASSERT(GDataTypeInfo[data_type].Size <= sizeof(data_backup));
    memcpy(data_backup, data_ptr, GDataTypeInfo[data_type].Size);

    if (format == NULL)
        format = GDataTypeInfo[data_type].ScanFmt;

    int arg1i = 0;
    if (data_type == ImGuiDataType_S32)
    {
        int* v = (int*)data_ptr;
        int arg0i = *v;
        float arg1f = 0.0f;
        if (op && sscanf(initial_value_buf, format, &arg0i) < 1)
            return false;
        // Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision
        if (op == '+')      { if (sscanf(buf, "%d", &arg1i)) *v = (int)(arg0i + arg1i); }                   // Add (use "+-" to subtract)
        else if (op == '*') { if (sscanf(buf, "%f", &arg1f)) *v = (int)(arg0i * arg1f); }                   // Multiply
        else if (op == '/') { if (sscanf(buf, "%f", &arg1f) && arg1f != 0.0f) *v = (int)(arg0i / arg1f); }  // Divide
        else                { if (sscanf(buf, format, &arg1i) == 1) *v = arg1i; }                           // Assign constant
    }
    else if (data_type == ImGuiDataType_U32 || data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)
    {
        // Assign constant
        // FIXME: We don't bother handling support for legacy operators since they are a little too crappy. Instead we may implement a proper expression evaluator in the future.
        sscanf(buf, format, data_ptr);
    }
    else if (data_type == ImGuiDataType_Float)
    {
        // For floats we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in
        format = "%f";
        float* v = (float*)data_ptr;
        float arg0f = *v, arg1f = 0.0f;
        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)
            return false;
        if (sscanf(buf, format, &arg1f) < 1)
            return false;
        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide
        else                { *v = arg1f; }                            // Assign constant
    }
    else if (data_type == ImGuiDataType_Double)
    {
        format = "%lf"; // scanf differentiate float/double unlike printf which forces everything to double because of ellipsis
        double* v = (double*)data_ptr;
        double arg0f = *v, arg1f = 0.0;
        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)
            return false;
        if (sscanf(buf, format, &arg1f) < 1)
            return false;
        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide
        else                { *v = arg1f; }                            // Assign constant
    }
    return memcmp(data_backup, data_ptr, GDataTypeInfo[data_type].Size) != 0;
}

static float GetMinimumStepAtDecimalPrecision(int decimal_precision)
{
    static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
    if (decimal_precision < 0)
        return FLT_MIN;
    return (decimal_precision >= 0 && decimal_precision < 10) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);
}

template<typename TYPE>
static const char* ImAtoi(const char* src, TYPE* output)
{
    int negative = 0;
    if (*src == '-') { negative = 1; src++; }
    if (*src == '+') { src++; }
    TYPE v = 0;
    while (*src >= '0' && *src <= '9')
        v = (v * 10) + (*src++ - '0');
    *output = negative ? -v : v;
    return src;
}

template<typename TYPE, typename SIGNEDTYPE>
TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)
{
    const char* fmt_start = ImParseFormatFindLoopCallback(format);
    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
        return v;
    char v_str[64];
    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
    const char* p = v_str;
    while (*p == ' ')
        p++;
    if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)
        v = (TYPE)ImAtof(p);
    else
        ImAtoi(p, (SIGNEDTYPE*)&v);
    return v;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
//-------------------------------------------------------------------------
// - DragBehaviorT<>() [Internal]
// - DragBehavior() [Internal]
// - DragScalar()
// - DragScalarN()
// - DragFloat()
// - DragFloat2()
// - DragFloat3()
// - DragFloat4()
// - DragFloatRange2()
// - DragInt()
// - DragInt2()
// - DragInt3()
// - DragInt4()
// - DragIntRange2()
//-------------------------------------------------------------------------

// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)
template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiDragFlags flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    const bool has_min_max = (v_min != v_max);

    // Default tweak speed
    if (v_speed == 0.0f && has_min_max && (v_max - v_min < FLT_MAX))
        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
    float adjust_delta = 0.0f;
    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)
    {
        adjust_delta = g.IO.MouseDelta[axis];
        if (g.IO.KeyAlt)
            adjust_delta *= 1.0f / 100.0f;
        if (g.IO.KeyShift)
            adjust_delta *= 10.0f;
    }
    else if (g.ActiveIdSource == ImGuiInputSource_Nav)
    {
        int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;
        adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];
        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
    }
    adjust_delta *= v_speed;

    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
    if (axis == ImGuiAxis_Y)
        adjust_delta = -adjust_delta;

    // Clear current value on activation
    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
    bool is_just_activated = g.ActiveIdIsJustActivated;
    bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
    if (is_just_activated || is_already_past_limits_and_pushing_outward)
    {
        g.DragCurrentAccum = 0.0f;
        g.DragCurrentAccumDirty = false;
    }
    else if (adjust_delta != 0.0f)
    {
        g.DragCurrentAccum += adjust_delta;
        g.DragCurrentAccumDirty = true;
    }

    if (!g.DragCurrentAccumDirty)
        return false;

    TYPE v_cur = *v;
    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

    const bool is_power = (power != 1.0f && is_decimal && has_min_max && (v_max - v_min < FLT_MAX));
    if (is_power)
    {
        // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
        FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);
        FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));
        v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);
        v_old_ref_for_accum_remainder = v_old_norm_curved;
    }
    else
    {
        v_cur += (TYPE)g.DragCurrentAccum;
    }

    // Round to user desired precision based on format string
    v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
    g.DragCurrentAccumDirty = false;
    if (is_power)
    {
        FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);
        g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);
    }
    else
    {
        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
    }

    // Lose zero sign for float/double
    if (v_cur == (TYPE)-0)
        v_cur = (TYPE)0;

    // Clamp values (+ handle overflow/wrap-around for integer types)
    if (*v != v_cur && has_min_max)
    {
        if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))
            v_cur = v_min;
        if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))
            v_cur = v_max;
    }

    // Apply result
    if (*v == v_cur)
        return false;
    *v = v_cur;
    return true;
}

bool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power, ImGuiDragFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId == id)
    {
        if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])
            ClearActiveID();
        else if (g.ActiveIdSource == ImGuiInputSource_Nav && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
            ClearActiveID();
    }
    if (g.ActiveId != id)
        return false;

    switch (data_type)
    {
    case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)v,  v_speed, v_min ? *(const ImS32* )v_min : IM_S32_MIN, v_max ? *(const ImS32* )v_max : IM_S32_MAX, format, power, flags);
    case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)v,  v_speed, v_min ? *(const ImU32* )v_min : IM_U32_MIN, v_max ? *(const ImU32* )v_max : IM_U32_MAX, format, power, flags);
    case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)v,  v_speed, v_min ? *(const ImS64* )v_min : IM_S64_MIN, v_max ? *(const ImS64* )v_max : IM_S64_MAX, format, power, flags);
    case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)v,  v_speed, v_min ? *(const ImU64* )v_min : IM_U64_MIN, v_max ? *(const ImU64* )v_max : IM_U64_MAX, format, power, flags);
    case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)v,  v_speed, v_min ? *(const float* )v_min : -FLT_MAX,   v_max ? *(const float* )v_max : FLT_MAX,    format, power, flags);
    case ImGuiDataType_Double: return DragBehaviorT<double,double,double>(data_type, (double*)v, v_speed, v_min ? *(const double*)v_min : -DBL_MAX,   v_max ? *(const double*)v_max : DBL_MAX,    format, power, flags);
    case ImGuiDataType_COUNT:  break;
    }
    IM_ASSERT(0);
    return false;
}

bool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    if (power != 1.0f)
        IM_ASSERT(v_min != NULL && v_max != NULL); // When using a power curve the drag needs to have known bounds

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const float w = CalcItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    // NB- we don't call ItemSize() yet because we may turn into a text edit box below
    if (!ItemAdd(total_bb, id, &frame_bb))
    {
        ItemSize(total_bb, style.FramePadding.y);
        return false;
    }
    const bool hovered = ItemHoverable(frame_bb, id);

    // Default format string when passing NULL
    // Patch old "%.0f" format string to use "%d", read function comments for more details.
    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)
        format = PatchFormatStringFloatToInt(format);

    // Tabbing or CTRL-clicking on Drag turns it into an input box
    bool start_text_input = false;
    const bool tab_focus_requested = FocusableItemRegister(window, id);
    if (tab_focus_requested || (hovered && (g.IO.MouseClicked[0] || g.IO.MouseDoubleClicked[0])) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))
    {
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
        if (tab_focus_requested || g.IO.KeyCtrl || g.IO.MouseDoubleClicked[0] || g.NavInputId == id)
        {
            start_text_input = true;
            g.ScalarAsInputTextId = 0;
        }
    }
    if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
    {
        FocusableItemUnregister(window);
        return InputScalarAsWidgetReplacement(frame_bb, id, label, data_type, v, format);
    }

    // Actual drag behavior
    ItemSize(total_bb, style.FramePadding.y);
    const bool value_changed = DragBehavior(id, data_type, v, v_speed, v_min, v_max, format, power, ImGuiDragFlags_None);
    if (value_changed)
        MarkItemEdited(id);

    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

    return value_changed;
}

bool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components);
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= DragScalar("##v", data_type, v, v_speed, v_min, v_max, format, power);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    PushID(label);
    BeginGroup();
    PushMultiItemsWidths(2);

    bool value_changed = DragFloat("##min", v_current_min, v_speed, (v_min >= v_max) ? -FLT_MAX : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format, power);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);
    value_changed |= DragFloat("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? FLT_MAX : v_max, format_max ? format_max : format, power);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    PopID();
    return value_changed;
}

// NB: v_speed is float to allow adjusting the drag speed with more precision
bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    PushID(label);
    BeginGroup();
    PushMultiItemsWidths(2);

    bool value_changed = DragInt("##min", v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);
    value_changed |= DragInt("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, format_max ? format_max : format);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    PopID();

    return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
//-------------------------------------------------------------------------
// - SliderBehaviorT<>() [Internal]
// - SliderBehavior() [Internal]
// - SliderScalar()
// - SliderScalarN()
// - SliderFloat()
// - SliderFloat2()
// - SliderFloat3()
// - SliderFloat4()
// - SliderAngle()
// - SliderInt()
// - SliderInt2()
// - SliderInt3()
// - SliderInt4()
// - VSliderScalar()
// - VSliderFloat()
// - VSliderInt()
//-------------------------------------------------------------------------

template<typename TYPE, typename FLOATTYPE>
float ImGui::SliderCalcRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, float power, float linear_zero_pos)
{
    if (v_min == v_max)
        return 0.0f;

    const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    if (is_power)
    {
        if (v_clamped < 0.0f)
        {
            const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));
            return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;
        }
        else
        {
            const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));
            return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);
        }
    }

    // Linear slider
    return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));
}

// FIXME: Move some of the code into SliderBehavior(). Current responsability is larger than what the equivalent DragBehaviorT<> does, we also do some rendering, etc.
template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    const bool is_power = (power != 1.0f) && is_decimal;

    const float grab_padding = 2.0f;
    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
    float grab_sz = style.GrabMinSize;
    SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);
    if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows
        grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit
    grab_sz = ImMin(grab_sz, slider_sz);
    const float slider_usable_sz = slider_sz - grab_sz;
    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz*0.5f;
    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz*0.5f;

    // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
    float linear_zero_pos;   // 0.0->1.0f
    if (is_power && v_min * v_max < 0.0f)
    {
        // Different sign
        const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f/power);
        const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f/power);
        linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));
    }
    else
    {
        // Same sign
        linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;
    }

    // Process interacting with the slider
    bool value_changed = false;
    if (g.ActiveId == id)
    {
        bool set_new_value = false;
        float clicked_t = 0.0f;
        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
        {
            if (!g.IO.MouseDown[0])
            {
                ClearActiveID();
            }
            else
            {
                const float mouse_abs_pos = g.IO.MousePos[axis];
                clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;
                if (axis == ImGuiAxis_Y)
                    clicked_t = 1.0f - clicked_t;
                set_new_value = true;
            }
        }
        else if (g.ActiveIdSource == ImGuiInputSource_Nav)
        {
            const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);
            float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;
            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
            {
                ClearActiveID();
            }
            else if (delta != 0.0f)
            {
                clicked_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);
                const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;
                if ((decimal_precision > 0) || is_power)
                {
                    delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds
                    if (IsNavInputDown(ImGuiNavInput_TweakSlow))
                        delta /= 10.0f;
                }
                else
                {
                    if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))
                        delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps
                    else
                        delta /= 100.0f;
                }
                if (IsNavInputDown(ImGuiNavInput_TweakFast))
                    delta *= 10.0f;
                set_new_value = true;
                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
                    set_new_value = false;
                else
                    clicked_t = ImSaturate(clicked_t + delta);
            }
        }

        if (set_new_value)
        {
            TYPE v_new;
            if (is_power)
            {
                // Account for power curve scale on both sides of the zero
                if (clicked_t < linear_zero_pos)
                {
                    // Negative: rescale to the negative range before powering
                    float a = 1.0f - (clicked_t / linear_zero_pos);
                    a = ImPow(a, power);
                    v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);
                }
                else
                {
                    // Positive: rescale to the positive range before powering
                    float a;
                    if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)
                        a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);
                    else
                        a = clicked_t;
                    a = ImPow(a, power);
                    v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);
                }
            }
            else
            {
                // Linear slider
                if (is_decimal)
                {
                    v_new = ImLerp(v_min, v_max, clicked_t);
                }
                else
                {
                    // For integer values we want the clicking position to match the grab box so we round above
                    // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
                    FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;
                    TYPE v_new_off_floor = (TYPE)(v_new_off_f);
                    TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);
                    if (!is_decimal && v_new_off_floor < v_new_off_round)
                        v_new = v_min + v_new_off_round;
                    else
                        v_new = v_min + v_new_off_floor;
                }
            }

            // Round to user desired precision based on format string
            v_new = RoundScalarWithFormatT<TYPE,SIGNEDTYPE>(format, data_type, v_new);

            // Apply result
            if (*v != v_new)
            {
                *v = v_new;
                value_changed = true;
            }
        }
    }

    // Output grab position so it can be displayed by the caller
    float grab_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);
    if (axis == ImGuiAxis_Y)
        grab_t = 1.0f - grab_t;
    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    if (axis == ImGuiAxis_X)
        *out_grab_bb = ImRect(grab_pos - grab_sz*0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz*0.5f, bb.Max.y - grab_padding);
    else
        *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz*0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz*0.5f);

    return value_changed;
}

// For 32-bits and larger types, slider bounds are limited to half the natural type range.
// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.
// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.
bool ImGui::SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)
{
    switch (data_type)
    {
    case ImGuiDataType_S32:
        IM_ASSERT(*(const ImS32*)v_min >= IM_S32_MIN/2 && *(const ImS32*)v_max <= IM_S32_MAX/2);
        return SliderBehaviorT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)v,  *(const ImS32*)v_min,  *(const ImS32*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_U32:
        IM_ASSERT(*(const ImU32*)v_min <= IM_U32_MAX/2);
        return SliderBehaviorT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)v,  *(const ImU32*)v_min,  *(const ImU32*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_S64:
        IM_ASSERT(*(const ImS64*)v_min >= IM_S64_MIN/2 && *(const ImS64*)v_max <= IM_S64_MAX/2);
        return SliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)v,  *(const ImS64*)v_min,  *(const ImS64*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_U64:
        IM_ASSERT(*(const ImU64*)v_min <= IM_U64_MAX/2);
        return SliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)v,  *(const ImU64*)v_min,  *(const ImU64*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_Float:
        IM_ASSERT(*(const float*)v_min >= -FLT_MAX/2.0f && *(const float*)v_max <= FLT_MAX/2.0f);
        return SliderBehaviorT<float, float, float >(bb, id, data_type, (float*)v,  *(const float*)v_min,  *(const float*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_Double:
        IM_ASSERT(*(const double*)v_min >= -DBL_MAX/2.0f && *(const double*)v_max <= DBL_MAX/2.0f);
        return SliderBehaviorT<double,double,double>(bb, id, data_type, (double*)v, *(const double*)v_min, *(const double*)v_max, format, power, flags, out_grab_bb);
    case ImGuiDataType_COUNT: break;
    }
    IM_ASSERT(0);
    return false;
}

bool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const float w = CalcItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    // NB- we don't call ItemSize() yet because we may turn into a text edit box below
    if (!ItemAdd(total_bb, id, &frame_bb))
    {
        ItemSize(total_bb, style.FramePadding.y);
        return false;
    }

    // Default format string when passing NULL
    // Patch old "%.0f" format string to use "%d", read function comments for more details.
    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)
        format = PatchFormatStringFloatToInt(format);

    // Tabbing or CTRL-clicking on Slider turns it into an input box
    bool start_text_input = false;
    const bool tab_focus_requested = FocusableItemRegister(window, id);
    const bool hovered = ItemHoverable(frame_bb, id);
    if (tab_focus_requested || (hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))
    {
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
        if (tab_focus_requested || g.IO.KeyCtrl || g.NavInputId == id)
        {
            start_text_input = true;
            g.ScalarAsInputTextId = 0;
        }
    }
    if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
    {
        FocusableItemUnregister(window);
        return InputScalarAsWidgetReplacement(frame_bb, id, label, data_type, v, format);
    }

    ItemSize(total_bb, style.FramePadding.y);

    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

    // Slider behavior
    ImRect grab_bb;
    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_None, &grab_bb);
    if (value_changed)
        MarkItemEdited(id);

    // Render grab
    window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    return value_changed;
}

// Add multiple sliders on 1 line for compact edition of multiple components
bool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components);
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= SliderScalar("##v", data_type, v, v_min, v_max, format, power);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, float power)
{
    return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, power);
}

bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power);
}

bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power);
}

bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power);
}

bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format)
{
    if (format == NULL)
        format = "%.0f deg";
    float v_deg = (*v_rad) * 360.0f / (2*IM_PI);
    bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, 1.0f);
    *v_rad = v_deg * (2*IM_PI) / 360.0f;
    return value_changed;
}

bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format)
{
    return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format);
}

bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format);
}

bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format);
}

bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format);
}

bool ImGui::VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(frame_bb, id))
        return false;

    // Default format string when passing NULL
    // Patch old "%.0f" format string to use "%d", read function comments for more details.
    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)
        format = PatchFormatStringFloatToInt(format);

    const bool hovered = ItemHoverable(frame_bb, id);
    if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id)
    {
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
    }

    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

    // Slider behavior
    ImRect grab_bb;
    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_Vertical, &grab_bb);
    if (value_changed)
        MarkItemEdited(id);

    // Render grab
    window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    // For the vertical slider we allow centered text to overlap the frame padding
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));
    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    return value_changed;
}

bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format, float power)
{
    return VSliderScalar(label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, power);
}

bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format)
{
    return VSliderScalar(label, size, ImGuiDataType_S32, v, &v_min, &v_max, format);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
//-------------------------------------------------------------------------
// - ImParseFormatFindLoopCallback() [Internal]
// - ImParseFormatFindEnd() [Internal]
// - ImParseFormatTrimDecorations() [Internal]
// - ImParseFormatPrecision() [Internal]
// - InputScalarAsWidgetReplacement() [Internal]
// - InputScalar()
// - InputScalarN()
// - InputFloat()
// - InputFloat2()
// - InputFloat3()
// - InputFloat4()
// - InputInt()
// - InputInt2()
// - InputInt3()
// - InputInt4()
// - InputDouble()
//-------------------------------------------------------------------------

// We don't use strchr() because our strings are usually very short and often start with '%'
const char* ImParseFormatFindLoopCallback(const char* fmt)
{
    while (char c = fmt[0])
    {
        if (c == '%' && fmt[1] != '%')
            return fmt;
        else if (c == '%')
            fmt++;
        fmt++;
    }
    return fmt;
}

const char* ImParseFormatFindEnd(const char* fmt)
{
    // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
    if (fmt[0] != '%')
        return fmt;
    const unsigned int ignored_uppercase_mask = (1 << ('I'-'A')) | (1 << ('L'-'A'));
    const unsigned int ignored_lowercase_mask = (1 << ('h'-'a')) | (1 << ('j'-'a')) | (1 << ('l'-'a')) | (1 << ('t'-'a')) | (1 << ('w'-'a')) | (1 << ('z'-'a'));
    for (char c; (c = *fmt) != 0; fmt++)
    {
        if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)
            return fmt + 1;
        if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)
            return fmt + 1;
    }
    return fmt;
}

// Extract the format out of a format string with leading or trailing decorations
//  fmt = "blah blah"  -> return fmt
//  fmt = "%.3f"       -> return fmt
//  fmt = "hello %.3f" -> return fmt + 6
//  fmt = "%.3f hello" -> return buf written with "%.3f"
const char* ImParseFormatTrimDecorations(const char* fmt, char* buf, int buf_size)
{
    const char* fmt_start = ImParseFormatFindLoopCallback(fmt);
    if (fmt_start[0] != '%')
        return fmt;
    const char* fmt_end = ImParseFormatFindEnd(fmt_start);
    if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.
        return fmt_start;
    ImStrncpy(buf, fmt_start, ImMin((int)(fmt_end + 1 - fmt_start), buf_size));
    return buf;
}

// Parse display precision back from the display format string
// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.
int ImParseFormatPrecision(const char* fmt, int default_precision)
{
    fmt = ImParseFormatFindLoopCallback(fmt);
    if (fmt[0] != '%')
        return default_precision;
    fmt++;
    while (*fmt >= '0' && *fmt <= '9')
        fmt++;
    int precision = INT_MAX;
    if (*fmt == '.')
    {
        fmt = ImAtoi<int>(fmt + 1, &precision);
        if (precision < 0 || precision > 99)
            precision = default_precision;
    }
    if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation
        precision = -1;
    if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)
        precision = -1;
    return (precision == INT_MAX) ? default_precision : precision;
}

// Create text input in place of an active drag/slider (used when doing a CTRL+Click on drag/slider widgets)
// FIXME: Logic is awkward and confusing. This should be reworked to facilitate using in other situations.
bool ImGui::InputScalarAsWidgetReplacement(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    // Our replacement widget will override the focus ID (registered previously to allow for a TAB focus to happen)
    // On the first frame, g.ScalarAsInputTextId == 0, then on subsequent frames it becomes == id
    SetActiveID(g.ScalarAsInputTextId, window);
    SetHoveredID(0);
    g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);

    char fmt_buf[32];
    char data_buf[32];
    format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));
    DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, data_ptr, format);
    ImStrTrimBlanks(data_buf);
    ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | ((data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) ? ImGuiInputTextFlags_CharsScientific : ImGuiInputTextFlags_CharsDecimal);
    bool value_changed = InputTextEx(label, data_buf, IM_ARRAYSIZE(data_buf), bb.GetSize(), flags);
    if (g.ScalarAsInputTextId == 0)     // First frame we started displaying the InputText widget
    {
        IM_ASSERT(g.ActiveId == id);    // InputText ID expected to match the Slider ID
        g.ScalarAsInputTextId = g.ActiveId;
        SetHoveredID(id);
    }
    if (value_changed)
        return DataTypeApplyOpFromText(data_buf, g.InputTextState.InitialText.Data, data_type, data_ptr, NULL);
    return false;
}

bool ImGui::InputScalar(const char* label, ImGuiDataType data_type, void* data_ptr, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags extra_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;

    char buf[64];
    DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, data_ptr, format);

    bool value_changed = false;
    if ((extra_flags & (ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific)) == 0)
        extra_flags |= ImGuiInputTextFlags_CharsDecimal;
    extra_flags |= ImGuiInputTextFlags_AutoSelectAll;

    if (step != NULL)
    {
        const float button_size = GetFrameHeight();

        BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()
        PushID(label);
        PushItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));
        if (InputText("", buf, IM_ARRAYSIZE(buf), extra_flags)) // PushId(label) + "" gives us the expected ID from outside point of view
            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialText.Data, data_type, data_ptr, format);
        PopItemWidth();

        // Step buttons
        SameLine(0, style.ItemInnerSpacing.x);
        if (ButtonEx("-", ImVec2(button_size, button_size), ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))
        {
            DataTypeApplyOp(data_type, '-', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);
            value_changed = true;
        }
        SameLine(0, style.ItemInnerSpacing.x);
        if (ButtonEx("+", ImVec2(button_size, button_size), ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))
        {
            DataTypeApplyOp(data_type, '+', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);
            value_changed = true;
        }
        SameLine(0, style.ItemInnerSpacing.x);
        TextUnformatted(label, FindRenderedTextEnd(label));

        PopID();
        EndGroup();
    }
    else
    {
        if (InputText(label, buf, IM_ARRAYSIZE(buf), extra_flags))
            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialText.Data, data_type, data_ptr, format);
    }

    return value_changed;
}

bool ImGui::InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags extra_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components);
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= InputScalar("##v", data_type, v, step, step_fast, format, extra_flags);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags extra_flags)
{
    extra_flags |= ImGuiInputTextFlags_CharsScientific;
    return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step>0.0f ? &step : NULL), (void*)(step_fast>0.0f ? &step_fast : NULL), format, extra_flags);
}

bool ImGui::InputFloat2(const char* label, float v[2], const char* format, ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, extra_flags);
}

bool ImGui::InputFloat3(const char* label, float v[3], const char* format, ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, extra_flags);
}

bool ImGui::InputFloat4(const char* label, float v[4], const char* format, ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, extra_flags);
}

// Prefer using "const char* format" directly, which is more flexible and consistent with other API.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputFloat(label, v, step, step_fast, format, extra_flags);
}

bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, extra_flags);
}

bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, extra_flags);
}

bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, extra_flags);
}
#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags extra_flags)
{
    // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
    const char* format = (extra_flags & ImGuiInputTextFlags_CharsHexadecimal) ? "%08X" : "%d";
    return InputScalar(label, ImGuiDataType_S32, (void*)v, (void*)(step>0 ? &step : NULL), (void*)(step_fast>0 ? &step_fast : NULL), format, extra_flags);
}

bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, "%d", extra_flags);
}

bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, "%d", extra_flags);
}

bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, "%d", extra_flags);
}

bool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags extra_flags)
{
    extra_flags |= ImGuiInputTextFlags_CharsScientific;
    return InputScalar(label, ImGuiDataType_Double, (void*)v, (void*)(step>0.0 ? &step : NULL), (void*)(step_fast>0.0 ? &step_fast : NULL), format, extra_flags);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputText, InputTextMultiline
//-------------------------------------------------------------------------
// - InputText()
// - InputTextMultiline()
// - InputTextEx() [Internal]
//-------------------------------------------------------------------------

bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()
    return InputTextEx(label, buf, (int)buf_size, ImVec2(0,0), flags, callback, user_data);
}

bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    return InputTextEx(label, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);
}

static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)
{
    int line_count = 0;
    const char* s = text_begin;
    while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding
        if (c == '\n')
            line_count++;
    s--;
    if (s[0] != '\n' && s[0] != '\r')
        line_count++;
    *out_text_end = s;
    return line_count;
}

static ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)
{
    ImFont* font = GImGui->Font;
    const float line_height = GImGui->FontSize;
    const float scale = line_height / font->FontSize;

    ImVec2 text_size = ImVec2(0,0);
    float line_width = 0.0f;

    const ImWchar* s = text_begin;
    while (s < text_end)
    {
        unsigned int c = (unsigned int)(*s++);
        if (c == '\n')
        {
            text_size.x = ImMax(text_size.x, line_width);
            text_size.y += line_height;
            line_width = 0.0f;
            if (stop_on_new_line)
                break;
            continue;
        }
        if (c == '\r')
            continue;

        const float char_width = font->GetCharAdvance((ImWchar)c) * scale;
        line_width += char_width;
    }

    if (text_size.x < line_width)
        text_size.x = line_width;

    if (out_offset)
        *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n

    if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n
        text_size.y += line_height;

    if (remaining)
        *remaining = s;

    return text_size;
}

// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)
namespace ImGuiStb
{

static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }
static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->TextW[idx]; }
static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx+char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }
static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }
static ImWchar STB_TEXTEDIT_NEWLINE = '\n';
static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)
{
    const ImWchar* text = obj->TextW.Data;
    const ImWchar* text_remaining = NULL;
    const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);
    r->x0 = 0.0f;
    r->x1 = size.x;
    r->baseline_y_delta = size.y;
    r->ymin = 0.0f;
    r->ymax = size.y;
    r->num_chars = (int)(text_remaining - (text + line_start_idx));
}

static bool is_separator(unsigned int c)                                        { return ImCharIsBlankW(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }
static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->TextW[idx-1] ) && !is_separator( obj->TextW[idx] ) ) : 1; }
static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }
#ifdef __APPLE__    // FIXME: Move setting to IO structure
static int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator( obj->TextW[idx-1] ) && is_separator( obj->TextW[idx] ) ) : 1; }
static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }
#else
static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }
#endif
#define STB_TEXTEDIT_MOVEWORDLEFT   STB_TEXTEDIT_MOVEWORDLEFT_IMPL    // They need to be #define for stb_textedit.h
#define STB_TEXTEDIT_MOVEWORDRIGHT  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

static void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)
{
    ImWchar* dst = obj->TextW.Data + pos;

    // We maintain our buffer length in both UTF-8 and wchar formats
    obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);
    obj->CurLenW -= n;

    // Offset remaining text (FIXME-OPT: Use memmove)
    const ImWchar* src = obj->TextW.Data + pos + n;
    while (ImWchar c = *src++)
        *dst++ = c;
    *dst = '\0';
}

static bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)
{
    const bool is_resizable = (obj->UserFlags & ImGuiInputTextFlags_CallbackResize) != 0;
    const int text_len = obj->CurLenW;
    IM_ASSERT(pos <= text_len);

    const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);
    if (!is_resizable && (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA))
        return false;

    // Grow internal buffer if needed
    if (new_text_len + text_len + 1 > obj->TextW.Size)
    {
        if (!is_resizable)
            return false;
        IM_ASSERT(text_len < obj->TextW.Size);
        obj->TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);
    }

    ImWchar* text = obj->TextW.Data;
    if (pos != text_len)
        memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));
    memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));

    obj->CurLenW += new_text_len;
    obj->CurLenA += new_text_len_utf8;
    obj->TextW[obj->CurLenW] = '\0';

    return true;
}

// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)
#define STB_TEXTEDIT_K_LEFT         0x10000 // keyboard input to move cursor left
#define STB_TEXTEDIT_K_RIGHT        0x10001 // keyboard input to move cursor right
#define STB_TEXTEDIT_K_UP           0x10002 // keyboard input to move cursor up
#define STB_TEXTEDIT_K_DOWN         0x10003 // keyboard input to move cursor down
#define STB_TEXTEDIT_K_LINESTART    0x10004 // keyboard input to move cursor to start of line
#define STB_TEXTEDIT_K_LINEEND      0x10005 // keyboard input to move cursor to end of line
#define STB_TEXTEDIT_K_TEXTSTART    0x10006 // keyboard input to move cursor to start of text
#define STB_TEXTEDIT_K_TEXTEND      0x10007 // keyboard input to move cursor to end of text
#define STB_TEXTEDIT_K_DELETE       0x10008 // keyboard input to delete selection or character under cursor
#define STB_TEXTEDIT_K_BACKSPACE    0x10009 // keyboard input to delete selection or character left of cursor
#define STB_TEXTEDIT_K_UNDO         0x1000A // keyboard input to perform undo
#define STB_TEXTEDIT_K_REDO         0x1000B // keyboard input to perform redo
#define STB_TEXTEDIT_K_WORDLEFT     0x1000C // keyboard input to move cursor left one word
#define STB_TEXTEDIT_K_WORDRIGHT    0x1000D // keyboard input to move cursor right one word
#define STB_TEXTEDIT_K_SHIFT        0x20000

#define STB_TEXTEDIT_IMPLEMENTATION
#include "imstb_textedit.h"

}

void ImGuiInputTextState::OnKeyPressed(int key)
{
    stb_textedit_key(this, &StbState, key);
    CursorFollow = true;
    CursorAnimReset();
}

ImGuiInputTextCallbackData::ImGuiInputTextCallbackData()
{
    memset(this, 0, sizeof(*this));
}

// Public API to manipulate UTF-8 text
// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)
// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.
void ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count)
{
    IM_ASSERT(pos + bytes_count <= BufTextLen);
    char* dst = Buf + pos;
    const char* src = Buf + pos + bytes_count;
    while (char c = *src++)
        *dst++ = c;
    *dst = '\0';

    if (CursorPos + bytes_count >= pos)
        CursorPos -= bytes_count;
    else if (CursorPos >= pos)
        CursorPos = pos;
    SelectionLoopCallback = SelectionEnd = CursorPos;
    BufDirty = true;
    BufTextLen -= bytes_count;
}

void ImGuiInputTextCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)
{
    const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;
    const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);
    if (new_text_len + BufTextLen >= BufSize)
    {
        if (!is_resizable)
            return;

        // Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the midly similar code (until we remove the U16 buffer alltogether!)
        ImGuiContext& g = *GImGui;
        ImGuiInputTextState* edit_state = &g.InputTextState;
        IM_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);
        IM_ASSERT(Buf == edit_state->TempBuffer.Data);
        int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;
        edit_state->TempBuffer.reserve(new_buf_size + 1);
        Buf = edit_state->TempBuffer.Data;
        BufSize = edit_state->BufCapacityA = new_buf_size;
    }

    if (BufTextLen != pos)
        memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));
    memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));
    Buf[BufTextLen + new_text_len] = '\0';

    if (CursorPos >= pos)
        CursorPos += new_text_len;
    SelectionLoopCallback = SelectionEnd = CursorPos;
    BufDirty = true;
    BufTextLen += new_text_len;
}

// Return false to discard a character.
static bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    unsigned int c = *p_char;

    if (c < 128 && c != ' ' && !isprint((int)(c & 0xFF)))
    {
        bool pass = false;
        pass |= (c == '\n' && (flags & ImGuiInputTextFlags_Multiline));
        pass |= (c == '\t' && (flags & ImGuiInputTextFlags_AllowTabInput));
        if (!pass)
            return false;
    }

    if (c >= 0xE000 && c <= 0xF8FF) // Filter private Unicode range. I don't imagine anybody would want to input them. GLFW on OSX seems to send private characters for special keys like arrow keys.
        return false;

    if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific))
    {
        if (flags & ImGuiInputTextFlags_CharsDecimal)
            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsScientific)
            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsHexadecimal)
            if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsUppercase)
            if (c >= 'a' && c <= 'z')
                *p_char = (c += (unsigned int)('A'-'a'));

        if (flags & ImGuiInputTextFlags_CharsNoBlank)
            if (ImCharIsBlankW(c))
                return false;
    }

    if (flags & ImGuiInputTextFlags_CallbackCharFilter)
    {
        ImGuiInputTextCallbackData callback_data;
        memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));
        callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;
        callback_data.EventChar = (ImWchar)c;
        callback_data.Flags = flags;
        callback_data.UserData = user_data;
        if (callback(&callback_data) != 0)
            return false;
        *p_char = callback_data.EventChar;
        if (!callback_data.EventChar)
            return false;
    }

    return true;
}

// Edit a string of text
// - buf_size account for the zero-terminator, so a buf_size of 6 can hold "Hello" but not "Hello!".
//   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match 
//   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.
// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.
// - If you want to use ImGui::InputText() with std::string, see misc/cpp/imgui_stdlib.h
// (FIXME: Rather messy function partly because we are doing UTF8 > u16 > UTF8 conversions on the go to more easily handle stb_textedit calls. Ideally we should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)
bool ImGui::InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)
    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)

    ImGuiContext& g = *GImGui;
    const ImGuiIO& io = g.IO;
    const ImGuiStyle& style = g.Style;

    const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;
    const bool is_editable = (flags & ImGuiInputTextFlags_ReadOnly) == 0;
    const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;
    const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;
    const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;
    if (is_resizable)
        IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!

    if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope, 
        BeginGroup();
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? GetTextLineHeight() * 8.0f : label_size.y) + style.FramePadding.y*2.0f); // Arbitrary default of 8 lines high for multi-line
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));

    ImGuiWindow* draw_window = window;
    if (is_multiline)
    {
        ItemAdd(total_bb, id, &frame_bb);
        if (!BeginChildFrame(id, frame_bb.GetSize()))
        {
            EndChildFrame();
            EndGroup();
            return false;
        }
        draw_window = GetCurrentWindow();
        draw_window->DC.NavLayerActiveMaskNext |= draw_window->DC.NavLayerCurrentMask; // This is to ensure that EndChild() will display a navigation highlight
        size.x -= draw_window->ScrollbarSizes.x;
    }
    else
    {
        ItemSize(total_bb, style.FramePadding.y);
        if (!ItemAdd(total_bb, id, &frame_bb))
            return false;
    }
    const bool hovered = ItemHoverable(frame_bb, id);
    if (hovered)
        g.MouseCursor = ImGuiMouseCursor_TextInput;

    // Password pushes a temporary font with only a fallback glyph
    if (is_password)
    {
        const ImFontGlyph* glyph = g.Font->FindGlyph('*');
        ImFont* password_font = &g.InputTextPasswordFont;
        password_font->FontSize = g.Font->FontSize;
        password_font->Scale = g.Font->Scale;
        password_font->DisplayOffset = g.Font->DisplayOffset;
        password_font->Ascent = g.Font->Ascent;
        password_font->Descent = g.Font->Descent;
        password_font->ContainerAtlas = g.Font->ContainerAtlas;
        password_font->FallbackGlyph = glyph;
        password_font->FallbackAdvanceX = glyph->AdvanceX;
        IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());
        PushFont(password_font);
    }

    // NB: we are only allowed to access 'edit_state' if we are the active widget.
    ImGuiInputTextState& edit_state = g.InputTextState;

    const bool focus_requested = FocusableItemRegister(window, id, (flags & (ImGuiInputTextFlags_CallbackCompletion|ImGuiInputTextFlags_AllowTabInput)) == 0);    // Using completion callback disable keyboard tabbing
    const bool focus_requested_by_code = focus_requested && (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent);
    const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;

    const bool user_clicked = hovered && io.MouseClicked[0];
    const bool user_scrolled = is_multiline && g.ActiveId == 0 && edit_state.ID == id && g.ActiveIdPreviousFrame == draw_window->GetIDNoKeepAlive("#SCROLLY");
    const bool user_nav_input_start = (g.ActiveId != id) && ((g.NavInputId == id) || (g.NavActivateId == id && g.NavInputSource == ImGuiInputSource_NavKeyboard));

    bool clear_active_id = false;

    bool select_all = (g.ActiveId != id) && ((flags & ImGuiInputTextFlags_AutoSelectAll) != 0 || user_nav_input_start) && (!is_multiline);
    if (focus_requested || user_clicked || user_scrolled || user_nav_input_start)
    {
        if (g.ActiveId != id)
        {
            // LoopCallback edition
            // Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)
            // From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)
            const int prev_len_w = edit_state.CurLenW;
            const int init_buf_len = (int)strlen(buf);
            edit_state.TextW.resize(buf_size+1);             // wchar count <= UTF-8 count. we use +1 to make sure that .Data isn't NULL so it doesn't crash.
            edit_state.InitialText.resize(init_buf_len + 1); // UTF-8. we use +1 to make sure that .Data isn't NULL so it doesn't crash.
            memcpy(edit_state.InitialText.Data, buf, init_buf_len + 1);
            const char* buf_end = NULL;
            edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, buf_size, buf, NULL, &buf_end);
            edit_state.CurLenA = (int)(buf_end - buf); // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.
            edit_state.CursorAnimReset();

            // Preserve cursor position and undo/redo stack if we come back to same widget
            // FIXME: We should probably compare the whole buffer to be on the safety side. Comparing buf (utf8) and edit_state.Text (wchar).
            const bool recycle_state = (edit_state.ID == id) && (prev_len_w == edit_state.CurLenW);
            if (recycle_state)
            {
                // Recycle existing cursor/selection/undo stack but clamp position
                // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
                edit_state.CursorClamp();
            }
            else
            {
                edit_state.ID = id;
                edit_state.ScrollX = 0.0f;
                stb_textedit_initialize_state(&edit_state.StbState, !is_multiline);
                if (!is_multiline && focus_requested_by_code)
                    select_all = true;
            }
            if (flags & ImGuiInputTextFlags_AlwaysInsertMode)
                edit_state.StbState.insert_mode = true;
            if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))
                select_all = true;
        }
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        if (!is_multiline && !(flags & ImGuiInputTextFlags_CallbackHistory))
            g.ActiveIdAllowNavDirFlags |= ((1 << ImGuiDir_Up) | (1 << ImGuiDir_Down));
    }
    else if (io.MouseClicked[0])
    {
        // Release focus when we click outside
        clear_active_id = true;
    }

    bool value_changed = false;
    bool enter_pressed = false;
    int backup_current_text_length = 0;

    if (g.ActiveId == id)
    {
        if (!is_editable && !g.ActiveIdIsJustActivated)
        {
            // When read-only we always use the live data passed to the function
            edit_state.TextW.resize(buf_size+1);
            const char* buf_end = NULL;
            edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, edit_state.TextW.Size, buf, NULL, &buf_end);
            edit_state.CurLenA = (int)(buf_end - buf);
            edit_state.CursorClamp();
        }

        backup_current_text_length = edit_state.CurLenA;
        edit_state.BufCapacityA = buf_size;
        edit_state.UserFlags = flags;
        edit_state.UserCallback = callback;
        edit_state.UserCallbackData = callback_user_data;

        // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
        // Down the line we should have a cleaner library-wide concept of Selected vs Active.
        g.ActiveIdAllowOverlap = !io.MouseDown[0];
        g.WantTextInputNextFrame = 1;

        // Edit in progress
        const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + edit_state.ScrollX;
        const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y) : (g.FontSize*0.5f));

        const bool is_osx = io.ConfigMacOSXBehaviors;
        if (select_all || (hovered && !is_osx && io.MouseDoubleClicked[0]))
        {
            edit_state.SelectAll();
            edit_state.SelectedAllMouseLock = true;
        }
        else if (hovered && is_osx && io.MouseDoubleClicked[0])
        {
            // Double-click select a word only, OS X style (by simulating keystrokes)
            edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);
            edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
        }
        else if (io.MouseClicked[0] && !edit_state.SelectedAllMouseLock)
        {
            if (hovered)
            {
                stb_textedit_click(&edit_state, &edit_state.StbState, mouse_x, mouse_y);
                edit_state.CursorAnimReset();
            }
        }
        else if (io.MouseDown[0] && !edit_state.SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))
        {
            stb_textedit_drag(&edit_state, &edit_state.StbState, mouse_x, mouse_y);
            edit_state.CursorAnimReset();
            edit_state.CursorFollow = true;
        }
        if (edit_state.SelectedAllMouseLock && !io.MouseDown[0])
            edit_state.SelectedAllMouseLock = false;

        if (io.InputCharacters[0])
        {
            // Process text input (before we check for Return because using some IME will effectively send a Return?)
            // We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
            bool ignore_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);
            if (!ignore_inputs && is_editable && !user_nav_input_start)
                for (int n = 0; n < IM_ARRAYSIZE(io.InputCharacters) && io.InputCharacters[n]; n++)
                {
                    // Insert character if they pass filtering
                    unsigned int c = (unsigned int)io.InputCharacters[n];
                    if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                        edit_state.OnKeyPressed((int)c);
                }

            // Consume characters
            memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));
        }
    }

    bool cancel_edit = false;
    if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)
    {
        // Handle key-presses
        const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);
        const bool is_osx = io.ConfigMacOSXBehaviors;
        const bool is_shortcut_key = (is_osx ? (io.KeySuper && !io.KeyCtrl) : (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift; // OS X style: Shortcuts using Cmd/Super instead of Ctrl
        const bool is_osx_shift_shortcut = is_osx && io.KeySuper && io.KeyShift && !io.KeyCtrl && !io.KeyAlt;
        const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl
        const bool is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text LoopCallback and End using Cmd+Arrows instead of Home/End
        const bool is_ctrl_key_only = io.KeyCtrl && !io.KeyShift && !io.KeyAlt && !io.KeySuper;
        const bool is_shift_key_only = io.KeyShift && !io.KeyCtrl && !io.KeyAlt && !io.KeySuper;

        const bool is_cut   = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_X)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Delete))) && is_editable && !is_password && (!is_multiline || edit_state.HasSelection());
        const bool is_copy  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_C)) || (is_ctrl_key_only  && IsKeyPressedMap(ImGuiKey_Insert))) && !is_password && (!is_multiline || edit_state.HasSelection());
        const bool is_paste = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_V)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Insert))) && is_editable;
        const bool is_undo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Z)) && is_editable && is_undoable);
        const bool is_redo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Y)) || (is_osx_shift_shortcut && IsKeyPressedMap(ImGuiKey_Z))) && is_editable && is_undoable;

        if (IsKeyPressedMap(ImGuiKey_LeftArrow))                        { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_RightArrow))                  { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Home))                        { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_End))                         { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Delete) && is_editable)       { edit_state.OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Backspace) && is_editable)
        {
            if (!edit_state.HasSelection())
            {
                if (is_wordmove_key_down) edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT|STB_TEXTEDIT_K_SHIFT);
                else if (is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl) edit_state.OnKeyPressed(STB_TEXTEDIT_K_LINESTART|STB_TEXTEDIT_K_SHIFT);
            }
            edit_state.OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);
        }
        else if (IsKeyPressedMap(ImGuiKey_Enter))
        {
            bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;
            if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))
            {
                enter_pressed = clear_active_id = true;
            }
            else if (is_editable)
            {
                unsigned int c = '\n'; // Insert new line
                if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                    edit_state.OnKeyPressed((int)c);
            }
        }
        else if ((flags & ImGuiInputTextFlags_AllowTabInput) && IsKeyPressedMap(ImGuiKey_Tab) && !io.KeyCtrl && !io.KeyShift && !io.KeyAlt && is_editable)
        {
            unsigned int c = '\t'; // Insert TAB
            if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                edit_state.OnKeyPressed((int)c);
        }
        else if (IsKeyPressedMap(ImGuiKey_Escape))
        {
            clear_active_id = cancel_edit = true;
        }
        else if (is_undo || is_redo)
        {
            edit_state.OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);
            edit_state.ClearSelection();
        }
        else if (is_shortcut_key && IsKeyPressedMap(ImGuiKey_A))
        {
            edit_state.SelectAll();
            edit_state.CursorFollow = true;
        }
        else if (is_cut || is_copy)
        {
            // Cut, Copy
            if (io.SetClipboardTextFn)
            {
                const int ib = edit_state.HasSelection() ? ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end) : 0;
                const int ie = edit_state.HasSelection() ? ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end) : edit_state.CurLenW;
                edit_state.TempBuffer.resize((ie-ib) * 4 + 1);
                ImTextStrToUtf8(edit_state.TempBuffer.Data, edit_state.TempBuffer.Size, edit_state.TextW.Data+ib, edit_state.TextW.Data+ie);
                SetClipboardText(edit_state.TempBuffer.Data);
            }
            if (is_cut)
            {
                if (!edit_state.HasSelection())
                    edit_state.SelectAll();
                edit_state.CursorFollow = true;
                stb_textedit_cut(&edit_state, &edit_state.StbState);
            }
        }
        else if (is_paste)
        {
            if (const char* clipboard = GetClipboardText())
            {
                // Filter pasted buffer
                const int clipboard_len = (int)strlen(clipboard);
                ImWchar* clipboard_filtered = (ImWchar*)MemAlloc((clipboard_len+1) * sizeof(ImWchar));
                int clipboard_filtered_len = 0;
                for (const char* s = clipboard; *s; )
                {
                    unsigned int c;
                    s += ImTextCharFromUtf8(&c, s, NULL);
                    if (c == 0)
                        break;
                    if (c >= 0x10000 || !InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                        continue;
                    clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;
                }
                clipboard_filtered[clipboard_filtered_len] = 0;
                if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation
                {
                    stb_textedit_paste(&edit_state, &edit_state.StbState, clipboard_filtered, clipboard_filtered_len);
                    edit_state.CursorFollow = true;
                }
                MemFree(clipboard_filtered);
            }
        }
    }

    if (g.ActiveId == id)
    {
        const char* apply_new_text = NULL;
        int apply_new_text_length = 0;
        if (cancel_edit)
        {
            // Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
            if (is_editable && strcmp(buf, edit_state.InitialText.Data) != 0)
            {
                apply_new_text = edit_state.InitialText.Data;
                apply_new_text_length = edit_state.InitialText.Size - 1;
            }
        }

        // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
        // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail. Also this allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage.
        bool apply_edit_back_to_user_buffer = !cancel_edit || (enter_pressed && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);
        if (apply_edit_back_to_user_buffer)
        {
            // Apply new value immediately - copy modified buffer back
            // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
            // FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
            // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.
            if (is_editable)
            {
                edit_state.TempBuffer.resize(edit_state.TextW.Size * 4 + 1);
                ImTextStrToUtf8(edit_state.TempBuffer.Data, edit_state.TempBuffer.Size, edit_state.TextW.Data, NULL);
            }

            // User callback
            if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways)) != 0)
            {
                IM_ASSERT(callback != NULL);

                // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
                ImGuiInputTextFlags event_flag = 0;
                ImGuiKey event_key = ImGuiKey_COUNT;
                if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && IsKeyPressedMap(ImGuiKey_Tab))
                {
                    event_flag = ImGuiInputTextFlags_CallbackCompletion;
                    event_key = ImGuiKey_Tab;
                }
                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_UpArrow))
                {
                    event_flag = ImGuiInputTextFlags_CallbackHistory;
                    event_key = ImGuiKey_UpArrow;
                }
                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_DownArrow))
                {
                    event_flag = ImGuiInputTextFlags_CallbackHistory;
                    event_key = ImGuiKey_DownArrow;
                }
                else if (flags & ImGuiInputTextFlags_CallbackAlways)
                    event_flag = ImGuiInputTextFlags_CallbackAlways;

                if (event_flag)
                {
                    ImGuiInputTextCallbackData callback_data;
                    memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));
                    callback_data.EventFlag = event_flag;
                    callback_data.Flags = flags;
                    callback_data.UserData = callback_user_data;

                    callback_data.EventKey = event_key;
                    callback_data.Buf = edit_state.TempBuffer.Data;
                    callback_data.BufTextLen = edit_state.CurLenA;
                    callback_data.BufSize = edit_state.BufCapacityA;
                    callback_data.BufDirty = false;

                    // We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
                    ImWchar* text = edit_state.TextW.Data;
                    const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.cursor);
                    const int utf8_selection_start = callback_data.SelectionLoopCallback = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_start);
                    const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_end);

                    // Call user code
                    callback(&callback_data);

                    // Read back what user may have modified
                    IM_ASSERT(callback_data.Buf == edit_state.TempBuffer.Data);  // Invalid to modify those fields
                    IM_ASSERT(callback_data.BufSize == edit_state.BufCapacityA);
                    IM_ASSERT(callback_data.Flags == flags);
                    if (callback_data.CursorPos != utf8_cursor_pos)            { edit_state.StbState.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos); edit_state.CursorFollow = true; }
                    if (callback_data.SelectionLoopCallback != utf8_selection_start)  { edit_state.StbState.select_start = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionLoopCallback); }
                    if (callback_data.SelectionEnd != utf8_selection_end)      { edit_state.StbState.select_end = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd); }
                    if (callback_data.BufDirty)
                    {
                        IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
                        if (callback_data.BufTextLen > backup_current_text_length && is_resizable)
                            edit_state.TextW.resize(edit_state.TextW.Size + (callback_data.BufTextLen - backup_current_text_length));
                        edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, edit_state.TextW.Size, callback_data.Buf, NULL);
                        edit_state.CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()
                        edit_state.CursorAnimReset();
                    }
                }
            }

            // Will copy result string if modified
            if (is_editable && strcmp(edit_state.TempBuffer.Data, buf) != 0)
            {
                apply_new_text = edit_state.TempBuffer.Data;
                apply_new_text_length = edit_state.CurLenA;
            }
        }

        // Copy result to user buffer
        if (apply_new_text)
        {
            IM_ASSERT(apply_new_text_length >= 0);
            if (backup_current_text_length != apply_new_text_length && is_resizable)
            {
                ImGuiInputTextCallbackData callback_data;
                callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;
                callback_data.Flags = flags;
                callback_data.Buf = buf;
                callback_data.BufTextLen = apply_new_text_length;
                callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);
                callback_data.UserData = callback_user_data;
                callback(&callback_data);
                buf = callback_data.Buf;
                buf_size = callback_data.BufSize;
                apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);
                IM_ASSERT(apply_new_text_length <= buf_size);
            }

            // If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.
            ImStrncpy(buf, edit_state.TempBuffer.Data, ImMin(apply_new_text_length + 1, buf_size));
            value_changed = true;
        }

        // Clear temporary user storage
        edit_state.UserFlags = 0;
        edit_state.UserCallback = NULL;
        edit_state.UserCallbackData = NULL;
    }

    // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
    if (clear_active_id && g.ActiveId == id)
        ClearActiveID();

    // Render
    // Select which buffer we are going to display. When ImGuiInputTextFlags_NoLiveEdit is set 'buf' might still be the old value. We set buf to NULL to prevent accidental usage from now on.
    const char* buf_display = (g.ActiveId == id && is_editable) ? edit_state.TempBuffer.Data : buf; buf = NULL;

    // Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line
    // without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.
    // Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.
    const int buf_display_max_length = 2 * 1024 * 1024;

    if (!is_multiline)
    {
        RenderNavHighlight(frame_bb, id);
        RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    }

    const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size
    ImVec2 render_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;
    ImVec2 text_size(0.f, 0.f);
    const bool is_currently_scrolling = (edit_state.ID == id && is_multiline && g.ActiveId == draw_window->GetIDNoKeepAlive("#SCROLLY"));
    if (g.ActiveId == id || is_currently_scrolling)
    {
        edit_state.CursorAnim += io.DeltaTime;

        // This is going to be messy. We need to:
        // - Display the text (this alone can be more easily clipped)
        // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
        // - Measure text height (for scrollbar)
        // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
        // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
        const ImWchar* text_begin = edit_state.TextW.Data;
        ImVec2 cursor_offset, select_start_offset;

        {
            // Count lines + find lines numbers straddling 'cursor' and 'select_start' position.
            const ImWchar* searches_input_ptr[2];
            searches_input_ptr[0] = text_begin + edit_state.StbState.cursor;
            searches_input_ptr[1] = NULL;
            int searches_remaining = 1;
            int searches_result_line_number[2] = { -1, -999 };
            if (edit_state.StbState.select_start != edit_state.StbState.select_end)
            {
                searches_input_ptr[1] = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);
                searches_result_line_number[1] = -1;
                searches_remaining++;
            }

            // Iterate all lines to find our line numbers
            // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
            searches_remaining += is_multiline ? 1 : 0;
            int line_count = 0;
            //for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bits
            for (const ImWchar* s = text_begin; *s != 0; s++)
                if (*s == '\n')
                {
                    line_count++;
                    if (searches_result_line_number[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_number[0] = line_count; if (--searches_remaining <= 0) break; }
                    if (searches_result_line_number[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_number[1] = line_count; if (--searches_remaining <= 0) break; }
                }
            line_count++;
            if (searches_result_line_number[0] == -1) searches_result_line_number[0] = line_count;
            if (searches_result_line_number[1] == -1) searches_result_line_number[1] = line_count;

            // Calculate 2d position by finding the beginning of the line and measuring distance
            cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;
            cursor_offset.y = searches_result_line_number[0] * g.FontSize;
            if (searches_result_line_number[1] >= 0)
            {
                select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;
                select_start_offset.y = searches_result_line_number[1] * g.FontSize;
            }

            // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
            if (is_multiline)
                text_size = ImVec2(size.x, line_count * g.FontSize);
        }

        // Scroll
        if (edit_state.CursorFollow)
        {
            // Horizontal scroll in chunks of quarter width
            if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))
            {
                const float scroll_increment_x = size.x * 0.25f;
                if (cursor_offset.x < edit_state.ScrollX)
                    edit_state.ScrollX = (float)(int)ImMax(0.0f, cursor_offset.x - scroll_increment_x);
                else if (cursor_offset.x - size.x >= edit_state.ScrollX)
                    edit_state.ScrollX = (float)(int)(cursor_offset.x - size.x + scroll_increment_x);
            }
            else
            {
                edit_state.ScrollX = 0.0f;
            }

            // Vertical scroll
            if (is_multiline)
            {
                float scroll_y = draw_window->Scroll.y;
                if (cursor_offset.y - g.FontSize < scroll_y)
                    scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);
                else if (cursor_offset.y - size.y >= scroll_y)
                    scroll_y = cursor_offset.y - size.y;
                draw_window->DC.CursorPos.y += (draw_window->Scroll.y - scroll_y);   // To avoid a frame of lag
                draw_window->Scroll.y = scroll_y;
                render_pos.y = draw_window->DC.CursorPos.y;
            }
        }
        edit_state.CursorFollow = false;
        const ImVec2 render_scroll = ImVec2(edit_state.ScrollX, 0.0f);

        // Draw selection
        if (edit_state.StbState.select_start != edit_state.StbState.select_end)
        {
            const ImWchar* text_selected_begin = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);
            const ImWchar* text_selected_end = text_begin + ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end);

            float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.
            float bg_offy_dn = is_multiline ? 0.0f : 2.0f;
            ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg);
            ImVec2 rect_pos = render_pos + select_start_offset - render_scroll;
            for (const ImWchar* p = text_selected_begin; p < text_selected_end; )
            {
                if (rect_pos.y > clip_rect.w + g.FontSize)
                    break;
                if (rect_pos.y < clip_rect.y)
                {
                    //p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bits
                    //p = p ? p + 1 : text_selected_end;
                    while (p < text_selected_end)
                        if (*p++ == '\n')
                            break;
                }
                else
                {
                    ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &p, NULL, true);
                    if (rect_size.x <= 0.0f) rect_size.x = (float)(int)(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines
                    ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos +ImVec2(rect_size.x, bg_offy_dn));
                    rect.ClipWith(clip_rect);
                    if (rect.Overlaps(clip_rect))
                        draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);
                }
                rect_pos.x = render_pos.x - render_scroll.x;
                rect_pos.y += g.FontSize;
            }
        }

        const int buf_display_len = edit_state.CurLenA;
        if (is_multiline || buf_display_len < buf_display_max_length)
            draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos - render_scroll, GetColorU32(ImGuiCol_Text), buf_display, buf_display + buf_display_len, 0.0f, is_multiline ? NULL : &clip_rect);

        // Draw blinking cursor
        bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (g.InputTextState.CursorAnim <= 0.0f) || ImFmod(g.InputTextState.CursorAnim, 1.20f) <= 0.80f;
        ImVec2 cursor_screen_pos = render_pos + cursor_offset - render_scroll;
        ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y-g.FontSize+0.5f, cursor_screen_pos.x+1.0f, cursor_screen_pos.y-1.5f);
        if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))
            draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));

        // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
        if (is_editable)
            g.PlatformImePos = ImVec2(cursor_screen_pos.x - 1, cursor_screen_pos.y - g.FontSize);
    }
    else
    {
        // Render text only
        const char* buf_end = NULL;
        if (is_multiline)
            text_size = ImVec2(size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_end) * g.FontSize); // We don't need width
        else
            buf_end = buf_display + strlen(buf_display);
        if (is_multiline || (buf_end - buf_display) < buf_display_max_length)
            draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos, GetColorU32(ImGuiCol_Text), buf_display, buf_end, 0.0f, is_multiline ? NULL : &clip_rect);
    }

    if (is_multiline)
    {
        Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line
        EndChildFrame();
        EndGroup();
    }

    if (is_password)
        PopFont();

    // Log as text
    if (g.LogEnabled && !is_password)
        LogRenderedText(&render_pos, buf_display, NULL);

    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    if (value_changed)
        MarkItemEdited(id);

    if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)
        return enter_pressed;
    else
        return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
//-------------------------------------------------------------------------
// - ColorEdit3()
// - ColorEdit4()
// - ColorPicker3()
// - RenderColorRectWithAlphaCheckerboard() [Internal]
// - ColorPicker4()
// - ColorButton()
// - SetColorEditOptions()
// - ColorTooltip() [Internal]
// - ColorEditOptionsPopup() [Internal]
// - ColorPickerOptionsPopup() [Internal]
//-------------------------------------------------------------------------

bool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)
{
    return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);
}

// Edit colors components (each component in 0.0f..1.0f range).
// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// With typical options: Left-click on colored square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.
bool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float square_sz = GetFrameHeight();
    const float w_extra = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);
    const float w_items_all = CalcItemWidth() - w_extra;
    const char* label_display_end = FindRenderedTextEnd(label);

    BeginGroup();
    PushID(label);

    // If we're not showing any slider there's no point in doing any HSV conversions
    const ImGuiColorEditFlags flags_untouched = flags;
    if (flags & ImGuiColorEditFlags_NoInputs)
        flags = (flags & (~ImGuiColorEditFlags__InputsMask)) | ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_NoOptions;

    // Context menu: display and modify options (before defaults are applied)
    if (!(flags & ImGuiColorEditFlags_NoOptions))
        ColorEditOptionsPopup(col, flags);

    // Read stored options
    if (!(flags & ImGuiColorEditFlags__InputsMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__InputsMask);
    if (!(flags & ImGuiColorEditFlags__DataTypeMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DataTypeMask);
    if (!(flags & ImGuiColorEditFlags__PickerMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__PickerMask);
    flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask));

    const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;
    const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;
    const int components = alpha ? 4 : 3;

    // Convert to the formats we need
    float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };
    if (flags & ImGuiColorEditFlags_HSV)
        ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);
    int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };

    bool value_changed = false;
    bool value_changed_as_float = false;

    if ((flags & (ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_HSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        // RGB/HSV 0..255 Sliders
        const float w_item_one  = ImMax(1.0f, (float)(int)((w_items_all - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));
        const float w_item_last = ImMax(1.0f, (float)(int)(w_items_all - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));

        const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);
        const char* ids[4] = { "##X", "##Y", "##Z", "##W" };
        const char* fmt_table_int[3][4] =
        {
            {   "%3d",   "%3d",   "%3d",   "%3d" }, // Short display
            { "R:%3d", "G:%3d", "B:%3d", "A:%3d" }, // Long display for RGBA
            { "H:%3d", "S:%3d", "V:%3d", "A:%3d" }  // Long display for HSVA
        };
        const char* fmt_table_float[3][4] =
        {
            {   "%0.3f",   "%0.3f",   "%0.3f",   "%0.3f" }, // Short display
            { "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" }, // Long display for RGBA
            { "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" }  // Long display for HSVA
        };
        const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_HSV) ? 2 : 1;

        PushItemWidth(w_item_one);
        for (int n = 0; n < components; n++)
        {
            if (n > 0)
                SameLine(0, style.ItemInnerSpacing.x);
            if (n + 1 == components)
                PushItemWidth(w_item_last);
            if (flags & ImGuiColorEditFlags_Float)
                value_changed = value_changed_as_float = value_changed | DragFloat(ids[n], &f[n], 1.0f/255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);
            else
                value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);
            if (!(flags & ImGuiColorEditFlags_NoOptions))
                OpenPopupOnItemClick("context");
        }
        PopItemWidth();
        PopItemWidth();
    }
    else if ((flags & ImGuiColorEditFlags_HEX) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        // RGB Hexadecimal Input
        char buf[64];
        if (alpha)
            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255), ImClamp(i[3],0,255));
        else
            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255));
        PushItemWidth(w_items_all);
        if (InputText("##Text", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))
        {
            value_changed = true;
            char* p = buf;
            while (*p == '#' || ImCharIsBlankA(*p))
                p++;
            i[0] = i[1] = i[2] = i[3] = 0;
            if (alpha)
                sscanf(p, "%02X%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)
            else
                sscanf(p, "%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");
        PopItemWidth();
    }

    ImGuiWindow* picker_active_window = NULL;
    if (!(flags & ImGuiColorEditFlags_NoSmallPreview))
    {
        if (!(flags & ImGuiColorEditFlags_NoInputs))
            SameLine(0, style.ItemInnerSpacing.x);

        const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);
        if (ColorButton("##ColorButton", col_v4, flags))
        {
            if (!(flags & ImGuiColorEditFlags_NoPicker))
            {
                // Store current color and open a picker
                g.ColorPickerRef = col_v4;
                OpenPopup("picker");
                SetNextWindowPos(window->DC.LastItemRect.GetBL() + ImVec2(-1,style.ItemSpacing.y));
            }
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");

        if (BeginPopup("picker"))
        {
            picker_active_window = g.CurrentWindow;
            if (label != label_display_end)
            {
                TextUnformatted(label, label_display_end);
                Spacing();
            }
            ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;
            ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;
            PushItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?
            value_changed |= ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef.x);
            PopItemWidth();
            EndPopup();
        }
    }

    if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))
    {
        SameLine(0, style.ItemInnerSpacing.x);
        TextUnformatted(label, label_display_end);
    }

    // Convert back
    if (picker_active_window == NULL)
    {
        if (!value_changed_as_float)
            for (int n = 0; n < 4; n++)
                f[n] = i[n] / 255.0f;
        if (flags & ImGuiColorEditFlags_HSV)
            ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
        if (value_changed)
        {
            col[0] = f[0];
            col[1] = f[1];
            col[2] = f[2];
            if (alpha)
                col[3] = f[3];
        }
    }

    PopID();
    EndGroup();

    // Drag and Drop Target
    // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
    if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget())
    {
        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))
        {
            memcpy((float*)col, payload->Data, sizeof(float) * 3);
            value_changed = true;
        }
        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))
        {
            memcpy((float*)col, payload->Data, sizeof(float) * components);
            value_changed = true;
        }
        EndDragDropTarget();
    }

    // When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
    if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)
        window->DC.LastItemId = g.ActiveId;

    if (value_changed)
        MarkItemEdited(window->DC.LastItemId);

    return value_changed;
}

bool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)
{
    float col4[4] = { col[0], col[1], col[2], 1.0f };
    if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))
        return false;
    col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];
    return true;
}

static inline ImU32 ImAlphaBlendColor(ImU32 col_a, ImU32 col_b)
{
    float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;
    int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);
    int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);
    int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);
    return IM_COL32(r, g, b, 0xFF);
}

// Helper for ColorPicker4()
// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.
// I spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding alltogether.
void ImGui::RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, int rounding_corners_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)
    {
        ImU32 col_bg1 = GetColorU32(ImAlphaBlendColor(IM_COL32(204,204,204,255), col));
        ImU32 col_bg2 = GetColorU32(ImAlphaBlendColor(IM_COL32(128,128,128,255), col));
        window->DrawList->AddRectFilled(p_min, p_max, col_bg1, rounding, rounding_corners_flags);

        int yi = 0;
        for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)
        {
            float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);
            if (y2 <= y1)
                continue;
            for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)
            {
                float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);
                if (x2 <= x1)
                    continue;
                int rounding_corners_flags_cell = 0;
                if (y1 <= p_min.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopRight; }
                if (y2 >= p_max.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotRight; }
                rounding_corners_flags_cell &= rounding_corners_flags;
                window->DrawList->AddRectFilled(ImVec2(x1,y1), ImVec2(x2,y2), col_bg2, rounding_corners_flags_cell ? rounding : 0.0f, rounding_corners_flags_cell);
            }
        }
    }
    else
    {
        window->DrawList->AddRectFilled(p_min, p_max, col, rounding, rounding_corners_flags);
    }
}

// Helper for ColorPicker4()
static void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w)
{
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32_BLACK);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32_WHITE);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32_BLACK);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32_WHITE);
}

// Note: ColorPicker4() only accesses 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)
bool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    ImDrawList* draw_list = window->DrawList;

    ImGuiStyle& style = g.Style;
    ImGuiIO& io = g.IO;

    PushID(label);
    BeginGroup();

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
        flags |= ImGuiColorEditFlags_NoSmallPreview;

    // Context menu: display and store options.
    if (!(flags & ImGuiColorEditFlags_NoOptions))
        ColorPickerOptionsPopup(col, flags);

    // Read stored options
    if (!(flags & ImGuiColorEditFlags__PickerMask))
        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__PickerMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__PickerMask;
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask))); // Check that only 1 is selected
    if (!(flags & ImGuiColorEditFlags_NoOptions))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);

    // Setup
    int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;
    bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);
    ImVec2 picker_pos = window->DC.CursorPos;
    float square_sz = GetFrameHeight();
    float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
    float sv_picker_size = ImMax(bars_width * 1, CalcItemWidth() - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box
    float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;
    float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;
    float bars_triangles_half_sz = (float)(int)(bars_width * 0.20f);

    float backup_initial_col[4];
    memcpy(backup_initial_col, col, components * sizeof(float));

    float wheel_thickness = sv_picker_size * 0.08f;
    float wheel_r_outer = sv_picker_size * 0.50f;
    float wheel_r_inner = wheel_r_outer - wheel_thickness;
    ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size*0.5f);

    // Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
    float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);
    ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.
    ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.
    ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.

    float H,S,V;
    ColorConvertRGBtoHSV(col[0], col[1], col[2], H, S, V);

    bool value_changed = false, value_changed_h = false, value_changed_sv = false;

    PushItemFlag(ImGuiItemFlags_NoNav, true);
    if (flags & ImGuiColorEditFlags_PickerHueWheel)
    {
        // Hue wheel + SV triangle logic
        InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));
        if (IsItemActive())
        {
            ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;
            ImVec2 current_off = g.IO.MousePos - wheel_center;
            float initial_dist2 = ImLengthSqr(initial_off);
            if (initial_dist2 >= (wheel_r_inner-1)*(wheel_r_inner-1) && initial_dist2 <= (wheel_r_outer+1)*(wheel_r_outer+1))
            {
                // Interactive with Hue wheel
                H = ImAtan2(current_off.y, current_off.x) / IM_PI*0.5f;
                if (H < 0.0f)
                    H += 1.0f;
                value_changed = value_changed_h = true;
            }
            float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);
            float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);
            if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))
            {
                // Interacting with SV triangle
                ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);
                if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))
                    current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);
                float uu, vv, ww;
                ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);
                V = ImClamp(1.0f - vv, 0.0001f, 1.0f);
                S = ImClamp(uu / V, 0.0001f, 1.0f);
                value_changed = value_changed_sv = true;
            }
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");
    }
    else if (flags & ImGuiColorEditFlags_PickerHueBar)
    {
        // SV rectangle logic
        InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));
        if (IsItemActive())
        {
            S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size-1));
            V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = value_changed_sv = true;
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");

        // Hue bar logic
        SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));
        InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));
        if (IsItemActive())
        {
            H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = value_changed_h = true;
        }
    }

    // Alpha bar logic
    if (alpha_bar)
    {
        SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));
        InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));
        if (IsItemActive())
        {
            col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = true;
        }
    }
    PopItemFlag(); // ImGuiItemFlags_NoNav

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
    {
        SameLine(0, style.ItemInnerSpacing.x);
        BeginGroup();
    }

    if (!(flags & ImGuiColorEditFlags_NoLabel))
    {
        const char* label_display_end = FindRenderedTextEnd(label);
        if (label != label_display_end)
        {
            if ((flags & ImGuiColorEditFlags_NoSidePreview))
                SameLine(0, style.ItemInnerSpacing.x);
            TextUnformatted(label, label_display_end);
        }
    }

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
    {
        PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
        ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
        if ((flags & ImGuiColorEditFlags_NoLabel))
            Text("Current");
        ColorButton("##current", col_v4, (flags & (ImGuiColorEditFlags_HDR|ImGuiColorEditFlags_AlphaPreview|ImGuiColorEditFlags_AlphaPreviewHalf|ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2));
        if (ref_col != NULL)
        {
            Text("Original");
            ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);
            if (ColorButton("##original", ref_col_v4, (flags & (ImGuiColorEditFlags_HDR|ImGuiColorEditFlags_AlphaPreview|ImGuiColorEditFlags_AlphaPreviewHalf|ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2)))
            {
                memcpy(col, ref_col, components * sizeof(float));
                value_changed = true;
            }
        }
        PopItemFlag();
        EndGroup();
    }

    // Convert back color to RGB
    if (value_changed_h || value_changed_sv)
        ColorConvertHSVtoRGB(H >= 1.0f ? H - 10 * 1e-6f : H, S > 0.0f ? S : 10*1e-6f, V > 0.0f ? V : 1e-6f, col[0], col[1], col[2]);

    // R,G,B and H,S,V slider color editor
    bool value_changed_fix_hue_wrap = false;
    if ((flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);
        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;
        ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;
        if (flags & ImGuiColorEditFlags_RGB || (flags & ImGuiColorEditFlags__InputsMask) == 0)
            if (ColorEdit4("##rgb", col, sub_flags | ImGuiColorEditFlags_RGB))
            {
                // FIXME: Hackily differenciating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
                // For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
                value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);
                value_changed = true;
            }
        if (flags & ImGuiColorEditFlags_HSV || (flags & ImGuiColorEditFlags__InputsMask) == 0)
            value_changed |= ColorEdit4("##hsv", col, sub_flags | ImGuiColorEditFlags_HSV);
        if (flags & ImGuiColorEditFlags_HEX || (flags & ImGuiColorEditFlags__InputsMask) == 0)
            value_changed |= ColorEdit4("##hex", col, sub_flags | ImGuiColorEditFlags_HEX);
        PopItemWidth();
    }

    // Try to cancel hue wrap (after ColorEdit4 call), if any
    if (value_changed_fix_hue_wrap)
    {
        float new_H, new_S, new_V;
        ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);
        if (new_H <= 0 && H > 0)
        {
            if (new_V <= 0 && V != new_V)
                ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);
            else if (new_S <= 0)
                ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);
        }
    }

    ImVec4 hue_color_f(1, 1, 1, 1); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);
    ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);
    ImU32 col32_no_alpha = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 1.0f));

    const ImU32 hue_colors[6+1] = { IM_COL32(255,0,0,255), IM_COL32(255,255,0,255), IM_COL32(0,255,0,255), IM_COL32(0,255,255,255), IM_COL32(0,0,255,255), IM_COL32(255,0,255,255), IM_COL32(255,0,0,255) };
    ImVec2 sv_cursor_pos;

    if (flags & ImGuiColorEditFlags_PickerHueWheel)
    {
        // Render Hue Wheel
        const float aeps = 1.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).
        const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);
        for (int n = 0; n < 6; n++)
        {
            const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;
            const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;
            const int vert_start_idx = draw_list->VtxBuffer.Size;
            draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);
            draw_list->PathStroke(IM_COL32_WHITE, false, wheel_thickness);
            const int vert_end_idx = draw_list->VtxBuffer.Size;

            // Paint colors over existing vertices
            ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);
            ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);
            ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, hue_colors[n], hue_colors[n+1]);
        }

        // Render Cursor + preview on Hue Wheel
        float cos_hue_angle = ImCos(H * 2.0f * IM_PI);
        float sin_hue_angle = ImSin(H * 2.0f * IM_PI);
        ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f);
        float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;
        int hue_cursor_segments = ImClamp((int)(hue_cursor_rad / 1.4f), 9, 32);
        draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);
        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad+1, IM_COL32(128,128,128,255), hue_cursor_segments);
        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, IM_COL32_WHITE, hue_cursor_segments);

        // Render SV triangle (rotated according to hue)
        ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);
        ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);
        ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);
        ImVec2 uv_white = GetFontTexUvWhitePixel();
        draw_list->PrimReserve(6, 6);
        draw_list->PrimVtx(tra, uv_white, hue_color32);
        draw_list->PrimVtx(trb, uv_white, hue_color32);
        draw_list->PrimVtx(trc, uv_white, IM_COL32_WHITE);
        draw_list->PrimVtx(tra, uv_white, IM_COL32_BLACK_TRANS);
        draw_list->PrimVtx(trb, uv_white, IM_COL32_BLACK);
        draw_list->PrimVtx(trc, uv_white, IM_COL32_BLACK_TRANS);
        draw_list->AddTriangle(tra, trb, trc, IM_COL32(128,128,128,255), 1.5f);
        sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));
    }
    else if (flags & ImGuiColorEditFlags_PickerHueBar)
    {
        // Render SV Square
        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_WHITE, hue_color32, hue_color32, IM_COL32_WHITE);
        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_BLACK_TRANS, IM_COL32_BLACK_TRANS, IM_COL32_BLACK, IM_COL32_BLACK);
        RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), 0.0f);
        sv_cursor_pos.x = ImClamp((float)(int)(picker_pos.x + ImSaturate(S)     * sv_picker_size + 0.5f), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much
        sv_cursor_pos.y = ImClamp((float)(int)(picker_pos.y + ImSaturate(1 - V) * sv_picker_size + 0.5f), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

        // Render Hue Bar
        for (int i = 0; i < 6; ++i)
            draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), hue_colors[i], hue_colors[i], hue_colors[i + 1], hue_colors[i + 1]);
        float bar0_line_y = (float)(int)(picker_pos.y + H * sv_picker_size + 0.5f);
        RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);
        RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);
    }

    // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
    float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;
    draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, col32_no_alpha, 12);
    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad+1, IM_COL32(128,128,128,255), 12);
    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, IM_COL32_WHITE, 12);

    // Render alpha bar
    if (alpha_bar)
    {
        float alpha = ImSaturate(col[3]);
        ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);
        RenderColorRectWithAlphaCheckerboard(bar1_bb.Min, bar1_bb.Max, IM_COL32(0,0,0,0), bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));
        draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, col32_no_alpha, col32_no_alpha, col32_no_alpha & ~IM_COL32_A_MASK, col32_no_alpha & ~IM_COL32_A_MASK);
        float bar1_line_y = (float)(int)(picker_pos.y + (1.0f - alpha) * sv_picker_size + 0.5f);
        RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);
        RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);
    }

    EndGroup();

    if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)
        value_changed = false;
    if (value_changed)
        MarkItemEdited(window->DC.LastItemId);

    PopID();

    return value_changed;
}

// A little colored square. Return true when clicked.
// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.
// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.
bool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiID id = window->GetID(desc_id);
    float default_size = GetFrameHeight();
    if (size.x == 0.0f)
        size.x = default_size;
    if (size.y == 0.0f)
        size.y = default_size;
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    if (flags & ImGuiColorEditFlags_NoAlpha)
        flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);

    ImVec4 col_without_alpha(col.x, col.y, col.z, 1.0f);
    float grid_step = ImMin(size.x, size.y) / 2.99f;
    float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);
    ImRect bb_inner = bb;
    float off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.
    bb_inner.Expand(off);
    if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col.w < 1.0f)
    {
        float mid_x = (float)(int)((bb_inner.Min.x + bb_inner.Max.x) * 0.5f + 0.5f);
        RenderColorRectWithAlphaCheckerboard(ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawCornerFlags_TopRight| ImDrawCornerFlags_BotRight);
        window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_without_alpha), rounding, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotLeft);
    }
    else
    {
        // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
        ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col : col_without_alpha;
        if (col_source.w < 1.0f)
            RenderColorRectWithAlphaCheckerboard(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);
        else
            window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding, ImDrawCornerFlags_All);
    }
    RenderNavHighlight(bb, id);
    if (g.Style.FrameBorderSize > 0.0f)
        RenderFrameBorder(bb.Min, bb.Max, rounding);
    else
        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border

    // Drag and Drop Source
    // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
    if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())
    {
        if (flags & ImGuiColorEditFlags_NoAlpha)
            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col, sizeof(float) * 3, ImGuiCond_Once);
        else
            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col, sizeof(float) * 4, ImGuiCond_Once);
        ColorButton(desc_id, col, flags);
        SameLine();
        TextUnformatted("Color");
        EndDragDropSource();
    }

    // Tooltip
    if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered)
        ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));

    if (pressed)
        MarkItemEdited(id);

    return pressed;
}

void ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)
{
    ImGuiContext& g = *GImGui;
    if ((flags & ImGuiColorEditFlags__InputsMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__InputsMask;
    if ((flags & ImGuiColorEditFlags__DataTypeMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DataTypeMask;
    if ((flags & ImGuiColorEditFlags__PickerMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__PickerMask;
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__InputsMask)));   // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__DataTypeMask))); // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask)));   // Check only 1 option is selected
    g.ColorEditOptions = flags;
}

// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
void ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)
{
    ImGuiContext& g = *GImGui;

    int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
    BeginTooltipEx(0, true);

    const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;
    if (text_end > text)
    {
        TextUnformatted(text, text_end);
        Separator();
    }

    ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);
    ColorButton("##preview", ImVec4(col[0], col[1], col[2], col[3]), (flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);
    SameLine();
    if (flags & ImGuiColorEditFlags_NoAlpha)
        Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);
    else
        Text("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);
    EndTooltip();
}

void ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)
{
    bool allow_opt_inputs = !(flags & ImGuiColorEditFlags__InputsMask);
    bool allow_opt_datatype = !(flags & ImGuiColorEditFlags__DataTypeMask);
    if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))
        return;
    ImGuiContext& g = *GImGui;
    ImGuiColorEditFlags opts = g.ColorEditOptions;
    if (allow_opt_inputs)
    {
        if (RadioButton("RGB", (opts & ImGuiColorEditFlags_RGB) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_RGB;
        if (RadioButton("HSV", (opts & ImGuiColorEditFlags_HSV) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HSV;
        if (RadioButton("HEX", (opts & ImGuiColorEditFlags_HEX) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HEX;
    }
    if (allow_opt_datatype)
    {
        if (allow_opt_inputs) Separator();
        if (RadioButton("0..255",     (opts & ImGuiColorEditFlags_Uint8) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Uint8;
        if (RadioButton("0.00..1.00", (opts & ImGuiColorEditFlags_Float) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Float;
    }

    if (allow_opt_inputs || allow_opt_datatype)
        Separator();
    if (Button("Copy as..", ImVec2(-1,0)))
        OpenPopup("Copy");
    if (BeginPopup("Copy"))
    {
        int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
        char buf[64];
        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
        if (Selectable(buf))
            SetClipboardText(buf);
        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%d,%d,%d,%d)", cr, cg, cb, ca);
        if (Selectable(buf))
            SetClipboardText(buf);
        if (flags & ImGuiColorEditFlags_NoAlpha)
            ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X", cr, cg, cb);
        else
            ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X%02X", cr, cg, cb, ca);
        if (Selectable(buf))
            SetClipboardText(buf);
        EndPopup();
    }

    g.ColorEditOptions = opts;
    EndPopup();
}

void ImGui::ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags)
{
    bool allow_opt_picker = !(flags & ImGuiColorEditFlags__PickerMask);
    bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);
    if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup("context"))
        return;
    ImGuiContext& g = *GImGui;
    if (allow_opt_picker)
    {
        ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function
        PushItemWidth(picker_size.x);
        for (int picker_type = 0; picker_type < 2; picker_type++)
        {
            // Draw small/thumbnail version of each picker type (over an invisible button for selection)
            if (picker_type > 0) Separator();
            PushID(picker_type);
            ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs|ImGuiColorEditFlags_NoOptions|ImGuiColorEditFlags_NoLabel|ImGuiColorEditFlags_NoSidePreview|(flags & ImGuiColorEditFlags_NoAlpha);
            if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;
            if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;
            ImVec2 backup_pos = GetCursorScreenPos();
            if (Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup
                g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags__PickerMask) | (picker_flags & ImGuiColorEditFlags__PickerMask);
            SetCursorScreenPos(backup_pos);
            ImVec4 dummy_ref_col;
            memcpy(&dummy_ref_col.x, ref_col, sizeof(float) * (picker_flags & ImGuiColorEditFlags_NoAlpha ? 3 : 4));
            ColorPicker4("##dummypicker", &dummy_ref_col.x, picker_flags);
            PopID();
        }
        PopItemWidth();
    }
    if (allow_opt_alpha_bar)
    {
        if (allow_opt_picker) Separator();
        CheckboxFlags("Alpha Bar", (unsigned int*)&g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);
    }
    EndPopup();
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
//-------------------------------------------------------------------------
// - TreeNode()
// - TreeNodeV()
// - TreeNodeEx()
// - TreeNodeExV()
// - TreeNodeBehavior() [Internal]  
// - TreePush()
// - TreePop()
// - TreeAdvanceToLabelPos()
// - GetTreeNodeToLabelSpacing()
// - SetNextTreeNodeOpen()
// - CollapsingHeader()
//-------------------------------------------------------------------------

bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(str_id, 0, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNode(const char* label)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;
    return TreeNodeBehavior(window->GetID(label), 0, label, NULL);
}

bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)
{
    return TreeNodeExV(str_id, 0, fmt, args);
}

bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)
{
    return TreeNodeExV(ptr_id, 0, fmt, args);
}

bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    return TreeNodeBehavior(window->GetID(label), flags, label, NULL);
}

bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(str_id, flags, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    return TreeNodeBehavior(window->GetID(str_id), flags, g.TempBuffer, label_end);
}

bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    return TreeNodeBehavior(window->GetID(ptr_id), flags, g.TempBuffer, label_end);
}

bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)
{
    if (flags & ImGuiTreeNodeFlags_Leaf)
        return true;

    // We only write to the tree storage if the user clicks (or explicitly use SetNextTreeNode*** functions)
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiStorage* storage = window->DC.StateStorage;

    bool is_open;
    if (g.NextTreeNodeOpenCond != 0)
    {
        if (g.NextTreeNodeOpenCond & ImGuiCond_Always)
        {
            is_open = g.NextTreeNodeOpenVal;
            storage->SetInt(id, is_open);
        }
        else
        {
            // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
            const int stored_value = storage->GetInt(id, -1);
            if (stored_value == -1)
            {
                is_open = g.NextTreeNodeOpenVal;
                storage->SetInt(id, is_open);
            }
            else
            {
                is_open = stored_value != 0;
            }
        }
        g.NextTreeNodeOpenCond = 0;
    }
    else
    {
        is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;
    }

    // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
    // NB- If we are above max depth we still allow manually opened nodes to be logged.
    if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && window->DC.TreeDepth < g.LogAutoExpandMaxDepth)
        is_open = true;

    return is_open;
}

bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;
    const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, 0.0f);

    if (!label_end)
        label_end = FindRenderedTextEnd(label);
    const ImVec2 label_size = CalcTextSize(label, label_end, false);

    // We vertically grow up to current line height up the typical widget height.
    const float text_base_offset_y = ImMax(padding.y, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
    const float frame_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + style.FramePadding.y*2), label_size.y + padding.y*2);
    ImRect frame_bb = ImRect(window->DC.CursorPos, ImVec2(window->Pos.x + GetContentRegionMax().x, window->DC.CursorPos.y + frame_height));
    if (display_frame)
    {
        // Framed header expand a little outside the default padding
        frame_bb.Min.x -= (float)(int)(window->WindowPadding.x*0.5f) - 1;
        frame_bb.Max.x += (float)(int)(window->WindowPadding.x*0.5f) - 1;
    }

    const float text_offset_x = (g.FontSize + (display_frame ? padding.x*3 : padding.x*2));   // Collapser arrow width + Spacing
    const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x*2 : 0.0f);   // Include collapser
    ItemSize(ImVec2(text_width, frame_height), text_base_offset_y);

    // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
    // (Ideally we'd want to add a flag for the user to specify if we want the hit test to be done up to the right side of the content or not)
    const ImRect interact_bb = display_frame ? frame_bb : ImRect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + text_width + style.ItemSpacing.x*2, frame_bb.Max.y);
    bool is_open = TreeNodeBehaviorIsOpen(id, flags);
    bool is_leaf = (flags & ImGuiTreeNodeFlags_Leaf) != 0;

    // Store a flag for the current depth to tell if we will allow closing this node when navigating one of its child.
    // For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
    // This is currently only support 32 level deep and we are fine with (1 << Depth) overflowing into a zero.
    if (is_open && !g.NavIdIsAlive && (flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
        window->DC.TreeDepthMayJumpToParentOnPop |= (1 << window->DC.TreeDepth);

    bool item_add = ItemAdd(interact_bb, id);
    window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;
    window->DC.LastItemDisplayRect = frame_bb;

    if (!item_add)
    {
        if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
            TreePushRawID(id);
        IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
        return is_open;
    }

    // Flags that affects opening behavior:
    // - 0(default) ..................... single-click anywhere to open
    // - OpenOnDoubleClick .............. double-click anywhere to open
    // - OpenOnArrow .................... single-click on arrow to open
    // - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open
    ImGuiButtonFlags button_flags = ImGuiButtonFlags_NoKeyModifiers | ((flags & ImGuiTreeNodeFlags_AllowItemOverlap) ? ImGuiButtonFlags_AllowItemOverlap : 0);
    if (!is_leaf)
        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;
    if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
        button_flags |= ImGuiButtonFlags_PressedOnDoubleClick | ((flags & ImGuiTreeNodeFlags_OpenOnArrow) ? ImGuiButtonFlags_PressedOnClickRelease : 0);

    bool hovered, held, pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);
    if (!is_leaf)
    {
        bool toggled = false;
        if (pressed)
        {
            toggled = !(flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) || (g.NavActivateId == id);
            if (flags & ImGuiTreeNodeFlags_OpenOnArrow)
                toggled |= IsMouseHoveringRect(interact_bb.Min, ImVec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y)) && (!g.NavDisableMouseHover);
            if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
                toggled |= g.IO.MouseDoubleClicked[0];
            if (g.DragDropActive && is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.
                toggled = false;
        }

        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Left && is_open)
        {
            toggled = true;
            NavMoveRequestCancel();
        }
        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?
        {
            toggled = true;
            NavMoveRequestCancel();
        }

        if (toggled)
        {
            is_open = !is_open;
            window->DC.StateStorage->SetInt(id, is_open);
        }
    }
    if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)
        SetItemAllowOverlap();

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
    const ImVec2 text_pos = frame_bb.Min + ImVec2(text_offset_x, text_base_offset_y);
    if (display_frame)
    {
        // Framed type
        RenderFrame(frame_bb.Min, frame_bb.Max, col, true, style.FrameRounding);
        RenderNavHighlight(frame_bb, id, ImGuiNavHighlightFlags_TypeThin);
        RenderArrow(frame_bb.Min + ImVec2(padding.x, text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f);
        if (g.LogEnabled)
        {
            // NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.
            const char log_prefix[] = "\n##";
            const char log_suffix[] = "##";
            LogRenderedText(&text_pos, log_prefix, log_prefix+3);
            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
            LogRenderedText(&text_pos, log_suffix+1, log_suffix+3);
        }
        else
        {
            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
        }
    }
    else
    {
        // Unframed typed for tree nodes
        if (hovered || (flags & ImGuiTreeNodeFlags_Selected))
        {
            RenderFrame(frame_bb.Min, frame_bb.Max, col, false);
            RenderNavHighlight(frame_bb, id, ImGuiNavHighlightFlags_TypeThin);
        }

        if (flags & ImGuiTreeNodeFlags_Bullet)
            RenderBullet(frame_bb.Min + ImVec2(text_offset_x * 0.5f, g.FontSize*0.50f + text_base_offset_y));
        else if (!is_leaf)
            RenderArrow(frame_bb.Min + ImVec2(padding.x, g.FontSize*0.15f + text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f);
        if (g.LogEnabled)
            LogRenderedText(&text_pos, ">");
        RenderText(text_pos, label, label_end, false);
    }

    if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
        TreePushRawID(id);
    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
    return is_open;
}

void ImGui::TreePush(const char* str_id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    PushID(str_id ? str_id : "#TreePush");
}

void ImGui::TreePush(const void* ptr_id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    PushID(ptr_id ? ptr_id : (const void*)"#TreePush");
}

void ImGui::TreePushRawID(ImGuiID id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    window->IDStack.push_back(id);
}

void ImGui::TreePop()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    Unindent();

    window->DC.TreeDepth--;
    if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())
        if (g.NavIdIsAlive && (window->DC.TreeDepthMayJumpToParentOnPop & (1 << window->DC.TreeDepth)))
        {
            SetNavID(window->IDStack.back(), g.NavLayer);
            NavMoveRequestCancel();
        }
    window->DC.TreeDepthMayJumpToParentOnPop &= (1 << window->DC.TreeDepth) - 1;

    IM_ASSERT(window->IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.
    PopID();
}

void ImGui::TreeAdvanceToLabelPos()
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow->DC.CursorPos.x += GetTreeNodeToLabelSpacing();
}

// Horizontal distance preceding label when using TreeNode() or Bullet()
float ImGui::GetTreeNodeToLabelSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + (g.Style.FramePadding.x * 2.0f);
}

void ImGui::SetNextTreeNodeOpen(bool is_open, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow->SkipItems)
        return;
    g.NextTreeNodeOpenVal = is_open;
    g.NextTreeNodeOpenCond = cond ? cond : ImGuiCond_Always;
}

// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).
// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().
bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);
}

bool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    if (p_open && !*p_open)
        return false;

    ImGuiID id = window->GetID(label);
    bool is_open = TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader | (p_open ? ImGuiTreeNodeFlags_AllowItemOverlap : 0), label);
    if (p_open)
    {
        // Create a small overlapping close button // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
        ImGuiContext& g = *GImGui;
        ImGuiItemHoveredDataBackup last_item_backup;
        float button_radius = g.FontSize * 0.5f;
        ImVec2 button_center = ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_radius, window->DC.LastItemRect.GetCenter().y);
        if (CloseButton(window->GetID((void*)(intptr_t)(id+1)), button_center, button_radius))
            *p_open = false;
        last_item_backup.Restore();
    }

    return is_open;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Selectable
//-------------------------------------------------------------------------
// - Selectable()
//-------------------------------------------------------------------------

// Tip: pass a non-visible label (e.g. "##dummy") then you can use the space to draw other text or image.
// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.
bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet) // FIXME-OPT: Avoid if vertically clipped.
        PopClipRect();

    ImGuiID id = window->GetID(label);
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);
    ImVec2 pos = window->DC.CursorPos;
    pos.y += window->DC.CurrentLineTextBaseOffset;
    ImRect bb_inner(pos, pos + size);
    ItemSize(bb_inner);

    // Fill horizontal space.
    ImVec2 window_padding = window->WindowPadding;
    float max_x = (flags & ImGuiSelectableFlags_SpanAllColumns) ? GetWindowContentRegionMax().x : GetContentRegionMax().x;
    float w_draw = ImMax(label_size.x, window->Pos.x + max_x - window_padding.x - window->DC.CursorPos.x);
    ImVec2 size_draw((size_arg.x != 0 && !(flags & ImGuiSelectableFlags_DrawFillAvailWidth)) ? size_arg.x : w_draw, size_arg.y != 0.0f ? size_arg.y : size.y);
    ImRect bb(pos, pos + size_draw);
    if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))
        bb.Max.x += window_padding.x;

    // Selectables are tightly packed together, we extend the box to cover spacing between selectable.
    float spacing_L = (float)(int)(style.ItemSpacing.x * 0.5f);
    float spacing_U = (float)(int)(style.ItemSpacing.y * 0.5f);
    float spacing_R = style.ItemSpacing.x - spacing_L;
    float spacing_D = style.ItemSpacing.y - spacing_U;
    bb.Min.x -= spacing_L;
    bb.Min.y -= spacing_U;
    bb.Max.x += spacing_R;
    bb.Max.y += spacing_D;
    if (!ItemAdd(bb, (flags & ImGuiSelectableFlags_Disabled) ? 0 : id))
    {
        if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)
            PushColumnClipRect();
        return false;
    }

    // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
    ImGuiButtonFlags button_flags = 0;
    if (flags & ImGuiSelectableFlags_NoHoldingActiveID) button_flags |= ImGuiButtonFlags_NoHoldingActiveID;
    if (flags & ImGuiSelectableFlags_PressedOnClick) button_flags |= ImGuiButtonFlags_PressedOnClick;
    if (flags & ImGuiSelectableFlags_PressedOnRelease) button_flags |= ImGuiButtonFlags_PressedOnRelease;
    if (flags & ImGuiSelectableFlags_Disabled) button_flags |= ImGuiButtonFlags_Disabled;
    if (flags & ImGuiSelectableFlags_AllowDoubleClick) button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
    if (flags & ImGuiSelectableFlags_Disabled)
        selected = false;

    // Hovering selectable with mouse updates NavId accordingly so navigation can be resumed with gamepad/keyboard (this doesn't happen on most widgets)
    if (pressed || hovered)
        if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)
        {
            g.NavDisableHighlight = true;
            SetNavID(id, window->DC.NavLayerCurrent);
        }
    if (pressed)
        MarkItemEdited(id);

    // Render
    if (hovered || selected)
    {
        const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
        RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
        RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);
    }

    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)
    {
        PushColumnClipRect();
        bb.Max.x -= (GetContentRegionMax().x - max_x);
    }

    if (flags & ImGuiSelectableFlags_Disabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
    RenderTextClipped(bb_inner.Min, bb.Max, label, NULL, &label_size, ImVec2(0.0f,0.0f));
    if (flags & ImGuiSelectableFlags_Disabled) PopStyleColor();

    // Automatically close popups
    if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup))
        CloseCurrentPopup();
    return pressed;
}

bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
{
    if (Selectable(label, *p_selected, flags, size_arg))
    {
        *p_selected = !*p_selected;
        return true;
    }
    return false;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ListBox
//-------------------------------------------------------------------------
// - ListBox()
// - ListBoxHeader()
// - ListBoxFooter()
//-------------------------------------------------------------------------

// FIXME: In principle this function should be called BeginListBox(). We should rename it after re-evaluating if we want to keep the same signature.
// Helper to calculate the size of a listbox and display a label on the right.
// Tip: To have a list filling the entire window width, PushItemWidth(-1) and pass an non-visible label e.g. "##empty"
bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    const ImGuiStyle& style = GetStyle();
    const ImGuiID id = GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    // Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);
    ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));
    ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
    ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
    window->DC.LastItemRect = bb; // Forward storage for ListBoxFooter.. dodgy.

    BeginGroup();
    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    BeginChildFrame(id, frame_bb.GetSize());
    return true;
}

// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.
bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)
{
    // Size default to hold ~7.25 items.
    // We add +25% worth of item height to allow the user to see at a glance if there are more items up/down, without looking at the scrollbar.
    // We don't add this extra bit if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.
    // I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.
    if (height_in_items < 0)
        height_in_items = ImMin(items_count, 7);
    const ImGuiStyle& style = GetStyle();
    float height_in_items_f = (height_in_items < items_count) ? (height_in_items + 0.25f) : (height_in_items + 0.00f);

    // We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().
    ImVec2 size;
    size.x = 0.0f;
    size.y = GetTextLineHeightWithSpacing() * height_in_items_f + style.FramePadding.y * 2.0f;
    return ListBoxHeader(label, size);
}

// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.
void ImGui::ListBoxFooter()
{
    ImGuiWindow* parent_window = GetCurrentWindow()->ParentWindow;
    const ImRect bb = parent_window->DC.LastItemRect;
    const ImGuiStyle& style = GetStyle();

    EndChildFrame();

    // Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)
    // We call SameLine() to restore DC.CurrentLine* data
    SameLine();
    parent_window->DC.CursorPos = bb.Min;
    ItemSize(bb, style.FramePadding.y);
    EndGroup();
}

bool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)
{
    const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);
    return value_changed;
}

bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
{
    if (!ListBoxHeader(label, items_count, height_in_items))
        return false;

    // Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.
    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.
    while (clipper.Step())
        for (int i = clipper.DisplayLoopCallback; i < clipper.DisplayEnd; i++)
        {
            const bool item_selected = (i == *current_item);
            const char* item_text;
            if (!items_getter(data, i, &item_text))
                item_text = "*Unknown item*";

            PushID(i);
            if (Selectable(item_text, item_selected))
            {
                *current_item = i;
                value_changed = true;
            }
            if (item_selected)
                SetItemDefaultFocus();
            PopID();
        }
    ListBoxFooter();
    if (value_changed)
        MarkItemEdited(g.CurrentWindow->DC.LastItemId);

    return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: PlotLines, PlotHistogram
//-------------------------------------------------------------------------
// - PlotEx() [Internal]
// - PlotLines()
// - PlotHistogram()
//-------------------------------------------------------------------------

void ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    if (graph_size.x == 0.0f)
        graph_size.x = CalcItemWidth();
    if (graph_size.y == 0.0f)
        graph_size.y = label_size.y + (style.FramePadding.y * 2);

    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(graph_size.x, graph_size.y));
    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, 0, &frame_bb))
        return;
    const bool hovered = ItemHoverable(inner_bb, 0);

    // Determine scale from values if not specified
    if (scale_min == FLT_MAX || scale_max == FLT_MAX)
    {
        float v_min = FLT_MAX;
        float v_max = -FLT_MAX;
        for (int i = 0; i < values_count; i++)
        {
            const float v = values_getter(data, i);
            v_min = ImMin(v_min, v);
            v_max = ImMax(v_max, v);
        }
        if (scale_min == FLT_MAX)
            scale_min = v_min;
        if (scale_max == FLT_MAX)
            scale_max = v_max;
    }

    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

    if (values_count > 0)
    {
        int res_w = ImMin((int)graph_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);
        int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

        // Tooltip on hover
        int v_hovered = -1;
        if (hovered)
        {
            const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);
            const int v_idx = (int)(t * item_count);
            IM_ASSERT(v_idx >= 0 && v_idx < values_count);

            const float v0 = values_getter(data, (v_idx + values_offset) % values_count);
            const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);
            if (plot_type == ImGuiPlotType_Lines)
                SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx+1, v1);
            else if (plot_type == ImGuiPlotType_Histogram)
                SetTooltip("%d: %8.4g", v_idx, v0);
            v_hovered = v_idx;
        }

        const float t_step = 1.0f / (float)res_w;
        const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));

        float v0 = values_getter(data, (0 + values_offset) % values_count);
        float t0 = 0.0f;
        ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale) );                       // Point in the normalized space of our target rectangle
        float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (-scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands

        const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);
        const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);

        for (int n = 0; n < res_w; n++)
        {
            const float t1 = t0 + t_step;
            const int v1_idx = (int)(t0 * item_count + 0.5f);
            IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);
            const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);
            const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale) );

            // NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
            ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);
            ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));
            if (plot_type == ImGuiPlotType_Lines)
            {
                window->DrawList->AddLine(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);
            }
            else if (plot_type == ImGuiPlotType_Histogram)
            {
                if (pos1.x >= pos0.x + 2.0f)
                    pos1.x -= 1.0f;
                window->DrawList->AddRectFilled(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);
            }

            t0 = t1;
            tp0 = tp1;
        }
    }

    // Text overlay
    if (overlay_text)
        RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);
}

struct ImGuiPlotArrayGetterData
{
    const float* Values;
    int Stride;

    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }
};

static float Plot_ArrayGetter(void* data, int idx)
{
    ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;
    const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);
    return v;
}

void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
{
    ImGuiPlotArrayGetterData data(values, stride);
    PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
    PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
{
    ImGuiPlotArrayGetterData data(values, stride);
    PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
    PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Value helpers
// Those is not very useful, legacy API.
//-------------------------------------------------------------------------
// - Value()
//-------------------------------------------------------------------------

void ImGui::Value(const char* prefix, bool b)
{
    Text("%s: %s", prefix, (b ? "true" : "false"));
}

void ImGui::Value(const char* prefix, int v)
{
    Text("%s: %d", prefix, v);
}

void ImGui::Value(const char* prefix, unsigned int v)
{
    Text("%s: %d", prefix, v);
}

void ImGui::Value(const char* prefix, float v, const char* float_format)
{
    if (float_format)
    {
        char fmt[64];
        ImFormatString(fmt, IM_ARRAYSIZE(fmt), "%%s: %s", float_format);
        Text(fmt, prefix, v);
    }
    else
    {
        Text("%s: %.3f", prefix, v);
    }
}

//-------------------------------------------------------------------------
// [SECTION] MenuItem, BeginMenu, EndMenu, etc.
//-------------------------------------------------------------------------
// - ImGuiMenuColumns [Internal]
// - BeginMainMenuBar()
// - EndMainMenuBar()
// - BeginMenuBar()
// - EndMenuBar()
// - BeginMenu()
// - EndMenu()
// - MenuItem()
//-------------------------------------------------------------------------

// Helpers for internal use
ImGuiMenuColumns::ImGuiMenuColumns()
{
    Count = 0;
    Spacing = Width = NextWidth = 0.0f;
    memset(Pos, 0, sizeof(Pos));
    memset(NextWidths, 0, sizeof(NextWidths));
}

void ImGuiMenuColumns::Update(int count, float spacing, bool clear)
{
    IM_ASSERT(Count <= IM_ARRAYSIZE(Pos));
    Count = count;
    Width = NextWidth = 0.0f;
    Spacing = spacing;
    if (clear) memset(NextWidths, 0, sizeof(NextWidths));
    for (int i = 0; i < Count; i++)
    {
        if (i > 0 && NextWidths[i] > 0.0f)
            Width += Spacing;
        Pos[i] = (float)(int)Width;
        Width += NextWidths[i];
        NextWidths[i] = 0.0f;
    }
}

float ImGuiMenuColumns::DeclColumns(float w0, float w1, float w2) // not using va_arg because they promote float to double
{
    NextWidth = 0.0f;
    NextWidths[0] = ImMax(NextWidths[0], w0);
    NextWidths[1] = ImMax(NextWidths[1], w1);
    NextWidths[2] = ImMax(NextWidths[2], w2);
    for (int i = 0; i < 3; i++)
        NextWidth += NextWidths[i] + ((i > 0 && NextWidths[i] > 0.0f) ? Spacing : 0.0f);
    return ImMax(Width, NextWidth);
}

float ImGuiMenuColumns::CalcExtraSpace(float avail_w)
{
    return ImMax(0.0f, avail_w - Width);
}

// For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.
bool ImGui::BeginMainMenuBar()
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));
    SetNextWindowPos(ImVec2(0.0f, 0.0f));
    SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.NextWindowData.MenuBarOffsetMinVal.y + g.FontBaseSize + g.Style.FramePadding.y));
    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
    PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0,0));
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;
    bool is_open = Begin("##MainMenuBar", NULL, window_flags) && BeginMenuBar();
    PopStyleVar(2);
    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);
    if (!is_open)
    {
        End();
        return false;
    }
    return true;
}

void ImGui::EndMainMenuBar()
{
    EndMenuBar();

    // When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow == g.NavWindow && g.NavLayer == 0)
        FocusPreviousWindowIgnoringOne(g.NavWindow);

    End();
}

bool ImGui::BeginMenuBar()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;
    if (!(window->Flags & ImGuiWindowFlags_MenuBar))
        return false;

    IM_ASSERT(!window->DC.MenuBarAppending);
    BeginGroup(); // Backup position on layer 0
    PushID("##menubar");

    // We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
    // We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
    ImRect bar_rect = window->MenuBarRect();
    ImRect clip_rect(ImFloor(bar_rect.Min.x + 0.5f), ImFloor(bar_rect.Min.y + window->WindowBorderSize + 0.5f), ImFloor(ImMax(bar_rect.Min.x, bar_rect.Max.x - window->WindowRounding) + 0.5f), ImFloor(bar_rect.Max.y + 0.5f));
    clip_rect.ClipWith(window->OuterRectClipped);
    PushClipRect(clip_rect.Min, clip_rect.Max, false);

    window->DC.CursorPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);
    window->DC.LayoutType = ImGuiLayoutType_Horizontal;
    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);
    window->DC.MenuBarAppending = true;
    AlignTextToFramePadding();
    return true;
}

void ImGui::EndMenuBar()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    // Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
    if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
    {
        ImGuiWindow* nav_earliest_child = g.NavWindow;
        while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))
            nav_earliest_child = nav_earliest_child->ParentWindow;
        if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && g.NavMoveRequestForward == ImGuiNavForward_None)
        {
            // To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
            // This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth the hassle/cost)
            IM_ASSERT(window->DC.NavLayerActiveMaskNext & 0x02); // Sanity check
            FocusWindow(window);
            SetNavIDWithRectRel(window->NavLastIds[1], 1, window->NavRectRel[1]);
            g.NavLayer = ImGuiNavLayer_Menu;
            g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.
            g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
            NavMoveRequestCancel();
        }
    }

    IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);
    IM_ASSERT(window->DC.MenuBarAppending);
    PopClipRect();
    PopID();
    window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->MenuBarRect().Min.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.
    window->DC.GroupStack.back().AdvanceCursor = false;
    EndGroup(); // Restore position on layer 0
    window->DC.LayoutType = ImGuiLayoutType_Vertical;
    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);
    window->DC.MenuBarAppending = false;
}

bool ImGui::BeginMenu(const char* label, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    ImVec2 label_size = CalcTextSize(label, NULL, true);

    bool pressed;
    bool menu_is_open = IsPopupOpen(id);
    bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].OpenParentId == window->IDStack.back());
    ImGuiWindow* backed_nav_window = g.NavWindow;
    if (menuset_is_open)
        g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)

    // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu (using FindBestWindowPosForPopup).
    ImVec2 popup_pos, pos = window->DC.CursorPos;
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
    {
        // Menu inside an horizontal menu bar
        // Selectable extend their highlight by half ItemSpacing in each direction.
        // For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
        popup_pos = ImVec2(pos.x - 1.0f - (float)(int)(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window->MenuBarHeight());
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);
        PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);
        float w = label_size.x;
        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));
        PopStyleVar();
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
    }
    else
    {
        // Menu inside a menu
        popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);
        float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame
        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);
        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));
        if (!enabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
        RenderArrow(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.30f, 0.0f), ImGuiDir_Right);
        if (!enabled) PopStyleColor();
    }

    const bool hovered = enabled && ItemHoverable(window->DC.LastItemRect, id);
    if (menuset_is_open)
        g.NavWindow = backed_nav_window;

    bool want_open = false, want_close = false;
    if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
    {
        // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
        bool moving_within_opened_triangle = false;
        if (g.HoveredWindow == window && g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].ParentWindow == window && !(window->Flags & ImGuiWindowFlags_MenuBar))
        {
            if (ImGuiWindow* next_window = g.OpenPopupStack[g.BeginPopupStack.Size].Window)
            {
                ImRect next_window_rect = next_window->Rect();
                ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;
                ImVec2 tb = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();
                ImVec2 tc = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();
                float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, 5.0f, 30.0f); // add a bit of extra slack.
                ta.x += (window->Pos.x < next_window->Pos.x) ? -0.5f : +0.5f;   // to avoid numerical issues
                tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -100.0f);            // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?
                tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +100.0f);
                moving_within_opened_triangle = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);
                //window->DrawList->PushClipRectFullScreen(); window->DrawList->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); window->DrawList->PopClipRect(); // Debug
            }
        }

        want_close = (menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_within_opened_triangle);
        want_open = (!menu_is_open && hovered && !moving_within_opened_triangle) || (!menu_is_open && hovered && pressed);

        if (g.NavActivateId == id)
        {
            want_close = menu_is_open;
            want_open = !menu_is_open;
        }
        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open
        {
            want_open = true;
            NavMoveRequestCancel();
        }
    }
    else
    {
        // Menu bar
        if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it
        {
            want_close = true;
            want_open = menu_is_open = false;
        }
        else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others
        {
            want_open = true;
        }
        else if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open
        {
            want_open = true;
            NavMoveRequestCancel();
        }
    }

    if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'
        want_close = true;
    if (want_close && IsPopupOpen(id))
        ClosePopupToLevel(g.BeginPopupStack.Size);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Openable | (menu_is_open ? ImGuiItemStatusFlags_Opened : 0));

    if (!menu_is_open && want_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size)
    {
        // Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.
        OpenPopup(label);
        return false;
    }

    menu_is_open |= want_open;
    if (want_open)
        OpenPopup(label);

    if (menu_is_open)
    {
        // Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)
        SetNextWindowPos(popup_pos, ImGuiCond_Always);
        ImGuiWindowFlags flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;
        if (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
            flags |= ImGuiWindowFlags_ChildWindow;
        menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    }

    return menu_is_open;
}

void ImGui::EndMenu()
{
    // Nav: When a left move request _within our child menu_ failed, close ourselves (the _parent_ menu).
    // A menu doesn't close itself because EndMenuBar() wants the catch the last Left<>Right inputs.
    // However, it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavWindow && g.NavWindow->ParentWindow == window && g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet() && window->DC.LayoutType == ImGuiLayoutType_Vertical)
    {
        ClosePopupToLevel(g.BeginPopupStack.Size);
        NavMoveRequestCancel();
    }

    EndPopup();
}

bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    ImVec2 pos = window->DC.CursorPos;
    ImVec2 label_size = CalcTextSize(label, NULL, true);

    ImGuiSelectableFlags flags = ImGuiSelectableFlags_PressedOnRelease | (enabled ? 0 : ImGuiSelectableFlags_Disabled);
    bool pressed;
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
    {
        // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
        // Note that in this situation we render neither the shortcut neither the selected tick mark
        float w = label_size.x;
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);
        PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);
        pressed = Selectable(label, false, flags, ImVec2(w, 0.0f));
        PopStyleVar();
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
    }
    else
    {
        ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);
        float w = window->MenuColumns.DeclColumns(label_size.x, shortcut_size.x, (float)(int)(g.FontSize * 1.20f)); // Feedback for next frame
        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);
        pressed = Selectable(label, false, flags | ImGuiSelectableFlags_DrawFillAvailWidth, ImVec2(w, 0.0f));
        if (shortcut_size.x > 0.0f)
        {
            PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
            RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);
            PopStyleColor();
        }
        if (selected)
            RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled), g.FontSize  * 0.866f);
    }

    IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (selected ? ImGuiItemStatusFlags_Checked : 0));
    return pressed;
}

bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)
{
    if (MenuItem(label, shortcut, p_selected ? *p_selected : false, enabled))
    {
        if (p_selected)
            *p_selected = !*p_selected;
        return true;
    }
    return false;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
//-------------------------------------------------------------------------
// [BETA API] API may evolve! This code has been extracted out of the Docking branch,
// and some of the construct which are not used in Master may be left here to facilitate merging.
//-------------------------------------------------------------------------
// - BeginTabBar()
// - BeginTabBarEx() [Internal]
// - EndTabBar()
// - TabBarLayout() [Internal]
// - TabBarCalcTabID() [Internal]
// - TabBarCalcMaxTabWidth() [Internal]
// - TabBarFindTabById() [Internal]
// - TabBarRemoveTab() [Internal]
// - TabBarCloseTab() [Internal]
// - TabBarScrollClamp()v
// - TabBarScrollToTab() [Internal]
// - TabBarQueueChangeTabOrder() [Internal]
// - TabBarScrollingButtons() [Internal]
//-------------------------------------------------------------------------

namespace ImGui
{
    static void             TabBarLayout(ImGuiTabBar* tab_bar);
    static ImU32            TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label);
    static float            TabBarCalcMaxTabWidth();
    static float            TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling);
    static void             TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
    static ImGuiTabItem*    TabBarScrollingButtons(ImGuiTabBar* tab_bar);
}

ImGuiTabBar::ImGuiTabBar()
{
    ID = 0;
    SelectedTabId = NextSelectedTabId = VisibleTabId = 0;
    CurrFrameVisible = PrevFrameVisible = -1;
    OffsetMax = OffsetNextTab = 0.0f;
    ScrollingAnim = ScrollingTarget = 0.0f;
    Flags = ImGuiTabBarFlags_None;
    ReorderRequestTabId = 0;
    ReorderRequestDir = 0;
    WantLayout = VisibleTabWasSubmitted = false;
    LastTabItemIdx = -1;
}

static int IMGUI_CDECL TabItemComparerByVisibleOffset(const void* lhs, const void* rhs)
{
    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;
    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;
    return (int)(a->Offset - b->Offset);
}

static int IMGUI_CDECL TabBarSortItemComparer(const void* lhs, const void* rhs)
{
    const ImGuiTabBarSortItem* a = (const ImGuiTabBarSortItem*)lhs;
    const ImGuiTabBarSortItem* b = (const ImGuiTabBarSortItem*)rhs;
    if (int d = (int)(b->Width - a->Width))
        return d;
    return (b->Index - a->Index);
}

bool    ImGui::BeginTabBar(const char* str_id, ImGuiTabBarFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return false;

    ImGuiID id = window->GetID(str_id);
    ImGuiTabBar* tab_bar = g.TabBars.GetOrAddByKey(id);
    ImRect tab_bar_bb = ImRect(window->DC.CursorPos.x, window->DC.CursorPos.y, window->InnerClipRect.Max.x, window->DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2);
    tab_bar->ID = id;
    return BeginTabBarEx(tab_bar, tab_bar_bb, flags | ImGuiTabBarFlags_IsFocused);
}

bool    ImGui::BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& tab_bar_bb, ImGuiTabBarFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return false;

    if ((flags & ImGuiTabBarFlags_DockNode) == 0)
        window->IDStack.push_back(tab_bar->ID);

    g.CurrentTabBar.push_back(tab_bar);
    if (tab_bar->CurrFrameVisible == g.FrameCount)
    {
        //printf("[%05d] BeginTabBarEx already called this frame\n", g.FrameCount);
        IM_ASSERT(0);
        return true;
    }

    // When toggling back from ordered to manually-reorderable, shuffle tabs to enforce the last visible order. 
    // Otherwise, the most recently inserted tabs would move at the end of visible list which can be a little too confusing or magic for the user.
    if ((flags & ImGuiTabBarFlags_Reorderable) && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable) && tab_bar->Tabs.Size > 1 && tab_bar->PrevFrameVisible != -1)
        ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerByVisibleOffset);

    // Flags
    if ((flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)
        flags |= ImGuiTabBarFlags_FittingPolicyDefault_;

    tab_bar->Flags = flags;
    tab_bar->BarRect = tab_bar_bb;
    tab_bar->WantLayout = true; // Layout will be done on the first call to ItemTab()
    tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;
    tab_bar->CurrFrameVisible = g.FrameCount;

    // Layout    
    ItemSize(ImVec2(tab_bar->OffsetMax, tab_bar->BarRect.GetHeight()));
    window->DC.CursorPos.x = tab_bar->BarRect.Min.x;

    // Draw separator
    const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabActive : ImGuiCol_Tab);
    const float y = tab_bar->BarRect.Max.y - 1.0f;
    {
        const float separator_min_x = tab_bar->BarRect.Min.x - ((flags & ImGuiTabBarFlags_DockNodeIsDockSpace) ? 0.0f : window->WindowPadding.x);
        const float separator_max_x = tab_bar->BarRect.Max.x + ((flags & ImGuiTabBarFlags_DockNodeIsDockSpace) ? 0.0f : window->WindowPadding.x);
        window->DrawList->AddLine(ImVec2(separator_min_x, y), ImVec2(separator_max_x, y), col, 1.0f);
    }
    return true;
}

void    ImGui::EndTabBar()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    IM_ASSERT(!g.CurrentTabBar.empty());      // Mismatched BeginTabBar/EndTabBar
    ImGuiTabBar* tab_bar = g.CurrentTabBar.back();
    if (tab_bar->WantLayout)
        TabBarLayout(tab_bar);

    // Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().
    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
    if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing)
        tab_bar->ContentsHeight = ImMax(window->DC.CursorPos.y - tab_bar->BarRect.Max.y, 0.0f);
    else
        window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->ContentsHeight;

    if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)
        PopID();
    g.CurrentTabBar.pop_back();
}

// This is called only once a frame before by the first call to ItemTab()
// The reason we're not calling it in BeginTabBar() is to leave a chance to the user to call the SetTabItemClosed() functions.
static void ImGui::TabBarLayout(ImGuiTabBar* tab_bar)
{
    ImGuiContext& g = *GImGui;
    tab_bar->WantLayout = false;

    // Garbage collect
    int tab_dst_n = 0;
    for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++)
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_src_n];
        if (tab->LastFrameVisible < tab_bar->PrevFrameVisible)
        {
            if (tab->ID == tab_bar->SelectedTabId)
                tab_bar->SelectedTabId = 0;
            continue;
        }
        if (tab_dst_n != tab_src_n)
            tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];
        tab_dst_n++;
    }
    if (tab_bar->Tabs.Size != tab_dst_n)
        tab_bar->Tabs.resize(tab_dst_n);

    // Setup next selected tab
    ImGuiID scroll_track_selected_tab_id = 0;
    if (tab_bar->NextSelectedTabId)
    {
        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;
        tab_bar->NextSelectedTabId = 0;
        scroll_track_selected_tab_id = tab_bar->SelectedTabId;
    }

    // Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).
    if (tab_bar->ReorderRequestTabId != 0)
    {
        if (ImGuiTabItem* tab1 = TabBarFindTabByID(tab_bar, tab_bar->ReorderRequestTabId))
        {
            //IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable); // <- this may happen when using debug tools
            int tab2_order = tab_bar->GetTabOrder(tab1) + tab_bar->ReorderRequestDir;
            if (tab2_order >= 0 && tab2_order < tab_bar->Tabs.Size)
            {
                ImGuiTabItem* tab2 = &tab_bar->Tabs[tab2_order];
                ImGuiTabItem item_tmp = *tab1;
                *tab1 = *tab2;
                *tab2 = item_tmp;
                if (tab2->ID == tab_bar->SelectedTabId)
                    scroll_track_selected_tab_id = tab2->ID;
                tab1 = tab2 = NULL;
            }
            if (tab_bar->Flags & ImGuiTabBarFlags_SaveSettings)
                MarkIniSettingsDirty();
        }
        tab_bar->ReorderRequestTabId = 0;
    }

    ImVector<ImGuiTabBarSortItem>& width_sort_buffer = g.TabSortByWidthBuffer;
    width_sort_buffer.resize(tab_bar->Tabs.Size);

    // Compute ideal widths
    float width_total_contents = 0.0f;
    ImGuiTabItem* most_recently_selected_tab = NULL;
    bool found_selected_tab_id = false;
    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
        IM_ASSERT(tab->LastFrameVisible >= tab_bar->PrevFrameVisible);

        if (most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected)
            most_recently_selected_tab = tab;
        if (tab->ID == tab_bar->SelectedTabId)
            found_selected_tab_id = true;

        // Refresh tab width immediately if we can (for manual tab bar, WidthContent will lag by one frame which is mostly noticeable when changing style.FramePadding.x)
        // Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet, 
        // and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
        width_total_contents += (tab_n > 0 ? g.Style.ItemInnerSpacing.x : 0.0f) + tab->WidthContents;

        // Store data so we can build an array sorted by width if we need to shrink tabs down
        width_sort_buffer[tab_n].Index = tab_n;
        width_sort_buffer[tab_n].Width = tab->WidthContents;
    }

    // Compute width
    const float width_avail = tab_bar->BarRect.GetWidth();
    float width_excess = (width_avail < width_total_contents) ? (width_total_contents - width_avail) : 0.0f;
    if (width_excess > 0.0f && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyResizeDown))
    {
        // If we don't have enough room, resize down the largest tabs first
        if (tab_bar->Tabs.Size > 1)
            ImQsort(width_sort_buffer.Data, (size_t)width_sort_buffer.Size, sizeof(ImGuiTabBarSortItem), TabBarSortItemComparer);
        int tab_count_same_width = 1;
        while (width_excess > 0.0f && tab_count_same_width < tab_bar->Tabs.Size)
        {
            while (tab_count_same_width < tab_bar->Tabs.Size && width_sort_buffer[0].Width == width_sort_buffer[tab_count_same_width].Width)
                tab_count_same_width++;
            float width_to_remove_per_tab_max = (tab_count_same_width < tab_bar->Tabs.Size) ? (width_sort_buffer[0].Width - width_sort_buffer[tab_count_same_width].Width) : (width_sort_buffer[0].Width - 1.0f);
            float width_to_remove_per_tab = ImMin(width_excess / tab_count_same_width, width_to_remove_per_tab_max);
            for (int tab_n = 0; tab_n < tab_count_same_width; tab_n++)
                width_sort_buffer[tab_n].Width -= width_to_remove_per_tab;
            width_excess -= width_to_remove_per_tab * tab_count_same_width;
        }
        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
            tab_bar->Tabs[width_sort_buffer[tab_n].Index].Width = (float)(int)width_sort_buffer[tab_n].Width;
    }
    else
    {
        const float tab_max_width = TabBarCalcMaxTabWidth();
        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
        {
            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
            tab->Width = ImMin(tab->WidthContents, tab_max_width);
        }
    }

    // Layout all active tabs
    float offset_x = 0.0f;
    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
        tab->Offset = offset_x;
        if (scroll_track_selected_tab_id == 0 && g.NavJustMovedToId == tab->ID)
            scroll_track_selected_tab_id = tab->ID;
        offset_x += tab->Width + g.Style.ItemInnerSpacing.x;
    }
    tab_bar->OffsetMax = ImMax(offset_x - g.Style.ItemInnerSpacing.x, 0.0f);
    tab_bar->OffsetNextTab = 0.0f;

    // Horizontal scrolling buttons
    const bool scrolling_buttons = (tab_bar->OffsetMax > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1) && !(tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons) && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll);
    if (scrolling_buttons)
        if (ImGuiTabItem* tab_to_select = TabBarScrollingButtons(tab_bar)) // NB: Will alter BarRect.Max.x!
            scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

    // If we have lost the selected tab, select the next most recently active one
    if (found_selected_tab_id == false)
        tab_bar->SelectedTabId = 0;
    if (tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 && most_recently_selected_tab != NULL)
        scroll_track_selected_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;

    // Lock in visible tab
    tab_bar->VisibleTabId = tab_bar->SelectedTabId;
    tab_bar->VisibleTabWasSubmitted = false;

    // Update scrolling
    if (scroll_track_selected_tab_id)
        if (ImGuiTabItem* scroll_track_selected_tab = TabBarFindTabByID(tab_bar, scroll_track_selected_tab_id))
            TabBarScrollToTab(tab_bar, scroll_track_selected_tab);
    tab_bar->ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar->ScrollingAnim);
    tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);
    const float scrolling_speed = (tab_bar->PrevFrameVisible + 1 < g.FrameCount) ? FLT_MAX : (g.IO.DeltaTime * g.FontSize * 70.0f);
    if (tab_bar->ScrollingAnim != tab_bar->ScrollingTarget)
        tab_bar->ScrollingAnim = ImLinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, scrolling_speed);
}

// Dockables uses Name/ID in the global namespace. Non-dockable items use the ID stack.
static ImU32   ImGui::TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label)
{
    if (tab_bar->Flags & ImGuiTabBarFlags_DockNode)
    {
        ImGuiID id = ImHash(label, 0);
        KeepAliveID(id);
        return id;
    }
    else
    {
        ImGuiWindow* window = GImGui->CurrentWindow;
        return window->GetID(label);
    }
}

static float ImGui::TabBarCalcMaxTabWidth()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize * 20.0f;
}

ImGuiTabItem* ImGui::TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id)
{
    if (tab_id != 0)
        for (int n = 0; n < tab_bar->Tabs.Size; n++)
            if (tab_bar->Tabs[n].ID == tab_id)
                return &tab_bar->Tabs[n];
    return NULL;
}

// The *TabId fields be already set by the docking system _before_ the actual TabItem was created, so we clear them regardless.
void ImGui::TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id)
{
    if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))
        tab_bar->Tabs.erase(tab);
    if (tab_bar->VisibleTabId == tab_id)      { tab_bar->VisibleTabId = 0; }
    if (tab_bar->SelectedTabId == tab_id)     { tab_bar->SelectedTabId = 0; }
    if (tab_bar->NextSelectedTabId == tab_id) { tab_bar->NextSelectedTabId = 0; }
}

// Called on manual closure attempt
void ImGui::TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)
{
    if ((tab_bar->VisibleTabId == tab->ID) && !(tab->Flags & ImGuiTabItemFlags_UnsavedDocument))
    {
        // This will remove a frame of lag for selecting another tab on closure.
        // However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
        tab->LastFrameVisible = -1;
        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;
    }
    else if ((tab_bar->VisibleTabId != tab->ID) && (tab->Flags & ImGuiTabItemFlags_UnsavedDocument))
    {
        // Actually select before expecting closure
        tab_bar->NextSelectedTabId = tab->ID;
    }
}

static float ImGui::TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling)
{
    scrolling = ImMin(scrolling, tab_bar->OffsetMax - tab_bar->BarRect.GetWidth());
    return ImMax(scrolling, 0.0f);
}

static void ImGui::TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)
{
    ImGuiContext& g = *GImGui;
    float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)
    int order = tab_bar->GetTabOrder(tab);
    float tab_x1 = tab->Offset + (order > 0 ? -margin : 0.0f);
    float tab_x2 = tab->Offset + tab->Width + (order + 1 < tab_bar->Tabs.Size ? margin : 1.0f);
    if (tab_bar->ScrollingTarget > tab_x1)
        tab_bar->ScrollingTarget = tab_x1;
    if (tab_bar->ScrollingTarget + tab_bar->BarRect.GetWidth() < tab_x2)
        tab_bar->ScrollingTarget = tab_x2 - tab_bar->BarRect.GetWidth();
}

void ImGui::TabBarQueueChangeTabOrder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir)
{
    IM_ASSERT(dir == -1 || dir == +1);
    IM_ASSERT(tab_bar->ReorderRequestTabId == 0);
    tab_bar->ReorderRequestTabId = tab->ID;
    tab_bar->ReorderRequestDir = dir;
}

static ImGuiTabItem* ImGui::TabBarScrollingButtons(ImGuiTabBar* tab_bar)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);
    const float scrolling_buttons_width = arrow_button_size.x * 2.0f;

    const ImVec2 backup_cursor_pos = window->DC.CursorPos;
    //window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));

    const ImRect avail_bar_rect = tab_bar->BarRect;
    bool want_clip_rect = !avail_bar_rect.Contains(ImRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(scrolling_buttons_width, 0.0f)));
    if (want_clip_rect)
        PushClipRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max + ImVec2(g.Style.ItemInnerSpacing.x, 0.0f), true);

    ImGuiTabItem* tab_to_select = NULL;

    int select_dir = 0;
    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];
    arrow_col.w *= 0.5f;

    PushStyleColor(ImGuiCol_Text, arrow_col);
    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
    const float backup_repeat_delay = g.IO.KeyRepeatDelay;
    const float backup_repeat_rate = g.IO.KeyRepeatRate;
    g.IO.KeyRepeatDelay = 0.250f;
    g.IO.KeyRepeatRate = 0.200f;
    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y);
    if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))
        select_dir = -1;
    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width + arrow_button_size.x, tab_bar->BarRect.Min.y);
    if (ArrowButtonEx("##>", ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))
        select_dir = +1;
    PopStyleColor(2);
    g.IO.KeyRepeatRate = backup_repeat_rate;
    g.IO.KeyRepeatDelay = backup_repeat_delay;

    if (want_clip_rect)
        PopClipRect();

    if (select_dir != 0)
        if (ImGuiTabItem* tab_item = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))
        {
            int selected_order = tab_bar->GetTabOrder(tab_item);
            int target_order = selected_order + select_dir;
            tab_to_select = &tab_bar->Tabs[(target_order >= 0 && target_order < tab_bar->Tabs.Size) ? target_order : selected_order]; // If we are at the end of the list, still scroll to make our tab visible
        }
    window->DC.CursorPos = backup_cursor_pos;
    tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;

    return tab_to_select;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
//-------------------------------------------------------------------------
// [BETA API] API may evolve! This code has been extracted out of the Docking branch,
// and some of the construct which are not used in Master may be left here to facilitate merging.
//-------------------------------------------------------------------------
// - BeginTabItem()
// - EndTabItem()
// - TabItemEx() [Internal]
// - SetTabItemClosed()
// - TabItemCalcSize() [Internal]
// - TabItemRenderBackground() [Internal]
// - TabItemLabelAndCloseButton() [Internal]
//-------------------------------------------------------------------------

bool    ImGui::BeginTabItem(const char* label, bool* p_open, ImGuiTabItemFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow->SkipItems)
        return false;

    IM_ASSERT(g.CurrentTabBar.Size > 0 && "Needs to be called between BeginTabBar() and EndTabBar()!");
    ImGuiTabBar* tab_bar = g.CurrentTabBar.back();
    bool ret = TabItemEx(tab_bar, label, p_open, flags);
    if (ret && !(flags & ImGuiTabItemFlags_NoPushId))
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
        g.CurrentWindow->IDStack.push_back(tab->ID);    // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)
    }
    return ret;
}

void    ImGui::EndTabItem()
{
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow->SkipItems)
        return;

    IM_ASSERT(g.CurrentTabBar.Size > 0 && "Needs to be called between BeginTabBar() and EndTabBar()!");
    ImGuiTabBar* tab_bar = g.CurrentTabBar.back();
    ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
    if (!(tab->Flags & ImGuiTabItemFlags_NoPushId))
        g.CurrentWindow->IDStack.pop_back();
}

bool    ImGui::TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags)
{
    // Layout whole tab bar if not already done
    if (tab_bar->WantLayout)
        TabBarLayout(tab_bar);

    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return false;

    const ImGuiStyle& style = g.Style;
    const ImGuiID id = TabBarCalcTabID(tab_bar, label);

    // If the user called us with *p_open == false, we early out and don't render. We make a dummy call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.
    if (p_open && !*p_open)
    {
        PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);
        ItemAdd(ImRect(), id);
        PopItemFlag();
        return false;
    }

    // Calculate tab contents size
    ImVec2 size = TabItemCalcSize(label, p_open != NULL);

    // Acquire tab data
    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, id);
    bool tab_is_new = false;
    if (tab == NULL)
    {
        tab_bar->Tabs.push_back(ImGuiTabItem());
        tab = &tab_bar->Tabs.back();
        tab->ID = id;
        tab->Width = size.x;
        tab_is_new = true;
    }
    tab_bar->LastTabItemIdx = (short)tab_bar->Tabs.index_from_pointer(tab);
    tab->WidthContents = size.x;

    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
    const bool tab_bar_focused = (tab_bar->Flags & ImGuiTabBarFlags_IsFocused) != 0;
    const bool tab_appearing = (tab->LastFrameVisible + 1 < g.FrameCount);
    tab->LastFrameVisible = g.FrameCount;
    tab->Flags = flags;

    // If we are not reorderable, always reset offset based on submission order.
    // (We already handled layout and sizing using the previous known order, but sizing is not affected by order!)
    if (!tab_appearing && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable))
    {
        tab->Offset = tab_bar->OffsetNextTab;
        tab_bar->OffsetNextTab += tab->Width + g.Style.ItemInnerSpacing.x;
    }

    // Update selected tab
    if (tab_appearing && (tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs) && tab_bar->NextSelectedTabId == 0)
        if (!tab_bar_appearing || tab_bar->SelectedTabId == 0)
            tab_bar->NextSelectedTabId = id;  // New tabs gets activated

    // Lock visibility
    bool tab_contents_visible = (tab_bar->VisibleTabId == id);
    if (tab_contents_visible)
        tab_bar->VisibleTabWasSubmitted = true;

    // On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches
    if (!tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing)
        if (tab_bar->Tabs.Size == 1 && !(tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs))
            tab_contents_visible = true;

    if (tab_appearing && !(tab_bar_appearing && !tab_is_new))
    {
        PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);
        ItemAdd(ImRect(), id);
        PopItemFlag();
        return tab_contents_visible;
    }

    if (tab_bar->SelectedTabId == id)
        tab->LastFrameSelected = g.FrameCount;

    // Backup current layout position
    const ImVec2 backup_main_cursor_pos = window->DC.CursorPos;

    // Layout
    size.x = tab->Width;
    window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2((float)(int)tab->Offset - tab_bar->ScrollingAnim, 0.0f);
    ImVec2 pos = window->DC.CursorPos;
    ImRect bb(pos, pos + size);

    // We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)
    bool want_clip_rect = (bb.Min.x < tab_bar->BarRect.Min.x) || (bb.Max.x >= tab_bar->BarRect.Max.x);
    if (want_clip_rect)
        PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->BarRect.Min.x), bb.Min.y - 1), ImVec2(tab_bar->BarRect.Max.x, bb.Max.y), true);

    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(bb, id))
    {
        if (want_clip_rect)
            PopClipRect();
        window->DC.CursorPos = backup_main_cursor_pos;
        return tab_contents_visible;
    }

    // Click to Select a tab
    ImGuiButtonFlags button_flags = (ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_AllowItemOverlap);
    if (g.DragDropActive)
        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
    hovered |= (g.HoveredId == id);
    if (pressed || ((flags & ImGuiTabItemFlags_SetSelected) && !tab_contents_visible)) // SetSelected can only be passed on explicit tab bar
        tab_bar->NextSelectedTabId = id;

    // Allow the close button to overlap unless we are dragging (in which case we don't want any overlapping tabs to be hovered)
    if (!held)
        SetItemAllowOverlap();

    // Drag and drop: re-order tabs
    if (held && !tab_appearing && IsMouseDragging(0))
    {
        if (!g.DragDropActive && (tab_bar->Flags & ImGuiTabBarFlags_Reorderable))
        {
            // While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
            if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x)
            {
                if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)
                    TabBarQueueChangeTabOrder(tab_bar, tab, -1);
            }
            else if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x)
            {
                if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)
                    TabBarQueueChangeTabOrder(tab_bar, tab, +1);
            }
        }
    }

#if 0
    if (hovered && g.HoveredIdNotActiveTimer > 0.50f && bb.GetWidth() < tab->WidthContents)
    {
        // Enlarge tab display when hovering
        bb.Max.x = bb.Min.x + (float)(int)ImLerp(bb.GetWidth(), tab->WidthContents, ImSaturate((g.HoveredIdNotActiveTimer - 0.40f) * 6.0f));
        display_draw_list = GetOverlayDrawList(window);
        TabItemRenderBackground(display_draw_list, bb, flags, GetColorU32(ImGuiCol_TitleBgActive));
    }
#endif

    // Render tab shape
    ImDrawList* display_draw_list = window->DrawList;
    const ImU32 tab_col = GetColorU32((held || hovered) ? ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive) : (tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabUnfocused));
    TabItemBackground(display_draw_list, bb, flags, tab_col);
    RenderNavHighlight(bb, id);

    // Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.
    const bool hovered_unblocked = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);
    if (hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)))
        tab_bar->NextSelectedTabId = id;

    if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)
        flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;

    // Render tab label, process close button
    const ImGuiID close_button_id = p_open ? window->GetID((void*)(intptr_t)(id + 1)) : 0;
    bool just_closed = TabItemLabelAndCloseButton(display_draw_list, bb, flags, label, id, close_button_id);
    if (just_closed)
    {
        *p_open = false;
        TabBarCloseTab(tab_bar, tab);
    }

    // Restore main window position so user can draw there
    if (want_clip_rect)
        PopClipRect();
    window->DC.CursorPos = backup_main_cursor_pos;

    // Tooltip (FIXME: Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer)
    if (g.HoveredId == id && !held && g.HoveredIdNotActiveTimer > 0.50f)
        SetTooltip("%.*s", (int)(FindRenderedTextEnd(label) - label), label);

    return tab_contents_visible;
}

// [Public] This is call is 100% optional but it allows to remove some one-frame glitches when a tab has been unexpectedly removed.
// To use it to need to call the function SetTabItemClosed() after BeginTabBar() and before any call to BeginTabItem()
void    ImGui::SetTabItemClosed(const char* label)
{
    ImGuiContext& g = *GImGui;
    bool is_within_manual_tab_bar = (g.CurrentTabBar.Size > 0) && !(g.CurrentTabBar.back()->Flags & ImGuiTabBarFlags_DockNode);
    if (is_within_manual_tab_bar)
    {
        ImGuiTabBar* tab_bar = g.CurrentTabBar.back();
        IM_ASSERT(tab_bar->WantLayout);         // Needs to be called AFTER BeginTabBar() and BEFORE the first call to BeginTabItem()
        ImGuiID tab_id = TabBarCalcTabID(tab_bar, label);
        TabBarRemoveTab(tab_bar, tab_id);
    }
}

ImVec2 ImGui::TabItemCalcSize(const char* label, bool has_close_button)
{
    ImGuiContext& g = *GImGui;
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f);
    if (has_close_button)
        size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize); // We use Y intentionally to fit the close button circle.
    else
        size.x += g.Style.FramePadding.x + 1.0f;
    return ImVec2(ImMin(size.x, TabBarCalcMaxTabWidth()), size.y);
}

void ImGui::TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col)
{
    // While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking "detached" from it.
    (void)flags;
    ImGuiContext& g = *GImGui;
    const float width = bb.GetWidth();
    IM_ASSERT(width > 0.0f);
    const float rounding = ImMax(0.0f, ImMin(g.Style.TabRounding, width * 0.5f - 1.0f));
    float y1 = bb.Min.y + 1.0f;
    float y2 = bb.Max.y - 1.0f;
    draw_list->PathLineTo(ImVec2(bb.Min.x, y2));
    draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);
    draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);
    draw_list->PathLineTo(ImVec2(bb.Max.x, y2));
    draw_list->AddConvexPolyFilled(draw_list->_Path.Data, draw_list->_Path.Size, col);
    if (g.Style.TabBorderSize > 0.0f)
        draw_list->AddPolyline(draw_list->_Path.Data, draw_list->_Path.Size, GetColorU32(ImGuiCol_Border), false, g.Style.TabBorderSize);
    draw_list->PathClear();
}

// Render text label (with custom clipping) + Unsaved Document marker + Close Button logic
bool ImGui::TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, const char* label, ImGuiID tab_id, ImGuiID close_button_id)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    if (bb.GetWidth() <= 1.0f)
        return false;

    // Render text label (with clipping + alpha gradient) + unsaved marker
    const char* TAB_UNSAVED_MARKER = "*";
    ImRect text_pixel_clip_bb(bb.Min.x + style.FramePadding.x, bb.Min.y + style.FramePadding.y, bb.Max.x - style.FramePadding.x, bb.Max.y);
    if (flags & ImGuiTabItemFlags_UnsavedDocument)
    {
        text_pixel_clip_bb.Max.x -= CalcTextSize(TAB_UNSAVED_MARKER, NULL, false).x;
        ImVec2 unsaved_marker_pos(ImMin(bb.Min.x + style.FramePadding.x + label_size.x + 2, text_pixel_clip_bb.Max.x), bb.Min.y + style.FramePadding.y + (float)(int)(-g.FontSize * 0.25f));
        RenderTextClippedEx(draw_list, unsaved_marker_pos, bb.Max - style.FramePadding, TAB_UNSAVED_MARKER, NULL, NULL);
    }
    ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;

    // Close Button
    // We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
    //  'hovered' will be true when hovering the Tab but NOT when hovering the close button
    //  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button
    //  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false
    bool close_button_pressed = false;
    bool close_button_visible = false;
    if (close_button_id != 0)
        if (g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == close_button_id)
            close_button_visible = true;
    if (close_button_visible)
    {
        ImGuiItemHoveredDataBackup last_item_backup;
        const float close_button_sz = g.FontSize * 0.5f;
        if (CloseButton(close_button_id, ImVec2(bb.Max.x - style.FramePadding.x - close_button_sz, bb.Min.y + style.FramePadding.y + close_button_sz), close_button_sz))
            close_button_pressed = true;
        last_item_backup.Restore();

        // Close with middle mouse button
        if (!(flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) && IsMouseClicked(2))
            close_button_pressed = true;

        text_pixel_clip_bb.Max.x -= close_button_sz * 2.0f;
    }

    // Label with ellipsis
    // FIXME: This should be extracted into a helper but the use of text_pixel_clip_bb and !close_button_visible makes it tricky to abstract at the moment
    const char* label_display_end = FindRenderedTextEnd(label);
    if (label_size.x > text_ellipsis_clip_bb.GetWidth())
    {
        const int ellipsis_dot_count = 3;
        const float ellipsis_width = (1.0f + 1.0f) * ellipsis_dot_count - 1.0f;
        const char* label_end = NULL;
        float label_size_clipped_x = g.Font->CalcTextSizeA(g.FontSize, text_ellipsis_clip_bb.GetWidth() - ellipsis_width + 1.0f, 0.0f, label, label_display_end, &label_end).x;
        if (label_end == label && label_end < label_display_end)    // Always display at least 1 character if there's no room for character + ellipsis
        {
            label_end = label + ImTextCountUtf8BytesFromChar(label, label_display_end);
            label_size_clipped_x = g.Font->CalcTextSizeA(g.FontSize, FLT_MAX, 0.0f, label, label_end).x;
        }
        while (label_end > label && ImCharIsBlankA(label_end[-1])) // Trim trailing space
        {
            label_end--;
            label_size_clipped_x -= g.Font->CalcTextSizeA(g.FontSize, FLT_MAX, 0.0f, label_end, label_end + 1).x; // Ascii blanks are always 1 byte
        }
        RenderTextClippedEx(draw_list, text_pixel_clip_bb.Min, text_pixel_clip_bb.Max, label, label_end, &label_size, ImVec2(0.0f, 0.0f));

        const float ellipsis_x = text_pixel_clip_bb.Min.x + label_size_clipped_x + 1.0f;
        if (!close_button_visible && ellipsis_x + ellipsis_width <= bb.Max.x)
            RenderPixelEllipsis(draw_list, g.Font, ImVec2(ellipsis_x, text_pixel_clip_bb.Min.y), ellipsis_dot_count, GetColorU32(ImGuiCol_Text));
    }
    else
    {
        RenderTextClippedEx(draw_list, text_pixel_clip_bb.Min, text_pixel_clip_bb.Max, label, label_display_end, &label_size, ImVec2(0.0f, 0.0f));
    }

    return close_button_pressed;
}

```

`Private Esp/imgui/imstb_rectpack.h`:

```h
// stb_rect_pack.h - v0.11 - public domain - rectangle packing
// Sean Barrett 2014
//
// Useful for e.g. packing rectangular textures into an atlas.
// Does not do rotation.
//
// Not necessarily the awesomest packing method, but better than
// the totally naive one in stb_truetype (which is primarily what
// this is meant to replace).
//
// Has only had a few tests run, may have issues.
//
// More docs to come.
//
// No memory allocations; uses qsort() and assert() from stdlib.
// Can override those by defining STBRP_SORT and STBRP_ASSERT.
//
// This library currently uses the Skyline Bottom-Left algorithm.
//
// Please note: better rectangle packers are welcome! Please
// implement them to the same API, but with a different init
// function.
//
// Credits
//
//  Library
//    Sean Barrett
//  Minor features
//    Martins Mozeiko
//    github:IntellectualKitty
//    
//  Bugfixes / warning fixes
//    Jeremy Jaussaud
//
// Version history:
//
//     0.11  (2017-03-03)  return packing success/fail result
//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings
//     0.09  (2016-08-27)  fix compiler warnings
//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)
//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)
//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort
//     0.05:  added STBRP_ASSERT to allow replacing assert
//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support
//     0.01:  initial release
//
// LICENSE
//
//   See end of file for license information.

//////////////////////////////////////////////////////////////////////////////
//
//       INCLUDE SECTION
//

#ifndef STB_INCLUDE_STB_RECT_PACK_H
#define STB_INCLUDE_STB_RECT_PACK_H

#define STB_RECT_PACK_VERSION  1

#ifdef STBRP_STATIC
#define STBRP_DEF static
#else
#define STBRP_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct stbrp_context stbrp_context;
typedef struct stbrp_node    stbrp_node;
typedef struct stbrp_rect    stbrp_rect;

#ifdef STBRP_LARGE_RECTS
typedef int            stbrp_coord;
#else
typedef unsigned short stbrp_coord;
#endif

STBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);
// Assign packed locations to rectangles. The rectangles are of type
// 'stbrp_rect' defined below, stored in the array 'rects', and there
// are 'num_rects' many of them.
//
// Rectangles which are successfully packed have the 'was_packed' flag
// set to a non-zero value and 'x' and 'y' store the minimum location
// on each axis (i.e. bottom-left in cartesian coordinates, top-left
// if you imagine y increasing downwards). Rectangles which do not fit
// have the 'was_packed' flag set to 0.
//
// You should not try to access the 'rects' array from another thread
// while this function is running, as the function temporarily reorders
// the array while it executes.
//
// To pack into another rectangle, you need to call stbrp_init_target
// again. To continue packing into the same rectangle, you can call
// this function again. Calling this multiple times with multiple rect
// arrays will probably produce worse packing results than calling it
// a single time with the full rectangle array, but the option is
// available.
//
// The function returns 1 if all of the rectangles were successfully
// packed and 0 otherwise.

struct stbrp_rect
{
   // reserved for your use:
   int            id;

   // input:
   stbrp_coord    w, h;

   // output:
   stbrp_coord    x, y;
   int            was_packed;  // non-zero if valid packing

}; // 16 bytes, nominally


STBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);
// Initialize a rectangle packer to:
//    pack a rectangle that is 'width' by 'height' in dimensions
//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long
//
// You must call this function every time you start packing into a new target.
//
// There is no "shutdown" function. The 'nodes' memory must stay valid for
// the following stbrp_pack_rects() call (or calls), but can be freed after
// the call (or calls) finish.
//
// Note: to guarantee best results, either:
//       1. make sure 'num_nodes' >= 'width'
//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'
//
// If you don't do either of the above things, widths will be quantized to multiples
// of small integers to guarantee the algorithm doesn't run out of temporary storage.
//
// If you do #2, then the non-quantized algorithm will be used, but the algorithm
// may run out of temporary storage and be unable to pack some rectangles.

STBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);
// Optionally call this function after init but before doing any packing to
// change the handling of the out-of-temp-memory scenario, described above.
// If you call init again, this will be reset to the default (false).


STBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);
// Optionally select which packing heuristic the library should use. Different
// heuristics will produce better/worse results for different data sets.
// If you call init again, this will be reset to the default.

enum
{
   STBRP_HEURISTIC_Skyline_default=0,
   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,
   STBRP_HEURISTIC_Skyline_BF_sortHeight
};


//////////////////////////////////////////////////////////////////////////////
//
// the details of the following structures don't matter to you, but they must
// be visible so you can handle the memory allocations for them

struct stbrp_node
{
   stbrp_coord  x,y;
   stbrp_node  *next;
};

struct stbrp_context
{
   int width;
   int height;
   int align;
   int init_mode;
   int heuristic;
   int num_nodes;
   stbrp_node *active_head;
   stbrp_node *free_head;
   stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'
};

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////
//
//     IMPLEMENTATION SECTION
//

#ifdef STB_RECT_PACK_IMPLEMENTATION
#ifndef STBRP_SORT
#include <stdlib.h>
#define STBRP_SORT qsort
#endif

#ifndef STBRP_ASSERT
#include <assert.h>
#define STBRP_ASSERT assert
#endif

#ifdef _MSC_VER
#define STBRP__NOTUSED(v)  (void)(v)
#define STBRP__CDECL __cdecl
#else
#define STBRP__NOTUSED(v)  (void)sizeof(v)
#define STBRP__CDECL
#endif

enum
{
   STBRP__INIT_skyline = 1
};

STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)
{
   switch (context->init_mode) {
      case STBRP__INIT_skyline:
         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);
         context->heuristic = heuristic;
         break;
      default:
         STBRP_ASSERT(0);
   }
}

STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)
{
   if (allow_out_of_mem)
      // if it's ok to run out of memory, then don't bother aligning them;
      // this gives better packing, but may fail due to OOM (even though
      // the rectangles easily fit). @TODO a smarter approach would be to only
      // quantize once we've hit OOM, then we could get rid of this parameter.
      context->align = 1;
   else {
      // if it's not ok to run out of memory, then quantize the widths
      // so that num_nodes is always enough nodes.
      //
      // I.e. num_nodes * align >= width
      //                  align >= width / num_nodes
      //                  align = ceil(width/num_nodes)

      context->align = (context->width + context->num_nodes-1) / context->num_nodes;
   }
}

STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
{
   int i;
#ifndef STBRP_LARGE_RECTS
   STBRP_ASSERT(width <= 0xffff && height <= 0xffff);
#endif

   for (i=0; i < num_nodes-1; ++i)
      nodes[i].next = &nodes[i+1];
   nodes[i].next = NULL;
   context->init_mode = STBRP__INIT_skyline;
   context->heuristic = STBRP_HEURISTIC_Skyline_default;
   context->free_head = &nodes[0];
   context->active_head = &context->extra[0];
   context->width = width;
   context->height = height;
   context->num_nodes = num_nodes;
   stbrp_setup_allow_out_of_mem(context, 0);

   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
   context->extra[0].x = 0;
   context->extra[0].y = 0;
   context->extra[0].next = &context->extra[1];
   context->extra[1].x = (stbrp_coord) width;
#ifdef STBRP_LARGE_RECTS
   context->extra[1].y = (1<<30);
#else
   context->extra[1].y = 65535;
#endif
   context->extra[1].next = NULL;
}

// find minimum y position if it starts at x1
static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)
{
   stbrp_node *node = first;
   int x1 = x0 + width;
   int min_y, visited_width, waste_area;

   STBRP__NOTUSED(c);

   STBRP_ASSERT(first->x <= x0);

   #if 0
   // skip in case we're past the node
   while (node->next->x <= x0)
      ++node;
   #else
   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
   #endif

   STBRP_ASSERT(node->x <= x0);

   min_y = 0;
   waste_area = 0;
   visited_width = 0;
   while (node->x < x1) {
      if (node->y > min_y) {
         // raise min_y higher.
         // we've accounted for all waste up to min_y,
         // but we'll now add more waste for everything we've visted
         waste_area += visited_width * (node->y - min_y);
         min_y = node->y;
         // the first time through, visited_width might be reduced
         if (node->x < x0)
            visited_width += node->next->x - x0;
         else
            visited_width += node->next->x - node->x;
      } else {
         // add waste area
         int under_width = node->next->x - node->x;
         if (under_width + visited_width > width)
            under_width = width - visited_width;
         waste_area += under_width * (min_y - node->y);
         visited_width += under_width;
      }
      node = node->next;
   }

   *pwaste = waste_area;
   return min_y;
}

typedef struct
{
   int x,y;
   stbrp_node **prev_link;
} stbrp__findresult;

static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)
{
   int best_waste = (1<<30), best_x, best_y = (1 << 30);
   stbrp__findresult fr;
   stbrp_node **prev, *node, *tail, **best = NULL;

   // align to multiple of c->align
   width = (width + c->align - 1);
   width -= width % c->align;
   STBRP_ASSERT(width % c->align == 0);

   node = c->active_head;
   prev = &c->active_head;
   while (node->x + width <= c->width) {
      int y,waste;
      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
         // bottom left
         if (y < best_y) {
            best_y = y;
            best = prev;
         }
      } else {
         // best-fit
         if (y + height <= c->height) {
            // can only use it if it first vertically
            if (y < best_y || (y == best_y && waste < best_waste)) {
               best_y = y;
               best_waste = waste;
               best = prev;
            }
         }
      }
      prev = &node->next;
      node = node->next;
   }

   best_x = (best == NULL) ? 0 : (*best)->x;

   // if doing best-fit (BF), we also have to try aligning right edge to each node position
   //
   // e.g, if fitting
   //
   //     ____________________
   //    |____________________|
   //
   //            into
   //
   //   |                         |
   //   |             ____________|
   //   |____________|
   //
   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
   //
   // This makes BF take about 2x the time

   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
      tail = c->active_head;
      node = c->active_head;
      prev = &c->active_head;
      // find first node that's admissible
      while (tail->x < width)
         tail = tail->next;
      while (tail) {
         int xpos = tail->x - width;
         int y,waste;
         STBRP_ASSERT(xpos >= 0);
         // find the left position that matches this
         while (node->next->x <= xpos) {
            prev = &node->next;
            node = node->next;
         }
         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
         if (y + height < c->height) {
            if (y <= best_y) {
               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {
                  best_x = xpos;
                  STBRP_ASSERT(y <= best_y);
                  best_y = y;
                  best_waste = waste;
                  best = prev;
               }
            }
         }
         tail = tail->next;
      }         
   }

   fr.prev_link = best;
   fr.x = best_x;
   fr.y = best_y;
   return fr;
}

static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)
{
   // find best position according to heuristic
   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
   stbrp_node *node, *cur;

   // bail if:
   //    1. it failed
   //    2. the best node doesn't fit (we don't always check this)
   //    3. we're out of memory
   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
      res.prev_link = NULL;
      return res;
   }

   // on success, create new node
   node = context->free_head;
   node->x = (stbrp_coord) res.x;
   node->y = (stbrp_coord) (res.y + height);

   context->free_head = node->next;

   // insert the new node into the right starting point, and
   // let 'cur' point to the remaining nodes needing to be
   // stiched back in

   cur = *res.prev_link;
   if (cur->x < res.x) {
      // preserve the existing one, so start testing with the next one
      stbrp_node *next = cur->next;
      cur->next = node;
      cur = next;
   } else {
      *res.prev_link = node;
   }

   // from here, traverse cur and free the nodes, until we get to one
   // that shouldn't be freed
   while (cur->next && cur->next->x <= res.x + width) {
      stbrp_node *next = cur->next;
      // move the current node to the free list
      cur->next = context->free_head;
      context->free_head = cur;
      cur = next;
   }

   // stitch the list back in
   node->next = cur;

   if (cur->x < res.x + width)
      cur->x = (stbrp_coord) (res.x + width);

#ifdef _DEBUG
   cur = context->active_head;
   while (cur->x < context->width) {
      STBRP_ASSERT(cur->x < cur->next->x);
      cur = cur->next;
   }
   STBRP_ASSERT(cur->next == NULL);

   {
      int count=0;
      cur = context->active_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      cur = context->free_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      STBRP_ASSERT(count == context->num_nodes+2);
   }
#endif

   return res;
}

static int STBRP__CDECL rect_height_compare(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   if (p->h > q->h)
      return -1;
   if (p->h < q->h)
      return  1;
   return (p->w > q->w) ? -1 : (p->w < q->w);
}

static int STBRP__CDECL rect_original_order(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
}

#ifdef STBRP_LARGE_RECTS
#define STBRP__MAXVAL  0xffffffff
#else
#define STBRP__MAXVAL  0xffff
#endif

STBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)
{
   int i, all_rects_packed = 1;

   // we use the 'was_packed' field internally to allow sorting/unsorting
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = i;
      #ifndef STBRP_LARGE_RECTS
      STBRP_ASSERT(rects[i].w <= 0xffff && rects[i].h <= 0xffff);
      #endif
   }

   // sort according to heuristic
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

   for (i=0; i < num_rects; ++i) {
      if (rects[i].w == 0 || rects[i].h == 0) {
         rects[i].x = rects[i].y = 0;  // empty rect needs no space
      } else {
         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
         if (fr.prev_link) {
            rects[i].x = (stbrp_coord) fr.x;
            rects[i].y = (stbrp_coord) fr.y;
         } else {
            rects[i].x = rects[i].y = STBRP__MAXVAL;
         }
      }
   }

   // unsort
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

   // set was_packed flags and all_rects_packed status
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
      if (!rects[i].was_packed)
         all_rects_packed = 0;
   }

   // return the all_rects_packed status
   return all_rects_packed;
}
#endif

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`Private Esp/imgui/imstb_textedit.h`:

```h
// [ImGui] this is a slightly modified version of stb_textedit.h 1.12. Those changes would need to be pushed into nothings/stb
// [ImGui] - 2018-06: fixed undo/redo after pasting large amount of text (over 32 kb). Redo will still fail when undo buffers are exhausted, but text won't be corrupted (see nothings/stb issue #620)
// [ImGui] - 2018-06: fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)
// [ImGui] - fixed some minor warnings

// stb_textedit.h - v1.12  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
// 
//
// LICENSE
//
// See end of file for license information.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining STB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash
//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield
//   1.10 (2016-10-25) supress warnings about casting away const with -Wcast-qual
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary keys for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//      Dan Thompson
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATE_COUNT
//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHAR_COUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Todo:
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTED_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control keys will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//     
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//     
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//     
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//     
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to
//          anything other type you wante before including.
//
//     
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

#ifndef INCLUDE_STB_TEXTEDIT_H
#define INCLUDE_STB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

#ifndef STB_TEXTEDIT_UNDOSTATECOUNT
#define STB_TEXTEDIT_UNDOSTATECOUNT   99
#endif
#ifndef STB_TEXTEDIT_UNDOCHARCOUNT
#define STB_TEXTEDIT_UNDOCHARCOUNT   999
#endif
#ifndef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_CHARTYPE        int
#endif
#ifndef STB_TEXTEDIT_POSITIONTYPE
#define STB_TEXTEDIT_POSITIONTYPE    int
#endif

typedef struct
{
   // private data
   STB_TEXTEDIT_POSITIONTYPE  where;
   STB_TEXTEDIT_POSITIONTYPE  insert_length;
   STB_TEXTEDIT_POSITIONTYPE  delete_length;
   int                        char_storage;
} StbUndoRecord;

typedef struct
{
   // private data
   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];
   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];
   short undo_point, redo_point;
   int undo_char_point, redo_char_point;
} StbUndoState;

typedef struct
{
   /////////////////////
   //
   // public data
   //

   int cursor;
   // position of the text cursor within the string

   int select_start;          // selection start point
   int select_end;
   // selection start and end point in characters; if equal, no selection.
   // note that start may be less than or greater than end (e.g. when
   // dragging the mouse, start is where the initial click was, and you
   // can drag in either direction)

   unsigned char insert_mode;
   // each textfield keeps its own insert mode state. to keep an app-wide
   // insert mode, copy this value in/out of the app state

   /////////////////////
   //
   // private data
   //
   unsigned char cursor_at_end_of_line; // not implemented yet
   unsigned char initialized;
   unsigned char has_preferred_x;
   unsigned char single_line;
   unsigned char padding1, padding2, padding3;
   float preferred_x; // this determines where the cursor up/down tries to seek to along x
   StbUndoState undostate;
} STB_TexteditState;


////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
typedef struct
{
   float x0,x1;             // starting x location, end x location (allows for align=right, etc)
   float baseline_y_delta;  // position of baseline relative to previous row's baseline
   float ymin,ymax;         // height of row above and below baseline
   int num_chars;
} StbTexteditRow;
#endif //INCLUDE_STB_TEXTEDIT_H


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////


// implementation isn't include-guarded, since it might have indirectly
// included just the "header" portion
#ifdef STB_TEXTEDIT_IMPLEMENTATION

#ifndef STB_TEXTEDIT_memmove
#include <string.h>
#define STB_TEXTEDIT_memmove memmove
#endif


/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
static int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)
{
   StbTexteditRow r;
   int n = STB_TEXTEDIT_STRINGLEN(str);
   float base_y = 0, prev_x;
   int i=0, k;

   r.x0 = r.x1 = 0;
   r.ymin = r.ymax = 0;
   r.num_chars = 0;

   // search rows to find one that straddles 'y'
   while (i < n) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (r.num_chars <= 0)
         return n;

      if (i==0 && y < base_y + r.ymin)
         return 0;

      if (y < base_y + r.ymax)
         break;

      i += r.num_chars;
      base_y += r.baseline_y_delta;
   }

   // below all text, return 'after' last character
   if (i >= n)
      return n;

   // check if it's before the beginning of the line
   if (x < r.x0)
      return i;

   // check if it's before the end of the line
   if (x < r.x1) {
      // search characters in row for one that straddles 'x'
      prev_x = r.x0;
      for (k=0; k < r.num_chars; ++k) {
         float w = STB_TEXTEDIT_GETWIDTH(str, i, k);
         if (x < prev_x+w) {
            if (x < prev_x+w/2)
               return k+i;
            else
               return k+i+1;
         }
         prev_x += w;
      }
      // shouldn't happen, but if it does, fall through to end-of-line case
   }

   // if the last character is a newline, return that. otherwise return 'after' the last character
   if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)
      return i+r.num_chars-1;
   else
      return i+r.num_chars;
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
static void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   state->cursor = stb_text_locate_coord(str, x, y);
   state->select_start = state->cursor;
   state->select_end = state->cursor;
   state->has_preferred_x = 0;
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
static void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   int p = 0;

   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   if (state->select_start == state->select_end)
      state->select_start = state->cursor;

   p = stb_text_locate_coord(str, x, y);
   state->cursor = state->select_end = p;
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);

typedef struct
{
   float x,y;    // position of n'th character
   float height; // height of line
   int first_char, length; // first char of row, and length
   int prev_first;  // first char of previous row
} StbFindState;

// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
static void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)
{
   StbTexteditRow r;
   int prev_start = 0;
   int z = STB_TEXTEDIT_STRINGLEN(str);
   int i=0, first;

   if (n == z) {
      // if it's at the end, then find the last line -- simpler than trying to
      // explicitly handle this case in the regular code
      if (single_line) {
         STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
         find->y = 0;
         find->first_char = 0;
         find->length = z;
         find->height = r.ymax - r.ymin;
         find->x = r.x1;
      } else {
         find->y = 0;
         find->x = 0;
         find->height = 1;
         while (i < z) {
            STB_TEXTEDIT_LAYOUTROW(&r, str, i);
            prev_start = i;
            i += r.num_chars;
         }
         find->first_char = i;
         find->length = 0;
         find->prev_first = prev_start;
      }
      return;
   }

   // search rows to find the one that straddles character n
   find->y = 0;

   for(;;) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (n < i + r.num_chars)
         break;
      prev_start = i;
      i += r.num_chars;
      find->y += r.baseline_y_delta;
   }

   find->first_char = first = i;
   find->length = r.num_chars;
   find->height = r.ymax - r.ymin;
   find->prev_first = prev_start;

   // now scan to find xpos
   find->x = r.x0;
   i = 0;
   for (i=0; first+i < n; ++i)
      find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);
}

#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)

// make the selection/cursor state valid if client altered the string
static void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   int n = STB_TEXTEDIT_STRINGLEN(str);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start > n) state->select_start = n;
      if (state->select_end   > n) state->select_end = n;
      // if clamping forced them to be equal, move the cursor to match
      if (state->select_start == state->select_end)
         state->cursor = state->select_start;
   }
   if (state->cursor > n) state->cursor = n;
}

// delete characters while updating undo
static void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)
{
   stb_text_makeundo_delete(str, state, where, len);
   STB_TEXTEDIT_DELETECHARS(str, where, len);
   state->has_preferred_x = 0;
}

// delete the section
static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   stb_textedit_clamp(str, state);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start < state->select_end) {
         stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);
         state->select_end = state->cursor = state->select_start;
      } else {
         stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);
         state->select_start = state->cursor = state->select_end;
      }
      state->has_preferred_x = 0;
   }
}

// canoncialize the selection so start <= end
static void stb_textedit_sortselection(STB_TexteditState *state)
{
   if (state->select_end < state->select_start) {
      int temp = state->select_end;
      state->select_end = state->select_start;
      state->select_start = temp;
   }
}

// move cursor to first character of selection
static void stb_textedit_move_to_first(STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      state->cursor = state->select_start;
      state->select_end = state->select_start;
      state->has_preferred_x = 0;
   }
}

// move cursor to last character of selection
static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      stb_textedit_clamp(str, state);
      state->cursor = state->select_end;
      state->select_start = state->select_end;
      state->has_preferred_x = 0;
   }
}

#ifdef STB_TEXTEDIT_IS_SPACE
static int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )
{
   return idx > 0 ? (STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str,idx-1) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str, idx) ) ) : 1;
}

#ifndef STB_TEXTEDIT_MOVEWORDLEFT
static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )
{
   --c; // always move at least one character
   while( c >= 0 && !is_word_boundary( str, c ) )
      --c;

   if( c < 0 )
      c = 0;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous
#endif

#ifndef STB_TEXTEDIT_MOVEWORDRIGHT
static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )
{
   const int len = STB_TEXTEDIT_STRINGLEN(str);
   ++c; // always move at least one character
   while( c < len && !is_word_boundary( str, c ) )
      ++c;

   if( c > len )
      c = len;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next
#endif

#endif

// update selection and cursor to match each other
static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)
{
   if (!STB_TEXT_HAS_SELECTION(state))
      state->select_start = state->select_end = state->cursor;
   else
      state->cursor = state->select_end;
}

// API cut: delete selection
static int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_delete_selection(str,state); // implicity clamps
      state->has_preferred_x = 0;
      return 1;
   }
   return 0;
}

// API paste: replace existing selection with passed-in text
static int stb_textedit_paste_internal(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
{
   // if there's a selection, the paste should delete it
   stb_textedit_clamp(str, state);
   stb_textedit_delete_selection(str,state);
   // try to insert the characters
   if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {
      stb_text_makeundo_insert(state, state->cursor, len);
      state->cursor += len;
      state->has_preferred_x = 0;
      return 1;
   }
   // remove the undo since we didn't actually insert the characters
   if (state->undostate.undo_point)
      --state->undostate.undo_point;
   return 0;
}

#ifndef STB_TEXTEDIT_KEYTYPE
#define STB_TEXTEDIT_KEYTYPE int
#endif

// API key: process a keyboard input
static void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)
{
retry:
   switch (key) {
      default: {
         int c = STB_TEXTEDIT_KEYTOTEXT(key);
         if (c > 0) {
            STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;

            // can't add newline in single-line mode
            if (c == '\n' && state->single_line)
               break;

            if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {
               stb_text_makeundo_replace(str, state, state->cursor, 1, 1);
               STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            } else {
               stb_textedit_delete_selection(str,state); // implicity clamps
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  stb_text_makeundo_insert(state, state->cursor, 1);
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            }
         }
         break;
      }

#ifdef STB_TEXTEDIT_K_INSERT
      case STB_TEXTEDIT_K_INSERT:
         state->insert_mode = !state->insert_mode;
         break;
#endif
         
      case STB_TEXTEDIT_K_UNDO:
         stb_text_undo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_REDO:
         stb_text_redo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT:
         // if currently there's a selection, move cursor to start of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else 
            if (state->cursor > 0)
               --state->cursor;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_RIGHT:
         // if currently there's a selection, move cursor to end of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);
         else
            ++state->cursor;
         stb_textedit_clamp(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         // move selection left
         if (state->select_end > 0)
            --state->select_end;
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_MOVEWORDLEFT
      case STB_TEXTEDIT_K_WORDLEFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

#ifdef STB_TEXTEDIT_MOVEWORDRIGHT
      case STB_TEXTEDIT_K_WORDRIGHT:
         if (STB_TEXT_HAS_SELECTION(state)) 
            stb_textedit_move_to_last(str, state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

      case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         // move selection right
         ++state->select_end;
         stb_textedit_clamp(str, state);
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_DOWN:
      case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

         if (state->single_line) {
            // on windows, up&down in single-line behave like left&right
            key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str,state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         // now find character position down a row
         if (find.length) {
            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
            float x;
            int start = find.first_char + find.length;
            state->cursor = start;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;
         }
         break;
      }
         
      case STB_TEXTEDIT_K_UP:
      case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

         if (state->single_line) {
            // on windows, up&down become left&right
            key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         // can only go up if there's a previous row
         if (find.prev_first != find.first_char) {
            // now find character position up a row
            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
            float x;
            state->cursor = find.prev_first;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;
         }
         break;
      }

      case STB_TEXTEDIT_K_DELETE:
      case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            int n = STB_TEXTEDIT_STRINGLEN(str);
            if (state->cursor < n)
               stb_textedit_delete(str, state, state->cursor, 1);
         }
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_BACKSPACE:
      case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            stb_textedit_clamp(str, state);
            if (state->cursor > 0) {
               stb_textedit_delete(str, state, state->cursor-1, 1);
               --state->cursor;
            }
         }
         state->has_preferred_x = 0;
         break;
         
#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2:
#endif
      case STB_TEXTEDIT_K_TEXTSTART:
         state->cursor = state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2:
#endif
      case STB_TEXTEDIT_K_TEXTEND:
         state->cursor = STB_TEXTEDIT_STRINGLEN(str);
         state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;
        
#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);
         state->has_preferred_x = 0;
         break;


#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2:
#endif
      case STB_TEXTEDIT_K_LINESTART:
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2:
#endif
      case STB_TEXTEDIT_K_LINEEND: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
             ++state->cursor;
         state->has_preferred_x = 0;
         break;
      }

#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
            ++state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;
      }

// @TODO:
//    STB_TEXTEDIT_K_PGUP      - move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
   }
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

static void stb_textedit_flush_redo(StbUndoState *state)
{
   state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
}

// discard the oldest entry in the undo list
static void stb_textedit_discard_undo(StbUndoState *state)
{
   if (state->undo_point > 0) {
      // if the 0th undo state has characters, clean those up
      if (state->undo_rec[0].char_storage >= 0) {
         int n = state->undo_rec[0].insert_length, i;
         // delete n characters from all other records
         state->undo_char_point -= n;
         STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));
         for (i=0; i < state->undo_point; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it
      }
      --state->undo_point;
      STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));
   }
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
static void stb_textedit_discard_redo(StbUndoState *state)
{
   int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;

   if (state->redo_point <= k) {
      // if the k'th undo state has characters, clean those up
      if (state->undo_rec[k].char_storage >= 0) {
         int n = state->undo_rec[k].insert_length, i;
         // move the remaining redo character data to the end of the buffer
         state->redo_char_point += n;
         STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));
         // adjust the position of all the other records to account for above memmove
         for (i=state->redo_point; i < k; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage += n;
      }
      // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
      STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, (size_t) ((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point)*sizeof(state->undo_rec[0])));
      // now move redo_point to point to the new one
      ++state->redo_point;
   }
}

static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)
{
   // any time we create a new undo record, we discard redo
   stb_textedit_flush_redo(state);

   // if we have no free records, we have to make room, by sliding the
   // existing records down
   if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      stb_textedit_discard_undo(state);

   // if the characters to store won't possibly fit in the buffer, we can't undo
   if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {
      state->undo_point = 0;
      state->undo_char_point = 0;
      return NULL;
   }

   // if we don't have enough free characters in the buffer, we have to make room
   while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)
      stb_textedit_discard_undo(state);

   return &state->undo_rec[state->undo_point++];
}

static STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)
{
   StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);
   if (r == NULL)
      return NULL;

   r->where = pos;
   r->insert_length = (STB_TEXTEDIT_POSITIONTYPE) insert_len;
   r->delete_length = (STB_TEXTEDIT_POSITIONTYPE) delete_len;

   if (insert_len == 0) {
      r->char_storage = -1;
      return NULL;
   } else {
      r->char_storage = state->undo_char_point;
      state->undo_char_point += insert_len;
      return &state->undo_char[r->char_storage];
   }
}

static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord u, *r;
   if (s->undo_point == 0)
      return;

   // we need to do two things: apply the undo record, and create a redo record
   u = s->undo_rec[s->undo_point-1];
   r = &s->undo_rec[s->redo_point-1];
   r->char_storage = -1;

   r->insert_length = u.delete_length;
   r->delete_length = u.insert_length;
   r->where = u.where;

   if (u.delete_length) {
      // if the undo record says to delete characters, then the redo record will
      // need to re-insert the characters that get deleted, so we need to store
      // them.

      // there are three cases:
      //    there's enough room to store the characters
      //    characters stored for *redoing* don't leave room for redo
      //    characters stored for *undoing* don't leave room for redo
      // if the last is true, we have to bail

      if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {
         // the undo records take up too much character space; there's no space to store the redo characters
         r->insert_length = 0;
      } else {
         int i;

         // there's definitely room to store the characters eventually
         while (s->undo_char_point + u.delete_length > s->redo_char_point) {
            // should never happen:
            if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
               return;
            // there's currently not enough room, so discard a redo record
            stb_textedit_discard_redo(s);
         }
         r = &s->undo_rec[s->redo_point-1];

         r->char_storage = s->redo_char_point - u.delete_length;
         s->redo_char_point = s->redo_char_point - u.delete_length;

         // now save the characters
         for (i=0; i < u.delete_length; ++i)
            s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);
      }

      // now we can carry out the deletion
      STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);
   }

   // check type of recorded action:
   if (u.insert_length) {
      // easy case: was a deletion, so we need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);
      s->undo_char_point -= u.insert_length;
   }

   state->cursor = u.where + u.insert_length;

   s->undo_point--;
   s->redo_point--;
}

static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord *u, r;
   if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      return;

   // we need to do two things: apply the redo record, and create an undo record
   u = &s->undo_rec[s->undo_point];
   r = s->undo_rec[s->redo_point];

   // we KNOW there must be room for the undo record, because the redo record
   // was derived from an undo record

   u->delete_length = r.insert_length;
   u->insert_length = r.delete_length;
   u->where = r.where;
   u->char_storage = -1;

   if (r.delete_length) {
      // the redo record requires us to delete characters, so the undo record
      // needs to store the characters

      if (s->undo_char_point + u->insert_length > s->redo_char_point) {
         u->insert_length = 0;
         u->delete_length = 0;
      } else {
         int i;
         u->char_storage = s->undo_char_point;
         s->undo_char_point = s->undo_char_point + u->insert_length;

         // now save the characters
         for (i=0; i < u->insert_length; ++i)
            s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);
      }

      STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);
   }

   if (r.insert_length) {
      // easy case: need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);
      s->redo_char_point += r.insert_length;
   }

   state->cursor = r.where + r.insert_length;

   s->undo_point++;
   s->redo_point++;
}

static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)
{
   stb_text_createundo(&state->undostate, where, 0, length);
}

static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);
   if (p) {
      for (i=0; i < length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);
   if (p) {
      for (i=0; i < old_length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

// reset the state to default
static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)
{
   state->undostate.undo_point = 0;
   state->undostate.undo_char_point = 0;
   state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
   state->select_end = state->select_start = 0;
   state->cursor = 0;
   state->has_preferred_x = 0;
   state->preferred_x = 0;
   state->cursor_at_end_of_line = 0;
   state->initialized = 1;
   state->single_line = (unsigned char) is_single_line;
   state->insert_mode = 0;
}

// API initialize
static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
{
   stb_textedit_clear_state(state, is_single_line);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

static int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)
{
   return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif//STB_TEXTEDIT_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`Private Esp/imgui/imstb_truetype.h`:

```h
// stb_truetype.h - v1.19 - public domain
// authored from 2009-2016 by Sean Barrett / RAD Game Tools
//
//   This library processes TrueType files:
//        parse files
//        extract glyph metrics
//        extract glyph shapes
//        render glyphs to one-channel bitmaps with antialiasing (box filter)
//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)
//
//   Todo:
//        non-MS cmaps
//        crashproof on bad data
//        hinting? (no longer patented)
//        cleartype-style AA?
//        optimize: use simple memory allocator for intermediates
//        optimize: build edge-list directly from curves
//        optimize: rasterize directly from curves?
//
// ADDITIONAL CONTRIBUTORS
//
//   Mikko Mononen: compound shape support, more cmap formats
//   Tor Andersson: kerning, subpixel rendering
//   Dougall Johnson: OpenType / Type 2 font handling
//   Daniel Ribeiro Maciel: basic GPOS-based kerning
//
//   Misc other:
//       Ryan Gordon
//       Simon Glass
//       github:IntellectualKitty
//       Imanol Celaya
//       Daniel Ribeiro Maciel
//
//   Bug/warning reports/fixes:
//       "Zer" on mollyrocket       Fabian "ryg" Giesen
//       Cass Everitt               Martins Mozeiko
//       stoiko (Haemimont Games)   Cap Petschulat
//       Brian Hook                 Omar Cornut
//       Walter van Niftrik         github:aloucks
//       David Gow                  Peter LaValle
//       David Given                Sergey Popov
//       Ivan-Assen Ivanov          Giumo X. Clanjor
//       Anthony Pesch              Higor Euripedes
//       Johan Duparc               Thomas Fields
//       Hou Qiming                 Derek Vinyard
//       Rob Loach                  Cort Stratton
//       Kenney Phillis Jr.         github:oyvindjam
//       Brian Costabile            github:vassvik
//       
// VERSION HISTORY
//
//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     variant PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//
//   Full history can be found at the end of this file.
//
// LICENSE
//
//   See end of file for license information.
//
// USAGE
//
//   Include this file in whatever places neeed to refer to it. In ONE C/C++
//   file, write:
//      #define STB_TRUETYPE_IMPLEMENTATION
//   before the #include of this file. This expands out the actual
//   implementation into that C/C++ file.
//
//   To make the implementation private to the file that generates the implementation,
//      #define STBTT_STATIC
//
//   Simple 3D API (don't ship this, but it's fine for tools and quick start)
//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
//
//   Improved 3D API (more shippable):
//           #include "stb_rect_pack.h"           -- optional, but you really want it
//           stbtt_PackBegin()
//           stbtt_PackSetOversampling()          -- for improved quality on small fonts
//           stbtt_PackFontRanges()               -- pack and renders
//           stbtt_PackEnd()
//           stbtt_GetPackedQuad()
//
//   "Load" a font file from a memory buffer (you have to keep the buffer loaded)
//           stbtt_InitFont()
//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections
//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections
//
//   Render a unicode codepoint to a bitmap
//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
//
//   Character advance/positioning
//           stbtt_GetCodepointHMetrics()
//           stbtt_GetFontVMetrics()
//           stbtt_GetFontVMetricsOS2()
//           stbtt_GetCodepointKernAdvance()
//
//   LoopCallbacking with version 1.06, the rasterizer was replaced with a new,
//   faster and generally-more-precise rasterizer. The new rasterizer more
//   accurately measures pixel coverage for anti-aliasing, except in the case
//   where multiple shapes overlap, in which case it overestimates the AA pixel
//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
//   this turns out to be a problem, you can re-enable the old rasterizer with
//        #define STBTT_RASTERIZER_VERSION 1
//   which will incur about a 15% speed hit.
//
// ADDITIONAL DOCUMENTATION
//
//   Immediately after this block comment are a series of sample programs.
//
//   After the sample programs is the "header file" section. This section
//   includes documentation for each API function.
//
//   Some important concepts to understand to use this library:
//
//      Codepoint
//         Characters are defined by unicode codepoints, e.g. 65 is
//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
//         the hiragana for "ma".
//
//      Glyph
//         A visual character shape (every codepoint is rendered as
//         some glyph)
//
//      Glyph index
//         A font-specific integer ID representing a glyph
//
//      Baseline
//         Glyph shapes are defined relative to a baseline, which is the
//         bottom of uppercase characters. Characters extend both above
//         and below the baseline.
//
//      Current Point
//         As you draw text to the screen, you keep track of a "current point"
//         which is the origin of each character. The current point's vertical
//         position is the baseline. Even "baked fonts" use this model.
//
//      Vertical Font Metrics
//         The vertical qualities of the font, used to vertically position
//         and space the characters. See docs for stbtt_GetFontVMetrics.
//
//      Font Size in Pixels or Points
//         The preferred interface for specifying font sizes in stb_truetype
//         is to specify how tall the font's vertical extent should be in pixels.
//         If that sounds good enough, skip the next paragraph.
//
//         Most font APIs instead use "points", which are a common typographic
//         measurement for describing font size, defined as 72 points per inch.
//         stb_truetype provides a point API for compatibility. However, true
//         "per inch" conventions don't make much sense on computer displays
//         since different monitors have different number of pixels per
//         inch. For example, Windows traditionally uses a convention that
//         there are 96 pixels per inch, thus making 'inch' measurements have
//         nothing to do with inches, and thus effectively defining a point to
//         be 1.333 pixels. Additionally, the TrueType font data provides
//         an explicit scale factor to scale a given font's glyphs to points,
//         but the author has observed that this scale factor is often wrong
//         for non-commercial fonts, thus making fonts scaled in points
//         according to the TrueType spec incoherently sized in practice.
//
// DETAILED USAGE:
//
//  Scale:
//    Select how high you want the font to be, in points or pixels.
//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute
//    a scale factor SF that will be used by all other functions.
//
//  Baseline:
//    You need to select a y-coordinate that is the baseline of where
//    your text will appear. Call GetFontBoundingBox to get the baseline-relative
//    bounding box for all characters. SF*-y0 will be the distance in pixels
//    that the worst-case character could extend above the baseline, so if
//    you want the top edge of characters to appear at the top of the
//    screen where y=0, then you would set the baseline to SF*-y0.
//
//  Current point:
//    Set the current point where the first character will appear. The
//    first character could extend left of the current point; this is font
//    dependent. You can either choose a current point that is the leftmost
//    point and hope, or add some padding, or check the bounding box or
//    left-side-bearing of the first character to be displayed and set
//    the current point based on that.
//
//  Displaying a character:
//    Compute the bounding box of the character. It will contain signed values
//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,
//    then the character should be displayed in the rectangle from
//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).
//
//  Advancing for the next character:
//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.
// 
//
// ADVANCED USAGE
//
//   Quality:
//
//    - Use the functions with Subpixel at the end to allow your characters
//      to have subpixel positioning. Since the font is anti-aliased, not
//      hinted, this is very import for quality. (This is not possible with
//      baked fonts.)
//
//    - Kerning is now supported, and if you're supporting subpixel rendering
//      then kerning is worth using to give your text a polished look.
//
//   Performance:
//
//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
//      if you don't do this, stb_truetype is forced to do the conversion on
//      every call.
//
//    - There are a lot of memory allocations. We should modify it to take
//      a temp buffer and allocate from the temp buffer (without freeing),
//      should help performance a lot.
//
// NOTES
//
//   The system uses the raw data found in the .ttf file without changing it
//   and without building auxiliary data structures. This is a bit inefficient
//   on little-endian systems (the data is big-endian), but assuming you're
//   caching the bitmaps or glyph shapes this shouldn't be a big deal.
//
//   It appears to be very hard to programmatically determine what font a
//   given file is in a general way. I provide an API for this, but I don't
//   recommend it.
//
//
// SOURCE STATISTICS (based on v0.6c, 2050 LOC)
//
//   Documentation & header file        520 LOC  \___ 660 LOC documentation
//   Sample code                        140 LOC  /
//   Truetype parsing                   620 LOC  ---- 620 LOC TrueType
//   Software rasterization             240 LOC  \                           .
//   Curve tesselation                  120 LOC   \__ 550 LOC Bitmap creation
//   Bitmap management                  100 LOC   /
//   Baked bitmap interface              70 LOC  /
//   Font name matching & access        150 LOC  ---- 150 
//   C runtime library abstraction       60 LOC  ----  60
//
//
// PERFORMANCE MEASUREMENTS FOR 1.06:
//
//                      32-bit     64-bit
//   Previous release:  8.83 s     7.68 s
//   Pool allocations:  7.72 s     6.34 s
//   Inline sort     :  6.54 s     5.65 s
//   New rasterizer  :  5.63 s     5.00 s

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////  SAMPLE PROGRAMS
////
//
//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless
//
#if 0
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

unsigned char ttf_buffer[1<<20];
unsigned char temp_bitmap[512*512];

stbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs
GLuint ftex;

void my_stbtt_initfont(void)
{
   fread(ttf_buffer, 1, 1<<20, fopen("c:/windows/fonts/times.ttf", "rb"));
   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!
   // can free ttf_buffer at this point
   glGenTextures(1, &ftex);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);
   // can free temp_bitmap at this point
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
}

void my_stbtt_print(float x, float y, char *text)
{
   // assume orthographic projection with units = screen pixels, origin at top left
   glEnable(GL_TEXTURE_2D);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glBegin(GL_QUADS);
   while (*text) {
      if (*text >= 32 && *text < 128) {
         stbtt_aligned_quad q;
         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9
         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y0);
         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y0);
         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y1);
         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y1);
      }
      ++text;
   }
   glEnd();
}
#endif
//
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program (this compiles): get a single bitmap, print as ASCII art
//
#if 0
#include <stdio.h>
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

char ttf_buffer[1<<25];

int main(int argc, char **argv)
{
   stbtt_fontinfo font;
   unsigned char *bitmap;
   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);

   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));

   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));
   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);

   for (j=0; j < h; ++j) {
      for (i=0; i < w; ++i)
         putchar(" .:ioVM@"[bitmap[j*w+i]>>5]);
      putchar('\n');
   }
   return 0;
}
#endif 
//
// Output:
//
//     .ii.
//    @@@@@@.
//   V@Mio@@o
//   :i.  V@V
//     :oM@@M
//   :@@@MM@M
//   @@o  o@M
//  :@@.  M@M
//   @@@o@@@@
//   :M@@V:@@.
//  
//////////////////////////////////////////////////////////////////////////////
// 
// Complete program: print "Hello World!" banner, with bugs
//
#if 0
char buffer[24<<20];
unsigned char screen[20][79];

int main(int arg, char **argv)
{
   stbtt_fontinfo font;
   int i,j,ascent,baseline,ch=0;
   float scale, xpos=2; // leave a little padding in case the character extends left
   char *text = "Heljo World!"; // intentionally misspelled to show 'lj' brokenness

   fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));
   stbtt_InitFont(&font, buffer, 0);

   scale = stbtt_ScaleForPixelHeight(&font, 15);
   stbtt_GetFontVMetrics(&font, &ascent,0,0);
   baseline = (int) (ascent*scale);

   while (text[ch]) {
      int advance,lsb,x0,y0,x1,y1;
      float x_shift = xpos - (float) floor(xpos);
      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);
      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);
      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);
      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong
      // because this API is really for baking character bitmaps into textures. if you want to render
      // a sequence of characters, you really need to render each bitmap to a temp buffer, then
      // "alpha blend" that into the working buffer
      xpos += (advance * scale);
      if (text[ch+1])
         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);
      ++ch;
   }

   for (j=0; j < 20; ++j) {
      for (i=0; i < 78; ++i)
         putchar(" .:ioVM@"[screen[j][i]>>5]);
      putchar('\n');
   }

   return 0;
}
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////   INTEGRATION WITH YOUR CODEBASE
////
////   The following sections allow you to supply alternate definitions
////   of C library functions used by stb_truetype, e.g. if you don't
////   link with the C runtime library.

#ifdef STB_TRUETYPE_IMPLEMENTATION
   // #define your own (u)stbtt_int8/16/32 before including to override this
   #ifndef stbtt_uint8
   typedef unsigned char   stbtt_uint8;
   typedef signed   char   stbtt_int8;
   typedef unsigned short  stbtt_uint16;
   typedef signed   short  stbtt_int16;
   typedef unsigned int    stbtt_uint32;
   typedef signed   int    stbtt_int32;
   #endif

   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];
   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];

   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h
   #ifndef STBTT_ifloor
   #include <math.h>
   #define STBTT_ifloor(x)   ((int) floor(x))
   #define STBTT_iceil(x)    ((int) ceil(x))
   #endif

   #ifndef STBTT_sqrt
   #include <math.h>
   #define STBTT_sqrt(x)      sqrt(x)
   #define STBTT_pow(x,y)     pow(x,y)
   #endif

   #ifndef STBTT_fmod
   #include <math.h>
   #define STBTT_fmod(x,y)    fmod(x,y)
   #endif

   #ifndef STBTT_cos
   #include <math.h>
   #define STBTT_cos(x)       cos(x)
   #define STBTT_acos(x)      acos(x)
   #endif

   #ifndef STBTT_fabs
   #include <math.h>
   #define STBTT_fabs(x)      fabs(x)
   #endif

   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
   #ifndef STBTT_malloc
   #include <stdlib.h>
   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
   #define STBTT_free(x,u)    ((void)(u),free(x))
   #endif

   #ifndef STBTT_assert
   #include <assert.h>
   #define STBTT_assert(x)    assert(x)
   #endif

   #ifndef STBTT_strlen
   #include <string.h>
   #define STBTT_strlen(x)    strlen(x)
   #endif

   #ifndef STBTT_memcpy
   #include <string.h>
   #define STBTT_memcpy       memcpy
   #define STBTT_memset       memset
   #endif
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   INTERFACE
////
////

#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
#define __STB_INCLUDE_STB_TRUETYPE_H__

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

// private structure
typedef struct
{
   unsigned char *data;
   int cursor;
   int size;
} stbtt__buf;

//////////////////////////////////////////////////////////////////////////////
//
// TEXTURE BAKING API
//
// If you use this API, you only have to call two functions ever.
//

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
} stbtt_bakedchar;

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long
// if return is positive, the first unused row of the bitmap
// if return is negative, returns the negative of the number of characters that fit
// if return is 0, no characters fit and no rows were used
// This uses a very crappy packing.

typedef struct
{
   float x0,y0,s0,t0; // top-left
   float x1,y1,s1,t1; // bottom-right
} stbtt_aligned_quad;

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier
// Call GetBakedQuad with char_index = 'character - first_char', and it
// creates the quad you need to draw and advances the current position.
//
// The coordinate system used assumes y increases downwards.
//
// Characters will extend both above and below the current position;
// see discussion of "BASELINE" above.
//
// It's inefficient; you might want to c&p it and optimize it.



//////////////////////////////////////////////////////////////////////////////
//
// NEW TEXTURE BAKING API
//
// This provides options for packing multiple fonts into one atlas, not
// perfectly but better than nothing.

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
   float xoff2,yoff2;
} stbtt_packedchar;

typedef struct stbtt_pack_context stbtt_pack_context;
typedef struct stbtt_fontinfo stbtt_fontinfo;
#ifndef STB_RECT_PACK_VERSION
typedef struct stbrp_rect stbrp_rect;
#endif

STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);
// Initializes a packing context stored in the passed-in stbtt_pack_context.
// Future calls using this context will pack characters into the bitmap passed
// in here: a 1-channel bitmap that is width * height. stride_in_bytes is
// the distance from one row to the next (or 0 to mean they are packed tightly
// together). "padding" is the amount of padding to leave between each
// character (normally you want '1' for bitmaps you'll use as textures with
// bilinear filtering).
//
// Returns 0 on failure, 1 on success.

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);
// Cleans up the packing context and frees all memory.

#define STBTT_POINT_SIZE(x)   (-(x))

STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);
// Creates character bitmaps from the font_index'th font found in fontdata (use
// font_index=0 if you don't know what that is). It creates num_chars_in_range
// bitmaps for characters with unicode values starting at first_unicode_char_in_range
// and increasing. Data for how to render them is stored in chardata_for_range;
// pass these to stbtt_GetPackedQuad to get back renderable quads.
//
// font_size is the full height of the character from ascender to descender,
// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
// and pass that result as 'font_size':
//       ...,                  20 , ... // font max minus min y is 20 pixels tall
//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall

typedef struct
{
   float font_size;
   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint
   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints
   int num_chars;
   stbtt_packedchar *chardata_for_range; // output
   unsigned char h_oversample, v_oversample; // don't set these, they're used internally
} stbtt_pack_range;

STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);
// Creates character bitmaps from multiple ranges of characters stored in
// ranges. This will usually create a better-packed bitmap than multiple
// calls to stbtt_PackFontRange. Note that you can call this multiple
// times within a single PackBegin/PackEnd.

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);
// Oversampling a font increases the quality by allowing higher-quality subpixel
// positioning, and is especially valuable at smaller text sizes.
//
// This function sets the amount of oversampling for all following calls to
// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given
// pack context. The default (no oversampling) is achieved by h_oversample=1
// and v_oversample=1. The total number of pixels required is
// h_oversample*v_oversample larger than the default; for example, 2x2
// oversampling requires 4x the storage of 1x1. For best results, render
// oversampled textures with bilinear filtering. Look at the readme in
// stb/tests/oversample for information about oversampled fonts
//
// To use with PackFontRangesGather etc., you must set it before calls
// call to PackFontRangesGatherRects.

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int align_to_integer);

STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);
STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
// Calling these functions in sequence is roughly equivalent to calling
// stbtt_PackFontRanges(). If you more control over the packing of multiple
// fonts, or if you want to pack custom data into a font texture, take a look
// at the source to of stbtt_PackFontRanges() and create a custom version 
// using these functions, e.g. call GatherRects multiple times,
// building up a single array of rects, then call PackRects once,
// then call RenderIntoRects repeatedly. This may result in a
// better packing than calling PackFontRanges multiple times
// (or it may not).

// this is an opaque structure that you shouldn't mess with which holds
// all the context needed from PackBegin to PackEnd.
struct stbtt_pack_context {
   void *user_allocator_context;
   void *pack_info;
   int   width;
   int   height;
   int   stride_in_bytes;
   int   padding;
   unsigned int   h_oversample, v_oversample;
   unsigned char *pixels;
   void  *nodes;
};

//////////////////////////////////////////////////////////////////////////////
//
// FONT LOADING
//
//

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);
// This function will determine the number of fonts in a font file.  TrueType
// collection (.ttc) files may contain multiple fonts, while TrueType font
// (.ttf) files only contain one font. The number of fonts can be used for
// indexing with the previous function where the index is between zero and one
// less than the total fonts. If an error occurs, -1 is returned.

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);
// Each .ttf/.ttc file may have more than one font. Each font has a sequential
// index number starting from 0. Call this function to get the font offset for
// a given index; it returns -1 if the index is out of range. A regular .ttf
// file will only define one font and it always be at offset 0, so it will
// return '0' for index 0, and -1 for all other indices.

// The following structure is defined publically so you can declare one on
// the stack or as a global or etc, but you should treat it as opaque.
struct stbtt_fontinfo
{
   void           * userdata;
   unsigned char  * data;              // pointer to .ttf file
   int              fontstart;         // offset of start of font

   int numGlyphs;                     // number of glyphs, needed for range checking

   int loca,head,glyf,hhea,hmtx,kern,gpos; // table locations as offset from start of .ttf
   int index_map;                     // a cmap mapping for our chosen character encoding
   int indexToLocFormat;              // format needed to map from glyph index to glyph

   stbtt__buf cff;                    // cff font data
   stbtt__buf charstrings;            // the charstring index
   stbtt__buf gsubrs;                 // global charstring subroutines index
   stbtt__buf subrs;                  // private charstring subroutines index
   stbtt__buf fontdicts;              // array of font dicts
   stbtt__buf fdselect;               // map from glyph to fontdict
};

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);
// Given an offset into the file that defines a font, this function builds
// the necessary cached info for the rest of the system. You must allocate
// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't
// need to do anything special to free it, because the contents are pure
// value data with no additional data structures. Returns 0 on failure.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER TO GLYPH-INDEX CONVERSIOn

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);
// If you're going to perform multiple operations on the same character
// and you want a speed-up, call this function with the character you're
// going to process, then use glyph-based functions instead of the
// codepoint-based functions.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER PROPERTIES
//

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose "height" is 'pixels' tall.
// Height is measured as the distance from the highest ascender to the lowest
// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics
// and computing:
//       scale = pixels / (ascent - descent)
// so if you prefer to measure height by the ascent only, use a similar calculation.

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose EM size is mapped to
// 'pixels' tall. This is probably what traditional APIs compute, but
// I'm not positive.

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);
// ascent is the coordinate above the baseline the font extends; descent
// is the coordinate below the baseline the font extends (i.e. it is typically negative)
// lineGap is the spacing between one row's descent and the next row's ascent...
// so you should advance the vertical position by "*ascent - *descent + *lineGap"
//   these are expressed in unscaled coordinates, so you must multiply by
//   the scale factor for a given size

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);
// analogous to GetFontVMetrics, but returns the "typographic" values from the OS/2
// table (specific to MS/Windows TTF files).
//
// Returns 1 on success (table present), 0 on failure.

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);
// the bounding box around all possible characters

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);
// leftSideBearing is the offset from the current horizontal position to the left edge of the character
// advanceWidth is the offset from the current horizontal position to the next horizontal position
//   these are expressed in unscaled coordinates

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);
// an additional amount to add to the 'advance' value between ch1 and ch2

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);
// Gets the bounding box of the visible part of the glyph, in unscaled coordinates

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);
STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
// as above, but takes one or more glyph indices for greater efficiency


//////////////////////////////////////////////////////////////////////////////
//
// GLYPH SHAPES (you probably don't need these, but they have to go before
// the bitmaps for C declaration-order reasons)
//

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
   enum {
      STBTT_vmove=1,
      STBTT_vline,
      STBTT_vcurve,
      STBTT_vcubic
   };
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
                   // (we share this with other code at RAD)
   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
   typedef struct
   {
      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
      unsigned char type,padding;
   } stbtt_vertex;
#endif

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);
// returns non-zero if nothing is drawn for this glyph

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);
STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);
// returns # of vertices and fills *vertices with the pointer to them
//   these are expressed in "unscaled" coordinates
//
// The shape is a series of countours. Each one starts with
// a STBTT_moveto, then consists of a series of mixed
// STBTT_lineto and STBTT_curveto segments. A lineto
// draws a line from previous endpoint to its x,y; a curveto
// draws a quadratic bezier from previous endpoint to
// its x,y, using cx,cy as the bezier control point.

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);
// frees the data allocated above

//////////////////////////////////////////////////////////////////////////////
//
// BITMAP RENDERING
//

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);
// frees the bitmap allocated below

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// allocates a large-enough single-channel 8bpp bitmap and renders the
// specified character/glyph at the specified scale into it, with
// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).
// *width & *height are filled out with the width & height of the bitmap,
// which is stored left-to-right, top-to-bottom.
//
// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);
// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap
// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap
// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the
// width and height and positioning info for it first.

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);
// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);
// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering
// is performed (see stbtt_PackSetOversampling)

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
// get the bbox of the bitmap centered around the glyph origin; so the
// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
// the bitmap top left is (leftSideBearing*scale,iy0).
// (Note that the bitmap uses y-increases-down, but the shape uses
// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);
// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel
// shift for the character

// the following functions are equivalent to the above functions, but operate
// on glyph indices instead of Unicode codepoints (for efficiency)
STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);
STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);


// @TODO: don't expose this structure
typedef struct
{
   int w,h,stride;
   unsigned char *pixels;
} stbtt__bitmap;

// rasterize a shape with quadratic beziers into a bitmap
STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
                               float flatness_in_pixels,     // allowable error of curve in pixels
                               stbtt_vertex *vertices,       // array of vertices defining shape
                               int num_verts,                // number of vertices in above array
                               float scale_x, float scale_y, // scale applied to input vertices
                               float shift_x, float shift_y, // translation applied to input vertices
                               int x_off, int y_off,         // another translation applied to input
                               int invert,                   // if non-zero, vertically flip shape
                               void *userdata);              // context for to STBTT_MALLOC

//////////////////////////////////////////////////////////////////////////////
//
// Signed Distance Function (or Field) rendering

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);
// frees the SDF bitmap allocated below

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
// These functions compute a discretized SDF field for a single character, suitable for storing
// in a single-channel texture, sampling with bilinear filtering, and testing against
// larger than some threshhold to produce scalable fonts.
//        info              --  the font
//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap
//        glyph/codepoint   --  the character to generate the SDF for
//        padding           --  extra "pixels" around the character which are filled with the distance to the character (not 0),
//                                 which allows effects like bit outlines
//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)
//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF "pixel" away from the edge (on the 0..255 scale)
//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside
//        width,height      --  output height & width of the SDF bitmap (including padding)
//        xoff,yoff         --  output origin of the character
//        return value      --  a 2D array of bytes 0..255, width*height in size
//
// pixel_dist_scale & onedge_value are a scale & bias that allows you to make
// optimal use of the limited 0..255 for your application, trading off precision
// and special effects. SDF values outside the range 0..255 are clamped to 0..255.
//
// Example:
//      scale = stbtt_ScaleForPixelHeight(22)
//      padding = 5
//      onedge_value = 180
//      pixel_dist_scale = 180/5.0 = 36.0
//
//      This will create an SDF bitmap in which the character is about 22 pixels
//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled
//      shape, sample the SDF at each pixel and fill the pixel if the SDF value
//      is greater than or equal to 180/255. (You'll actually want to antialias,
//      which is beyond the scope of this example.) Additionally, you can compute
//      offset outlines (e.g. to stroke the character border inside & outside,
//      or only outside). For example, to fill outside the character up to 3 SDF
//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above
//      choice of variables maps a range from 5 pixels outside the shape to
//      2 pixels inside the shape to 0..255; this is intended primarily for apply
//      outside effects only (the interior range is needed to allow proper
//      antialiasing of the font at *smaller* sizes)
//
// The function computes the SDF analytically at each SDF pixel, not by e.g.
// building a higher-res bitmap and approximating it. In theory the quality
// should be as high as possible for an SDF of this size & representation, but
// unclear if this is true in practice (perhaps building a higher-res bitmap
// and computing from that can allow drop-out prevention).
//
// The algorithm has not been optimized at all, so expect it to be slow
// if computing lots of characters or very large sizes. 



//////////////////////////////////////////////////////////////////////////////
//
// Finding the right font...
//
// You should really just solve this offline, keep your own tables
// of what font is what, and don't try to get it out of the .ttf file.
// That's because getting it out of the .ttf file is really hard, because
// the names in the file can appear in many possible encodings, in many
// possible languages, and e.g. if you need a case-insensitive comparison,
// the details of that depend on the encoding & language in a complex way
// (actually underspecified in truetype, but also gigantic).
//
// But you can use the provided functions in two possible ways:
//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on
//             unicode-encoded names to try to find the font you want;
//             you can run this before calling stbtt_InitFont()
//
//     stbtt_GetFontNameString() lets you get any of the various strings
//             from the file yourself and do your own comparisons on them.
//             You have to have called stbtt_InitFont() first.


STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);
// returns the offset (not index) of the font that matches, or -1 if none
//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".
//   if you use any other flag, use a font name like "Arial"; this checks
//     the 'macStyle' header field; i don't know if fonts set this consistently
#define STBTT_MACSTYLE_DONTCARE     0
#define STBTT_MACSTYLE_BOLD         1
#define STBTT_MACSTYLE_ITALIC       2
#define STBTT_MACSTYLE_UNDERSCORE   4
#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);
// returns 1/0 whether the first string interpreted as utf8 is identical to
// the second string interpreted as big-endian utf16... useful for strings from next func

STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);
// returns the string (which may be big-endian double byte, e.g. for unicode)
// and puts the length in bytes in *length.
//
// some of the values for the IDs are below; for more see the truetype spec:
//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
//     http://www.microsoft.com/typography/otspec/name.htm

enum { // platformID
   STBTT_PLATFORM_ID_UNICODE   =0,
   STBTT_PLATFORM_ID_MAC       =1,
   STBTT_PLATFORM_ID_ISO       =2,
   STBTT_PLATFORM_ID_MICROSOFT =3
};

enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
   STBTT_UNICODE_EID_UNICODE_1_0    =0,
   STBTT_UNICODE_EID_UNICODE_1_1    =1,
   STBTT_UNICODE_EID_ISO_10646      =2,
   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
};

enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
   STBTT_MS_EID_SYMBOL        =0,
   STBTT_MS_EID_UNICODE_BMP   =1,
   STBTT_MS_EID_SHIFTJIS      =2,
   STBTT_MS_EID_UNICODE_FULL  =10
};

enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
};

enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
};

enum { // languageID for STBTT_PLATFORM_ID_MAC
   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
};

#ifdef __cplusplus
}
#endif

#endif // __STB_INCLUDE_STB_TRUETYPE_H__

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   IMPLEMENTATION
////
////

#ifdef STB_TRUETYPE_IMPLEMENTATION

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

//////////////////////////////////////////////////////////////////////////
//
// stbtt__buf helpers to parse data from file
//

static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor++];
}

static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor];
}

static void stbtt__buf_seek(stbtt__buf *b, int o)
{
   STBTT_assert(!(o > b->size || o < 0));
   b->cursor = (o > b->size || o < 0) ? b->size : o;
}

static void stbtt__buf_skip(stbtt__buf *b, int o)
{
   stbtt__buf_seek(b, b->cursor + o);
}

static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)
{
   stbtt_uint32 v = 0;
   int i;
   STBTT_assert(n >= 1 && n <= 4);
   for (i = 0; i < n; i++)
      v = (v << 8) | stbtt__buf_get8(b);
   return v;
}

static stbtt__buf stbtt__new_buf(const void *p, size_t size)
{
   stbtt__buf r;
   STBTT_assert(size < 0x40000000);
   r.data = (stbtt_uint8*) p;
   r.size = (int) size;
   r.cursor = 0;
   return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
{
   stbtt__buf r = stbtt__new_buf(NULL, 0);
   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
   r.data = b->data + o;
   r.size = s;
   return r;
}

static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
{
   int count, start, offsize;
   start = b->cursor;
   count = stbtt__buf_get16(b);
   if (count) {
      offsize = stbtt__buf_get8(b);
      STBTT_assert(offsize >= 1 && offsize <= 4);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
   }
   return stbtt__buf_range(b, start, b->cursor - start);
}

static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)
{
   int b0 = stbtt__buf_get8(b);
   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
   else if (b0 == 28)               return stbtt__buf_get16(b);
   else if (b0 == 29)               return stbtt__buf_get32(b);
   STBTT_assert(0);
   return 0;
}

static void stbtt__cff_skip_operand(stbtt__buf *b) {
   int v, b0 = stbtt__buf_peek8(b);
   STBTT_assert(b0 >= 28);
   if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b->cursor < b->size) {
         v = stbtt__buf_get8(b);
         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
            break;
      }
   } else {
      stbtt__cff_int(b);
   }
}

static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
{
   stbtt__buf_seek(b, 0);
   while (b->cursor < b->size) {
      int start = b->cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28)
         stbtt__cff_skip_operand(b);
      end = b->cursor;
      op = stbtt__buf_get8(b);
      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
      if (op == key) return stbtt__buf_range(b, start, end-start);
   }
   return stbtt__buf_range(b, 0, 0);
}

static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)
{
   int i;
   stbtt__buf operands = stbtt__dict_get(b, key);
   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
      out[i] = stbtt__cff_int(&operands);
}

static int stbtt__cff_index_count(stbtt__buf *b)
{
   stbtt__buf_seek(b, 0);
   return stbtt__buf_get16(b);
}

static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
   int count, offsize, start, end;
   stbtt__buf_seek(&b, 0);
   count = stbtt__buf_get16(&b);
   offsize = stbtt__buf_get8(&b);
   STBTT_assert(i >= 0 && i < count);
   STBTT_assert(offsize >= 1 && offsize <= 4);
   stbtt__buf_skip(&b, i*offsize);
   start = stbtt__buf_get(&b, offsize);
   end = stbtt__buf_get(&b, offsize);
   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
}

//////////////////////////////////////////////////////////////////////////
//
// accessors to parse data from file
//

// on platforms that don't allow misaligned reads, if we want to allow
// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE

#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
#define ttCHAR(p)     (* (stbtt_int8 *) (p))
#define ttFixed(p)    ttLONG(p)

static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])

static int stbtt__isfont(stbtt_uint8 *font)
{
   // check the version number
   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
   return 0;
}

// @OPTIMIZE: binary search
static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
{
   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
   stbtt_uint32 tabledir = fontstart + 12;
   stbtt_int32 i;
   for (i=0; i < num_tables; ++i) {
      stbtt_uint32 loc = tabledir + 16*i;
      if (stbtt_tag(data+loc+0, tag))
         return ttULONG(data+loc+8);
   }
   return 0;
}

static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)
{
   // if it's just a font, there's only one valid index
   if (stbtt__isfont(font_collection))
      return index == 0 ? 0 : -1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         stbtt_int32 n = ttLONG(font_collection+8);
         if (index >= n)
            return -1;
         return ttULONG(font_collection+12+index*4);
      }
   }
   return -1;
}

static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)
{
   // if it's just a font, there's only one valid font
   if (stbtt__isfont(font_collection))
      return 1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         return ttLONG(font_collection+8);
      }
   }
   return 0;
}

static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };
   stbtt__buf pdict;
   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
   if (!subrsoff) return stbtt__new_buf(NULL, 0);
   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
   return stbtt__cff_get_index(&cff);
}

static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)
{
   stbtt_uint32 cmap, t;
   stbtt_int32 i,numTables;

   info->data = data;
   info->fontstart = fontstart;
   info->cff = stbtt__new_buf(NULL, 0);

   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
   info->head = stbtt__find_table(data, fontstart, "head"); // required
   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

   if (!cmap || !info->head || !info->hhea || !info->hmtx)
      return 0;
   if (info->glyf) {
      // required for truetype
      if (!info->loca) return 0;
   } else {
      // initialization for CFF / Type2 fonts (OTF)
      stbtt__buf b, topdict, topdictidx;
      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      stbtt_uint32 cff;

      cff = stbtt__find_table(data, fontstart, "CFF ");
      if (!cff) return 0;

      info->fontdicts = stbtt__new_buf(NULL, 0);
      info->fdselect = stbtt__new_buf(NULL, 0);

      // @TODO this should use size from table (not 512MB)
      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
      b = info->cff;

      // read the header
      stbtt__buf_skip(&b, 2);
      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

      // @TODO the name INDEX could list multiple fonts,
      // but we just use the first one.
      stbtt__cff_get_index(&b);  // name INDEX
      topdictidx = stbtt__cff_get_index(&b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(&b);  // string INDEX
      info->gsubrs = stbtt__cff_get_index(&b);

      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
      info->subrs = stbtt__get_subrs(b, topdict);

      // we only support Type 2 charstrings
      if (cstype != 2) return 0;
      if (charstrings == 0) return 0;

      if (fdarrayoff) {
         // looks like a CID font
         if (!fdselectoff) return 0;
         stbtt__buf_seek(&b, fdarrayoff);
         info->fontdicts = stbtt__cff_get_index(&b);
         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      }

      stbtt__buf_seek(&b, charstrings);
      info->charstrings = stbtt__cff_get_index(&b);
   }

   t = stbtt__find_table(data, fontstart, "maxp");
   if (t)
      info->numGlyphs = ttUSHORT(data+t+4);
   else
      info->numGlyphs = 0xffff;

   // find a cmap encoding table we understand *now* to avoid searching
   // later. (todo: could make this installable)
   // the same regardless of glyph.
   numTables = ttUSHORT(data + cmap + 2);
   info->index_map = 0;
   for (i=0; i < numTables; ++i) {
      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
      // find an encoding we understand:
      switch(ttUSHORT(data+encoding_record)) {
         case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data+encoding_record+2)) {
               case STBTT_MS_EID_UNICODE_BMP:
               case STBTT_MS_EID_UNICODE_FULL:
                  // MS/Unicode
                  info->index_map = cmap + ttULONG(data+encoding_record+4);
                  break;
            }
            break;
        case STBTT_PLATFORM_ID_UNICODE:
            // Mac/iOS has these
            // all the encodingIDs are unicode, so we don't bother to check it
            info->index_map = cmap + ttULONG(data+encoding_record+4);
            break;
      }
   }
   if (info->index_map == 0)
      return 0;

   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
   return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
{
   stbtt_uint8 *data = info->data;
   stbtt_uint32 index_map = info->index_map;

   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
   if (format == 0) { // apple byte encoding
      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
      if (unicode_codepoint < bytes-6)
         return ttBYTE(data + index_map + 6 + unicode_codepoint);
      return 0;
   } else if (format == 6) {
      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      return 0;
   } else if (format == 2) {
      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
      return 0;
   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

      // do a binary search of the segments
      stbtt_uint32 endCount = index_map + 14;
      stbtt_uint32 search = endCount;

      if (unicode_codepoint > 0xffff)
         return 0;

      // they lie from endCount .. endCount + segCount
      // but searchRange is the nearest power of two, so...
      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
         search += rangeShift*2;

      // now decrement to bias correctly to find smallest
      search -= 2;
      while (entrySelector) {
         stbtt_uint16 end;
         searchRange >>= 1;
         end = ttUSHORT(data + search + searchRange*2);
         if (unicode_codepoint > end)
            search += searchRange*2;
         --entrySelector;
      }
      search += 2;

      {
         stbtt_uint16 offset, start;
         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

         STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));
         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
         if (unicode_codepoint < start)
            return 0;

         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
         if (offset == 0)
            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      }
   } else if (format == 12 || format == 13) {
      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
      stbtt_int32 low,high;
      low = 0; high = (stbtt_int32)ngroups;
      // Binary search the right group.
      while (low < high) {
         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
         if ((stbtt_uint32) unicode_codepoint < start_char)
            high = mid;
         else if ((stbtt_uint32) unicode_codepoint > end_char)
            low = mid+1;
         else {
            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
            if (format == 12)
               return start_glyph + unicode_codepoint-start_char;
            else // format == 13
               return start_glyph;
         }
      }
      return 0; // not found
   }
   // @TODO
   STBTT_assert(0);
   return 0;
}

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
{
   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
}

static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
{
   v->type = type;
   v->x = (stbtt_int16) x;
   v->y = (stbtt_int16) y;
   v->cx = (stbtt_int16) cx;
   v->cy = (stbtt_int16) cy;
}

static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
   int g1,g2;

   STBTT_assert(!info->cff.size);

   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

   if (info->indexToLocFormat == 0) {
      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   } else {
      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   }

   return g1==g2 ? -1 : g1; // if length is 0, return -1
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   if (info->cff.size) {
      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
   } else {
      int g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) return 0;

      if (x0) *x0 = ttSHORT(info->data + g + 2);
      if (y0) *y0 = ttSHORT(info->data + g + 4);
      if (x1) *x1 = ttSHORT(info->data + g + 6);
      if (y1) *y1 = ttSHORT(info->data + g + 8);
   }
   return 1;
}

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
{
   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);
}

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt_int16 numberOfContours;
   int g;
   if (info->cff.size)
      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;
   g = stbtt__GetGlyfOffset(info, glyph_index);
   if (g < 0) return 1;
   numberOfContours = ttSHORT(info->data + g);
   return numberOfContours == 0;
}

static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
{
   if (start_off) {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   } else {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      else
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
   }
   return num_vertices;
}

static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   stbtt_int16 numberOfContours;
   stbtt_uint8 *endPtsOfContours;
   stbtt_uint8 *data = info->data;
   stbtt_vertex *vertices=0;
   int num_vertices=0;
   int g = stbtt__GetGlyfOffset(info, glyph_index);

   *pvertices = NULL;

   if (g < 0) return 0;

   numberOfContours = ttSHORT(data + g);

   if (numberOfContours > 0) {
      stbtt_uint8 flags=0,flagcount;
      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
      stbtt_uint8 *points;
      endPtsOfContours = (data + g + 10);
      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
      points = data + g + 10 + numberOfContours * 2 + 2 + ins;

      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
      if (vertices == 0)
         return 0;

      next_move = 0;
      flagcount=0;

      // in first pass, we load uninterpreted data into the allocated array
      // above, shifted to the end of the array so we won't overwrite it when
      // we create our final data starting from the front

      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

      // first load flags

      for (i=0; i < n; ++i) {
         if (flagcount == 0) {
            flags = *points++;
            if (flags & 8)
               flagcount = *points++;
         } else
            --flagcount;
         vertices[off+i].type = flags;
      }

      // now load x coordinates
      x=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 2) {
            stbtt_int16 dx = *points++;
            x += (flags & 16) ? dx : -dx; // ???
         } else {
            if (!(flags & 16)) {
               x = x + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].x = (stbtt_int16) x;
      }

      // now load y coordinates
      y=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 4) {
            stbtt_int16 dy = *points++;
            y += (flags & 32) ? dy : -dy; // ???
         } else {
            if (!(flags & 32)) {
               y = y + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].y = (stbtt_int16) y;
      }

      // now convert them to our format
      num_vertices=0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         x     = (stbtt_int16) vertices[off+i].x;
         y     = (stbtt_int16) vertices[off+i].y;

         if (next_move == i) {
            if (i != 0)
               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

            // now start the new one               
            start_off = !(flags & 1);
            if (start_off) {
               // if we start off with an off-curve point, then when we need to find a point on the curve
               // where we can start, and we need to save some state for when we wraparound.
               scx = x;
               scy = y;
               if (!(vertices[off+i+1].type & 1)) {
                  // next point is also a curve point, so interpolate an on-point curve
                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
               } else {
                  // otherwise just use the next point as our start point
                  sx = (stbtt_int32) vertices[off+i+1].x;
                  sy = (stbtt_int32) vertices[off+i+1].y;
                  ++i; // we're using point i+1 as the starting point, so skip it
               }
            } else {
               sx = x;
               sy = y;
            }
            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
            was_off = 0;
            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
            ++j;
         } else {
            if (!(flags & 1)) { // if it's a curve
               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
               cx = x;
               cy = y;
               was_off = 1;
            } else {
               if (was_off)
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
               else
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
               was_off = 0;
            }
         }
      }
      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   } else if (numberOfContours == -1) {
      // Compound shapes.
      int more = 1;
      stbtt_uint8 *comp = data + g + 10;
      num_vertices = 0;
      vertices = 0;
      while (more) {
         stbtt_uint16 flags, gidx;
         int comp_num_verts = 0, i;
         stbtt_vertex *comp_verts = 0, *tmp = 0;
         float mtx[6] = {1,0,0,1,0,0}, m, n;
         
         flags = ttSHORT(comp); comp+=2;
         gidx = ttSHORT(comp); comp+=2;

         if (flags & 2) { // XY values
            if (flags & 1) { // shorts
               mtx[4] = ttSHORT(comp); comp+=2;
               mtx[5] = ttSHORT(comp); comp+=2;
            } else {
               mtx[4] = ttCHAR(comp); comp+=1;
               mtx[5] = ttCHAR(comp); comp+=1;
            }
         }
         else {
            // @TODO handle matching point
            STBTT_assert(0);
         }
         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         }
         
         // Find transformation scales.
         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

         // Get indexed glyph.
         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
         if (comp_num_verts > 0) {
            // Transform vertices.
            for (i = 0; i < comp_num_verts; ++i) {
               stbtt_vertex* v = &comp_verts[i];
               stbtt_vertex_type x,y;
               x=v->x; y=v->y;
               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
               x=v->cx; y=v->cy;
               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
            }
            // Append vertices.
            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
            if (!tmp) {
               if (vertices) STBTT_free(vertices, info->userdata);
               if (comp_verts) STBTT_free(comp_verts, info->userdata);
               return 0;
            }
            if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
            if (vertices) STBTT_free(vertices, info->userdata);
            vertices = tmp;
            STBTT_free(comp_verts, info->userdata);
            num_vertices += comp_num_verts;
         }
         // More components ?
         more = flags & (1<<5);
      }
   } else if (numberOfContours < 0) {
      // @TODO other compound variations?
      STBTT_assert(0);
   } else {
      // numberOfCounters == 0, do nothing
   }

   *pvertices = vertices;
   return num_vertices;
}

typedef struct
{
   int bounds;
   int started;
   float first_x, first_y;
   float x, y;
   stbtt_int32 min_x, max_x, min_y, max_y;

   stbtt_vertex *pvertices;
   int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)
{
   if (x > c->max_x || !c->started) c->max_x = x;
   if (y > c->max_y || !c->started) c->max_y = y;
   if (x < c->min_x || !c->started) c->min_x = x;
   if (y < c->min_y || !c->started) c->min_y = y;
   c->started = 1;
}

static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)
{
   if (c->bounds) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
         stbtt__track_vertex(c, cx, cy);
         stbtt__track_vertex(c, cx1, cy1);
      }
   } else {
      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;
      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;
   }
   c->num_vertices++;
}

static void stbtt__csctx_close_shape(stbtt__csctx *ctx)
{
   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
{
   stbtt__csctx_close_shape(ctx);
   ctx->first_x = ctx->x = ctx->x + dx;
   ctx->first_y = ctx->y = ctx->y + dy;
   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
{
   ctx->x += dx;
   ctx->y += dy;
   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
   float cx1 = ctx->x + dx1;
   float cy1 = ctx->y + dy1;
   float cx2 = cx1 + dx2;
   float cy2 = cy1 + dy2;
   ctx->x = cx2 + dx3;
   ctx->y = cy2 + dy3;
   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
   int count = stbtt__cff_index_count(&idx);
   int bias = 107;
   if (count >= 33900)
      bias = 32768;
   else if (count >= 1240)
      bias = 1131;
   n += bias;
   if (n < 0 || n >= count)
      return stbtt__new_buf(NULL, 0);
   return stbtt__cff_index_get(idx, n);
}

static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt__buf fdselect = info->fdselect;
   int nranges, start, end, v, fmt, fdselector = -1, i;

   stbtt__buf_seek(&fdselect, 0);
   fmt = stbtt__buf_get8(&fdselect);
   if (fmt == 0) {
      // untested
      stbtt__buf_skip(&fdselect, glyph_index);
      fdselector = stbtt__buf_get8(&fdselect);
   } else if (fmt == 3) {
      nranges = stbtt__buf_get16(&fdselect);
      start = stbtt__buf_get16(&fdselect);
      for (i = 0; i < nranges; i++) {
         v = stbtt__buf_get8(&fdselect);
         end = stbtt__buf_get16(&fdselect);
         if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
         }
         start = end;
      }
   }
   if (fdselector == -1) stbtt__new_buf(NULL, 0);
   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
{
   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
   int has_subrs = 0, clear_stack;
   float s[48];
   stbtt__buf subr_stack[10], subrs = info->subrs, b;
   float f;

#define STBTT__CSERR(s) (0)

   // this currently ignores the initial width value, which isn't needed if we have hmtx
   b = stbtt__cff_index_get(info->charstrings, glyph_index);
   while (b.cursor < b.size) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(&b);
      switch (b0) {
      // @TODO implement hinting
      case 0x13: // hintmask
      case 0x14: // cntrmask
         if (in_header)
            maskbits += (sp / 2); // implicit "vstem"
         in_header = 0;
         stbtt__buf_skip(&b, (maskbits + 7) / 8);
         break;

      case 0x01: // hstem
      case 0x03: // vstem
      case 0x12: // hstemhm
      case 0x17: // vstemhm
         maskbits += (sp / 2);
         break;

      case 0x15: // rmoveto
         in_header = 0;
         if (sp < 2) return STBTT__CSERR("rmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
         break;
      case 0x04: // vmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("vmoveto stack");
         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
         break;
      case 0x16: // hmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("hmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-1], 0);
         break;

      case 0x05: // rlineto
         if (sp < 2) return STBTT__CSERR("rlineto stack");
         for (; i + 1 < sp; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
      // starting from a different place.

      case 0x07: // vlineto
         if (sp < 1) return STBTT__CSERR("vlineto stack");
         goto vlineto;
      case 0x06: // hlineto
         if (sp < 1) return STBTT__CSERR("hlineto stack");
         for (;;) {
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
      vlineto:
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
         }
         break;

      case 0x1F: // hvcurveto
         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
         goto hvcurveto;
      case 0x1E: // vhcurveto
         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
         for (;;) {
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
            i += 4;
      hvcurveto:
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
            i += 4;
         }
         break;

      case 0x08: // rrcurveto
         if (sp < 6) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x18: // rcurveline
         if (sp < 8) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp - 2; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
         stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      case 0x19: // rlinecurve
         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
         for (; i + 1 < sp - 6; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x1A: // vvcurveto
      case 0x1B: // hhcurveto
         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
         f = 0.0;
         if (sp & 1) { f = s[i]; i++; }
         for (; i + 3 < sp; i += 4) {
            if (b0 == 0x1B)
               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
            else
               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
            f = 0.0;
         }
         break;

      case 0x0A: // callsubr
         if (!has_subrs) {
            if (info->fdselect.size)
               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            has_subrs = 1;
         }
         // fallthrough
      case 0x1D: // callgsubr
         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
         v = (int) s[--sp];
         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
         subr_stack[subr_stack_height++] = b;
         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
         if (b.size == 0) return STBTT__CSERR("subr not found");
         b.cursor = 0;
         clear_stack = 0;
         break;

      case 0x0B: // return
         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
         b = subr_stack[--subr_stack_height];
         clear_stack = 0;
         break;

      case 0x0E: // endchar
         stbtt__csctx_close_shape(c);
         return 1;

      case 0x0C: { // two-byte escape
         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
         float dx, dy;
         int b1 = stbtt__buf_get8(&b);
         switch (b1) {
         // @TODO These "flex" implementations ignore the flex-depth and resolution,
         // and always draw beziers.
         case 0x22: // hflex
            if (sp < 7) return STBTT__CSERR("hflex stack");
            dx1 = s[0];
            dx2 = s[1];
            dy2 = s[2];
            dx3 = s[3];
            dx4 = s[4];
            dx5 = s[5];
            dx6 = s[6];
            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
            break;

         case 0x23: // flex
            if (sp < 13) return STBTT__CSERR("flex stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = s[10];
            dy6 = s[11];
            //fd is s[12]
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         case 0x24: // hflex1
            if (sp < 9) return STBTT__CSERR("hflex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dx4 = s[5];
            dx5 = s[6];
            dy5 = s[7];
            dx6 = s[8];
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
            break;

         case 0x25: // flex1
            if (sp < 11) return STBTT__CSERR("flex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = dy6 = s[10];
            dx = dx1+dx2+dx3+dx4+dx5;
            dy = dy1+dy2+dy3+dy4+dy5;
            if (STBTT_fabs(dx) > STBTT_fabs(dy))
               dy6 = -dy;
            else
               dx6 = -dx;
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         default:
            return STBTT__CSERR("unimplemented");
         }
      } break;

      default:
         if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254))
            return STBTT__CSERR("reserved operator");

         // push immediate
         if (b0 == 255) {
            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;
         } else {
            stbtt__buf_skip(&b, -1);
            f = (float)(stbtt_int16)stbtt__cff_int(&b);
         }
         if (sp >= 48) return STBTT__CSERR("push stack overflow");
         s[sp++] = f;
         clear_stack = 0;
         break;
      }
      if (clear_stack) sp = 0;
   }
   return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   // runs the charstring twice, once to count and once to output (to avoid realloc)
   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
      output_ctx.pvertices = *pvertices;
      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
         return output_ctx.num_vertices;
      }
   }
   *pvertices = NULL;
   return 0;
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   stbtt__csctx c = STBTT__CSCTX_INIT(1);
   int r = stbtt__run_charstring(info, glyph_index, &c);
   if (x0)  *x0 = r ? c.min_x : 0;
   if (y0)  *y0 = r ? c.min_y : 0;
   if (x1)  *x1 = r ? c.max_x : 0;
   if (y1)  *y1 = r ? c.max_y : 0;
   return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   if (!info->cff.size)
      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
   else
      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
{
   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
   if (glyph_index < numOfLongHorMetrics) {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
   } else {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
   }
}

static int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   stbtt_uint8 *data = info->data + info->kern;
   stbtt_uint32 needle, straw;
   int l, r, m;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   l = 0;
   r = ttUSHORT(data+10) - 1;
   needle = glyph1 << 16 | glyph2;
   while (l <= r) {
      m = (l + r) >> 1;
      straw = ttULONG(data+18+(m*6)); // note: unaligned read
      if (needle < straw)
         r = m - 1;
      else if (needle > straw)
         l = m + 1;
      else
         return ttSHORT(data+22+(m*6));
   }
   return 0;
}

static stbtt_int32  stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)
{
    stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);
    switch(coverageFormat) {
        case 1: {
            stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);

            // Binary search.
            stbtt_int32 l=0, r=glyphCount-1, m;
            int straw, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *glyphArray = coverageTable + 4;
                stbtt_uint16 glyphID;
                m = (l + r) >> 1;
                glyphID = ttUSHORT(glyphArray + 2 * m);
                straw = glyphID;
                if (needle < straw)
                    r = m - 1;
                else if (needle > straw)
                    l = m + 1;
                else {
                     return m;
                }
            }
        } break;

        case 2: {
            stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);
            stbtt_uint8 *rangeArray = coverageTable + 4;

            // Binary search.
            stbtt_int32 l=0, r=rangeCount-1, m;
            int strawLoopCallback, strawEnd, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *rangeRecord;
                m = (l + r) >> 1;
                rangeRecord = rangeArray + 6 * m;
                strawLoopCallback = ttUSHORT(rangeRecord);
                strawEnd = ttUSHORT(rangeRecord + 2);
                if (needle < strawLoopCallback)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else {
                    stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
                    return startCoverageIndex + glyph - strawLoopCallback;
                }
            }
        } break;

        default: {
            // There are no other cases.
            STBTT_assert(0);
        } break;
    }

    return -1;
}

static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)
{
    stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);
    switch(classDefFormat)
    {
        case 1: {
            stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);
            stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);
            stbtt_uint8 *classDef1ValueArray = classDefTable + 6;

            if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
                return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));

            classDefTable = classDef1ValueArray + 2 * glyphCount;
        } break;

        case 2: {
            stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);
            stbtt_uint8 *classRangeRecords = classDefTable + 4;

            // Binary search.
            stbtt_int32 l=0, r=classRangeCount-1, m;
            int strawLoopCallback, strawEnd, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *classRangeRecord;
                m = (l + r) >> 1;
                classRangeRecord = classRangeRecords + 6 * m;
                strawLoopCallback = ttUSHORT(classRangeRecord);
                strawEnd = ttUSHORT(classRangeRecord + 2);
                if (needle < strawLoopCallback)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else
                    return (stbtt_int32)ttUSHORT(classRangeRecord + 4);
            }

            classDefTable = classRangeRecords + 6 * classRangeCount;
        } break;

        default: {
            // There are no other cases.
            STBTT_assert(0);
        } break;
    }

    return -1;
}

// Define to STBTT_assert(x) if you want to break on unimplemented formats.
#define STBTT_GPOS_TODO_assert(x)

static stbtt_int32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
    stbtt_uint16 lookupListOffset;
    stbtt_uint8 *lookupList;
    stbtt_uint16 lookupCount;
    stbtt_uint8 *data;
    stbtt_int32 i;

    if (!info->gpos) return 0;

    data = info->data + info->gpos;

    if (ttUSHORT(data+0) != 1) return 0; // Major version 1
    if (ttUSHORT(data+2) != 0) return 0; // Minor version 0

    lookupListOffset = ttUSHORT(data+8);
    lookupList = data + lookupListOffset;
    lookupCount = ttUSHORT(lookupList);

    for (i=0; i<lookupCount; ++i) {
        stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
        stbtt_uint8 *lookupTable = lookupList + lookupOffset;

        stbtt_uint16 lookupType = ttUSHORT(lookupTable);
        stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);
        stbtt_uint8 *subTableOffsets = lookupTable + 6;
        switch(lookupType) {
            case 2: { // Pair Adjustment Positioning Subtable
                stbtt_int32 sti;
                for (sti=0; sti<subTableCount; sti++) {
                    stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
                    stbtt_uint8 *table = lookupTable + subtableOffset;
                    stbtt_uint16 posFormat = ttUSHORT(table);
                    stbtt_uint16 coverageOffset = ttUSHORT(table + 2);
                    stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
                    if (coverageIndex == -1) continue;

                    switch (posFormat) {
                        case 1: {
                            stbtt_int32 l, r, m;
                            int straw, needle;
                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
                            stbtt_int32 valueRecordPairSizeInBytes = 2;
                            stbtt_uint16 pairSetCount = ttUSHORT(table + 8);
                            stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
                            stbtt_uint8 *pairValueTable = table + pairPosOffset;
                            stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);
                            stbtt_uint8 *pairValueArray = pairValueTable + 2;
                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            STBTT_assert(coverageIndex < pairSetCount);
                            STBTT__NOTUSED(pairSetCount);

                            needle=glyph2;
                            r=pairValueCount-1;
                            l=0;

                            // Binary search.
                            while (l <= r) {
                                stbtt_uint16 secondGlyph;
                                stbtt_uint8 *pairValue;
                                m = (l + r) >> 1;
                                pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
                                secondGlyph = ttUSHORT(pairValue);
                                straw = secondGlyph;
                                if (needle < straw)
                                    r = m - 1;
                                else if (needle > straw)
                                    l = m + 1;
                                else {
                                    stbtt_int16 xAdvance = ttSHORT(pairValue + 2);
                                    return xAdvance;
                                }
                            }
                        } break;

                        case 2: {
                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);

                            stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);
                            stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);
                            int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
                            int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

                            stbtt_uint16 class1Count = ttUSHORT(table + 12);
                            stbtt_uint16 class2Count = ttUSHORT(table + 14);
                            STBTT_assert(glyph1class < class1Count);
                            STBTT_assert(glyph2class < class2Count);

                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            if (glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count) {
                                stbtt_uint8 *class1Records = table + 16;
                                stbtt_uint8 *class2Records = class1Records + 2 * (glyph1class * class2Count);
                                stbtt_int16 xAdvance = ttSHORT(class2Records + 2 * glyph2class);
                                return xAdvance;
                            }
                        } break;

                        default: {
                            // There are no other cases.
                            STBTT_assert(0);
                            break;
                        };
                    }
                }
                break;
            };

            default:
                // TODO: Implement other stuff.
                break;
        }
    }

    return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
{
   int xAdvance = 0;

   if (info->gpos)
      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);

   if (info->kern)
      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

   return xAdvance;
}

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)
{
   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs
      return 0;
   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));
}

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
{
   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);
}

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
{
   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
}

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)
{
   int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");
   if (!tab)
      return 0;
   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);
   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);
   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);
   return 1;
}

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
{
   *x0 = ttSHORT(info->data + info->head + 36);
   *y0 = ttSHORT(info->data + info->head + 38);
   *x1 = ttSHORT(info->data + info->head + 40);
   *y1 = ttSHORT(info->data + info->head + 42);
}

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
{
   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
   return (float) height / fheight;
}

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
{
   int unitsPerEm = ttUSHORT(info->data + info->head + 18);
   return pixels / unitsPerEm;
}

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)
{
   STBTT_free(v, info->userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// antialiasing software rasterizer
//

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      // e.g. space character
      if (ix0) *ix0 = 0;
      if (iy0) *iy0 = 0;
      if (ix1) *ix1 = 0;
      if (iy1) *iy1 = 0;
   } else {
      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
   }
}

STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Rasterizer

typedef struct stbtt__hheap_chunk
{
   struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
   struct stbtt__hheap_chunk *head;
   void   *first_free;
   int    num_remaining_in_head_chunk;
} stbtt__hheap;

static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
   if (hh->first_free) {
      void *p = hh->first_free;
      hh->first_free = * (void **) p;
      return p;
   } else {
      if (hh->num_remaining_in_head_chunk == 0) {
         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
         if (c == NULL)
            return NULL;
         c->next = hh->head;
         hh->head = c;
         hh->num_remaining_in_head_chunk = count;
      }
      --hh->num_remaining_in_head_chunk;
      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
   }
}

static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
   *(void **) p = hh->first_free;
   hh->first_free = p;
}

static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
   stbtt__hheap_chunk *c = hh->head;
   while (c) {
      stbtt__hheap_chunk *n = c->next;
      STBTT_free(c, userdata);
      c = n;
   }
}

typedef struct stbtt__edge {
   float x0,y0, x1,y1;
   int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
   struct stbtt__active_edge *next;
   #if STBTT_RASTERIZER_VERSION==1
   int x,dx;
   float ey;
   int direction;
   #elif STBTT_RASTERIZER_VERSION==2
   float fx,fdx,fdy;
   float direction;
   float sy;
   float ey;
   #else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
   #endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   if (!z) return z;
   
   // round dx down to avoid overshooting
   if (dxdy < 0)
      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);
   else
      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);

   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
   z->x -= off_x * STBTT_FIX;

   z->ey = e->y1;
   z->next = 0;
   z->direction = e->invert ? 1 : -1;
   return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   //STBTT_assert(e->y0 <= start_point);
   if (!z) return z;
   z->fdx = dxdy;
   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
   z->fx = e->x0 + dxdy * (start_point - e->y0);
   z->fx -= off_x;
   z->direction = e->invert ? 1.0f : -1.0f;
   z->sy = e->y0;
   z->ey = e->y1;
   z->next = 0;
   return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1
// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
   // non-zero winding fill
   int x0=0, w=0;

   while (e) {
      if (w == 0) {
         // if we're currently at zero, we need to record the edge start point
         x0 = e->x; w += e->direction;
      } else {
         int x1 = e->x; w += e->direction;
         // if we went to zero, we need to draw
         if (w == 0) {
            int i = x0 >> STBTT_FIXSHIFT;
            int j = x1 >> STBTT_FIXSHIFT;

            if (i < len && j >= 0) {
               if (i == j) {
                  // x0,x1 are the same pixel, so compute combined coverage
                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
               } else {
                  if (i >= 0) // add antialiasing for x0
                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     i = -1; // clip

                  if (j < len) // add antialiasing for x1
                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     j = len; // clip

                  for (++i; i < j; ++i) // fill pixels between x0 and x1
                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;
               }
            }
         }
      }
      
      e = e->next;
   }
}

static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0;
   int max_weight = (255 / vsubsample);  // weight per vertical scanline
   int s; // vertical subsample index
   unsigned char scanline_data[512], *scanline;

   if (result->w > 512)
      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
   else
      scanline = scanline_data;

   y = off_y * vsubsample;
   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;

   while (j < result->h) {
      STBTT_memset(scanline, 0, result->w);
      for (s=0; s < vsubsample; ++s) {
         // find center of pixel for this scanline
         float scan_y = y + 0.5f;
         stbtt__active_edge **step = &active;

         // update all active edges;
         // remove all active edges that terminate before the center of this scanline
         while (*step) {
            stbtt__active_edge * z = *step;
            if (z->ey <= scan_y) {
               *step = z->next; // delete from list
               STBTT_assert(z->direction);
               z->direction = 0;
               stbtt__hheap_free(&hh, z);
            } else {
               z->x += z->dx; // advance to position for current scanline
               step = &((*step)->next); // advance through list
            }
         }

         // resort the list if needed
         for(;;) {
            int changed=0;
            step = &active;
            while (*step && (*step)->next) {
               if ((*step)->x > (*step)->next->x) {
                  stbtt__active_edge *t = *step;
                  stbtt__active_edge *q = t->next;

                  t->next = q->next;
                  q->next = t;
                  *step = q;
                  changed = 1;
               }
               step = &(*step)->next;
            }
            if (!changed) break;
         }

         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
         while (e->y0 <= scan_y) {
            if (e->y1 > scan_y) {
               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
               if (z != NULL) {
                  // find insertion point
                  if (active == NULL)
                     active = z;
                  else if (z->x < active->x) {
                     // insert at front
                     z->next = active;
                     active = z;
                  } else {
                     // find thing to insert AFTER
                     stbtt__active_edge *p = active;
                     while (p->next && p->next->x < z->x)
                        p = p->next;
                     // at this point, p->next->x is NOT < z->x
                     z->next = p->next;
                     p->next = z;
                  }
               }
            }
            ++e;
         }

         // now process all active edges in XOR fashion
         if (active)
            stbtt__fill_active_edges(scanline, result->w, active, max_weight);

         ++y;
      }
      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

// the edge passed in here does not cross the vertical line at x or the vertical line at x+1
// (i.e. it has already been clipped to those)
static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
   if (y0 == y1) return;
   STBTT_assert(y0 < y1);
   STBTT_assert(e->sy <= e->ey);
   if (y0 > e->ey) return;
   if (y1 < e->sy) return;
   if (y0 < e->sy) {
      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
      y0 = e->sy;
   }
   if (y1 > e->ey) {
      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
      y1 = e->ey;
   }

   if (x0 == x)
      STBTT_assert(x1 <= x+1);
   else if (x0 == x+1)
      STBTT_assert(x1 >= x);
   else if (x0 <= x)
      STBTT_assert(x1 <= x);
   else if (x0 >= x+1)
      STBTT_assert(x1 >= x+1);
   else
      STBTT_assert(x1 >= x && x1 <= x+1);

   if (x0 <= x && x1 <= x)
      scanline[x] += e->direction * (y1-y0);
   else if (x0 >= x+1 && x1 >= x+1)
      ;
   else {
      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
   }
}

static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
   float y_bottom = y_top+1;

   while (e) {
      // brute force every pixel

      // compute intersection points with top & bottom
      STBTT_assert(e->ey >= y_top);

      if (e->fdx == 0) {
         float x0 = e->fx;
         if (x0 < len) {
            if (x0 >= 0) {
               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
            } else {
               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
            }
         }
      } else {
         float x0 = e->fx;
         float dx = e->fdx;
         float xb = x0 + dx;
         float x_top, x_bottom;
         float sy0,sy1;
         float dy = e->fdy;
         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

         // compute endpoints of line segment clipped to this scanline (if the
         // line segment starts on this scanline. x0 is the intersection of the
         // line with y_top, but that may be off the line segment.
         if (e->sy > y_top) {
            x_top = x0 + dx * (e->sy - y_top);
            sy0 = e->sy;
         } else {
            x_top = x0;
            sy0 = y_top;
         }
         if (e->ey < y_bottom) {
            x_bottom = x0 + dx * (e->ey - y_top);
            sy1 = e->ey;
         } else {
            x_bottom = xb;
            sy1 = y_bottom;
         }

         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            // from here on, we don't have to range check x values

            if ((int) x_top == (int) x_bottom) {
               float height;
               // simple case, only spans one pixel
               int x = (int) x_top;
               height = sy1 - sy0;
               STBTT_assert(x >= 0 && x < len);
               scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;
               scanline_fill[x] += e->direction * height; // everything right of this pixel is filled
            } else {
               int x,x1,x2;
               float y_crossing, step, sign, area;
               // covers 2+ pixels
               if (x_top > x_bottom) {
                  // flip scanline vertically; signed area is the same
                  float t;
                  sy0 = y_bottom - (sy0 - y_top);
                  sy1 = y_bottom - (sy1 - y_top);
                  t = sy0, sy0 = sy1, sy1 = t;
                  t = x_bottom, x_bottom = x_top, x_top = t;
                  dx = -dx;
                  dy = -dy;
                  t = x0, x0 = xb, xb = t;
               }

               x1 = (int) x_top;
               x2 = (int) x_bottom;
               // compute intersection with y axis at x1+1
               y_crossing = (x1+1 - x0) * dy + y_top;

               sign = e->direction;
               // area of the rectangle covered from y0..y_crossing
               area = sign * (y_crossing-sy0);
               // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
               scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);

               step = sign * dy;
               for (x = x1+1; x < x2; ++x) {
                  scanline[x] += area + step/2;
                  area += step;
               }
               y_crossing += dy * (x2 - (x1+1));

               STBTT_assert(STBTT_fabs(area) <= 1.01f);

               scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);

               scanline_fill[x2] += sign * (sy1-sy0);
            }
         } else {
            // if edge goes outside of box we're drawing, we require
            // clipping logic. since this does not match the intended use
            // of this library, we use a different, very slow brute
            // force implementation
            int x;
            for (x=0; x < len; ++x) {
               // cases:
               //
               // there can be up to two intersections with the pixel. any intersection
               // with left or right edges can be handled by splitting into two (or three)
               // regions. intersections with top & bottom do not necessitate case-wise logic.
               //
               // the old way of doing this found the intersections with the left & right edges,
               // then used some simple logic to produce up to three segments in sorted order
               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
               // across the x border, then the corresponding y position might not be distinct
               // from the other y segment, and it might ignored as an empty segment. to avoid
               // that, we need to explicitly produce segments based on x positions.

               // rename variables to clearly-defined pairs
               float y0 = y_top;
               float x1 = (float) (x);
               float x2 = (float) (x+1);
               float x3 = xb;
               float y3 = y_bottom;

               // x = e->x + e->dx * (y-y_top)
               // (y-y_top) = (x - e->x) / e->dx
               // y = (x - e->x) / e->dx + y_top
               float y1 = (x - x0) / dx + y_top;
               float y2 = (x+1 - x0) / dx + y_top;

               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else {  // one segment
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
               }
            }
         }
      }
      e = e->next;
   }
}

// directly AA rasterize edges w/o supersampling
static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0, i;
   float scanline_data[129], *scanline, *scanline2;

   STBTT__NOTUSED(vsubsample);

   if (result->w > 64)
      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
   else
      scanline = scanline_data;

   scanline2 = scanline + result->w;

   y = off_y;
   e[n].y0 = (float) (off_y + result->h) + 1;

   while (j < result->h) {
      // find center of pixel for this scanline
      float scan_y_top    = y + 0.0f;
      float scan_y_bottom = y + 1.0f;
      stbtt__active_edge **step = &active;

      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

      // update all active edges;
      // remove all active edges that terminate before the top of this scanline
      while (*step) {
         stbtt__active_edge * z = *step;
         if (z->ey <= scan_y_top) {
            *step = z->next; // delete from list
            STBTT_assert(z->direction);
            z->direction = 0;
            stbtt__hheap_free(&hh, z);
         } else {
            step = &((*step)->next); // advance through list
         }
      }

      // insert all edges that start before the bottom of this scanline
      while (e->y0 <= scan_y_bottom) {
         if (e->y0 != e->y1) {
            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
            if (z != NULL) {
               STBTT_assert(z->ey >= scan_y_top);
               // insert at front
               z->next = active;
               active = z;
            }
         }
         ++e;
      }

      // now process all active edges
      if (active)
         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

      {
         float sum = 0;
         for (i=0; i < result->w; ++i) {
            float k;
            int m;
            sum += scanline2[i];
            k = scanline[i] + sum;
            k = (float) STBTT_fabs(k)*255 + 0.5f;
            m = (int) k;
            if (m > 255) m = 255;
            result->pixels[j*result->stride + i] = (unsigned char) m;
         }
      }
      // advance all the edges
      step = &active;
      while (*step) {
         stbtt__active_edge *z = *step;
         z->fx += z->fdx; // advance to position for current scanline
         step = &((*step)->next); // advance through list
      }

      ++y;
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
   int i,j;
   for (i=1; i < n; ++i) {
      stbtt__edge t = p[i], *a = &t;
      j = i;
      while (j > 0) {
         stbtt__edge *b = &p[j-1];
         int c = STBTT__COMPARE(a,b);
         if (!c) break;
         p[j] = p[j-1];
         --j;
      }
      if (i != j)
         p[j] = t;
   }
}

static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
   /* threshhold for transitioning to insertion sort */
   while (n > 12) {
      stbtt__edge t;
      int c01,c12,c,m,i,j;

      /* compute median of three */
      m = n >> 1;
      c01 = STBTT__COMPARE(&p[0],&p[m]);
      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
      if (c01 != c12) {
         /* otherwise, we'll need to swap something else to middle */
         int z;
         c = STBTT__COMPARE(&p[0],&p[n-1]);
         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
         z = (c == c12) ? 0 : n-1;
         t = p[z];
         p[z] = p[m];
         p[m] = t;
      }
      /* now p[m] is the median-of-three */
      /* swap it to the beginning so it won't move around */
      t = p[0];
      p[0] = p[m];
      p[m] = t;

      /* partition loop */
      i=1;
      j=n-1;
      for(;;) {
         /* handling of equality is crucial here */
         /* for sentinels & efficiency with duplicates */
         for (;;++i) {
            if (!STBTT__COMPARE(&p[i], &p[0])) break;
         }
         for (;;--j) {
            if (!STBTT__COMPARE(&p[0], &p[j])) break;
         }
         /* make sure we haven't crossed */
         if (i >= j) break;
         t = p[i];
         p[i] = p[j];
         p[j] = t;

         ++i;
         --j;
      }
      /* recurse on smaller side, iterate on larger */
      if (j < (n-i)) {
         stbtt__sort_edges_quicksort(p,j);
         p = p+i;
         n = n-i;
      } else {
         stbtt__sort_edges_quicksort(p+i, n-i);
         n = j;
      }
   }
}

static void stbtt__sort_edges(stbtt__edge *p, int n)
{
   stbtt__sort_edges_quicksort(p, n);
   stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
   float x,y;
} stbtt__point;

static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
   float y_scale_inv = invert ? -scale_y : scale_y;
   stbtt__edge *e;
   int n,i,j,k,m;
#if STBTT_RASTERIZER_VERSION == 1
   int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
   int vsubsample = 1;
#else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity

   // now we have to blow out the windings into explicit edge lists
   n = 0;
   for (i=0; i < windings; ++i)
      n += wcount[i];

   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
   if (e == 0) return;
   n = 0;

   m=0;
   for (i=0; i < windings; ++i) {
      stbtt__point *p = pts + m;
      m += wcount[i];
      j = wcount[i]-1;
      for (k=0; k < wcount[i]; j=k++) {
         int a=k,b=j;
         // skip the edge if horizontal
         if (p[j].y == p[k].y)
            continue;
         // add edge from j to k to the list
         e[n].invert = 0;
         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
            e[n].invert = 1;
            a=j,b=k;
         }
         e[n].x0 = p[a].x * scale_x + shift_x;
         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
         e[n].x1 = p[b].x * scale_x + shift_x;
         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
         ++n;
      }
   }

   // now sort the edges by their highest point (should snap to integer, and then by x)
   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
   stbtt__sort_edges(e, n);

   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

   STBTT_free(e, userdata);
}

static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
   if (!points) return; // during first pass, it's unallocated
   points[n].x = x;
   points[n].y = y;
}

// tesselate until threshhold p is happy... @TODO warped to compensate for non-linear stretching
static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
   // midpoint
   float mx = (x0 + 2*x1 + x2)/4;
   float my = (y0 + 2*y1 + y2)/4;
   // versus directly drawn line
   float dx = (x0+x2)/2 - mx;
   float dy = (y0+y2)/2 - my;
   if (n > 16) // 65536 segments on one curve better be enough!
      return 1;
   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x2,y2);
      *num_points = *num_points+1;
   }
   return 1;
}

static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
   float dx0 = x1-x0;
   float dy0 = y1-y0;
   float dx1 = x2-x1;
   float dy1 = y2-y1;
   float dx2 = x3-x2;
   float dy2 = y3-y2;
   float dx = x3-x0;
   float dy = y3-y0;
   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));
   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);
   float flatness_squared = longlen*longlen-shortlen*shortlen;

   if (n > 16) // 65536 segments on one curve better be enough!
      return;

   if (flatness_squared > objspace_flatness_squared) {
      float x01 = (x0+x1)/2;
      float y01 = (y0+y1)/2;
      float x12 = (x1+x2)/2;
      float y12 = (y1+y2)/2;
      float x23 = (x2+x3)/2;
      float y23 = (y2+y3)/2;

      float xa = (x01+x12)/2;
      float ya = (y01+y12)/2;
      float xb = (x12+x23)/2;
      float yb = (y12+y23)/2;

      float mx = (xa+xb)/2;
      float my = (ya+yb)/2;

      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x3,y3);
      *num_points = *num_points+1;
   }
}

// returns number of contours
static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
   stbtt__point *points=0;
   int num_points=0;

   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
   int i,n=0,start=0, pass;

   // count how many "moves" there are to get the contour count
   for (i=0; i < num_verts; ++i)
      if (vertices[i].type == STBTT_vmove)
         ++n;

   *num_contours = n;
   if (n == 0) return 0;

   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

   if (*contour_lengths == 0) {
      *num_contours = 0;
      return 0;
   }

   // make two passes through the points so we don't need to realloc
   for (pass=0; pass < 2; ++pass) {
      float x=0,y=0;
      if (pass == 1) {
         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
         if (points == NULL) goto error;
      }
      num_points = 0;
      n= -1;
      for (i=0; i < num_verts; ++i) {
         switch (vertices[i].type) {
            case STBTT_vmove:
               // start the next contour
               if (n >= 0)
                  (*contour_lengths)[n] = num_points - start;
               ++n;
               start = num_points;

               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x,y);
               break;
            case STBTT_vline:
               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x, y);
               break;
            case STBTT_vcurve:
               stbtt__tesselate_curve(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
            case STBTT_vcubic:
               stbtt__tesselate_cubic(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].cx1, vertices[i].cy1,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
         }
      }
      (*contour_lengths)[n] = num_points - start;
   }

   return points;
error:
   STBTT_free(points, userdata);
   STBTT_free(*contour_lengths, userdata);
   *contour_lengths = 0;
   *num_contours = 0;
   return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
   float scale            = scale_x > scale_y ? scale_y : scale_x;
   int winding_count      = 0;
   int *winding_lengths   = NULL;
   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
   if (windings) {
      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
      STBTT_free(winding_lengths, userdata);
      STBTT_free(windings, userdata);
   }
}

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   int ix0,iy0,ix1,iy1;
   stbtt__bitmap gbm;
   stbtt_vertex *vertices;   
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) {
         STBTT_free(vertices, info->userdata);
         return NULL;
      }
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

   // now we get the size
   gbm.w = (ix1 - ix0);
   gbm.h = (iy1 - iy0);
   gbm.pixels = NULL; // in case we error

   if (width ) *width  = gbm.w;
   if (height) *height = gbm.h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;
   
   if (gbm.w && gbm.h) {
      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
      if (gbm.pixels) {
         gbm.stride = gbm.w;

         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
      }
   }
   STBTT_free(vertices, info->userdata);
   return gbm.pixels;
}   

STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
{
   int ix0,iy0;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
   stbtt__bitmap gbm;   

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
   gbm.pixels = output;
   gbm.w = out_w;
   gbm.h = out_h;
   gbm.stride = out_stride;

   if (gbm.w && gbm.h)
      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

   STBTT_free(vertices, info->userdata);
}

STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);
}   

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);
}   

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
{
   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);
}

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-CRAPPY packing to keep source code small

static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata)
{
   float scale;
   int x,y,bottom_y, i;
   stbtt_fontinfo f;
   f.userdata = NULL;
   if (!stbtt_InitFont(&f, data, offset))
      return -1;
   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
   x=y=1;
   bottom_y = 1;

   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);

   for (i=0; i < num_chars; ++i) {
      int advance, lsb, x0,y0,x1,y1,gw,gh;
      int g = stbtt_FindGlyphIndex(&f, first_char + i);
      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);
      gw = x1-x0;
      gh = y1-y0;
      if (x + gw + 1 >= pw)
         y = bottom_y, x = 1; // advance to next row
      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row
         return -i;
      STBTT_assert(x+gw < pw);
      STBTT_assert(y+gh < ph);
      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);
      chardata[i].x0 = (stbtt_int16) x;
      chardata[i].y0 = (stbtt_int16) y;
      chardata[i].x1 = (stbtt_int16) (x + gw);
      chardata[i].y1 = (stbtt_int16) (y + gh);
      chardata[i].xadvance = scale * advance;
      chardata[i].xoff     = (float) x0;
      chardata[i].yoff     = (float) y0;
      x = x + gw + 1;
      if (y+gh+1 > bottom_y)
         bottom_y = y+gh+1;
   }
   return bottom_y;
}

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
{
   float d3d_bias = opengl_fillrule ? 0 : -0.5f;
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_bakedchar *b = chardata + char_index;
   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);
   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);

   q->x0 = round_x + d3d_bias;
   q->y0 = round_y + d3d_bias;
   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// rectangle packing replacement routines if you don't have stb_rect_pack.h
//

#ifndef STB_RECT_PACK_VERSION

typedef int stbrp_coord;

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                                                                                //
// COMPILER WARNING ?!?!?                                                         //
//                                                                                //
//                                                                                //
// if you get a compile warning due to these symbols being defined more than      //
// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
   int width,height;
   int x,y,bottom_y;
} stbrp_context;

typedef struct
{
   unsigned char x;
} stbrp_node;

struct stbrp_rect
{
   stbrp_coord x,y;
   int id,w,h,was_packed;
};

static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
{
   con->width  = pw;
   con->height = ph;
   con->x = 0;
   con->y = 0;
   con->bottom_y = 0;
   STBTT__NOTUSED(nodes);
   STBTT__NOTUSED(num_nodes);   
}

static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)
{
   int i;
   for (i=0; i < num_rects; ++i) {
      if (con->x + rects[i].w > con->width) {
         con->x = 0;
         con->y = con->bottom_y;
      }
      if (con->y + rects[i].h > con->height)
         break;
      rects[i].x = con->x;
      rects[i].y = con->y;
      rects[i].was_packed = 1;
      con->x += rects[i].w;
      if (con->y + rects[i].h > con->bottom_y)
         con->bottom_y = con->y + rects[i].h;
   }
   for (   ; i < num_rects; ++i)
      rects[i].was_packed = 0;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.

STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
{
   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
   int            num_nodes = pw - padding;
   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

   if (context == NULL || nodes == NULL) {
      if (context != NULL) STBTT_free(context, alloc_context);
      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
      return 0;
   }

   spc->user_allocator_context = alloc_context;
   spc->width = pw;
   spc->height = ph;
   spc->pixels = pixels;
   spc->pack_info = context;
   spc->nodes = nodes;
   spc->padding = padding;
   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
   spc->h_oversample = 1;
   spc->v_oversample = 1;

   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

   if (pixels)
      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

   return 1;
}

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)
{
   STBTT_free(spc->nodes    , spc->user_allocator_context);
   STBTT_free(spc->pack_info, spc->user_allocator_context);
}

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
{
   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
   if (h_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->h_oversample = h_oversample;
   if (v_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->v_oversample = v_oversample;
}

#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)

static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_w = w - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < h; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < w; ++i) {
         STBTT_assert(pixels[i] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i] = (unsigned char) (total / kernel_width);
      }

      pixels += stride_in_bytes;
   }
}

static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_h = h - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < w; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < h; ++i) {
         STBTT_assert(pixels[i*stride_in_bytes] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
      }

      pixels += 1;
   }
}

static float stbtt__oversample_shift(int oversample)
{
   if (!oversample)
      return 0.0f;

   // The prefilter is a box filter of width "oversample",
   // which shifts phase by (oversample - 1)/2 pixels in
   // oversampled space. We want to shift in the opposite
   // direction to counter this.
   return (float)-(oversample - 1) / (2.0f * (float)oversample);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k;

   k=0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      ranges[i].h_oversample = (unsigned char) spc->h_oversample;
      ranges[i].v_oversample = (unsigned char) spc->v_oversample;
      for (j=0; j < ranges[i].num_chars; ++j) {
         int x0,y0,x1,y1;
         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
         int glyph = stbtt_FindGlyphIndex(info, codepoint);
         stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,
                                         scale * spc->h_oversample,
                                         scale * spc->v_oversample,
                                         0,0,
                                         &x0,&y0,&x1,&y1);
         rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);
         rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);
         ++k;
      }
   }

   return k;
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info,
                                 output,
                                 out_w - (prefilter_x - 1),
                                 out_h - (prefilter_y - 1),
                                 out_stride,
                                 scale_x,
                                 scale_y,
                                 shift_x,
                                 shift_y,
                                 glyph);

   if (prefilter_x > 1)
      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);

   if (prefilter_y > 1)
      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);

   *sub_x = stbtt__oversample_shift(prefilter_x);
   *sub_y = stbtt__oversample_shift(prefilter_y);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k, return_value = 1;

   // save current values
   int old_h_over = spc->h_oversample;
   int old_v_over = spc->v_oversample;

   k = 0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      float recip_h,recip_v,sub_x,sub_y;
      spc->h_oversample = ranges[i].h_oversample;
      spc->v_oversample = ranges[i].v_oversample;
      recip_h = 1.0f / spc->h_oversample;
      recip_v = 1.0f / spc->v_oversample;
      sub_x = stbtt__oversample_shift(spc->h_oversample);
      sub_y = stbtt__oversample_shift(spc->v_oversample);
      for (j=0; j < ranges[i].num_chars; ++j) {
         stbrp_rect *r = &rects[k];
         if (r->was_packed) {
            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
            int advance, lsb, x0,y0,x1,y1;
            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
            int glyph = stbtt_FindGlyphIndex(info, codepoint);
            stbrp_coord pad = (stbrp_coord) spc->padding;

            // pad on left and top
            r->x += pad;
            r->y += pad;
            r->w -= pad;
            r->h -= pad;
            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
            stbtt_GetGlyphBitmapBox(info, glyph,
                                    scale * spc->h_oversample,
                                    scale * spc->v_oversample,
                                    &x0,&y0,&x1,&y1);
            stbtt_MakeGlyphBitmapSubpixel(info,
                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                          r->w - spc->h_oversample+1,
                                          r->h - spc->v_oversample+1,
                                          spc->stride_in_bytes,
                                          scale * spc->h_oversample,
                                          scale * spc->v_oversample,
                                          0,0,
                                          glyph);

            if (spc->h_oversample > 1)
               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->h_oversample);

            if (spc->v_oversample > 1)
               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->v_oversample);

            bc->x0       = (stbtt_int16)  r->x;
            bc->y0       = (stbtt_int16)  r->y;
            bc->x1       = (stbtt_int16) (r->x + r->w);
            bc->y1       = (stbtt_int16) (r->y + r->h);
            bc->xadvance =                scale * advance;
            bc->xoff     =       (float)  x0 * recip_h + sub_x;
            bc->yoff     =       (float)  y0 * recip_v + sub_y;
            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
         } else {
            return_value = 0; // if any fail, report failure
         }

         ++k;
      }
   }

   // restore original values
   spc->h_oversample = old_h_over;
   spc->v_oversample = old_v_over;

   return return_value;
}

STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
{
   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);
}

STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
{
   stbtt_fontinfo info;
   int i,j,n, return_value = 1;
   //stbrp_context *context = (stbrp_context *) spc->pack_info;
   stbrp_rect    *rects;

   // flag all characters as NOT packed
   for (i=0; i < num_ranges; ++i)
      for (j=0; j < ranges[i].num_chars; ++j)
         ranges[i].chardata_for_range[j].x0 =
         ranges[i].chardata_for_range[j].y0 =
         ranges[i].chardata_for_range[j].x1 =
         ranges[i].chardata_for_range[j].y1 = 0;

   n = 0;
   for (i=0; i < num_ranges; ++i)
      n += ranges[i].num_chars;
         
   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);
   if (rects == NULL)
      return 0;

   info.userdata = spc->user_allocator_context;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));

   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);

   stbtt_PackFontRangesPackRects(spc, rects, n);
  
   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);

   STBTT_free(rects, spc->user_allocator_context);
   return return_value;
}

STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
{
   stbtt_pack_range range;
   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
   range.array_of_unicode_codepoints = NULL;
   range.num_chars                   = num_chars_in_range;
   range.chardata_for_range          = chardata_for_range;
   range.font_size                   = font_size;
   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);
}

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
{
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_packedchar *b = chardata + char_index;

   if (align_to_integer) {
      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
      q->x0 = x;
      q->y0 = y;
      q->x1 = x + b->xoff2 - b->xoff;
      q->y1 = y + b->yoff2 - b->yoff;
   } else {
      q->x0 = *xpos + b->xoff;
      q->y0 = *ypos + b->yoff;
      q->x1 = *xpos + b->xoff2;
      q->y1 = *ypos + b->yoff2;
   }

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// sdf computation
//

#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))
#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))

static int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])
{
   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];
   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];
   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];
   float roperp = orig[1]*ray[0] - orig[0]*ray[1];

   float a = q0perp - 2*q1perp + q2perp;
   float b = q1perp - q0perp;
   float c = q0perp - roperp;

   float s0 = 0., s1 = 0.;
   int num_s = 0;

   if (a != 0.0) {
      float discr = b*b - a*c;
      if (discr > 0.0) {
         float rcpna = -1 / a;
         float d = (float) STBTT_sqrt(discr);
         s0 = (b+d) * rcpna;
         s1 = (b-d) * rcpna;
         if (s0 >= 0.0 && s0 <= 1.0)
            num_s = 1;
         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {
            if (num_s == 0) s0 = s1;
            ++num_s;
         }
      }
   } else {
      // 2*b*s + c = 0
      // s = -c / (2*b)
      s0 = c / (-2 * b);
      if (s0 >= 0.0 && s0 <= 1.0)
         num_s = 1;
   }

   if (num_s == 0)
      return 0;
   else {
      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);
      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;

      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;
      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;
      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;
      float rod = orig[0]*rayn_x + orig[1]*rayn_y;

      float q10d = q1d - q0d;
      float q20d = q2d - q0d;
      float q0rd = q0d - rod;

      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;
      hits[0][1] = a*s0+b;

      if (num_s > 1) {
         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;
         hits[1][1] = a*s1+b;
         return 2;
      } else {
         return 1;
      }
   }
}

static int equal(float *a, float *b)
{
   return (a[0] == b[0] && a[1] == b[1]);
}

static int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)
{
   int i;
   float orig[2], ray[2] = { 1, 0 };
   float y_frac;
   int winding = 0;

   orig[0] = x;
   orig[1] = y;

   // make sure y never passes through a vertex of the shape
   y_frac = (float) STBTT_fmod(y, 1.0f);
   if (y_frac < 0.01f)
      y += 0.01f;
   else if (y_frac > 0.99f)
      y -= 0.01f;
   orig[1] = y;

   // test a ray from (-infinity,y) to (x,y)
   for (i=0; i < nverts; ++i) {
      if (verts[i].type == STBTT_vline) {
         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;
         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;
         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
            if (x_inter < x)  
               winding += (y0 < y1) ? 1 : -1;
         }
      }
      if (verts[i].type == STBTT_vcurve) {
         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;
         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;
         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;
         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));
         int by = STBTT_max(y0,STBTT_max(y1,y2));
         if (y > ay && y < by && x > ax) {
            float q0[2],q1[2],q2[2];
            float hits[2][2];
            q0[0] = (float)x0;
            q0[1] = (float)y0;
            q1[0] = (float)x1;
            q1[1] = (float)y1;
            q2[0] = (float)x2;
            q2[1] = (float)y2;
            if (equal(q0,q1) || equal(q1,q2)) {
               x0 = (int)verts[i-1].x;
               y0 = (int)verts[i-1].y;
               x1 = (int)verts[i  ].x;
               y1 = (int)verts[i  ].y;
               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
                  if (x_inter < x)  
                     winding += (y0 < y1) ? 1 : -1;
               }
            } else {
               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);
               if (num_hits >= 1)
                  if (hits[0][0] < 0)
                     winding += (hits[0][1] < 0 ? -1 : 1);
               if (num_hits >= 2)
                  if (hits[1][0] < 0)
                     winding += (hits[1][1] < 0 ? -1 : 1);
            }
         } 
      }
   }
   return winding;
}

static float stbtt__cuberoot( float x )
{
   if (x<0)
      return -(float) STBTT_pow(-x,1.0f/3.0f);
   else
      return  (float) STBTT_pow( x,1.0f/3.0f);
}

// x^3 + c*x^2 + b*x + a = 0
static int stbtt__solve_cubic(float a, float b, float c, float* r)
{
	float s = -a / 3;
	float p = b - a*a / 3;
	float q = a * (2*a*a - 9*b) / 27 + c;
   float p3 = p*p*p;
	float d = q*q + 4*p3 / 27;
	if (d >= 0) {
		float z = (float) STBTT_sqrt(d);
		float u = (-q + z) / 2;
		float v = (-q - z) / 2;
		u = stbtt__cuberoot(u);
		v = stbtt__cuberoot(v);
		r[0] = s + u + v;
		return 1;
	} else {
	   float u = (float) STBTT_sqrt(-p/3);
	   float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative
	   float m = (float) STBTT_cos(v);
      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;
	   r[0] = s + u * 2 * m;
	   r[1] = s - u * (m + n);
	   r[2] = s - u * (m - n);

      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?
      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);
      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);
   	return 3;
   }
}

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   float scale_x = scale, scale_y = scale;
   int ix0,iy0,ix1,iy1;
   int w,h;
   unsigned char *data;

   // if one scale is 0, use same scale for both
   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) return NULL;  // if both scales are 0, return NULL
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);

   // if empty, return NULL
   if (ix0 == ix1 || iy0 == iy1)
      return NULL;

   ix0 -= padding;
   iy0 -= padding;
   ix1 += padding;
   iy1 += padding;

   w = (ix1 - ix0);
   h = (iy1 - iy0);

   if (width ) *width  = w;
   if (height) *height = h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   // invert for y-downwards bitmaps
   scale_y = -scale_y;
      
   {
      int x,y,i,j;
      float *precompute;
      stbtt_vertex *verts;
      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);
      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);
      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);

      for (i=0,j=num_verts-1; i < num_verts; j=i++) {
         if (verts[i].type == STBTT_vline) {
            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;
            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;
            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;
         } else if (verts[i].type == STBTT_vcurve) {
            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;
            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;
            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;
            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
            float len2 = bx*bx + by*by;
            if (len2 != 0.0f)
               precompute[i] = 1.0f / (bx*bx + by*by);
            else
               precompute[i] = 0.0f;
         } else
            precompute[i] = 0.0f;
      }

      for (y=iy0; y < iy1; ++y) {
         for (x=ix0; x < ix1; ++x) {
            float val;
            float min_dist = 999999.0f;
            float sx = (float) x + 0.5f;
            float sy = (float) y + 0.5f;
            float x_gspace = (sx / scale_x);
            float y_gspace = (sy / scale_y);

            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path

            for (i=0; i < num_verts; ++i) {
               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;

               // check against every point here rather than inside line/curve primitives -- @TODO: wrong if multiple 'moves' in a row produce a garbage point, and given culling, probably more efficient to do within line/curve
               float dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
               if (dist2 < min_dist*min_dist)
                  min_dist = (float) STBTT_sqrt(dist2);

               if (verts[i].type == STBTT_vline) {
                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;

                  // coarse culling against bbox
                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&
                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)
                  float dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];
                  STBTT_assert(i != 0);
                  if (dist < min_dist) {
                     // check position along line
                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)
                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)
                     float dx = x1-x0, dy = y1-y0;
                     float px = x0-sx, py = y0-sy;
                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy
                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve
                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);
                     if (t >= 0.0f && t <= 1.0f)
                        min_dist = dist;
                  }
               } else if (verts[i].type == STBTT_vcurve) {
                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;
                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;
                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);
                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);
                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);
                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);
                  // coarse culling against bbox to avoid computing cubic unnecessarily
                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {
                     int num=0;
                     float ax = x1-x0, ay = y1-y0;
                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
                     float mx = x0 - sx, my = y0 - sy;
                     float res[3],px,py,t,it;
                     float a_inv = precompute[i];
                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula
                        float a = 3*(ax*bx + ay*by);
                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);
                        float c = mx*ax+my*ay;
                        if (a == 0.0) { // if a is 0, it's linear
                           if (b != 0.0) {
                              res[num++] = -c/b;
                           }
                        } else {
                           float discriminant = b*b - 4*a*c;
                           if (discriminant < 0)
                              num = 0;
                           else {
                              float root = (float) STBTT_sqrt(discriminant);
                              res[0] = (-b - root)/(2*a);
                              res[1] = (-b + root)/(2*a);
                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work
                           }
                        }
                     } else {
                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point
                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;
                        float d = (mx*ax+my*ay) * a_inv;
                        num = stbtt__solve_cubic(b, c, d, res);
                     }
                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {
                        t = res[0], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {
                        t = res[1], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {
                        t = res[2], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                  }
               }
            }
            if (winding == 0)
               min_dist = -min_dist;  // if outside the shape, value is negative
            val = onedge_value + pixel_dist_scale * min_dist;
            if (val < 0)
               val = 0;
            else if (val > 255)
               val = 255;
            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;
         }
      }
      STBTT_free(precompute, info->userdata);
      STBTT_free(verts, info->userdata);
   }
   return data;
}   

STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// font name matching -- recommended not to use this
//

// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2) 
{
   stbtt_int32 i=0;

   // convert utf16 to utf8 and compare the results while converting
   while (len2) {
      stbtt_uint16 ch = s2[0]*256 + s2[1];
      if (ch < 0x80) {
         if (i >= len1) return -1;
         if (s1[i++] != ch) return -1;
      } else if (ch < 0x800) {
         if (i+1 >= len1) return -1;
         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;
         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;
      } else if (ch >= 0xd800 && ch < 0xdc00) {
         stbtt_uint32 c;
         stbtt_uint16 ch2 = s2[2]*256 + s2[3];
         if (i+3 >= len1) return -1;
         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;
         if (s1[i++] != 0xf0 + (c >> 18)) return -1;
         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;
         s2 += 2; // plus another 2 below
         len2 -= 2;
      } else if (ch >= 0xdc00 && ch < 0xe000) {
         return -1;
      } else {
         if (i+2 >= len1) return -1;
         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;
         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;
      }
      s2 += 2;
      len2 -= 2;
   }
   return i;
}

static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2) 
{
   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);
}

// returns results in whatever encoding you request... but note that 2-byte encodings
// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
{
   stbtt_int32 i,count,stringOffset;
   stbtt_uint8 *fc = font->data;
   stbtt_uint32 offset = font->fontstart;
   stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return NULL;

   count = ttUSHORT(fc+nm+2);
   stringOffset = nm + ttUSHORT(fc+nm+4);
   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)
          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {
         *length = ttUSHORT(fc+loc+8);
         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));
      }
   }
   return NULL;
}

static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
{
   stbtt_int32 i;
   stbtt_int32 count = ttUSHORT(fc+nm+2);
   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);

   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      stbtt_int32 id = ttUSHORT(fc+loc+6);
      if (id == target_id) {
         // find the encoding
         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);

         // is this a Unicode encoding?
         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {
            stbtt_int32 slen = ttUSHORT(fc+loc+8);
            stbtt_int32 off = ttUSHORT(fc+loc+10);

            // check if there's a prefix match
            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);
            if (matchlen >= 0) {
               // check for target_id+1 immediately following, with same encoding & language
               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {
                  slen = ttUSHORT(fc+loc+12+8);
                  off = ttUSHORT(fc+loc+12+10);
                  if (slen == 0) {
                     if (matchlen == nlen)
                        return 1;
                  } else if (matchlen < nlen && name[matchlen] == ' ') {
                     ++matchlen;
                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))
                        return 1;
                  }
               } else {
                  // if nothing immediately following
                  if (matchlen == nlen)
                     return 1;
               }
            }
         }

         // @TODO handle other encodings
      }
   }
   return 0;
}

static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
{
   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);
   stbtt_uint32 nm,hd;
   if (!stbtt__isfont(fc+offset)) return 0;

   // check italics/bold/underline flags in macStyle...
   if (flags) {
      hd = stbtt__find_table(fc, offset, "head");
      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;
   }

   nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return 0;

   if (flags) {
      // if we checked the macStyle flags, then just check the family and ignore the subfamily
      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   } else {
      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   }

   return 0;
}

static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)
{
   stbtt_int32 i;
   for (i=0;;++i) {
      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);
      if (off < 0) return off;
      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))
         return off;
   }
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,
                                float pixel_height, unsigned char *pixels, int pw, int ph,
                                int first_char, int num_chars, stbtt_bakedchar *chardata)
{
   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);
}

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)
{
   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);   
}

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)
{
   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);
}

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)
{
   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
}

STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)
{
   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);
}

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)
{
   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif // STB_TRUETYPE_IMPLEMENTATION


// FULL VERSION HISTORY
//
//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) allow user-defined fabs() replacement
//                     fix memory leak if fontsize=0.0
//                     fix warning from duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     allow PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                     also more precise AA rasterizer, except if shapes overlap
//                     remove need for STBTT_sort
//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//   1.04 (2015-04-15) typo in example
//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
//                        non-oversampled; STBTT_POINT_SIZE for packed case only
//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
//   0.8b (2014-07-07) fix a warning
//   0.8  (2014-05-25) fix a few more warnings
//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
//   0.6c (2012-07-24) improve documentation
//   0.6b (2012-07-20) fix a few more warnings
//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
//   0.5  (2011-12-09) bugfixes:
//                        subpixel glyph renderer computed wrong bounding box
//                        first vertex of shape can be off-curve (FreeSans)
//   0.4b (2011-12-03) fixed an error in the font baking example
//   0.4  (2011-12-01) kerning, subpixel rendering (tor)
//                    bugfixes for:
//                        codepoint-to-glyph conversion using table fmt=12
//                        codepoint-to-glyph conversion using table fmt=4
//                        stbtt_GetBakedQuad with non-square texture (Zer)
//                    updated Hello World! sample to use kerning and subpixel
//                    fixed some warnings
//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
//                    userdata, malloc-from-userdata, non-zero fill (stb)
//   0.2  (2009-03-11) Fix unsigned/signed char warnings
//   0.1  (2009-03-09) First public release
//

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`README.md`:

```md
###  Valorant Aimbot + Esp C++ 
```sh-session
VALORANT EXTERNAL RELEASE C++ / AIMBOT / ESP / SPOOFER / DRIVER 
```

***

### 📌・   DISCORD SHOP : [Fate Univers] (https://discord.gg/YaaFUKHw34) 

* `👋 SELL CHEATING PRIVATE / SPOOFER / SOURCE CODE / ETC `
* `✔️ UPDATE FREE & LIFETIME & UNDETECTED & BYPASS DRIVER , INJECTOR `
* ` IF YOU WANT A SAFE CHEATING PRIVATE , THINK OF ME`
* ` SAFE 100% IF BANNED = REFUND MONEY`
* ` WE GIVE YOU THE HIGHEST LEVEL OF SECURITY AND PRIVACY , DON'T WORRY`

🌐・ **Website** : https://fate-shop.fr

🐵・**We** have a backup server base and many main servers and we are **LEGIT**

 ```sh-session
MY CHEATS , YOU CAN PLAY ON THE MAIN ACCOUT. IT WON"T GET YOU BANNED :) / DM TO BUY 
```                
                           
## Features
<details>
<summary>Features (Drop Down)</summary>
  
* AIMBOT
  
* ESP
  
* SPOOFER HARDWARE IDS
  </details>
***

![cccsc](https://user-images.githubusercontent.com/94861415/164327675-7b80b794-7cb7-4234-8e9f-d65aaa913b27.png)


![nice release](https://user-images.githubusercontent.com/94861415/164327708-94d92101-6dc0-4833-ae80-7894b448dad3.png)




```

`Valorant Spoofer/fnv.hpp`:

```hpp
/* This file is part of hdd_serial_spoofer by namazso, licensed under the MIT license:
*
* MIT Licenses
*
* Copyright (c) namazso 2018
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
#pragma once
#include <cstdint>
#include <type_traits>

// Implements FNV-1a hash algorithm
namespace detail
{
	template <typename Type, Type OffsetBasis, Type Prime>
	struct SizeDependantData
	{
		using type = Type;

		constexpr static auto k_offset_basis = OffsetBasis;
		constexpr static auto k_prime = Prime;
	};

	template <std::size_t Bits>
	struct SizeSelector : std::false_type { };

	template <>
	struct SizeSelector<32> : SizeDependantData<std::uint32_t, 0x811c9dc5ul, 16777619ul> { };

	template <>
	struct SizeSelector<64> : SizeDependantData<std::uint64_t, 0xcbf29ce484222325ull, 1099511628211ull> { };

	template <std::size_t Size>
	class FnvHash
	{
	private:
		using data_t = SizeSelector<Size>;

	public:
		using hash = typename data_t::type;

	private:
		constexpr static auto k_offset_basis = data_t::k_offset_basis;
		constexpr static auto k_prime = data_t::k_prime;

	public:
		static __forceinline constexpr auto hash_init(
		) -> hash
		{
			return k_offset_basis;
		}

		static __forceinline constexpr auto hash_byte(
			hash current,
			std::uint8_t byte
		) -> hash
		{
			return ( current ^ byte ) * k_prime;
		}

		template <std::size_t N>
		static __forceinline constexpr auto hash_constexpr(
			const char( &str )[ N ],
			const std::size_t size = N - 1 /* do not hash the null */
		) -> hash
		{
			const auto prev_hash = size == 1 ? hash_init( ) : hash_constexpr( str, size - 1 );
			const auto cur_hash = hash_byte( prev_hash, str[ size - 1 ] );
			return cur_hash;
		}

		static auto __forceinline hash_runtime_data(
			const void* data,
			const std::size_t sz
		) -> hash
		{
			const auto bytes = static_cast< const uint8_t* >( data );
			const auto end = bytes + sz;
			auto result = hash_init( );
			for ( auto it = bytes; it < end; ++it )
				result = hash_byte( result, *it );

			return result;
		}

		static auto __forceinline hash_runtime(
			const char* str
		) -> hash
		{
			auto result = hash_init( );
			do
				result = hash_byte( result, *str++ );
			while ( *str != '\0' );

			return result;
		}
	};
}

using fnv32 = ::detail::FnvHash<32>;
using fnv64 = ::detail::FnvHash<64>;
using fnv = ::detail::FnvHash<sizeof( void* ) * 8>;

#define FNV(str) (std::integral_constant<fnv::hash, fnv::hash_constexpr(str)>::value)
#define FNV32(str) (std::integral_constant<fnv32::hash, fnv32::hash_constexpr(str)>::value)
#define FNV64(str) (std::integral_constant<fnv64::hash, fnv64::hash_constexpr(str)>::value)


delete <<
```

`Valorant Spoofer/gpu.hpp`:

```hpp
#pragma once
#include "util.hpp"
#include "log.hpp" // test

namespace n_gpu
{
	char customize_gpu_serial[100]{ 0 };

	PDRIVER_DISPATCH g_original_device_control = 0;

	NTSTATUS my_device_control(PDEVICE_OBJECT device, PIRP irp)
	{
		PIO_STACK_LOCATION ioc = IoGetCurrentIrpStackLocation(irp);

#define IOCTL_NVIDIA_SMIL (0x8DE0008)
#define IOCTL_NVIDIA_SMIL_MAX (512)
		if (ioc->Parameters.DeviceIoControl.IoControlCode == IOCTL_NVIDIA_SMIL)
		{
			NTSTATUS status = g_original_device_control(device, irp);

			char* original_buffer = (char*)irp->UserBuffer;
			const int length = IOCTL_NVIDIA_SMIL_MAX;

			if (original_buffer)
			{
				const unsigned long tag = 'Gput';
				void* buffer = ExAllocatePoolWithTag(NonPagedPool, length, tag);
				if (buffer)
				{
					MM_COPY_ADDRESS addr{ 0 };
					addr.VirtualAddress = irp->UserBuffer;

					SIZE_T copy_size = 0;
					if (NT_SUCCESS(MmCopyMemory(buffer, addr, length, MM_COPY_MEMORY_VIRTUAL, &copy_size))
						&& copy_size == length)
					{
						const char* gpu = "GPU-";
						const size_t len = strlen(gpu);

						for (int i = 0; i < length - len; i++)
						{
							char* ptr = (char*)buffer + i;
							if (0 == memcmp(ptr, gpu, strlen(gpu)))
							{
								RtlCopyMemory(original_buffer + i + len, customize_gpu_serial, 100);
								// n_util::random_string(original_buffer + i + len, 0);
								break;
							}
						}
					}

					ExFreePoolWithTag(buffer, tag);
				}
			}

			return status;
		}

		return g_original_device_control(device, irp);
	}

	bool start_hook()
	{
		g_original_device_control = n_util::add_irp_hook(L"\\Driver\\nvlddmkm", my_device_control);
		return g_original_device_control;
	}

	bool clean_hook()
	{
		return n_util::del_irp_hook(L"\\Driver\\nvlddmkm", g_original_device_control);
	}
}

```

`Valorant Spoofer/hwid_spoofer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>s
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>s
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pattern.cpp">
      <Filter>Header Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pattern.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="exported.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="raid_extension.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="fnv.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Valorant Spoofer/hwid_spoofer.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Valorant Spoofer/log.hpp`:

```hpp
#pragma once
#include <ntifs.h>
#include <stdarg.h>

namespace n_log
{
	void printf(const char* text, ...)
	{
		va_list(args);
		va_start(args, text);

		vDbgPrintExWithPrefix("[hwid spoofer] : ", 0, 0, text, args);

		va_end(args);
	}
}

```

`Valorant Spoofer/main.cpp`:

```cpp
#include "pattern.hpp"
#include "util.hpp"
#include "raid_extension.hpp"
#include <classpnp.h>
#include <ntifs.h>s

NTSTATUS driver_start( )
{
	std::unique_ptr< DRIVER_OBJECT, decltype( &ObfDereferenceObject ) > disk_object( nullptr, &ObfDereferenceObject );
	
	UNICODE_STRING driver_unicode{};
	RtlInitUnicodeString( &driver_unicode, L"\\Driver\\Disk" );
	
	ObReferenceObjectByName( &driver_unicode, OBJ_CASE_INSENSITIVE, nullptr, 0, *IoDriverObjectType, KernelMode, nullptr, reinterpret_cast< void** >( disk_object.get( ) ) );

	if ( !disk_object.get( ) )
		return STATUS_UNSUCCESSFUL;

	memory::initialize( L"disk.sys" );
	const auto DiskEnableDisableFailurePrediction = reinterpret_cast< NTSTATUS( __fastcall* )( PFUNCTIONAL_DEVICE_EXTENSION, BOOLEAN ) >( memory::from_pattern( "\x48\x89\x5c\x24\x00\x48\x89\x74\x24\x00\x57\x48\x81\xec\x00\x00\x00\x00\x48\x8b\x05\x00\x00\x00\x00\x48\x33\xc4\x48\x89\x84\x24\x00\x00\x00\x00\x48\x8b\x59\x60\x48\x8b\xf1\x40\x8a\xfa\x8b\x4b\x10", "xxxx?xxxx?xxxx????xxx????xxxxxxx????xxxxxxxxxxxxx" ) );

	if ( !DiskEnableDisableFailurePrediction )
		return STATUS_UNSUCCESSFUL;

	memory::initialize( L"storport.sys" );
	const auto RaidUnitRegisterInterfaces_address = memory::from_pattern( "\xe8\x00\x00\x00\x00\x48\x8b\xcb\xe8\x00\x00\x00\x00\x85\xc0\x74\x0a", "x????xxxx????xxxx" );

	if ( !RaidUnitRegisterInterfaces_address )
		return STATUS_UNSUCCESSFUL;

	const auto RaidUnitRegisterInterfaces = reinterpret_cast< NTSTATUS( __fastcall* )( RAID_UNIT_EXTENSION* ) >( RaidUnitRegisterInterfaces_address + 5 + *reinterpret_cast< std::int32_t* >( RaidUnitRegisterInterfaces_address + 1 ) );

	const auto seed = __rdtsc( );

	for (auto current_object = disk_object->DeviceObject; current_object != nullptr; current_object = current_object->NextDevice )
	{
		const auto fd_extension = static_cast< PFUNCTIONAL_DEVICE_EXTENSION >( current_object->DeviceExtension );

		if ( !fd_extension )
			continue;

		const auto fs_device = IoGetDeviceAttachmentBaseRef( current_object );

		if ( !fs_device || fs_device->DeviceType != FILE_DEVICE_DISK || !fs_device->DeviceExtension )
			continue;

		const auto raid_extension = static_cast< PRAID_UNIT_EXTENSION >( fs_device->DeviceExtension );
		const auto identity = reinterpret_cast< PSTOR_SCSI_IDENTITY >( std::uintptr_t( raid_extension ) + 0x68 ); // this offset changes per windows build, you figure it out
		const auto fdo_descriptor = fd_extension->DeviceDescriptor;

		if ( !fdo_descriptor )
		{
			ObfDereferenceObject( fs_device );
			continue;
		}
		
		const auto fdo_serial = reinterpret_cast< char* >( fdo_descriptor ) + fdo_descriptor->SerialNumberOffset;

		serializer::randomize( seed, fdo_serial );

		identity->SerialNumber.Length = static_cast< USHORT >( std::strlen( fdo_serial ) );
		memset( identity->SerialNumber.Buffer, 0, identity->SerialNumber.Length );
		memcpy( identity->SerialNumber.Buffer, fdo_serial, identity->SerialNumber.Length );

		DiskEnableDisableFailurePrediction( fd_extension, FALSE );
		RaidUnitRegisterInterfaces( raid_extension );
		
		const auto raid_extension = static_cast< PRAID_UNIT_EXTENSION >( fs_device->DeviceExtension );
		const auto identity = reinterpret_cast< PSTOR_SCSI_IDENTITY >( std::uintptr_t( raid_extension ) + 0x68 ); // this offset changes per windows build, you figure it out
		const auto fdo_descriptor = fd_extension->DeviceDescriptor;
	}
		
	return STATUS_SUCCESS;
}

```

`Valorant Spoofer/pattern.cpp`:

```cpp
#include "pattern.hpp"
#include <vector>
#include <string>s

bool memory::initialize( const wchar_t* module )
{
	UNICODE_STRING module_name{};
	RtlInitUnicodeString( &module_name, module );

	for ( PLIST_ENTRY entry = PsLoadedModuleList; entry != PsLoadedModuleList->Blink; entry = entry->Flink )
	{s
		PLDR_DATA_TABLE_ENTRY data_table = CONTAINING_RECORD( entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks );

		if ( RtlEqualUnicodeString( &data_table->BaseDllName, &module_name, TRUE ) )
		{
			_memory_module = { std::uintptr_t(data_table->DllBase), data_table->SizeOfImage };
			break;
		}
	}

	return true;
}
std::uintptr_t memory::from_pattern( const char* sig, const char* mask )
{
	for ( std::uintptr_t i = 0; i < _memory_module.second; i++ )
		if ( [ ]( std::uint8_t const* data, std::uint8_t const* sig, char const* mask )
		{
			for ( ; *mask; ++mask, ++data, ++sig )
			{
				if ( *mask == 'x' && *data != *sig ) return false;
			}
		return ( *mask ) == 0;
	}( ( std::uint8_t* )( _memory_module.first + i ), ( std::uint8_t* )sig, mask ) )
		return _memory_module.first + i;

	return 0;
}
```

`Valorant Spoofer/pattern.hpp`:

```hpp
#pragma once
#include "exported.hpp"
#include <cstdint>
#include <string>s

namespace memory
{
	static std::pair<std::uintptr_t, std::uint32_t> _memory_module{};

	bool initialize( const wchar_t* module_name );
	std::uintptr_t from_pattern( const char* sig, const char* mask );
}
```

`Valorant Spoofer/raid_extension.hpp`:

```hpp
#pragma once
#include "exported.hpp"

typedef enum
{
	RaidUnknownObject = 0xFFFFFFFF,s
	RaidAdapterObject = 0x0,
	RaidUnitObject = 0x1,
	RaidDriverObject = 0x2,
} RAID_OBJECT_TYPE;

typedef enum
{
	DeviceStateNotPresent = 0x0,
	DeviceStateWorking = 0x1,
	DeviceStateStopped = 0x2,
	DeviceStatePendingStop = 0x3,
	DeviceStatePendingRemove = 0x4,
	DeviceStateSurpriseRemoval = 0x5,
	DeviceStateDeleted = 0x6,
	DeviceStateDisabled = 0x7,
	DeviceStateNoResource = 0x8,
} DEVICE_STATE;

typedef enum
{
	RaidDeferredTimerRequest = 0x1,
	RaidDeferredError = 0x2,
	RaidDeferredPause = 0x3,
	RaidDeferredResume = 0x4,
	RaidDeferredPauseDevice = 0x5,
	RaidDeferredResumeDevice = 0x6,
	RaidDeferredBusy = 0x7,
	RaidDeferredReady = 0x8,
	RaidDeferredDeviceBusy = 0x9,
	RaidDeferredDeviceReady = 0xA,
	RaidDeferredAdditionalTimerRequest = 0xB,
	RaidDeferredAsyncNotification = 0xC,
} RAID_DEFERRED_TYPE;

typedef struct _RAID_WORK_ITEM_CONTEXT
{
	struct _IO_WORKITEM* WorkItem;
	struct _IRP* Irp;
} RAID_WORK_ITEM_CONTEXT, * PRAID_WORK_ITEM_CONTEXT;

typedef struct __declspec( align( 8 ) ) _STOR_ASYNC_NOTIFY_CONTEXT
{
	struct _IO_WORKITEM* WorkItem;
	unsigned __int64 Flags;
	unsigned int InUse;
} STOR_ASYNC_NOTIFY_CONTEXT, * PSTOR_ASYNC_NOTIFY_CONTEXT;

typedef struct __declspec( align( 8 ) ) _RAID_SHARED_WORK_ITEM_CONTEXT
{
	struct _IO_WORKITEM* WorkItem;
	struct _IRP* Irp;
	unsigned int InUse;
} RAID_SHARED_WORK_ITEM_CONTEXT, * PRAID_SHARED_WORK_ITEM_CONTEXT;

typedef struct _RAID_UNIT_REGISTRY_PARAMETERS
{
	unsigned int BusyRetryCount;
	unsigned int QueueFullWaitIoPercentage;
	unsigned int BusyPauseTime;
	unsigned int EnableLogoETW;
	unsigned int DisableIdlePowerManagement;
	unsigned int MinimumIdleTimeoutInMS;
} RAID_UNIT_REGISTRY_PARAMETERS, * PRAID_UNIT_REGISTRY_PARAMETERS;

typedef struct _RAID_UNIT_ATTRIBUTES
{
	unsigned __int32 VmPassThroughLun : 1;
	unsigned __int32 DeviceAttentionSupported : 1;
	unsigned __int32 AsyncNotificationSupported : 1;
	unsigned __int32 D3ColdNotSupported : 1;
	unsigned __int32 DefaultWriteCacheEnabled : 1;
	unsigned __int32 Reserved : 27;
} RAID_UNIT_ATTRIBUTES, * PRAID_UNIT_ATTRIBUTES;

typedef struct _RAID_UNIT_QOS
{
	char Enabled;
	unsigned int RetryCount;
	unsigned int ResetUnresponsiveTimeoutIn500MS;
	unsigned int ResetInterval;
	unsigned int HwTimeoutInSec;
	unsigned int ResetTimeoutInSec;
	unsigned int MaxWaitTimeIn500MS;
	char TimerSettingChangeNeeded;
	int AdapterWaitTimeoutCheckEnabled;
	unsigned __int64 QosThresholdIn100NS;
} RAID_UNIT_QOS, * PRAID_UNIT_QOS;

typedef struct __declspec( align( 8 ) ) _RAID_TELEMETRY_ERROR_ENTRY
{
	char SrbStatus;
	char ScsiStatus;
	char SenseKey;
	char AdditionalSenseCode;
	char AdditionalSenseCodeQualifier;
	char CdbOpCode;
	char Reserved1[ 2 ];
	unsigned int IoSize;
	unsigned int IoLatency;
	unsigned int WaitDuration;
	unsigned int QueueDepth;
	unsigned __int64 LBA;
	union
	{
		unsigned int Quantity;
		unsigned int Position;
	} u;
} RAID_TELEMETRY_ERROR_ENTRY, * PRAID_TELEMETRY_ERROR_ENTRY;

typedef struct _RAID_TELEMETRY_SAMPLED_ERROR_LOG
{
	unsigned int TotalErrors;
	unsigned int TotalReadWriteErrors;
	unsigned int TotalStRtlImpendingDeviceFailureErrors;
	unsigned int TotalStRtlTotalDeviceFailureErrors;
	RAID_TELEMETRY_ERROR_ENTRY LastError;
	RAID_TELEMETRY_ERROR_ENTRY SampledErrors[ 10 ];
} RAID_TELEMETRY_SAMPLED_ERROR_LOG, * PRAID_TELEMETRY_SAMPLED_ERROR_LOG;

typedef struct _RAID_TELEMETRY_UNIQUE_ERROR_LOG
{
	RAID_TELEMETRY_ERROR_ENTRY UniqueErrors[ 5 ];
} RAID_TELEMETRY_UNIQUE_ERROR_LOG, * PRAID_TELEMETRY_UNIQUE_ERROR_LOG;

typedef struct __declspec( align( 4 ) ) _TELEMETRY_UNIT_EXTENSION
{
	struct
	{
		unsigned __int32 DeviceHealthEventsLogged : 1;
		unsigned __int32 FailedFirstSMARTCommand : 1;
		unsigned __int32 FailedFirstDeiceStatisticsLogCommand : 1;
		unsigned __int32 FailedFirstNvmeCloudSSDCommand : 1;
		unsigned __int32 SmartPredictFailure : 1;
		unsigned __int32 Reserved : 27;
	} Flags;
	char NvmeCriticalWarning;
} TELEMETRY_UNIT_EXTENSION, * PTELEMETRY_UNIT_EXTENSION;

typedef struct _RAID_IO_RESOURCES
{
	unsigned int QueueTag;
	void* SrbExtension;
	struct EXTENDED_REQUEST_BLOCK* Xrb;
	void* SenseInfo;
} RAID_IO_RESOURCES, * PRAID_IO_RESOURCES;

typedef struct __declspec( align( 16 ) ) _RAID_DEFERRED_HEADER
{
	SLIST_ENTRY Link;
	int Pool;
} RAID_DEFERRED_HEADER, * PRAID_DEFERRED_HEADER;

typedef struct _STOR_SCSI_IDENTITY
{
	INQUIRYDATA* InquiryData;        //0x0000
	STRING SerialNumber;            //0x0008 
	unsigned char Supports1667;        //0x0018 
	unsigned char ZonedDevice;        //0x0019 
	char pad_0x001A[ 0x6 ];            //0x001A
	UINT_PTR DeviceId;                //0x0020 
	UINT_PTR AtaDeviceId;            //0x0028 
	UINT_PTR RichDeviceDescription;    //0x0030 
} STOR_SCSI_IDENTITY, * PSTOR_SCSI_IDENTITY;

typedef struct _STOR_SCSI_ADDRESS
{
	char PathId;
	char TargetId;
	char Lun;
	char Reserved;
} STOR_SCSI_ADDRESS, * PSTOR_SCSI_ADDRESS;

typedef struct __declspec( align( 16 ) ) _RAID_DEFERRED_ELEMENT
{
	RAID_DEFERRED_HEADER Header;
	RAID_DEFERRED_TYPE Type;
	STOR_SCSI_ADDRESS Address;
	union
	{
		struct __declspec( align( 8 ) )
		{
			void( __fastcall * HwTimerRoutine )( void* );
			unsigned int Timeout;
		} Timer;
		struct
		{
			SCSI_REQUEST_BLOCK* Srb;
			unsigned int ErrorCode;
			unsigned int UniqueId;
			char FreeErrorInfo[ 16 ];
		} Error;
		struct
		{
			unsigned int Timeout;
		} PauseDevice;
		struct
		{
			unsigned int RequestsToComplete;
		} Busy;
		struct
		{
			unsigned int RequestsToComplete;
		} DeviceBusy;
		struct __declspec( align( 8 ) )
		{
			struct STOR_TIMER_CONTEXT* StorTimer;
			LARGE_INTEGER Timeout;
			unsigned int TolerableDelay;
		} AdditionalTimer;
		struct
		{
			STOR_ASYNC_NOTIFY_CONTEXT* StorAsyncNotify;
		} AsyncNotification;
	};
} RAID_DEFERRED_ELEMENT, * PRAID_DEFERRED_ELEMENT;

typedef struct __declspec( align( 8 ) ) _EXTENDED_DEVICE_QUEUE
{
	__int16 Type;
	__int16 Size;
	int Depth;
	struct STOR_IO_GATEWAY* Gateway;
	int DeviceCount;
	int ByPassCount;
	int ByPassPowerCount;
	int PauseCount;
	int BusyCount;
	char Frozen;
	char Locked;
	char Untagged;
	char PowerLocked;
	unsigned int QuiescenceClients;
	KEVENT QuiescenceEvent;
	volatile int RWLock;
	int OutstandingCount;
	LIST_ENTRY DeviceList;
	LIST_ENTRY ByPassList;
	LIST_ENTRY QosReqList;
	LIST_ENTRY ZoneWriteGroupList;
	unsigned __int64 ZoneWriteGroupListLock;
	unsigned int ZoneWriteGroupListEntries;
	int PeriodicMaxDeviceCount;
	int PeriodicMaxOutstandingCount;
} EXTENDED_DEVICE_QUEUE, * PEXTENDED_DEVICE_QUEUE;

typedef struct __declspec( align( 8 ) ) _IO_QUEUE
{
	DEVICE_OBJECT* DeviceObject;
	void( __fastcall* StartIo )( DEVICE_OBJECT*, struct _IRP*, void* );
	EXTENDED_DEVICE_QUEUE DeviceQueue;
	unsigned int QueueChanged;
} IO_QUEUE, * PIO_QUEUE;

typedef struct _QUEUE_TAG_LIST
{
	struct QUEUE_TAG_LIST_HEADER* Header;
	struct __declspec( align( 64 ) ) QUEUE_TAG_ENTRY* Buffer;
	unsigned int TagsPerNode;
} QUEUE_TAG_LIST, * PQUEUE_TAG_LIST;

typedef struct __declspec( align( 4 ) ) _RAID_POWER_STATE
{
	SYSTEM_POWER_STATE SystemState;
	DEVICE_POWER_STATE DeviceState;
	POWER_ACTION PowerAction;
	char SystemPoweringDown;
} RAID_POWER_STATE, * PRAID_POWER_STATE;

typedef struct __declspec( align( 64 ) ) _RAID_UNIT_EXTENSION
{
	RAID_OBJECT_TYPE ObjectType;
	DEVICE_OBJECT* DeviceObject;
	void* UnitExtension;
	struct RAID_ADAPTER_EXTENSION* Adapter;
	unsigned __int64 SlowLock;
	DEVICE_STATE DeviceState;
	LIST_ENTRY NextUnit;
	LIST_ENTRY UnitTableLink;
	union
	{
		STOR_ADDR_BTL8 StorAddressBTL8;
		struct
		{
			unsigned __int16 AddressType;
			unsigned __int16 AddressPort;
			unsigned int AddressLength;
			STOR_SCSI_ADDRESS Address;
		};
	};
	STOR_SCSI_IDENTITY Identity;
	struct
	{
		__int8 DeviceClaimed : 1;
		__int8 Enumerated : 1;
		__int8 Present : 1;
		__int8 Temporary : 1;
		__int8 WmiInitialized : 1;
		__int8 Zombie : 1;
		__int8 RescanNeeded : 1;
		__int8 PoweringUp : 1;
		__int8 PoweringDown : 1;
		__int8 D3ColdSupported : 1;
		__int8 D3ColdEnabled : 1;
		__int8 ActiveReferenceOnAdapter : 1;
		__int8 DeviceInitialized : 1;
		__int8 DisabledPendingTimer : 1;
		__int8 DumpActiveNotCapable : 1;
		__int8 RegisteredForPoFx : 1;
		__int8 BootUnit : 1;
		__int8 Unresponsive : 1;
		__int8 DumpAlwaysPowerOn : 1;
		__int8 VmLunInterfaceState : 1;
		unsigned __int32 Reserved : 12;
	} Flags;
	union
	{
		struct
		{
			unsigned __int32 PoFxRegistrationPending : 1;
			unsigned __int32 PowerCycleCountSavePending : 1;
			unsigned __int32 Reserved : 30;
		};
		unsigned int AsUlong;
	} InterlockedFlags;
	KEVENT ZeroOutstandingEvent;
	RAID_POWER_STATE Power;
	struct STOR_EVENT_QUEUE* PendingQueue;
	QUEUE_TAG_LIST TagList;
	IO_QUEUE IoQueue;
	unsigned int MaxQueueDepth;
	unsigned int LogicalSectorSize;
	STORAGE_POWERUP_REASON_TYPE PowerupReason;
	ACPI_INTERFACE_STANDARD2 AcpiInterface;
	int OutstandingCount;
	unsigned int PagingPathCount;
	unsigned int CrashDumpPathCount;
	unsigned int HiberPathCount;
	KTIMER PendingTimer;
	KDPC PendingDpc;
	KTIMER PauseTimer;
	KDPC PauseTimerDpc;
	KDPC RestartDpc;
	struct RAID_MEMORY_REGION* CommonBufferVAs;
	unsigned int CommonBufferSize;
	unsigned int CommonBufferBlocks;
	unsigned int DefaultTimeout;
	int ResetCount;
	struct
	{
		RAID_DEFERRED_ELEMENT PauseDevice;
		RAID_DEFERRED_ELEMENT ResumeDevice;
		RAID_DEFERRED_ELEMENT DeviceBusy;
		RAID_DEFERRED_ELEMENT DeviceReady;
		RAID_DEFERRED_ELEMENT AsyncNotification;
	} DeferredList;
	RAID_IO_RESOURCES ResetResources;
	int ResetResourcesAcquired;
	char SenseInfoSize;
	char CallFreeDumpPtrSRB;
	char DumpPowerReady;
	char StackDumpPowerReady;
	struct _EX_RUNDOWN_REF_CACHE_AWARE* PoFxRundownProtection;
	struct RAID_UNIT_POFX* PoFx;
	D3COLD_SUPPORT_INTERFACE* D3ColdInterface;
	volatile int PowerUpRequired;
	volatile int PowerDownRequired;
	struct _IO_WORKITEM* HierarchicalResetWorkItem;
	int HierarchicalResetWorkItemTimeoutCountdown;
	int HierarchicalResetSrbTimeoutCountdown;
	unsigned int HierarchicalResetAbortCount;
	volatile int PendingRequests;
	unsigned __int64 HierarchicalResetWorkItemSpinLock;
	RAID_UNIT_REGISTRY_PARAMETERS RegistryParameters;
	RAID_UNIT_ATTRIBUTES UnitAttributes;
	UNICODE_STRING VmLunPnpInterfaceName;
	RAID_WORK_ITEM_CONTEXT QuiesceDeviceWorkItem;
	STOR_ASYNC_NOTIFY_CONTEXT StorAsyncNotify;
	RAID_SHARED_WORK_ITEM_CONTEXT PowerWorkItem;
	struct
	{
		char FStateTransition;
		char DStateTransition;
		unsigned int FState;
		struct _IRP* PowerIrp;
	} PendingPowerUpContext;
	SLIST_ENTRY PendingPowerUpListEntry;
	UNICODE_STRING SesPnpInterfaceName;
	unsigned __int64 IoCountDelayedByLatencyCap;
	GUID DeviceGuid;
	TELEMETRY_UNIT_EXTENSION TelemetryExtension;
	unsigned __int64 FirstDPNRTimeAfterCS;
	unsigned __int64 LastF1StartTime;
	unsigned __int64 F1DurationInCS;
	unsigned __int64 LastDPNRStartTime;
	unsigned __int64 DPNRDurationInCS;
	unsigned __int64 ActiveReferencesInCS;
	unsigned __int64 ActiveReferencesInCoalescing;
	unsigned int UnitTimeoutsInCS;
	unsigned int F0TransitionsSinceCSStateChange;
	unsigned int D0TransitionsSinceCSStateChange;
	unsigned int F0TransitionsLongSinceCSStateChange;
	unsigned int D0TransitionsLongSinceCSStateChange;
	unsigned __int64 UnresponsiveRequests;
	unsigned __int64 QosGuaranteeFailures;
	unsigned __int64 TimeoutsInGateway;
	unsigned __int64 TimeoutsInLunQueue;
	unsigned int TimeoutsInMiniport;
	unsigned int PeriodicMaxDeviceCountAtSwTimeout;
	unsigned int PauseDeviceCount;
	unsigned int DeviceBusyCount;
	unsigned int BusyCompletionCount;
	unsigned int StorpTraceLoggingPerformanceEnabled;
	struct RAID_TELEMETRY_PERF_BUCKET* TelemetryPerfBuckets;
	LARGE_INTEGER TelemetryLastPerfCollectionTimeStamp;
	struct RAID_TELEMETRY_PERF_BUCKET* TelemetryPerfPreviousCounters;
	char* TelemetryMaxReadWriteLatencyPerNumaNode;
	unsigned __int64 TelemetryMaxFlushLatency;
	unsigned __int64 TelemetryMaxUnmapLatency;
	unsigned __int64 TelemetryLock;
	RAID_TELEMETRY_SAMPLED_ERROR_LOG TelemetrySampledErrorLog;
	RAID_TELEMETRY_UNIQUE_ERROR_LOG TelemetryUniqueErrorLog;
	unsigned __int64 TelemetryBytesWritten;
	unsigned __int64 TelemetryStreamBytesWritten;
	unsigned int PowerCycleCount;
	LARGE_INTEGER InitialTimestamp;
	RAID_UNIT_QOS Qos;
	unsigned __int64 LastHierarchicalResetEndTime;
	struct DUMP_DISK_INFO* CrashDumpInfo;
	struct DUMP_DISK_INFO* HiberDumpInfo;
	unsigned __int64 ZoneSize;
} RAID_UNIT_EXTENSION, * PRAID_UNIT_EXTENSION;
```

`Valorant Spoofer/util.hpp`:

```hpp
#pragma once
#include "exported.hpp"
#include "fnv.hpp"
#include <tuple>
#include <random>s

namespace serializer
{
	// thanks to namazso
	static inline bool is_good_char( char c )
	{
		const auto u = uint8_t( c );
		return ( u >= uint8_t( '0' ) && u <= uint8_t( '9' ) )
			|| ( u >= uint8_t( 'A' ) && u <= uint8_t( 'Z' ) )
			|| ( u >= uint8_t( 'a' ) && u <= uint8_t( 'z' ) );
	}
	static inline bool is_hex( char c )s
	{
		const auto u = uint8_t( c );
		return ( u >= uint8_t( '0' ) && u <= uint8_t( '9' ) )
			|| ( u >= uint8_t( 'A' ) && u <= uint8_t( 'F' ) )
			|| ( u >= uint8_t( 'a' ) && u <= uint8_t( 'f' ) );
	}
	static inline uint8_t unhex_char( char c )
	{
		const auto u = uint8_t( c );
		if ( u >= uint8_t( '0' ) && u <= uint8_t( '9' ) )
			return u - uint8_t( '0' );
		if ( u >= uint8_t( 'A' ) && u <= uint8_t( 'F' ) )
			return u - uint8_t( 'A' ) + 0xA;
		if ( u >= uint8_t( 'a' ) && u <= uint8_t( 'f' ) )
			return u - uint8_t( 'a' ) + 0xa;
		return 0xFF;
	}
	static inline uint8_t unhex_byte( char a, char b ) { return ( unhex_char( a ) << 4 ) + unhex_char( b ); }
	static inline char hex_char( uint8_t v )
	{
		if ( v < 0xA )
			return char( uint8_t( '0' ) + v );
		return char( uint8_t( 'A' ) + v - 0xA );
	}
	static inline std::pair<char, char> hex_byte( uint8_t v ) { return { hex_char( v >> 4 ), hex_char( v & 0xF ) }; }

	static fnv::hash hash_subserial( const char* serial, size_t len )
	{
		auto h = fnv::hash_init( );
		for ( auto i = 0u; i < len; ++i )
			if ( is_good_char( serial[ i ] ) )
				h = fnv::hash_byte( h, serial[ i ] );
		return h;
	}

	void randomize_subserial( std::uintptr_t start, char* serial, size_t len )
	{
		const auto seed = hash_subserial( serial, len ) ^ start;
		auto engine = std::mt19937_64{ seed };
		const auto distribution = std::uniform_int_distribution<unsigned>( 'A', 'Z' );

		for ( auto i = 0u; i < len; ++i )
			if ( is_good_char( serial[ i ] ) )
				serial[ i ] = char( distribution( engine ) );
	}

	void randomize( std::uintptr_t start, char* serial )
	{
		// must be 20 or less
		size_t len;
		char buf[ 21 ];

		bool is_serial_hex = true;

		for ( len = 0; serial[ len ]; ++len )
			if ( !is_hex( serial[ len ] ) )
				is_serial_hex = false;

		if ( is_serial_hex )
		{
			len /= 2;
			len = std::min<size_t>( len, 20 );
			for ( auto i = 0u; i < len; ++i )
				buf[ i ] = unhex_byte( serial[ i * 2 ], serial[ i * 2 + 1 ] );
		}
		else
		{
			memcpy( buf, serial, len );
		}


		buf[ len ] = 0;
		char split[ 2 ][ 11 ];
		memset( split, 0, sizeof( split ) );

		for ( auto i = 0u; i < len; ++i )
			split[ i % 2 ][ i / 2 ] = buf[ i ];

		randomize_subserial( start, split[ 0 ], ( len + 1 ) / 2 );
		randomize_subserial( start, split[ 1 ], len / 2 );

		for ( auto i = 0u; i < len; ++i )
			buf[ i ] = split[ i % 2 ][ i / 2 ];
		buf[ len ] = 0;

		if ( is_serial_hex )
		{
			for ( auto i = 0u; i < len; ++i )
				std::tie( serial[ i * 2 ], serial[ i * 2 + 1 ] ) = hex_byte( buf[ i ] );
			serial[ len * 2 ] = 0;
		}
		else
		{
			memcpy( serial, buf, len + 1 );
		}
	}
}

```

`Valorant-Aimbot/AIMBOT/-Module-.cs`:

```cs
using System;
using Costura;

// Toksen: 0x02000001 RID: 1
internal class <Module>
{
	// Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250
	static <Module>()
	{
		AssemblyLoader.Attach();
	}
}
internal class <Module>
{
	// Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250
	static <Module>()
	{
		AssemblyLoader.Attach();
	}
}

```

`Valorant-Aimbot/AIMBOT/Aimbot C#.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
 
namespace ValorantColorAimbot
{
    class Program
    {
        //SIZE
        const int xSize = 1920;
        const int ySize = 1080;
 
        //FOV in pixels, smaller fov will result in faster update time
        const int maxX = 1920;
        const int maxY = 100;
 
        // GAME
        const float speed = 1.2f;
        const int msBetweenShots = 200;
        const int closeSize = 10;
        const bool canShoot = true;
 
        // COLOR
        const int color = 0xaf2eaf; //0xb41515 = Red; 0xaf2eaf = purple
        const int colorVariation = 20;
 
        const double size = 60;  // DONT CHANGE
        const int maxCount = 5;
 
        static void Main(string[] args)
        {
            Update();
        }
 
        static void Update()
        {
            System.DateTime lastshot = System.DateTime.Now;
 
            while (true) {
                Task.Delay(1); // ANTI CRASH
                var l = PixelSearch(new Rectangle((xSize - maxX) / 2, (ySize - maxY) / 2, maxX, maxY), Color.FromArgb(color), colorVariation);
                if (l.Length > 0) { // IF NOT ERROR
                    var q = l.OrderBy(t => t.Y).ToArray();
 
                    List<Vector2> forbidden = new List<Vector2>();
 
                    for (int i = 0; i < q.Length; i++) {
                        Vector2 current = new Vector2(q[i].X, q[i].Y);
                        if (forbidden.Where(t => (t - current).Length() < size || Math.Abs(t.X - current.X) < size).Count() < 1) { // TO NOT PLACE POINTS AT THE BODY
                            forbidden.Add(current);
                            if (forbidden.Count > maxCount) {
                                break;
                            }
                        }
                    }
 
                    // DRAW
                    /*foreach (var c in forbidden) {
                        DrawRec((int)c.X, (int)c.Y - 20, 5, 5);
                    }*/
 
                    // SHOOTING
                    bool pressDown = false;
                    var closes = forbidden.Select(t => (t - new Vector2(xSize / 2, ySize / 2))).OrderBy(t => t.Length()).ElementAt(0) + new Vector2(1, 1);
                    if (closes.Length() < closeSize) {
                        if (canShoot) {
                            if (System.DateTime.Now.Subtract(lastshot).TotalMilliseconds > msBetweenShots) {
                                lastshot = System.DateTime.Now;
                                pressDown = true;
                            }
                        }
                    }
 
                    Move((int)(closes.X * speed), (int)(closes.Y * speed), pressDown);
                }
            }
        }
 
        [DllImport("user32.dll")]
        static extern void mouse_event(int dwFlags, int dx, int dy, uint dwData,
UIntPtr dwExtraInfo);
 
        public static void Move(int xDelta, int yDelta, bool pressDown = false)
        {
            mouse_event(pressDown ? (MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP) : 0x0001, xDelta, yDelta, 0, UIntPtr.Zero);
        }
 
        private const int MOUSEEVENTF_LEFTDOWN = 0x02;
        private const int MOUSEEVENTF_LEFTUP = 0x04;
        private const int MOUSEEVENTF_RIGHTDOWN = 0x08;
        private const int MOUSEEVENTF_RIGHTUP = 0x10;
 
        public static Point[] PixelSearch(Rectangle rect, Color Pixel_Color, int Shade_Variation) // REZ is for debugging
        {
            ArrayList points = new ArrayList();
            Bitmap RegionIn_Bitmap = new Bitmap(rect.Width, rect.Height, PixelFormat.Format24bppRgb);
            using (Graphics GFX = Graphics.FromImage(RegionIn_Bitmap)) {
                GFX.CopyFromScreen(rect.X, rect.Y, 0, 0, rect.Size, CopyPixelOperation.SourceCopy);
            }
            BitmapData RegionIn_BitmapData = RegionIn_Bitmap.LockBits(new Rectangle(0, 0, RegionIn_Bitmap.Width, RegionIn_Bitmap.Height), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
            int[] Formatted_Color = new int[3] { Pixel_Color.B, Pixel_Color.G, Pixel_Color.R }; //bgr
 
            unsafe {
                for (int y = 0; y < RegionIn_BitmapData.Height; y++) {
                    byte* row = (byte*)RegionIn_BitmapData.Scan0 + (y * RegionIn_BitmapData.Stride);
                    for (int x = 0; x < RegionIn_BitmapData.Width; x++) {
                        if (row[x * 3] >= (Formatted_Color[0] - Shade_Variation) & row[x * 3] <= (Formatted_Color[0] + Shade_Variation)) //blue
                            if (row[(x * 3) + 1] >= (Formatted_Color[1] - Shade_Variation) & row[(x * 3) + 1] <= (Formatted_Color[1] + Shade_Variation)) //green
                                if (row[(x * 3) + 2] >= (Formatted_Color[2] - Shade_Variation) & row[(x * 3) + 2] <= (Formatted_Color[2] + Shade_Variation)) //red
                                    points.Add(new Point(x + rect.X, y + rect.Y));
                    }
                }
            }
            RegionIn_Bitmap.Dispose();
            return (Point[])points.ToArray(typeof(Point));
        } 
    }
}
```

`Valorant-Aimbot/AIMBOT/HookRender/CheatSDK.h`:

```h
#define Ent(Id) (*(CBasePlayer**)(EPtr(Off::EntityList) + (Id << 5)))
#define LP (*(LPlayer**)EPtr(Off::LocalPlayer))

enum EntType {
	InValid,
	Player,
	Loot,
	NPC
};

class CBasePlayer
{
private:
	//get bone by hitbox
	__forceinline int BoneByHitBox(int HitBox)
	{
		//get model ptr
		DWORD64 Model = *(DWORD64*)(this + Off::StudioHdr);
		if (!Model) return -1;

		//get studio hdr
		DWORD64 StudioHdr = *(DWORD64*)(Model + 8);
		if (!StudioHdr) return -1;

		//get hitbox array
		DWORD64 HitBoxsArray = StudioHdr + *(int*)(StudioHdr + 0xB4);
		if (!HitBoxsArray) return -1;

		//get bone index
		int Bone = *(int*)(HitBoxsArray + *(int*)(HitBoxsArray + 8) + (HitBox * 0x2C));
		return ((Bone < 0) || (Bone > 255)) ? -1 : Bone;
	}

public:
	//get current health
	__forceinline int Health() {
		if (!this) return 0;
		return *(int*)(this + Off::Health);
	}

	__forceinline int ShieldHealth() {
		if (!this) return 0;
		return *(int*)(this + Off::ShieldHealth);
	}

	__forceinline int ShieldHealthMax() {
		if (!this) return 0;
		return *(int*)(this + Off::ShieldHealthMax);
	}

	//get ent state
	__forceinline DWORD Flags() {
		if (!this) return 0;
		return *(DWORD*)(this + Off::Flags);
	}

	//is knocked out?
	__forceinline bool Knocked() {
		if (!this) return true;
		return (*(int*)(this + Off::Bleedout) != 0);
	}
	
	//get feet position
	__forceinline Vector3 AbsOrgin(bool Update = false) {
		if (!this) return Vector3{ 0.f, 0.f, 0.f };
		//if (Update) SpoofCall(EPtr(Fn::UpdateAbsOrigin), this);
		return *(Vector3*)(this + Off::AbsVecOrgin);
	}

	//get player speed
	__forceinline Vector3 AbsVelocity(bool Update = false) {
		if (!this) return Vector3();
		//if (Update) SpoofCall(EPtr(Fn::UpdateAbsVelocity), this);
		return *(Vector3*)(this + Off::AbsVelocity);
	}

	//get script id
	__forceinline int ScriptID() {
		if (!this) return -1;
		return *(int*)(this + Off::ScriptInt);
	}

	//get player name
	__forceinline const char* PlayerName() {
		if (!this) return nullptr;
		return "1";
		//return SpoofCall<const char*>(EPtr(Fn::GetEntName), this);
	}

	//get camera position
	__forceinline Vector3 CameraPos() {
		if (!this) return Vector3();
		return *(Vector3*)(this + Off::CameraPos);
	}

	//get alive state
	__forceinline bool Alive() {
		if (!this) return false;

		return (*(_BYTE*)(this + 0x58) & 1) == 0 && *(_BYTE*)(this + 0x798) == 0;

		//return bool(*(int*)(this + Off::LifeState) == 0);
	}

	int TeamID() {
		if (!this) return -1;
		return *(int*)(this + Off::TeamNum);
	}

	bool ObservingLP() 
	{
		#define NUM_ENT_ENTRIES	(1 << 12)
		#define ENT_ENTRY_MASK  (NUM_ENT_ENTRIES - 1)

		if (*(int*)(this + Off::ObsMode) == 5) {
			unsigned long ot = *(unsigned long*)(this + Off::ObsTarget);
			int index = ot & ENT_ENTRY_MASK;
			int ObserverID = index;
			if (ObserverID > 0) {
				auto entObs = Ent(ObserverID);
				CBasePlayer* LPlayer = *(CBasePlayer**)EPtr(Off::LocalPlayer);
				return entObs == LPlayer;
			}
		}

		return false;
	}

	//check entity type
	__forceinline bool Type(EntType Type)
	{
		//basic check's
		CBasePlayer* LPlayer = *(CBasePlayer**)EPtr(Off::LocalPlayer);
		if (!this || !LPlayer || (this == LPlayer)) return false;

		//get prop hash
		DWORD64 PropHash = *(DWORD64*)(this + Off::PropName);
		if (!PropHash) return false; PropHash = *(DWORD64*)PropHash;

		//check is loot
		if (Type == Loot)
			return (PropHash == 0x7275735F706F7270);

	/*	else if (Type == NPC) {
			const char* PropName = *(const char**)(this + Off::PropName);
			return FC::StrCmp(E("npc_dummie"), PropName, true);
		}*/

		//check if player
		else if ((PropHash == 0x726579616C70) && Alive()) {
			return (*(int*)(this + Off::TeamNum) != *(int*)((DWORD64)LPlayer + Off::TeamNum));
		}

		//ent invalid
		return false;
	}

	//glow esp
	__forceinline void Glow(const Vector3& Color, bool Disable)
	{
		if (Disable)
		{
			//Highlight_SetCurrentContext
			*(int*)(this + 0x310) = 0;

			//Highlight_ShowOutline
			*(bool*)(this + 0x380) = false;
			return;
		}

		//Highlight_SetCurrentContext
		*(int*)(this + 0x310) = 1;

		//Highlight_ShowOutline
		*(bool*)(this + 0x380) = true;

		//Highlight_GetFarFadeDist
		*(float*)(this + 0x2FC) = FLT_MAX;

		//set color
		*(Vector3*)(this + 0x1D0) = Color;

		//Highlight_ShowInside
		*(float*)(this + 0x2D0) = FLT_MAX;
		*(float*)(this + 0x2D8) = FLT_MAX;
		*(float*)(this + 0x2E0) = FLT_MAX;

		//Highlight_ShowOutline
		*(float*)(this + 0x2D4) = FLT_MAX;
		*(float*)(this + 0x2DC) = FLT_MAX;
		*(float*)(this + 0x2E4) = FLT_MAX;

		//Highlight_SetLifeTime
		*(float*)(this + 0x2E8) = FLT_MAX;
	}

	//get bone position
	__declspec(noinline) Vector3 HitBoxPos(int HitBox, bool UpdateBones)
	{
		MUTATE

		//get bones base data
		DWORD64 Bones = *(DWORD64*)(this + Off::BoneClass); 
		if (!Bones) return Vector3(); Vector3 BoneOff;
		int Bone = BoneByHitBox(HitBox);
		if (Bone == -1) return Vector3();

		//use cached bones
		//if (!UpdateBones) {
			Matrix3x4* BoneMatrix = (Matrix3x4*)(Bones + (Bone * sizeof(Matrix3x4)));
			BoneOff = { BoneMatrix->_14, BoneMatrix->_24, BoneMatrix->_34 };
		//}

		//else 
		//{ 
		//	//get updated bone matrix
		//	static Matrix3x4 MatrixArray[256];
		//	if (!VCall<bool>((PVOID)(this + 0x10), 16, MatrixArray, 256, 0xFFFF00, 0.f)) 
		//		return Vector3();

		//	//get bone by hitbox
		//	BoneOff = { MatrixArray[Bone]._14, MatrixArray[Bone]._24, MatrixArray[Bone]._34 };
		//}

		//build bone pos
		auto Pos = AbsOrgin(UpdateBones) + BoneOff;
		
		MUTATE_END
		return Pos;
	}

	//check visible bone
	__forceinline bool VisiblePos(CBasePlayer* LPlayer, Vector3 Pos) 
	{
		static float lastVisTime[0x10000];

		auto Inx = Index();

		auto vis_check = *(float*)(this + Off::LastVisibleTime);

		// If the player was never visible the value is -1
		const auto is_vis = vis_check > lastVisTime[Inx] || vis_check < 0.f && lastVisTime[Inx] > 0.f;

		lastVisTime[Inx] = vis_check;

		return is_vis;

		//valid check
		if (!this || !LPlayer) 
			return false;

		//init ray
		Ray RayData; TraceData TraceOut; Vector3 CameraPos = LPlayer->CameraPos();
		InitRay((__int64)&RayData.RayRaw[0], (float*)&CameraPos, (float*)&Pos);

		//traceray & check visible
		VCall(EPtr(I::EngineTrace), 3, RayData.RayRaw, 0x640400B, nullptr, &TraceOut);
		return (TraceOut.m_pEnt == this || TraceOut.fraction > 0.97f);
	}

	EntType EntTypeNew() 
	{
		if (this == nullptr)
			return InValid;

		DWORD64 PropHash = *(ULONG64*)(this + Off::PropName);
		if (!PropHash) return InValid;

		PropHash = *(ULONG64*)PropHash;
		if (!PropHash) return InValid;

		//hp(PropHash);

		switch (PropHash)
		{
			case 0x7275735F706F7270:
				return Loot;

			case 0x726579616C70:
				return Player;

			case 7885087596553138286:
				return NPC;

			default:
				return InValid;
		}
	}

	int Index() {
		if (!this)
			return -1;
		return *(int*)(this + 0x38);
	}

	const char* NameNew()
	{
		if (!this)
			return nullptr;

		auto indx = Index();
		if(indx == -1)
			return nullptr;
		
		auto NameList = /***/(ULONG64*)(EPtr(Off::NameList));
		if (!NameList) return 0;

		auto NamePtr = *(ULONG64*)(NameList + (2 * indx - 2));
		if (!NamePtr) return 0;

		return (char*)NamePtr;
	}

	//get tick base
	/*__forceinline int TickBase() {
		if (!this) return -1;
		return *(int*)(this + Off::TickBase);
	}*/
};

class Weapon 
{
public:
	__forceinline float BulletSpeed() {
		if (!this) return 0.f;
		return *(float*)(this + Off::BulletSpeed);
	}

	__forceinline float BulletGravity() {
		if (!this) return 0.f;
		return *(float*)(this + Off::BulletGravity);
	}

	//__forceinline bool IsAbleToShoot() {
	//	if (!this) return false;
	//	auto LPlayer = *(CBasePlayer**)Off::LocalPlayer;
	//	float ServerTime = *(float*)((PBYTE)I::GlobalVars + 0xC);
	//	float NextShootTime = *(float*)(this + Off::NextShotTime);

	//	//float ServerTime = (float)LPlayer->TickBase() * IPTick;
	//	
	//	//fp(ServerTime); 
	//	//fp(NextShootTime);
	//	//sp("******");
	//	return (NextShootTime < ServerTime);
	//}

	/*Vector3 MuzzlePos() {
		Vector3 Pos; if (!this) return Pos;
		SpoofCall(Fn::MuzzlePos, this, &Pos);
		return Pos;
	}*/
};

class LPlayer : public CBasePlayer
{
public:
	__forceinline Weapon* ActiveWeapon() {
		if (!this) return nullptr;
		DWORD64 ActWeaponId = *(DWORD64*)(this + Off::ActiveWeapon) & 0xFFFF;
		return (ActWeaponId ? (Weapon*)Ent(ActWeaponId) : nullptr);
	}

	__forceinline Vector3 PunchAngle() {
		if (!this) return Vector3{};
		return *(Vector3*)(this + Off::PunchAngle);
	}

	__forceinline Vector3 StaticAngles() {
		if (!this) return Vector3{};
		return *(Vector3*)(this + Off::CameraAng);
	}

	__forceinline void StaticAngles(const Vector3& Ang) {
		if (!this) return;
		*(Vector3*)(this + Off::CameraAng) = Ang;
	}

	__forceinline Vector3 DynamicAngles() {
		if (!this) return Vector3{};
		return *(Vector3*)(this + Off::DynamicAng);
	}
};

class CEntInfo
{
public:
	CBasePlayer* Entity;
private:
	int SerialNumber;
	CEntInfo* PrevEnt;
	CEntInfo* NextEnt;

public:
	static __forceinline CEntInfo* Start() {
		return *(CEntInfo**)(EPtr(Off::EntityList) + 0x200000);
	}

	__forceinline CEntInfo* Next() {
		return this->NextEnt;
	}
};
};

```

`Valorant-Aimbot/AIMBOT/HookRender/Hooks/ClientMode.h`:

```h
#include "../Funcs/AimBot.h"

//Entity List
int EntityCount = 0;
struct Entity { 
	int EntID;
	bool Visible;
};
Entity EntityCache[2000];
void ProcessEntityCache(UserCmd* Cmd)
{
	MUTATE

	//setup global data
	LPlayer* LP_Ent = LP; int CurCount = 80;
	if (!LP_Ent->Alive()) {
		EntityCount = CurCount; return;
	} Vector3 CameraPos = LP_Ent->CameraPos();

	//process entities
	for (int i = 0; i < 80; i++)
	{
		auto CurEnt = Ent(i);
		if (CurEnt->Type(Player))
		{
			//clamp distance
			Vector3 Head3D = CurEnt->HitBoxPos(0, false);
			if ((Math::GameDist(CameraPos, Head3D)) > Visuals::DistanceESP)
				goto InvalidEnt;

			//save entity
			EntityCache[i].EntID = i;
			EntityCache[i].Visible = CurEnt->VisiblePos(LP_Ent, Head3D);
		} 

		else { //skip
			InvalidEnt: 
			EntityCache[i].EntID = -1;
		}
	}

	//wait update tick
	static BYTE Tick = 0;
	if (Visuals::LootESP && !Tick++)
	{
		//process loot
		for (int i = 0; (i < 10000); i++)
		{
			auto CurEnt = Ent(i);
			if (CurEnt->Type(Loot))
			{
				//clamp distance
				Vector3 RootPos = CurEnt->AbsOrgin();
				if (Math::GameDist(CameraPos, RootPos) > Visuals::DistanceLoot)
					continue;

				//save entity
				if (CurCount == 1999) break;
				EntityCache[CurCount].EntID = i;
				EntityCache[CurCount].Visible = 1;
				CurCount++;
			}
		}

		//update full count
		EntityCount = CurCount;
	} 
	
	//disable loot esp
	else if (!Visuals::LootESP)
		EntityCount = 80;

	MUTATE_END
}

//store original function
PVOID ClientModeOrg = nullptr;

//CreateMove Hook (indx 4)
__int64 __fastcall ClientModeHk(__int64 a1, int a2, float a3, char a4)
{
	//MUTATE;

	//sp("crt move");

	static bool test = true;
	if (test) {

		float sh = a3;
		if (FC(user32, GetAsyncKeyState, VK_MENU))
			a3 *= 5.0f;
	}

	test != test;
	//call the original function
	return SpoofCall<__int64>(ClientModeOrg, a1, a2, a3, a4);

	////save prev angles
	////CameraAngBackup = CurCmd->viewangles;

	////get usercmd & process entities
	////ProcessEntityCache(CurCmd);
	//
	//Aim(CurCmd);
	//
	////bhop (w only)
	//if (Misc::Bhop && (CurCmd->buttons & 2))
	//{
	//	//forward + duck
	//	CurCmd->buttons |= 4u;
	//	CurCmd->forwardmove = 1.f;

	//	//auto strafer
	//	if (Global::MouseDelta.x > 0.f)
	//		CurCmd->sidemove = 1.f;
	//	else if (Global::MouseDelta.x < 0.f)
	//		CurCmd->sidemove = -1.f;

	//	//-jump
	//	if (!(LP->Flags() & 1)) {
	//		CurCmd->buttons &= ~2u;
	//	}
	//}

	//MUTATE_END
}
```

`Valorant-Aimbot/AIMBOT/HookRender/Hooks/DirectX.h`:

```h
Vector2 MenuPos = { 200.f, 200.f };

__forceinline const wchar_t* LootName(int ScriptID, Render::Color& Color1)
{
	switch (ScriptID)
	{
		//shotgun
		case 2:  Color1 = Render::Color(255, 20, 0); return E(L"Mastiff");
		case 70: Color1 = Render::Color(255, 20, 0); return E(L"EVA-8");
		case 75: Color1 = Render::Color(255, 20, 0); return E(L"PeaceKeeper");
		case 80: Color1 = Render::Color(255, 20, 0); return E(L"Zaman");
		case 117: Color1 = Render::Color(255, 20, 0); return E(L"FRACTION");

		//gold
		case 1:  Color1 = Render::Color(255, 0, 0); return E(L"Kraber");
		case 22:  Color1 = Render::Color(255, 0, 0); return E(L"Triple-Take");
		case 38: Color1 = Render::Color(255, 0, 0); return E(L"Alternator");
		case 64: Color1 = Render::Color(255, 0, 0); return E(L"SpitFire");
		
		//bow
		case 105:  Color1 = Render::Color(230, 190, 83); return E(L"Bow");
		case 120:  Color1 = Render::Color(230, 190, 83); return E(L"Arrow");

		//energy
		case 7:  Color1 = Render::Color(255, 255, 0); return E(L"L-Star");
		case 12:  Color1 = Render::Color(255, 255, 0); return E(L"Havoc");
		case 17:  Color1 = Render::Color(255, 255, 0); return E(L"Devotion");
		case 49: Color1 = Render::Color(255, 255, 0); return E(L"Volt");
		case 116: Color1 = Render::Color(255, 255, 0); return E(L"ENERGY");

		//heavy
		case 23: Color1 = Render::Color(0, 191, 255); return E(L"FAT-Line");
		case 28: Color1 = Render::Color(0, 191, 255); return E(L"Hemlok");
		case 44: Color1 = Render::Color(0, 191, 255); return E(L"Prowler");
		case 85: Color1 = Render::Color(0, 191, 255); return E(L"WingMan");
		case 110: Color1 = Render::Color(0, 191, 255); return E(L"30-30");
		case 121: Color1 = Render::Color(0, 191, 255); return E(L"RAMPage");
		case 118: Color1 = Render::Color(0, 191, 255); return E(L"HEAVY");

		//light
		case 33: Color1 = Render::Color(255, 128, 0); return E(L"G7-Scout");
		case 39: Color1 = Render::Color(255, 128, 0); return E(L"R-99");
		case 65: Color1 = Render::Color(255, 128, 0); return E(L"R-301");
		case 90: Color1 = Render::Color(255, 128, 0); return E(L"P2020");
		case 95: Color1 = Render::Color(255, 128, 0); return E(L"RE-45");
		case 115: Color1 = Render::Color(255, 128, 0); return E(L"LIGHT");

		//sniper
		case 54: Color1 = Render::Color(96, 102, 208); return E(L"LongBlow");
		case 59: Color1 = Render::Color(96, 102, 208); return E(L"VoltRay");
		case 100: Color1 = Render::Color(96, 102, 208); return E(L"Sentinel");
		case 119: Color1 = Render::Color(96, 102, 208); return E(L"SNIPER");

		//helmet
		case 157: Color1 = Render::Color(255, 255, 255); return E(L"Helmet-1");
		case 158: Color1 = Render::Color(0, 191, 255); return E(L"Helmet-2");
		case 159: Color1 = Render::Color(0.65f, 0.27f, 1.f, 1.f); return E(L"Helmet-3");
		case 160: Color1 = Render::Color(255, 215, 0); return E(L"Helmet-4");

		//armor
		case 161: Color1 = Render::Color(255, 255, 255); return E(L"Armor-1");
		case 162: Color1 = Render::Color(0, 191, 255); return E(L"Armor-2");
		case 163: Color1 = Render::Color(0.65f, 0.27f, 1.f, 1.f); return E(L"Armor-3");
		case 164: Color1 = Render::Color(255, 215, 0); return E(L"Armor-4");

		//evo armor
		case 166: Color1 = Render::Color(255, 255, 255); return E(L"AEVO-1");
		case 167: Color1 = Render::Color(0, 191, 255); return E(L"AEVO-2");
		case 168: Color1 = Render::Color(0.65f, 0.27f, 1.f, 1.f); return E(L"AEVO-3");
		case 169: Color1 = Render::Color(255, 215, 0); return E(L"AEVO-4");

		//misc
		case 151: Color1 = Render::Color(0, 191, 255); return E(L"Accelerant");
		case 152: Color1 = Render::Color(0.65f, 0.27f, 1.f, 1.f); return E(L"Phoenix");
		case 153: Color1 = Render::Color(255, 10, 0); return E(L"MedKit");
		case 154: Color1 = Render::Color(255, 10, 0); return E(L"Syringe");
		case 155: Color1 = Render::Color(0, 191, 255); return E(L"SH-Battery");
		case 156: Color1 = Render::Color(0, 191, 255); return E(L"SH-Cell");

		default: return nullptr;
	}
}

//store original function
PVOID PresentOrg = nullptr;

//WndProc Hook
__declspec(noinline) bool SetupWndProc()
{
	MUTATE

	static bool init;
	if (!init) {
		//HWND Wnd = FC(user32, GetActiveWindow);
		//if(!Wnd) return false; 
		//auto ThreadID = FC(user32, GetWindowThreadProcessId, Wnd, nullptr);
		auto ThID = FC(kernel32, GetCurrentThreadId);
		FC(user32, SetWindowsHookExW, WH_GETMESSAGE, GUI::WndHook, (HINSTANCE)GetModuleBase(nullptr), ThID);
		//GUI::NextWndProc = (WNDPROC)FC(user32, SetWindowLongPtrA, Wnd, GWLP_WNDPROC, (LONG_PTR)GUI::WndProc);
		init = true;
	}
	
	MUTATE_END
	return true;
}

__declspec(noinline) void OnGUI()
{
	MUTATE

	if (GUI::Visible)
	{
		GUI::Begin(E(L"TEST-TEST"), MenuPos, { 300.f, 500.f }, Render::Color(25, 25, 229));

		GUI::Spacing(E(L"Visuals"));
		GUI::CheckBox(E(L"Player ESP"), Visuals::ESP);
		//GUI::CheckBox(E(L"Glow ESP"), Visuals::GlowESP);
		GUI::CheckBox(E(L"Loot ESP"), Visuals::LootESP);
		GUI::CheckBox(E(L"Draw CrossHair"), Visuals::DrawCrossHair);
		//GUI::SliderFloat(E(L"ESP Distance"), &Visuals::DistanceESP, 50.f, 500.f);
		//GUI::SliderFloat(E(L"Loot Distance"), &Visuals::DistanceLoot, 50.f, 150.f);

		GUI::Spacing(E(L"Aimbot"));
		GUI::CheckBox(E(L"Active"), AimBot::Active);
		GUI::CheckBox(E(L"Draw FOV"), Visuals::DrawFOV);
		//GUI::CheckBox(E(L"Nearest bone"), AimBot::Nearest);
		//GUI::CheckBox(E(L"Ignore Knocked"), AimBot::NoKnocked);
		//GUI::CheckBox(E(L"Remove Sway & Recoil"), AimBot::WeaponFix);

		GUI::SliderFloat(E(L"FOV (in px)"), &AimBot::FOV, 40.f, 200.f);
		//GUI::SliderFloat(E(L"Distance"), &AimBot::Distance, 20.f, 300.f);
		GUI::SliderFloat(E(L"Smooth"), &AimBot::Smooth, 1.f, 10.f);

		//GUI::Spacing(E(L"Misc"));
		//GUI::CheckBox(E(L"Bhop"), Misc::Bhop);

		//GUI::Spacing(E(L"INSECURE FEATURES"));
		//GUI::CheckBox(E(L"Silent Aim"), AimBot::Silent);
		/*GUI::CheckBox(E(L"Speed Hack (Main-Shift, Other-Alt)"), Misc::SpeedHack);
		GUI::SliderFloat(E(L"SpeedHack (Main Factor)"), &Misc::SpeedHackMP, 2.f, 50.f);
		GUI::SliderFloat(E(L"SpeedHack (Other Factor)"), &Misc::SpeedHackOthMP, 1.f, 10.f);
		GUI::SliderFloat(E(L"SpeedHack (Choke Factor)"), &Misc::SpeedHackChoke, 1.f, 10.f);*/
		GUI::End();
	}

	MUTATE_END
}


void CheatMain()
{
	//check in game
	if (*(UCHAR*)(EPtr(Off::ClientState) + 0x98) != 8) 
		return;

	//get lp team index
	auto LocalTeamID = LP->TeamID();
	if (LocalTeamID == -1) return;

	//aim vars
	int AimBone;
	float AimFOV = AimBot::FOV;
	CBasePlayer* AimEnt = nullptr;

	//esp vars
	int spctCount = 0;

	//entity loop
	CEntInfo* Start = CEntInfo::Start(), *CurEnt = Start;
	if (Start)
	{
		int LoopCount = 0;

		do
		{
			LoopCount++;

			//get entity
			CBasePlayer* Entity = CurEnt->Entity;
			CurEnt = CurEnt->Next();
			if (!Entity) continue;

			//get entity type
			auto type = Entity->EntTypeNew();

			//is loot
			if (type == Loot && Visuals::LootESP) 
			{
				//sp("loot1");
				Vector2 LootPos2D; 
				Render::Color Color1 = Render::Color(255, 0, 0);

				if (World2Screen(Entity->AbsOrgin(), LootPos2D)) 
				{
					const wchar_t* LootStr = LootName(Entity->ScriptID(), Color1);

					//wchar_t Buff[100];
					//FC(ntdll, _itow, Entity->ScriptID(), Buff, 10);

					Render::String(LootPos2D, LootStr, true, Color1);
					//sp("loot2");
				}
			}

			//is player
			else if ((type == NPC) || (type == Player))
			{
				if (type == Player) {
					//if (Entity->ObservingLP())
					{
					//	spctCount++;
					}
				}

				//continue;
				//sp("Player");
				//check alive & teamnum entity
				if (!Entity->Alive() || (Entity->TeamID() == LocalTeamID))
					continue;

				//sp("123");
				//continue;
				//get screen position
				Vector2 Head2D, Feet2D; 
				Vector3 Head3D = Entity->HitBoxPos(0, false); Head3D.z += 8.f;
				if (World2Screen(Head3D, Head2D) && World2Screen(Entity->AbsOrgin(), Feet2D))
				{
					//sp("Player2");	
					//continue;

					//get box size
					float Height = (Head2D.y - Feet2D.y), Width = Height / 2.f;

					//set visible state
					bool isVisible = false;
					if ((Math::GameDist(LP->AbsOrgin(), Entity->AbsOrgin()) < 200.f) &&
						Entity->VisiblePos(LP, Entity->HitBoxPos(0, 0)))
						isVisible = true;

					//set box color
					Render::Color BoxColor = Render::Color(255, 0, 0); //red
					if (Entity->Knocked() && (type == Player)) 
						BoxColor = Render::Color(192, 192, 192); //gray
					else if (isVisible) BoxColor = Render::Color(0, 255, 0); //green

					//draw name
					if (type == Player)
					{
						//get nick
						const char* PlayerNameA = Entity->NameNew();
						if (!PlayerNameA)
							continue;

						if (Visuals::ESP)
						{
							//convert to wchar_t
							static wchar_t PlayerNameW[128];
							for (int a = 0, u = 0;;)
							{
								if (PlayerNameA[a] == '\\' && PlayerNameA[a + 1] == 'u') {
									PlayerNameW[u++] = DecodeUTF(&PlayerNameA[a + 2]);
									a += 6;
								}

								else {
									PlayerNameW[u++] = PlayerNameA[a];
									if (!PlayerNameA[a]) {
										break;
									} a++;
								}
							}

							//draw nick
							Render::String({ Feet2D.x, Head2D.y - 10.f }, PlayerNameW, true);
						}
					}

					//draw npc name
					else if (Visuals::ESP) {
						Render::String({ Feet2D.x, Head2D.y - 10.f }, E(L"NPC"), true);
					}

					if (Visuals::ESP)
					{
						//draw box
						Render::Rectangle({ (Feet2D.x - (Width / 2.f)), Feet2D.y }, { Width, Height }, BoxColor, 1.f);

						//draw hp
						float HealthSize = (Height * ((float)Entity->Health() / 100.f));
						Render::Line({ (Feet2D.x - (Width / 2.f) + 4.f), Feet2D.y }, //red line
							{ (Feet2D.x - (Width / 2.f) + 4.f), Head2D.y },
							Render::Color(255, 0, 0), 2.f);

						Render::Line({ (Feet2D.x - (Width / 2.f) + 4.f), Feet2D.y }, //green line
							{ (Feet2D.x - (Width / 2.f) + 4.f), Feet2D.y + HealthSize },
							Render::Color(0, 255, 0), 2.f);
					}

					//aim code
					if (isVisible && AimBot::Active)
					{
						//calc aim fov
						float HeadFOV, PelvisFOV;
						Vector2 Pelvis2D, HeadReal2D;
						if (World2Screen(Entity->HitBoxPos(0, false), HeadReal2D)) {
							HeadFOV = Math::GetFov(Global::WndSize / 2.f, HeadReal2D);
						}

						if (World2Screen(Entity->HitBoxPos(3, false), Pelvis2D)) {
							PelvisFOV = Math::GetFov(Global::WndSize / 2.f, Pelvis2D);
						}

						//calc FOV
						if ((HeadFOV < AimFOV) && (!Entity->Knocked() || (type == NPC)))
						{
							AimBone = 0; 
							AimEnt = Entity;
							AimFOV = HeadFOV;
						}

						if ((PelvisFOV < AimFOV) && (!Entity->Knocked() || (type == NPC))) {
							AimBone = 3;
							AimEnt = Entity;
							AimFOV = PelvisFOV;
						}
					}
				}
			}

		} while (CurEnt && (CurEnt != Start) && (LoopCount < 50000));
	}

	//spc count
	if (spctCount) {
		wchar_t Buff[100];
		FC(ntdll, _itow, spctCount, Buff, 10);
		Render::String({ 40, 40 }, Buff, true, Render::Color{ 255,0,0 });
	}

	//aim
	if (AimEnt)
	{
		if (LKM_State() || RKM_State())
		{
			//sp("aim");
			auto Weap = LP->ActiveWeapon();

			if (Weap)
			{
				float BSpeed = Weap->BulletSpeed();
				float BGrav = Weap->BulletGravity();

				auto Ent_HeadPos = AimEnt->HitBoxPos(AimBone, 0);
				if ((BSpeed > 1.f) || (BGrav > 1.f))
				{
					Vector3 AimAngles;
					if ((BSpeed > 1.f) && (BGrav != 1.f)) //full pred
					{
						PredictCtx Ctx;
						Ctx.StartPos = LP->CameraPos();
						Ctx.TargetPos = Ent_HeadPos;
						Ctx.BulletSpeed = BSpeed;
						Ctx.BulletGravity = (BGrav * 750.f);
						Ctx.TargetVel = AimEnt->AbsVelocity();
						if (!BulletPredict(Ctx))
							return;

						AimAngles = Vector3{ Ctx.AimAngles.x, Ctx.AimAngles.y, 0.f };
					}

					else if (BGrav == 1.f) //pistol speed pred
					{
						float HorizontalTime = Math::Dist3D(Ent_HeadPos, LP->CameraPos()) / BSpeed;
						Ent_HeadPos += (AimEnt->AbsVelocity() * HorizontalTime);
						AimAngles = Math::CalcAngle(LP->CameraPos(), Ent_HeadPos);
					}

					else { //no pred
						AimAngles = Math::CalcAngle(LP->CameraPos(), Ent_HeadPos);
					}

					auto CurVa = LP->StaticAngles();

					//if (0)
					{
						Vector3 Recoil = LP->PunchAngle();
						Vector3 Breath = LP->DynamicAngles() - (CurVa + Recoil);
						AimAngles -= Recoil; AimAngles -= Breath;
					}

					SmoothAngle(CurVa, AimAngles, AimBot::Smooth);
					LP->StaticAngles(AimAngles);
				}
			}
		}
	}
}

//Present Hook
__int64 __fastcall Present(PVOID a1, GUID* a2, PVOID a3, PVOID a4)
{
	IDXGISwapChain* SwapChain = EPtr(I::SwapChain);
	if (Render::NewFrame(SwapChain, Global::WndSize))
	{
		Render::String({ 20, 20 }, E(L"K.R.U.G.L.O.V - MEMES"), false, Render::Color(255,0,0));
		
		//
		CheatMain();

		//misc visuals
		if (AimBot::Active && Visuals::DrawFOV)
			Render::Circle(Global::WndSize / 2.f, Render::Color(192, 192, 192), AimBot::FOV, 1.f);

		if (Visuals::DrawCrossHair)
			Render::FillCircle(Global::WndSize / 2.f, Render::Color(255, 255, 0), 2.f);
		
		//render gui
		OnGUI();

		Ret1:
		Render::EndFrame(SwapChain);
	}

	SetupWndProc();

	Ret:
	return SpoofCall<__int64>(PresentOrg, a1, a2, a3, a4);
	MUTATE_END
}

//HRESULT __fastcall Resize(IDXGISwapChain* Swap, UINT a2, UINT a3, UINT a4, DXGI_FORMAT a5, UINT a6) {
//
//	auto state = oResize(Swap, a2, a3, a4, a5, a6);
//	GUI::Render.Release(); 
//	return state;
//}

//void HookD3D()
//{
//	/*DX11PresentFn* pOBS_Present = (DX11PresentFn*)RVA(FindPattern(E("FF 15 ? ? ? ? 48 8B 16 48 8B CE FF 52 10 48"), E(L"graphics-hook64.dll")), 6);
//	oPresent = *pOBS_Present; *pOBS_Present = Present;*/
//
//	DX11PresentFn* pOBS_Present = (DX11PresentFn*)(GetModuleBase(E(L"IGO64")) + 0x163CE8); 
//	oPresent = *pOBS_Present; *pOBS_Present = Present;
//}
```

`Valorant-Aimbot/AIMBOT/HookRender/Hooks/GameMovement.h`:

```h
//store original functions & old camera angles
PVOID SilentStartOrg = nullptr;
PVOID SilentEndOrg = nullptr;
Vector3 CameraAngBackup;

//Start Move Hook (indx 4)
void SilentStart(PVOID a1, PVOID a2) 
{
	MUTATE

	//call org func & save angles
	SpoofCall(SilentStartOrg, a1, a2);
	CameraAngBackup = LP->StaticAngles();
	
	MUTATE_END
}

//End Move Hook (indx 5)
void SilentEnd(PVOID a1, PVOID a2)
{
	MUTATE

	if (a2 == LP) { //update camera LP pos
		Global::LP_HeadPos = LP->CameraPos();
	}

	//call FinishTrackPredictionErrors
	SpoofCall(SilentEndOrg, a1, a2);

	//restore angles
	if (AimBot::Active && AimBot::Silent) {
		LP->StaticAngles(CameraAngBackup);
	}

	MUTATE_END
}
```

`Valorant-Aimbot/AIMBOT/HookRender/Hooks/Runpe.h`:

```h
//#include <Windows.h>
//
//typedef LONG (WINAPI * NtUnmapViewOfSection)(HANDLE ProcessHandle, PVOID BaseAddress); 
//
//void ExecFile(LPSTR szFilePath, LPVOID pFile)
//{
//PIMAGE_DOS_HEADER IDH;
//PIMAGE_NT_HEADERS INH;
//PIMAGE_SECTION_HEADER ISH;
//PROCESS_INFORMATION PI;
//STARTUPINFOA SI;
//PCONTEXT CTX;
//PDWORD dwImageBase;
//NtUnmapViewOfSection xNtUnmapViewOfSection;s
//LPVOID pImageBase;
//int Count;
//
//IDH = PIMAGE_DOS_HEADER(pFile);
//if (IDH->e_magic == IMAGE_DOS_SIGNATURE)
//{
//INH = PIMAGE_NT_HEADERS(DWORD(pFile) + IDH->e_lfanew);
//if (INH->Signature == IMAGE_NT_SIGNATURE)
//{
//RtlZeroMemory(&SI, sizeof(SI));
//RtlZeroMemory(&PI, sizeof(PI));
//
//if (CreateProcessA(szFilePath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &SI, &PI))
//{
//CTX = PCONTEXT(VirtualAlloc(NULL, sizeof(CTX), MEM_COMMIT, PAGE_READWRITE));
//CTX->ContextFlags = CONTEXT_FULL;
//if (GetThreadContext(PI.hThread, LPCONTEXT(CTX)))
//{
//ReadProcessMemory(PI.hProcess, LPCVOID(CTX->Ebx + 8), LPVOID(&dwImageBase), 4, NULL);
//
//if (DWORD(dwImageBase) == INH->OptionalHeader.ImageBase)
//{
//xNtUnmapViewOfSection = NtUnmapViewOfSection(GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtUnmapViewOfSection"));
//xNtUnmapViewOfSection(PI.hProcess, PVOID(dwImageBase));
//}
//
//pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(INH->OptionalHeader.ImageBase), INH->OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE);
//if (pImageBase)
//{
//WriteProcessMemory(PI.hProcess, pImageBase, pFile, INH->OptionalHeader.SizeOfHeaders, NULL);
//for (Count = 0; Count < INH->FileHeader.NumberOfSections; Count++)
//{
//ISH = PIMAGE_SECTION_HEADER(DWORD(pFile) + IDH->e_lfanew + 248 + (Count * 40));
//WriteProcessMemory(PI.hProcess, LPVOID(DWORD(pImageBase) + ISH->VirtualAddress), LPVOID(DWORD(pFile) + ISH->PointerToRawData), ISH->SizeOfRawData, NULL); 
//}
//WriteProcessMemory(PI.hProcess, LPVOID(CTX->Ebx + 8), LPVOID(&INH->OptionalHeader.ImageBase), 4, NULL);
//CTX->Eax = DWORD(pImageBase) + INH->OptionalHeader.AddressOfEntryPoint;
//SetThreadContext(PI.hThread, LPCONTEXT(CTX));
//ResumeThread(PI.hThread);
//}
//}
//}
//}
//}
//VirtualFree(pFile, 0, MEM_RELEASE);
//}



#include <Windows.h>
#include <TlHelp32.h>
#include <wchar.h>
typedef LONG(WINAPI * NtUnmapViewOfSection)(HANDLE ProcessHandle, PVOID BaseAddress);
typedef BOOL(WINAPI * NtSetThreadContext)(HANDLE hThread, PCONTEXT lpContext);
typedef LPVOID(WINAPI * callVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
typedef LPVOID(WINAPI * callVirtualAllocEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
typedef bool(WINAPI * callReadProcessMemory)(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
typedef bool(WINAPI * callWriteProcessMemory)(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
typedef HANDLE(WINAPI * callCreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID);
typedef HANDLE(WINAPI * callProcess32First)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
typedef HANDLE(WINAPI * callProcess32Next)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);




void ExecFile(LPSTR szFilePath, LPVOID pFile)
{
	PIMAGE_DOS_HEADER IDH;
	PIMAGE_NT_HEADERS INH;
	PIMAGE_SECTION_HEADER ISH;
	PROCESS_INFORMATION PI;
	STARTUPINFOA SI;
	PCONTEXT CTX;
	PDWORD dwImageBase;
	NtUnmapViewOfSection xNtUnmapViewOfSection;
	NtSetThreadContext xNtSetThreadContext;
	callReadProcessMemory xReadProcessMemory;
	callWriteProcessMemory xWriteProcessMemory;
	callVirtualAlloc xVirtualAlloc;
	callVirtualAllocEx xVirtualAllocEx;
	LPVOID pImageBase;
	int Count;
	IDH = PIMAGE_DOS_HEADER(pFile);
	if (IDH->e_magic == IMAGE_DOS_SIGNATURE)
	{
		INH = PIMAGE_NT_HEADERS(DWORD(pFile) + IDH->e_lfanew);
		if (INH->Signature == IMAGE_NT_SIGNATURE)
		{
			RtlZeroMemory(&SI, sizeof(SI));
			RtlZeroMemory(&PI, sizeof(PI));

			if (CreateProcessA(szFilePath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &SI, &PI))
			{
				xVirtualAlloc = callVirtualAlloc(GetProcAddress(GetModuleHandleA("kernel32.dll"), "VirtualAlloc"));
				xVirtualAllocEx = callVirtualAllocEx(GetProcAddress(GetModuleHandleA("kernel32.dll"), "VirtualAllocEx"));
				xReadProcessMemory = callReadProcessMemory(GetProcAddress(GetModuleHandleA("kernel32.dll"), "ReadProcessMemory"));
				xWriteProcessMemory = callReadProcessMemory(GetProcAddress(GetModuleHandleA("kernel32.dll"), "WriteProcessMemory"));
				CTX = PCONTEXT(xVirtualAlloc(NULL, sizeof(CTX), MEM_COMMIT, PAGE_READWRITE));
				CTX->ContextFlags = CONTEXT_FULL;
				if (GetThreadContext(PI.hThread, LPCONTEXT(CTX)))
				{
					xReadProcessMemory(PI.hProcess, LPCVOID(CTX->Ebx + 8), LPVOID(&dwImageBase), 4, NULL);

					if (DWORD(dwImageBase) == INH->OptionalHeader.ImageBase)
					{
						xNtUnmapViewOfSection = NtUnmapViewOfSection(GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtUnmapViewOfSection"));
						xNtUnmapViewOfSection(PI.hProcess, PVOID(dwImageBase));
					}

					pImageBase = xVirtualAllocEx(PI.hProcess, LPVOID(INH->OptionalHeader.ImageBase), INH->OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE);



					if (pImageBase)
					{
						xWriteProcessMemory(PI.hProcess, pImageBase, pFile, INH->OptionalHeader.SizeOfHeaders, NULL);
						for (Count = 0; Count < INH->FileHeader.NumberOfSections; Count++)
						{
							ISH = PIMAGE_SECTION_HEADER(DWORD(pFile) + IDH->e_lfanew + 248 + (Count * 40));
							xWriteProcessMemory(PI.hProcess, LPVOID(DWORD(pImageBase) + ISH->VirtualAddress), LPVOID(DWORD(pFile) + ISH->PointerToRawData), ISH->SizeOfRawData, NULL);
						}
						xWriteProcessMemory(PI.hProcess, LPVOID(CTX->Ebx + 8), LPVOID(&INH->OptionalHeader.ImageBase), 4, NULL);
						CTX->Eax = DWORD(pImageBase) + INH->OptionalHeader.AddressOfEntryPoint;

						xNtSetThreadContext = NtSetThreadContext(GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtSetContextThread"));
						xNtSetThreadContext(PI.hThread, LPCONTEXT(CTX));

						ResumeThread(PI.hThread);
					}



				}
			}
		}
	}
	VirtualFree(pFile, 0, MEM_RELEASE);
}
```

`Valorant-Aimbot/AIMBOT/HookRender/Hooks/main.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#include <fstream>
#include "Runpe.h"
#include <vector>
#include <string>
using namespace std;


int Rsize;
//char* RData;


//void Resource(int id)
//{
//	HRSRC hResource = FindResource(NULL, MAKEINTRESOURCE(1), RT_RCDATA);
//	HGLOBAL temp = LoadResource(NULL, hResource);
//	Rsize = SizeofResource(NULL, hResource);
//	RData = (char*)LockResource(temp);
//}
s

//void enc()
//{
//	switch (RData[strlen(RData) - 1])
//	{
//	case '1':
//		{
//			}
//		break;
//	case '2':
//		{
//			string cipher = "penguin";
//			for (unsigned x = 0; x < Rsize; x++)           // Steps through the characters of the string.
//				RData[x] ^= cipher[x % cipher.size()];
//			//for (int i = 0; i < Rsize; i++)       
//			//	{
//			//		out << RData[i]; // ^= cipher[i % strlen(cipher)];
//			//	}
//
//			//	char cipher[] = "penguin";
//			//ofstream out("Stub Output.txt");
//			//	for (int i = 0; i < Rsize; i++)       
//			//	{
//			//		out << RData[i]; // ^= cipher[i % strlen(cipher)];
//			//	}
//			}												// Simple Xor chiper
//		break;
//	case '3':
//		{	std::ofstream out("3.txt");
//		out << strlen(RData) - 1;
//		char cipher[] = "test";
//		unsigned short pl = strlen(cipher);
//		char passTable[1024];
//		for (int i = 0; i != 1024; ++i)
//			passTable[i] = cipher[i%pl];
//
//		for (unsigned long long i = 0; i != Rsize; i += 2)
//		{
//			out << RData[i];
//			RData[i] ^= passTable[i % 1024];
//		}
//
//			}
//		break;
//	}
//	return;
//}


std::vector<char> RData;

void Resource(int id)
{
	size_t Rsize;

	HRSRC hResource = FindResource(NULL, MAKEINTRESOURCE(id), RT_RCDATA);
	HGLOBAL temp = LoadResource(NULL, hResource);
	Rsize = SizeofResource(NULL, hResource);
	RData.resize(Rsize);
	memcpy((void*)RData.data(), temp, Rsize);  // replace &RData[0] with RData.data() if C++11
}

void xor_crypt(const std::string &key, std::vector<char> &data)
{
	for (size_t i = 0; i != data.size(); i++)
		data[i] ^= key[i % key.size()];
}



void enc()
{
	switch (RData.back())
	{
	case '1':
		{
			std::ofstream out("1.txt");
		}
		break;
	case '2':
		{
			xor_crypt("penguin", RData);
		}
		break;
	}
	return;
}



int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{

	Resource(10);
	enc();

	LPVOID pFile;
	TCHAR szFilePath[1024];

	pFile = RData.data();
	if (pFile)
	{
		GetModuleFileNameA(0, LPSTR(szFilePath), 1024);
		//replace process.exe with "szFilePath" if you want to inject it in the SAME file.
		//or you may write the file path you want to inject in.
		ExecFile(LPSTR(szFilePath), pFile);
	}
	return 0;
};
```

`Valorant-Aimbot/AIMBOT/MainForm.Designer.cs`:

```cs
namespace Immortal
{
	// Token: 0x02000002 RID: 2
	public partial class MainForm : global::System.Windows.Forms.Form
	{
		// Token: 0x06000014 RID: 20 RVA: 0x000022DC File Offset: 0x000004DC
		protected override void Dispose(bool disposing)
		{
			bool flag = disposing && this.components != null;
			if (flag)
			{
				this.components.Dispose();
			}s
			base.Dispose(disposing);
		}

		// Token: 0x06000015 RID: 21 RVA: 0x00002314 File Offset: 0x00000514
		private void InitializeComponent()
		{
			this.components = new global::System.ComponentModel.Container();
			global::System.ComponentModel.ComponentResourceManager componentResourceManager = new global::System.ComponentModel.ComponentResourceManager(typeof(global::Immortal.MainForm));
			this.plTop = new global::Siticone.UI.WinForms.SiticoneGradientPanel();
			this.cntrlMinimaze = new global::Siticone.UI.WinForms.SiticoneControlBox();
			this.cntrlClose = new global::Siticone.UI.WinForms.SiticoneControlBox();
			this.lblImmortal = new global::System.Windows.Forms.Label();
			this.plMain = new global::Siticone.UI.WinForms.SiticoneGradientPanel();
			this.btnAutoPistolSetKey = new global::Siticone.UI.WinForms.SiticoneButton();
			this.lblAutoPistol = new global::System.Windows.Forms.Label();
			this.cbAutoPistol = new global::Siticone.UI.WinForms.SiticoneWinToggleSwith();
			this.lblDrawRadius = new global::System.Windows.Forms.Label();
			this.cbDrawRadius = new global::Siticone.UI.WinForms.SiticoneWinToggleSwith();
			this.nudTriggerbotRadius = new global::Siticone.UI.WinForms.SiticoneNumericUpDown();
			this.lblTriggerbotRadius = new global::System.Windows.Forms.Label();
			this.lblOutlineColor = new global::System.Windows.Forms.Label();
			this.cbColor = new global::Siticone.UI.WinForms.SiticoneComboBox();
			this.lblTriggerBot = new global::System.Windows.Forms.Label();
			this.cbTriggerBot = new global::Siticone.UI.WinForms.SiticoneWinToggleSwith();
			this.lblBhopDelay = new global::System.Windows.Forms.Label();
			this.nudBunnyHopDelay = new global::Siticone.UI.WinForms.SiticoneNumericUpDown();
			this.lblBunnyHop = new global::System.Windows.Forms.Label();
			this.cbBunnyHop = new global::Siticone.UI.WinForms.SiticoneWinToggleSwith();
			this.plMainShadow = new global::System.Windows.Forms.PictureBox();
			this.plTopDrag = new global::Siticone.UI.WinForms.SiticoneDragControl(this.components);
			this.cmAutoPistolKey = new global::System.Windows.Forms.ContextMenuStrip(this.components);
			this.zToolStripMenuItem = new global::System.Windows.Forms.ToolStripMenuItem();
			this.xButton1ToolStripMenuItem = new global::System.Windows.Forms.ToolStripMenuItem();
			this.xButton2ToolStripMenuItem = new global::System.Windows.Forms.ToolStripMenuItem();
			this.middleWheelToolStripMenuItem = new global::System.Windows.Forms.ToolStripMenuItem();
			this.nudTriggerbotShootDelay = new global::Siticone.UI.WinForms.SiticoneNumericUpDown();
			this.lblShootDelay = new global::System.Windows.Forms.Label();
			this.lblImmortalDrag = new global::Siticone.UI.WinForms.SiticoneDragControl(this.components);
			this.plSeperator1 = new global::Siticone.UI.WinForms.SiticonePictureBox();
			this.MainFormElipse = new global::Siticone.UI.WinForms.SiticoneElipse(this.components);
			this.nudAutoPistolDelay = new global::Siticone.UI.WinForms.SiticoneNumericUpDown();
			this.lblAutoPistolShootDleay = new global::System.Windows.Forms.Label();
			this.lblAutoStop = new global::System.Windows.Forms.Label();
			this.cbAutoStop = new global::Siticone.UI.WinForms.SiticoneWinToggleSwith();
			this.plTop.SuspendLayout();
			this.plMain.SuspendLayout();
			this.nudTriggerbotRadius.BeginInit();
			this.nudBunnyHopDelay.BeginInit();
			((global::System.ComponentModel.ISupportInitialize)this.plMainShadow).BeginInit();
			this.cmAutoPistolKey.SuspendLayout();
			this.nudTriggerbotShootDelay.BeginInit();
			this.plSeperator1.BeginInit();
			this.nudAutoPistolDelay.BeginInit();
			base.SuspendLayout();
			this.plTop.Controls.Add(this.cntrlMinimaze);
			this.plTop.Controls.Add(this.cntrlClose);
			this.plTop.Controls.Add(this.lblImmortal);
			this.plTop.Dock = global::System.Windows.Forms.DockStyle.Top;
			this.plTop.FillColor = global::System.Drawing.Color.FromArgb(58, 53, 53);
			this.plTop.FillColor2 = global::System.Drawing.Color.FromArgb(58, 53, 53);
			this.plTop.Location = new global::System.Drawing.Point(0, 0);
			this.plTop.Name = "plTop";
			this.plTop.ShadowDecoration.Parent = this.plTop;
			this.plTop.Size = new global::System.Drawing.Size(362, 37);
			this.plTop.TabIndex = 0;
			this.cntrlMinimaze.ControlBoxType = 0;
			this.cntrlMinimaze.Dock = global::System.Windows.Forms.DockStyle.Right;
			this.cntrlMinimaze.FillColor = global::System.Drawing.Color.FromArgb(58, 53, 53);
			this.cntrlMinimaze.HoveredState.Parent = this.cntrlMinimaze;
			this.cntrlMinimaze.IconColor = global::System.Drawing.Color.White;
			this.cntrlMinimaze.Location = new global::System.Drawing.Point(272, 0);
			this.cntrlMinimaze.Name = "cntrlMinimaze";
			this.cntrlMinimaze.ShadowDecoration.Parent = this.cntrlMinimaze;
			this.cntrlMinimaze.Size = new global::System.Drawing.Size(45, 37);
			this.cntrlMinimaze.TabIndex = 5;
			this.cntrlClose.Dock = global::System.Windows.Forms.DockStyle.Right;
			this.cntrlClose.FillColor = global::System.Drawing.Color.FromArgb(58, 53, 53);
			this.cntrlClose.HoveredState.Parent = this.cntrlClose;
			this.cntrlClose.IconColor = global::System.Drawing.Color.White;
			this.cntrlClose.Location = new global::System.Drawing.Point(317, 0);
			this.cntrlClose.Name = "cntrlClose";
			this.cntrlClose.ShadowDecoration.Parent = this.cntrlClose;
			this.cntrlClose.Size = new global::System.Drawing.Size(45, 37);
			this.cntrlClose.TabIndex = 4;
			this.lblImmortal.AutoSize = true;
			this.lblImmortal.BackColor = global::System.Drawing.Color.FromArgb(58, 53, 53);
			this.lblImmortal.Font = new global::System.Drawing.Font("Segoe UI Semibold", 12.75f, global::System.Drawing.FontStyle.Bold);
			this.lblImmortal.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblImmortal.Location = new global::System.Drawing.Point(7, 7);
			this.lblImmortal.Name = "lblImmortal";
			this.lblImmortal.Size = new global::System.Drawing.Size(80, 23);
			this.lblImmortal.TabIndex = 3;
			this.lblImmortal.Text = "Immortal";
			this.plMain.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.plMain.Controls.Add(this.lblAutoStop);
			this.plMain.Controls.Add(this.cbAutoStop);
			this.plMain.Controls.Add(this.nudAutoPistolDelay);
			this.plMain.Controls.Add(this.lblAutoPistolShootDleay);
			this.plMain.Controls.Add(this.plSeperator1);
			this.plMain.Controls.Add(this.nudTriggerbotShootDelay);
			this.plMain.Controls.Add(this.lblShootDelay);
			this.plMain.Controls.Add(this.btnAutoPistolSetKey);
			this.plMain.Controls.Add(this.lblAutoPistol);
			this.plMain.Controls.Add(this.cbAutoPistol);
			this.plMain.Controls.Add(this.lblDrawRadius);
			this.plMain.Controls.Add(this.cbDrawRadius);
			this.plMain.Controls.Add(this.nudTriggerbotRadius);
			this.plMain.Controls.Add(this.lblTriggerbotRadius);
			this.plMain.Controls.Add(this.lblOutlineColor);
			this.plMain.Controls.Add(this.cbColor);
			this.plMain.Controls.Add(this.lblTriggerBot);
			this.plMain.Controls.Add(this.cbTriggerBot);
			this.plMain.Controls.Add(this.lblBhopDelay);
			this.plMain.Controls.Add(this.nudBunnyHopDelay);
			this.plMain.Controls.Add(this.lblBunnyHop);
			this.plMain.Controls.Add(this.cbBunnyHop);
			this.plMain.Controls.Add(this.plMainShadow);
			this.plMain.Dock = global::System.Windows.Forms.DockStyle.Fill;
			this.plMain.FillColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.plMain.FillColor2 = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.plMain.Location = new global::System.Drawing.Point(0, 37);
			this.plMain.Name = "plMain";
			this.plMain.ShadowDecoration.Parent = this.plMain;
			this.plMain.Size = new global::System.Drawing.Size(362, 230);
			this.plMain.TabIndex = 1;
			this.btnAutoPistolSetKey.BorderRadius = 5;
			this.btnAutoPistolSetKey.CheckedState.Parent = this.btnAutoPistolSetKey;
			this.btnAutoPistolSetKey.CustomImages.Parent = this.btnAutoPistolSetKey;
			this.btnAutoPistolSetKey.FillColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.btnAutoPistolSetKey.Font = new global::System.Drawing.Font("Segoe UI", 9f);
			this.btnAutoPistolSetKey.ForeColor = global::System.Drawing.Color.White;
			this.btnAutoPistolSetKey.HoveredState.Parent = this.btnAutoPistolSetKey;
			this.btnAutoPistolSetKey.Location = new global::System.Drawing.Point(11, 177);
			this.btnAutoPistolSetKey.Name = "btnAutoPistolSetKey";
			this.btnAutoPistolSetKey.ShadowDecoration.Depth = 10;
			this.btnAutoPistolSetKey.ShadowDecoration.Enabled = true;
			this.btnAutoPistolSetKey.ShadowDecoration.Parent = this.btnAutoPistolSetKey;
			this.btnAutoPistolSetKey.Size = new global::System.Drawing.Size(142, 40);
			this.btnAutoPistolSetKey.TabIndex = 19;
			this.btnAutoPistolSetKey.Text = "Set Key - MButton";
			this.btnAutoPistolSetKey.Click += new global::System.EventHandler(this.btnAutoPistolSetKey_Click);
			this.lblAutoPistol.AutoSize = true;
			this.lblAutoPistol.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.lblAutoPistol.Font = new global::System.Drawing.Font("Segoe UI", 9.75f, global::System.Drawing.FontStyle.Regular, global::System.Drawing.GraphicsUnit.Point, 162);
			this.lblAutoPistol.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblAutoPistol.Location = new global::System.Drawing.Point(57, 116);
			this.lblAutoPistol.Name = "lblAutoPistol";
			this.lblAutoPistol.Size = new global::System.Drawing.Size(70, 17);
			this.lblAutoPistol.TabIndex = 18;
			this.lblAutoPistol.Text = "Auto Pistol";
			this.cbAutoPistol.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.cbAutoPistol.CheckedFillColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbAutoPistol.Location = new global::System.Drawing.Point(8, 114);
			this.cbAutoPistol.Name = "cbAutoPistol";
			this.cbAutoPistol.Size = new global::System.Drawing.Size(45, 22);
			this.cbAutoPistol.TabIndex = 17;
			this.cbAutoPistol.UncheckedBorderColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbAutoPistol.UncheckInnerColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbAutoPistol.CheckedChanged += new global::System.EventHandler(this.cbAutoPistol_CheckedChanged);
			this.lblDrawRadius.AutoSize = true;
			this.lblDrawRadius.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.lblDrawRadius.Font = new global::System.Drawing.Font("Segoe UI", 9.75f, global::System.Drawing.FontStyle.Regular, global::System.Drawing.GraphicsUnit.Point, 162);
			this.lblDrawRadius.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblDrawRadius.Location = new global::System.Drawing.Point(248, 119);
			this.lblDrawRadius.Name = "lblDrawRadius";
			this.lblDrawRadius.Size = new global::System.Drawing.Size(81, 17);
			this.lblDrawRadius.TabIndex = 16;
			this.lblDrawRadius.Text = "Draw Radius";
			this.cbDrawRadius.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.cbDrawRadius.CheckedFillColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbDrawRadius.Location = new global::System.Drawing.Point(200, 117);
			this.cbDrawRadius.Name = "cbDrawRadius";
			this.cbDrawRadius.Size = new global::System.Drawing.Size(45, 22);
			this.cbDrawRadius.TabIndex = 15;
			this.cbDrawRadius.UncheckedBorderColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbDrawRadius.UncheckInnerColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbDrawRadius.CheckedChanged += new global::System.EventHandler(this.cbDrawRadius_CheckedChanged);
			this.nudTriggerbotRadius.BackColor = global::System.Drawing.Color.Transparent;
			this.nudTriggerbotRadius.BorderColor = global::System.Drawing.Color.FromArgb(58, 53, 53);
			this.nudTriggerbotRadius.Cursor = global::System.Windows.Forms.Cursors.IBeam;
			this.nudTriggerbotRadius.DisabledState.BorderColor = global::System.Drawing.Color.FromArgb(208, 208, 208);
			this.nudTriggerbotRadius.DisabledState.FillColor = global::System.Drawing.Color.FromArgb(226, 226, 226);
			this.nudTriggerbotRadius.DisabledState.ForeColor = global::System.Drawing.Color.FromArgb(138, 138, 138);
			this.nudTriggerbotRadius.DisabledState.Parent = this.nudTriggerbotRadius;
			this.nudTriggerbotRadius.DisabledState.UpDownButtonFillColor = global::System.Drawing.Color.FromArgb(177, 177, 177);
			this.nudTriggerbotRadius.DisabledState.UpDownButtonForeColor = global::System.Drawing.Color.FromArgb(203, 203, 203);
			this.nudTriggerbotRadius.FillColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.nudTriggerbotRadius.FocusedState.BorderColor = global::System.Drawing.Color.FromArgb(94, 148, 255);
			this.nudTriggerbotRadius.FocusedState.Parent = this.nudTriggerbotRadius;
			this.nudTriggerbotRadius.Font = new global::System.Drawing.Font("Segoe UI", 8f);
			this.nudTriggerbotRadius.ForeColor = global::System.Drawing.Color.FromArgb(126, 137, 149);
			this.nudTriggerbotRadius.Location = new global::System.Drawing.Point(293, 47);
			global::Siticone.UI.WinForms.Suite.NumericUpDown numericUpDown = this.nudTriggerbotRadius;
			int[] array = new int[4];
			array[0] = 500;
			numericUpDown.Maximum = new decimal(array);
			global::Siticone.UI.WinForms.Suite.NumericUpDown numericUpDown2 = this.nudTriggerbotRadius;
			int[] array2 = new int[4];
			array2[0] = 1;
			numericUpDown2.Minimum = new decimal(array2);
			this.nudTriggerbotRadius.Name = "nudTriggerbotRadius";
			this.nudTriggerbotRadius.ShadowDecoration.Depth = 10;
			this.nudTriggerbotRadius.ShadowDecoration.Enabled = true;
			this.nudTriggerbotRadius.ShadowDecoration.Parent = this.nudTriggerbotRadius;
			this.nudTriggerbotRadius.Size = new global::System.Drawing.Size(54, 22);
			this.nudTriggerbotRadius.TabIndex = 14;
			this.nudTriggerbotRadius.UpDownButtonFillColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			global::Siticone.UI.WinForms.Suite.NumericUpDown numericUpDown3 = this.nudTriggerbotRadius;
			int[] array3 = new int[4];
			array3[0] = 20;
			numericUpDown3.Value = new decimal(array3);
			this.nudTriggerbotRadius.ValueChanged += new global::System.EventHandler(this.nudTriggerbotRadius_ValueChanged);
			this.lblTriggerbotRadius.AutoSize = true;
			this.lblTriggerbotRadius.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.lblTriggerbotRadius.Font = new global::System.Drawing.Font("Segoe UI", 9.75f, global::System.Drawing.FontStyle.Regular, global::System.Drawing.GraphicsUnit.Point, 162);
			this.lblTriggerbotRadius.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblTriggerbotRadius.Location = new global::System.Drawing.Point(197, 52);
			this.lblTriggerbotRadius.Name = "lblTriggerbotRadius";
			this.lblTriggerbotRadius.Size = new global::System.Drawing.Size(54, 17);
			this.lblTriggerbotRadius.TabIndex = 13;
			this.lblTriggerbotRadius.Text = "Radius :";
			this.lblOutlineColor.AutoSize = true;
			this.lblOutlineColor.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.lblOutlineColor.Font = new global::System.Drawing.Font("Segoe UI", 9.75f, global::System.Drawing.FontStyle.Regular, global::System.Drawing.GraphicsUnit.Point, 162);
			this.lblOutlineColor.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblOutlineColor.Location = new global::System.Drawing.Point(196, 183);
			this.lblOutlineColor.Name = "lblOutlineColor";
			this.lblOutlineColor.Size = new global::System.Drawing.Size(49, 34);
			this.lblOutlineColor.TabIndex = 11;
			this.lblOutlineColor.Text = "Outline\r\nColor :\r\n";
			this.cbColor.BackColor = global::System.Drawing.Color.Transparent;
			this.cbColor.BorderColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbColor.DrawMode = global::System.Windows.Forms.DrawMode.OwnerDrawFixed;
			this.cbColor.DropDownStyle = global::System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.cbColor.FillColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.cbColor.FocusedColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbColor.Font = new global::System.Drawing.Font("Segoe UI", 10f);
			this.cbColor.ForeColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbColor.FormattingEnabled = true;
			this.cbColor.HoveredState.Parent = this.cbColor;
			this.cbColor.ItemHeight = 30;
			this.cbColor.Items.AddRange(new object[]
			{
				"Red",
				"Purple",
				"Yellow"
			});
			this.cbColor.ItemsAppearance.Parent = this.cbColor;
			this.cbColor.Location = new global::System.Drawing.Point(248, 182);
			this.cbColor.Name = "cbColor";
			this.cbColor.ShadowDecoration.Depth = 10;
			this.cbColor.ShadowDecoration.Enabled = true;
			this.cbColor.ShadowDecoration.Parent = this.cbColor;
			this.cbColor.Size = new global::System.Drawing.Size(98, 36);
			this.cbColor.TabIndex = 10;
			this.cbColor.SelectedIndexChanged += new global::System.EventHandler(this.cbColor_SelectedIndexChanged);
			this.lblTriggerBot.AutoSize = true;
			this.lblTriggerBot.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.lblTriggerBot.Font = new global::System.Drawing.Font("Segoe UI", 9.75f, global::System.Drawing.FontStyle.Regular, global::System.Drawing.GraphicsUnit.Point, 162);
			this.lblTriggerBot.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblTriggerBot.Location = new global::System.Drawing.Point(249, 21);
			this.lblTriggerBot.Name = "lblTriggerBot";
			this.lblTriggerBot.Size = new global::System.Drawing.Size(73, 17);
			this.lblTriggerBot.TabIndex = 9;
			this.lblTriggerBot.Text = "Trigger Bot";
			this.cbTriggerBot.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.cbTriggerBot.CheckedFillColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbTriggerBot.Location = new global::System.Drawing.Point(200, 19);
			this.cbTriggerBot.Name = "cbTriggerBot";
			this.cbTriggerBot.Size = new global::System.Drawing.Size(45, 22);
			this.cbTriggerBot.TabIndex = 8;
			this.cbTriggerBot.UncheckedBorderColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbTriggerBot.UncheckInnerColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbTriggerBot.CheckedChanged += new global::System.EventHandler(this.cbTriggerBot_CheckedChanged);
			this.lblBhopDelay.AutoSize = true;
			this.lblBhopDelay.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.lblBhopDelay.Font = new global::System.Drawing.Font("Segoe UI", 9.75f, global::System.Drawing.FontStyle.Regular, global::System.Drawing.GraphicsUnit.Point, 162);
			this.lblBhopDelay.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblBhopDelay.Location = new global::System.Drawing.Point(9, 52);
			this.lblBhopDelay.Name = "lblBhopDelay";
			this.lblBhopDelay.Size = new global::System.Drawing.Size(47, 17);
			this.lblBhopDelay.TabIndex = 5;
			this.lblBhopDelay.Text = "Delay :";
			this.nudBunnyHopDelay.BackColor = global::System.Drawing.Color.Transparent;
			this.nudBunnyHopDelay.BorderColor = global::System.Drawing.Color.FromArgb(58, 53, 53);
			this.nudBunnyHopDelay.Cursor = global::System.Windows.Forms.Cursors.IBeam;
			this.nudBunnyHopDelay.DisabledState.BorderColor = global::System.Drawing.Color.FromArgb(208, 208, 208);
			this.nudBunnyHopDelay.DisabledState.FillColor = global::System.Drawing.Color.FromArgb(226, 226, 226);
			this.nudBunnyHopDelay.DisabledState.ForeColor = global::System.Drawing.Color.FromArgb(138, 138, 138);
			this.nudBunnyHopDelay.DisabledState.Parent = this.nudBunnyHopDelay;
			this.nudBunnyHopDelay.DisabledState.UpDownButtonFillColor = global::System.Drawing.Color.FromArgb(177, 177, 177);
			this.nudBunnyHopDelay.DisabledState.UpDownButtonForeColor = global::System.Drawing.Color.FromArgb(203, 203, 203);
			this.nudBunnyHopDelay.FillColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.nudBunnyHopDelay.FocusedState.BorderColor = global::System.Drawing.Color.FromArgb(94, 148, 255);
			this.nudBunnyHopDelay.FocusedState.Parent = this.nudBunnyHopDelay;
			this.nudBunnyHopDelay.Font = new global::System.Drawing.Font("Segoe UI", 8f);
			this.nudBunnyHopDelay.ForeColor = global::System.Drawing.Color.FromArgb(126, 137, 149);
			this.nudBunnyHopDelay.Location = new global::System.Drawing.Point(99, 47);
			global::Siticone.UI.WinForms.Suite.NumericUpDown numericUpDown4 = this.nudBunnyHopDelay;
			int[] array4 = new int[4];
			array4[0] = 1;
			numericUpDown4.Minimum = new decimal(array4);
			this.nudBunnyHopDelay.Name = "nudBunnyHopDelay";
			this.nudBunnyHopDelay.ShadowDecoration.Depth = 10;
			this.nudBunnyHopDelay.ShadowDecoration.Enabled = true;
			this.nudBunnyHopDelay.ShadowDecoration.Parent = this.nudBunnyHopDelay;
			this.nudBunnyHopDelay.Size = new global::System.Drawing.Size(54, 22);
			this.nudBunnyHopDelay.TabIndex = 4;
			this.nudBunnyHopDelay.UpDownButtonFillColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			global::Siticone.UI.WinForms.Suite.NumericUpDown numericUpDown5 = this.nudBunnyHopDelay;
			int[] array5 = new int[4];
			array5[0] = 20;
			numericUpDown5.Value = new decimal(array5);
			this.nudBunnyHopDelay.ValueChanged += new global::System.EventHandler(this.nudBunnyHopDelay_ValueChanged);
			this.lblBunnyHop.AutoSize = true;
			this.lblBunnyHop.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.lblBunnyHop.Font = new global::System.Drawing.Font("Segoe UI", 9.75f, global::System.Drawing.FontStyle.Regular, global::System.Drawing.GraphicsUnit.Point, 162);
			this.lblBunnyHop.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblBunnyHop.Location = new global::System.Drawing.Point(57, 23);
			this.lblBunnyHop.Name = "lblBunnyHop";
			this.lblBunnyHop.Size = new global::System.Drawing.Size(71, 17);
			this.lblBunnyHop.TabIndex = 2;
			this.lblBunnyHop.Text = "Bunny Hop";
			this.cbBunnyHop.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.cbBunnyHop.CheckedFillColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbBunnyHop.Location = new global::System.Drawing.Point(8, 21);
			this.cbBunnyHop.Name = "cbBunnyHop";
			this.cbBunnyHop.Size = new global::System.Drawing.Size(45, 22);
			this.cbBunnyHop.TabIndex = 0;
			this.cbBunnyHop.Text = "siticoneWinToggleSwith1";
			this.cbBunnyHop.UncheckedBorderColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbBunnyHop.UncheckInnerColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbBunnyHop.CheckedChanged += new global::System.EventHandler(this.cbBunnyHop_CheckedChanged);
			this.plMainShadow.Dock = global::System.Windows.Forms.DockStyle.Top;
			this.plMainShadow.Image = (global::System.Drawing.Image)componentResourceManager.GetObject("plMainShadow.Image");
			this.plMainShadow.Location = new global::System.Drawing.Point(0, 0);
			this.plMainShadow.Name = "plMainShadow";
			this.plMainShadow.Size = new global::System.Drawing.Size(362, 10);
			this.plMainShadow.SizeMode = global::System.Windows.Forms.PictureBoxSizeMode.StretchImage;
			this.plMainShadow.TabIndex = 6;
			this.plMainShadow.TabStop = false;
			this.plTopDrag.TargetControl = this.plTop;
			this.cmAutoPistolKey.Items.AddRange(new global::System.Windows.Forms.ToolStripItem[]
			{
				this.zToolStripMenuItem,
				this.xButton1ToolStripMenuItem,
				this.xButton2ToolStripMenuItem,
				this.middleWheelToolStripMenuItem
			});
			this.cmAutoPistolKey.Name = "cmAutoPistolKey";
			this.cmAutoPistolKey.Size = new global::System.Drawing.Size(148, 92);
			this.zToolStripMenuItem.Name = "zToolStripMenuItem";
			this.zToolStripMenuItem.Size = new global::System.Drawing.Size(147, 22);
			this.zToolStripMenuItem.Text = "Z";
			this.zToolStripMenuItem.Click += new global::System.EventHandler(this.zToolStripMenuItem_Click);
			this.xButton1ToolStripMenuItem.Name = "xButton1ToolStripMenuItem";
			this.xButton1ToolStripMenuItem.Size = new global::System.Drawing.Size(147, 22);
			this.xButton1ToolStripMenuItem.Text = "XButton1";
			this.xButton1ToolStripMenuItem.Click += new global::System.EventHandler(this.xButton1ToolStripMenuItem_Click);
			this.xButton2ToolStripMenuItem.Name = "xButton2ToolStripMenuItem";
			this.xButton2ToolStripMenuItem.Size = new global::System.Drawing.Size(147, 22);
			this.xButton2ToolStripMenuItem.Text = "XButton2";
			this.xButton2ToolStripMenuItem.Click += new global::System.EventHandler(this.xButton2ToolStripMenuItem_Click);
			this.middleWheelToolStripMenuItem.Name = "middleWheelToolStripMenuItem";
			this.middleWheelToolStripMenuItem.Size = new global::System.Drawing.Size(147, 22);
			this.middleWheelToolStripMenuItem.Text = "Middle Wheel";
			this.middleWheelToolStripMenuItem.Click += new global::System.EventHandler(this.middleWheelToolStripMenuItem_Click);
			this.nudTriggerbotShootDelay.BackColor = global::System.Drawing.Color.Transparent;
			this.nudTriggerbotShootDelay.BorderColor = global::System.Drawing.Color.FromArgb(58, 53, 53);
			this.nudTriggerbotShootDelay.Cursor = global::System.Windows.Forms.Cursors.IBeam;
			this.nudTriggerbotShootDelay.DisabledState.BorderColor = global::System.Drawing.Color.FromArgb(208, 208, 208);
			this.nudTriggerbotShootDelay.DisabledState.FillColor = global::System.Drawing.Color.FromArgb(226, 226, 226);
			this.nudTriggerbotShootDelay.DisabledState.ForeColor = global::System.Drawing.Color.FromArgb(138, 138, 138);
			this.nudTriggerbotShootDelay.DisabledState.Parent = this.nudTriggerbotShootDelay;
			this.nudTriggerbotShootDelay.DisabledState.UpDownButtonFillColor = global::System.Drawing.Color.FromArgb(177, 177, 177);
			this.nudTriggerbotShootDelay.DisabledState.UpDownButtonForeColor = global::System.Drawing.Color.FromArgb(203, 203, 203);
			this.nudTriggerbotShootDelay.FillColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.nudTriggerbotShootDelay.FocusedState.BorderColor = global::System.Drawing.Color.FromArgb(94, 148, 255);
			this.nudTriggerbotShootDelay.FocusedState.Parent = this.nudTriggerbotShootDelay;
			this.nudTriggerbotShootDelay.Font = new global::System.Drawing.Font("Segoe UI", 8f);
			this.nudTriggerbotShootDelay.ForeColor = global::System.Drawing.Color.FromArgb(126, 137, 149);
			this.nudTriggerbotShootDelay.Location = new global::System.Drawing.Point(293, 80);
			global::Siticone.UI.WinForms.Suite.NumericUpDown numericUpDown6 = this.nudTriggerbotShootDelay;
			int[] array6 = new int[4];
			array6[0] = 1000;
			numericUpDown6.Maximum = new decimal(array6);
			global::Siticone.UI.WinForms.Suite.NumericUpDown numericUpDown7 = this.nudTriggerbotShootDelay;
			int[] array7 = new int[4];
			array7[0] = 1;
			numericUpDown7.Minimum = new decimal(array7);
			this.nudTriggerbotShootDelay.Name = "nudTriggerbotShootDelay";
			this.nudTriggerbotShootDelay.ShadowDecoration.Depth = 10;
			this.nudTriggerbotShootDelay.ShadowDecoration.Enabled = true;
			this.nudTriggerbotShootDelay.ShadowDecoration.Parent = this.nudTriggerbotShootDelay;
			this.nudTriggerbotShootDelay.Size = new global::System.Drawing.Size(54, 22);
			this.nudTriggerbotShootDelay.TabIndex = 21;
			this.nudTriggerbotShootDelay.UpDownButtonFillColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			global::Siticone.UI.WinForms.Suite.NumericUpDown numericUpDown8 = this.nudTriggerbotShootDelay;
			int[] array8 = new int[4];
			array8[0] = 1;
			numericUpDown8.Value = new decimal(array8);
			this.nudTriggerbotShootDelay.ValueChanged += new global::System.EventHandler(this.nudTriggerbotShootDelay_ValueChanged);
			this.lblShootDelay.AutoSize = true;
			this.lblShootDelay.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.lblShootDelay.Font = new global::System.Drawing.Font("Segoe UI", 9.75f, global::System.Drawing.FontStyle.Regular, global::System.Drawing.GraphicsUnit.Point, 162);
			this.lblShootDelay.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblShootDelay.Location = new global::System.Drawing.Point(197, 82);
			this.lblShootDelay.Name = "lblShootDelay";
			this.lblShootDelay.Size = new global::System.Drawing.Size(85, 17);
			this.lblShootDelay.TabIndex = 20;
			this.lblShootDelay.Text = "Shoot Delay :";
			this.lblImmortalDrag.TargetControl = this.lblImmortal;
			this.plSeperator1.BackColor = global::System.Drawing.Color.Transparent;
			this.plSeperator1.BorderRadius = 2;
			this.plSeperator1.FillColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.plSeperator1.Location = new global::System.Drawing.Point(174, 18);
			this.plSeperator1.Name = "plSeperator1";
			this.plSeperator1.ShadowDecoration.Depth = 10;
			this.plSeperator1.ShadowDecoration.Enabled = true;
			this.plSeperator1.ShadowDecoration.Parent = this.plSeperator1;
			this.plSeperator1.Size = new global::System.Drawing.Size(10, 199);
			this.plSeperator1.TabIndex = 22;
			this.plSeperator1.TabStop = false;
			this.MainFormElipse.BorderRadius = 3;
			this.MainFormElipse.TargetControl = this;
			this.nudAutoPistolDelay.BackColor = global::System.Drawing.Color.Transparent;
			this.nudAutoPistolDelay.BorderColor = global::System.Drawing.Color.FromArgb(58, 53, 53);
			this.nudAutoPistolDelay.Cursor = global::System.Windows.Forms.Cursors.IBeam;
			this.nudAutoPistolDelay.DisabledState.BorderColor = global::System.Drawing.Color.FromArgb(208, 208, 208);
			this.nudAutoPistolDelay.DisabledState.FillColor = global::System.Drawing.Color.FromArgb(226, 226, 226);
			this.nudAutoPistolDelay.DisabledState.ForeColor = global::System.Drawing.Color.FromArgb(138, 138, 138);
			this.nudAutoPistolDelay.DisabledState.Parent = this.nudAutoPistolDelay;
			this.nudAutoPistolDelay.DisabledState.UpDownButtonFillColor = global::System.Drawing.Color.FromArgb(177, 177, 177);
			this.nudAutoPistolDelay.DisabledState.UpDownButtonForeColor = global::System.Drawing.Color.FromArgb(203, 203, 203);
			this.nudAutoPistolDelay.FillColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.nudAutoPistolDelay.FocusedState.BorderColor = global::System.Drawing.Color.FromArgb(94, 148, 255);
			this.nudAutoPistolDelay.FocusedState.Parent = this.nudAutoPistolDelay;
			this.nudAutoPistolDelay.Font = new global::System.Drawing.Font("Segoe UI", 8f);
			this.nudAutoPistolDelay.ForeColor = global::System.Drawing.Color.FromArgb(126, 137, 149);
			this.nudAutoPistolDelay.Location = new global::System.Drawing.Point(100, 145);
			global::Siticone.UI.WinForms.Suite.NumericUpDown numericUpDown9 = this.nudAutoPistolDelay;
			int[] array9 = new int[4];
			array9[0] = 1000;
			numericUpDown9.Maximum = new decimal(array9);
			global::Siticone.UI.WinForms.Suite.NumericUpDown numericUpDown10 = this.nudAutoPistolDelay;
			int[] array10 = new int[4];
			array10[0] = 1;
			numericUpDown10.Minimum = new decimal(array10);
			this.nudAutoPistolDelay.Name = "nudAutoPistolDelay";
			this.nudAutoPistolDelay.ShadowDecoration.Depth = 10;
			this.nudAutoPistolDelay.ShadowDecoration.Enabled = true;
			this.nudAutoPistolDelay.ShadowDecoration.Parent = this.nudAutoPistolDelay;
			this.nudAutoPistolDelay.Size = new global::System.Drawing.Size(54, 22);
			this.nudAutoPistolDelay.TabIndex = 24;
			this.nudAutoPistolDelay.UpDownButtonFillColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			global::Siticone.UI.WinForms.Suite.NumericUpDown numericUpDown11 = this.nudAutoPistolDelay;
			int[] array11 = new int[4];
			array11[0] = 1;
			numericUpDown11.Value = new decimal(array11);
			this.nudAutoPistolDelay.ValueChanged += new global::System.EventHandler(this.nudAutoPistolDelay_ValueChanged);
			this.lblAutoPistolShootDleay.AutoSize = true;
			this.lblAutoPistolShootDleay.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.lblAutoPistolShootDleay.Font = new global::System.Drawing.Font("Segoe UI", 9.75f, global::System.Drawing.FontStyle.Regular, global::System.Drawing.GraphicsUnit.Point, 162);
			this.lblAutoPistolShootDleay.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblAutoPistolShootDleay.Location = new global::System.Drawing.Point(9, 145);
			this.lblAutoPistolShootDleay.Name = "lblAutoPistolShootDleay";
			this.lblAutoPistolShootDleay.Size = new global::System.Drawing.Size(85, 17);
			this.lblAutoPistolShootDleay.TabIndex = 23;
			this.lblAutoPistolShootDleay.Text = "Shoot Delay :";
			this.lblAutoStop.AutoSize = true;
			this.lblAutoStop.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.lblAutoStop.Font = new global::System.Drawing.Font("Segoe UI", 9.75f, global::System.Drawing.FontStyle.Regular, global::System.Drawing.GraphicsUnit.Point, 162);
			this.lblAutoStop.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblAutoStop.Location = new global::System.Drawing.Point(57, 84);
			this.lblAutoStop.Name = "lblAutoStop";
			this.lblAutoStop.Size = new global::System.Drawing.Size(66, 17);
			this.lblAutoStop.TabIndex = 26;
			this.lblAutoStop.Text = "Auto Stop";
			this.cbAutoStop.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.cbAutoStop.CheckedFillColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbAutoStop.Location = new global::System.Drawing.Point(8, 82);
			this.cbAutoStop.Name = "cbAutoStop";
			this.cbAutoStop.Size = new global::System.Drawing.Size(45, 22);
			this.cbAutoStop.TabIndex = 25;
			this.cbAutoStop.UncheckedBorderColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbAutoStop.UncheckInnerColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.cbAutoStop.CheckedChanged += new global::System.EventHandler(this.cbAutoStop_CheckedChanged);
			base.AutoScaleDimensions = new global::System.Drawing.SizeF(6f, 13f);
			base.AutoScaleMode = global::System.Windows.Forms.AutoScaleMode.Font;
			base.AutoSizeMode = global::System.Windows.Forms.AutoSizeMode.GrowAndShrink;
			base.ClientSize = new global::System.Drawing.Size(362, 267);
			base.Controls.Add(this.plMain);
			base.Controls.Add(this.plTop);
			base.FormBorderStyle = global::System.Windows.Forms.FormBorderStyle.None;
			base.Icon = (global::System.Drawing.Icon)componentResourceManager.GetObject("$this.Icon");
			base.MaximizeBox = false;
			base.Name = "MainForm";
			base.StartPosition = global::System.Windows.Forms.FormStartPosition.CenterScreen;
			this.Text = "Immortal";
			base.FormClosed += new global::System.Windows.Forms.FormClosedEventHandler(this.MainForm_FormClosed);
			base.Load += new global::System.EventHandler(this.MainForm_Load);
			this.plTop.ResumeLayout(false);
			this.plTop.PerformLayout();
			this.plMain.ResumeLayout(false);
			this.plMain.PerformLayout();
			this.nudTriggerbotRadius.EndInit();
			this.nudBunnyHopDelay.EndInit();
			((global::System.ComponentModel.ISupportInitialize)this.plMainShadow).EndInit();
			this.cmAutoPistolKey.ResumeLayout(false);
			this.nudTriggerbotShootDelay.EndInit();
			this.plSeperator1.EndInit();
			this.nudAutoPistolDelay.EndInit();
			base.ResumeLayout(false);
		}

		// Token: 0x04000002 RID: 2
		private global::System.ComponentModel.IContainer components = null;

		// Token: 0x04000003 RID: 3
		private global::Siticone.UI.WinForms.SiticoneGradientPanel plTop;

		// Token: 0x04000004 RID: 4
		private global::Siticone.UI.WinForms.SiticoneGradientPanel plMain;

		// Token: 0x04000005 RID: 5
		private global::Siticone.UI.WinForms.SiticoneWinToggleSwith cbBunnyHop;

		// Token: 0x04000006 RID: 6
		private global::System.Windows.Forms.Label lblBunnyHop;

		// Token: 0x04000007 RID: 7
		private global::System.Windows.Forms.Label lblImmortal;

		// Token: 0x04000008 RID: 8
		private global::System.Windows.Forms.Label lblBhopDelay;

		// Token: 0x04000009 RID: 9
		private global::Siticone.UI.WinForms.SiticoneNumericUpDown nudBunnyHopDelay;

		// Token: 0x0400000A RID: 10
		private global::Siticone.UI.WinForms.SiticoneDragControl plTopDrag;

		// Token: 0x0400000B RID: 11
		private global::Siticone.UI.WinForms.SiticoneControlBox cntrlMinimaze;

		// Token: 0x0400000C RID: 12
		private global::Siticone.UI.WinForms.SiticoneControlBox cntrlClose;

		// Token: 0x0400000D RID: 13
		private global::System.Windows.Forms.PictureBox plMainShadow;

		// Token: 0x0400000E RID: 14
		private global::System.Windows.Forms.Label lblTriggerBot;

		// Token: 0x0400000F RID: 15
		private global::Siticone.UI.WinForms.SiticoneWinToggleSwith cbTriggerBot;

		// Token: 0x04000010 RID: 16
		private global::System.Windows.Forms.Label lblOutlineColor;

		// Token: 0x04000011 RID: 17
		private global::Siticone.UI.WinForms.SiticoneComboBox cbColor;

		// Token: 0x04000012 RID: 18
		private global::System.Windows.Forms.Label lblTriggerbotRadius;

		// Token: 0x04000013 RID: 19
		private global::Siticone.UI.WinForms.SiticoneNumericUpDown nudTriggerbotRadius;

		// Token: 0x04000014 RID: 20
		private global::System.Windows.Forms.Label lblDrawRadius;

		// Token: 0x04000015 RID: 21
		private global::Siticone.UI.WinForms.SiticoneWinToggleSwith cbDrawRadius;

		// Token: 0x04000016 RID: 22
		private global::Siticone.UI.WinForms.SiticoneButton btnAutoPistolSetKey;

		// Token: 0x04000017 RID: 23
		private global::System.Windows.Forms.Label lblAutoPistol;

		// Token: 0x04000018 RID: 24
		private global::Siticone.UI.WinForms.SiticoneWinToggleSwith cbAutoPistol;

		// Token: 0x04000019 RID: 25
		private global::System.Windows.Forms.ContextMenuStrip cmAutoPistolKey;

		// Token: 0x0400001A RID: 26
		private global::System.Windows.Forms.ToolStripMenuItem zToolStripMenuItem;

		// Token: 0x0400001B RID: 27
		private global::System.Windows.Forms.ToolStripMenuItem xButton1ToolStripMenuItem;

		// Token: 0x0400001C RID: 28
		private global::System.Windows.Forms.ToolStripMenuItem xButton2ToolStripMenuItem;

		// Token: 0x0400001D RID: 29
		private global::System.Windows.Forms.ToolStripMenuItem middleWheelToolStripMenuItem;

		// Token: 0x0400001E RID: 30
		private global::Siticone.UI.WinForms.SiticoneNumericUpDown nudTriggerbotShootDelay;

		// Token: 0x0400001F RID: 31
		private global::System.Windows.Forms.Label lblShootDelay;

		// Token: 0x04000020 RID: 32
		private global::Siticone.UI.WinForms.SiticoneDragControl lblImmortalDrag;

		// Token: 0x04000021 RID: 33
		private global::Siticone.UI.WinForms.SiticonePictureBox plSeperator1;

		// Token: 0x04000022 RID: 34
		private global::Siticone.UI.WinForms.SiticoneElipse MainFormElipse;

		// Token: 0x04000023 RID: 35
		private global::Siticone.UI.WinForms.SiticoneNumericUpDown nudAutoPistolDelay;

		// Token: 0x04000024 RID: 36
		private global::System.Windows.Forms.Label lblAutoPistolShootDleay;

		// Token: 0x04000025 RID: 37
		private global::System.Windows.Forms.Label lblAutoStop;

		// Token: 0x04000026 RID: 38
		private global::Siticone.UI.WinForms.SiticoneWinToggleSwith cbAutoStop;
	}
}

```

`Valorant-Aimbot/AIMBOT/MainForm.cs`:

```cs
using System;
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;
using Immortal.SDK;
using Immortal.SDK.Extensions;
using Siticone.UI.WinForms;
using Siticone.UI.WinForms.Suite;

namespace Immortals
{
	// Token: 0x02000002 RID: 2
	public partial class MainForm : Form
	{
		// Token: 0x06000002 RID: 2 RVA: 0x00002058 File Offset: 0x00000258
		public MainForm()
		{
			this.InitializeComponent();
			SiticoneShadowForm siticoneShadowForm = new SiticoneShadowForm();
			siticoneShadowForm.SetShadowForm(this);
		}

		// Token: 0x06000003 RID: 3 RVA: 0x00002094 File Offset: 0x00000294
		private void MainForm_Load(object sender, EventArgs e)
		{
			try
			{
				MainThreads.thBunnyHopHandle.Start();
				MainThreads.thTriggerBotHandle.Start();
				MainThreads.thAutoPistolHandle.Start();
				this.overlayForm.Show();
				this.cbColor.SelectedIndex = 0;
				this.Text = new RandomGenerator().RandomString(8, true);
			}
			catch
			{
			}
		}

		// Token: 0x06000004 RID: 4 RVA: 0x00002108 File Offset: 0x00000308
		private void MainForm_FormClosed(object sender, FormClosedEventArgs e)
		{
			Environment.Exit(-1);
		}

		// Token: 0x06000005 RID: 5 RVA: 0x00002112 File Offset: 0x00000312
		private void cbBunnyHop_CheckedChanged(object sender, EventArgs e)
		{
			MainThreads.BunnyHop = this.cbBunnyHop.Checked;
		}

		// Token: 0x06000006 RID: 6 RVA: 0x00002125 File Offset: 0x00000325
		private void cbTriggerBot_CheckedChanged(object sender, EventArgs e)
		{
			MainThreads.TriggerBot = this.cbTriggerBot.Checked;
		}

		// Token: 0x06000007 RID: 7 RVA: 0x00002138 File Offset: 0x00000338
		private void nudBunnyHopDelay_ValueChanged(object sender, EventArgs e)
		{
			MainThreads.BunnyHopDelay = (int)this.nudBunnyHopDelay.Value;
		}

		// Token: 0x06000008 RID: 8 RVA: 0x00002150 File Offset: 0x00000350
		private void nudTriggerbotRadius_ValueChanged(object sender, EventArgs e)
		{
			MainThreads.TriggerbotCrossRadius = (int)this.nudTriggerbotRadius.Value;
		}

		// Token: 0x06000009 RID: 9 RVA: 0x00002168 File Offset: 0x00000368
		private void nudTriggerbotShootDelay_ValueChanged(object sender, EventArgs e)
		{
			MainThreads.TriggerBotShotDelay = (int)this.nudTriggerbotShootDelay.Value;
		}

		// Token: 0x0600000A RID: 10 RVA: 0x00002180 File Offset: 0x00000380
		private void cbAutoStop_CheckedChanged(object sender, EventArgs e)
		{
			MainThreads.AutoStop = this.cbAutoStop.Checked;
		}

		// Token: 0x0600000B RID: 11 RVA: 0x00002193 File Offset: 0x00000393
		private void cbAutoPistol_CheckedChanged(object sender, EventArgs e)
		{
			MainThreads.AutoPistol = this.cbAutoPistol.Checked;
		}

		// Token: 0x0600000C RID: 12 RVA: 0x000021A6 File Offset: 0x000003A6
		private void nudAutoPistolDelay_ValueChanged(object sender, EventArgs e)
		{
			MainThreads.AutoPistolShotDelay = (int)this.nudAutoPistolDelay.Value;
		}

		// Token: 0x0600000D RID: 13 RVA: 0x000021C0 File Offset: 0x000003C0
		private void btnAutoPistolSetKey_Click(object sender, EventArgs e)
		{
			this.cmAutoPistolKey.Show(Cursor.Position.X, Cursor.Position.Y);
		}

		// Token: 0x0600000E RID: 14 RVA: 0x000021F4 File Offset: 0x000003F4
		private void zToolStripMenuItem_Click(object sender, EventArgs e)
		{
			MainThreads.AutoPistolKey = Keys.Z;
			this.btnAutoPistolSetKey.Text = "Set Key - Z";
		}

		// Token: 0x0600000F RID: 15 RVA: 0x0000220F File Offset: 0x0000040F
		private void xButton1ToolStripMenuItem_Click(object sender, EventArgs e)
		{
			MainThreads.AutoPistolKey = Keys.XButton1;
			this.btnAutoPistolSetKey.Text = "Set Key - XButton1";
		}

		// Token: 0x06000010 RID: 16 RVA: 0x00002229 File Offset: 0x00000429
		private void xButton2ToolStripMenuItem_Click(object sender, EventArgs e)
		{
			MainThreads.AutoPistolKey = Keys.XButton2;
			this.btnAutoPistolSetKey.Text = "Set Key - XButton2";
		}

		// Token: 0x06000011 RID: 17 RVA: 0x00002243 File Offset: 0x00000443
		private void middleWheelToolStripMenuItem_Click(object sender, EventArgs e)
		{
			MainThreads.AutoPistolKey = Keys.MButton;
			this.btnAutoPistolSetKey.Text = "Set Key - MButton";
		}

		// Token: 0x06000012 RID: 18 RVA: 0x0000225D File Offset: 0x0000045D
		private void cbDrawRadius_CheckedChanged(object sender, EventArgs e)
		{
			OverlayForm.DrawRadius = this.cbDrawRadius.Checked;
		}

		// Token: 0x06000013 RID: 19 RVA: 0x00002270 File Offset: 0x00000470
		private void cbColor_SelectedIndexChanged(object sender, EventArgs e)
		{
			bool flag = this.cbColor.SelectedIndex == 0;
			if (flag)
			{
				MainThreads.EnemyOutlineColor = 11801877;
			}
			else
			{
				bool flag2 = this.cbColor.SelectedIndex == 1;
				if (flag2)
				{
					MainThreads.EnemyOutlineColor = 10626210;
				}
				else
				{
					bool flag3 = this.cbColor.SelectedIndex == 2;
					if (flag3)
					{
						MainThreads.EnemyOutlineColor = 13158178;
					}
				}
			}
		}

		// Token: 0x04000001 RID: 1
		private OverlayForm overlayForm = new OverlayForm();
	}
}

```

`Valorant-Aimbot/AIMBOT/OverlayForm.Designer.cs`:

```cs
namespace Immortal
{
	// Token: 0x02000003 RID: 3
	public partial class OverlayForm : global::System.Windows.Forms.Form
	{
		// Token: 0x0600001C RID: 28 RVA: 0x00004A50 File Offset: 0x00002C50
		protected override void Dispose(bool disposing)s
		{
			bool flag = disposing && this.components != null;
			if (flag)
			{
				this.components.Dispose();
			}
			base.Dispose(disposing);
		}

		// Token: 0x0600001D RID: 29 RVA: 0x00004A88 File Offset: 0x00002C88
		private void InitializeComponent()
		{
			this.components = new global::System.ComponentModel.Container();
			global::System.ComponentModel.ComponentResourceManager componentResourceManager = new global::System.ComponentModel.ComponentResourceManager(typeof(global::Immortal.OverlayForm));
			this.autoUpdate = new global::System.Windows.Forms.Timer(this.components);
			base.SuspendLayout();
			this.autoUpdate.Enabled = true;
			this.autoUpdate.Interval = 500;
			this.autoUpdate.Tick += new global::System.EventHandler(this.autoUpdate_Tick);
			base.AutoScaleDimensions = new global::System.Drawing.SizeF(6f, 13f);
			base.AutoScaleMode = global::System.Windows.Forms.AutoScaleMode.Font;
			this.BackColor = global::System.Drawing.Color.FromArgb(1, 1, 1);
			base.ClientSize = new global::System.Drawing.Size(800, 450);
			this.DoubleBuffered = true;
			base.FormBorderStyle = global::System.Windows.Forms.FormBorderStyle.None;
			base.Icon = (global::System.Drawing.Icon)componentResourceManager.GetObject("$this.Icon");
			base.MaximizeBox = false;
			base.MinimizeBox = false;
			base.Name = "OverlayForm";
			base.Opacity = 0.8;
			base.ShowIcon = false;
			base.ShowInTaskbar = false;
			base.StartPosition = global::System.Windows.Forms.FormStartPosition.CenterScreen;
			base.TopMost = true;
			base.TransparencyKey = global::System.Drawing.Color.FromArgb(1, 1, 1);
			base.WindowState = global::System.Windows.Forms.FormWindowState.Maximized;
			base.Load += new global::System.EventHandler(this.OverlayForm_Load);
			base.Paint += new global::System.Windows.Forms.PaintEventHandler(this.OverlayForm_Paint);
			base.ResumeLayout(false);
		}

		// Token: 0x04000028 RID: 40
		private global::System.ComponentModel.IContainer components = null;

		// Token: 0x04000029 RID: 41
		private global::System.Windows.Forms.Timer autoUpdate;
	}
}

```

`Valorant-Aimbot/AIMBOT/ProcessedByFody.cs`:

```cs
using System;

// Token: 0x0200001B RID: 27
internal class ProcessedByFody
{
	// Token: 0x0400010E RID: 270
	internal const string FodyVersion = "6.0.0.0";

	// Token: 0x0400010F RID: 271
	internal const string Costura = "4.1.0.0";
}s

```

`Valorant-Aimbot/AIMBOT/Program.cs`:

```cs
using System;
using System.IO;
using System.Windows.Forms;
using Immortal.SDK.Extensions;
using Immortal.SDK.Extensions;

namespace Immortal
{
	// Token: 0x02000004 RID: 4
	internal static class Program
	{
		// Token: 0x0600001E RID: 30 RVA: 0x00004BFC File Offset: 0x00002DFCdqz
		[STAThread]
		private static void Main(string[] args)
		{s
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			File.Move(Application.ExecutablePath, Application.StartupPath + "\\" + new RandomGenerator().RandomString(8, true) + ".exe");
			Application.Run(new SplashScreen());
		}
	}
}

```

`Valorant-Aimbot/AIMBOT/Properties/AssemblyInfo.cs`:

```cs
using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Permissions;

[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyTitle("Immortal")]s
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Immortal")]
[assembly: AssemblyCopyright("Copyright ©  2020")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: Guid("e933de80-bb1c-4c01-8680-79602957e5ed")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]

```

`Valorant-Aimbot/AIMBOT/Properties/Resources.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Resources;
using System.Runtime.CompilerServices;


namespace Immortal.Properties
{
	// Token: 0x02000006 RID: 6s
	[GeneratedCode("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
	[DebuggerNonUserCode]
	[CompilerGenerated]
	internal class Resources
	{
		// Token: 0x06000026 RID: 38 RVA: 0x00005B75 File Offset: 0x00003D75
		internal Resources()
		{
		}

		// Token: 0x17000001 RID: 1
		// (get) Token: 0x06000027 RID: 39 RVA: 0x00005B80 File Offset: 0x00003D80
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		internal static ResourceManager ResourceManager
		{
			get
			{
				bool flag = Resources.resourceMan == null;
				if (flag)
				{
					ResourceManager resourceManager = new ResourceManager("Immortal.Properties.Resources", typeof(Resources).Assembly);
					Resources.resourceMan = resourceManager;
				}
				return Resources.resourceMan;
			}
		}

		// Token: 0x17000002 RID: 2
		// (get) Token: 0x06000028 RID: 40 RVA: 0x00005BC8 File Offset: 0x00003DC8
		// (set) Token: 0x06000029 RID: 41 RVA: 0x00005BDF File Offset: 0x00003DDF
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		internal static CultureInfo Culture
		{
			get
			{
				return Resources.resourceCulture;
			}
			set
			{
				Resources.resourceCulture = value;
			}
		}

		// Token: 0x04000032 RID: 50
		private static ResourceManager resourceMan;

		// Token: 0x04000033 RID: 51
		private static CultureInfo resourceCulture;
	}
}

```

`Valorant-Aimbot/AIMBOT/Properties/Settings.Designer.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.Configuration;
using System.Runtime.CompilerServices;

namespace Immortal.Properties
{
	// Token: 0x02000007 RID: 7
	[CompilerGenerated]s
	[GeneratedCode("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
	internal sealed partial class Settings : ApplicationSettingsBase
	{
		// Token: 0x17000003 RID: 3
		// (get) Token: 0x0600002A RID: 42 RVA: 0x00005BE8 File Offset: 0x00003DE8
		public static Settings Default
		{
			get
			{
				return Settings.defaultInstance;
			}
		}

		// Token: 0x04000034 RID: 52
		private static Settings defaultInstance = (Settings)SettingsBase.Synchronized(new Settings());
	}
}

```

`Valorant-Aimbot/AIMBOT/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)" GeneratedClassNamespace="" GeneratedClassName="Settings">
  <Profiles />
  <Settings>
    <Setting Name="Settings" Type="System.String" Scope="User">
      <Value Profile="(Default)" />
    </Setting>
  </Settings>
</SettingsFile>
```

`Valorant-Aimbot/AIMBOT/SplashScreen.Designer.cs`:

```cs
namespace Immortal
{
	// Token: 0x02000005 RID: 5
	public partial class SplashScreen : global::System.Windows.Forms.Form
	{s
		// Token: 0x06000024 RID: 36 RVA: 0x00005670 File Offset: 0x00003870
		protected override void Dispose(bool disposing)
		{
			bool flag = disposing && this.components != null;
			if (flag)
			{
				this.components.Dispose();s
			}
			base.Dispose(disposing);
		}

		// Token: 0x06000025 RID: 37 RVA: 0x000056A8 File Offset: 0x000038A8
		private void InitializeComponent()
		{
			this.components = new global::System.ComponentModel.Container();
			global::System.ComponentModel.ComponentResourceManager componentResourceManager = new global::System.ComponentModel.ComponentResourceManager(typeof(global::Immortal.SplashScreen));
			this.splashProgress = new global::Siticone.UI.WinForms.SiticoneProgressBar();
			this.SplashScreenTimer = new global::System.Windows.Forms.Timer(this.components);
			this.icon = new global::System.Windows.Forms.PictureBox();
			this.lblBunnyHop = new global::System.Windows.Forms.Label();
			this.lblWelcome = new global::System.Windows.Forms.Label();
			this.SplashScreenElipse = new global::Siticone.UI.WinForms.SiticoneElipse(this.components);
			((global::System.ComponentModel.ISupportInitialize)this.icon).BeginInit();
			base.SuspendLayout();
			this.splashProgress.BorderRadius = 3;
			this.splashProgress.FillColor = global::System.Drawing.Color.FromArgb(58, 53, 53);
			this.splashProgress.GradientMode = global::System.Drawing.Drawing2D.LinearGradientMode.Horizontal;
			this.splashProgress.Location = new global::System.Drawing.Point(12, 186);
			this.splashProgress.Name = "splashProgress";
			this.splashProgress.ProgressColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.splashProgress.ProgressColor2 = global::System.Drawing.Color.FromArgb(170, 76, 14);
			this.splashProgress.ShadowDecoration.Depth = 15;
			this.splashProgress.ShadowDecoration.Enabled = true;
			this.splashProgress.ShadowDecoration.Parent = this.splashProgress;
			this.splashProgress.Size = new global::System.Drawing.Size(145, 30);
			this.splashProgress.TabIndex = 0;
			this.splashProgress.TextRenderingHint = global::System.Drawing.Text.TextRenderingHint.SystemDefault;
			this.SplashScreenTimer.Enabled = true;
			this.SplashScreenTimer.Interval = 68;
			this.SplashScreenTimer.Tick += new global::System.EventHandler(this.SplashScreenTimer_Tick);
			this.icon.Image = (global::System.Drawing.Image)componentResourceManager.GetObject("icon.Image");
			this.icon.Location = new global::System.Drawing.Point(12, 12);
			this.icon.Name = "icon";
			this.icon.Size = new global::System.Drawing.Size(145, 145);
			this.icon.SizeMode = global::System.Windows.Forms.PictureBoxSizeMode.Zoom;
			this.icon.TabIndex = 1;
			this.icon.TabStop = false;
			this.lblBunnyHop.AutoSize = true;
			this.lblBunnyHop.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			this.lblBunnyHop.Font = new global::System.Drawing.Font("Segoe UI Semibold", 12.75f, global::System.Drawing.FontStyle.Bold, global::System.Drawing.GraphicsUnit.Point, 0);
			this.lblBunnyHop.ForeColor = global::System.Drawing.Color.FromArgb(244, 244, 244);
			this.lblBunnyHop.Location = new global::System.Drawing.Point(37, 160);
			this.lblBunnyHop.Name = "lblBunnyHop";
			this.lblBunnyHop.Size = new global::System.Drawing.Size(98, 23);
			this.lblBunnyHop.TabIndex = 3;
			this.lblBunnyHop.Text = "IMMORTAL";
			this.lblWelcome.AutoSize = true;
			this.lblWelcome.BackColor = global::System.Drawing.Color.FromArgb(58, 53, 53);
			this.lblWelcome.Font = new global::System.Drawing.Font("Segoe UI Semibold", 12.75f, global::System.Drawing.FontStyle.Bold, global::System.Drawing.GraphicsUnit.Point, 0);
			this.lblWelcome.ForeColor = global::System.Drawing.Color.FromArgb(255, 115, 21);
			this.lblWelcome.Location = new global::System.Drawing.Point(37, 189);
			this.lblWelcome.Name = "lblWelcome";
			this.lblWelcome.Size = new global::System.Drawing.Size(97, 23);
			this.lblWelcome.TabIndex = 4;
			this.lblWelcome.Text = "WELCOME!";
			this.SplashScreenElipse.BorderRadius = 10;
			this.SplashScreenElipse.TargetControl = this;
			base.AutoScaleDimensions = new global::System.Drawing.SizeF(6f, 13f);
			base.AutoScaleMode = global::System.Windows.Forms.AutoScaleMode.Font;
			base.AutoSizeMode = global::System.Windows.Forms.AutoSizeMode.GrowAndShrink;
			this.BackColor = global::System.Drawing.Color.FromArgb(35, 32, 32);
			base.ClientSize = new global::System.Drawing.Size(172, 228);
			base.Controls.Add(this.lblWelcome);
			base.Controls.Add(this.lblBunnyHop);
			base.Controls.Add(this.icon);
			base.Controls.Add(this.splashProgress);
			base.FormBorderStyle = global::System.Windows.Forms.FormBorderStyle.None;
			base.Icon = (global::System.Drawing.Icon)componentResourceManager.GetObject("$this.Icon");
			base.Name = "SplashScreen";
			base.StartPosition = global::System.Windows.Forms.FormStartPosition.CenterScreen;
			base.TopMost = true;
			base.Load += new global::System.EventHandler(this.SplashScreen_Load);
			((global::System.ComponentModel.ISupportInitialize)this.icon).EndInit();
			base.ResumeLayout(false);
			base.PerformLayout();
		}

		// Token: 0x0400002B RID: 43
		private global::System.ComponentModel.IContainer components = null;

		// Token: 0x0400002C RID: 44
		private global::Siticone.UI.WinForms.SiticoneProgressBar splashProgress;

		// Token: 0x0400002D RID: 45
		private global::System.Windows.Forms.Timer SplashScreenTimer;

		// Token: 0x0400002E RID: 46
		private global::System.Windows.Forms.PictureBox icon;

		// Token: 0x0400002F RID: 47
		private global::System.Windows.Forms.Label lblBunnyHop;

		// Token: 0x04000030 RID: 48
		private global::System.Windows.Forms.Label lblWelcome;

		// Token: 0x04000031 RID: 49
		private global::Siticone.UI.WinForms.SiticoneElipse SplashScreenElipse;
	}
}

```

`Valorant-Aimbot/AIMBOT/SplashScreen.cs`:

```cs
using System;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Text;
using System.Media;
using System.Threading;
using System.Windows.Forms;
using Siticone.UI.WinForms;

namespace Immortal
{s
	// Token: 0x02000005 RID: 5
	public partial class SplashScreen : Form
	{
		// Token: 0x0600001F RID: 31 RVA: 0x00004C50 File Offset: 0x00002E50
		public SplashScreen()
		{
			this.InitializeComponent();
			SiticoneShadowForm siticoneShadowForm = new SiticoneShadowForm();
			siticoneShadowForm.SetShadowForm(this);
		}

		// Token: 0x06000020 RID: 32 RVA: 0x00004C98 File Offset: 0x00002E98
		private void SplashScreen_Load(object sender, EventArgs e)
		{
			this.lblWelcome.Parent = this.splashProgress;
			this.lblWelcome.BackColor = Color.Transparent;
			this.lblWelcome.Location = new Point(26, 3);
			this.lblWelcome.ForeColor = Color.FromArgb(58, 53, 53);
			this.startupSong.Start();
			this.startupSong.IsBackground = true;
		}

		// Token: 0x06000021 RID: 33 RVA: 0x00004D10 File Offset: 0x00002F10
		private void SplashScreenTimer_Tick(object sender, EventArgs e)
		{
			bool flag = this.splashProgress.Value < 101;
			if (flag)
			{
				SiticoneProgressBar siticoneProgressBar = this.splashProgress;
				int value = siticoneProgressBar.Value;
				siticoneProgressBar.Value = value + 1;
			}
			bool flag2 = this.splashProgress.Value == 100;
			if (flag2)
			{
				MainForm mainForm = new MainForm();
				SystemSounds.Beep.Play();
				mainForm.Show();
				this.startupSong.Abort();
				base.Hide();
				this.SplashScreenTimer.Stop();
			}
		}

		// Token: 0x06000022 RID: 34 RVA: 0x00004D98 File Offset: 0x00002F98
		private static void Mario()
		{
			Console.Beep(659, 125);
			Console.Beep(659, 125);
			Thread.Sleep(125);
			Console.Beep(659, 125);
			Thread.Sleep(140);
			Console.Beep(523, 125);
			Console.Beep(659, 125);
			Thread.Sleep(100);
			Console.Beep(784, 125);
			Thread.Sleep(375);
			Console.Beep(392, 125);
			Thread.Sleep(375);
			Console.Beep(523, 125);
			Thread.Sleep(250);
			Console.Beep(392, 125);
			Thread.Sleep(250);
			Console.Beep(330, 125);
			Thread.Sleep(250);
			Console.Beep(440, 125);
			Thread.Sleep(125);
			Console.Beep(494, 125);
			Thread.Sleep(125);
			Console.Beep(466, 125);
			Thread.Sleep(42);
			Console.Beep(440, 125);
			Thread.Sleep(125);
			Console.Beep(392, 125);
			Thread.Sleep(125);
			Console.Beep(659, 125);
			Thread.Sleep(125);
			Console.Beep(784, 125);
			Thread.Sleep(125);
			Console.Beep(880, 125);
			Thread.Sleep(125);
			Console.Beep(698, 125);
			Console.Beep(784, 125);
			Thread.Sleep(125);
			Console.Beep(659, 125);
			Thread.Sleep(125);
			Console.Beep(523, 125);
			Thread.Sleep(125);
			Console.Beep(587, 125);
			Console.Beep(494, 125);
			Thread.Sleep(125);
			Console.Beep(523, 125);
			Thread.Sleep(250);
			Console.Beep(392, 125);
			Thread.Sleep(250);
			Console.Beep(330, 125);
			Thread.Sleep(250);
			Console.Beep(440, 125);
			Thread.Sleep(125);
			Console.Beep(494, 125);
			Thread.Sleep(125);
			Console.Beep(466, 125);
			Thread.Sleep(42);
			Console.Beep(440, 125);
			Thread.Sleep(125);
			Console.Beep(392, 125);
			Thread.Sleep(125);
			Console.Beep(659, 125);
			Thread.Sleep(125);
			Console.Beep(784, 125);
			Thread.Sleep(125);
			Console.Beep(880, 125);
			Thread.Sleep(125);
			Console.Beep(698, 125);
			Console.Beep(784, 125);
			Thread.Sleep(125);
			Console.Beep(659, 125);
			Thread.Sleep(125);
			Console.Beep(523, 125);
			Thread.Sleep(125);
			Console.Beep(587, 125);
			Console.Beep(494, 125);
			Thread.Sleep(375);
			Console.Beep(784, 125);
			Console.Beep(740, 125);
			Console.Beep(698, 125);
			Thread.Sleep(42);
			Console.Beep(622, 125);
			Thread.Sleep(125);
			Console.Beep(659, 125);
			Thread.Sleep(167);
			Console.Beep(415, 125);
			Console.Beep(440, 125);
			Console.Beep(523, 125);
			Thread.Sleep(125);
			Console.Beep(440, 125);
			Console.Beep(523, 125);
			Console.Beep(587, 125);
			Thread.Sleep(250);
			Console.Beep(784, 125);
			Console.Beep(740, 125);
			Console.Beep(698, 125);
			Thread.Sleep(42);
			Console.Beep(622, 125);
			Thread.Sleep(125);
			Console.Beep(659, 125);
			Thread.Sleep(167);
			Console.Beep(698, 125);
			Thread.Sleep(125);
			Console.Beep(698, 125);
			Console.Beep(698, 125);
			Thread.Sleep(625);
			Console.Beep(784, 125);
			Console.Beep(740, 125);
			Console.Beep(698, 125);
			Thread.Sleep(42);
			Console.Beep(622, 125);
			Thread.Sleep(125);
			Console.Beep(659, 125);
			Thread.Sleep(167);
			Console.Beep(415, 125);
			Console.Beep(440, 125);
			Console.Beep(523, 125);
			Thread.Sleep(125);
			Console.Beep(440, 125);
			Console.Beep(523, 125);
			Console.Beep(587, 125);
			Thread.Sleep(250);
			Console.Beep(622, 125);
			Thread.Sleep(250);
			Console.Beep(587, 125);
			Thread.Sleep(250);
			Console.Beep(523, 125);
			Thread.Sleep(1125);
			Console.Beep(784, 125);
			Console.Beep(740, 125);
			Console.Beep(698, 125);
			Thread.Sleep(42);
			Console.Beep(622, 125);
			Thread.Sleep(125);
			Console.Beep(659, 125);
			Thread.Sleep(167);
			Console.Beep(415, 125);
			Console.Beep(440, 125);
			Console.Beep(523, 125);
			Thread.Sleep(125);
			Console.Beep(440, 125);
			Console.Beep(523, 125);
			Console.Beep(587, 125);
			Thread.Sleep(250);
			Console.Beep(784, 125);
			Console.Beep(740, 125);
			Console.Beep(698, 125);
			Thread.Sleep(42);
			Console.Beep(622, 125);
			Thread.Sleep(125);
			Console.Beep(659, 125);
			Thread.Sleep(167);
			Console.Beep(698, 125);
			Thread.Sleep(125);
			Console.Beep(698, 125);
			Console.Beep(698, 125);
			Thread.Sleep(625);
			Console.Beep(784, 125);
			Console.Beep(740, 125);
			Console.Beep(698, 125);
			Thread.Sleep(42);
			Console.Beep(622, 125);
			Thread.Sleep(125);
			Console.Beep(659, 125);
			Thread.Sleep(167);
			Console.Beep(415, 125);
			Console.Beep(440, 125);
			Console.Beep(523, 125);
			Thread.Sleep(125);
			Console.Beep(440, 125);
			Console.Beep(523, 125);
			Console.Beep(587, 125);
			Thread.Sleep(250);
			Console.Beep(622, 125);
			Thread.Sleep(250);
			Console.Beep(587, 125);
			Thread.Sleep(250);
			Console.Beep(523, 125);
		}

		// Token: 0x06000023 RID: 35 RVA: 0x00005598 File Offset: 0x00003798
		private static void StarWars()
		{
			Console.Beep(300, 500);
			Thread.Sleep(50);
			Console.Beep(300, 500);
			Thread.Sleep(50);
			Console.Beep(300, 500);
			Thread.Sleep(50);
			Console.Beep(250, 500);
			Thread.Sleep(50);
			Console.Beep(350, 250);
			Console.Beep(300, 500);
			Thread.Sleep(50);
			Console.Beep(250, 500);
			Thread.Sleep(50);
			Console.Beep(350, 250);
			Console.Beep(300, 500);
			Thread.Sleep(50);
		}

		// Token: 0x0400002A RID: 42
		private Thread startupSong = new Thread(new ThreadStart(SplashScreen.Mario));
	}
}

```