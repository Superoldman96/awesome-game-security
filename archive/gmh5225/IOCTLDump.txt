Project Path: arc_gmh5225_IOCTLDump_w_mnecmr

Source Tree:

```txt
arc_gmh5225_IOCTLDump_w_mnecmr
├── IOCTLDump
│   ├── IOCTLDump.h
│   ├── IOCTLDump.inf
│   ├── IOCTLDump.vcxproj
│   ├── IOCTLDump.vcxproj.filters
│   ├── IOCTLDump.vcxproj.user
│   ├── IOCTLDump_Kern.h
│   └── Main.cpp
├── IOCTLDump.sln
├── IOCTLDumpClient
│   ├── IOCTLDumpClient.cpp
│   ├── IOCTLDumpClient.vcxproj
│   ├── IOCTLDumpClient.vcxproj.filters
│   ├── IOCTLDumpClient.vcxproj.user
│   └── ntdll.h
├── README.md
└── design2.txt

```

`IOCTLDump.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32014.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "IOCTLDump", "IOCTLDump\IOCTLDump.vcxproj", "{7CC542F2-F14C-4339-83AB-5940889EDEA6}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "IOCTLDumpClient", "IOCTLDumpClient\IOCTLDumpClient.vcxproj", "{A38675CF-B728-4DD5-9098-D356C33378CC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|ARM.ActiveCfg = Debug|ARM
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|ARM.Build.0 = Debug|ARM
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|ARM.Deploy.0 = Debug|ARM
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|ARM64.Build.0 = Debug|ARM64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|x64.ActiveCfg = Debug|x64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|x64.Build.0 = Debug|x64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|x64.Deploy.0 = Debug|x64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|x86.ActiveCfg = Debug|Win32
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|x86.Build.0 = Debug|Win32
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Debug|x86.Deploy.0 = Debug|Win32
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|ARM.ActiveCfg = Release|ARM
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|ARM.Build.0 = Release|ARM
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|ARM.Deploy.0 = Release|ARM
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|ARM64.ActiveCfg = Release|ARM64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|ARM64.Build.0 = Release|ARM64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|ARM64.Deploy.0 = Release|ARM64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|x64.ActiveCfg = Release|x64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|x64.Build.0 = Release|x64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|x64.Deploy.0 = Release|x64
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|x86.ActiveCfg = Release|Win32
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|x86.Build.0 = Release|Win32
		{7CC542F2-F14C-4339-83AB-5940889EDEA6}.Release|x86.Deploy.0 = Release|Win32
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Debug|ARM.ActiveCfg = Debug|Win32
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Debug|ARM64.ActiveCfg = Debug|Win32
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Debug|x64.ActiveCfg = Debug|x64
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Debug|x64.Build.0 = Debug|x64
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Debug|x86.ActiveCfg = Debug|Win32
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Debug|x86.Build.0 = Debug|Win32
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Release|ARM.ActiveCfg = Release|Win32
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Release|ARM64.ActiveCfg = Release|Win32
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Release|x64.ActiveCfg = Release|x64
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Release|x64.Build.0 = Release|x64
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Release|x86.ActiveCfg = Release|Win32
		{A38675CF-B728-4DD5-9098-D356C33378CC}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0DDC926C-1199-4883-AFE1-D8500BC78DFC}
	EndGlobalSection
EndGlobal

```

`IOCTLDump/IOCTLDump.h`:

```h
#pragma once
#define DUMP_TYPE 40000
#define IOCTL_DUMP_METHOD_BUFFERED \
    CTL_CODE( DUMP_TYPE, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS  )
#define MODE_MANUAL 1
#define MODE_AUTO 2
#define TYPE_FASTIOD 1
#define TYPE_FASTIOR 3
#define TYPE_FASTIOW 4
#define TYPE_DEVICEIOD 2
#define TYPE_DEVICEIOR 5
#define TYPE_DEVICEIOW 6
#define TYPE_FILEIOD 7
#define FUZZ_COUNT 200
#define NT_DEVICE_NAME      L"\\Device\\dIoctl"
#define DOS_DEVICE_NAME     L"\\DosDevices\\dIoctl"
#define USR_DEVICE_NAME		L"\\\\.\\dIoctl"
#define METHOD_FROM_CTL_CODE(ctrlCode)        ((ULONG)(ctrlCode & 3))



struct HookRequest
{
	UNICODE_STRING driverName;
	short mode;
	bool fuzz;
	short type;
	PVOID* address;
};


```

`IOCTLDump/IOCTLDump.inf`:

```inf
;
; IOCTLDump.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=IOCTLDump.cat
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[DefaultInstall.amd64]

[Standard.NT$ARCH$]



[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="IOCTLDump Source Disk"

```

`IOCTLDump/IOCTLDump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7CC542F2-F14C-4339-83AB-5940889EDEA6}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>IOCTLDump</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.22000.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <DriverTargetPlatform>Windows Driver</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <DriverTargetPlatform>Windows Driver</DriverTargetPlatform>
    <SupportsPackaging>false</SupportsPackaging>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <EnableInf2cat>false</EnableInf2cat>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <EnableClangTidyCodeAnalysis>false</EnableClangTidyCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
    <Inf>
      <KmdfVersionNumber />
    </Inf>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="IOCTLDump.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="IOCTLDump.h" />
    <ClInclude Include="IOCTLDump_Kern.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`IOCTLDump/IOCTLDump.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="IOCTLDump.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="IOCTLDump.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IOCTLDump_Kern.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`IOCTLDump/IOCTLDump.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <DbgengKernelMachineName>1903test</DbgengKernelMachineName>
    <TestCertificate>CN="WDKTestCert Christopher,132740934503899814" | D6BB68ED23AC7DDB7CF4A85673B8744A4E570DBB</TestCertificate>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TestCertificate>CN="WDKTestCert Christopher,132741537496104807" | F7323CC138F86DE6FA48147894FE6983C277003F</TestCertificate>
  </PropertyGroup>
</Project>
```

`IOCTLDump/IOCTLDump_Kern.h`:

```h
#pragma once

typedef bool(__stdcall* fastIoCallD)(
	struct _FILE_OBJECT* FileObject,
	BOOLEAN Wait,
	PVOID InputBuffer,
	ULONG InputBufferLength,
	PVOID OutputBuffer,
	ULONG OutputBufferLength,
	ULONG IoControlCode,
	PIO_STATUS_BLOCK IoStatus,
	struct _DEVICE_OBJECT* DeviceObject
	);

typedef bool(__stdcall* fastIoCallRW) (
	struct _FILE_OBJECT* FileObject,
	PLARGE_INTEGER FileOffset,
	ULONG Length,
	BOOLEAN Wait,
	ULONG LockKey,
	PVOID Buffer,
	PIO_STATUS_BLOCK IoStatus,
	struct _DEVICE_OBJECT* DeviceObject
	);

typedef bool(__stdcall* devIoCallRWD)(
	PDEVICE_OBJECT pDeviceObject,
	PIRP Irp
	);




struct IoHooks
{
	UNICODE_STRING driverName;
	PVOID originalFunction;
	PVOID hookedAddress;
};

struct IoHookList
{
	PFAST_MUTEX lock;
	ULONGLONG entry_count;
	ULONGLONG entry_max;
	IoHooks entries[];
};
```

`IOCTLDump/Main.cpp`:

```cpp
#include <ntifs.h>
#include <wdm.h>
#include <stdlib.h>
#include <ntddk.h>
#include "IOCTLDump.h"
#include "IOCTLDump_Kern.h"

#define METHOD_FROM_CTL_CODE(ctrlCode)         ((ULONG)(ctrlCode & 3))

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3



// For Windows 10 support, we redirect ExFreePool2 calls to ExFreePool
#ifdef W10
void ExFreePool2(PVOID pointer, ULONG tag, PVOID arg3, ULONG arg4) {
	return ExFreePool(pointer);
}
#endif


IoHookList* fastIoHooksDArray = NULL;

IoHookList* fastIoHooksRArray = NULL;

IoHookList* fastIoHooksWArray = NULL;

IoHookList* deviceIoHooksDArray = NULL;

IoHookList* deviceIoHooksWArray = NULL;

IoHookList* deviceIoHooksRArray = NULL;

IoHookList* fileIoHooksDArray = NULL;




KIRQL LowerAndCheckIRQL()
{
	KIRQL current = KeGetCurrentIrql();
	if (current > PASSIVE_LEVEL) {
		KeLowerIrql(PASSIVE_LEVEL);
	}
	return current;
}

void RaiseAndCheckIRQL(KIRQL old)
{
	KIRQL current = KeGetCurrentIrql();
	if (current != old)
	{
		KfRaiseIrql(old);
	}
}



/// <summary>
/// File creation helper, creates a file on disk and returns the handle in `fileHandle`
/// </summary>
/// <param name="filePath">
/// File path of the file to create
/// </param>
/// <param name="DesiredAccess">
/// Access mask of the file to create
/// </param>
/// <param name="CreationDisposition">
/// Creation disposition of the file
/// </param>
/// <param name="fileHandle">
/// Pointer that will receive the file handle on a successful file creation
/// </param>
/// <returns>
/// Status of the ZwCreateFile call
/// </returns>
NTSTATUS CreateFileHelper(LPWSTR filePath, ACCESS_MASK DesiredAccess, ULONG CreationDisposition, PHANDLE fileHandle)
{
	UNREFERENCED_PARAMETER(DesiredAccess);
	UNREFERENCED_PARAMETER(CreationDisposition);
	NTSTATUS status;
	OBJECT_ATTRIBUTES objAttr;
	UNICODE_STRING fPath = { 0 };
	RtlCreateUnicodeString(&fPath, filePath);
	InitializeObjectAttributes(&objAttr, &fPath, OBJ_KERNEL_HANDLE, NULL, NULL);
	IO_STATUS_BLOCK statBlock = { 0 };
	status = ZwCreateFile(fileHandle, GENERIC_WRITE | GENERIC_READ | SYNCHRONIZE, &objAttr, &statBlock, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_CREATE, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0);
	RtlFreeUnicodeString(&fPath);
	return status;
}

/// <summary>
/// Creates a folder at the provided path if it does not exist, note this is not recursive (e.g. if path/fold1 does not exist, then creation of path/fold1/fold2 will fail)
/// </summary>
/// <param name="folderPath">
/// Path of the folder to create
/// </param>
/// <returns>
/// Status of the ZwCreateFile call
/// </returns>
NTSTATUS CreateFolder(LPWSTR folderPath)
{
	HANDLE hFolder = 0;
	NTSTATUS status;
	OBJECT_ATTRIBUTES objAttr;
	UNICODE_STRING fPath = { 0 };
	RtlCreateUnicodeString(&fPath, folderPath);
	InitializeObjectAttributes(&objAttr, &fPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
	IO_STATUS_BLOCK statBlock = { 0 };
	status = ZwCreateFile(&hFolder, GENERIC_ALL, &objAttr, &statBlock, NULL, FILE_ATTRIBUTE_NORMAL | SYNCHRONIZE, FILE_SHARE_READ, FILE_OPEN_IF, FILE_DIRECTORY_FILE, NULL, 0);
	RtlFreeUnicodeString(&fPath);
	ZwClose(hFolder);
	if (status != STATUS_SUCCESS) {
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "ERROR: Failed to create folder:%ws.\n", folderPath));
	}
	return status;
}

/// <summary>
/// Our hook function that replaces a target's FastIoControl function, we dump the input buffer and 
/// log the metadata of this call
/// </summary>
bool FastIoHookD(IN struct _FILE_OBJECT* FileObject,
	IN BOOLEAN Wait,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength,
	IN ULONG IoControlCode,
	OUT PIO_STATUS_BLOCK IoStatus,
	IN struct _DEVICE_OBJECT* DeviceObject)
{
	// We need to operate in PASSIVE_IRQL due to our file operations, ensure we're at that IRQL and save the current
	// IRQL so we can restore it later
	KIRQL oldIRQL = LowerAndCheckIRQL();
	// Initialize all our pointers to NULL, this allows us to check if they're non-null in our
	// cleanup phase without concerns of accessing non-initialized pointers.
	// Ensure whenever we free these pointers, we reset it back to NULL
	PUNICODE_STRING pOutputBufLenStringUni = NULL;
	LPWSTR confFileString = NULL;
	HANDLE hConfFile = NULL;
	LPWSTR pConfPath = NULL;
	HANDLE hDataFile = NULL;
	LPWSTR pDataPath = NULL;
	PUNICODE_STRING pInputBufLenStringUni = NULL;
	PUNICODE_STRING pIoctlStringUni = NULL;
	LPWSTR pFullPath = NULL;
	POBJECT_NAME_INFORMATION pObjName = NULL;
	PUNICODE_STRING pDevName = NULL;

	NTSTATUS status;
	// Debugging print 
	UNICODE_STRING drvName = DeviceObject->DriverObject->DriverName;
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Driver Name:%wZ.\n", drvName));

	// Check if the device also has a name
	ULONG nameLen = 0;
	// ObQueryNameString will return the required size in nameLen if exists
	status = ObQueryNameString(DeviceObject, NULL, NULL, &nameLen);
	if (nameLen != 0) {
		// Name exists, lets allocate enough room for it
		pObjName = (POBJECT_NAME_INFORMATION)ExAllocatePool2(POOL_FLAG_NON_PAGED, nameLen,'PMDI');
		if (pObjName != NULL) {
			status = ObQueryNameString(DeviceObject, pObjName, nameLen, &nameLen);
			if (status == STATUS_SUCCESS) {
				if (pObjName->Name.Length == 0)
				{
					ExFreePool(pObjName);
				}
				else {
					// Name exists, lets copy it into pDevName and free the object_name_information object
					pDevName = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
					if (pDevName != NULL) {
						pDevName->Length = pObjName->Name.Length;
						pDevName->MaximumLength = pObjName->Name.MaximumLength;
						pDevName->Buffer = (PWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, pObjName->Name.MaximumLength, 'PMDI');
						if (pDevName->Buffer != NULL) {
							memcpy(pDevName->Buffer, pObjName->Name.Buffer, pObjName->Name.Length);
						}
						// Copy finished, lets free pObjName
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
						// Detect if the copy failed due to a failed allocation
						if (pDevName->Buffer == NULL) {
							// Buffer failed to allocate, free pDevName and set it to NULL so we can detect the failure later
							ExFreePool2(pDevName, 'PMDI', NULL, NULL);
							pDevName = NULL;
						}
					}
					else {
						// pDevName failed to allocate, free pObjName and continue
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
					}
					
				}

			}
			
		}
		
	}
	// Now, pDevName will either be NULL or point to a UNICODE_STRING, If it's NULL, the device name did not exist, or failed to copy
	



	// Base folder for our driver hooks
	LPWSTR pCFolder = L"\\DosDevices\\C:\\DriverHooks";

	// Quick workaround instead of properly parsing slashes and creating the nested
	// folder structure. Ideally in CreateFolder we would check for the existence of each folder
	// in the path and create them if required
	LPWSTR pCFolder_tmp2 = L"\\DosDevices\\C:\\DriverHooks\\Driver";

	SIZE_T fullPathSz = 2048 * sizeof(WCHAR);

	// Used to hold the eventual full path of our data dump, with a max of 2048 characters
	pFullPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, fullPathSz, 'PMDI');
	if (pFullPath == NULL) {
		goto cleanup;
	}
	wcsncpy_s(pFullPath, fullPathSz, pCFolder,wcslen(pCFolder));
	
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ws.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	status = CreateFolder(pCFolder_tmp2);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder2.\n"));

	
	wcsncat(pFullPath, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder.\n"));

	


	pIoctlStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED,  sizeof(UNICODE_STRING), 'PMDI');
	if (pIoctlStringUni == NULL) {
		goto cleanup;
	}
	pIoctlStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  30, 'PMDI');
	if (pIoctlStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pIoctlStringUni->MaximumLength = 30;
	status = RtlIntegerToUnicodeString(IoControlCode, 16, pIoctlStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	LPWSTR hookTypeStr = L"\\fastIOD";
	// Concat ioctl string to full path
	wcsncat(pFullPath, hookTypeStr, wcslen(hookTypeStr));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	wcsncat(pFullPath, L"\\", wcslen(L"\\"));
	wcsncat(pFullPath, pIoctlStringUni->Buffer,pIoctlStringUni->Length / sizeof(WCHAR));

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ls.\n",pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created folder 2.\n"));
	
	pInputBufLenStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
	if (pInputBufLenStringUni == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  30, 'PMDI');
	if (pInputBufLenStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->MaximumLength = 30;

	status = RtlIntegerToUnicodeString(InputBufferLength, 16, pInputBufLenStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	
	if (InputBufferLength > 0)
	{
		// Dump memory
		pDataPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR),'PMDI');
		RtlZeroMemory(pDataPath, 4096 * sizeof(WCHAR));
		wcscat(pDataPath, pFullPath);
		wcsncat(pDataPath, L"\\", wcslen(L"\\"));
		wcsncat(pDataPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / 2);
		LPWSTR dataTerminator = L".data";
		wcsncat(pDataPath, dataTerminator, wcslen(dataTerminator));
		// Create handle to pDataPath
		hDataFile = 0; 
		status = CreateFileHelper(pDataPath, GENERIC_WRITE, FILE_CREATE, &hDataFile);
		if (!NT_SUCCESS(status))
		{
			// File probably exists already, lets quit
			goto cleanup;
		}
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
		pDataPath = NULL;
		// Write data to pDataFile handle
		IO_STATUS_BLOCK statBlock;
		status = ZwWriteFile(hDataFile, NULL, NULL, NULL, &statBlock, InputBuffer, InputBufferLength, NULL, NULL);
		ZwClose(hDataFile);
		hDataFile = NULL;
		if (!NT_SUCCESS(status))
		{
			// Error writing file
			goto cleanup;
		}
	}
	// Write conf
	pConfPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR),'PMDI');
	RtlZeroMemory(pConfPath, 4096 * sizeof(WCHAR));
	wcscpy(pConfPath, pFullPath);
	wcsncat(pConfPath, L"\\", wcslen(L"\\"));
	wcsncat(pConfPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	LPWSTR confTerminator = L".conf";
	wcsncat(pConfPath, confTerminator, wcslen(confTerminator));
	hConfFile = 0;
	status = CreateFileHelper(pConfPath, GENERIC_WRITE, FILE_CREATE, &hConfFile);
	if (!NT_SUCCESS(status))
	{
		// File probably exists already, lets quit
		goto cleanup;
	}
	ExFreePool2(pConfPath,'PMDI', NULL, NULL);
	pConfPath = NULL;
	// Write data to pConfFile handle
	confFileString = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096*sizeof(WCHAR),'PMDI');
	RtlZeroMemory(confFileString, 4096 * sizeof(WCHAR));
	LPWSTR drvHeader = L"DriverName:";
	wcsncpy(confFileString, drvHeader, wcslen(drvHeader));
	wcsncat(confFileString, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	LPWSTR newLine = L"\r\n";
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR typeHeader = L"Type:FASTIOD\r\n";
	wcsncat(confFileString, typeHeader, wcslen(typeHeader));
	LPWSTR ioctlHeader = L"IOCTL:";
	wcsncat(confFileString, ioctlHeader, wcslen(ioctlHeader));
	wcsncat(confFileString, pIoctlStringUni->Buffer, pIoctlStringUni->Length / sizeof(WCHAR));
	ExFreePool2(pIoctlStringUni->Buffer, 'PMDI',NULL,NULL);
	ExFreePool2(pIoctlStringUni,'PMDI', NULL, NULL);
	pIoctlStringUni = NULL;
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR inputLenHeader = L"InputBufferLength:";
	wcsncat(confFileString, inputLenHeader, wcslen(inputLenHeader));
	wcsncat(confFileString, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	ExFreePool2(pInputBufLenStringUni->Buffer,'PMDI', NULL, NULL);
	ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	pInputBufLenStringUni = NULL;
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR outputLenHeader = L"OutputBufferLength:";
	wcsncat(confFileString, outputLenHeader, wcslen(outputLenHeader));

	pOutputBufLenStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
	if (pOutputBufLenStringUni == NULL) {
		goto cleanup;
	}
	pOutputBufLenStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  60, 'PMDI');
	if (pOutputBufLenStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pOutputBufLenStringUni->MaximumLength = 60;
	status = RtlIntegerToUnicodeString(OutputBufferLength, 16, pOutputBufLenStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	wcsncat(confFileString, pOutputBufLenStringUni->Buffer, pOutputBufLenStringUni->Length / sizeof(WCHAR));

	ExFreePool2(pOutputBufLenStringUni->Buffer, 'PMDI',NULL,NULL);
	ExFreePool2(pOutputBufLenStringUni, 'PMDI',NULL,NULL);
	pOutputBufLenStringUni = NULL;

	IO_STATUS_BLOCK statBlock;
	status = ZwWriteFile(hConfFile, NULL, NULL, NULL, &statBlock, confFileString, wcslen(confFileString) * sizeof(WCHAR), NULL, NULL);
	ZwClose(hConfFile);
	hConfFile = NULL;
	goto cleanup;
cleanup:
	// Check for NULL pointers and skip them, if we have a pointer that's non-null we free it, or if its a UNICODE type, we check if ->Buffer is NULL,
	// if not then we free that internal buffer first, then the UNICODE pointer.
	// Make sure we initialize all pointers as NULL at the start of this function, so that they may exist here for checking if we hit an error path and 
	// jump here early.
	if (confFileString != NULL) {
		ExFreePool2(confFileString, 'PMDI', NULL, NULL);
	}
	if (pConfPath != NULL) {
		ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	}
	if (pDataPath != NULL) {
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
	}
	if (pFullPath != NULL) {
		ExFreePool2(pFullPath, 'PMDI', NULL, NULL);
	}
	if (pObjName != NULL) {
		ExFreePool2(pObjName, 'PMDI', NULL, NULL);
	}
	if (pOutputBufLenStringUni != NULL) {
		if (pOutputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pOutputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pOutputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pInputBufLenStringUni != NULL) {
		if (pInputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pIoctlStringUni != NULL) {
		if (pIoctlStringUni->Buffer != NULL) {
			ExFreePool2(pIoctlStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pIoctlStringUni, 'PMDI', NULL, NULL);
	}
	if (pDevName != NULL) {
		if (pDevName->Buffer != NULL) {
			ExFreePool2(pDevName->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pDevName, 'PMDI', NULL, NULL);
	}
	// Check and close handles
	if (hConfFile != NULL) {
		ZwClose(hConfFile);
	}
	if (hDataFile != NULL) {
		ZwClose(hDataFile);
	}
	goto End;

End:
	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = fastIoHooksDArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);

	// Call original overwritten address
	for (int i = 0; i < hookList->entry_count; i++)
	{
		if (RtlEqualUnicodeString(&hookList->entries[i].driverName, &drvName, false))
		{
			fastIoCallD origFuncCall = (fastIoCallD)hookList->entries[i].originalFunction;
			// Release lock
			ExReleaseFastMutex(hookList->lock);
			// Revert IRQL to value when we were called
			RaiseAndCheckIRQL(oldIRQL);
			// Call the original function now that we've logged it, then
			// return to caller
			return origFuncCall(FileObject,
				Wait,
				InputBuffer,
				InputBufferLength,
				OutputBuffer,
				OutputBufferLength,
				IoControlCode,
				IoStatus,
				DeviceObject);
		}
	}
	// Release lock
	ExReleaseFastMutex(hookList->lock);
	// Rever IRQL
	RaiseAndCheckIRQL(oldIRQL);
	// Oops, cant find original hook address as something went wrong. We should never hit here, for debug purposes we crash the system. Alternatively, return 
	// a fake result to continue system execution
	__debugbreak();
	//return false;
}


bool FastIoHookW(IN struct _FILE_OBJECT* FileObject,
	IN PLARGE_INTEGER FileOffset,
	IN ULONG Length,
	IN BOOLEAN Wait,
	IN ULONG LockKey,
	OUT PVOID Buffer,
	OUT PIO_STATUS_BLOCK IoStatus,
	IN struct _DEVICE_OBJECT* DeviceObject)
{
	// We need to operate in PASSIVE_IRQL due to our file operations, ensure we're at that IRQL and save the current
	// IRQL so we can restore it later
	KIRQL oldIRQL = LowerAndCheckIRQL();
	// Initialize all our pointers to NULL, this allows us to check if they're non-null in our
	// cleanup phase without concerns of accessing non-initialized pointers.
	// Ensure whenever we free these pointers, we reset it back to NULL
	PUNICODE_STRING pOutputBufLenStringUni = NULL;
	LPWSTR confFileString = NULL;
	HANDLE hConfFile = NULL;
	LPWSTR pConfPath = NULL;
	HANDLE hDataFile = NULL;
	LPWSTR pDataPath = NULL;
	PUNICODE_STRING pInputBufLenStringUni = NULL;
	PUNICODE_STRING pIoctlStringUni = NULL;
	LPWSTR pFullPath = NULL;
	POBJECT_NAME_INFORMATION pObjName = NULL;
	PUNICODE_STRING pDevName = NULL;

	NTSTATUS status;
	// Debugging print 
	UNICODE_STRING drvName = DeviceObject->DriverObject->DriverName;
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Driver Name:%wZ.\n", drvName));

	// Check if the device also has a name
	ULONG nameLen = 0;
	// ObQueryNameString will return the required size in nameLen if exists
	status = ObQueryNameString(DeviceObject, NULL, NULL, &nameLen);
	if (nameLen != 0) {
		// Name exists, lets allocate enough room for it
		pObjName = (POBJECT_NAME_INFORMATION)ExAllocatePool2(POOL_FLAG_NON_PAGED, nameLen, 'PMDI');
		if (pObjName != NULL) {
			status = ObQueryNameString(DeviceObject, pObjName, nameLen, &nameLen);
			if (status == STATUS_SUCCESS) {
				if (pObjName->Name.Length == 0)
				{
					ExFreePool(pObjName);
				}
				else {
					// Name exists, lets copy it into pDevName and free the object_name_information object
					pDevName = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
					if (pDevName != NULL) {
						pDevName->Length = pObjName->Name.Length;
						pDevName->MaximumLength = pObjName->Name.MaximumLength;
						pDevName->Buffer = (PWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, pObjName->Name.MaximumLength, 'PMDI');
						if (pDevName->Buffer != NULL) {
							memcpy(pDevName->Buffer, pObjName->Name.Buffer, pObjName->Name.Length);
						}
						// Copy finished, lets free pObjName
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
						// Detect if the copy failed due to a failed allocation
						if (pDevName->Buffer == NULL) {
							// Buffer failed to allocate, free pDevName and set it to NULL so we can detect the failure later
							ExFreePool2(pDevName, 'PMDI', NULL, NULL);
							pDevName = NULL;
						}
					}
					else {
						// pDevName failed to allocate, free pObjName and continue
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
					}

				}

			}

		}

	}
	// Now, pDevName will either be NULL or point to a UNICODE_STRING, If it's NULL, the device name did not exist, or failed to copy




	// Base folder for our driver hooks
	LPWSTR pCFolder = L"\\DosDevices\\C:\\DriverHooks";

	// Quick workaround instead of properly parsing slashes and creating the nested
	// folder structure. Ideally in CreateFolder we would check for the existence of each folder
	// in the path and create them if required
	LPWSTR pCFolder_tmp2 = L"\\DosDevices\\C:\\DriverHooks\\Driver";

	SIZE_T fullPathSz = 2048 * sizeof(WCHAR);

	// Used to hold the eventual full path of our data dump, with a max of 2048 characters
	pFullPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  fullPathSz, 'PMDI');
	if (pFullPath == NULL) {
		goto cleanup;
	}
	wcsncpy_s(pFullPath, fullPathSz, pCFolder, wcslen(pCFolder));

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ws.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	status = CreateFolder(pCFolder_tmp2);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder2.\n"));

	
	wcsncat(pFullPath, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder.\n"));

	

	LPWSTR hookTypeStr = L"\\fastIOW";
	// Concat ioctl string to full path
	wcsncat(pFullPath, hookTypeStr, wcslen(hookTypeStr));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%s.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created folder 2.\n"));

	pInputBufLenStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
	if (pInputBufLenStringUni == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  30, 'PMDI');
	if (pInputBufLenStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->MaximumLength = 30;

	status = RtlIntegerToUnicodeString(Length, 16, pInputBufLenStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}


	if (Length > 0)
	{
		// Dump memory
		pDataPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
		RtlZeroMemory(pDataPath, 4096 * sizeof(WCHAR));
		wcscat(pDataPath, pFullPath);
		wcsncat(pDataPath, L"\\", wcslen(L"\\"));
		wcsncat(pDataPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / 2);
		LPWSTR dataTerminator = L".data";
		wcsncat(pDataPath, dataTerminator, wcslen(dataTerminator));
		// Create handle to pDataPath
		hDataFile = 0;
		status = CreateFileHelper(pDataPath, GENERIC_WRITE, FILE_CREATE, &hDataFile);
		if (!NT_SUCCESS(status))
		{
			// File probably exists already, lets quit
			goto cleanup;
		}
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
		pDataPath = NULL;
		// Write data to pDataFile handle
		IO_STATUS_BLOCK statBlock;
		status = ZwWriteFile(hDataFile, NULL, NULL, NULL, &statBlock, Buffer, Length, NULL, NULL);
		ZwClose(hDataFile);
		hDataFile = NULL;
		if (!NT_SUCCESS(status))
		{
			// Error writing file
			goto cleanup;
		}
	}
	// Write conf
	pConfPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(pConfPath, 4096 * sizeof(WCHAR));
	wcscpy(pConfPath, pFullPath);
	wcsncat(pConfPath, L"\\", wcslen(L"\\"));
	wcsncat(pConfPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	LPWSTR confTerminator = L".conf";
	wcsncat(pConfPath, confTerminator, wcslen(confTerminator));
	hConfFile = 0;
	status = CreateFileHelper(pConfPath, GENERIC_WRITE, FILE_CREATE, &hConfFile);
	if (!NT_SUCCESS(status))
	{
		// File probably exists already, lets quit
		goto cleanup;
	}
	ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	pConfPath = NULL;
	// Write data to pConfFile handle
	confFileString = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(confFileString, 4096 * sizeof(WCHAR));
	LPWSTR drvHeader = L"DriverName:";
	wcsncpy(confFileString, drvHeader, wcslen(drvHeader));
	wcsncat(confFileString, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	LPWSTR newLine = L"\r\n";
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR typeHeader = L"Type:FASTIOW\r\n";
	wcsncat(confFileString, typeHeader, wcslen(typeHeader));
	LPWSTR ioctlHeader = L"IOCTL:";
	wcsncat(confFileString, ioctlHeader, wcslen(ioctlHeader));
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR inputLenHeader = L"InputBufferLength:";
	wcsncat(confFileString, inputLenHeader, wcslen(inputLenHeader));
	wcsncat(confFileString, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
	ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	pInputBufLenStringUni = NULL;
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR outputLenHeader = L"OutputBufferLength:";
	wcsncat(confFileString, outputLenHeader, wcslen(outputLenHeader));

	IO_STATUS_BLOCK statBlock;
	status = ZwWriteFile(hConfFile, NULL, NULL, NULL, &statBlock, confFileString, wcslen(confFileString) * sizeof(WCHAR), NULL, NULL);
	ZwClose(hConfFile);
	hConfFile = NULL;
	goto cleanup;
cleanup:
	// Check for NULL pointers and skip them, if we have a pointer that's non-null we free it, or if its a UNICODE type, we check if ->Buffer is NULL,
	// if not then we free that internal buffer first, then the UNICODE pointer.
	// Make sure we initialize all pointers as NULL at the start of this function, so that they may exist here for checking if we hit an error path and 
	// jump here early.
	if (confFileString != NULL) {
		ExFreePool2(confFileString, 'PMDI', NULL, NULL);
	}
	if (pConfPath != NULL) {
		ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	}
	if (pDataPath != NULL) {
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
	}
	if (pFullPath != NULL) {
		ExFreePool2(pFullPath, 'PMDI', NULL, NULL);
	}
	if (pObjName != NULL) {
		ExFreePool2(pObjName, 'PMDI', NULL, NULL);
	}
	if (pOutputBufLenStringUni != NULL) {
		if (pOutputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pOutputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pOutputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pInputBufLenStringUni != NULL) {
		if (pInputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pIoctlStringUni != NULL) {
		if (pIoctlStringUni->Buffer != NULL) {
			ExFreePool2(pIoctlStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pIoctlStringUni, 'PMDI', NULL, NULL);
	}
	if (pDevName != NULL) {
		if (pDevName->Buffer != NULL) {
			ExFreePool2(pDevName->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pDevName, 'PMDI', NULL, NULL);
	}
	// Check and close handles
	if (hConfFile != NULL) {
		ZwClose(hConfFile);
	}
	if (hDataFile != NULL) {
		ZwClose(hDataFile);
	}
	goto End;

End:
	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = fastIoHooksWArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);

	// Call original overwritten address
	for (int i = 0; i < hookList->entry_count; i++)
	{
		if (RtlEqualUnicodeString(&hookList->entries[i].driverName, &drvName, false))
		{
			fastIoCallRW origFuncCall = (fastIoCallRW)hookList->entries[i].originalFunction;
			// Release lock
			ExReleaseFastMutex(hookList->lock);
			// Revert IRQL to value when we were called
			RaiseAndCheckIRQL(oldIRQL);
			// Call the original function now that we've logged it, then
			// return to caller
			return origFuncCall(FileObject,
				FileOffset,
				Length,
				Wait,
				LockKey,
				Buffer,
				IoStatus,
				DeviceObject);
		}
	}
	// Release lock
	ExReleaseFastMutex(hookList->lock);
	// Rever IRQL
	RaiseAndCheckIRQL(oldIRQL);
	// Oops, cant find original hook address as something went wrong. We should never hit here, for debug purposes we crash the system. Alternatively, return 
	// a fake result to continue system execution
	__debugbreak();
	//return false;
}






bool FastIoHookR(IN struct _FILE_OBJECT* FileObject,
	IN PLARGE_INTEGER FileOffset,
	IN ULONG Length,
	IN BOOLEAN Wait,
	IN ULONG LockKey,
	OUT PVOID Buffer,
	OUT PIO_STATUS_BLOCK IoStatus,
	IN struct _DEVICE_OBJECT* DeviceObject)
{
	// We need to operate in PASSIVE_IRQL due to our file operations, ensure we're at that IRQL and save the current
	// IRQL so we can restore it later
	KIRQL oldIRQL = LowerAndCheckIRQL();
	// Initialize all our pointers to NULL, this allows us to check if they're non-null in our
	// cleanup phase without concerns of accessing non-initialized pointers.
	// Ensure whenever we free these pointers, we reset it back to NULL
	PUNICODE_STRING pOutputBufLenStringUni = NULL;
	LPWSTR confFileString = NULL;
	HANDLE hConfFile = NULL;
	LPWSTR pConfPath = NULL;
	HANDLE hDataFile = NULL;
	LPWSTR pDataPath = NULL;
	PUNICODE_STRING pInputBufLenStringUni = NULL;
	PUNICODE_STRING pIoctlStringUni = NULL;
	LPWSTR pFullPath = NULL;
	POBJECT_NAME_INFORMATION pObjName = NULL;
	PUNICODE_STRING pDevName = NULL;

	NTSTATUS status;
	// Debugging print 
	UNICODE_STRING drvName = DeviceObject->DriverObject->DriverName;
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Driver Name:%wZ.\n", drvName));

	// Check if the device also has a name
	ULONG nameLen = 0;
	// ObQueryNameString will return the required size in nameLen if exists
	status = ObQueryNameString(DeviceObject, NULL, NULL, &nameLen);
	if (nameLen != 0) {
		// Name exists, lets allocate enough room for it
		pObjName = (POBJECT_NAME_INFORMATION)ExAllocatePool2(POOL_FLAG_NON_PAGED, nameLen, 'PMDI');
		if (pObjName != NULL) {
			status = ObQueryNameString(DeviceObject, pObjName, nameLen, &nameLen);
			if (status == STATUS_SUCCESS) {
				if (pObjName->Name.Length == 0)
				{
					ExFreePool(pObjName);
				}
				else {
					// Name exists, lets copy it into pDevName and free the object_name_information object
					pDevName = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
					if (pDevName != NULL) {
						pDevName->Length = pObjName->Name.Length;
						pDevName->MaximumLength = pObjName->Name.MaximumLength;
						pDevName->Buffer = (PWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, pObjName->Name.MaximumLength, 'PMDI');
						if (pDevName->Buffer != NULL) {
							memcpy(pDevName->Buffer, pObjName->Name.Buffer, pObjName->Name.Length);
						}
						// Copy finished, lets free pObjName
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
						// Detect if the copy failed due to a failed allocation
						if (pDevName->Buffer == NULL) {
							// Buffer failed to allocate, free pDevName and set it to NULL so we can detect the failure later
							ExFreePool2(pDevName, 'PMDI', NULL, NULL);
							pDevName = NULL;
						}
					}
					else {
						// pDevName failed to allocate, free pObjName and continue
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
					}

				}

			}

		}

	}
	// Now, pDevName will either be NULL or point to a UNICODE_STRING, If it's NULL, the device name did not exist, or failed to copy




	// Base folder for our driver hooks
	LPWSTR pCFolder = L"\\DosDevices\\C:\\DriverHooks";

	// Quick workaround instead of properly parsing slashes and creating the nested
	// folder structure. Ideally in CreateFolder we would check for the existence of each folder
	// in the path and create them if required
	LPWSTR pCFolder_tmp2 = L"\\DosDevices\\C:\\DriverHooks\\Driver";

	SIZE_T fullPathSz = 2048 * sizeof(WCHAR);

	// Used to hold the eventual full path of our data dump, with a max of 2048 characters
	pFullPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  fullPathSz, 'PMDI');
	if (pFullPath == NULL) {
		goto cleanup;
	}
	wcsncpy_s(pFullPath, fullPathSz, pCFolder, wcslen(pCFolder));

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ws.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	status = CreateFolder(pCFolder_tmp2);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder2.\n"));

	
	wcsncat(pFullPath, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder.\n"));

	

	LPWSTR hookTypeStr = L"\\fastIOR";
	// Concat ioctl string to full path
	wcsncat(pFullPath, hookTypeStr, wcslen(hookTypeStr));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%s.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created folder 2.\n"));

	pInputBufLenStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING),'PMDI');
	if (pInputBufLenStringUni == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  30, 'PMDI');
	if (pInputBufLenStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->MaximumLength = 30;

	status = RtlIntegerToUnicodeString(Length, 16, pInputBufLenStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}


	if (Length > 0)
	{
		// Dump memory
		pDataPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
		RtlZeroMemory(pDataPath, 4096 * sizeof(WCHAR));
		wcscat(pDataPath, pFullPath);
		wcsncat(pDataPath, L"\\", wcslen(L"\\"));
		wcsncat(pDataPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / 2);
		LPWSTR dataTerminator = L".data";
		wcsncat(pDataPath, dataTerminator, wcslen(dataTerminator));
		// Create handle to pDataPath
		hDataFile = 0;
		status = CreateFileHelper(pDataPath, GENERIC_WRITE, FILE_CREATE, &hDataFile);
		if (!NT_SUCCESS(status))
		{
			// File probably exists already, lets quit
			goto cleanup;
		}
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
		pDataPath = NULL;
		// We dump the buffer later, as we need the target to fill in the buffer first.
	}
	// Write conf
	pConfPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(pConfPath, 4096 * sizeof(WCHAR));
	wcscpy(pConfPath, pFullPath);
	wcsncat(pConfPath, L"\\", wcslen(L"\\"));
	wcsncat(pConfPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	LPWSTR confTerminator = L".conf";
	wcsncat(pConfPath, confTerminator, wcslen(confTerminator));
	hConfFile = 0;
	status = CreateFileHelper(pConfPath, GENERIC_WRITE, FILE_CREATE, &hConfFile);
	if (!NT_SUCCESS(status))
	{
		// File probably exists already, lets quit
		goto cleanup;
	}
	ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	pConfPath = NULL;
	// Write data to pConfFile handle
	confFileString = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(confFileString, 4096 * sizeof(WCHAR));
	LPWSTR drvHeader = L"DriverName:";
	wcsncpy(confFileString, drvHeader, wcslen(drvHeader));
	wcsncat(confFileString, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	LPWSTR newLine = L"\r\n";
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR typeHeader = L"Type:FASTIOR\r\n";
	wcsncat(confFileString, typeHeader, wcslen(typeHeader));
	LPWSTR ioctlHeader = L"IOCTL:";
	wcsncat(confFileString, ioctlHeader, wcslen(ioctlHeader));
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR inputLenHeader = L"InputBufferLength:";
	wcsncat(confFileString, inputLenHeader, wcslen(inputLenHeader));
	wcsncat(confFileString, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
	ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	pInputBufLenStringUni = NULL;
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR outputLenHeader = L"OutputBufferLength:";
	wcsncat(confFileString, outputLenHeader, wcslen(outputLenHeader));

	IO_STATUS_BLOCK statBlock;
	status = ZwWriteFile(hConfFile, NULL, NULL, NULL, &statBlock, confFileString, wcslen(confFileString) * sizeof(WCHAR), NULL, NULL);
	ZwClose(hConfFile);
	hConfFile = NULL;
	goto cleanup;
cleanup:
	// Check for NULL pointers and skip them, if we have a pointer that's non-null we free it, or if its a UNICODE type, we check if ->Buffer is NULL,
	// if not then we free that internal buffer first, then the UNICODE pointer.
	// Make sure we initialize all pointers as NULL at the start of this function, so that they may exist here for checking if we hit an error path and 
	// jump here early.
	if (confFileString != NULL) {
		ExFreePool2(confFileString, 'PMDI', NULL, NULL);
	}
	if (pConfPath != NULL) {
		ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	}
	if (pDataPath != NULL) {
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
	}
	if (pFullPath != NULL) {
		ExFreePool2(pFullPath, 'PMDI', NULL, NULL);
	}
	if (pObjName != NULL) {
		ExFreePool2(pObjName, 'PMDI', NULL, NULL);
	}
	if (pOutputBufLenStringUni != NULL) {
		if (pOutputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pOutputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pOutputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pInputBufLenStringUni != NULL) {
		if (pInputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pIoctlStringUni != NULL) {
		if (pIoctlStringUni->Buffer != NULL) {
			ExFreePool2(pIoctlStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pIoctlStringUni, 'PMDI', NULL, NULL);
	}
	if (pDevName != NULL) {
		if (pDevName->Buffer != NULL) {
			ExFreePool2(pDevName->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pDevName, 'PMDI', NULL, NULL);
	}
	// Check and close handles
	if (hConfFile != NULL) {
		ZwClose(hConfFile);
	}
	
	goto End;

End:
	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = fastIoHooksRArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);

	// Call original overwritten address
	for (int i = 0; i < hookList->entry_count; i++)
	{
		if (RtlEqualUnicodeString(&hookList->entries[i].driverName, &drvName, false))
		{
			fastIoCallRW origFuncCall = (fastIoCallRW)hookList->entries[i].originalFunction;
			// Release lock
			ExReleaseFastMutex(hookList->lock);
			// Revert IRQL to value when we were called
			RaiseAndCheckIRQL(oldIRQL);
			// Call the original function now that we've logged it, then
			// return to caller
			bool res = origFuncCall(FileObject,
				FileOffset,
				Length,
				Wait,
				LockKey,
				Buffer,
				IoStatus,
				DeviceObject);
			if (Length > 0 && hDataFile != NULL) {

				LowerAndCheckIRQL();
				// Write data to pDataFile handle
				IO_STATUS_BLOCK statBlock;
				status = ZwWriteFile(hDataFile, NULL, NULL, NULL, &statBlock, Buffer, Length, NULL, NULL);
				ZwClose(hDataFile);
				hDataFile = NULL;
				RaiseAndCheckIRQL(oldIRQL);
			}
			return res;
			

		}
	}
	// Release lock
	ExReleaseFastMutex(hookList->lock);
	// Rever IRQL
	RaiseAndCheckIRQL(oldIRQL);
	// Oops, cant find original hook address as something went wrong. We should never hit here, for debug purposes we crash the system. Alternatively, return 
	// a fake result to continue system execution
	__debugbreak();
	//return false;
}


NTSTATUS DeviceIoHookW(_DEVICE_OBJECT* DeviceObject,
	_IRP* Irp)
{
	// We need to operate in PASSIVE_IRQL due to our file operations, ensure we're at that IRQL and save the current
	// IRQL so we can restore it later
	KIRQL oldIRQL = LowerAndCheckIRQL();
	PIO_STACK_LOCATION pIoStackLocation;
	pIoStackLocation = IoGetCurrentIrpStackLocation(Irp);
	// Initialize all our pointers to NULL, this allows us to check if they're non-null in our
	// cleanup phase without concerns of accessing non-initialized pointers.
	// Ensure whenever we free these pointers, we reset it back to NULL
	PUNICODE_STRING pOutputBufLenStringUni = NULL;
	LPWSTR confFileString = NULL;
	HANDLE hConfFile = NULL;
	LPWSTR pConfPath = NULL;
	HANDLE hDataFile = NULL;
	LPWSTR pDataPath = NULL;
	PUNICODE_STRING pInputBufLenStringUni = NULL;
	PUNICODE_STRING pIoctlStringUni = NULL;
	LPWSTR pFullPath = NULL;
	POBJECT_NAME_INFORMATION pObjName = NULL;
	PUNICODE_STRING pDevName = NULL;

	NTSTATUS status;
	// Debugging print 
	UNICODE_STRING drvName = DeviceObject->DriverObject->DriverName;
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Driver Name:%wZ.\n", drvName));

	// Check if the device also has a name
	ULONG nameLen = 0;
	// ObQueryNameString will return the required size in nameLen if exists
	status = ObQueryNameString(DeviceObject, NULL, NULL, &nameLen);
	if (nameLen != 0) {
		// Name exists, lets allocate enough room for it
		pObjName = (POBJECT_NAME_INFORMATION)ExAllocatePool2(POOL_FLAG_NON_PAGED, nameLen, 'PMDI');
		if (pObjName != NULL) {
			status = ObQueryNameString(DeviceObject, pObjName, nameLen, &nameLen);
			if (status == STATUS_SUCCESS) {
				if (pObjName->Name.Length == 0)
				{
					ExFreePool(pObjName);
				}
				else {
					// Name exists, lets copy it into pDevName and free the object_name_information object
					pDevName = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
					if (pDevName != NULL) {
						pDevName->Length = pObjName->Name.Length;
						pDevName->MaximumLength = pObjName->Name.MaximumLength;
						pDevName->Buffer = (PWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, pObjName->Name.MaximumLength, 'PMDI');
						if (pDevName->Buffer != NULL) {
							memcpy(pDevName->Buffer, pObjName->Name.Buffer, pObjName->Name.Length);
						}
						// Copy finished, lets free pObjName
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
						// Detect if the copy failed due to a failed allocation
						if (pDevName->Buffer == NULL) {
							// Buffer failed to allocate, free pDevName and set it to NULL so we can detect the failure later
							ExFreePool2(pDevName, 'PMDI', NULL, NULL);
							pDevName = NULL;
						}
					}
					else {
						// pDevName failed to allocate, free pObjName and continue
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
					}

				}

			}

		}

	}
	// Now, pDevName will either be NULL or point to a UNICODE_STRING, If it's NULL, the device name did not exist, or failed to copy




	// Base folder for our driver hooks
	LPWSTR pCFolder = L"\\DosDevices\\C:\\DriverHooks";

	// Quick workaround instead of properly parsing slashes and creating the nested
	// folder structure. Ideally in CreateFolder we would check for the existence of each folder
	// in the path and create them if required
	LPWSTR pCFolder_tmp2 = L"\\DosDevices\\C:\\DriverHooks\\Driver";

	SIZE_T fullPathSz = 2048 * sizeof(WCHAR);

	// Used to hold the eventual full path of our data dump, with a max of 2048 characters
	pFullPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  fullPathSz, 'PMDI');
	if (pFullPath == NULL) {
		goto cleanup;
	}
	wcsncpy_s(pFullPath, fullPathSz, pCFolder, wcslen(pCFolder));

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ws.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	status = CreateFolder(pCFolder_tmp2);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder2.\n"));

	
	wcsncat(pFullPath, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder.\n"));

	

	LPWSTR hookTypeStr = L"\\devIOW";
	// Concat ioctl string to full path
	wcsncat(pFullPath, hookTypeStr, wcslen(hookTypeStr));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ls.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created folder 2.\n"));

	pInputBufLenStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
	if (pInputBufLenStringUni == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  30, 'PMDI');
	if (pInputBufLenStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->MaximumLength = 30;

	status = RtlIntegerToUnicodeString(pIoStackLocation->Parameters.Write.Length, 16, pInputBufLenStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}


	if (pIoStackLocation->Parameters.Write.Length > 0)
	{
		// Dump memory
		pDataPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
		RtlZeroMemory(pDataPath, 4096 * sizeof(WCHAR));
		wcscat(pDataPath, pFullPath);
		wcsncat(pDataPath, L"\\", wcslen(L"\\"));
		wcsncat(pDataPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / 2);
		LPWSTR dataTerminator = L".data";
		wcsncat(pDataPath, dataTerminator, wcslen(dataTerminator));
		// Create handle to pDataPath
		hDataFile = 0;
		status = CreateFileHelper(pDataPath, GENERIC_WRITE, FILE_CREATE, &hDataFile);
		if (!NT_SUCCESS(status))
		{
			// File probably exists already, lets quit
			goto cleanup;
		}
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
		pDataPath = NULL;
		// Write data to pDataFile handle
		IO_STATUS_BLOCK statBlock;
		status = ZwWriteFile(hDataFile, NULL, NULL, NULL, &statBlock, Irp->AssociatedIrp.SystemBuffer, pIoStackLocation->Parameters.Write.Length, NULL, NULL);
		ZwClose(hDataFile);
		hDataFile = NULL;
		if (!NT_SUCCESS(status))
		{
			// Error writing file
			goto cleanup;
		}
	}
	// Write conf
	pConfPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(pConfPath, 4096 * sizeof(WCHAR));
	wcscpy(pConfPath, pFullPath);
	wcsncat(pConfPath, L"\\", wcslen(L"\\"));
	wcsncat(pConfPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	LPWSTR confTerminator = L".conf";
	wcsncat(pConfPath, confTerminator, wcslen(confTerminator));
	hConfFile = 0;
	status = CreateFileHelper(pConfPath, GENERIC_WRITE, FILE_CREATE, &hConfFile);
	if (!NT_SUCCESS(status))
	{
		// File probably exists already, lets quit
		goto cleanup;
	}
	ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	pConfPath = NULL;
	// Write data to pConfFile handle
	confFileString = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(confFileString, 4096 * sizeof(WCHAR));
	LPWSTR drvHeader = L"DriverName:";
	wcsncpy(confFileString, drvHeader, wcslen(drvHeader));
	wcsncat(confFileString, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	LPWSTR newLine = L"\r\n";
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR typeHeader = L"Type:DEVIOW\r\n";
	wcsncat(confFileString, typeHeader, wcslen(typeHeader));
	LPWSTR ioctlHeader = L"IOCTL:";
	wcsncat(confFileString, ioctlHeader, wcslen(ioctlHeader));
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR inputLenHeader = L"InputBufferLength:";
	wcsncat(confFileString, inputLenHeader, wcslen(inputLenHeader));
	wcsncat(confFileString, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
	ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	pInputBufLenStringUni = NULL;
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR outputLenHeader = L"OutputBufferLength:";
	wcsncat(confFileString, outputLenHeader, wcslen(outputLenHeader));

	IO_STATUS_BLOCK statBlock;
	status = ZwWriteFile(hConfFile, NULL, NULL, NULL, &statBlock, confFileString, wcslen(confFileString) * sizeof(WCHAR), NULL, NULL);
	ZwClose(hConfFile);
	hConfFile = NULL;
	goto cleanup;
cleanup:
	// Check for NULL pointers and skip them, if we have a pointer that's non-null we free it, or if its a UNICODE type, we check if ->Buffer is NULL,
	// if not then we free that internal buffer first, then the UNICODE pointer.
	// Make sure we initialize all pointers as NULL at the start of this function, so that they may exist here for checking if we hit an error path and 
	// jump here early.
	if (confFileString != NULL) {
		ExFreePool2(confFileString, 'PMDI', NULL, NULL);
	}
	if (pConfPath != NULL) {
		ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	}
	if (pDataPath != NULL) {
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
	}
	if (pFullPath != NULL) {
		ExFreePool2(pFullPath, 'PMDI', NULL, NULL);
	}
	if (pObjName != NULL) {
		ExFreePool2(pObjName, 'PMDI', NULL, NULL);
	}
	if (pOutputBufLenStringUni != NULL) {
		if (pOutputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pOutputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pOutputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pInputBufLenStringUni != NULL) {
		if (pInputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pIoctlStringUni != NULL) {
		if (pIoctlStringUni->Buffer != NULL) {
			ExFreePool2(pIoctlStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pIoctlStringUni, 'PMDI', NULL, NULL);
	}
	if (pDevName != NULL) {
		if (pDevName->Buffer != NULL) {
			ExFreePool2(pDevName->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pDevName, 'PMDI', NULL, NULL);
	}
	// Check and close handles
	if (hConfFile != NULL) {
		ZwClose(hConfFile);
	}
	if (hDataFile != NULL) {
		ZwClose(hDataFile);
	}
	goto End;

End:
	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = deviceIoHooksWArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);

	// Call original overwritten address
	for (int i = 0; i < hookList->entry_count; i++)
	{
		if (RtlEqualUnicodeString(&hookList->entries[i].driverName, &drvName, false))
		{
			devIoCallRWD  origFuncCall = (devIoCallRWD)hookList->entries[i].originalFunction;
			// Release lock
			ExReleaseFastMutex(hookList->lock);
			// Revert IRQL to value when we were called
			RaiseAndCheckIRQL(oldIRQL);
			// Call the original function now that we've logged it, then
			// return to caller
			return origFuncCall(DeviceObject, Irp);
		}
	}
	// Release lock
	ExReleaseFastMutex(hookList->lock);
	// Rever IRQL
	RaiseAndCheckIRQL(oldIRQL);
	// Oops, cant find original hook address as something went wrong. We should never hit here, for debug purposes we crash the system. Alternatively, return 
	// a fake result to continue system execution
	__debugbreak();
	//return false;
}


NTSTATUS DeviceIoHookR(_DEVICE_OBJECT* DeviceObject,
	_IRP* Irp)
{
	// We need to operate in PASSIVE_IRQL due to our file operations, ensure we're at that IRQL and save the current
	// IRQL so we can restore it later
	KIRQL oldIRQL = LowerAndCheckIRQL();
	PIO_STACK_LOCATION pIoStackLocation;
	pIoStackLocation = IoGetCurrentIrpStackLocation(Irp);
	// Initialize all our pointers to NULL, this allows us to check if they're non-null in our
	// cleanup phase without concerns of accessing non-initialized pointers.
	// Ensure whenever we free these pointers, we reset it back to NULL
	PUNICODE_STRING pOutputBufLenStringUni = NULL;
	LPWSTR confFileString = NULL;
	HANDLE hConfFile = NULL;
	LPWSTR pConfPath = NULL;
	HANDLE hDataFile = NULL;
	LPWSTR pDataPath = NULL;
	PUNICODE_STRING pInputBufLenStringUni = NULL;
	PUNICODE_STRING pIoctlStringUni = NULL;
	LPWSTR pFullPath = NULL;
	POBJECT_NAME_INFORMATION pObjName = NULL;
	PUNICODE_STRING pDevName = NULL;

	NTSTATUS status;
	// Debugging print 
	UNICODE_STRING drvName = DeviceObject->DriverObject->DriverName;
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Driver Name:%wZ.\n", drvName));

	// Check if the device also has a name
	ULONG nameLen = 0;
	// ObQueryNameString will return the required size in nameLen if exists
	status = ObQueryNameString(DeviceObject, NULL, NULL, &nameLen);
	if (nameLen != 0) {
		// Name exists, lets allocate enough room for it
		pObjName = (POBJECT_NAME_INFORMATION)ExAllocatePool2(POOL_FLAG_NON_PAGED, nameLen, 'PMDI');
		if (pObjName != NULL) {
			status = ObQueryNameString(DeviceObject, pObjName, nameLen, &nameLen);
			if (status == STATUS_SUCCESS) {
				if (pObjName->Name.Length == 0)
				{
					ExFreePool(pObjName);
				}
				else {
					// Name exists, lets copy it into pDevName and free the object_name_information object
					pDevName = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
					if (pDevName != NULL) {
						pDevName->Length = pObjName->Name.Length;
						pDevName->MaximumLength = pObjName->Name.MaximumLength;
						pDevName->Buffer = (PWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, pObjName->Name.MaximumLength, 'PMDI');
						if (pDevName->Buffer != NULL) {
							memcpy(pDevName->Buffer, pObjName->Name.Buffer, pObjName->Name.Length);
						}
						// Copy finished, lets free pObjName
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
						// Detect if the copy failed due to a failed allocation
						if (pDevName->Buffer == NULL) {
							// Buffer failed to allocate, free pDevName and set it to NULL so we can detect the failure later
							ExFreePool2(pDevName, 'PMDI', NULL, NULL);
							pDevName = NULL;
						}
					}
					else {
						// pDevName failed to allocate, free pObjName and continue
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
					}

				}

			}

		}

	}
	// Now, pDevName will either be NULL or point to a UNICODE_STRING, If it's NULL, the device name did not exist, or failed to copy




	// Base folder for our driver hooks
	LPWSTR pCFolder = L"\\DosDevices\\C:\\DriverHooks";

	// Quick workaround instead of properly parsing slashes and creating the nested
	// folder structure. Ideally in CreateFolder we would check for the existence of each folder
	// in the path and create them if required
	LPWSTR pCFolder_tmp2 = L"\\DosDevices\\C:\\DriverHooks\\Driver";

	SIZE_T fullPathSz = 2048 * sizeof(WCHAR);

	// Used to hold the eventual full path of our data dump, with a max of 2048 characters
	pFullPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  fullPathSz, 'PMDI');
	if (pFullPath == NULL) {
		goto cleanup;
	}
	wcsncpy_s(pFullPath, fullPathSz, pCFolder, wcslen(pCFolder));

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ws.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	status = CreateFolder(pCFolder_tmp2);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder2.\n"));

	
	wcsncat(pFullPath, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder.\n"));

	

	LPWSTR hookTypeStr = L"\\devIOR";
	// Concat ioctl string to full path
	wcsncat(pFullPath, hookTypeStr, wcslen(hookTypeStr));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ls.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created folder 2.\n"));

	pInputBufLenStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED,  sizeof(UNICODE_STRING), 'PMDI');
	if (pInputBufLenStringUni == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  30, 'PMDI');
	if (pInputBufLenStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->MaximumLength = 30;

	status = RtlIntegerToUnicodeString(pIoStackLocation->Parameters.Read.Length, 16, pInputBufLenStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}


	if (pIoStackLocation->Parameters.Read.Length > 0)
	{
		// Dump memory
		pDataPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
		RtlZeroMemory(pDataPath, 4096 * sizeof(WCHAR));
		wcscat(pDataPath, pFullPath);
		wcsncat(pDataPath, L"\\", wcslen(L"\\"));
		wcsncat(pDataPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / 2);
		LPWSTR dataTerminator = L".data";
		wcsncat(pDataPath, dataTerminator, wcslen(dataTerminator));
		// Create handle to pDataPath
		hDataFile = 0;
		status = CreateFileHelper(pDataPath, GENERIC_WRITE, FILE_CREATE, &hDataFile);
		if (!NT_SUCCESS(status))
		{
			// File probably exists already, lets quit
			goto cleanup;
		}
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
		pDataPath = NULL;
		// We dump the buffer later, as we need the target to fill in the buffer first.
	}
	// Write conf
	pConfPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(pConfPath, 4096 * sizeof(WCHAR));
	wcscpy(pConfPath, pFullPath);
	wcsncat(pConfPath, L"\\", wcslen(L"\\"));
	wcsncat(pConfPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	LPWSTR confTerminator = L".conf";
	wcsncat(pConfPath, confTerminator, wcslen(confTerminator));
	hConfFile = 0;
	status = CreateFileHelper(pConfPath, GENERIC_WRITE, FILE_CREATE, &hConfFile);
	if (!NT_SUCCESS(status))
	{
		// File probably exists already, lets quit
		goto cleanup;
	}
	ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	pConfPath = NULL;
	// Write data to pConfFile handle
	confFileString = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(confFileString, 4096 * sizeof(WCHAR));
	LPWSTR drvHeader = L"DriverName:";
	wcsncpy(confFileString, drvHeader, wcslen(drvHeader));
	wcsncat(confFileString, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	LPWSTR newLine = L"\r\n";
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR typeHeader = L"Type:DEVIOR\r\n";
	wcsncat(confFileString, typeHeader, wcslen(typeHeader));
	LPWSTR ioctlHeader = L"IOCTL:";
	wcsncat(confFileString, ioctlHeader, wcslen(ioctlHeader));
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR inputLenHeader = L"InputBufferLength:";
	wcsncat(confFileString, inputLenHeader, wcslen(inputLenHeader));
	wcsncat(confFileString, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
	ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	pInputBufLenStringUni = NULL;
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR outputLenHeader = L"OutputBufferLength:";
	wcsncat(confFileString, outputLenHeader, wcslen(outputLenHeader));

	IO_STATUS_BLOCK statBlock;
	status = ZwWriteFile(hConfFile, NULL, NULL, NULL, &statBlock, confFileString, wcslen(confFileString) * sizeof(WCHAR), NULL, NULL);
	ZwClose(hConfFile);
	hConfFile = NULL;
	goto cleanup;
cleanup:
	// Check for NULL pointers and skip them, if we have a pointer that's non-null we free it, or if its a UNICODE type, we check if ->Buffer is NULL,
	// if not then we free that internal buffer first, then the UNICODE pointer.
	// Make sure we initialize all pointers as NULL at the start of this function, so that they may exist here for checking if we hit an error path and 
	// jump here early.
	if (confFileString != NULL) {
		ExFreePool2(confFileString, 'PMDI', NULL, NULL);
	}
	if (pConfPath != NULL) {
		ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	}
	if (pDataPath != NULL) {
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
	}
	if (pFullPath != NULL) {
		ExFreePool2(pFullPath, 'PMDI', NULL, NULL);
	}
	if (pObjName != NULL) {
		ExFreePool2(pObjName, 'PMDI', NULL, NULL);
	}
	if (pOutputBufLenStringUni != NULL) {
		if (pOutputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pOutputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pOutputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pInputBufLenStringUni != NULL) {
		if (pInputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pIoctlStringUni != NULL) {
		if (pIoctlStringUni->Buffer != NULL) {
			ExFreePool2(pIoctlStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pIoctlStringUni, 'PMDI', NULL, NULL);
	}
	if (pDevName != NULL) {
		if (pDevName->Buffer != NULL) {
			ExFreePool2(pDevName->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pDevName, 'PMDI', NULL, NULL);
	}
	// Check and close handles
	if (hConfFile != NULL) {
		ZwClose(hConfFile);
	}

	goto End;

End:
	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = deviceIoHooksRArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);

	// Call original overwritten address
	for (int i = 0; i < hookList->entry_count; i++)
	{
		if (RtlEqualUnicodeString(&hookList->entries[i].driverName, &drvName, false))
		{
			devIoCallRWD origFuncCall = (devIoCallRWD)hookList->entries[i].originalFunction;
			// Release lock
			ExReleaseFastMutex(hookList->lock);
			// Revert IRQL to value when we were called
			RaiseAndCheckIRQL(oldIRQL);
			// Call the original function now that we've logged it, then
			// return to caller
			NTSTATUS res = origFuncCall(DeviceObject, Irp);
	
			if (pIoStackLocation->Parameters.Read.Length > 0 && hDataFile != NULL) {

				LowerAndCheckIRQL();
				// Write data to pDataFile handle
				IO_STATUS_BLOCK statBlock;
				status = ZwWriteFile(hDataFile, NULL, NULL, NULL, &statBlock, Irp->AssociatedIrp.SystemBuffer, pIoStackLocation->Parameters.Read.Length, NULL, NULL);
				ZwClose(hDataFile);
				hDataFile = NULL;
				RaiseAndCheckIRQL(oldIRQL);
			}
			return res;


		}
	}
	// Release lock
	ExReleaseFastMutex(hookList->lock);
	// Rever IRQL
	RaiseAndCheckIRQL(oldIRQL);
	// Oops, cant find original hook address as something went wrong. We should never hit here, for debug purposes we crash the system. Alternatively, return 
	// a fake result to continue system execution
	__debugbreak();
	//return false;
}

NTSTATUS DeviceIoHookD(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	// We need to operate in PASSIVE_IRQL due to our file operations, ensure we're at that IRQL and save the current
	// IRQL so we can restore it later
	KIRQL oldIRQL = LowerAndCheckIRQL();
	// Initialize all our pointers to NULL, this allows us to check if they're non-null in our
	// cleanup phase without concerns of accessing non-initialized pointers.
	// Ensure whenever we free these pointers, we reset it back to NULL
	PUNICODE_STRING pOutputBufLenStringUni = NULL;
	LPWSTR confFileString = NULL;
	HANDLE hConfFile = NULL;
	LPWSTR pConfPath = NULL;
	HANDLE hDataFile = NULL;
	LPWSTR pDataPath = NULL;
	PUNICODE_STRING pInputBufLenStringUni = NULL;
	PUNICODE_STRING pIoctlStringUni = NULL;
	LPWSTR pFullPath = NULL;
	POBJECT_NAME_INFORMATION pObjName = NULL;
	PUNICODE_STRING pDevName = NULL;

	PVOID inBuf = NULL;
	PVOID outBuf = NULL;

	PIO_STACK_LOCATION pIoStackLocation;
	pIoStackLocation = IoGetCurrentIrpStackLocation(Irp);

	NTSTATUS status;
	// Debugging print 
	UNICODE_STRING drvName = DeviceObject->DriverObject->DriverName;
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Driver Name:%wZ.\n", drvName));

	// Check if the device also has a name
	ULONG nameLen = 0;
	// ObQueryNameString will return the required size in nameLen if exists
	status = ObQueryNameString(DeviceObject, NULL, NULL, &nameLen);
	if (nameLen != 0) {
		// Name exists, lets allocate enough room for it
		pObjName = (POBJECT_NAME_INFORMATION)ExAllocatePool2(POOL_FLAG_NON_PAGED, nameLen, 'PMDI');
		if (pObjName != NULL) {
			status = ObQueryNameString(DeviceObject, pObjName, nameLen, &nameLen);
			if (status == STATUS_SUCCESS) {
				if (pObjName->Name.Length == 0)
				{
					ExFreePool(pObjName);
				}
				else {
					// Name exists, lets copy it into pDevName and free the object_name_information object
					pDevName = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
					if (pDevName != NULL) {
						pDevName->Length = pObjName->Name.Length;
						pDevName->MaximumLength = pObjName->Name.MaximumLength;
						pDevName->Buffer = (PWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, pObjName->Name.MaximumLength, 'PMDI');
						if (pDevName->Buffer != NULL) {
							memcpy(pDevName->Buffer, pObjName->Name.Buffer, pObjName->Name.Length);
						}
						// Copy finished, lets free pObjName
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
						// Detect if the copy failed due to a failed allocation
						if (pDevName->Buffer == NULL) {
							// Buffer failed to allocate, free pDevName and set it to NULL so we can detect the failure later
							ExFreePool2(pDevName, 'PMDI', NULL, NULL);
							pDevName = NULL;
						}
					}
					else {
						// pDevName failed to allocate, free pObjName and continue
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
					}

				}

			}

		}

	}
	// Now, pDevName will either be NULL or point to a UNICODE_STRING, If it's NULL, the device name did not exist, or failed to copy




	// Base folder for our driver hooks
	LPWSTR pCFolder = L"\\DosDevices\\C:\\DriverHooks";

	// Quick workaround instead of properly parsing slashes and creating the nested
	// folder structure. Ideally in CreateFolder we would check for the existence of each folder
	// in the path and create them if required
	LPWSTR pCFolder_tmp2 = L"\\DosDevices\\C:\\DriverHooks\\Driver";

	SIZE_T fullPathSz = 2048 * sizeof(WCHAR);

	// Used to hold the eventual full path of our data dump, with a max of 2048 characters
	pFullPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, fullPathSz, 'PMDI');
	if (pFullPath == NULL) {
		goto cleanup;
	}
	wcsncpy_s(pFullPath, fullPathSz, pCFolder, wcslen(pCFolder));

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ws.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	status = CreateFolder(pCFolder_tmp2);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder2.\n"));

	
	wcsncat(pFullPath, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder.\n"));

	


	pIoctlStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED,sizeof(UNICODE_STRING), 'PMDI');
	if (pIoctlStringUni == NULL) {
		goto cleanup;
	}
	pIoctlStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  30, 'PMDI');
	if (pIoctlStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pIoctlStringUni->MaximumLength = 30;
	status = RtlIntegerToUnicodeString(pIoStackLocation->Parameters.DeviceIoControl.IoControlCode, 16, pIoctlStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	LPWSTR hookTypeStr = L"\\devIOD";
	// Concat ioctl string to full path
	wcsncat(pFullPath, hookTypeStr, wcslen(hookTypeStr));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	wcsncat(pFullPath, L"\\", wcslen(L"\\"));
	wcsncat(pFullPath, pIoctlStringUni->Buffer, pIoctlStringUni->Length / sizeof(WCHAR));


	// Input & output buffer location will differ based on IoControlCode
	switch (METHOD_FROM_CTL_CODE(pIoStackLocation->Parameters.DeviceIoControl.IoControlCode))
	{
	case METHOD_BUFFERED:
		inBuf = Irp->AssociatedIrp.SystemBuffer; outBuf = Irp->AssociatedIrp.SystemBuffer; break;
	case METHOD_IN_DIRECT:
		inBuf = Irp->AssociatedIrp.SystemBuffer; outBuf = MmGetMdlVirtualAddress(Irp->MdlAddress); break;
	case METHOD_OUT_DIRECT:
		inBuf = Irp->AssociatedIrp.SystemBuffer; outBuf = MmGetMdlVirtualAddress (Irp->MdlAddress); break;
	case METHOD_NEITHER:
		inBuf = pIoStackLocation->Parameters.DeviceIoControl.Type3InputBuffer; outBuf = Irp->UserBuffer; break;
	default:
		// This should never be hit, something went wrong if so. Print an error and go to cleanup
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "ERROR: Unknown IOCTL method: %lu.\n", pIoStackLocation->Parameters.DeviceIoControl.IoControlCode));
		goto cleanup;
	}

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ls.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created folder 2.\n"));

	pInputBufLenStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
	if (pInputBufLenStringUni == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  30, 'PMDI');
	if (pInputBufLenStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->MaximumLength = 30;

	status = RtlIntegerToUnicodeString(pIoStackLocation->Parameters.DeviceIoControl.InputBufferLength, 16, pInputBufLenStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}


	if (pIoStackLocation->Parameters.DeviceIoControl.InputBufferLength > 0 && inBuf != NULL)
	{
		// Dump memory
		pDataPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
		RtlZeroMemory(pDataPath, 4096 * sizeof(WCHAR));
		wcscat(pDataPath, pFullPath);
		wcsncat(pDataPath, L"\\", wcslen(L"\\"));
		wcsncat(pDataPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / 2);
		LPWSTR dataTerminator = L".data";
		wcsncat(pDataPath, dataTerminator, wcslen(dataTerminator));
		// Create handle to pDataPath
		hDataFile = 0;
		status = CreateFileHelper(pDataPath, GENERIC_WRITE, FILE_CREATE, &hDataFile);
		if (!NT_SUCCESS(status))
		{
			// File probably exists already, lets quit
			goto cleanup;
		}
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
		pDataPath = NULL;
		// Write data to pDataFile handle
		IO_STATUS_BLOCK statBlock;
		status = ZwWriteFile(hDataFile, NULL, NULL, NULL, &statBlock, inBuf, pIoStackLocation->Parameters.DeviceIoControl.InputBufferLength, NULL, NULL);
		ZwClose(hDataFile);
		hDataFile = NULL;
		if (!NT_SUCCESS(status))
		{
			// Error writing file
			goto cleanup;
		}
	}
	// Write conf
	pConfPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(pConfPath, 4096 * sizeof(WCHAR));
	wcscpy(pConfPath, pFullPath);
	wcsncat(pConfPath, L"\\", wcslen(L"\\"));
	wcsncat(pConfPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	LPWSTR confTerminator = L".conf";
	wcsncat(pConfPath, confTerminator, wcslen(confTerminator));
	hConfFile = 0;
	status = CreateFileHelper(pConfPath, GENERIC_WRITE, FILE_CREATE, &hConfFile);
	if (!NT_SUCCESS(status))
	{
		// File probably exists already, lets quit
		goto cleanup;
	}
	ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	pConfPath = NULL;
	// Write data to pConfFile handle
	confFileString = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(confFileString, 4096 * sizeof(WCHAR));
	LPWSTR drvHeader = L"DriverName:";
	wcsncpy(confFileString, drvHeader, wcslen(drvHeader));
	wcsncat(confFileString, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	LPWSTR newLine = L"\r\n";
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR typeHeader = L"Type:DEVIOD\r\n";
	wcsncat(confFileString, typeHeader, wcslen(typeHeader));
	LPWSTR type2Header = L"BuffType:";
	LPWSTR buffHeader = L"METHOD_BUFFERED\r\n";
	LPWSTR inDir = L"METHOD_IN_DIRECT\r\n";
	LPWSTR outDir = L"METHOD_OUT_DIRECT\r\n";
	LPWSTR neiDir = L"METHOD_NEITHER\r\n";
	wcsncat(confFileString, type2Header, wcslen(type2Header));
	switch (METHOD_FROM_CTL_CODE(pIoStackLocation->Parameters.DeviceIoControl.IoControlCode))
	{
	case METHOD_BUFFERED:
		wcsncat(confFileString, buffHeader, wcslen(buffHeader)); break;
	case METHOD_IN_DIRECT:
		wcsncat(confFileString, inDir, wcslen(inDir)); break;
	case METHOD_OUT_DIRECT:
		wcsncat(confFileString, outDir, wcslen(outDir)); break;
	case METHOD_NEITHER:
		wcsncat(confFileString, neiDir, wcslen(neiDir)); break;
	default:
		goto cleanup;
	}
	LPWSTR ioctlHeader = L"IOCTL:";
	wcsncat(confFileString, ioctlHeader, wcslen(ioctlHeader));
	wcsncat(confFileString, pIoctlStringUni->Buffer, pIoctlStringUni->Length / sizeof(WCHAR));
	ExFreePool2(pIoctlStringUni->Buffer, 'PMDI', NULL, NULL);
	ExFreePool2(pIoctlStringUni, 'PMDI', NULL, NULL);
	pIoctlStringUni = NULL;
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR inputLenHeader = L"InputBufferLength:";
	wcsncat(confFileString, inputLenHeader, wcslen(inputLenHeader));
	wcsncat(confFileString, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
	ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	pInputBufLenStringUni = NULL;
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR outputLenHeader = L"OutputBufferLength:";
	wcsncat(confFileString, outputLenHeader, wcslen(outputLenHeader));

	pOutputBufLenStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
	if (pOutputBufLenStringUni == NULL) {
		goto cleanup;
	}
	pOutputBufLenStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  60, 'PMDI');
	if (pOutputBufLenStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pOutputBufLenStringUni->MaximumLength = 60;
	status = RtlIntegerToUnicodeString(pIoStackLocation->Parameters.DeviceIoControl.OutputBufferLength, 16, pOutputBufLenStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	wcsncat(confFileString, pOutputBufLenStringUni->Buffer, pOutputBufLenStringUni->Length / sizeof(WCHAR));

	ExFreePool2(pOutputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
	ExFreePool2(pOutputBufLenStringUni, 'PMDI', NULL, NULL);
	pOutputBufLenStringUni = NULL;

	IO_STATUS_BLOCK statBlock;
	status = ZwWriteFile(hConfFile, NULL, NULL, NULL, &statBlock, confFileString, wcslen(confFileString) * sizeof(WCHAR), NULL, NULL);
	ZwClose(hConfFile);
	hConfFile = NULL;
	goto cleanup;
cleanup:
	// Check for NULL pointers and skip them, if we have a pointer that's non-null we free it, or if its a UNICODE type, we check if ->Buffer is NULL,
	// if not then we free that internal buffer first, then the UNICODE pointer.
	// Make sure we initialize all pointers as NULL at the start of this function, so that they may exist here for checking if we hit an error path and 
	// jump here early.
	if (confFileString != NULL) {
		ExFreePool2(confFileString, 'PMDI', NULL, NULL);
	}
	if (pConfPath != NULL) {
		ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	}
	if (pDataPath != NULL) {
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
	}
	if (pFullPath != NULL) {
		ExFreePool2(pFullPath, 'PMDI', NULL, NULL);
	}
	if (pObjName != NULL) {
		ExFreePool2(pObjName, 'PMDI', NULL, NULL);
	}
	if (pOutputBufLenStringUni != NULL) {
		if (pOutputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pOutputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pOutputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pInputBufLenStringUni != NULL) {
		if (pInputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pIoctlStringUni != NULL) {
		if (pIoctlStringUni->Buffer != NULL) {
			ExFreePool2(pIoctlStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pIoctlStringUni, 'PMDI', NULL, NULL);
	}
	if (pDevName != NULL) {
		if (pDevName->Buffer != NULL) {
			ExFreePool2(pDevName->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pDevName, 'PMDI', NULL, NULL);
	}
	// Check and close handles
	if (hConfFile != NULL) {
		ZwClose(hConfFile);
	}
	if (hDataFile != NULL) {
		ZwClose(hDataFile);
	}
	goto End;

End:
	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = deviceIoHooksDArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);

	// Call original overwritten address
	for (int i = 0; i < hookList->entry_count; i++)
	{
		if (RtlEqualUnicodeString(&hookList->entries[i].driverName, &drvName, false))
		{
			devIoCallRWD origFuncCall = (devIoCallRWD)hookList->entries[i].originalFunction;
			// Release lock
			ExReleaseFastMutex(hookList->lock);
			// Revert IRQL to value when we were called
			RaiseAndCheckIRQL(oldIRQL);
			// Call the original function now that we've logged it, then
			// return to caller
			return origFuncCall(DeviceObject, Irp);
		}
	}
	// Release lock
	ExReleaseFastMutex(hookList->lock);
	// Rever IRQL
	RaiseAndCheckIRQL(oldIRQL);
	// Oops, cant find original hook address as something went wrong. We should never hit here, for debug purposes we crash the system. Alternatively, return 
	// a fake result to continue system execution
	__debugbreak();
	//return false;
}


NTSTATUS FileIoHookD(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	// We need to operate in PASSIVE_IRQL due to our file operations, ensure we're at that IRQL and save the current
	// IRQL so we can restore it later
	KIRQL oldIRQL = LowerAndCheckIRQL();
	// Initialize all our pointers to NULL, this allows us to check if they're non-null in our
	// cleanup phase without concerns of accessing non-initialized pointers.
	// Ensure whenever we free these pointers, we reset it back to NULL
	PUNICODE_STRING pOutputBufLenStringUni = NULL;
	LPWSTR confFileString = NULL;
	HANDLE hConfFile = NULL;
	LPWSTR pConfPath = NULL;
	HANDLE hDataFile = NULL;
	LPWSTR pDataPath = NULL;
	PUNICODE_STRING pInputBufLenStringUni = NULL;
	PUNICODE_STRING pIoctlStringUni = NULL;
	LPWSTR pFullPath = NULL;
	POBJECT_NAME_INFORMATION pObjName = NULL;
	PUNICODE_STRING pDevName = NULL;

	PVOID inBuf = NULL;
	PVOID outBuf = NULL;

	PIO_STACK_LOCATION pIoStackLocation;
	pIoStackLocation = IoGetCurrentIrpStackLocation(Irp);

	NTSTATUS status;
	// Debugging print 
	UNICODE_STRING drvName = DeviceObject->DriverObject->DriverName;
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Driver Name:%wZ.\n", drvName));

	// Check if the device also has a name
	ULONG nameLen = 0;
	// ObQueryNameString will return the required size in nameLen if exists
	status = ObQueryNameString(DeviceObject, NULL, NULL, &nameLen);
	if (nameLen != 0) {
		// Name exists, lets allocate enough room for it
		pObjName = (POBJECT_NAME_INFORMATION)ExAllocatePool2(POOL_FLAG_NON_PAGED, nameLen, 'PMDI');
		if (pObjName != NULL) {
			status = ObQueryNameString(DeviceObject, pObjName, nameLen, &nameLen);
			if (status == STATUS_SUCCESS) {
				if (pObjName->Name.Length == 0)
				{
					ExFreePool(pObjName);
				}
				else {
					// Name exists, lets copy it into pDevName and free the object_name_information object
					pDevName = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
					if (pDevName != NULL) {
						pDevName->Length = pObjName->Name.Length;
						pDevName->MaximumLength = pObjName->Name.MaximumLength;
						pDevName->Buffer = (PWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, pObjName->Name.MaximumLength, 'PMDI');
						if (pDevName->Buffer != NULL) {
							memcpy(pDevName->Buffer, pObjName->Name.Buffer, pObjName->Name.Length);
						}
						// Copy finished, lets free pObjName
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
						// Detect if the copy failed due to a failed allocation
						if (pDevName->Buffer == NULL) {
							// Buffer failed to allocate, free pDevName and set it to NULL so we can detect the failure later
							ExFreePool2(pDevName, 'PMDI', NULL, NULL);
							pDevName = NULL;
						}
					}
					else {
						// pDevName failed to allocate, free pObjName and continue
						ExFreePool2(pObjName, 'PMDI', NULL, NULL);
						pObjName = NULL;
					}

				}

			}

		}

	}
	// Now, pDevName will either be NULL or point to a UNICODE_STRING, If it's NULL, the device name did not exist, or failed to copy




	// Base folder for our driver hooks
	LPWSTR pCFolder = L"\\DosDevices\\C:\\DriverHooks";

	// Quick workaround instead of properly parsing slashes and creating the nested
	// folder structure. Ideally in CreateFolder we would check for the existence of each folder
	// in the path and create them if required
	LPWSTR pCFolder_tmp2 = L"\\DosDevices\\C:\\DriverHooks\\Driver";

	SIZE_T fullPathSz = 2048 * sizeof(WCHAR);

	// Used to hold the eventual full path of our data dump, with a max of 2048 characters
	pFullPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  fullPathSz, 'PMDI');
	if (pFullPath == NULL) {
		goto cleanup;
	}
	wcsncpy_s(pFullPath, fullPathSz, pCFolder, wcslen(pCFolder));

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ws.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	status = CreateFolder(pCFolder_tmp2);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder2.\n"));

	
	wcsncat(pFullPath, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created initial folder.\n"));

	



	pIoctlStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
	if (pIoctlStringUni == NULL) {
		goto cleanup;
	}
	pIoctlStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  30, 'PMDI');
	if (pIoctlStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pIoctlStringUni->MaximumLength = 30;
	status = RtlIntegerToUnicodeString(pIoStackLocation->Parameters.DeviceIoControl.IoControlCode, 16, pIoctlStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	LPWSTR hookTypeStr = L"\\fileIOD";
	// Concat ioctl string to full path
	wcsncat(pFullPath, hookTypeStr, wcslen(hookTypeStr));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	wcsncat(pFullPath, L"\\", wcslen(L"\\"));
	wcsncat(pFullPath, pIoctlStringUni->Buffer, pIoctlStringUni->Length / sizeof(WCHAR));


	// Input & output buffer location will differ based on IoControlCode
	switch (METHOD_FROM_CTL_CODE(pIoStackLocation->Parameters.DeviceIoControl.IoControlCode))
	{
	case METHOD_BUFFERED:
		inBuf = Irp->AssociatedIrp.SystemBuffer; outBuf = Irp->AssociatedIrp.SystemBuffer; break;
	case METHOD_IN_DIRECT:
		inBuf = Irp->AssociatedIrp.SystemBuffer; outBuf = MmGetMdlVirtualAddress(Irp->MdlAddress); break;
	case METHOD_OUT_DIRECT:
		inBuf = Irp->AssociatedIrp.SystemBuffer; outBuf = MmGetMdlVirtualAddress(Irp->MdlAddress); break;
	case METHOD_NEITHER:
		inBuf = pIoStackLocation->Parameters.DeviceIoControl.Type3InputBuffer; outBuf = Irp->UserBuffer; break;
	default:
		// This should never be hit, something went wrong if so. Print an error and go to cleanup
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "ERROR: Unknown IOCTL method: %lu.\n", pIoStackLocation->Parameters.DeviceIoControl.IoControlCode));
		goto cleanup;
	}

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Creating folder:%ls.\n", pFullPath));
	status = CreateFolder(pFullPath);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "INFO: Created folder 2.\n"));

	pInputBufLenStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
	if (pInputBufLenStringUni == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED,  30, 'PMDI');
	if (pInputBufLenStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pInputBufLenStringUni->MaximumLength = 30;

	status = RtlIntegerToUnicodeString(pIoStackLocation->Parameters.DeviceIoControl.InputBufferLength, 16, pInputBufLenStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}


	if (pIoStackLocation->Parameters.DeviceIoControl.InputBufferLength > 0 && inBuf != NULL)
	{
		// Dump memory
		pDataPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
		RtlZeroMemory(pDataPath, 4096 * sizeof(WCHAR));
		wcscat(pDataPath, pFullPath);
		wcsncat(pDataPath, L"\\", wcslen(L"\\"));
		wcsncat(pDataPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / 2);
		LPWSTR dataTerminator = L".data";
		wcsncat(pDataPath, dataTerminator, wcslen(dataTerminator));
		// Create handle to pDataPath
		hDataFile = 0;
		status = CreateFileHelper(pDataPath, GENERIC_WRITE, FILE_CREATE, &hDataFile);
		if (!NT_SUCCESS(status))
		{
			// File probably exists already, lets quit
			goto cleanup;
		}
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
		pDataPath = NULL;
		// Write data to pDataFile handle
		IO_STATUS_BLOCK statBlock;
		status = ZwWriteFile(hDataFile, NULL, NULL, NULL, &statBlock, inBuf, pIoStackLocation->Parameters.DeviceIoControl.InputBufferLength, NULL, NULL);
		ZwClose(hDataFile);
		hDataFile = NULL;
		if (!NT_SUCCESS(status))
		{
			// Error writing file
			goto cleanup;
		}
	}
	// Write conf
	pConfPath = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(pConfPath, 4096 * sizeof(WCHAR));
	wcscpy(pConfPath, pFullPath);
	wcsncat(pConfPath, L"\\", wcslen(L"\\"));
	wcsncat(pConfPath, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	LPWSTR confTerminator = L".conf";
	wcsncat(pConfPath, confTerminator, wcslen(confTerminator));
	hConfFile = 0;
	status = CreateFileHelper(pConfPath, GENERIC_WRITE, FILE_CREATE, &hConfFile);
	if (!NT_SUCCESS(status))
	{
		// File probably exists already, lets quit
		goto cleanup;
	}
	ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	pConfPath = NULL;
	// Write data to pConfFile handle
	confFileString = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 4096 * sizeof(WCHAR), 'PMDI');
	RtlZeroMemory(confFileString, 4096 * sizeof(WCHAR));
	LPWSTR drvHeader = L"DriverName:";
	wcsncpy(confFileString, drvHeader, wcslen(drvHeader));
	wcsncat(confFileString, drvName.Buffer, drvName.Length / sizeof(WCHAR));
	LPWSTR newLine = L"\r\n";
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR typeHeader = L"Type:FILEIOD\r\n";
	wcsncat(confFileString, typeHeader, wcslen(typeHeader));
	LPWSTR type2Header = L"BuffType:";
	LPWSTR buffHeader = L"METHOD_BUFFERED\r\n";
	LPWSTR inDir = L"METHOD_IN_DIRECT\r\n";
	LPWSTR outDir = L"METHOD_OUT_DIRECT\r\n";
	LPWSTR neiDir = L"METHOD_NEITHER\r\n";
	wcsncat(confFileString, type2Header, wcslen(type2Header));
	switch (METHOD_FROM_CTL_CODE(pIoStackLocation->Parameters.DeviceIoControl.IoControlCode))
	{
	case METHOD_BUFFERED:
		wcsncat(confFileString, buffHeader, wcslen(buffHeader)); break;
	case METHOD_IN_DIRECT:
		wcsncat(confFileString, inDir, wcslen(inDir)); break;
	case METHOD_OUT_DIRECT:
		wcsncat(confFileString, outDir, wcslen(outDir)); break;
	case METHOD_NEITHER:
		wcsncat(confFileString, neiDir, wcslen(neiDir)); break;
	default:
		goto cleanup;
	}
	LPWSTR ioctlHeader = L"IOCTL:";
	wcsncat(confFileString, ioctlHeader, wcslen(ioctlHeader));
	wcsncat(confFileString, pIoctlStringUni->Buffer, pIoctlStringUni->Length / sizeof(WCHAR));
	ExFreePool2(pIoctlStringUni->Buffer, 'PMDI', NULL, NULL);
	ExFreePool2(pIoctlStringUni, 'PMDI', NULL, NULL);
	pIoctlStringUni = NULL;
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR inputLenHeader = L"InputBufferLength:";
	wcsncat(confFileString, inputLenHeader, wcslen(inputLenHeader));
	wcsncat(confFileString, pInputBufLenStringUni->Buffer, pInputBufLenStringUni->Length / sizeof(WCHAR));
	ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
	ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	pInputBufLenStringUni = NULL;
	wcsncat(confFileString, newLine, wcslen(newLine));
	LPWSTR outputLenHeader = L"OutputBufferLength:";
	wcsncat(confFileString, outputLenHeader, wcslen(outputLenHeader));

	pOutputBufLenStringUni = (PUNICODE_STRING)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(UNICODE_STRING), 'PMDI');
	if (pOutputBufLenStringUni == NULL) {
		goto cleanup;
	}
	pOutputBufLenStringUni->Buffer = (LPWSTR)ExAllocatePool2(POOL_FLAG_NON_PAGED, 60, 'PMDI');
	if (pOutputBufLenStringUni->Buffer == NULL) {
		goto cleanup;
	}
	pOutputBufLenStringUni->MaximumLength = 60;
	status = RtlIntegerToUnicodeString(pIoStackLocation->Parameters.DeviceIoControl.OutputBufferLength, 16, pOutputBufLenStringUni);
	if (!NT_SUCCESS(status))
	{
		goto cleanup;
	}

	wcsncat(confFileString, pOutputBufLenStringUni->Buffer, pOutputBufLenStringUni->Length / sizeof(WCHAR));

	ExFreePool2(pOutputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
	ExFreePool2(pOutputBufLenStringUni, 'PMDI', NULL, NULL);
	pOutputBufLenStringUni = NULL;

	IO_STATUS_BLOCK statBlock;
	status = ZwWriteFile(hConfFile, NULL, NULL, NULL, &statBlock, confFileString, wcslen(confFileString) * sizeof(WCHAR), NULL, NULL);
	ZwClose(hConfFile);
	hConfFile = NULL;
	goto cleanup;
cleanup:
	// Check for NULL pointers and skip them, if we have a pointer that's non-null we free it, or if its a UNICODE type, we check if ->Buffer is NULL,
	// if not then we free that internal buffer first, then the UNICODE pointer.
	// Make sure we initialize all pointers as NULL at the start of this function, so that they may exist here for checking if we hit an error path and 
	// jump here early.
	if (confFileString != NULL) {
		ExFreePool2(confFileString, 'PMDI', NULL, NULL);
	}
	if (pConfPath != NULL) {
		ExFreePool2(pConfPath, 'PMDI', NULL, NULL);
	}
	if (pDataPath != NULL) {
		ExFreePool2(pDataPath, 'PMDI', NULL, NULL);
	}
	if (pFullPath != NULL) {
		ExFreePool2(pFullPath, 'PMDI', NULL, NULL);
	}
	if (pObjName != NULL) {
		ExFreePool2(pObjName, 'PMDI', NULL, NULL);
	}
	if (pOutputBufLenStringUni != NULL) {
		if (pOutputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pOutputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pOutputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pInputBufLenStringUni != NULL) {
		if (pInputBufLenStringUni->Buffer != NULL) {
			ExFreePool2(pInputBufLenStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pInputBufLenStringUni, 'PMDI', NULL, NULL);
	}
	if (pIoctlStringUni != NULL) {
		if (pIoctlStringUni->Buffer != NULL) {
			ExFreePool2(pIoctlStringUni->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pIoctlStringUni, 'PMDI', NULL, NULL);
	}
	if (pDevName != NULL) {
		if (pDevName->Buffer != NULL) {
			ExFreePool2(pDevName->Buffer, 'PMDI', NULL, NULL);
		}
		ExFreePool2(pDevName, 'PMDI', NULL, NULL);
	}
	// Check and close handles
	if (hConfFile != NULL) {
		ZwClose(hConfFile);
	}
	if (hDataFile != NULL) {
		ZwClose(hDataFile);
	}
	goto End;

End:
	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = fileIoHooksDArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);

	// Call original overwritten address
	for (int i = 0; i < hookList->entry_count; i++)
	{
		if (RtlEqualUnicodeString(&hookList->entries[i].driverName, &drvName, false))
		{
			devIoCallRWD origFuncCall = (devIoCallRWD)hookList->entries[i].originalFunction;
			// Release lock
			ExReleaseFastMutex(hookList->lock);
			// Revert IRQL to value when we were called
			RaiseAndCheckIRQL(oldIRQL);
			// Call the original function now that we've logged it, then
			// return to caller
			return origFuncCall(DeviceObject, Irp);
		}
	}
	// Release lock
	ExReleaseFastMutex(hookList->lock);
	// Rever IRQL
	RaiseAndCheckIRQL(oldIRQL);
	// Oops, cant find original hook address as something went wrong. We should never hit here, for debug purposes we crash the system. Alternatively, return 
	// a fake result to continue system execution
	__debugbreak();
	//return false;
}







/// <summary>
/// Hooks the target function as a `FastIoHookD` type,
/// </summary>
/// <param name="originalFunc">
/// Pointer to the original function we're overwriting
/// </param>
/// <param name="hookDumpFunc">
/// Our function that will replace the original target function
/// </param>
/// <param name="driverName">
/// The name of the device driver we're hooking
/// </param>
/// <returns></returns>
NTSTATUS AddFastIOHookD(PVOID* originalFunc, PVOID hookDumpFunc, UNICODE_STRING driverName)
{
	
	IoHooks newHook = { 0 };
	newHook.driverName = driverName;
	newHook.originalFunction = *originalFunc;
	newHook.hookedAddress = originalFunc;

	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = fastIoHooksDArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);
	// Execution has resumed, meaning we have obtained the lock, we can continue processing and ensure we release the lock
	// before returning from this function

	// Check if there is room to add a new hook
	if (hookList->entry_count == hookList->entry_max) {
		// No room to add hook, release the lock and return an error
		ExReleaseFastMutex(hookList->lock);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	// We have room to add a new hook, the array is always sorted such that there are no gaps between hooks, this means
	// the next free index in the array is always the count of elements (we ensure we don't remove hooks, or if we do, we re-sort the array to eliminate gaps between entries)

	// Before we add the entry, lets ensure the entry doesn't already exist
	for (int i = 0; i < hookList->entry_count; i++) {
		if (hookList->entries[i].originalFunction == originalFunc) {
			// Target function is already hooked, release lock and return error
			ExReleaseFastMutex(hookList->lock);
			return STATUS_INVALID_PARAMETER;
		}
	}
	// If we reach here, hook doesn't exist, we can add our new hook
	hookList->entries[hookList->entry_count] = newHook;
	// Increment entry_count to the next free index
	hookList->entry_count += 1;
	
	InterlockedExchangePointer(originalFunc, hookDumpFunc);

	// release hook
	ExReleaseFastMutex(hookList->lock);

	return STATUS_SUCCESS;
}

/// <summary>
/// Hooks the target function as a `FastIoHookR` type,
/// </summary>
/// <param name="originalFunc">
/// Pointer to the original function we're overwriting
/// </param>
/// <param name="hookDumpFunc">
/// Our function that will replace the original target function
/// </param>
/// <param name="driverName">
/// The name of the device driver we're hooking
/// </param>
/// <returns></returns>
NTSTATUS AddFastIOHookR(PVOID* originalFunc, PVOID hookDumpFunc, UNICODE_STRING driverName)
{

	IoHooks newHook = { 0 };
	newHook.driverName = driverName;
	newHook.originalFunction = *originalFunc;
	newHook.hookedAddress = originalFunc;

	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = fastIoHooksRArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);
	// Execution has resumed, meaning we have obtained the lock, we can continue processing and ensure we release the lock
	// before returning from this function

	// Check if there is room to add a new hook
	if (hookList->entry_count == hookList->entry_max) {
		// No room to add hook, release the lock and return an error
		ExReleaseFastMutex(hookList->lock);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	// We have room to add a new hook, the array is always sorted such that there are no gaps between hooks, this means
	// the next free index in the array is always the count of elements (we ensure we don't remove hooks, or if we do, we re-sort the array to eliminate gaps between entries)

	// Before we add the entry, lets ensure the entry doesn't already exist
	for (int i = 0; i < hookList->entry_count; i++) {
		if (hookList->entries[i].originalFunction == originalFunc) {
			// Target function is already hooked, release lock and return error
			ExReleaseFastMutex(hookList->lock);
			return STATUS_INVALID_PARAMETER;
		}
	}
	// If we reach here, hook doesn't exist, we can add our new hook
	hookList->entries[hookList->entry_count] = newHook;
	// Increment entry_count to the next free index
	hookList->entry_count += 1;

	InterlockedExchangePointer(originalFunc, hookDumpFunc);;

	// release hook
	ExReleaseFastMutex(hookList->lock);

	return STATUS_SUCCESS;
}


/// <summary>
/// Hooks the target function as a `FastIoHookW` type,
/// </summary>
/// <param name="originalFunc">
/// Pointer to the original function we're overwriting
/// </param>
/// <param name="hookDumpFunc">
/// Our function that will replace the original target function
/// </param>
/// <param name="driverName">
/// The name of the device driver we're hooking
/// </param>
/// <returns></returns>
NTSTATUS AddFastIOHookW(PVOID* originalFunc, PVOID hookDumpFunc, UNICODE_STRING driverName)
{

	IoHooks newHook = { 0 };
	newHook.driverName = driverName;
	newHook.originalFunction = *originalFunc;
	newHook.hookedAddress = originalFunc;

	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = fastIoHooksWArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);
	// Execution has resumed, meaning we have obtained the lock, we can continue processing and ensure we release the lock
	// before returning from this function

	// Check if there is room to add a new hook
	if (hookList->entry_count == hookList->entry_max) {
		// No room to add hook, release the lock and return an error
		ExReleaseFastMutex(hookList->lock);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	// We have room to add a new hook, the array is always sorted such that there are no gaps between hooks, this means
	// the next free index in the array is always the count of elements (we ensure we don't remove hooks, or if we do, we re-sort the array to eliminate gaps between entries)

	// Before we add the entry, lets ensure the entry doesn't already exist
	for (int i = 0; i < hookList->entry_count; i++) {
		if (hookList->entries[i].originalFunction == originalFunc) {
			// Target function is already hooked, release lock and return error
			ExReleaseFastMutex(hookList->lock);
			return STATUS_INVALID_PARAMETER;
		}
	}
	// If we reach here, hook doesn't exist, we can add our new hook
	hookList->entries[hookList->entry_count] = newHook;
	// Increment entry_count to the next free index
	hookList->entry_count += 1;

	InterlockedExchangePointer(originalFunc, hookDumpFunc);;

	// release hook
	ExReleaseFastMutex(hookList->lock);

	return STATUS_SUCCESS;
}

/// <summary>
/// Hooks the target function as a `DeviceIoHookD` type,
/// </summary>
/// <param name="originalFunc">
/// Pointer to the original function we're overwriting
/// </param>
/// <param name="hookDumpFunc">
/// Our function that will replace the original target function
/// </param>
/// <param name="driverName">
/// The name of the device driver we're hooking
/// </param>
/// <returns></returns>
NTSTATUS AddDeviceIOHookD(PVOID* originalFunc, PVOID hookDumpFunc, UNICODE_STRING driverName)
{

	IoHooks newHook = { 0 };
	newHook.driverName = driverName;
	newHook.originalFunction = *originalFunc;
	newHook.hookedAddress = originalFunc;

	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = deviceIoHooksDArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);
	// Execution has resumed, meaning we have obtained the lock, we can continue processing and ensure we release the lock
	// before returning from this function

	// Check if there is room to add a new hook
	if (hookList->entry_count == hookList->entry_max) {
		// No room to add hook, release the lock and return an error
		ExReleaseFastMutex(hookList->lock);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	// We have room to add a new hook, the array is always sorted such that there are no gaps between hooks, this means
	// the next free index in the array is always the count of elements (we ensure we don't remove hooks, or if we do, we re-sort the array to eliminate gaps between entries)

	// Before we add the entry, lets ensure the entry doesn't already exist
	for (int i = 0; i < hookList->entry_count; i++) {
		if (hookList->entries[i].originalFunction == originalFunc) {
			// Target function is already hooked, release lock and return error
			ExReleaseFastMutex(hookList->lock);
			return STATUS_INVALID_PARAMETER;
		}
	}
	// If we reach here, hook doesn't exist, we can add our new hook
	hookList->entries[hookList->entry_count] = newHook;
	// Increment entry_count to the next free index
	hookList->entry_count += 1;

	InterlockedExchangePointer(originalFunc, hookDumpFunc);;

	// release hook
	ExReleaseFastMutex(hookList->lock);

	return STATUS_SUCCESS;
}

/// <summary>
/// Hooks the target function as a `DeviceIoHookR` type,
/// </summary>
/// <param name="originalFunc">
/// Pointer to the original function we're overwriting
/// </param>
/// <param name="hookDumpFunc">
/// Our function that will replace the original target function
/// </param>
/// <param name="driverName">
/// The name of the device driver we're hooking
/// </param>
/// <returns></returns>
NTSTATUS AddDeviceIOHookR(PVOID* originalFunc, PVOID hookDumpFunc, UNICODE_STRING driverName)
{

	IoHooks newHook = { 0 };
	newHook.driverName = driverName;
	newHook.originalFunction = *originalFunc;
	newHook.hookedAddress = originalFunc;

	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = deviceIoHooksRArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);
	// Execution has resumed, meaning we have obtained the lock, we can continue processing and ensure we release the lock
	// before returning from this function

	// Check if there is room to add a new hook
	if (hookList->entry_count == hookList->entry_max) {
		// No room to add hook, release the lock and return an error
		ExReleaseFastMutex(hookList->lock);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	// We have room to add a new hook, the array is always sorted such that there are no gaps between hooks, this means
	// the next free index in the array is always the count of elements (we ensure we don't remove hooks, or if we do, we re-sort the array to eliminate gaps between entries)

	// Before we add the entry, lets ensure the entry doesn't already exist
	for (int i = 0; i < hookList->entry_count; i++) {
		if (hookList->entries[i].originalFunction == originalFunc) {
			// Target function is already hooked, release lock and return error
			ExReleaseFastMutex(hookList->lock);
			return STATUS_INVALID_PARAMETER;
		}
	}
	// If we reach here, hook doesn't exist, we can add our new hook
	hookList->entries[hookList->entry_count] = newHook;
	// Increment entry_count to the next free index
	hookList->entry_count += 1;

	InterlockedExchangePointer(originalFunc, hookDumpFunc);;

	// release hook
	ExReleaseFastMutex(hookList->lock);

	return STATUS_SUCCESS;
}

/// <summary>
/// Hooks the target function as a `DeviceIoHookW` type,
/// </summary>
/// <param name="originalFunc">
/// Pointer to the original function we're overwriting
/// </param>
/// <param name="hookDumpFunc">
/// Our function that will replace the original target function
/// </param>
/// <param name="driverName">
/// The name of the device driver we're hooking
/// </param>
/// <returns></returns>
NTSTATUS AddDeviceIOHookW(PVOID* originalFunc, PVOID hookDumpFunc, UNICODE_STRING driverName)
{

	IoHooks newHook = { 0 };
	newHook.driverName = driverName;
	newHook.originalFunction = *originalFunc;
	newHook.hookedAddress = originalFunc;

	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = deviceIoHooksWArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);
	// Execution has resumed, meaning we have obtained the lock, we can continue processing and ensure we release the lock
	// before returning from this function

	// Check if there is room to add a new hook
	if (hookList->entry_count == hookList->entry_max) {
		// No room to add hook, release the lock and return an error
		ExReleaseFastMutex(hookList->lock);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	// We have room to add a new hook, the array is always sorted such that there are no gaps between hooks, this means
	// the next free index in the array is always the count of elements (we ensure we don't remove hooks, or if we do, we re-sort the array to eliminate gaps between entries)

	// Before we add the entry, lets ensure the entry doesn't already exist
	for (int i = 0; i < hookList->entry_count; i++) {
		if (hookList->entries[i].originalFunction == originalFunc) {
			// Target function is already hooked, release lock and return error
			ExReleaseFastMutex(hookList->lock);
			return STATUS_INVALID_PARAMETER;
		}
	}
	// If we reach here, hook doesn't exist, we can add our new hook
	hookList->entries[hookList->entry_count] = newHook;
	// Increment entry_count to the next free index
	hookList->entry_count += 1;

	InterlockedExchangePointer(originalFunc, hookDumpFunc);;

	// release hook
	ExReleaseFastMutex(hookList->lock);

	return STATUS_SUCCESS;
}

/// <summary>
/// Hooks the target function as a `FileIoHookD` type,
/// </summary>
/// <param name="originalFunc">
/// Pointer to the original function we're overwriting
/// </param>
/// <param name="hookDumpFunc">
/// Our function that will replace the original target function
/// </param>
/// <param name="driverName">
/// The name of the device driver we're hooking
/// </param>
/// <returns></returns>
NTSTATUS AddFileIOHookD(PVOID* originalFunc, PVOID hookDumpFunc, UNICODE_STRING driverName)
{

	IoHooks newHook = { 0 };
	newHook.driverName = driverName;
	newHook.originalFunction = *originalFunc;
	newHook.hookedAddress = originalFunc;

	// Use the `hookList` var for the rest of this function instead of the global, to mitigate typos
	IoHookList* hookList = fileIoHooksDArray;

	// Obtain lock to our IoHookList to prevent concurrency issues
	ExAcquireFastMutex(hookList->lock);
	// Execution has resumed, meaning we have obtained the lock, we can continue processing and ensure we release the lock
	// before returning from this function

	// Check if there is room to add a new hook
	if (hookList->entry_count == hookList->entry_max) {
		// No room to add hook, release the lock and return an error
		ExReleaseFastMutex(hookList->lock);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	// We have room to add a new hook, the array is always sorted such that there are no gaps between hooks, this means
	// the next free index in the array is always the count of elements (we ensure we don't remove hooks, or if we do, we re-sort the array to eliminate gaps between entries)

	// Before we add the entry, lets ensure the entry doesn't already exist
	for (int i = 0; i < hookList->entry_count; i++) {
		if (hookList->entries[i].originalFunction == originalFunc) {
			// Target function is already hooked, release lock and return error
			ExReleaseFastMutex(hookList->lock);
			return STATUS_INVALID_PARAMETER;
		}
	}
	// If we reach here, hook doesn't exist, we can add our new hook
	hookList->entries[hookList->entry_count] = newHook;
	// Increment entry_count to the next free index
	hookList->entry_count += 1;

	InterlockedExchangePointer(originalFunc, hookDumpFunc);;

	// release hook
	ExReleaseFastMutex(hookList->lock);

	return STATUS_SUCCESS;
}

/// <summary>
/// Hook the target `address`, saving the hook metadata into the appropriate global depending on the `type` parameter.
/// </summary>
/// <param name="address">
/// Kernel address to hook, should be a FastIo or DeviceIo function for the target driver
/// </param>
/// <param name="type">
/// Type of function we're hooking, should be a FastIo* or DeviceIo* type
/// </param>
/// <param name="driverName">
/// Name of the device driver we're hooking, used for bookkeeping purposes
/// </param>
/// <returns>
/// Success, unless the hook type is invalid
/// </returns>
NTSTATUS DoManualHook(PVOID* address, short type, UNICODE_STRING driverName)
{
	NTSTATUS status;
	PVOID hookDumpFunc;
	PVOID* originalFunc = address;
	// If type is valid, we call the appropriate hook function that will hook the address and save the hook metadata based
	// on the type.
	switch (type)
	{
	case TYPE_FASTIOD:
		hookDumpFunc = FastIoHookD; status = AddFastIOHookD(originalFunc, hookDumpFunc, driverName); break;
	case TYPE_FASTIOR:
		hookDumpFunc = FastIoHookR; status = AddFastIOHookR(originalFunc, hookDumpFunc, driverName); break;
	case TYPE_FASTIOW:
		hookDumpFunc = FastIoHookW; status = AddFastIOHookW(originalFunc, hookDumpFunc, driverName); break;
	case TYPE_DEVICEIOD:
		hookDumpFunc = DeviceIoHookD; status = AddDeviceIOHookD(originalFunc, hookDumpFunc, driverName); break;
	case TYPE_DEVICEIOR:
		hookDumpFunc = DeviceIoHookR; status = AddDeviceIOHookR(originalFunc, hookDumpFunc, driverName); break;
	case TYPE_DEVICEIOW:
		hookDumpFunc = DeviceIoHookW; status = AddDeviceIOHookW(originalFunc, hookDumpFunc, driverName); break;
	case TYPE_FILEIOD:
		hookDumpFunc = FileIoHookD; status = AddFileIOHookD(originalFunc, hookDumpFunc, driverName); break;
	default:
		return STATUS_INVALID_PARAMETER;
	}

	return status;

}

/// <summary>
/// Find the IOCTL handlers for a target device driver and hook them
/// </summary>
/// <param name="driverName">
/// The name of a target device driver to hook
/// </param>
/// <returns>
/// Status code indicating success or failure
/// </returns>
NTSTATUS DoAutoHook(UNICODE_STRING driverName)
{
	NTSTATUS status;
	PFILE_OBJECT phFile = NULL;
	PDEVICE_OBJECT phDev = NULL;
	// Use IoGetDeviceObjectPointer to get the associated Device (then, Driver) object
	// for the target, once we obtain the object we can find the IOCTL handlers inside the
	// object struct.
	status = IoGetDeviceObjectPointer(&driverName, FILE_READ_ACCESS, &phFile, &phDev);
	// Check if we succeeded, if not then print an error to any attached kernel debugger and return the appropriate
	// status to the user.
	if (!NT_SUCCESS(status))
	{
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "Error: Failed to find driver:%wZ. ",driverName));
		switch (status)
		{
		case STATUS_OBJECT_TYPE_MISMATCH:
			KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "STATUS_OBJECT_TYPE_MISMATCH.\n")); break;
		case STATUS_INVALID_PARAMETER:
			KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "STATUS_INVALID_PARAMETER.\n")); break;
		case STATUS_PRIVILEGE_NOT_HELD:
			KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "STATUS_PRIVILEGE_NOT_HELD.\n")); break;
		case STATUS_INSUFFICIENT_RESOURCES:
			KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "STATUS_INSUFFICIENT_RESOURCES.\n")); break;
		case STATUS_OBJECT_NAME_INVALID:
			KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "STATUS_OBJECT_NAME_INVALID.\n")); break;
		default:
			KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "Unknown error:%x.\n", status)); break;
		}
		
		return status;
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "Info: Attempting to hook:%wZ.\n", driverName));
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "Info: Device object:%p\n. ", phDev));
	PDRIVER_OBJECT phDriv = phDev->DriverObject;
	// Check if FastIoDispatch routines are set for our target, if they are then we ensure we hook them too
	PFAST_IO_DISPATCH fastIoDispatch = phDriv->FastIoDispatch;
	if (fastIoDispatch != NULL)
	{
		status = DoManualHook((PVOID*)&fastIoDispatch->FastIoDeviceControl, TYPE_FASTIOD, phDriv->DriverName);
		status = DoManualHook((PVOID*)&fastIoDispatch->FastIoRead, TYPE_FASTIOR, phDriv->DriverName);
		status = DoManualHook((PVOID*)&fastIoDispatch->FastIoWrite, TYPE_FASTIOW, phDriv->DriverName);
	}
	// The handlers below should always be set for any driver (if they're unimplemeneted, they'll be still be set to a dummy
	// handler, therefore its always safe to hook without checking for their existance, unlike their FastIo counterparts)
	// We hook each function, passing the address to hook and the function type & driver name to our `DoManualHook` function.
	status = DoManualHook((PVOID*)&phDriv->MajorFunction[IRP_MJ_DEVICE_CONTROL], TYPE_DEVICEIOD, phDriv->DriverName);
	status = DoManualHook((PVOID*)&phDriv->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL], TYPE_FILEIOD, phDriv->DriverName);
	status = DoManualHook((PVOID*)&phDriv->MajorFunction[IRP_MJ_READ], TYPE_DEVICEIOR, phDriv->DriverName);
	status = DoManualHook((PVOID*)&phDriv->MajorFunction[IRP_MJ_WRITE], TYPE_DEVICEIOW, phDriv->DriverName);
	return status;
}

/// <summary>
/// Parse the `HookRequest` provided by user via IOCTL.
/// We will determine what the mode is, and hook as appropriate.
/// Manual hooks will hook the user provided address and interpret it as the `HookRequest.Type` function.
/// Auto hooks will use the user-provided driverName and our knowledge of the driver structure to 
/// automatically find and hook the target driver's IOCTLs.
/// For most cases, the AutoHook mode is expected.
/// </summary>
/// <param name="hookRequest"></param>
/// <returns></returns>
NTSTATUS DoHook(HookRequest* hookRequest)
{
	NTSTATUS status;
	if (hookRequest->mode == MODE_MANUAL)
	{
		// Manual hook mode proivded, we pass the address, type, and name to perform the manual hook
		status = DoManualHook(hookRequest->address, hookRequest->type, hookRequest->driverName);
		return status;
	}
	else if (hookRequest->mode == MODE_AUTO)
	{
		// Auto hook mode provided, we pass the target driver name to our next function that will automatically find 
		// and hook the IOCTL interfaces for the target.
		status = DoAutoHook(hookRequest->driverName);
		return status;
	}
	else {
		// Invalid `HookRequest` mode passed, we return an error to the client.
		status = STATUS_ILLEGAL_FUNCTION;
	}
	return status;
}

/// <summary>
/// This function receives input from user-mode programs, here we pass the input as a `HookRequest` struct, and
/// we hook the IOCTL functions for the driver specified in the `HookRequest`. All hooks are managed in an array
/// where we can unhook them on driver unload.
/// When a hook is hit, we log the IOCTL call and input, then call the original target function for the hooked device driver.
/// </summary>
/// <param name="DeviceObject"></param>
/// <param name="Irp"></param>
/// <returns></returns>
NTSTATUS
IoDeviceControlFunc(
	PDEVICE_OBJECT DeviceObject,
	PIRP Irp
)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	NTSTATUS status = STATUS_SUCCESS;
	PIO_STACK_LOCATION irpSp;
	irpSp = IoGetCurrentIrpStackLocation(Irp);
	// Validate the input buffer length, it should be the size of a `HookRequest` struct only.
	ULONG inBufLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
	if (inBufLength != sizeof(HookRequest))
	{
		// Invalid size, return invalid parameter status to notify the client/user
		status = STATUS_INVALID_PARAMETER;
		goto End;
	}
	HookRequest* hookRequest;
	// Check the IoControlCode method, we only expect parameters to be passed via METHOD_BUFFERED, this is the only
	// ioctl we expect
	switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
	{
	case IOCTL_DUMP_METHOD_BUFFERED:
		// The parameter passing method was as expected, we can interpret the input from the user as a `HookRequest` and process this
		// in our `DoHook` function and return the status obtained from processing the input.
		// Note that since we are using METHOD_BUFFERED, it is safe to use the `SystemBuffer` directly as it is safely in kernel-memory and 
		// no longer modifiable by the user.
		hookRequest = (HookRequest*)Irp->AssociatedIrp.SystemBuffer;
		status = DoHook(hookRequest); goto End;
	
	default:
		// If we hit this code, the ioctl received did not provide the right parameter passing method we expected,
		// we return invalid parameter to notify the client.
		status = STATUS_INVALID_PARAMETER; goto End;

	}

End:
	Irp->IoStatus.Status = status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return status;
}



/// <summary>
/// Unloads our driver, if we have hooks applied we will enumerate our hooks and restore
/// them to their original code (i.e unhook).
/// </summary>
/// <param name="DriverObject"></param>
VOID
UnloadDriver(
	_In_ PDRIVER_OBJECT DriverObject
)
{

	DECLARE_UNICODE_STRING_SIZE(DosDeviceName, 40);
	RtlInitUnicodeString(&DosDeviceName, DOS_DEVICE_NAME);
	IoDeleteSymbolicLink(&DosDeviceName);
	IoDeleteDevice(DriverObject->DeviceObject);

	if (fastIoHooksDArray != NULL)
	{
		// Obtain lock to our IoHookList to prevent concurrency issues
		ExAcquireFastMutex(fastIoHooksDArray->lock);
		for (int i = 0; i < fastIoHooksDArray->entry_count; i++)
		{
			InterlockedExchangePointer((volatile PVOID*)fastIoHooksDArray->entries[i].hookedAddress,fastIoHooksDArray->entries[i].originalFunction);
		}
		ExReleaseFastMutex(fastIoHooksDArray->lock);
		ExFreePool2(fastIoHooksDArray->lock, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksDArray,'PMDI',NULL,NULL);
		
	}
	

	if (fastIoHooksWArray != NULL)
	{
		// Obtain lock to our IoHookList to prevent concurrency issues
		ExAcquireFastMutex(fastIoHooksWArray->lock);
		for (int i = 0; i < fastIoHooksWArray->entry_count; i++)
		{
			InterlockedExchangePointer((volatile PVOID*)fastIoHooksWArray->entries[i].hookedAddress,fastIoHooksWArray->entries[i].originalFunction);
		}
		ExReleaseFastMutex(fastIoHooksWArray->lock);
		ExFreePool2(fastIoHooksWArray->lock, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksWArray,'PMDI',NULL,NULL);
		
	}
	
	if (fastIoHooksRArray != NULL)
	{
		// Obtain lock to our IoHookList to prevent concurrency issues
		ExAcquireFastMutex(fastIoHooksRArray->lock);
		for (int i = 0; i < fastIoHooksRArray->entry_count; i++)
		{
			InterlockedExchangePointer((volatile PVOID*)fastIoHooksRArray->entries[i].hookedAddress, fastIoHooksRArray->entries[i].originalFunction);
		}
		ExReleaseFastMutex(fastIoHooksRArray->lock);
		ExFreePool2(fastIoHooksRArray->lock, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksRArray,'PMDI',NULL,NULL);
		
	}
	if (deviceIoHooksRArray != NULL)
	{
		// Obtain lock to our IoHookList to prevent concurrency issues
		ExAcquireFastMutex(deviceIoHooksRArray->lock);
		for (int i = 0; i < deviceIoHooksRArray->entry_count; i++)
		{
			InterlockedExchangePointer((volatile PVOID*)deviceIoHooksRArray->entries[i].hookedAddress, deviceIoHooksRArray->entries[i].originalFunction);
		}
		ExReleaseFastMutex(deviceIoHooksRArray->lock);
		ExFreePool2(deviceIoHooksRArray->lock, 'PMDI', NULL, NULL);
		ExFreePool2(deviceIoHooksRArray,'PMDI',NULL,NULL);
		
	}
	if (deviceIoHooksWArray != NULL)
	{
		// Obtain lock to our IoHookList to prevent concurrency issues
		ExAcquireFastMutex(deviceIoHooksWArray->lock);
		for (int i = 0; i < deviceIoHooksWArray->entry_count; i++)
		{
			InterlockedExchangePointer((volatile PVOID*)deviceIoHooksWArray->entries[i].hookedAddress, deviceIoHooksWArray->entries[i].originalFunction);
		}
		ExReleaseFastMutex(deviceIoHooksWArray->lock);
		ExFreePool2(deviceIoHooksWArray->lock, 'PMDI', NULL, NULL);
		ExFreePool2(deviceIoHooksWArray,'PMDI',NULL,NULL);
		
	}
	if (deviceIoHooksDArray != NULL)
	{
		// Obtain lock to our IoHookList to prevent concurrency issues
		ExAcquireFastMutex(deviceIoHooksDArray->lock);
		for (int i = 0; i < deviceIoHooksDArray->entry_count; i++)
		{
			InterlockedExchangePointer((volatile PVOID*)deviceIoHooksDArray->entries[i].hookedAddress,deviceIoHooksDArray->entries[i].originalFunction);
		}
		ExReleaseFastMutex(deviceIoHooksDArray->lock);
		ExFreePool2(deviceIoHooksDArray->lock, 'PMDI', NULL, NULL);
		ExFreePool2(deviceIoHooksDArray,'PMDI',NULL,NULL);
		
	}
	if (fileIoHooksDArray != NULL)
	{
		// Obtain lock to our IoHookList to prevent concurrency issues
		ExAcquireFastMutex(fileIoHooksDArray->lock);
		for (int i = 0; i < fileIoHooksDArray->entry_count; i++)
		{
			InterlockedExchangePointer((volatile PVOID*)fileIoHooksDArray->entries[i].hookedAddress, fileIoHooksDArray->entries[i].originalFunction);
		}
		ExReleaseFastMutex(fileIoHooksDArray->lock);
		ExFreePool2(fileIoHooksDArray->lock, 'PMDI', NULL, NULL);
		ExFreePool2(fileIoHooksDArray,'PMDI',NULL,NULL);
		
	}
	
	return;
}

/// <summary>
/// This function is called when a program attempts to open or close a handle to our device driver. We allow any program
/// that can reach this code to obtain or close handles to it.
/// </summary>
/// <param name="DeviceObject"></param>
/// <param name="Irp"></param>
/// <returns></returns>
NTSTATUS
ioctlCreateClose(
	PDEVICE_OBJECT DeviceObject,
	PIRP Irp
)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	// This code can be paged as it should only be run in PASSIVE_IRQL
	PAGED_CODE();
	// Arbitrarly allow programs to obtain/close handles
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	// Complete the requesting IRP and return success
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}


NTSTATUS
ioctlCleanup(
	_In_ PDEVICE_OBJECT DeviceObject,
	_Inout_ PIRP Irp
)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

DRIVER_INITIALIZE DriverEntry;

/// <summary>
/// Entry point for the Driver, will initialize the device for user->driver comms.
/// </summary>
/// <param name="drvObj">
/// Pointer to this Driver's `DRIVER_OBJECT` as provided by the OS
/// </param>
/// <param name="regPath">
/// Pointer to this Driver's Regpath as provided by the OS
/// </param>
/// <returns>
/// Success if there was no errors creating the associated Ioctld device. This function should always be successful unless
/// the device name has been taken (likely by another instance of this driver).
/// </returns>
NTSTATUS DriverEntry(
	PDRIVER_OBJECT drvObj,
	PUNICODE_STRING regPath
)
{
	UNREFERENCED_PARAMETER(regPath);

	NTSTATUS status;
	PDEVICE_OBJECT deviceObject;
	UNICODE_STRING ntUnicodeString;
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "Info: In DriverEntry\n"));
	// Initialize the global structs used for saving hook metadata
	// Allow at most 20 hooks per hook-type, configure this number as-per your requirements
	ULONGLONG entry_max_len = 20;
	SIZE_T entry_array_size = entry_max_len * sizeof(IoHooks);
	// Allocate enough space for our IoHookList struct + the size of our entries array
	fastIoHooksDArray = (IoHookList*) ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(IoHookList) + entry_array_size, 'PMDI');
	if (fastIoHooksDArray == NULL) {
		goto failed_allocation;
	}
	fastIoHooksRArray = (IoHookList*)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(IoHookList) + entry_array_size, 'PMDI');
	if (fastIoHooksRArray == NULL) {
		goto failed_allocation;
	}
	fastIoHooksWArray = (IoHookList*)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(IoHookList) + entry_array_size, 'PMDI');
	if (fastIoHooksWArray == NULL) {
		goto failed_allocation;
	}
	deviceIoHooksDArray = (IoHookList*)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(IoHookList) + entry_array_size, 'PMDI');
	if (deviceIoHooksDArray == NULL) {
		goto failed_allocation;
	}
	deviceIoHooksWArray = (IoHookList*)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(IoHookList) + entry_array_size, 'PMDI');
	if (deviceIoHooksWArray == NULL) {
		goto failed_allocation;
	}
	deviceIoHooksRArray = (IoHookList*)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(IoHookList) + entry_array_size, 'PMDI');
	if (deviceIoHooksRArray == NULL) {
		goto failed_allocation;
	}
	fileIoHooksDArray = (IoHookList*)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(IoHookList) + entry_array_size, 'PMDI');
	if (fileIoHooksDArray == NULL) {
		goto failed_allocation;
	}

	// Initialize the max len and entry count in our IoHookLists
	fastIoHooksDArray->entry_max = entry_max_len;
	fastIoHooksDArray->entry_count = 0;
	
	fastIoHooksRArray->entry_max = entry_max_len;
	fastIoHooksRArray->entry_count = 0;

	fastIoHooksWArray->entry_max = entry_max_len;
	fastIoHooksWArray->entry_count = 0;
	
	deviceIoHooksDArray->entry_max = entry_max_len;
	deviceIoHooksDArray->entry_count = 0;

	deviceIoHooksWArray->entry_max = entry_max_len;
	deviceIoHooksWArray->entry_count = 0;

	deviceIoHooksRArray->entry_max = entry_max_len;
	deviceIoHooksRArray->entry_count = 0;

	fileIoHooksDArray->entry_max = entry_max_len;
	fileIoHooksDArray->entry_count = 0;

	// Initialize the locks for each IoHookList
	PFAST_MUTEX fastIoHooksDMutex = (PFAST_MUTEX)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(FAST_MUTEX), 'PMDI');
	if (fastIoHooksDMutex == NULL) {
		goto failed_allocation;
	}

	PFAST_MUTEX fastIoHooksRMutex = (PFAST_MUTEX)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(FAST_MUTEX), 'PMDI');
	if (fastIoHooksRMutex == NULL) {
		ExFreePool2(fastIoHooksDMutex, 'PMDI', NULL, NULL);
		goto failed_allocation;
	}

	PFAST_MUTEX fastIoHooksWMutex = (PFAST_MUTEX)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(FAST_MUTEX), 'PMDI');
	if (fastIoHooksWMutex == NULL) {
		ExFreePool2(fastIoHooksDMutex, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksRMutex, 'PMDI', NULL, NULL);
		goto failed_allocation;
	}

	PFAST_MUTEX deviceIoHooksDMutex = (PFAST_MUTEX)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(FAST_MUTEX), 'PMDI');
	if (deviceIoHooksDMutex == NULL) {
		ExFreePool2(fastIoHooksDMutex, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksRMutex, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksWMutex, 'PMDI', NULL, NULL);
		goto failed_allocation;
	}

	PFAST_MUTEX deviceIoHooksWMutex = (PFAST_MUTEX)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(FAST_MUTEX), 'PMDI');
	if (deviceIoHooksWMutex == NULL) {
		ExFreePool2(fastIoHooksDMutex, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksRMutex, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksWMutex, 'PMDI', NULL, NULL);
		ExFreePool2(deviceIoHooksDMutex, 'PMDI', NULL, NULL);
		goto failed_allocation;
	}

	PFAST_MUTEX deviceIoHooksRMutex = (PFAST_MUTEX)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(FAST_MUTEX), 'PMDI');
	if (deviceIoHooksRMutex == NULL) {
		ExFreePool2(fastIoHooksDMutex, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksRMutex, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksWMutex, 'PMDI', NULL, NULL);
		ExFreePool2(deviceIoHooksDMutex, 'PMDI', NULL, NULL);
		ExFreePool2(deviceIoHooksWMutex, 'PMDI', NULL, NULL);
		goto failed_allocation;
	}

	PFAST_MUTEX fileIoHooksDMutex = (PFAST_MUTEX)ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(FAST_MUTEX), 'PMDI');
	if (fileIoHooksDMutex == NULL) {
		ExFreePool2(fastIoHooksDMutex, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksRMutex, 'PMDI', NULL, NULL);
		ExFreePool2(fastIoHooksWMutex, 'PMDI', NULL, NULL);
		ExFreePool2(deviceIoHooksDMutex, 'PMDI', NULL, NULL);
		ExFreePool2(deviceIoHooksWMutex, 'PMDI', NULL, NULL);
		ExFreePool2(deviceIoHooksRMutex, 'PMDI', NULL, NULL);
		goto failed_allocation;
	}
	
	// Initialize Mutex, these mutexes must be held/locked when operating
	// on their respective IoHookList
	ExInitializeFastMutex(fastIoHooksDMutex);
	ExInitializeFastMutex(fastIoHooksRMutex);
	ExInitializeFastMutex(fastIoHooksWMutex);
	ExInitializeFastMutex(deviceIoHooksDMutex);
	ExInitializeFastMutex(deviceIoHooksWMutex);
	ExInitializeFastMutex(deviceIoHooksRMutex);
	ExInitializeFastMutex(fileIoHooksDMutex);

	// Set mutex in their respective IoHookList
	fastIoHooksDArray->lock = fastIoHooksDMutex;
	fastIoHooksRArray->lock = fastIoHooksRMutex;
	fastIoHooksWArray->lock = fastIoHooksWMutex;
	deviceIoHooksDArray->lock = deviceIoHooksDMutex;
	deviceIoHooksWArray->lock = deviceIoHooksWMutex;
	deviceIoHooksRArray->lock = deviceIoHooksRMutex;
	fileIoHooksDArray->lock = fileIoHooksDMutex;


	// Create the device object for user->driver communcation
	RtlInitUnicodeString(&ntUnicodeString, NT_DEVICE_NAME);
	status = IoCreateDevice(drvObj, 0, &ntUnicodeString, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &deviceObject);
	if (!NT_SUCCESS(status))
	{
		// Likely only hit this path if the device name is taken
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "Error: Failed to create device.\n"));
		RtlFreeUnicodeString(&ntUnicodeString);
		return STATUS_FAILED_DRIVER_ENTRY;
	}
	UNICODE_STRING ntWin32NameString;
	// Create the associated DosDevice name, again for user->driver communication
	RtlInitUnicodeString(&ntWin32NameString, DOS_DEVICE_NAME);
	status = IoCreateSymbolicLink(&ntWin32NameString, &ntUnicodeString);
	if (!NT_SUCCESS(status))
	{
		KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "Error: Failed to create symbolink link for device.\n"));
		IoDeleteDevice(deviceObject);
		RtlFreeUnicodeString(&ntWin32NameString);
		RtlFreeUnicodeString(&ntUnicodeString);
		return STATUS_FAILED_DRIVER_ENTRY;
	}
	// Create a link to our IOCTL handler as we use this for user->driver communication
	drvObj->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IoDeviceControlFunc;
	// We create links to our create/close handlers to permit user programs to open and close handles
	// to our device driver.
	drvObj->MajorFunction[IRP_MJ_CREATE] = ioctlCreateClose;
	drvObj->MajorFunction[IRP_MJ_CLOSE] = ioctlCreateClose;
	// Link our cleanup routine for when the driver is unloaded
	drvObj->MajorFunction[IRP_MJ_CLEANUP] = ioctlCleanup;
	// Set the unload function to permit driver unloads
	drvObj->DriverUnload = UnloadDriver;
	// Initialization is completed, we can return success and expect calls to our create/close and IOCTL handler
	// after this point.
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "Info: Finished DriverEntry\n"));
	return STATUS_SUCCESS;

failed_allocation:
	// An allocation for one of our global IoHookLists failed, lets cleanup and return an error
	// Check if any of the allocations succeeded, and free their allocated memory.
	if (fastIoHooksDArray != NULL){
		ExFreePool2(fastIoHooksDArray, 'PMDI', NULL, NULL);
	}
	if (fastIoHooksRArray != NULL) {
		ExFreePool2(fastIoHooksRArray, 'PMDI', NULL, NULL);
	}
	if (fastIoHooksWArray != NULL) {
		ExFreePool2(fastIoHooksWArray, 'PMDI', NULL, NULL);
	}
	if (deviceIoHooksDArray != NULL) {
		ExFreePool2(deviceIoHooksDArray, 'PMDI', NULL, NULL);
	}
	if (deviceIoHooksWArray != NULL) {
		ExFreePool2(deviceIoHooksWArray, 'PMDI', NULL, NULL);
	}
	if (deviceIoHooksRArray != NULL) {
		ExFreePool2(deviceIoHooksRArray, 'PMDI', NULL, NULL);
	}
	if (fileIoHooksDArray != NULL) {
		ExFreePool2(fileIoHooksDArray, 'PMDI', NULL, NULL);
	}
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "ERROR: Failed DriverEntry\n"));
	// Return an error
	return STATUS_INSUFFICIENT_RESOURCES;
}

```

`IOCTLDumpClient/IOCTLDumpClient.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#include "ntdll.h"
#include "..\IOCTLDump\IOCTLDump.h"


#pragma warning( disable : 4996)


// No security checks, careful
int main(int argc, char* argv[])
{
	if (argc < 1)
	{
		std::cout << "Incorrect Parameters.\n";
		return 1;
	}
	HookRequest hookRequest = { 0 };
	char* devName = argv[1];
	int len = strlen(devName);
	WCHAR* devNameW = NULL;
	int req = MultiByteToWideChar(0, 0, devName, -1, devNameW, 0);
	devNameW = new WCHAR[req];
	MultiByteToWideChar(0, 0, devName, -1, devNameW, req);
	UNICODE_STRING  devNameU;
	RtlInitUnicodeString pRtlInitUnicodeString = (RtlInitUnicodeString)GetProcAddress(GetModuleHandleA("ntdll"), "RtlInitUnicodeString");
	pRtlInitUnicodeString(&devNameU, devNameW);
	printf("Sending request for driver:%wZ\n",devNameU);
	// E.g. \Device\Spaceport
	hookRequest.driverName = devNameU;
	hookRequest.address = NULL;
	hookRequest.mode = MODE_AUTO;
	hookRequest.type = NULL;
	HANDLE hDevice = CreateFileW(USR_DEVICE_NAME,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		0,
		NULL);
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		std::cout << "Failed to obtain device handle, error:" << std::hex << GetLastError();
		std::cout << "\n";
		return 2;
	}
	DWORD junk = 0;
	BOOL bResult = DeviceIoControl(hDevice,
		IOCTL_DUMP_METHOD_BUFFERED,
		&hookRequest,
		sizeof(hookRequest),
		NULL,
		0,
		&junk,
		0);
	CloseHandle(hDevice);
	if (!bResult)
	{
		std::cout << "DeviceIoControl failed, error:" << std::hex << GetLastError();
		std::cout << "\n";
		std::cout << "Usage: <exe> \\Device\\<DevName>, e.g.: IOCTLDumpClient.exe \\Device\\MyDevice\n";
		return 2;
	}
	else {
		std::cout << "Success.\n";
		return 0;
	}
}

```

`IOCTLDumpClient/IOCTLDumpClient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{A38675CF-B728-4DD5-9098-D356C33378CC}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>IOCTLDumpClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="IOCTLDumpClient.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`IOCTLDumpClient/IOCTLDumpClient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="IOCTLDumpClient.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`IOCTLDumpClient/IOCTLDumpClient.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`IOCTLDumpClient/ntdll.h`:

```h
#pragma once

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define PS_INHERIT_HANDLES                      4
#define RTL_USER_PROC_PARAMS_NORMALIZED     0x00000001
#define RELOC_32BIT_FIELD 3
#define RELOC_64BIT_FIELD 0xA
typedef LONG NTSTATUS;

typedef struct _BASE_RELOCATION_ENTRY {
    WORD Offset : 12;
    WORD Type : 4;
} BASE_RELOCATION_ENTRY, *PBASE_RELOCATION_ENTRY;


static const USHORT TXFS_MINIVERSION_DIRTY_VIEW = 0xFFFE;

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
}  OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

typedef void(_stdcall *RtlInitUnicodeString)(
	PUNICODE_STRING DestinationString,
	PCWSTR SourceString
	);

typedef NTSTATUS(_stdcall *ZwCreateSection)(
	PHANDLE            SectionHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	PLARGE_INTEGER     MaximumSize,
	ULONG              SectionPageProtection,
	ULONG              AllocationAttributes,
	HANDLE             FileHandle
);
typedef NTSTATUS(_stdcall* ZwOpenSection)(
	PHANDLE            SectionHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes
	);

typedef enum _SECTION_INHERIT {
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT, * PSECTION_INHERIT;

typedef NTSTATUS (_stdcall *ZwMapViewOfSection)(
	HANDLE          SectionHandle,
	HANDLE          ProcessHandle,
	PVOID* BaseAddress,
	ULONG_PTR       ZeroBits,
	SIZE_T          CommitSize,
	PLARGE_INTEGER  SectionOffset,
	PSIZE_T         ViewSize,
	SECTION_INHERIT InheritDisposition,
	ULONG           AllocationType,
	ULONG           Win32Protect
);
typedef NTSTATUS (_stdcall *NtCreateProcessEx)(
	PHANDLE ProcessHandle,
	ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES oa,
	HANDLE ParentProcess,
	ULONG Flags,
	HANDLE SectionHandle,
	HANDLE DebugPort,
	HANDLE ExceptionPort,
	ULONG JobFlag
	);
	
typedef struct __CLIENT_ID
{
	PVOID UniqueProcess;
	PVOID UniqueThread;
} CLIENT_ID , *PCLIENT_ID;
	
typedef NTSTATUS (_stdcall *NtOpenProcess)(
	PHANDLE            ProcessHandle,
  ACCESS_MASK        DesiredAccess,
  POBJECT_ATTRIBUTES ObjectAttributes,
  PCLIENT_ID         ClientId
	);


typedef NTSTATUS (_stdcall *NtUnmapViewOfSection)(
	HANDLE ProcessHandle,
	PVOID  BaseAddress
);

typedef NTSTATUS(_stdcall* NtOpenSection)(
	PHANDLE            SectionHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes
	);

typedef NTSTATUS(_stdcall *NtSetContextThread)(
	IN HANDLE               ThreadHandle,
	IN PCONTEXT             Context
);

typedef NTSTATUS (_stdcall *NtResumeThread)(
	IN HANDLE               ThreadHandle,
	OUT PULONG              SuspendCount OPTIONAL
);

typedef NTSTATUS(_stdcall* NtGetContextThread)(
	IN HANDLE               ThreadHandle,
	OUT PCONTEXT            pContext
	);

typedef NTSTATUS (_stdcall *RtlCreateUserThread)(



	IN HANDLE               ProcessHandle,
	IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
	IN BOOLEAN              CreateSuspended,
	IN ULONG                StackZeroBits,
	IN OUT PULONG           StackReserved,
	IN OUT PULONG           StackCommit,
	IN PVOID                StartAddress,
	IN PVOID                StartParameter OPTIONAL,
	OUT PHANDLE             ThreadHandle,
	OUT PCLIENT_ID          ClientID);

typedef enum _PROCESSINFOCLASS
{
	ProcessBasicInformation, // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
	ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
	ProcessIoCounters, // q: IO_COUNTERS
	ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
	ProcessTimes, // q: KERNEL_USER_TIMES
	ProcessBasePriority, // s: KPRIORITY
	ProcessRaisePriority, // s: ULONG
	ProcessDebugPort, // q: HANDLE
	ProcessExceptionPort, // s: PROCESS_EXCEPTION_PORT
	ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
	ProcessLdtInformation, // qs: PROCESS_LDT_INFORMATION // 10
	ProcessLdtSize, // s: PROCESS_LDT_SIZE
	ProcessDefaultHardErrorMode, // qs: ULONG
	ProcessIoPortHandlers, // (kernel-mode only)
	ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
	ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
	ProcessUserModeIOPL,
	ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
	ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
	ProcessWx86Information,
	ProcessHandleCount, // q: ULONG, PROCESS_HANDLE_INFORMATION // 20
	ProcessAffinityMask, // s: KAFFINITY
	ProcessPriorityBoost, // qs: ULONG
	ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
	ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
	ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
	ProcessWow64Information, // q: ULONG_PTR
	ProcessImageFileName, // q: UNICODE_STRING
	ProcessLUIDDeviceMapsEnabled, // q: ULONG
	ProcessBreakOnTermination, // qs: ULONG
	ProcessDebugObjectHandle, // q: HANDLE // 30
	ProcessDebugFlags, // qs: ULONG
	ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
	ProcessIoPriority, // qs: IO_PRIORITY_HINT
	ProcessExecuteFlags, // qs: ULONG
	ProcessResourceManagement, // ProcessTlsInformation // PROCESS_TLS_INFORMATION
	ProcessCookie, // q: ULONG
	ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
	ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
	ProcessPagePriority, // q: PAGE_PRIORITY_INFORMATION
	ProcessInstrumentationCallback, // qs: PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION // 40
	ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
	ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]
	ProcessImageFileNameWin32, // q: UNICODE_STRING
	ProcessImageFileMapping, // q: HANDLE (input)
	ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
	ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
	ProcessGroupInformation, // q: USHORT[]
	ProcessTokenVirtualizationEnabled, // s: ULONG
	ProcessConsoleHostProcess, // q: ULONG_PTR // ProcessOwnerInformation
	ProcessWindowInformation, // q: PROCESS_WINDOW_INFORMATION // 50
	ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
	ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
	ProcessDynamicFunctionTableInformation,
	ProcessHandleCheckingMode, // qs: ULONG; s: 0 disables, otherwise enables
	ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
	ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
	ProcessWorkingSetControl, // s: PROCESS_WORKING_SET_CONTROL
	ProcessHandleTable, // q: ULONG[] // since WINBLUE
	ProcessCheckStackExtentsMode,
	ProcessCommandLineInformation, // q: UNICODE_STRING // 60
	ProcessProtectionInformation, // q: PS_PROTECTION
	ProcessMemoryExhaustion, // PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
	ProcessFaultInformation, // PROCESS_FAULT_INFORMATION
	ProcessTelemetryIdInformation, // PROCESS_TELEMETRY_ID_INFORMATION
	ProcessCommitReleaseInformation, // PROCESS_COMMIT_RELEASE_INFORMATION
	ProcessDefaultCpuSetsInformation,
	ProcessAllowedCpuSetsInformation,
	ProcessSubsystemProcess,
	ProcessJobMemoryInformation, // PROCESS_JOB_MEMORY_INFO
	ProcessInPrivate, // since THRESHOLD2 // 70
	ProcessRaiseUMExceptionOnInvalidHandleClose, // qs: ULONG; s: 0 disables, otherwise enables
	ProcessIumChallengeResponse,
	ProcessChildProcessInformation, // PROCESS_CHILD_PROCESS_INFORMATION
	ProcessHighGraphicsPriorityInformation,
	ProcessSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
	ProcessEnergyValues, // PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES
	ProcessActivityThrottleState, // PROCESS_ACTIVITY_THROTTLE_STATE
	ProcessActivityThrottlePolicy, // PROCESS_ACTIVITY_THROTTLE_POLICY
	ProcessWin32kSyscallFilterInformation,
	ProcessDisableSystemAllowedCpuSets, // 80
	ProcessWakeInformation, // PROCESS_WAKE_INFORMATION
	ProcessEnergyTrackingState, // PROCESS_ENERGY_TRACKING_STATE
	ProcessManageWritesToExecutableMemory, // MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
	ProcessCaptureTrustletLiveDump,
	ProcessTelemetryCoverage,
	ProcessEnclaveInformation,
	ProcessEnableReadWriteVmLogging, // PROCESS_READWRITEVM_LOGGING_INFORMATION
	ProcessUptimeInformation, // PROCESS_UPTIME_INFORMATION
	ProcessImageSection, // q: HANDLE
	ProcessDebugAuthInformation, // since REDSTONE4 // 90
	ProcessSystemResourceManagement, // PROCESS_SYSTEM_RESOURCE_MANAGEMENT
	ProcessSequenceNumber, // q: ULONGLONG
	ProcessLoaderDetour, // since REDSTONE5
	ProcessSecurityDomainInformation, // PROCESS_SECURITY_DOMAIN_INFORMATION
	ProcessCombineSecurityDomainsInformation, // PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION
	ProcessEnableLogging, // PROCESS_LOGGING_INFORMATION
	ProcessLeapSecondInformation, // PROCESS_LEAP_SECOND_INFORMATION
	ProcessFiberShadowStackAllocation, // PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION // since 19H1
	ProcessFreeFiberShadowStackAllocation, // PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION
	MaxProcessInfoClass
} PROCESSINFOCLASS;

typedef LONG KPRIORITY;

typedef struct _PROCESS_BASIC_INFORMATION {
	NTSTATUS ExitStatus;
	PVOID PebBaseAddress;
	ULONG_PTR AffinityMask;
	KPRIORITY BasePriority;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;

typedef NTSTATUS (_stdcall *NtQueryInformationProcess)(
	HANDLE           ProcessHandle,
	PROCESSINFOCLASS ProcessInformationClass,
	PVOID           ProcessInformation,
	ULONG            ProcessInformationLength,
	PULONG          ReturnLength
);

typedef PIMAGE_NT_HEADERS (_stdcall *RtlImageNtHeader)(
	PVOID Base
);

//LPRTLIMAGENTHEADER			RtlImageNtHeader;

typedef NTSTATUS (_stdcall *NtClose)(
	HANDLE Handle
);

typedef NTSTATUS (_stdcall *NtCreateTransaction)(
	_Out_     PHANDLE TransactionHandle,
	_In_      ACCESS_MASK DesiredAccess,
	_In_opt_  POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_  LPGUID Uow,
	_In_opt_  HANDLE TmHandle,
	_In_opt_  ULONG CreateOptions,
	_In_opt_  ULONG IsolationLevel,
	_In_opt_  ULONG IsolationFlags,
	_In_opt_  PLARGE_INTEGER Timeout,
	_In_opt_  PUNICODE_STRING Description
);

typedef struct _PEB_LDR_DATA {
	ULONG                   Length;
	BOOLEAN                 Initialized;
	PVOID                   SsHandle;
	LIST_ENTRY              InLoadOrderModuleList;
	LIST_ENTRY              InMemoryOrderModuleList;
	LIST_ENTRY              InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _RTL_DRIVE_LETTER_CURDIR {
	USHORT                  Flags;
	USHORT                  Length;
	ULONG                   TimeStamp;
	UNICODE_STRING          DosPath;
} RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;

typedef struct _CURDIR
{
	UNICODE_STRING DosPath;
	HANDLE Handle;
} CURDIR, * PCURDIR;

#define RTL_MAX_DRIVE_LETTERS 32

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;
	ULONG Length;

	ULONG Flags;
	ULONG DebugFlags;

	HANDLE ConsoleHandle;
	ULONG ConsoleFlags;
	HANDLE StandardInput;
	HANDLE StandardOutput;
	HANDLE StandardError;

	CURDIR CurrentDirectory;
	UNICODE_STRING DllPath;
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
	PVOID Environment;

	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;

	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING WindowTitle;
	UNICODE_STRING DesktopInfo;
	UNICODE_STRING ShellInfo;
	UNICODE_STRING RuntimeData;
	RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

	ULONG EnvironmentSize;
	ULONG EnvironmentVersion;
	PVOID PackageDependencyData; //8+
	ULONG ProcessGroupId;
	// ULONG LoaderThreads;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef void (*PPEBLOCKROUTINE)(
	PVOID PebLock
	);

typedef struct _PEB_FREE_BLOCK {
	_PEB_FREE_BLOCK* Next;
	ULONG                   Size;
} PEB_FREE_BLOCK, * PPEB_FREE_BLOCK;

typedef struct _PEB {
	BOOLEAN                 InheritedAddressSpace;
	BOOLEAN                 ReadImageFileExecOptions;
	BOOLEAN                 BeingDebugged;
	BOOLEAN                 Spare;
	HANDLE                  Mutant;
	PVOID                   ImageBaseAddress;
	PPEB_LDR_DATA           LoaderData;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID                   SubSystemData;
	PVOID                   ProcessHeap;
	PVOID                   FastPebLock;
	PPEBLOCKROUTINE         FastPebLockRoutine;
	PPEBLOCKROUTINE         FastPebUnlockRoutine;
	ULONG                   EnvironmentUpdateCount;
	PVOID* KernelCallbackTable;
	PVOID                   EventLogSection;
	PVOID                   EventLog;
	PPEB_FREE_BLOCK         FreeList;
	ULONG                   TlsExpansionCounter;
	PVOID                   TlsBitmap;
	ULONG                   TlsBitmapBits[0x2];
	PVOID                   ReadOnlySharedMemoryBase;
	PVOID                   ReadOnlySharedMemoryHeap;
	PVOID* ReadOnlyStaticServerData;
	PVOID                   AnsiCodePageData;
	PVOID                   OemCodePageData;
	PVOID                   UnicodeCaseTableData;
	ULONG                   NumberOfProcessors;
	ULONG                   NtGlobalFlag;
	BYTE                    Spare2[0x4];
	LARGE_INTEGER           CriticalSectionTimeout;
	ULONG                   HeapSegmentReserve;
	ULONG                   HeapSegmentCommit;
	ULONG                   HeapDeCommitTotalFreeThreshold;
	ULONG                   HeapDeCommitFreeBlockThreshold;
	ULONG                   NumberOfHeaps;
	ULONG                   MaximumNumberOfHeaps;
	PVOID** ProcessHeaps;
	PVOID                   GdiSharedHandleTable;
	PVOID                   ProcessStarterHelper;
	PVOID                   GdiDCAttributeList;
	PVOID                   LoaderLock;
	ULONG                   OSMajorVersion;
	ULONG                   OSMinorVersion;
	ULONG                   OSBuildNumber;
	ULONG                   OSPlatformId;
	ULONG                   ImageSubSystem;
	ULONG                   ImageSubSystemMajorVersion;
	ULONG                   ImageSubSystemMinorVersion;
	ULONG                   GdiHandleBuffer[0x22];
	ULONG                   PostProcessInitRoutine;
	ULONG                   TlsExpansionBitmap;
	BYTE                    TlsExpansionBitmapBits[0x80];
	ULONG                   SessionId;
} PEB, * PPEB;

typedef NTSTATUS(_stdcall *NtCreateThreadEx)
(
	PHANDLE hThread,
	ACCESS_MASK DesiredAccess,
	LPVOID ObjectAttributes,
	HANDLE ProcessHandle,
	LPTHREAD_START_ROUTINE lpStartAddress,
	LPVOID lpParameter,
	BOOL CreateSuspended,
	ULONG StackZeroBits,
	ULONG SizeOfStackCommit,
	ULONG SizeOfStackReserve,
	LPVOID lpBytesBuffer
);

typedef NTSTATUS(_stdcall *NtFreeVirtualMemory)(
	HANDLE  ProcessHandle,
	PVOID* BaseAddress,
	PSIZE_T RegionSize,
	ULONG   FreeType
);

typedef NTSTATUS(_stdcall *RtlCreateProcessParametersEx)(
	PRTL_USER_PROCESS_PARAMETERS* pProcessParameters,
	PUNICODE_STRING ImagePathName,
	PUNICODE_STRING DllPath,
	PUNICODE_STRING CurrentDirectory,
	PUNICODE_STRING CommandLine,
	PVOID Environment,
	PUNICODE_STRING WindowTitle,
	PUNICODE_STRING DesktopInfo,
	PUNICODE_STRING ShellInfo,
	PUNICODE_STRING RuntimeData,
	ULONG Flags);


```

`README.md`:

```md
# IOCTLDump

IOCTLDump is a driver that can be used for hooking and dumping IOCTLS (including FastIO & RW interactions) of other device drivers.

It will log the IOCTL request information in a .conf file (the IOCTL code, whether its from DeviceIO or FastIO or RW, the input & output buffer sizes).

It will also log the input buffer contents in a .data file.

Note that for each (IOCTL & Input Buffer Size) combination, only one will be saved (e.g. if a hooked IOCTL recieves a request for an IOCTL we've seen before, and with the exact same input buffer size we've seen before, we don't log it).

## Usage

Install the driver on your system 
` sc create ioctld binPath= c:\tmp\IOCTLDump.sys type= kernel `
` sc start ioctld`

Then, use IOCTLDumpClient.exe to interact with the driver to hook another driver, e.g.

` IOCTLDumpClient.exe \Device\SomeDeviceToHook `

Then, intercepted IOCTLs will be dumped as per the design.txt file in C:\DriverHooks


## Notes

By default this driver targets Windows 11.

To target Windows 10, ensure you have 'W10' defined in your visual studio preprocessor definitions.

```

`design2.txt`:

```txt
formats: C:\DriverHooks\<drvname>\<devname>\<hooktype>\<hookspecificlayout>...
	 C:\DriverHooks\<drvname>\<devname>\<hooktype>\<dev|fast>IO<W|R>\<len.conf len.data>
	 C:\DriverHooks\<drvname>\<devname>\<hooktype>\<dev|fast>IOD\<ioctl>\<len.conf len.data>



conf format:
DriverName:<drvname>
Type:<hooktype>
IOCTL:<ifapplicable>
InputBufferLength:<ifapplicable>
OutputBufferLength:<ifapplicable>

c:\DriverHooks\mfehidk\mfehidk\fastIOR\23.conf
c:\DriverHooks\mfehidk\mfehidk\fastIOR\23.data
```