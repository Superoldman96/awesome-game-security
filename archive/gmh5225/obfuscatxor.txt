Project Path: arc_gmh5225_obfuscatxor_hzidk7m1

Source Tree:

```txt
arc_gmh5225_obfuscatxor_hzidk7m1
├── LICENSE
├── README.md
├── cmd
│   └── obfuscator
│       ├── hash.go
│       ├── obfuscate.go
│       ├── obfuscator.go
│       ├── source.go
│       ├── string.go
│       └── template.go
├── example
│   └── strings.go
└── go.mod

```

`LICENSE`:

```

					#YOLO Public License (YPL) v0.12.34-hunter.2
 This software is provided as is and free of charge.  It can be redesigned, redistributed,
 refrigerated, remade, reheated, and regifted in part or in whole by any person, corporation, rodent, or wet floor sign
 for fun or profit or hookers and blow. Marsupials, and all other inanimate objects are prohibited from using this software.
 In exchange, just give me credit for inspiring you to steal my code like Carlos Mencia steals jokes.  I steal a bunch too so you're
 probably just getting sloppy seconds anyways. Shout out to Stack Exchange/Overflow for giving me help via shitty code snippets whenever 
 I got stuck.

 Keep in mind I'm not a dev and can barely write good English let alone good code.  This software is likely buggy as hell 
 and is provided AS IS with no warranty real, imagined, fabricated, fornicated or pulled from a magic hat that this software is 
 suitable for any purpose, porpise, or tortise, unless it's also a florist.  To be honest, you probably should not even use this in any
 environment you want to have working right. If by some miracle this code works and you see me at a con then you owe me beer or some kind 
 of booze except for smirnoff ice because that shit is fucking gross.

 In short, you can't sue me if you decide to use this code that I'm putting out there for free and shit goes terribly wrong. I'm talking
 deleting your root with no backups type of bad shit happenning. I'm just as broke as this code and you'll just be pissing into the wind
 on that endeavor.  I already warned you that my code is bad.  Read through it and make sure you know what it does, or have your cousin
 that took a web design class in high school help you figure out what it does.
 


 ...Or just take my word for it and wing it. #YOLO
8=====D
```

`README.md`:

```md
# Obfuscatxor

#### Overview

Very simple string obfuscation package for (near) compile-time obfuscation and hash processing.

Functionality provided at present:

- XOR strings with variable-length key
- Generate CRC64 hashes of strings

_Updated with a suggestion from [C-Sto](https://x.com/C__Sto/status/1707590550906659059?s=20) to include the XOR and hashing functions inside the template to avoid loading the external library._

#### Compile-time usage

Create a file (ex: `strings.go`) using the following format:
~~~go
//go:generate go run github.com/redskal/obfuscatxor/cmd/obfuscator -output strings-out.go strings.go
package testing

//obfuscate Key(ObfuscateThis) Phrase(Just a test string) VarName(test1)
//obfuscate Key(ObfuscateMe) Phrase(Something, something, whatever, whatever) VarName(test2)

//hash phrase(hash me please) VarName(hash1)
//hash phrase(another thing to hash) varname(hash2)
~~~

When you use `go generate` the compiler will parse the `//go:generate` comment and use the obfuscator tool to produce an output file containing your XOR'd strings and CRC64 hashes. The generated variables can then be used in your code.

Output file will look like this:

~~~go
// Code generated by 'go generate'; DO NOT EDIT

package testing

import (
	"hash/crc64"
	"math/rand"
)

var hashTable = crc64.MakeTable(crc64.ECMA)

var (
	// Key: "ObfuscateThis", String: "Just a test string"
	test1 = []byte{
		0x05, 0x17, 0x15, 0x01, 0x53, 0x02, 0x41, 0x00, 0x00, 0x27, 0x1c, 0x49, 0x00, 0x3b, 0x10,
		0x0f, 0x1b, 0x14}
	// Key: "ObfuscateMe", String: "Something, something, whatever, whatever"
	test2 = []byte{
		0x1c, 0x0d, 0x0b, 0x10, 0x07, 0x0b, 0x08, 0x1a, 0x02, 0x61, 0x45, 0x3c, 0x0d, 0x0b, 0x10,
		0x07, 0x0b, 0x08, 0x1a, 0x02, 0x61, 0x45, 0x38, 0x0a, 0x07, 0x01, 0x16, 0x15, 0x04, 0x06,
		0x49, 0x6d, 0x12, 0x27, 0x03, 0x12, 0x10, 0x05, 0x06, 0x13}

	hash1 uint64 = 4933402316976831528  // String: "hash me please"
	hash2 uint64 = 15307073676716255198 // String: "another thing to hash"

)
[...SNIP...]
~~~

Just make sure the file is included in your project, and you'll have your obfuscated strings and the necessary functions included.

#### Usage

To use the string XOR function do as follows:
~~~go
import "fmt"

func main() {
    // Key: "ObfuscateThis", String: "Just a test string"
	test1 = []byte{
		0x05, 0x17, 0x15, 0x01, 0x53, 0x02, 0x41, 0x00, 0x00, 0x27, 0x1c, 0x49, 0x00, 0x3b, 0x10,
		0x0f, 0x1b, 0x14}
    fmt.Println(StringXOR(string(test1), "ObfuscateThis"))
}
~~~

Output will be:

~~~
Just a test string
~~~

To use the CRC64 hashing it's equally as simple:

~~~go
import "fmt"

func main() {
    hash1 uint64 := 4933402316976831528
    str := "hash me please"
    if hash1 == obfuscate.GetCRCHash(str) {
        fmt.Println("It's the same")
    } else {
        fmt.Println("Wrong-o!")
    }
}
~~~

Output will be:

~~~
It's the same
~~~

#### Licence

Respect the licence of any and all third party code. Anything that's mine is provided under #YOLO Public License.

```

`cmd/obfuscator/hash.go`:

```go
/*
  For processing the strings to be added to output as CRC64 hashes
*/
package main

type CRCHash struct {
	Plaintext string
	Hash      string
	Varname   string
}

func (c *CRCHash) GetPlaintext() string {
	return c.Plaintext
}

func (c *CRCHash) GetHash() string {
	return c.Hash
}

func (c *CRCHash) GetVarName() string {
	return c.Varname
}

```

`cmd/obfuscator/obfuscate.go`:

```go
package main

import (
	"hash/crc64"
	"math/rand"
)

var hashTable = crc64.MakeTable(crc64.ECMA)

// SetHashTable sets HashTable used for crc64 checksums to specified value.
func SetCRCHashTable(table uint64) {
	hashTable = crc64.MakeTable(table)
}

// RandomiseHashTable sets HashTable used for crc64 checksums to a random value.
func RandomiseCRCHashTable() {
	hashTable = crc64.MakeTable(rand.Uint64())
}

// GetHash returns the crc64 hash of the specified string.
func GetCRCHash(input string) uint64 {
	return crc64.Checksum([]byte(input), hashTable)
}

// StringXOR taken from https://kylewbanks.com/blog/xor-encryption-using-go
func StringXOR(input, key string) (output string) {
	for i := 0; i < len(input); i++ {
		output += string(input[i] ^ key[i%len(key)])
	}
	return
}

```

`cmd/obfuscator/obfuscator.go`:

```go
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
)

const (
	prefixObfuscate = "//obfuscate"
	prefixHash      = "//hash"
)

var (
	outFile = flag.String("output", "", "Output file name")
)

func usage() {
	fmt.Fprintf(os.Stderr, "usage: obfuscator [flags] [path ...]\n")
	flag.PrintDefaults()
	os.Exit(1)
}

func main() {
	flag.Usage = usage
	flag.Parse()
	if len(flag.Args()) <= 0 {
		fmt.Fprintf(os.Stderr, "no files to parse provided.\n")
		usage()
	}

	// parse our source code files
	src, err := ParseFiles(flag.Args())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing files: "+err.Error())
	}

	// generate the new source code file
	var buf bytes.Buffer
	if err := src.Generate(&buf); err != nil {
		log.Fatal(err)
	}
	data, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if *outFile == "" {
		_, err = os.Stdout.Write(data)
	} else {
		err = os.WriteFile(*outFile, data, 0644)
	}
	if err != nil {
		log.Fatal(err)
	}
}

```

`cmd/obfuscator/source.go`:

```go
/*
For generating the source code file from the structs that have
been populated.
*/
package main

import (
	"bufio"
	"errors"
	"fmt"
	"go/parser"
	"go/token"
	"io"
	"os"
	"strconv"
	"strings"
	"text/template"
)

const (
	OBS_STRING = iota + 1
	OBS_HASH
)

type Source struct {
	String      []*ObsString
	Hash        []*CRCHash
	PackageName string
}

// ParseFiles parses files into a Source instance
func ParseFiles(files []string) (*Source, error) {
	// instantiate a new Source struct
	src := &Source{
		String: make([]*ObsString, 0),
	}

	// process the files provided
	for _, file := range files {
		if err := src.ParseFile(file); err != nil {
			return nil, err
		}
	}

	return src, nil
}

// ParseFile adds additional string entries to Source
func (src *Source) ParseFile(path string) error {
	// open the file provided
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	defer file.Close()

	// new scanner, innit
	s := bufio.NewScanner(file)
	for s.Scan() {
		t := strings.TrimSpace(s.Text())

		// not the droid you are looking for
		if !strings.HasPrefix(t, prefixObfuscate) && !strings.HasPrefix(t, prefixHash) {
			continue
		}

		// we're not interested in the prefix
		var obfuscate bool // used to judge between xor and crc hash
		if strings.HasPrefix(t, prefixObfuscate) {
			t = t[len(prefixObfuscate):]
			obfuscate = true
		} else if strings.HasPrefix(t, prefixHash) {
			t = t[len(prefixHash):]
			obfuscate = false
		}

		// a weird false positive?
		if !(t[0] == ' ' || t[0] == '\t') {
			continue
		}
		// no thanks, whitespace
		t = strings.TrimSpace(t)

		// process the string we have either through xor or hashing
		if obfuscate {
			str, err := newString(t)
			if err != nil {
				return err
			}
			src.String = append(src.String, str)
		} else {
			hsh, err := newHash(t)
			if err != nil {
				return err
			}
			src.Hash = append(src.Hash, hsh)
		}
	}
	if err := s.Err(); err != nil {
		return err
	}

	// get the package name
	fset := token.NewFileSet()
	_, err = file.Seek(0, 0)
	if err != nil {
		return err
	}

	pkg, err := parser.ParseFile(fset, "", file, parser.PackageClauseOnly)
	if err != nil {
		return err
	}
	src.PackageName = pkg.Name.Name

	return nil
}

// Generate output source file
func (src *Source) Generate(w io.Writer) error {
	// create our function map
	funcMap := template.FuncMap{
		"packagename": src.GetPackageName,
	}

	// process template and write to w
	t := template.Must(template.New("main").Funcs(funcMap).Parse(outTemplate))
	err := t.Execute(w, src)
	if err != nil {
		return errors.New("Failed to execute template: " + err.Error())
	}
	return nil
}

// GetPackageName returns the package name of src
func (src *Source) GetPackageName() string {
	return src.PackageName
}

// newHash parses string s and returns CRCHash
func newHash(s string) (*CRCHash, error) {
	s = strings.TrimSpace(s)

	crc := &CRCHash{}

	var p string
	var b string
	var found bool
	for i := 0; i <= 1; i++ {
		p, b, s, found = extractSection(s, '(', ')')
		if !found {
			return nil, errors.New("Could not extract information from \"" + s + "\"")
		}
		switch strings.ToLower(p) {
		case "phrase":
			crc.Plaintext = b
		case "varname":
			crc.Varname = b
		}

	}
	fmt.Printf("DEBUG: hash(phrase=\"%s\" varname=\"%s\")\n", crc.Plaintext, crc.Varname)

	// Can't hash a non-existant string or delcare it if name is not known
	if crc.Plaintext == "" || crc.Varname == "" {
		return nil, errors.New("variable name or plaintext string not supplied")
	}

	// hash the string using ECMA CRC64 hash table
	uintHash := GetCRCHash(crc.Plaintext)
	crc.Hash = strconv.FormatUint(uintHash, 10)

	return crc, nil
}

// newString parses string s and returns an ObsString.
func newString(s string) (*ObsString, error) {
	s = strings.TrimSpace(s)

	str := &ObsString{}

	// extract the 3 strings
	var p string
	var b string
	var found bool
	for i := 0; i <= 2; i++ {
		p, b, s, found = extractSection(s, '(', ')')
		if !found || !containsWord(p) {
			return nil, errors.New("Could not extract information from \"" + s + "\".")
		}
		switch strings.ToLower(p) {
		case "key":
			str.Key = b
		case "phrase":
			str.Plaintext = b
		case "varname":
			str.Varname = b
		}
	}
	fmt.Printf("DEBUG: obfuscate(key=\"%s\" phrase=\"%s\" varname=\"%s\")\n", str.GetKey(), str.GetPlaintext(), str.GetVarName())

	// we can't encrypt the string and produce output without these.
	if str.Key == "" || str.Plaintext == "" || str.Varname == "" {
		return nil, errors.New("key, variable name, or plaintext string not supplied")
	}

	// encrypt the string and get a pretty version
	str.Encrypted = []byte(StringXOR(str.Plaintext, str.Key))
	str.EncryptedPretty = prettifyBytes(str.Encrypted)

	return str, nil
}

// prettifyBytes makes a printable version of the encrypted string for adding
// to the output source file
func prettifyBytes(b []byte) (pretty string) {
	for i, v := range b {
		if (i % 15) == 0 {
			pretty += "\n"
		}
		if i != (len(b) - 1) {
			pretty += fmt.Sprintf("0x%02x", v) + ", "
		} else {
			pretty += fmt.Sprintf("0x%02x", v)
		}
	}
	pretty = fmt.Sprintf("[]byte{%s }", pretty)
	return
}

// containsWord is a helper function for checking the strings extracted
// for the correct formatting. Makes newString less ugly to read.
func containsWord(s string) bool {
	return (strings.ToLower(s) == "key" || strings.ToLower(s) == "phrase" ||
		strings.ToLower(s) == "varname")
}

// extractSection extracts text out of string s starting after start
// and ending just before end. found return value will indicate success,
// and prefix, body and suffix will contain correspondent parts of string s.
func extractSection(s string, start, end rune) (prefix, body, suffix string, found bool) {
	// ripped straight from https://github.com/C-Sto/BananaPhone/blob/master/cmd/mkdirectwinsyscall/function.go
	// which was ripped from https://cs.opensource.google/go/x/sys/+/5a0f0661:windows/mkwinsyscall/mkwinsyscall.go;l=403
	s = strings.TrimSpace(s)
	if strings.HasPrefix(s, string(start)) {
		// no prefix
		body = s[1:]
	} else {
		a := strings.SplitN(s, string(start), 2)
		if len(a) != 2 {
			suffix = s
			found = false
			return
		}
		prefix = a[0]
		body = a[1]
	}
	a := strings.SplitN(body, string(end), 2)
	if len(a) != 2 {
		//has no end marker. suffix won't be set, but body/prefix may be
		found = false
		return
	}
	return prefix, a[0], a[1], true
}

```

`cmd/obfuscator/string.go`:

```go
/*
 For structuring the strings to be processed and included into
 the generated source code file.
*/
package main

type ObsString struct {
	Plaintext       string
	Key             string
	Varname         string
	Encrypted       []byte
	EncryptedPretty string
}

func (s *ObsString) GetPlaintext() string {
	return s.Plaintext
}

func (s *ObsString) GetKey() string {
	return s.Key
}

func (s *ObsString) GetVarName() string {
	return s.Varname
}

func (s *ObsString) GetEncrypted() []byte {
	return s.Encrypted
}

func (s *ObsString) GetPretty() string {
	return s.EncryptedPretty
}

```

`cmd/obfuscator/template.go`:

```go
/*
The template used to generate the Go source code.
*/
package main

const outTemplate = `
{{define "main"}}// Code generated by 'go generate'; DO NOT EDIT

package {{packagename}}

import (
	"hash/crc64"
	"math/rand"
)

var hashTable = crc64.MakeTable(crc64.ECMA)

var (
{{range .String}}// Key: "{{.GetKey}}", String: "{{.GetPlaintext}}"
{{.GetVarName}} = {{.GetPretty}} 
{{end}}

{{range .Hash}}{{.GetVarName}} uint64 = {{.GetHash}} // String: "{{.GetPlaintext}}"
{{end}}
)

// SetHashTable sets HashTable used for crc64 checksums to specified value.
func SetCRCHashTable(table uint64) {
	hashTable = crc64.MakeTable(table)
}

// RandomiseHashTable sets HashTable used for crc64 checksums to a random value.
func RandomiseCRCHashTable() {
	hashTable = crc64.MakeTable(rand.Uint64())
}

// GetHash returns the crc64 hash of the specified string.
func GetCRCHash(input string) uint64 {
	return crc64.Checksum([]byte(input), hashTable)
}

// StringXOR taken from https://kylewbanks.com/blog/xor-encryption-using-go
func StringXOR(input, key string) (output string) {
	for i := 0; i < len(input); i++ {
		output += string(input[i] ^ key[i%len(key)])
	}
	return
}
{{end}}
`

```

`example/strings.go`:

```go
//go:generate go run github.com/redskal/obfuscatxor/cmd/obfuscator -output strings-out.go strings.go
package testing

//obfuscate Key(ObfuscateThis) Phrase(Just a test string) VarName(test1)
//obfuscate Key(ObfuscateMe) Phrase(Something, something, whatever, whatever) VarName(test2)

//hash phrase(hash me please) VarName(hash1)
//hash phrase(another thing to hash) varname(hash2)

```

`go.mod`:

```mod
module github.com/redskal/obfuscatxor

go 1.20

```