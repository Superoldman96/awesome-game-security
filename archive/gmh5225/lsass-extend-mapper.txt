Project Path: arc_gmh5225_lsass-extend-mapper_z5wojd1g

Source Tree:

```txt
arc_gmh5225_lsass-extend-mapper_z5wojd1g
├── README.md
├── elevation.hpp
├── entry.cpp
├── lsass-extend-mapper.sln
├── lsass-extend-mapper.vcxproj
├── lsass-extend-mapper.vcxproj.filters
├── lsass.hpp
├── nt.hpp
├── process.cpp
└── process.hpp

```

`README.md`:

```md
# lsass-extend-mapper
Manual mapper from LSASS which extends an already existing module inside the target process

# Note
Due to school-related reasons I cannot finish this project as of now, and I might not even finish it.

```

`elevation.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <iostream>
#include <thread>

// Shoutout to Ian
// love you bro <3
namespace privelege {

	// Get current path to executable
	static auto get_file_path(char* out) -> void
	{
		char file_name[MAX_PATH];
		GetModuleFileNameA(nullptr, file_name, sizeof file_name);
		GetFullPathNameA(file_name, sizeof file_name, out, nullptr);
	}

	// Check if the current process is elevated
	static auto is_elevated() -> bool {
		auto* token = HANDLE{};

		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &token))
			return false;
		
		auto size = DWORD{};
		auto elevation = TOKEN_ELEVATION{};

		if (!GetTokenInformation(token, TokenElevation, &elevation, sizeof elevation, &size))
			return false;

		CloseHandle(token);

		return elevation.TokenIsElevated;
	}

	// Set dbg privelege
	static auto set_dbg_privelege(bool val) -> bool {
		auto priveleges = TOKEN_PRIVILEGES{};
		auto token = HANDLE{};

		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) {

			if (token)
				CloseHandle(token);

			return false;
		}

		auto luid = LUID{};
		if (!LookupPrivilegeValueA(0, SE_DEBUG_NAME, &luid)) {
			CloseHandle(token);
			return false;
		}

		priveleges.PrivilegeCount = 1;
		priveleges.Privileges[0].Luid = luid;
		priveleges.Privileges[0].Attributes = val ? SE_PRIVILEGE_ENABLED : SE_PRIVILEGE_REMOVED;

		if (!AdjustTokenPrivileges(token, false, &priveleges, 0, 0, 0)) {
			CloseHandle(token);
			return false;
		}

		CloseHandle(token);
		return true;
	}

	// Ensure the process we're running is actually elevated,
	// that way we can access LSASS
	static auto ensure_elevation() -> void {
		if (!is_elevated())
		{
			// Request runas...
			char file_path[MAX_PATH];
			get_file_path(file_path);

			ShellExecuteA(nullptr, "runas", file_path, "", nullptr, SW_SHOWNORMAL);

			exit(0);
		}

		// Set debug privelege so that we can actually access lsass...
		if (!set_dbg_privelege(true))
			__fastfail(0);
	}
}
```

`entry.cpp`:

```cpp
 
#include "process.hpp"
#include "elevation.hpp"

#include <fstream>
#include <filesystem>

#include "lsass.hpp"

int main()
{
	privelege::ensure_elevation();

	lsass::map_into_lsass("C:\\Users\\Zor\\Crates\\lsass-cpp\\test_project\\x64\\Release\\test_project.dll", "minecraft");
}
```

`lsass-extend-mapper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31515.178
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "lsass-extend-mapper", "lsass-extend-mapper.vcxproj", "{6F4BD057-23F5-439B-A75B-E8C52ED4B186}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6F4BD057-23F5-439B-A75B-E8C52ED4B186}.Debug|x64.ActiveCfg = Debug|x64
		{6F4BD057-23F5-439B-A75B-E8C52ED4B186}.Debug|x64.Build.0 = Debug|x64
		{6F4BD057-23F5-439B-A75B-E8C52ED4B186}.Debug|x86.ActiveCfg = Debug|Win32
		{6F4BD057-23F5-439B-A75B-E8C52ED4B186}.Debug|x86.Build.0 = Debug|Win32
		{6F4BD057-23F5-439B-A75B-E8C52ED4B186}.Release|x64.ActiveCfg = Release|x64
		{6F4BD057-23F5-439B-A75B-E8C52ED4B186}.Release|x64.Build.0 = Release|x64
		{6F4BD057-23F5-439B-A75B-E8C52ED4B186}.Release|x86.ActiveCfg = Release|Win32
		{6F4BD057-23F5-439B-A75B-E8C52ED4B186}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {95E10F2C-2277-47B6-8075-7D193DEF0D14}
	EndGlobalSection
EndGlobal

```

`lsass-extend-mapper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{6f4bd057-23f5-439b-a75b-e8c52ed4b186}</ProjectGuid>
    <RootNamespace>lsassextendmapper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp" />
    <ClCompile Include="process.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="elevation.hpp" />
    <ClInclude Include="lsass.hpp" />
    <ClInclude Include="nt.hpp" />
    <ClInclude Include="process.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`lsass-extend-mapper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="process.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="elevation.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="process.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="nt.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="lsass.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`lsass.hpp`:

```hpp
#pragma once

#include <filesystem>
#include <fstream>

#include "process.hpp"

namespace lsass {
	
	constexpr auto SIZE_OF_MAPPER	= 0x255; // note: this size is +A
	constexpr auto SIZE_OF_UTIL		= 0xD6; // same here

	namespace utils {
		using LoadLibraryFn      = HINSTANCE(WINAPI*)(const char* lpLibFilename);
		using GetProcAddressFn   = std::uintptr_t(__stdcall*)(HINSTANCE mod, const char* name);
		using DllMainFn          = bool(__stdcall*)(void* base, std::size_t reason, void* data);

		inline auto get_peb() -> PEB* {
			return reinterpret_cast<PEB*>(__readgsqword(0x60));
		}

		inline auto get_syscall_idx(std::string mod, std::string fn_name) -> std::int32_t {
			auto fn = GetProcAddress(GetModuleHandleA(mod.c_str()), fn_name.c_str());

			std::uint8_t pre_syscall_opcodes[] = {
				0x4C, 0x8B, 0xD1,	// mov r10, rcx;
				0xB8				// mov eax, XXh ; Syscall ID
			};

			for (int i = 0; i < 4; ++i)
				if (*(std::uint8_t*)((DWORD64)fn + i) != pre_syscall_opcodes[i])
					return 0; // The function has been tampered with already...

			return *(DWORD*)((DWORD64)fn + 4);

		}

		typedef struct _LDR_DATA_TABLE_ENTRY_NATIVE {
			LIST_ENTRY     InLoadOrderLinks;
			LIST_ENTRY     InMemoryOrderLinks;
			LIST_ENTRY     InInitializationOrderLinks;
			LPVOID         DllBase;
			LPVOID         EntryPoint;
			ULONG          SizeOfImage;
			UNICODE_STRING FullDllName;
			UNICODE_STRING BaseDllName;
		} LDR_DATA_TABLE_ENTRY_NATIVE, * PLDR_DATA_TABLE_ENTRY_NATIVE;

		struct manual_map_data {
			// pointer to DLL buffer
			std::uint8_t* buffer;
			std::size_t   buffer_size;

			// function pointers
			LoadLibraryFn      load_library;
			GetProcAddressFn   get_proc_address;
		};

		struct controller {
			// spinlock
			std::uintptr_t spinlock	= 1;	// 0
			std::uintptr_t target	= 0;	// 8
			std::uintptr_t base		= 0;	// 16
			std::uintptr_t size		= 0;	// 24
			std::uintptr_t buffer	= 0;	// 32
			std::uintptr_t mm_data	= 0;	// 40
		};


		#define RELOC_FLAG32(RelInfo) ((RelInfo >> 0x0C) == IMAGE_REL_BASED_HIGHLOW)
		#define RELOC_FLAG64(RelInfo) ((RelInfo >> 0x0C) == IMAGE_REL_BASED_DIR64)

		#ifdef _WIN64
		#define RELOC_FLAG RELOC_FLAG64
		#else
		#define RELOC_FLAG RELOC_FLAG32
		#endif
	}

	// Shellcode to map the DLL into memory
	__declspec(noinline) static auto shellcode_mapper(utils::manual_map_data* data) -> void {
		auto nt = reinterpret_cast<IMAGE_NT_HEADERS*>(data->buffer + reinterpret_cast<IMAGE_DOS_HEADER*>(data->buffer)->e_lfanew);

		auto loc_delta = data->buffer - nt->OptionalHeader.ImageBase;

		// store main function
		auto main = reinterpret_cast<utils::DllMainFn>(data->buffer + nt->OptionalHeader.AddressOfEntryPoint);

		// relocate...
		if (loc_delta)
		{
			if (nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size)
			{
				auto reloc_data = reinterpret_cast<IMAGE_BASE_RELOCATION*>(data->buffer + nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);

				while (reloc_data->VirtualAddress)
				{
					auto n_entries = (reloc_data->SizeOfBlock - sizeof IMAGE_BASE_RELOCATION) / sizeof WORD;
					auto reloc_info = reinterpret_cast<WORD*>(reloc_data + 1);

					for (auto i = 0; i != n_entries; ++i, ++reloc_info)
					{
						if (RELOC_FLAG(*reloc_info))
						{
							auto patch = reinterpret_cast<UINT_PTR*>(data->buffer + reloc_data->VirtualAddress + ((*reloc_info) & 0xFFF));
							*patch += reinterpret_cast<UINT_PTR>(loc_delta);
						}
					}
				}
			}
		}

		// imports...
		if (nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size)
		{
			auto import_desc = reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(data->buffer + nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

			while (import_desc->Name)
			{
				auto sz_mod = reinterpret_cast<char*>(data->buffer + import_desc->Name);
				auto dll = data->load_library(sz_mod);

				auto thunk_ref = reinterpret_cast<ULONG_PTR*>(data->buffer + import_desc->OriginalFirstThunk);
				auto func_ref  = reinterpret_cast<ULONG_PTR*>(data->buffer + import_desc->FirstThunk);

				if (!thunk_ref)
					thunk_ref = func_ref;

				for (; *thunk_ref; ++thunk_ref, ++func_ref)
				{
					if (IMAGE_SNAP_BY_ORDINAL(*thunk_ref))
						*func_ref = data->get_proc_address(dll, reinterpret_cast<char*>(*thunk_ref & 0xFFFF));
					else
					{
						auto _import = reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(data->buffer + *thunk_ref);
						*func_ref = data->get_proc_address(dll, _import->Name);
					}
				}

				++import_desc;
			}
		}
		

		// tls...
		if (nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size)
		{
			auto tls = reinterpret_cast<IMAGE_TLS_DIRECTORY*>(data->buffer + nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
			auto callback = reinterpret_cast<PIMAGE_TLS_CALLBACK*>(tls->AddressOfCallBacks);

			for (; callback && *callback; ++callback)
				(*callback)(data->buffer, DLL_PROCESS_ATTACH, nullptr);
		}

		// zero out headers
		auto dos_size = sizeof IMAGE_DOS_HEADER;
		auto base = data->buffer;

		for (auto i = 0; i < dos_size; ++i)
			*(std::uint8_t*)(base + i) = 0;

		auto nt_size  = sizeof IMAGE_NT_HEADERS;

		for (auto i = 0; i < nt_size; ++i)
			*(std::uint8_t*)(nt + i) = 0;

		// call entry
		// note: this makes DllMain responsible for the cleaning up of the data
		main(data->buffer, DLL_PROCESS_ATTACH, data);
	}

	// Map dll at path {path_to_file} into a target process
	static auto map_into_lsass(std::filesystem::path path_to_file, std::string target) -> bool {

		// Initialize portal wars thing
		auto target_process = std::make_unique<process::remote_process>(target);

		// Couldn't find target
		if (!target_process->pid()) {
			return false;
		}

		// Init lsass
		auto lsass_process = std::make_unique<process::remote_process>("lsass");

		// Couldn't find lsass
		if (!lsass_process->pid()) {
			return false;
		}

		// Try and find a handle to {target} within LSASS
		auto remote_handle = lsass_process->retrieve_handle_to(target_process->name());

		// Sanity check
		if (!remote_handle) {
			return false;
		}

		// Copy file to a buffer
		auto file = std::ifstream(path_to_file, std::ios::binary | std::ios::ate);

		// Sanity check
		if (file.fail())
		{
			file.close();
			return false;
		}

		// Allocate buffer
		auto file_size = file.tellg();

		auto source_data = new std::uint8_t[static_cast<UINT_PTR>(file_size)];

		if (!source_data)
		{
			file.close();
			return false;
		}

		// Back to the start of file
		file.seekg(0, std::ios::beg);

		// Copy file into buffer
		file.read(reinterpret_cast<char*>(source_data), file_size);

		// Close
		file.close();

		if (reinterpret_cast<IMAGE_DOS_HEADER*>(source_data)->e_magic != 0x5a4d)
		{
			delete[] source_data;
			return false;
		}

		// ...
		auto old_nt = reinterpret_cast<IMAGE_NT_HEADERS*>(source_data + reinterpret_cast<IMAGE_DOS_HEADER*>(source_data)->e_lfanew);
		auto old_opt = &old_nt->OptionalHeader;
		auto old_fil = &old_nt->FileHeader;

		if (old_fil->Machine != IMAGE_FILE_MACHINE_AMD64)
		{
			delete[] source_data;
			return false;
		}

		std::size_t		size = old_opt->SizeOfImage;
		PVOID			base = nullptr;

		lsass_process->open(PROCESS_ALL_ACCESS);

		// allocate buffer for our DLL into lsass
		auto res = NtAllocateVirtualMemory(lsass_process->handle(), &base, 0, &size, MEM_COMMIT, PAGE_READWRITE);

		if (size < old_opt->SizeOfImage) {
			NtFreeVirtualMemory(lsass_process->handle(), reinterpret_cast<PVOID*>(&base), 0, MEM_RELEASE);
			delete[] source_data;
			return false;
		}

		if (!base) {
			delete[] source_data;
			return false;
		}

		utils::manual_map_data	mm{};
		mm.load_library			= GetModuleHandleA;
		mm.get_proc_address		= reinterpret_cast<utils::GetProcAddressFn>(GetProcAddress);

		auto section_header = IMAGE_FIRST_SECTION(old_nt);

		for (auto i = 0; i != old_fil->NumberOfSections; ++i, ++section_header)
		{
			if (section_header->SizeOfRawData)
			{
				// write section to thing
				if (!WriteProcessMemory(lsass_process->handle(), reinterpret_cast<LPVOID>((std::intptr_t)base + section_header->VirtualAddress), source_data + section_header->PointerToRawData, section_header->SizeOfRawData, nullptr))
				{
					NtFreeVirtualMemory(lsass_process->handle(), reinterpret_cast<PVOID*>(&base), 0, MEM_RELEASE);
					delete[] source_data;
					return false;
				}
			}
		}

		// manual map data at beginning of that buffer
		memcpy(source_data, &mm, sizeof mm); 

		// write to target
		WriteProcessMemory(lsass_process->handle(), reinterpret_cast<LPVOID>(base), source_data, 0x1000, nullptr);

		// cleanup
		delete[] source_data;

		// Allocate memory for remote controller
		std::size_t		controller_size = sizeof utils::controller;
		PVOID			controller_base = nullptr;

		NtAllocateVirtualMemory(lsass_process->handle(), &controller_base, 0, &controller_size, MEM_COMMIT, PAGE_READWRITE);

		// TODO:
		// the rest.
		// Note so that I know what I'm doing from here on out:
		// also, spawn a local shellcode buffer so we can easily write
		// The DLL is copied into LSASS with address of {base} and size {size}
		// Current steps are
		// 1. Write shellcode with spinlock & function templates
		// {
		//		mov al, [&spinlock]
		//		cmp al, 0
		//		pause
		//		jnz -14
		// ---------------------- We're past the spinlock
		//	registers: (1) RCX (2) RDX (3) r8 (4) r9 (5...) stack
		//	functions:
		//		(0): AVM
		//		(1): WVM
		//		(2): CreateRemoteThread
		//
		auto wvm_syscall = utils::get_syscall_idx("ntdll.dll", "NtWriteVirtualMemory");
		auto avm_syscall = utils::get_syscall_idx("ntdll.dll", "NtAllocateVirtualMemory");

		std::uintptr_t	local_shellcode_buffer	= reinterpret_cast<std::uintptr_t>(VirtualAlloc(nullptr, 4096, MEM_COMMIT, PAGE_READWRITE));

		auto original_local_shellcode_buffer_address = local_shellcode_buffer;

		if (!local_shellcode_buffer)
		{
			NtFreeVirtualMemory(lsass_process->handle(), reinterpret_cast<PVOID*>(&base), 0, MEM_RELEASE);
			return false;
		}

		std::uint8_t spinlock_shellcode[] = {
			0xa0, 0,0,0,0,0,0,0,0,	// mov al, [&spinlock]
			0x3c, 0,				// cmp al, 0
			0xf3, 0x90,				// pause
			0x75, 0xf1,				// jnz -15
			0x50,					// push rax				
			0x48, 0x83, 0xec, 0x28,	// sub rsp, 0x28		
		};
		*(std::uintptr_t*)(spinlock_shellcode + 1) = (std::uintptr_t)(controller_base);

		// copy shellcode into buffer
		std::memcpy((void*)local_shellcode_buffer, spinlock_shellcode, sizeof spinlock_shellcode);
		local_shellcode_buffer += sizeof spinlock_shellcode;

		std::uint8_t controller_shellcode[] = {
			0xa0, 0,0,0,0,0,0,0,0,					// mov al, [&function]	(+0)  (&function +1)
			0x3c, 2,								// cmp al, 2			(+9) NOTE: The reason we check CreateRemoteThread first is because it basically needs its own stack
			0x74, 102,								// je +104				(+11) Jump to CreateRemoteThread instead


			0x48, 0xa1, 0, 0, 0, 0, 0, 0, 0, 0,		// mov rax, [&target]	(+13) (&target	+15)
			0x48, 0x89, 0xc1,						// mov rcx, rax			(+23)
			0x48, 0xa1, 0, 0, 0, 0, 0, 0, 0, 0,		// mov rax, [&base]		(+26) (&base	+28)
			0x48, 0x89, 0xc2,						// mov rdx, rax			(+36)
			0x3c, 0,								// cmp al, 0			(+39) This is AVM
			0x75, 33,								// jne +33				(+41) Jump to WVM

			// We're now inside syscall for AVM !!!!
			// Arguments left: Buffer (ZERO_BITS), Size (done), AllocationType, Protect,
			0x49, 0xc7, 0, 0, 0, 0,					// mov r8, 0			(+43)
			0x48, 0xa1, 0, 0, 0, 0, 0, 0, 0, 0,		// mov rax, [&size]		(+49) (&size	+51)
			0x49, 0x89, 0xc1,						// mov r9, rax			(+59)
			0x68, 0x00, 0x10, 0x00, 0x00,			// push MEM_COMMIT		(+62)
			0x6a, 0x40,								// push PAGE_EXECUTE_READWRITE (+67)
			0xb8, 0,0,0,0,							// mov eax, syscall id	(+69) (&syscall +70)
			0x0f, 0x05,								// syscall				(+74)
			0xeb, 93,								// jmp +93				(+76)

			// We're now inside syscall for WVM!!!
			// Arguments left: buffer (done), size (done), num_of_bytes_written
			0x48, 0xa1, 0, 0, 0, 0, 0, 0, 0, 0,		// mov rax, [&buffer]	(+78) (&buffer	+80)
			0x49, 0x89, 0xc0,						// mov r8, rax			(+88)
			0x48, 0xa1, 0, 0, 0, 0, 0, 0, 0, 0,		// mov rax, [&size]		(+91) (&size	+93)
			0x49, 0x89, 0xc1,						// mov r9, rax			(+101)
			//  push 0 on the stack, this is equivalent to the NumberOfBytesWritten argument for WVM
			0x48, 0x31, 0xc0,						// xor rax, rax			(+104)
			0x50,									// push rax				(+107)
			0xb8, 0,0,0,0,							// mov eax, syscall id	(+108) (&syscall +109)
			0x0f, 0x05,								// syscall				(+113)
			0xeb, 54,								// jmp +54				(+115)

			// We're now inside CreateRemoteThread
			0x48, 0xa1, 0, 0, 0, 0, 0, 0, 0, 0,		// mov rax, [&target]	(+117) (&target	+119)
			0x48, 0x89, 0xc1,						// mov rcx, rax			(+127) 
			0x48, 0xc7, 0xc2, 0,0,0,0,				// mov rdx, 0			(+130)	//threadattributes
			0x49, 0xc7, 0xc0, 0, 0, 0, 0,			// mov r8, 0			(+137)	//stacksize
			0x48, 0xa1, 0, 0, 0, 0, 0, 0, 0, 0,		// mov rax, [&data]		(+144) (&data	+146)
			0x49, 0x89, 0xc1,						// mov r9, rax			(+154)  //args
			0x6a, 0,								// push 0				(+157)	//creation flags
			0x6a, 0,								// push 0				(+157)	//thread id
			0x48, 0xb8, 0, 0, 0, 0, 0 ,0 ,0 ,0,		// mov rax [&create_remote_thread]	(+159) (&create_remote_thread	+161)
			0xff, 0xd0,								// call rax				(+169)
			0x48, 0x83, 0xC4, 0x30					// add rsp, 0x30		(+171)
		};

		//members
		*(DWORD64*)(controller_shellcode + 1)	= (DWORD64)(ULONG_PTR)((DWORD64)controller_base + 0);	// <-- function

		*(DWORD64*)(controller_shellcode + 15)	= (DWORD64)(ULONG_PTR)((DWORD64)controller_base + 8);	// <-- target
		*(DWORD64*)(controller_shellcode + 119) = (DWORD64)(ULONG_PTR)((DWORD64)controller_base + 8);	// <-- target

		*(DWORD64*)(controller_shellcode + 28)	= (DWORD64)(ULONG_PTR)((DWORD64)controller_base + 16);	// <-- base

		*(DWORD64*)(controller_shellcode + 80) = (DWORD64)(ULONG_PTR)((DWORD64)controller_base + 32);	// <-- buffer

		*(DWORD64*)(controller_shellcode + 51)	= (DWORD64)(ULONG_PTR)((DWORD64)controller_base + 24);	// <-- size
		*(DWORD64*)(controller_shellcode + 93) = (DWORD64)(ULONG_PTR)((DWORD64)controller_base + 24);	// <-- size

		*(DWORD64*)(controller_shellcode + 146) = (DWORD64)(ULONG_PTR)((DWORD64)controller_base + 40);	// <-- size
		*(DWORD64*)(controller_shellcode + 161) = (DWORD64)(ULONG_PTR)(CreateRemoteThread);	// <-- size

		// syscalls
		*(DWORD*)(controller_shellcode + 70)	= (DWORD)(ULONG_PTR)avm_syscall;
		*(DWORD*)(controller_shellcode + 109) = (DWORD)(ULONG_PTR)wvm_syscall;

		// append to shellcode buffer
		std::memcpy((void*)local_shellcode_buffer, controller_shellcode, sizeof controller_shellcode);
		local_shellcode_buffer += sizeof controller_shellcode;

		// toggle spinlock again
		std::uint8_t toggle_spinlock_shellcode[] = {
			0xB0, 1,								// mov al, 1
			0xA2, 0, 0, 0, 0, 0, 0, 0, 0			// mov [&spinlock], al
		};
		*(DWORD64*)((PUCHAR)toggle_spinlock_shellcode + 3) = (DWORD64)(ULONG_PTR)((DWORD64)controller_base + 0);

		// append to shellcode buffer
		std::memcpy((void*)local_shellcode_buffer, toggle_spinlock_shellcode, sizeof toggle_spinlock_shellcode);
		local_shellcode_buffer += sizeof toggle_spinlock_shellcode;

		// jump back to begin
		std::uint8_t reset_shellcode[]{
			0x48, 0xb8,	0, 0, 0, 0, 0, 0, 0, 0,		// mov rax, controller
			0xff, 0xe0								// jmp rax
		};


		// !!!!! Don't forget this
		*(DWORD64*)((PUCHAR)reset_shellcode + 2) = (DWORD64)(ULONG_PTR)(0xFFFFFFFF);

		// append to shellcode buffer
		std::memcpy((void*)local_shellcode_buffer, reset_shellcode, sizeof reset_shellcode);
		local_shellcode_buffer += sizeof reset_shellcode;

		auto shellcode_size = (local_shellcode_buffer - original_local_shellcode_buffer_address);

		//TODO:
		//write shellcode, spawn thread, and proceed to write DLL into target process


		// free the shellcode buffer
		VirtualFree(reinterpret_cast<LPVOID>(original_local_shellcode_buffer_address), 0, MEM_RELEASE);
	}
}
```

`nt.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <Winternl.h>
#include <ntstatus.h>
#include <mutex>
#pragma comment (lib, "ntdll.lib")

typedef struct _SYSTEM_HANDLE {
	ULONG ProcessId;
	UCHAR ObjectTypeNumber;
	UCHAR Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION {
	ULONG HandleCount; // Or NumberOfHandles if you prefer
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
	DWORD UniqueProcessId;
	WORD HandleType;
	USHORT HandleValue;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef enum _MEMORY_INFORMATION_CLASS {
	MemoryBasicInformation
} MEMORY_INFORMATION_CLASS;

typedef struct _OBJECT_TYPE_INFORMATION {
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG TotalPagedPoolUsage;
	ULONG TotalNonPagedPoolUsage;
	ULONG TotalNamePoolUsage;
	ULONG TotalHandleTableUsage;
	ULONG HighWaterNumberOfObjects;
	ULONG HighWaterNumberOfHandles;
	ULONG HighWaterPagedPoolUsage;
	ULONG HighWaterNonPagedPoolUsage;
	ULONG HighWaterNamePoolUsage;
	ULONG HighWaterHandleTableUsage;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	BOOLEAN SecurityRequired;
	BOOLEAN MaintainHandleCount;
	UCHAR TypeIndex;
	CHAR ReservedByte;
	ULONG PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

using NtWriteVirtualMemoryFn = NTSTATUS(NTAPI*)(IN  HANDLE ProcessHandle,
	OUT PVOID BaseAddress,
	IN  PVOID Buffer,
	IN  ULONG BufferSize,
	OUT PULONG NumberOfBytesWritten OPTIONAL);

using NtQueryVirtualMemoryFn = NTSTATUS (NTAPI*)(
	HANDLE                   ProcessHandle,
	PVOID                    BaseAddress,
	MEMORY_INFORMATION_CLASS MemoryInformationClass,
	PVOID                    MemoryInformation,
	SIZE_T                   MemoryInformationLength,
	PSIZE_T                  ReturnLength);

using NtAllocateVirtualMemoryFn = NTSTATUS(NTAPI*)(HANDLE    ProcessHandle,
	PVOID* BaseAddress,
	ULONG_PTR ZeroBits,
	PSIZE_T   RegionSize,
	ULONG     AllocationType,
	ULONG     Protect);

using NtFreeVirtualMemoryFn = NTSTATUS(NTAPI*)(HANDLE  ProcessHandle,
	PVOID* BaseAddress,
	PSIZE_T RegionSize,
	ULONG   FreeType);

using NtCreateThreadExFn = NTSTATUS(NTAPI*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, HANDLE, LPTHREAD_START_ROUTINE, LPVOID, ULONG, ULONG_PTR, SIZE_T, SIZE_T, LPVOID);

using NtReadVirtualMemoryFn = NTSTATUS (NTAPI*)(HANDLE handle, PVOID base, PVOID buffer, ULONG num_to_read, PULONG read);

static NTSTATUS NtReadVirtualMemory(HANDLE handle, PVOID base, PVOID buffer, ULONG num_to_read, PULONG read) {
	static std::intptr_t  fn_address = 0;
	static std::once_flag initialized;

	std::call_once(initialized, [&]() {
			auto ntdll = GetModuleHandle("ntdll.dll");

			if (!ntdll)
				ntdll = LoadLibrary("ntdll");

			if (!fn_address) fn_address = (std::intptr_t)GetProcAddress(ntdll, "NtReadVirtualMemory");
		});

	reinterpret_cast<NtReadVirtualMemoryFn>(fn_address)(handle, base, buffer, num_to_read, read);
}

static NTSTATUS NtQueryVirtualMemory(HANDLE                   ProcessHandle,
	PVOID                    BaseAddress,
	MEMORY_INFORMATION_CLASS MemoryInformationClass,
	PVOID                    MemoryInformation,
	SIZE_T                   MemoryInformationLength,
	PSIZE_T                  ReturnLength) {

	static std::intptr_t  fn_address = 0;
	static std::once_flag initialized;
	
	std::call_once(initialized, [&]() {
		auto ntdll = GetModuleHandle("ntdll.dll");

		if (!ntdll)
			ntdll = LoadLibrary("ntdll");

		if (!fn_address) fn_address = (std::intptr_t)GetProcAddress(ntdll, "NtQueryVirtualMemory");
	});

	reinterpret_cast<NtQueryVirtualMemoryFn>(fn_address)(ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation, MemoryInformationLength, ReturnLength);
}

static NTSTATUS NtAllocateVirtualMemory(HANDLE    ProcessHandle,
	PVOID* BaseAddress,
	ULONG_PTR ZeroBits,
	PSIZE_T   RegionSize,
	ULONG     AllocationType,
	ULONG     Protect) {

	static std::intptr_t  fn_address = 0;
	static std::once_flag initialized;

	std::call_once(initialized, [&]() {
		auto ntdll = GetModuleHandle("ntdll.dll");

		if (!ntdll)
			ntdll = LoadLibrary("ntdll");

		if (!fn_address) fn_address = (std::intptr_t)GetProcAddress(ntdll, "NtAllocateVirtualMemory");
		});

	reinterpret_cast<NtAllocateVirtualMemoryFn>(fn_address)(ProcessHandle,
		BaseAddress,
		ZeroBits,
		RegionSize,
		AllocationType,
		Protect);
}


static NTSTATUS NtFreeVirtualMemory(HANDLE  ProcessHandle,
	PVOID* BaseAddress,
	PSIZE_T RegionSize,
	ULONG   FreeType) {

	static std::intptr_t  fn_address = 0;
	static std::once_flag initialized;

	std::call_once(initialized, [&]() {
		auto ntdll = GetModuleHandle("ntdll.dll");

		if (!ntdll)
			ntdll = LoadLibrary("ntdll");

		if (!fn_address) fn_address = (std::intptr_t)GetProcAddress(ntdll, "NtFreeVirtualMemory");
	});

	reinterpret_cast<NtFreeVirtualMemoryFn>(fn_address)(ProcessHandle,
		BaseAddress,
		RegionSize,
		FreeType);
}


EXTERN_C NTSTATUS NTAPI NtDuplicateObject(HANDLE, HANDLE, HANDLE, PHANDLE, ACCESS_MASK, BOOLEAN, ULONG);
```

`process.cpp`:

```cpp
#include "process.hpp"

using namespace process;

// Returns true if the address is inside a module
auto remote_process::is_address_in_module(std::intptr_t address) -> bool {
	auto modules = enum_modules(this);

	auto res = std::find_if(modules.begin(), modules.end(), [&](enum_modules::iterator::value_type entry) {
		return address >= reinterpret_cast<std::intptr_t>(entry.modBaseAddr) && address <= reinterpret_cast<std::intptr_t>(entry.modBaseAddr + entry.modBaseSize);
	});

	return res != modules.end();
}

// Attempts to find targetable regions where we can write our LSASS shellcode
auto remote_process::find_targetable_regions() -> std::vector<utils::TARGETABLE_REGION> {
	std::vector<utils::TARGETABLE_REGION> result;	
	std::vector<MEMORY_BASIC_INFORMATION> info;

	// Open handle to target process
	open(PROCESS_ALL_ACCESS);

	std::uintptr_t           address = 0;
	std::size_t              length  = sizeof MEMORY_BASIC_INFORMATION;
	NTSTATUS				 res     = 0;
	MEMORY_BASIC_INFORMATION minfo   = {0};

	// last address, because we're lazy
	std::uintptr_t			 last_address = 0;

	// populate temporary info buffer
	for (address = 0; res = NtQueryVirtualMemory(handle(), reinterpret_cast<PVOID>(address), MemoryBasicInformation, &minfo, sizeof minfo, &length) >= 0; address += minfo.RegionSize)	{
		
		// easy way to find out if we reached the end
		if (last_address != 0 && last_address == reinterpret_cast<std::uintptr_t>(minfo.BaseAddress))
			break;

		last_address = reinterpret_cast<std::uintptr_t>(minfo.BaseAddress);
		info.push_back(minfo);
	}

	// remove all non-targetable regions (non-executable)
	info.erase(std::remove_if(info.begin(), info.end(), [&](MEMORY_BASIC_INFORMATION minfo) { 
		return !(minfo.Protect == PAGE_EXECUTE || minfo.Protect == PAGE_EXECUTE_READ || minfo.Protect == PAGE_EXECUTE_READWRITE || minfo.Protect == PAGE_EXECUTE_WRITECOPY);
	}), info.end());

	if (info.empty())
		return result;

	std::for_each(info.begin(), info.end(), [&](MEMORY_BASIC_INFORMATION info) {
		auto buff = VirtualAlloc(nullptr, info.RegionSize, MEM_COMMIT, PAGE_READWRITE);

		// check if we are allowed to iterate
		if (buff == nullptr)
			return;

		// copy
		NtReadVirtualMemory(handle(), info.BaseAddress, buff, info.RegionSize, 0);

		// easy access
		auto buffer      = reinterpret_cast<std::int8_t*>(buff);
		// indexing
		auto index       = info.RegionSize - 1;
		// size
		std::size_t size = 0;

		while (buffer[index] == 0)
		{
			index--;
			size++;
		}

		utils::TARGETABLE_REGION region {};
		region.info = info;
		region.size = size;
		region.base = reinterpret_cast<std::uintptr_t>(info.BaseAddress) + index;

		result.push_back(region);
	});

	close();

	return result;
}

// Attempts to "steal" handle, we aren't really stealing, but just get
// the handle to process with name {name}
auto remote_process::retrieve_handle_to(std::string name, std::size_t owner) -> void* {
	if (name.empty())
		return nullptr;

	if (!owner)
		owner = pid();

	std::intptr_t buffer = 0;
	std::size_t   size   = 0;

	while (true) {
		auto status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(16), reinterpret_cast<PVOID>(buffer), size, reinterpret_cast<PULONG>(&size));

		if (!NT_SUCCESS(status))
		{
			if (status == STATUS_INFO_LENGTH_MISMATCH)
			{
				if (buffer != 0)
					VirtualFree(reinterpret_cast<LPVOID>(buffer), 0, MEM_RELEASE);

				buffer = reinterpret_cast<std::intptr_t>(VirtualAlloc(nullptr, size, MEM_COMMIT, PAGE_READWRITE));
			}
		}
		else {
			break;
		}
	}

	//Our buffer has now been filled with a SYSTEM_HANDLE_INFORMATION struct
	auto handle_info = reinterpret_cast<PSYSTEM_HANDLE_INFORMATION>(buffer);

	// Define outside of loop so that we may free them after lol
	std::intptr_t   object_buffer = 0;
	std::size_t     object_size = 0;

	for (auto i = 0; i < handle_info->HandleCount; ++i)
	{
		// Retrieve the handle
		auto remote_handle = reinterpret_cast<PSYSTEM_HANDLE_TABLE_ENTRY_INFO>(&handle_info->Handles[i]);

		// Sanity checks
		if (!remote_handle)
			continue;
		if (!remote_handle->HandleValue)
			continue;
		if (remote_handle->UniqueProcessId != owner) {
			continue;
		}

		// Try to duplicate the handle
		open(PROCESS_DUP_HANDLE);

		// ...
		auto local = reinterpret_cast<HANDLE>(remote_handle->HandleValue);
		auto dup_status = NtDuplicateObject(handle(), HANDLE(remote_handle->HandleValue), GetCurrentProcess(), &local, PROCESS_QUERY_LIMITED_INFORMATION, false, 0);

		// close temporary handle
		close();

		if (!NT_SUCCESS(dup_status))
			continue; // Failed to duplicate sadge

		std::size_t num_attempts  = 0;

		while (true) {

			if (num_attempts == 20)
				break;

			++num_attempts;

			// Query object info
			auto query_object_status = NtQueryObject(local, ObjectTypeInformation, reinterpret_cast<PVOID>(object_buffer), object_size, reinterpret_cast<PULONG>(&object_size));

			// Speaks for itself
			if (!NT_SUCCESS(query_object_status)) {
				if (object_buffer != 0)
					VirtualFree(reinterpret_cast<LPVOID>(object_buffer), 0, MEM_RELEASE); // free old page

				object_buffer = reinterpret_cast<std::intptr_t>(VirtualAlloc(nullptr, object_size, MEM_COMMIT, PAGE_READWRITE)); // allocate new one
			}
			else {
				if (object_buffer == 0)
					break;

				if (wcsncmp(reinterpret_cast<POBJECT_TYPE_INFORMATION>(object_buffer)->TypeName.Buffer, L"Process", reinterpret_cast<POBJECT_TYPE_INFORMATION>(object_buffer)->TypeName.Length + 1) == 0) {
					wchar_t process[MAX_PATH];
					if (GetModuleFileNameExW(local, nullptr, process, MAX_PATH)) {

						// Input 
						std::wstring wide_process_name = std::wstring(name.begin(), name.end());

						// Read value
						std::wstring wide_process      = std::wstring(process);

						// Fix so we can compare
						auto position = wide_process.find_last_of(L"\\");

						wide_process = wide_process.substr(position + 1, wide_process.length());

						// Transform them to lower
						wide_process_name = utils::to_lowercase(wide_process_name);
						wide_process      = utils::to_lowercase(wide_process);

						// Compare
						if (wcsstr(wide_process.c_str(), wide_process_name.c_str()) != nullptr) {
							HANDLE handle_found = reinterpret_cast<HANDLE>(remote_handle->HandleValue);

							// free the buffers
							VirtualFree(reinterpret_cast<LPVOID>(buffer), 0, MEM_RELEASE);
							VirtualFree(reinterpret_cast<LPVOID>(object_buffer), 0, MEM_RELEASE);

							// close owner to the remote process
							close();

							// return the handle
							return handle_found;
						}
						else {
							break;
						}
					}
				}
				else {
					break;
				}
			}
		}

		close();
		continue;
	}

	// free the buffers
	if(buffer != 0)
	VirtualFree(reinterpret_cast<LPVOID>(buffer), 0, MEM_RELEASE);

	if(object_buffer != 0)
	VirtualFree(reinterpret_cast<LPVOID>(object_buffer), 0, MEM_RELEASE);

	// return invalid handle
	return INVALID_HANDLE_VALUE;
}

auto remote_process::open(std::size_t rights) -> bool {
	// if we have a handle already, and we have the requested rights already
	if (_handle && _rights == rights) {
		return true; // just keep the current handle
	}

	// else check if we already have a handle, if so, close it
	if (_handle)
		CloseHandle(_handle);

	// open a new handle
	_handle = OpenProcess(rights, false, _pid);

	// set new rights value
	if (_handle) _rights = rights; else _rights = 0;

	// return val
	return _handle ? true : false;
}

auto remote_process::close() -> void {
	if (_handle)
		CloseHandle(_handle);

	// reset
	_handle = nullptr;
	_rights = 0;
}

remote_process::remote_process(std::string name) : _name(name), _handle(nullptr), _pid(0), _rights(0) {
	auto processes = enum_processes();
	auto entry = processes.find(name);

	if (entry == processes.end()) {
		__fastfail(0);
	}

	_pid = entry->th32ProcessID;

}
```

`process.hpp`:

```hpp
#pragma once

#include <string>
#include <Windows.h>
#include <TlHelp32.h>
#include <vector>
#include <iostream>
#include <algorithm>
#include <map>
#include <Psapi.h>
#include <memory>

#include "nt.hpp"

namespace process {
	// Convert a PROCESSENTRY to std::string
	static auto entry_to_string(const PROCESSENTRY32 entry) -> const std::string {
		return std::string(entry.szExeFile);
	}

	// Utilities
	namespace utils {

		template <typename T, std::enable_if_t<std::is_void<decltype(void(std::declval<T&>().begin()))>::value, bool> = true>
		auto to_lowercase(T entry) -> T {
			std::transform(entry.begin(), entry.end(), entry.begin(), [](unsigned char c) {
				return std::tolower(c);
			});
			return entry;
		}

		struct TARGETABLE_REGION {
			std::intptr_t base;
			std::size_t    size;
			MEMORY_BASIC_INFORMATION info;
		};
	}

	// Remote process structure
	class remote_process {
	private:
		std::string _name;
		std::size_t _pid;
		std::size_t _rights;
		HANDLE		_handle;
	public:

		// Attempt to find a process by its name
		remote_process(std::string);

		// Open target process with rights [rights]
		auto open(std::size_t rights) -> bool;

		// Get the address of the handle that remote process has to [process]
		auto retrieve_handle_to(std::string name, std::size_t owner = 0) -> void*;

		// Find executable region where we can write our shellcode
		auto find_targetable_regions() -> std::vector<utils::TARGETABLE_REGION>;

		// Returns true if the address is inside a module
		auto is_address_in_module(std::intptr_t address) -> bool;

		// Close the current handle
		auto close() -> void;

		// Returns the process name
		auto name() -> const std::string {
			return _name;
		}

		// Get the current handle
		auto handle() -> void* {
			return _handle;
		}

		// Returns the PID of the remote process
		auto pid() -> std::size_t {
			return _pid;
		}

		// Attempt to read from target process
		template<typename T>
		auto read(std::uintptr_t address)->T = delete;

		// Attempt to write to target process
		template<typename T>
		auto write(std::uintptr_t address, T value) -> bool = delete;
	};

	// Module iterator for remote_process
	class enum_modules {
	private:
		remote_process* _process;
	public:
		// C++17 is good but also very bad
		class iterator : public std::iterator<std::input_iterator_tag, MODULEENTRY32> {
		private:
			// Cache for processes with key {pid}
			static inline std::map<std::size_t, std::vector<MODULEENTRY32>> _cache;
			remote_process* __process;
			int _idx;
		public:
			// Populate cache for the current process
			explicit iterator(remote_process* process, int index = 0, bool recache = false) : _idx(index), __process(process) {

				// Check if the process in question has a cached module list
				if (_cache[process->pid()].size() > 0 && !recache)
					return;

				// Open handle
				auto handle = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, process->pid());

				if (!handle) {
					__fastfail(-1);
				}

				auto entry = MODULEENTRY32{};
				entry.dwSize = sizeof MODULEENTRY32;

				// Populate the cache for remote process
				for (auto res = Module32First(handle, &entry); res; res = Module32Next(handle, &entry)) {
					_cache[__process->pid()].push_back(entry);
				}

				// Close the handle
				CloseHandle(handle);
			}

			auto length() -> const std::size_t {
				return _cache[__process->pid()].size();
			}

			// Returns current index
			auto idx() -> const int {
				return _idx;
			}

			// Returns true if the given index {i} is correct given the size of our cache
			auto is_valid_index(int i) -> const bool {
				return i <= (_cache[__process->pid()].size() - 1);
			}

			// Increment the iterator
			auto operator++() -> iterator& {
				_idx++; return *this;
			}

			auto operator==(iterator other) -> const bool {
				return _idx == other._idx;
			}

			auto operator!=(iterator other) -> const bool {
				return !(*this == other);
			}

			auto operator*() -> reference {
				if (!is_valid_index(_idx))
					_idx = length() - 1;

				return _cache[__process->pid()].at(_idx);
			}

			auto operator->() -> pointer {
				if (!is_valid_index(_idx))
					_idx = length() - 1;

				return &_cache[__process->pid()].at(_idx);
			}

			auto name() -> std::string {
				return std::string(_cache[__process->pid()].at(_idx).szModule);
			}
		};

		enum_modules(remote_process* process) : _process(process) {}

		iterator find(std::string name) {
			return std::find_if(begin(), end(), [&](MODULEENTRY32 entry) -> bool {
				return std::strstr(utils::to_lowercase(std::string(entry.szExePath)).c_str(), utils::to_lowercase(name).c_str()) != nullptr;
			});
		}

		iterator find(std::intptr_t address) {
			return std::find_if(begin(), end(), [&](MODULEENTRY32 entry) -> bool {
				return address >= reinterpret_cast<std::intptr_t>(entry.modBaseAddr) && address <= reinterpret_cast<std::intptr_t>(entry.modBaseAddr + entry.modBaseSize);
			});
		}

		iterator begin() { return iterator(_process); }
		iterator end() { return iterator(_process, iterator(_process).length()); }
	};

	// Process iterator
	class enum_processes {
	public:
		// Deprecated but cba to do the other way lol!
		class iterator : public std::iterator<std::input_iterator_tag, PROCESSENTRY32> {
		private:
			static inline std::vector<PROCESSENTRY32> _cache;
			int _idx;
		public:
			// Populate the cache with all process entries
			// And set the first index ofc..
			explicit iterator(int index = 0, bool recache = false) : _idx(index) {

				// Check if the process list has been cached, if we are specifically asked to recache
				// we will
				if (_cache.size() > 0 && !recache)
					return;

				auto handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

				if (!handle) {
					__fastfail(-1);
				}

				auto entry = PROCESSENTRY32{};
				entry.dwSize = sizeof PROCESSENTRY32;

				// Populate the cache
				for (auto res = Process32First(handle, &entry); res; res = Process32Next(handle, &entry)) {
					_cache.push_back(entry);
				}

				// Close the handle
				CloseHandle(handle);

				// Nice!
				std::cout << "Size of _cache: " << _cache.size() << std::endl;
			}

			// Returns size of our cache
			auto length() -> const std::size_t {
				return _cache.size();
			}
			
			// Returns current index
			auto idx() -> const int {
				return _idx;
			}


			// Returns true if the given index i is correct given the size of our cache
			auto is_valid_index(int i) -> const bool {
				return i <= (_cache.size() - 1);
			}

			// Increment the iterator
			auto operator++() -> iterator& {
				_idx++; return *this;
			}

			auto operator==(iterator other) -> const bool {
				return _idx == other._idx;
			}

			auto operator!=(iterator other) -> const bool {
				return !(*this == other);
			}

			auto operator*() -> reference {
				if (!is_valid_index(_idx))
					_idx = length() - 1;

				return _cache[_idx];
			}

			auto operator->() -> pointer {
				if (!is_valid_index(_idx))
					_idx = length() - 1;

				return &_cache[_idx];
			}
		};

		iterator find(std::string name) {
			return std::find_if(begin(), end(), [&](iterator::value_type entry) -> bool {
				return std::strstr(utils::to_lowercase(std::string(entry.szExeFile)).c_str(), utils::to_lowercase(name).c_str()) != nullptr;
			});
		}

		iterator begin() { return iterator(); }
		iterator end() { return iterator(iterator().length()); }
	};
}
```