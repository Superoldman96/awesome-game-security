Project Path: arc_gmh5225_IbInputSimulator_04la1ouv

Source Tree:

```txt
arc_gmh5225_IbInputSimulator_04la1ouv
├── Binding.AHK1
│   ├── IbInputSimulator.ahk
│   └── test
│       ├── KeyHistory.ahk
│       ├── mode 0.ahk
│       ├── mode 1.ahk
│       ├── mode ahk.ahk
│       ├── type DD.ahk
│       ├── type Logitech.ahk
│       ├── type MouClassInputInjection.ahk
│       ├── type Razer.ahk
│       └── type SendInput.ahk
├── Binding.AHK2
│   ├── IbInputSimulator.ahk
│   └── test
│       ├── KeyHistory.ahk
│       ├── mode 0.ahk
│       ├── mode 1.ahk
│       ├── mode ahk.ahk
│       ├── type DD.ahk
│       ├── type Logitech.ahk
│       ├── type MouClassInputInjection.ahk
│       ├── type Razer.ahk
│       └── type SendInput.ahk
├── CMakeLists.txt
├── LICENSE.txt
├── README.md
└── Simulator
    ├── CMakeLists.txt
    ├── include
    │   └── IbInputSimulator
    │       ├── InputSimulator.hpp
    │       ├── SendTypes
    │       │   ├── DD.hpp
    │       │   ├── Logitech.hpp
    │       │   ├── MouClassInputInjection
    │       │   │   └── ioctl.h
    │       │   ├── MouClassInputInjection.hpp
    │       │   ├── Razer.hpp
    │       │   ├── SendInput.hpp
    │       │   ├── base.hpp
    │       │   ├── types.hpp
    │       │   └── usb.hpp
    │       └── common.hpp
    ├── source
    │   ├── API 2.cpp
    │   ├── API 3.cpp
    │   └── dllmain.cpp
    └── test
        ├── test.cpp
        └── vk.hpp

```

`Binding.AHK1/IbInputSimulator.ahk`:

```ahk
; IbInputSimulator (v1)
; Description: Enable AHK to send keystrokes by drivers.
; Author: Chaoses Ib
; Version: 0.3
; Git: https://github.com/Chaoses-Ib/IbInputSimulator

IbSendInit(send_type := "AnyDriver", mode := 1, args*){
    workding_dir := A_WorkingDir
    SetWorkingDir, %A_ScriptDir%

    static hModule := DllCall("LoadLibrary", "Str", A_ScriptDir "\IbInputSimulator.dll", "Ptr")
    if (hModule == 0){
        if (A_PtrSize == 4)
            throw "SendLibLoadFailed: Please use AutoHotkey x64"
        else if (!FileExist("IbInputSimulator.dll"))
            throw "SendLibLoadFailed: Please put IbInputSimulator.dll with your script file (or use AHK v2 instead, which can locate those DLLs that are put with the library files)"
        else
            throw "SendLibLoadFailed"
    }

    if (send_type == "AnyDriver")
        result := DllCall("IbInputSimulator\IbSendInit", "Int", 0, "Int", 0, "Ptr", 0, "Int")
    else if (send_type == "SendInput")
        result := DllCall("IbInputSimulator\IbSendInit", "Int", 1, "Int", 0, "Ptr", 0, "Int")
    else if (send_type == "Logitech")
        result := DllCall("IbInputSimulator\IbSendInit", "Int", 2, "Int", 0, "Ptr", 0, "Int")
    else if (send_type == "Razer")
        result := DllCall("IbInputSimulator\IbSendInit", "Int", 3, "Int", 0, "Ptr", 0, "Int")
    else if (send_type == "DD"){
        if (args.MaxIndex() == 1)
            result := DllCall("IbInputSimulator\IbSendInit", "Int", 4, "Int", 0, "WStr", args[1], "Int")
        else
            result := DllCall("IbInputSimulator\IbSendInit", "Int", 4, "Int", 0, "Ptr", 0, "Int")
    } else if (send_type == "MouClassInputInjection"){
        if (args.MaxIndex() != 1)
            throw "MouClassInputInjection: Please specify the process ID of the target process"
        result := DllCall("IbInputSimulator\IbSendInit", "Int", 5, "Int", 0, "UInt64", args[1], "Int")
    } else
        throw "Invalid send type"
    
    SetWorkingDir, %workding_dir%
    
    if (result != 0){
        error_text := ["InvalidArgument", "LibraryNotFound", "LibraryLoadFailed", "LibraryError", "DeviceCreateFailed", "DeviceNotFound", "DeviceOpenFailed"]
        throw error_text[result]
    }

    if (mode != 0){
        IbSendMode(mode)
    }
}

IbSendMode(mode){
    static ahk_mode := ""
    if (mode == 1){
        DllCall("IbInputSimulator\IbSendInputHook", "Int", 1)
        ahk_mode := A_SendMode
        SendMode Input
    } else if (mode == 0){
        SendMode %ahk_mode%
        DllCall("IbInputSimulator\IbSendInputHook", "Int", 0)
    } else {
        throw "Invalid send mode"
    }
}

IbSendDestroy(){
    DllCall("IbInputSimulator\IbSendDestroy")
    ;DllCall("FreeLibrary", "Ptr", hModule)
}

IbSyncKeyStates(){
    DllCall("IbInputSimulator\IbSendSyncKeyStates")
}

IbSend(keys){
    DllCall("IbInputSimulator\IbSendInputHook", "Int", 1)  ;or IbSendMode(1)
    SendInput %keys%
    DllCall("IbInputSimulator\IbSendInputHook", "Int", 0)  ;or IbSendMode(0)
}
```

`Binding.AHK1/test/KeyHistory.ahk`:

```ahk
#InstallKeybdHook
#InstallMouseHook
KeyHistory

; If a key is sent by the driver, it should not have an "i" in the Type field.

F4::ExitApp
```

`Binding.AHK1/test/mode 0.ahk`:

```ahk
; Mode 0 (v1)
; Run Notepad, type "Hello world!" and then select all text by mouse.

#Include %A_ScriptDir%
#Include ..\IbInputSimulator.ahk

IbSendInit("AnyDriver", 0)

IbSend("#r")
WinWaitActive, ahk_class #32770
IbSend("notepad`n")

WinWaitActive, ahk_exe notepad.exe
IbSend("Hello world{!}")
Sleep 100
CoordMode, Mouse, Client
IbSend("{Click 5, 5, down}{click 150, 50, up}")
```

`Binding.AHK1/test/mode 1.ahk`:

```ahk
; Mode 1 (v1)
; Run Notepad, type "Hello world!" and then select all text by mouse.

#Include %A_ScriptDir%
#Include ..\IbInputSimulator.ahk

IbSendInit()

Send #r
WinWaitActive, ahk_class #32770
Send notepad`n

WinWaitActive, ahk_exe notepad.exe
Send Hello world{!}
Sleep 100
CoordMode, Mouse, Client
MouseClickDrag, Left, 5, 5, 150, 50
```

`Binding.AHK1/test/mode ahk.ahk`:

```ahk
; Run Notepad, type "Hello world!" and then select all text by mouse.

Send #r
WinWaitActive, ahk_class #32770
Send notepad`n

WinWaitActive, ahk_exe notepad.exe
Send Hello world{!}
Sleep 100
CoordMode, Mouse, Client
MouseClickDrag, Left, 5, 5, 150, 50
```

`Binding.AHK1/test/type DD.ahk`:

```ahk
#Include %A_ScriptDir%
#Include ..\IbInputSimulator.ahk
IbSendInit("DD")  ;or IbSendInit("DD", 1, "C:\SomeDir\DD64.dll")
#Include mode ahk.ahk
```

`Binding.AHK1/test/type Logitech.ahk`:

```ahk
#Include %A_ScriptDir%
#Include ..\IbInputSimulator.ahk
IbSendInit("Logitech")
#Include mode ahk.ahk
```

`Binding.AHK1/test/type MouClassInputInjection.ahk`:

```ahk
#Include %A_ScriptDir%
#Include ..\IbInputSimulator.ahk
InputBox, pid, , Please specify the process ID of the target process
IbSendInit("MouClassInputInjection", 1, pid)

;MouseClickDrag, Left, 5, 5, 150, 50, 0, R
SendInput {Click 100 100}
```

`Binding.AHK1/test/type Razer.ahk`:

```ahk
#Include %A_ScriptDir%
#Include ..\IbInputSimulator.ahk
IbSendInit("Razer")
#Include mode ahk.ahk
```

`Binding.AHK1/test/type SendInput.ahk`:

```ahk
#Include %A_ScriptDir%
#Include ..\IbInputSimulator.ahk
IbSendInit("SendInput")
#Include mode ahk.ahk
```

`Binding.AHK2/IbInputSimulator.ahk`:

```ahk
; IbInputSimulator
; Description: Enable AHK to send keystrokes by drivers.
; Author: Chaoses Ib
; Version: 0.3
; Git: https://github.com/Chaoses-Ib/IbInputSimulator

#DllLoad "*i IbInputSimulator.dll"  ;DllCall("LoadLibrary") cannot locate DLL correctly

IbSendInit(send_type := "AnyDriver", mode := 1, args*){
    workding_dir := A_WorkingDir
    SetWorkingDir(A_ScriptDir)

    static hModule := DllCall("GetModuleHandle", "Str", "IbInputSimulator.dll", "Ptr")
    if (hModule == 0){
        if (A_PtrSize == 4)
            throw "SendLibLoadFailed: Please use AutoHotkey x64"
        else
            throw "SendLibLoadFailed"
    }
    
    if (send_type == "AnyDriver")
        result := DllCall("IbInputSimulator\IbSendInit", "Int", 0, "Int", 0, "Ptr", 0, "Int")
    else if (send_type == "SendInput")
        result := DllCall("IbInputSimulator\IbSendInit", "Int", 1, "Int", 0, "Ptr", 0, "Int")
    else if (send_type == "Logitech")
        result := DllCall("IbInputSimulator\IbSendInit", "Int", 2, "Int", 0, "Ptr", 0, "Int")
    else if (send_type == "Razer")
        result := DllCall("IbInputSimulator\IbSendInit", "Int", 3, "Int", 0, "Ptr", 0, "Int")
    else if (send_type == "DD"){
        if (args.Length == 1)
            result := DllCall("IbInputSimulator\IbSendInit", "Int", 4, "Int", 0, "WStr", args[1], "Int")
        else
            result := DllCall("IbInputSimulator\IbSendInit", "Int", 4, "Int", 0, "Ptr", 0, "Int")
    } else if (send_type == "MouClassInputInjection"){
        if (args.Length != 1)
            throw "MouClassInputInjection: Please specify the process ID of the target process"
        result := DllCall("IbInputSimulator\IbSendInit", "Int", 5, "Int", 0, "UInt64", args[1], "Int")
    } else
        throw "Invalid send type"

    SetWorkingDir(workding_dir)

    if (result !== 0){
        error_text := [
            "InvalidArgument",
            "LibraryNotFound",
            "LibraryLoadFailed",
            "LibraryError",
            "DeviceCreateFailed",
            "DeviceNotFound",
            "DeviceOpenFailed"
        ]
        throw error_text[result]
    }

    if (mode !== 0){
        IbSendMode(mode)
    }
}

IbSendMode(mode){
    static ahk_mode := ""
    if (mode == 1){
        DllCall("IbInputSimulator\IbSendInputHook", "Int", 1)
        ahk_mode := A_SendMode
        SendMode("Input")
    } else if (mode == 0){
        SendMode(ahk_mode)
        DllCall("IbInputSimulator\IbSendInputHook", "Int", 0)
    } else {
        throw "Invalid send mode"
    }
}

IbSendDestroy(){
    DllCall("IbInputSimulator\IbSendDestroy")
    ;DllCall("FreeLibrary", "Ptr", hModule)
}

IbSyncKeyStates(){
    DllCall("IbInputSimulator\IbSendSyncKeyStates")
}

IbSend(keys){
    DllCall("IbInputSimulator\IbSendInputHook", "Int", 1)  ;or IbSendMode(1)
    SendInput(keys)
    DllCall("IbInputSimulator\IbSendInputHook", "Int", 0)  ;or IbSendMode(0)
}

IbClick(args*){
    IbSendMode(1)
    Click(args*)
    IbSendMode(0)
}

IbMouseMove(args*){
    IbSendMode(1)
    MouseMove(args*)
    IbSendMode(0)
}

IbMouseClick(args*){
    IbSendMode(1)
    MouseClick(args*)
    IbSendMode(0)
}

IbMouseClickDrag(args*){
    IbSendMode(1)
    MouseClickDrag(args*)
    IbSendMode(0)
}
```

`Binding.AHK2/test/KeyHistory.ahk`:

```ahk
#InstallKeybdHook
#InstallMouseHook
KeyHistory()

; If a key is sent by the driver, it should not have an "i" in the Type field.

F4::ExitApp()
```

`Binding.AHK2/test/mode 0.ahk`:

```ahk
; Mode 0
; Run Notepad, type "Hello world!" and then select all text by mouse.

#Include "..\IbInputSimulator.ahk"

IbSendInit("AnyDriver", 0)

IbSend("#r")
WinWaitActive("ahk_class #32770")
IbSend("notepad`n")

WinWaitActive("ahk_exe notepad.exe")
IbSend("Hello world{!}")
Sleep(100)
IbMouseClickDrag("Left", 5, 5, 150, 50)
```

`Binding.AHK2/test/mode 1.ahk`:

```ahk
; Mode 1
; Run Notepad, type "Hello world!" and then select all text by mouse.

#Include "..\IbInputSimulator.ahk"

IbSendInit()

Send("#r")
WinWaitActive("ahk_class #32770")
Send("notepad`n")

WinWaitActive("ahk_exe notepad.exe")
Send("Hello world{!}")
Sleep(100)
MouseClickDrag("Left", 5, 5, 150, 50)
```

`Binding.AHK2/test/mode ahk.ahk`:

```ahk
; Run Notepad, type "Hello world!" and then select all text by mouse.

Send("#r")
WinWaitActive("ahk_class #32770")
Send("notepad`n")

WinWaitActive("ahk_exe notepad.exe")
Send("Hello world{!}")
Sleep(100)
MouseClickDrag("Left", 5, 5, 150, 50)
```

`Binding.AHK2/test/type DD.ahk`:

```ahk
#Include "..\IbInputSimulator.ahk"
IbSendInit("DD")  ;or IbSendInit("DD", 1, "C:\SomeDir\DD64.dll")
#Include "mode ahk.ahk"
```

`Binding.AHK2/test/type Logitech.ahk`:

```ahk
#Include "..\IbInputSimulator.ahk"
IbSendInit("Logitech")
#Include "mode ahk.ahk"
```

`Binding.AHK2/test/type MouClassInputInjection.ahk`:

```ahk
#Include "..\IbInputSimulator.ahk"
pid := InputBox("Please specify the process ID of the target process")
IbSendInit("MouClassInputInjection", 1, pid)
#Include "mode ahk.ahk"
```

`Binding.AHK2/test/type Razer.ahk`:

```ahk
#Include "..\IbInputSimulator.ahk"
IbSendInit("Razer")
#Include "mode ahk.ahk"
```

`Binding.AHK2/test/type SendInput.ahk`:

```ahk
#Include "..\IbInputSimulator.ahk"
IbSendInit("SendInput")
#Include "mode ahk.ahk"
```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.14)

project(IbInputSimulator)

add_subdirectory(Simulator)
```

`LICENSE.txt`:

```txt
MIT License

Copyright (c) 2021 Chaoses-Ib

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# IbInputSimulator
A library for simulating keyboard, mouse and other inputs.

## Download
[Releases](https://github.com/Chaoses-Ib/IbInputSimulator/releases)

## Supported drivers
- [Logitech G HUB](https://www.logitechg.com/innovation/g-hub.html)  
  No Logitech hardware required.  
  e.g. `IbSendInit("Logitech")`
- [Logitech Gaming Software](https://support.logi.com/hc/en-gb/articles/360025298053-Logitech-Gaming-Software)  
  No Logitech hardware required.  
  e.g. `IbSendInit("Logitech")`
- [Razer Synapse 3](https://www.razer.com/synapse-3)  
  Require Razer hardware. (Note that the old versions do not require Razer hardware, however, Razer Synapse 3 only provides an online installer and there is no way to install an old version)  
  e.g. `IbSendInit("Razer")`
- [MouClassInputInjection](https://github.com/Chaoses-Ib/MouClassInputInjection)  
  e.g. `IbSendInit("MouClassInputInjection", 1, process_id)`
- [DD Virtual Mouse & Virtual Keyboard](https://github.com/ddxoft/master)  
  May cause a blue screen; difficult to uninstall cleanly; need network.  
  To use it, put the DLL (`DD94687.64.dll`/`DD64.dll`/`DDHID64.dll`) with your script file, and then:
  ```ahk
  IbSendInit("DD")
  ```
  or specify the DLL path when call IbSendInit:
  ```ahk
  IbSendInit("DD", 1, "C:\SomeDir\DD64.dll")
  ```
- [EDI](https://t.me/Chaoses_Ib) (paid)

## Software compatibility
Software | SendInput | Logitech | Razer | MCII | DD | EDI | DM | Other
--- | --- | --- | --- | --- | --- | --- | --- | ---
Blade & Soul (Korean) <!--220703--> | | ✔️ | | | ❗ | ✔️ | ✔️ | ❌ SendInput hook

## Supported languages
### AutoHotkey
<table>
<thead><tr>
    <th>AutoHotkey v2</th>
    <th>AutoHotkey v1</th>
</tr></thead>
<tbody>
    <tr>
        <td><pre lang="ahk">; Run Notepad, type "Hello world!"
; and then select all text by mouse.
<br/>
#Include "IbInputSimulator.ahk"
<br/>
IbSendInit()  ; IbSendInit("AnyDriver", 1)
<br/>
Send("#r")
WinWaitActive("ahk_class #32770")
Send("notepad`n")
<br/>
WinWaitActive("ahk_exe notepad.exe")
Send("Hello world{!}")
Sleep(100)
MouseClickDrag("Left", 5, 5, 150, 50)</pre></td>
        <td><pre lang="ahk">; Run Notepad, type "Hello world!"
; and then select all text by mouse.
<br/>
#Include %A_ScriptDir%
#Include IbInputSimulator.ahk
<br/>
IbSendInit() ; IbSendInit("AnyDriver", 1)
<br/>
Send #r
WinWaitActive, ahk_class #32770
Send notepad`n
<br/>
WinWaitActive, ahk_exe notepad.exe
Send Hello world{!}
Sleep 100
CoordMode, Mouse, Client
MouseClickDrag, Left, 5, 5, 150, 50</pre></td>
    </tr>
</tbody>
</table>

## Build
[vcpkg](https://github.com/microsoft/vcpkg):
```
vcpkg install detours rapidjson --triplet=x64-windows-static
```
CMake:
```
mkdir build
cd build
cmake .. -DCMAKE_TOOLCHAIN_FILE="C:\...\vcpkg\scripts\buildsystems\vcpkg.cmake" -DVCPKG_TARGET_TRIPLET=x64-windows-static
cmake --build . --config Release
```

For the test you also need:
```
vcpkg install boost-test fmt
```
And add `-DBUILD_TESTING=ON` when calling `cmake ..` .

## See also
- [IbLogiSoftExt](https://github.com/Chaoses-Ib/IbLogiSoftExt)

## Credits
- Logitech
  - @Eagle1020
  - [ekknod/logitech-cve](https://github.com/ekknod/logitech-cve) for learning that Logitech devices can be opened directly
- Razer
  - [Sadmeme/rzctl](https://github.com/Sadmeme/rzctl)
  - @任性 for providing test environment

Sponsors:

Date | Sponsor
--- | ---
2023-02-28 | -
2021-08-28 | 任性
```

`Simulator/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.15)

project(IbInputSimulator)

# IbWinCppLib
include(FetchContent)
FetchContent_Declare(IbWinCpp
    GIT_REPOSITORY https://github.com/Chaoses-Ib/IbWinCppLib.git
    GIT_TAG        a29ac95537f403ac5ae221cb744d3e82076efbf7
)
FetchContent_MakeAvailable(IbWinCpp)

# Detours
find_path(DETOURS_INCLUDE_DIR detours/detours.h)
find_library(DETOURS_LIBRARY detours)

# RapidJSON
find_package(RapidJSON CONFIG REQUIRED)


set(sourceFiles
    dllmain.cpp
    "API 2.cpp"
    "API 3.cpp"
)
list(TRANSFORM sourceFiles PREPEND source/)
add_library(IbInputSimulator SHARED ${sourceFiles})
set_property(TARGET IbInputSimulator PROPERTY
    MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>"
)
target_compile_features(IbInputSimulator PUBLIC cxx_std_20)
target_compile_definitions(IbInputSimulator PRIVATE IB_INPUT_DLLEXPORT)

target_include_directories(IbInputSimulator
    PUBLIC include
    PRIVATE ${DETOURS_INCLUDE_DIR}
)
target_link_libraries(IbInputSimulator
    PRIVATE IbWinCpp    
    PRIVATE ${DETOURS_LIBRARY}
    PRIVATE rapidjson
)

# Test
if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
    option(BUILD_TESTING "Build the testing tree." OFF)
    include(CTest)
    if(BUILD_TESTING)
        find_package(Boost REQUIRED COMPONENTS unit_test_framework)
        find_package(fmt CONFIG REQUIRED)

        set(testFiles
            test.cpp
        )
        list(TRANSFORM testFiles PREPEND test/)

        add_executable(IbInputSimulator_Test ${testFiles})
        target_link_libraries(IbInputSimulator_Test
            PRIVATE IbInputSimulator
            PRIVATE Boost::unit_test_framework
            PRIVATE IbWinCpp
            PRIVATE fmt::fmt
        )
    endif()
endif()
```

`Simulator/include/IbInputSimulator/InputSimulator.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <stdint.h>

#ifdef IB_INPUT_DLLEXPORT
#define DLLAPI extern "C" __declspec(dllexport)
#else
#define DLLAPI extern "C" __declspec(dllimport)
#endif

namespace Send {
    enum class Error : uint32_t {
        Success,
        InvalidArgument,
        LibraryNotFound,
        LibraryLoadFailed,
        LibraryError,
        DeviceCreateFailed,
        DeviceNotFound,
        DeviceOpenFailed
    };

    enum class SendType : uint32_t {
        AnyDriver,
        SendInput,
        Logitech,
        Razer,
        DD,
        MouClassInputInjection
    };

    using InitFlags = const uint32_t;
    struct Init {
        using T = InitFlags;
    };

    enum class HookCode : uint32_t {
        Off,
        On,
        InitOnly,
        Destroy
    };
}

DLLAPI Send::Error __stdcall IbSendInit(Send::SendType type, Send::InitFlags flags, void* argument);
DLLAPI void __stdcall IbSendDestroy();

DLLAPI void __stdcall IbSendSyncKeyStates();

#pragma region API 1

DLLAPI UINT WINAPI IbSendInput(
    _In_ UINT cInputs,                    // number of input in the array
    _In_reads_(cInputs) LPINPUT pInputs,  // array of inputs
    _In_ int cbSize                       // sizeof(INPUT)
);

DLLAPI void __stdcall IbSendInputHook(Send::HookCode code);

#pragma endregion


#pragma region API 2

DLLAPI VOID WINAPI IbSend_mouse_event(
    _In_ DWORD dwFlags,         //MOUSEEVENTF_
    _In_ DWORD dx,
    _In_ DWORD dy,
    _In_ DWORD dwData,
    _In_ ULONG_PTR dwExtraInfo
);

DLLAPI VOID WINAPI IbSend_keybd_event(
    _In_ BYTE bVk,
    _In_ BYTE bScan,
    _In_ DWORD dwFlags,         //KEYEVENTF_
    _In_ ULONG_PTR dwExtraInfo
);

#pragma endregion


#pragma region API 3

namespace Send {
    enum class MoveMode : uint32_t {
        Absolute,  //0
        Relative   //1
    };

    enum class MouseButton : uint32_t {
        LeftDown = MOUSEEVENTF_LEFTDOWN,              //0x02
        LeftUp = MOUSEEVENTF_LEFTUP,                  //0x04
        Left = LeftDown | LeftUp,                     //0x06

        RightDown = MOUSEEVENTF_RIGHTDOWN,            //0x08
        RightUp = MOUSEEVENTF_RIGHTUP,                //0x10
        Right = RightDown | RightUp,                  //0x18

        MiddleDown = MOUSEEVENTF_MIDDLEDOWN,          //0x20
        MiddleUp = MOUSEEVENTF_MIDDLEUP,              //0x40
        Middle = MiddleDown | MiddleUp,               //0x60

        XButton1Down = MOUSEEVENTF_XDOWN | XBUTTON1,  //0x81
        XButton1Up = MOUSEEVENTF_XUP | XBUTTON1,      //0x101
        XButton1 = XButton1Down | XButton1Up,         //0x181

        XButton2Down = MOUSEEVENTF_XDOWN | XBUTTON2,  //0x82
        XButton2Up = MOUSEEVENTF_XUP | XBUTTON2,      //0x102
        XButton2 = XButton2Down | XButton2Up,         //0x182
    };

    struct KeyboardModifiers {
        bool LCtrl : 1;   //0x01
        bool LShift : 1;  //0x02
        bool LAlt : 1;    //0x04
        bool LWin : 1;    //0x08
        bool RCtrl : 1;   //0x10
        bool RShift : 1;  //0x20  
        bool RAlt : 1;    //0x40
        bool RWin : 1;    //0x80
    };
}

DLLAPI bool __stdcall IbSendMouseMove(uint32_t x, uint32_t y, Send::MoveMode mode);
DLLAPI bool __stdcall IbSendMouseClick(Send::MouseButton button);
DLLAPI bool __stdcall IbSendMouseWheel(int32_t movement);

DLLAPI bool __stdcall IbSendKeybdDown(uint16_t vk);
DLLAPI bool __stdcall IbSendKeybdUp(uint16_t vk);
DLLAPI bool __stdcall IbSendKeybdDownUp(uint16_t vk, Send::KeyboardModifiers modifiers);

#pragma endregion
```

`Simulator/include/IbInputSimulator/SendTypes/DD.hpp`:

```hpp
#pragma once
#include <IbWinCpp/WinCpp.hpp>

#include "base.hpp"

namespace Send::Type::Internal {
    class DD final : virtual public Base, public VirtualKeyStates {
        KeyboardModifiers modifiers;
        std::mutex keyboard_mutex;

        HMODULE dd;
        int (*DD_btn)(int btn);
        int (*DD_whl)(int whl);
        int (*DD_mov)(int x, int y);
        int (*DD_movR)(int dx, int dy);

        int (*DD_todc)(int vk);
        int (*DD_key)(int keycode, int flag);
        //int (*DD_str)(char* str);
    public:
        DD() : VirtualKeyStates(modifiers, keyboard_mutex) {}

        Error create(const wchar_t* dd_lib) {
            if (dd_lib == nullptr) {
                if (create(L"DD94687.64.dll") == Error::Success
                    || create(L"DD64.dll") == Error::Success
                    || create(L"DDHID64.dll") == Error::Success)
                    return Error::Success;
                else
                    return Error::LibraryNotFound;  
            } else {
                dd = LoadLibraryW(dd_lib);
                if (!dd)
                    return Error::LibraryLoadFailed;

                DD_btn = ib::Addr(GetProcAddress(dd, "DD_btn"));
                if (!DD_btn) {
                    FreeLibrary(dd);
                    return Error::LibraryLoadFailed;
                }
                DD_whl = ib::Addr(GetProcAddress(dd, "DD_whl"));
                DD_mov = ib::Addr(GetProcAddress(dd, "DD_mov"));
                DD_movR = ib::Addr(GetProcAddress(dd, "DD_movR"));

                DD_todc = ib::Addr(GetProcAddress(dd, "DD_todc"));
                DD_key = ib::Addr(GetProcAddress(dd, "DD_key"));
                //DD_str = ib::Addr(GetProcAddress(dd, "DD_str"));

                if (!(DD_whl && DD_mov && DD_movR && DD_todc && DD_key /*&& DD_str*/)) {
                    FreeLibrary(dd);
                    return Error::LibraryLoadFailed;
                }

                if (DD_btn(0) != 1) {
                    FreeLibrary(dd);
                    return Error::LibraryError;
                }

                return Error::Success;
            }
        }

        void destroy() override {
            FreeLibrary(dd);
        }

        uint32_t send_mouse_input(const INPUT inputs[], uint32_t n) override {
            update_screen_resolution();
            return Base::send_mouse_input(inputs, n);
        }

        bool send_mouse_input(const MOUSEINPUT& mi) override {
            //#TODO: MOUSEEVENTF_MOVE_NOCOALESCE, MOUSEEVENTF_VIRTUALDESK
            if (mi.dwFlags & MOUSEEVENTF_MOVE) {
                POINT move{ mi.dx, mi.dy };
                if (mi.dwFlags & MOUSEEVENTF_ABSOLUTE) {
                    mouse_absolute_to_screen(move);
                    if constexpr (debug)
                        DebugOStream() << L"DD_mov: (" << move.x << L", " << move.y << L")\n";
                    DD_mov(move.x, move.y);
                } else {
                    if constexpr (debug)
                        DebugOStream() << L"DD_movR: (" << move.x << L", " << move.y << L")\n";
                    DD_movR(move.x, move.y);
                }
            }

            if (mi.dwFlags & 0x7E) {
                DWORD keys[] = { MOUSEEVENTF_LEFTDOWN, MOUSEEVENTF_LEFTUP, MOUSEEVENTF_RIGHTDOWN, MOUSEEVENTF_RIGHTUP, MOUSEEVENTF_MIDDLEDOWN, MOUSEEVENTF_MIDDLEUP };
                for (DWORD key : keys)
                    if (mi.dwFlags & key) {
                        if constexpr (debug)
                            DebugOStream() << L"DD_btn: " << (key >> 1) << L"\n";
                        DD_btn(key >> 1);
                    }
            }
            if (mi.dwFlags & (MOUSEEVENTF_XDOWN | MOUSEEVENTF_XUP)) {
                bool down = mi.dwFlags & MOUSEEVENTF_XDOWN;
                switch (mi.mouseData) {
                case XBUTTON1: DD_btn(down ? 64 : 128); break;
                case XBUTTON2: DD_btn(down ? 256 : 512); break;
                }
            } else if (mi.dwFlags & MOUSEEVENTF_WHEEL) {
                int32_t v = std::bit_cast<int32_t>(mi.mouseData);
                int sign = v > 0 ? 1 : -1;
                if constexpr (debug)
                    DebugOStream() << L"DD_whl: " << v << L"\n";
                for (DWORD i = 0; i < abs(v); i++)
                    DD_whl(sign);
            }

            return true;  //#TODO
        }

        bool send_keyboard_input(const KEYBDINPUT& ki) override {
            std::lock_guard lock(keyboard_mutex);

            bool keydown = !(ki.dwFlags & KEYEVENTF_KEYUP);
            if (is_modifier(ki.wVk))
                set_modifier_state(ki.wVk, keydown);
            
            int dd_code = DD_todc(ki.wVk);
            if (dd_code == -1) {
                // (some version) DD do not support left/right modifiers
                if (ki.wVk == VK_LSHIFT || ki.wVk == VK_RSHIFT)
                    dd_code = DD_todc(VK_SHIFT);
                else if (ki.wVk == VK_LCONTROL || ki.wVk == VK_RCONTROL)
                    dd_code = DD_todc(VK_CONTROL);
                else if (ki.wVk == VK_LMENU || ki.wVk == VK_RMENU)
                    dd_code = DD_todc(VK_MENU);

                if (dd_code == -1) {
                    if constexpr (debug)
                        DebugOStream() << L"DD_todc: unsupported key " << ki.wVk << L"\n";
                    return false;
                }
                else {
                    if constexpr (debug)
                        DebugOStream() << L"DD_todc: left/right modifier key (" << ki.wVk << ") is unsupported" << L"\n";
                }
            }
            if constexpr (debug)
                DebugOStream() << L"DD_key: " << dd_code << L" (vk" << ki.wVk << L"), " << (keydown ? 1 : 2) << L")\n";
            DD_key(dd_code, keydown ? 1 : 2);  //#TODO: result?

            return true;
        }

#pragma warning(suppress : 4250)  //'class1' : inherits 'class2::member' via dominance
    };
}
```

`Simulator/include/IbInputSimulator/SendTypes/Logitech.hpp`:

```hpp
#pragma once
#include <string>
#include <rapidjson/document.h>
#include <rapidjson/filereadstream.h>
#include "../common.hpp"
#include "base.hpp"
#include "usb.hpp"

namespace Send::Type::Internal {
    class LogitechDriver {
        HANDLE device;
        bool has_acceleration;

    public:
        Error create() {
            std::wstring device_name = find_device();
            if (device_name.empty())
                return Error::DeviceNotFound;

            device = CreateFileW(
                device_name.c_str(),
                GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                OPEN_EXISTING, 0, NULL
            );
            if (device == INVALID_HANDLE_VALUE)
                return Error::DeviceOpenFailed;

            int acceleration = get_has_acceleration();
            /* #TODO: G HUB
            if (acceleration < 0) {
                CloseHandle(device);
                return Error::LogiSettingsNotFound;
            }
            */
            has_acceleration = acceleration == 1;

            return Error::Success;
        }

        void destroy() {
            CloseHandle(device);
        }

    private:
        int get_has_acceleration() {
            //#TODO: G HUB

            using namespace rapidjson;
            //#TODO: 20 warnings... maybe getline is better? or disable warnings for rapidjson?

            //fopen doesn't support environment variables
            wchar_t path[MAX_PATH];
            ExpandEnvironmentStringsW(LR"(%LOCALAPPDATA%\Logitech\Logitech Gaming Software\settings.json)", path, (DWORD)std::size(path));
            FILE* file = _wfsopen(path, L"rb", _SH_DENYNO);
            if (!file) {
                return -1;
            }
            char* buf = new char[16 * 1024];
            FileReadStream is(file, buf, sizeof(buf));

            int result;
            Document doc;
            doc.ParseStream(is);

            //pointer.hasAcceleration
            //#TODO: FindMember
            if (doc.HasMember("pointer")) {
                auto& pointer = doc["pointer"];
                if (pointer.HasMember("hasAcceleration")) {
                    result = pointer["hasAcceleration"].GetBool();
                }
                else {
                    //hasAcceleration not found
                    result = 0;
                }
            }
            else {
                //pointer not found
                result = 0;
            }

            fclose(file);
            delete[] buf;

            return result;
        }

        std::wstring find_device() {
            return Internal::find_device([](std::wstring_view sv) {
                using namespace std::literals;

                //LGS:
                //ROOT#SYSTEM#0001#{df31f106-d870-453d-8fa1-ec8ab43fa1d2}
                //ROOT#SYSTEM#0001#{5bada891-842b-4296-a496-68ae931aa16c}
                //Root#SYSTEM#0001#{df31f106-d870-453d-8fa1-ec8ab43fa1d2}
                //Root#SYSTEM#0001#{5bada891-842b-4296-a496-68ae931aa16c}

                //G HUB:
                //ROOT#SYSTEM#0001#{1abc05c0-c378-41b9-9cef-df1aba82b015}
                //ROOT#SYSTEM#0002#{1abc05c0-c378-41b9-9cef-df1aba82b015} ?
                //ROOT#SYSTEM#0001#{dfbedcdb-2148-416d-9e4d-cecc2424128c}

                return (sv.starts_with(L"ROOT#SYSTEM#"sv)
                     || sv.starts_with(L"Root#SYSTEM#"sv))
                     &&
                       (sv.ends_with(L"#{1abc05c0-c378-41b9-9cef-df1aba82b015}"sv)
                     || sv.ends_with(L"#{df31f106-d870-453d-8fa1-ec8ab43fa1d2}"sv)
                     || sv.ends_with(L"#{dfbedcdb-2148-416d-9e4d-cecc2424128c}"sv)
                     || sv.ends_with(L"#{5bada891-842b-4296-a496-68ae931aa16c}"sv));
            });
        }

    public:
        struct MouseButton {
            bool LButton : 1;
            bool RButton : 1;
            bool MButton : 1;
            bool XButton1 : 1;
            bool XButton2 : 1;
            bool unknown : 3;
        };

        struct MouseReport {
            union {
                MouseButton button;
                Byte button_byte;
            };
            int8_t x;
            int8_t y;
            Byte unknown_W;  //#TODO: Wheel?
            Byte unknown_T;  //#TODO: T?
        private:
            void assert_size() {
                static_assert(sizeof MouseReport == 5);
            }
        };

    private:
        [[deprecated]] static LONG compensate_win_acceleration(LONG x) {
            //#TODO

            static struct {
                int threshold[2];
                int acceleration;
            } mouse;
            static int speed = -1;  //1~20. #TODO: 0 when disabled?
            if (speed == -1) {  //#TODO: may change
                SystemParametersInfoW(SPI_GETMOUSE, 0, &mouse, 0);
                SystemParametersInfoW(SPI_GETMOUSESPEED, 0, &speed, 0);
                if constexpr (debug)
                    DebugOStream() << L"compensate_win_acceleration: "
                    << mouse.acceleration << L", " << mouse.threshold[0] << L"," << mouse.threshold[1]
                    << L", " << speed << std::endl;
                //1, 6,10, 10
            }

            /*
            if (mouse.acceleration) {
                if (x > mouse.threshold[0])
                    x *= 2;
                if (x > mouse.threshold[1] && mouse.acceleration == 2)
                    x *= 2;
            }
            return x * speed / 10;
            */

            return x;
        }

        static int8_t compensate_lgs_acceleration(int8_t x) {
            int8_t abs_x = abs(x);
            int8_t sign = x > 0 ? 1 : -1;

            if (abs_x <= 5)
                return x;
            else if (abs_x <= 10)
                return sign * (abs_x + 1);
            else
                return sign * (int8_t)round(0.6156218196 * abs_x + 4.45777444629);
        }

    public:
        bool report_mouse(MouseReport report, int8_t compensate_switch) const {
            constexpr DWORD IOCTL_BUSENUM_PLAY_MOUSEMOVE = 0x2A2010;
            DWORD bytes_returned;

            if (has_acceleration && (report.x || report.y)) {
                MouseReport report11 = report;
                report11.x = report11.y = compensate_switch;
                DeviceIoControl(device, IOCTL_BUSENUM_PLAY_MOUSEMOVE, &report11, sizeof MouseReport, nullptr, 0, &bytes_returned, nullptr);

                report.x = compensate_lgs_acceleration(report.x);
                report.y = compensate_lgs_acceleration(report.y);
            }

            if constexpr (debug) {
                bool success = DeviceIoControl(device, IOCTL_BUSENUM_PLAY_MOUSEMOVE, &report, sizeof MouseReport, nullptr, 0, &bytes_returned, nullptr);
                DWORD error = GetLastError();
                DebugOStream() << L"report_mouse: " << report.button_byte << L", " << report.x << L", " << report.y << L". "
                    << success << L", " << error << std::endl;
                return success;
            }
            return DeviceIoControl(device, IOCTL_BUSENUM_PLAY_MOUSEMOVE, &report, sizeof MouseReport, nullptr, 0, &bytes_returned, nullptr);
        }

        struct KeyboardReport {
            union {
                KeyboardModifiers modifiers;
                Byte modifiers_byte;
            };
            Byte reserved;
            Byte keys[6];
        private:
            void assert_size() {
                static_assert(sizeof KeyboardReport == 8);
            }
        };

        bool report_keyboard(KeyboardReport report) const {
            DWORD bytes_returned;
            if constexpr (debug) {
                bool success = DeviceIoControl(device, 0x2A200C, &report, sizeof KeyboardReport, nullptr, 0, &bytes_returned, nullptr);
                DWORD error = GetLastError();
                DebugOStream() << L"report_keyboard: " << report.modifiers_byte << L", " << report.keys[0] << L", " << report.keys[1] << L". "
                    << success << L", " << error << std::endl;
                return success;
            }
            return DeviceIoControl(device, 0x2A200C, &report, sizeof KeyboardReport, nullptr, 0, &bytes_returned, nullptr);
        }
    };

    class Logitech final : virtual public Base, public VirtualKeyStates {
        LogitechDriver driver;
    public:
        Logitech() : VirtualKeyStates(keyboard_report.modifiers, keyboard_mutex) {}

        Error create() {
            return driver.create();
        }

        void destroy() override {
            driver.destroy();
        }

    private:
        LogitechDriver::MouseReport mouse_report{};
        uint8_t compensate_switch = -1;
        std::mutex mouse_mutex;

    public:
        uint32_t send_mouse_input(const INPUT inputs[], uint32_t n) override {
            update_screen_resolution();
            return Base::send_mouse_input(inputs, n);
        }

        bool send_mouse_input(const MOUSEINPUT& mi) override {
            std::lock_guard lock(mouse_mutex);
            
            if constexpr (debug)
                DebugOStream() << L"send_mouse_input: " << mi.dwFlags << L", " << mi.dx << L", " << mi.dy << std::endl;

            //#TODO: move and then click, or click and then move? former?

            //#TODO: MOUSEEVENTF_MOVE_NOCOALESCE, MOUSEEVENTF_VIRTUALDESK
            if (mi.dwFlags & MOUSEEVENTF_MOVE) {
                POINT move { mi.dx, mi.dy };
                if (mi.dwFlags & MOUSEEVENTF_ABSOLUTE) {
                    mouse_absolute_to_screen(move);
                    mouse_screen_to_relative(move);
                }

                while (abs(move.x) > 127 || abs(move.y) > 127) {
                    if (abs(move.x) > 127) {
                        mouse_report.x = move.x > 0 ? 127 : -127;
                        move.x -= mouse_report.x;
                    }
                    else {
                        mouse_report.x = 0;
                    }

                    if (abs(move.y) > 127) {
                        mouse_report.y = move.y > 0 ? 127 : -127;
                        move.y -= mouse_report.y;
                    }
                    else {
                        mouse_report.y = 0;
                    }

                    driver.report_mouse(mouse_report, compensate_switch = -compensate_switch);
                }

                mouse_report.x = (uint8_t)move.x;
                mouse_report.y = (uint8_t)move.y;
            } else {
                mouse_report.x = 0;
                mouse_report.y = 0;
            }

#define CODE_GENERATE(down, up, member)  \
            if (mi.dwFlags & down || mi.dwFlags & up)  \
                mouse_report.button.##member = mi.dwFlags & down;

            CODE_GENERATE(MOUSEEVENTF_LEFTDOWN, MOUSEEVENTF_LEFTUP, LButton)  //#TODO: may be switched?
            CODE_GENERATE(MOUSEEVENTF_RIGHTDOWN, MOUSEEVENTF_RIGHTUP, RButton)
            CODE_GENERATE(MOUSEEVENTF_MIDDLEDOWN, MOUSEEVENTF_MIDDLEUP, MButton)
#undef CODE_GENERATE
            if (mi.dwFlags & (MOUSEEVENTF_XDOWN | MOUSEEVENTF_XUP)) {
                bool down = mi.dwFlags & MOUSEEVENTF_XDOWN;
                switch (mi.mouseData) {
                case XBUTTON1: mouse_report.button.XButton1 = down; break;
                case XBUTTON2: mouse_report.button.XButton2 = down; break;
                }
            }
        
            return driver.report_mouse(mouse_report, compensate_switch = -compensate_switch);
        }

    private:
        LogitechDriver::KeyboardReport keyboard_report{};
        std::mutex keyboard_mutex;
    public:
        bool send_keyboard_input(const KEYBDINPUT& ki) override {
            std::lock_guard lock(keyboard_mutex);

            bool keydown = !(ki.dwFlags & KEYEVENTF_KEYUP);
            if (is_modifier(ki.wVk)) {
                set_modifier_state(ki.wVk, keydown);
            }
            else {
                uint8_t usage = Usb::keyboard_vk_to_usage((uint8_t)ki.wVk);;
                if (keydown) {
                    for (int i = 0; i < 6; i++) {
                        if (keyboard_report.keys[i] == 0) {
                            keyboard_report.keys[i] = usage;
                            break;
                        }
                    }
                    //full
                }
                else {
                    for (int i = 0; i < 6; i++) {
                        if (keyboard_report.keys[i] == usage) {
                            keyboard_report.keys[i] = 0;
                            //#TODO: move to left?
                            break;
                        }
                    }
                }
            }

            return driver.report_keyboard(keyboard_report);
        }
#pragma warning(suppress : 4250)  //'class1' : inherits 'class2::member' via dominance
    };
}
```

`Simulator/include/IbInputSimulator/SendTypes/MouClassInputInjection.hpp`:

```hpp
#pragma once
#include "base.hpp"
#include "MouClassInputInjection/ioctl.h"

namespace Send::Type::Internal {
    class MouClassInputInjection final : virtual public Base {
    public:
        MouClassInputInjection() {}
        
        Error create(ULONG_PTR pid) {
            device = CreateFileW(
                LOCAL_DEVICE_PATH_U,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                nullptr,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                nullptr
            );
            if (device == INVALID_HANDLE_VALUE)
                return Error::DeviceNotFound;
            
            DWORD bytes_returned;
            if (!DeviceIoControl(
                device,
                IOCTL_INITIALIZE_MOUSE_DEVICE_STACK_CONTEXT,
                nullptr, 0,
                &device_info, sizeof(device_info),
                &bytes_returned,
                nullptr
            )) {
                CloseHandle(device);
                return Error::DeviceOpenFailed;
            }

            this->pid = pid;

            return Error::Success;
        }
        
        void destroy() override {
            CloseHandle(device);
        }

        bool send_mouse_input(const MOUSEINPUT& mi) override {
            if (mi.dwFlags & MOUSEEVENTF_MOVE) {
                USHORT flags = 0;
                POINT move{ mi.dx, mi.dy };
                
                // MOUSE_MOVE_RELATIVE: 0
                if (device_info.MovementDevice.AbsoluteMovement) {
                    flags |= MOUSE_MOVE_ABSOLUTE;
                    if (!(mi.dwFlags & MOUSEEVENTF_ABSOLUTE)) {
                        POINT cursor;
                        GetCursorPos(&cursor);
                        move.x += cursor.x;
                        move.y += cursor.y;
                    }
                    else {
                        //@todo mouse_absolute_to_screen(move);
                    }
                }
                else {
                    if (mi.dwFlags & MOUSEEVENTF_ABSOLUTE) {
                        mouse_absolute_to_screen(move);
                        mouse_screen_to_relative(move);
                    }
                }
                    
                //@todo mi.dwFlags & MOUSEEVENTF_VIRTUALDESK
                if (device_info.MovementDevice.VirtualDesktop)
                    flags |= MOUSE_VIRTUAL_DESKTOP;
                
                // MOUSE_ATTRIBUTES_CHANGED
                
                if (mi.dwFlags & MOUSEEVENTF_MOVE_NOCOALESCE)
                    flags |= MOUSE_MOVE_NOCOALESCE;
                
                // MOUSE_TERMSRV_SRC_SHADOW: unknown
                
                INJECT_MOUSE_MOVEMENT_INPUT_REQUEST request{
                    .ProcessId = pid,
                    .IndicatorFlags = flags,
                    .MovementX = move.x,
                    .MovementY = move.y
                };
                DWORD bytes_returned;
                DeviceIoControl(
                    device,
                    IOCTL_INJECT_MOUSE_MOVEMENT_INPUT,
                    &request, sizeof(request),
                    nullptr, 0,
                    &bytes_returned,
                    nullptr
                );
            }

            if (mi.dwFlags & 0x7E) {
                DWORD keys[] = { MOUSEEVENTF_LEFTDOWN, MOUSEEVENTF_LEFTUP, MOUSEEVENTF_RIGHTDOWN, MOUSEEVENTF_RIGHTUP, MOUSEEVENTF_MIDDLEDOWN, MOUSEEVENTF_MIDDLEUP };
                for (DWORD key : keys)
                    if (mi.dwFlags & key)
                        inject_button(key >> 1);
            }
            if (mi.dwFlags & (MOUSEEVENTF_XDOWN | MOUSEEVENTF_XUP)) {
                bool down = mi.dwFlags & MOUSEEVENTF_XDOWN;
                switch (mi.mouseData) {
                case XBUTTON1: inject_button(down ? MOUSE_BUTTON_4_DOWN : MOUSE_BUTTON_4_UP); break;
                case XBUTTON2: inject_button(down ? MOUSE_BUTTON_5_DOWN : MOUSE_BUTTON_5_UP); break;
                }
            }
            else if (mi.dwFlags & MOUSEEVENTF_WHEEL)
                return false;

            //@todo
            return true;
        }

        bool send_keyboard_input(const KEYBDINPUT& ki) override {
            return false;
        }
        
    private:
        HANDLE device;
        MOUSE_DEVICE_STACK_INFORMATION device_info;
        ULONG_PTR pid;

        bool inject_button(USHORT button) {
            INJECT_MOUSE_BUTTON_INPUT_REQUEST request{
                .ProcessId = pid,
                .ButtonFlags = button,
                .ButtonData = 0
            };
            DWORD bytes_returned;
            return DeviceIoControl(
                device,
                IOCTL_INJECT_MOUSE_BUTTON_INPUT,
                &request, sizeof(request),
                nullptr, 0,
                &bytes_returned,
                nullptr
            );
        }
    };
}
```

`Simulator/include/IbInputSimulator/SendTypes/MouClassInputInjection/ioctl.h`:

```h
/*++

Copyright (c) 2019 changeofpace. All rights reserved.

Use of this source code is governed by the MIT license. See the 'LICENSE' file
for more information.

--*/

#pragma once

#if defined(_KERNEL_MODE)
#include <fltKernel.h>
#else
#include <Windows.h>
#endif

#include <devioctl.h>
#include <ntddmou.h>

//=============================================================================
// Names
//=============================================================================
#define DRIVER_NAME_U           L"MouClassInputInjection"
#define LOCAL_DEVICE_PATH_U     (L"\\\\.\\" DRIVER_NAME_U)
#define NT_DEVICE_NAME_U        (L"\\Device\\" DRIVER_NAME_U)
#define SYMBOLIC_LINK_NAME_U    (L"\\DosDevices\\" DRIVER_NAME_U)

//=============================================================================
// Ioctls
//=============================================================================
#define FILE_DEVICE_MOUCLASS_INPUT_INJECTION    48781ul

#define IOCTL_INITIALIZE_MOUSE_DEVICE_STACK_CONTEXT \
    CTL_CODE(                                       \
        FILE_DEVICE_MOUCLASS_INPUT_INJECTION,       \
        2600,                                       \
        METHOD_BUFFERED,                            \
        FILE_ANY_ACCESS)

#define IOCTL_INJECT_MOUSE_BUTTON_INPUT         \
    CTL_CODE(                                   \
        FILE_DEVICE_MOUCLASS_INPUT_INJECTION,   \
        2850,                                   \
        METHOD_BUFFERED,                        \
        FILE_ANY_ACCESS)

#define IOCTL_INJECT_MOUSE_MOVEMENT_INPUT       \
    CTL_CODE(                                   \
        FILE_DEVICE_MOUCLASS_INPUT_INJECTION,   \
        2851,                                   \
        METHOD_BUFFERED,                        \
        FILE_ANY_ACCESS)

#define IOCTL_INJECT_MOUSE_INPUT_PACKET         \
    CTL_CODE(                                   \
        FILE_DEVICE_MOUCLASS_INPUT_INJECTION,   \
        2870,                                   \
        METHOD_BUFFERED,                        \
        FILE_ANY_ACCESS)

//=============================================================================
// IOCTL_INITIALIZE_MOUSE_DEVICE_STACK_CONTEXT
//=============================================================================
typedef struct _MOUSE_CLASS_BUTTON_DEVICE_INFORMATION {
    USHORT UnitId;
} MOUSE_CLASS_BUTTON_DEVICE_INFORMATION,
*PMOUSE_CLASS_BUTTON_DEVICE_INFORMATION;

typedef struct _MOUSE_CLASS_MOVEMENT_DEVICE_INFORMATION {
    USHORT UnitId;
    BOOLEAN AbsoluteMovement;
    BOOLEAN VirtualDesktop;
} MOUSE_CLASS_MOVEMENT_DEVICE_INFORMATION,
*PMOUSE_CLASS_MOVEMENT_DEVICE_INFORMATION;

typedef struct _MOUSE_DEVICE_STACK_INFORMATION {
    MOUSE_CLASS_BUTTON_DEVICE_INFORMATION ButtonDevice;
    MOUSE_CLASS_MOVEMENT_DEVICE_INFORMATION MovementDevice;
} MOUSE_DEVICE_STACK_INFORMATION, *PMOUSE_DEVICE_STACK_INFORMATION;

typedef struct _INITIALIZE_MOUSE_DEVICE_STACK_CONTEXT_REPLY {
    MOUSE_DEVICE_STACK_INFORMATION DeviceStackInformation;
} INITIALIZE_MOUSE_DEVICE_STACK_CONTEXT_REPLY,
*PINITIALIZE_MOUSE_DEVICE_STACK_CONTEXT_REPLY;

//=============================================================================
// IOCTL_INJECT_MOUSE_BUTTON_INPUT
//=============================================================================
typedef struct _INJECT_MOUSE_BUTTON_INPUT_REQUEST {
    ULONG_PTR ProcessId;
    USHORT ButtonFlags;
    USHORT ButtonData;
} INJECT_MOUSE_BUTTON_INPUT_REQUEST, *PINJECT_MOUSE_BUTTON_INPUT_REQUEST;

//=============================================================================
// IOCTL_INJECT_MOUSE_MOVEMENT_INPUT
//=============================================================================
typedef struct _INJECT_MOUSE_MOVEMENT_INPUT_REQUEST {
    ULONG_PTR ProcessId;
    USHORT IndicatorFlags;
    LONG MovementX;
    LONG MovementY;
} INJECT_MOUSE_MOVEMENT_INPUT_REQUEST, *PINJECT_MOUSE_MOVEMENT_INPUT_REQUEST;

//=============================================================================
// IOCTL_INJECT_MOUSE_INPUT_PACKET
//=============================================================================
typedef struct _INJECT_MOUSE_INPUT_PACKET_REQUEST {
    ULONG_PTR ProcessId;
    BOOLEAN UseButtonDevice;
    MOUSE_INPUT_DATA InputPacket;
} INJECT_MOUSE_INPUT_PACKET_REQUEST, *PINJECT_MOUSE_INPUT_PACKET_REQUEST;

```

`Simulator/include/IbInputSimulator/SendTypes/Razer.hpp`:

```hpp
#pragma once
#include "base.hpp"
#include "usb.hpp"

namespace Send::Type::Internal {
    class Razer final : virtual public Base, public VirtualKeyStates {
        HANDLE device;

        KeyboardModifiers modifiers;
        std::mutex keyboard_mutex;
    public:
        Razer() : VirtualKeyStates(modifiers, keyboard_mutex) {}

        Error create() {
            std::wstring device_name = find_device([](std::wstring_view sv) {
                using namespace std::literals;

                //RZCONTROL#VID_1532&PID_0306&MI_00#3&1c65d7f8&0#{e3be005d-d130-4910-88ff-09ae02f680e9}
                return sv.starts_with(L"RZCONTROL#"sv) && sv.ends_with(L"#{e3be005d-d130-4910-88ff-09ae02f680e9}"sv);
            });
            if (device_name.empty())
                return Error::DeviceNotFound;

            device = CreateFileW(
                device_name.c_str(),
                GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                OPEN_EXISTING, 0, NULL
            );
            if (device == INVALID_HANDLE_VALUE)
                return Error::DeviceOpenFailed;

            return Error::Success;
        }

        void destroy() override {
            CloseHandle(device);
        }

        struct RzControl {
            uint32_t unk1;
            enum class Type : uint32_t {
                Keyboard = 1,
                Mouse = 2
            } type;
            union {
                struct {
                    uint32_t absolute_coord;
                    struct {
                        bool LButtonDown : 1;
                        bool LButtonUp : 1;
                        bool RButtonDown : 1;
                        bool RButtonUp : 1;
                        bool MButtonDown : 1;
                        bool MButtonUp : 1;
                        bool XButton1Down : 1;
                        bool XButton1Up : 1;
                        bool XButton2Down : 1;
                        bool XButton2Up : 1;
                        bool Wheel : 1;
                        bool HWheel : 1;
                        uint8_t unk : 4;
                    private:
                        void assert_size() {
                            static_assert(sizeof(*this) == 2);
                        }
                    } btn;
                    int16_t movement;
                    uint32_t unk1;
                    int32_t x;
                    int32_t y;
                    uint32_t unk2;
                } mi;
                struct {
                    uint16_t unk1;
                    int16_t key;
                    uint16_t action;
                    uint16_t unk2;
                    uint32_t unk3;
                    uint32_t unk4;
                    uint32_t unk5;
                    uint32_t unk6;
                } ki;
            };
        private:
            void assert_size() {
                static_assert(sizeof RzControl == 32);
            }
        };

        bool send_mouse_input(const MOUSEINPUT& mi) override {
            RzControl control{ .type = RzControl::Type::Mouse };

            if (mi.dwFlags & MOUSEEVENTF_MOVE) {
                POINT move{ mi.dx, mi.dy };
                if (mi.dwFlags & MOUSEEVENTF_ABSOLUTE) {
                    control.mi.absolute_coord = 0x10000;
                }
                control.mi.x = mi.dx;
                control.mi.y = mi.dy;
            }

#define CODE_GENERATE(down, up, member)  \
            control.mi.btn.##member##Down = mi.dwFlags & down;  \
            control.mi.btn.##member##Up = mi.dwFlags & up;

            CODE_GENERATE(MOUSEEVENTF_LEFTDOWN, MOUSEEVENTF_LEFTUP, LButton)  //#TODO: may be switched?
            CODE_GENERATE(MOUSEEVENTF_RIGHTDOWN, MOUSEEVENTF_RIGHTUP, RButton)
            CODE_GENERATE(MOUSEEVENTF_MIDDLEDOWN, MOUSEEVENTF_MIDDLEUP, MButton)
#undef CODE_GENERATE
            if (mi.dwFlags & MOUSEEVENTF_XDOWN) {
                switch (mi.mouseData) {
                case XBUTTON1: control.mi.btn.XButton1Down = 1; break;
                case XBUTTON2: control.mi.btn.XButton2Down = 1; break;
                }
            } else if (mi.dwFlags & MOUSEEVENTF_XUP) {
                switch (mi.mouseData) {
                case XBUTTON1: control.mi.btn.XButton1Up = 1; break;
                case XBUTTON2: control.mi.btn.XButton2Up = 1; break;
                }
            } else if (mi.dwFlags & MOUSEEVENTF_WHEEL || mi.dwFlags & MOUSEEVENTF_HWHEEL) {
                if (mi.dwFlags & MOUSEEVENTF_WHEEL)
                    control.mi.btn.Wheel = 1;
                else
                    control.mi.btn.HWheel = 1;
                control.mi.movement = 120 * std::bit_cast<int32_t>(mi.mouseData);  //#TODO
            }

            if constexpr (debug)
                DebugOStream() << L"send_mouse_input: " << *(uint16_t*)&control.mi.btn << L", (" << control.mi.x << L", " << control.mi.y << L") " << control.mi.absolute_coord << std::endl;

            DWORD bytes_returned;
            return DeviceIoControl(device, 0x88883020, &control, sizeof control, nullptr, 0, &bytes_returned, nullptr);
        }

        bool send_keyboard_input(const KEYBDINPUT& ki) override {
            RzControl control{ .type = RzControl::Type::Keyboard };

            if ((control.ki.key = keyboard_vk_to_key(ki.wVk)) < 0)
                return false;

            std::lock_guard lock(keyboard_mutex);

            bool keydown = !(ki.dwFlags & KEYEVENTF_KEYUP);
            if (is_modifier(ki.wVk))
                set_modifier_state(ki.wVk, keydown);

            if (ki.wVk == VK_LWIN || ki.wVk == VK_RWIN)  //#TODO: Any other keys?
                control.ki.action = keydown ? 2 : 3;
            else
                control.ki.action = keydown ? 0 : 1;

            if constexpr (debug)
                DebugOStream() << L"send_keyboard_input: " << control.ki.key << ", " << control.ki.action << std::endl;

            DWORD bytes_returned;
            return DeviceIoControl(device, 0x88883020, &control, sizeof control, nullptr, 0, &bytes_returned, nullptr);
        }

        int16_t keyboard_vk_to_key(uint8_t vk) {
            if constexpr (debug)
                DebugOStream() << L"keyboard_vk_to_key: " << vk << L" -> " << Usb::keyboard_vk_to_usage(vk) << L" -> " << keyboard_usage_to_key(Usb::keyboard_vk_to_usage(vk)) << std::endl;
            return keyboard_usage_to_key(Usb::keyboard_vk_to_usage(vk));
        }

        // RCtrl and RAlt will be treated as left ones.
        constexpr int16_t keyboard_usage_to_key(uint16_t usage_id) {
            if (usage_id <= 115) {
                constexpr uint16_t table[] = { -1, 255, 252, -3, 30, 48, 46, 32, 18, 33, 34, 35, 23, 36, 37, 38, 50, 49, 24, 25, 16, 19, 31, 20, 22, 47, 17, 45, 21, 44, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 28, 1, 14, 15, 57, 12, 13, 26, 27, 43, 43, 39, 40, 41, 51, 52, 53, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 87, 88, 55, 70, 29, 82, 71, 73, 83, 79, 81, 77, 75, 80, 72, 69, 53, 55, 74, 78, 28, 79, 80, 81, 75, 76, 77, 71, 72, 73, 82, 83, 86, 93, 94, 89, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 118, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, 94, 95, 99, -3, 126, -3, 115, 112, 125, 121, 123, 92, -3, -3, -3, 242, 241, 120, 119, 118 };
                return table[usage_id];
            } else if (181 <= usage_id && usage_id <= 183) {
                constexpr uint16_t table[] = { 25,16,36 };
                return table[usage_id - 181];
            } else if (usage_id == 205)
                return 34;
            else if (224 <= usage_id && usage_id <= 234) {
                constexpr uint16_t table[] = { 29, 42, 56, 91, 29, 54, 56, 92, -2, 48, 46 };
                return table[usage_id - 224];
            }
            return -1;
        }
    };
}
```

`Simulator/include/IbInputSimulator/SendTypes/SendInput.hpp`:

```hpp
#pragma once
#include "base.hpp"

namespace Send::Type::Internal {
    class SendInput final : virtual public Base {
        decltype(&::SendInput) *SendInput_true;
    public:
        Error create(decltype(&::SendInput)* SendInput_true) {
            this->SendInput_true = SendInput_true;
            return Error::Success;
        }

        void destroy() override {}

        uint32_t send_input(const INPUT inputs[], uint32_t n) override {
            return (*SendInput_true)(n, const_cast<INPUT*>(inputs), sizeof INPUT);
        }


        uint32_t send_mouse_input(const INPUT inputs[], uint32_t n) override {
            return (*SendInput_true)(n, const_cast<INPUT*>(inputs), sizeof INPUT);
        }

        bool send_mouse_input(const MOUSEINPUT& mi) override {
            INPUT input;
            input.type = INPUT_MOUSE;
            input.mi = mi;
            return (*SendInput_true)(1, &input, sizeof INPUT);
        }


        uint32_t send_keyboard_input(const INPUT inputs[], uint32_t n) override {
            return (*SendInput_true)(n, const_cast<INPUT*>(inputs), sizeof INPUT);
        }

        bool send_keyboard_input(const KEYBDINPUT& ki) override {
            INPUT input;
            input.type = INPUT_KEYBOARD;
            input.ki = ki;
            return (*SendInput_true)(1, &input, sizeof INPUT);
        }
    };
}
```

`Simulator/include/IbInputSimulator/SendTypes/base.hpp`:

```hpp
#pragma once
#include "../common.hpp"
#include <mutex>
#include <IbWinCpp/WinCpp.hpp>

#include <winternl.h>
#pragma comment(lib, "ntdll.lib")

extern "C" {
    constexpr NTSTATUS STATUS_SUCCESS = 0x00000000;
    constexpr NTSTATUS STATUS_MORE_ENTRIES = 0x00000105;
    constexpr NTSTATUS STATUS_BUFFER_TOO_SMALL = 0xC0000023;
    constexpr ACCESS_MASK DIRECTORY_QUERY = 0x0001;

    NTSTATUS WINAPI NtOpenDirectoryObject(
        _Out_ PHANDLE            DirectoryHandle,
        _In_  ACCESS_MASK        DesiredAccess,
        _In_  POBJECT_ATTRIBUTES ObjectAttributes
    );

    typedef struct _OBJECT_DIRECTORY_INFORMATION {
        UNICODE_STRING Name;
        UNICODE_STRING TypeName;
    } OBJECT_DIRECTORY_INFORMATION, * POBJECT_DIRECTORY_INFORMATION;

    NTSTATUS WINAPI NtQueryDirectoryObject(
        _In_      HANDLE  DirectoryHandle,
        _Out_opt_ PVOID   Buffer,
        _In_      ULONG   Length,
        _In_      BOOLEAN ReturnSingleEntry,
        _In_      BOOLEAN RestartScan,
        _Inout_   PULONG  Context,
        _Out_opt_ PULONG  ReturnLength
    );
}

namespace Send::Type::Internal {
    class Base {
    protected:
        decltype(&::GetAsyncKeyState)* get_key_state_fallback;

        static bool is_modifier(int vKey) {
            int mods[] = { VK_LCONTROL, VK_RCONTROL, VK_LSHIFT, VK_RSHIFT, VK_LMENU, VK_RMENU, VK_LWIN, VK_RWIN };
            for (int mod : mods)
                if (mod == vKey)
                    return true;
            return false;
        }

        POINT screen;
        void mouse_absolute_to_screen(POINT& absolute) const {
            // absolute.x = round(x / screen.x * 65536)
            absolute.x = absolute.x * screen.x / 65536;
            absolute.y = absolute.y * screen.y / 65536;
        }

        void update_screen_resolution() {
            screen.x = GetSystemMetrics(SM_CXSCREEN);  //#TODO: SM_CXVIRTUALSCREEN?
            screen.y = GetSystemMetrics(SM_CYSCREEN);

            // the overhead of WM_DISPLAYCHANGE is a bit high
        }

        // need to call update_screen_resolution first
        static void mouse_screen_to_relative(POINT& screen_point) {
            POINT point;
            GetCursorPos(&point);
            if constexpr (debug)
                DebugOStream() << L"mouse_screen_to_relative: cursor (" << point.x << L", " << point.y << L") to point (" << screen_point.x << L", " << screen_point.y << L")\n";
            screen_point.x -= point.x;
            screen_point.y -= point.y;
        }

    public:
        void create_base(decltype(&::GetAsyncKeyState)* get_key_state_fallback) {
            this->get_key_state_fallback = get_key_state_fallback;
        }

        virtual void destroy() = 0;

        virtual uint32_t send_input(const INPUT inputs[], uint32_t n) {
            uint32_t count = 0;

            for (uint32_t i = 0; i < n; i++) {
                DWORD type = inputs[i].type;

                uint32_t j = i + 1;
                while (j < n && inputs[j].type == type)
                    j++;

                switch (type) {
                case INPUT_KEYBOARD:
                    count += send_keyboard_input(inputs + i, j - i);
                    break;
                case INPUT_MOUSE:
                    count += send_mouse_input(inputs + i, j - i);
                    break;
                }

                i = j;
            }

            return count;
        }

        virtual uint32_t send_mouse_input(const INPUT inputs[], uint32_t n) {
            uint32_t count = 0;
            for (uint32_t i = 0; i < n; i++)
                count += send_mouse_input(inputs[i].mi);
            return count;
        }

        virtual bool send_mouse_input(const MOUSEINPUT& mi) = 0;

        virtual uint32_t send_keyboard_input(const INPUT inputs[], uint32_t n) {
            uint32_t count = 0;
            for (uint32_t i = 0; i < n; i++)
                count += send_keyboard_input(inputs[i].ki);
            return count;
        }
        
        virtual bool send_keyboard_input(const KEYBDINPUT& ki) = 0;
        
        virtual SHORT get_key_state(int vKey) {
            return (*get_key_state_fallback)(vKey);
        }

        virtual void sync_key_states() {}
    };

    struct KeyboardModifiers {
        bool LCtrl : 1;
        bool LShift : 1;
        bool LAlt : 1;
        bool LGui : 1;
        bool RCtrl : 1;
        bool RShift : 1;
        bool RAlt : 1;
        bool RGui : 1;
    };

    class VirtualKeyStates : virtual public Base {
        KeyboardModifiers& modifiers;
        std::mutex& mutex;

    protected:
        VirtualKeyStates(KeyboardModifiers& modifiers, std::mutex& mutex) : modifiers(modifiers), mutex(mutex) {}

        void set_modifier_state(int vKey, bool keydown) {
            switch (vKey) {
#define CODE_GENERATE(vk, member)  \
                case vk:  \
                    modifiers.##member = keydown;  \
                    break;

                CODE_GENERATE(VK_LCONTROL, LCtrl)
                CODE_GENERATE(VK_RCONTROL, RCtrl)
                CODE_GENERATE(VK_LSHIFT, LShift)
                CODE_GENERATE(VK_RSHIFT, RShift)
                CODE_GENERATE(VK_LMENU, LAlt)
                CODE_GENERATE(VK_RMENU, RAlt)
                CODE_GENERATE(VK_LWIN, LGui)
                CODE_GENERATE(VK_RWIN, RGui)
#undef CODE_GENERATE
            }
        }

    public:
        SHORT get_key_state(int vKey) override {
            switch (vKey) {
#define CODE_GENERATE(vk, member)  case vk: return modifiers.##member << 15;

                CODE_GENERATE(VK_LCONTROL, LCtrl)
                CODE_GENERATE(VK_RCONTROL, RCtrl)
                CODE_GENERATE(VK_LSHIFT, LShift)
                CODE_GENERATE(VK_RSHIFT, RShift)
                CODE_GENERATE(VK_LMENU, LAlt)
                CODE_GENERATE(VK_RMENU, RAlt)
                CODE_GENERATE(VK_LWIN, LGui)
                CODE_GENERATE(VK_RWIN, RGui)
#undef CODE_GENERATE
            default:
                return (*get_key_state_fallback)(vKey);
            }
        }

        void sync_key_states() override {
            std::lock_guard lock(mutex);

            //#TODO: GetKeyboardState() ?
            //static bool states[256];  //down := true
#define CODE_GENERATE(vk, member)  modifiers.##member = (*get_key_state_fallback)(vk) & 0x8000;

            CODE_GENERATE(VK_LCONTROL, LCtrl)
            CODE_GENERATE(VK_RCONTROL, RCtrl)
            CODE_GENERATE(VK_LSHIFT, LShift)
            CODE_GENERATE(VK_RSHIFT, RShift)
            CODE_GENERATE(VK_LMENU, LAlt)
            CODE_GENERATE(VK_RMENU, RAlt)
            CODE_GENERATE(VK_LWIN, LGui)
            CODE_GENERATE(VK_RWIN, RGui)
#undef CODE_GENERATE
        }
    };

    inline std::wstring find_device(std::function<bool(std::wstring_view name)> p) {
        std::wstring result{};
        HANDLE dir_handle;

        OBJECT_ATTRIBUTES obj_attr;
        UNICODE_STRING obj_name;  //or RTL_CONSTANT_STRING
        RtlInitUnicodeString(&obj_name, LR"(\GLOBAL??)");
        InitializeObjectAttributes(&obj_attr, &obj_name, 0, NULL, NULL);

        if (NT_SUCCESS(NtOpenDirectoryObject(&dir_handle, DIRECTORY_QUERY, &obj_attr))) {  //or DIRECTORY_TRAVERSE?
            union {
                ib::Byte buf[2048];  //#TODO
                OBJECT_DIRECTORY_INFORMATION info[1];
            };
            ULONG context;

#pragma warning(suppress : 6001)  //Warning C6001: Using uninitialized memory 'context'.
            NTSTATUS status = NtQueryDirectoryObject(dir_handle, buf, sizeof buf, false, true, &context, NULL);
            while (NT_SUCCESS(status)) {  //STATUS_SUCCESS, STATUS_MORE_ENTRIES
                bool found = false;
                for (ULONG i = 0; info[i].Name.Buffer; i++) {
                    std::wstring_view sv{ info[i].Name.Buffer, info[i].Name.Length / sizeof(wchar_t) };
                    if (p(sv)) {
                        result = LR"(\??\)" + std::wstring(sv);
                        found = true;
                        break;
                    }
                }
                if (found || status != STATUS_MORE_ENTRIES)
                    break;
                status = NtQueryDirectoryObject(dir_handle, buf, sizeof buf, false, false, &context, NULL);
            }

            CloseHandle(dir_handle);
        }

        return result;
    }
}
```

`Simulator/include/IbInputSimulator/SendTypes/types.hpp`:

```hpp
#pragma once
#include "base.hpp"
#include "SendInput.hpp"
#include "Logitech.hpp"
#include "Razer.hpp"
#include "DD.hpp"
#include "MouClassInputInjection.hpp"

namespace Send
{
    namespace Type
    {
        using Internal::Base;
        using Internal::SendInput;
        using Internal::Logitech;
        using Internal::Razer;
        using Internal::DD;
        using Internal::MouClassInputInjection;
    }
}
```

`Simulator/include/IbInputSimulator/SendTypes/usb.hpp`:

```hpp
#pragma once
#include "../common.hpp"

namespace Send::Type::Internal {
    namespace Usb
    {
        constexpr uint8_t keyboard_vk_to_usage(uint8_t vkCode) {
            //#TODO: fully test

#pragma region
            switch (vkCode) {
            case 0x00: return 0x0000;
            case 0x01: return 0x0000;  //VK_LBUTTON
            case 0x02: return 0x0000;  //VK_RBUTTON
            case 0x03: return 0x9B;  //VK_CANCEL
            case 0x04: return 0x0000;  //VK_MBUTTON
            case 0x05: return 0x0000;  //VK_XBUTTON1
            case 0x06: return 0x0000;  //VK_XBUTTON2
            case 0x07: return 0x00;  //reserved
            case 0x08: return 0x2A;  //VK_BACK
            case 0x09: return 0x2B;  //VK_TAB
            case 0x0A: return 0x00;  //reserved
            case 0x0B: return 0x00;  //reserved
            case 0x0C: return 0x0000;  //VK_CLEAR
            case 0x0D: return 0x28;  //VK_RETURN
            case 0x0E: return 0x00;  //reserved
            case 0x0F: return 0x00;  //reserved
            case 0x10: return 0x0000;  //VK_SHIFT
            case 0x11: return 0x0000;  //VK_CONTROL
            case 0x12: return 0x0000;  //VK_MENU
            case 0x13: return 0x48;  //VK_PAUSE
            case 0x14: return 0x39;  //VK_CAPITAL
            case 0x15: return 0x0000;  //VK_KANA|VK_HANGEUL|VK_HANGUL
            case 0x16: return 0x00;  //unassigned
            case 0x17: return 0x0000;  //VK_JUNJA
            case 0x18: return 0x0000;  //VK_FINAL
            case 0x19: return 0x0000;  //VK_HANJA|VK_KANJI
            case 0x1A: return 0x00;  //unassigned
            case 0x1B: return 0x29;  //VK_ESCAPE
            case 0x1C: return 0x0000;  //VK_CONVERT
            case 0x1D: return 0x0000;  //VK_NONCONVERT
            case 0x1E: return 0x0000;  //VK_ACCEPT
            case 0x1F: return 0x0000;  //VK_MODECHANGE
            case 0x20: return 0x2C;  //VK_SPACE
            case 0x21: return 0x4B;  //VK_PRIOR
            case 0x22: return 0x4E;  //VK_NEXT
            case 0x23: return 0x4D;  //VK_END
            case 0x24: return 0x4A;  //VK_HOME
            case 0x25: return 0x50;  //VK_LEFT
            case 0x26: return 0x52;  //VK_UP
            case 0x27: return 0x4F;  //VK_RIGHT
            case 0x28: return 0x51;  //VK_DOWN
            case 0x29: return 0x0000;  //VK_SELECT
            case 0x2A: return 0x0000;  //VK_PRINT
            case 0x2B: return 0x0000;  //VK_EXECUTE
            case 0x2C: return 0x46;  //VK_SNAPSHOT
            case 0x2D: return 0x49;  //VK_INSERT
            case 0x2E: return 0x4C;  //VK_DELETE
            case 0x2F: return 0x0000;  //VK_HELP
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            case 0x3F:
            case 0x40: return 0x00;  //unassigned
            case 0x5B: return 0xE3;  //VK_LWIN
            case 0x5C: return 0xE7;  //VK_RWIN
            case 0x5D: return 0x65;  //VK_APPS
            case 0x5E: return 0x00;  //reserved
            case 0x5F: return 0x0000;  //VK_SLEEP

            case 0x6A: return 0x55;  //VK_MULTIPLY
            case 0x6B: return 0x57;  //VK_ADD
            case 0x6C: return 0x0000;  //VK_SEPARATOR
            case 0x6D: return 0x56;  //VK_SUBTRACT
            case 0x6E: return 0x63;  //VK_DECIMAL
            case 0x6F: return 0x54;  //VK_DIVIDE

            case 0x88: return 0x0000;  //VK_NAVIGATION_VIEW
            case 0x89: return 0x0000;  //VK_NAVIGATION_MENU
            case 0x8A: return 0x0000;  //VK_NAVIGATION_UP
            case 0x8B: return 0x0000;  //VK_NAVIGATION_DOWN
            case 0x8C: return 0x0000;  //VK_NAVIGATION_LEFT
            case 0x8D: return 0x0000;  //VK_NAVIGATION_RIGHT
            case 0x8E: return 0x0000;  //VK_NAVIGATION_ACCEPT
            case 0x8F: return 0x0000;  //VK_NAVIGATION_CANCEL
            case 0x90: return 0x53;  //VK_NUMLOCK
            case 0x91: return 0x47;  //VK_SCROLL
            case 0x92: return 0x0000;  //VK_OEM_NEC_EQUAL|VK_OEM_FJ_JISHO
            case 0x93: return 0x0000;  //VK_OEM_FJ_MASSHOU
            case 0x94: return 0x0000;  //VK_OEM_FJ_TOUROKU
            case 0x95: return 0x0000;  //VK_OEM_FJ_LOYA
            case 0x96: return 0x0000;  //VK_OEM_FJ_ROYA
            case 0x97:
            case 0x98:
            case 0x99:
            case 0x9A:
            case 0x9B:
            case 0x9C:
            case 0x9D:
            case 0x9E:
            case 0x9F: return 0x00;  //unassigned
            case 0xA0: return 0xE1;  //VK_LSHIFT
            case 0xA1: return 0xE5;  //VK_RSHIFT
            case 0xA2: return 0xE0;  //VK_LCONTROL
            case 0xA3: return 0xE4;  //VK_RCONTROL
            case 0xA4: return 0xE2;  //VK_LMENU
            case 0xA5: return 0xE6;  //VK_RMENU
            case 0xA6: return 0x0000;  //VK_BROWSER_BACK
            case 0xA7: return 0x0000;  //VK_BROWSER_FORWARD
            case 0xA8: return 0x0000;  //VK_BROWSER_REFRESH
            case 0xA9: return 0x0000;  //VK_BROWSER_STOP
            case 0xAA: return 0x0000;  //VK_BROWSER_SEARCH
            case 0xAB: return 0x0000;  //VK_BROWSER_FAVORITES
            case 0xAC: return 0x0000;  //VK_BROWSER_HOME
            case 0xAD: return 0x0000;  //VK_VOLUME_MUTE
            case 0xAE: return 0x0000;  //VK_VOLUME_DOWN
            case 0xAF: return 0x0000;  //VK_VOLUME_UP
            case 0xB0: return 0x0000;  //VK_MEDIA_NEXT_TRACK
            case 0xB1: return 0x0000;  //VK_MEDIA_PREV_TRACK
            case 0xB2: return 0x0000;  //VK_MEDIA_STOP
            case 0xB3: return 0x0000;  //VK_MEDIA_PLAY_PAUSE
            case 0xB4: return 0x0000;  //VK_LAUNCH_MAIL
            case 0xB5: return 0x0000;  //VK_LAUNCH_MEDIA_SELECT
            case 0xB6: return 0x0000;  //VK_LAUNCH_APP1
            case 0xB7: return 0x0000;  //VK_LAUNCH_APP2
            case 0xB8:
            case 0xB9: return 0x00;  //reserved
            case 0xBA: return 0x33;  //VK_OEM_1   // ';:' for US
            case 0xBB: return 0x2E;  //VK_OEM_PLUS   // '+' any country
            case 0xBC: return 0x36;  //VK_OEM_COMMA   // ',' any country
            case 0xBD: return 0x2D;  //VK_OEM_MINUS   // '-' any country
            case 0xBE: return 0x37;  //VK_OEM_PERIOD   // '.' any country
            case 0xBF: return 0x38;  //VK_OEM_2   // '/?' for US
            case 0xC0: return 0x35;  //VK_OEM_3   // '`~' for US
            case 0xC1: return 0x00;  //reserved
            case 0xC2: return 0x00;  //reserved
            case 0xC3: return 0x00;  //VK_GAMEPAD_A // reserved
            case 0xC4: return 0x00;  //VK_GAMEPAD_B // reserved
            case 0xC5: return 0x00;  //VK_GAMEPAD_X // reserved
            case 0xC6: return 0x00;  //VK_GAMEPAD_Y // reserved
            case 0xC7: return 0x00;  //VK_GAMEPAD_RIGHT_SHOULDER // reserved
            case 0xC8: return 0x00;  //VK_GAMEPAD_LEFT_SHOULDER // reserved
            case 0xC9: return 0x00;  //VK_GAMEPAD_LEFT_TRIGGER // reserved
            case 0xCA: return 0x00;  //VK_GAMEPAD_RIGHT_TRIGGER // reserved
            case 0xCB: return 0x00;  //VK_GAMEPAD_DPAD_UP // reserved
            case 0xCC: return 0x00;  //VK_GAMEPAD_DPAD_DOWN // reserved
            case 0xCD: return 0x00;  //VK_GAMEPAD_DPAD_LEFT // reserved
            case 0xCE: return 0x00;  //VK_GAMEPAD_DPAD_RIGHT // reserved
            case 0xCF: return 0x00;  //VK_GAMEPAD_MENU // reserved
            case 0xD0: return 0x00;  //VK_GAMEPAD_VIEW // reserved
            case 0xD1: return 0x00;  //VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON // reserved
            case 0xD2: return 0x00;  //VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON // reserved
            case 0xD3: return 0x00;  //VK_GAMEPAD_LEFT_THUMBSTICK_UP // reserved
            case 0xD4: return 0x00;  //VK_GAMEPAD_LEFT_THUMBSTICK_DOWN // reserved
            case 0xD5: return 0x00;  //VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT // reserved
            case 0xD6: return 0x00;  //VK_GAMEPAD_LEFT_THUMBSTICK_LEFT // reserved
            case 0xD7: return 0x00;  //VK_GAMEPAD_RIGHT_THUMBSTICK_UP // reserved
            case 0xD8: return 0x00;  //VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN // reserved
            case 0xD9: return 0x00;  //VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT // reserved
            case 0xDA: return 0x00;  //VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT // reserved
            case 0xDB: return 0x2F;  //VK_OEM_4  //  '[{' for US
            case 0xDC: return 0x31;  //VK_OEM_5  //  '\|' for US
            case 0xDD: return 0x30;  //VK_OEM_6  //  ']}' for US
            case 0xDE: return 0x34;  //VK_OEM_7  //  ''"' for US
            case 0xDF: return 0x0000;  //VK_OEM_8
            case 0xE0: return 0x0000;  //reserved
            case 0xE1: return 0x0000;  //VK_OEM_AX  //  'AX' key on Japanese AX kbd
            case 0xE2: return 0x64;  //VK_OEM_102  //  "<>" or "\|" on RT 102-key kbd.
            case 0xE3: return 0x0000;  //VK_ICO_HELP  //  Help key on ICO
            case 0xE4: return 0x0000;  //VK_ICO_00  //  00 key on ICO
            case 0xE5: return 0x0000;  //VK_PROCESSKEY
            case 0xE6: return 0x0000;  //VK_ICO_CLEAR
            case 0xE7: return 0x0000;  //VK_PACKET
            case 0xE8: return 0x0000;  //unassigned
            case 0xE9: return 0x0000;  //VK_OEM_RESET
            case 0xEA: return 0x0000;  //VK_OEM_JUMP
            case 0xEB: return 0x0000;  //VK_OEM_PA1
            case 0xEC: return 0x0000;  //VK_OEM_PA2
            case 0xED: return 0x0000;  //VK_OEM_PA3
            case 0xEE: return 0x0000;  //VK_OEM_WSCTRL
            case 0xEF: return 0x0000;  //VK_OEM_CUSEL
            case 0xF0: return 0x0000;  //VK_OEM_ATTN
            case 0xF1: return 0x0000;  //VK_OEM_FINISH
            case 0xF2: return 0x0000;  //VK_OEM_COPY
            case 0xF3: return 0x0000;  //VK_OEM_AUTO
            case 0xF4: return 0x0000;  //VK_OEM_ENLW
            case 0xF5: return 0x0000;  //VK_OEM_BACKTAB
            case 0xF6: return 0x0000;  //VK_ATTN
            case 0xF7: return 0x0000;  //VK_CRSEL
            case 0xF8: return 0x0000;  //VK_EXSEL
            case 0xF9: return 0x0000;  //VK_EREOF
            case 0xFA: return 0x0000;  //VK_PLAY
            case 0xFB: return 0x0000;  //VK_ZOOM
            case 0xFC: return 0x0000;  //VK_NONAME
            case 0xFD: return 0x0000;  //VK_PA1
            case 0xFE: return 0x0000;  //VK_OEM_CLEAR
            case 0xFF: return 0x0000;
            default:
                if ('A' <= vkCode && vkCode <= 'Z')
                    return 0x04 + vkCode - 'A';
                else if ('0' <= vkCode && vkCode <= '9')
                    return vkCode == '0' ? 0x27 : 0x1E + vkCode - '1';
                else if (VK_NUMPAD0 <= vkCode && vkCode <= VK_NUMPAD9)
                    return vkCode == VK_NUMPAD0 ? 0x62 : 0x59 + vkCode - VK_NUMPAD1;
                else if (VK_F1 <= vkCode && vkCode <= VK_F24)
                    return vkCode <= VK_F12
                    ? 0x3A + vkCode - VK_F1
                    : 0x68 + vkCode - VK_F13;
            }
#pragma endregion
        }
    }
}
```

`Simulator/include/IbInputSimulator/common.hpp`:

```hpp
#pragma once
#include "InputSimulator.hpp"
using namespace Send;

#include <detours/detours.h>
#include <IbWinCpp/WinCpp.hpp>
using ib::Byte;

constexpr int debug = ib::debug_runtime;

ib::DebugOStream<> DebugOStream() {
    return { L"IbInputSimulator: " };
}

template<typename T>
LONG IbDetourAttach(_Inout_ T* ppPointer, _In_ T pDetour) {
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach((void**)ppPointer, pDetour);
    return DetourTransactionCommit();
}

template<typename T>
LONG IbDetourDetach(_Inout_ T* ppPointer, _In_ T pDetour) {
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourDetach((void**)ppPointer, pDetour);
    return DetourTransactionCommit();
}
```

`Simulator/source/API 2.cpp`:

```cpp
#include <bit>
#include <IbInputSimulator/InputSimulator.hpp>
using namespace Send;


DLLAPI VOID WINAPI IbSend_mouse_event(
    _In_ DWORD dwFlags,
    _In_ DWORD dx,
    _In_ DWORD dy,
    _In_ DWORD dwData,
    _In_ ULONG_PTR dwExtraInfo
) {
    INPUT input{
        .type = INPUT_MOUSE,
        .mi {
            .dx = std::bit_cast<LONG>(dx),
            .dy = std::bit_cast<LONG>(dy),
            .mouseData = dwData,
            .dwFlags = dwFlags,
            .time = 0,
            .dwExtraInfo = dwExtraInfo
        }
    };
    IbSendInput(1, &input, sizeof INPUT);
}

DLLAPI VOID WINAPI IbSend_keybd_event(
    _In_ BYTE bVk,
    _In_ BYTE bScan,
    _In_ DWORD dwFlags,
    _In_ ULONG_PTR dwExtraInfo
) {
    INPUT input{
        .type = INPUT_KEYBOARD,
        .ki {
            .wVk = bVk,
            .wScan = bScan,
            .dwFlags = dwFlags,
            .time = 0,
            .dwExtraInfo = dwExtraInfo
        }
    };
    IbSendInput(1, &input, sizeof INPUT);
}
```

`Simulator/source/API 3.cpp`:

```cpp
#include <bit>
#include <cassert>
#include <IbInputSimulator/InputSimulator.hpp>
using namespace Send;


DLLAPI bool __stdcall IbSendMouseMove(uint32_t x, uint32_t y, Send::MoveMode mode) {
    INPUT input {
        .type = INPUT_MOUSE,
        .mi {
            .dx = std::bit_cast<LONG>(x),
            .dy = std::bit_cast<LONG>(y),
            .mouseData = 0,
            .dwFlags = [mode]() -> DWORD {
                switch (mode) {
                    case MoveMode::Absolute: return MOUSEEVENTF_ABSOLUTE;
                    case MoveMode::Relative: return MOUSEEVENTF_MOVE;
                    default: assert(false);
                }
            }(),
            .time = 0,
            .dwExtraInfo = 0
        }
    };
    return IbSendInput(1, &input, sizeof INPUT);
}

DLLAPI bool __stdcall IbSendMouseClick(Send::MouseButton button) {
    INPUT inputs[2];
    inputs[0] = inputs[1] = {
        .type = INPUT_MOUSE,
        .mi {
            .dx = 0,
            .dy = 0,
            .mouseData = 0,
            .time = 0,
            .dwExtraInfo = 0
        }
    };

    switch (button) {
        case MouseButton::Left:
            inputs[0].mi.dwFlags = MOUSEEVENTF_LEFTDOWN;
            inputs[1].mi.dwFlags = MOUSEEVENTF_LEFTUP;
            return IbSendInput(2, inputs, sizeof INPUT) == 2;
        case MouseButton::Right:
            inputs[0].mi.dwFlags = MOUSEEVENTF_RIGHTDOWN;
            inputs[1].mi.dwFlags = MOUSEEVENTF_RIGHTUP;
            return IbSendInput(2, inputs, sizeof INPUT) == 2;
        case MouseButton::Middle:
            inputs[0].mi.dwFlags = MOUSEEVENTF_MIDDLEDOWN;
            inputs[1].mi.dwFlags = MOUSEEVENTF_MIDDLEUP;
            return IbSendInput(2, inputs, sizeof INPUT) == 2;
        case MouseButton::XButton1:
            inputs[0].mi.dwFlags = MOUSEEVENTF_XDOWN;
            inputs[1].mi.dwFlags = MOUSEEVENTF_XUP;
            inputs[0].mi.mouseData = inputs[1].mi.mouseData = XBUTTON1;
            return IbSendInput(2, inputs, sizeof INPUT) == 2;
        case MouseButton::XButton2:
            inputs[0].mi.dwFlags = MOUSEEVENTF_XDOWN;
            inputs[1].mi.dwFlags = MOUSEEVENTF_XUP;
            inputs[0].mi.mouseData = inputs[1].mi.mouseData = XBUTTON2;
            return IbSendInput(2, inputs, sizeof INPUT) == 2;
        default:
            inputs[0].mi.dwFlags = static_cast<DWORD>(button);
            return IbSendInput(1, inputs, sizeof INPUT);
    }
}

DLLAPI bool __stdcall IbSendMouseWheel(int32_t movement) {
    INPUT input{
        .type = INPUT_MOUSE,
        .mi {
            .dx = 0,
            .dy = 0,
            .mouseData = std::bit_cast<DWORD>(movement),
            .dwFlags = MOUSEEVENTF_WHEEL,
            .time = 0,
            .dwExtraInfo = 0
        }
    };
    return IbSendInput(1, &input, sizeof INPUT);
}

DLLAPI bool __stdcall IbSendKeybdDown(uint16_t vk) {
    INPUT input{
        .type = INPUT_KEYBOARD,
        .ki {
            .wVk = vk,
            .wScan = 0,
            .dwFlags = 0,
            .time = 0,
            .dwExtraInfo = 0
        }
    };
    return IbSendInput(1, &input, sizeof INPUT);
}

DLLAPI bool __stdcall IbSendKeybdUp(uint16_t vk) {
    INPUT input{
        .type = INPUT_KEYBOARD,
        .ki {
            .wVk = vk,
            .wScan = 0,
            .dwFlags = KEYEVENTF_KEYUP,
            .time = 0,
            .dwExtraInfo = 0
        }
    };
    return IbSendInput(1, &input, sizeof INPUT);
}

DLLAPI bool __stdcall IbSendKeybdDownUp(uint16_t vk, Send::KeyboardModifiers modifiers) {
    constexpr INPUT blank_input = INPUT{ .type = INPUT_KEYBOARD, .ki { 0, 0, 0, 0, 0 }};

    INPUT inputs[18];  //720 bytes
    uint32_t i = 0;

#define CODE_GENERATE(vk, member)  \
    if (modifiers.member) {  \
        inputs[i] = blank_input;  \
        inputs[i].ki.wVk = vk;  \
        i++;  \
    }

    CODE_GENERATE(VK_LCONTROL, LCtrl)
    CODE_GENERATE(VK_RCONTROL, RCtrl)
    CODE_GENERATE(VK_LSHIFT, LShift)
    CODE_GENERATE(VK_RSHIFT, RShift)
    CODE_GENERATE(VK_LMENU, LAlt)
    CODE_GENERATE(VK_RMENU, RAlt)
    CODE_GENERATE(VK_LWIN, LWin)
    CODE_GENERATE(VK_RWIN, RWin)
#undef CODE_GENERATE
    inputs[i] = blank_input;
    inputs[i].ki.wVk = vk;
    i++;

    inputs[i] = inputs[i-1];
    inputs[i].ki.dwFlags = KEYEVENTF_KEYUP;
    i++;
#define CODE_GENERATE(vk, member)  \
    if (modifiers.member) {  \
        inputs[i] = blank_input;  \
        inputs[i].ki.wVk = vk;  \
        inputs[i].ki.dwFlags = KEYEVENTF_KEYUP;  \
        i++;  \
    }

    CODE_GENERATE(VK_RWIN, RWin)
    CODE_GENERATE(VK_LWIN, LWin)
    CODE_GENERATE(VK_RMENU, RAlt)
    CODE_GENERATE(VK_LMENU, LAlt)
    CODE_GENERATE(VK_RSHIFT, RShift)
    CODE_GENERATE(VK_LSHIFT, LShift)
    CODE_GENERATE(VK_RCONTROL, RCtrl)
    CODE_GENERATE(VK_LCONTROL, LCtrl)
#undef CODE_GENERATE

    return IbSendInput(i, inputs, sizeof INPUT) == i;
}
```

`Simulator/source/dllmain.cpp`:

```cpp
#include <IbInputSimulator/InputSimulator.hpp>
using namespace Send;

#include <IbInputSimulator/SendTypes/types.hpp>

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        IbSendDestroy();
        break;
    }
    return TRUE;
}

namespace main {
    static std::unique_ptr<Type::Base> send;
}

class SendInputHook {
public:
    static inline decltype(SendInput)* SendInput_real = SendInput;
    static UINT WINAPI SendInput_detour(UINT cInputs, LPINPUT pInputs, int cbSize) {
        if (!hook)
            return SendInput_real(cInputs, pInputs, cbSize);

        return main::send->send_input(pInputs, cInputs);
    }

    //#TODO: only needed when two or more AHK processes exist?
    static inline decltype(GetAsyncKeyState)* GetAsyncKeyState_real = GetAsyncKeyState;
    static SHORT WINAPI GetAsyncKeyState_detour(int vKey) {
        if (!hook)
            return GetAsyncKeyState_real(vKey);

        if constexpr (debug)
            DebugOStream() << L"GetAsyncKeyState: " << vKey << ", " << main::send->get_key_state(vKey) << std::endl;
        return main::send->get_key_state(vKey);
    }

public:
    static inline bool hook;

    SendInputHook() {
        hook = false;
        IbDetourAttach(&GetAsyncKeyState_real, GetAsyncKeyState_detour);
        IbDetourAttach(&SendInput_real, SendInput_detour);
    }

    ~SendInputHook() {
        IbDetourDetach(&SendInput_real, SendInput_detour);
        IbDetourDetach(&GetAsyncKeyState_real, GetAsyncKeyState_detour);
    }
};
ib::HolderB<SendInputHook> sendinput_hook;

DLLAPI void __stdcall IbSendInputHook(HookCode code) {
    switch (code) {
    case HookCode::InitOnly:
        sendinput_hook.create();
        break;
    case HookCode::Destroy:
        sendinput_hook.destroy();
        break;
    case HookCode::On:
        if (!sendinput_hook.created())
            sendinput_hook.create();
        sendinput_hook->hook = true;
        break;
    case HookCode::Off:
        sendinput_hook->hook = false;
        break;
    }
}


DLLAPI Send::Error __stdcall IbSendInit(SendType type, InitFlags flags, void* argument) {
    if (type == SendType::AnyDriver) {
        Error error = IbSendInit(SendType::Logitech, flags, nullptr);
        if (error == Error::Success) return Error::Success;

        error = IbSendInit(SendType::Razer, flags, nullptr);
        if (error == Error::Success) return Error::Success;

        error = IbSendInit(SendType::DD, flags, nullptr);
        if (error == Error::Success) return Error::Success;

        error = IbSendInit(SendType::MouClassInputInjection, flags, nullptr);
        if (error == Error::Success) return Error::Success;

        return Error::DeviceNotFound;
    }
    else {
        switch (type) {
        case SendType::SendInput:
            {
                auto type = std::make_unique<Type::SendInput>();
                type->create_base(&SendInputHook::GetAsyncKeyState_real);
                Error error = type->create(&SendInputHook::SendInput_real);
                if (error != Error::Success)
                    return error;
                main::send = std::move(type);
            }
            break;
        case SendType::Logitech:
            {
                auto type = std::make_unique<Type::Logitech>();
                type->create_base(&SendInputHook::GetAsyncKeyState_real);
                Error error = type->create();
                if (error != Error::Success)
                    return error;
                main::send = std::move(type);
            }
            break;
        case SendType::Razer:
            {
                auto type = std::make_unique<Type::Razer>();
                type->create_base(&SendInputHook::GetAsyncKeyState_real);
                Error error = type->create();
                if (error != Error::Success)
                    return error;
                main::send = std::move(type);
            }
            break;
        case SendType::DD:
            {
                auto type = std::make_unique<Type::DD>();
                type->create_base(&SendInputHook::GetAsyncKeyState_real);
                Error error = type->create(ib::Addr(argument));
                if (error != Error::Success)
                    return error;
                main::send = std::move(type);
            }
            break;
        case SendType::MouClassInputInjection:
            {
                auto type = std::make_unique<Type::MouClassInputInjection>();
                type->create_base(&SendInputHook::GetAsyncKeyState_real);
                Error error = type->create((ULONG_PTR)argument);
                if (error != Error::Success)
                    return error;
                main::send = std::move(type);
            }
            break;
        default:
            return Error::InvalidArgument;
        }
        return Error::Success;
    }
}

DLLAPI void __stdcall IbSendDestroy() {
    IbSendInputHook(HookCode::Destroy);

    if (!main::send)
        return;
    main::send->destroy();
    main::send.release();
}

DLLAPI void __stdcall IbSendSyncKeyStates() {
    main::send->sync_key_states();
}

DLLAPI UINT WINAPI IbSendInput(
    _In_ UINT cInputs,
    _In_reads_(cInputs) LPINPUT pInputs,
    _In_ int cbSize
) {
    return main::send->send_input(pInputs, cInputs);
}
```

`Simulator/test/test.cpp`:

```cpp
#include <IbInputSimulator/InputSimulator.hpp>
using namespace Send;

#define BOOST_TEST_MODULE Test
#include <boost/test/unit_test.hpp>
#include <fmt/core.h>

#include <thread>
#include <mutex>
#include <future>
#include <queue>
#include <IbWinCpp/WinCpp.hpp>
#include "Vk.hpp"


class Measure {
	LARGE_INTEGER t;
	double frequency_ns;
public:
	Measure() {
		LARGE_INTEGER frequency;
		QueryPerformanceFrequency(&frequency);
		frequency_ns = frequency.QuadPart / 1'000'000'000.0;
	}

	void begin() {
		QueryPerformanceCounter(&t);
	}

	uint64_t end() {
		LARGE_INTEGER t_;
		QueryPerformanceCounter(&t_);
		return uint64_t((t_.QuadPart - t.QuadPart) / frequency_ns);
	}
};

template <SendType TypeV>
class InitTest {
public:
	InitTest() {
		Send::Error error = IbSendInit(TypeV, 0, nullptr);
		BOOST_REQUIRE(error == Send::Error::Success);
	}

	~InitTest() {
		IbSendDestroy();
	}
};

template <SendType TypeV>
class KeyboardTest : public InitTest<TypeV>
{
	static inline HHOOK hook;
	static inline bool capture;
	static inline std::queue<DWORD> input_keys;
	static inline std::mutex mutex;

	std::thread t;

	static LRESULT CALLBACK LowLevelKeyboardProc(
		_In_ int    nCode,
		_In_ WPARAM wParam,
		_In_ LPARAM lParam
	) {
		if (capture && nCode == HC_ACTION) {
			KBDLLHOOKSTRUCT* p = ib::Addr(lParam);
			{
				std::lock_guard lock(mutex);
				input_keys.push(p->vkCode);
			}
		}
		return CallNextHookEx(hook, nCode, wParam, lParam);
	}
public:
	KeyboardTest() {
		capture = false;
		std::promise<HHOOK> pro;
		std::future<HHOOK> fut = pro.get_future();
		t = std::thread([](std::promise<HHOOK>&& pro) {
			pro.set_value(SetWindowsHookExW(WH_KEYBOARD_LL, LowLevelKeyboardProc, GetModuleHandle(0), 0));

			MSG messages;
			while (GetMessageW(&messages, NULL, 0, 0))
			{
				TranslateMessage(&messages);
				DispatchMessageW(&messages);
			}
		}, std::move(pro));
		hook = fut.get();
		BOOST_REQUIRE(hook != NULL);
	}

	~KeyboardTest() {
		std::thread::id id = t.get_id();
		PostThreadMessageW(*(DWORD*)(&id), WM_QUIT, 0, 0);
		UnhookWindowsHookEx(hook);
		input_keys = {};

		t.join();
	}

	void TestKeyboardLatency() {
		Measure measure;

		INPUT inputs[2];

		inputs[0].type = INPUT_KEYBOARD;
		inputs[0].ki = {};
		inputs[0].ki.wVk = VK_F12;

		inputs[1] = inputs[0];
		inputs[1].ki.dwFlags = KEYEVENTF_KEYUP;

		capture = true;
		measure.begin();
		IbSendInput(2, inputs, sizeof INPUT);

		uint64_t t1 = measure.end();
		
		measure.begin();
		{
			while (input_keys.size() < 2)
				_mm_pause();
			capture = false;
		}
		uint64_t t2 = measure.end();

		{
			std::lock_guard lock(mutex);
			BOOST_CHECK(input_keys.back() == VK_F12);
			input_keys.pop();
		    BOOST_CHECK(input_keys.back() == VK_F12);
			input_keys.pop();
		}

		BOOST_TEST_MESSAGE("TestKeyboardLatency:");
		BOOST_TEST_MESSAGE(fmt::format("    Duration: {}ns", t1));
		//SendInput: 1000~3000us (1~3ms)
		//Logitech: 25~45us
		//Razer: 500~1000us
		//DD: 70~110us
		BOOST_TEST_MESSAGE(fmt::format("    Latency: {}ns", t2));
		//SendInput: 100ns (0)
		//Logitech: 0.8~4ms
		//Razer: 0.8~10ms
		//DD: 0.6~1ms
	}
};

template <SendType TypeV>
class MouseTest : public InitTest<TypeV> {
public:
	void TestMouseMove() {
		Measure measure;
		
		INPUT input;
		input.type = INPUT_MOUSE;
		input.mi = {};
		input.mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_MOVE_NOCOALESCE;

		measure.begin();
		for (size_t i = 0; i < 10000 / 200; i++) {
			input.mi.dx = input.mi.dy = 1;
			for (size_t i = 0; i < 100; i++)
				IbSendInput(1, &input, sizeof INPUT);

			input.mi.dx = input.mi.dy = -1;
			for (size_t i = 0; i < 100; i++)
				IbSendInput(1, &input, sizeof INPUT);
		}
		uint64_t t = measure.end();

		Sleep(5000);  //avoid bothering other tests (Razer will queue all movements)

		BOOST_TEST_MESSAGE("TestMouseMove:");
		BOOST_TEST_MESSAGE(fmt::format("    Duration: {}ns", t / 10000));
		//SendInput: 200~800us
		//Logitech: 3~10us
		//Razer: 3~5us
		//DD: 500~1000us
	}

	void TestMouseMoveLatency() {
		Measure measure;

		POINT p1, p2, d;
		GetCursorPos(&p1);
		
		INPUT input;
		input.type = INPUT_MOUSE;
		input.mi = {};
		input.mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_MOVE_NOCOALESCE;
		input.mi.dx = input.mi.dy = 100;
		IbSendInput(1, &input, sizeof INPUT);

		measure.begin();
		do {
			GetCursorPos(&p2);
			d = { p2.x - p1.x, p2.y - p1.y };
		} while (!(d.x >= 50 && d.y >= 50));
		uint64_t latency = measure.end();

		BOOST_TEST_MESSAGE("TestMouseMoveLatency:");
		BOOST_TEST_MESSAGE(fmt::format("    Latency: {}ns", latency));
		//SendInput: 0.003~0.2ms (3~200us)
		//Logitech: 0.9~4ms
		//Razer: 0.7~4ms
		//DD: 1.1ms~1.3ms
	}

	void TestMouseAbsoluteMove() {
		POINT screen{ GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN) };

		INPUT input;
		input.type = INPUT_MOUSE;
		input.mi = {};
		input.mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_MOVE_NOCOALESCE | MOUSEEVENTF_ABSOLUTE;
		input.mi.dx = 65536 * 100 / screen.x;
		input.mi.dy = 65536 * 100 / screen.y;
		IbSendInput(1, &input, sizeof INPUT);

		POINT p1, p2;
		GetCursorPos(&p1);
		Sleep(10);
		GetCursorPos(&p2);
		BOOST_CHECK((abs(p2.x - 100) <= 10 && abs(p2.y - 100) <= 100));

		BOOST_TEST_MESSAGE("TestMouseAbsoluteMove:");
		BOOST_TEST_MESSAGE(fmt::format("    0ms: ({}, {})", p1.x, p1.y));
		BOOST_TEST_MESSAGE(fmt::format("    10ms: ({}, {})", p2.x, p2.y));
	}

	void TestMouseRelativeMove() {
		auto test = [](LONG movement) {
			POINT p1, p2, d1, d2;
			GetCursorPos(&p1);

			INPUT input;
			input.type = INPUT_MOUSE;
			input.mi = {};
			input.mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_MOVE_NOCOALESCE;
			input.mi.dx = input.mi.dy = movement;
			IbSendInput(1, &input, sizeof INPUT);

			GetCursorPos(&p2);
			d1 = { p2.x - p1.x, p2.y - p1.y };

			Sleep(10);

			GetCursorPos(&p2);
			d2 = { p2.x - p1.x, p2.y - p1.y };
			BOOST_CHECK((abs(d2.x - movement) <= 10 && abs(d2.y - movement) <= 10));

			BOOST_TEST_MESSAGE("TestMouseRelativeMove(" << movement << "):");
			BOOST_TEST_MESSAGE(fmt::format("    0ms: ({}, {})", d1.x, d1.y));
			BOOST_TEST_MESSAGE(fmt::format("    10ms: ({}, {})", d2.x, d2.y));
		};
		test(100);
		test(-100);
	}
};

#define CODE_GENERATE_KEYBOARDTEST  \
		using base = BOOST_AUTO_TEST_CASE_FIXTURE;  \
		BOOST_AUTO_TEST_CASE(TestKeyboardLatency) {  \
		    base::TestKeyboardLatency();  \
		}

#define CODE_GENERATE_MOUSETEST  \
	    using base = BOOST_AUTO_TEST_CASE_FIXTURE;  \
		BOOST_AUTO_TEST_CASE(TestMouseMove) {  \
		    base::TestMouseMove();  \
		}  \
		BOOST_AUTO_TEST_CASE(TestMouseMoveLatency) {  \
		    base::TestMouseMoveLatency();  \
		}  \
		BOOST_AUTO_TEST_CASE(TestMouseAbsoluteMove) {  \
		    base::TestMouseAbsoluteMove();  \
		}  \
		BOOST_AUTO_TEST_CASE(TestMouseRelativeMove) {  \
		    base::TestMouseRelativeMove();  \
		}

#define CODE_GENERATE_TEST_NAME(name, type)  \
BOOST_AUTO_TEST_SUITE(name)  \
    BOOST_FIXTURE_TEST_SUITE(Keyboard, KeyboardTest<SendType::type>)  \
        CODE_GENERATE_KEYBOARDTEST  \
    BOOST_AUTO_TEST_SUITE_END()  \
      \
	BOOST_FIXTURE_TEST_SUITE(Mouse, MouseTest<SendType::type>)  \
		CODE_GENERATE_MOUSETEST  \
	BOOST_AUTO_TEST_SUITE_END()  \
BOOST_AUTO_TEST_SUITE_END()
#define CODE_GENERATE_TEST(type) CODE_GENERATE_TEST_NAME(type, type)

CODE_GENERATE_TEST_NAME(SendInput_, SendInput)
CODE_GENERATE_TEST(AnyDriver)
CODE_GENERATE_TEST(Logitech)
CODE_GENERATE_TEST(Razer)

BOOST_AUTO_TEST_SUITE(DD)
    BOOST_FIXTURE_TEST_SUITE(Keyboard, KeyboardTest<SendType::DD>)
        BOOST_AUTO_TEST_CASE(TestDDCode) {
	        HMODULE dd = GetModuleHandleW(L"DD94687.64.dll");
	        if(!dd) dd = GetModuleHandleW(L"DD64.dll");
			if (!dd) dd = GetModuleHandleW(L"DDHID64.dll");
			BOOST_CHECK(dd);
			int (*DD_todc)(int vk) = ib::Addr(GetProcAddress(dd, "DD_todc"));
			BOOST_CHECK(DD_todc);

			std::stringstream ss;
			for (WORD vk = 0; vk < 0x100; vk++)
				ss << vk << " " << vk_to_str(vk) << ": " << DD_todc(vk) << "\n";
			BOOST_TEST_MESSAGE(ss.str());
        }

        CODE_GENERATE_KEYBOARDTEST
    BOOST_AUTO_TEST_SUITE_END()
    
	BOOST_FIXTURE_TEST_SUITE(Mouse, MouseTest<SendType::DD>)
		CODE_GENERATE_MOUSETEST
	BOOST_AUTO_TEST_SUITE_END()
BOOST_AUTO_TEST_SUITE_END()
```

`Simulator/test/vk.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <string>

constexpr std::string vk_to_str(WORD vkCode) {
    using namespace std::literals;

    switch (vkCode) {
    case 0x01: return "VK_LBUTTON";
    case 0x02: return "VK_RBUTTON";
    case 0x03: return "VK_CANCEL";
    case 0x04: return "VK_MBUTTON";
    case 0x05: return "VK_XBUTTON1";
    case 0x06: return "VK_XBUTTON2";
    case 0x07: return "reserved";
    case 0x08: return "VK_BACK";
    case 0x09: return "VK_TAB";
    case 0x0A: return "reserved";
    case 0x0B: return "reserved";
    case 0x0C: return "VK_CLEAR";
    case 0x0D: return "VK_RETURN";
    case 0x0E: return "reserved";
    case 0x0F: return "reserved";
    case 0x10: return "VK_SHIFT";
    case 0x11: return "VK_CONTROL";
    case 0x12: return "VK_MENU";
    case 0x13: return "VK_PAUSE";
    case 0x14: return "VK_CAPITAL";
    case 0x15: return "VK_KANA|VK_HANGEUL|VK_HANGUL";
    case 0x16: return "unassigned";
    case 0x17: return "VK_JUNJA";
    case 0x18: return "VK_FINAL";
    case 0x19: return "VK_HANJA|VK_KANJI";
    case 0x1A: return "unassigned";
    case 0x1B: return "VK_ESCAPE";
    case 0x1C: return "VK_CONVERT";
    case 0x1D: return "VK_NONCONVERT";
    case 0x1E: return "VK_ACCEPT";
    case 0x1F: return "VK_MODECHANGE";
    case 0x20: return "VK_SPACE";
    case 0x21: return "VK_PRIOR";
    case 0x22: return "VK_NEXT";
    case 0x23: return "VK_END";
    case 0x24: return "VK_HOME";
    case 0x25: return "VK_LEFT";
    case 0x26: return "VK_UP";
    case 0x27: return "VK_RIGHT";
    case 0x28: return "VK_DOWN";
    case 0x29: return "VK_SELECT";
    case 0x2A: return "VK_PRINT";
    case 0x2B: return "VK_EXECUTE";
    case 0x2C: return "VK_SNAPSHOT";
    case 0x2D: return "VK_INSERT";
    case 0x2E: return "VK_DELETE";
    case 0x2F: return "VK_HELP";
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
    case 0x3E:
    case 0x3F:
    case 0x40: return "unassigned";
    case 0x5B: return "VK_LWIN";
    case 0x5C: return "VK_RWIN";
    case 0x5D: return "VK_APPS";
    case 0x5E: return "reserved";
    case 0x5F: return "VK_SLEEP";
    case 0x60: return "VK_NUMPAD0";
    case 0x61: return "VK_NUMPAD1";
    case 0x62: return "VK_NUMPAD2";
    case 0x63: return "VK_NUMPAD3";
    case 0x64: return "VK_NUMPAD4";
    case 0x65: return "VK_NUMPAD5";
    case 0x66: return "VK_NUMPAD6";
    case 0x67: return "VK_NUMPAD7";
    case 0x68: return "VK_NUMPAD8";
    case 0x69: return "VK_NUMPAD9";
    case 0x6A: return "VK_MULTIPLY";
    case 0x6B: return "VK_ADD";
    case 0x6C: return "VK_SEPARATOR";
    case 0x6D: return "VK_SUBTRACT";
    case 0x6E: return "VK_DECIMAL";
    case 0x6F: return "VK_DIVIDE";
    case 0x70: return "VK_F1";
    case 0x71: return "VK_F2";
    case 0x72: return "VK_F3";
    case 0x73: return "VK_F4";
    case 0x74: return "VK_F5";
    case 0x75: return "VK_F6";
    case 0x76: return "VK_F7";
    case 0x77: return "VK_F8";
    case 0x78: return "VK_F9";
    case 0x79: return "VK_F10";
    case 0x7A: return "VK_F11";
    case 0x7B: return "VK_F12";
    case 0x7C: return "VK_F13";
    case 0x7D: return "VK_F14";
    case 0x7E: return "VK_F15";
    case 0x7F: return "VK_F16";
    case 0x80: return "VK_F17";
    case 0x81: return "VK_F18";
    case 0x82: return "VK_F19";
    case 0x83: return "VK_F20";
    case 0x84: return "VK_F21";
    case 0x85: return "VK_F22";
    case 0x86: return "VK_F23";
    case 0x87: return "VK_F24";
    case 0x88: return "VK_NAVIGATION_VIEW";
    case 0x89: return "VK_NAVIGATION_MENU";
    case 0x8A: return "VK_NAVIGATION_UP";
    case 0x8B: return "VK_NAVIGATION_DOWN";
    case 0x8C: return "VK_NAVIGATION_LEFT";
    case 0x8D: return "VK_NAVIGATION_RIGHT";
    case 0x8E: return "VK_NAVIGATION_ACCEPT";
    case 0x8F: return "VK_NAVIGATION_CANCEL";
    case 0x90: return "VK_NUMLOCK";
    case 0x91: return "VK_SCROLL";
    case 0x92: return "VK_OEM_NEC_EQUAL|VK_OEM_FJ_JISHO";
    case 0x93: return "VK_OEM_FJ_MASSHOU";
    case 0x94: return "VK_OEM_FJ_TOUROKU";
    case 0x95: return "VK_OEM_FJ_LOYA";
    case 0x96: return "VK_OEM_FJ_ROYA";
    case 0x97:
    case 0x98:
    case 0x99:
    case 0x9A:
    case 0x9B:
    case 0x9C:
    case 0x9D:
    case 0x9E:
    case 0x9F: return "unassigned";
    case 0xA0: return "VK_LSHIFT";
    case 0xA1: return "VK_RSHIFT";
    case 0xA2: return "VK_LCONTROL";
    case 0xA3: return "VK_RCONTROL";
    case 0xA4: return "VK_LMENU";
    case 0xA5: return "VK_RMENU";
    case 0xA6: return "VK_BROWSER_BACK";
    case 0xA7: return "VK_BROWSER_FORWARD";
    case 0xA8: return "VK_BROWSER_REFRESH";
    case 0xA9: return "VK_BROWSER_STOP";
    case 0xAA: return "VK_BROWSER_SEARCH";
    case 0xAB: return "VK_BROWSER_FAVORITES";
    case 0xAC: return "VK_BROWSER_HOME";
    case 0xAD: return "VK_VOLUME_MUTE";
    case 0xAE: return "VK_VOLUME_DOWN";
    case 0xAF: return "VK_VOLUME_UP";
    case 0xB0: return "VK_MEDIA_NEXT_TRACK";
    case 0xB1: return "VK_MEDIA_PREV_TRACK";
    case 0xB2: return "VK_MEDIA_STOP";
    case 0xB3: return "VK_MEDIA_PLAY_PAUSE";
    case 0xB4: return "VK_LAUNCH_MAIL";
    case 0xB5: return "VK_LAUNCH_MEDIA_SELECT";
    case 0xB6: return "VK_LAUNCH_APP1";
    case 0xB7: return "VK_LAUNCH_APP2";
    case 0xB8:
    case 0xB9: return "reserved";
    case 0xBA: return "VK_OEM_1";   // ';:' for US
    case 0xBB: return "VK_OEM_PLUS";   // '+' any country
    case 0xBC: return "VK_OEM_COMMA";   // ',' any country
    case 0xBD: return "VK_OEM_MINUS";   // '-' any country
    case 0xBE: return "VK_OEM_PERIOD";   // '.' any country
    case 0xBF: return "VK_OEM_2";   // '/?' for US
    case 0xC0: return "VK_OEM_3";   // '`~' for US
    case 0xC1: return "reserved";
    case 0xC2: return "reserved";
    case 0xC3: return "VK_GAMEPAD_A"; // reserved
    case 0xC4: return "VK_GAMEPAD_B"; // reserved
    case 0xC5: return "VK_GAMEPAD_X"; // reserved
    case 0xC6: return "VK_GAMEPAD_Y"; // reserved
    case 0xC7: return "VK_GAMEPAD_RIGHT_SHOULDER"; // reserved
    case 0xC8: return "VK_GAMEPAD_LEFT_SHOULDER"; // reserved
    case 0xC9: return "VK_GAMEPAD_LEFT_TRIGGER"; // reserved
    case 0xCA: return "VK_GAMEPAD_RIGHT_TRIGGER"; // reserved
    case 0xCB: return "VK_GAMEPAD_DPAD_UP"; // reserved
    case 0xCC: return "VK_GAMEPAD_DPAD_DOWN"; // reserved
    case 0xCD: return "VK_GAMEPAD_DPAD_LEFT"; // reserved
    case 0xCE: return "VK_GAMEPAD_DPAD_RIGHT"; // reserved
    case 0xCF: return "VK_GAMEPAD_MENU"; // reserved
    case 0xD0: return "VK_GAMEPAD_VIEW"; // reserved
    case 0xD1: return "VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON"; // reserved
    case 0xD2: return "VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON"; // reserved
    case 0xD3: return "VK_GAMEPAD_LEFT_THUMBSTICK_UP"; // reserved
    case 0xD4: return "VK_GAMEPAD_LEFT_THUMBSTICK_DOWN"; // reserved
    case 0xD5: return "VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT"; // reserved
    case 0xD6: return "VK_GAMEPAD_LEFT_THUMBSTICK_LEFT"; // reserved
    case 0xD7: return "VK_GAMEPAD_RIGHT_THUMBSTICK_UP"; // reserved
    case 0xD8: return "VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN"; // reserved
    case 0xD9: return "VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT"; // reserved
    case 0xDA: return "VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT"; // reserved
    case 0xDB: return "VK_OEM_4";  //  '[{' for US
    case 0xDC: return "VK_OEM_5";  //  '\|' for US
    case 0xDD: return "VK_OEM_6";  //  ']}' for US
    case 0xDE: return "VK_OEM_7";  //  ''"' for US
    case 0xDF: return "VK_OEM_8";
    case 0xE0: return "reserved";
    case 0xE1: return "VK_OEM_AX";  //  'AX' key on Japanese AX kbd
    case 0xE2: return "VK_OEM_102";  //  "<>" or "\|" on RT 102-key kbd.
    case 0xE3: return "VK_ICO_HELP";  //  Help key on ICO
    case 0xE4: return "VK_ICO_00";  //  00 key on ICO
    case 0xE5: return "VK_PROCESSKEY";
    case 0xE6: return "VK_ICO_CLEAR";
    case 0xE7: return "VK_PACKET";
    case 0xE8: return "unassigned";
    case 0xE9: return "VK_OEM_RESET";
    case 0xEA: return "VK_OEM_JUMP";
    case 0xEB: return "VK_OEM_PA1";
    case 0xEC: return "VK_OEM_PA2";
    case 0xED: return "VK_OEM_PA3";
    case 0xEE: return "VK_OEM_WSCTRL";
    case 0xEF: return "VK_OEM_CUSEL";
    case 0xF0: return "VK_OEM_ATTN";
    case 0xF1: return "VK_OEM_FINISH";
    case 0xF2: return "VK_OEM_COPY";
    case 0xF3: return "VK_OEM_AUTO";
    case 0xF4: return "VK_OEM_ENLW";
    case 0xF5: return "VK_OEM_BACKTAB";
    case 0xF6: return "VK_ATTN";
    case 0xF7: return "VK_CRSEL";
    case 0xF8: return "VK_EXSEL";
    case 0xF9: return "VK_EREOF";
    case 0xFA: return "VK_PLAY";
    case 0xFB: return "VK_ZOOM";
    case 0xFC: return "VK_NONAME";
    case 0xFD: return "VK_PA1";
    case 0xFE: return "VK_OEM_CLEAR";
    default: if ('0' <= vkCode and vkCode <= '9'
        || 'A' <= vkCode and vkCode <= 'Z'
        ) return "VK_"s + (char)vkCode;
           else
        return std::to_string(vkCode);
    }
}

//DDCode:
/*
0 0: -1
1 VK_LBUTTON : -1
2 VK_RBUTTON : -1
3 VK_CANCEL : -1
4 VK_MBUTTON : -1
5 VK_XBUTTON1 : -1
6 VK_XBUTTON2 : -1
7 reserved : -1
8 VK_BACK : 214
9 VK_TAB : 300
10 reserved : -1
11 reserved : -1
12 VK_CLEAR : -1
13 VK_RETURN : 313
14 reserved : -1
15 reserved : -1
16 VK_SHIFT : 500
17 VK_CONTROL : 600
18 VK_MENU : 602
19 VK_PAUSE : 702
20 VK_CAPITAL : 400
21 VK_KANA | VK_HANGEUL | VK_HANGUL : -1
22 unassigned : -1
23 VK_JUNJA : -1
24 VK_FINAL : -1
25 VK_HANJA | VK_KANJI : -1
26 unassigned : -1
27 VK_ESCAPE : 100
28 VK_CONVERT : -1
29 VK_NONCONVERT : -1
30 VK_ACCEPT : -1
31 VK_MODECHANGE : -1
32 VK_SPACE : 603
33 VK_PRIOR : 705
34 VK_NEXT : 708
35 VK_END : 707
36 VK_HOME : 704
37 VK_LEFT : 710
38 VK_UP : 709
39 VK_RIGHT : 712
40 VK_DOWN : 711
41 VK_SELECT : -1
42 VK_PRINT : -1
43 VK_EXECUTE : -1
44 VK_SNAPSHOT : 700
45 VK_INSERT : 703
46 VK_DELETE : 706
47 VK_HELP : -1
48 VK_0 : 210
49 VK_1 : 201
50 VK_2 : 202
51 VK_3 : 203
52 VK_4 : 204
53 VK_5 : 205
54 VK_6 : 206
55 VK_7 : 207
56 VK_8 : 208
57 VK_9 : 209
58 unassigned : -1
59 unassigned : -1
60 unassigned : -1
61 unassigned : -1
62 unassigned : -1
63 unassigned : -1
64 unassigned : -1
65 VK_A : 401
66 VK_B : 505
67 VK_C : 503
68 VK_D : 403
69 VK_E : 303
70 VK_F : 404
71 VK_G : 405
72 VK_H : 406
73 VK_I : 308
74 VK_J : 407
75 VK_K : 408
76 VK_L : 409
77 VK_M : 507
78 VK_N : 506
79 VK_O : 309
80 VK_P : 310
81 VK_Q : 301
82 VK_R : 304
83 VK_S : 402
84 VK_T : 305
85 VK_U : 307
86 VK_V : 504
87 VK_W : 302
88 VK_X : 502
89 VK_Y : 306
90 VK_Z : 501
91 VK_LWIN : 601
92 VK_RWIN : 605
93 VK_APPS : 606
94 reserved : -1
95 VK_SLEEP : -1
96 VK_NUMPAD0 : 800
97 VK_NUMPAD1 : 801
98 VK_NUMPAD2 : 802
99 VK_NUMPAD3 : 803
100 VK_NUMPAD4 : 804
101 VK_NUMPAD5 : 805
102 VK_NUMPAD6 : 806
103 VK_NUMPAD7 : 807
104 VK_NUMPAD8 : 808
105 VK_NUMPAD9 : 809
106 VK_MULTIPLY : 812
107 VK_ADD : 814
108 VK_SEPARATOR : -1
109 VK_SUBTRACT : 813
110 VK_DECIMAL : 816
111 VK_DIVIDE : 811
112 VK_F1 : 101
113 VK_F2 : 102
114 VK_F3 : 103
115 VK_F4 : 104
116 VK_F5 : 105
117 VK_F6 : 106
118 VK_F7 : 107
119 VK_F8 : 108
120 VK_F9 : 109
121 VK_F10 : 110
122 VK_F11 : 111
123 VK_F12 : 112
124 VK_F13 : -1
125 VK_F14 : -1
126 VK_F15 : -1
127 VK_F16 : -1
128 VK_F17 : -1
129 VK_F18 : -1
130 VK_F19 : -1
131 VK_F20 : -1
132 VK_F21 : -1
133 VK_F22 : -1
134 VK_F23 : -1
135 VK_F24 : -1
136 VK_NAVIGATION_VIEW : -1
137 VK_NAVIGATION_MENU : -1
138 VK_NAVIGATION_UP : -1
139 VK_NAVIGATION_DOWN : -1
140 VK_NAVIGATION_LEFT : -1
141 VK_NAVIGATION_RIGHT : -1
142 VK_NAVIGATION_ACCEPT : -1
143 VK_NAVIGATION_CANCEL : -1
144 VK_NUMLOCK : 810
145 VK_SCROLL : 701
146 VK_OEM_NEC_EQUAL | VK_OEM_FJ_JISHO : -1
147 VK_OEM_FJ_MASSHOU : -1
148 VK_OEM_FJ_TOUROKU : -1
149 VK_OEM_FJ_LOYA : -1
150 VK_OEM_FJ_ROYA : -1
151 unassigned : -1
152 unassigned : -1
153 unassigned : -1
154 unassigned : -1
155 unassigned : -1
156 unassigned : -1
157 unassigned : -1
158 unassigned : -1
159 unassigned : -1
160 VK_LSHIFT : -1
161 VK_RSHIFT : -1
162 VK_LCONTROL : -1
163 VK_RCONTROL : -1
164 VK_LMENU : -1
165 VK_RMENU : -1
166 VK_BROWSER_BACK : -1
167 VK_BROWSER_FORWARD : -1
168 VK_BROWSER_REFRESH : -1
169 VK_BROWSER_STOP : -1
170 VK_BROWSER_SEARCH : -1
171 VK_BROWSER_FAVORITES : -1
172 VK_BROWSER_HOME : -1
173 VK_VOLUME_MUTE : -1
174 VK_VOLUME_DOWN : -1
175 VK_VOLUME_UP : -1
176 VK_MEDIA_NEXT_TRACK : -1
177 VK_MEDIA_PREV_TRACK : -1
178 VK_MEDIA_STOP : -1
179 VK_MEDIA_PLAY_PAUSE : -1
180 VK_LAUNCH_MAIL : -1
181 VK_LAUNCH_MEDIA_SELECT : -1
182 VK_LAUNCH_APP1 : -1
183 VK_LAUNCH_APP2 : -1
184 reserved : -1
185 reserved : -1
186 VK_OEM_1 : 410
187 VK_OEM_PLUS : 212
188 VK_OEM_COMMA : 508
189 VK_OEM_MINUS : 211
190 VK_OEM_PERIOD : 509
191 VK_OEM_2 : 510
192 VK_OEM_3 : 200
193 reserved : -1
194 reserved : -1
195 VK_GAMEPAD_A : -1
196 VK_GAMEPAD_B : -1
197 VK_GAMEPAD_X : -1
198 VK_GAMEPAD_Y : -1
199 VK_GAMEPAD_RIGHT_SHOULDER : -1
200 VK_GAMEPAD_LEFT_SHOULDER : -1
201 VK_GAMEPAD_LEFT_TRIGGER : -1
202 VK_GAMEPAD_RIGHT_TRIGGER : -1
203 VK_GAMEPAD_DPAD_UP : -1
204 VK_GAMEPAD_DPAD_DOWN : -1
205 VK_GAMEPAD_DPAD_LEFT : -1
206 VK_GAMEPAD_DPAD_RIGHT : -1
207 VK_GAMEPAD_MENU : -1
208 VK_GAMEPAD_VIEW : -1
209 VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON : -1
210 VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON : -1
211 VK_GAMEPAD_LEFT_THUMBSTICK_UP : -1
212 VK_GAMEPAD_LEFT_THUMBSTICK_DOWN : -1
213 VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT : -1
214 VK_GAMEPAD_LEFT_THUMBSTICK_LEFT : -1
215 VK_GAMEPAD_RIGHT_THUMBSTICK_UP : -1
216 VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN : -1
217 VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT : -1
218 VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT : -1
219 VK_OEM_4 : 311
220 VK_OEM_5 : 213
221 VK_OEM_6 : 312
222 VK_OEM_7 : 411
223 VK_OEM_8 : -1
224 reserved : -1
225 VK_OEM_AX : -1
226 VK_OEM_102 : -1
227 VK_ICO_HELP : -1
228 VK_ICO_00 : -1
229 VK_PROCESSKEY : -1
230 VK_ICO_CLEAR : -1
231 VK_PACKET : -1
232 unassigned : -1
233 VK_OEM_RESET : -1
234 VK_OEM_JUMP : -1
235 VK_OEM_PA1 : -1
236 VK_OEM_PA2 : -1
237 VK_OEM_PA3 : -1
238 VK_OEM_WSCTRL : -1
239 VK_OEM_CUSEL : -1
240 VK_OEM_ATTN : -1
241 VK_OEM_FINISH : -1
242 VK_OEM_COPY : -1
243 VK_OEM_AUTO : -1
244 VK_OEM_ENLW : -1
245 VK_OEM_BACKTAB : -1
246 VK_ATTN : -1
247 VK_CRSEL : -1
248 VK_EXSEL : -1
249 VK_EREOF : -1
250 VK_PLAY : -1
251 VK_ZOOM : -1
252 VK_NONAME : -1
253 VK_PA1 : -1
254 VK_OEM_CLEAR : -1
255 255 : -1
*/
```