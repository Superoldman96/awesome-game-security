Project Path: arc_gmh5225_BattlEye-Handler-BYPASS_p_cweal2

Source Tree:

```txt
arc_gmh5225_BattlEye-Handler-BYPASS_p_cweal2
├── README.md
├── bypass.sln
├── bypass.vcxproj
├── bypass.vcxproj.filters
├── bypass.vcxproj.user
├── defs.hpp
├── global
│   └── global.hpp
├── hook
│   └── hook.hpp
├── io
│   ├── io.cpp
│   └── io.hpp
└── main.cpp

```

`README.md`:

```md
# BattlEye-Handler-BYPASS
Made by unclasified
BE-Handler is a project that will allow you to create a handle, and maintain it until battleye strips it. (5 seconds)
But, you can always just create a new handle 

```

`bypass.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30804.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "bypass", "bypass\bypass.vcxproj", "{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|ARM.ActiveCfg = Debug|ARM
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|ARM.Build.0 = Debug|ARM
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|ARM.Deploy.0 = Debug|ARM
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|ARM64.Build.0 = Debug|ARM64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|x64.ActiveCfg = Debug|x64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|x64.Build.0 = Debug|x64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|x64.Deploy.0 = Debug|x64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|x86.ActiveCfg = Debug|Win32
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|x86.Build.0 = Debug|Win32
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Debug|x86.Deploy.0 = Debug|Win32
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|ARM.ActiveCfg = Release|ARM
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|ARM.Build.0 = Release|ARM
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|ARM.Deploy.0 = Release|ARM
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|ARM64.ActiveCfg = Release|ARM64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|ARM64.Build.0 = Release|ARM64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|ARM64.Deploy.0 = Release|ARM64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|x64.ActiveCfg = Release|x64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|x64.Build.0 = Release|x64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|x64.Deploy.0 = Release|x64
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|x86.ActiveCfg = Release|Win32
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|x86.Build.0 = Release|Win32
		{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A4B6DF2F-82DD-4365-87E8-516BB221054E}
	EndGlobalSection
EndGlobal

```

`bypass.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="io\io.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{EAD37431-EEAC-47C0-BE5D-DD7B65FAEFFC}</ProjectGuid>
    <TemplateGuid>{497e31cb-056b-4f31-abb8-447fd55ee5a5}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>bypass</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(WindowsSDK_IncludePath);$(VC_IncludePath);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">
      </WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <AdditionalDependencies>legacy_stdio_definitions.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.hpp" />
    <ClInclude Include="global\global.hpp" />
    <ClInclude Include="hook\hook.hpp" />
    <ClInclude Include="io\io.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`bypass.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\io">
      <UniqueIdentifier>{cbcbaed6-7008-4721-a6c1-4e6a783c0dbb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\global">
      <UniqueIdentifier>{28b93e11-992f-4e6a-a35f-6745c395a15e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\hook">
      <UniqueIdentifier>{2abd33d4-ea5d-4323-9aba-3e6d89969eea}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="io\io.cpp">
      <Filter>Header Files\io</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="io\io.hpp">
      <Filter>Header Files\io</Filter>
    </ClInclude>
    <ClInclude Include="global\global.hpp">
      <Filter>Header Files\global</Filter>
    </ClInclude>
    <ClInclude Include="hook\hook.hpp">
      <Filter>Header Files\hook</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`bypass.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`defs.hpp`:

```hpp
#include <ntifs.h>
#pragma
extern "C"
{

	NTKERNELAPI PVOID
		PsGetProcessSectionBaseAddress(
			PEPROCESS Process
		);

}

#pragma once
#define _USE_MATH_DEFINES
#include <math.h>

#if defined(__GNUC__)
typedef          long long ll;
typedef unsigned long long ull;
#define __int64 long long
#define __int32 int
#define __int16 short
#define __int8  char
#define MAKELL(num) num ## LL
#define FMT_64 "ll"
#elif defined(_MSC_VER)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "I64"
#elif defined (__BORLANDC__)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "L"
#else
#error "unknown compiler"
#endif
typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
//typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;

// Partially defined types:
#define _BYTE  uint8
#define _WORD  uint16
#define _DWORD uint32
#define _QWORD uint64
#if !defined(_MSC_VER)
#define _LONGLONG __int128
#endif


// Some convenience macros to make partial accesses nicer
// first unsigned macros:
//Already defined
//#define LOBYTE(x)   (*((_BYTE*)&(x)))   // low byte
//#define LOWORD(x)   (*((_WORD*)&(x)))   // low word
//#define LODWORD(x)  (*((_DWORD*)&(x)))  // low dword
//#define HIBYTE(x)   (*((_BYTE*)&(x)+1))
//#define HIWORD(x)   (*((_WORD*)&(x)+1))
#define HIDWORD(x)  (*((_DWORD*)&(x)+1))
#define BYTEn(x, n)   (*((_BYTE*)&(x)+n))
#define WORDn(x, n)   (*((_WORD*)&(x)+n))
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)
#define BYTE3(x)   BYTEn(x,  3)
#define BYTE4(x)   BYTEn(x,  4)
#define BYTE5(x)   BYTEn(x,  5)
#define BYTE6(x)   BYTEn(x,  6)
#define BYTE7(x)   BYTEn(x,  7)
#define BYTE8(x)   BYTEn(x,  8)
#define BYTE9(x)   BYTEn(x,  9)
#define BYTE10(x)  BYTEn(x, 10)
#define BYTE11(x)  BYTEn(x, 11)
#define BYTE12(x)  BYTEn(x, 12)
#define BYTE13(x)  BYTEn(x, 13)
#define BYTE14(x)  BYTEn(x, 14)
#define BYTE15(x)  BYTEn(x, 15)
#define WORD1(x)   WORDn(x,  1)
#define WORD2(x)   WORDn(x,  2)         // third word of the object, unsigned
#define WORD3(x)   WORDn(x,  3)
#define WORD4(x)   WORDn(x,  4)
#define WORD5(x)   WORDn(x,  5)
#define WORD6(x)   WORDn(x,  6)
#define WORD7(x)   WORDn(x,  7)

// now signed macros (the same but with sign extension)
#define SLOBYTE(x)   (*((int8*)&(x)))
#define SLOWORD(x)   (*((int16*)&(x)))
#define SLODWORD(x)  (*((int32*)&(x)))
#define SHIBYTE(x)   (*((int8*)&(x)+1))
#define SHIWORD(x)   (*((int16*)&(x)+1))
#define SHIDWORD(x)  (*((int32*)&(x)+1))
#define SBYTEn(x, n)   (*((int8*)&(x)+n))
#define SWORDn(x, n)   (*((int16*)&(x)+n))
#define SBYTE1(x)   SBYTEn(x,  1)
#define SBYTE2(x)   SBYTEn(x,  2)
#define SBYTE3(x)   SBYTEn(x,  3)
#define SBYTE4(x)   SBYTEn(x,  4)
#define SBYTE5(x)   SBYTEn(x,  5)
#define SBYTE6(x)   SBYTEn(x,  6)
#define SBYTE7(x)   SBYTEn(x,  7)
#define SBYTE8(x)   SBYTEn(x,  8)
#define SBYTE9(x)   SBYTEn(x,  9)
#define SBYTE10(x)  SBYTEn(x, 10)
#define SBYTE11(x)  SBYTEn(x, 11)
#define SBYTE12(x)  SBYTEn(x, 12)
#define SBYTE13(x)  SBYTEn(x, 13)
#define SBYTE14(x)  SBYTEn(x, 14)
#define SBYTE15(x)  SBYTEn(x, 15)
#define SWORD1(x)   SWORDn(x,  1)
#define SWORD2(x)   SWORDn(x,  2)
#define SWORD3(x)   SWORDn(x,  3)
#define SWORD4(x)   SWORDn(x,  4)
#define SWORD5(x)   SWORDn(x,  5)
#define SWORD6(x)   SWORDn(x,  6)
#define SWORD7(x)   SWORDn(x,  7)

template<class T> T __ROL__(T value, int count)
{
	const uint nbits = sizeof(T) * 8;

	if (count > 0)
	{
		count %= nbits;
		T high = value >> (nbits - count);
		if (T(-1) < 0) // signed value
			high &= ~((T(-1) << count));
		value <<= count;
		value |= high;
	}
	else
	{
		count = -count % nbits;
		T low = value << (nbits - count);
		value >>= count;
		value |= low;
	}
	return value;
}

inline uint8  __ROL1__(uint8  value, int count) { return __ROL__((uint8)value, count); }
inline uint16 __ROL2__(uint16 value, int count) { return __ROL__((uint16)value, count); }
inline uint32 __ROL4__(uint32 value, int count) { return __ROL__((uint32)value, count); }
inline uint64 __ROL8__(uint64 value, int count) { return __ROL__((uint64)value, count); }
inline uint8  __ROR1__(uint8  value, int count) { return __ROL__((uint8)value, -count); }
inline uint16 __ROR2__(uint16 value, int count) { return __ROL__((uint16)value, -count); }
inline uint32 __ROR4__(uint32 value, int count) { return __ROL__((uint32)value, -count); }
inline uint64 __ROR8__(uint64 value, int count) { return __ROL__((uint64)value, -count); }

//Dumb glow decryption stuff
//https://www.codeproject.com/Articles/1274943/IEEE-754-Conversion

#define NTH_BIT(b, n) ((b >> n) & 0x1)

#define BYTE_TO_BIN(b)   (( b & 0x80 ) ) |\
            (( b & 0x40 ) ) |\
            (( b & 0x20 ) ) |\
            (( b & 0x10 ) ) |\
            (( b & 0x08 ) ) |\
            (( b & 0x04 ) ) |\
            (( b & 0x02 ) ) |\
            ( b & 0x01 )

#define MANTISSA_TO_BIN(b)  (( b & 0x400000 ) ) |\
             (( b & 0x200000 ) ) |\
             (( b & 0x100000 ) ) |\
             (( b &  0x80000 ) ) |\
             (( b &  0x40000 ) ) |\
             (( b &  0x20000 ) ) |\
             (( b &  0x10000 ) ) |\
             (( b &  0x8000 ) ) |\
             (( b &  0x4000 ) ) |\
             (( b &  0x2000 ) ) |\
             (( b &  0x1000 ) ) |\
             (( b &  0x800 ) ) |\
             (( b &  0x400 ) ) |\
             (( b &  0x200 ) ) |\
             (( b &  0x100 ) ) |\
             (( b &  0x80 ) ) |\
             (( b &  0x40 ) ) |\
             (( b &  0x20 ) ) |\
             (( b &  0x10 ) ) |\
             (( b &  0x08 ) ) |\
             (( b &  0x04 ) ) |\
             (( b &  0x02 ) ) |\
              ( b & 0x01 )

typedef union IEEE754
{
	struct
	{
		unsigned int mantissa : 23;
		unsigned int exponent : 8;
		unsigned int sign : 1;
	} raw;
	float f;
} IEEE754;

typedef struct _MM_UNLOADED_DRIVER
{
	UNICODE_STRING     Name;
	PVOID             ModuleStart;
	PVOID             ModuleEnd;
	ULONG64         UnloadTime;
} MM_UNLOADED_DRIVER, * PMM_UNLOADED_DRIVER;
typedef struct _PIDDBCACHE_ENTRY
{
	LIST_ENTRY        List;
	UNICODE_STRING    DriverName;
	ULONG            TimeDateStamp;
	NTSTATUS        LoadStatus;
	char            _0x0028[16];
} PIDDBCACHE_ENTRY, * PPIDDBCACHE_ENTRY;
typedef struct _SYSTEM_MODULE
{
	ULONG_PTR Reserved[2];
	PVOID     Base;
	ULONG     Size;
	ULONG     Flags;
	USHORT    Index;
	USHORT    Unknown;
	USHORT    LoadCount;
	USHORT    ModuleNameOffset;
	CHAR      ImageName[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;
typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG_PTR     ModuleCount;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;
typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,				   // q: SYSTEM_BASIC_INFORMATION
	SystemProcessorInformation,			   // q: SYSTEM_PROCESSOR_INFORMATION
	SystemPerformanceInformation,		   // q: SYSTEM_PERFORMANCE_INFORMATION
	SystemTimeOfDayInformation,			   // q: SYSTEM_TIMEOFDAY_INFORMATION
	SystemPathInformation,				   // not implemented
	SystemProcessInformation,			   // q: SYSTEM_PROCESS_INFORMATION
	SystemCallCountInformation,			   // q: SYSTEM_CALL_COUNT_INFORMATION
	SystemDeviceInformation,			   // q: SYSTEM_DEVICE_INFORMATION
	SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
	SystemFlagsInformation,				   // q: SYSTEM_FLAGS_INFORMATION
	SystemCallTimeInformation,			   // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
	SystemModuleInformation,			   // q: RTL_PROCESS_MODULES
	SystemLocksInformation,				   // q: SYSTEM_LOCK_INFORMATION
	SystemStackTraceInformation,
	SystemPagedPoolInformation,			   // not implemented
	SystemNonPagedPoolInformation,		   // not implemented
	SystemHandleInformation,			   // q: SYSTEM_HANDLE_INFORMATION
	SystemObjectInformation,			   // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
	SystemPageFileInformation,			   // q: SYSTEM_PAGEFILE_INFORMATION
	SystemVdmInstemulInformation,		   // q
	SystemVdmBopInformation,			   // not implemented // 20
	SystemFileCacheInformation,			   // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
	SystemPoolTagInformation,			   // q: SYSTEM_POOLTAG_INFORMATION
	SystemInterruptInformation,			   // q: SYSTEM_INTERRUPT_INFORMATION
	SystemDpcBehaviorInformation,		   // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
	SystemFullMemoryInformation,		   // not implemented
	SystemLoadGdiDriverInformation,		   // s (kernel-mode only)
	SystemUnloadGdiDriverInformation,	  // s (kernel-mode only)
	SystemTimeAdjustmentInformation,	   // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
	SystemSummaryMemoryInformation,		   // not implemented
	SystemMirrorMemoryInformation,		   // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
	SystemPerformanceTraceInformation,	 // s
	SystemObsolete0,					   // not implemented
	SystemExceptionInformation,			   // q: SYSTEM_EXCEPTION_INFORMATION
	SystemCrashDumpStateInformation,	   // s (requires SeDebugPrivilege)
	SystemKernelDebuggerInformation,	   // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
	SystemContextSwitchInformation,		   // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
	SystemRegistryQuotaInformation,		   // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
	SystemExtendServiceTableInformation,   // s (requires SeLoadDriverPrivilege) // loads win32k only
	SystemPrioritySeperation,			   // s (requires SeTcbPrivilege)
	SystemVerifierAddDriverInformation,	// s (requires SeDebugPrivilege) // 40
	SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
	SystemProcessorIdleInformation,		   // q: SYSTEM_PROCESSOR_IDLE_INFORMATION
	SystemLegacyDriverInformation,		   // q: SYSTEM_LEGACY_DRIVER_INFORMATION
	SystemCurrentTimeZoneInformation,	  // q
	SystemLookasideInformation,			   // q: SYSTEM_LOOKASIDE_INFORMATION
	SystemTimeSlipNotification,			   // s (requires SeSystemtimePrivilege)
	SystemSessionCreate,				   // not implemented
	SystemSessionDetach,				   // not implemented
	SystemSessionInformation,			   // not implemented
	SystemRangeStartInformation,		   // q: SYSTEM_RANGE_START_INFORMATION // 50
	SystemVerifierInformation,			   // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
	SystemVerifierThunkExtend,			   // s (kernel-mode only)
	SystemSessionProcessInformation,	   // q: SYSTEM_SESSION_PROCESS_INFORMATION
	SystemLoadGdiDriverInSystemSpace,	  // s (kernel-mode only) (same as SystemLoadGdiDriverInformation)
	SystemNumaProcessorMap,				   // q
	SystemPrefetcherInformation,		   // q: PREFETCHER_INFORMATION; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
	SystemExtendedProcessInformation,	  // q: SYSTEM_PROCESS_INFORMATION
	SystemRecommendedSharedDataAlignment,  // q
	SystemComPlusPackage,				   // q; s
	SystemNumaAvailableMemory,			   // 60
	SystemProcessorPowerInformation,	   // q: SYSTEM_PROCESSOR_POWER_INFORMATION
	SystemEmulationBasicInformation,	   // q
	SystemEmulationProcessorInformation,
	SystemExtendedHandleInformation,			   // q: SYSTEM_HANDLE_INFORMATION_EX
	SystemLostDelayedWriteInformation,			   // q: ULONG
	SystemBigPoolInformation,					   // q: SYSTEM_BIGPOOL_INFORMATION
	SystemSessionPoolTagInformation,			   // q: SYSTEM_SESSION_POOLTAG_INFORMATION
	SystemSessionMappedViewInformation,			   // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
	SystemHotpatchInformation,					   // q; s
	SystemObjectSecurityMode,					   // q // 70
	SystemWatchdogTimerHandler,					   // s (kernel-mode only)
	SystemWatchdogTimerInformation,				   // q (kernel-mode only); s (kernel-mode only)
	SystemLogicalProcessorInformation,			   // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION
	SystemWow64SharedInformationObsolete,		   // not implemented
	SystemRegisterFirmwareTableInformationHandler, // s (kernel-mode only)
	SystemFirmwareTableInformation,				   // SYSTEM_FIRMWARE_TABLE_INFORMATION
	SystemModuleInformationEx,					   // q: RTL_PROCESS_MODULE_INFORMATION_EX
	SystemVerifierTriageInformation,			   // not implemented
	SystemSuperfetchInformation,				   // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
	SystemMemoryListInformation,				   // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
	SystemFileCacheInformationEx,				   // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
	SystemThreadPriorityClientIdInformation,	   // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
	SystemProcessorIdleCycleTimeInformation,	   // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[]
	SystemVerifierCancellationInformation,		   // not implemented // name:wow64:whNT32QuerySystemVerifierCancellationInformation
	SystemProcessorPowerInformationEx,			   // not implemented
	SystemRefTraceInformation,					   // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
	SystemSpecialPoolInformation,				   // q; s (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
	SystemProcessIdInformation,					   // q: SYSTEM_PROCESS_ID_INFORMATION
	SystemErrorPortInformation,					   // s (requires SeTcbPrivilege)
	SystemBootEnvironmentInformation,			   // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
	SystemHypervisorInformation,				   // q; s (kernel-mode only)
	SystemVerifierInformationEx,				   // q; s: SYSTEM_VERIFIER_INFORMATION_EX
	SystemTimeZoneInformation,					   // s (requires SeTimeZonePrivilege)
	SystemImageFileExecutionOptionsInformation,	// s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
	SystemCoverageInformation,					   // q; s // name:wow64:whNT32QuerySystemCoverageInformation; ExpCovQueryInformation
	SystemPrefetchPatchInformation,				   // not implemented
	SystemVerifierFaultsInformation,			   // s (requires SeDebugPrivilege)
	SystemSystemPartitionInformation,			   // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
	SystemSystemDiskInformation,				   // q: SYSTEM_SYSTEM_DISK_INFORMATION
	SystemProcessorPerformanceDistribution,		   // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION // 100
	SystemNumaProximityNodeInformation,			   // q
	SystemDynamicTimeZoneInformation,			   // q; s (requires SeTimeZonePrivilege)
	SystemCodeIntegrityInformation,				   // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
	SystemProcessorMicrocodeUpdateInformation,	 // s
	SystemProcessorBrandString,					   // q // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
	SystemVirtualAddressInformation,			   // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
	SystemLogicalProcessorAndGroupInformation,	 // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // since WIN7 // KeQueryLogicalProcessorRelationship
	SystemProcessorCycleTimeInformation,		   // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[]
	SystemStoreInformation,						   // q; s // SmQueryStoreInformation
	SystemRegistryAppendString,					   // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
	SystemAitSamplingValue,						   // s: ULONG (requires SeProfileSingleProcessPrivilege)
	SystemVhdBootInformation,					   // q: SYSTEM_VHD_BOOT_INFORMATION
	SystemCpuQuotaInformation,					   // q; s // PsQueryCpuQuotaInformation
	SystemNativeBasicInformation,				   // not implemented
	SystemSpare1,								   // not implemented
	SystemLowPriorityIoInformation,				   // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
	SystemTpmBootEntropyInformation,			   // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
	SystemVerifierCountersInformation,			   // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
	SystemPagedPoolInformationEx,				   // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
	SystemSystemPtesInformationEx,				   // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
	SystemNodeDistanceInformation,				   // q
	SystemAcpiAuditInformation,					   // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
	SystemBasicPerformanceInformation,			   // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
	SystemQueryPerformanceCounterInformation,	  // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
	SystemSessionBigPoolInformation,			   // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
	SystemBootGraphicsInformation,				   // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
	SystemScrubPhysicalMemoryInformation,
	SystemBadPageInformation,
	SystemProcessorProfileControlArea,
	SystemCombinePhysicalMemoryInformation, // 130
	SystemEntropyInterruptTimingCallback,
	SystemConsoleInformation,		 // q: SYSTEM_CONSOLE_INFORMATION
	SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION
	SystemThrottleNotificationInformation,
	SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
	SystemDeviceDataInformation,			   // q: SYSTEM_DEVICE_DATA_INFORMATION
	SystemDeviceDataEnumerationInformation,
	SystemMemoryTopologyInformation,		 // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
	SystemMemoryChannelInformation,			 // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
	SystemBootLogoInformation,				 // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
	SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // since WINBLUE
	SystemSpare0,
	SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
	SystemPageFileInformationEx,	   // q: SYSTEM_PAGEFILE_INFORMATION_EX
	SystemSecureBootInformation,	   // q: SYSTEM_SECUREBOOT_INFORMATION
	SystemEntropyInterruptTimingRawInformation,
	SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
	SystemFullProcessInformation,				   // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
	SystemKernelDebuggerInformationEx,			   // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
	SystemBootMetadataInformation,				   // 150
	SystemSoftRebootInformation,
	SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
	SystemOfflineDumpConfigInformation,
	SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
	SystemRegistryReconciliationInformation,
	SystemEdidInformation,
	SystemManufacturingInformation,			 // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
	SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
	SystemHypervisorDetailInformation,		 // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
	SystemProcessorCycleStatsInformation,	// q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION // 160
	SystemVmGenerationCountInformation,
	SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
	SystemKernelDebuggerFlags,
	SystemCodeIntegrityPolicyInformation, // q: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
	SystemIsolatedUserModeInformation,	// q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
	SystemHardwareSecurityTestInterfaceResultsInformation,
	SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION
	SystemAllowedCpuSetsInformation,
	SystemDmaProtectionInformation,		   // q: SYSTEM_DMA_PROTECTION_INFORMATION
	SystemInterruptCpuSetsInformation,	 // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
	SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
	SystemCodeIntegrityPolicyFullInformation,
	SystemAffinitizedInterruptProcessorInformation,
	SystemRootSiloInformation,  // q: SYSTEM_ROOT_SILO_INFORMATION
	SystemCpuSetInformation,	// q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
	SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION
	SystemWin32WerStartCallout,
	SystemSecureKernelProfileInformation,			// q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
	SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
	SystemInterruptSteeringInformation,				// 180
	SystemSupportedProcessorArchitectures,
	SystemMemoryUsageInformation,			   // q: SYSTEM_MEMORY_USAGE_INFORMATION
	SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
	MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS;

extern "C" __declspec(dllexport) PCHAR __stdcall PsGetProcessImageFileName(PEPROCESS);
typedef struct _CALLBACK_ENTRY
{
	USHORT Version;
	USHORT OperationRegistrationCount;
	ULONG unk1;
	PVOID RegistrationContext;
	UNICODE_STRING Altitude;
} CALLBACK_ENTRY, * PCALLBACK_ENTRY;
typedef struct _CALLBACK_ENTRY_ITEM
{
	LIST_ENTRY CallbackList;
	OB_OPERATION Operations;
	ULONG Active;
	CALLBACK_ENTRY* CallbackEntry;
	PVOID ObjectType;
	POB_PRE_OPERATION_CALLBACK PreOperation;
	POB_POST_OPERATION_CALLBACK PostOperation;
	ULONGLONG unk1;
} CALLBACK_ENTRY_ITEM, * PCALLBACK_ENTRY_ITEM;
```

`global/global.hpp`:

```hpp
#pragma
namespace driver
{
	namespace global
	{
		// anti cheat driver name
		char* target_driver;

		// driver altitude; see:
		// https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/allocated-altitudes
		wchar_t* target_altitude;

		// our target game
		char* target_process;

		// our usermode process that creats the handle
		char* usermode_process;
	}
}
```

`hook/hook.hpp`:

```hpp
#pragma
#include "../defs.hpp"
#include "../io/io.hpp"
#include "../global/global.hpp"
using namespace driver;

// l0l
#define RAPE_BATTLEYE 0x1fffffL
POB_PRE_OPERATION_CALLBACK pre_operation_callback = nullptr;

OB_PREOP_CALLBACK_STATUS pre_operation_callback_hook( PVOID registration_context, POB_PRE_OPERATION_INFORMATION operation_information )
{
	// if the callback object does not our process type return our callback
	if ( operation_information->ObjectType != *PsProcessType )
		return pre_operation_callback(registration_context, operation_information);

	// get raw image name
	const char* current_process = PsGetProcessImageFileName( IoGetCurrentProcess( ) );
	const char* target_process = PsGetProcessImageFileName( reinterpret_cast< PEPROCESS >(operation_information->Object ) );

	// ensure the target proces and current process are our desired processes
	if ( strstr( target_process, global::target_process ) && strstr( current_process, global::usermode_process ) )
	{
		io::dbgprint( "found, setting info..." );

		// set the access mask; see:
		// https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_ob_pre_create_handle_information
		operation_information->Parameters->CreateHandleInformation.DesiredAccess = RAPE_BATTLEYE;
		operation_information->Parameters->CreateHandleInformation.OriginalDesiredAccess = RAPE_BATTLEYE;

		io::dbgprint( "set" );

		// ObjectPreCallback returns an OB_PREOP_CALLBACK_STATUS value. Drivers must return OB_PREOP_SUCCESS; see:
		// https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nc-wdm-pob_pre_operation_callback
		return OB_PREOP_SUCCESS;
	}

	io::dbgprint( "finished callback" );

	// if the callback object does not our process type return our callback
	return pre_operation_callback( registration_context, operation_information );
}

// we need to set post operation, so this is just a null function
void post_operation_callback_hook( PVOID, POB_POST_OPERATION_INFORMATION ) { /* do nothing */ }

void callback( PLIST_ENTRY list_entry )
{
	for ( PLIST_ENTRY current_entry = list_entry->Flink; current_entry != list_entry; current_entry = current_entry->Flink )
	{
		// get the base address of an instance of a structure given the type of the 
		//structure and the address of a field within the containing structure; see:
		// https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/mm-bad-pointer
		PCALLBACK_ENTRY_ITEM callback_item = CONTAINING_RECORD( current_entry, CALLBACK_ENTRY_ITEM, CallbackList );

		// check if the atitude of this callback item is the altidude of our desired driver
		if ( !wcscmp( callback_item->CallbackEntry->Altitude.Buffer, global::target_altitude ) )
		{
			// if pre_operation_callback_hook hasnt been set yet
			if ( pre_operation_callback == nullptr )
				 pre_operation_callback = callback_item->PreOperation;

			// set operations
			callback_item->PreOperation = pre_operation_callback_hook;
			callback_item->PostOperation = post_operation_callback_hook;
		}
	}
}

```

`io/io.cpp`:

```cpp
#include <stdarg.h>
#include <stdio.h>
#include <ntifs.h>
#include <ntimage.h>
#include "io.hpp"

void driver::io::dbgprint(PCCH format, ...)
{

	//https://github.com/unmaewei/Full-Kernel-Driver/blob/main/full%20kernel%20bypass/io/io.cpp

	DbgPrintEx(0, 0, format);

	//CHAR message[512];
	//va_list _valist;
	//va_start(_valist, format);
	//const ULONG N = _vsnprintf_s(message, sizeof(message) - 1, format, _valist);
	//message[N] = L'\0';

	//vDbgPrintExWithPrefix("[Kernel Driver] ", DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, message, _valist);

	//va_end(_valist);
}

```

`io/io.hpp`:

```hpp
#pragma
#include <ntdef.h>

namespace driver
{
	namespace io
	{
		void dbgprint(PCCH format, ...);
	}
}
```

`main.cpp`:

```cpp
#include <ntifs.h>
#include <ntimage.h>
#include <ntddk.h>
#include <memory>
#include "hook/hook.hpp"

using namespace driver;

void driver_thread( void* context )
{

	// wait for battleye (ooga booga)
	//https://www.youtube.com/watch?v=qdy0cZf5loU
	while ( !/*get_base*/( "BEDaisy" ) )
	{
		io::dbgprint( "waiting for BEDaisy..." );

		// got this from stack overflow dunno the links soz
		LARGE_INTEGER time; 
		time.QuadPart = -(250) * 10 * 1000; 
		KeDelayExecutionThread(KernelMode, TRUE, &time);
	}

	// credits to rakes thread this this and vergillius project, 0xC8 is list entrys
	uint64_t target_process_callbacks = reinterpret_cast< uint64_t >( *PsProcessType ) + 0xC8;
	uint64_t target_thread_callbacks = reinterpret_cast< uint64_t >( *PsThreadType ) + 0xC8;

	// magic time...
	callback( reinterpret_cast< PLIST_ENTRY >( target_process_callbacks ) );
	callback( reinterpret_cast< PLIST_ENTRY >( target_thread_callbacks ) );

	io::dbgprint( "hooked, terminating thread..." );

	// were done, the callback will do the rest for us. exit.
	PsTerminateSystemThread( STATUS_SUCCESS );
}

// <params> only used for cleaning, u can change params as u need
NTSTATUS DriverEntry( int64 address, int32 size ) 
{
	io::dbgprint( "driver entry called." );

	// change this per your desire; see:
	// global.hpp
	global::target_altitude = L"363220";
	global::target_driver = "BEDaisy";

	// here weo do RainbowSix. so we can desipher
	// between the actual game and RainbowSix_BE.exe
	// (thank god to my friend for telling me this,
	// i was stuck here for over a hour)
	global::target_process = "RainbowSix.";
	global::usermode_process = "Meme";

	// thread defines
	HANDLE thread_handle = nullptr;
	OBJECT_ATTRIBUTES object_attribues{ };
	InitializeObjectAttributes( &object_attribues, nullptr, OBJ_KERNEL_HANDLE, nullptr, nullptr );

	// create thread
	NTSTATUS status = PsCreateSystemThread( &thread_handle, NULL, &object_attribues, nullptr, nullptr, reinterpret_cast< PKSTART_ROUTINE >( &driver_thread ), nullptr );

	// print thread status and exit
	io::dbgprint( "thread status -> 0x%llx", status );
	io::dbgprint( "fininshed driver entry... closing..." );


	return STATUS_SUCCESS;
}

```