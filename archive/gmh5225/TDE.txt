Project Path: arc_gmh5225_TDE_grx2ciwp

Source Tree:

```txt
arc_gmh5225_TDE_grx2ciwp
├── LICENSE
├── README.md
└── TDE
    ├── cisc.cpp
    ├── cisc.hpp
    ├── dolphin.cpp
    ├── dolphin.hpp
    ├── dolphin_handler.cpp
    ├── dolphin_handler.hpp
    ├── eagle.cpp
    ├── eagle.hpp
    ├── fish.cpp
    ├── fish.hpp
    ├── fish_context.cpp
    ├── fish_context.hpp
    ├── fish_handler.cpp
    ├── fish_handler.hpp
    ├── fish_handler_mnemonics.hpp
    ├── fish_handler_types.hpp
    ├── instruction_container.cpp
    ├── instruction_container.hpp
    ├── instruction_container_base.cpp
    ├── instruction_container_base.hpp
    ├── instruction_container_branch_evaluator.cpp
    ├── instruction_container_branch_evaluator.hpp
    ├── instruction_container_deobfuscator.cpp
    ├── instruction_container_deobfuscator.hpp
    ├── instruction_emulator.cpp
    ├── instruction_emulator.hpp
    ├── libudis86
    │   ├── decode.c
    │   ├── decode.h
    │   ├── extern.h
    │   ├── itab.c
    │   ├── itab.h
    │   ├── syn-att.c
    │   ├── syn-intel.c
    │   ├── syn.c
    │   ├── syn.h
    │   ├── types.h
    │   ├── udint.h
    │   └── udis86.c
    ├── main.cpp
    ├── oreans_base.cpp
    ├── oreans_base.hpp
    ├── oreans_entry.cpp
    ├── oreans_entry.hpp
    ├── puma.cpp
    ├── puma.hpp
    ├── risc.cpp
    ├── risc.hpp
    ├── segment_copy.cpp
    ├── segment_copy.hpp
    ├── segment_manager.cpp
    ├── segment_manager.hpp
    ├── shark.cpp
    ├── shark.hpp
    ├── tiger.cpp
    ├── tiger.hpp
    ├── tiger_context.cpp
    ├── tiger_context.hpp
    ├── tiger_handler.cpp
    ├── tiger_handler.hpp
    ├── tiger_handler_types.hpp
    ├── ud_instruction.cpp
    ├── ud_instruction.hpp
    ├── udis86.h
    ├── wild.hpp
    ├── wild_base.cpp
    ├── wild_base.hpp
    ├── wild_context.cpp
    ├── wild_context.hpp
    ├── wild_context_keys.cpp
    ├── wild_context_keys.hpp
    ├── wild_handler.cpp
    ├── wild_handler.hpp
    ├── wild_handler_flow.cpp
    ├── wild_handler_flow.hpp
    ├── wild_handler_key.cpp
    ├── wild_handler_key.hpp
    ├── wild_handler_mnemonics.hpp
    ├── wild_handler_parser.cpp
    ├── wild_handler_parser.hpp
    ├── wild_handler_tracer.cpp
    ├── wild_handler_tracer.hpp
    ├── wild_handler_types.hpp
    ├── wild_hybrid_base.cpp
    ├── wild_hybrid_base.hpp
    ├── wild_opcode_label.hpp
    ├── wild_opcode_label_manager.hpp
    └── wild_opcode_reader.hpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Soda

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# TDE
A devirtualization engine for Themida.

# Information
This engine is wrote to be a plugin for IDA.
Supported FISH VMA versions: 2.2.5.0, 2.2.6.0, 2.2.7.0


# Dependencies
Wrote using the udis86 library

```

`TDE/cisc.cpp`:

```cpp
#include "cisc.hpp"

#include <idp.hpp>

bool cisc::is_signature(instruction_container& vm_entrance)
{
	msg("CISC machine identified.\n");
	return true;
}

bool cisc::devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_entrance)
{
	msg("CISC machines are currently not supported.\n");
	return false;
}

```

`TDE/cisc.hpp`:

```hpp
#ifndef CISC_HPP_
#define CISC_HPP_

#include "oreans_base.hpp"

class cisc : public oreans_base
{
public:
	bool is_signature(instruction_container& vm_entrance);
	bool devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_entrance);
};

#endif

```

`TDE/dolphin.cpp`:

```cpp
#include "dolphin.hpp"

#include <idp.hpp>

dolphin::dolphin()
	: wild(this->context)
{

}

bool dolphin::is_signature(instruction_container& vm_entrance)
{
	msg("DOLPHIN machine identified.\n");
	return true;
}

bool dolphin::devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions)
{
	msg("DOLPHIN machines are currently not supported.\n");
	return false;
}

bool dolphin::parse_initial_handler(instruction_container& instructions)
{
	msg("DOLPHIN attempted to parse key handler.\n");
	return false;
}

```

`TDE/dolphin.hpp`:

```hpp
#ifndef DOLPHIN_HPP_
#define DOLPHIN_HPP_

#include "wild.hpp"

#include "dolphin_handler.hpp"

class dolphin : public wild<dolphin_handler>
{
public:
	dolphin();

public:
	bool is_signature(instruction_container& vm_entrance);
	bool devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions);

private:
	bool parse_initial_handler(instruction_container& instructions);

private:
	wild_context context;
};

#endif

```

`TDE/dolphin_handler.cpp`:

```cpp
#include "dolphin_handler.hpp"

#include <idp.hpp>

dolphin_handler::dolphin_handler(uint16_t index)
	: wild_handler(index)
{

}

bool dolphin_handler::map_handler_specific(instruction_container& instructions, wild_context& context)
{
	msg("Attempting to map specific handler of type DOLPHIN: %04X.\n", this->index);
	return false;
}

```

`TDE/dolphin_handler.hpp`:

```hpp
#ifndef DOLPHIN_HANDLER_HPP_
#define DOLPHIN_HANDLER_HPP_

#include "wild_handler.hpp"

class dolphin_handler : public wild_handler
{
public:
	dolphin_handler(uint16_t index);

private:
	bool map_handler_specific(instruction_container& instructions, wild_context& context);
};

#endif

```

`TDE/eagle.cpp`:

```cpp
#include "eagle.hpp"

#include <idp.hpp>

bool eagle::is_signature(instruction_container& vm_entrance)
{
	msg("EAGLE machine identified.\n");
	return true;
}

bool eagle::devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions)
{
	msg("EAGLE machines are currently not supported.\n");
	return false;
}

```

`TDE/eagle.hpp`:

```hpp
#ifndef EAGLE_HPP_
#define EAGLE_HPP_

#include "wild_hybrid_base.hpp"

#include "fish.hpp"
#include "dolphin.hpp"

class eagle : public wild_hybrid_base<fish, dolphin>
{
public:
	bool is_signature(instruction_container& vm_entrance);
	bool devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions);
};

#endif

```

`TDE/fish.cpp`:

```cpp
#include "fish.hpp"

#include <idp.hpp>

fish::fish()
	: wild(this->context)
{

}

bool fish::is_signature(instruction_container& vm_entrance)
{
	msg("FISH machine identified.\n");
	return true;
}

bool fish::parse_initial_handler(instruction_container& instructions)
{
	static const ud_size operand_sizes[] = 
	{
		UD_SIZE_DWORD,	UD_SIZE_DWORD,	UD_SIZE_DWORD,	UD_SIZE_DWORD,
		UD_SIZE_DWORD,	UD_SIZE_WORD,	UD_SIZE_BYTE,	UD_SIZE_DWORD
	};

	if (instructions.size() < _countof(operand_sizes))
		return false;

	for (std::size_t i = 0; i < _countof(operand_sizes); i++)
	{
		/* 0: mov [ebp+xx],0x00 */
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_MEM, operand_sizes[i]) &&
			instructions.at(i).is_operand_base(0, UD_R_EBP) &&
			instructions.at(i).has_operand_index_not(0) &&
			instructions.at(i).has_operand_scale_not(0) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM) &&
			instructions.at(i).is_operand_data(1, 0))
		{
			this->context.add_key(instructions.at(i).get_operand_data(0));
		}
		else
		{
			return false;
		}
	}

	return true;
}

bool fish::update_argument_data()
{
	if (!this->context.fish_operands[0].is_found ||
		!this->context.fish_operands[1].is_found)
	{
		return false;
	}
	
	for (std::size_t i = 0; i < this->handlers.size(); i++)
	{
		if (!this->handlers.at(i).update_argument_data(this->context))
			return false;
	}

	return true;
}

```

`TDE/fish.hpp`:

```hpp
#ifndef FISH_HPP_
#define FISH_HPP_

#include "wild.hpp"
#include "fish_context.hpp"
#include "fish_handler.hpp"

class Fish : public Wild<FishHandler>
{
public:
    Fish() {}

    bool isSignature(InstructionContainer& vmEntrance);
    
private:
    bool parseInitialHandler(InstructionContainer& instructions);
    bool updateArgumentData();

private:
    FishContext context;
};

#endif

```

`TDE/fish_context.cpp`:

```cpp
#include "fish_context.hpp"

void fish_context::clear()
{
    wild_context::clear();

    std::fill(std::begin(fish_operands), std::end(fish_operands), FishOperand{});

    initialized_push_pop_mnemonics = false;
    initialized_unary_mnemonics = false;
    initialized_binary_mnemonics = false;
}

```

`TDE/fish_context.hpp`:

```hpp
#ifndef FISH_CONTEXT_HPP_
#define FISH_CONTEXT_HPP_

#include "wild_context.hpp"

class fish_context : public wild_context
{
public:
    fish_context() : initialized_push_pop_mnemonics(false),
                     initialized_unary_mnemonics(false),
                     initialized_binary_mnemonics(false) {}

    void clear();

    class FishOperand
    {
    public:
        bool is_found;          // Still no idea what this is
        uint16_t operand_data;  // Still no idea what this is
        uint16_t operand_info;  // Still no idea what this is
    };

    FishOperand fish_operands[2];

private:
    bool initialized_push_pop_mnemonics;
    bool initialized_unary_mnemonics;
    bool initialized_binary_mnemonics;
};

#endif

```

`TDE/fish_handler.cpp`:

```cpp
#include "fish_handler.hpp"
#include "fish_handler_types.hpp"

#include "instruction_emulator.hpp"

#include <idp.hpp>

#define operand_prefix 0x66

fish_handler::fish_handler(uint16_t index)
	: wild_handler(index)
{

}

bool fish_handler::update_argument_data(fish_context& context)
{
	if (this->id != WILD_HANDLER_INVALID)
	{
		for (std::size_t i = 0; i < this->subhandlers.size() && i < this->x2.size(); i++)
		{
			if (this->subhandlers.at(i).first == FISH_SUBHANDLER_LOAD_OPERAND_DATA)
			{
				if (this->x2.at(i).first == context.fish_operands[0].operand_data)
					this->x2.at(i).first = 0;
				else if (this->x2.at(i).first == context.fish_operands[1].operand_data)
					this->x2.at(i).first = 1;
				else
				{
					msg("Failed parsing argument data at %04X (%04X) with arg: %08X\n", this->id, this->index, this->x2.at(i).first);
					return false;
				}
			}
			else if (this->subhandlers.at(i).first == FISH_SUBHANDLER_LOAD_OPERAND_INFO)
			{
				if (this->x2.at(i).first == context.fish_operands[0].operand_info)
					this->x2.at(i).first = 0;
				else if (this->x2.at(i).first == context.fish_operands[1].operand_info)
					this->x2.at(i).first = 1;
				else
				{
					msg("Failed parsing argument data at %04X (%04X) with arg: %08X\n", this->id, this->index, this->x2.at(i).first);
					return false;
				}
			}
		}
	}

	return true;
}

bool fish_handler::map_handler_specific(instruction_container& instructions, wild_context& context)
{
	try
	{
		return this->map_handler_fish(instructions, dynamic_cast<fish_context&>(context));
	}
	catch (std::bad_cast const& e)
	{
		msg("Exception: %s\n", e.what());
	}

	return false;
}

bool fish_handler::map_handler_fish(instruction_container& instructions, fish_context& context)
{
	if (!this->map_handler_call(instructions, context))
	{
		std::size_t offset = 0;

		while (this->map_subhandler(instructions, context, offset) &&
			this->subhandlers.back().first != FISH_SUBHANDLER_LOAD_STORE)
		{
			offset += this->subhandlers.back().second;
		}

		uint16_t subhandler_counter[FISH_SUBHANDLER_COUNT];
		memset(subhandler_counter, 0, sizeof(subhandler_counter));

		for (std::size_t i = 0; i < this->subhandlers.size(); i++)
		{
			if (this->subhandlers.at(i).first < FISH_SUBHANDLER_COUNT)
				subhandler_counter[this->subhandlers.at(i).first]++;
		}

		if (this->map_handler_internal_0000(instructions, context, subhandler_counter) ||
			this->map_handler_internal_0001(instructions, context, subhandler_counter) ||
			this->map_handler_internal_0002(instructions, context, subhandler_counter) ||
			this->map_handler_internal_0003(instructions, context, subhandler_counter) ||
			this->map_handler_internal_0004(instructions, context, subhandler_counter))
		{
			if (this->decrypt_fish_data(instructions, context))
				return true;
		}
		
		msg("[CodeDevirtualizer] Failed to either map- or decrypt handler data for handler %04X (%04X) of type fish.\n", this->index, this->id);
	}
	
	return true;
}

bool fish_handler::map_handler_call(instruction_container& instructions, wild_context& context)
{
	if (instructions.bounds(0, 20) &&
		instructions.at(0).is_mnemonic(UD_Imov) &&
		instructions.at(1).is_mnemonic(UD_Iadd) &&
		instructions.at(2).is_mnemonic(UD_Imov) &&
		instructions.at(3).is_mnemonic(UD_Icmp) &&
		instructions.at(4).is_mnemonic(UD_Ijnz) &&
		instructions.at(5).is_mnemonic(UD_Imov) &&
		instructions.at(6).is_mnemonic(UD_Iadd) &&
		instructions.at(7).is_mnemonic(UD_Imov) &&
		instructions.at(8).is_mnemonic(UD_Iadd) &&
		instructions.at(9).is_mnemonic(UD_Imov) &&
		instructions.at(10).is_mnemonic(UD_Iadd) &&
		instructions.at(11).is_mnemonic(UD_Imov) &&
		instructions.at(12).is_mnemonic(UD_Iadd) &&
		instructions.at(13).is_mnemonic(UD_Imov) &&
		instructions.at(14).is_mnemonic(UD_Icmp) &&
		instructions.at(15).is_mnemonic(UD_Ijz) &&
		instructions.at(16).is_mnemonic(UD_Icmp) &&
		instructions.at(17).is_mnemonic(UD_Ijz) &&
		instructions.at(18).is_mnemonic(UD_Iadd) &&
		instructions.at(19).is_mnemonic(UD_Imov) &&
		instructions.at(20).is_mnemonic(UD_Iadd))
	{
		this->id = WILD_HANDLER_CALL;
		this->opcode_offsets[0] = instructions.at(1).get_loword(1);
		this->opcode_offsets[1] = instructions.at(6).get_loword(1);
		this->opcode_offsets[2] = instructions.at(10).get_loword(1);
		this->opcode_offsets[3] = instructions.at(20).get_loword(1);
		this->opcode_offsets[4] = instructions.at(3).get_loword(1);
		this->opcode_offsets[5] = instructions.at(14).get_loword(1);
		this->opcode_offsets[6] = instructions.at(16).get_loword(1);
		return true;
	}

	return false;
}

bool fish_handler::map_handler_internal_0000(instruction_container& instructions, fish_context& context, uint16_t* subhandler_counts)
{
	if (instructions.size() >= 6 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0000] == 1 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_STORE] == 1 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0004] == 1 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_OPERAND_INFO] == 1 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_OPERAND_DATA] == 1 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_MNEMONIC] == 1)
	{
		this->id = FISH_HANDLER_PUSH_POP;

		if (!context.fish_operands[0].is_found)
		{
			for (std::size_t i = 0, offset = 0; i < this->subhandlers.size(); i++)
			{
				if (this->subhandlers.at(i).first == FISH_SUBHANDLER_LOAD_OPERAND_INFO)
				{
					if (instructions.bounds(offset, 9))
						context.fish_operands[0].operand_info = instructions.at(offset + 9).get_operand_data<uint16_t>(0);
				}
				else if (this->subhandlers.at(i).first == FISH_SUBHANDLER_LOAD_OPERAND_DATA)
				{
					if (instructions.bounds(offset, 5))
						context.fish_operands[0].operand_data = instructions.at(offset + 5).get_operand_data<uint16_t>(0);
				}

				offset += this->subhandlers.at(i).second;
			}

			context.fish_operands[0].is_found = true;
		}

		return true;
	}

	return false;
}

bool fish_handler::map_handler_internal_0001(instruction_container& instructions, fish_context& context, uint16_t* subhandler_counts)
{
	std::size_t index = 10;

	if (instructions.size() >= 5 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0000] == 1 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0001] == 0 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_STORE] == 0 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0004] == 1 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0005] == 0 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_OPERAND_INFO] == 1 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_OPERAND_DATA] == 1 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_MNEMONIC] == 1 &&
		instructions.find_mnemonic_index(UD_Ipushfd, index))
	{
		this->id = FISH_HANDLER_COMMON_UNARY_OPERATION;
		return true;
	}

	return false;
}
	
bool fish_handler::map_handler_internal_0002(instruction_container& instructions, fish_context& context, uint16_t* subhandler_counts)
{
	if (instructions.size() >= 10 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0000] == 1 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0001] == 1 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_STORE] == 0 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0004] == 1 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0005] == 1 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_OPERAND_INFO] == 2 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_OPERAND_DATA] == 2 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_MNEMONIC] == 1)
	{
		this->id = FISH_HANDLER_COMMON_BINARY_OPERATION;
		
		if (context.fish_operands[0].is_found && !context.fish_operands[1].is_found)
		{
			for (std::size_t i = 0, offset = 0; i < this->subhandlers.size(); i++)
			{
				if (this->subhandlers.at(i).first == FISH_SUBHANDLER_LOAD_OPERAND_INFO)
				{
					if (instructions.bounds(offset, 9) &&
						instructions.at(offset + 9).is_operand_data_not<uint16_t>(0, context.fish_operands[0].operand_info))
					{
						context.fish_operands[1].operand_info = instructions.at(offset + 9).get_operand_data<uint16_t>(0);
					}
				}
				else if (this->subhandlers.at(i).first == FISH_SUBHANDLER_LOAD_OPERAND_DATA)
				{
					if (instructions.bounds(offset, 5) &&
						instructions.at(offset + 5).is_operand_data_not<uint16_t>(0, context.fish_operands[0].operand_data))
					{
						context.fish_operands[1].operand_data = instructions.at(offset + 5).get_operand_data<uint16_t>(0);
					}
				}

				offset += this->subhandlers.at(i).second;
			}

			context.fish_operands[1].is_found = true;
		}

		return true;
	}

	return false;
}
	
bool fish_handler::map_handler_internal_0003(instruction_container& instructions, fish_context& context, uint16_t* subhandler_counts)
{
	if (instructions.size() >= 2 &&
		subhandler_counts[FISH_SUBHANDLER_ALIGN_REGISTER] == 1 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_OPERAND_DATA] == 1)
	{
		this->id = FISH_HANDLER_ALIGN;
		return true;
	}

	return false;
}
	
bool fish_handler::map_handler_internal_0004(instruction_container& instructions, fish_context& context, uint16_t* subhandler_counts)
{
	if (instructions.size() >= 8 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0000] == 1 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0001] == 0 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0002] == 1 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_STORE] == 0 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0004] == 2 &&
		subhandler_counts[FISH_UNKNOWN_SUBHANDLER_0005] == 0 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_OPERAND_INFO] == 2 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_OPERAND_DATA] == 2 &&
		subhandler_counts[FISH_SUBHANDLER_LOAD_MNEMONIC] == 0)
	{
		this->id = FISH_HANDLER_XCHG;
		return true;
	}

	return false;
}

bool fish_handler::map_subhandler(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	return (this->map_subhandler_0000(instructions, context, offset) ||
		this->map_subhandler_0001(instructions, context, offset) ||
		this->map_subhandler_0002(instructions, context, offset) ||
		this->map_subhandler_0003(instructions, context, offset) ||
		this->map_subhandler_0004(instructions, context, offset) ||
		this->map_subhandler_0005(instructions, context, offset) ||
		this->map_subhandler_0006(instructions, context, offset) ||
		this->map_subhandler_0007(instructions, context, offset) ||
		this->map_subhandler_0008(instructions, context, offset) ||
		this->map_subhandler_0009(instructions, context, offset) ||
		this->map_subhandler_000A(instructions, context, offset));
}

bool fish_handler::map_subhandler_0000(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	const std::size_t subhandler_size = 27;

	if (instructions.bounds(offset, subhandler_size - 1) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 2).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 3).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 4).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 5).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 6).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 7).is_mnemonic(UD_Iand) &&
		instructions.at(offset + 8).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 9).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 10).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 11).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 12).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 13).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 14).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 15).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 16).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 17).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 18).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 19).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 20).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 21).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 22).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 23).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 24).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 25).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 26).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_UNKNOWN_SUBHANDLER_0000, subhandler_size));
		return true;
	}
	
	return false;
}

bool fish_handler::map_subhandler_0001(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	const std::size_t subhandler_size = 24;
	
	if (instructions.bounds(offset, subhandler_size - 1) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 2).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 3).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 4).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 5).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 6).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 7).is_mnemonic(UD_Iand) &&
		instructions.at(offset + 8).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 9).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 10).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 11).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 12).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 13).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 14).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 15).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 16).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 17).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 18).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 19).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 20).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 21).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 22).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 23).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_UNKNOWN_SUBHANDLER_0001, subhandler_size));
		return true;
	}
	else if (instructions.bounds(offset, subhandler_size - 3) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 2).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 3).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 4).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 5).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 6).is_mnemonic(UD_Iand) &&
		instructions.at(offset + 7).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 8).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 9).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 10).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 11).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 12).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 13).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 14).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 15).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 16).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 17).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 18).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 19).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 20).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 21).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_UNKNOWN_SUBHANDLER_0001, subhandler_size - 2));
		return true;
	}
	
	return false;
}

bool fish_handler::map_subhandler_0002(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	const std::size_t subhandler_size = 27;
	
	if (instructions.bounds(offset, subhandler_size - 1) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 2).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 3).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 4).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 5).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 6).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 7).is_mnemonic(UD_Iand) &&
		instructions.at(offset + 8).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 9).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 10).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 11).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 12).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 13).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 14).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 15).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 16).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 17).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 18).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 19).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 20).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 21).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 22).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 23).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 24).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 25).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 26).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_UNKNOWN_SUBHANDLER_0002, subhandler_size));
		return true;
	}
	else if (instructions.bounds(offset, subhandler_size - 3) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 2).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 3).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 4).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 5).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 6).is_mnemonic(UD_Iand) &&
		instructions.at(offset + 7).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 8).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 9).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 10).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 11).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 12).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 13).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 14).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 15).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 16).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 17).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 18).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 19).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 20).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 21).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 22).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 23).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 24).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_UNKNOWN_SUBHANDLER_0002, subhandler_size - 2));
		return true;
	}
	
	return false;
}

bool fish_handler::map_subhandler_0003(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	/*
		decode idk3/idk5 -> $1
		decode key (byte) -> $2
		decode operand size -> $3

		push:
		compare $2 to FISH_MNEMONIC_PUSH (else: skip 'push')
		compare $3 to 0x2 (if: push word $1, else: push dword $1)

		pop:
		compare $2 to FISH_MNEMONIC_POP (else: skip 'pop')
		decode VM_REG -> $1
		compare $3 to 0x2 (if: pop word ptr [$1], else: pop dword ptr [$1])
	*/
	if (instructions.bounds(offset, 3) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 2).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 3).is_mnemonic(UD_Imov))
	{
		std::size_t index = offset + 3;

		ud_type bases[2] = { UD_NONE, UD_NONE };

		for (std::size_t i = 0; i < 2; i++)
		{
			if (instructions.bounds(index) &&
				instructions.at(index).is_mnemonic(UD_Imov) &&
				instructions.at(index).is_operand_type(0, UD_OP_REG))
			{ 
				bases[i] = instructions.at(index++).get_base_type(0);

				while (instructions.bounds(index) &&
					instructions.at(index).is_mnemonic_not(UD_Imov) &&
					instructions.at(index).is_mnemonic_not(UD_Icmp) &&
					instructions.at(index).is_operand_base(0, { bases[0], bases[1] }))
				{
					index++;
				}
			}
		}

		if (instructions.bounds(index, 4) &&
			instructions.at(index).is_mnemonic(UD_Icmp) &&
			instructions.at(index + 1).is_mnemonic(UD_Ijnz) &&
			instructions.at(index + 2).is_mnemonic(UD_Icmp) &&
			instructions.at(index + 3).is_mnemonic(UD_Ijnz) &&
			instructions.at(index + 4).is_mnemonic(UD_Ipush))
		{
			index += 5;
			
			if (instructions.bounds(index) &&
				instructions.at(index).is_mnemonic(UD_Imov) &&
				instructions.at(index).is_operand_type(0, UD_OP_REG))
			{
				ud_type base = instructions.at(index++).get_base_type(0);
				
				while (instructions.bounds(index) &&
					instructions.at(index).is_mnemonic_not(UD_Imov) &&
					instructions.at(index).is_mnemonic_not(UD_Icmp) &&
					instructions.at(index).is_operand_base(0, base))
				{
					index++;
				}
			}
			
			if (instructions.bounds(index, 6) &&
				instructions.at(index).is_mnemonic(UD_Icmp) &&
				instructions.at(index + 1).is_mnemonic(UD_Ijnz) &&
				instructions.at(index + 2).is_mnemonic(UD_Imov) &&
				instructions.at(index + 3).compare_mnemonic(false, false, true) &&
				instructions.at(index + 4).is_mnemonic(UD_Icmp) &&
				instructions.at(index + 5).is_mnemonic(UD_Ijnz) &&
				instructions.at(index + 6).is_mnemonic(UD_Ipop))
			{
				this->subhandlers.push_back(std::make_pair(FISH_SUBHANDLER_LOAD_STORE, index + 7));
				return true;
			}
		}
	}

	return false;
}

bool fish_handler::map_subhandler_0004(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	const std::size_t subhandler_size = 16;
	
	if (instructions.bounds(offset, subhandler_size - 1) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 2).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 3).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 4).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 5).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 6).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 7).is_mnemonic(UD_Iand) &&
		instructions.at(offset + 8).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 9).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 10).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 11).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 12).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 13).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 14).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 15).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_UNKNOWN_SUBHANDLER_0004, subhandler_size));
		return true;
	}
	else if (instructions.bounds(offset, subhandler_size - 3) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 2).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 3).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 4).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 5).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 6).is_mnemonic(UD_Iand) &&
		instructions.at(offset + 7).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 8).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 9).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 10).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 11).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 12).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 13).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_UNKNOWN_SUBHANDLER_0004, subhandler_size - 2));
		return true;
	}
	
	return false;
}

bool fish_handler::map_subhandler_0005(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	const std::size_t subhandler_size = 13;
	
	if (instructions.bounds(offset, subhandler_size - 1) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 2).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 3).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 4).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 5).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 6).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 7).is_mnemonic(UD_Iand) &&
		instructions.at(offset + 8).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 9).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 10).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 11).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 12).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_UNKNOWN_SUBHANDLER_0005, subhandler_size));
		return true;
	}
	else if (instructions.bounds(offset, subhandler_size - 3) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 2).is_mnemonic(UD_Icmp) &&
		instructions.at(offset + 3).is_mnemonic(UD_Ijnz) &&
		instructions.at(offset + 4).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 5).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 6).is_mnemonic(UD_Iand) &&
		instructions.at(offset + 7).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 8).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 9).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 10).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_UNKNOWN_SUBHANDLER_0005, subhandler_size - 2));
		return true;
	}
	
	return false;
}

bool fish_handler::map_subhandler_0006(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	const std::size_t subhandler_size = 11;
	
	/* 
		read opcode (byte) -> $1
		encode (($1 & 0xF0) >> 4) -> idk4/idk6	; operand type (1 = register, 2 = memory, 3 = immediate)
		encode ($1 & 0xF) -> 0x70/0x3A			; operand size (1 = byte, 2 = word, 3 = dword)
	*/
	if (instructions.bounds(offset, subhandler_size - 1) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 2).is_mnemonic(UD_Imovzx) &&
		instructions.at(offset + 3).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 4).is_mnemonic(UD_Iand) &&
		instructions.at(offset + 5).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 6).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 7).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 8).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 9).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 10).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_SUBHANDLER_LOAD_OPERAND_INFO, subhandler_size));
		return true;
	}
	
	return false;
}

bool fish_handler::map_subhandler_0007(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	const std::size_t subhandler_size = 7;
	
	/*
		decode idk3/idk5 -> $1
		and $1,0xFFFF
		add $1,VM_CONTEXT
		add dword ptr [$1],imagebase
	*/
	if (instructions.bounds(offset, subhandler_size - 1) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 2).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 3).is_mnemonic(UD_Iand) &&
		instructions.at(offset + 4).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 5).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 5).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
		instructions.at(offset + 5).is_operand_data(1, context.vm_imagebase_offset) &&
		instructions.at(offset + 6).is_mnemonic(UD_Iadd))
	{
		this->subhandlers.push_back(std::make_pair(FISH_SUBHANDLER_ALIGN_REGISTER, subhandler_size));
		return true;
	}
	
	return false;
}

bool fish_handler::map_subhandler_0008(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	const std::size_t subhandler_size = 6;
	
	/*
		read opcode (dword) -> $1
		encode $1 -> idk3/idk5
	*/
	if (instructions.bounds(offset, subhandler_size - 2) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 2).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 3).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 4).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_SUBHANDLER_LOAD_OPERAND_DATA, subhandler_size - 1));
		return true;
	}
	else if (instructions.bounds(offset, subhandler_size - 1) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 1).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 2).is_mnemonic(UD_Imov) &&
		instructions.at(offset + 3).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 4).compare_mnemonic(false, false, true) &&
		instructions.at(offset + 5).is_mnemonic(UD_Imov))
	{
		this->subhandlers.push_back(std::make_pair(FISH_SUBHANDLER_LOAD_OPERAND_DATA, subhandler_size));
		return true;
	}
	
	return false;
}

bool fish_handler::map_subhandler_0009(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	const std::size_t subhandler_size = 3;

	/*
		read opcode (byte) -> $1
		encode $1 -> key (byte)
	*/
	if (instructions.bounds(offset, subhandler_size - 1) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		context.is_opcode_access_instruction(instructions.at(offset)) &&
		instructions.at(offset + 1).is_mnemonic(UD_Iadd) &&
		instructions.at(offset + 2).is_mnemonic(UD_Imovzx) &&
		instructions.at(offset + 2).is_operand_type(1, UD_OP_MEM, UD_SIZE_BYTE))
	{
		this->subhandlers.push_back(std::make_pair(FISH_SUBHANDLER_LOAD_MNEMONIC, subhandler_size));
		return true;
	}
	
	return false;
}

bool fish_handler::map_subhandler_000A(instruction_container& instructions, fish_context& context, std::size_t& offset)
{
	const std::size_t subhandler_size = 1;

	/* 0: mov byte ptr [ebp+xx],0x00 */
	if (instructions.bounds(offset, subhandler_size - 1) &&
		instructions.at(offset).is_mnemonic(UD_Imov) &&
		instructions.at(offset).is_operand_type(0, UD_OP_MEM, UD_SIZE_BYTE) &&
		instructions.at(offset).is_operand_base(0, UD_R_EBP) &&
		instructions.at(offset).has_operand_index_not(0) &&
		instructions.at(offset).has_operand_scale_not(0) &&
		instructions.at(offset).is_operand_type(1, UD_OP_IMM, UD_SIZE_BYTE) &&
		instructions.at(offset).is_operand_data(1, 0))
	{
		this->subhandlers.push_back(std::make_pair(FISH_SUBHANDLER_RESET_INTERNAL_STATE, subhandler_size));
		return true;
	}
	
	return false;
}

bool fish_handler::decrypt_default_data(instruction_container& instructions, wild_context& context)
{
	return true;
}

bool fish_handler::decrypt_fish_data(instruction_container& instructions, fish_context& context)
{
	for (std::size_t i = 0, offset = 0, push_pop_subhandler_offset = 0, parameter_count = 0;; i++)
	{
		if (i >= this->subhandlers.size())
		{
			if (this->id == FISH_HANDLER_PUSH_POP)
				return this->parse_push_pop_mnemonics(instructions, context, push_pop_subhandler_offset);
			else if (this->id == FISH_HANDLER_COMMON_UNARY_OPERATION)
				return this->parse_unary_operation_mnemonics(instructions, context, offset);
			else if (this->id == FISH_HANDLER_COMMON_BINARY_OPERATION)
				return this->parse_binary_operation_mnemonics(instructions, context, offset);
			else
				return true;
		}
		else
		{
			switch (this->subhandlers.at(i).first)
			{
			case FISH_UNKNOWN_SUBHANDLER_0000:
			case FISH_UNKNOWN_SUBHANDLER_0001:
			case FISH_UNKNOWN_SUBHANDLER_0002:
				this->opcode_offsets[parameter_count++] = instructions.at(offset + 2).get_loword(1);
				this->x2.push_back(std::make_pair(0xFF, instructions.at(offset + 2).get_index()));
				break;

			case FISH_SUBHANDLER_LOAD_STORE:
				this->opcode_offsets[parameter_count++] = instructions.at(offset + 4).get_loword(1);
				this->x2.push_back(std::make_pair(0xFF, instructions.at(offset + 4).get_index()));
				push_pop_subhandler_offset = offset;
				break;

			case FISH_UNKNOWN_SUBHANDLER_0004:
			case FISH_UNKNOWN_SUBHANDLER_0005:
				this->opcode_offsets[parameter_count++] = instructions.at(offset + 2).get_loword(1);
				this->x2.push_back(std::make_pair(0xFF, instructions.at(offset + 2).get_index()));
				break;

			case FISH_SUBHANDLER_LOAD_OPERAND_INFO:
				this->opcode_offsets[parameter_count++] = instructions.at(offset + 1).get_loword(1);
				this->x2.push_back(std::make_pair(instructions.at(offset + 9).get_operand_data<uint8_t>(0), instructions.at(offset + 2).get_index()));
				break;

			case FISH_SUBHANDLER_ALIGN_REGISTER:
				this->opcode_offsets[parameter_count++] = instructions.at(offset + 1).get_loword(1);
				this->x2.push_back(std::make_pair(0xFF, instructions.at(offset + 2).get_index()));
				break;

			case FISH_SUBHANDLER_LOAD_OPERAND_DATA:
				this->opcode_offsets[parameter_count++] = instructions.at(offset + 1).get_loword(1);
				this->x2.push_back(std::make_pair(instructions.at(offset + (this->subhandlers.at(i).second - 1)).get_operand_data<uint8_t>(0), instructions.at(offset + 2).get_index()));
				//this->x2.push_back(std::make_pair(instructions.at(offset + 5).get_operand_data<uint8_t>(0), instructions.at(offset + 2).get_index()));
				break;

			case FISH_SUBHANDLER_LOAD_MNEMONIC:
				this->opcode_offsets[parameter_count++] = instructions.at(offset + 1).get_loword(1);
				this->x2.push_back(std::make_pair(0xFF, instructions.at(offset + 2).get_index()));
				break;

			case FISH_SUBHANDLER_RESET_INTERNAL_STATE:
				this->opcode_offsets[parameter_count++] = instructions.at(offset).get_loword(1);
				this->x2.push_back(std::make_pair(0x00, instructions.at(offset).get_index()));
				break;

			default:
				return false;
			}

			offset += this->subhandlers.at(i).second;
		}
	}

	return false;
}

bool fish_handler::parse_push_pop_mnemonics(instruction_container& instructions, fish_context& context, std::size_t index)
{
	ud_instruction mnemonic_key_instruction;
	
	if (!this->find_mnemonic_key_read_instruction(instructions, context, index, mnemonic_key_instruction))
		return false;
	
	/* 0: ___ reg,imm8 */
	while (instructions.bounds(++index) &&
		instructions.at(index).is_mnemonic_not(UD_Icmp))
	{
		if (instructions.at(index).compare_mnemonic(false, false, true) &&
			instructions.at(index).is_operand_type(0, UD_OP_REG) &&
			instructions.at(index).is_operand_base(0, mnemonic_key_instruction, 0) &&
			instructions.at(index).is_operand_type(1, UD_OP_IMM, UD_SIZE_BYTE))
		{
			this->mnemonic_key_decoders.push_back(std::make_pair(instructions.at(index).get_mnemonic(), instructions.at(index).get_operand_data<uint8_t>(1)));
		}
	}
	
	if (instructions.at(index).is_mnemonic(UD_Icmp) &&
		instructions.at(index).is_operand_base(0, mnemonic_key_instruction, 0))
	{
		if (!context.initialized_push_pop_mnemonics)
		{
			if (instructions.at(index).is_operand_data(1, 0))
			{
				context.set_mnemonic(this->mnemonic_key_decoders.back().second, UD_Ipush);
				this->mnemonic_key_decoders.pop_back();
				
				for (int i = 0; i < 2; i++)
				{
					if (!instructions.find_mnemonic_index(UD_Icmp, ++index))
						return false;
				}
				
				context.set_mnemonic(instructions.at(index - 1).get_operand_data<uint8_t>(1), UD_Ipop);
			}
			else
			{
				context.set_mnemonic(instructions.at(index).get_operand_data(1), UD_Ipush);

				for (int i = 0; i < 2; i++)
				{
					if (!instructions.find_mnemonic_index(UD_Icmp, ++index))
						return false;
				}
				
				context.set_mnemonic(instructions.at(index).get_operand_data(1), UD_Ipop);
			}
			
			context.initialized_push_pop_mnemonics = true;
		}
		else if (instructions.at(index).is_operand_data(1, 0))
		{
			this->mnemonic_key_decoders.pop_back();
		}

		return true;
	}
	
	return false;
}

bool fish_handler::parse_unary_operation_mnemonics(instruction_container& instructions, fish_context& context, std::size_t index)
{
	ud_instruction mnemonic_key_instruction;

	if (context.initialized_unary_mnemonics)
	{
		if (!this->find_mnemonic_key_read_instruction(instructions, context, index, mnemonic_key_instruction))
			return false;
	
		/* 0: ___ reg,imm8 */
		while (instructions.bounds(++index) &&
			instructions.at(index).is_mnemonic_not(UD_Icmp))
		{
			if (instructions.at(index).compare_mnemonic(false, false, true) &&
				instructions.at(index).is_operand_type(0, UD_OP_REG) &&
				instructions.at(index).is_operand_base(0, mnemonic_key_instruction, 0) &&
				instructions.at(index).is_operand_type(1, UD_OP_IMM, UD_SIZE_BYTE))
			{
				this->mnemonic_key_decoders.push_back(std::make_pair(instructions.at(index).get_mnemonic(), instructions.at(index).get_operand_data<uint8_t>(1)));
			}
		}

		if (instructions.at(index).is_mnemonic(UD_Icmp))
		{
			if (instructions.at(index).is_operand_data(1, 0))
				this->mnemonic_key_decoders.pop_back();

			return true;
		}
	}
	else
	{
		for (std::size_t i = 0; i < 4; i++)
		{
			if (!this->find_mnemonic_key_read_instruction(instructions, context, index, mnemonic_key_instruction))
				return false;
	
			this->mnemonic_key_decoders.clear();

			/* 0: ___ reg,imm8 */
			while (instructions.bounds(++index) &&
				instructions.at(index).is_mnemonic_not(UD_Icmp))
			{
				if (instructions.at(index).compare_mnemonic(false, false, true) &&
					instructions.at(index).is_operand_type(0, UD_OP_REG) &&
					instructions.at(index).is_operand_base(0, mnemonic_key_instruction, 0) &&
					instructions.at(index).is_operand_type(1, UD_OP_IMM, UD_SIZE_BYTE))
				{
					this->mnemonic_key_decoders.push_back(std::make_pair(instructions.at(index).get_mnemonic(), instructions.at(index).get_operand_data<uint8_t>(1)));
				}
			}
			
			if (instructions.at(index).is_mnemonic_not(UD_Icmp))
				return false;
			
			uint8_t mnemonic_id = 0;
			
			if (instructions.at(index).is_operand_data(1, 0))
			{
				mnemonic_id = this->mnemonic_key_decoders.back().second;
				this->mnemonic_key_decoders.pop_back();
			}
			else
			{
				mnemonic_id = instructions.at(index).get_operand_data<uint8_t>(1);
			}
			
			if (!this->parse_handler_mnemonic(instructions, context, ++index, mnemonic_id))
				return false;
		}

		context.initialized_unary_mnemonics = true;
		return true;
	}

	return false;
}

bool fish_handler::parse_binary_operation_mnemonics(instruction_container& instructions, fish_context& context, std::size_t index)
{
	ud_instruction mnemonic_key_instruction;

	if (context.initialized_binary_mnemonics)
	{
		if (!this->find_mnemonic_key_read_instruction(instructions, context, index, mnemonic_key_instruction))
			return false;
	
		/* 0: ___ reg,imm8 */
		while (instructions.bounds(++index) &&
			instructions.at(index).is_mnemonic_not(UD_Icmp))
		{
			if (instructions.at(index).compare_mnemonic(false, false, true) &&
				instructions.at(index).is_operand_type(0, UD_OP_REG) &&
				instructions.at(index).is_operand_base(0, mnemonic_key_instruction, 0) &&
				instructions.at(index).is_operand_type(1, UD_OP_IMM, UD_SIZE_BYTE))
			{
				this->mnemonic_key_decoders.push_back(std::make_pair(instructions.at(index).get_mnemonic(), instructions.at(index).get_operand_data<uint8_t>(1)));
			}
		}

		if (instructions.at(index).is_mnemonic(UD_Icmp))
		{
			if (instructions.at(index).is_operand_data(1, 0))
				this->mnemonic_key_decoders.pop_back();

			return true;
		}
	}
	else
	{
		for (std::size_t i = 0; i < 17; i++)
		{
			if (!this->find_mnemonic_key_read_instruction(instructions, context, index, mnemonic_key_instruction))
				return false;
	
			this->mnemonic_key_decoders.clear();

			/* 0: ___ reg,imm8 */
			while (instructions.bounds(++index) &&
				instructions.at(index).is_mnemonic_not(UD_Icmp))
			{
				if (instructions.at(index).compare_mnemonic(false, false, true) &&
					instructions.at(index).is_operand_type(0, UD_OP_REG) &&
					instructions.at(index).is_operand_base(0, mnemonic_key_instruction, 0) &&
					instructions.at(index).is_operand_type(1, UD_OP_IMM, UD_SIZE_BYTE))
				{
					this->mnemonic_key_decoders.push_back(std::make_pair(instructions.at(index).get_mnemonic(), instructions.at(index).get_operand_data<uint8_t>(1)));
				}
			}
			
			if (instructions.at(index).is_mnemonic_not(UD_Icmp))
				return false;
			
			uint8_t mnemonic_id = 0;
			
			if (instructions.at(index).is_operand_data(1, 0))
			{
				mnemonic_id = this->mnemonic_key_decoders.back().second;
				this->mnemonic_key_decoders.pop_back();
			}
			else
			{
				mnemonic_id = instructions.at(index).get_operand_data<uint8_t>(1);
			}
			
			if (!this->parse_handler_mnemonic(instructions, context, ++index, mnemonic_id))
				return false;
		}

		context.initialized_binary_mnemonics = true;
		return true;
	}

	return false;
}

bool fish_handler::parse_handler_mnemonic(instruction_container& instructions, fish_context& context, std::size_t& index, uint8_t offset)
{
	std::size_t temp_index = index;
	
	/* 0: jnz ___ */
	if (!instructions.find_mnemonic_index(UD_Ijnz, temp_index))
		return false;
	
	/* 0: pushfd */
	if (!instructions.find_mnemonic_index(UD_Ipushfd, temp_index))
		return false;

	index = temp_index;
	
	if (this->id == FISH_HANDLER_COMMON_UNARY_OPERATION && 
		instructions.at(index - 2).is_mnemonic(UD_Inot) &&
		instructions.at(index - 1).is_mnemonic(UD_Icmp))
	{
		context.set_mnemonic(offset, UD_Inot);
		return true;
	}
	else if (this->id == FISH_HANDLER_COMMON_BINARY_OPERATION && 
		instructions.at(index - 1).is_mnemonic(UD_Iadd))
	{
		if (instructions.at(index - 2).is_mnemonic(UD_Imov) &&
			instructions.at(index - 2).is_operand_type(0, UD_OP_REG) &&
			instructions.at(index - 2).is_operand_base(0, instructions.at(index - 1), 1) &&
			instructions.at(index - 2).is_operand_type(1, UD_OP_REG) &&
			instructions.at(index - 2).is_operand_base(1, instructions.at(index - 1), 0))
		{
			context.set_mnemonic(offset, UD_Imovspecial);
			return true;
		}
		else if (instructions.at(index - 2).is_mnemonic(UD_Imovsx) &&
			instructions.at(index - 2).is_operand_type(0, UD_OP_REG) &&
			instructions.at(index - 2).is_operand_base(0, instructions.at(index - 1), 1) &&
			instructions.at(index - 2).is_operand_type(1, UD_OP_REG) &&
			instructions.at(index - 2).is_operand_base_family(1, instructions.at(index - 1).get_base_type(0)))
		{
			context.set_mnemonic(offset, UD_Imovsx);
			return true;
		}
		else if (instructions.at(index - 2).is_mnemonic(UD_Imovzx) &&
			instructions.at(index - 2).is_operand_type(0, UD_OP_REG) &&
			instructions.at(index - 2).is_operand_base(0, instructions.at(index - 1), 1) &&
			instructions.at(index - 2).is_operand_type(1, UD_OP_REG) &&
			instructions.at(index - 2).is_operand_base_family(1, instructions.at(index - 1).get_base_type(0)))
		{
			context.set_mnemonic(offset, UD_Imovzx);
			return true;
		}
	}
	
	context.set_mnemonic(offset, instructions.at(index - 1).get_mnemonic());
	return true;
}

bool fish_handler::find_mnemonic_key_read_instruction(instruction_container& instructions, fish_context& context, std::size_t& index, ud_instruction& instruction)
{
	for (std::size_t i = index; i < instructions.size(); i++)
	{
		/* 0: mov reg,byte ptr [ebp+xx] */
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG) &&
			instructions.at(i).is_operand_type(1, UD_OP_MEM, UD_SIZE_BYTE) &&
			instructions.at(i).is_operand_base(1, UD_R_EBP) &&
			instructions.at(i).has_operand_index_not(1) &&
			instructions.at(i).has_operand_scale_not(1) &&
			instructions.at(i).is_operand_data(1, context.get_key_offset(FISH_KEY_MNEMONIC)))
		{
			index = i;
			instruction = instructions.at(i);
			return true;
		}
	}

	return false;
}

bool fish_handler::step_handler_specific(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	try
	{
		return this->step_handler_fish(instructions, dynamic_cast<fish_context&>(context), opcode);
	}
	catch (std::bad_cast const& e)
	{
		msg("[CodeDevirtualizer] Exception: %s\n", e.what());
	}

	return false;
}

bool fish_handler::step_handler_fish(instruction_container& instructions, fish_context& context, opcode_reader& opcode)
{
	switch (this->id)
	{
	case WILD_HANDLER_CALL:
		return this->step_handler_call(instructions, context, opcode);

	case FISH_HANDLER_PUSH_POP:
		return this->step_handler_push_pop(instructions, context, opcode);

	case FISH_HANDLER_COMMON_UNARY_OPERATION:
		return this->step_handler_common_unary_operation(instructions, context, opcode);

	case FISH_HANDLER_COMMON_BINARY_OPERATION:
		return this->step_handler_common_binary_operation(instructions, context, opcode);

	case FISH_HANDLER_ALIGN:
		return this->step_handler_align(instructions, context, opcode);

	case FISH_HANDLER_XCHG:
		return this->step_handler_xchg(instructions, context, opcode);

	default:
		break;
	}

	return false;
}

bool fish_handler::step_handler_call(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t type = opcode.read<uint8_t>(this->opcode_offsets[0]);
	
	context.step_params[0] = type;
	
	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Icall);

	if (type == this->opcode_offsets[4])
	{
		uint32_t offset = opcode.read<uint32_t>(this->opcode_offsets[1]);

		instruction.set_operand_type(0, UD_OP_IMM, UD_SIZE_DWORD);
		instruction.set_operand_data(0, context.vm_imagebase + offset);
	}
	else if (type == this->opcode_offsets[5])
	{
		uint32_t register_id = opcode.read<uint8_t>(this->opcode_offsets[1]);

		instruction.set_operand_type(0, UD_OP_REG, UD_SIZE_DWORD);
		instruction.set_operand_base(0, context.get_vm_register(register_id));
	}
	else if (type == this->opcode_offsets[6])
	{
		uint32_t register_id = opcode.read<uint8_t>(this->opcode_offsets[1]);

		instruction.set_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD);
		instruction.set_operand_base(0, context.get_vm_register(register_id));
	}

	instructions.push_back(instruction);

	/* Decode return address and create label */
	uint32_t return_address = context.vm_imagebase + opcode.read<uint32_t>(this->opcode_offsets[3]);
	
	if (!return_address)
		return false;

	ud_instruction return_instruction(return_address);
	return_instruction.set_input(context.to_segment(return_address));
	
	instruction_container return_instructions;
	
	for (std::size_t i = 0; i < 2; i++)
	{
		if (!return_instructions.decode_assembly(return_instruction))
			return false;

		if (return_instruction.is_mnemonic_not(UD_Ipush) ||
			return_instruction.is_operand_type_not(0, UD_OP_IMM, UD_SIZE_DWORD))
		{
			return false;
		}
	}
	
	context.create_label(context.vm_imagebase + return_instructions.at(0).get_operand_data(0), return_instructions.at(1).get_operand_data(0));
	return true;
}

bool fish_handler::step_handler_push_pop(instruction_container& instructions, fish_context& context, opcode_reader& opcode)
{
	uint32_t key_data = 0;

	if (this->key_accessors.size() > 0 && this->key_accessors.at(0).index < 3)
		this->perform_key_sequence(context, 0, this->x2.at(0).second, &key_data);
	
	uint32_t operand_info = 0;
	uint32_t operand_data = 0;

	for (std::size_t i = 0; i < this->subhandlers.size(); i++)
	{
		switch (this->subhandlers.at(i).first)
		{
		case 0:
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			break;

		case 3:
			this->perform_key_sequence(context, this->x2.at(i).second, this->flow_data_index, &key_data);
			break;

		case 4:
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			break;
			
		case FISH_SUBHANDLER_LOAD_OPERAND_INFO:
			operand_info = opcode.read<uint8_t>(this->opcode_offsets[i]);
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_info);
			break;
			
		case FISH_SUBHANDLER_LOAD_OPERAND_DATA:
			operand_data = opcode.read<uint32_t>(this->opcode_offsets[i]);
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_data);
			break;
			
		case 9:
			key_data = opcode.read<uint8_t>(this->opcode_offsets[i]);
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			break;

		case FISH_SUBHANDLER_RESET_INTERNAL_STATE:
			if ((i + 1) < this->subhandlers.size())
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			else
				this->perform_key_sequence(context, this->x2.at(i).second, this->flow_data_index, &key_data);

			break;

		default:
			break;
		}
	}
	
	context.step_params[0] = context.get_key_data(FISH_KEY_MNEMONIC);

	for (std::size_t i = 0; i < this->mnemonic_key_decoders.size(); i++)
		instruction::emulate(this->mnemonic_key_decoders.at(i).first, UD_SIZE_BYTE, this->mnemonic_key_decoders.at(i).second, &context.step_params[0]);

	context.step_params[1] = operand_info;
	context.step_params[2] = operand_data;

	if (context.current_register_type < 0)
	{
		this->parse_common_instruction(instructions, context, context.current_virtual_opcode,
			context.get_key_data(FISH_KEY_MNEMONIC), operand_info, operand_data, 0, 0);
	}
	else
	{
		ud_type base = static_cast<ud_type>(UD_R_EAX + context.current_register_type--);

		ud_instruction instruction(context.current_virtual_opcode);
		instruction.set_mnemonic(UD_Ipop);
		instruction.set_operand_type(0, UD_OP_REG, UD_SIZE_DWORD);
		instruction.set_operand_base(0, base);

		if (base != UD_R_ESP)
			context.set_vm_register(operand_data, base);

		instructions.push_back(instruction);
	}

	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool fish_handler::step_handler_common_unary_operation(instruction_container& instructions, fish_context& context, opcode_reader& opcode)
{
	uint32_t key_data = 0;

	if (this->key_accessors.size() > 0 && this->key_accessors.at(0).index < 3)
		this->perform_key_sequence(context, 0, this->x2.at(0).second, &key_data);

	uint32_t operand_info = 0;
	uint32_t operand_data = 0;
	
	for (std::size_t i = 0; i < this->subhandlers.size(); i++)
	{
		switch (this->subhandlers.at(i).first)
		{
		case 0:
		case 1:
		case 2:
		case 4:
		case 5:
			if ((i + 1) < this->subhandlers.size())
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			else
				this->perform_key_sequence(context, this->x2.at(i).second, this->flow_data_index, &key_data);

			break;
			
		case FISH_SUBHANDLER_LOAD_OPERAND_INFO:
			operand_info = opcode.read<uint8_t>(this->opcode_offsets[i]);
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_info);
			break;
			
		case FISH_SUBHANDLER_LOAD_OPERAND_DATA:
			operand_data = opcode.read<uint32_t>(this->opcode_offsets[i]);
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_data);
			break;
			
		case 9:
			key_data = opcode.read<uint8_t>(this->opcode_offsets[i]);
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			break;

		case FISH_SUBHANDLER_RESET_INTERNAL_STATE:
			if ((i + 1) < this->subhandlers.size())
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			else
				this->perform_key_sequence(context, this->x2.at(i).second, this->flow_data_index, &key_data);

			break;

		default:
			break;
		}
	}

	context.step_params[0] = context.get_key_data(FISH_KEY_MNEMONIC);

	for (std::size_t i = 0; i < this->mnemonic_key_decoders.size(); i++)
		instruction::emulate(this->mnemonic_key_decoders.at(i).first, UD_SIZE_BYTE, this->mnemonic_key_decoders.at(i).second, &context.step_params[0]);
	
	//this->step_params[0] = this->fish_keys.get_data(FISH_KEY_MNEMONIC);
	//this->perform_immediate_action(static_cast<x86_mnemonic_code>(handler_object.mnemonic_key_decode_mnemonic), OPERAND_SIZE_BYTE, &this->step_params[0], handler_object.mnemonic_key_decode_data);

	context.step_params[1] = operand_info;
	context.step_params[2] = operand_data;
	
	this->parse_common_instruction(instructions, context, context.current_virtual_opcode,
		context.get_key_data(FISH_KEY_MNEMONIC), operand_info, operand_data, 0, 0);

	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool fish_handler::step_handler_common_binary_operation(instruction_container& instructions, fish_context& context, opcode_reader& opcode)
{
	uint32_t key_data = 0;

	if (this->key_accessors.size() > 0 && this->key_accessors.at(0).index < 3)
		this->perform_key_sequence(context, 0, this->x2.at(0).second, &key_data);
	
	uint32_t operand_0_info = 0;
	uint32_t operand_0_data = 0;
	
	uint32_t operand_1_info = 0;
	uint32_t operand_1_data = 0;

	for (std::size_t i = 0; i < this->subhandlers.size(); i++)
	{
		switch (this->subhandlers.at(i).first)
		{
		case 0:
		case 1:
		case 2:
		case 4:
		case 5:
			if ((i + 1) < this->subhandlers.size())
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			else
				this->perform_key_sequence(context, this->x2.at(i).second, this->flow_data_index, &key_data);

			break;
			
		case FISH_SUBHANDLER_LOAD_OPERAND_INFO:
			if (this->x2.at(i).first == 0)
			{
				operand_0_info = opcode.read<uint8_t>(this->opcode_offsets[i]);
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_0_info);
			}
			else if (this->x2.at(i).first == 1)
			{
				operand_1_info = opcode.read<uint8_t>(this->opcode_offsets[i]);
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_1_info);
			}
			
			break;
			
		case FISH_SUBHANDLER_LOAD_OPERAND_DATA:
			if (this->x2.at(i).first == 0)
			{
				operand_0_data = opcode.read<uint32_t>(this->opcode_offsets[i]);
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_0_data);
			}
			else if (this->x2.at(i).first == 1)
			{
				operand_1_data = opcode.read<uint32_t>(this->opcode_offsets[i]);
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_1_data);
			}
			
			break;

		case 9:
			key_data = opcode.read<uint8_t>(this->opcode_offsets[i]);
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			break;
			
		case FISH_SUBHANDLER_RESET_INTERNAL_STATE:
			if ((i + 1) < this->subhandlers.size())
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			else
				this->perform_key_sequence(context, this->x2.at(i).second, this->flow_data_index, &key_data);

			break;

		default:
			break;
		}
	}

	context.step_params[0] = context.get_key_data(FISH_KEY_MNEMONIC);

	for (std::size_t i = 0; i < this->mnemonic_key_decoders.size(); i++)
		instruction::emulate(this->mnemonic_key_decoders.at(i).first, UD_SIZE_BYTE, this->mnemonic_key_decoders.at(i).second, &context.step_params[0]);
	
	//this->step_params[0] = this->fish_keys.get_data(FISH_KEY_MNEMONIC);
	//this->perform_immediate_action(static_cast<x86_mnemonic_code>(handler_object.mnemonic_key_decode_mnemonic), OPERAND_SIZE_BYTE, &this->step_params[0], handler_object.mnemonic_key_decode_data);
	
	context.step_params[1] = operand_0_info;
	context.step_params[2] = operand_0_data;
	context.step_params[3] = operand_1_info;
	context.step_params[4] = operand_1_data;
	
	this->parse_common_instruction(instructions, context, context.current_virtual_opcode, context.get_key_data(FISH_KEY_MNEMONIC), operand_0_info, operand_0_data, operand_1_info, operand_1_data);

	if (instructions.back().is_mnemonic(UD_Imov) &&
		instructions.back().is_operand_type(0, UD_OP_REG, UD_SIZE_BYTE) &&
		instructions.back().is_operand_base(0, UD_R_AL) &&
		instructions.back().is_operand_type(1, UD_OP_REG, UD_SIZE_BYTE) &&
		instructions.back().is_operand_base(1, UD_R_AL))
	{
		instructions.back().set_mnemonic(UD_Inop);
		instructions.back().set_operand_null(0);
		instructions.back().set_operand_null(1);
	}

	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool fish_handler::step_handler_align(instruction_container& instructions, fish_context& context, opcode_reader& opcode)
{
	uint32_t key_data = 0;

	if (this->key_accessors.size() > 0 && this->key_accessors.at(0).index < 3)
		this->perform_key_sequence(context, 0, this->x2.at(0).second, &key_data);
	
	uint32_t register_id = 0;

	for (std::size_t i = 0; i < this->subhandlers.size(); i++)
	{
		switch (this->subhandlers.at(i).first)
		{
		case FISH_SUBHANDLER_ALIGN_REGISTER:
			this->perform_key_sequence(context, this->x2.at(i).second, this->flow_data_index, &key_data);
			break;

		case FISH_SUBHANDLER_LOAD_OPERAND_DATA:
			register_id = opcode.read<uint32_t>(this->opcode_offsets[i]);
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &register_id);
			break;
			
		case FISH_SUBHANDLER_RESET_INTERNAL_STATE:
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			break;

		default:
			break;
		}
	}

	context.step_params[0] = register_id;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Ialign);
	instruction.set_operand_type(0, UD_OP_REG, UD_SIZE_DWORD);
	instruction.set_operand_base(0, context.get_vm_register(register_id));
	instruction.set_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD);
	instruction.set_operand_data(1, context.vm_imagebase);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool fish_handler::step_handler_xchg(instruction_container& instructions, fish_context& context, opcode_reader& opcode)
{
	uint32_t key_data = 0;

	if (this->key_accessors.size() > 0 && this->key_accessors.at(0).index < 3)
		this->perform_key_sequence(context, 0, this->x2.at(0).second, &key_data);
	
	uint32_t operand_0_info = 0;
	uint32_t operand_0_data = 0;
	
	uint32_t operand_1_info = 0;
	uint32_t operand_1_data = 0;
	
	for (std::size_t i = 0; i < this->subhandlers.size(); i++)
	{
		switch (this->subhandlers.at(i).first)
		{
		case 0:
		case 1:
		case 2:
		case 4:
		case 5:
			if ((i + 1) < this->subhandlers.size())
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			else
				this->perform_key_sequence(context, this->x2.at(i).second, this->flow_data_index, &key_data);

			break;
			
		case FISH_SUBHANDLER_LOAD_OPERAND_INFO:
			if (this->x2.at(i).first == 0)
			{
				operand_0_info = opcode.read<uint8_t>(this->opcode_offsets[i]);
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_0_info);
			}
			else if (this->x2.at(i).first == 1)
			{
				operand_1_info = opcode.read<uint8_t>(this->opcode_offsets[i]);
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_1_info);
			}

			break;
			
		case FISH_SUBHANDLER_LOAD_OPERAND_DATA:
			if (this->x2.at(i).first == 0)
			{
				operand_0_data = opcode.read<uint32_t>(this->opcode_offsets[i]);
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_0_data);
			}
			else if (this->x2.at(i).first == 1)
			{
				operand_1_data = opcode.read<uint32_t>(this->opcode_offsets[i]);
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &operand_1_data);
			}
			
			break;

		case 9:
			key_data = opcode.read<uint8_t>(this->opcode_offsets[i]);
			this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			break;
			
		case FISH_SUBHANDLER_RESET_INTERNAL_STATE:
			if ((i + 1) < this->subhandlers.size())
				this->perform_key_sequence(context, this->x2.at(i).second, this->x2.at(i + 1).second, &key_data);
			else
				this->perform_key_sequence(context, this->x2.at(i).second, this->flow_data_index, &key_data);

			break;

		default:
			break;
		}
	}

	context.step_params[0] = UD_Ixchg;

	for (std::size_t i = 0; i < this->mnemonic_key_decoders.size(); i++)
		instruction::emulate(this->mnemonic_key_decoders.at(i).first, UD_SIZE_BYTE, this->mnemonic_key_decoders.at(i).second, &context.step_params[0]);
	
	//this->step_params[0] = UD_Ixchg;
	//this->perform_immediate_action(static_cast<x86_mnemonic_code>(handler_object.mnemonic_key_decode_mnemonic), OPERAND_SIZE_BYTE, &this->step_params[0], handler_object.mnemonic_key_decode_data);
	
	context.step_params[1] = operand_0_info;
	context.step_params[2] = operand_0_data;
	context.step_params[3] = operand_1_info;
	context.step_params[4] = operand_1_data;
	
	this->parse_common_instruction(instructions, context, context.current_virtual_opcode, context.get_key_data(FISH_KEY_MNEMONIC), operand_0_info, operand_0_data, operand_1_info, operand_1_data);

	instructions.back().set_mnemonic(UD_Ixchg);

	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool fish_handler::step_default_sequence(wild_context& context, opcode_reader& opcode)
{
	uint32_t key_data = 0;
	return this->perform_key_sequence(context, 0, this->flow_data_index, &key_data);
}

void fish_handler::parse_common_instruction(instruction_container& instructions, fish_context& context, uint32_t address, uint16_t mnemonic_key_constant, uint8_t operand_0_info, uint32_t operand_0_data, uint8_t operand_1_info, int32_t operand_1_data)
{
	uint32_t mnemonic_id = mnemonic_key_constant;

	for (std::size_t i = 0; i < this->mnemonic_key_decoders.size(); i++)
		instruction::emulate(this->mnemonic_key_decoders.at(i).first, UD_SIZE_BYTE, this->mnemonic_key_decoders.at(i).second, &mnemonic_id);
	
	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(context.get_mnemonic(mnemonic_id));

	uint8_t operand_0_type = static_cast<uint8_t>((operand_0_info >> 4) & 0xF);
	ud_size operand_0_size = static_cast<ud_size>(static_cast<uint8_t>(std::pow(2, 2 + (operand_0_info & 0xF))));

	/* Parse ADDR registers */
	if (instruction.is_mnemonic(UD_Imovspecial))
	{
		instruction.set_mnemonic(UD_Imov);

		if (operand_0_type == FISH_OPERAND_TYPE_REGISTER && context.get_vm_register(operand_0_data) == UD_NONE)
		{
			if (context.register_addr1_id == 0xFFFF)
			{
				context.register_addr1_id = operand_0_data;
				context.set_vm_register(operand_0_data, UD_R_ADDR1);
			}
			else if (context.register_addr2_id == 0xFFFF)
			{
				context.register_addr2_id = operand_0_data;
				context.set_vm_register(operand_0_data, UD_R_ADDR2);
			}
		}
	}

	this->parse_common_operand(instruction, context, 1, operand_1_info, operand_1_data);
	this->parse_common_operand(instruction, context, 0, operand_0_info, operand_0_data);

	instructions.push_back(instruction);
}

void fish_handler::parse_common_operand(ud_instruction& instruction, fish_context& context, std::size_t operand, uint8_t operand_info, uint32_t operand_data)
{
	if (operand_info)
	{
		uint8_t operand_type = static_cast<uint8_t>((operand_info >> 4) & 0xF);
		ud_size operand_size = static_cast<ud_size>(static_cast<uint8_t>(std::pow(2, 2 + (operand_info & 0xF))));
		
		if (operand_type == FISH_OPERAND_TYPE_REGISTER)
		{
			instruction.set_operand_type(operand, UD_OP_REG, operand_size);
			instruction.set_operand_base(operand, context.get_vm_register(operand_data), operand_size);
			
			if (operand_size == UD_SIZE_BYTE && instruction.is_operand_base(operand, UD_NONE))
				instruction.set_operand_base(operand, static_cast<ud_type>(instruction.base_to_size_type(context.get_vm_register(operand_data - 1), operand_size) + (UD_R_AH - UD_R_AL)));
		}
		else if (operand_type == FISH_OPERAND_TYPE_MEMORY)
		{
			instruction.set_operand_type(operand, UD_OP_MEM, operand_size);
			instruction.set_operand_base(operand, context.get_vm_register(operand_data));
		}
		else /* if (operand_type == FISH_OPERAND_TYPE_IMMEDIATE) */
		{
			instruction.set_operand_type(operand, UD_OP_IMM, UD_SIZE_DWORD);
			instruction.set_operand_data(operand, operand_data);
		}

		if (operand_size == UD_SIZE_WORD)
			instruction.pfx_opr = operand_prefix;
	}
}

```

`TDE/fish_handler.hpp`:

```hpp
#ifndef FISH_HANDLER_HPP_
#define FISH_HANDLER_HPP_

#include "wild_handler.hpp"
#include "fish_context.hpp"

class fish_handler : public wild_handler
{
	enum fish_key_types
	{
		FISH_KEY_MNEMONIC = 6,
	};

	enum fish_operand_type
	{
		FISH_OPERAND_TYPE_REGISTER = 0x01,
		FISH_OPERAND_TYPE_MEMORY,
		FISH_OPERAND_TYPE_IMMEDIATE
	};

public:
	fish_handler(uint16_t index);
	
	bool update_argument_data(fish_context& context);

private:
	bool map_handler_specific(instruction_container& instructions, wild_context& context);
	bool map_handler_fish(instruction_container& instructions, fish_context& context);

private:
	bool map_handler_call(instruction_container& instructions, wild_context& context);
	bool map_handler_internal_0000(instruction_container& instructions, fish_context& context, uint16_t* subhandler_counts);
	bool map_handler_internal_0001(instruction_container& instructions, fish_context& context, uint16_t* subhandler_counts);
	bool map_handler_internal_0002(instruction_container& instructions, fish_context& context, uint16_t* subhandler_counts);
	bool map_handler_internal_0003(instruction_container& instructions, fish_context& context, uint16_t* subhandler_counts);
	bool map_handler_internal_0004(instruction_container& instructions, fish_context& context, uint16_t* subhandler_counts);
	
private:
	bool map_subhandler(instruction_container& instructions, fish_context& context, std::size_t& offset);
	
private:
	bool map_subhandler_0000(instruction_container& instructions, fish_context& context, std::size_t& offset);
	bool map_subhandler_0001(instruction_container& instructions, fish_context& context, std::size_t& offset);
	bool map_subhandler_0002(instruction_container& instructions, fish_context& context, std::size_t& offset);
	bool map_subhandler_0003(instruction_container& instructions, fish_context& context, std::size_t& offset);
	bool map_subhandler_0004(instruction_container& instructions, fish_context& context, std::size_t& offset);
	bool map_subhandler_0005(instruction_container& instructions, fish_context& context, std::size_t& offset);
	bool map_subhandler_0006(instruction_container& instructions, fish_context& context, std::size_t& offset);
	bool map_subhandler_0007(instruction_container& instructions, fish_context& context, std::size_t& offset);
	bool map_subhandler_0008(instruction_container& instructions, fish_context& context, std::size_t& offset);
	bool map_subhandler_0009(instruction_container& instructions, fish_context& context, std::size_t& offset);
	bool map_subhandler_000A(instruction_container& instructions, fish_context& context, std::size_t& offset);
	
private:
	bool decrypt_default_data(instruction_container& instructions, wild_context& context);
	bool decrypt_fish_data(instruction_container& instructions, fish_context& context);
	
	bool parse_push_pop_mnemonics(instruction_container& instructions, fish_context& context, std::size_t index);
	bool parse_unary_operation_mnemonics(instruction_container& instructions, fish_context& context, std::size_t index);
	bool parse_binary_operation_mnemonics(instruction_container& instructions, fish_context& context, std::size_t index);
	
	bool parse_handler_mnemonic(instruction_container& instructions, fish_context& context, std::size_t& index, uint8_t offset);
	
	bool find_mnemonic_key_read_instruction(instruction_container& instructions, fish_context& context, std::size_t& index, ud_instruction& instruction);
	
private:
	bool step_handler_specific(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_fish(instruction_container& instructions, fish_context& context, opcode_reader& opcode);
	
private:
	bool step_handler_call(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_push_pop(instruction_container& instructions, fish_context& context, opcode_reader& opcode);
	bool step_handler_common_unary_operation(instruction_container& instructions, fish_context& context, opcode_reader& opcode);
	bool step_handler_common_binary_operation(instruction_container& instructions, fish_context& context, opcode_reader& opcode);
	bool step_handler_align(instruction_container& instructions, fish_context& context, opcode_reader& opcode);
	bool step_handler_xchg(instruction_container& instructions, fish_context& context, opcode_reader& opcode);

private:
	bool step_default_sequence(wild_context& context, opcode_reader& opcode);

	void parse_common_instruction(instruction_container& instructions, fish_context& context, uint32_t address, uint16_t mnemonic_key_constant, 
		uint8_t operand_0_info, uint32_t operand_0_data, uint8_t operand_1_info, int32_t operand_1_data);

	void parse_common_operand(ud_instruction& instruction, fish_context& context, std::size_t operand, uint8_t operand_info, uint32_t operand_data);

public:
	std::vector<std::pair<ud_mnemonic_code, uint8_t>> mnemonic_key_decoders;
	
	std::vector<std::pair<uint32_t, std::size_t>> subhandlers; // xx2 ;
	std::vector<std::pair<uint8_t, std::size_t>> x2;	// x2 ; <idk1, index>
};

#endif

```

`TDE/fish_handler_mnemonics.hpp`:

```hpp
#ifndef FISH_HANDLER_MNEMONICS_HPP_
#define FISH_HANDLER_MNEMONICS_HPP_

#include <stdint.h>

enum fish_handler_mnemonics : uint16_t
{
	FISH_MNEMONIC_UNKNOWN = 0x8000,
	
	FISH_MNEMONIC_ALIGN,
};

#endif

```

`TDE/fish_handler_types.hpp`:

```hpp
#ifndef FISH_HANDLER_TYPES_HPP_
#define FISH_HANDLER_TYPES_HPP_

#include <stdint.h>

enum fish_handler_types : uint16_t
{
	FISH_HANDLER_PUSH_POP = 0x1000,
	FISH_HANDLER_COMMON_UNARY_OPERATION,
	FISH_HANDLER_COMMON_BINARY_OPERATION,
	FISH_HANDLER_ALIGN,
	FISH_HANDLER_XCHG,

	FISH_HANDLER_COUNT,
};

enum fish_subhandler_types : uint16_t
{
	/*
		decode idk4/idk6 -> $1
		compare $1 to 0x2 (else: skip rest)

		decode idk3/idk5 -> $2
		and $2,0xFFFF
		add $2,VM_CONTEXT

		decode operand size -> $3
		
		mov $2,[$2]
		encode $2 -> VM_REG
		
		compare $3 to 0x1 (if: mov $2,byte ptr [$2])
		compare $3 to 0x2 (if: mov $2,word ptr [$2])
		compare $3 to 0x3 (if: mov $2,dword ptr [$2])
		
		encode $2 -> idk3/idk5
	*/
	FISH_UNKNOWN_SUBHANDLER_0000 = 0x0000,		// 
	
	/*
		decode idk4/idk6 -> $1
		compare $1 to 0x02 (else: skip rest)

		decode idk3/idk5 -> $2
		and $2,0xFFFF
		add $2,VM_CONTEXT

		decode operand size -> $3

		mov $2,[$2]
		
		compare $3 to 0x1 (if: mov $2,byte ptr [$2])
		compare $3 to 0x2 (if: mov $2,word ptr [$2])
		compare $3 to 0x3 (if: mov $2,dword ptr [$2])
		
		encode $2 -> idk3/idk5
	*/
	FISH_UNKNOWN_SUBHANDLER_0001,				// 

	FISH_UNKNOWN_SUBHANDLER_0002,				// Same as 0000
	
	FISH_SUBHANDLER_LOAD_STORE,

	/*
		decode idk4/idk6 -> $1
		compare $1 to 0x01 (else: skip rest)

		decode idk3/idk5 -> $2
		and $2,0xFFFF
		add $2,VM_CONTEXT

		encode $2 -> VM_REG						; addr
		encode dword ptr [$2] -> idk3/idk5		; value
	*/
	FISH_UNKNOWN_SUBHANDLER_0004,				

	/*
		decode idk4/idk6 -> $1
		compare $1 to 0x01 (else: skip rest)

		decode idk3/idk5 -> $2
		and $2,0xFFFF
		add $2,VM_CONTEXT

		encode [$2] -> idk3/idk5
	*/
	FISH_UNKNOWN_SUBHANDLER_0005,

	FISH_SUBHANDLER_LOAD_OPERAND_INFO,
	FISH_SUBHANDLER_ALIGN_REGISTER,
	FISH_SUBHANDLER_LOAD_OPERAND_DATA,
	FISH_SUBHANDLER_LOAD_MNEMONIC,
	FISH_SUBHANDLER_RESET_INTERNAL_STATE,

	FISH_SUBHANDLER_PROTECTION_TEMPLATE_0000,

	FISH_SUBHANDLER_COUNT,

	FISH_INVALID_SUBHANDLER = 0xFFFF,
};

#endif

```

`TDE/instruction_container.cpp`:

```cpp
#include "instruction_container.hpp"
#include "wild_context.hpp"
#include <idp.hpp>
#include <algorithm>

bool instruction_container::decodeAssembly(ud_instruction& instruction) {
    int err = ud_disassemble(&instruction);
    if (err != 0) {
        push_back(instruction);
        return true;
    } else {
        msg("Decode err: %d. PC is %08x\n", err, instruction.pc);
        return false;
    }
}

void instruction_container::printAssembly(FILE* file) {
    for (const auto& instruction : *this) {
        instruction.translator(&instruction);
        if (file)
            fprintf(file, "%016llx %s\n", instruction.get_address(), ud_insn_asm(&instruction));
        else
            msg("%016llx %s\n", instruction.get_address(), ud_insn_asm(&instruction));
    }
}

void instruction_container::printSyntax(WildContext& context, ud_instruction& instruction, uint32_t handler_offset, FILE* file) {
    instruction.translator(&instruction);
    if (file)
        fprintf(file, "{%04X} [%08X-%08X-%08X-%08X-%08X] %s\n", handler_offset, context.step_params[0], context.step_params[1], context.step_params[2], context.step_params[3], context.step_params[4], ud_insn_asm(&instruction));
    else
        msg("%08X {%04X} [%08X-%08X-%08X-%08X-%08X] %s\n", instruction.get_address<uint32_t>(), 
            handler_offset, context.step_params[0], context.step_params[1], context.step_params[2], context.step_params[3], context.step_params[4], ud_insn_asm(&instruction));
}

void instruction_container::updateIndexes() {
    for (size_t i = 0; i < size(); ++i)
        at(i).setIndex(i);
}

bool instruction_container::hasAddress(uint32_t address) const {
    auto iter = std::find_if(begin(), end(), [address](const auto& value) {
        return value.isAddress<uint32_t>(address);
    });
    return iter != end();
}

bool instruction_container::findAddressIndex(uint32_t address, size_t& index) const {
    auto iter = std::find_if(begin(), end(), [address](const auto& value) {
        return value.isAddress<uint32_t>(address);
    });
    if (iter != end()) {
        index = iter - begin();
        return true;
    }
    return false;
}

bool instruction_container::findMnemonicIndex(ud_mnemonic_code mnemonic, size_t& index) const {
    auto iter = std::find_if(begin(), end(), [mnemonic](const auto& value) {
        return value.isMnemonic(mnemonic);
    });
    if (iter != end()) {
        index = iter - begin();
        return true;
    }
    return false;
}

bool instruction_container::findIndexByRegisterBase(ud_type base, size_t& index, ud_instruction& instruction) {
    auto iter = std::find_if(begin(), end(), [base, &instruction](const auto& value) {
        if (value.isOperandType(0, UD_OP_REG) && value.isOperandBase(0, base)) {
            instruction = value;
            return true;
        }
        return false;
    });
    if (iter != end()) {
        index = iter - begin();
        return true;
    }
    return false;
}

bool instruction_container::findIndexByMemoryBase(ud_type base, size_t operand, size_t& index, ud_instruction& instruction) {
    auto iter = std::find_if(begin(), end(), [base, operand, &instruction](const auto& value) {
        if (value.isOperandType(operand, UD_OP_MEM) && value.isOperandBase(operand, base)) {
            instruction = value;
            return true;
        }
        return false;
    });
    if (iter != end()) {
        index = iter - begin();
        return true;
    }
    return false;
}

bool instruction_container::findIndex(size_t& index, instruction_container_base::predicate_function predicate) const {
    auto iter = std::find_if(begin(), end(), predicate);
    if (iter != end()) {
        index = iter - begin();
        return true;
    }
    return false;
}

```

`TDE/instruction_container.hpp`:

```hpp
#ifndef INSTRUCTION_CONTAINER_HPP_
#define INSTRUCTION_CONTAINER_HPP_

#include "instruction_container_branch_evaluator.hpp"
#include <cstdint>

class WildContext; // Forward declaration

class InstructionContainer : public InstructionContainerBranchEvaluator {
public:
    bool decodeAssembly(ud_instruction& instruction);
    void printAssembly(FILE* file = nullptr);
    void printSyntax(WildContext& context, ud_instruction& instruction, uint32_t handler_offset, FILE* file = nullptr);

public:
    void updateIndexes();

public:
    bool hasAddress(uint32_t address) const;
    bool findAddressIndex(uint32_t address, std::size_t& index) const;
    bool findMnemonicIndex(ud_mnemonic_code mnemonic, std::size_t& index) const;
    bool findIndexByRegisterBase(ud_type base, std::size_t& index, ud_instruction& instruction);
    bool findIndexByMemoryBase(ud_type base, std::size_t operand, std::size_t& index, ud_instruction& instruction);

private:
    bool findIndex(size_type& index, predicate_function predicate) const;
    bool find(const_iterator& iter, size_type& index, predicate_function predicate) const;
};

#endif

```

`TDE/instruction_container_base.cpp`:

```cpp
#include "instruction_container_base.hpp"

bool instruction_container_base::empty() const {
    return instructions.empty();
}

bool instruction_container_base::bounds(size_type offset, size_type size) const {
    bool offsetBounds = (offset < size());
    bool sizeBounds = (size == 0) ? true : (offset + size <= size());
    return (offsetBounds && sizeBounds);
}

instruction_container_base::size_type instruction_container_base::size() const {
    return instructions.size();
}

void instruction_container_base::clear() {
    instructions.clear();
}

void instruction_container_base::remove(size_type offset, size_type size) {
    if (size == 0)
        instructions.erase(instructions.begin() + offset);
    else
        instructions.erase(instructions.begin() + offset, instructions.begin() + offset + size);
}

void instruction_container_base::push_back(const value_type& value) {
    instructions.push_back(value);
}

void instruction_container_base::pop_back() {
    instructions.pop_back();
}

instruction_container_base::reference instruction_container_base::at(size_type index) {
    return instructions.at(index);
}

instruction_container_base::const_reference instruction_container_base::at(size_type index) const {
    return instructions.at(index);
}

instruction_container_base::reference instruction_container_base::front() {
    return instructions.front();
}

instruction_container_base::reference instruction_container_base::back() {
    return instructions.back();
}

instruction_container_base::iterator instruction_container_base::begin() {
    return instructions.begin();
}

instruction_container_base::const_iterator instruction_container_base::begin() const {
    return instructions.begin();
}

instruction_container_base::iterator instruction_container_base::end() {
    return instructions.end();
}

instruction_container_base::const_iterator instruction_container_base::end() const {
    return instructions.end();
}

instruction_container_base::const_iterator instruction_container_base::cbegin() const {
    return instructions.cbegin();
}

instruction_container_base::const_iterator instruction_container_base::cend() const {
    return instructions.cend();
}

```

`TDE/instruction_container_base.hpp`:

```hpp
#ifndef INSTRUCTION_CONTAINER_BASE_HPP_
#define INSTRUCTION_CONTAINER_BASE_HPP_

#include "ud_instruction.hpp"

#include <functional>
#include <vector>

class instruction_container_base
{
protected:
	typedef ud_instruction container_type;

	typedef std::vector<container_type>::iterator iterator;
	typedef std::vector<container_type>::const_iterator const_iterator;

	typedef std::vector<container_type>::reference reference;
	typedef std::vector<container_type>::const_reference const_reference;
	
	typedef std::vector<container_type>::size_type size_type;
	typedef std::vector<container_type>::value_type value_type;

	typedef std::function<bool(value_type const&)> predicate_function;

public:
	bool empty() const;
	bool bounds(size_type offset, size_type size = 0) const;

	size_type size() const;
	
	void clear();
	void remove(size_type offset, size_type size = 0);
	
	void push_back(value_type const& value);
	void pop_back();
	
	reference at(size_type index = 0);
	const_reference at(size_type index = 0) const;

	reference front();
	reference back();
	
	iterator begin();
	const_iterator begin() const;
	
	iterator end();
	const_iterator end() const;

	const_iterator cbegin() const;
	const_iterator cend() const;

private:
	std::vector<container_type> instructions;
};

#endif
```

`TDE/instruction_container_branch_evaluator.cpp`:

```cpp
#include "instruction_container_branch_evaluator.hpp"
#include "instruction_emulator.hpp"

#include <idp.hpp>

bool instruction_container_branch_evaluator::try_evaluate_branch(ud_instruction& instruction)
{
	bool jump_condition = false;

	if (!this->evaluate_branch(instruction.mnemonic, &jump_condition))
		jump_condition = (askbuttons_c(NULL, NULL, NULL, ASKBTN_YES, "HIDECANCEL\nCould not evaluate jcc branch for mnemonic %04X at address %08X\nWould you like to follow the jump?", instruction.mnemonic, instruction.get_address<uint32_t>()) == ASKBTN_YES);

	return jump_condition;
}

bool instruction_container_branch_evaluator::try_evaluate_branch_simple()
{
	ud_instruction& instruction = this->at(this->size() - 2);

	if (instruction.is_mnemonic(UD_Icmp))
		return true;
	else if (instruction.is_mnemonic(UD_Itest))
		return true;
	else if (instruction.is_mnemonic(UD_Ior) &&
		instruction.is_operand_type(0, UD_OP_REG) &&
		instruction.is_operand_type(1, UD_OP_REG) &&
		instruction.is_operand_base(1, instruction, 0))
	{
		return true;
	}

	return false;
}

bool instruction_container_branch_evaluator::evaluate_branch(ud_mnemonic_code mnemonic, bool* jump_condition)
{
	if (this->empty())
		return false;

	this->evaluating_branch = true;
	
	ud_instruction& instruction = this->at(this->size() - 2);

	/*
		0: mov ___,___
		1: jcc _______
	*/
	if (instruction.is_mnemonic(UD_Imov))
	{
		this->evaluating_branch = false;
		return false;
	}
	/*
		0: cmp ___,___
		1: jcc _______
	*/
	else if (instruction.is_mnemonic(UD_Icmp))
	{
		this->evaluating_branch = false;
		return true;
	}
	/*
		0: test ___,___
		1: jcc ________
	*/
	else if (instruction.is_mnemonic(UD_Itest))
	{
		this->evaluating_branch = false;
		return true;
	}
	/*
		0: or reg1,reg1
		1: jcc ________
	*/
	else if (instruction.is_mnemonic(UD_Ior) &&
		instruction.is_operand_type(0, UD_OP_REG) &&
		instruction.is_operand_type(1, UD_OP_REG) &&
		instruction.is_operand_base(1, instruction, 0))
	{
		this->evaluating_branch = false;
		return true;
	}
	else
	{
		uint32_t imm_product = 0;
		std::size_t index = static_cast<std::size_t>(-1);

		if (this->find_condition_start(index, imm_product) || (this->deobfuscate(), this->find_condition_start(index, imm_product)))
		{
			uint32_t eflags = 0;

			for (std::size_t i = index + 1; i < this->size(); i++)
			{
				if (instruction.is_operand_type(0, UD_OP_REG))
				{
					instruction::emulate_eflags(this->at(i).mnemonic, this->at(i).get_base_size(0), this->at(i).get_operand_data(1), imm_product, &eflags);
					instruction::emulate(this->at(i).mnemonic, this->at(i).get_base_size(0), this->at(i).get_operand_data(1), &imm_product);
				}
				else
				{
					instruction::emulate_eflags(this->at(i).mnemonic, this->at(i).get_operand_size(0), this->at(i).get_operand_data(1), imm_product, &eflags);
					instruction::emulate(this->at(i).mnemonic, this->at(i).get_operand_size(0), this->at(i).get_operand_data(1), &imm_product);
				}
			}

			*jump_condition = this->evaluate_conditional_jump(mnemonic, eflags);
			this->evaluating_branch = false;
			return true;
		}
	}

	this->evaluating_branch = false;
	return false;
}

bool instruction_container_branch_evaluator::evaluate_conditional_jump(ud_mnemonic_code mnemonic, uint32_t flags)
{
	#define CARRY_FLAG(x)		(((x) >> 0) & 1)	// Carry bit = 0
	#define PARITY_FLAG(x)		(((x) >> 2) & 1)	// Parity bit = 2
	#define ZERO_FLAG(x)		(((x) >> 6) & 1)	// Zero bit = 6
	#define SIGN_FLAG(x)		(((x) >> 7) & 1)	// Sign bit = 7
	#define OVERFLOW_FLAG(x)	(((x) >> 11) & 1)	// Overflow bit = 11

	switch (mnemonic)
	{
	case UD_Ija:	/* Jump if above (alt: not below or equal): CF = 0 & ZF = 0 */
		return (CARRY_FLAG(flags) == 0 && ZERO_FLAG(flags) == 0);
	
	case UD_Ijae:	/* Jump if above or equal (alt: not carry, not below ): CF = 0 */
		return (CARRY_FLAG(flags) == 0);
	
	case UD_Ijb:	/* Jump if below (alt: carry, not above or equal): CF = 1 */
		return (CARRY_FLAG(flags) == 1);
	
	case UD_Ijbe:	/* Jump if below or equal (alt: not above): CF = 1 | ZF = 1 */
		return (CARRY_FLAG(flags) == 1 || ZERO_FLAG(flags) == 1);
	
	case UD_Ijz:	/* Jump if zero (alt: equal): ZF = 1 */
		return (ZERO_FLAG(flags) == 1);
	
	case UD_Ijnz:	/* Jump if not zero (alt: not equal): ZF = 0 */
		return (ZERO_FLAG(flags) == 0);
	
	case UD_Ijg:	/* Jump if greater (alt: not less or equal): SF = OF & ZF = 0 */
		return (SIGN_FLAG(flags) == OVERFLOW_FLAG(flags) && ZERO_FLAG(flags) == 0);
	
	case UD_Ijge:	/* Jump if greater or equal (alt: not less): SF = OF */
		return (SIGN_FLAG(flags) == OVERFLOW_FLAG(flags));
	
	case UD_Ijl:	/* Jump if less (alt: not greater or equal): SF <> OF */
		return (SIGN_FLAG(flags) != OVERFLOW_FLAG(flags));
	
	case UD_Ijle:	/* Jump if less or equal (alt: not greater): SF <> OF | ZF = 1 */
		return (SIGN_FLAG(flags) != OVERFLOW_FLAG(flags) || ZERO_FLAG(flags) == 1);
	
	case UD_Ijo:	/* Jump if overflow: OF = 1 */
		return (OVERFLOW_FLAG(flags) == 1);
	
	case UD_Ijno:	/* Jump if not overflow: OF = 0 */
		return (OVERFLOW_FLAG(flags) == 0);
	
	case UD_Ijp:	/* Jump if parity (alt: parity even): PF = 1 */
		return (PARITY_FLAG(flags) == 1);
	
	case UD_Ijnp:	/* Jump if not parity (alt: parity odd): PF = 0 */
		return (PARITY_FLAG(flags) == 0);
	
	case UD_Ijs:	/* Jump if sign: SF = 1 */
		return (SIGN_FLAG(flags) == 1);

	case UD_Ijns:	/* Jump if not sign: SF = 0 */
		return (SIGN_FLAG(flags) == 0);
	
	case UD_Ijcxz:
	case UD_Ijecxz:
	case UD_Ijrcxz:
		/* ... */

	default:
		printf("Invalid mnemonic to perform conditional jump evaluation.\n");
		return false;
	}

	return true;
}

bool instruction_container_branch_evaluator::find_condition_start(std::size_t& index, uint32_t& product)
{
	for (std::size_t i = (this->size() - 1); static_cast<int32_t>(i) >= 0; i--)
	{
		if (!this->at(i).compare_mnemonic(true, true, true))
			return false;
		
		if (this->at(i).compare_mnemonic(true, false, true))
		{
			if (this->at(i).is_operand_type_not(0, { UD_OP_REG, UD_OP_MEM }) ||
				this->at(i).is_operand_base_not(0, this->back(), 0) ||
				this->at(i).is_operand_index_not(0, this->back(), 0) ||
				this->at(i).is_operand_scale_not(0, this->back(), 0) ||
				this->at(i).is_operand_data_not(0, this->back(), 0) ||
				this->at(i).is_operand_type_not(1, UD_OP_IMM))
			{
				return false;
			}

			if (this->at(i).compare_mnemonic(true, false, false))
			{
				index = i;
				product = this->at(i).get_operand_data(1);
				return true;
			}
		}

		if (this->at(i).compare_mnemonic(false, true, false))
		{
			if (this->at(i).is_operand_type_not(0, { UD_OP_REG, UD_OP_MEM }) ||
				this->at(i).is_operand_base_not(0, this->back(), 0) ||
				this->at(i).is_operand_index_not(0, this->back(), 0) ||
				this->at(i).is_operand_scale_not(0, this->back(), 0) ||
				this->at(i).is_operand_data_not(0, this->back(), 0))
			{
				return false;
			}
		}
	}

	return true;
}
```

`TDE/instruction_container_branch_evaluator.hpp`:

```hpp
#ifndef INSTRUCTION_CONTAINER_BRANCH_EVALUATOR_HPP_
#define INSTRUCTION_CONTAINER_BRANCH_EVALUATOR_HPP_

#include "instruction_container_deobfuscator.hpp"

class instruction_container_branch_evaluator : public instruction_container_deobfuscator
{
public:
	bool try_evaluate_branch(ud_instruction& instruction);
	bool try_evaluate_branch_simple();
	
private:
	bool evaluate_branch(ud_mnemonic_code mnemonic, bool* jump_condition);
	bool evaluate_conditional_jump(ud_mnemonic_code mnemonic, uint32_t flags);
	
	bool find_condition_start(std::size_t& index, uint32_t& product);

private:
	bool evaluating_branch;
};

#endif
```

`TDE/instruction_container_deobfuscator.cpp`:

```cpp
#include "instruction_container_deobfuscator.hpp"
#include "instruction_emulator.hpp"

void instruction_container_deobfuscator::deobfuscate()
{
	uint32_t pre_deobfuscation_size = 0;

	do
	{
		pre_deobfuscation_size = this->size();

		this->deobfuscate_push();
		this->deobfuscate_pop();
		this->deobfuscate_stack();
		this->deobfuscate_xchg_v1();
		this->deobfuscate_mov_v1();
		this->deobfuscate_xchg_v2();
		this->deobfuscate_arithmetics();
		this->deobfuscate_offset();
		this->deobfuscate_generated_memory();
		this->deobfuscate_generated_register();
		this->deobfuscate_neg();
		
		if (pre_deobfuscation_size == this->size())
			this->deobfuscate_mov_v2();
	}
	while (pre_deobfuscation_size != this->size());
}

void instruction_container_deobfuscator::deobfuscate_wild()
{
	uint32_t pre_deobfuscation_size = 0;

	do
	{
		pre_deobfuscation_size = this->size();
		
		this->deobfuscate_push();
		this->deobfuscate_pop();
		this->deobfuscate_stack();
		this->deobfuscate_xchg_v1();
		this->deobfuscate_mov_v1();
		this->deobfuscate_xchg_v2();
		this->deobfuscate_arithmetics();
		this->deobfuscate_offset();
		this->deobfuscate_generated_memory();
		this->deobfuscate_generated_register();
		this->deobfuscate_neg();
		
		if (pre_deobfuscation_size == this->size())
		{
			this->deobfuscate_mov_v2();
			
			if (pre_deobfuscation_size == this->size())
			{
				this->deobfuscate_fillers();

				//if (pre_deobfuscation_size == instructions.size())
				//	this->deobfuscate_new_types(instructions);
			}
		}
	}
	while (pre_deobfuscation_size != this->size());
}

void instruction_container_deobfuscator::deobfuscate_push()
{
	for (std::size_t i = 0; i < this->size(); i++)
	{
		/*
			0: sub esp,02/04
			1: mov (d)word ptr [esp],reg
		*/
		if (this->bounds(i, 1) &&
			this->at(i).is_mnemonic(UD_Isub) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).is_operand_base(0, UD_R_ESP) &&
			this->at(i).is_operand_type(1, UD_OP_IMM) &&
			this->at(i).is_operand_data(1, { 2, 4 }) &&
			
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_MEM, { UD_SIZE_WORD, UD_SIZE_DWORD }) &&
			this->at(i + 1).is_operand_base(0, UD_R_ESP) &&
			this->at(i + 1).has_operand_index_not(0) &&
			this->at(i + 1).has_operand_scale_not(0) &&
			this->at(i + 1).has_operand_data_not(0) &&
			this->at(i + 1).is_operand_type(1, UD_OP_REG))
		{
			/* 1: mov (d)word ptr [esp],(e)sp */
			if (this->at(i + 1).is_operand_base(1, { UD_R_SP, UD_R_ESP }))
			{
				/* 2: add unknown ptr [esp],02/04 */
				if (this->bounds(i, 2) &&
					this->at(i + 2).is_mnemonic(UD_Iadd) &&
					this->at(i + 2).is_operand_type(0, UD_OP_MEM) &&
					this->at(i + 2).is_operand_base(0, UD_R_ESP) &&
					this->at(i + 2).has_operand_index_not(0) &&
					this->at(i + 2).has_operand_scale_not(0) &&
					this->at(i + 2).has_operand_data_not(0) &&
					this->at(i + 2).is_operand_type(1, UD_OP_IMM) &&
					this->at(i + 2).is_operand_data(1, { 2, 4 }))
				{
					/* 0: push esp */
					this->at(i).set_mnemonic(UD_Ipush);
					this->at(i).set_prefixes(this->at(i + 1));
					this->at(i).set_operand(0, this->at(i + 1), 1);
					this->at(i).set_operand_null(1);

					this->remove(i + 1, 2);
				}
			}
			else
			{
				/* 0: push reg */
				this->at(i).set_mnemonic(UD_Ipush);
				this->at(i).set_prefixes(this->at(i + 1));
				this->at(i).set_operand(0, this->at(i + 1), 1);
				this->at(i).set_operand_null(1);
		
				this->remove(i + 1);
			}
		}
	
		/*
			0: push reg/imm
			1: mov (d)word ptr [esp],reg
		*/
		if (this->bounds(i, 1) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, { UD_OP_REG, UD_OP_IMM }) &&
			
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_MEM, { UD_SIZE_WORD, UD_SIZE_DWORD }) &&
			this->at(i + 1).is_operand_base(0, UD_R_ESP) &&
			this->at(i + 1).has_operand_index_not(0) &&
			this->at(i + 1).has_operand_scale_not(0) &&
			this->at(i + 1).has_operand_data_not(0) &&
			this->at(i + 1).is_operand_type(1, UD_OP_REG))
		{
			/* 1: mov (d)word ptr [esp],(e)sp */
			if (this->at(i + 1).is_operand_base(1, { UD_R_SP, UD_R_ESP }))
			{
				/* 2: add unknown ptr [esp],02/04 */
				if (this->bounds(i, 2) &&
					this->at(i + 2).is_mnemonic(UD_Iadd) &&
					this->at(i + 2).is_operand_type(0, UD_OP_MEM) &&
					this->at(i + 2).is_operand_base(0, UD_R_ESP) &&
					this->at(i + 2).has_operand_index_not(0) &&
					this->at(i + 2).has_operand_scale_not(0) &&
					this->at(i + 2).has_operand_data_not(0) &&
					this->at(i + 2).is_operand_type(1, UD_OP_IMM) &&
					this->at(i + 2).is_operand_data(1, { 2, 4 }))
				{
					/* 0: push esp */
					this->at(i).set_mnemonic(UD_Ipush);
					this->at(i).set_prefixes(this->at(i + 1));
					this->at(i).set_operand(0, this->at(i + 1), 1);

					this->remove(i + 1, 2);
				}
			}
			else
			{
				/* 0: push reg */
				this->at(i).set_mnemonic(UD_Ipush);
				this->at(i).set_prefixes(this->at(i + 1));
				this->at(i).set_operand(0, this->at(i + 1), 1);
		
				this->remove(i + 1);
			}
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_pop()
{
	for (std::size_t i = (this->size() - 1); static_cast<int32_t>(i) >= 0; i--)
	{
		/*
			0: mov reg,(d)word ptr [esp]
			1: add esp,02/04
		*/
		if (this->bounds(i, 1) &&
			this->at(i).is_mnemonic(UD_Imov) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).is_operand_base_not(0, { UD_R_SP, UD_R_ESP }) &&
			this->at(i).is_operand_type(1, UD_OP_MEM, { UD_SIZE_WORD, UD_SIZE_DWORD }) &&
			this->at(i).is_operand_base(1, UD_R_ESP) &&
			this->at(i).has_operand_index_not(1) &&
			this->at(i).has_operand_scale_not(1) &&
			this->at(i).has_operand_data_not(1) &&
			
			this->at(i + 1).is_mnemonic(UD_Iadd) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 1).is_operand_base(0, UD_R_ESP) &&
			this->at(i + 1).is_operand_type(1, UD_OP_IMM) &&
			this->at(i + 1).is_operand_data(1, { 2, 4 }))
		{
			/* 0: pop reg */
			this->at(i).set_mnemonic(UD_Ipop);
			this->at(i).set_operand_null(1);
		
			this->remove(i + 1);
		}

		/* 0: mov (e)sp,(d)word ptr [esp] */
		if (this->bounds(i) &&
			this->at(i).is_mnemonic(UD_Imov) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).is_operand_base(0, { UD_R_SP, UD_R_ESP }) &&
			this->at(i).is_operand_type(1, UD_OP_MEM, { UD_SIZE_WORD, UD_SIZE_DWORD }) &&
			this->at(i).is_operand_base(1, UD_R_ESP) &&
			this->at(i).has_operand_index_not(1) &&
			this->at(i).has_operand_scale_not(1) &&
			this->at(i).has_operand_data_not(1))
		{
			/* 0: pop (e)sp */
			this->at(i).set_mnemonic(UD_Ipop);
			this->at(i).set_operand_null(1);
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_stack()
{
	for (std::size_t i = 0; i < this->size(); i++)
	{
		/*
			0: push (reg != esp)
			1: mov reg,esp
			2: add reg,04
			3: add/sub reg,imm
			4: xchg reg/(d)word ptr [esp],reg/(d)word ptr [esp]
			5: pop esp
		*/
		if (this->bounds(i, 5) &&			
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).is_operand_base_not(0, UD_R_ESP) &&
			
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 1).is_operand_base(0, this->at(i), 0) &&
			this->at(i + 1).is_operand_type(1, UD_OP_REG) &&
			this->at(i + 1).is_operand_base(1, UD_R_ESP) &&
			
			this->at(i + 2).is_mnemonic(UD_Iadd) &&
			this->at(i + 2).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 2).is_operand_base(0, this->at(i), 0) &&
			this->at(i + 2).is_operand_type(1, UD_OP_IMM) &&
			this->at(i + 2).is_operand_data(1, 4) &&
			
			this->at(i + 3).is_mnemonic({ UD_Iadd, UD_Isub }) &&
			this->at(i + 3).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 3).is_operand_base(0, this->at(i), 0) &&
			this->at(i + 3).is_operand_type(1, UD_OP_IMM) &&

			this->at(i + 4).is_mnemonic(UD_Ixchg) &&
			((this->at(i + 4).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) && 
			this->at(i + 4).is_operand_base(0, UD_R_ESP) &&
			this->at(i + 4).has_operand_index_not(0) &&
			this->at(i + 4).has_operand_scale_not(0) &&
			this->at(i + 4).has_operand_data_not(0) &&
			this->at(i + 4).is_operand_type(1, UD_OP_REG) &&
			this->at(i + 4).is_operand_base(1, this->at(i), 0)) ||
			(this->at(i + 4).is_operand_type(0, UD_OP_REG) && 
			this->at(i + 4).is_operand_base(0, this->at(i), 0) &&
			this->at(i + 4).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
			this->at(i + 4).is_operand_base(1, UD_R_ESP) &&
			this->at(i + 4).has_operand_index_not(1) &&
			this->at(i + 4).has_operand_scale_not(1) &&
			this->at(i + 4).has_operand_data_not(1))) &&

			this->at(i + 5).is_mnemonic(UD_Ipop) &&
			this->at(i + 5).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 5).is_operand_base(0, UD_R_ESP))
		{
			/* 0: add/sub esp,imm */
			this->at(i).set_mnemonic(this->at(i + 3));
			this->at(i).set_operand_type(0, UD_OP_REG, UD_SIZE_DWORD);
			this->at(i).set_operand_base(0, UD_R_ESP);
			this->at(i).set_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD);
			this->at(i).set_operand_data(1, this->at(i + 3), 1);

			this->remove(i + 1, 5);
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_xchg_v1()
{
	for (std::size_t i = (this->size() - 1); static_cast<int32_t>(i) >= 0; i--)
	{
		/*
			0: xor x1,x2
			1: xor x2,x1
			2: xor x1,x2
		*/
		if (this->bounds(i, 2) &&
			this->at(i).is_mnemonic(UD_Ixor) &&

			this->at(i + 1).is_mnemonic(UD_Ixor) &&
			this->at(i + 1).is_operand(0, this->at(i), 1) &&
			this->at(i + 1).is_operand(1, this->at(i), 0) &&

			this->at(i + 2).is_mnemonic(UD_Ixor) &&
			this->at(i + 2).is_operand(0, this->at(i + 1), 1) &&
			this->at(i + 2).is_operand(1, this->at(i + 1), 0))
		{
			/* 0: xchg x1,x2 */
			this->at(i).set_mnemonic(UD_Ixchg);
			this->at(i).set_operand(0, this->at(i + 1), 0);
			this->at(i).set_operand(1, this->at(i + 2), 0);
			
			this->remove(i + 1, 2);
		}

		/*
			0: push reg
			1: mov reg,dword ptr [esp+4]
			2: pop dword ptr [esp]
		*/
		if (this->bounds(i, 2) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).is_operand_base_not(0, UD_R_ESP) &&

			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 1).is_operand_base(0, this->at(i), 0) &&
			this->at(i + 1).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
			this->at(i + 1).is_operand_base(1, UD_R_ESP) &&
			this->at(i + 1).has_operand_index_not(1) &&
			this->at(i + 1).has_operand_scale_not(1) &&
			this->at(i + 1).is_operand_data(1, 4) &&

			this->at(i + 2).is_mnemonic(UD_Ipop) &&
			this->at(i + 2).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) &&
			this->at(i + 2).is_operand_base(0, UD_R_ESP) &&
			this->at(i + 2).has_operand_index_not(0) &&
			this->at(i + 2).has_operand_scale_not(0) &&
			this->at(i + 2).has_operand_data_not(0))
		{
			/* 0: xchg reg,dword ptr [esp] */
			this->at(i).set_mnemonic(UD_Ixchg);
			this->at(i).set_operand(1, this->at(i + 2), 0);

			this->remove(i + 1, 2);
		}

		/*
			0: push reg1
			1: mov reg1,x2
			2: mov x2,x3
			3: mov x3,reg1
			4: pop reg1
		*/
		if (this->bounds(i, 4) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).compare_base(0, this->at(i + 1), 0) &&
			
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&

			this->at(i + 2).is_mnemonic(UD_Imov) &&
			this->at(i + 2).is_operand(0, this->at(i + 1), 1) &&

			this->at(i + 3).is_mnemonic(UD_Imov) &&
			this->at(i + 3).is_operand(0, this->at(i + 2), 1) &&
			this->at(i + 3).is_operand_type(1, UD_OP_REG) &&
			this->at(i + 3).is_operand(1, this->at(i + 1), 0) &&

			this->at(i + 4).is_mnemonic(UD_Ipop) &&
			this->at(i + 4).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 4).is_operand_base(0, this->at(i), 0))
		{
			/* 0: xchg x2,x3 */
			this->at(i).set_mnemonic(UD_Ixchg);
			this->at(i).set_prefixes(this->at(i + 3));
			this->at(i).set_operand(0, this->at(i + 3), 0);
			this->at(i).set_operand(1, this->at(i + 2), 0);
			
			if (this->at(i).is_operand_type(0, UD_OP_MEM) && this->at(i).is_operand_base(0, UD_R_ESP))
				this->at(i).dec_operand_data<uint32_t>(0, this->at(i + 4).is_operand_base_size(0, UD_SIZE_DWORD) ? 4 : 2);
			
			if (this->at(i).is_operand_type(1, UD_OP_MEM) && this->at(i).is_operand_base(1, UD_R_ESP))
				this->at(i).dec_operand_data<uint32_t>(1, this->at(i + 4).is_operand_base_size(0, UD_SIZE_DWORD) ? 4 : 2);
			
			this->remove(i + 1, 4);
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_mov_v1()
{
	for (std::size_t i = (this->size() - 1); static_cast<int32_t>(i) >= 0; i--)
	{
		/*
			0: push x1
			1: pop x2
		*/
		if (this->bounds(i, 1) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i + 1).is_mnemonic(UD_Ipop) &&
			
			((this->at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			this->at(i + 1).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD)) ||
			
			(this->at(i).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD)) ||
			
			(this->at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_WORD) &&
			this->at(i + 1).is_operand_type(0, UD_OP_MEM, UD_SIZE_WORD)) ||
			
			(this->at(i).is_operand_type(0, UD_OP_MEM, UD_SIZE_WORD) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG, UD_SIZE_WORD)) ||
			
			(this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG)) ||
			
			(this->at(i).is_operand_type(0, UD_OP_IMM, UD_SIZE_DWORD) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG)) ||
			
			(this->at(i).is_operand_type(0, UD_OP_IMM, UD_SIZE_WORD) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG))))
		{
			/* 0: mov x2,x1 */
			this->at(i).set_mnemonic(UD_Imov);
			this->at(i).set_operand(1, this->at(i), 0);
			this->at(i).set_operand(0, this->at(i + 1), 0);
			
			this->remove(i + 1);
		}

		/*
			0: push x1
			1: sub|add|xor unknown ptr [esp],imm
			2: pop x2
			3: add|sub|xor x2,imm
		*/
		if (this->bounds(i, 3) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&

			((this->at(i + 1).is_mnemonic(UD_Isub) && this->at(i + 3).is_mnemonic(UD_Iadd)) ||
			(this->at(i + 1).is_mnemonic(UD_Iadd) && this->at(i + 3).is_mnemonic(UD_Isub)) ||
			(this->at(i + 1).is_mnemonic(UD_Ixor) && this->at(i + 3).is_mnemonic(UD_Ixor))) &&
			this->at(i + 1).is_operand_type(0, UD_OP_MEM) &&
			this->at(i + 1).is_operand_base(0, UD_R_ESP) &&
			this->at(i + 1).has_operand_index_not(0) &&
			this->at(i + 1).has_operand_scale_not(0) &&
			this->at(i + 1).has_operand_data_not(0) &&
			this->at(i + 1).is_operand_type(1, UD_OP_IMM) &&
			
			this->at(i + 2).is_mnemonic(UD_Ipop) &&
			this->at(i + 2).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&

			this->at(i + 3).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
			this->at(i + 3).is_operand(0, this->at(i + 2), 0) &&
			this->at(i + 3).is_operand_type(1, UD_OP_IMM) &&
			this->at(i + 3).is_operand_data(1, this->at(i + 1), 1))
		{
			/* 0: mov x2,x1 */
			this->at(i).set_mnemonic(UD_Imov);
			this->at(i).set_operand(1, this->at(i), 0);
			this->at(i).set_operand(0, this->at(i + 2), 0);

			this->remove(i + 1, 3);
		}
		
		/*
			0: push reg
			1: mov reg,imm
			2: mov x2,imm
			3: ___ x2,reg
			4: pop reg
		*/
		if (this->bounds(i, 4) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).compare_base(0, this->at(i + 1), 0) &&

			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 1).is_operand_type(1, UD_OP_IMM) &&

			this->at(i + 2).is_mnemonic(UD_Imov) &&
			this->at(i + 2).is_operand_type(1, UD_OP_IMM) &&

			this->at(i + 3).compare_mnemonic(true, false, true) &&
			this->at(i + 3).is_operand_sib(0, this->at(i + 2), 0) &&
			this->at(i + 3).is_operand_data(0, this->at(i + 2), 0) &&
			this->at(i + 3).is_operand_type(1, UD_OP_REG) &&
			this->at(i + 3).is_operand(1, this->at(i + 1), 0) &&

			this->at(i + 4).is_mnemonic(UD_Ipop) &&
			this->at(i + 4).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 4).is_operand_base(0, this->at(i), 0))
		{
			/* 0: mov x2,imm */
			uint32_t imm_product = this->at(i + 2).get_operand_data<uint32_t>(1);

			if (this->at(i + 3).is_operand_type(0, UD_OP_REG))
				instruction::emulate(this->at(i + 3).get_mnemonic(), this->at(i + 3).get_base_size(0), this->at(i + 1).get_operand_data(1), &imm_product);
			else if (this->at(i + 3).is_operand_type(0, UD_OP_MEM))
			{
				/* 3: ___ [esp+xx],x1 */
				if (this->at(i + 3).is_operand_base(0, UD_R_ESP))
					this->at(i + 3).dec_operand_data<uint32_t>(0, this->at(i).is_operand_base_size(0, UD_SIZE_DWORD) ? 4 : 2);
				
				instruction::emulate(this->at(i + 3).get_mnemonic(), this->at(i + 3).get_operand_size(0), this->at(i + 1).get_operand_data(1), &imm_product);
			}

			this->at(i).set_mnemonic(UD_Imov);
			this->at(i).set_prefixes(this->at(i + 3));
			this->at(i).set_operand(0, this->at(i + 3), 0);
			this->at(i).set_operand(1, this->at(i + 1), 1);
			this->at(i).set_operand_data(1, imm_product);

			this->remove(i + 1, 4);
		}

		/*
			0: push reg
			1: mov reg,imm
			2: mov x,imm
			3: ___ x,reg
			4: ___ x,imm
			5: pop reg
		*/
		if (this->bounds(i, 5) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).compare_base(0, this->at(i + 1), 0) &&
			
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 1).is_operand_type(1, UD_OP_IMM) &&

			this->at(i + 2).is_mnemonic(UD_Imov) &&
			this->at(i + 2).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 2).is_operand_type(1, UD_OP_IMM) &&
			
			this->at(i + 3).compare_mnemonic(true, false, true) &&
			this->at(i + 3).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 3).is_operand_base_not(0, this->at(i + 1), 0) &&
			this->at(i + 3).is_operand_base(0, this->at(i + 2), 0) &&
			this->at(i + 3).is_operand_type(1, UD_OP_REG) &&
			this->at(i + 3).is_operand_base(1, this->at(i + 1), 0) &&
			
			this->at(i + 4).compare_mnemonic(true, false, true) &&
			this->at(i + 4).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 4).is_operand_base(0, this->at(i + 3), 0) &&
			this->at(i + 4).is_operand_type(1, { UD_OP_IMM, UD_OP_CONST }) &&

			this->at(i + 5).is_mnemonic(UD_Ipop) &&
			this->at(i + 5).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 5).is_operand_base(0, this->at(i), 0))
		{
			/* 0: mov reg2,imm */
			uint32_t imm_product = this->at(i + 2).get_operand_data<uint32_t>(1);
			
			instruction::emulate(this->at(i + 3).get_mnemonic(), this->at(i + 3).get_base_size(0), this->at(i + 1).get_operand_data(1), &imm_product);
			instruction::emulate(this->at(i + 4).get_mnemonic(), this->at(i + 4).get_base_size(0), this->at(i + 4).get_operand_data(1), &imm_product);

			this->at(i).set_mnemonic(UD_Imov);
			this->at(i).set_prefixes(this->at(i + 3));
			this->at(i).set_operand(0, this->at(i + 3), 0);
			this->at(i).set_operand(1, this->at(i + 1), 1);
			this->at(i).set_operand_data(1, imm_product);

			this->remove(i + 1, 5);
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_xchg_v2()
{
	for (std::size_t i = (this->size() - 1); static_cast<int32_t>(i) >= 0; i--)
	{
		/*
			0: xchg x1,x2
			1: ___ ___,___
			2: xchg x1,x2
		*/
		if (this->at(i).is_mnemonic(UD_Ixchg) &&
			this->at(i + 1).compare_mnemonic(false, true, true) &&
			this->at(i + 2).is_mnemonic(UD_Ixchg) &&
			((this->at(i + 2).is_operand(0, this->at(i), 0) && this->at(i + 2).is_operand(1, this->at(i), 1)) ||
			(this->at(i + 2).is_operand(0, this->at(i), 1) && this->at(i + 2).is_operand(1, this->at(i), 0))))
		{
			/* 1: ___ x1,(imm) */
			if (this->at(i + 1).is_operand(0, this->at(i), 0) &&
				this->at(i + 1).is_operand_type(1, { UD_NONE, UD_OP_IMM, UD_OP_CONST }))
			{
				/* 0: ___ x2,(imm) */
				this->at(i).set_mnemonic(this->at(i + 1));
				this->at(i).set_operand(0, this->at(i), 1);
				this->at(i).set_operand(1, this->at(i + 1), 1);

				this->remove(i + 1, 2);
			}
			/* 1: ___ x2,(imm) */
			else if (this->at(i + 1).is_operand(0, this->at(i), 1) &&
				this->at(i + 1).is_operand_type(1, { UD_NONE, UD_OP_IMM, UD_OP_CONST }))
			{
				/* 0: ___ x1,(imm) */
				this->at(i).set_mnemonic(this->at(i + 1));
				this->at(i).set_operand(0, this->at(i), 0);
				this->at(i).set_operand(1, this->at(i + 1), 1);

				this->remove(i + 1, 2);
			}
		}
		
		/*
			0: xchg x1,x2
			1: ___ ___,___
			2: ___ ___,___
			3: xchg x1,x2
		*/
		if (this->bounds(i, 3) &&
			this->at(i).is_mnemonic(UD_Ixchg) &&
			this->at(i + 1).compare_mnemonic(false, true, true) &&
			this->at(i + 2).compare_mnemonic(false, true, true) &&
			this->at(i + 3).is_mnemonic(UD_Ixchg) &&
			((this->at(i + 3).is_operand(0, this->at(i), 0) && this->at(i + 3).is_operand(1, this->at(i), 1)) ||
			(this->at(i + 3).is_operand(0, this->at(i), 1) && this->at(i + 3).is_operand(1, this->at(i), 0))))
		{
			/*
				1: ___ x1,(imm)
				2: ___ x1,(imm)
			*/
			if (this->at(i + 1).is_operand(0, this->at(i), 0) &&
				this->at(i + 1).is_operand_type(1, { UD_NONE, UD_OP_IMM, UD_OP_CONST }) &&
				this->at(i + 2).is_operand(0, this->at(i + 1), 0) &&
				this->at(i + 2).is_operand_type(1, { UD_NONE, UD_OP_IMM, UD_OP_CONST }))
			{
				/*
					0: ___ x2,(imm)
					1: ___ x2,(imm)
				*/
				this->at(i).set_mnemonic(this->at(i + 1));
				this->at(i).set_operand(0, this->at(i), 1);
				this->at(i).set_operand(1, this->at(i + 1), 1);
				
				this->at(i + 1).set_mnemonic(this->at(i + 2));
				this->at(i + 1).set_operand(0, this->at(i), 0);
				this->at(i + 1).set_operand(1, this->at(i + 2), 1);

				this->remove(i + 2, 2);
			}
			/* 1: ___ x2,imm */
			else if (this->at(i + 1).is_operand(0, this->at(i), 1) &&
				this->at(i + 1).is_operand_type(1, { UD_NONE, UD_OP_IMM, UD_OP_CONST }))
			{
				/*
					0: ___ x1,(imm)
					1: ___ x1,___
				*/
				this->at(i).set_mnemonic(this->at(i + 1));
				this->at(i).set_operand(0, this->at(i), 0);
				this->at(i).set_operand(1, this->at(i + 1), 1);
				
				this->at(i + 1).set_mnemonic(this->at(i + 2));
				this->at(i + 1).set_operand(0, this->at(i), 0);
				this->at(i + 1).set_operand(1, this->at(i + 2), 1);

				this->remove(i + 2, 2);
			}
		}

		/*
			0: push ___
			1: mov ___,___
			2: pop ___
		*/
		if (this->bounds(i, 2) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 2).is_mnemonic(UD_Ipop))
		{
			/*
				0: push reg
				1: mov ___,reg
			*/
			if (this->at(i).is_operand_type(0, UD_OP_REG) &&
				this->at(i + 1).is_operand_type(1, UD_OP_REG))
			{
				/*
					0: push x1
					1: mov x1,x2
					2: pop x2
				*/
				if (this->at(i + 1).is_operand(0, this->at(i), 0) &&
					this->at(i + 2).is_operand(0, this->at(i + 1), 1))
				{
					/* 0: xchg x1,x2 */
					this->at(i).set_mnemonic(UD_Ixchg);
					this->at(i).set_operand(1, this->at(i + 1), 1);

					this->remove(i + 1, 2);
				}
			}
			/*
				0: push unknown ptr [mem]
				1: mov ___,reg
			*/
			else if (this->at(i).is_operand_type(0, UD_OP_MEM) &&
				this->at(i + 1).is_operand_type(1, UD_OP_REG))
			{
				/*
					0: push unknown ptr [mem]
					1: mov unknown ptr [mem],reg
					2: pop reg
				*/
				if (this->at(i + 1).is_operand_type(0, this->at(i), 0) &&
					this->at(i + 2).is_operand(0, this->at(i + 1), 1))
				{
					/*
						0: push (d)word ptr [esp+xx]
						1: mov (d)word ptr [esp+xx+02/04],reg
						2: pop reg
					*/
					if (this->at(i).is_operand_base(0, UD_R_ESP) &&
						this->at(i).is_operand_index(0, this->at(i + 1), 0) &&
						this->at(i).is_operand_scale(0, this->at(i + 1), 0) &&
						this->at(i).is_operand_data(0, this->at(i + 1).get_operand_data(0) + (this->at(i).is_operand_size(0, UD_SIZE_DWORD) ? 4 : 2))) 
					{
						/* 0: xchg (d)word ptr [esp+xx],reg */
						this->at(i).set_mnemonic(UD_Ixchg);
						this->at(i).set_operand(1, this->at(i + 1), 1);
						
						this->remove(i + 1, 2);
					}
					/*
						0: push unknown ptr [mem]
						1: mov unknown ptr [mem],reg
						2: pop reg
					*/
					else if (this->at(i).is_operand(0, this->at(i + 1), 0))
					{
						/* 0: xchg unknown ptr [mem],reg */
						this->at(i).set_mnemonic(UD_Ixchg);
						this->at(i).set_operand(1, this->at(i + 1), 1);
						
						this->remove(i + 1, 2);
					}
				}
			}
			/*
				0: push reg
				1: mov ___,unknown ptr [mem]
			*/
			else if (this->at(i).is_operand_type(0, UD_OP_REG) &&
				this->at(i + 1).is_operand_type(1, UD_OP_MEM))
			{
				/*
					0: push reg
					1: mov reg,unknown ptr [mem]
					2: pop unknown ptr [mem]
				*/
				if (this->at(i + 1).is_operand(0, this->at(i), 0) &&
					this->at(i + 2).is_operand_type(0, this->at(i + 1), 1))
				{
					/*
						0: push reg
						1: mov reg,(d)word ptr [esp+xx+04]
						2: pop (d)word ptr [esp+xx]
					*/
					if (this->at(i + 1).is_operand_base(1, UD_R_ESP) &&
						this->at(i + 1).is_operand_index(1, this->at(i + 2), 0) &&
						this->at(i + 1).is_operand_scale(1, this->at(i + 2), 0) &&
						this->at(i + 1).is_operand_data(1, this->at(i + 2).get_operand_data(0) + (this->at(i + 1).is_operand_size(1, UD_SIZE_DWORD) ? 4 : 2)))
					{
						/* 0: xchg reg,(d)word ptr [esp+xx] */
						this->at(i).set_mnemonic(UD_Ixchg);
						this->at(i).set_operand(1, this->at(i + 2), 0);
						
						this->remove(i + 1, 2);
					}
					/*
						0: push reg
						1: mov reg,unknown ptr [mem]
						2: pop unknown ptr [mem]
					*/
					else if (this->at(i + 1).is_operand(1, this->at(i + 2), 0))
					{
						/* 0: xchg reg,unknown ptr [mem] */
						this->at(i).set_mnemonic(UD_Ixchg);
						this->at(i).set_operand(1, this->at(i + 1), 1);
						
						this->remove(i + 1, 2);
					}
				}
			}
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_arithmetics()
{
	for (std::size_t i = 0; i < this->size(); i++)
	{
		/*
			0: push reg
			1: mov reg,x1
			2: ___ x2,reg
			3: pop reg
		*/
		if (this->bounds(i, 3) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).compare_base(0, this->at(i + 1), 0) &&
			
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&
			
			this->at(i + 2).compare_mnemonic(true, false, true) &&
			this->at(i + 2).is_operand_type(1, UD_OP_REG) &&
			this->at(i + 2).is_operand_base(1, this->at(i + 1), 0) &&

			this->at(i + 3).is_mnemonic(UD_Ipop) &&
			this->at(i + 3).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 3).is_operand_base(0, this->at(i), 0))
		{
			/* 0: ___ x2,x1 */
			if (this->at(i + 2).is_operand_type(0, UD_OP_MEM) && this->at(i + 2).is_operand_base(0, UD_R_ESP))
				this->at(i + 2).dec_operand_data<uint32_t>(0, this->at(i).is_operand_base_size(0, UD_SIZE_DWORD) ? 4 : 2);

			this->at(i).set_mnemonic(this->at(i + 2));
			this->at(i).set_prefixes(this->at(i + 2));
			this->at(i).set_operand(0, this->at(i + 2), 0);
			this->at(i).set_operand(1, this->at(i + 1), 1);

			this->remove(i + 1, 3);
		}

		/*
			0: push reg/unknown ptr [mem]
			1: ___ esp/unknown ptr [esp+xx],(___)
			2: pop reg/unknown ptr [mem]
		*/
		if (this->bounds(i, 2) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&

			this->at(i + 1).compare_mnemonic(false, true, true) &&
			this->at(i + 1).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
			this->at(i + 1).is_operand_base(0, UD_R_ESP) &&
			this->at(i + 1).has_operand_index_not(0) &&
			this->at(i + 1).has_operand_scale_not(0) &&

			this->at(i + 2).is_mnemonic(UD_Ipop) &&
			this->at(i + 2).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
			this->at(i + 2).is_operand(0, this->at(i), 0))
		{
			/*
				0: push reg
				1: ___ byte ptr [esp+01],(___)
			*/
			if (this->at(i).is_operand_type(0, UD_OP_REG) &&
				this->at(i).is_operand_base_family(0, { UD_R_EAX, UD_R_ECX, UD_R_EDX, UD_R_EBX }) &&
				this->at(i + 1).is_operand_type(0, UD_OP_MEM, UD_SIZE_BYTE) &&
				this->at(i + 1).is_operand_data(0, 1))
			{
				/* 0: ___ reg,(___) */
				this->at(i).set_mnemonic(this->at(i + 1));
				this->at(i).set_operand_type(0, this->at(i + 2), 0);
				this->at(i).set_operand_size(0, UD_SIZE_BYTE);
				this->at(i).set_operand_base(0, this->at(i + 2).get_base_high_type(0));
				this->at(i).set_operand(1, this->at(i + 1), 1);

				this->remove(i + 1, 2);
			}
			/* 1: ___ esp/unknown ptr [esp],(___) */
			else if (this->at(i + 1).has_operand_data_not(0))
			{
				/* 0: ___ reg/unknown ptr [mem],(___) */
				this->at(i).set_mnemonic(this->at(i + 1));
				this->at(i).set_prefixes(this->at(i + 1));
				this->at(i).set_operand_type(0, this->at(i + 2), 0);
				
				if (this->at(i + 2).is_operand_type(0, UD_OP_REG))
				{
					this->at(i).set_operand_size(0, this->at(i + 1).get_operand_size(0));
					this->at(i).set_operand_base(0, this->at(i + 2).get_base_size_type(0, this->at(i + 1).get_operand_size(0)));
				}
				else
				{
					this->at(i).set_operand_type(0, this->at(i + 2).get_operand_type(0), this->at(i + 1).get_operand_size(0));
				}

				this->at(i).set_operand(1, this->at(i + 1), 1);

				this->remove(i + 1, 2);
			}
		}
		
		/*
			0: push reg
			1: ___ esp/unknown ptr [esp+xx],(___)
			2: ___ esp/unknown ptr [esp+xx],(___)
			3: pop reg
		*/
		if (this->bounds(1, 3) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			
			this->at(i + 1).compare_mnemonic(false, true, true) &&
			this->at(i + 1).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
			this->at(i + 1).is_operand_base(0, UD_R_ESP) &&
			this->at(i + 1).has_operand_index_not(0) &&
			this->at(i + 1).has_operand_scale_not(0) &&
			
			this->at(i + 2).compare_mnemonic(false, true, true) &&
			this->at(i + 2).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
			this->at(i + 2).is_operand(0, this->at(i + 1), 0) &&

			this->at(i + 3).is_mnemonic(UD_Ipop) &&
			this->at(i + 3).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 3).is_operand(0, this->at(i), 0))
		{
			/*
				0: push reg
				1: ___ byte ptr [esp+01],(___)
				2: ___ byte ptr [esp+01],(___)
			*/
			if (this->at(i).is_operand_type(0, UD_OP_REG) &&
				this->at(i).is_operand_base_family(0, { UD_R_EAX, UD_R_ECX, UD_R_EDX, UD_R_EBX }) &&
				this->at(i + 1).is_operand_type(0, UD_OP_MEM, UD_SIZE_BYTE) &&
				this->at(i + 1).is_operand_data(0, 1))
			{
				/*
					0: ___ byte ptr reg,(___)
					1: ___ byte ptr reg,(___)
				*/
				this->at(i).set_mnemonic(this->at(i + 1));
				this->at(i).set_operand_type(0, this->at(i + 3), 0);
				this->at(i).set_operand_size(0, UD_SIZE_BYTE);
				this->at(i).set_operand_base(0, this->at(i + 3).get_base_high_type(0));
				this->at(i).set_operand(1, this->at(i + 1), 1);
				
				this->at(i + 1).set_mnemonic(this->at(i + 2));
				this->at(i + 1).set_operand_type(0, this->at(i + 3), 0);
				this->at(i + 1).set_operand_size(0, UD_SIZE_BYTE);
				this->at(i + 1).set_operand_base(0, this->at(i + 3).get_base_high_type(0));
				this->at(i + 1).set_operand(1, this->at(i + 2), 1);

				this->remove(i + 2, 2);
			}
			/* 1: ___ esp/unknown ptr [esp],(___) */
			else if (this->at(i + 1).has_operand_data_not(0))
			{
				/*
					0: ___ unknown ptr reg,(___)
					1: ___ unknown ptr reg,(___)
				*/
				this->at(i).set_mnemonic(this->at(i + 1));
				this->at(i).set_prefixes(this->at(i + 1));
				this->at(i).set_operand_type(0, this->at(i + 3), 0);

				if (this->at(i + 3).is_operand_type(0, UD_OP_REG))
				{
					this->at(i).set_operand_size(0, this->at(i + 1).get_operand_size(0));
					this->at(i).set_operand_base(0, this->at(i + 3).get_base_size_type(0, this->at(i + 1).get_operand_size(0)));
					this->at(i).set_operand_index_null(0);
					this->at(i).set_operand_scale_null(0);
					this->at(i).set_operand_data_null(0);
				}
				else
				{
					this->at(i).set_operand_type(0, this->at(i + 3).get_operand_type(0), this->at(i + 1).get_operand_size(0));
				}

				this->at(i).set_operand(1, this->at(i + 1), 1);
			
				this->at(i + 1).set_mnemonic(this->at(i + 2));
				this->at(i + 1).set_prefixes(this->at(i + 2));
				this->at(i + 1).set_operand_type(0, this->at(i + 3), 0);
				
				if (this->at(i + 3).is_operand_type(0, UD_OP_REG))
				{
					this->at(i + 1).set_operand_size(0, this->at(i + 2).get_operand_size(0));
					this->at(i + 1).set_operand_base(0, this->at(i + 3).get_base_size_type(0, this->at(i + 2).get_operand_size(0)));
					this->at(i + 1).set_operand_index_null(0);
					this->at(i + 1).set_operand_scale_null(0);
					this->at(i + 1).set_operand_data_null(0);
				}
				else
				{
					this->at(i + 1).set_operand_type(0, this->at(i + 3).get_operand_type(0), this->at(i + 2).get_operand_size(0));
				}

				this->at(i + 1).set_operand(1, this->at(i + 2), 1);

				this->remove(i + 2, 2);
			}
		}

			
		/*
			0: push reg
			1: mov reg,x
			2: ___ reg,___
			3: mov x,reg
			4: pop reg
		*/
		if (this->bounds(1, 4) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).compare_base(0, this->at(i + 1), 0) &&
		
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 1).is_operand_type(1, UD_OP_REG) &&

			(this->at(i + 2).compare_mnemonic(false, true, true) || this->at(i + 2).compare_immediate()) &&
			this->at(i + 2).is_operand_type(0, UD_OP_REG) &&
			
			this->at(i + 3).is_mnemonic(UD_Imov) &&
			this->at(i + 3).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 3).is_operand_base(0, this->at(i + 1), 1) &&
			this->at(i + 3).is_operand_type(1, UD_OP_REG) &&
			this->at(i + 3).is_operand_base(1, this->at(i + 1), 0) &&
			this->at(i + 3).is_operand_base(1, this->at(i + 2), 0) &&

			this->at(i + 4).is_mnemonic(UD_Ipop) &&
			this->at(i + 4).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 4).is_operand_base(0, this->at(i), 0))
		{
			/* 0: ___ x,___ */
			this->at(i).set_mnemonic(this->at(i + 2));
			this->at(i).set_prefixes(this->at(i + 2));
			this->at(i).set_operand(0, this->at(i + 3), 0);
			this->at(i).set_operand(1, this->at(i + 2), 1);

			this->remove(i + 1, 4);
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_offset()
{
	for (std::size_t i = 0; i < this->size(); i++)
	{
		/*
			0: add|sub x1,imm
			1: add/sub x1,___
			2: sub|add x1,imm
		*/
		if (this->bounds(i, 2) &&
			((this->at(i).is_mnemonic(UD_Iadd) && this->at(i + 2).is_mnemonic(UD_Isub)) ||
			(this->at(i).is_mnemonic(UD_Isub) && this->at(i + 2).is_mnemonic(UD_Iadd))) &&
			this->at(i).is_operand_type(1, UD_OP_IMM) &&

			this->at(i + 1).is_mnemonic({ UD_Iadd, UD_Isub }) &&
			this->at(i + 1).is_operand(0, this->at(i), 0) &&
			this->at(i + 1).is_operand_type_not(1, UD_OP_IMM) && 
			
			this->at(i + 2).is_operand(0, this->at(i + 1), 0) &&
			this->at(i + 2).is_operand_type(1, UD_OP_IMM) &&
			this->at(i + 2).is_operand_data(1, this->at(i), 1))
		{
			/* 0: add/sub x1,___ */
			this->at(i).set_mnemonic(this->at(i + 1));
			this->at(i).set_operand(1, this->at(i + 1), 1);

			this->remove(i + 1, 2);
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_generated_memory()
{
	for (std::size_t i = 0; i < this->size(); i++)
	{
		/*
			0: push reg
			1: mov reg,reg/imm
		*/
		if (this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 1).is_operand_type(1, { UD_OP_REG, UD_OP_IMM }))
		{
			/* 1: mov reg,reg */
			if (this->at(i + 1).is_operand_type(1, UD_OP_REG) &&
				this->at(i + 1).is_operand_base(1, this->at(i + 1), 0))
			{
				continue;
			}

			/* 1: mov regx,reg/imm */
			if (this->at(i + 1).is_operand_base(0, this->at(i), 0))
			{
				ud_type base_type = UD_NONE;
				uint32_t registers = 0;
					
				/*
					0: push regx
					1: mov regx,regb
				*/
				if (this->at(i + 1).is_operand_base(0, this->at(i), 0) &&
					this->at(i + 1).is_operand_type(1, UD_OP_REG) &&
					this->at(i + 1).is_operand_base_not(1, this->at(i + 1), 0))
				{
					base_type = this->at(i + 1).get_base_type(1);
					registers++;
				}

				bool is_valid = true;

				std::size_t j = 0;
				std::size_t index = 0;

				for (j = 0; j < (this->size() - (i + 2)); j++)
				{
					index = (i + 2 + j);

					/* 2+j: ___ ___,___ */
					if (!this->at(index).compare_mnemonic(true, true, true))
					{
						is_valid = false;
						break;
					}

					/* 2+j: (___ != mov) reg,(imm) */
					if (this->at(index).is_mnemonic_not(UD_Imov) &&
						this->at(index).is_operand_type(0, UD_OP_REG) &&
						this->at(index).is_operand_type(1, { UD_NONE, UD_OP_IMM, UD_OP_CONST }))
					{
						/* 2+j: (___ != mov) (reg != regx),(imm) */
						if (this->at(index).is_operand_base_not(0, this->at(i + 1), 0))
						{
							is_valid = false;
							break;
						}
					}
					/* 2+j: (___ != mov) reg,reg  */
					else if (this->at(index).is_mnemonic_not(UD_Imov) &&
						this->at(index).is_operand_type(0, UD_OP_REG) &&
						this->at(index).is_operand_type(1, UD_OP_REG) &&
						this->at(index).is_operand_base_not(1, this->at(index), 0))
					{
						/* 2+j: (___ != mov) (reg != regx),reg */
						if (this->at(index).is_operand_base_not(0, this->at(i + 1), 0))
						{
							is_valid = false;
							break;
						}
						
						base_type = this->at(index).get_base_type(1);
						registers++;
					}
					else
					{
						/* 2+j: ___ reg,unknown ptr [mem] */
						if (this->at(index).is_operand_type(0, UD_OP_REG) &&
							this->at(index).is_operand_type(1, UD_OP_MEM))
						{
							/*
								2+j:	___ reg,unknown ptr [regx]
								2+j+1:	pop regx
							*/
							if (this->bounds(index, 1) &&
								(this->at(index).is_operand_base(0, this->at(i + 1), 0) ||
								this->at(index).is_operand_base_not(1, this->at(i + 1), 0) ||
								this->at(index).has_operand_index(1) ||
								this->at(index).has_operand_scale(1) ||
								this->at(index).has_operand_data(1) ||
								
								this->at(index + 1).is_mnemonic_not(UD_Ipop) ||
								this->at(index + 1).is_operand_type_not(0, UD_OP_REG) ||
								this->at(index + 1).is_operand_base_not(0, this->at(index), 1) ||
								this->at(index + 1).is_operand_base_not(0, this->at(i), 0)))
							{
								is_valid = false;
							}
						}
						/* 2+j: ___ unknown ptr [mem],reg */
						else if (this->at(index).is_operand_type(0, UD_OP_MEM) &&
							this->at(index).is_operand_type(1, UD_OP_REG))
						{
							/*
								2+j:	___ unknown ptr [regx],reg
								2+j+1:	pop regx
							*/
							if (this->bounds(index, 1) &&
								(this->at(index).is_operand_base(1, this->at(i + 1), 0) ||
								this->at(index).is_operand_base_not(0, this->at(i + 1), 0) ||
								this->at(index).has_operand_index(0) ||
								this->at(index).has_operand_scale(0) ||
								this->at(index).has_operand_data(0) ||
								
								this->at(index + 1).is_mnemonic_not(UD_Ipop) ||
								this->at(index + 1).is_operand_type_not(0, UD_OP_REG) ||
								this->at(index + 1).is_operand_base_not(0, this->at(index), 0) ||
								this->at(index + 1).is_operand_base_not(0, this->at(i), 0)))
							{
								is_valid = false;
							}
						}
						/* 2+j: ___ unknown ptr [mem],imm */
						else if (this->at(index).is_operand_type(0, UD_OP_MEM) &&
							this->at(index).is_operand_type(1, { UD_OP_IMM, UD_OP_CONST }))
						{
							/*
								2+j:	___ unknown ptr [regx],imm
								2+j+1:	pop regx
							*/
							if (this->bounds(index, 1) &&
								(this->at(index).is_operand_base_not(0, this->at(i + 1), 0) ||
								this->at(index).has_operand_index(0) ||
								this->at(index).has_operand_scale(0) ||
								this->at(index).has_operand_data(0) ||
								
								this->at(index + 1).is_mnemonic_not(UD_Ipop) ||
								this->at(index + 1).is_operand_type_not(0, UD_OP_REG) ||
								this->at(index + 1).is_operand_base_not(0, this->at(index), 0) ||
								this->at(index + 1).is_operand_base_not(0, this->at(i), 0)))
							{
								is_valid = false;
							}
						}
						else
						{
							is_valid = false;
						}

						break;
					}
				}

				if (is_valid && registers == 1)
				{
					this->at(i).set_mnemonic(this->at(index));
					this->at(i).set_prefixes(this->at(index));

					uint32_t imm_product = 0;
					ud_size imm_size = UD_SIZE_NONE;

					for (std::size_t k = 0; k < (j + 1); k++)
					{
						if (this->at(i + 1 + k).is_operand_type_not(1, UD_OP_REG))
						{
							if (k == 0)
								imm_product = this->at(i + 1).get_operand_data(1);
							else
								instruction::emulate(this->at(i + 1 + k).get_mnemonic(), this->at(i + 1).get_base_size(0), this->at(i + 1 + k).get_operand_data(1), &imm_product);
						}
					}

					if (this->at(index).is_operand_type(1, UD_OP_MEM))
					{
						/* 0: ___ reg,unknown ptr [regb+d] ; b = regb, d = imm (product) */
						this->at(i).set_operand(0, this->at(index), 0);
						this->at(i).set_operand(1, this->at(index), 1);
						this->at(i).set_operand_base(1, base_type);
						this->at(i).set_operand_index_null(1);
						this->at(i).set_operand_scale_null(1);
						this->at(i).set_operand_offset(1, UD_SIZE_DWORD);
						this->at(i).set_operand_data(1, imm_product);
					}
					else
					{
						/* 0: ___ unknown ptr [regb+d],___ ; b = regb, d = imm (product) */
						this->at(i).set_operand(0, this->at(index), 0);
						this->at(i).set_operand_base(0, base_type);
						this->at(i).set_operand_index_null(0);
						this->at(i).set_operand_scale_null(0);
						this->at(i).set_operand_offset(0, UD_SIZE_DWORD);
						this->at(i).set_operand_data(0, imm_product);
						this->at(i).set_operand(1, this->at(index), 1);
					}

					this->remove(i + 1, 2 + j + 1);
				}
			}
		}

		
		/*
			0: push reg (x)
			1: mov x,reg (i)
			2: shl x,imm (s)
			3: add x,imm (d)
			4: add x,reg (b)
			5: ___ ___,unknown ptr [x]
			5: ___ unknown ptr [x],___
			6: pop x
		*/
		if (this->bounds(1, 6) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 1).is_operand_base(0, this->at(i), 0) &&
			this->at(i + 1).is_operand_type(1, UD_OP_REG) &&
			this->at(i + 1).is_operand_base_not(1, this->at(i + 1), 0) &&
			
			this->at(i + 2).is_mnemonic(UD_Ishl) &&
			this->at(i + 2).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 2).is_operand_base(0, this->at(i + 1), 0) &&
			this->at(i + 2).is_operand_type(1, { UD_OP_IMM, UD_OP_CONST }) &&
			
			this->at(i + 3).is_mnemonic(UD_Iadd) &&
			this->at(i + 3).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 3).is_operand_base(0, this->at(i + 2), 0) &&
			this->at(i + 3).is_operand_type(1, UD_OP_IMM) &&
			
			this->at(i + 4).is_mnemonic(UD_Iadd) &&
			this->at(i + 4).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 4).is_operand_base(0, this->at(i + 3), 0) &&
			this->at(i + 4).is_operand_type(1, UD_OP_REG) &&

			this->at(i + 5).compare_mnemonic(true, false, true) &&
			((this->at(i + 5).is_operand_type(0, UD_OP_MEM) &&
			this->at(i + 5).is_operand_base(0, this->at(i + 2), 0) &&
			this->at(i + 5).has_operand_index_not(0) &&
			this->at(i + 5).has_operand_scale_not(0) &&
			this->at(i + 5).has_operand_data_not(0)) ||
			(this->at(i + 5).is_operand_type(1, UD_OP_MEM) &&
			this->at(i + 5).is_operand_base(1, this->at(i + 2), 0) &&
			this->at(i + 5).has_operand_index_not(1) &&
			this->at(i + 5).has_operand_scale_not(1) &&
			this->at(i + 5).has_operand_data_not(1))) &&
			
			this->at(i + 6).is_mnemonic(UD_Ipop) &&
			this->at(i + 6).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 6).is_operand_base(0, this->at(i), 0))
		{
			this->at(i).set_mnemonic(this->at(i + 5));
			this->at(i).set_prefixes(this->at(i + 5));

			/* 5: ___ ___,unknown ptr [mem] */
			if (this->at(i + 5).is_operand_type(1, UD_OP_MEM))
			{
				/* 0: ___ ___,unknown ptr [b+i*s+d] */
				if (this->at(i + 5).is_operand_base(1, UD_R_ESP))
					this->at(i + 5).dec_operand_data<uint32_t>(1, this->at(i).get_base_size(0) == UD_SIZE_DWORD ? 4 : 2);

				this->at(i).set_operand(0, this->at(i + 5), 0);

				this->at(i).set_operand_type(1, this->at(i + 5), 1);
				this->at(i).set_operand_base(1, this->at(i + 4), 1);
				this->at(i).set_operand_index(1, this->at(i + 1), 1);
				this->at(i).set_operand_scale_by_exponent(1, this->at(i + 2).get_operand_data<uint8_t>(1));
				this->at(i).set_operand_data(1, this->at(i + 3), 1);
			}
			/* 5: ___ unknown ptr [mem],___ */
			else
			{
				/* 0: ___ unknown ptr [b+i*s+d],___ */
				if (this->at(i + 5).is_operand_base(0, UD_R_ESP))
					this->at(i + 5).dec_operand_data<uint32_t>(0, this->at(i).get_base_size(0) == UD_SIZE_DWORD ? 4 : 2);

				this->at(i).set_operand(1, this->at(i + 5), 1);

				this->at(i).set_operand_type(0, this->at(i + 5), 0);
				this->at(i).set_operand_base(0, this->at(i + 4), 1);
				this->at(i).set_operand_index_by_base(0, this->at(i + 1), 1);
				this->at(i).set_operand_scale_by_exponent(0, this->at(i + 2).get_operand_data<uint8_t>(1));
				this->at(i).set_operand_data(0, this->at(i + 3), 1);
			}

			this->remove(i + 1, 6);
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_generated_register()
{
	for (std::size_t i = (this->size() - 1); static_cast<int32_t>(i) >= 0; i--)
	{
		/*
			0: push reg
			1: mov reg,imm
		*/
		if (this->bounds(i, 1) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).compare_base(0, this->at(i + 1), 0) &&
			
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 1).is_operand_type(1, UD_OP_IMM))
		{
			bool is_valid = true;

			std::size_t j = 0;
			std::size_t index = 0;

			for (j = 0; j < (this->size() - (i + 2)); j++)
			{
				index = (i + 2 + j);

				/* 2+j: ___ ___,___ */
				if (this->at(index).compare_mnemonic_not(true, true, true))
				{
					is_valid = false;
					break;
				}
				
				/* 2+j: (___ != mov) reg,(imm) */
				if (this->at(index).is_mnemonic_not(UD_Imov) &&
					this->at(index).is_operand_type(0, UD_OP_REG) &&
					this->at(index).is_operand_type(1, { UD_NONE, UD_OP_IMM, UD_OP_CONST }))
				{
					if (this->at(index).is_operand_base_not(0, this->at(i + 1), 0))
					{
						is_valid = false;
						break;
					}
				}
				else
				{
					/* 2+j: ___ reg,reg */
					if (this->at(index).is_operand_type(0, UD_OP_REG) &&
						this->at(index).is_operand_type(1, UD_OP_REG))
					{
						if (this->bounds(index, 1) &&
							this->at(index).is_operand_base(0, this->at(i + 1), 0) ||
							this->at(index + 1).is_mnemonic_not(UD_Ipop) ||
							this->at(index + 1).is_operand_type_not(0, UD_OP_REG) ||
							this->at(index + 1).is_operand_base_not(0, this->at(i), 0) ||
							this->at(index + 1).compare_base_not(0, this->at(index), 1))
						{
							is_valid = false;
						}
					}
					/* 2+j: ___ unknown ptr [mem],reg */
					else if (this->at(index).is_operand_type(0, UD_OP_MEM) &&
						this->at(index).is_operand_type(1, UD_OP_REG))
					{
						if (this->bounds(index, 1) &&
							this->at(index + 1).is_mnemonic_not(UD_Ipop) ||
							this->at(index + 1).is_operand_type_not(0, UD_OP_REG) ||
							this->at(index + 1).is_operand_base_not(0, this->at(i), 0) ||
							this->at(index + 1).compare_base_not(0, this->at(index), 1))
						{
							is_valid = false;
						}
					}
					else
					{
						is_valid = false;
					}

					break;
				}
			}

			if (is_valid)
			{
				this->at(i).set_mnemonic(this->at(index));
				this->at(i).set_prefixes(this->at(index));
				
				this->at(i).set_operand(0, this->at(index), 0);
				this->at(i).set_operand(1, this->at(i + 1), 1);

				uint32_t imm_product = this->at(i + 1).get_operand_data<uint32_t>(1);

				for (std::size_t k = 0; k < j; k++)
					instruction::emulate(this->at(i + 2 + k).get_mnemonic(), this->at(i + 1).get_base_size(0), this->at(i + 2 + k).get_operand_data(1), &imm_product);

				this->at(i).set_operand_data(1, imm_product);

				if (this->at(i).is_operand_type(0, UD_OP_MEM) && this->at(i).is_operand_base(0, UD_R_ESP))
					this->at(i).dec_operand_data<uint32_t>(0, this->at(index + 1).is_operand_base_size(0, UD_SIZE_DWORD) ? 4 : 2);

				this->remove(i + 1, 2 + j + 1);
			}
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_neg()
{
	for (std::size_t i = 0; i < this->size(); i++)
	{
		/*
			0: push 0
			1: sub unknown ptr [esp],reg
			2: pop reg
		*/
		if (this->bounds(i, 2) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_IMM) &&
			this->at(i).is_operand_data(0, 0) &&

			this->at(i + 1).is_mnemonic(UD_Isub) &&
			this->at(i + 1).is_operand_type(0, UD_OP_MEM) &&
			this->at(i + 1).is_operand_base(0, UD_R_ESP) &&
			this->at(i + 1).has_operand_index_not(0) &&
			this->at(i + 1).has_operand_scale_not(0) &&
			this->at(i + 1).has_operand_data_not(0) &&
			this->at(i + 1).is_operand_type(1, UD_OP_REG) &&
			this->at(i + 1).is_operand_base_not(1, UD_R_ESP) &&

			this->at(i + 2).is_mnemonic(UD_Ipop) &&
			this->at(i + 2).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 2).is_operand_base(0, this->at(i + 1), 1))
		{
			/* 0: neg reg */
			this->at(i).set_mnemonic(UD_Ineg);
			this->at(i).set_operand(0, this->at(i + 1), 1);

			this->remove(i + 1, 2);
		}

		/* 0: not ___ */
		if (this->bounds(i, 1) &&
			this->at(i).is_mnemonic(UD_Inot))
		{
			/* 1: inc ___ */
			if (this->at(i + 1).is_mnemonic(UD_Iinc))
			{
				/*
					0: not reg/unknown ptr [mem]
					1: inc reg/unknown ptr [mem]
				*/
				if (this->at(i).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
					this->at(i).is_operand(0, this->at(i + 1), 0))
				{
					/* 0: neg reg/unknown ptr [mem] */
					this->at(i).set_mnemonic(UD_Ineg);

					this->remove(i + 1);
				}
			}
			/* 1: add ___,___ */
			else if (this->at(i + 1).is_mnemonic(UD_Iadd))
			{
				/*
					0: not reg/unknown ptr [mem]
					1: add reg/unknown ptr [mem],1
				*/
				if (this->at(i).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
					this->at(i).is_operand(0, this->at(i + 1), 0) &&
					this->at(i + 1).is_operand_type(1, UD_OP_IMM) &&
					this->at(i + 1).is_operand_data(1, 1))
				{
					/* 0: neg reg/unknown ptr [mem] */
					this->at(i).set_mnemonic(UD_Ineg);

					this->remove(i + 1);
				}
			}
			/* 1: sub ___,___ */
			else if (this->at(i + 1).is_mnemonic(UD_Isub))
			{
				/*
					0: not reg/unknown ptr [mem]
					1: sub reg/unknown ptr [mem],-1
				*/
				if (this->at(i).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
					this->at(i).is_operand(0, this->at(i + 1), 0) && 
					this->at(i + 1).is_operand_type(1, UD_OP_IMM, UD_SIZE_BYTE) &&
					this->at(i + 1).is_operand_data(1, { 255, -1 }))
				{
					/* 0: neg reg/unknown ptr [mem] */
					this->at(i).set_mnemonic(UD_Ineg);

					this->remove(i + 1);
				}
			}
		}

		/* 1: not ___ */
		if (this->bounds(i, 1) &&
			this->at(i + 1).is_mnemonic(UD_Inot))
		{
			/* 0: dec ___ */
			if (this->at(i).is_mnemonic(UD_Idec))
			{
				/*
					0: dec reg/unknown ptr [mem]
					1: not reg/unknown ptr [mem]
				*/
				if (this->at(i + 1).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
					this->at(i + 1).is_operand(0, this->at(i), 0))
				{
					/* 0: neg reg/unknown ptr [mem] */
					this->at(i).set_mnemonic(UD_Ineg);

					this->remove(i + 1);
				}
			}
			/*
				0: add ___
				1: not ___
			*/
			else if (this->at(i).is_mnemonic(UD_Iadd))
			{
				/*
					0: add reg/unknown ptr [mem],255/-1
					1: not reg/unknown ptr [mem]
				*/
				if (this->at(i).is_operand_type(1, UD_OP_IMM, UD_SIZE_BYTE) &&
					this->at(i).is_operand_data(1, { 255, -1 }) &&
					this->at(i + 1).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
					this->at(i + 1).is_operand(0, this->at(i), 0))
				{
					/* 0: neg reg/unknown ptr [mem] */
					this->at(i).set_mnemonic(UD_Ineg);
					this->at(i).set_operand_null(1);

					this->remove(i + 1);
				}
			}
			/* 0: sub ___,___ */
			else if (this->at(i).is_mnemonic(UD_Isub))
			{
				/*
					0: sub reg/unknown ptr [mem],1
					1: not reg/unknown ptr [mem]
				*/
				if (this->at(i).is_operand_type(1, UD_OP_IMM) &&
					this->at(i).is_operand_data(1, 1) &&
					this->at(i + 1).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
					this->at(i + 1).is_operand(0, this->at(i), 0))
				{
					/* 0: neg [mem]/reg */
					this->at(i).set_mnemonic(UD_Ineg);
					this->at(i).set_operand_null(1);

					this->remove(i + 1);
				}
			}
		}

		/*
			0: push 0
			1: sub byte ptr [esp],(reg != esp)
			2: mov reg,byte ptr [esp]
			3: add esp,02/04
		*/
		if (this->bounds(i, 3) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_IMM) &&
			this->at(i).is_operand_data(0, 0) &&
			
			this->at(i + 1).is_mnemonic(UD_Isub) &&
			this->at(i + 1).is_operand_type(0, UD_OP_MEM, UD_SIZE_BYTE) &&
			this->at(i + 1).is_operand_base(0, UD_R_ESP) &&
			this->at(i + 1).has_operand_index_not(0) &&
			this->at(i + 1).has_operand_scale_not(0) &&
			this->at(i + 1).has_operand_data_not(0) &&
			this->at(i + 1).is_operand_type(1, UD_OP_REG) &&
			this->at(i + 1).is_operand_base_not(1, UD_R_ESP) &&
			
			this->at(i + 2).is_mnemonic(UD_Imov) &&
			this->at(i + 2).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 2).is_operand_base(0, this->at(i + 1), 1) &&
			this->at(i + 2).is_operand_type(1, UD_OP_MEM, UD_SIZE_BYTE) &&
			this->at(i + 2).is_operand_base(1, UD_R_ESP) &&
			this->at(i + 2).has_operand_index_not(1) &&
			this->at(i + 2).has_operand_scale_not(1) &&
			this->at(i + 2).has_operand_data_not(1) &&
			
			this->at(i + 3).is_mnemonic(UD_Iadd) &&
			this->at(i + 3).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 3).is_operand_base(0, UD_R_ESP) &&
			this->at(i + 3).is_operand_type(1, UD_OP_IMM) &&
			((this->at(i + 3).is_operand_data(1, 2) && this->at(i).is_operand_size(0, UD_SIZE_WORD)) ||
			(this->at(i + 3).is_operand_data(1, 4) && this->at(i).is_operand_size(0, UD_SIZE_DWORD))))
		{
			/* 0: neg reg */
			this->at(i).set_mnemonic(UD_Ineg);
			this->at(i).set_operand(0, this->at(i + 1), 1);

			this->remove(i + 1, 3);
		}

		/*
			0: push reg
			1: mov reg,0
			2: sub reg,x1
			3: mov/xchg reg/unknown ptr [mem],reg/unknown ptr [mem]
			4: pop reg
		*/
		if (this->bounds(i, 4) &&
			this->at(i).is_mnemonic(UD_Ipush) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).compare_base(0, this->at(i + 1), 0) &&
			
			this->at(i + 1).is_mnemonic(UD_Imov) &&
			this->at(i + 1).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 1).is_operand_type(1, UD_OP_IMM) &&
			this->at(i + 1).is_operand_data(1, 0) &&
			
			this->at(i + 2).is_mnemonic(UD_Isub) &&
			this->at(i + 2).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 2).is_operand_base(0, this->at(i + 1), 0) &&
			this->at(i + 2).is_operand_type(1, { UD_OP_REG, UD_OP_MEM }) &&
			this->at(i + 2).is_operand_base_not(1, this->at(i + 2), 0) &&

			this->at(i + 3).is_mnemonic({ UD_Imov, UD_Ixchg }) &&
			this->at(i + 3).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
			this->at(i + 3).is_operand_type(1, { UD_OP_REG, UD_OP_MEM }) &&

			this->at(i + 4).is_mnemonic(UD_Ipop) &&
			this->at(i + 4).is_operand_type(0, UD_OP_REG) &&
			this->at(i + 4).is_operand_base(0, this->at(i), 0))
		{
			/* 3: mov x1,reg */
			if (this->at(i + 3).is_mnemonic(UD_Imov) &&
				this->at(i + 3).is_operand_sib(0, this->at(i + 2), 1) &&
				this->at(i + 3).is_operand_data(0, this->at(i + 2), 1) &&
				this->at(i + 3).is_operand_base(1, this->at(i + 2), 0))
			{
				/* 0: neg x1 */
				this->at(i).set_mnemonic(UD_Ineg);
				this->at(i).set_prefixes(this->at(i + 2));
				this->at(i).set_operand(0, this->at(i + 2), 1);

				this->remove(i + 1, 4);
			}
			/* 3: xchg x1|reg,reg|x1 */
			else if (this->at(i + 3).is_mnemonic(UD_Ixchg) &&
				((this->at(i + 3).is_operand(0, this->at(i + 2), 1) && this->at(i + 3).is_operand_base(1, this->at(i + 2), 0)) ||
				(this->at(i + 3).is_operand(1, this->at(i + 2), 1) && this->at(i + 3).is_operand_base(0, this->at(i + 2), 0))))
			{
				/* 0: neg x1 */
				this->at(i).set_mnemonic(UD_Ineg);
				this->at(i).set_prefixes(this->at(i + 2));
				this->at(i).set_operand(0, this->at(i + 2), 1);

				this->remove(i + 1, 4);
			}
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_mov_v2()
{
	for (std::size_t i = (this->size() - 1); static_cast<int32_t>(i) >= 0; i--)
	{
		/*
			0: mov reg/unknown ptr [mem],imm
			1: (___ != mov) reg/unknown ptr [mem],___
		*/
		if (this->bounds(i, 1) &&
			this->at(i).is_mnemonic(UD_Imov) &&
			this->at(i).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }) &&
			this->at(i).is_operand_type(1, UD_OP_IMM) &&
			
			this->at(i + 1).is_mnemonic_not(UD_Imov) &&
			this->at(i + 1).is_operand_sib(0, this->at(i), 0) &&
			this->at(i + 1).is_operand_data(0, this->at(i), 0))
		{
			std::size_t j = 0;
			std::size_t index = 0;

			for (j = 0; j < (this->size() - (i + 1)); j++)
			{
				index = (i + 1 + j);

				/* ___ reg/unknown ptr [mem],(imm) */
				if (this->at(index).compare_mnemonic_not(false, true, true) ||
					this->at(index).is_operand_not(0, this->at(i), 0) ||
					this->at(index).is_operand_type_not(1, { UD_NONE, UD_OP_IMM, UD_OP_CONST }))
				{
					break;
				}
			}

			if (j != 0)
			{
				uint32_t imm_product = this->at(i).get_operand_data(1);

				for (std::size_t k = 0; k < j; k++)
				{
					if (this->at(i).is_operand_type(0, UD_OP_REG))
						instruction::emulate(this->at(i + 1 + k).get_mnemonic(), this->at(i).get_base_size(0), this->at(i + 1 + k).get_operand_data(1), &imm_product);
					else
						instruction::emulate(this->at(i + 1 + k).get_mnemonic(), this->at(i).get_operand_size(0), this->at(i + 1 + k).get_operand_data(1), &imm_product);
				}

				this->at(i).set_operand_data(1, imm_product);

				this->remove(i + 1, j);
			}
		}
	}
}

void instruction_container_deobfuscator::deobfuscate_fillers()
{
	for (std::size_t i = 0; i < this->size(); i++)
	{
		/* 0: mov reg,reg */
		if (this->at(i).is_mnemonic(UD_Imov) &&
			this->at(i).is_operand_type(0, UD_OP_REG) &&
			this->at(i).is_operand_type(1, UD_OP_REG) &&
			this->at(i).is_operand_base(1, this->at(i), 0))
		{
			this->remove(i--);
		}
		
		//try
		//{
		//	/* 
		//		0: pushad
		//		1: popad
		//	*/
		//	if (instructions.at(i).mnemonic == MNEMONIC_PUSHA &&
		//		instructions.at(i + 1).mnemonic == MNEMONIC_POPA)
		//	{
		//		this->remove_instructions(instructions, i, 2);
		//	}
		//}
		//catch (std::out_of_range const& e)
		//{
		//	UNREFERENCED_PARAMETER(e);
		//	/* Ignore out-of-range exceptions. They occur when (index >= size). */
		//}
		//
		//try
		//{
		//	/* 
		//		0: pushfd
		//		1: popfd
		//	*/
		//	if (instructions.at(i).mnemonic == MNEMONIC_PUSHF &&
		//		instructions.at(i + 1).mnemonic == MNEMONIC_POPF)
		//	{
		//		this->remove_instructions(instructions, i, 2);
		//	}
		//}
		//catch (std::out_of_range const& e)
		//{
		//	UNREFERENCED_PARAMETER(e);
		//	/* Ignore out-of-range exceptions. They occur when (index >= size). */
		//}
		//
		//try
		//{
		//	/*
		//		0: push x1
		//		1: pop x1
		//	*/
		//	if (instructions.at(i).mnemonic == MNEMONIC_PUSH &&
		//		instructions.at(i + 1).mnemonic == MNEMONIC_POP &&
		//		instructions.at(i).operands[0].type == instructions.at(i + 1).operands[0].type &&
		//		instructions.at(i).operands[0].size == instructions.at(i + 1).operands[0].size &&
		//		instructions.at(i).operands[0].base.type == instructions.at(i + 1).operands[0].base.type &&
		//		instructions.at(i).operands[0].base.size == instructions.at(i + 1).operands[0].base.size &&
		//		instructions.at(i).operands[0].index.type == instructions.at(i + 1).operands[0].index.type &&
		//		instructions.at(i).operands[0].index.size == instructions.at(i + 1).operands[0].index.size &&
		//		instructions.at(i).operands[0].scale == instructions.at(i + 1).operands[0].scale &&
		//		instructions.at(i).operands[0].data.dword == instructions.at(i + 1).operands[0].data.dword)
		//	{
		//		this->remove_instructions(instructions, i, 2);
		//	}
		//}
		//catch (std::out_of_range const& e)
		//{
		//	UNREFERENCED_PARAMETER(e);
		//	/* Ignore out-of-range exceptions. They occur when (index >= size). */
		//}
	}
}
//
//void oreans_deobfuscator::deobfuscate_new_types(std::vector<x86_instruction>& instructions)
//{
//	for (std::size_t i = 0; i < instructions.size(); i++)
//	{
//		try
//		{
//			/*
//				0: push reg
//				1: mov [esp],imm32
//			*/
//			if (instructions.at(i).mnemonic == MNEMONIC_PUSH &&
//				instructions.at(i).operands[0].type == OPERAND_TYPE_REGISTER &&
//				instructions.at(i + 1).mnemonic == MNEMONIC_MOV &&
//				instructions.at(i + 1).operands[0].is_type(OPERAND_TYPE_MEMORY, OPERAND_SIZE_DWORD) &&
//				instructions.at(i + 1).operands[0].has_params(true, false, false, false) &&
//				instructions.at(i + 1).operands[0].base.is_type(REGISTER_ESP, OPERAND_SIZE_DWORD) &&
//				instructions.at(i + 1).operands[1].is_type(OPERAND_TYPE_IMMEDIATE))
//			{
//				/* 0: push imm32 */
//				instructions.at(i).mnemonic = MNEMONIC_PUSH;
//				instructions.at(i).operands[0].set_type(instructions.at(i + 1).operands[1]);
//				instructions.at(i).operands[0].data.dword = instructions.at(i + 1).operands[1].data.dword;
//
//				this->remove_instructions(instructions, i + 1);
//			}
//		}
//		catch (std::out_of_range const& e)
//		{
//			UNREFERENCED_PARAMETER(e);
//			/* Ignore out-of-range exceptions. They occur when (index >= size). */
//		}
//	}
//}
```

`TDE/instruction_container_deobfuscator.hpp`:

```hpp
#ifndef INSTRUCTION_CONTAINER_DEOBFUSCATOR_HPP_
#define INSTRUCTION_CONTAINER_DEOBFUSCATOR_HPP_

#include "instruction_container_base.hpp"

class instruction_container_deobfuscator : public instruction_container_base
{
public:
	void deobfuscate();
	void deobfuscate_wild();

private:
	/*
		Deobfuscates the following push-obfuscation patterns:

		0: sub esp,02/04				->		0: push reg
		1: mov (d)word ptr [esp],reg

		0: push reg/imm					->		0: push reg
		1: mov (d)word ptr [esp],reg

		- Each pattern contains a special stack pattern
		1: mov (d)word ptr [esp],(e)sp	->		0: push (e)sp
		2: add unknown ptr [esp],02/04
	*/
	void deobfuscate_push();

	/*
		Deobfuscates the following pop-obfuscation patterns:

		0: mov reg,(d)word ptr [esp]	->		0: pop reg
		1: add esp,02/04

		0: mov (e)sp,(d)word ptr [esp]	->		0: pop (e)sp
	*/
	void deobfuscate_pop();	
	
	/*
		Deobfuscates the following stack-obfuscation patterns:
		
		0: push (reg != esp)			->		0: add/sub esp,imm
		1: mov reg,esp
		2: add reg,04
		3: add/sub reg,imm
		4: xchg dword ptr [esp],reg
		4: xchg reg,dword ptr [esp]
		5: pop esp
	*/
	void deobfuscate_stack();
	
	/*	
		Deobfuscates the following xchg-obfuscation patterns:
		
		0: xor x1,x2					->		0: xchg x1,x2
		1: xor x2,x1
		2: xor x1,x2
		
		0: push (reg != esp)			->		0: xchg reg,dword ptr [esp]
		1: mov reg,dword ptr [esp+4]
		2: pop dword ptr [esp]
		
		0: push reg1					->		0: xchg x2,x3
		1: mov reg1,x2
		2: mov x2,x3
		3: mov x3,reg1
		4: pop reg1
	*/
	void deobfuscate_xchg_v1();

	/*
		Deobfuscates the following mov-obfuscation patterns:
		
		0: push x1						->		0: mov x2,x1
		1: pop x2

		0: push x1						->		0: mov x2,x1
		1: sub|add|xor unknown ptr [esp],imm
		2: pop x2
		3: add|sub|xor x2,imm

		0: push reg						->		0: mov x,imm
		1: mov reg,imm
		2: mov x,imm
		3: ___ x,reg
		4: pop reg
		
		0: push reg						->		0: mov x,imm
		1: mov reg,imm
		2: mov x,imm
		3: ___ x,reg
		4: ___ x,imm
		5: pop reg
	*/
	void deobfuscate_mov_v1();
	
	/*
		Deobfuscates the following xchg-obfuscation patterns:

		0: xchg x1,x2					->		0: ___ x2/x1,(imm)
		1: ___ x1/x2,(imm)
		2: xchg x1,x2

		0: xchg x1,x2					->		0: ___ x2/x1,(imm)
		1: ___ x1/x2,(imm)						1: ___ x2/x1,(imm)
		2: ___ x1/x2,(imm)
		3: xchg x1,x2

		0: push x1						->		0: xchg x1,x2
		1: mov x1,x2
		2: pop x2

		0: push (d)word ptr [esp+xx]	->		0: xchg (d)word ptr [esp+xx],reg
		1: mov (d)word ptr [esp+xx+04],reg
		2: pop reg

		0: push reg						->		0: xchg reg,(d)word ptr [esp+xx]
		1: mov reg,(d)word ptr [esp+xx+04]
		2: pop (d)word ptr [esp+xx]
	*/
	void deobfuscate_xchg_v2();
	
	/*
		Deobfuscates the following ??-obfuscation patterns:
					
		0: push reg						->		0: ___ x2,x1
		1: mov reg,x1
		2: ___ x2,reg
		3: pop reg

		0: push reg						->		0: ___ h(reg),(___)
		1: ___ byte ptr [esp+01],(___)
		2: pop reg

		0: push reg/unknown ptr [mem]	->		0: ___ reg/unknown ptr [mem],(___)
		1: ___ esp/unknown ptr [esp],(___)
		2: pop reg/unknown ptr [mem]

		0: push reg						->		0: ___ h(reg),(___)
		1: ___ byte ptr [esp+01],(___)			1: ___ h(reg),(___)
		2: ___ byte ptr [esp+01],(___)
		3: pop reg

		0: push reg						->		0: ___ unknown ptr reg,(___)
		1: ___ esp/unknown ptr [esp],(___)		1: ___ unknown ptr reg,(___)
		2: ___ esp/unknown ptr [esp],(___)
		3: pop reg

		0: push reg						->		0: ___ x,___
		1: mov reg,x
		2: ___ reg,___
		3: mov x,reg
		4: pop reg
	*/
	void deobfuscate_arithmetics();

	/*
		Deobfuscates the following offset-obfuscation patterns:

		0: add|sub x1,imm				->		0: add/sub x1,___
		1: add/sub x1,___
		2: sub|add x1,imm
	*/
	void deobfuscate_offset();

	/*
		Deobfuscates the following generator-obfuscation patterns:
		
		0: push regx					->		0: ___ reg,unknown ptr [regb+d]			; d = imm (product)
		1: mov regx,regb				->		0: ___ unknown ptr [regb+d],reg/imm		; d = imm (product)
		j: ... imm actions ...
		j: ___ reg,unknown ptr [regx]
		j: ___ unknown ptr [regx],reg/imm
		j: ... imm actions ...
		e: pop regx
		
		0: push x (reg)					->		0: ___ ___,unknown ptr [b+i*s+d] 
		1: mov x,reg (i)						0: ___ unknown ptr [b+i*s+d],___
		2: shl x,imm (s)
		3: add x,imm (d)
		4: add x,reg (b)
		5: ___ ___,unknown ptr [x]
		5: ___ unknown ptr [x],___
		6: pop x
	*/
	void deobfuscate_generated_memory();

	/*
		Deobfuscates the following generator-obfuscation patterns:

		0: push reg						->		0: ___ reg,imm (product)
		1: mov reg,imm
		j: ... imm actions ...
		j: ___ reg,___
		j: ... imm actions ...
		e: pop reg		
	*/
	void deobfuscate_generated_register();

	/*
		Deobfuscates the following neg-obfuscation patterns:

		0: push 0						->		0: neg reg	
		1: sub unknown ptr [esp],reg
		2: pop reg

		0: not x1						->		0: neg x1
		1: inc x1

		0: not x1						->		0: neg x1
		1: add x1,1

		0: not x1						->		0: neg x1
		1: sub x1,-1
							
		0: dec x1						->		0: neg x1
		1: not x1

		0: add x1,-1					->		0: neg x1
		1: not x1

		0: sub x1,1						->		0: neg x1
		1: not x1

		0: push 0						->		0: neg reg
		1: sub byte ptr [esp],(reg != esp)
		2: mov reg,byte ptr [esp]
		3: add esp,02/04

		0: push reg						->		0: neg x1
		1: mov reg,0
		2: sub reg,x1
		3: mov x1,reg
		3: xchg x1|reg,reg|x1
		4: pop reg
	*/
	void deobfuscate_neg();

	/*
		Deobfuscates the following mov-obfuscation patterns:
			
		0: mov x,imm					->		0: mov x,imm (product)
		j: ___ x,(imm)
	*/
	void deobfuscate_mov_v2();
	
	/*
		Deobfuscates the following filler-obfuscation patterns:
			
		0: mov reg1,reg1				->		0: <removed>
	*/
	void deobfuscate_fillers();
};

#endif
```

`TDE/instruction_emulator.cpp`:

```cpp
#include "instruction_emulator.hpp"

#include <idp.hpp>

namespace instruction
{
	template <typename T>
	bool emulate_action_internal(ud_mnemonic_code mnemonic, T input, T* product)
	{
		switch (mnemonic)
		{
		case UD_Ishl:
			*product = (*product << input);
			return true;

		case UD_Ishr:
			*product = (*product >> input);
			return true;
			
		case UD_Iand:
			*product = (*product & input);
			return true;

		case UD_Ixor:
			*product = (*product ^ input);
			return true;

		case UD_Ior:
			*product = (*product | input);
			return true;
			
		case UD_Inot:
			*product = ~(*product);
			return true;
			
		case UD_Ineg:
			*product = static_cast<T>(-(static_cast<std::make_signed<T>::type>(*product)));
			return true;

		case UD_Isub:
			*product = (*product - input);
			return true;

		case UD_Iadd:
			*product = (*product + input);
			return true;
			
		case UD_Iinc:
			*product = (*product + 1);
			return true;

		case UD_Idec:
			*product = (*product - 1);
			return true;

		default:
			msg("[CodeDevirtualizer] Attempted instruction-emulation (for immediate value) on unsupported mnemonic.\n");
			break;
		}

		return false;
	}

	bool emulate(ud_mnemonic_code mnemonic, ud_size size, uint32_t input, uint32_t* product)
	{
		switch (size)
		{
		case UD_SIZE_BYTE:
			return emulate_action_internal<uint8_t>(mnemonic, static_cast<uint8_t>(input), reinterpret_cast<uint8_t*>(product));

		case UD_SIZE_WORD:
			return emulate_action_internal<uint16_t>(mnemonic, static_cast<uint16_t>(input), reinterpret_cast<uint16_t*>(product));

		case UD_SIZE_DWORD:
			return emulate_action_internal<uint32_t>(mnemonic, input, product);

		default:
			msg("[CodeDevirtualizer] Attempted instruction-emulation (for immediate value) on unsupported operand size.\n");
			break;
		}
		
		return false;
	}

	bool emulate_eflags_internal_uint8(ud_mnemonic_code mnemonic, uint8_t input, uint8_t product, uint32_t* eflags)
	{
		switch (mnemonic)
		{
		case UD_Ishl:
			__asm mov al,byte ptr [product]
			__asm mov cl,byte ptr [input]
			__asm shl al,cl
			*eflags = __readeflags();
			return true;

		case UD_Ishr:
			__asm mov al,byte ptr [product]
			__asm mov cl,byte ptr [input]
			__asm shr al,cl
			*eflags = __readeflags();
			return true;
			
		case UD_Iand:
			__asm mov al,byte ptr [product]
			__asm mov cl,byte ptr [input]
			__asm and al,cl
			*eflags = __readeflags();
			return true;

		case UD_Ixor:
			__asm mov al,byte ptr [product]
			__asm mov cl,byte ptr [input]
			__asm xor al,cl
			*eflags = __readeflags();
			return true;

		case UD_Ior:
			__asm mov al,byte ptr [product]
			__asm mov cl,byte ptr [input]
			__asm or al,cl
			*eflags = __readeflags();
			return true;
			
		case UD_Inot:
			__asm mov al,byte ptr [product]
			__asm not al
			*eflags = __readeflags();
			return true;

		case UD_Ineg:
			__asm mov al,byte ptr [product]
			__asm neg al
			*eflags = __readeflags();
			return true;

		case UD_Isub:
			__asm mov al,byte ptr [product]
			__asm mov cl,byte ptr [input]
			__asm sub al,cl
			*eflags = __readeflags();
			return true;

		case UD_Iadd:
			__asm mov al,byte ptr [product]
			__asm mov cl,byte ptr [input]
			__asm add al,cl
			*eflags = __readeflags();
			return true;
			
		case UD_Iinc:
			__asm mov al,byte ptr [product]
			__asm inc al
			*eflags = __readeflags();
			return true;

		case UD_Idec:
			__asm mov al,byte ptr [product]
			__asm dec al
			*eflags = __readeflags();
			return true;

		default:
			msg("[CodeDevirtualizer] Attempted instruction-emulation (for eflags value) on unsupported mnemonic.\n");
			break;
		}

		return false;
	}

	bool emulate_eflags_internal_uint16(ud_mnemonic_code mnemonic, uint16_t input, uint16_t product, uint32_t* eflags)
	{
		switch (mnemonic)
		{
		case UD_Ishl:
			__asm mov ax,word ptr [product]
			__asm mov cl,byte ptr [input]
			__asm shl ax,cl
			*eflags = __readeflags();
			return true;

		case UD_Ishr:
			__asm mov ax,word ptr [product]
			__asm mov cl,byte ptr [input]
			__asm shr ax,cl
			*eflags = __readeflags();
			return true;
			
		case UD_Iand:
			__asm mov ax,word ptr [product]
			__asm mov cx,word ptr [input]
			__asm and ax,cx
			*eflags = __readeflags();
			return true;

		case UD_Ixor:
			__asm mov ax,word ptr [product]
			__asm mov cx,word ptr [input]
			__asm xor ax,cx
			*eflags = __readeflags();
			return true;

		case UD_Ior:
			__asm mov ax,word ptr [product]
			__asm mov cx,word ptr [input]
			__asm or ax,cx
			*eflags = __readeflags();
			return true;
			
		case UD_Inot:
			__asm mov ax,word ptr [product]
			__asm not ax
			*eflags = __readeflags();
			return true;

		case UD_Ineg:
			__asm mov ax,word ptr [product]
			__asm neg ax
			*eflags = __readeflags();
			return true;

		case UD_Isub:
			__asm mov ax,word ptr [product]
			__asm mov cx,word ptr [input]
			__asm sub ax,cx
			*eflags = __readeflags();
			return true;

		case UD_Iadd:
			__asm mov ax,word ptr [product]
			__asm mov cx,word ptr [input]
			__asm add ax,cx
			*eflags = __readeflags();
			return true;

		case UD_Iinc:
			__asm mov ax,word ptr [product]
			__asm inc ax
			*eflags = __readeflags();
			return true;

		case UD_Idec:
			__asm mov ax,word ptr [product]
			__asm dec ax
			*eflags = __readeflags();
			return true;

		default:
			msg("[CodeDevirtualizer] Attempted instruction-emulation (for eflags value) on unsupported mnemonic.\n");
			break;
		}

		return false;
	}

	bool emulate_eflags_internal_uint32(ud_mnemonic_code mnemonic, uint32_t input, uint32_t product, uint32_t* eflags)
	{
		switch (mnemonic)
		{
		case UD_Ishl:
			__asm mov eax,dword ptr [product]
			__asm mov cl,byte ptr [input]
			__asm shl eax,cl
			*eflags = __readeflags();
			return true;

		case UD_Ishr:
			__asm mov eax,dword ptr [product]
			__asm mov cl,byte ptr [input]
			__asm shr eax,cl
			*eflags = __readeflags();
			return true;
			
		case UD_Iand:
			__asm mov eax,dword ptr [product]
			__asm mov ecx,dword ptr [input]
			__asm and eax,ecx
			*eflags = __readeflags();
			return true;

		case UD_Ixor:
			__asm mov eax,dword ptr [product]
			__asm mov ecx,dword ptr [input]
			__asm xor eax,ecx
			*eflags = __readeflags();
			return true;

		case UD_Ior:
			__asm mov eax,dword ptr [product]
			__asm mov ecx,dword ptr [input]
			__asm or eax,ecx
			*eflags = __readeflags();
			return true;

		case UD_Inot:
			__asm mov eax,dword ptr [product]
			__asm not eax
			*eflags = __readeflags();
			return true;

		case UD_Ineg:
			__asm mov eax,dword ptr [product]
			__asm neg eax
			*eflags = __readeflags();
			return true;

		case UD_Isub:
			__asm mov eax,dword ptr [product]
			__asm mov ecx,dword ptr [input]
			__asm sub eax,ecx
			*eflags = __readeflags();
			return true;

		case UD_Iadd:
			__asm mov eax,dword ptr [product]
			__asm mov ecx,dword ptr [input]
			__asm add eax,ecx
			*eflags = __readeflags();
			return true;

		case UD_Iinc:
			__asm mov eax,dword ptr [product]
			__asm inc eax
			*eflags = __readeflags();
			return true;

		case UD_Idec:
			__asm mov eax,dword ptr [product]
			__asm dec eax
			*eflags = __readeflags();
			return true;

		default:
			msg("[CodeDevirtualizer] Attempted instruction-emulation (for eflags value) on unsupported mnemonic.\n");
			break;
		}

		return false;
	}

	bool emulate_eflags(ud_mnemonic_code mnemonic, ud_size size, uint32_t input, uint32_t product, uint32_t* eflags)
	{
		switch (size)
		{
		case UD_SIZE_BYTE:
			return emulate_eflags_internal_uint8(mnemonic, static_cast<uint8_t>(input), static_cast<uint8_t>(product), eflags);

		case UD_SIZE_WORD:
			return emulate_eflags_internal_uint16(mnemonic, static_cast<uint16_t>(input), static_cast<uint16_t>(product), eflags);

		case UD_SIZE_DWORD:
			return emulate_eflags_internal_uint32(mnemonic, input, product, eflags);

		default:
			msg("[CodeDevirtualizer] Attempted instruction-emulation (for eflags value) on unsupported operand size.\n");
			break;
		}
		
		return false;
	}
}
```

`TDE/instruction_emulator.hpp`:

```hpp
#ifndef INSTRUCTION_EMULATOR_HPP_
#define INSTRUCTION_EMULATOR_HPP_

#include "ud_instruction.hpp"

namespace instruction
{
	bool emulate(ud_mnemonic_code mnemonic, ud_size size, uint32_t input, uint32_t* product);
	bool emulate_eflags(ud_mnemonic_code mnemonic, ud_size size, uint32_t input, uint32_t product, uint32_t* eflags);
};

#endif
```

`TDE/libudis86/decode.c`:

```c
/* udis86 - libudis86/decode.c
 * 
 * Copyright (c) 2002-2009 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "udint.h"
#include "types.h"
#include "extern.h"
#include "decode.h"

#ifndef __UD_STANDALONE__
# include <string.h>
#endif /* __UD_STANDALONE__ */

/* The max number of prefixes to an instruction */
#define MAX_PREFIXES    15

/* rex prefix bits */
#define REX_W(r)        ( ( 0xF & ( r ) )  >> 3 )
#define REX_R(r)        ( ( 0x7 & ( r ) )  >> 2 )
#define REX_X(r)        ( ( 0x3 & ( r ) )  >> 1 )
#define REX_B(r)        ( ( 0x1 & ( r ) )  >> 0 )
#define REX_PFX_MASK(n) ( ( P_REXW(n) << 3 ) | \
                          ( P_REXR(n) << 2 ) | \
                          ( P_REXX(n) << 1 ) | \
                          ( P_REXB(n) << 0 ) )

/* scable-index-base bits */
#define SIB_S(b)        ( ( b ) >> 6 )
#define SIB_I(b)        ( ( ( b ) >> 3 ) & 7 )
#define SIB_B(b)        ( ( b ) & 7 )

/* modrm bits */
#define MODRM_REG(b)    ( ( ( b ) >> 3 ) & 7 )
#define MODRM_NNN(b)    ( ( ( b ) >> 3 ) & 7 )
#define MODRM_MOD(b)    ( ( ( b ) >> 6 ) & 3 )
#define MODRM_RM(b)     ( ( b ) & 7 )

static int decode_ext(struct ud *u, uint16_t ptr);
static int decode_opcode(struct ud *u);

enum reg_class { /* register classes */
  REGCLASS_GPR,
  REGCLASS_MMX,
  REGCLASS_CR,
  REGCLASS_DB,
  REGCLASS_SEG,
  REGCLASS_XMM
};

 /* 
 * inp_start
 *    Should be called before each de-code operation.
 */
static void
inp_start(struct ud *u)
{
  u->inp_ctr = 0;
}

static uint8_t
inp_peek(struct ud *u)
{
  if (u->inp_end == 0) {
    if (u->inp_buf != NULL) {
      if (u->inp_buf_index < u->inp_buf_size) {
        return u->inp_buf[u->inp_buf_index];
      }
    } else if (u->inp_peek != UD_EOI) {
      return u->inp_peek;
    } else {
      int c;
      if ((c = u->inp_hook(u)) != UD_EOI) {
        u->inp_peek = c;
        return u->inp_peek;
      }
    }
  }
  u->inp_end = 1;
  UDERR(u, "byte expected, eoi received\n");
  return 0;
}
   
static uint8_t
inp_next(struct ud *u)
{
  if (u->inp_end == 0) {
    if (u->inp_buf != NULL) {
      if (u->inp_buf_index < u->inp_buf_size) {
        u->inp_ctr++;
        return (u->inp_curr = u->inp_buf[u->inp_buf_index++]);
      }
    } else {
      int c = u->inp_peek;
      if (c != UD_EOI || (c = u->inp_hook(u)) != UD_EOI) {
        u->inp_peek = UD_EOI;
        u->inp_curr = c;
        u->inp_sess[u->inp_ctr++] = u->inp_curr;
        return u->inp_curr;
      }
    }
  }
  u->inp_end = 1;
  UDERR(u, "byte expected, eoi received\n");
  return 0;
}

static uint8_t
inp_curr(struct ud *u)
{
  return u->inp_curr;
}


/*
 * inp_uint8
 * int_uint16
 * int_uint32
 * int_uint64
 *    Load little-endian values from input
 */
static uint8_t 
inp_uint8(struct ud* u)
{
  return inp_next(u);
}

static uint16_t 
inp_uint16(struct ud* u)
{
  uint16_t r, ret;

  ret = inp_next(u);
  r = inp_next(u);
  return ret | (r << 8);
}

static uint32_t 
inp_uint32(struct ud* u)
{
  uint32_t r, ret;

  ret = inp_next(u);
  r = inp_next(u);
  ret = ret | (r << 8);
  r = inp_next(u);
  ret = ret | (r << 16);
  r = inp_next(u);
  return ret | (r << 24);
}

static uint64_t 
inp_uint64(struct ud* u)
{
  uint64_t r, ret;

  ret = inp_next(u);
  r = inp_next(u);
  ret = ret | (r << 8);
  r = inp_next(u);
  ret = ret | (r << 16);
  r = inp_next(u);
  ret = ret | (r << 24);
  r = inp_next(u);
  ret = ret | (r << 32);
  r = inp_next(u);
  ret = ret | (r << 40);
  r = inp_next(u);
  ret = ret | (r << 48);
  r = inp_next(u);
  return ret | (r << 56);
}


static UD_INLINE int
eff_opr_mode(int dis_mode, int rex_w, int pfx_opr)
{
  if (dis_mode == 64) {
    return rex_w ? 64 : (pfx_opr ? 16 : 32);
  } else if (dis_mode == 32) {
    return pfx_opr ? 16 : 32;
  } else {
    UD_ASSERT(dis_mode == 16);
    return pfx_opr ? 32 : 16;
  }
}


static UD_INLINE int
eff_adr_mode(int dis_mode, int pfx_adr)
{
  if (dis_mode == 64) {
    return pfx_adr ? 32 : 64;
  } else if (dis_mode == 32) {
    return pfx_adr ? 16 : 32;
  } else {
    UD_ASSERT(dis_mode == 16);
    return pfx_adr ? 32 : 16;
  }
}


/* 
 * decode_prefixes
 *
 *  Extracts instruction prefixes.
 */
static int 
decode_prefixes(struct ud *u)
{
  int done = 0;
  uint8_t curr = 0, last = 0;
  UD_RETURN_ON_ERROR(u);

  do {
    last = curr;
    curr = inp_next(u); 
    UD_RETURN_ON_ERROR(u);
    if (u->inp_ctr == MAX_INSN_LENGTH) {
      UD_RETURN_WITH_ERROR(u, "max instruction length");
    }
   
    switch (curr)  
    {
    case 0x2E: 
      u->pfx_seg = UD_R_CS; 
      break;
    case 0x36:     
      u->pfx_seg = UD_R_SS; 
      break;
    case 0x3E: 
      u->pfx_seg = UD_R_DS; 
      break;
    case 0x26: 
      u->pfx_seg = UD_R_ES; 
      break;
    case 0x64: 
      u->pfx_seg = UD_R_FS; 
      break;
    case 0x65: 
      u->pfx_seg = UD_R_GS; 
      break;
    case 0x67: /* adress-size override prefix */ 
      u->pfx_adr = 0x67;
      break;
    case 0xF0: 
      u->pfx_lock = 0xF0;
      break;
    case 0x66: 
      u->pfx_opr = 0x66;
      break;
    case 0xF2:
      u->pfx_str = 0xf2;
      break;
    case 0xF3:
      u->pfx_str = 0xf3;
      break;
    default:
      /* consume if rex */
      done = (u->dis_mode == 64 && (curr & 0xF0) == 0x40) ? 0 : 1;
      break;
    }
  } while (!done);
  /* rex prefixes in 64bit mode, must be the last prefix */
  if (u->dis_mode == 64 && (last & 0xF0) == 0x40) {
    u->pfx_rex = last;  
  }
  return 0;
}


/*
 * vex_l, vex_w
 *  Return the vex.L and vex.W bits
 */
static UD_INLINE uint8_t
vex_l(const struct ud *u)
{
  UD_ASSERT(u->vex_op != 0);
  return ((u->vex_op == 0xc4 ? u->vex_b2 : u->vex_b1) >> 2) & 1;
}

static UD_INLINE uint8_t
vex_w(const struct ud *u)
{
  UD_ASSERT(u->vex_op != 0);
  return u->vex_op == 0xc4 ? ((u->vex_b2 >> 7) & 1) : 0;
}


static UD_INLINE uint8_t
modrm(struct ud * u)
{
    if ( !u->have_modrm ) {
        u->modrm = inp_next( u );
        u->modrm_offset = (uint8_t) (u->inp_ctr - 1);
        u->have_modrm = 1;
    }
    return u->modrm;
}


static unsigned int
resolve_operand_size(const struct ud* u, ud_operand_size_t osize)
{
  switch (osize) {
  case SZ_V:
    return u->opr_mode;
  case SZ_Z:  
    return u->opr_mode == 16 ? 16 : 32;
  case SZ_Y:
    return u->opr_mode == 16 ? 32 : u->opr_mode;
  case SZ_RDQ:
    return u->dis_mode == 64 ? 64 : 32;
  case SZ_X:
    UD_ASSERT(u->vex_op != 0);
    return (P_VEXL(u->itab_entry->prefix) && vex_l(u)) ?  SZ_QQ : SZ_DQ;
  default:
    return osize;
  }
}


static int resolve_mnemonic( struct ud* u )
{
  /* resolve 3dnow weirdness. */
  if ( u->mnemonic == UD_I3dnow ) {
    u->mnemonic = ud_itab[ u->le->table[ inp_curr( u )  ] ].mnemonic;
  }
  /* SWAPGS is only valid in 64bits mode */
  if ( u->mnemonic == UD_Iswapgs && u->dis_mode != 64 ) {
    UDERR(u, "swapgs invalid in 64bits mode\n");
    return -1;
  }

  if (u->mnemonic == UD_Ixchg) {
    if ((u->operand[0].type == UD_OP_REG && u->operand[0].base == UD_R_AX  &&
         u->operand[1].type == UD_OP_REG && u->operand[1].base == UD_R_AX) ||
        (u->operand[0].type == UD_OP_REG && u->operand[0].base == UD_R_EAX &&
         u->operand[1].type == UD_OP_REG && u->operand[1].base == UD_R_EAX)) {
      u->operand[0].type = UD_NONE;
      u->operand[1].type = UD_NONE;
      u->mnemonic = UD_Inop;
    }
  }

  if (u->mnemonic == UD_Inop && u->pfx_repe) {
    u->pfx_repe = 0;
    u->mnemonic = UD_Ipause;
  }
  return 0;
}


/* -----------------------------------------------------------------------------
 * decode_a()- Decodes operands of the type seg:offset
 * -----------------------------------------------------------------------------
 */
static void 
decode_a(struct ud* u, struct ud_operand *op)
{
  if (u->opr_mode == 16) {  
    /* seg16:off16 */
    op->type = UD_OP_PTR;
    op->size = 32;
    op->lval.ptr.off = inp_uint16(u);
    op->lval.ptr.seg = inp_uint16(u);
  } else {
    /* seg16:off32 */
    op->type = UD_OP_PTR;
    op->size = 48;
    op->lval.ptr.off = inp_uint32(u);
    op->lval.ptr.seg = inp_uint16(u);
  }
}

/* -----------------------------------------------------------------------------
 * decode_gpr() - Returns decoded General Purpose Register 
 * -----------------------------------------------------------------------------
 */
static enum ud_type 
decode_gpr(register struct ud* u, unsigned int s, unsigned char rm)
{
  switch (s) {
    case 64:
        return UD_R_RAX + rm;
    case 32:
        return UD_R_EAX + rm;
    case 16:
        return UD_R_AX  + rm;
    case  8:
        if (u->dis_mode == 64 && u->pfx_rex) {
            if (rm >= 4)
                return UD_R_SPL + (rm-4);
            return UD_R_AL + rm;
        } else return UD_R_AL + rm;
    case 0:
        /* invalid size in case of a decode error */
        UD_ASSERT(u->error);
        return UD_NONE;
    default:
        UD_ASSERT(!"invalid operand size");
        return UD_NONE;
  }
}

static void
decode_reg(struct ud *u, 
           struct ud_operand *opr,
           int type,
           int num,
           int size)
{
  int reg;
  size = resolve_operand_size(u, size);
  switch (type) {
    case REGCLASS_GPR : reg = decode_gpr(u, size, num); break;
    case REGCLASS_MMX : reg = UD_R_MM0  + (num & 7); break;
    case REGCLASS_XMM :
      reg = num + (size == SZ_QQ ? UD_R_YMM0 : UD_R_XMM0);
      break;
    case REGCLASS_CR : reg = UD_R_CR0  + num; break;
    case REGCLASS_DB : reg = UD_R_DR0  + num; break;
    case REGCLASS_SEG : {
      /*
       * Only 6 segment registers, anything else is an error.
       */
      if ((num & 7) > 5) {
        UDERR(u, "invalid segment register value\n");
        return;
      } else {
        reg = UD_R_ES + (num & 7);
      }
      break;
    }
    default:
      UD_ASSERT(!"invalid register type");
      return;
  }
  opr->type = UD_OP_REG;
  opr->base = reg;
  opr->size = size;
}


/*
 * decode_imm 
 *
 *    Decode Immediate values.
 */
static void 
decode_imm(struct ud* u, unsigned int size, struct ud_operand *op)
{
  op->size = resolve_operand_size(u, size);
  op->type = UD_OP_IMM;

  switch (op->size) {
  case  8: op->lval.sbyte = inp_uint8(u);   break;
  case 16: op->lval.uword = inp_uint16(u);  break;
  case 32: op->lval.udword = inp_uint32(u); break;
  case 64: op->lval.uqword = inp_uint64(u); break;
  default: return;
  }
}


/* 
 * decode_mem_disp
 *
 *    Decode mem address displacement.
 */
static void 
decode_mem_disp(struct ud* u, unsigned int size, struct ud_operand *op)
{
  switch (size) {
  case 8:
    op->offset = 8; 
    op->lval.ubyte  = inp_uint8(u);
    break;
  case 16:
    op->offset = 16; 
    op->lval.uword  = inp_uint16(u); 
    break;
  case 32:
    op->offset = 32; 
    op->lval.udword = inp_uint32(u); 
    break;
  case 64:
    op->offset = 64; 
    op->lval.uqword = inp_uint64(u); 
    break;
  default:
      return;
  }
}


/*
 * decode_modrm_reg
 *
 *    Decodes reg field of mod/rm byte
 * 
 */
static UD_INLINE void
decode_modrm_reg(struct ud         *u, 
                 struct ud_operand *operand,
                 unsigned int       type,
                 unsigned int       size)
{
  uint8_t reg = (REX_R(u->_rex) << 3) | MODRM_REG(modrm(u));
  decode_reg(u, operand, type, reg, size);
}


/*
 * decode_modrm_rm
 *
 *    Decodes rm field of mod/rm byte
 * 
 */
static void 
decode_modrm_rm(struct ud         *u, 
                struct ud_operand *op,
                unsigned char      type,    /* register type */
                unsigned int       size)    /* operand size */

{
  size_t offset = 0;
  unsigned char mod, rm;

  /* get mod, r/m and reg fields */
  mod = MODRM_MOD(modrm(u));
  rm  = (REX_B(u->_rex) << 3) | MODRM_RM(modrm(u));

  /* 
   * If mod is 11b, then the modrm.rm specifies a register.
   *
   */
  if (mod == 3) {
    decode_reg(u, op, type, rm, size);
    return;
  }

  /* 
   * !11b => Memory Address
   */  
  op->type = UD_OP_MEM;
  op->size = resolve_operand_size(u, size);

  if (u->adr_mode == 64) {
    op->base = UD_R_RAX + rm;
    if (mod == 1) {
      offset = 8;
    } else if (mod == 2) {
      offset = 32;
    } else if (mod == 0 && (rm & 7) == 5) {           
      op->base = UD_R_RIP;
      offset = 32;
    } else {
      offset = 0;
    }
    /* 
     * Scale-Index-Base (SIB) 
     */
    if ((rm & 7) == 4) {
      inp_next(u);
      
      op->base  = UD_R_RAX + (SIB_B(inp_curr(u)) | (REX_B(u->_rex) << 3));
      op->index = UD_R_RAX + (SIB_I(inp_curr(u)) | (REX_X(u->_rex) << 3));
      /* special conditions for base reference */
      if (op->index == UD_R_RSP) {
        op->index = UD_NONE;
        op->scale = UD_NONE;
      } else {
        op->scale = (1 << SIB_S(inp_curr(u))) & ~1;
      }

      if (op->base == UD_R_RBP || op->base == UD_R_R13) {
        if (mod == 0) {
          op->base = UD_NONE;
        } 
        if (mod == 1) {
          offset = 8;
        } else {
          offset = 32;
        }
      }
    } else {
        op->scale = UD_NONE;
        op->index = UD_NONE;
    }
  } else if (u->adr_mode == 32) {
    op->base = UD_R_EAX + rm;
    if (mod == 1) {
      offset = 8;
    } else if (mod == 2) {
      offset = 32;
    } else if (mod == 0 && rm == 5) {
      op->base = UD_NONE;
      offset = 32;
    } else {
      offset = 0;
    }

    /* Scale-Index-Base (SIB) */
    if ((rm & 7) == 4) {
      inp_next(u);

      op->scale = (1 << SIB_S(inp_curr(u))) & ~1;
      op->index = UD_R_EAX + (SIB_I(inp_curr(u)) | (REX_X(u->pfx_rex) << 3));
      op->base  = UD_R_EAX + (SIB_B(inp_curr(u)) | (REX_B(u->pfx_rex) << 3));

      if (op->index == UD_R_ESP) {
        op->index = UD_NONE;
        op->scale = UD_NONE;
      }

      /* special condition for base reference */
      if (op->base == UD_R_EBP) {
        if (mod == 0) {
          op->base = UD_NONE;
        } 
        if (mod == 1) {
          offset = 8;
        } else {
          offset = 32;
        }
      }
    } else {
      op->scale = UD_NONE;
      op->index = UD_NONE;
    }
  } else {
    const unsigned int bases[]   = { UD_R_BX, UD_R_BX, UD_R_BP, UD_R_BP,
                                     UD_R_SI, UD_R_DI, UD_R_BP, UD_R_BX };
    const unsigned int indices[] = { UD_R_SI, UD_R_DI, UD_R_SI, UD_R_DI,
                                     UD_NONE, UD_NONE, UD_NONE, UD_NONE };
    op->base  = bases[rm & 7];
    op->index = indices[rm & 7];
    op->scale = UD_NONE;
    if (mod == 0 && rm == 6) {
      offset = 16;
      op->base = UD_NONE;
    } else if (mod == 1) {
      offset = 8;
    } else if (mod == 2) { 
      offset = 16;
    }
  }

  if (offset) {
    decode_mem_disp(u, offset, op);
  } else {
    op->offset = 0;
  }
}


/* 
 * decode_moffset
 *    Decode offset-only memory operand
 */
static void
decode_moffset(struct ud *u, unsigned int size, struct ud_operand *opr)
{
  opr->type  = UD_OP_MEM;
  opr->base  = UD_NONE;
  opr->index = UD_NONE;
  opr->scale = UD_NONE;
  opr->size  = resolve_operand_size(u, size);
  decode_mem_disp(u, u->adr_mode, opr);
}


static void
decode_vex_vvvv(struct ud *u, struct ud_operand *opr, unsigned size)
{
  uint8_t vvvv;
  UD_ASSERT(u->vex_op != 0);
  vvvv = ((u->vex_op == 0xc4 ? u->vex_b2 : u->vex_b1) >> 3) & 0xf;
  decode_reg(u, opr, REGCLASS_XMM, (0xf & ~vvvv), size);
}


/* 
 * decode_vex_immreg
 *    Decode source operand encoded in immediate byte [7:4]
 */
static int
decode_vex_immreg(struct ud *u, struct ud_operand *opr, unsigned size)
{
  uint8_t imm  = inp_next(u);
  uint8_t mask = u->dis_mode == 64 ? 0xf : 0x7;
  UD_RETURN_ON_ERROR(u);
  UD_ASSERT(u->vex_op != 0);
  decode_reg(u, opr, REGCLASS_XMM, mask & (imm >> 4), size);
  return 0;
}


/* 
 * decode_operand
 *
 *      Decodes a single operand.
 *      Returns the type of the operand (UD_NONE if none)
 */
static int
decode_operand(struct ud           *u, 
               struct ud_operand   *operand,
               enum ud_operand_code type,
               unsigned int         size)
{
  operand->type = UD_NONE;
  operand->_oprcode = type;

  switch (type) {
    case OP_A :
      decode_a(u, operand);
      break;
    case OP_MR:
      decode_modrm_rm(u, operand, REGCLASS_GPR, 
                      MODRM_MOD(modrm(u)) == 3 ? 
                        Mx_reg_size(size) : Mx_mem_size(size));
      break;
    case OP_F:
      u->br_far  = 1;
      /* intended fall through */
    case OP_M:
      if (MODRM_MOD(modrm(u)) == 3) {
        UDERR(u, "expected modrm.mod != 3\n");
      }
      /* intended fall through */
    case OP_E:
      decode_modrm_rm(u, operand, REGCLASS_GPR, size);
      break;
    case OP_G:
      decode_modrm_reg(u, operand, REGCLASS_GPR, size);
      break;
    case OP_sI:
    case OP_I:
      decode_imm(u, size, operand);
      break;
    case OP_I1:
      operand->type = UD_OP_CONST;
      operand->lval.udword = 1;
      break;
    case OP_N:
      if (MODRM_MOD(modrm(u)) != 3) {
        UDERR(u, "expected modrm.mod == 3\n");
      }
      /* intended fall through */
    case OP_Q:
      decode_modrm_rm(u, operand, REGCLASS_MMX, size);
      break;
    case OP_P:
      decode_modrm_reg(u, operand, REGCLASS_MMX, size);
      break;
    case OP_U:
      if (MODRM_MOD(modrm(u)) != 3) {
        UDERR(u, "expected modrm.mod == 3\n");
      }
      /* intended fall through */
    case OP_W:
      decode_modrm_rm(u, operand, REGCLASS_XMM, size);
      break;
    case OP_V:
      decode_modrm_reg(u, operand, REGCLASS_XMM, size);
      break;
    case OP_H:
      decode_vex_vvvv(u, operand, size);
      break;
    case OP_MU:
      decode_modrm_rm(u, operand, REGCLASS_XMM, 
                      MODRM_MOD(modrm(u)) == 3 ? 
                        Mx_reg_size(size) : Mx_mem_size(size));
      break;
    case OP_S:
      decode_modrm_reg(u, operand, REGCLASS_SEG, size);
      break;
    case OP_O:
      decode_moffset(u, size, operand);
      break;
    case OP_R0: 
    case OP_R1: 
    case OP_R2: 
    case OP_R3: 
    case OP_R4: 
    case OP_R5: 
    case OP_R6: 
    case OP_R7:
      decode_reg(u, operand, REGCLASS_GPR, 
                 (REX_B(u->_rex) << 3) | (type - OP_R0), size);
      break;
    case OP_AL:
    case OP_AX:
    case OP_eAX:
    case OP_rAX:
      decode_reg(u, operand, REGCLASS_GPR, 0, size);
      break;
    case OP_CL:
    case OP_CX:
    case OP_eCX:
      decode_reg(u, operand, REGCLASS_GPR, 1, size);
      break;
    case OP_DL:
    case OP_DX:
    case OP_eDX:
      decode_reg(u, operand, REGCLASS_GPR, 2, size);
      break;
    case OP_ES: 
    case OP_CS: 
    case OP_DS:
    case OP_SS: 
    case OP_FS: 
    case OP_GS:
      /* in 64bits mode, only fs and gs are allowed */
      if (u->dis_mode == 64) {
        if (type != OP_FS && type != OP_GS) {
          UDERR(u, "invalid segment register in 64bits\n");
        }
      }
      operand->type = UD_OP_REG;
      operand->base = (type - OP_ES) + UD_R_ES;
      operand->size = 16;
      break;
    case OP_J :
      decode_imm(u, size, operand);
      operand->type = UD_OP_JIMM;
      break ;
    case OP_R :
      if (MODRM_MOD(modrm(u)) != 3) {
        UDERR(u, "expected modrm.mod == 3\n");
      }
      decode_modrm_rm(u, operand, REGCLASS_GPR, size);
      break;
    case OP_C:
      decode_modrm_reg(u, operand, REGCLASS_CR, size);
      break;
    case OP_D:
      decode_modrm_reg(u, operand, REGCLASS_DB, size);
      break;
    case OP_I3 :
      operand->type = UD_OP_CONST;
      operand->lval.sbyte = 3;
      break;
    case OP_ST0: 
    case OP_ST1: 
    case OP_ST2: 
    case OP_ST3:
    case OP_ST4:
    case OP_ST5: 
    case OP_ST6: 
    case OP_ST7:
      operand->type = UD_OP_REG;
      operand->base = (type - OP_ST0) + UD_R_ST0;
      operand->size = 80;
      break;
    case OP_L:
      decode_vex_immreg(u, operand, size);
      break;
    default :
      operand->type = UD_NONE;
      break;
  }
  return operand->type;
}


/* 
 * decode_operands
 *
 *    Disassemble upto 3 operands of the current instruction being
 *    disassembled. By the end of the function, the operand fields
 *    of the ud structure will have been filled.
 */
static int
decode_operands(struct ud* u)
{
  decode_operand(u, &u->operand[0],
                    u->itab_entry->operand1.type,
                    u->itab_entry->operand1.size);
  if (u->operand[0].type != UD_NONE) {
      decode_operand(u, &u->operand[1],
                        u->itab_entry->operand2.type,
                        u->itab_entry->operand2.size);
  }
  if (u->operand[1].type != UD_NONE) {
      decode_operand(u, &u->operand[2],
                        u->itab_entry->operand3.type,
                        u->itab_entry->operand3.size);
  }
  if (u->operand[2].type != UD_NONE) {
      decode_operand(u, &u->operand[3],
                        u->itab_entry->operand4.type,
                        u->itab_entry->operand4.size);
  }
  return 0;
}
    
/* -----------------------------------------------------------------------------
 * clear_insn() - clear instruction structure
 * -----------------------------------------------------------------------------
 */
static void
clear_insn(register struct ud* u)
{
  u->error     = 0;
  u->pfx_seg   = 0;
  u->pfx_opr   = 0;
  u->pfx_adr   = 0;
  u->pfx_lock  = 0;
  u->pfx_repne = 0;
  u->pfx_rep   = 0;
  u->pfx_repe  = 0;
  u->pfx_rex   = 0;
  u->pfx_str   = 0;
  u->mnemonic  = UD_Inone;
  u->itab_entry = NULL;
  u->have_modrm = 0;
  u->br_far    = 0;
  u->vex_op    = 0;
  u->_rex      = 0;

  for (int i = 0; i < 4; i++)
	memset(&u->operand[i], 0, sizeof(struct ud_operand));
}


static UD_INLINE int
resolve_pfx_str(struct ud* u)
{
  if (u->pfx_str == 0xf3) {
    if (P_STR(u->itab_entry->prefix)) {
        u->pfx_rep  = 0xf3;
    } else {
        u->pfx_repe = 0xf3;
    }
  } else if (u->pfx_str == 0xf2) {
    u->pfx_repne = 0xf3;
  }
  return 0;
}


static int
resolve_mode( struct ud* u )
{
  /* if in error state, bail out */
  if ( u->error ) return -1; 

  /* propagate prefix effects */
  if ( u->dis_mode == 64 ) {  /* set 64bit-mode flags */

    /* Check validity of  instruction m64 */
    if ( P_INV64( u->itab_entry->prefix ) ) {
      UDERR(u, "instruction invalid in 64bits\n");
      return -1;
    }

    /* compute effective rex based on,
     *  - vex prefix (if any)
     *  - rex prefix (if any, and not vex)
     *  - allowed prefixes specified by the opcode map
     */
    if (u->vex_op == 0xc4) {
        /* vex has rex.rxb in 1's complement */
        u->_rex = ((~(u->vex_b1 >> 5) & 0x7) /* rex.0rxb */ | 
                   ((u->vex_b2  >> 4) & 0x8) /* rex.w000 */);
    } else if (u->vex_op == 0xc5) {
        /* vex has rex.r in 1's complement */
        u->_rex = (~(u->vex_b1 >> 5)) & 4;
    } else {
        UD_ASSERT(u->vex_op == 0);
        u->_rex = u->pfx_rex;
    }
    u->_rex &= REX_PFX_MASK(u->itab_entry->prefix);

    /* whether this instruction has a default operand size of 
     * 64bit, also hardcoded into the opcode map.
     */
    int default64 = P_DEF64( u->itab_entry->prefix ); 
    /* calculate effective operand size */
    if (REX_W(u->_rex)) {
        u->opr_mode = 64;
    } else if ( u->pfx_opr ) {
        u->opr_mode = 16;
    } else {
        /* unless the default opr size of instruction is 64,
         * the effective operand size in the absence of rex.w
         * prefix is 32.
         */
        u->opr_mode = default64 ? 64 : 32;
    }

    /* calculate effective address size */
    u->adr_mode = (u->pfx_adr) ? 32 : 64;
  } else if ( u->dis_mode == 32 ) { /* set 32bit-mode flags */
    u->opr_mode = ( u->pfx_opr ) ? 16 : 32;
    u->adr_mode = ( u->pfx_adr ) ? 16 : 32;
  } else if ( u->dis_mode == 16 ) { /* set 16bit-mode flags */
    u->opr_mode = ( u->pfx_opr ) ? 32 : 16;
    u->adr_mode = ( u->pfx_adr ) ? 32 : 16;
  }

  return 0;
}


static UD_INLINE int
decode_insn(struct ud *u, uint16_t ptr)
{
  UD_ASSERT((ptr & 0x8000) == 0);
  u->itab_entry = &ud_itab[ ptr ];
  u->mnemonic = u->itab_entry->mnemonic;
  return (resolve_pfx_str(u)  == 0 &&
          resolve_mode(u)     == 0 &&
          decode_operands(u)  == 0 &&
          resolve_mnemonic(u) == 0) ? 0 : -1;
}


/*
 * decode_3dnow()
 *
 *    Decoding 3dnow is a little tricky because of its strange opcode
 *    structure. The final opcode disambiguation depends on the last
 *    byte that comes after the operands have been decoded. Fortunately,
 *    all 3dnow instructions have the same set of operand types. So we
 *    go ahead and decode the instruction by picking an arbitrarily chosen
 *    valid entry in the table, decode the operands, and read the final
 *    byte to resolve the menmonic.
 */
static UD_INLINE int
decode_3dnow(struct ud* u)
{
  uint16_t ptr;
  UD_ASSERT(u->le->type == UD_TAB__OPC_3DNOW);
  UD_ASSERT(u->le->table[0xc] != 0);
  decode_insn(u, u->le->table[0xc]);
  inp_next(u); 
  if (u->error) {
    return -1;
  }
  ptr = u->le->table[inp_curr(u)]; 
  UD_ASSERT((ptr & 0x8000) == 0);
  u->mnemonic = ud_itab[ptr].mnemonic;
  return 0;
}


static int
decode_ssepfx(struct ud *u)
{
  uint8_t idx;
  uint8_t pfx;
 
  /*
   * String prefixes (f2, f3) take precedence over operand
   * size prefix (66).
   */
  pfx = u->pfx_str;
  if (pfx == 0) {
    pfx = u->pfx_opr;
  }
  idx = ((pfx & 0xf) + 1) / 2;
  if (u->le->table[idx] == 0) {
    idx = 0;
  }
  if (idx && u->le->table[idx] != 0) {
    /*
     * "Consume" the prefix as a part of the opcode, so it is no
     * longer exported as an instruction prefix.
     */
    u->pfx_str = 0;
    if (pfx == 0x66) {
        /* 
         * consume "66" only if it was used for decoding, leaving
         * it to be used as an operands size override for some
         * simd instructions.
         */
        u->pfx_opr = 0;
    }
  }
  return decode_ext(u, u->le->table[idx]);
}


static int
decode_vex(struct ud *u)
{
  uint8_t index;
  if (u->dis_mode != 64 && MODRM_MOD(inp_peek(u)) != 0x3) {
    index = 0;
  } else {
    u->vex_op = inp_curr(u);
    u->vex_b1 = inp_next(u);
    if (u->vex_op == 0xc4) {
      uint8_t pp, m;
      /* 3-byte vex */
      u->vex_b2 = inp_next(u);
      UD_RETURN_ON_ERROR(u);
      m  = u->vex_b1 & 0x1f;
      if (m == 0 || m > 3) {
        UD_RETURN_WITH_ERROR(u, "reserved vex.m-mmmm value");
      }
      pp = u->vex_b2 & 0x3;
      index = (pp << 2) | m;
    } else {
      /* 2-byte vex */
      UD_ASSERT(u->vex_op == 0xc5);
      index = 0x1 | ((u->vex_b1 & 0x3) << 2);
    }
  }
  return decode_ext(u, u->le->table[index]); 
}


/*
 * decode_ext()
 *
 *    Decode opcode extensions (if any)
 */
static int
decode_ext(struct ud *u, uint16_t ptr)
{
  uint8_t idx = 0;
  if ((ptr & 0x8000) == 0) {
    return decode_insn(u, ptr); 
  }
  u->le = &ud_lookup_table_list[(~0x8000 & ptr)];
  if (u->le->type == UD_TAB__OPC_3DNOW) {
    return decode_3dnow(u);
  }

  switch (u->le->type) {
    case UD_TAB__OPC_MOD:
      /* !11 = 0, 11 = 1 */
      idx = (MODRM_MOD(modrm(u)) + 1) / 4;
      break;
      /* disassembly mode/operand size/address size based tables.
       * 16 = 0,, 32 = 1, 64 = 2
       */
    case UD_TAB__OPC_MODE:
      idx = u->dis_mode != 64 ? 0 : 1;
      break;
    case UD_TAB__OPC_OSIZE:
      idx = eff_opr_mode(u->dis_mode, REX_W(u->pfx_rex), u->pfx_opr) / 32;
      break;
    case UD_TAB__OPC_ASIZE:
      idx = eff_adr_mode(u->dis_mode, u->pfx_adr) / 32;
      break;
    case UD_TAB__OPC_X87:
      idx = modrm(u) - 0xC0;
      break;
    case UD_TAB__OPC_VENDOR:
      if (u->vendor == UD_VENDOR_ANY) {
        /* choose a valid entry */
        idx = (u->le->table[idx] != 0) ? 0 : 1;
      } else if (u->vendor == UD_VENDOR_AMD) {
        idx = 0;
      } else {
        idx = 1;
      }
      break;
    case UD_TAB__OPC_RM:
      idx = MODRM_RM(modrm(u));
      break;
    case UD_TAB__OPC_REG:
      idx = MODRM_REG(modrm(u));
      break;
    case UD_TAB__OPC_SSE:
      return decode_ssepfx(u);
    case UD_TAB__OPC_VEX:
      return decode_vex(u);
    case UD_TAB__OPC_VEX_W:
      idx = vex_w(u);
      break;
    case UD_TAB__OPC_VEX_L:
      idx = vex_l(u);
      break;
    case UD_TAB__OPC_TABLE:
      inp_next(u);
      return decode_opcode(u);
    default:
      UD_ASSERT(!"not reached");
      break;
  }

  return decode_ext(u, u->le->table[idx]);
}


static int
decode_opcode(struct ud *u)
{
  uint16_t ptr;
  UD_ASSERT(u->le->type == UD_TAB__OPC_TABLE);
  UD_RETURN_ON_ERROR(u);
  ptr = u->le->table[inp_curr(u)];
  return decode_ext(u, ptr);
}

 
/* =============================================================================
 * ud_decode() - Instruction decoder. Returns the number of bytes decoded.
 * =============================================================================
 */
unsigned int
ud_decode(struct ud *u)
{
  inp_start(u);
  clear_insn(u);
  u->le = &ud_lookup_table_list[0];
  u->error = decode_prefixes(u) == -1 || 
             decode_opcode(u)   == -1 ||
             u->error;
  /* Handle decode error. */
  if (u->error) {
    /* clear out the decode data. */
    clear_insn(u);
    /* mark the sequence of bytes as invalid. */
    u->itab_entry = &ud_itab[0]; /* entry 0 is invalid */
    u->mnemonic = u->itab_entry->mnemonic;
  } 

    /* maybe this stray segment override byte
     * should be spewed out?
     */
    if ( !P_SEG( u->itab_entry->prefix ) && 
            u->operand[0].type != UD_OP_MEM &&
            u->operand[1].type != UD_OP_MEM )
        u->pfx_seg = 0;

  u->insn_offset = u->pc; /* set offset of instruction */
  u->asm_buf_fill = 0;   /* set translation buffer index to 0 */
  u->pc += u->inp_ctr;    /* move program counter by bytes decoded */

  /* return number of bytes disassembled. */
  return u->inp_ctr;
}

/*
vim: set ts=2 sw=2 expandtab
*/

```

`TDE/libudis86/decode.h`:

```h
/* udis86 - libudis86/decode.h
 *
 * Copyright (c) 2002-2009 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef UD_DECODE_H
#define UD_DECODE_H

#include "types.h"
#include "udint.h"
#include "itab.h"

#define MAX_INSN_LENGTH 15

/* itab prefix bits */
#define P_none          ( 0 )

#define P_inv64         ( 1 << 0 )
#define P_INV64(n)      ( ( n >> 0 ) & 1 )
#define P_def64         ( 1 << 1 )
#define P_DEF64(n)      ( ( n >> 1 ) & 1 )

#define P_oso           ( 1 << 2 )
#define P_OSO(n)        ( ( n >> 2 ) & 1 )
#define P_aso           ( 1 << 3 )
#define P_ASO(n)        ( ( n >> 3 ) & 1 )

#define P_rexb          ( 1 << 4 )
#define P_REXB(n)       ( ( n >> 4 ) & 1 )
#define P_rexw          ( 1 << 5 )
#define P_REXW(n)       ( ( n >> 5 ) & 1 )
#define P_rexr          ( 1 << 6 )
#define P_REXR(n)       ( ( n >> 6 ) & 1 )
#define P_rexx          ( 1 << 7 )
#define P_REXX(n)       ( ( n >> 7 ) & 1 )

#define P_seg           ( 1 << 8 )
#define P_SEG(n)        ( ( n >> 8 ) & 1 )

#define P_vexl          ( 1 << 9 )
#define P_VEXL(n)       ( ( n >> 9 ) & 1 )
#define P_vexw          ( 1 << 10 )
#define P_VEXW(n)       ( ( n >> 10 ) & 1 )

#define P_str           ( 1 << 11 )
#define P_STR(n)        ( ( n >> 11 ) & 1 )
#define P_strz          ( 1 << 12 )
#define P_STR_ZF(n)     ( ( n >> 12 ) & 1 )

/* operand type constants -- order is important! */

enum ud_operand_code {
    OP_NONE,

    OP_A,      OP_E,      OP_M,       OP_G,       
    OP_I,      OP_F,

    OP_R0,     OP_R1,     OP_R2,      OP_R3,
    OP_R4,     OP_R5,     OP_R6,      OP_R7,

    OP_AL,     OP_CL,     OP_DL,
    OP_AX,     OP_CX,     OP_DX,
    OP_eAX,    OP_eCX,    OP_eDX,
    OP_rAX,    OP_rCX,    OP_rDX,

    OP_ES,     OP_CS,     OP_SS,      OP_DS,  
    OP_FS,     OP_GS,

    OP_ST0,    OP_ST1,    OP_ST2,     OP_ST3,
    OP_ST4,    OP_ST5,    OP_ST6,     OP_ST7,

    OP_J,      OP_S,      OP_O,          
    OP_I1,     OP_I3,     OP_sI,

    OP_V,      OP_W,      OP_Q,       OP_P, 
    OP_U,      OP_N,      OP_MU,      OP_H,
    OP_L,

    OP_R,      OP_C,      OP_D,       

    OP_MR
} UD_ATTR_PACKED;


/*
 * Operand size constants
 *
 *  Symbolic constants for various operand sizes. Some of these constants
 *  are given a value equal to the width of the data (SZ_B == 8), such
 *  that they maybe used interchangeably in the internals. Modifying them
 *  will most certainly break things!
 */
typedef uint16_t ud_operand_size_t;

#define SZ_NA  0
#define SZ_Z   1
#define SZ_V   2
#define SZ_Y   3
#define SZ_X   4
#define SZ_RDQ 7
#define SZ_B   8
#define SZ_W   16
#define SZ_D   32
#define SZ_Q   64
#define SZ_T   80
#define SZ_O   12
#define SZ_DQ  128 /* double quad */
#define SZ_QQ  256 /* quad quad */

/*
 * Complex size types; that encode sizes for operands of type MR (memory or
 * register); for internal use only. Id space above 256.
 */
#define SZ_BD  ((SZ_B << 8) | SZ_D)
#define SZ_BV  ((SZ_B << 8) | SZ_V)
#define SZ_WD  ((SZ_W << 8) | SZ_D)
#define SZ_WV  ((SZ_W << 8) | SZ_V)
#define SZ_WY  ((SZ_W << 8) | SZ_Y)
#define SZ_DY  ((SZ_D << 8) | SZ_Y)
#define SZ_WO  ((SZ_W << 8) | SZ_O)
#define SZ_DO  ((SZ_D << 8) | SZ_O)
#define SZ_QO  ((SZ_Q << 8) | SZ_O)


/* resolve complex size type.
 */
static UD_INLINE ud_operand_size_t
Mx_mem_size(ud_operand_size_t size)
{
  return (size >> 8) & 0xff;
}

static UD_INLINE ud_operand_size_t
Mx_reg_size(ud_operand_size_t size)
{
  return size & 0xff;
}

/* A single operand of an entry in the instruction table. 
 * (internal use only)
 */
struct ud_itab_entry_operand 
{
  enum ud_operand_code type;
  ud_operand_size_t size;
};


/* A single entry in an instruction table. 
 *(internal use only)
 */
struct ud_itab_entry 
{
  enum ud_mnemonic_code         mnemonic;
  struct ud_itab_entry_operand  operand1;
  struct ud_itab_entry_operand  operand2;
  struct ud_itab_entry_operand  operand3;
  struct ud_itab_entry_operand  operand4;
  uint32_t                      prefix;
};

struct ud_lookup_table_list_entry {
    const uint16_t *table;
    enum ud_table_type type;
    const char *meta;
};
     
extern struct ud_itab_entry ud_itab[];
extern struct ud_lookup_table_list_entry ud_lookup_table_list[];

#endif /* UD_DECODE_H */

/* vim:cindent
 * vim:expandtab
 * vim:ts=4
 * vim:sw=4
 */

```

`TDE/libudis86/extern.h`:

```h
/* udis86 - libudis86/extern.h
 *
 * Copyright (c) 2002-2009, 2013 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef UD_EXTERN_H
#define UD_EXTERN_H

#ifdef __cplusplus
extern "C" {
#endif

#include "types.h"

#if defined(_MSC_VER) && defined(_USRDLL)
# ifdef LIBUDIS86_EXPORTS
#  define LIBUDIS86_DLLEXTERN __declspec(dllexport)
# else 
#  define LIBUDIS86_DLLEXTERN __declspec(dllimport)
# endif
#else
# define LIBUDIS86_DLLEXTERN 
#endif

/* ============================= PUBLIC API ================================= */

extern LIBUDIS86_DLLEXTERN void ud_init(struct ud*);

extern LIBUDIS86_DLLEXTERN void ud_set_mode(struct ud*, uint8_t);

extern LIBUDIS86_DLLEXTERN void ud_set_pc(struct ud*, uint64_t);

extern LIBUDIS86_DLLEXTERN void ud_set_input_hook(struct ud*, int (*)(struct ud*));

extern LIBUDIS86_DLLEXTERN void ud_set_input_buffer(struct ud*, const uint8_t*, size_t);

#ifndef __UD_STANDALONE__
extern LIBUDIS86_DLLEXTERN void ud_set_input_file(struct ud*, FILE*);
#endif /* __UD_STANDALONE__ */

extern LIBUDIS86_DLLEXTERN void ud_set_vendor(struct ud*, unsigned);

extern LIBUDIS86_DLLEXTERN void ud_set_syntax(struct ud*, void (*)(struct ud*));

extern LIBUDIS86_DLLEXTERN void ud_input_skip(struct ud*, size_t);

extern LIBUDIS86_DLLEXTERN int ud_input_end(const struct ud*);

extern LIBUDIS86_DLLEXTERN unsigned int ud_decode(struct ud*);

extern LIBUDIS86_DLLEXTERN unsigned int ud_disassemble(struct ud*);

extern LIBUDIS86_DLLEXTERN void ud_translate_intel(struct ud*);

extern LIBUDIS86_DLLEXTERN void ud_translate_att(struct ud*);

extern LIBUDIS86_DLLEXTERN const char* ud_insn_asm(const struct ud* u);

extern LIBUDIS86_DLLEXTERN const uint8_t* ud_insn_ptr(const struct ud* u);

extern LIBUDIS86_DLLEXTERN uint64_t ud_insn_off(const struct ud*);

extern LIBUDIS86_DLLEXTERN const char* ud_insn_hex(struct ud*);

extern LIBUDIS86_DLLEXTERN unsigned int ud_insn_len(const struct ud* u);

extern LIBUDIS86_DLLEXTERN const struct ud_operand* ud_insn_opr(const struct ud *u, unsigned int n);

extern LIBUDIS86_DLLEXTERN int ud_opr_is_sreg(const struct ud_operand *opr);

extern LIBUDIS86_DLLEXTERN int ud_opr_is_gpr(const struct ud_operand *opr);

extern LIBUDIS86_DLLEXTERN enum ud_mnemonic_code ud_insn_mnemonic(const struct ud *u);

extern LIBUDIS86_DLLEXTERN const char* ud_lookup_mnemonic(enum ud_mnemonic_code c);

extern LIBUDIS86_DLLEXTERN void ud_set_user_opaque_data(struct ud*, void*);

extern LIBUDIS86_DLLEXTERN void* ud_get_user_opaque_data(const struct ud*);

extern LIBUDIS86_DLLEXTERN void ud_set_asm_buffer(struct ud *u, char *buf, size_t size);

extern LIBUDIS86_DLLEXTERN void ud_set_sym_resolver(struct ud *u, 
                                const char* (*resolver)(struct ud*, 
                                                        uint64_t addr,
                                                        int64_t *offset));

/* ========================================================================== */

#ifdef __cplusplus
}
#endif
#endif /* UD_EXTERN_H */

```

`TDE/libudis86/itab.c`:

```c
/* itab.c -- generated by udis86:scripts/ud_itab.py, do no edit */
#include "decode.h"

#define GROUP(n) (0x8000 | (n))
#define INVALID  0


const uint16_t ud_itab__0[] = {
  /*  0 */          15,          16,          17,          18,
  /*  4 */          19,          20,  GROUP(426),  GROUP(415),
  /*  8 */         964,         965,         966,         967,
  /*  c */         968,         969,  GROUP(427),   GROUP(17),
  /* 10 */           5,           6,           7,           8,
  /* 14 */           9,          10,  GROUP(428),  GROUP(416),
  /* 18 */        1336,        1337,        1338,        1339,
  /* 1c */        1340,        1341,  GROUP(429),  GROUP(417),
  /* 20 */          49,          50,          51,          52,
  /* 24 */          53,          54,     INVALID,  GROUP(374),
  /* 28 */        1407,        1408,        1409,        1410,
  /* 2c */        1411,        1412,     INVALID,  GROUP(375),
  /* 30 */        1487,        1488,        1489,        1490,
  /* 34 */        1491,        1492,     INVALID,    GROUP(1),
  /* 38 */         100,         101,         102,         103,
  /* 3c */         104,         105,     INVALID,    GROUP(4),
  /* 40 */         699,         700,         701,         702,
  /* 44 */         703,         704,         705,         706,
  /* 48 */         175,         176,         177,         178,
  /* 4c */         179,         180,         181,         182,
  /* 50 */        1246,        1247,        1248,        1249,
  /* 54 */        1250,        1251,        1252,        1253,
  /* 58 */        1101,        1102,        1103,        1104,
  /* 5c */        1105,        1106,        1107,        1108,
  /* 60 */  GROUP(430),  GROUP(419),  GROUP(446),  GROUP(367),
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */        1254,         697,        1256,         698,
  /* 6c */         709,  GROUP(403),         982,  GROUP(414),
  /* 70 */         726,         728,         730,         732,
  /* 74 */         734,         736,         738,         740,
  /* 78 */         742,         744,         746,         748,
  /* 7c */         750,         752,         754,         756,
  /* 80 */    GROUP(5),   GROUP(15),    GROUP(6),   GROUP(16),
  /* 84 */        1433,        1434,        1475,        1476,
  /* 88 */         828,         829,         830,         831,
  /* 8c */         832,         770,         833,  GROUP(418),
  /* 90 */        1477,        1478,        1479,        1480,
  /* 94 */        1481,        1482,        1483,        1484,
  /* 98 */  GROUP(371),  GROUP(373),  GROUP(370),        1470,
  /* 9c */  GROUP(433),  GROUP(422),        1310,         766,
  /* a0 */         834,         835,         836,         837,
  /* a4 */         922,  GROUP(413),         114,  GROUP(372),
  /* a8 */        1435,        1436,        1402,  GROUP(445),
  /* ac */         790,  GROUP(410),        1346,  GROUP(444),
  /* b0 */         838,         839,         840,         841,
  /* b4 */         842,         843,         844,         845,
  /* b8 */         846,         847,         848,         849,
  /* bc */         850,         851,         852,         853,
  /* c0 */  GROUP(437),  GROUP(438),        1301,        1302,
  /* c4 */  GROUP(297),  GROUP(408),  GROUP(411),  GROUP(412),
  /* c8 */         200,         776,        1303,        1304,
  /* cc */         713,         714,  GROUP(404),  GROUP(405),
  /* d0 */  GROUP(439),  GROUP(442),  GROUP(440),  GROUP(441),
  /* d4 */    GROUP(3),    GROUP(2),  GROUP(443),        1486,
  /* d8 */  GROUP(385),  GROUP(379),  GROUP(397),  GROUP(394),
  /* dc */  GROUP(382),  GROUP(400),  GROUP(388),  GROUP(391),
  /* e0 */         794,         795,         796,  GROUP(406),
  /* e4 */         690,         691,         978,         979,
  /* e8 */          72,         763,  GROUP(407),         765,
  /* ec */         692,         693,         980,         981,
  /* f0 */         789,         712,        1299,        1300,
  /* f4 */         687,          83,  GROUP(378),  GROUP(377),
  /* f8 */          77,        1395,          81,        1398,
  /* fc */          78,        1396,  GROUP(376),  GROUP(368),
};

static const uint16_t ud_itab__1[] = {
  /*  0 */           1,     INVALID,
};

static const uint16_t ud_itab__2[] = {
  /*  0 */           2,     INVALID,
};

static const uint16_t ud_itab__3[] = {
  /*  0 */           3,     INVALID,
};

static const uint16_t ud_itab__4[] = {
  /*  0 */           4,     INVALID,
};

static const uint16_t ud_itab__5[] = {
  /*  0 */          21,         970,          11,        1342,
  /*  4 */          55,        1413,        1493,         106,
};

static const uint16_t ud_itab__6[] = {
  /*  0 */    GROUP(8),   GROUP(11),    GROUP(7),   GROUP(12),
  /*  4 */    GROUP(9),   GROUP(13),   GROUP(14),   GROUP(10),
};

static const uint16_t ud_itab__7[] = {
  /*  0 */          12,     INVALID,
};

static const uint16_t ud_itab__8[] = {
  /*  0 */          22,     INVALID,
};

static const uint16_t ud_itab__9[] = {
  /*  0 */          56,     INVALID,
};

static const uint16_t ud_itab__10[] = {
  /*  0 */         107,     INVALID,
};

static const uint16_t ud_itab__11[] = {
  /*  0 */         972,     INVALID,
};

static const uint16_t ud_itab__12[] = {
  /*  0 */        1344,     INVALID,
};

static const uint16_t ud_itab__13[] = {
  /*  0 */        1415,     INVALID,
};

static const uint16_t ud_itab__14[] = {
  /*  0 */        1495,     INVALID,
};

static const uint16_t ud_itab__15[] = {
  /*  0 */          23,         971,          13,        1343,
  /*  4 */          57,        1414,        1494,         108,
};

static const uint16_t ud_itab__16[] = {
  /*  0 */          24,         973,          14,        1345,
  /*  4 */          58,        1416,        1496,         109,
};

static const uint16_t ud_itab__17[] = {
  /*  0 */  GROUP(156),  GROUP(117),         767,         797,
  /*  4 */     INVALID,        1426,          82,        1431,
  /*  8 */         716,        1471,     INVALID,        1444,
  /*  c */     INVALID,  GROUP(224),         430,  GROUP(262),
  /* 10 */  GROUP(188),  GROUP(189),  GROUP(178),  GROUP(181),
  /* 14 */  GROUP(275),  GROUP(274),  GROUP(174),  GROUP(177),
  /* 18 */  GROUP(225),         955,         956,         957,
  /* 1c */         958,         959,         960,         961,
  /* 20 */         854,         855,         856,         857,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */  GROUP(166),  GROUP(167),  GROUP(153),  GROUP(184),
  /* 2c */  GROUP(154),  GROUP(151),  GROUP(273),  GROUP(148),
  /* 30 */        1472,        1297,        1295,        1296,
  /* 34 */  GROUP(269),  GROUP(271),     INVALID,        1514,
  /* 38 */   GROUP(20),     INVALID,   GROUP(82),     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */          84,          85,          86,          87,
  /* 44 */          88,          89,          90,          91,
  /* 48 */          92,          93,          94,          95,
  /* 4c */          96,          97,          98,          99,
  /* 50 */  GROUP(182),  GROUP(267),  GROUP(265),  GROUP(264),
  /* 54 */  GROUP(109),  GROUP(110),  GROUP(191),  GROUP(278),
  /* 58 */   GROUP(18),  GROUP(190),  GROUP(152),  GROUP(150),
  /* 5c */  GROUP(268),  GROUP(160),  GROUP(155),  GROUP(159),
  /* 60 */  GROUP(259),  GROUP(260),  GROUP(261),  GROUP(192),
  /* 64 */  GROUP(209),  GROUP(210),  GROUP(211),  GROUP(194),
  /* 68 */  GROUP(256),  GROUP(257),  GROUP(258),  GROUP(193),
  /* 6c */  GROUP(291),  GROUP(290),  GROUP(168),  GROUP(186),
  /* 70 */  GROUP(227),  GROUP(229),  GROUP(234),  GROUP(239),
  /* 74 */  GROUP(206),  GROUP(207),  GROUP(208),         199,
  /* 78 */  GROUP(276),  GROUP(277),     INVALID,     INVALID,
  /* 7c */  GROUP(292),  GROUP(293),  GROUP(171),  GROUP(187),
  /* 80 */         727,         729,         731,         733,
  /* 84 */         735,         737,         739,         741,
  /* 88 */         743,         745,         747,         749,
  /* 8c */         751,         753,         755,         757,
  /* 90 */        1350,        1351,        1352,        1353,
  /* 94 */        1354,        1355,        1356,        1357,
  /* 98 */        1358,        1359,        1360,        1361,
  /* 9c */        1362,        1363,        1364,        1365,
  /* a0 */        1245,        1100,         131,        1670,
  /* a4 */        1375,        1376,  GROUP(161),  GROUP(279),
  /* a8 */        1244,        1099,        1305,        1675,
  /* ac */        1377,        1378,  GROUP(111),         694,
  /* b0 */         122,         123,         775,        1673,
  /* b4 */         772,         773,         940,         941,
  /* b8 */  GROUP(296),     INVALID,  GROUP(295),        1671,
  /* bc */        1659,        1660,         930,         931,
  /* c0 */        1473,        1474,  GROUP(138),         904,
  /* c4 */  GROUP(213),  GROUP(212),  GROUP(266),  GROUP(139),
  /* c8 */        1661,        1662,        1663,        1664,
  /* cc */        1665,        1666,        1667,        1668,
  /* d0 */   GROUP(19),  GROUP(246),  GROUP(247),  GROUP(248),
  /* d4 */  GROUP(287),  GROUP(222),  GROUP(185),  GROUP(219),
  /* d8 */  GROUP(254),  GROUP(255),  GROUP(218),  GROUP(202),
  /* dc */  GROUP(200),  GROUP(201),  GROUP(216),  GROUP(203),
  /* e0 */  GROUP(204),  GROUP(244),  GROUP(245),  GROUP(205),
  /* e4 */  GROUP(220),  GROUP(221),  GROUP(149),  GROUP(183),
  /* e8 */  GROUP(252),  GROUP(253),  GROUP(217),  GROUP(223),
  /* ec */  GROUP(198),  GROUP(199),  GROUP(215),  GROUP(263),
  /* f0 */  GROUP(294),  GROUP(228),  GROUP(233),  GROUP(238),
  /* f4 */  GROUP(289),  GROUP(214),  GROUP(226),  GROUP(157),
  /* f8 */  GROUP(249),  GROUP(250),  GROUP(251),  GROUP(288),
  /* fc */  GROUP(195),  GROUP(196),  GROUP(197),     INVALID,
};

static const uint16_t ud_itab__18[] = {
  /*  0 */          27,     INVALID,          31,     INVALID,
};

static const uint16_t ud_itab__19[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__20[] = {
  /*  0 */   GROUP(37),   GROUP(38),   GROUP(39),   GROUP(40),
  /*  4 */   GROUP(41),   GROUP(42),   GROUP(43),   GROUP(44),
  /*  8 */   GROUP(45),   GROUP(47),   GROUP(46),   GROUP(48),
  /*  c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 10 */   GROUP(49),     INVALID,     INVALID,     INVALID,
  /* 14 */   GROUP(62),   GROUP(61),     INVALID,   GROUP(78),
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */   GROUP(34),   GROUP(35),   GROUP(36),     INVALID,
  /* 20 */   GROUP(65),   GROUP(66),   GROUP(67),   GROUP(68),
  /* 24 */   GROUP(69),   GROUP(70),     INVALID,     INVALID,
  /* 28 */   GROUP(50),   GROUP(77),   GROUP(63),   GROUP(64),
  /* 2c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 30 */   GROUP(71),   GROUP(72),   GROUP(73),   GROUP(74),
  /* 34 */   GROUP(75),   GROUP(76),     INVALID,   GROUP(79),
  /* 38 */   GROUP(51),   GROUP(52),   GROUP(53),   GROUP(54),
  /* 3c */   GROUP(55),   GROUP(56),   GROUP(58),   GROUP(57),
  /* 40 */   GROUP(59),   GROUP(60),     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 5c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */   GROUP(26),   GROUP(30),     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,   GROUP(25),
  /* dc */   GROUP(23),   GROUP(24),   GROUP(21),   GROUP(22),
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */   GROUP(80),   GROUP(81),     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__21[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__22[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__23[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__24[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__25[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__26[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__27[] = {
  /*  0 */   GROUP(28),   GROUP(29),
};

static const uint16_t ud_itab__28[] = {
  /*  0 */     INVALID,         717,     INVALID,
};

static const uint16_t ud_itab__29[] = {
  /*  0 */     INVALID,         718,     INVALID,
};

static const uint16_t ud_itab__30[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__31[] = {
  /*  0 */   GROUP(32),   GROUP(33),
};

static const uint16_t ud_itab__32[] = {
  /*  0 */     INVALID,         721,     INVALID,
};

static const uint16_t ud_itab__33[] = {
  /*  0 */     INVALID,         722,     INVALID,
};

static const uint16_t ud_itab__34[] = {
  /*  0 */        1573,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__35[] = {
  /*  0 */        1576,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__36[] = {
  /*  0 */        1579,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__37[] = {
  /*  0 */        1582,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__38[] = {
  /*  0 */        1585,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__39[] = {
  /*  0 */        1588,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__40[] = {
  /*  0 */        1591,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__41[] = {
  /*  0 */        1594,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__42[] = {
  /*  0 */        1597,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__43[] = {
  /*  0 */        1600,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__44[] = {
  /*  0 */        1603,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__45[] = {
  /*  0 */        1606,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__46[] = {
  /*  0 */        1609,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__47[] = {
  /*  0 */        1612,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__48[] = {
  /*  0 */        1615,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__49[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__50[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__51[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__52[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__53[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__54[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__55[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__56[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__57[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__58[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__59[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__60[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__61[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__62[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__63[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__64[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__65[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__66[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__67[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__68[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__69[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__70[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__71[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__72[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__73[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__74[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__75[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__76[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__77[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__78[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__79[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__80[] = {
  /*  0 */        1723,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__81[] = {
  /*  0 */        1724,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__82[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */   GROUP(97),   GROUP(98),   GROUP(99),  GROUP(100),
  /*  c */  GROUP(102),  GROUP(101),  GROUP(103),   GROUP(96),
  /* 10 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 14 */   GROUP(87),   GROUP(90),   GROUP(88),   GROUP(86),
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */   GROUP(91),   GROUP(95),   GROUP(92),     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 2c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */   GROUP(85),   GROUP(84),  GROUP(104),     INVALID,
  /* 44 */   GROUP(94),     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 5c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 60 */  GROUP(106),  GROUP(105),  GROUP(108),  GROUP(107),
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,   GROUP(83),
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__83[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__84[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__85[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__86[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__87[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__88[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__89[] = {
  /*  0 */     INVALID,        1049,        1051,
};

static const uint16_t ud_itab__90[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__91[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__92[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__93[] = {
  /*  0 */     INVALID,        1063,        1064,
};

static const uint16_t ud_itab__94[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__95[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__96[] = {
  /*  0 */        1618,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__97[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__98[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__99[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__100[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__101[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__102[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__103[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__104[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__105[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__106[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__107[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__108[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__109[] = {
  /*  0 */          61,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__110[] = {
  /*  0 */          65,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__111[] = {
  /*  0 */  GROUP(112),  GROUP(113),
};

static const uint16_t ud_itab__112[] = {
  /*  0 */         683,         682,         768,        1400,
  /*  4 */        1507,        1506,     INVALID,          79,
};

static const uint16_t ud_itab__113[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,  GROUP(114),  GROUP(115),  GROUP(116),
};

static const uint16_t ud_itab__114[] = {
  /*  0 */         777,         778,         779,         780,
  /*  4 */         781,         782,         783,         784,
};

static const uint16_t ud_itab__115[] = {
  /*  0 */         808,         809,         810,         811,
  /*  4 */         812,         813,         814,         815,
};

static const uint16_t ud_itab__116[] = {
  /*  0 */        1366,        1367,        1368,        1369,
  /*  4 */        1370,        1371,        1372,        1373,
};

static const uint16_t ud_itab__117[] = {
  /*  0 */  GROUP(137),  GROUP(118),
};

static const uint16_t ud_itab__118[] = {
  /*  0 */  GROUP(131),  GROUP(128),  GROUP(136),  GROUP(119),
  /*  4 */        1386,     INVALID,         788,  GROUP(129),
};

static const uint16_t ud_itab__119[] = {
  /*  0 */  GROUP(124),  GROUP(125),  GROUP(126),  GROUP(127),
  /*  4 */  GROUP(122),  GROUP(120),  GROUP(123),  GROUP(121),
};

static const uint16_t ud_itab__120[] = {
  /*  0 */          80,     INVALID,     INVALID,
};

static const uint16_t ud_itab__121[] = {
  /*  0 */         720,     INVALID,     INVALID,
};

static const uint16_t ud_itab__122[] = {
  /*  0 */        1397,     INVALID,     INVALID,
};

static const uint16_t ud_itab__123[] = {
  /*  0 */        1399,     INVALID,     INVALID,
};

static const uint16_t ud_itab__124[] = {
  /*  0 */        1466,     INVALID,     INVALID,
};

static const uint16_t ud_itab__125[] = {
  /*  0 */        1467,     INVALID,     INVALID,
};

static const uint16_t ud_itab__126[] = {
  /*  0 */        1468,     INVALID,     INVALID,
};

static const uint16_t ud_itab__127[] = {
  /*  0 */        1469,     INVALID,     INVALID,
};

static const uint16_t ud_itab__128[] = {
  /*  0 */         824,         952,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__129[] = {
  /*  0 */        1425,  GROUP(130),     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__130[] = {
  /*  0 */        1298,     INVALID,     INVALID,
};

static const uint16_t ud_itab__131[] = {
  /*  0 */     INVALID,  GROUP(132),  GROUP(133),  GROUP(134),
  /*  4 */  GROUP(135),     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__132[] = {
  /*  0 */     INVALID,        1455,     INVALID,
};

static const uint16_t ud_itab__133[] = {
  /*  0 */     INVALID,        1461,     INVALID,
};

static const uint16_t ud_itab__134[] = {
  /*  0 */     INVALID,        1462,     INVALID,
};

static const uint16_t ud_itab__135[] = {
  /*  0 */     INVALID,        1463,     INVALID,
};

static const uint16_t ud_itab__136[] = {
  /*  0 */        1485,        1508,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__137[] = {
  /*  0 */        1374,        1383,         785,         774,
  /*  4 */        1385,     INVALID,         787,         719,
};

static const uint16_t ud_itab__138[] = {
  /*  0 */         112,     INVALID,         120,     INVALID,
};

static const uint16_t ud_itab__139[] = {
  /*  0 */  GROUP(140),  GROUP(147),
};

static const uint16_t ud_itab__140[] = {
  /*  0 */     INVALID,  GROUP(141),     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,  GROUP(142),  GROUP(146),
};

static const uint16_t ud_itab__141[] = {
  /*  0 */     INVALID,         125,         126,
};

static const uint16_t ud_itab__142[] = {
  /*  0 */  GROUP(145),     INVALID,  GROUP(144),     INVALID,
};

static const uint16_t ud_itab__143[] = {
  /*  0 */     INVALID,        1457,     INVALID,
};

static const uint16_t ud_itab__144[] = {
  /*  0 */     INVALID,        1458,     INVALID,
};

static const uint16_t ud_itab__145[] = {
  /*  0 */     INVALID,        1459,     INVALID,
};

static const uint16_t ud_itab__146[] = {
  /*  0 */     INVALID,        1460,     INVALID,
};

static const uint16_t ud_itab__147[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,        1456,     INVALID,
};

static const uint16_t ud_itab__148[] = {
  /*  0 */         129,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__149[] = {
  /*  0 */     INVALID,     INVALID,         132,     INVALID,
};

static const uint16_t ud_itab__150[] = {
  /*  0 */         134,     INVALID,         163,     INVALID,
};

static const uint16_t ud_itab__151[] = {
  /*  0 */         147,     INVALID,         158,     INVALID,
};

static const uint16_t ud_itab__152[] = {
  /*  0 */         145,     INVALID,         156,     INVALID,
};

static const uint16_t ud_itab__153[] = {
  /*  0 */         141,     INVALID,         154,     INVALID,
};

static const uint16_t ud_itab__154[] = {
  /*  0 */         165,     INVALID,         168,     INVALID,
};

static const uint16_t ud_itab__155[] = {
  /*  0 */         189,     INVALID,         193,     INVALID,
};

static const uint16_t ud_itab__156[] = {
  /*  0 */        1384,        1406,         786,         798,
  /*  4 */        1453,        1454,     INVALID,     INVALID,
};

static const uint16_t ud_itab__157[] = {
  /*  0 */     INVALID,  GROUP(158),
};

static const uint16_t ud_itab__158[] = {
  /*  0 */         799,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__159[] = {
  /*  0 */         802,     INVALID,         806,     INVALID,
};

static const uint16_t ud_itab__160[] = {
  /*  0 */         818,     INVALID,         822,     INVALID,
};

static const uint16_t ud_itab__161[] = {
  /*  0 */     INVALID,  GROUP(162),
};

static const uint16_t ud_itab__162[] = {
  /*  0 */  GROUP(163),  GROUP(164),  GROUP(165),     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__163[] = {
  /*  0 */         825,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__164[] = {
  /*  0 */        1509,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__165[] = {
  /*  0 */        1510,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__166[] = {
  /*  0 */         862,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__167[] = {
  /*  0 */         864,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__168[] = {
  /*  0 */  GROUP(169),     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__169[] = {
  /*  0 */     INVALID,         867,         910,
};

static const uint16_t ud_itab__170[] = {
  /*  0 */     INVALID,         870,         911,
};

static const uint16_t ud_itab__171[] = {
  /*  0 */  GROUP(172),     INVALID,         916,     INVALID,
};

static const uint16_t ud_itab__172[] = {
  /*  0 */     INVALID,         873,         913,
};

static const uint16_t ud_itab__173[] = {
  /*  0 */     INVALID,         876,         914,
};

static const uint16_t ud_itab__174[] = {
  /*  0 */  GROUP(175),  GROUP(176),
};

static const uint16_t ud_itab__175[] = {
  /*  0 */         882,     INVALID,        1567,     INVALID,
};

static const uint16_t ud_itab__176[] = {
  /*  0 */         886,     INVALID,        1565,     INVALID,
};

static const uint16_t ud_itab__177[] = {
  /*  0 */         884,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__178[] = {
  /*  0 */  GROUP(179),  GROUP(180),
};

static const uint16_t ud_itab__179[] = {
  /*  0 */         892,     INVALID,        1571,     INVALID,
};

static const uint16_t ud_itab__180[] = {
  /*  0 */         896,     INVALID,        1569,     INVALID,
};

static const uint16_t ud_itab__181[] = {
  /*  0 */         894,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__182[] = {
  /*  0 */         900,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__183[] = {
  /*  0 */         909,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__184[] = {
  /*  0 */         907,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__185[] = {
  /*  0 */     INVALID,     INVALID,        1526,     INVALID,
};

static const uint16_t ud_itab__186[] = {
  /*  0 */         920,     INVALID,        1522,     INVALID,
};

static const uint16_t ud_itab__187[] = {
  /*  0 */         921,     INVALID,        1524,     INVALID,
};

static const uint16_t ud_itab__188[] = {
  /*  0 */         936,     INVALID,         928,     INVALID,
};

static const uint16_t ud_itab__189[] = {
  /*  0 */         938,     INVALID,         929,     INVALID,
};

static const uint16_t ud_itab__190[] = {
  /*  0 */         946,     INVALID,         950,     INVALID,
};

static const uint16_t ud_itab__191[] = {
  /*  0 */         976,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__192[] = {
  /*  0 */         987,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__193[] = {
  /*  0 */         990,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__194[] = {
  /*  0 */         993,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__195[] = {
  /*  0 */         996,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__196[] = {
  /*  0 */         997,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__197[] = {
  /*  0 */        1000,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__198[] = {
  /*  0 */        1003,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__199[] = {
  /*  0 */        1006,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__200[] = {
  /*  0 */        1009,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__201[] = {
  /*  0 */        1012,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__202[] = {
  /*  0 */        1017,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__203[] = {
  /*  0 */        1020,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__204[] = {
  /*  0 */        1023,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__205[] = {
  /*  0 */        1026,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__206[] = {
  /*  0 */        1027,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__207[] = {
  /*  0 */        1030,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__208[] = {
  /*  0 */        1033,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__209[] = {
  /*  0 */        1038,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__210[] = {
  /*  0 */        1041,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__211[] = {
  /*  0 */        1044,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__212[] = {
  /*  0 */        1055,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__213[] = {
  /*  0 */        1059,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__214[] = {
  /*  0 */        1069,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__215[] = {
  /*  0 */        1074,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__216[] = {
  /*  0 */        1075,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__217[] = {
  /*  0 */        1080,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__218[] = {
  /*  0 */        1083,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__219[] = {
  /*  0 */        1086,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__220[] = {
  /*  0 */        1087,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__221[] = {
  /*  0 */        1092,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__222[] = {
  /*  0 */        1093,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__223[] = {
  /*  0 */        1118,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__224[] = {
  /*  0 */        1119,        1120,        1121,        1122,
  /*  4 */        1123,        1124,        1125,        1126,
};

static const uint16_t ud_itab__225[] = {
  /*  0 */        1127,        1128,        1129,        1130,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__226[] = {
  /*  0 */        1133,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__227[] = {
  /*  0 */        1134,     INVALID,        1535,     INVALID,
};

static const uint16_t ud_itab__228[] = {
  /*  0 */        1136,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__229[] = {
  /*  0 */     INVALID,     INVALID,  GROUP(232),     INVALID,
  /*  4 */  GROUP(231),     INVALID,  GROUP(230),     INVALID,
};

static const uint16_t ud_itab__230[] = {
  /*  0 */        1138,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__231[] = {
  /*  0 */        1152,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__232[] = {
  /*  0 */        1159,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__233[] = {
  /*  0 */        1140,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__234[] = {
  /*  0 */     INVALID,     INVALID,  GROUP(237),     INVALID,
  /*  4 */  GROUP(236),     INVALID,  GROUP(235),     INVALID,
};

static const uint16_t ud_itab__235[] = {
  /*  0 */        1142,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__236[] = {
  /*  0 */        1153,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__237[] = {
  /*  0 */        1165,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__238[] = {
  /*  0 */        1144,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__239[] = {
  /*  0 */     INVALID,     INVALID,  GROUP(241),  GROUP(243),
  /*  4 */     INVALID,     INVALID,  GROUP(240),  GROUP(242),
};

static const uint16_t ud_itab__240[] = {
  /*  0 */        1146,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__241[] = {
  /*  0 */        1171,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__242[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__243[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__244[] = {
  /*  0 */        1147,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__245[] = {
  /*  0 */        1156,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__246[] = {
  /*  0 */        1160,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__247[] = {
  /*  0 */        1166,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__248[] = {
  /*  0 */        1172,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__249[] = {
  /*  0 */        1179,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__250[] = {
  /*  0 */        1182,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__251[] = {
  /*  0 */        1183,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__252[] = {
  /*  0 */        1186,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__253[] = {
  /*  0 */        1189,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__254[] = {
  /*  0 */        1192,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__255[] = {
  /*  0 */        1195,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__256[] = {
  /*  0 */        1200,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__257[] = {
  /*  0 */        1203,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__258[] = {
  /*  0 */        1206,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__259[] = {
  /*  0 */        1209,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__260[] = {
  /*  0 */        1212,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__261[] = {
  /*  0 */        1215,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__262[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  c */        1216,        1217,     INVALID,     INVALID,
  /* 10 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 14 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */        1218,        1219,     INVALID,     INVALID,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 2c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 5c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,        1220,     INVALID,
  /* 8c */     INVALID,     INVALID,        1221,     INVALID,
  /* 90 */        1222,     INVALID,     INVALID,     INVALID,
  /* 94 */        1223,     INVALID,        1224,        1225,
  /* 98 */     INVALID,     INVALID,        1226,     INVALID,
  /* 9c */     INVALID,     INVALID,        1227,     INVALID,
  /* a0 */        1228,     INVALID,     INVALID,     INVALID,
  /* a4 */        1229,     INVALID,        1230,        1231,
  /* a8 */     INVALID,     INVALID,        1232,     INVALID,
  /* ac */     INVALID,     INVALID,        1233,     INVALID,
  /* b0 */        1234,     INVALID,     INVALID,     INVALID,
  /* b4 */        1235,     INVALID,        1236,        1237,
  /* b8 */     INVALID,     INVALID,     INVALID,        1238,
  /* bc */     INVALID,     INVALID,     INVALID,        1239,
  /* c0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__263[] = {
  /*  0 */        1266,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__264[] = {
  /*  0 */        1291,     INVALID,        1293,     INVALID,
};

static const uint16_t ud_itab__265[] = {
  /*  0 */        1306,     INVALID,        1308,     INVALID,
};

static const uint16_t ud_itab__266[] = {
  /*  0 */        1381,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__267[] = {
  /*  0 */        1387,     INVALID,        1393,     INVALID,
};

static const uint16_t ud_itab__268[] = {
  /*  0 */        1419,     INVALID,        1423,     INVALID,
};

static const uint16_t ud_itab__269[] = {
  /*  0 */        1427,  GROUP(270),
};

static const uint16_t ud_itab__270[] = {
  /*  0 */     INVALID,        1428,     INVALID,
};

static const uint16_t ud_itab__271[] = {
  /*  0 */        1429,  GROUP(272),
};

static const uint16_t ud_itab__272[] = {
  /*  0 */     INVALID,        1430,     INVALID,
};

static const uint16_t ud_itab__273[] = {
  /*  0 */        1442,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__274[] = {
  /*  0 */        1447,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__275[] = {
  /*  0 */        1449,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__276[] = {
  /*  0 */     INVALID,        1464,     INVALID,
};

static const uint16_t ud_itab__277[] = {
  /*  0 */     INVALID,        1465,     INVALID,
};

static const uint16_t ud_itab__278[] = {
  /*  0 */        1499,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__279[] = {
  /*  0 */     INVALID,  GROUP(280),
};

static const uint16_t ud_itab__280[] = {
  /*  0 */  GROUP(286),  GROUP(281),  GROUP(282),  GROUP(283),
  /*  4 */  GROUP(284),  GROUP(285),     INVALID,     INVALID,
};

static const uint16_t ud_itab__281[] = {
  /*  0 */        1501,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__282[] = {
  /*  0 */        1502,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__283[] = {
  /*  0 */        1503,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__284[] = {
  /*  0 */        1504,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__285[] = {
  /*  0 */        1505,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__286[] = {
  /*  0 */        1511,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__287[] = {
  /*  0 */        1527,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__288[] = {
  /*  0 */        1532,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__289[] = {
  /*  0 */        1533,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__290[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__291[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__292[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__293[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__294[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__295[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */        1669,        1676,        1674,        1672,
};

static const uint16_t ud_itab__296[] = {
  /*  0 */     INVALID,     INVALID,        1710,     INVALID,
};

static const uint16_t ud_itab__297[] = {
  /*  0 */  GROUP(366),  GROUP(314),     INVALID,     INVALID,
  /*  4 */     INVALID,  GROUP(298),  GROUP(329),  GROUP(341),
  /*  8 */     INVALID,  GROUP(324),     INVALID,     INVALID,
  /*  c */     INVALID,  GROUP(320),     INVALID,     INVALID,
};

static const uint16_t ud_itab__298[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 10 */         933,         935,  GROUP(302),         891,
  /* 14 */        1452,        1446,  GROUP(301),         881,
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */         859,         861,     INVALID,         906,
  /* 2c */     INVALID,     INVALID,        1441,         128,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */         899,        1390,     INVALID,     INVALID,
  /* 54 */          60,          64,         975,        1498,
  /* 58 */          26,         945,         140,         144,
  /* 5c */        1418,         817,         188,         801,
  /* 60 */        1208,        1211,        1214,         986,
  /* 64 */        1037,        1040,        1043,         992,
  /* 68 */        1199,        1202,        1205,         989,
  /* 6c */        1548,        1546,  GROUP(299),        1518,
  /* 70 */        1540,  GROUP(304),  GROUP(306),  GROUP(308),
  /* 74 */        1029,        1032,        1035,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */        1550,        1554,  GROUP(300),        1516,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,         111,     INVALID,
  /* c4 */        1061,        1054,        1380,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */          34,        1162,        1168,        1174,
  /* d4 */        1529,        1095,         919,  GROUP(303),
  /* d8 */        1194,        1197,        1082,        1016,
  /* dc */        1011,        1014,        1077,        1019,
  /* e0 */        1022,        1149,        1155,        1025,
  /* e4 */        1089,        1091,         161,         903,
  /* e8 */        1188,        1191,        1079,        1117,
  /* ec */        1005,        1008,        1073,        1265,
  /* f0 */     INVALID,  GROUP(311),  GROUP(312),  GROUP(313),
  /* f4 */     INVALID,        1071,        1132,  GROUP(310),
  /* f8 */        1178,        1181,        1185,        1531,
  /* fc */         995,         999,        1002,     INVALID,
};

static const uint16_t ud_itab__299[] = {
  /*  0 */     INVALID,         871,         912,
};

static const uint16_t ud_itab__300[] = {
  /*  0 */     INVALID,         877,         915,
};

static const uint16_t ud_itab__301[] = {
  /*  0 */         879,     INVALID,
};

static const uint16_t ud_itab__302[] = {
  /*  0 */         889,     INVALID,
};

static const uint16_t ud_itab__303[] = {
  /*  0 */        1085,     INVALID,
};

static const uint16_t ud_itab__304[] = {
  /*  0 */     INVALID,     INVALID,        1164,     INVALID,
  /*  4 */        1151,     INVALID,  GROUP(305),     INVALID,
};

static const uint16_t ud_itab__305[] = {
  /*  0 */        1756,     INVALID,
};

static const uint16_t ud_itab__306[] = {
  /*  0 */     INVALID,     INVALID,        1170,     INVALID,
  /*  4 */        1158,     INVALID,  GROUP(307),     INVALID,
};

static const uint16_t ud_itab__307[] = {
  /*  0 */        1758,     INVALID,
};

static const uint16_t ud_itab__308[] = {
  /*  0 */     INVALID,     INVALID,        1176,        1544,
  /*  4 */     INVALID,     INVALID,  GROUP(309),        1542,
};

static const uint16_t ud_itab__309[] = {
  /*  0 */        1760,     INVALID,
};

static const uint16_t ud_itab__310[] = {
  /*  0 */     INVALID,        1520,
};

static const uint16_t ud_itab__311[] = {
  /*  0 */        1755,     INVALID,
};

static const uint16_t ud_itab__312[] = {
  /*  0 */        1757,     INVALID,
};

static const uint16_t ud_itab__313[] = {
  /*  0 */        1759,     INVALID,
};

static const uint16_t ud_itab__314[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 10 */         937,         939,  GROUP(316),         895,
  /* 14 */        1450,        1448,  GROUP(315),         885,
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */         863,         865,     INVALID,         908,
  /* 2c */     INVALID,     INVALID,        1443,         130,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */         901,        1388,        1307,        1292,
  /* 54 */          62,          66,         977,        1500,
  /* 58 */          28,         947,         146,         135,
  /* 5c */        1420,         819,         190,         803,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,  GROUP(319),
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,  GROUP(317),     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,         113,     INVALID,
  /* c4 */     INVALID,     INVALID,        1382,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__315[] = {
  /*  0 */         883,         887,
};

static const uint16_t ud_itab__316[] = {
  /*  0 */         893,         897,
};

static const uint16_t ud_itab__317[] = {
  /*  0 */  GROUP(318),     INVALID,
};

static const uint16_t ud_itab__318[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1401,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__319[] = {
  /*  0 */        1742,        1743,
};

static const uint16_t ud_itab__320[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 10 */  GROUP(322),  GROUP(323),  GROUP(321),     INVALID,
  /* 14 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,     INVALID,         153,     INVALID,
  /* 2c */         167,         149,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,        1392,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */          30,         949,         151,     INVALID,
  /* 5c */        1422,         821,         192,         805,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */        1538,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */        1552,        1556,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,         118,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */          36,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,         137,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */        1560,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__321[] = {
  /*  0 */        1564,        1562,
};

static const uint16_t ud_itab__322[] = {
  /*  0 */        1747,        1746,
};

static const uint16_t ud_itab__323[] = {
  /*  0 */        1749,        1748,
};

static const uint16_t ud_itab__324[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 10 */  GROUP(327),  GROUP(328),  GROUP(326),     INVALID,
  /* 14 */     INVALID,     INVALID,  GROUP(325),     INVALID,
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,     INVALID,         155,     INVALID,
  /* 2c */         169,         159,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,        1394,        1309,        1294,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */          32,         951,         157,         164,
  /* 5c */        1424,         823,         194,         807,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,        1523,
  /* 70 */        1536,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,         917,        1525,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,         121,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,         133,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__325[] = {
  /*  0 */        1568,        1566,
};

static const uint16_t ud_itab__326[] = {
  /*  0 */        1572,        1570,
};

static const uint16_t ud_itab__327[] = {
  /*  0 */        1751,        1750,
};

static const uint16_t ud_itab__328[] = {
  /*  0 */        1753,        1752,
};

static const uint16_t ud_itab__329[] = {
  /*  0 */        1584,        1587,        1590,        1593,
  /*  4 */        1596,        1599,        1602,        1605,
  /*  8 */        1608,        1614,        1611,        1617,
  /*  c */  GROUP(338),  GROUP(337),  GROUP(339),  GROUP(340),
  /* 10 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 14 */     INVALID,     INVALID,     INVALID,        1712,
  /* 18 */  GROUP(330),  GROUP(331),     INVALID,     INVALID,
  /* 1c */        1575,        1578,        1581,     INVALID,
  /* 20 */        1686,        1688,        1690,        1692,
  /* 24 */        1694,     INVALID,     INVALID,     INVALID,
  /* 28 */        1623,        1709,        1682,        1684,
  /* 2c */  GROUP(333),  GROUP(335),  GROUP(334),  GROUP(336),
  /* 30 */        1697,        1699,        1701,        1703,
  /* 34 */        1705,        1707,     INVALID,        1718,
  /* 38 */        1625,        1627,        1629,        1631,
  /* 3c */        1633,        1635,        1639,        1637,
  /* 40 */        1641,        1643,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 5c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,          46,
  /* dc */          42,          44,          38,          40,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__330[] = {
  /*  0 */        1727,     INVALID,
};

static const uint16_t ud_itab__331[] = {
  /*  0 */  GROUP(332),     INVALID,
};

static const uint16_t ud_itab__332[] = {
  /*  0 */     INVALID,        1728,
};

static const uint16_t ud_itab__333[] = {
  /*  0 */        1731,     INVALID,
};

static const uint16_t ud_itab__334[] = {
  /*  0 */        1732,     INVALID,
};

static const uint16_t ud_itab__335[] = {
  /*  0 */        1733,     INVALID,
};

static const uint16_t ud_itab__336[] = {
  /*  0 */        1734,     INVALID,
};

static const uint16_t ud_itab__337[] = {
  /*  0 */        1735,     INVALID,
};

static const uint16_t ud_itab__338[] = {
  /*  0 */        1737,     INVALID,
};

static const uint16_t ud_itab__339[] = {
  /*  0 */        1740,     INVALID,
};

static const uint16_t ud_itab__340[] = {
  /*  0 */        1741,     INVALID,
};

static const uint16_t ud_itab__341[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */  GROUP(360),  GROUP(359),  GROUP(361),     INVALID,
  /*  8 */        1645,        1647,        1649,        1651,
  /*  c */        1655,        1653,        1678,        1620,
  /* 10 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 14 */  GROUP(342),        1057,  GROUP(343),         202,
  /* 18 */  GROUP(357),  GROUP(355),     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */  GROUP(347),        1558,  GROUP(349),     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 2c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */         198,         196,        1680,     INVALID,
  /* 44 */        1513,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,  GROUP(364),  GROUP(363),
  /* 4c */  GROUP(365),     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 5c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 60 */        1716,        1714,        1722,        1720,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,          48,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__342[] = {
  /*  0 */        1046,     INVALID,
};

static const uint16_t ud_itab__343[] = {
  /*  0 */     INVALID,  GROUP(345),  GROUP(346),
};

static const uint16_t ud_itab__344[] = {
  /*  0 */        1048,     INVALID,
};

static const uint16_t ud_itab__345[] = {
  /*  0 */        1050,     INVALID,
};

static const uint16_t ud_itab__346[] = {
  /*  0 */     INVALID,        1052,
};

static const uint16_t ud_itab__347[] = {
  /*  0 */  GROUP(348),     INVALID,
};

static const uint16_t ud_itab__348[] = {
  /*  0 */        1065,     INVALID,
};

static const uint16_t ud_itab__349[] = {
  /*  0 */  GROUP(350),  GROUP(352),
};

static const uint16_t ud_itab__350[] = {
  /*  0 */  GROUP(351),     INVALID,
};

static const uint16_t ud_itab__351[] = {
  /*  0 */        1066,     INVALID,
};

static const uint16_t ud_itab__352[] = {
  /*  0 */  GROUP(353),  GROUP(354),
};

static const uint16_t ud_itab__353[] = {
  /*  0 */        1067,     INVALID,
};

static const uint16_t ud_itab__354[] = {
  /*  0 */        1068,     INVALID,
};

static const uint16_t ud_itab__355[] = {
  /*  0 */  GROUP(356),     INVALID,
};

static const uint16_t ud_itab__356[] = {
  /*  0 */     INVALID,        1729,
};

static const uint16_t ud_itab__357[] = {
  /*  0 */  GROUP(358),     INVALID,
};

static const uint16_t ud_itab__358[] = {
  /*  0 */     INVALID,        1730,
};

static const uint16_t ud_itab__359[] = {
  /*  0 */        1736,     INVALID,
};

static const uint16_t ud_itab__360[] = {
  /*  0 */        1738,     INVALID,
};

static const uint16_t ud_itab__361[] = {
  /*  0 */  GROUP(362),     INVALID,
};

static const uint16_t ud_itab__362[] = {
  /*  0 */     INVALID,        1739,
};

static const uint16_t ud_itab__363[] = {
  /*  0 */        1744,     INVALID,
};

static const uint16_t ud_itab__364[] = {
  /*  0 */        1745,     INVALID,
};

static const uint16_t ud_itab__365[] = {
  /*  0 */        1754,     INVALID,
};

static const uint16_t ud_itab__366[] = {
  /*  0 */         771,     INVALID,
};

static const uint16_t ud_itab__367[] = {
  /*  0 */          67,          68,
};

static const uint16_t ud_itab__368[] = {
  /*  0 */         707,         184,  GROUP(369),          71,
  /*  4 */         761,         762,        1255,     INVALID,
};

static const uint16_t ud_itab__369[] = {
  /*  0 */          69,          70,
};

static const uint16_t ud_itab__370[] = {
  /*  0 */          73,     INVALID,
};

static const uint16_t ud_itab__371[] = {
  /*  0 */     INVALID,          75,          76,
};

static const uint16_t ud_itab__372[] = {
  /*  0 */     INVALID,         116,         119,
};

static const uint16_t ud_itab__373[] = {
  /*  0 */     INVALID,         171,         172,
};

static const uint16_t ud_itab__374[] = {
  /*  0 */         173,     INVALID,
};

static const uint16_t ud_itab__375[] = {
  /*  0 */         174,     INVALID,
};

static const uint16_t ud_itab__376[] = {
  /*  0 */         708,         183,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__377[] = {
  /*  0 */        1438,        1439,         963,         954,
  /*  4 */         943,         696,         185,         688,
};

static const uint16_t ud_itab__378[] = {
  /*  0 */        1432,        1437,         962,         953,
  /*  4 */         942,         695,         186,         689,
};

static const uint16_t ud_itab__379[] = {
  /*  0 */  GROUP(381),  GROUP(380),
};

static const uint16_t ud_itab__380[] = {
  /*  0 */         477,         478,         479,         480,
  /*  4 */         481,         482,         483,         484,
  /*  8 */         658,         659,         660,         661,
  /*  c */         662,         663,         664,         665,
  /* 10 */         522,     INVALID,     INVALID,     INVALID,
  /* 14 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 18 */         549,         550,         551,         552,
  /* 1c */         553,         554,         555,         556,
  /* 20 */         233,         204,     INVALID,     INVALID,
  /* 24 */         639,         657,     INVALID,     INVALID,
  /* 28 */         485,         486,         487,         488,
  /* 2c */         489,         490,         491,     INVALID,
  /* 30 */         203,         685,         529,         526,
  /* 34 */         684,         528,         377,         454,
  /* 38 */         527,         686,         537,         536,
  /* 3c */         530,         534,         535,         376,
};

static const uint16_t ud_itab__381[] = {
  /*  0 */         476,     INVALID,         573,         540,
  /*  4 */         493,         492,         584,         583,
};

static const uint16_t ud_itab__382[] = {
  /*  0 */  GROUP(383),  GROUP(384),
};

static const uint16_t ud_itab__383[] = {
  /*  0 */         205,         494,         308,         358,
  /*  4 */         588,         613,         378,         404,
};

static const uint16_t ud_itab__384[] = {
  /*  0 */         207,         208,         209,         210,
  /*  4 */         211,         212,         213,         214,
  /*  8 */         495,         496,         497,         498,
  /*  c */         499,         500,         501,         502,
  /* 10 */         317,         318,         319,         320,
  /* 14 */         321,         322,         323,         324,
  /* 18 */         325,         326,         327,         328,
  /* 1c */         329,         330,         331,         332,
  /* 20 */         622,         623,         624,         625,
  /* 24 */         626,         627,         628,         629,
  /* 28 */         597,         598,         599,         600,
  /* 2c */         601,         602,         603,         604,
  /* 30 */         405,         406,         407,         408,
  /* 34 */         409,         410,         411,         412,
  /* 38 */         379,         380,         381,         382,
  /* 3c */         383,         384,         385,         386,
};

static const uint16_t ud_itab__385[] = {
  /*  0 */  GROUP(386),  GROUP(387),
};

static const uint16_t ud_itab__386[] = {
  /*  0 */         206,         503,         307,         357,
  /*  4 */         587,         630,         387,         413,
};

static const uint16_t ud_itab__387[] = {
  /*  0 */         215,         216,         217,         218,
  /*  4 */         219,         220,         221,         222,
  /*  8 */         504,         505,         506,         507,
  /*  c */         508,         509,         510,         511,
  /* 10 */         309,         310,         311,         312,
  /* 14 */         313,         314,         315,         316,
  /* 18 */         359,         360,         361,         362,
  /* 1c */         363,         364,         365,         366,
  /* 20 */         589,         590,         591,         592,
  /* 24 */         593,         594,         595,         596,
  /* 28 */         614,         615,         616,         617,
  /* 2c */         618,         619,         620,         621,
  /* 30 */         388,         389,         390,         391,
  /* 34 */         392,         393,         394,         395,
  /* 38 */         414,         415,         416,         417,
  /* 3c */         418,         419,         420,         421,
};

static const uint16_t ud_itab__388[] = {
  /*  0 */  GROUP(390),  GROUP(389),
};

static const uint16_t ud_itab__389[] = {
  /*  0 */         223,         224,         225,         226,
  /*  4 */         227,         228,         229,         230,
  /*  8 */         512,         513,         514,         515,
  /*  c */         516,         517,         518,         519,
  /* 10 */         367,         368,         369,         370,
  /* 14 */         371,         372,         373,         374,
  /* 18 */     INVALID,         375,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */         631,         632,         633,         634,
  /* 24 */         635,         636,         637,         638,
  /* 28 */         605,         606,         607,         608,
  /* 2c */         609,         610,         611,         612,
  /* 30 */         422,         423,         424,         425,
  /* 34 */         426,         427,         428,         429,
  /* 38 */         396,         397,         398,         399,
  /* 3c */         400,         401,         402,         403,
};

static const uint16_t ud_itab__390[] = {
  /*  0 */         457,         521,         447,         449,
  /*  4 */         463,         465,         461,         459,
};

static const uint16_t ud_itab__391[] = {
  /*  0 */  GROUP(392),  GROUP(393),
};

static const uint16_t ud_itab__392[] = {
  /*  0 */         451,         473,         466,         468,
  /*  4 */         231,         452,         232,         469,
};

static const uint16_t ud_itab__393[] = {
  /*  0 */         439,         440,         441,         442,
  /*  4 */         443,         444,         445,         446,
  /*  8 */         674,         675,         676,         677,
  /*  c */         678,         679,         680,         681,
  /* 10 */         557,         558,         559,         560,
  /* 14 */         561,         562,         563,         564,
  /* 18 */         565,         566,         567,         568,
  /* 1c */         569,         570,         571,         572,
  /* 20 */         586,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */         341,         342,         343,         344,
  /* 2c */         345,         346,         347,         348,
  /* 30 */         349,         350,         351,         352,
  /* 34 */         353,         354,         355,         356,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__394[] = {
  /*  0 */  GROUP(396),  GROUP(395),
};

static const uint16_t ud_itab__395[] = {
  /*  0 */         267,         268,         269,         270,
  /*  4 */         271,         272,         273,         274,
  /*  8 */         275,         276,         277,         278,
  /*  c */         279,         280,         281,         282,
  /* 10 */         283,         284,         285,         286,
  /* 14 */         287,         288,         289,         290,
  /* 18 */         291,         292,         293,         294,
  /* 1c */         295,         296,         297,         298,
  /* 20 */         524,         523,         234,         455,
  /* 24 */         525,         532,     INVALID,     INVALID,
  /* 28 */         299,         300,         301,         302,
  /* 2c */         303,         304,         305,         306,
  /* 30 */         333,         334,         335,         336,
  /* 34 */         337,         338,         339,         340,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__396[] = {
  /*  0 */         453,         471,         467,         470,
  /*  4 */     INVALID,         474,     INVALID,         538,
};

static const uint16_t ud_itab__397[] = {
  /*  0 */  GROUP(399),  GROUP(398),
};

static const uint16_t ud_itab__398[] = {
  /*  0 */         235,         236,         237,         238,
  /*  4 */         239,         240,         241,         242,
  /*  8 */         243,         244,         245,         246,
  /*  c */         247,         248,         249,         250,
  /* 10 */         251,         252,         253,         254,
  /* 14 */         255,         256,         257,         258,
  /* 18 */         259,         260,         261,         262,
  /* 1c */         263,         264,         265,         266,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,         656,     INVALID,     INVALID,
  /* 2c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__399[] = {
  /*  0 */         456,         520,         448,         450,
  /*  4 */         462,         464,         460,         458,
};

static const uint16_t ud_itab__400[] = {
  /*  0 */  GROUP(402),  GROUP(401),
};

static const uint16_t ud_itab__401[] = {
  /*  0 */         431,         432,         433,         434,
  /*  4 */         435,         436,         437,         438,
  /*  8 */         666,         667,         668,         669,
  /*  c */         670,         671,         672,         673,
  /* 10 */         575,         576,         577,         578,
  /* 14 */         579,         580,         581,         582,
  /* 18 */         541,         542,         543,         544,
  /* 1c */         545,         546,         547,         548,
  /* 20 */         640,         641,         642,         643,
  /* 24 */         644,         645,         646,         647,
  /* 28 */         648,         649,         650,         651,
  /* 2c */         652,         653,         654,         655,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__402[] = {
  /*  0 */         475,         472,         574,         539,
  /*  4 */         531,     INVALID,         533,         585,
};

static const uint16_t ud_itab__403[] = {
  /*  0 */     INVALID,         711,     INVALID,
};

static const uint16_t ud_itab__404[] = {
  /*  0 */         715,     INVALID,
};

static const uint16_t ud_itab__405[] = {
  /*  0 */     INVALID,         724,         725,
};

static const uint16_t ud_itab__406[] = {
  /*  0 */     INVALID,         759,         760,
};

static const uint16_t ud_itab__407[] = {
  /*  0 */         764,     INVALID,
};

static const uint16_t ud_itab__408[] = {
  /*  0 */  GROUP(409),  GROUP(314),     INVALID,     INVALID,
  /*  4 */     INVALID,  GROUP(298),  GROUP(329),  GROUP(341),
  /*  8 */     INVALID,  GROUP(324),     INVALID,     INVALID,
  /*  c */     INVALID,  GROUP(320),     INVALID,     INVALID,
};

static const uint16_t ud_itab__409[] = {
  /*  0 */         769,     INVALID,
};

static const uint16_t ud_itab__410[] = {
  /*  0 */     INVALID,         792,         793,
};

static const uint16_t ud_itab__411[] = {
  /*  0 */         826,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__412[] = {
  /*  0 */         827,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__413[] = {
  /*  0 */     INVALID,         924,         927,
};

static const uint16_t ud_itab__414[] = {
  /*  0 */     INVALID,         984,     INVALID,
};

static const uint16_t ud_itab__415[] = {
  /*  0 */        1096,     INVALID,
};

static const uint16_t ud_itab__416[] = {
  /*  0 */        1097,     INVALID,
};

static const uint16_t ud_itab__417[] = {
  /*  0 */        1098,     INVALID,
};

static const uint16_t ud_itab__418[] = {
  /*  0 */        1109,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__419[] = {
  /*  0 */     INVALID,  GROUP(421),     INVALID,
};

static const uint16_t ud_itab__420[] = {
  /*  0 */        1110,     INVALID,
};

static const uint16_t ud_itab__421[] = {
  /*  0 */        1111,     INVALID,
};

static const uint16_t ud_itab__422[] = {
  /*  0 */     INVALID,  GROUP(424),  GROUP(425),
};

static const uint16_t ud_itab__423[] = {
  /*  0 */        1112,     INVALID,
};

static const uint16_t ud_itab__424[] = {
  /*  0 */        1113,        1114,
};

static const uint16_t ud_itab__425[] = {
  /*  0 */     INVALID,        1115,
};

static const uint16_t ud_itab__426[] = {
  /*  0 */        1240,     INVALID,
};

static const uint16_t ud_itab__427[] = {
  /*  0 */        1241,     INVALID,
};

static const uint16_t ud_itab__428[] = {
  /*  0 */        1242,     INVALID,
};

static const uint16_t ud_itab__429[] = {
  /*  0 */        1243,     INVALID,
};

static const uint16_t ud_itab__430[] = {
  /*  0 */     INVALID,  GROUP(432),     INVALID,
};

static const uint16_t ud_itab__431[] = {
  /*  0 */        1257,     INVALID,
};

static const uint16_t ud_itab__432[] = {
  /*  0 */        1258,     INVALID,
};

static const uint16_t ud_itab__433[] = {
  /*  0 */     INVALID,  GROUP(435),  GROUP(436),
};

static const uint16_t ud_itab__434[] = {
  /*  0 */        1259,        1260,
};

static const uint16_t ud_itab__435[] = {
  /*  0 */        1261,        1262,
};

static const uint16_t ud_itab__436[] = {
  /*  0 */     INVALID,        1263,
};

static const uint16_t ud_itab__437[] = {
  /*  0 */        1279,        1286,        1267,        1275,
  /*  4 */        1327,        1334,        1318,        1313,
};

static const uint16_t ud_itab__438[] = {
  /*  0 */        1284,        1287,        1268,        1274,
  /*  4 */        1323,        1330,        1319,        1315,
};

static const uint16_t ud_itab__439[] = {
  /*  0 */        1280,        1285,        1269,        1273,
  /*  4 */        1326,        1333,        1320,        1314,
};

static const uint16_t ud_itab__440[] = {
  /*  0 */        1282,        1289,        1270,        1277,
  /*  4 */        1324,        1331,        1321,        1316,
};

static const uint16_t ud_itab__441[] = {
  /*  0 */        1283,        1290,        1271,        1278,
  /*  4 */        1328,        1335,        1322,        1317,
};

static const uint16_t ud_itab__442[] = {
  /*  0 */        1281,        1288,        1272,        1276,
  /*  4 */        1325,        1332,        1329,        1312,
};

static const uint16_t ud_itab__443[] = {
  /*  0 */        1311,     INVALID,
};

static const uint16_t ud_itab__444[] = {
  /*  0 */     INVALID,        1348,        1349,
};

static const uint16_t ud_itab__445[] = {
  /*  0 */     INVALID,        1404,        1405,
};

static const uint16_t ud_itab__446[] = {
  /*  0 */        1658,     INVALID,
};


struct ud_lookup_table_list_entry ud_lookup_table_list[] = {
    /* 000 */ { ud_itab__0, UD_TAB__OPC_TABLE, "opctbl" },
    /* 001 */ { ud_itab__1, UD_TAB__OPC_MODE, "/m" },
    /* 002 */ { ud_itab__2, UD_TAB__OPC_MODE, "/m" },
    /* 003 */ { ud_itab__3, UD_TAB__OPC_MODE, "/m" },
    /* 004 */ { ud_itab__4, UD_TAB__OPC_MODE, "/m" },
    /* 005 */ { ud_itab__5, UD_TAB__OPC_REG, "/reg" },
    /* 006 */ { ud_itab__6, UD_TAB__OPC_REG, "/reg" },
    /* 007 */ { ud_itab__7, UD_TAB__OPC_MODE, "/m" },
    /* 008 */ { ud_itab__8, UD_TAB__OPC_MODE, "/m" },
    /* 009 */ { ud_itab__9, UD_TAB__OPC_MODE, "/m" },
    /* 010 */ { ud_itab__10, UD_TAB__OPC_MODE, "/m" },
    /* 011 */ { ud_itab__11, UD_TAB__OPC_MODE, "/m" },
    /* 012 */ { ud_itab__12, UD_TAB__OPC_MODE, "/m" },
    /* 013 */ { ud_itab__13, UD_TAB__OPC_MODE, "/m" },
    /* 014 */ { ud_itab__14, UD_TAB__OPC_MODE, "/m" },
    /* 015 */ { ud_itab__15, UD_TAB__OPC_REG, "/reg" },
    /* 016 */ { ud_itab__16, UD_TAB__OPC_REG, "/reg" },
    /* 017 */ { ud_itab__17, UD_TAB__OPC_TABLE, "opctbl" },
    /* 018 */ { ud_itab__18, UD_TAB__OPC_SSE, "/sse" },
    /* 019 */ { ud_itab__19, UD_TAB__OPC_SSE, "/sse" },
    /* 020 */ { ud_itab__20, UD_TAB__OPC_TABLE, "opctbl" },
    /* 021 */ { ud_itab__21, UD_TAB__OPC_SSE, "/sse" },
    /* 022 */ { ud_itab__22, UD_TAB__OPC_SSE, "/sse" },
    /* 023 */ { ud_itab__23, UD_TAB__OPC_SSE, "/sse" },
    /* 024 */ { ud_itab__24, UD_TAB__OPC_SSE, "/sse" },
    /* 025 */ { ud_itab__25, UD_TAB__OPC_SSE, "/sse" },
    /* 026 */ { ud_itab__26, UD_TAB__OPC_SSE, "/sse" },
    /* 027 */ { ud_itab__27, UD_TAB__OPC_MODE, "/m" },
    /* 028 */ { ud_itab__28, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 029 */ { ud_itab__29, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 030 */ { ud_itab__30, UD_TAB__OPC_SSE, "/sse" },
    /* 031 */ { ud_itab__31, UD_TAB__OPC_MODE, "/m" },
    /* 032 */ { ud_itab__32, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 033 */ { ud_itab__33, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 034 */ { ud_itab__34, UD_TAB__OPC_SSE, "/sse" },
    /* 035 */ { ud_itab__35, UD_TAB__OPC_SSE, "/sse" },
    /* 036 */ { ud_itab__36, UD_TAB__OPC_SSE, "/sse" },
    /* 037 */ { ud_itab__37, UD_TAB__OPC_SSE, "/sse" },
    /* 038 */ { ud_itab__38, UD_TAB__OPC_SSE, "/sse" },
    /* 039 */ { ud_itab__39, UD_TAB__OPC_SSE, "/sse" },
    /* 040 */ { ud_itab__40, UD_TAB__OPC_SSE, "/sse" },
    /* 041 */ { ud_itab__41, UD_TAB__OPC_SSE, "/sse" },
    /* 042 */ { ud_itab__42, UD_TAB__OPC_SSE, "/sse" },
    /* 043 */ { ud_itab__43, UD_TAB__OPC_SSE, "/sse" },
    /* 044 */ { ud_itab__44, UD_TAB__OPC_SSE, "/sse" },
    /* 045 */ { ud_itab__45, UD_TAB__OPC_SSE, "/sse" },
    /* 046 */ { ud_itab__46, UD_TAB__OPC_SSE, "/sse" },
    /* 047 */ { ud_itab__47, UD_TAB__OPC_SSE, "/sse" },
    /* 048 */ { ud_itab__48, UD_TAB__OPC_SSE, "/sse" },
    /* 049 */ { ud_itab__49, UD_TAB__OPC_SSE, "/sse" },
    /* 050 */ { ud_itab__50, UD_TAB__OPC_SSE, "/sse" },
    /* 051 */ { ud_itab__51, UD_TAB__OPC_SSE, "/sse" },
    /* 052 */ { ud_itab__52, UD_TAB__OPC_SSE, "/sse" },
    /* 053 */ { ud_itab__53, UD_TAB__OPC_SSE, "/sse" },
    /* 054 */ { ud_itab__54, UD_TAB__OPC_SSE, "/sse" },
    /* 055 */ { ud_itab__55, UD_TAB__OPC_SSE, "/sse" },
    /* 056 */ { ud_itab__56, UD_TAB__OPC_SSE, "/sse" },
    /* 057 */ { ud_itab__57, UD_TAB__OPC_SSE, "/sse" },
    /* 058 */ { ud_itab__58, UD_TAB__OPC_SSE, "/sse" },
    /* 059 */ { ud_itab__59, UD_TAB__OPC_SSE, "/sse" },
    /* 060 */ { ud_itab__60, UD_TAB__OPC_SSE, "/sse" },
    /* 061 */ { ud_itab__61, UD_TAB__OPC_SSE, "/sse" },
    /* 062 */ { ud_itab__62, UD_TAB__OPC_SSE, "/sse" },
    /* 063 */ { ud_itab__63, UD_TAB__OPC_SSE, "/sse" },
    /* 064 */ { ud_itab__64, UD_TAB__OPC_SSE, "/sse" },
    /* 065 */ { ud_itab__65, UD_TAB__OPC_SSE, "/sse" },
    /* 066 */ { ud_itab__66, UD_TAB__OPC_SSE, "/sse" },
    /* 067 */ { ud_itab__67, UD_TAB__OPC_SSE, "/sse" },
    /* 068 */ { ud_itab__68, UD_TAB__OPC_SSE, "/sse" },
    /* 069 */ { ud_itab__69, UD_TAB__OPC_SSE, "/sse" },
    /* 070 */ { ud_itab__70, UD_TAB__OPC_SSE, "/sse" },
    /* 071 */ { ud_itab__71, UD_TAB__OPC_SSE, "/sse" },
    /* 072 */ { ud_itab__72, UD_TAB__OPC_SSE, "/sse" },
    /* 073 */ { ud_itab__73, UD_TAB__OPC_SSE, "/sse" },
    /* 074 */ { ud_itab__74, UD_TAB__OPC_SSE, "/sse" },
    /* 075 */ { ud_itab__75, UD_TAB__OPC_SSE, "/sse" },
    /* 076 */ { ud_itab__76, UD_TAB__OPC_SSE, "/sse" },
    /* 077 */ { ud_itab__77, UD_TAB__OPC_SSE, "/sse" },
    /* 078 */ { ud_itab__78, UD_TAB__OPC_SSE, "/sse" },
    /* 079 */ { ud_itab__79, UD_TAB__OPC_SSE, "/sse" },
    /* 080 */ { ud_itab__80, UD_TAB__OPC_SSE, "/sse" },
    /* 081 */ { ud_itab__81, UD_TAB__OPC_SSE, "/sse" },
    /* 082 */ { ud_itab__82, UD_TAB__OPC_TABLE, "opctbl" },
    /* 083 */ { ud_itab__83, UD_TAB__OPC_SSE, "/sse" },
    /* 084 */ { ud_itab__84, UD_TAB__OPC_SSE, "/sse" },
    /* 085 */ { ud_itab__85, UD_TAB__OPC_SSE, "/sse" },
    /* 086 */ { ud_itab__86, UD_TAB__OPC_SSE, "/sse" },
    /* 087 */ { ud_itab__87, UD_TAB__OPC_SSE, "/sse" },
    /* 088 */ { ud_itab__88, UD_TAB__OPC_SSE, "/sse" },
    /* 089 */ { ud_itab__89, UD_TAB__OPC_OSIZE, "/o" },
    /* 090 */ { ud_itab__90, UD_TAB__OPC_SSE, "/sse" },
    /* 091 */ { ud_itab__91, UD_TAB__OPC_SSE, "/sse" },
    /* 092 */ { ud_itab__92, UD_TAB__OPC_SSE, "/sse" },
    /* 093 */ { ud_itab__93, UD_TAB__OPC_OSIZE, "/o" },
    /* 094 */ { ud_itab__94, UD_TAB__OPC_SSE, "/sse" },
    /* 095 */ { ud_itab__95, UD_TAB__OPC_SSE, "/sse" },
    /* 096 */ { ud_itab__96, UD_TAB__OPC_SSE, "/sse" },
    /* 097 */ { ud_itab__97, UD_TAB__OPC_SSE, "/sse" },
    /* 098 */ { ud_itab__98, UD_TAB__OPC_SSE, "/sse" },
    /* 099 */ { ud_itab__99, UD_TAB__OPC_SSE, "/sse" },
    /* 100 */ { ud_itab__100, UD_TAB__OPC_SSE, "/sse" },
    /* 101 */ { ud_itab__101, UD_TAB__OPC_SSE, "/sse" },
    /* 102 */ { ud_itab__102, UD_TAB__OPC_SSE, "/sse" },
    /* 103 */ { ud_itab__103, UD_TAB__OPC_SSE, "/sse" },
    /* 104 */ { ud_itab__104, UD_TAB__OPC_SSE, "/sse" },
    /* 105 */ { ud_itab__105, UD_TAB__OPC_SSE, "/sse" },
    /* 106 */ { ud_itab__106, UD_TAB__OPC_SSE, "/sse" },
    /* 107 */ { ud_itab__107, UD_TAB__OPC_SSE, "/sse" },
    /* 108 */ { ud_itab__108, UD_TAB__OPC_SSE, "/sse" },
    /* 109 */ { ud_itab__109, UD_TAB__OPC_SSE, "/sse" },
    /* 110 */ { ud_itab__110, UD_TAB__OPC_SSE, "/sse" },
    /* 111 */ { ud_itab__111, UD_TAB__OPC_MOD, "/mod" },
    /* 112 */ { ud_itab__112, UD_TAB__OPC_REG, "/reg" },
    /* 113 */ { ud_itab__113, UD_TAB__OPC_REG, "/reg" },
    /* 114 */ { ud_itab__114, UD_TAB__OPC_RM, "/rm" },
    /* 115 */ { ud_itab__115, UD_TAB__OPC_RM, "/rm" },
    /* 116 */ { ud_itab__116, UD_TAB__OPC_RM, "/rm" },
    /* 117 */ { ud_itab__117, UD_TAB__OPC_MOD, "/mod" },
    /* 118 */ { ud_itab__118, UD_TAB__OPC_REG, "/reg" },
    /* 119 */ { ud_itab__119, UD_TAB__OPC_RM, "/rm" },
    /* 120 */ { ud_itab__120, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 121 */ { ud_itab__121, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 122 */ { ud_itab__122, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 123 */ { ud_itab__123, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 124 */ { ud_itab__124, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 125 */ { ud_itab__125, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 126 */ { ud_itab__126, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 127 */ { ud_itab__127, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 128 */ { ud_itab__128, UD_TAB__OPC_RM, "/rm" },
    /* 129 */ { ud_itab__129, UD_TAB__OPC_RM, "/rm" },
    /* 130 */ { ud_itab__130, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 131 */ { ud_itab__131, UD_TAB__OPC_RM, "/rm" },
    /* 132 */ { ud_itab__132, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 133 */ { ud_itab__133, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 134 */ { ud_itab__134, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 135 */ { ud_itab__135, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 136 */ { ud_itab__136, UD_TAB__OPC_RM, "/rm" },
    /* 137 */ { ud_itab__137, UD_TAB__OPC_REG, "/reg" },
    /* 138 */ { ud_itab__138, UD_TAB__OPC_SSE, "/sse" },
    /* 139 */ { ud_itab__139, UD_TAB__OPC_MOD, "/mod" },
    /* 140 */ { ud_itab__140, UD_TAB__OPC_REG, "/reg" },
    /* 141 */ { ud_itab__141, UD_TAB__OPC_OSIZE, "/o" },
    /* 142 */ { ud_itab__142, UD_TAB__OPC_SSE, "/sse" },
    /* 143 */ { ud_itab__143, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 144 */ { ud_itab__144, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 145 */ { ud_itab__145, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 146 */ { ud_itab__146, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 147 */ { ud_itab__147, UD_TAB__OPC_REG, "/reg" },
    /* 148 */ { ud_itab__148, UD_TAB__OPC_SSE, "/sse" },
    /* 149 */ { ud_itab__149, UD_TAB__OPC_SSE, "/sse" },
    /* 150 */ { ud_itab__150, UD_TAB__OPC_SSE, "/sse" },
    /* 151 */ { ud_itab__151, UD_TAB__OPC_SSE, "/sse" },
    /* 152 */ { ud_itab__152, UD_TAB__OPC_SSE, "/sse" },
    /* 153 */ { ud_itab__153, UD_TAB__OPC_SSE, "/sse" },
    /* 154 */ { ud_itab__154, UD_TAB__OPC_SSE, "/sse" },
    /* 155 */ { ud_itab__155, UD_TAB__OPC_SSE, "/sse" },
    /* 156 */ { ud_itab__156, UD_TAB__OPC_REG, "/reg" },
    /* 157 */ { ud_itab__157, UD_TAB__OPC_MOD, "/mod" },
    /* 158 */ { ud_itab__158, UD_TAB__OPC_SSE, "/sse" },
    /* 159 */ { ud_itab__159, UD_TAB__OPC_SSE, "/sse" },
    /* 160 */ { ud_itab__160, UD_TAB__OPC_SSE, "/sse" },
    /* 161 */ { ud_itab__161, UD_TAB__OPC_MOD, "/mod" },
    /* 162 */ { ud_itab__162, UD_TAB__OPC_REG, "/reg" },
    /* 163 */ { ud_itab__163, UD_TAB__OPC_RM, "/rm" },
    /* 164 */ { ud_itab__164, UD_TAB__OPC_RM, "/rm" },
    /* 165 */ { ud_itab__165, UD_TAB__OPC_RM, "/rm" },
    /* 166 */ { ud_itab__166, UD_TAB__OPC_SSE, "/sse" },
    /* 167 */ { ud_itab__167, UD_TAB__OPC_SSE, "/sse" },
    /* 168 */ { ud_itab__168, UD_TAB__OPC_SSE, "/sse" },
    /* 169 */ { ud_itab__169, UD_TAB__OPC_OSIZE, "/o" },
    /* 170 */ { ud_itab__170, UD_TAB__OPC_OSIZE, "/o" },
    /* 171 */ { ud_itab__171, UD_TAB__OPC_SSE, "/sse" },
    /* 172 */ { ud_itab__172, UD_TAB__OPC_OSIZE, "/o" },
    /* 173 */ { ud_itab__173, UD_TAB__OPC_OSIZE, "/o" },
    /* 174 */ { ud_itab__174, UD_TAB__OPC_MOD, "/mod" },
    /* 175 */ { ud_itab__175, UD_TAB__OPC_SSE, "/sse" },
    /* 176 */ { ud_itab__176, UD_TAB__OPC_SSE, "/sse" },
    /* 177 */ { ud_itab__177, UD_TAB__OPC_SSE, "/sse" },
    /* 178 */ { ud_itab__178, UD_TAB__OPC_MOD, "/mod" },
    /* 179 */ { ud_itab__179, UD_TAB__OPC_SSE, "/sse" },
    /* 180 */ { ud_itab__180, UD_TAB__OPC_SSE, "/sse" },
    /* 181 */ { ud_itab__181, UD_TAB__OPC_SSE, "/sse" },
    /* 182 */ { ud_itab__182, UD_TAB__OPC_SSE, "/sse" },
    /* 183 */ { ud_itab__183, UD_TAB__OPC_SSE, "/sse" },
    /* 184 */ { ud_itab__184, UD_TAB__OPC_SSE, "/sse" },
    /* 185 */ { ud_itab__185, UD_TAB__OPC_SSE, "/sse" },
    /* 186 */ { ud_itab__186, UD_TAB__OPC_SSE, "/sse" },
    /* 187 */ { ud_itab__187, UD_TAB__OPC_SSE, "/sse" },
    /* 188 */ { ud_itab__188, UD_TAB__OPC_SSE, "/sse" },
    /* 189 */ { ud_itab__189, UD_TAB__OPC_SSE, "/sse" },
    /* 190 */ { ud_itab__190, UD_TAB__OPC_SSE, "/sse" },
    /* 191 */ { ud_itab__191, UD_TAB__OPC_SSE, "/sse" },
    /* 192 */ { ud_itab__192, UD_TAB__OPC_SSE, "/sse" },
    /* 193 */ { ud_itab__193, UD_TAB__OPC_SSE, "/sse" },
    /* 194 */ { ud_itab__194, UD_TAB__OPC_SSE, "/sse" },
    /* 195 */ { ud_itab__195, UD_TAB__OPC_SSE, "/sse" },
    /* 196 */ { ud_itab__196, UD_TAB__OPC_SSE, "/sse" },
    /* 197 */ { ud_itab__197, UD_TAB__OPC_SSE, "/sse" },
    /* 198 */ { ud_itab__198, UD_TAB__OPC_SSE, "/sse" },
    /* 199 */ { ud_itab__199, UD_TAB__OPC_SSE, "/sse" },
    /* 200 */ { ud_itab__200, UD_TAB__OPC_SSE, "/sse" },
    /* 201 */ { ud_itab__201, UD_TAB__OPC_SSE, "/sse" },
    /* 202 */ { ud_itab__202, UD_TAB__OPC_SSE, "/sse" },
    /* 203 */ { ud_itab__203, UD_TAB__OPC_SSE, "/sse" },
    /* 204 */ { ud_itab__204, UD_TAB__OPC_SSE, "/sse" },
    /* 205 */ { ud_itab__205, UD_TAB__OPC_SSE, "/sse" },
    /* 206 */ { ud_itab__206, UD_TAB__OPC_SSE, "/sse" },
    /* 207 */ { ud_itab__207, UD_TAB__OPC_SSE, "/sse" },
    /* 208 */ { ud_itab__208, UD_TAB__OPC_SSE, "/sse" },
    /* 209 */ { ud_itab__209, UD_TAB__OPC_SSE, "/sse" },
    /* 210 */ { ud_itab__210, UD_TAB__OPC_SSE, "/sse" },
    /* 211 */ { ud_itab__211, UD_TAB__OPC_SSE, "/sse" },
    /* 212 */ { ud_itab__212, UD_TAB__OPC_SSE, "/sse" },
    /* 213 */ { ud_itab__213, UD_TAB__OPC_SSE, "/sse" },
    /* 214 */ { ud_itab__214, UD_TAB__OPC_SSE, "/sse" },
    /* 215 */ { ud_itab__215, UD_TAB__OPC_SSE, "/sse" },
    /* 216 */ { ud_itab__216, UD_TAB__OPC_SSE, "/sse" },
    /* 217 */ { ud_itab__217, UD_TAB__OPC_SSE, "/sse" },
    /* 218 */ { ud_itab__218, UD_TAB__OPC_SSE, "/sse" },
    /* 219 */ { ud_itab__219, UD_TAB__OPC_SSE, "/sse" },
    /* 220 */ { ud_itab__220, UD_TAB__OPC_SSE, "/sse" },
    /* 221 */ { ud_itab__221, UD_TAB__OPC_SSE, "/sse" },
    /* 222 */ { ud_itab__222, UD_TAB__OPC_SSE, "/sse" },
    /* 223 */ { ud_itab__223, UD_TAB__OPC_SSE, "/sse" },
    /* 224 */ { ud_itab__224, UD_TAB__OPC_REG, "/reg" },
    /* 225 */ { ud_itab__225, UD_TAB__OPC_REG, "/reg" },
    /* 226 */ { ud_itab__226, UD_TAB__OPC_SSE, "/sse" },
    /* 227 */ { ud_itab__227, UD_TAB__OPC_SSE, "/sse" },
    /* 228 */ { ud_itab__228, UD_TAB__OPC_SSE, "/sse" },
    /* 229 */ { ud_itab__229, UD_TAB__OPC_REG, "/reg" },
    /* 230 */ { ud_itab__230, UD_TAB__OPC_SSE, "/sse" },
    /* 231 */ { ud_itab__231, UD_TAB__OPC_SSE, "/sse" },
    /* 232 */ { ud_itab__232, UD_TAB__OPC_SSE, "/sse" },
    /* 233 */ { ud_itab__233, UD_TAB__OPC_SSE, "/sse" },
    /* 234 */ { ud_itab__234, UD_TAB__OPC_REG, "/reg" },
    /* 235 */ { ud_itab__235, UD_TAB__OPC_SSE, "/sse" },
    /* 236 */ { ud_itab__236, UD_TAB__OPC_SSE, "/sse" },
    /* 237 */ { ud_itab__237, UD_TAB__OPC_SSE, "/sse" },
    /* 238 */ { ud_itab__238, UD_TAB__OPC_SSE, "/sse" },
    /* 239 */ { ud_itab__239, UD_TAB__OPC_REG, "/reg" },
    /* 240 */ { ud_itab__240, UD_TAB__OPC_SSE, "/sse" },
    /* 241 */ { ud_itab__241, UD_TAB__OPC_SSE, "/sse" },
    /* 242 */ { ud_itab__242, UD_TAB__OPC_SSE, "/sse" },
    /* 243 */ { ud_itab__243, UD_TAB__OPC_SSE, "/sse" },
    /* 244 */ { ud_itab__244, UD_TAB__OPC_SSE, "/sse" },
    /* 245 */ { ud_itab__245, UD_TAB__OPC_SSE, "/sse" },
    /* 246 */ { ud_itab__246, UD_TAB__OPC_SSE, "/sse" },
    /* 247 */ { ud_itab__247, UD_TAB__OPC_SSE, "/sse" },
    /* 248 */ { ud_itab__248, UD_TAB__OPC_SSE, "/sse" },
    /* 249 */ { ud_itab__249, UD_TAB__OPC_SSE, "/sse" },
    /* 250 */ { ud_itab__250, UD_TAB__OPC_SSE, "/sse" },
    /* 251 */ { ud_itab__251, UD_TAB__OPC_SSE, "/sse" },
    /* 252 */ { ud_itab__252, UD_TAB__OPC_SSE, "/sse" },
    /* 253 */ { ud_itab__253, UD_TAB__OPC_SSE, "/sse" },
    /* 254 */ { ud_itab__254, UD_TAB__OPC_SSE, "/sse" },
    /* 255 */ { ud_itab__255, UD_TAB__OPC_SSE, "/sse" },
    /* 256 */ { ud_itab__256, UD_TAB__OPC_SSE, "/sse" },
    /* 257 */ { ud_itab__257, UD_TAB__OPC_SSE, "/sse" },
    /* 258 */ { ud_itab__258, UD_TAB__OPC_SSE, "/sse" },
    /* 259 */ { ud_itab__259, UD_TAB__OPC_SSE, "/sse" },
    /* 260 */ { ud_itab__260, UD_TAB__OPC_SSE, "/sse" },
    /* 261 */ { ud_itab__261, UD_TAB__OPC_SSE, "/sse" },
    /* 262 */ { ud_itab__262, UD_TAB__OPC_3DNOW, "/3dnow" },
    /* 263 */ { ud_itab__263, UD_TAB__OPC_SSE, "/sse" },
    /* 264 */ { ud_itab__264, UD_TAB__OPC_SSE, "/sse" },
    /* 265 */ { ud_itab__265, UD_TAB__OPC_SSE, "/sse" },
    /* 266 */ { ud_itab__266, UD_TAB__OPC_SSE, "/sse" },
    /* 267 */ { ud_itab__267, UD_TAB__OPC_SSE, "/sse" },
    /* 268 */ { ud_itab__268, UD_TAB__OPC_SSE, "/sse" },
    /* 269 */ { ud_itab__269, UD_TAB__OPC_MODE, "/m" },
    /* 270 */ { ud_itab__270, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 271 */ { ud_itab__271, UD_TAB__OPC_MODE, "/m" },
    /* 272 */ { ud_itab__272, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 273 */ { ud_itab__273, UD_TAB__OPC_SSE, "/sse" },
    /* 274 */ { ud_itab__274, UD_TAB__OPC_SSE, "/sse" },
    /* 275 */ { ud_itab__275, UD_TAB__OPC_SSE, "/sse" },
    /* 276 */ { ud_itab__276, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 277 */ { ud_itab__277, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 278 */ { ud_itab__278, UD_TAB__OPC_SSE, "/sse" },
    /* 279 */ { ud_itab__279, UD_TAB__OPC_MOD, "/mod" },
    /* 280 */ { ud_itab__280, UD_TAB__OPC_REG, "/reg" },
    /* 281 */ { ud_itab__281, UD_TAB__OPC_RM, "/rm" },
    /* 282 */ { ud_itab__282, UD_TAB__OPC_RM, "/rm" },
    /* 283 */ { ud_itab__283, UD_TAB__OPC_RM, "/rm" },
    /* 284 */ { ud_itab__284, UD_TAB__OPC_RM, "/rm" },
    /* 285 */ { ud_itab__285, UD_TAB__OPC_RM, "/rm" },
    /* 286 */ { ud_itab__286, UD_TAB__OPC_RM, "/rm" },
    /* 287 */ { ud_itab__287, UD_TAB__OPC_SSE, "/sse" },
    /* 288 */ { ud_itab__288, UD_TAB__OPC_SSE, "/sse" },
    /* 289 */ { ud_itab__289, UD_TAB__OPC_SSE, "/sse" },
    /* 290 */ { ud_itab__290, UD_TAB__OPC_SSE, "/sse" },
    /* 291 */ { ud_itab__291, UD_TAB__OPC_SSE, "/sse" },
    /* 292 */ { ud_itab__292, UD_TAB__OPC_SSE, "/sse" },
    /* 293 */ { ud_itab__293, UD_TAB__OPC_SSE, "/sse" },
    /* 294 */ { ud_itab__294, UD_TAB__OPC_SSE, "/sse" },
    /* 295 */ { ud_itab__295, UD_TAB__OPC_REG, "/reg" },
    /* 296 */ { ud_itab__296, UD_TAB__OPC_SSE, "/sse" },
    /* 297 */ { ud_itab__297, UD_TAB__OPC_VEX, "/vex" },
    /* 298 */ { ud_itab__298, UD_TAB__OPC_TABLE, "opctbl" },
    /* 299 */ { ud_itab__299, UD_TAB__OPC_OSIZE, "/o" },
    /* 300 */ { ud_itab__300, UD_TAB__OPC_OSIZE, "/o" },
    /* 301 */ { ud_itab__301, UD_TAB__OPC_MOD, "/mod" },
    /* 302 */ { ud_itab__302, UD_TAB__OPC_MOD, "/mod" },
    /* 303 */ { ud_itab__303, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 304 */ { ud_itab__304, UD_TAB__OPC_REG, "/reg" },
    /* 305 */ { ud_itab__305, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 306 */ { ud_itab__306, UD_TAB__OPC_REG, "/reg" },
    /* 307 */ { ud_itab__307, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 308 */ { ud_itab__308, UD_TAB__OPC_REG, "/reg" },
    /* 309 */ { ud_itab__309, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 310 */ { ud_itab__310, UD_TAB__OPC_MOD, "/mod" },
    /* 311 */ { ud_itab__311, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 312 */ { ud_itab__312, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 313 */ { ud_itab__313, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 314 */ { ud_itab__314, UD_TAB__OPC_TABLE, "opctbl" },
    /* 315 */ { ud_itab__315, UD_TAB__OPC_MOD, "/mod" },
    /* 316 */ { ud_itab__316, UD_TAB__OPC_MOD, "/mod" },
    /* 317 */ { ud_itab__317, UD_TAB__OPC_MOD, "/mod" },
    /* 318 */ { ud_itab__318, UD_TAB__OPC_REG, "/reg" },
    /* 319 */ { ud_itab__319, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 320 */ { ud_itab__320, UD_TAB__OPC_TABLE, "opctbl" },
    /* 321 */ { ud_itab__321, UD_TAB__OPC_MOD, "/mod" },
    /* 322 */ { ud_itab__322, UD_TAB__OPC_MOD, "/mod" },
    /* 323 */ { ud_itab__323, UD_TAB__OPC_MOD, "/mod" },
    /* 324 */ { ud_itab__324, UD_TAB__OPC_TABLE, "opctbl" },
    /* 325 */ { ud_itab__325, UD_TAB__OPC_MOD, "/mod" },
    /* 326 */ { ud_itab__326, UD_TAB__OPC_MOD, "/mod" },
    /* 327 */ { ud_itab__327, UD_TAB__OPC_MOD, "/mod" },
    /* 328 */ { ud_itab__328, UD_TAB__OPC_MOD, "/mod" },
    /* 329 */ { ud_itab__329, UD_TAB__OPC_TABLE, "opctbl" },
    /* 330 */ { ud_itab__330, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 331 */ { ud_itab__331, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 332 */ { ud_itab__332, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 333 */ { ud_itab__333, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 334 */ { ud_itab__334, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 335 */ { ud_itab__335, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 336 */ { ud_itab__336, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 337 */ { ud_itab__337, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 338 */ { ud_itab__338, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 339 */ { ud_itab__339, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 340 */ { ud_itab__340, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 341 */ { ud_itab__341, UD_TAB__OPC_TABLE, "opctbl" },
    /* 342 */ { ud_itab__342, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 343 */ { ud_itab__343, UD_TAB__OPC_OSIZE, "/o" },
    /* 344 */ { ud_itab__344, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 345 */ { ud_itab__345, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 346 */ { ud_itab__346, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 347 */ { ud_itab__347, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 348 */ { ud_itab__348, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 349 */ { ud_itab__349, UD_TAB__OPC_MODE, "/m" },
    /* 350 */ { ud_itab__350, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 351 */ { ud_itab__351, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 352 */ { ud_itab__352, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 353 */ { ud_itab__353, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 354 */ { ud_itab__354, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 355 */ { ud_itab__355, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 356 */ { ud_itab__356, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 357 */ { ud_itab__357, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 358 */ { ud_itab__358, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 359 */ { ud_itab__359, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 360 */ { ud_itab__360, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 361 */ { ud_itab__361, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 362 */ { ud_itab__362, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 363 */ { ud_itab__363, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 364 */ { ud_itab__364, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 365 */ { ud_itab__365, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 366 */ { ud_itab__366, UD_TAB__OPC_MODE, "/m" },
    /* 367 */ { ud_itab__367, UD_TAB__OPC_MODE, "/m" },
    /* 368 */ { ud_itab__368, UD_TAB__OPC_REG, "/reg" },
    /* 369 */ { ud_itab__369, UD_TAB__OPC_MODE, "/m" },
    /* 370 */ { ud_itab__370, UD_TAB__OPC_MODE, "/m" },
    /* 371 */ { ud_itab__371, UD_TAB__OPC_OSIZE, "/o" },
    /* 372 */ { ud_itab__372, UD_TAB__OPC_OSIZE, "/o" },
    /* 373 */ { ud_itab__373, UD_TAB__OPC_OSIZE, "/o" },
    /* 374 */ { ud_itab__374, UD_TAB__OPC_MODE, "/m" },
    /* 375 */ { ud_itab__375, UD_TAB__OPC_MODE, "/m" },
    /* 376 */ { ud_itab__376, UD_TAB__OPC_REG, "/reg" },
    /* 377 */ { ud_itab__377, UD_TAB__OPC_REG, "/reg" },
    /* 378 */ { ud_itab__378, UD_TAB__OPC_REG, "/reg" },
    /* 379 */ { ud_itab__379, UD_TAB__OPC_MOD, "/mod" },
    /* 380 */ { ud_itab__380, UD_TAB__OPC_X87, "/x87" },
    /* 381 */ { ud_itab__381, UD_TAB__OPC_REG, "/reg" },
    /* 382 */ { ud_itab__382, UD_TAB__OPC_MOD, "/mod" },
    /* 383 */ { ud_itab__383, UD_TAB__OPC_REG, "/reg" },
    /* 384 */ { ud_itab__384, UD_TAB__OPC_X87, "/x87" },
    /* 385 */ { ud_itab__385, UD_TAB__OPC_MOD, "/mod" },
    /* 386 */ { ud_itab__386, UD_TAB__OPC_REG, "/reg" },
    /* 387 */ { ud_itab__387, UD_TAB__OPC_X87, "/x87" },
    /* 388 */ { ud_itab__388, UD_TAB__OPC_MOD, "/mod" },
    /* 389 */ { ud_itab__389, UD_TAB__OPC_X87, "/x87" },
    /* 390 */ { ud_itab__390, UD_TAB__OPC_REG, "/reg" },
    /* 391 */ { ud_itab__391, UD_TAB__OPC_MOD, "/mod" },
    /* 392 */ { ud_itab__392, UD_TAB__OPC_REG, "/reg" },
    /* 393 */ { ud_itab__393, UD_TAB__OPC_X87, "/x87" },
    /* 394 */ { ud_itab__394, UD_TAB__OPC_MOD, "/mod" },
    /* 395 */ { ud_itab__395, UD_TAB__OPC_X87, "/x87" },
    /* 396 */ { ud_itab__396, UD_TAB__OPC_REG, "/reg" },
    /* 397 */ { ud_itab__397, UD_TAB__OPC_MOD, "/mod" },
    /* 398 */ { ud_itab__398, UD_TAB__OPC_X87, "/x87" },
    /* 399 */ { ud_itab__399, UD_TAB__OPC_REG, "/reg" },
    /* 400 */ { ud_itab__400, UD_TAB__OPC_MOD, "/mod" },
    /* 401 */ { ud_itab__401, UD_TAB__OPC_X87, "/x87" },
    /* 402 */ { ud_itab__402, UD_TAB__OPC_REG, "/reg" },
    /* 403 */ { ud_itab__403, UD_TAB__OPC_OSIZE, "/o" },
    /* 404 */ { ud_itab__404, UD_TAB__OPC_MODE, "/m" },
    /* 405 */ { ud_itab__405, UD_TAB__OPC_OSIZE, "/o" },
    /* 406 */ { ud_itab__406, UD_TAB__OPC_ASIZE, "/a" },
    /* 407 */ { ud_itab__407, UD_TAB__OPC_MODE, "/m" },
    /* 408 */ { ud_itab__408, UD_TAB__OPC_VEX, "/vex" },
    /* 409 */ { ud_itab__409, UD_TAB__OPC_MODE, "/m" },
    /* 410 */ { ud_itab__410, UD_TAB__OPC_OSIZE, "/o" },
    /* 411 */ { ud_itab__411, UD_TAB__OPC_REG, "/reg" },
    /* 412 */ { ud_itab__412, UD_TAB__OPC_REG, "/reg" },
    /* 413 */ { ud_itab__413, UD_TAB__OPC_OSIZE, "/o" },
    /* 414 */ { ud_itab__414, UD_TAB__OPC_OSIZE, "/o" },
    /* 415 */ { ud_itab__415, UD_TAB__OPC_MODE, "/m" },
    /* 416 */ { ud_itab__416, UD_TAB__OPC_MODE, "/m" },
    /* 417 */ { ud_itab__417, UD_TAB__OPC_MODE, "/m" },
    /* 418 */ { ud_itab__418, UD_TAB__OPC_REG, "/reg" },
    /* 419 */ { ud_itab__419, UD_TAB__OPC_OSIZE, "/o" },
    /* 420 */ { ud_itab__420, UD_TAB__OPC_MODE, "/m" },
    /* 421 */ { ud_itab__421, UD_TAB__OPC_MODE, "/m" },
    /* 422 */ { ud_itab__422, UD_TAB__OPC_OSIZE, "/o" },
    /* 423 */ { ud_itab__423, UD_TAB__OPC_MODE, "/m" },
    /* 424 */ { ud_itab__424, UD_TAB__OPC_MODE, "/m" },
    /* 425 */ { ud_itab__425, UD_TAB__OPC_MODE, "/m" },
    /* 426 */ { ud_itab__426, UD_TAB__OPC_MODE, "/m" },
    /* 427 */ { ud_itab__427, UD_TAB__OPC_MODE, "/m" },
    /* 428 */ { ud_itab__428, UD_TAB__OPC_MODE, "/m" },
    /* 429 */ { ud_itab__429, UD_TAB__OPC_MODE, "/m" },
    /* 430 */ { ud_itab__430, UD_TAB__OPC_OSIZE, "/o" },
    /* 431 */ { ud_itab__431, UD_TAB__OPC_MODE, "/m" },
    /* 432 */ { ud_itab__432, UD_TAB__OPC_MODE, "/m" },
    /* 433 */ { ud_itab__433, UD_TAB__OPC_OSIZE, "/o" },
    /* 434 */ { ud_itab__434, UD_TAB__OPC_MODE, "/m" },
    /* 435 */ { ud_itab__435, UD_TAB__OPC_MODE, "/m" },
    /* 436 */ { ud_itab__436, UD_TAB__OPC_MODE, "/m" },
    /* 437 */ { ud_itab__437, UD_TAB__OPC_REG, "/reg" },
    /* 438 */ { ud_itab__438, UD_TAB__OPC_REG, "/reg" },
    /* 439 */ { ud_itab__439, UD_TAB__OPC_REG, "/reg" },
    /* 440 */ { ud_itab__440, UD_TAB__OPC_REG, "/reg" },
    /* 441 */ { ud_itab__441, UD_TAB__OPC_REG, "/reg" },
    /* 442 */ { ud_itab__442, UD_TAB__OPC_REG, "/reg" },
    /* 443 */ { ud_itab__443, UD_TAB__OPC_MODE, "/m" },
    /* 444 */ { ud_itab__444, UD_TAB__OPC_OSIZE, "/o" },
    /* 445 */ { ud_itab__445, UD_TAB__OPC_OSIZE, "/o" },
    /* 446 */ { ud_itab__446, UD_TAB__OPC_MODE, "/m" },
};

/* itab entry operand definitions (for readability) */
#define O_AL      { OP_AL,       SZ_B     }
#define O_AX      { OP_AX,       SZ_W     }
#define O_Av      { OP_A,        SZ_V     }
#define O_C       { OP_C,        SZ_NA    }
#define O_CL      { OP_CL,       SZ_B     }
#define O_CS      { OP_CS,       SZ_NA    }
#define O_CX      { OP_CX,       SZ_W     }
#define O_D       { OP_D,        SZ_NA    }
#define O_DL      { OP_DL,       SZ_B     }
#define O_DS      { OP_DS,       SZ_NA    }
#define O_DX      { OP_DX,       SZ_W     }
#define O_E       { OP_E,        SZ_NA    }
#define O_ES      { OP_ES,       SZ_NA    }
#define O_Eb      { OP_E,        SZ_B     }
#define O_Ed      { OP_E,        SZ_D     }
#define O_Eq      { OP_E,        SZ_Q     }
#define O_Ev      { OP_E,        SZ_V     }
#define O_Ew      { OP_E,        SZ_W     }
#define O_Ey      { OP_E,        SZ_Y     }
#define O_Ez      { OP_E,        SZ_Z     }
#define O_FS      { OP_FS,       SZ_NA    }
#define O_Fv      { OP_F,        SZ_V     }
#define O_G       { OP_G,        SZ_NA    }
#define O_GS      { OP_GS,       SZ_NA    }
#define O_Gb      { OP_G,        SZ_B     }
#define O_Gd      { OP_G,        SZ_D     }
#define O_Gq      { OP_G,        SZ_Q     }
#define O_Gv      { OP_G,        SZ_V     }
#define O_Gw      { OP_G,        SZ_W     }
#define O_Gy      { OP_G,        SZ_Y     }
#define O_Gz      { OP_G,        SZ_Z     }
#define O_H       { OP_H,        SZ_X     }
#define O_Hqq     { OP_H,        SZ_QQ    }
#define O_Hx      { OP_H,        SZ_X     }
#define O_I1      { OP_I1,       SZ_NA    }
#define O_I3      { OP_I3,       SZ_NA    }
#define O_Ib      { OP_I,        SZ_B     }
#define O_Iv      { OP_I,        SZ_V     }
#define O_Iw      { OP_I,        SZ_W     }
#define O_Iz      { OP_I,        SZ_Z     }
#define O_Jb      { OP_J,        SZ_B     }
#define O_Jv      { OP_J,        SZ_V     }
#define O_Jz      { OP_J,        SZ_Z     }
#define O_L       { OP_L,        SZ_O     }
#define O_Lx      { OP_L,        SZ_X     }
#define O_M       { OP_M,        SZ_NA    }
#define O_Mb      { OP_M,        SZ_B     }
#define O_MbRd    { OP_MR,       SZ_BD    }
#define O_MbRv    { OP_MR,       SZ_BV    }
#define O_Md      { OP_M,        SZ_D     }
#define O_MdRy    { OP_MR,       SZ_DY    }
#define O_MdU     { OP_MU,       SZ_DO    }
#define O_Mdq     { OP_M,        SZ_DQ    }
#define O_Mo      { OP_M,        SZ_O     }
#define O_Mq      { OP_M,        SZ_Q     }
#define O_MqU     { OP_MU,       SZ_QO    }
#define O_Ms      { OP_M,        SZ_W     }
#define O_Mt      { OP_M,        SZ_T     }
#define O_Mv      { OP_M,        SZ_V     }
#define O_Mw      { OP_M,        SZ_W     }
#define O_MwRd    { OP_MR,       SZ_WD    }
#define O_MwRv    { OP_MR,       SZ_WV    }
#define O_MwRy    { OP_MR,       SZ_WY    }
#define O_MwU     { OP_MU,       SZ_WO    }
#define O_N       { OP_N,        SZ_Q     }
#define O_NONE    { OP_NONE,     SZ_NA    }
#define O_Ob      { OP_O,        SZ_B     }
#define O_Ov      { OP_O,        SZ_V     }
#define O_Ow      { OP_O,        SZ_W     }
#define O_P       { OP_P,        SZ_Q     }
#define O_Q       { OP_Q,        SZ_Q     }
#define O_R       { OP_R,        SZ_RDQ   }
#define O_R0b     { OP_R0,       SZ_B     }
#define O_R0v     { OP_R0,       SZ_V     }
#define O_R0w     { OP_R0,       SZ_W     }
#define O_R0y     { OP_R0,       SZ_Y     }
#define O_R0z     { OP_R0,       SZ_Z     }
#define O_R1b     { OP_R1,       SZ_B     }
#define O_R1v     { OP_R1,       SZ_V     }
#define O_R1w     { OP_R1,       SZ_W     }
#define O_R1y     { OP_R1,       SZ_Y     }
#define O_R1z     { OP_R1,       SZ_Z     }
#define O_R2b     { OP_R2,       SZ_B     }
#define O_R2v     { OP_R2,       SZ_V     }
#define O_R2w     { OP_R2,       SZ_W     }
#define O_R2y     { OP_R2,       SZ_Y     }
#define O_R2z     { OP_R2,       SZ_Z     }
#define O_R3b     { OP_R3,       SZ_B     }
#define O_R3v     { OP_R3,       SZ_V     }
#define O_R3w     { OP_R3,       SZ_W     }
#define O_R3y     { OP_R3,       SZ_Y     }
#define O_R3z     { OP_R3,       SZ_Z     }
#define O_R4b     { OP_R4,       SZ_B     }
#define O_R4v     { OP_R4,       SZ_V     }
#define O_R4w     { OP_R4,       SZ_W     }
#define O_R4y     { OP_R4,       SZ_Y     }
#define O_R4z     { OP_R4,       SZ_Z     }
#define O_R5b     { OP_R5,       SZ_B     }
#define O_R5v     { OP_R5,       SZ_V     }
#define O_R5w     { OP_R5,       SZ_W     }
#define O_R5y     { OP_R5,       SZ_Y     }
#define O_R5z     { OP_R5,       SZ_Z     }
#define O_R6b     { OP_R6,       SZ_B     }
#define O_R6v     { OP_R6,       SZ_V     }
#define O_R6w     { OP_R6,       SZ_W     }
#define O_R6y     { OP_R6,       SZ_Y     }
#define O_R6z     { OP_R6,       SZ_Z     }
#define O_R7b     { OP_R7,       SZ_B     }
#define O_R7v     { OP_R7,       SZ_V     }
#define O_R7w     { OP_R7,       SZ_W     }
#define O_R7y     { OP_R7,       SZ_Y     }
#define O_R7z     { OP_R7,       SZ_Z     }
#define O_S       { OP_S,        SZ_W     }
#define O_SS      { OP_SS,       SZ_NA    }
#define O_ST0     { OP_ST0,      SZ_NA    }
#define O_ST1     { OP_ST1,      SZ_NA    }
#define O_ST2     { OP_ST2,      SZ_NA    }
#define O_ST3     { OP_ST3,      SZ_NA    }
#define O_ST4     { OP_ST4,      SZ_NA    }
#define O_ST5     { OP_ST5,      SZ_NA    }
#define O_ST6     { OP_ST6,      SZ_NA    }
#define O_ST7     { OP_ST7,      SZ_NA    }
#define O_U       { OP_U,        SZ_O     }
#define O_Ux      { OP_U,        SZ_X     }
#define O_V       { OP_V,        SZ_DQ    }
#define O_Vdq     { OP_V,        SZ_DQ    }
#define O_Vqq     { OP_V,        SZ_QQ    }
#define O_Vsd     { OP_V,        SZ_Q     }
#define O_Vx      { OP_V,        SZ_X     }
#define O_W       { OP_W,        SZ_DQ    }
#define O_Wdq     { OP_W,        SZ_DQ    }
#define O_Wqq     { OP_W,        SZ_QQ    }
#define O_Wsd     { OP_W,        SZ_Q     }
#define O_Wx      { OP_W,        SZ_X     }
#define O_eAX     { OP_eAX,      SZ_Z     }
#define O_eCX     { OP_eCX,      SZ_Z     }
#define O_eDX     { OP_eDX,      SZ_Z     }
#define O_rAX     { OP_rAX,      SZ_V     }
#define O_rCX     { OP_rCX,      SZ_V     }
#define O_rDX     { OP_rDX,      SZ_V     }
#define O_sIb     { OP_sI,       SZ_B     }
#define O_sIv     { OP_sI,       SZ_V     }
#define O_sIz     { OP_sI,       SZ_Z     }

struct ud_itab_entry ud_itab[] = {
  /* 0000 */ { UD_Iinvalid, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0001 */ { UD_Iaaa, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0002 */ { UD_Iaad, O_Ib, O_NONE, O_NONE, O_NONE, P_none },
  /* 0003 */ { UD_Iaam, O_Ib, O_NONE, O_NONE, O_NONE, P_none },
  /* 0004 */ { UD_Iaas, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0005 */ { UD_Iadc, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0006 */ { UD_Iadc, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0007 */ { UD_Iadc, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0008 */ { UD_Iadc, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0009 */ { UD_Iadc, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0010 */ { UD_Iadc, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0011 */ { UD_Iadc, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0012 */ { UD_Iadc, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0013 */ { UD_Iadc, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0014 */ { UD_Iadc, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0015 */ { UD_Iadd, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0016 */ { UD_Iadd, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0017 */ { UD_Iadd, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0018 */ { UD_Iadd, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0019 */ { UD_Iadd, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0020 */ { UD_Iadd, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0021 */ { UD_Iadd, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0022 */ { UD_Iadd, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0023 */ { UD_Iadd, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0024 */ { UD_Iadd, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0025 */ { UD_Iaddpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0026 */ { UD_Ivaddpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0027 */ { UD_Iaddps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0028 */ { UD_Ivaddps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0029 */ { UD_Iaddsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0030 */ { UD_Ivaddsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0031 */ { UD_Iaddss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0032 */ { UD_Ivaddss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0033 */ { UD_Iaddsubpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0034 */ { UD_Ivaddsubpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0035 */ { UD_Iaddsubps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0036 */ { UD_Ivaddsubps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0037 */ { UD_Iaesdec, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0038 */ { UD_Ivaesdec, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0039 */ { UD_Iaesdeclast, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0040 */ { UD_Ivaesdeclast, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0041 */ { UD_Iaesenc, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0042 */ { UD_Ivaesenc, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0043 */ { UD_Iaesenclast, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0044 */ { UD_Ivaesenclast, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0045 */ { UD_Iaesimc, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0046 */ { UD_Ivaesimc, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0047 */ { UD_Iaeskeygenassist, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0048 */ { UD_Ivaeskeygenassist, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0049 */ { UD_Iand, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0050 */ { UD_Iand, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0051 */ { UD_Iand, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0052 */ { UD_Iand, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0053 */ { UD_Iand, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0054 */ { UD_Iand, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0055 */ { UD_Iand, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0056 */ { UD_Iand, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0057 */ { UD_Iand, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0058 */ { UD_Iand, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0059 */ { UD_Iandpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0060 */ { UD_Ivandpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0061 */ { UD_Iandps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0062 */ { UD_Ivandps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0063 */ { UD_Iandnpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0064 */ { UD_Ivandnpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0065 */ { UD_Iandnps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0066 */ { UD_Ivandnps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0067 */ { UD_Iarpl, O_Ew, O_Gw, O_NONE, O_NONE, P_aso },
  /* 0068 */ { UD_Imovsxd, O_Gq, O_Ed, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexx|P_rexr|P_rexb },
  /* 0069 */ { UD_Icall, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0070 */ { UD_Icall, O_Eq, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 0071 */ { UD_Icall, O_Fv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0072 */ { UD_Icall, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0073 */ { UD_Icall, O_Av, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0074 */ { UD_Icbw, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0075 */ { UD_Icwde, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0076 */ { UD_Icdqe, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0077 */ { UD_Iclc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0078 */ { UD_Icld, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0079 */ { UD_Iclflush, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0080 */ { UD_Iclgi, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0081 */ { UD_Icli, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0082 */ { UD_Iclts, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0083 */ { UD_Icmc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0084 */ { UD_Icmovo, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0085 */ { UD_Icmovno, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0086 */ { UD_Icmovb, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0087 */ { UD_Icmovae, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0088 */ { UD_Icmovz, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0089 */ { UD_Icmovnz, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0090 */ { UD_Icmovbe, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0091 */ { UD_Icmova, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0092 */ { UD_Icmovs, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0093 */ { UD_Icmovns, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0094 */ { UD_Icmovp, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0095 */ { UD_Icmovnp, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0096 */ { UD_Icmovl, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0097 */ { UD_Icmovge, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0098 */ { UD_Icmovle, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0099 */ { UD_Icmovg, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0100 */ { UD_Icmp, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0101 */ { UD_Icmp, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0102 */ { UD_Icmp, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0103 */ { UD_Icmp, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0104 */ { UD_Icmp, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0105 */ { UD_Icmp, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0106 */ { UD_Icmp, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0107 */ { UD_Icmp, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0108 */ { UD_Icmp, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0109 */ { UD_Icmp, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0110 */ { UD_Icmppd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0111 */ { UD_Ivcmppd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0112 */ { UD_Icmpps, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0113 */ { UD_Ivcmpps, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0114 */ { UD_Icmpsb, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_seg },
  /* 0115 */ { UD_Icmpsw, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw|P_seg },
  /* 0116 */ { UD_Icmpsd, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw|P_seg },
  /* 0117 */ { UD_Icmpsd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0118 */ { UD_Ivcmpsd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0119 */ { UD_Icmpsq, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw|P_seg },
  /* 0120 */ { UD_Icmpss, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0121 */ { UD_Ivcmpss, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0122 */ { UD_Icmpxchg, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0123 */ { UD_Icmpxchg, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0124 */ { UD_Icmpxchg8b, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0125 */ { UD_Icmpxchg8b, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0126 */ { UD_Icmpxchg16b, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0127 */ { UD_Icomisd, O_Vsd, O_Wsd, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0128 */ { UD_Ivcomisd, O_Vsd, O_Wsd, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0129 */ { UD_Icomiss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0130 */ { UD_Ivcomiss, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0131 */ { UD_Icpuid, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0132 */ { UD_Icvtdq2pd, O_V, O_Wdq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0133 */ { UD_Ivcvtdq2pd, O_Vx, O_Wdq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0134 */ { UD_Icvtdq2ps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0135 */ { UD_Ivcvtdq2ps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0136 */ { UD_Icvtpd2dq, O_Vdq, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0137 */ { UD_Ivcvtpd2dq, O_Vdq, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0138 */ { UD_Icvtpd2pi, O_P, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0139 */ { UD_Icvtpd2ps, O_Vdq, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0140 */ { UD_Ivcvtpd2ps, O_Vdq, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0141 */ { UD_Icvtpi2ps, O_V, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0142 */ { UD_Icvtpi2pd, O_V, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0143 */ { UD_Icvtps2dq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0144 */ { UD_Ivcvtps2dq, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0145 */ { UD_Icvtps2pd, O_V, O_Wdq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0146 */ { UD_Ivcvtps2pd, O_Vx, O_Wdq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0147 */ { UD_Icvtps2pi, O_P, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0148 */ { UD_Icvtsd2si, O_Gy, O_MqU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0149 */ { UD_Ivcvtsd2si, O_Gy, O_MqU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0150 */ { UD_Icvtsd2ss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0151 */ { UD_Ivcvtsd2ss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0152 */ { UD_Icvtsi2sd, O_V, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0153 */ { UD_Ivcvtsi2sd, O_Vx, O_Hx, O_Ey, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0154 */ { UD_Icvtsi2ss, O_V, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0155 */ { UD_Ivcvtsi2ss, O_Vx, O_Hx, O_Ey, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0156 */ { UD_Icvtss2sd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0157 */ { UD_Ivcvtss2sd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0158 */ { UD_Icvtss2si, O_Gy, O_MdU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0159 */ { UD_Ivcvtss2si, O_Gy, O_MdU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0160 */ { UD_Icvttpd2dq, O_Vdq, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0161 */ { UD_Ivcvttpd2dq, O_Vdq, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0162 */ { UD_Icvttpd2pi, O_P, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0163 */ { UD_Icvttps2dq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0164 */ { UD_Ivcvttps2dq, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0165 */ { UD_Icvttps2pi, O_P, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0166 */ { UD_Icvttsd2si, O_Gy, O_MqU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0167 */ { UD_Ivcvttsd2si, O_Gy, O_MqU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0168 */ { UD_Icvttss2si, O_Gy, O_MdU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0169 */ { UD_Ivcvttss2si, O_Gy, O_MdU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0170 */ { UD_Icwd, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0171 */ { UD_Icdq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0172 */ { UD_Icqo, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0173 */ { UD_Idaa, O_NONE, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 0174 */ { UD_Idas, O_NONE, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 0175 */ { UD_Idec, O_R0z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0176 */ { UD_Idec, O_R1z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0177 */ { UD_Idec, O_R2z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0178 */ { UD_Idec, O_R3z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0179 */ { UD_Idec, O_R4z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0180 */ { UD_Idec, O_R5z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0181 */ { UD_Idec, O_R6z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0182 */ { UD_Idec, O_R7z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0183 */ { UD_Idec, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0184 */ { UD_Idec, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0185 */ { UD_Idiv, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0186 */ { UD_Idiv, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0187 */ { UD_Idivpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0188 */ { UD_Ivdivpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0189 */ { UD_Idivps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0190 */ { UD_Ivdivps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0191 */ { UD_Idivsd, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0192 */ { UD_Ivdivsd, O_Vx, O_Hx, O_MqU, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0193 */ { UD_Idivss, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0194 */ { UD_Ivdivss, O_Vx, O_Hx, O_MdU, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0195 */ { UD_Idppd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0196 */ { UD_Ivdppd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0197 */ { UD_Idpps, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0198 */ { UD_Ivdpps, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0199 */ { UD_Iemms, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0200 */ { UD_Ienter, O_Iw, O_Ib, O_NONE, O_NONE, P_def64 },
  /* 0201 */ { UD_Iextractps, O_MdRy, O_V, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0202 */ { UD_Ivextractps, O_MdRy, O_Vx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0203 */ { UD_If2xm1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0204 */ { UD_Ifabs, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0205 */ { UD_Ifadd, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0206 */ { UD_Ifadd, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0207 */ { UD_Ifadd, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0208 */ { UD_Ifadd, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0209 */ { UD_Ifadd, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0210 */ { UD_Ifadd, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0211 */ { UD_Ifadd, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0212 */ { UD_Ifadd, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0213 */ { UD_Ifadd, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0214 */ { UD_Ifadd, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0215 */ { UD_Ifadd, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0216 */ { UD_Ifadd, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0217 */ { UD_Ifadd, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0218 */ { UD_Ifadd, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0219 */ { UD_Ifadd, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0220 */ { UD_Ifadd, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0221 */ { UD_Ifadd, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0222 */ { UD_Ifadd, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0223 */ { UD_Ifaddp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0224 */ { UD_Ifaddp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0225 */ { UD_Ifaddp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0226 */ { UD_Ifaddp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0227 */ { UD_Ifaddp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0228 */ { UD_Ifaddp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0229 */ { UD_Ifaddp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0230 */ { UD_Ifaddp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0231 */ { UD_Ifbld, O_Mt, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0232 */ { UD_Ifbstp, O_Mt, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0233 */ { UD_Ifchs, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0234 */ { UD_Ifclex, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0235 */ { UD_Ifcmovb, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0236 */ { UD_Ifcmovb, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0237 */ { UD_Ifcmovb, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0238 */ { UD_Ifcmovb, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0239 */ { UD_Ifcmovb, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0240 */ { UD_Ifcmovb, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0241 */ { UD_Ifcmovb, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0242 */ { UD_Ifcmovb, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0243 */ { UD_Ifcmove, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0244 */ { UD_Ifcmove, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0245 */ { UD_Ifcmove, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0246 */ { UD_Ifcmove, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0247 */ { UD_Ifcmove, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0248 */ { UD_Ifcmove, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0249 */ { UD_Ifcmove, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0250 */ { UD_Ifcmove, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0251 */ { UD_Ifcmovbe, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0252 */ { UD_Ifcmovbe, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0253 */ { UD_Ifcmovbe, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0254 */ { UD_Ifcmovbe, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0255 */ { UD_Ifcmovbe, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0256 */ { UD_Ifcmovbe, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0257 */ { UD_Ifcmovbe, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0258 */ { UD_Ifcmovbe, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0259 */ { UD_Ifcmovu, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0260 */ { UD_Ifcmovu, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0261 */ { UD_Ifcmovu, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0262 */ { UD_Ifcmovu, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0263 */ { UD_Ifcmovu, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0264 */ { UD_Ifcmovu, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0265 */ { UD_Ifcmovu, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0266 */ { UD_Ifcmovu, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0267 */ { UD_Ifcmovnb, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0268 */ { UD_Ifcmovnb, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0269 */ { UD_Ifcmovnb, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0270 */ { UD_Ifcmovnb, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0271 */ { UD_Ifcmovnb, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0272 */ { UD_Ifcmovnb, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0273 */ { UD_Ifcmovnb, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0274 */ { UD_Ifcmovnb, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0275 */ { UD_Ifcmovne, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0276 */ { UD_Ifcmovne, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0277 */ { UD_Ifcmovne, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0278 */ { UD_Ifcmovne, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0279 */ { UD_Ifcmovne, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0280 */ { UD_Ifcmovne, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0281 */ { UD_Ifcmovne, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0282 */ { UD_Ifcmovne, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0283 */ { UD_Ifcmovnbe, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0284 */ { UD_Ifcmovnbe, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0285 */ { UD_Ifcmovnbe, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0286 */ { UD_Ifcmovnbe, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0287 */ { UD_Ifcmovnbe, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0288 */ { UD_Ifcmovnbe, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0289 */ { UD_Ifcmovnbe, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0290 */ { UD_Ifcmovnbe, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0291 */ { UD_Ifcmovnu, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0292 */ { UD_Ifcmovnu, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0293 */ { UD_Ifcmovnu, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0294 */ { UD_Ifcmovnu, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0295 */ { UD_Ifcmovnu, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0296 */ { UD_Ifcmovnu, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0297 */ { UD_Ifcmovnu, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0298 */ { UD_Ifcmovnu, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0299 */ { UD_Ifucomi, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0300 */ { UD_Ifucomi, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0301 */ { UD_Ifucomi, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0302 */ { UD_Ifucomi, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0303 */ { UD_Ifucomi, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0304 */ { UD_Ifucomi, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0305 */ { UD_Ifucomi, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0306 */ { UD_Ifucomi, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0307 */ { UD_Ifcom, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0308 */ { UD_Ifcom, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0309 */ { UD_Ifcom, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0310 */ { UD_Ifcom, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0311 */ { UD_Ifcom, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0312 */ { UD_Ifcom, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0313 */ { UD_Ifcom, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0314 */ { UD_Ifcom, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0315 */ { UD_Ifcom, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0316 */ { UD_Ifcom, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0317 */ { UD_Ifcom2, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0318 */ { UD_Ifcom2, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0319 */ { UD_Ifcom2, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0320 */ { UD_Ifcom2, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0321 */ { UD_Ifcom2, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0322 */ { UD_Ifcom2, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0323 */ { UD_Ifcom2, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0324 */ { UD_Ifcom2, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0325 */ { UD_Ifcomp3, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0326 */ { UD_Ifcomp3, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0327 */ { UD_Ifcomp3, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0328 */ { UD_Ifcomp3, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0329 */ { UD_Ifcomp3, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0330 */ { UD_Ifcomp3, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0331 */ { UD_Ifcomp3, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0332 */ { UD_Ifcomp3, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0333 */ { UD_Ifcomi, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0334 */ { UD_Ifcomi, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0335 */ { UD_Ifcomi, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0336 */ { UD_Ifcomi, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0337 */ { UD_Ifcomi, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0338 */ { UD_Ifcomi, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0339 */ { UD_Ifcomi, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0340 */ { UD_Ifcomi, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0341 */ { UD_Ifucomip, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0342 */ { UD_Ifucomip, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0343 */ { UD_Ifucomip, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0344 */ { UD_Ifucomip, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0345 */ { UD_Ifucomip, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0346 */ { UD_Ifucomip, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0347 */ { UD_Ifucomip, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0348 */ { UD_Ifucomip, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0349 */ { UD_Ifcomip, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0350 */ { UD_Ifcomip, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0351 */ { UD_Ifcomip, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0352 */ { UD_Ifcomip, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0353 */ { UD_Ifcomip, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0354 */ { UD_Ifcomip, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0355 */ { UD_Ifcomip, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0356 */ { UD_Ifcomip, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0357 */ { UD_Ifcomp, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0358 */ { UD_Ifcomp, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0359 */ { UD_Ifcomp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0360 */ { UD_Ifcomp, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0361 */ { UD_Ifcomp, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0362 */ { UD_Ifcomp, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0363 */ { UD_Ifcomp, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0364 */ { UD_Ifcomp, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0365 */ { UD_Ifcomp, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0366 */ { UD_Ifcomp, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0367 */ { UD_Ifcomp5, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0368 */ { UD_Ifcomp5, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0369 */ { UD_Ifcomp5, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0370 */ { UD_Ifcomp5, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0371 */ { UD_Ifcomp5, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0372 */ { UD_Ifcomp5, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0373 */ { UD_Ifcomp5, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0374 */ { UD_Ifcomp5, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0375 */ { UD_Ifcompp, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0376 */ { UD_Ifcos, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0377 */ { UD_Ifdecstp, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0378 */ { UD_Ifdiv, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0379 */ { UD_Ifdiv, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0380 */ { UD_Ifdiv, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0381 */ { UD_Ifdiv, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0382 */ { UD_Ifdiv, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0383 */ { UD_Ifdiv, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0384 */ { UD_Ifdiv, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0385 */ { UD_Ifdiv, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0386 */ { UD_Ifdiv, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0387 */ { UD_Ifdiv, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0388 */ { UD_Ifdiv, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0389 */ { UD_Ifdiv, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0390 */ { UD_Ifdiv, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0391 */ { UD_Ifdiv, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0392 */ { UD_Ifdiv, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0393 */ { UD_Ifdiv, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0394 */ { UD_Ifdiv, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0395 */ { UD_Ifdiv, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0396 */ { UD_Ifdivp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0397 */ { UD_Ifdivp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0398 */ { UD_Ifdivp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0399 */ { UD_Ifdivp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0400 */ { UD_Ifdivp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0401 */ { UD_Ifdivp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0402 */ { UD_Ifdivp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0403 */ { UD_Ifdivp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0404 */ { UD_Ifdivr, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0405 */ { UD_Ifdivr, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0406 */ { UD_Ifdivr, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0407 */ { UD_Ifdivr, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0408 */ { UD_Ifdivr, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0409 */ { UD_Ifdivr, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0410 */ { UD_Ifdivr, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0411 */ { UD_Ifdivr, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0412 */ { UD_Ifdivr, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0413 */ { UD_Ifdivr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0414 */ { UD_Ifdivr, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0415 */ { UD_Ifdivr, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0416 */ { UD_Ifdivr, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0417 */ { UD_Ifdivr, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0418 */ { UD_Ifdivr, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0419 */ { UD_Ifdivr, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0420 */ { UD_Ifdivr, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0421 */ { UD_Ifdivr, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0422 */ { UD_Ifdivrp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0423 */ { UD_Ifdivrp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0424 */ { UD_Ifdivrp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0425 */ { UD_Ifdivrp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0426 */ { UD_Ifdivrp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0427 */ { UD_Ifdivrp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0428 */ { UD_Ifdivrp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0429 */ { UD_Ifdivrp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0430 */ { UD_Ifemms, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0431 */ { UD_Iffree, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0432 */ { UD_Iffree, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0433 */ { UD_Iffree, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0434 */ { UD_Iffree, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0435 */ { UD_Iffree, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0436 */ { UD_Iffree, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0437 */ { UD_Iffree, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0438 */ { UD_Iffree, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0439 */ { UD_Iffreep, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0440 */ { UD_Iffreep, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0441 */ { UD_Iffreep, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0442 */ { UD_Iffreep, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0443 */ { UD_Iffreep, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0444 */ { UD_Iffreep, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0445 */ { UD_Iffreep, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0446 */ { UD_Iffreep, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0447 */ { UD_Ificom, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0448 */ { UD_Ificom, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0449 */ { UD_Ificomp, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0450 */ { UD_Ificomp, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0451 */ { UD_Ifild, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0452 */ { UD_Ifild, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0453 */ { UD_Ifild, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0454 */ { UD_Ifincstp, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0455 */ { UD_Ifninit, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0456 */ { UD_Ifiadd, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0457 */ { UD_Ifiadd, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0458 */ { UD_Ifidivr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0459 */ { UD_Ifidivr, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0460 */ { UD_Ifidiv, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0461 */ { UD_Ifidiv, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0462 */ { UD_Ifisub, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0463 */ { UD_Ifisub, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0464 */ { UD_Ifisubr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0465 */ { UD_Ifisubr, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0466 */ { UD_Ifist, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0467 */ { UD_Ifist, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0468 */ { UD_Ifistp, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0469 */ { UD_Ifistp, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0470 */ { UD_Ifistp, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0471 */ { UD_Ifisttp, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0472 */ { UD_Ifisttp, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0473 */ { UD_Ifisttp, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0474 */ { UD_Ifld, O_Mt, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0475 */ { UD_Ifld, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0476 */ { UD_Ifld, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0477 */ { UD_Ifld, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0478 */ { UD_Ifld, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0479 */ { UD_Ifld, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0480 */ { UD_Ifld, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0481 */ { UD_Ifld, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0482 */ { UD_Ifld, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0483 */ { UD_Ifld, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0484 */ { UD_Ifld, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0485 */ { UD_Ifld1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0486 */ { UD_Ifldl2t, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0487 */ { UD_Ifldl2e, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0488 */ { UD_Ifldpi, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0489 */ { UD_Ifldlg2, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0490 */ { UD_Ifldln2, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0491 */ { UD_Ifldz, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0492 */ { UD_Ifldcw, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0493 */ { UD_Ifldenv, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0494 */ { UD_Ifmul, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0495 */ { UD_Ifmul, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0496 */ { UD_Ifmul, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0497 */ { UD_Ifmul, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0498 */ { UD_Ifmul, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0499 */ { UD_Ifmul, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0500 */ { UD_Ifmul, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0501 */ { UD_Ifmul, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0502 */ { UD_Ifmul, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0503 */ { UD_Ifmul, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0504 */ { UD_Ifmul, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0505 */ { UD_Ifmul, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0506 */ { UD_Ifmul, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0507 */ { UD_Ifmul, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0508 */ { UD_Ifmul, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0509 */ { UD_Ifmul, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0510 */ { UD_Ifmul, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0511 */ { UD_Ifmul, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0512 */ { UD_Ifmulp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0513 */ { UD_Ifmulp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0514 */ { UD_Ifmulp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0515 */ { UD_Ifmulp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0516 */ { UD_Ifmulp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0517 */ { UD_Ifmulp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0518 */ { UD_Ifmulp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0519 */ { UD_Ifmulp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0520 */ { UD_Ifimul, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0521 */ { UD_Ifimul, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0522 */ { UD_Ifnop, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0523 */ { UD_Ifndisi, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0524 */ { UD_Ifneni, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0525 */ { UD_Ifnsetpm, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0526 */ { UD_Ifpatan, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0527 */ { UD_Ifprem, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0528 */ { UD_Ifprem1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0529 */ { UD_Ifptan, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0530 */ { UD_Ifrndint, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0531 */ { UD_Ifrstor, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0532 */ { UD_Ifrstpm, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0533 */ { UD_Ifnsave, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0534 */ { UD_Ifscale, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0535 */ { UD_Ifsin, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0536 */ { UD_Ifsincos, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0537 */ { UD_Ifsqrt, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0538 */ { UD_Ifstp, O_Mt, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0539 */ { UD_Ifstp, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0540 */ { UD_Ifstp, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0541 */ { UD_Ifstp, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0542 */ { UD_Ifstp, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0543 */ { UD_Ifstp, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0544 */ { UD_Ifstp, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0545 */ { UD_Ifstp, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0546 */ { UD_Ifstp, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0547 */ { UD_Ifstp, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0548 */ { UD_Ifstp, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0549 */ { UD_Ifstp1, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0550 */ { UD_Ifstp1, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0551 */ { UD_Ifstp1, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0552 */ { UD_Ifstp1, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0553 */ { UD_Ifstp1, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0554 */ { UD_Ifstp1, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0555 */ { UD_Ifstp1, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0556 */ { UD_Ifstp1, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0557 */ { UD_Ifstp8, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0558 */ { UD_Ifstp8, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0559 */ { UD_Ifstp8, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0560 */ { UD_Ifstp8, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0561 */ { UD_Ifstp8, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0562 */ { UD_Ifstp8, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0563 */ { UD_Ifstp8, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0564 */ { UD_Ifstp8, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0565 */ { UD_Ifstp9, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0566 */ { UD_Ifstp9, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0567 */ { UD_Ifstp9, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0568 */ { UD_Ifstp9, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0569 */ { UD_Ifstp9, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0570 */ { UD_Ifstp9, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0571 */ { UD_Ifstp9, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0572 */ { UD_Ifstp9, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0573 */ { UD_Ifst, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0574 */ { UD_Ifst, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0575 */ { UD_Ifst, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0576 */ { UD_Ifst, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0577 */ { UD_Ifst, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0578 */ { UD_Ifst, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0579 */ { UD_Ifst, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0580 */ { UD_Ifst, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0581 */ { UD_Ifst, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0582 */ { UD_Ifst, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0583 */ { UD_Ifnstcw, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0584 */ { UD_Ifnstenv, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0585 */ { UD_Ifnstsw, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0586 */ { UD_Ifnstsw, O_AX, O_NONE, O_NONE, O_NONE, P_none },
  /* 0587 */ { UD_Ifsub, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0588 */ { UD_Ifsub, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0589 */ { UD_Ifsub, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0590 */ { UD_Ifsub, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0591 */ { UD_Ifsub, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0592 */ { UD_Ifsub, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0593 */ { UD_Ifsub, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0594 */ { UD_Ifsub, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0595 */ { UD_Ifsub, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0596 */ { UD_Ifsub, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0597 */ { UD_Ifsub, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0598 */ { UD_Ifsub, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0599 */ { UD_Ifsub, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0600 */ { UD_Ifsub, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0601 */ { UD_Ifsub, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0602 */ { UD_Ifsub, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0603 */ { UD_Ifsub, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0604 */ { UD_Ifsub, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0605 */ { UD_Ifsubp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0606 */ { UD_Ifsubp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0607 */ { UD_Ifsubp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0608 */ { UD_Ifsubp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0609 */ { UD_Ifsubp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0610 */ { UD_Ifsubp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0611 */ { UD_Ifsubp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0612 */ { UD_Ifsubp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0613 */ { UD_Ifsubr, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0614 */ { UD_Ifsubr, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0615 */ { UD_Ifsubr, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0616 */ { UD_Ifsubr, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0617 */ { UD_Ifsubr, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0618 */ { UD_Ifsubr, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0619 */ { UD_Ifsubr, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0620 */ { UD_Ifsubr, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0621 */ { UD_Ifsubr, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0622 */ { UD_Ifsubr, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0623 */ { UD_Ifsubr, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0624 */ { UD_Ifsubr, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0625 */ { UD_Ifsubr, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0626 */ { UD_Ifsubr, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0627 */ { UD_Ifsubr, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0628 */ { UD_Ifsubr, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0629 */ { UD_Ifsubr, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0630 */ { UD_Ifsubr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0631 */ { UD_Ifsubrp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0632 */ { UD_Ifsubrp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0633 */ { UD_Ifsubrp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0634 */ { UD_Ifsubrp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0635 */ { UD_Ifsubrp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0636 */ { UD_Ifsubrp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0637 */ { UD_Ifsubrp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0638 */ { UD_Ifsubrp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0639 */ { UD_Iftst, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0640 */ { UD_Ifucom, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0641 */ { UD_Ifucom, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0642 */ { UD_Ifucom, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0643 */ { UD_Ifucom, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0644 */ { UD_Ifucom, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0645 */ { UD_Ifucom, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0646 */ { UD_Ifucom, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0647 */ { UD_Ifucom, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0648 */ { UD_Ifucomp, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0649 */ { UD_Ifucomp, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0650 */ { UD_Ifucomp, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0651 */ { UD_Ifucomp, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0652 */ { UD_Ifucomp, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0653 */ { UD_Ifucomp, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0654 */ { UD_Ifucomp, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0655 */ { UD_Ifucomp, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0656 */ { UD_Ifucompp, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0657 */ { UD_Ifxam, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0658 */ { UD_Ifxch, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0659 */ { UD_Ifxch, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0660 */ { UD_Ifxch, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0661 */ { UD_Ifxch, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0662 */ { UD_Ifxch, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0663 */ { UD_Ifxch, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0664 */ { UD_Ifxch, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0665 */ { UD_Ifxch, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0666 */ { UD_Ifxch4, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0667 */ { UD_Ifxch4, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0668 */ { UD_Ifxch4, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0669 */ { UD_Ifxch4, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0670 */ { UD_Ifxch4, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0671 */ { UD_Ifxch4, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0672 */ { UD_Ifxch4, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0673 */ { UD_Ifxch4, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0674 */ { UD_Ifxch7, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0675 */ { UD_Ifxch7, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0676 */ { UD_Ifxch7, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0677 */ { UD_Ifxch7, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0678 */ { UD_Ifxch7, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0679 */ { UD_Ifxch7, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0680 */ { UD_Ifxch7, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0681 */ { UD_Ifxch7, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0682 */ { UD_Ifxrstor, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0683 */ { UD_Ifxsave, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0684 */ { UD_Ifxtract, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0685 */ { UD_Ifyl2x, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0686 */ { UD_Ifyl2xp1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0687 */ { UD_Ihlt, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0688 */ { UD_Iidiv, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0689 */ { UD_Iidiv, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0690 */ { UD_Iin, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0691 */ { UD_Iin, O_eAX, O_Ib, O_NONE, O_NONE, P_oso },
  /* 0692 */ { UD_Iin, O_AL, O_DX, O_NONE, O_NONE, P_none },
  /* 0693 */ { UD_Iin, O_eAX, O_DX, O_NONE, O_NONE, P_oso },
  /* 0694 */ { UD_Iimul, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0695 */ { UD_Iimul, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0696 */ { UD_Iimul, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0697 */ { UD_Iimul, O_Gv, O_Ev, O_Iz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0698 */ { UD_Iimul, O_Gv, O_Ev, O_sIb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0699 */ { UD_Iinc, O_R0z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0700 */ { UD_Iinc, O_R1z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0701 */ { UD_Iinc, O_R2z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0702 */ { UD_Iinc, O_R3z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0703 */ { UD_Iinc, O_R4z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0704 */ { UD_Iinc, O_R5z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0705 */ { UD_Iinc, O_R6z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0706 */ { UD_Iinc, O_R7z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0707 */ { UD_Iinc, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0708 */ { UD_Iinc, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0709 */ { UD_Iinsb, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0710 */ { UD_Iinsw, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0711 */ { UD_Iinsd, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0712 */ { UD_Iint1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0713 */ { UD_Iint3, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0714 */ { UD_Iint, O_Ib, O_NONE, O_NONE, O_NONE, P_none },
  /* 0715 */ { UD_Iinto, O_NONE, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 0716 */ { UD_Iinvd, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0717 */ { UD_Iinvept, O_Gd, O_Mo, O_NONE, O_NONE, P_none },
  /* 0718 */ { UD_Iinvept, O_Gq, O_Mo, O_NONE, O_NONE, P_none },
  /* 0719 */ { UD_Iinvlpg, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0720 */ { UD_Iinvlpga, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0721 */ { UD_Iinvvpid, O_Gd, O_Mo, O_NONE, O_NONE, P_none },
  /* 0722 */ { UD_Iinvvpid, O_Gq, O_Mo, O_NONE, O_NONE, P_none },
  /* 0723 */ { UD_Iiretw, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0724 */ { UD_Iiretd, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0725 */ { UD_Iiretq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0726 */ { UD_Ijo, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0727 */ { UD_Ijo, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0728 */ { UD_Ijno, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0729 */ { UD_Ijno, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0730 */ { UD_Ijb, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0731 */ { UD_Ijb, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0732 */ { UD_Ijae, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0733 */ { UD_Ijae, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0734 */ { UD_Ijz, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0735 */ { UD_Ijz, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0736 */ { UD_Ijnz, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0737 */ { UD_Ijnz, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0738 */ { UD_Ijbe, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0739 */ { UD_Ijbe, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0740 */ { UD_Ija, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0741 */ { UD_Ija, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0742 */ { UD_Ijs, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0743 */ { UD_Ijs, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0744 */ { UD_Ijns, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0745 */ { UD_Ijns, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0746 */ { UD_Ijp, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0747 */ { UD_Ijp, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0748 */ { UD_Ijnp, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0749 */ { UD_Ijnp, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0750 */ { UD_Ijl, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0751 */ { UD_Ijl, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0752 */ { UD_Ijge, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0753 */ { UD_Ijge, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0754 */ { UD_Ijle, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0755 */ { UD_Ijle, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0756 */ { UD_Ijg, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0757 */ { UD_Ijg, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0758 */ { UD_Ijcxz, O_Jb, O_NONE, O_NONE, O_NONE, P_aso },
  /* 0759 */ { UD_Ijecxz, O_Jb, O_NONE, O_NONE, O_NONE, P_aso },
  /* 0760 */ { UD_Ijrcxz, O_Jb, O_NONE, O_NONE, O_NONE, P_aso },
  /* 0761 */ { UD_Ijmp, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 0762 */ { UD_Ijmp, O_Fv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0763 */ { UD_Ijmp, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0764 */ { UD_Ijmp, O_Av, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0765 */ { UD_Ijmp, O_Jb, O_NONE, O_NONE, O_NONE, P_def64 },
  /* 0766 */ { UD_Ilahf, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0767 */ { UD_Ilar, O_Gv, O_Ew, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0768 */ { UD_Ildmxcsr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0769 */ { UD_Ilds, O_Gv, O_M, O_NONE, O_NONE, P_aso|P_oso },
  /* 0770 */ { UD_Ilea, O_Gv, O_M, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0771 */ { UD_Iles, O_Gv, O_M, O_NONE, O_NONE, P_aso|P_oso },
  /* 0772 */ { UD_Ilfs, O_Gz, O_M, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0773 */ { UD_Ilgs, O_Gz, O_M, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0774 */ { UD_Ilidt, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0775 */ { UD_Ilss, O_Gv, O_M, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0776 */ { UD_Ileave, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0777 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0778 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0779 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0780 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0781 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0782 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0783 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0784 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0785 */ { UD_Ilgdt, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0786 */ { UD_Illdt, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0787 */ { UD_Ilmsw, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0788 */ { UD_Ilmsw, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0789 */ { UD_Ilock, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0790 */ { UD_Ilodsb, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0791 */ { UD_Ilodsw, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0792 */ { UD_Ilodsd, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0793 */ { UD_Ilodsq, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0794 */ { UD_Iloopne, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0795 */ { UD_Iloope, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0796 */ { UD_Iloop, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0797 */ { UD_Ilsl, O_Gv, O_Ew, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0798 */ { UD_Iltr, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0799 */ { UD_Imaskmovq, O_P, O_N, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0800 */ { UD_Imaxpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0801 */ { UD_Ivmaxpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0802 */ { UD_Imaxps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0803 */ { UD_Ivmaxps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0804 */ { UD_Imaxsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0805 */ { UD_Ivmaxsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0806 */ { UD_Imaxss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0807 */ { UD_Ivmaxss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0808 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0809 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0810 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0811 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0812 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0813 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0814 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0815 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0816 */ { UD_Iminpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0817 */ { UD_Ivminpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0818 */ { UD_Iminps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0819 */ { UD_Ivminps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0820 */ { UD_Iminsd, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0821 */ { UD_Ivminsd, O_Vx, O_Hx, O_MqU, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0822 */ { UD_Iminss, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0823 */ { UD_Ivminss, O_Vx, O_Hx, O_MdU, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0824 */ { UD_Imonitor, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0825 */ { UD_Imontmul, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0826 */ { UD_Imov, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0827 */ { UD_Imov, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0828 */ { UD_Imov, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0829 */ { UD_Imov, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0830 */ { UD_Imov, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0831 */ { UD_Imov, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0832 */ { UD_Imov, O_MwRv, O_S, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0833 */ { UD_Imov, O_S, O_MwRv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0834 */ { UD_Imov, O_AL, O_Ob, O_NONE, O_NONE, P_none },
  /* 0835 */ { UD_Imov, O_rAX, O_Ov, O_NONE, O_NONE, P_aso|P_oso|P_rexw },
  /* 0836 */ { UD_Imov, O_Ob, O_AL, O_NONE, O_NONE, P_none },
  /* 0837 */ { UD_Imov, O_Ov, O_rAX, O_NONE, O_NONE, P_aso|P_oso|P_rexw },
  /* 0838 */ { UD_Imov, O_R0b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0839 */ { UD_Imov, O_R1b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0840 */ { UD_Imov, O_R2b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0841 */ { UD_Imov, O_R3b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0842 */ { UD_Imov, O_R4b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0843 */ { UD_Imov, O_R5b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0844 */ { UD_Imov, O_R6b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0845 */ { UD_Imov, O_R7b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0846 */ { UD_Imov, O_R0v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0847 */ { UD_Imov, O_R1v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0848 */ { UD_Imov, O_R2v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0849 */ { UD_Imov, O_R3v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0850 */ { UD_Imov, O_R4v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0851 */ { UD_Imov, O_R5v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0852 */ { UD_Imov, O_R6v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0853 */ { UD_Imov, O_R7v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0854 */ { UD_Imov, O_R, O_C, O_NONE, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0855 */ { UD_Imov, O_R, O_D, O_NONE, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0856 */ { UD_Imov, O_C, O_R, O_NONE, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0857 */ { UD_Imov, O_D, O_R, O_NONE, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0858 */ { UD_Imovapd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0859 */ { UD_Ivmovapd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0860 */ { UD_Imovapd, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0861 */ { UD_Ivmovapd, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0862 */ { UD_Imovaps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0863 */ { UD_Ivmovaps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0864 */ { UD_Imovaps, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0865 */ { UD_Ivmovaps, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0866 */ { UD_Imovd, O_P, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0867 */ { UD_Imovd, O_P, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0868 */ { UD_Imovd, O_V, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0869 */ { UD_Ivmovd, O_Vx, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0870 */ { UD_Imovd, O_V, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0871 */ { UD_Ivmovd, O_Vx, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0872 */ { UD_Imovd, O_Ey, O_P, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0873 */ { UD_Imovd, O_Ey, O_P, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0874 */ { UD_Imovd, O_Ey, O_V, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0875 */ { UD_Ivmovd, O_Ey, O_Vx, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0876 */ { UD_Imovd, O_Ey, O_V, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0877 */ { UD_Ivmovd, O_Ey, O_Vx, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0878 */ { UD_Imovhpd, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0879 */ { UD_Ivmovhpd, O_Vx, O_Hx, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0880 */ { UD_Imovhpd, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0881 */ { UD_Ivmovhpd, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0882 */ { UD_Imovhps, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0883 */ { UD_Ivmovhps, O_Vx, O_Hx, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0884 */ { UD_Imovhps, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0885 */ { UD_Ivmovhps, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0886 */ { UD_Imovlhps, O_V, O_U, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0887 */ { UD_Ivmovlhps, O_Vx, O_Hx, O_Ux, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0888 */ { UD_Imovlpd, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0889 */ { UD_Ivmovlpd, O_Vx, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0890 */ { UD_Imovlpd, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0891 */ { UD_Ivmovlpd, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0892 */ { UD_Imovlps, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0893 */ { UD_Ivmovlps, O_Vx, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0894 */ { UD_Imovlps, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0895 */ { UD_Ivmovlps, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0896 */ { UD_Imovhlps, O_V, O_U, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0897 */ { UD_Ivmovhlps, O_Vx, O_Ux, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0898 */ { UD_Imovmskpd, O_Gd, O_U, O_NONE, O_NONE, P_oso|P_rexr|P_rexb },
  /* 0899 */ { UD_Ivmovmskpd, O_Gd, O_Ux, O_NONE, O_NONE, P_oso|P_rexr|P_rexb|P_vexl },
  /* 0900 */ { UD_Imovmskps, O_Gd, O_U, O_NONE, O_NONE, P_oso|P_rexr|P_rexb },
  /* 0901 */ { UD_Ivmovmskps, O_Gd, O_Ux, O_NONE, O_NONE, P_oso|P_rexr|P_rexb },
  /* 0902 */ { UD_Imovntdq, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0903 */ { UD_Ivmovntdq, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0904 */ { UD_Imovnti, O_M, O_Gy, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0905 */ { UD_Imovntpd, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0906 */ { UD_Ivmovntpd, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0907 */ { UD_Imovntps, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0908 */ { UD_Ivmovntps, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0909 */ { UD_Imovntq, O_M, O_P, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0910 */ { UD_Imovq, O_P, O_Eq, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0911 */ { UD_Imovq, O_V, O_Eq, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0912 */ { UD_Ivmovq, O_Vx, O_Eq, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0913 */ { UD_Imovq, O_Eq, O_P, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0914 */ { UD_Imovq, O_Eq, O_V, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0915 */ { UD_Ivmovq, O_Eq, O_Vx, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0916 */ { UD_Imovq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0917 */ { UD_Ivmovq, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0918 */ { UD_Imovq, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0919 */ { UD_Ivmovq, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0920 */ { UD_Imovq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0921 */ { UD_Imovq, O_Q, O_P, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0922 */ { UD_Imovsb, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0923 */ { UD_Imovsw, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0924 */ { UD_Imovsd, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0925 */ { UD_Imovsd, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0926 */ { UD_Imovsd, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0927 */ { UD_Imovsq, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0928 */ { UD_Imovss, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0929 */ { UD_Imovss, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0930 */ { UD_Imovsx, O_Gv, O_Eb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0931 */ { UD_Imovsx, O_Gy, O_Ew, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0932 */ { UD_Imovupd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0933 */ { UD_Ivmovupd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0934 */ { UD_Imovupd, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0935 */ { UD_Ivmovupd, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0936 */ { UD_Imovups, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0937 */ { UD_Ivmovups, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0938 */ { UD_Imovups, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0939 */ { UD_Ivmovups, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0940 */ { UD_Imovzx, O_Gv, O_Eb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0941 */ { UD_Imovzx, O_Gy, O_Ew, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0942 */ { UD_Imul, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0943 */ { UD_Imul, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0944 */ { UD_Imulpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0945 */ { UD_Ivmulpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0946 */ { UD_Imulps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0947 */ { UD_Ivmulps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0948 */ { UD_Imulsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0949 */ { UD_Ivmulsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0950 */ { UD_Imulss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0951 */ { UD_Ivmulss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0952 */ { UD_Imwait, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0953 */ { UD_Ineg, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0954 */ { UD_Ineg, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0955 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0956 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0957 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0958 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0959 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0960 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0961 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0962 */ { UD_Inot, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0963 */ { UD_Inot, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0964 */ { UD_Ior, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0965 */ { UD_Ior, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0966 */ { UD_Ior, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0967 */ { UD_Ior, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0968 */ { UD_Ior, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0969 */ { UD_Ior, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0970 */ { UD_Ior, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0971 */ { UD_Ior, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0972 */ { UD_Ior, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0973 */ { UD_Ior, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0974 */ { UD_Iorpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0975 */ { UD_Ivorpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0976 */ { UD_Iorps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0977 */ { UD_Ivorps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0978 */ { UD_Iout, O_Ib, O_AL, O_NONE, O_NONE, P_none },
  /* 0979 */ { UD_Iout, O_Ib, O_eAX, O_NONE, O_NONE, P_oso },
  /* 0980 */ { UD_Iout, O_DX, O_AL, O_NONE, O_NONE, P_none },
  /* 0981 */ { UD_Iout, O_DX, O_eAX, O_NONE, O_NONE, P_oso },
  /* 0982 */ { UD_Ioutsb, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0983 */ { UD_Ioutsw, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0984 */ { UD_Ioutsd, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0985 */ { UD_Ipacksswb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0986 */ { UD_Ivpacksswb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0987 */ { UD_Ipacksswb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0988 */ { UD_Ipackssdw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0989 */ { UD_Ivpackssdw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0990 */ { UD_Ipackssdw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0991 */ { UD_Ipackuswb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0992 */ { UD_Ivpackuswb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0993 */ { UD_Ipackuswb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0994 */ { UD_Ipaddb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0995 */ { UD_Ivpaddb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0996 */ { UD_Ipaddb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0997 */ { UD_Ipaddw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0998 */ { UD_Ipaddw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0999 */ { UD_Ivpaddw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1000 */ { UD_Ipaddd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1001 */ { UD_Ipaddd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1002 */ { UD_Ivpaddd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1003 */ { UD_Ipaddsb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1004 */ { UD_Ipaddsb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1005 */ { UD_Ivpaddsb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1006 */ { UD_Ipaddsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1007 */ { UD_Ipaddsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1008 */ { UD_Ivpaddsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1009 */ { UD_Ipaddusb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1010 */ { UD_Ipaddusb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1011 */ { UD_Ivpaddusb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1012 */ { UD_Ipaddusw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1013 */ { UD_Ipaddusw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1014 */ { UD_Ivpaddusw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1015 */ { UD_Ipand, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1016 */ { UD_Ivpand, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1017 */ { UD_Ipand, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1018 */ { UD_Ipandn, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1019 */ { UD_Ivpandn, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1020 */ { UD_Ipandn, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1021 */ { UD_Ipavgb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1022 */ { UD_Ivpavgb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1023 */ { UD_Ipavgb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1024 */ { UD_Ipavgw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1025 */ { UD_Ivpavgw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1026 */ { UD_Ipavgw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1027 */ { UD_Ipcmpeqb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1028 */ { UD_Ipcmpeqb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1029 */ { UD_Ivpcmpeqb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1030 */ { UD_Ipcmpeqw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1031 */ { UD_Ipcmpeqw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1032 */ { UD_Ivpcmpeqw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1033 */ { UD_Ipcmpeqd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1034 */ { UD_Ipcmpeqd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1035 */ { UD_Ivpcmpeqd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1036 */ { UD_Ipcmpgtb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1037 */ { UD_Ivpcmpgtb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1038 */ { UD_Ipcmpgtb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1039 */ { UD_Ipcmpgtw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1040 */ { UD_Ivpcmpgtw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1041 */ { UD_Ipcmpgtw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1042 */ { UD_Ipcmpgtd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1043 */ { UD_Ivpcmpgtd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1044 */ { UD_Ipcmpgtd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1045 */ { UD_Ipextrb, O_MbRv, O_V, O_Ib, O_NONE, P_aso|P_rexx|P_rexr|P_rexb|P_def64 },
  /* 1046 */ { UD_Ivpextrb, O_MbRv, O_Vx, O_Ib, O_NONE, P_aso|P_rexx|P_rexr|P_rexb|P_def64 },
  /* 1047 */ { UD_Ipextrd, O_Ed, O_V, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexw|P_rexb },
  /* 1048 */ { UD_Ivpextrd, O_Ed, O_Vx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexw|P_rexb },
  /* 1049 */ { UD_Ipextrd, O_Ed, O_V, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexw|P_rexb },
  /* 1050 */ { UD_Ivpextrd, O_Ed, O_Vx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexw|P_rexb },
  /* 1051 */ { UD_Ipextrq, O_Eq, O_V, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexb|P_def64 },
  /* 1052 */ { UD_Ivpextrq, O_Eq, O_Vx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexb|P_def64 },
  /* 1053 */ { UD_Ipextrw, O_Gd, O_U, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexb },
  /* 1054 */ { UD_Ivpextrw, O_Gd, O_Ux, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexb },
  /* 1055 */ { UD_Ipextrw, O_Gd, O_N, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1056 */ { UD_Ipextrw, O_MwRd, O_V, O_Ib, O_NONE, P_aso|P_rexw|P_rexx|P_rexr|P_rexb },
  /* 1057 */ { UD_Ivpextrw, O_MwRd, O_Vx, O_Ib, O_NONE, P_aso|P_rexw|P_rexx|P_rexr|P_rexb },
  /* 1058 */ { UD_Ipinsrb, O_V, O_MbRd, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1059 */ { UD_Ipinsrw, O_P, O_MwRy, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1060 */ { UD_Ipinsrw, O_V, O_MwRy, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1061 */ { UD_Ivpinsrw, O_Vx, O_MwRy, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1062 */ { UD_Ipinsrd, O_V, O_Ed, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1063 */ { UD_Ipinsrd, O_V, O_Ed, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1064 */ { UD_Ipinsrq, O_V, O_Eq, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1065 */ { UD_Ivpinsrb, O_V, O_H, O_MbRd, O_Ib, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1066 */ { UD_Ivpinsrd, O_V, O_H, O_Ed, O_Ib, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1067 */ { UD_Ivpinsrd, O_V, O_H, O_Ed, O_Ib, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1068 */ { UD_Ivpinsrq, O_V, O_H, O_Eq, O_Ib, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1069 */ { UD_Ipmaddwd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1070 */ { UD_Ipmaddwd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1071 */ { UD_Ivpmaddwd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1072 */ { UD_Ipmaxsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1073 */ { UD_Ivpmaxsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1074 */ { UD_Ipmaxsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1075 */ { UD_Ipmaxub, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1076 */ { UD_Ipmaxub, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1077 */ { UD_Ivpmaxub, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1078 */ { UD_Ipminsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1079 */ { UD_Ivpminsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1080 */ { UD_Ipminsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1081 */ { UD_Ipminub, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1082 */ { UD_Ivpminub, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1083 */ { UD_Ipminub, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1084 */ { UD_Ipmovmskb, O_Gd, O_U, O_NONE, O_NONE, P_oso|P_rexr|P_rexw|P_rexb },
  /* 1085 */ { UD_Ivpmovmskb, O_Gd, O_Ux, O_NONE, O_NONE, P_oso|P_rexr|P_rexw|P_rexb },
  /* 1086 */ { UD_Ipmovmskb, O_Gd, O_N, O_NONE, O_NONE, P_oso|P_rexr|P_rexw|P_rexb },
  /* 1087 */ { UD_Ipmulhuw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1088 */ { UD_Ipmulhuw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1089 */ { UD_Ivpmulhuw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1090 */ { UD_Ipmulhw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1091 */ { UD_Ivpmulhw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1092 */ { UD_Ipmulhw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1093 */ { UD_Ipmullw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1094 */ { UD_Ipmullw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1095 */ { UD_Ivpmullw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1096 */ { UD_Ipop, O_ES, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1097 */ { UD_Ipop, O_SS, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1098 */ { UD_Ipop, O_DS, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1099 */ { UD_Ipop, O_GS, O_NONE, O_NONE, O_NONE, P_none },
  /* 1100 */ { UD_Ipop, O_FS, O_NONE, O_NONE, O_NONE, P_none },
  /* 1101 */ { UD_Ipop, O_R0v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1102 */ { UD_Ipop, O_R1v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1103 */ { UD_Ipop, O_R2v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1104 */ { UD_Ipop, O_R3v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1105 */ { UD_Ipop, O_R4v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1106 */ { UD_Ipop, O_R5v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1107 */ { UD_Ipop, O_R6v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1108 */ { UD_Ipop, O_R7v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1109 */ { UD_Ipop, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1110 */ { UD_Ipopa, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 1111 */ { UD_Ipopad, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 1112 */ { UD_Ipopfw, O_NONE, O_NONE, O_NONE, O_NONE, P_oso },
  /* 1113 */ { UD_Ipopfd, O_NONE, O_NONE, O_NONE, O_NONE, P_oso },
  /* 1114 */ { UD_Ipopfq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 1115 */ { UD_Ipopfq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 1116 */ { UD_Ipor, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1117 */ { UD_Ivpor, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1118 */ { UD_Ipor, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1119 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1120 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1121 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1122 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1123 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1124 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1125 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1126 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1127 */ { UD_Iprefetchnta, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1128 */ { UD_Iprefetcht0, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1129 */ { UD_Iprefetcht1, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1130 */ { UD_Iprefetcht2, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1131 */ { UD_Ipsadbw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1132 */ { UD_Ivpsadbw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1133 */ { UD_Ipsadbw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1134 */ { UD_Ipshufw, O_P, O_Q, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1135 */ { UD_Ipsllw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1136 */ { UD_Ipsllw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1137 */ { UD_Ipsllw, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1138 */ { UD_Ipsllw, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1139 */ { UD_Ipslld, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1140 */ { UD_Ipslld, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1141 */ { UD_Ipslld, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1142 */ { UD_Ipslld, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1143 */ { UD_Ipsllq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1144 */ { UD_Ipsllq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1145 */ { UD_Ipsllq, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1146 */ { UD_Ipsllq, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1147 */ { UD_Ipsraw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1148 */ { UD_Ipsraw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1149 */ { UD_Ivpsraw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1150 */ { UD_Ipsraw, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1151 */ { UD_Ivpsraw, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1152 */ { UD_Ipsraw, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1153 */ { UD_Ipsrad, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1154 */ { UD_Ipsrad, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1155 */ { UD_Ivpsrad, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1156 */ { UD_Ipsrad, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1157 */ { UD_Ipsrad, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1158 */ { UD_Ivpsrad, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1159 */ { UD_Ipsrlw, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1160 */ { UD_Ipsrlw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1161 */ { UD_Ipsrlw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1162 */ { UD_Ivpsrlw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1163 */ { UD_Ipsrlw, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1164 */ { UD_Ivpsrlw, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1165 */ { UD_Ipsrld, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1166 */ { UD_Ipsrld, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1167 */ { UD_Ipsrld, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1168 */ { UD_Ivpsrld, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1169 */ { UD_Ipsrld, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1170 */ { UD_Ivpsrld, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1171 */ { UD_Ipsrlq, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1172 */ { UD_Ipsrlq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1173 */ { UD_Ipsrlq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1174 */ { UD_Ivpsrlq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1175 */ { UD_Ipsrlq, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1176 */ { UD_Ivpsrlq, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1177 */ { UD_Ipsubb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1178 */ { UD_Ivpsubb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1179 */ { UD_Ipsubb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1180 */ { UD_Ipsubw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1181 */ { UD_Ivpsubw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1182 */ { UD_Ipsubw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1183 */ { UD_Ipsubd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1184 */ { UD_Ipsubd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1185 */ { UD_Ivpsubd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1186 */ { UD_Ipsubsb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1187 */ { UD_Ipsubsb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1188 */ { UD_Ivpsubsb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1189 */ { UD_Ipsubsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1190 */ { UD_Ipsubsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1191 */ { UD_Ivpsubsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1192 */ { UD_Ipsubusb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1193 */ { UD_Ipsubusb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1194 */ { UD_Ivpsubusb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1195 */ { UD_Ipsubusw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1196 */ { UD_Ipsubusw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1197 */ { UD_Ivpsubusw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1198 */ { UD_Ipunpckhbw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1199 */ { UD_Ivpunpckhbw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1200 */ { UD_Ipunpckhbw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1201 */ { UD_Ipunpckhwd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1202 */ { UD_Ivpunpckhwd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1203 */ { UD_Ipunpckhwd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1204 */ { UD_Ipunpckhdq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1205 */ { UD_Ivpunpckhdq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1206 */ { UD_Ipunpckhdq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1207 */ { UD_Ipunpcklbw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1208 */ { UD_Ivpunpcklbw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1209 */ { UD_Ipunpcklbw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1210 */ { UD_Ipunpcklwd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1211 */ { UD_Ivpunpcklwd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1212 */ { UD_Ipunpcklwd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1213 */ { UD_Ipunpckldq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1214 */ { UD_Ivpunpckldq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1215 */ { UD_Ipunpckldq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1216 */ { UD_Ipi2fw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1217 */ { UD_Ipi2fd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1218 */ { UD_Ipf2iw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1219 */ { UD_Ipf2id, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1220 */ { UD_Ipfnacc, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1221 */ { UD_Ipfpnacc, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1222 */ { UD_Ipfcmpge, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1223 */ { UD_Ipfmin, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1224 */ { UD_Ipfrcp, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1225 */ { UD_Ipfrsqrt, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1226 */ { UD_Ipfsub, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1227 */ { UD_Ipfadd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1228 */ { UD_Ipfcmpgt, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1229 */ { UD_Ipfmax, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1230 */ { UD_Ipfrcpit1, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1231 */ { UD_Ipfrsqit1, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1232 */ { UD_Ipfsubr, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1233 */ { UD_Ipfacc, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1234 */ { UD_Ipfcmpeq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1235 */ { UD_Ipfmul, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1236 */ { UD_Ipfrcpit2, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1237 */ { UD_Ipmulhrw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1238 */ { UD_Ipswapd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1239 */ { UD_Ipavgusb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1240 */ { UD_Ipush, O_ES, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1241 */ { UD_Ipush, O_CS, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1242 */ { UD_Ipush, O_SS, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1243 */ { UD_Ipush, O_DS, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1244 */ { UD_Ipush, O_GS, O_NONE, O_NONE, O_NONE, P_none },
  /* 1245 */ { UD_Ipush, O_FS, O_NONE, O_NONE, O_NONE, P_none },
  /* 1246 */ { UD_Ipush, O_R0v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1247 */ { UD_Ipush, O_R1v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1248 */ { UD_Ipush, O_R2v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1249 */ { UD_Ipush, O_R3v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1250 */ { UD_Ipush, O_R4v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1251 */ { UD_Ipush, O_R5v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1252 */ { UD_Ipush, O_R6v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1253 */ { UD_Ipush, O_R7v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1254 */ { UD_Ipush, O_sIz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 1255 */ { UD_Ipush, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1256 */ { UD_Ipush, O_sIb, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 1257 */ { UD_Ipusha, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 1258 */ { UD_Ipushad, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 1259 */ { UD_Ipushfw, O_NONE, O_NONE, O_NONE, O_NONE, P_oso },
  /* 1260 */ { UD_Ipushfw, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_def64 },
  /* 1261 */ { UD_Ipushfd, O_NONE, O_NONE, O_NONE, O_NONE, P_oso },
  /* 1262 */ { UD_Ipushfq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_def64 },
  /* 1263 */ { UD_Ipushfq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_def64 },
  /* 1264 */ { UD_Ipxor, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1265 */ { UD_Ivpxor, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1266 */ { UD_Ipxor, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1267 */ { UD_Ircl, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1268 */ { UD_Ircl, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1269 */ { UD_Ircl, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1270 */ { UD_Ircl, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1271 */ { UD_Ircl, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1272 */ { UD_Ircl, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1273 */ { UD_Ircr, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1274 */ { UD_Ircr, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1275 */ { UD_Ircr, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1276 */ { UD_Ircr, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1277 */ { UD_Ircr, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1278 */ { UD_Ircr, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1279 */ { UD_Irol, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1280 */ { UD_Irol, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1281 */ { UD_Irol, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1282 */ { UD_Irol, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1283 */ { UD_Irol, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1284 */ { UD_Irol, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1285 */ { UD_Iror, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1286 */ { UD_Iror, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1287 */ { UD_Iror, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1288 */ { UD_Iror, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1289 */ { UD_Iror, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1290 */ { UD_Iror, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1291 */ { UD_Ircpps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1292 */ { UD_Ivrcpps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1293 */ { UD_Ircpss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1294 */ { UD_Ivrcpss, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1295 */ { UD_Irdmsr, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1296 */ { UD_Irdpmc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1297 */ { UD_Irdtsc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1298 */ { UD_Irdtscp, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1299 */ { UD_Irepne, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1300 */ { UD_Irep, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1301 */ { UD_Iret, O_Iw, O_NONE, O_NONE, O_NONE, P_none },
  /* 1302 */ { UD_Iret, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1303 */ { UD_Iretf, O_Iw, O_NONE, O_NONE, O_NONE, P_none },
  /* 1304 */ { UD_Iretf, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1305 */ { UD_Irsm, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1306 */ { UD_Irsqrtps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1307 */ { UD_Ivrsqrtps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1308 */ { UD_Irsqrtss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1309 */ { UD_Ivrsqrtss, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1310 */ { UD_Isahf, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1311 */ { UD_Isalc, O_NONE, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1312 */ { UD_Isar, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1313 */ { UD_Isar, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1314 */ { UD_Isar, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1315 */ { UD_Isar, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1316 */ { UD_Isar, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1317 */ { UD_Isar, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1318 */ { UD_Ishl, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1319 */ { UD_Ishl, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1320 */ { UD_Ishl, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1321 */ { UD_Ishl, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1322 */ { UD_Ishl, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1323 */ { UD_Ishl, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1324 */ { UD_Ishl, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1325 */ { UD_Ishl, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1326 */ { UD_Ishl, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1327 */ { UD_Ishl, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1328 */ { UD_Ishl, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1329 */ { UD_Ishl, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1330 */ { UD_Ishr, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1331 */ { UD_Ishr, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1332 */ { UD_Ishr, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1333 */ { UD_Ishr, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1334 */ { UD_Ishr, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1335 */ { UD_Ishr, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1336 */ { UD_Isbb, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1337 */ { UD_Isbb, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1338 */ { UD_Isbb, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1339 */ { UD_Isbb, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1340 */ { UD_Isbb, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 1341 */ { UD_Isbb, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 1342 */ { UD_Isbb, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1343 */ { UD_Isbb, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1344 */ { UD_Isbb, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 1345 */ { UD_Isbb, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1346 */ { UD_Iscasb, O_NONE, O_NONE, O_NONE, O_NONE, P_strz },
  /* 1347 */ { UD_Iscasw, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw },
  /* 1348 */ { UD_Iscasd, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw },
  /* 1349 */ { UD_Iscasq, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw },
  /* 1350 */ { UD_Iseto, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1351 */ { UD_Isetno, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1352 */ { UD_Isetb, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1353 */ { UD_Isetae, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1354 */ { UD_Isetz, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1355 */ { UD_Isetnz, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1356 */ { UD_Isetbe, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1357 */ { UD_Iseta, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1358 */ { UD_Isets, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1359 */ { UD_Isetns, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1360 */ { UD_Isetp, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1361 */ { UD_Isetnp, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1362 */ { UD_Isetl, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1363 */ { UD_Isetge, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1364 */ { UD_Isetle, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1365 */ { UD_Isetg, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1366 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1367 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1368 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1369 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1370 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1371 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1372 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1373 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1374 */ { UD_Isgdt, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1375 */ { UD_Ishld, O_Ev, O_Gv, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1376 */ { UD_Ishld, O_Ev, O_Gv, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1377 */ { UD_Ishrd, O_Ev, O_Gv, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1378 */ { UD_Ishrd, O_Ev, O_Gv, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1379 */ { UD_Ishufpd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1380 */ { UD_Ivshufpd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1381 */ { UD_Ishufps, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1382 */ { UD_Ivshufps, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1383 */ { UD_Isidt, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1384 */ { UD_Isldt, O_MwRv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1385 */ { UD_Ismsw, O_MwRv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1386 */ { UD_Ismsw, O_MwRv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1387 */ { UD_Isqrtps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1388 */ { UD_Ivsqrtps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1389 */ { UD_Isqrtpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1390 */ { UD_Ivsqrtpd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1391 */ { UD_Isqrtsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1392 */ { UD_Ivsqrtsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1393 */ { UD_Isqrtss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1394 */ { UD_Ivsqrtss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1395 */ { UD_Istc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1396 */ { UD_Istd, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1397 */ { UD_Istgi, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1398 */ { UD_Isti, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1399 */ { UD_Iskinit, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1400 */ { UD_Istmxcsr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1401 */ { UD_Ivstmxcsr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1402 */ { UD_Istosb, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 1403 */ { UD_Istosw, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 1404 */ { UD_Istosd, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 1405 */ { UD_Istosq, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 1406 */ { UD_Istr, O_MwRv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1407 */ { UD_Isub, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1408 */ { UD_Isub, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1409 */ { UD_Isub, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1410 */ { UD_Isub, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1411 */ { UD_Isub, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 1412 */ { UD_Isub, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 1413 */ { UD_Isub, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1414 */ { UD_Isub, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1415 */ { UD_Isub, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 1416 */ { UD_Isub, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1417 */ { UD_Isubpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1418 */ { UD_Ivsubpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1419 */ { UD_Isubps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1420 */ { UD_Ivsubps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1421 */ { UD_Isubsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1422 */ { UD_Ivsubsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1423 */ { UD_Isubss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1424 */ { UD_Ivsubss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1425 */ { UD_Iswapgs, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1426 */ { UD_Isyscall, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1427 */ { UD_Isysenter, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1428 */ { UD_Isysenter, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1429 */ { UD_Isysexit, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1430 */ { UD_Isysexit, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1431 */ { UD_Isysret, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1432 */ { UD_Itest, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1433 */ { UD_Itest, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1434 */ { UD_Itest, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1435 */ { UD_Itest, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 1436 */ { UD_Itest, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 1437 */ { UD_Itest, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1438 */ { UD_Itest, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1439 */ { UD_Itest, O_Ev, O_Iz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1440 */ { UD_Iucomisd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1441 */ { UD_Ivucomisd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1442 */ { UD_Iucomiss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1443 */ { UD_Ivucomiss, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1444 */ { UD_Iud2, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1445 */ { UD_Iunpckhpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1446 */ { UD_Ivunpckhpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1447 */ { UD_Iunpckhps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1448 */ { UD_Ivunpckhps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1449 */ { UD_Iunpcklps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1450 */ { UD_Ivunpcklps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1451 */ { UD_Iunpcklpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1452 */ { UD_Ivunpcklpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1453 */ { UD_Iverr, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1454 */ { UD_Iverw, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1455 */ { UD_Ivmcall, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1456 */ { UD_Irdrand, O_R, O_NONE, O_NONE, O_NONE, P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1457 */ { UD_Ivmclear, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1458 */ { UD_Ivmxon, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1459 */ { UD_Ivmptrld, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1460 */ { UD_Ivmptrst, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1461 */ { UD_Ivmlaunch, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1462 */ { UD_Ivmresume, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1463 */ { UD_Ivmxoff, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1464 */ { UD_Ivmread, O_Ey, O_Gy, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1465 */ { UD_Ivmwrite, O_Gy, O_Ey, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1466 */ { UD_Ivmrun, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1467 */ { UD_Ivmmcall, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1468 */ { UD_Ivmload, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1469 */ { UD_Ivmsave, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1470 */ { UD_Iwait, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1471 */ { UD_Iwbinvd, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1472 */ { UD_Iwrmsr, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1473 */ { UD_Ixadd, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexx|P_rexb },
  /* 1474 */ { UD_Ixadd, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1475 */ { UD_Ixchg, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1476 */ { UD_Ixchg, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1477 */ { UD_Ixchg, O_R0v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1478 */ { UD_Ixchg, O_R1v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1479 */ { UD_Ixchg, O_R2v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1480 */ { UD_Ixchg, O_R3v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1481 */ { UD_Ixchg, O_R4v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1482 */ { UD_Ixchg, O_R5v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1483 */ { UD_Ixchg, O_R6v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1484 */ { UD_Ixchg, O_R7v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1485 */ { UD_Ixgetbv, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1486 */ { UD_Ixlatb, O_NONE, O_NONE, O_NONE, O_NONE, P_rexw|P_seg },
  /* 1487 */ { UD_Ixor, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1488 */ { UD_Ixor, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1489 */ { UD_Ixor, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1490 */ { UD_Ixor, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1491 */ { UD_Ixor, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 1492 */ { UD_Ixor, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 1493 */ { UD_Ixor, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1494 */ { UD_Ixor, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1495 */ { UD_Ixor, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 1496 */ { UD_Ixor, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1497 */ { UD_Ixorpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1498 */ { UD_Ivxorpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1499 */ { UD_Ixorps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1500 */ { UD_Ivxorps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1501 */ { UD_Ixcryptecb, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1502 */ { UD_Ixcryptcbc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1503 */ { UD_Ixcryptctr, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1504 */ { UD_Ixcryptcfb, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1505 */ { UD_Ixcryptofb, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1506 */ { UD_Ixrstor, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1507 */ { UD_Ixsave, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1508 */ { UD_Ixsetbv, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1509 */ { UD_Ixsha1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1510 */ { UD_Ixsha256, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1511 */ { UD_Ixstore, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1512 */ { UD_Ipclmulqdq, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1513 */ { UD_Ivpclmulqdq, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1514 */ { UD_Igetsec, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1515 */ { UD_Imovdqa, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1516 */ { UD_Ivmovdqa, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1517 */ { UD_Imovdqa, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1518 */ { UD_Ivmovdqa, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1519 */ { UD_Imaskmovdqu, O_V, O_U, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1520 */ { UD_Ivmaskmovdqu, O_Vx, O_Ux, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1521 */ { UD_Imovdq2q, O_P, O_U, O_NONE, O_NONE, P_aso|P_rexb },
  /* 1522 */ { UD_Imovdqu, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1523 */ { UD_Ivmovdqu, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1524 */ { UD_Imovdqu, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1525 */ { UD_Ivmovdqu, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1526 */ { UD_Imovq2dq, O_V, O_N, O_NONE, O_NONE, P_aso|P_rexr },
  /* 1527 */ { UD_Ipaddq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1528 */ { UD_Ipaddq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1529 */ { UD_Ivpaddq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1530 */ { UD_Ipsubq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1531 */ { UD_Ivpsubq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1532 */ { UD_Ipsubq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1533 */ { UD_Ipmuludq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1534 */ { UD_Ipmuludq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1535 */ { UD_Ipshufhw, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1536 */ { UD_Ivpshufhw, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1537 */ { UD_Ipshuflw, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1538 */ { UD_Ivpshuflw, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1539 */ { UD_Ipshufd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1540 */ { UD_Ivpshufd, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1541 */ { UD_Ipslldq, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1542 */ { UD_Ivpslldq, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1543 */ { UD_Ipsrldq, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1544 */ { UD_Ivpsrldq, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1545 */ { UD_Ipunpckhqdq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1546 */ { UD_Ivpunpckhqdq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1547 */ { UD_Ipunpcklqdq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1548 */ { UD_Ivpunpcklqdq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1549 */ { UD_Ihaddpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1550 */ { UD_Ivhaddpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1551 */ { UD_Ihaddps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1552 */ { UD_Ivhaddps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1553 */ { UD_Ihsubpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1554 */ { UD_Ivhsubpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1555 */ { UD_Ihsubps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1556 */ { UD_Ivhsubps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1557 */ { UD_Iinsertps, O_V, O_Md, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1558 */ { UD_Ivinsertps, O_Vx, O_Hx, O_Md, O_Ib, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1559 */ { UD_Ilddqu, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1560 */ { UD_Ivlddqu, O_Vx, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1561 */ { UD_Imovddup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1562 */ { UD_Ivmovddup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1563 */ { UD_Imovddup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1564 */ { UD_Ivmovddup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1565 */ { UD_Imovshdup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1566 */ { UD_Ivmovshdup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1567 */ { UD_Imovshdup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1568 */ { UD_Ivmovshdup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1569 */ { UD_Imovsldup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1570 */ { UD_Ivmovsldup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1571 */ { UD_Imovsldup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1572 */ { UD_Ivmovsldup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1573 */ { UD_Ipabsb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1574 */ { UD_Ipabsb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1575 */ { UD_Ivpabsb, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1576 */ { UD_Ipabsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1577 */ { UD_Ipabsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1578 */ { UD_Ivpabsw, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1579 */ { UD_Ipabsd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1580 */ { UD_Ipabsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1581 */ { UD_Ivpabsd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1582 */ { UD_Ipshufb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1583 */ { UD_Ipshufb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1584 */ { UD_Ivpshufb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1585 */ { UD_Iphaddw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1586 */ { UD_Iphaddw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1587 */ { UD_Ivphaddw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1588 */ { UD_Iphaddd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1589 */ { UD_Iphaddd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1590 */ { UD_Ivphaddd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1591 */ { UD_Iphaddsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1592 */ { UD_Iphaddsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1593 */ { UD_Ivphaddsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1594 */ { UD_Ipmaddubsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1595 */ { UD_Ipmaddubsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1596 */ { UD_Ivpmaddubsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1597 */ { UD_Iphsubw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1598 */ { UD_Iphsubw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1599 */ { UD_Ivphsubw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1600 */ { UD_Iphsubd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1601 */ { UD_Iphsubd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1602 */ { UD_Ivphsubd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1603 */ { UD_Iphsubsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1604 */ { UD_Iphsubsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1605 */ { UD_Ivphsubsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1606 */ { UD_Ipsignb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1607 */ { UD_Ipsignb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1608 */ { UD_Ivpsignb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1609 */ { UD_Ipsignd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1610 */ { UD_Ipsignd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1611 */ { UD_Ivpsignd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1612 */ { UD_Ipsignw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1613 */ { UD_Ipsignw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1614 */ { UD_Ivpsignw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1615 */ { UD_Ipmulhrsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1616 */ { UD_Ipmulhrsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1617 */ { UD_Ivpmulhrsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1618 */ { UD_Ipalignr, O_P, O_Q, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1619 */ { UD_Ipalignr, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1620 */ { UD_Ivpalignr, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1621 */ { UD_Ipblendvb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1622 */ { UD_Ipmuldq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1623 */ { UD_Ivpmuldq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1624 */ { UD_Ipminsb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1625 */ { UD_Ivpminsb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1626 */ { UD_Ipminsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1627 */ { UD_Ivpminsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1628 */ { UD_Ipminuw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1629 */ { UD_Ivpminuw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1630 */ { UD_Ipminud, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1631 */ { UD_Ivpminud, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1632 */ { UD_Ipmaxsb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1633 */ { UD_Ivpmaxsb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1634 */ { UD_Ipmaxsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1635 */ { UD_Ivpmaxsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1636 */ { UD_Ipmaxud, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1637 */ { UD_Ivpmaxud, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1638 */ { UD_Ipmaxuw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1639 */ { UD_Ivpmaxuw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1640 */ { UD_Ipmulld, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1641 */ { UD_Ivpmulld, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1642 */ { UD_Iphminposuw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1643 */ { UD_Ivphminposuw, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1644 */ { UD_Iroundps, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1645 */ { UD_Ivroundps, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1646 */ { UD_Iroundpd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1647 */ { UD_Ivroundpd, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1648 */ { UD_Iroundss, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1649 */ { UD_Ivroundss, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1650 */ { UD_Iroundsd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1651 */ { UD_Ivroundsd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1652 */ { UD_Iblendpd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1653 */ { UD_Ivblendpd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1654 */ { UD_Iblendps, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1655 */ { UD_Ivblendps, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1656 */ { UD_Iblendvpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1657 */ { UD_Iblendvps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1658 */ { UD_Ibound, O_Gv, O_M, O_NONE, O_NONE, P_aso|P_oso },
  /* 1659 */ { UD_Ibsf, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1660 */ { UD_Ibsr, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1661 */ { UD_Ibswap, O_R0y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1662 */ { UD_Ibswap, O_R1y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1663 */ { UD_Ibswap, O_R2y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1664 */ { UD_Ibswap, O_R3y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1665 */ { UD_Ibswap, O_R4y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1666 */ { UD_Ibswap, O_R5y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1667 */ { UD_Ibswap, O_R6y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1668 */ { UD_Ibswap, O_R7y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1669 */ { UD_Ibt, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1670 */ { UD_Ibt, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1671 */ { UD_Ibtc, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1672 */ { UD_Ibtc, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1673 */ { UD_Ibtr, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1674 */ { UD_Ibtr, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1675 */ { UD_Ibts, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1676 */ { UD_Ibts, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1677 */ { UD_Ipblendw, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1678 */ { UD_Ivpblendw, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1679 */ { UD_Impsadbw, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1680 */ { UD_Ivmpsadbw, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1681 */ { UD_Imovntdqa, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1682 */ { UD_Ivmovntdqa, O_Vx, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb|P_vexl },
  /* 1683 */ { UD_Ipackusdw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1684 */ { UD_Ivpackusdw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb|P_vexl },
  /* 1685 */ { UD_Ipmovsxbw, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1686 */ { UD_Ivpmovsxbw, O_Vx, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1687 */ { UD_Ipmovsxbd, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1688 */ { UD_Ivpmovsxbd, O_Vx, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1689 */ { UD_Ipmovsxbq, O_V, O_MwU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1690 */ { UD_Ivpmovsxbq, O_Vx, O_MwU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1691 */ { UD_Ipmovsxwd, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1692 */ { UD_Ivpmovsxwd, O_Vx, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1693 */ { UD_Ipmovsxwq, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1694 */ { UD_Ivpmovsxwq, O_Vx, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1695 */ { UD_Ipmovsxdq, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1696 */ { UD_Ipmovzxbw, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1697 */ { UD_Ivpmovzxbw, O_Vx, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1698 */ { UD_Ipmovzxbd, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1699 */ { UD_Ivpmovzxbd, O_Vx, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1700 */ { UD_Ipmovzxbq, O_V, O_MwU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1701 */ { UD_Ivpmovzxbq, O_Vx, O_MwU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1702 */ { UD_Ipmovzxwd, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1703 */ { UD_Ivpmovzxwd, O_Vx, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1704 */ { UD_Ipmovzxwq, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1705 */ { UD_Ivpmovzxwq, O_Vx, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1706 */ { UD_Ipmovzxdq, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1707 */ { UD_Ivpmovzxdq, O_Vx, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1708 */ { UD_Ipcmpeqq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1709 */ { UD_Ivpcmpeqq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1710 */ { UD_Ipopcnt, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1711 */ { UD_Iptest, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1712 */ { UD_Ivptest, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb|P_vexl },
  /* 1713 */ { UD_Ipcmpestri, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1714 */ { UD_Ivpcmpestri, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1715 */ { UD_Ipcmpestrm, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1716 */ { UD_Ivpcmpestrm, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1717 */ { UD_Ipcmpgtq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1718 */ { UD_Ivpcmpgtq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1719 */ { UD_Ipcmpistri, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1720 */ { UD_Ivpcmpistri, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1721 */ { UD_Ipcmpistrm, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1722 */ { UD_Ivpcmpistrm, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1723 */ { UD_Imovbe, O_Gv, O_Mv, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1724 */ { UD_Imovbe, O_Mv, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1725 */ { UD_Icrc32, O_Gy, O_Eb, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1726 */ { UD_Icrc32, O_Gy, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1727 */ { UD_Ivbroadcastss, O_V, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1728 */ { UD_Ivbroadcastsd, O_Vqq, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1729 */ { UD_Ivextractf128, O_Wdq, O_Vqq, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1730 */ { UD_Ivinsertf128, O_Vqq, O_Hqq, O_Wdq, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1731 */ { UD_Ivmaskmovps, O_V, O_H, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1732 */ { UD_Ivmaskmovps, O_M, O_H, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1733 */ { UD_Ivmaskmovpd, O_V, O_H, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1734 */ { UD_Ivmaskmovpd, O_M, O_H, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1735 */ { UD_Ivpermilpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1736 */ { UD_Ivpermilpd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1737 */ { UD_Ivpermilps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1738 */ { UD_Ivpermilps, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1739 */ { UD_Ivperm2f128, O_Vqq, O_Hqq, O_Wqq, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1740 */ { UD_Ivtestps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1741 */ { UD_Ivtestpd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1742 */ { UD_Ivzeroupper, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1743 */ { UD_Ivzeroall, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1744 */ { UD_Ivblendvpd, O_Vx, O_Hx, O_Wx, O_Lx, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1745 */ { UD_Ivblendvps, O_Vx, O_Hx, O_Wx, O_Lx, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1746 */ { UD_Ivmovsd, O_V, O_H, O_U, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1747 */ { UD_Ivmovsd, O_V, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1748 */ { UD_Ivmovsd, O_U, O_H, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1749 */ { UD_Ivmovsd, O_Mq, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1750 */ { UD_Ivmovss, O_V, O_H, O_U, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1751 */ { UD_Ivmovss, O_V, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1752 */ { UD_Ivmovss, O_U, O_H, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1753 */ { UD_Ivmovss, O_Md, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1754 */ { UD_Ivpblendvb, O_V, O_H, O_W, O_L, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1755 */ { UD_Ivpsllw, O_V, O_H, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1756 */ { UD_Ivpsllw, O_H, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1757 */ { UD_Ivpslld, O_V, O_H, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1758 */ { UD_Ivpslld, O_H, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1759 */ { UD_Ivpsllq, O_V, O_H, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1760 */ { UD_Ivpsllq, O_H, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
};


const char* ud_mnemonics_str[] = {
    "aaa",
    "aad",
    "aam",
    "aas",
    "adc",
    "add",
    "addpd",
    "addps",
    "addsd",
    "addss",
    "addsubpd",
    "addsubps",
    "aesdec",
    "aesdeclast",
    "aesenc",
    "aesenclast",
    "aesimc",
    "aeskeygenassist",
    "and",
    "andnpd",
    "andnps",
    "andpd",
    "andps",
    "arpl",
    "blendpd",
    "blendps",
    "blendvpd",
    "blendvps",
    "bound",
    "bsf",
    "bsr",
    "bswap",
    "bt",
    "btc",
    "btr",
    "bts",
    "call",
    "cbw",
    "cdq",
    "cdqe",
    "clc",
    "cld",
    "clflush",
    "clgi",
    "cli",
    "clts",
    "cmc",
    "cmova",
    "cmovae",
    "cmovb",
    "cmovbe",
    "cmovg",
    "cmovge",
    "cmovl",
    "cmovle",
    "cmovno",
    "cmovnp",
    "cmovns",
    "cmovnz",
    "cmovo",
    "cmovp",
    "cmovs",
    "cmovz",
    "cmp",
    "cmppd",
    "cmpps",
    "cmpsb",
    "cmpsd",
    "cmpsq",
    "cmpss",
    "cmpsw",
    "cmpxchg",
    "cmpxchg16b",
    "cmpxchg8b",
    "comisd",
    "comiss",
    "cpuid",
    "cqo",
    "crc32",
    "cvtdq2pd",
    "cvtdq2ps",
    "cvtpd2dq",
    "cvtpd2pi",
    "cvtpd2ps",
    "cvtpi2pd",
    "cvtpi2ps",
    "cvtps2dq",
    "cvtps2pd",
    "cvtps2pi",
    "cvtsd2si",
    "cvtsd2ss",
    "cvtsi2sd",
    "cvtsi2ss",
    "cvtss2sd",
    "cvtss2si",
    "cvttpd2dq",
    "cvttpd2pi",
    "cvttps2dq",
    "cvttps2pi",
    "cvttsd2si",
    "cvttss2si",
    "cwd",
    "cwde",
    "daa",
    "das",
    "dec",
    "div",
    "divpd",
    "divps",
    "divsd",
    "divss",
    "dppd",
    "dpps",
    "emms",
    "enter",
    "extractps",
    "f2xm1",
    "fabs",
    "fadd",
    "faddp",
    "fbld",
    "fbstp",
    "fchs",
    "fclex",
    "fcmovb",
    "fcmovbe",
    "fcmove",
    "fcmovnb",
    "fcmovnbe",
    "fcmovne",
    "fcmovnu",
    "fcmovu",
    "fcom",
    "fcom2",
    "fcomi",
    "fcomip",
    "fcomp",
    "fcomp3",
    "fcomp5",
    "fcompp",
    "fcos",
    "fdecstp",
    "fdiv",
    "fdivp",
    "fdivr",
    "fdivrp",
    "femms",
    "ffree",
    "ffreep",
    "fiadd",
    "ficom",
    "ficomp",
    "fidiv",
    "fidivr",
    "fild",
    "fimul",
    "fincstp",
    "fist",
    "fistp",
    "fisttp",
    "fisub",
    "fisubr",
    "fld",
    "fld1",
    "fldcw",
    "fldenv",
    "fldl2e",
    "fldl2t",
    "fldlg2",
    "fldln2",
    "fldpi",
    "fldz",
    "fmul",
    "fmulp",
    "fndisi",
    "fneni",
    "fninit",
    "fnop",
    "fnsave",
    "fnsetpm",
    "fnstcw",
    "fnstenv",
    "fnstsw",
    "fpatan",
    "fprem",
    "fprem1",
    "fptan",
    "frndint",
    "frstor",
    "frstpm",
    "fscale",
    "fsin",
    "fsincos",
    "fsqrt",
    "fst",
    "fstp",
    "fstp1",
    "fstp8",
    "fstp9",
    "fsub",
    "fsubp",
    "fsubr",
    "fsubrp",
    "ftst",
    "fucom",
    "fucomi",
    "fucomip",
    "fucomp",
    "fucompp",
    "fxam",
    "fxch",
    "fxch4",
    "fxch7",
    "fxrstor",
    "fxsave",
    "fxtract",
    "fyl2x",
    "fyl2xp1",
    "getsec",
    "haddpd",
    "haddps",
    "hlt",
    "hsubpd",
    "hsubps",
    "idiv",
    "imul",
    "in",
    "inc",
    "insb",
    "insd",
    "insertps",
    "insw",
    "int",
    "int1",
    "int3",
    "into",
    "invd",
    "invept",
    "invlpg",
    "invlpga",
    "invvpid",
    "iretd",
    "iretq",
    "iretw",
    "ja",
    "jae",
    "jb",
    "jbe",
    "jcxz",
    "jecxz",
    "jg",
    "jge",
    "jl",
    "jle",
    "jmp",
    "jno",
    "jnp",
    "jns",
    "jnz",
    "jo",
    "jp",
    "jrcxz",
    "js",
    "jz",
    "lahf",
    "lar",
    "lddqu",
    "ldmxcsr",
    "lds",
    "lea",
    "leave",
    "les",
    "lfence",
    "lfs",
    "lgdt",
    "lgs",
    "lidt",
    "lldt",
    "lmsw",
    "lock",
    "lodsb",
    "lodsd",
    "lodsq",
    "lodsw",
    "loop",
    "loope",
    "loopne",
    "lsl",
    "lss",
    "ltr",
    "maskmovdqu",
    "maskmovq",
    "maxpd",
    "maxps",
    "maxsd",
    "maxss",
    "mfence",
    "minpd",
    "minps",
    "minsd",
    "minss",
    "monitor",
    "montmul",
    "mov",
    "movapd",
    "movaps",
    "movbe",
    "movd",
    "movddup",
    "movdq2q",
    "movdqa",
    "movdqu",
    "movhlps",
    "movhpd",
    "movhps",
    "movlhps",
    "movlpd",
    "movlps",
    "movmskpd",
    "movmskps",
    "movntdq",
    "movntdqa",
    "movnti",
    "movntpd",
    "movntps",
    "movntq",
    "movq",
    "movq2dq",
    "movsb",
    "movsd",
    "movshdup",
    "movsldup",
    "movsq",
    "movss",
    "movsw",
    "movsx",
    "movsxd",
    "movupd",
    "movups",
    "movzx",
    "mpsadbw",
    "mul",
    "mulpd",
    "mulps",
    "mulsd",
    "mulss",
    "mwait",
    "neg",
    "nop",
    "not",
    "or",
    "orpd",
    "orps",
    "out",
    "outsb",
    "outsd",
    "outsw",
    "pabsb",
    "pabsd",
    "pabsw",
    "packssdw",
    "packsswb",
    "packusdw",
    "packuswb",
    "paddb",
    "paddd",
    "paddq",
    "paddsb",
    "paddsw",
    "paddusb",
    "paddusw",
    "paddw",
    "palignr",
    "pand",
    "pandn",
    "pavgb",
    "pavgusb",
    "pavgw",
    "pblendvb",
    "pblendw",
    "pclmulqdq",
    "pcmpeqb",
    "pcmpeqd",
    "pcmpeqq",
    "pcmpeqw",
    "pcmpestri",
    "pcmpestrm",
    "pcmpgtb",
    "pcmpgtd",
    "pcmpgtq",
    "pcmpgtw",
    "pcmpistri",
    "pcmpistrm",
    "pextrb",
    "pextrd",
    "pextrq",
    "pextrw",
    "pf2id",
    "pf2iw",
    "pfacc",
    "pfadd",
    "pfcmpeq",
    "pfcmpge",
    "pfcmpgt",
    "pfmax",
    "pfmin",
    "pfmul",
    "pfnacc",
    "pfpnacc",
    "pfrcp",
    "pfrcpit1",
    "pfrcpit2",
    "pfrsqit1",
    "pfrsqrt",
    "pfsub",
    "pfsubr",
    "phaddd",
    "phaddsw",
    "phaddw",
    "phminposuw",
    "phsubd",
    "phsubsw",
    "phsubw",
    "pi2fd",
    "pi2fw",
    "pinsrb",
    "pinsrd",
    "pinsrq",
    "pinsrw",
    "pmaddubsw",
    "pmaddwd",
    "pmaxsb",
    "pmaxsd",
    "pmaxsw",
    "pmaxub",
    "pmaxud",
    "pmaxuw",
    "pminsb",
    "pminsd",
    "pminsw",
    "pminub",
    "pminud",
    "pminuw",
    "pmovmskb",
    "pmovsxbd",
    "pmovsxbq",
    "pmovsxbw",
    "pmovsxdq",
    "pmovsxwd",
    "pmovsxwq",
    "pmovzxbd",
    "pmovzxbq",
    "pmovzxbw",
    "pmovzxdq",
    "pmovzxwd",
    "pmovzxwq",
    "pmuldq",
    "pmulhrsw",
    "pmulhrw",
    "pmulhuw",
    "pmulhw",
    "pmulld",
    "pmullw",
    "pmuludq",
    "pop",
    "popa",
    "popad",
    "popcnt",
    "popfd",
    "popfq",
    "popfw",
    "por",
    "prefetch",
    "prefetchnta",
    "prefetcht0",
    "prefetcht1",
    "prefetcht2",
    "psadbw",
    "pshufb",
    "pshufd",
    "pshufhw",
    "pshuflw",
    "pshufw",
    "psignb",
    "psignd",
    "psignw",
    "pslld",
    "pslldq",
    "psllq",
    "psllw",
    "psrad",
    "psraw",
    "psrld",
    "psrldq",
    "psrlq",
    "psrlw",
    "psubb",
    "psubd",
    "psubq",
    "psubsb",
    "psubsw",
    "psubusb",
    "psubusw",
    "psubw",
    "pswapd",
    "ptest",
    "punpckhbw",
    "punpckhdq",
    "punpckhqdq",
    "punpckhwd",
    "punpcklbw",
    "punpckldq",
    "punpcklqdq",
    "punpcklwd",
    "push",
    "pusha",
    "pushad",
    "pushfd",
    "pushfq",
    "pushfw",
    "pxor",
    "rcl",
    "rcpps",
    "rcpss",
    "rcr",
    "rdmsr",
    "rdpmc",
    "rdrand",
    "rdtsc",
    "rdtscp",
    "rep",
    "repne",
    "ret",
    "retf",
    "rol",
    "ror",
    "roundpd",
    "roundps",
    "roundsd",
    "roundss",
    "rsm",
    "rsqrtps",
    "rsqrtss",
    "sahf",
    "salc",
    "sar",
    "sbb",
    "scasb",
    "scasd",
    "scasq",
    "scasw",
    "seta",
    "setae",
    "setb",
    "setbe",
    "setg",
    "setge",
    "setl",
    "setle",
    "setno",
    "setnp",
    "setns",
    "setnz",
    "seto",
    "setp",
    "sets",
    "setz",
    "sfence",
    "sgdt",
    "shl",
    "shld",
    "shr",
    "shrd",
    "shufpd",
    "shufps",
    "sidt",
    "skinit",
    "sldt",
    "smsw",
    "sqrtpd",
    "sqrtps",
    "sqrtsd",
    "sqrtss",
    "stc",
    "std",
    "stgi",
    "sti",
    "stmxcsr",
    "stosb",
    "stosd",
    "stosq",
    "stosw",
    "str",
    "sub",
    "subpd",
    "subps",
    "subsd",
    "subss",
    "swapgs",
    "syscall",
    "sysenter",
    "sysexit",
    "sysret",
    "test",
    "ucomisd",
    "ucomiss",
    "ud2",
    "unpckhpd",
    "unpckhps",
    "unpcklpd",
    "unpcklps",
    "vaddpd",
    "vaddps",
    "vaddsd",
    "vaddss",
    "vaddsubpd",
    "vaddsubps",
    "vaesdec",
    "vaesdeclast",
    "vaesenc",
    "vaesenclast",
    "vaesimc",
    "vaeskeygenassist",
    "vandnpd",
    "vandnps",
    "vandpd",
    "vandps",
    "vblendpd",
    "vblendps",
    "vblendvpd",
    "vblendvps",
    "vbroadcastsd",
    "vbroadcastss",
    "vcmppd",
    "vcmpps",
    "vcmpsd",
    "vcmpss",
    "vcomisd",
    "vcomiss",
    "vcvtdq2pd",
    "vcvtdq2ps",
    "vcvtpd2dq",
    "vcvtpd2ps",
    "vcvtps2dq",
    "vcvtps2pd",
    "vcvtsd2si",
    "vcvtsd2ss",
    "vcvtsi2sd",
    "vcvtsi2ss",
    "vcvtss2sd",
    "vcvtss2si",
    "vcvttpd2dq",
    "vcvttps2dq",
    "vcvttsd2si",
    "vcvttss2si",
    "vdivpd",
    "vdivps",
    "vdivsd",
    "vdivss",
    "vdppd",
    "vdpps",
    "verr",
    "verw",
    "vextractf128",
    "vextractps",
    "vhaddpd",
    "vhaddps",
    "vhsubpd",
    "vhsubps",
    "vinsertf128",
    "vinsertps",
    "vlddqu",
    "vmaskmovdqu",
    "vmaskmovpd",
    "vmaskmovps",
    "vmaxpd",
    "vmaxps",
    "vmaxsd",
    "vmaxss",
    "vmcall",
    "vmclear",
    "vminpd",
    "vminps",
    "vminsd",
    "vminss",
    "vmlaunch",
    "vmload",
    "vmmcall",
    "vmovapd",
    "vmovaps",
    "vmovd",
    "vmovddup",
    "vmovdqa",
    "vmovdqu",
    "vmovhlps",
    "vmovhpd",
    "vmovhps",
    "vmovlhps",
    "vmovlpd",
    "vmovlps",
    "vmovmskpd",
    "vmovmskps",
    "vmovntdq",
    "vmovntdqa",
    "vmovntpd",
    "vmovntps",
    "vmovq",
    "vmovsd",
    "vmovshdup",
    "vmovsldup",
    "vmovss",
    "vmovupd",
    "vmovups",
    "vmpsadbw",
    "vmptrld",
    "vmptrst",
    "vmread",
    "vmresume",
    "vmrun",
    "vmsave",
    "vmulpd",
    "vmulps",
    "vmulsd",
    "vmulss",
    "vmwrite",
    "vmxoff",
    "vmxon",
    "vorpd",
    "vorps",
    "vpabsb",
    "vpabsd",
    "vpabsw",
    "vpackssdw",
    "vpacksswb",
    "vpackusdw",
    "vpackuswb",
    "vpaddb",
    "vpaddd",
    "vpaddq",
    "vpaddsb",
    "vpaddsw",
    "vpaddusb",
    "vpaddusw",
    "vpaddw",
    "vpalignr",
    "vpand",
    "vpandn",
    "vpavgb",
    "vpavgw",
    "vpblendvb",
    "vpblendw",
    "vpclmulqdq",
    "vpcmpeqb",
    "vpcmpeqd",
    "vpcmpeqq",
    "vpcmpeqw",
    "vpcmpestri",
    "vpcmpestrm",
    "vpcmpgtb",
    "vpcmpgtd",
    "vpcmpgtq",
    "vpcmpgtw",
    "vpcmpistri",
    "vpcmpistrm",
    "vperm2f128",
    "vpermilpd",
    "vpermilps",
    "vpextrb",
    "vpextrd",
    "vpextrq",
    "vpextrw",
    "vphaddd",
    "vphaddsw",
    "vphaddw",
    "vphminposuw",
    "vphsubd",
    "vphsubsw",
    "vphsubw",
    "vpinsrb",
    "vpinsrd",
    "vpinsrq",
    "vpinsrw",
    "vpmaddubsw",
    "vpmaddwd",
    "vpmaxsb",
    "vpmaxsd",
    "vpmaxsw",
    "vpmaxub",
    "vpmaxud",
    "vpmaxuw",
    "vpminsb",
    "vpminsd",
    "vpminsw",
    "vpminub",
    "vpminud",
    "vpminuw",
    "vpmovmskb",
    "vpmovsxbd",
    "vpmovsxbq",
    "vpmovsxbw",
    "vpmovsxwd",
    "vpmovsxwq",
    "vpmovzxbd",
    "vpmovzxbq",
    "vpmovzxbw",
    "vpmovzxdq",
    "vpmovzxwd",
    "vpmovzxwq",
    "vpmuldq",
    "vpmulhrsw",
    "vpmulhuw",
    "vpmulhw",
    "vpmulld",
    "vpmullw",
    "vpor",
    "vpsadbw",
    "vpshufb",
    "vpshufd",
    "vpshufhw",
    "vpshuflw",
    "vpsignb",
    "vpsignd",
    "vpsignw",
    "vpslld",
    "vpslldq",
    "vpsllq",
    "vpsllw",
    "vpsrad",
    "vpsraw",
    "vpsrld",
    "vpsrldq",
    "vpsrlq",
    "vpsrlw",
    "vpsubb",
    "vpsubd",
    "vpsubq",
    "vpsubsb",
    "vpsubsw",
    "vpsubusb",
    "vpsubusw",
    "vpsubw",
    "vptest",
    "vpunpckhbw",
    "vpunpckhdq",
    "vpunpckhqdq",
    "vpunpckhwd",
    "vpunpcklbw",
    "vpunpckldq",
    "vpunpcklqdq",
    "vpunpcklwd",
    "vpxor",
    "vrcpps",
    "vrcpss",
    "vroundpd",
    "vroundps",
    "vroundsd",
    "vroundss",
    "vrsqrtps",
    "vrsqrtss",
    "vshufpd",
    "vshufps",
    "vsqrtpd",
    "vsqrtps",
    "vsqrtsd",
    "vsqrtss",
    "vstmxcsr",
    "vsubpd",
    "vsubps",
    "vsubsd",
    "vsubss",
    "vtestpd",
    "vtestps",
    "vucomisd",
    "vucomiss",
    "vunpckhpd",
    "vunpckhps",
    "vunpcklpd",
    "vunpcklps",
    "vxorpd",
    "vxorps",
    "vzeroall",
    "vzeroupper",
    "wait",
    "wbinvd",
    "wrmsr",
    "xadd",
    "xchg",
    "xcryptcbc",
    "xcryptcfb",
    "xcryptctr",
    "xcryptecb",
    "xcryptofb",
    "xgetbv",
    "xlatb",
    "xor",
    "xorpd",
    "xorps",
    "xrstor",
    "xsave",
    "xsetbv",
    "xsha1",
    "xsha256",
    "xstore",
    "invalid",
    "3dnow",
    "none",
    "db",
    "pause",
	
	/* User-specific mnemonics */
	"undef",
	"restore stack",
	"load stack",
	"store stack",
	"reset eflags",
	"reset",
	"crypt",
	"align",
	"movspecial"
};

```

`TDE/libudis86/itab.h`:

```h
#ifndef UD_ITAB_H
#define UD_ITAB_H

/* itab.h -- generated by udis86:scripts/ud_itab.py, do no edit */

/* ud_table_type -- lookup table types (see decode.c) */
enum ud_table_type {
    UD_TAB__OPC_TABLE,
    UD_TAB__OPC_SSE,
    UD_TAB__OPC_REG,
    UD_TAB__OPC_RM,
    UD_TAB__OPC_MOD,
    UD_TAB__OPC_MODE,
    UD_TAB__OPC_X87,
    UD_TAB__OPC_ASIZE,
    UD_TAB__OPC_OSIZE,
    UD_TAB__OPC_3DNOW,
    UD_TAB__OPC_VENDOR,
    UD_TAB__OPC_VEX,
    UD_TAB__OPC_VEX_W,
    UD_TAB__OPC_VEX_L
};

/* ud_mnemonic -- mnemonic constants */
enum ud_mnemonic_code {
    UD_Iaaa,
    UD_Iaad,
    UD_Iaam,
    UD_Iaas,
    UD_Iadc,
    UD_Iadd,
    UD_Iaddpd,
    UD_Iaddps,
    UD_Iaddsd,
    UD_Iaddss,
    UD_Iaddsubpd,
    UD_Iaddsubps,
    UD_Iaesdec,
    UD_Iaesdeclast,
    UD_Iaesenc,
    UD_Iaesenclast,
    UD_Iaesimc,
    UD_Iaeskeygenassist,
    UD_Iand,
    UD_Iandnpd,
    UD_Iandnps,
    UD_Iandpd,
    UD_Iandps,
    UD_Iarpl,
    UD_Iblendpd,
    UD_Iblendps,
    UD_Iblendvpd,
    UD_Iblendvps,
    UD_Ibound,
    UD_Ibsf,
    UD_Ibsr,
    UD_Ibswap,
    UD_Ibt,
    UD_Ibtc,
    UD_Ibtr,
    UD_Ibts,
    UD_Icall,
    UD_Icbw,
    UD_Icdq,
    UD_Icdqe,
    UD_Iclc,
    UD_Icld,
    UD_Iclflush,
    UD_Iclgi,
    UD_Icli,
    UD_Iclts,
    UD_Icmc,
    UD_Icmova,
    UD_Icmovae,
    UD_Icmovb,
    UD_Icmovbe,
    UD_Icmovg,
    UD_Icmovge,
    UD_Icmovl,
    UD_Icmovle,
    UD_Icmovno,
    UD_Icmovnp,
    UD_Icmovns,
    UD_Icmovnz,
    UD_Icmovo,
    UD_Icmovp,
    UD_Icmovs,
    UD_Icmovz,
    UD_Icmp,
    UD_Icmppd,
    UD_Icmpps,
    UD_Icmpsb,
    UD_Icmpsd,
    UD_Icmpsq,
    UD_Icmpss,
    UD_Icmpsw,
    UD_Icmpxchg,
    UD_Icmpxchg16b,
    UD_Icmpxchg8b,
    UD_Icomisd,
    UD_Icomiss,
    UD_Icpuid,
    UD_Icqo,
    UD_Icrc32,
    UD_Icvtdq2pd,
    UD_Icvtdq2ps,
    UD_Icvtpd2dq,
    UD_Icvtpd2pi,
    UD_Icvtpd2ps,
    UD_Icvtpi2pd,
    UD_Icvtpi2ps,
    UD_Icvtps2dq,
    UD_Icvtps2pd,
    UD_Icvtps2pi,
    UD_Icvtsd2si,
    UD_Icvtsd2ss,
    UD_Icvtsi2sd,
    UD_Icvtsi2ss,
    UD_Icvtss2sd,
    UD_Icvtss2si,
    UD_Icvttpd2dq,
    UD_Icvttpd2pi,
    UD_Icvttps2dq,
    UD_Icvttps2pi,
    UD_Icvttsd2si,
    UD_Icvttss2si,
    UD_Icwd,
    UD_Icwde,
    UD_Idaa,
    UD_Idas,
    UD_Idec,
    UD_Idiv,
    UD_Idivpd,
    UD_Idivps,
    UD_Idivsd,
    UD_Idivss,
    UD_Idppd,
    UD_Idpps,
    UD_Iemms,
    UD_Ienter,
    UD_Iextractps,
    UD_If2xm1,
    UD_Ifabs,
    UD_Ifadd,
    UD_Ifaddp,
    UD_Ifbld,
    UD_Ifbstp,
    UD_Ifchs,
    UD_Ifclex,
    UD_Ifcmovb,
    UD_Ifcmovbe,
    UD_Ifcmove,
    UD_Ifcmovnb,
    UD_Ifcmovnbe,
    UD_Ifcmovne,
    UD_Ifcmovnu,
    UD_Ifcmovu,
    UD_Ifcom,
    UD_Ifcom2,
    UD_Ifcomi,
    UD_Ifcomip,
    UD_Ifcomp,
    UD_Ifcomp3,
    UD_Ifcomp5,
    UD_Ifcompp,
    UD_Ifcos,
    UD_Ifdecstp,
    UD_Ifdiv,
    UD_Ifdivp,
    UD_Ifdivr,
    UD_Ifdivrp,
    UD_Ifemms,
    UD_Iffree,
    UD_Iffreep,
    UD_Ifiadd,
    UD_Ificom,
    UD_Ificomp,
    UD_Ifidiv,
    UD_Ifidivr,
    UD_Ifild,
    UD_Ifimul,
    UD_Ifincstp,
    UD_Ifist,
    UD_Ifistp,
    UD_Ifisttp,
    UD_Ifisub,
    UD_Ifisubr,
    UD_Ifld,
    UD_Ifld1,
    UD_Ifldcw,
    UD_Ifldenv,
    UD_Ifldl2e,
    UD_Ifldl2t,
    UD_Ifldlg2,
    UD_Ifldln2,
    UD_Ifldpi,
    UD_Ifldz,
    UD_Ifmul,
    UD_Ifmulp,
    UD_Ifndisi,
    UD_Ifneni,
    UD_Ifninit,
    UD_Ifnop,
    UD_Ifnsave,
    UD_Ifnsetpm,
    UD_Ifnstcw,
    UD_Ifnstenv,
    UD_Ifnstsw,
    UD_Ifpatan,
    UD_Ifprem,
    UD_Ifprem1,
    UD_Ifptan,
    UD_Ifrndint,
    UD_Ifrstor,
    UD_Ifrstpm,
    UD_Ifscale,
    UD_Ifsin,
    UD_Ifsincos,
    UD_Ifsqrt,
    UD_Ifst,
    UD_Ifstp,
    UD_Ifstp1,
    UD_Ifstp8,
    UD_Ifstp9,
    UD_Ifsub,
    UD_Ifsubp,
    UD_Ifsubr,
    UD_Ifsubrp,
    UD_Iftst,
    UD_Ifucom,
    UD_Ifucomi,
    UD_Ifucomip,
    UD_Ifucomp,
    UD_Ifucompp,
    UD_Ifxam,
    UD_Ifxch,
    UD_Ifxch4,
    UD_Ifxch7,
    UD_Ifxrstor,
    UD_Ifxsave,
    UD_Ifxtract,
    UD_Ifyl2x,
    UD_Ifyl2xp1,
    UD_Igetsec,
    UD_Ihaddpd,
    UD_Ihaddps,
    UD_Ihlt,
    UD_Ihsubpd,
    UD_Ihsubps,
    UD_Iidiv,
    UD_Iimul,
    UD_Iin,
    UD_Iinc,
    UD_Iinsb,
    UD_Iinsd,
    UD_Iinsertps,
    UD_Iinsw,
    UD_Iint,
    UD_Iint1,
    UD_Iint3,
    UD_Iinto,
    UD_Iinvd,
    UD_Iinvept,
    UD_Iinvlpg,
    UD_Iinvlpga,
    UD_Iinvvpid,
    UD_Iiretd,
    UD_Iiretq,
    UD_Iiretw,
    UD_Ija,
    UD_Ijae,
    UD_Ijb,
    UD_Ijbe,
    UD_Ijcxz,
    UD_Ijecxz,
    UD_Ijg,
    UD_Ijge,
    UD_Ijl,
    UD_Ijle,
    UD_Ijmp,
    UD_Ijno,
    UD_Ijnp,
    UD_Ijns,
    UD_Ijnz,
    UD_Ijo,
    UD_Ijp,
    UD_Ijrcxz,
    UD_Ijs,
    UD_Ijz,
    UD_Ilahf,
    UD_Ilar,
    UD_Ilddqu,
    UD_Ildmxcsr,
    UD_Ilds,
    UD_Ilea,
    UD_Ileave,
    UD_Iles,
    UD_Ilfence,
    UD_Ilfs,
    UD_Ilgdt,
    UD_Ilgs,
    UD_Ilidt,
    UD_Illdt,
    UD_Ilmsw,
    UD_Ilock,
    UD_Ilodsb,
    UD_Ilodsd,
    UD_Ilodsq,
    UD_Ilodsw,
    UD_Iloop,
    UD_Iloope,
    UD_Iloopne,
    UD_Ilsl,
    UD_Ilss,
    UD_Iltr,
    UD_Imaskmovdqu,
    UD_Imaskmovq,
    UD_Imaxpd,
    UD_Imaxps,
    UD_Imaxsd,
    UD_Imaxss,
    UD_Imfence,
    UD_Iminpd,
    UD_Iminps,
    UD_Iminsd,
    UD_Iminss,
    UD_Imonitor,
    UD_Imontmul,
    UD_Imov,
    UD_Imovapd,
    UD_Imovaps,
    UD_Imovbe,
    UD_Imovd,
    UD_Imovddup,
    UD_Imovdq2q,
    UD_Imovdqa,
    UD_Imovdqu,
    UD_Imovhlps,
    UD_Imovhpd,
    UD_Imovhps,
    UD_Imovlhps,
    UD_Imovlpd,
    UD_Imovlps,
    UD_Imovmskpd,
    UD_Imovmskps,
    UD_Imovntdq,
    UD_Imovntdqa,
    UD_Imovnti,
    UD_Imovntpd,
    UD_Imovntps,
    UD_Imovntq,
    UD_Imovq,
    UD_Imovq2dq,
    UD_Imovsb,
    UD_Imovsd,
    UD_Imovshdup,
    UD_Imovsldup,
    UD_Imovsq,
    UD_Imovss,
    UD_Imovsw,
    UD_Imovsx,
    UD_Imovsxd,
    UD_Imovupd,
    UD_Imovups,
    UD_Imovzx,
    UD_Impsadbw,
    UD_Imul,
    UD_Imulpd,
    UD_Imulps,
    UD_Imulsd,
    UD_Imulss,
    UD_Imwait,
    UD_Ineg,
    UD_Inop,
    UD_Inot,
    UD_Ior,
    UD_Iorpd,
    UD_Iorps,
    UD_Iout,
    UD_Ioutsb,
    UD_Ioutsd,
    UD_Ioutsw,
    UD_Ipabsb,
    UD_Ipabsd,
    UD_Ipabsw,
    UD_Ipackssdw,
    UD_Ipacksswb,
    UD_Ipackusdw,
    UD_Ipackuswb,
    UD_Ipaddb,
    UD_Ipaddd,
    UD_Ipaddq,
    UD_Ipaddsb,
    UD_Ipaddsw,
    UD_Ipaddusb,
    UD_Ipaddusw,
    UD_Ipaddw,
    UD_Ipalignr,
    UD_Ipand,
    UD_Ipandn,
    UD_Ipavgb,
    UD_Ipavgusb,
    UD_Ipavgw,
    UD_Ipblendvb,
    UD_Ipblendw,
    UD_Ipclmulqdq,
    UD_Ipcmpeqb,
    UD_Ipcmpeqd,
    UD_Ipcmpeqq,
    UD_Ipcmpeqw,
    UD_Ipcmpestri,
    UD_Ipcmpestrm,
    UD_Ipcmpgtb,
    UD_Ipcmpgtd,
    UD_Ipcmpgtq,
    UD_Ipcmpgtw,
    UD_Ipcmpistri,
    UD_Ipcmpistrm,
    UD_Ipextrb,
    UD_Ipextrd,
    UD_Ipextrq,
    UD_Ipextrw,
    UD_Ipf2id,
    UD_Ipf2iw,
    UD_Ipfacc,
    UD_Ipfadd,
    UD_Ipfcmpeq,
    UD_Ipfcmpge,
    UD_Ipfcmpgt,
    UD_Ipfmax,
    UD_Ipfmin,
    UD_Ipfmul,
    UD_Ipfnacc,
    UD_Ipfpnacc,
    UD_Ipfrcp,
    UD_Ipfrcpit1,
    UD_Ipfrcpit2,
    UD_Ipfrsqit1,
    UD_Ipfrsqrt,
    UD_Ipfsub,
    UD_Ipfsubr,
    UD_Iphaddd,
    UD_Iphaddsw,
    UD_Iphaddw,
    UD_Iphminposuw,
    UD_Iphsubd,
    UD_Iphsubsw,
    UD_Iphsubw,
    UD_Ipi2fd,
    UD_Ipi2fw,
    UD_Ipinsrb,
    UD_Ipinsrd,
    UD_Ipinsrq,
    UD_Ipinsrw,
    UD_Ipmaddubsw,
    UD_Ipmaddwd,
    UD_Ipmaxsb,
    UD_Ipmaxsd,
    UD_Ipmaxsw,
    UD_Ipmaxub,
    UD_Ipmaxud,
    UD_Ipmaxuw,
    UD_Ipminsb,
    UD_Ipminsd,
    UD_Ipminsw,
    UD_Ipminub,
    UD_Ipminud,
    UD_Ipminuw,
    UD_Ipmovmskb,
    UD_Ipmovsxbd,
    UD_Ipmovsxbq,
    UD_Ipmovsxbw,
    UD_Ipmovsxdq,
    UD_Ipmovsxwd,
    UD_Ipmovsxwq,
    UD_Ipmovzxbd,
    UD_Ipmovzxbq,
    UD_Ipmovzxbw,
    UD_Ipmovzxdq,
    UD_Ipmovzxwd,
    UD_Ipmovzxwq,
    UD_Ipmuldq,
    UD_Ipmulhrsw,
    UD_Ipmulhrw,
    UD_Ipmulhuw,
    UD_Ipmulhw,
    UD_Ipmulld,
    UD_Ipmullw,
    UD_Ipmuludq,
    UD_Ipop,
    UD_Ipopa,
    UD_Ipopad,
    UD_Ipopcnt,
    UD_Ipopfd,
    UD_Ipopfq,
    UD_Ipopfw,
    UD_Ipor,
    UD_Iprefetch,
    UD_Iprefetchnta,
    UD_Iprefetcht0,
    UD_Iprefetcht1,
    UD_Iprefetcht2,
    UD_Ipsadbw,
    UD_Ipshufb,
    UD_Ipshufd,
    UD_Ipshufhw,
    UD_Ipshuflw,
    UD_Ipshufw,
    UD_Ipsignb,
    UD_Ipsignd,
    UD_Ipsignw,
    UD_Ipslld,
    UD_Ipslldq,
    UD_Ipsllq,
    UD_Ipsllw,
    UD_Ipsrad,
    UD_Ipsraw,
    UD_Ipsrld,
    UD_Ipsrldq,
    UD_Ipsrlq,
    UD_Ipsrlw,
    UD_Ipsubb,
    UD_Ipsubd,
    UD_Ipsubq,
    UD_Ipsubsb,
    UD_Ipsubsw,
    UD_Ipsubusb,
    UD_Ipsubusw,
    UD_Ipsubw,
    UD_Ipswapd,
    UD_Iptest,
    UD_Ipunpckhbw,
    UD_Ipunpckhdq,
    UD_Ipunpckhqdq,
    UD_Ipunpckhwd,
    UD_Ipunpcklbw,
    UD_Ipunpckldq,
    UD_Ipunpcklqdq,
    UD_Ipunpcklwd,
    UD_Ipush,
    UD_Ipusha,
    UD_Ipushad,
    UD_Ipushfd,
    UD_Ipushfq,
    UD_Ipushfw,
    UD_Ipxor,
    UD_Ircl,
    UD_Ircpps,
    UD_Ircpss,
    UD_Ircr,
    UD_Irdmsr,
    UD_Irdpmc,
    UD_Irdrand,
    UD_Irdtsc,
    UD_Irdtscp,
    UD_Irep,
    UD_Irepne,
    UD_Iret,
    UD_Iretf,
    UD_Irol,
    UD_Iror,
    UD_Iroundpd,
    UD_Iroundps,
    UD_Iroundsd,
    UD_Iroundss,
    UD_Irsm,
    UD_Irsqrtps,
    UD_Irsqrtss,
    UD_Isahf,
    UD_Isalc,
    UD_Isar,
    UD_Isbb,
    UD_Iscasb,
    UD_Iscasd,
    UD_Iscasq,
    UD_Iscasw,
    UD_Iseta,
    UD_Isetae,
    UD_Isetb,
    UD_Isetbe,
    UD_Isetg,
    UD_Isetge,
    UD_Isetl,
    UD_Isetle,
    UD_Isetno,
    UD_Isetnp,
    UD_Isetns,
    UD_Isetnz,
    UD_Iseto,
    UD_Isetp,
    UD_Isets,
    UD_Isetz,
    UD_Isfence,
    UD_Isgdt,
    UD_Ishl,
    UD_Ishld,
    UD_Ishr,
    UD_Ishrd,
    UD_Ishufpd,
    UD_Ishufps,
    UD_Isidt,
    UD_Iskinit,
    UD_Isldt,
    UD_Ismsw,
    UD_Isqrtpd,
    UD_Isqrtps,
    UD_Isqrtsd,
    UD_Isqrtss,
    UD_Istc,
    UD_Istd,
    UD_Istgi,
    UD_Isti,
    UD_Istmxcsr,
    UD_Istosb,
    UD_Istosd,
    UD_Istosq,
    UD_Istosw,
    UD_Istr,
    UD_Isub,
    UD_Isubpd,
    UD_Isubps,
    UD_Isubsd,
    UD_Isubss,
    UD_Iswapgs,
    UD_Isyscall,
    UD_Isysenter,
    UD_Isysexit,
    UD_Isysret,
    UD_Itest,
    UD_Iucomisd,
    UD_Iucomiss,
    UD_Iud2,
    UD_Iunpckhpd,
    UD_Iunpckhps,
    UD_Iunpcklpd,
    UD_Iunpcklps,
    UD_Ivaddpd,
    UD_Ivaddps,
    UD_Ivaddsd,
    UD_Ivaddss,
    UD_Ivaddsubpd,
    UD_Ivaddsubps,
    UD_Ivaesdec,
    UD_Ivaesdeclast,
    UD_Ivaesenc,
    UD_Ivaesenclast,
    UD_Ivaesimc,
    UD_Ivaeskeygenassist,
    UD_Ivandnpd,
    UD_Ivandnps,
    UD_Ivandpd,
    UD_Ivandps,
    UD_Ivblendpd,
    UD_Ivblendps,
    UD_Ivblendvpd,
    UD_Ivblendvps,
    UD_Ivbroadcastsd,
    UD_Ivbroadcastss,
    UD_Ivcmppd,
    UD_Ivcmpps,
    UD_Ivcmpsd,
    UD_Ivcmpss,
    UD_Ivcomisd,
    UD_Ivcomiss,
    UD_Ivcvtdq2pd,
    UD_Ivcvtdq2ps,
    UD_Ivcvtpd2dq,
    UD_Ivcvtpd2ps,
    UD_Ivcvtps2dq,
    UD_Ivcvtps2pd,
    UD_Ivcvtsd2si,
    UD_Ivcvtsd2ss,
    UD_Ivcvtsi2sd,
    UD_Ivcvtsi2ss,
    UD_Ivcvtss2sd,
    UD_Ivcvtss2si,
    UD_Ivcvttpd2dq,
    UD_Ivcvttps2dq,
    UD_Ivcvttsd2si,
    UD_Ivcvttss2si,
    UD_Ivdivpd,
    UD_Ivdivps,
    UD_Ivdivsd,
    UD_Ivdivss,
    UD_Ivdppd,
    UD_Ivdpps,
    UD_Iverr,
    UD_Iverw,
    UD_Ivextractf128,
    UD_Ivextractps,
    UD_Ivhaddpd,
    UD_Ivhaddps,
    UD_Ivhsubpd,
    UD_Ivhsubps,
    UD_Ivinsertf128,
    UD_Ivinsertps,
    UD_Ivlddqu,
    UD_Ivmaskmovdqu,
    UD_Ivmaskmovpd,
    UD_Ivmaskmovps,
    UD_Ivmaxpd,
    UD_Ivmaxps,
    UD_Ivmaxsd,
    UD_Ivmaxss,
    UD_Ivmcall,
    UD_Ivmclear,
    UD_Ivminpd,
    UD_Ivminps,
    UD_Ivminsd,
    UD_Ivminss,
    UD_Ivmlaunch,
    UD_Ivmload,
    UD_Ivmmcall,
    UD_Ivmovapd,
    UD_Ivmovaps,
    UD_Ivmovd,
    UD_Ivmovddup,
    UD_Ivmovdqa,
    UD_Ivmovdqu,
    UD_Ivmovhlps,
    UD_Ivmovhpd,
    UD_Ivmovhps,
    UD_Ivmovlhps,
    UD_Ivmovlpd,
    UD_Ivmovlps,
    UD_Ivmovmskpd,
    UD_Ivmovmskps,
    UD_Ivmovntdq,
    UD_Ivmovntdqa,
    UD_Ivmovntpd,
    UD_Ivmovntps,
    UD_Ivmovq,
    UD_Ivmovsd,
    UD_Ivmovshdup,
    UD_Ivmovsldup,
    UD_Ivmovss,
    UD_Ivmovupd,
    UD_Ivmovups,
    UD_Ivmpsadbw,
    UD_Ivmptrld,
    UD_Ivmptrst,
    UD_Ivmread,
    UD_Ivmresume,
    UD_Ivmrun,
    UD_Ivmsave,
    UD_Ivmulpd,
    UD_Ivmulps,
    UD_Ivmulsd,
    UD_Ivmulss,
    UD_Ivmwrite,
    UD_Ivmxoff,
    UD_Ivmxon,
    UD_Ivorpd,
    UD_Ivorps,
    UD_Ivpabsb,
    UD_Ivpabsd,
    UD_Ivpabsw,
    UD_Ivpackssdw,
    UD_Ivpacksswb,
    UD_Ivpackusdw,
    UD_Ivpackuswb,
    UD_Ivpaddb,
    UD_Ivpaddd,
    UD_Ivpaddq,
    UD_Ivpaddsb,
    UD_Ivpaddsw,
    UD_Ivpaddusb,
    UD_Ivpaddusw,
    UD_Ivpaddw,
    UD_Ivpalignr,
    UD_Ivpand,
    UD_Ivpandn,
    UD_Ivpavgb,
    UD_Ivpavgw,
    UD_Ivpblendvb,
    UD_Ivpblendw,
    UD_Ivpclmulqdq,
    UD_Ivpcmpeqb,
    UD_Ivpcmpeqd,
    UD_Ivpcmpeqq,
    UD_Ivpcmpeqw,
    UD_Ivpcmpestri,
    UD_Ivpcmpestrm,
    UD_Ivpcmpgtb,
    UD_Ivpcmpgtd,
    UD_Ivpcmpgtq,
    UD_Ivpcmpgtw,
    UD_Ivpcmpistri,
    UD_Ivpcmpistrm,
    UD_Ivperm2f128,
    UD_Ivpermilpd,
    UD_Ivpermilps,
    UD_Ivpextrb,
    UD_Ivpextrd,
    UD_Ivpextrq,
    UD_Ivpextrw,
    UD_Ivphaddd,
    UD_Ivphaddsw,
    UD_Ivphaddw,
    UD_Ivphminposuw,
    UD_Ivphsubd,
    UD_Ivphsubsw,
    UD_Ivphsubw,
    UD_Ivpinsrb,
    UD_Ivpinsrd,
    UD_Ivpinsrq,
    UD_Ivpinsrw,
    UD_Ivpmaddubsw,
    UD_Ivpmaddwd,
    UD_Ivpmaxsb,
    UD_Ivpmaxsd,
    UD_Ivpmaxsw,
    UD_Ivpmaxub,
    UD_Ivpmaxud,
    UD_Ivpmaxuw,
    UD_Ivpminsb,
    UD_Ivpminsd,
    UD_Ivpminsw,
    UD_Ivpminub,
    UD_Ivpminud,
    UD_Ivpminuw,
    UD_Ivpmovmskb,
    UD_Ivpmovsxbd,
    UD_Ivpmovsxbq,
    UD_Ivpmovsxbw,
    UD_Ivpmovsxwd,
    UD_Ivpmovsxwq,
    UD_Ivpmovzxbd,
    UD_Ivpmovzxbq,
    UD_Ivpmovzxbw,
    UD_Ivpmovzxdq,
    UD_Ivpmovzxwd,
    UD_Ivpmovzxwq,
    UD_Ivpmuldq,
    UD_Ivpmulhrsw,
    UD_Ivpmulhuw,
    UD_Ivpmulhw,
    UD_Ivpmulld,
    UD_Ivpmullw,
    UD_Ivpor,
    UD_Ivpsadbw,
    UD_Ivpshufb,
    UD_Ivpshufd,
    UD_Ivpshufhw,
    UD_Ivpshuflw,
    UD_Ivpsignb,
    UD_Ivpsignd,
    UD_Ivpsignw,
    UD_Ivpslld,
    UD_Ivpslldq,
    UD_Ivpsllq,
    UD_Ivpsllw,
    UD_Ivpsrad,
    UD_Ivpsraw,
    UD_Ivpsrld,
    UD_Ivpsrldq,
    UD_Ivpsrlq,
    UD_Ivpsrlw,
    UD_Ivpsubb,
    UD_Ivpsubd,
    UD_Ivpsubq,
    UD_Ivpsubsb,
    UD_Ivpsubsw,
    UD_Ivpsubusb,
    UD_Ivpsubusw,
    UD_Ivpsubw,
    UD_Ivptest,
    UD_Ivpunpckhbw,
    UD_Ivpunpckhdq,
    UD_Ivpunpckhqdq,
    UD_Ivpunpckhwd,
    UD_Ivpunpcklbw,
    UD_Ivpunpckldq,
    UD_Ivpunpcklqdq,
    UD_Ivpunpcklwd,
    UD_Ivpxor,
    UD_Ivrcpps,
    UD_Ivrcpss,
    UD_Ivroundpd,
    UD_Ivroundps,
    UD_Ivroundsd,
    UD_Ivroundss,
    UD_Ivrsqrtps,
    UD_Ivrsqrtss,
    UD_Ivshufpd,
    UD_Ivshufps,
    UD_Ivsqrtpd,
    UD_Ivsqrtps,
    UD_Ivsqrtsd,
    UD_Ivsqrtss,
    UD_Ivstmxcsr,
    UD_Ivsubpd,
    UD_Ivsubps,
    UD_Ivsubsd,
    UD_Ivsubss,
    UD_Ivtestpd,
    UD_Ivtestps,
    UD_Ivucomisd,
    UD_Ivucomiss,
    UD_Ivunpckhpd,
    UD_Ivunpckhps,
    UD_Ivunpcklpd,
    UD_Ivunpcklps,
    UD_Ivxorpd,
    UD_Ivxorps,
    UD_Ivzeroall,
    UD_Ivzeroupper,
    UD_Iwait,
    UD_Iwbinvd,
    UD_Iwrmsr,
    UD_Ixadd,
    UD_Ixchg,
    UD_Ixcryptcbc,
    UD_Ixcryptcfb,
    UD_Ixcryptctr,
    UD_Ixcryptecb,
    UD_Ixcryptofb,
    UD_Ixgetbv,
    UD_Ixlatb,
    UD_Ixor,
    UD_Ixorpd,
    UD_Ixorps,
    UD_Ixrstor,
    UD_Ixsave,
    UD_Ixsetbv,
    UD_Ixsha1,
    UD_Ixsha256,
    UD_Ixstore,
    UD_Iinvalid,
    UD_I3dnow,
    UD_Inone,
    UD_Idb,
    UD_Ipause,

	/* User-specific mnemonics */
	UD_Iundef,
	UD_Irestorestack,
	UD_Iloadstack,
	UD_Istorestack,
	UD_Ireseteflags,
	UD_Ireset,
	UD_Icrypt,

	UD_Ialign,
	UD_Imovspecial,

    UD_MAX_MNEMONIC_CODE
};

extern const char * ud_mnemonics_str[];

#endif /* UD_ITAB_H */

```

`TDE/libudis86/syn-att.c`:

```c
/* udis86 - libudis86/syn-att.c
 *
 * Copyright (c) 2002-2009 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "types.h"
#include "extern.h"
#include "decode.h"
#include "itab.h"
#include "syn.h"
#include "udint.h"

/* -----------------------------------------------------------------------------
 * opr_cast() - Prints an operand cast.
 * -----------------------------------------------------------------------------
 */
static void 
opr_cast(struct ud* u, struct ud_operand* op)
{
  switch(op->size) {
  case 16 : case 32 :
    ud_asmprintf(u, "*");   break;
  default: break;
  }
}

/* -----------------------------------------------------------------------------
 * gen_operand() - Generates assembly output for each operand.
 * -----------------------------------------------------------------------------
 */
static void 
gen_operand(struct ud* u, struct ud_operand* op)
{
  switch(op->type) {
  case UD_OP_CONST:
    ud_asmprintf(u, "$0x%x", op->lval.udword);
    break;

  case UD_OP_REG:
    ud_asmprintf(u, "%%%s", ud_reg_tab[op->base - UD_R_AL]);
    break;

  case UD_OP_MEM:
    if (u->br_far) {
        opr_cast(u, op);
    }
    if (u->pfx_seg) {
      ud_asmprintf(u, "%%%s:", ud_reg_tab[u->pfx_seg - UD_R_AL]);
    }
    if (op->offset != 0) { 
      ud_syn_print_mem_disp(u, op, 0);
    }
    if (op->base) {
      ud_asmprintf(u, "(%%%s", ud_reg_tab[op->base - UD_R_AL]);
    }
    if (op->index) {
      if (op->base) {
        ud_asmprintf(u, ",");
      } else {
        ud_asmprintf(u, "(");
      }
      ud_asmprintf(u, "%%%s", ud_reg_tab[op->index - UD_R_AL]);
    }
    if (op->scale) {
      ud_asmprintf(u, ",%d", op->scale);
    }
    if (op->base || op->index) {
      ud_asmprintf(u, ")");
    }
    break;

  case UD_OP_IMM:
    ud_asmprintf(u, "$");
    ud_syn_print_imm(u, op);
    break;

  case UD_OP_JIMM:
    ud_syn_print_addr(u, ud_syn_rel_target(u, op));
    break;

  case UD_OP_PTR:
    switch (op->size) {
      case 32:
        ud_asmprintf(u, "$0x%x, $0x%x", op->lval.ptr.seg, 
          op->lval.ptr.off & 0xFFFF);
        break;
      case 48:
        ud_asmprintf(u, "$0x%x, $0x%x", op->lval.ptr.seg, 
          op->lval.ptr.off);
        break;
    }
    break;
      
  default: return;
  }
}

/* =============================================================================
 * translates to AT&T syntax 
 * =============================================================================
 */
extern void 
ud_translate_att(struct ud *u)
{
  int size = 0;
  int star = 0;

  /* check if P_OSO prefix is used */
  if (! P_OSO(u->itab_entry->prefix) && u->pfx_opr) {
  switch (u->dis_mode) {
    case 16: 
      ud_asmprintf(u, "o32 ");
      break;
    case 32:
    case 64:
      ud_asmprintf(u, "o16 ");
      break;
  }
  }

  /* check if P_ASO prefix was used */
  if (! P_ASO(u->itab_entry->prefix) && u->pfx_adr) {
  switch (u->dis_mode) {
    case 16: 
      ud_asmprintf(u, "a32 ");
      break;
    case 32:
      ud_asmprintf(u, "a16 ");
      break;
    case 64:
      ud_asmprintf(u, "a32 ");
      break;
  }
  }

  if (u->pfx_lock)
    ud_asmprintf(u,  "lock ");
  if (u->pfx_rep) {
    ud_asmprintf(u, "rep ");
  } else if (u->pfx_repe) {
    ud_asmprintf(u, "repe ");
  } else if (u->pfx_repne) {
    ud_asmprintf(u, "repne ");
  }

  /* special instructions */
  switch (u->mnemonic) {
  case UD_Iretf: 
    ud_asmprintf(u, "lret "); 
    break;
  case UD_Idb:
    ud_asmprintf(u, ".byte 0x%x", u->operand[0].lval.ubyte);
    return;
  case UD_Ijmp:
  case UD_Icall:
    if (u->br_far) ud_asmprintf(u,  "l");
        if (u->operand[0].type == UD_OP_REG) {
          star = 1;
        }
    ud_asmprintf(u, "%s", ud_lookup_mnemonic(u->mnemonic));
    break;
  case UD_Ibound:
  case UD_Ienter:
    if (u->operand[0].type != UD_NONE)
      gen_operand(u, &u->operand[0]);
    if (u->operand[1].type != UD_NONE) {
      ud_asmprintf(u, ",");
      gen_operand(u, &u->operand[1]);
    }
    return;
  default:
    ud_asmprintf(u, "%s", ud_lookup_mnemonic(u->mnemonic));
  }

  if (size == 8) {
    ud_asmprintf(u, "b");
  } else if (size == 16) {
    ud_asmprintf(u, "w");
  } else if (size == 64) {
    ud_asmprintf(u, "q");
  }

  if (star) {
    ud_asmprintf(u, " *");
  } else {
    ud_asmprintf(u, " ");
  }

  if (u->operand[3].type != UD_NONE) {
    gen_operand(u, &u->operand[3]);
    ud_asmprintf(u, ", ");
  }
  if (u->operand[2].type != UD_NONE) {
    gen_operand(u, &u->operand[2]);
    ud_asmprintf(u, ", ");
  }
  if (u->operand[1].type != UD_NONE) {
    gen_operand(u, &u->operand[1]);
    ud_asmprintf(u, ", ");
  }
  if (u->operand[0].type != UD_NONE) {
    gen_operand(u, &u->operand[0]);
  }
}

/*
vim: set ts=2 sw=2 expandtab
*/

```

`TDE/libudis86/syn-intel.c`:

```c
/* udis86 - libudis86/syn-intel.c
 *
 * Copyright (c) 2002-2013 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "types.h"
#include "extern.h"
#include "decode.h"
#include "itab.h"
#include "syn.h"
#include "udint.h"

/* -----------------------------------------------------------------------------
 * opr_cast() - Prints an operand cast.
 * -----------------------------------------------------------------------------
 */
static void 
opr_cast(struct ud* u, struct ud_operand* op)
{
  if (u->br_far) {
    ud_asmprintf(u, "far "); 
  }
  switch(op->size) {
  case  8:  ud_asmprintf(u, "byte " ); break;
  case 16:  ud_asmprintf(u, "word " ); break;
  case 32:  ud_asmprintf(u, "dword "); break;
  case 64:  ud_asmprintf(u, "qword "); break;
  case 80:  ud_asmprintf(u, "tword "); break;
  case 128: ud_asmprintf(u, "oword "); break;
  case 256: ud_asmprintf(u, "yword "); break;
  default: break;
  }
}

/* -----------------------------------------------------------------------------
 * gen_operand() - Generates assembly output for each operand.
 * -----------------------------------------------------------------------------
 */
static void gen_operand(struct ud* u, struct ud_operand* op, int syn_cast)
{
  switch(op->type) {
  case UD_OP_REG:
    ud_asmprintf(u, "%s", ud_reg_tab[op->base - UD_R_AL]);
    break;

  case UD_OP_MEM:
    if (syn_cast) {
      opr_cast(u, op);
    }
    ud_asmprintf(u, "[");
    if (u->pfx_seg) {
      ud_asmprintf(u, "%s:", ud_reg_tab[u->pfx_seg - UD_R_AL]);
    }
    if (op->base) {
      ud_asmprintf(u, "%s", ud_reg_tab[op->base - UD_R_AL]);
    }
    if (op->index) {
      ud_asmprintf(u, "%s%s", op->base != UD_NONE? "+" : "",
                              ud_reg_tab[op->index - UD_R_AL]);
      if (op->scale) {
        ud_asmprintf(u, "*%d", op->scale);
      }
    }
    if (op->offset != 0) {
      ud_syn_print_mem_disp(u, op, (op->base  != UD_NONE || 
                                    op->index != UD_NONE) ? 1 : 0);
    }
    ud_asmprintf(u, "]");
    break;
      
  case UD_OP_IMM:
    ud_syn_print_imm(u, op);
    break;

  case UD_OP_JIMM:
    ud_syn_print_addr(u, ud_syn_rel_target(u, op));
    break;

  case UD_OP_PTR:
    switch (op->size) {
      case 32:
        ud_asmprintf(u, "word 0x%x:0x%x", op->lval.ptr.seg, 
          op->lval.ptr.off & 0xFFFF);
        break;
      case 48:
        ud_asmprintf(u, "dword 0x%x:0x%x", op->lval.ptr.seg, 
          op->lval.ptr.off);
        break;
    }
    break;

  case UD_OP_CONST:
    if (syn_cast) opr_cast(u, op);
    ud_asmprintf(u, "%d", op->lval.udword);
    break;

  default: return;
  }
}

/* =============================================================================
 * translates to intel syntax 
 * =============================================================================
 */
extern void
ud_translate_intel(struct ud* u)
{
	u->asm_buf_fill = 0;

	if (u->itab_entry != NULL)
	{
  /* check if P_OSO prefix is used */
  if (!P_OSO(u->itab_entry->prefix) && u->pfx_opr) {
    switch (u->dis_mode) {
    case 16: ud_asmprintf(u, "o32 "); break;
    case 32:
    case 64: ud_asmprintf(u, "o16 "); break;
    }
  }

  /* check if P_ASO prefix was used */
  if (!P_ASO(u->itab_entry->prefix) && u->pfx_adr) {
    switch (u->dis_mode) {
    case 16: ud_asmprintf(u, "a32 "); break;
    case 32: ud_asmprintf(u, "a16 "); break;
    case 64: ud_asmprintf(u, "a32 "); break;
    }
  }
	}

  if (u->pfx_seg &&
      u->operand[0].type != UD_OP_MEM &&
      u->operand[1].type != UD_OP_MEM ) {
    ud_asmprintf(u, "%s ", ud_reg_tab[u->pfx_seg - UD_R_AL]);
  }

  if (u->pfx_lock) {
    ud_asmprintf(u, "lock ");
  }
  if (u->pfx_rep) {
    ud_asmprintf(u, "rep ");
  } else if (u->pfx_repe) {
    ud_asmprintf(u, "repe ");
  } else if (u->pfx_repne) {
    ud_asmprintf(u, "repne ");
  }

  /* print the instruction mnemonic */
  ud_asmprintf(u, "%s", ud_lookup_mnemonic(u->mnemonic));

  if (u->operand[0].type != UD_NONE) {
    int cast = 0;
    ud_asmprintf(u, " ");
    if (u->operand[0].type == UD_OP_MEM) {
      if (u->operand[1].type == UD_OP_IMM   ||
          u->operand[1].type == UD_OP_CONST ||
          u->operand[1].type == UD_NONE     ||
          (u->operand[0].size != u->operand[1].size)) {
          cast = 1;
      } else if (u->operand[1].type == UD_OP_REG &&
                 u->operand[1].base == UD_R_CL) {
          switch (u->mnemonic) {
          case UD_Ircl:
          case UD_Irol:
          case UD_Iror:
          case UD_Ircr:
          case UD_Ishl:
          case UD_Ishr:
          case UD_Isar:
              cast = 1;
              break;
          default: break;
          }
      }
    }
    gen_operand(u, &u->operand[0], cast);
  }

  if (u->operand[1].type != UD_NONE) {
    int cast = 0;
    ud_asmprintf(u, ", ");
    if (u->operand[1].type == UD_OP_MEM &&
        u->operand[0].size != u->operand[1].size && 
        !ud_opr_is_sreg(&u->operand[0])) {
      cast = 1;
    }
    gen_operand(u, &u->operand[1], cast);
  }

  if (u->operand[2].type != UD_NONE) {
    int cast = 0;
    ud_asmprintf(u, ", ");
    if (u->operand[2].type == UD_OP_MEM &&
        u->operand[2].size != u->operand[1].size) {
      cast = 1;
    }
    gen_operand(u, &u->operand[2], cast);
  }

  if (u->operand[3].type != UD_NONE) {
    ud_asmprintf(u, ", ");
    gen_operand(u, &u->operand[3], 0);
  }
}

/*
vim: set ts=2 sw=2 expandtab
*/

```

`TDE/libudis86/syn.c`:

```c
/* udis86 - libudis86/syn.c
 *
 * Copyright (c) 2002-2013 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "types.h"
#include "decode.h"
#include "syn.h"
#include "udint.h"

/* 
 * Register Table - Order Matters (types.h)!
 *
 */
const char* ud_reg_tab[] = 
{
  "al",   "cl",   "dl",   "bl",
  "ah",   "ch",   "dh",   "bh",
  "spl",  "bpl",  "sil",  "dil",
  "r8b",  "r9b",  "r10b", "r11b",
  "r12b", "r13b", "r14b", "r15b",

  "ax",   "cx",   "dx",   "bx",
  "sp",   "bp",   "si",   "di",
  "r8w",  "r9w",  "r10w", "r11w",
  "r12w", "r13w", "r14w", "r15w",
  
  "eax",  "ecx",  "edx",  "ebx",
  "esp",  "ebp",  "esi",  "edi",
  "r8d",  "r9d",  "r10d", "r11d",
  "r12d", "r13d", "r14d", "r15d",
  
  "rax",  "rcx",  "rdx",  "rbx",
  "rsp",  "rbp",  "rsi",  "rdi",
  "r8",   "r9",   "r10",  "r11",
  "r12",  "r13",  "r14",  "r15",

  "es",   "cs",   "ss",   "ds",
  "fs",   "gs", 

  "cr0",  "cr1",  "cr2",  "cr3",
  "cr4",  "cr5",  "cr6",  "cr7",
  "cr8",  "cr9",  "cr10", "cr11",
  "cr12", "cr13", "cr14", "cr15",
  
  "dr0",  "dr1",  "dr2",  "dr3",
  "dr4",  "dr5",  "dr6",  "dr7",
  "dr8",  "dr9",  "dr10", "dr11",
  "dr12", "dr13", "dr14", "dr15",

  "mm0",  "mm1",  "mm2",  "mm3",
  "mm4",  "mm5",  "mm6",  "mm7",

  "st0",  "st1",  "st2",  "st3",
  "st4",  "st5",  "st6",  "st7", 

  "xmm0", "xmm1", "xmm2", "xmm3",
  "xmm4", "xmm5", "xmm6", "xmm7",
  "xmm8", "xmm9", "xmm10", "xmm11",
  "xmm12", "xmm13", "xmm14", "xmm15",

  "ymm0", "ymm1", "ymm2",   "ymm3",
  "ymm4", "ymm5", "ymm6",   "ymm7",
  "ymm8", "ymm9", "ymm10",  "ymm11",
  "ymm12", "ymm13", "ymm14", "ymm15",

  "rip",

  "addr1", "addr2"
};


uint64_t
ud_syn_rel_target(struct ud *u, struct ud_operand *opr)
{
  const uint64_t trunc_mask = 0xffffffffffffffffull >> (64 - u->opr_mode);
  switch (opr->size) {
  case 8 : return (u->pc + opr->lval.sbyte)  & trunc_mask;
  case 16: return (u->pc + opr->lval.sword)  & trunc_mask;
  case 32: return (u->pc + opr->lval.sdword) & trunc_mask;
  default: UD_ASSERT(!"invalid relative offset size.");
    return 0ull;
  }
}


/*
 * asmprintf
 *    Printf style function for printing translated assembly
 *    output. Returns the number of characters written and
 *    moves the buffer pointer forward. On an overflow,
 *    returns a negative number and truncates the output.
 */
int
ud_asmprintf(struct ud *u, const char *fmt, ...)
{
  int ret;
  int avail;
  va_list ap;
  va_start(ap, fmt);
  avail = u->asm_buf_size - u->asm_buf_fill - 1 /* nullchar */;
  ret = vsnprintf((char*) u->asm_buf + u->asm_buf_fill, avail, fmt, ap);
  if (ret < 0 || ret > avail) {
      u->asm_buf_fill = u->asm_buf_size - 1;
  } else {
      u->asm_buf_fill += ret;
  }
  va_end(ap);
  return ret;
}


void
ud_syn_print_addr(struct ud *u, uint64_t addr)
{
  const char *name = NULL;
  if (u->sym_resolver) {
    int64_t offset = 0;
    name = u->sym_resolver(u, addr, &offset);
    if (name) {
      if (offset) {
        ud_asmprintf(u, "%s%+" FMT64 "d", name, offset);
      } else {
        ud_asmprintf(u, "%s", name);
      }
      return;
    }
  }
  ud_asmprintf(u, "0x%" FMT64 "x", addr);
}


void
ud_syn_print_imm(struct ud* u, const struct ud_operand *op)
{
  uint64_t v;
  if (op->_oprcode == OP_sI && op->size != u->opr_mode) {
    if (op->size == 8) {
      v = (int64_t)op->lval.sbyte;
    } else {
      UD_ASSERT(op->size == 32);
      v = (int64_t)op->lval.sdword;
    }
    if (u->opr_mode < 64) {
      v = v & ((1ull << u->opr_mode) - 1ull);
    }
  } else {
    switch (op->size) {
    case 8 : v = op->lval.ubyte;  break;
    case 16: v = op->lval.uword;  break;
    case 32: v = op->lval.udword; break;
    case 64: v = op->lval.uqword; break;
    default: UD_ASSERT(!"invalid offset"); v = 0; /* keep cc happy */
    }
  }
  ud_asmprintf(u, "0x%" FMT64 "x", v);
}


void
ud_syn_print_mem_disp(struct ud* u, const struct ud_operand *op, int sign)
{
  UD_ASSERT(op->offset != 0);
 if (op->base == UD_NONE && op->index == UD_NONE) {
    uint64_t v;
    UD_ASSERT(op->scale == UD_NONE && op->offset != 8);
    /* unsigned mem-offset */
    switch (op->offset) {
    case 16: v = op->lval.uword;  break;
    case 32: v = op->lval.udword; break;
    case 64: v = op->lval.uqword; break;
    default: UD_ASSERT(!"invalid offset"); v = 0; /* keep cc happy */
    }
    ud_asmprintf(u, "0x%" FMT64 "x", v);
  } else {
    int64_t v;
    UD_ASSERT(op->offset != 64);
    switch (op->offset) {
    case 8 : v = op->lval.sbyte;  break;
    case 16: v = op->lval.sword;  break;
    case 32: v = op->lval.sdword; break;
    default: UD_ASSERT(!"invalid offset"); v = 0; /* keep cc happy */
    }
    if (v < 0) {
      ud_asmprintf(u, "-0x%" FMT64 "x", -v);
    } else if (v > 0) {
      ud_asmprintf(u, "%s0x%" FMT64 "x", sign? "+" : "", v);
    }
  }
}

/*
vim: set ts=2 sw=2 expandtab
*/

```

`TDE/libudis86/syn.h`:

```h
/* udis86 - libudis86/syn.h
 *
 * Copyright (c) 2002-2009
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef UD_SYN_H
#define UD_SYN_H

#include "types.h"
#ifndef __UD_STANDALONE__
# include <stdarg.h>
#endif /* __UD_STANDALONE__ */

extern const char* ud_reg_tab[];

uint64_t ud_syn_rel_target(struct ud*, struct ud_operand*);

#ifdef __GNUC__
int ud_asmprintf(struct ud *u, const char *fmt, ...)
    __attribute__ ((format (printf, 2, 3)));
#else
int ud_asmprintf(struct ud *u, const char *fmt, ...);
#endif

void ud_syn_print_addr(struct ud *u, uint64_t addr);
void ud_syn_print_imm(struct ud* u, const struct ud_operand *op);
void ud_syn_print_mem_disp(struct ud* u, const struct ud_operand *, int sign);

#endif /* UD_SYN_H */

/*
vim: set ts=2 sw=2 expandtab
*/

```

`TDE/libudis86/types.h`:

```h
/* udis86 - libudis86/types.h
 *
 * Copyright (c) 2002-2013 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef UD_TYPES_H
#define UD_TYPES_H

#ifdef __KERNEL__
  /* 
   * -D__KERNEL__ is automatically passed on the command line when
   * building something as part of the Linux kernel. Assume standalone
   * mode.
   */
# include <linux/kernel.h>
# include <linux/string.h>
# ifndef __UD_STANDALONE__
#  define __UD_STANDALONE__ 1
# endif
#endif /* __KERNEL__ */

#if !defined(__UD_STANDALONE__)
# include <stdint.h>
# include <stdio.h>
#endif

/* gcc specific extensions */
#ifdef __GNUC__
# define UD_ATTR_PACKED __attribute__((packed))
#else
# define UD_ATTR_PACKED
#endif /* UD_ATTR_PACKED */


/* -----------------------------------------------------------------------------
 * All possible "types" of objects in udis86. Order is Important!
 * -----------------------------------------------------------------------------
 */
enum ud_type
{
  UD_NONE,

  /* 8 bit GPRs */
  UD_R_AL,  UD_R_CL,  UD_R_DL,  UD_R_BL,
  UD_R_AH,  UD_R_CH,  UD_R_DH,  UD_R_BH,
  UD_R_SPL, UD_R_BPL, UD_R_SIL, UD_R_DIL,
  UD_R_R8B, UD_R_R9B, UD_R_R10B,  UD_R_R11B,
  UD_R_R12B,  UD_R_R13B,  UD_R_R14B,  UD_R_R15B,

  /* 16 bit GPRs */
  UD_R_AX,  UD_R_CX,  UD_R_DX,  UD_R_BX,
  UD_R_SP,  UD_R_BP,  UD_R_SI,  UD_R_DI,
  UD_R_R8W, UD_R_R9W, UD_R_R10W,  UD_R_R11W,
  UD_R_R12W,  UD_R_R13W,  UD_R_R14W,  UD_R_R15W,
  
  /* 32 bit GPRs */
  UD_R_EAX, UD_R_ECX, UD_R_EDX, UD_R_EBX,
  UD_R_ESP, UD_R_EBP, UD_R_ESI, UD_R_EDI,
  UD_R_R8D, UD_R_R9D, UD_R_R10D,  UD_R_R11D,
  UD_R_R12D,  UD_R_R13D,  UD_R_R14D,  UD_R_R15D,
  
  /* 64 bit GPRs */
  UD_R_RAX, UD_R_RCX, UD_R_RDX, UD_R_RBX,
  UD_R_RSP, UD_R_RBP, UD_R_RSI, UD_R_RDI,
  UD_R_R8,  UD_R_R9,  UD_R_R10, UD_R_R11,
  UD_R_R12, UD_R_R13, UD_R_R14, UD_R_R15,

  /* segment registers */
  UD_R_ES,  UD_R_CS,  UD_R_SS,  UD_R_DS,
  UD_R_FS,  UD_R_GS,  

  /* control registers*/
  UD_R_CR0, UD_R_CR1, UD_R_CR2, UD_R_CR3,
  UD_R_CR4, UD_R_CR5, UD_R_CR6, UD_R_CR7,
  UD_R_CR8, UD_R_CR9, UD_R_CR10,  UD_R_CR11,
  UD_R_CR12,  UD_R_CR13,  UD_R_CR14,  UD_R_CR15,
  
  /* debug registers */
  UD_R_DR0, UD_R_DR1, UD_R_DR2, UD_R_DR3,
  UD_R_DR4, UD_R_DR5, UD_R_DR6, UD_R_DR7,
  UD_R_DR8, UD_R_DR9, UD_R_DR10,  UD_R_DR11,
  UD_R_DR12,  UD_R_DR13,  UD_R_DR14,  UD_R_DR15,

  /* mmx registers */
  UD_R_MM0, UD_R_MM1, UD_R_MM2, UD_R_MM3,
  UD_R_MM4, UD_R_MM5, UD_R_MM6, UD_R_MM7,

  /* x87 registers */
  UD_R_ST0, UD_R_ST1, UD_R_ST2, UD_R_ST3,
  UD_R_ST4, UD_R_ST5, UD_R_ST6, UD_R_ST7, 

  /* extended multimedia registers */
  UD_R_XMM0,  UD_R_XMM1,  UD_R_XMM2,  UD_R_XMM3,
  UD_R_XMM4,  UD_R_XMM5,  UD_R_XMM6,  UD_R_XMM7,
  UD_R_XMM8,  UD_R_XMM9,  UD_R_XMM10, UD_R_XMM11,
  UD_R_XMM12, UD_R_XMM13, UD_R_XMM14, UD_R_XMM15,

  /* 256B multimedia registers */
  UD_R_YMM0,  UD_R_YMM1,  UD_R_YMM2,  UD_R_YMM3,
  UD_R_YMM4,  UD_R_YMM5,  UD_R_YMM6,  UD_R_YMM7,
  UD_R_YMM8,  UD_R_YMM9,  UD_R_YMM10, UD_R_YMM11,
  UD_R_YMM12, UD_R_YMM13, UD_R_YMM14, UD_R_YMM15,

  UD_R_RIP,

  /* User-defined Types */
  UD_R_ADDR1, UD_R_ADDR2,

  /* Operand Types */
  UD_OP_REG,  UD_OP_MEM,  UD_OP_PTR,  UD_OP_IMM,  
  UD_OP_JIMM, UD_OP_CONST,
};

#include "itab.h"

union ud_lval {
  int8_t     sbyte;
  uint8_t    ubyte;
  int16_t    sword;
  uint16_t   uword;
  int32_t    sdword;
  uint32_t   udword;
  int64_t    sqword;
  uint64_t   uqword;
  struct {
    uint16_t seg;
    uint32_t off;
  } ptr;
};

/* -----------------------------------------------------------------------------
 * struct ud_operand - Disassembled instruction Operand.
 * -----------------------------------------------------------------------------
 */
struct ud_operand {
  enum ud_type    type;
  uint16_t        size;
  enum ud_type    base;
  enum ud_type    index;
  uint8_t         scale;  
  uint8_t         offset;
  union ud_lval   lval;
  /*
   * internal use only
   */
  uint64_t        _legacy; /* this will be removed in 1.8 */
  uint8_t         _oprcode;
};

/* -----------------------------------------------------------------------------
 * struct ud - The udis86 object.
 * -----------------------------------------------------------------------------
 */
struct ud
{
  /*
   * input buffering
   */
  int       (*inp_hook) (struct ud*);
#ifndef __UD_STANDALONE__
  FILE*     inp_file;
#endif
  const uint8_t* inp_buf;
  size_t    inp_buf_size;
  size_t    inp_buf_index;
  uint8_t   inp_curr;
  size_t    inp_ctr;
  uint8_t   inp_sess[64];
  int       inp_end;
  int       inp_peek;

  void      (*translator)(struct ud*);
  uint64_t  insn_offset;
  char      insn_hexcode[64];

  /*
   * Assembly output buffer
   */
  char     *asm_buf;
  size_t    asm_buf_size;
  size_t    asm_buf_fill;
  char      asm_buf_int[128];

  /*
   * Symbol resolver for use in the translation phase.
   */
  const char* (*sym_resolver)(struct ud*, uint64_t addr, int64_t *offset);

  uint8_t   dis_mode;
  uint64_t  pc;
  uint8_t   vendor;
  enum ud_mnemonic_code mnemonic;
  struct ud_operand operand[4];
  uint8_t   error;
  uint8_t   _rex;
  uint8_t   pfx_rex;
  uint8_t   pfx_seg;
  uint8_t   pfx_opr;
  uint8_t   pfx_adr;
  uint8_t   pfx_lock;
  uint8_t   pfx_str;
  uint8_t   pfx_rep;
  uint8_t   pfx_repe;
  uint8_t   pfx_repne;
  uint8_t   opr_mode;
  uint8_t   adr_mode;
  uint8_t   br_far;
  uint8_t   br_near;
  uint8_t   have_modrm;
  uint8_t   modrm;
  uint8_t   modrm_offset;
  uint8_t   vex_op;
  uint8_t   vex_b1;
  uint8_t   vex_b2;
  uint8_t   primary_opcode;
  void *    user_opaque_data;
  struct ud_itab_entry * itab_entry;
  struct ud_lookup_table_list_entry *le;
};

/* -----------------------------------------------------------------------------
 * Type-definitions
 * -----------------------------------------------------------------------------
 */
typedef enum ud_type          ud_type_t;
typedef enum ud_mnemonic_code ud_mnemonic_code_t;

typedef struct ud             ud_t;
typedef struct ud_operand     ud_operand_t;

#define UD_SYN_INTEL          ud_translate_intel
#define UD_SYN_ATT            ud_translate_att
#define UD_EOI                (-1)
#define UD_INP_CACHE_SZ       32
#define UD_VENDOR_AMD         0
#define UD_VENDOR_INTEL       1
#define UD_VENDOR_ANY         2

#endif

/*
vim: set ts=2 sw=2 expandtab
*/

```

`TDE/libudis86/udint.h`:

```h
/* udis86 - libudis86/udint.h -- definitions for internal use only
 * 
 * Copyright (c) 2002-2009 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef _UDINT_H_
#define _UDINT_H_

#include "types.h"

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */

#if defined(UD_DEBUG) && HAVE_ASSERT_H
# include <assert.h>
# define UD_ASSERT(_x) assert(_x)
#else
# define UD_ASSERT(_x)
#endif /* !HAVE_ASSERT_H */

#if defined(UD_DEBUG)
  #define UDERR(u, msg) \
    do { \
      (u)->error = 1; \
      fprintf(stderr, "decode-error: %s:%d: %s", \
              __FILE__, __LINE__, (msg)); \
    } while (0)
#else
  #define UDERR(u, m) \
    do { \
      (u)->error = 1; \
    } while (0)
#endif /* !LOGERR */

#define UD_RETURN_ON_ERROR(u) \
  do { \
    if ((u)->error != 0) { \
      return (u)->error; \
    } \
  } while (0)

#define UD_RETURN_WITH_ERROR(u, m) \
  do { \
    UDERR(u, m); \
    return (u)->error; \
  } while (0)

#ifndef __UD_STANDALONE__
# define UD_NON_STANDALONE(x) x
#else
# define UD_NON_STANDALONE(x)
#endif

/* printf formatting int64 specifier */
#ifdef FMT64
# undef FMT64
#endif
#if defined(_MSC_VER) || defined(__BORLANDC__)
# define FMT64 "I64"
#else
# if defined(__APPLE__)
#  define FMT64 "ll"
# elif defined(__amd64__) || defined(__x86_64__)
#  define FMT64 "l"
# else 
#  define FMT64 "ll"
# endif /* !x64 */
#endif

/* define an inline macro */
#if defined(_MSC_VER) || defined(__BORLANDC__)
# define UD_INLINE __inline /* MS Visual Studio requires __inline
                               instead of inline for C code */
#else
# define UD_INLINE inline
#endif

#endif /* _UDINT_H_ */

```

`TDE/libudis86/udis86.c`:

```c
/* udis86 - libudis86/udis86.c
 *
 * Copyright (c) 2002-2013 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "udint.h"
#include "extern.h"
#include "decode.h"

#if !defined(__UD_STANDALONE__)
# if HAVE_STRING_H
#  include <string.h>
# endif
#endif /* !__UD_STANDALONE__ */

static void ud_inp_init(struct ud *u);

/* =============================================================================
 * ud_init
 *    Initializes ud_t object.
 * =============================================================================
 */
extern void 
ud_init(struct ud* u)
{
  memset((void*)u, 0, sizeof(struct ud));
  ud_set_mode(u, 16);
  u->mnemonic = UD_Iinvalid;
  ud_set_pc(u, 0);
#ifndef __UD_STANDALONE__
  ud_set_input_file(u, stdin);
#endif /* __UD_STANDALONE__ */

  ud_set_asm_buffer(u, u->asm_buf_int, sizeof(u->asm_buf_int));
}

/* =============================================================================
 * ud_disassemble
 *    Disassembles one instruction and returns the number of 
 *    bytes disassembled. A zero means end of disassembly.
 * =============================================================================
 */
extern unsigned int
ud_disassemble(struct ud* u)
{
  int len;
  if (u->inp_end) {
    return 0;
  }
  if ((len = ud_decode(u)) > 0) {
    if (u->translator != NULL) {
      u->asm_buf[0] = '\0';
      u->translator(u);
    }
  }
  return len;
}


/* =============================================================================
 * ud_set_mode() - Set Disassemly Mode.
 * =============================================================================
 */
extern void 
ud_set_mode(struct ud* u, uint8_t m)
{
  switch(m) {
  case 16:
  case 32:
  case 64: u->dis_mode = m ; return;
  default: u->dis_mode = 16; return;
  }
}

/* =============================================================================
 * ud_set_vendor() - Set vendor.
 * =============================================================================
 */
extern void 
ud_set_vendor(struct ud* u, unsigned v)
{
  switch(v) {
  case UD_VENDOR_INTEL:
    u->vendor = v;
    break;
  case UD_VENDOR_ANY:
    u->vendor = v;
    break;
  default:
    u->vendor = UD_VENDOR_AMD;
  }
}

/* =============================================================================
 * ud_set_pc() - Sets code origin. 
 * =============================================================================
 */
extern void 
ud_set_pc(struct ud* u, uint64_t o)
{
  u->pc = o;
}

/* =============================================================================
 * ud_set_syntax() - Sets the output syntax.
 * =============================================================================
 */
extern void 
ud_set_syntax(struct ud* u, void (*t)(struct ud*))
{
  u->translator = t;
}

/* =============================================================================
 * ud_insn() - returns the disassembled instruction
 * =============================================================================
 */
const char* 
ud_insn_asm(const struct ud* u) 
{
  return u->asm_buf;
}

/* =============================================================================
 * ud_insn_offset() - Returns the offset.
 * =============================================================================
 */
uint64_t
ud_insn_off(const struct ud* u) 
{
  return u->insn_offset;
}


/* =============================================================================
 * ud_insn_hex() - Returns hex form of disassembled instruction.
 * =============================================================================
 */
const char* 
ud_insn_hex(struct ud* u) 
{
  u->insn_hexcode[0] = 0;
  if (!u->error) {
    unsigned int i;
    const unsigned char *src_ptr = ud_insn_ptr(u);
    char* src_hex;
    src_hex = (char*) u->insn_hexcode;
    /* for each byte used to decode instruction */
    for (i = 0; i < ud_insn_len(u) && i < sizeof(u->insn_hexcode) / 2;
         ++i, ++src_ptr) {
      sprintf(src_hex, "%02x", *src_ptr & 0xFF);
      src_hex += 2;
    }
  }
  return u->insn_hexcode;
}


/* =============================================================================
 * ud_insn_ptr
 *    Returns a pointer to buffer containing the bytes that were
 *    disassembled.
 * =============================================================================
 */
extern const uint8_t* 
ud_insn_ptr(const struct ud* u) 
{
  return (u->inp_buf == NULL) ? 
            u->inp_sess : u->inp_buf + (u->inp_buf_index - u->inp_ctr);
}


/* =============================================================================
 * ud_insn_len
 *    Returns the count of bytes disassembled.
 * =============================================================================
 */
extern unsigned int 
ud_insn_len(const struct ud* u) 
{
  return u->inp_ctr;
}


/* =============================================================================
 * ud_insn_get_opr
 *    Return the operand struct representing the nth operand of
 *    the currently disassembled instruction. Returns NULL if
 *    there's no such operand.
 * =============================================================================
 */
const struct ud_operand*
ud_insn_opr(const struct ud *u, unsigned int n)
{
  if (n > 3 || u->operand[n].type == UD_NONE) {
    return NULL; 
  } else {
    return &u->operand[n];
  }
}


/* =============================================================================
 * ud_opr_is_sreg
 *    Returns non-zero if the given operand is of a segment register type.
 * =============================================================================
 */
int
ud_opr_is_sreg(const struct ud_operand *opr)
{
  return opr->type == UD_OP_REG && 
         opr->base >= UD_R_ES   &&
         opr->base <= UD_R_GS;
}


/* =============================================================================
 * ud_opr_is_sreg
 *    Returns non-zero if the given operand is of a general purpose
 *    register type.
 * =============================================================================
 */
int
ud_opr_is_gpr(const struct ud_operand *opr)
{
  return opr->type == UD_OP_REG && 
         opr->base >= UD_R_AL   &&
         opr->base <= UD_R_R15;
}


/* =============================================================================
 * ud_set_user_opaque_data
 * ud_get_user_opaque_data
 *    Get/set user opaqute data pointer
 * =============================================================================
 */
void
ud_set_user_opaque_data(struct ud * u, void* opaque)
{
  u->user_opaque_data = opaque;
}

void*
ud_get_user_opaque_data(const struct ud *u)
{
  return u->user_opaque_data;
}


/* =============================================================================
 * ud_set_asm_buffer
 *    Allow the user to set an assembler output buffer. If `buf` is NULL,
 *    we switch back to the internal buffer.
 * =============================================================================
 */
void
ud_set_asm_buffer(struct ud *u, char *buf, size_t size)
{
  if (buf == NULL) {
    ud_set_asm_buffer(u, u->asm_buf_int, sizeof(u->asm_buf_int));
  } else {
    u->asm_buf = buf;
    u->asm_buf_size = size;
  }
}


/* =============================================================================
 * ud_set_sym_resolver
 *    Set symbol resolver for relative targets used in the translation
 *    phase.
 *
 *    The resolver is a function that takes a uint64_t address and returns a
 *    symbolic name for the that address. The function also takes a second
 *    argument pointing to an integer that the client can optionally set to a
 *    non-zero value for offsetted targets. (symbol+offset) The function may
 *    also return NULL, in which case the translator only prints the target
 *    address.
 *
 *    The function pointer maybe NULL which resets symbol resolution.
 * =============================================================================
 */
void
ud_set_sym_resolver(struct ud *u, const char* (*resolver)(struct ud*, 
                                                          uint64_t addr,
                                                          int64_t *offset))
{
  u->sym_resolver = resolver;
}


/* =============================================================================
 * ud_insn_mnemonic
 *    Return the current instruction mnemonic.
 * =============================================================================
 */
enum ud_mnemonic_code
ud_insn_mnemonic(const struct ud *u)
{
  return u->mnemonic;
}


/* =============================================================================
 * ud_lookup_mnemonic
 *    Looks up mnemonic code in the mnemonic string table.
 *    Returns NULL if the mnemonic code is invalid.
 * =============================================================================
 */
const char*
ud_lookup_mnemonic(enum ud_mnemonic_code c)
{
  if (c < UD_MAX_MNEMONIC_CODE) {
    return ud_mnemonics_str[c];
  } else {
    return NULL;
  }
}


/* 
 * ud_inp_init
 *    Initializes the input system.
 */
static void
ud_inp_init(struct ud *u)
{
  u->inp_hook      = NULL;
  u->inp_buf       = NULL;
  u->inp_buf_size  = 0;
  u->inp_buf_index = 0;
  u->inp_curr      = 0;
  u->inp_ctr       = 0;
  u->inp_end       = 0;
  u->inp_peek      = UD_EOI;
  UD_NON_STANDALONE(u->inp_file = NULL);
}


/* =============================================================================
 * ud_inp_set_hook
 *    Sets input hook.
 * =============================================================================
 */
void 
ud_set_input_hook(register struct ud* u, int (*hook)(struct ud*))
{
  ud_inp_init(u);
  u->inp_hook = hook;
}

/* =============================================================================
 * ud_inp_set_buffer
 *    Set buffer as input.
 * =============================================================================
 */
void 
ud_set_input_buffer(register struct ud* u, const uint8_t* buf, size_t len)
{
  ud_inp_init(u);
  u->inp_buf = buf;
  u->inp_buf_size = len;
  u->inp_buf_index = 0;
}


#ifndef __UD_STANDALONE__
/* =============================================================================
 * ud_input_set_file
 *    Set FILE as input.
 * =============================================================================
 */
static int 
inp_file_hook(struct ud* u)
{
  return fgetc(u->inp_file);
}

void 
ud_set_input_file(register struct ud* u, FILE* f)
{
  ud_inp_init(u);
  u->inp_hook = inp_file_hook;
  u->inp_file = f;
}
#endif /* __UD_STANDALONE__ */


/* =============================================================================
 * ud_input_skip
 *    Skip n input bytes.
 * ============================================================================
 */
void 
ud_input_skip(struct ud* u, size_t n)
{
  if (u->inp_end) {
    return;
  }
  if (u->inp_buf == NULL) {
    while (n--) {
      int c = u->inp_hook(u);
      if (c == UD_EOI) {
        goto eoi;
      }
    }
    return;
  } else {
    if (n > u->inp_buf_size ||
        u->inp_buf_index > u->inp_buf_size - n) {
      u->inp_buf_index = u->inp_buf_size; 
      goto eoi;
    }
    u->inp_buf_index += n; 
    return;
  }
eoi:
  u->inp_end = 1;
  UDERR(u, "cannot skip, eoi received\b");
  return;
}


/* =============================================================================
 * ud_input_end
 *    Returns non-zero on end-of-input.
 * =============================================================================
 */
int
ud_input_end(const struct ud *u)
{
  return u->inp_end;
}

/* vim:set ts=2 sw=2 expandtab */

```

`TDE/main.cpp`:

```cpp
#include "oreans_entry.hpp"
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <allins.hpp>

int __stdcall IDAPInitialize() {
    if (inf.filetype != f_PE) {
        warning("Only supports PE binaries.");
        return PLUGIN_SKIP;
    } else if (strncmp(inf.procName, "metapc", 8) != 0) {
        warning("Only supports x86 (for now).");
        return PLUGIN_SKIP;
    }
    return PLUGIN_KEEP;
}

void __stdcall IDAPTerminate() {
    /* There's nothing to clean up here */
}

void __stdcall IDAPRun(int arg) {
    ea_t address = get_screen_ea();
    msg("rying to devirtualize at address %08X...\n", address);
    decode_insn(address);

    if (cmd.itype != NN_jmp && cmd.itype != NN_call)
        msg("Instruction not an immediate jump or call.\n", address);
    else if (!cmd.Operands[0].addr)
        msg("Instruction doesn't point to an address.\n", address);
    else if (!isCode(get_flags_novalue(cmd.Operands[0].addr)))
        msg("The selected function entry is not executable code.");
    else if (!oreans_entry::get().tryDevirtualize(address, cmd.Operands[0].addr))
        msg("Failed to devirtualize function at %08X.\n", address);
    else
        msg("Successfully devirtualized function at %08X.\n", address);
}

plugin_t PLUGIN = {
    IDP_INTERFACE_VERSION,     // IDA version plug-in is written for
    0,                          // Flags (see below)
    IDAPInitialize,             // Initialisation function
    IDAPTerminate,              // Clean-up function
    IDAPRun,                    // Main plug-in body
    "This is my test plug-in",  // Comment – unused
    "CodeDevirtualizer",        // Help – unused
    "CodeDevirtualizer",        // Plug-in name shown in Edit->Plugins menu
    "Alt-F"                     // Hot key to run the plug-in
};

```

`TDE/oreans_base.cpp`:

```cpp
#include "oreans_base.hpp"

bool oreans_base::is_signature(instruction_container& vm_entrance)
{
	/* Placeholder for virtual function */
	return false;
}

bool oreans_base::devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions)
{
	/* Placeholder for virtual function */
	return false;
}
```

`TDE/oreans_base.hpp`:

```hpp
#ifndef OREANS_BASE_HPP_
#define OREANS_BASE_HPP_

#include "instruction_container.hpp"

class oreans_base
{
public:
	virtual bool is_signature(instruction_container& vm_entrance);
	virtual bool devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions);
};

#endif
```

`TDE/oreans_entry.cpp`:

```cpp
#include "oreans_entry.hpp"
#include <bytes.hpp>

#define VM_ENTRANCE_BUFFER_SIZE 512

bool OreansEntry::tryDevirtualize(uint32_t vmFunction, uint32_t vmEntry) {
    unsigned char vmEntranceBuffer[VM_ENTRANCE_BUFFER_SIZE];
    get_many_bytes(vmEntry, vmEntranceBuffer, sizeof(vmEntranceBuffer));

    InstructionContainer vmEntrance;
    if (!decodeVmEntrance(vmEntranceBuffer, vmEntry, vmEntrance))
        return false;

    if (vmEntrance.size() == 2 &&
        vmEntrance.at(0).isPushImmediate() && vmEntrance.at(0).isOperandType(0, UD_OP_IMM, UD_SIZE_DWORD) &&
        vmEntrance.at(1).isJumpImmediate()) {
        if (vmRisc.isSignature(vmEntrance))
            return vmRisc.devirtualize(vmFunction, vmEntry, vmEntrance);
        else if (vmCisc.isSignature(vmEntrance))
            return vmCisc.devirtualize(vmFunction, vmEntry, vmEntrance);
    } else if (vmEntrance.size() == 3 &&
               vmEntrance.at(0).isPushImmediate() && vmEntrance.at(0).isOperandType(0, UD_OP_IMM) &&
               vmEntrance.at(1).isPushImmediate() && vmEntrance.at(1).isOperandType(0, UD_OP_IMM) &&
               vmEntrance.at(2).isJumpImmediate()) {
        qstrvec_t virtualMachines = {"TIGER", "FISH", "PUMA", "SHARK"};
        static int32_t vmTypeSelection = 0;
        return showVirtualMachineDialog(vmFunction, vmEntry, vmEntrance, virtualMachines, vmTypeSelection);
    } else {
        qstrvec_t virtualMachines = {"TIGER", "FISH", "PUMA", "SHARK", "DOLPHIN", "EAGLE"};
        static int32_t vmTypeSelection = 0;
        return showVirtualMachineDialog(vmFunction, vmEntry, vmEntrance, virtualMachines, vmTypeSelection);
    }
    return false;
}

bool OreansEntry::showVirtualMachineDialog(uint32_t vmFunction, uint32_t vmEntry, InstructionContainer& vmInstructions, qstrvec_t& virtualMachines, int32_t& vmTypeSelection) {
    if (AskUsingForm_c("Select Virtual Machine\nAuto-analysis failed to determine VM-type for address %M.\n<Please specify VM architecture:b:0:::>",
        reinterpret_cast<ea_t*>(&vmFunction), &virtualMachines, &vmTypeSelection) == ASKBTN_YES) {
        switch (vmTypeSelection) {
            case 0:
                msg("TIGER machine identified by user.\n");
                return vmTiger.devirtualize(vmFunction, vmEntry, vmInstructions);
            case 1:
                msg("FISH machine identified by user.\n");
                return vmFish.devirtualize(vmFunction, vmEntry, vmInstructions);
            case 2:
                msg("PUMA machine identified by user.\n");
                return vmPuma.devirtualize(vmFunction, vmEntry, vmInstructions);
            case 3:
                msg("SHARK machine identified by user.\n");
                return vmShark.devirtualize(vmFunction, vmEntry, vmInstructions);
            case 4:
                msg("DOLPHIN machine identified by user.\n");
                return vmDolphin.devirtualize(vmFunction, vmEntry, vmInstructions);
            case 5:
                msg("EAGLE machine identified by user.\n");
                return vmEagle.devirtualize(vmFunction, vmEntry, vmInstructions);
            default:
                break;
        }
    } else {
        msg("No virtual machine selected.\n");
    }
    return false;
}

bool OreansEntry::decodeVmEntrance(uint8_t* buffer, uint32_t vmEntry, InstructionContainer& vmEntrance) {
    ud_instruction instruction(vmEntry);
    instruction.setInput(buffer, VM_ENTRANCE_BUFFER_SIZE);

    do {
        if (!vmEntrance.decodeAssembly(instruction))
            return false;
        if (instruction.isMnemonicJumpConditional()) {
            if (instruction.isOperandTypeNot(0, UD_OP_JIMM) || instruction.hasOperandData(0)) {
                // if (tryEvaluateBranch(vmEntrance, instruction, vmEntry + vmOffset))
                //     vmOffset += instruction.operands[0].data.dword;
            }
        }
    } while (instruction.isMnemonicNot(UD_Ijmp));

    vmEntrance.deobfuscate();
    return true;
}

```

`TDE/oreans_entry.hpp`:

```hpp
#ifndef OREANS_ENTRY_HPP_
#define OREANS_ENTRY_HPP_

#include "instruction_container.hpp"

#include "cisc.hpp"
#include "risc.hpp"

#include "fish.hpp"
#include "tiger.hpp"
#include "dolphin.hpp"

#include "puma.hpp"
#include "shark.hpp"
#include "eagle.hpp"

#include <idp.hpp>

class oreans_entry
{
public:
	static oreans_entry& get()
	{
		static oreans_entry instance;
		return instance;
	}

public:
	bool try_devirtualize(uint32_t vm_function, uint32_t vm_entry);
	bool show_virtual_machine_dialog(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions, qstrvec_t& virtual_machines, int32_t& vm_type_selection);

private:
	bool decode_vm_entrance(uint8_t* buffer, uint32_t vm_entry, instruction_container& vm_entrance);

private:
	cisc vm_cisc;
	risc vm_risc;

	fish vm_fish;
	tiger vm_tiger;
	dolphin vm_dolphin;

	puma vm_puma;
	shark vm_shark;
	eagle vm_eagle;
};

#endif
```

`TDE/puma.cpp`:

```cpp
#include "puma.hpp"

#include <idp.hpp>

bool puma::is_signature(instruction_container& vm_entrance)
{
	msg("[CodeDevirtualizer] PUMA machine identified.\n");
	return true;
}

bool puma::devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions)
{
	msg("[CodeDevirtualizer] PUMA machines are currently not supported.\n");
	return false;
}
```

`TDE/puma.hpp`:

```hpp
#ifndef PUMA_HPP_
#define PUMA_HPP_

#include "wild_hybrid_base.hpp"

#include "tiger.hpp"
#include "fish.hpp"

class puma : public wild_hybrid_base<tiger, fish>
{
public:
	bool is_signature(instruction_container& vm_entrance);
	bool devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions);
};

/*

*/

#endif
```

`TDE/risc.cpp`:

```cpp
#include "risc.hpp"

#include <idp.hpp>
#include <allins.hpp>

#define RISC_VM_SIGNATURE_BUFFER_SIZE 512

bool risc::is_signature(instruction_container& vm_entrance)
{
	decode_insn(vm_entrance.at(1).get_address<uint32_t>());

	if (cmd.itype == NN_jmp && cmd.Operands[0].addr != 0)
	{
		unsigned char risc_vm_signature_buffer[RISC_VM_SIGNATURE_BUFFER_SIZE];
		get_many_bytes(cmd.Operands[0].addr, risc_vm_signature_buffer, sizeof(risc_vm_signature_buffer));
			
		ud_instruction instruction(cmd.Operands[0].addr);
		instruction.set_input(risc_vm_signature_buffer, sizeof(risc_vm_signature_buffer));

		instruction_container instructions;

		do
		{
			if (!instructions.decode_assembly(instruction))
				return false;

			if (instruction.is_mnemonic(UD_Inop))
				msg("[CodeDevirtualizer] RISC machine identified. Scanning type...\n");
			else if (instruction.is_mnemonic(UD_Icall))
			{
				/* 0: call unknown ptr [mem] */
				if (instruction.is_operand_type(0, UD_OP_MEM))
				{
					msg("[CodeDevirtualizer] RISC machine identified as RISC-64.\n");
					return true;
				}
				/* 0: call reg */
				else if (instruction.is_operand_type(0, UD_OP_REG))
				{
					msg("[CodeDevirtualizer] RISC machine identified as RISC-128.\n");
					return true;
				}
			}
		}
		while (instruction.is_mnemonic_not(UD_Ijmp));
	}
	
	return false;
}

bool risc::devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_entrance)
{
	msg("[CodeDevirtualizer] RISC machines are currently not supported.\n");
	return false;
}
```

`TDE/risc.hpp`:

```hpp
#ifndef RISC_HPP_
#define RISC_HPP_

#include "oreans_base.hpp"

class risc : public oreans_base
{
public:
	bool is_signature(instruction_container& vm_entrance);
	bool devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_entrance);
};

/* 
	Machine: RISC32 (deprecated)

	[Main Machine Info]
	Name = (deprecated)
	MachineId =  0x00000200
	MachineSignature = 0x1ADCC45F
	ProductSupport = WinLicense, Themida
	FileVersionEncoded = 0x12872829
	HardwareEncryption = Not available

	[Main Machine Architecture]
	Name = RISC32
	Bits = 32
	MaxCPUs = 1
	Emulates = IA32

	[Main Machine Stats]
	MemoryUsage = 1000 KB
	Speed = 15
	Complexity = 40
	ScoreMultiplier = 1
*/

#endif
```

`TDE/segment_copy.cpp`:

```cpp
#include "segment_copy.hpp"
#include <idp.hpp>
#include <segment.hpp>

SegmentCopy::SegmentCopy(uint32_t startAddress, uint32_t endAddress)
    : segmentInfo(std::make_pair(startAddress, endAddress)) {
    segmentData.resize(endAddress - startAddress);
    get_many_bytes(startAddress, &segmentData[0], segmentData.size());
}

uint32_t SegmentCopy::start() const {
    return segmentInfo.first;
}

uint32_t SegmentCopy::end() const {
    return segmentInfo.second;
}

uint32_t SegmentCopy::size() const {
    return end() - start();
}

uint8_t* SegmentCopy::data(uint32_t offset) {
    return segmentData.data() + offset;
}

```

`TDE/segment_copy.hpp`:

```hpp
#ifndef SEGMENT_COPY_HPP_
#define SEGMENT_COPY_HPP_

#include <stdint.h>
#include <vector>

class segment_copy
{
public:
	segment_copy(uint32_t start_address, uint32_t end_address);

	uint32_t start() const;
	uint32_t end() const;

	uint32_t size() const;
	uint8_t* data(uint32_t offset = 0);

private:
	std::pair<uint32_t, uint32_t> segment_info;
	std::vector<uint8_t> segment_data;
};

#endif
```

`TDE/segment_manager.cpp`:

```cpp
#include "segment_manager.hpp"
#include <idp.hpp>
#include <segment.hpp>

bool SegmentManager::makeSegmentCopy(uint32_t address, std::size_t index) {
    for (int32_t segIndex = 0, segCount = get_segm_qty(); segIndex < segCount; ++segIndex) {
        segment_t* segment = getnseg(segIndex);
        if (address >= segment->startEA && address < segment->endEA) {
            if (index < vmSegments.size())
                vmSegments.erase(vmSegments.begin() + index);
            vmSegments.insert(vmSegments.begin() + index, SegmentCopy(segment->startEA, segment->endEA));
            return true;
        }
    }
    return false;
}

bool SegmentManager::isSegment(uint32_t address, std::size_t index) {
    if (index >= vmSegments.size())
        return false;
    uint32_t start = vmSegments.at(index).start();
    uint32_t end = vmSegments.at(index).end();
    return (address >= start && address < end);
}

bool SegmentManager::inSegmentRange(uint32_t address, uint32_t offset, std::size_t index) {
    if (index >= vmSegments.size())
        return false;
    uint32_t start = vmSegments.at(index).start();
    uint32_t size = vmSegments.at(index).size();
    return ((address - start) + offset) < size;
}

std::pair<uint8_t*, uint32_t> SegmentManager::toSegment(uint32_t address, std::size_t index) {
    return std::make_pair(toSegmentBase(address, index), toSegmentSize(address, index));
}

uint8_t* SegmentManager::toSegmentBase(uint32_t address, std::size_t index) {
    if (!isSegment(address, index))
        return nullptr;
    uint32_t start = vmSegments.at(index).start();
    return vmSegments.at(index).data(address - start);
}

uint32_t SegmentManager::toSegmentSize(uint32_t address, std::size_t index) {
    if (!isSegment(address, index))
        return 0;
    uint32_t start = vmSegments.at(index).start();
    return (vmSegments.at(index).size() - (address - start));
}

```

`TDE/segment_manager.hpp`:

```hpp
#ifndef SEGMENT_MANAGER_HPP_
#define SEGMENT_MANAGER_HPP_

#include "segment_copy.hpp"

class segment_manager
{
public:
	bool make_segment_copy(uint32_t address, std::size_t index = 0);

	bool is_segment(uint32_t address, std::size_t index = 0);
	bool in_segment_range(uint32_t address, uint32_t offset, std::size_t index = 0);
	
	std::pair<uint8_t*, uint32_t> to_segment(uint32_t address, std::size_t index = 0);
	
private:
	uint8_t* to_segment_base(uint32_t address, std::size_t index = 0);
	uint32_t to_segment_size(uint32_t address, std::size_t index = 0);

private:
	std::vector<segment_copy> vm_segments;
};

#endif
```

`TDE/shark.cpp`:

```cpp
#include "shark.hpp"

#include <idp.hpp>

bool shark::is_signature(instruction_container& vm_entrance)
{
	msg("[CodeDevirtualizer] SHARK machine identified.\n");
	return true;
}

bool shark::devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions)
{
	msg("[CodeDevirtualizer] SHARK machines are currently not supported.\n");
	return false;
}
```

`TDE/shark.hpp`:

```hpp
#ifndef SHARK_HPP_
#define SHARK_HPP_

#include "wild_hybrid_base.hpp"

#include "fish.hpp"
#include "tiger.hpp"

class shark : public wild_hybrid_base<fish, tiger>
{
public:
	bool is_signature(instruction_container& vm_entrance);
	bool devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions);
};

/*

*/

#endif
```

`TDE/tiger.cpp`:

```cpp
#include "tiger.hpp"

#include <idp.hpp>

tiger::tiger()
	: wild(this->context)
{

}

bool tiger::is_signature(instruction_container& vm_entrance)
{
	msg("[CodeDevirtualizer] TIGER machine identified.\n");
	return true;
}

bool tiger::parse_initial_handler(instruction_container& instructions)
{
	static const ud_size operand_sizes[] = 
	{
		UD_SIZE_DWORD,	UD_SIZE_DWORD,	UD_SIZE_DWORD,	UD_SIZE_DWORD,
		UD_SIZE_DWORD,	UD_SIZE_WORD,	UD_SIZE_WORD,	UD_SIZE_WORD,
		UD_SIZE_DWORD,	UD_SIZE_DWORD
	};
	
	if (instructions.size() < _countof(operand_sizes))
		return false;

	for (std::size_t i = 0; i < _countof(operand_sizes); i++)
	{
		/* 0: mov [ebp+xx],0x00 */
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_MEM, operand_sizes[i]) &&
			instructions.at(i).is_operand_base(0, UD_R_EBP) &&
			instructions.at(i).has_operand_index_not(0) &&
			instructions.at(i).has_operand_scale_not(0) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM) &&
			instructions.at(i).is_operand_data(1, 0))
		{
			this->context.add_key(instructions.at(i).get_operand_data(0));
		}
		else
		{
			return false;
		}
	}
	
	return true;
}

bool tiger::update_argument_data()
{
	return true;

	if (!this->context.tiger_operands[0].is_found ||
		!this->context.tiger_operands[1].is_found)
	{
		return false;
	}
	
	for (std::size_t i = 0; i < this->handlers.size(); i++)
	{
		if (!this->handlers.at(i).update_argument_data(this->context))
			return false;
	}

	return true;
}
```

`TDE/tiger.hpp`:

```hpp
#ifndef TIGER_HPP_
#define TIGER_HPP_

#include "wild.hpp"

#include "tiger_context.hpp"
#include "tiger_handler.hpp"

class tiger : public wild<tiger_handler>
{
public:
	tiger();

public:
	bool is_signature(instruction_container& vm_entrance);

private:
	bool parse_initial_handler(instruction_container& instructions);
	
private:
	bool update_argument_data();

private:
	tiger_context context;
};

/*
	Machine: TIGER32 (Black/Red/White)                             

	[Main Machine Info]
	Name = (Black/Red/White)
	MachineId =  0x3E34470A/0x3E344705/0x3E344701
	MachineSignature = 0xDD82E451/0x876FB1C7/0xDA097AE9
	ProductSupport = WinLicense, Virtualizer, Themida
	FileVersionEncoded = 0x12872829
	HardwareEncryption = Not available

	[Main Machine Architecture]
	Name = TIGER32
	Bits = 32
	MaxCPUs = 8
	Emulates = IA32

	[Main Machine Stats]
	MemoryUsage = 1650/1150/550 KB
	Speed = 92/95/96
	Complexity = 25/21/15
	ScoreMultiplier = 1/20/1

	[Main Machine Processor]
	RelocateRegs = Yes
	RelocateStages = Yes
	OpcodePermutation = Yes
	RelocateHandlers = Yes
	JoinUndefinedOpcodes = No
	AllowAvidFields = Yes
	ExpandedInstructionSet = Yes
	MergeStages = Yes
	EnableRevirtualization = Yes
	EnableJoinHandlers = Yes
	EnableStageGarbage = Yes
	SmartInstructionsRelocation = Yes
	EnableHandlerTimes = Yes
	EnableBreakPoints = No
	EnableDebugMode = No
	EnableInterruptTrace = No
	EnableFakeJumps = No
	EnableFakeConditionalJumps = No
	PermutateHandlers = No
	MutateHandlers = No

	[Specific Opcodes Customization]
	Group1Mnemonics = ADD, MOV, SUB, AND, XOR, OR, POP, PUSH
	Group1Garbage = [5/5/3]
	Group1Avid = [5/2/1..15/6/3]
	Group1Times = [2/2/1..6/5/3]

	Group2Mnemonics = ROL, ROR, RCL, SHL, RCR, SHR, MOVZX, MOVSX
	Group2Garbage = [4/3/2]
	Group2Avid = [4/2/1..8/4/2]
	Group2Times = [1..4/3/2]

	Group3Mnemonics = CMP, TEST, DEC, INC, NOT, NEG
	Group3Garbage = [5/4/2]
	Group3Avid = [4/2/1..10/5/3]
	Group3Times = [1..4/4/2]

	Group4Mnemonics = IMUL, LODSB, LODSW, LODSD, SCASB, SCASW, SCASD, CMPSB, CMPSW, CMPSD, STOSB, STOSW, STOSD, MOVSB, MOVSW, MOVSD, PUSHFD, POPFD
	Group4Garbage = [4/2/2]
	Group4Avid = [4/2/1..10/5/3]
	Group4Times = [1..3/2/2]

	Group5Mnemonics = JCC_INSIDE, JUMP_OUTSIDE, JUMP_INSIDE, CALL, UNDEF, RET, JCC_OUTSIDE
	Group5Garbage = [5/5/3]
	Group5Avid = [0..0]
	Group5Times = [3/2/1..7/5/3]
*/

#endif
```

`TDE/tiger_context.cpp`:

```cpp
#include "tiger_context.hpp"

void tiger_context::clear()
{
	this->wild_context::clear();

	memset(this->tiger_operands, 0, sizeof(this->tiger_operands));
}
```

`TDE/tiger_context.hpp`:

```hpp
#ifndef TIGER_CONTEXT_HPP_
#define TIGER_CONTEXT_HPP_

#include "wild_context.hpp"

class tiger_context : public wild_context
{
	typedef struct tiger_operand
	{
		bool is_found;			// idk1/idk2
		uint16_t operand_data;	// idk3/idk5
		uint16_t operand_info;	// idk4/idk6
	} tiger_operand;

public:
	void clear();

public:
	tiger_operand tiger_operands[2];
};

#endif
```

`TDE/tiger_handler.cpp`:

```cpp
#include "tiger_handler.hpp"
#include "tiger_handler_types.hpp"

#include "instruction_emulator.hpp"

#include <idp.hpp>

/*
Imagebase:		00400000
Context:		0041D3AF
Imagebase o:	00000027
PImagebase o:	00000047
PImagebase:		00400000
Opcode o:		0000008F
HTable:			004A8CED
HTable o:		0000000B
HTable count:	0000033A

0000000000445330 mov dword [ebp+0x7a], 0x0
000000000044533e mov dword [ebp+0xf], 0x0
000000000044534c mov dword [ebp+0x21], 0x0
000000000044535a mov dword [ebp+0x83], 0x0
0000000000445368 mov dword [ebp+0x6d], 0x0
0000000000445376 mov word [ebp+0x32], 0x0
0000000000445382 mov word [ebp+0x2f], 0x0
000000000044538f mov word [ebp+0x38], 0x0
000000000044539c mov dword [ebp+0x1d], 0x0
00000000004453aa mov dword [ebp+0x17], 0x0
*/

tiger_handler::tiger_handler(uint16_t index)
	: wild_handler(index)
{
	for (uint32_t i = 0; i < _countof(this->operands); i++)
	{
		this->operands[i].type = UD_NONE;
		this->operands[i].size = UD_SIZE_NONE;
		this->operands[i].index = static_cast<std::size_t>(-1);
	}
}

bool tiger_handler::update_argument_data(tiger_context& context)
{
	if (this->id != WILD_HANDLER_INVALID)
	{
		
	}

	return true;
}

bool tiger_handler::map_handler_specific(instruction_container& instructions, wild_context& context)
{
	try
	{
		return this->map_handler_tiger(instructions, dynamic_cast<tiger_context&>(context));
	}
	catch (std::bad_cast const& e)
	{
		msg("[CodeDevirtualizer] Exception: %s\n", e.what());
	}

	return false;
}

bool tiger_handler::map_handler_tiger(instruction_container& instructions, tiger_context& context)
{
	if (this->map_handler_call(instructions, context) ||
		this->map_handler_nop(instructions, context) ||
		this->map_handler_push(instructions, context) ||
		this->map_handler_pop(instructions, context) ||
		this->map_handler_inc(instructions, context) ||
		this->map_handler_dec(instructions, context) ||
		this->map_handler_not(instructions, context) ||
		this->map_handler_neg(instructions, context) ||
		this->map_handler_mov(instructions, context) ||
		this->map_handler_movsx(instructions, context) ||
		this->map_handler_movzx(instructions, context) ||
		this->map_handler_add(instructions, context) ||
		this->map_handler_sub(instructions, context) ||
		this->map_handler_and(instructions, context) ||
		this->map_handler_xor(instructions, context) ||
		this->map_handler_or(instructions, context) ||
		this->map_handler_shl(instructions, context) ||
		this->map_handler_shr(instructions, context) ||
		this->map_handler_rcl(instructions, context) ||
		this->map_handler_rcr(instructions, context) ||
		this->map_handler_rol(instructions, context) ||
		this->map_handler_ror(instructions, context) ||
		this->map_handler_cmp(instructions, context) ||
		this->map_handler_test(instructions, context) ||
		this->map_handler_imul(instructions, context))
	{
		if (this->decrypt_tiger_data(instructions, context))
			return true;
	}
	
	//msg("[CodeDevirtualizer] Failed to either map- or decrypt handler data for handler %04X (%04X) of type tiger.\n", this->index, this->id);
	return true;
}

bool tiger_handler::map_handler_call(instruction_container& instructions, tiger_context& context)
{
	if (instructions.back().is_mnemonic(UD_Iret))
	{
		this->operands[0].type = UD_NONE;

		if (instructions.bounds(3) &&
			instructions.at(2).is_operand_size(1, UD_SIZE_DWORD) &&
			instructions.at(3).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
			instructions.at(3).is_operand_base(1, UD_R_EBP) &&
			instructions.at(3).is_operand_data(1, context.vm_imagebase_offset))
		{
			this->operands[0].type = UD_OP_IMM;
		}
		else if (instructions.bounds(4) &&
			instructions.at(4).is_mnemonic(UD_Imov) &&
			instructions.at(4).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD))
		{
			if (instructions.bounds(5) &&
				instructions.at(5).is_mnemonic(UD_Imov) &&
				instructions.at(5).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
				instructions.at(5).is_operand_base(1, instructions.at(4), 0))
			{
				this->operands[0].type = UD_OP_MEM;
			}
			else
			{
				this->operands[0].type = UD_OP_REG;
			}
		}

		this->id = WILD_HANDLER_CALL;
		return true;
	}

	return false;
}

bool tiger_handler::map_handler_nop(instruction_container& instructions, tiger_context& context)
{
	if (this->flow_read_index == 0)
	{
		this->id = TIGER_HANDLER_NOP;
		return true;
	}

	return false;
}

bool tiger_handler::map_handler_push(instruction_container& instructions, tiger_context& context)
{
	std::size_t index = 0;

	if (this->map_unary_operation(instructions, context, index, UD_Ipush))
	{
		if (instructions.bounds(index, 1) &&
			instructions.at(index + 1).is_mnemonic_not({ UD_Ipopfw, UD_Ipopfd, UD_Ipopfq }))
		{
			this->id = TIGER_HANDLER_PUSH;
			return true;
		}
	}

	return false;
}

bool tiger_handler::map_handler_pop(instruction_container& instructions, tiger_context& context)
{
	std::size_t index = 0;

	if (this->map_unary_operation(instructions, context, index, UD_Ipop))
	{
		this->id = TIGER_HANDLER_POP;
		return true;
	}

	return false;
}

bool tiger_handler::map_handler_inc(instruction_container& instructions, tiger_context& context)
{
	std::size_t index = 0;

	if (this->map_unary_operation(instructions, context, index, UD_Iinc))
	{
		/* Maybe consider that 'no flags' is actually "lea reg,[reg+x]" */
		this->id = TIGER_HANDLER_INC;
		return true;
	}

	return false;
}

bool tiger_handler::map_handler_dec(instruction_container& instructions, tiger_context& context)
{
	std::size_t index = 0;

	if (this->map_unary_operation(instructions, context, index, UD_Idec))
	{
		this->id = TIGER_HANDLER_DEC;
		return true;
	}

	return false;
}
	
bool tiger_handler::map_handler_not(instruction_container& instructions, tiger_context& context)
{
	std::size_t index = 0;

	if (this->map_unary_operation(instructions, context, index, UD_Inot))
	{
		this->id = TIGER_HANDLER_NOT;
		return true;
	}

	return false;
}

bool tiger_handler::map_handler_neg(instruction_container& instructions, tiger_context& context)
{
	std::size_t index = 0;

	if (this->map_unary_operation(instructions, context, index, UD_Ineg))
	{
		this->id = TIGER_HANDLER_NEG;
		return true;
	}

	return false;
}

bool tiger_handler::map_handler_mov(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_movsx(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_movzx(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_add(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_sub(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_and(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_xor(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_or(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_shl(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_shr(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_rcl(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_rcr(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_rol(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_ror(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_cmp(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_test(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_handler_imul(instruction_container& instructions, tiger_context& context)
{
	return false;
}

bool tiger_handler::map_unary_operation(instruction_container& instructions, tiger_context& context, std::size_t& index, ud_mnemonic_code mnemonic)
{
	ud_instruction operand_key_instruction;
	
	for (std::size_t i = 0; i < instructions.size(); i++)
	{
		if (this->find_operand_key_read_instruction(instructions, context, TIGER_KEY_OPERAND_0, i, operand_key_instruction))
		{
			ud_type operand_type = UD_OP_REG;

			for (std::size_t j = i + 1, stage = 0; j < instructions.size(); j++)
			{
				if (stage == 0 && 
					instructions.at(j).is_mnemonic(UD_Iadd) &&
					instructions.at(j).is_operand_type(0, UD_OP_REG) &&
					instructions.at(j).is_operand_base(0, operand_key_instruction, 0) &&
					instructions.at(j).is_operand_type(1, UD_OP_REG) &&
					instructions.at(j).is_operand_base(1, UD_R_EBP))
				{
					stage++;
				}
				else if (stage == 1)
				{
					if (instructions.at(j).is_mnemonic(UD_Imov) &&
						instructions.at(j).is_operand_type(0, UD_OP_REG) &&
						instructions.at(j).is_operand_base(0, operand_key_instruction, 0))
					{
						if (instructions.at(j).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
							instructions.at(j).is_operand_base(1, operand_key_instruction, 0))
						{
							operand_type = UD_OP_MEM;
						}
						else
						{
							break;
						}
					}
					else if (instructions.at(j).is_mnemonic(mnemonic) &&
						instructions.at(j).is_operand_type(0, UD_OP_MEM) &&
						instructions.at(j).is_operand_base(0, operand_key_instruction, 0))
					{
						this->operands[0].type = operand_type;
						this->operands[0].size = instructions.at(j).get_operand_size(0);
						this->operands[0].index = i;

						index = j;
						return true;
					}
				}
			}
		}
	}

	return false;
}

bool tiger_handler::decrypt_tiger_data(instruction_container& instructions, tiger_context& context)
{
	return (this->decrypt_tiger_operand_data(instructions, context, TIGER_KEY_OPERAND_0, this->operands[0].key_decoders) &&
		this->decrypt_tiger_operand_data(instructions, context, TIGER_KEY_OPERAND_1, this->operands[1].key_decoders));
}
	
bool tiger_handler::decrypt_tiger_operand_data(instruction_container& instructions, tiger_context& context, uint8_t operand_key, std::vector<tiger_operand_decoder>& key_decoders)
{
	std::size_t index = 0;
	ud_instruction operand_key_instruction;
	
	if (this->find_operand_key_read_instruction(instructions, context, operand_key, index, operand_key_instruction))
	{
		/* 0: ___ reg,imm */
		while (instructions.bounds(++index) &&
			instructions.at(index).compare_mnemonic(false, false, true) &&
			instructions.at(index).is_operand_type(0, UD_OP_REG) &&
			instructions.at(index).is_operand_base_family(0, operand_key_instruction, 0) &&
			instructions.at(index).is_operand_type(1, UD_OP_IMM))
		{
			key_decoders.push_back({ instructions.at(index).get_mnemonic(), instructions.at(index).get_operand_size(1), instructions.at(index).get_operand_data(1) });
		}
	}

	return true;
}

bool tiger_handler::find_operand_key_read_instruction(instruction_container& instructions, tiger_context& context, uint8_t operand_key, std::size_t& index, ud_instruction& instruction)
{
	for (std::size_t i = index; i < instructions.size(); i++)
	{
		/* 0: mov reg,word ptr [ebp+xx] */
		if (instructions.at(i).is_mnemonic(UD_Imovzx) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG) &&
			instructions.at(i).is_operand_type(1, UD_OP_MEM, UD_SIZE_WORD) &&
			instructions.at(i).is_operand_base(1, UD_R_EBP) &&
			instructions.at(i).has_operand_index_not(1) &&
			instructions.at(i).has_operand_scale_not(1) &&
			instructions.at(i).is_operand_data(1, context.get_key_offset(operand_key)))
		{
			index = i;
			instruction = instructions.at(i);
			return true;
		}
	}

	return false;
}

bool tiger_handler::step_handler_specific(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	try
	{
		return this->step_handler_tiger(instructions, dynamic_cast<tiger_context&>(context), opcode);
	}
	catch (std::bad_cast const& e)
	{
		msg("[CodeDevirtualizer] Exception: %s\n", e.what());
	}

	return false;
}

bool tiger_handler::step_handler_tiger(instruction_container& instructions, tiger_context& context, opcode_reader& opcode)
{
	switch (this->id)
	{
	case TIGER_HANDLER_NOP:
		return this->step_handler_nop(instructions, context, opcode);

	case TIGER_HANDLER_PUSH:
		return this->step_handler_push(instructions, context, opcode);

	case TIGER_HANDLER_POP:
		return this->step_handler_pop(instructions, context, opcode);

	default:
		this->step_opcode_regions(context, opcode);
		return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
		break;
	}

	return false;
}

bool tiger_handler::step_handler_nop(instruction_container& instructions, tiger_context& context, opcode_reader& opcode)
{
	context.step_params[0] = UD_Inop;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Inop);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(0), true);
}

bool tiger_handler::step_handler_push(instruction_container& instructions, tiger_context& context, opcode_reader& opcode)
{
	this->step_opcode_regions(context, opcode);

	uint32_t register_id = context.get_key_data(TIGER_KEY_OPERAND_0);

	for (std::size_t i = 0; i < this->operands[0].key_decoders.size(); i++)
		instruction::emulate(this->operands[0].key_decoders.at(i).mnemonic, this->operands[0].key_decoders.at(i).size, this->operands[0].key_decoders.at(i).data, &register_id);

	context.step_params[0] = register_id;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Ipush);
	instruction.set_operand_type(0, UD_OP_REG, UD_SIZE_DWORD);
	instruction.set_operand_base(0, context.get_vm_register(register_id));

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool tiger_handler::step_handler_pop(instruction_container& instructions, tiger_context& context, opcode_reader& opcode)
{
	this->step_opcode_regions(context, opcode);

	uint32_t register_id = context.get_key_data(TIGER_KEY_OPERAND_0);
	
	for (std::size_t i = 0; i < this->operands[0].key_decoders.size(); i++)
		instruction::emulate(this->operands[0].key_decoders.at(i).mnemonic, this->operands[0].key_decoders.at(i).size, this->operands[0].key_decoders.at(i).data, &register_id);

	context.step_params[0] = register_id;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Ipop);
	instruction.set_operand_type(0, this->operands[0].type, this->operands[0].size);

	if (context.current_register_type < 0)
	{
		if (this->operands[0].type == UD_OP_REG) 
			instruction.set_operand_base(0, context.get_vm_register(register_id), this->operands[0].size);
		else /* if (this->operands[0].type == UD_OP_MEM) */
			instruction.set_operand_base(0, context.get_vm_register(register_id));
	}
	else
	{
		ud_type base = static_cast<ud_type>(UD_R_EAX + context.current_register_type--);

		if (base != UD_R_ESP)
			context.set_vm_register(register_id, base);
		
		instruction.set_operand_base(0, base);
	}
	
	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}
```

`TDE/tiger_handler.hpp`:

```hpp
#ifndef TIGER_HANDLER_HPP_
#define TIGER_HANDLER_HPP_

#include "wild_handler.hpp"
#include "tiger_context.hpp"

class tiger_handler : public wild_handler
{
	enum tiger_key_types
	{
		TIGER_KEY_OPERAND_1 = 5,
		TIGER_KEY_OPERAND_0,
	};
	
	typedef struct tiger_operand_decoder
	{
		ud_mnemonic_code mnemonic;
		ud_size size;
		uint32_t data;
	} tiger_operand_decoder;

	typedef struct tiger_operand
	{
		ud_type type;
		ud_size size;
		std::size_t index;
		std::vector<tiger_operand_decoder> key_decoders;
	} tiger_operand;

public:
	tiger_handler(uint16_t index);
	
	bool update_argument_data(tiger_context& context);

private:
	bool map_handler_specific(instruction_container& instructions, wild_context& context);
	bool map_handler_tiger(instruction_container& instructions, tiger_context& context);

private:
	bool map_handler_call(instruction_container& instructions, tiger_context& context);

	bool map_handler_nop(instruction_container& instructions, tiger_context& context);
	bool map_handler_push(instruction_container& instructions, tiger_context& context);
	bool map_handler_pop(instruction_container& instructions, tiger_context& context);
	
	bool map_handler_inc(instruction_container& instructions, tiger_context& context);
	bool map_handler_dec(instruction_container& instructions, tiger_context& context);
	bool map_handler_not(instruction_container& instructions, tiger_context& context);
	bool map_handler_neg(instruction_container& instructions, tiger_context& context);

	bool map_handler_mov(instruction_container& instructions, tiger_context& context);
	bool map_handler_movsx(instruction_container& instructions, tiger_context& context);
	bool map_handler_movzx(instruction_container& instructions, tiger_context& context);
	bool map_handler_add(instruction_container& instructions, tiger_context& context);
	bool map_handler_sub(instruction_container& instructions, tiger_context& context);
	bool map_handler_and(instruction_container& instructions, tiger_context& context);
	bool map_handler_xor(instruction_container& instructions, tiger_context& context);
	bool map_handler_or(instruction_container& instructions, tiger_context& context);
	bool map_handler_shl(instruction_container& instructions, tiger_context& context);
	bool map_handler_shr(instruction_container& instructions, tiger_context& context);
	bool map_handler_rcl(instruction_container& instructions, tiger_context& context);
	bool map_handler_rcr(instruction_container& instructions, tiger_context& context);
	bool map_handler_rol(instruction_container& instructions, tiger_context& context);
	bool map_handler_ror(instruction_container& instructions, tiger_context& context);
	bool map_handler_cmp(instruction_container& instructions, tiger_context& context);
	bool map_handler_test(instruction_container& instructions, tiger_context& context);
	bool map_handler_imul(instruction_container& instructions, tiger_context& context);

	bool map_unary_operation(instruction_container& instructions, tiger_context& context, std::size_t& index, ud_mnemonic_code mnemonic);

private:
	bool decrypt_tiger_data(instruction_container& instructions, tiger_context& context);
	bool decrypt_tiger_operand_data(instruction_container& instructions, tiger_context& context, uint8_t operand_key, std::vector<tiger_operand_decoder>& key_decoders);
	
	bool find_operand_key_read_instruction(instruction_container& instructions, tiger_context& context, uint8_t operand_key, std::size_t& index, ud_instruction& instruction);
	
private:
	bool step_handler_specific(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_tiger(instruction_container& instructions, tiger_context& context, opcode_reader& opcode);

private:
	bool step_handler_nop(instruction_container& instructions, tiger_context& context, opcode_reader& opcode);
	bool step_handler_push(instruction_container& instructions, tiger_context& context, opcode_reader& opcode);
	bool step_handler_pop(instruction_container& instructions, tiger_context& context, opcode_reader& opcode);

private:
	tiger_operand operands[2];
};

#endif
```

`TDE/tiger_handler_types.hpp`:

```hpp
#ifndef TIGER_HANDLER_TYPES_HPP_
#define TIGER_HANDLER_TYPES_HPP_

#include <stdint.h>

enum tiger_handler_types : uint16_t
{
	TIGER_HANDLER_NOP = 0x2000,

	TIGER_HANDLER_PUSH,
	TIGER_HANDLER_POP,

	TIGER_HANDLER_INC,
	TIGER_HANDLER_DEC,
	TIGER_HANDLER_NOT,
	TIGER_HANDLER_NEG,
	
	TIGER_HANDLER_MOV,
	TIGER_HANDLER_MOVSX,
	TIGER_HANDLER_MOVZX,

	TIGER_HANDLER_ADD,
	TIGER_HANDLER_SUB,
	TIGER_HANDLER_AND,
	TIGER_HANDLER_XOR,
	TIGER_HANDLER_OR,

	TIGER_HANDLER_SHL,
	TIGER_HANDLER_SHR,
	TIGER_HANDLER_RCL,
	TIGER_HANDLER_RCR,
	TIGER_HANDLER_ROL,
	TIGER_HANDLER_ROR,

	TIGER_HANDLER_CMP,
	TIGER_HANDLER_TEST,
	
	TIGER_HANDLER_IMUL,

	TIGER_HANDLER_COUNT,
};

#endif
```

`TDE/ud_instruction.cpp`:

```cpp
#include "ud_instruction.hpp"

#include <algorithm>

void ud_instruction::initialize(uint64_t base_address, uint8_t mode)
{
	this->index = 0;
	this->key_data = 0;

	ud_init(this);
	ud_set_pc(this, base_address);
	ud_set_mode(this, mode);
	ud_set_syntax(this, UD_SYN_INTEL);

	this->opr_mode = mode;
	this->insn_offset = this->pc;
}

ud_instruction::ud_instruction()
{
	this->initialize(0);
}

ud_instruction::ud_instruction(uint64_t base_address)
{
	this->initialize(base_address);
}
uint32_t ud_instruction::get_index()
{
	return this->index;
}

void ud_instruction::set_index(uint32_t index)
{
	this->index = index;
}

uint32_t ud_instruction::get_key_data()
{
	return this->key_data;
}

void ud_instruction::set_key_data(uint32_t key_data)
{
	this->key_data = key_data;
}

void ud_instruction::set_input(uint8_t* address, uint32_t size)
{
	ud_set_input_buffer(this, address, size);
}

void ud_instruction::set_input(std::pair<uint8_t*, uint32_t> input)
{
	this->set_input(input.first, input.second);
}

void ud_instruction::skip_input(uint32_t length)
{
	this->inp_buf_index += length;
	this->pc += length;
}

void ud_instruction::reset_input(uint32_t address)
{
	uint32_t base_address = static_cast<uint32_t>(this->pc - this->inp_buf_index);
	uint32_t base_offset = (address - base_address);

	this->inp_buf_index = base_offset;
	this->pc = base_address + base_offset;
}

void ud_instruction::set_program_counter(uint64_t counter)
{
	ud_set_pc(this, counter);
}

template <typename T>
T ud_instruction::get_operand_data(std::size_t index) const
{
	return static_cast<T>(this->get_operand_data<uint64_t>(index));
}

template <>
int8_t ud_instruction::get_operand_data<int8_t>(std::size_t index) const
{
	return this->operand[index].lval.sbyte;
}

template <>
uint8_t ud_instruction::get_operand_data<uint8_t>(std::size_t index) const
{
	return this->operand[index].lval.ubyte;
}

template <>
int16_t ud_instruction::get_operand_data<int16_t>(std::size_t index) const
{
	return this->operand[index].lval.sword;
}

template <>
uint16_t ud_instruction::get_operand_data<uint16_t>(std::size_t index) const
{
	return this->operand[index].lval.uword;
}

template <>
int32_t ud_instruction::get_operand_data<int32_t>(std::size_t index) const
{
	return this->operand[index].lval.sdword;
}

template <>
uint32_t ud_instruction::get_operand_data<uint32_t>(std::size_t index) const
{
	return this->operand[index].lval.udword;
}

template <>
int64_t ud_instruction::get_operand_data<int64_t>(std::size_t index) const
{
	return this->operand[index].lval.sqword;
}

template <>
uint64_t ud_instruction::get_operand_data<uint64_t>(std::size_t index) const
{
	return this->operand[index].lval.uqword;
}

template <>
void ud_instruction::set_operand_data<int8_t>(std::size_t index, int8_t data)
{
	this->operand[index].lval.sbyte = data;
}

template <>
void ud_instruction::set_operand_data<uint8_t>(std::size_t index, uint8_t data)
{
	this->operand[index].lval.ubyte = data;
}
	
template <>
void ud_instruction::set_operand_data<int16_t>(std::size_t index, int16_t data)
{
	this->operand[index].lval.sword = data;
}

template <>
void ud_instruction::set_operand_data<uint16_t>(std::size_t index, uint16_t data)
{
	this->operand[index].lval.uword = data;
}
	
template <>
void ud_instruction::set_operand_data<int32_t>(std::size_t index, int32_t data)
{
	this->operand[index].lval.sdword = data;
}

template <>
void ud_instruction::set_operand_data<uint32_t>(std::size_t index, uint32_t data)
{
	this->operand[index].lval.udword = data;
}

template <>
void ud_instruction::set_operand_data<int64_t>(std::size_t index, int64_t data)
{
	this->operand[index].lval.sqword = data;
}

template <>
void ud_instruction::set_operand_data<uint64_t>(std::size_t index, uint64_t data)
{
	this->operand[index].lval.uqword = data;
}
	
ud_mnemonic_code ud_instruction::get_mnemonic() const
{
	return this->mnemonic;	
}

ud_type ud_instruction::get_operand_type(std::size_t index) const
{
	return this->operand[index].type;
}

ud_size ud_instruction::get_operand_size(std::size_t index) const
{
	return static_cast<ud_size>(this->operand[index].size);
}

ud_type ud_instruction::get_base_type(std::size_t index) const
{
	return this->operand[index].base;
}

ud_type ud_instruction::get_base_high_type(std::size_t index) const
{
	switch (this->operand[index].base)
	{
	case UD_R_AL:	case UD_R_AH:	case UD_R_AX:	case UD_R_EAX:	case UD_R_RAX:
		return UD_R_AH;
		
	case UD_R_CL:	case UD_R_CH:	case UD_R_CX:	case UD_R_ECX:	case UD_R_RCX:
		return UD_R_CH;
		
	case UD_R_DL:	case UD_R_DH:	case UD_R_DX:	case UD_R_EDX:	case UD_R_RDX:
		return UD_R_DH;
		
	case UD_R_BL:	case UD_R_BH:	case UD_R_BX:	case UD_R_EBX:	case UD_R_RBX:
		return UD_R_BH;

	default:
		break;
	}

	return UD_NONE;
}

ud_type ud_instruction::get_base_size_type(std::size_t index, ud_size size) const
{
	return this->base_to_size_type(this->operand[index].base, size);
}

ud_size ud_instruction::get_base_size(std::size_t index) const
{
	switch (this->operand[index].type)
	{
	case UD_OP_REG:
	case UD_OP_CONST:
		return static_cast<ud_size>(this->operand[index].size);

	case UD_OP_MEM:
		return this->get_type_size(this->operand[index].base);

	default:
		break;
	}

	return UD_SIZE_NONE;
}

ud_size ud_instruction::get_type_size(ud_type type) const
{
	if (type >= UD_R_AL && type <= UD_R_R15B)
		return UD_SIZE_BYTE;
	else if (type >= UD_R_AX && type <= UD_R_R15W)
		return UD_SIZE_WORD;
	else if (type >= UD_R_EAX && type <= UD_R_R15D)
		return UD_SIZE_DWORD;
	else if (type >= UD_R_RAX && type <= UD_R_R15)
		return UD_SIZE_QWORD;
	else 
		return UD_SIZE_NONE;
}

ud_type ud_instruction::base_to_size_type(ud_type base, ud_size size) const
{
	static const ud_type accumulator_types[]		= { UD_R_AL,  UD_R_AX, UD_R_EAX, UD_R_RAX };
	static const ud_type counter_types[]			= { UD_R_CL,  UD_R_CX, UD_R_ECX, UD_R_RCX };
	static const ud_type data_types[]				= { UD_R_DL,  UD_R_DX, UD_R_EDX, UD_R_RDX };
	static const ud_type base_types[]				= { UD_R_BL,  UD_R_BX, UD_R_EBX, UD_R_RBX };
	static const ud_type stack_pointer_types[]		= { UD_R_SPL, UD_R_SP, UD_R_ESP, UD_R_RSP };
	static const ud_type stack_base_types[]			= { UD_R_BPL, UD_R_BP, UD_R_EBP, UD_R_RBP };
	static const ud_type source_index_types[]		= { UD_R_SIL, UD_R_SI, UD_R_ESI, UD_R_RSI };
	static const ud_type destination_index_types[]	= { UD_R_DIL, UD_R_DI, UD_R_EDI, UD_R_RDI };
	
	/*
		x = std::pow(y, z) is reversible through z = log(x) / log(y).

		std::pow(2, 3) = 8		-> log(8)  / log(2) = 3
		std::pow(2, 4) = 16		-> log(16) / log(2) = 4
		std::pow(2, 5) = 32		-> log(32) / log(2) = 5
		std::pow(2, 6) = 64		-> log(32) / log(2) = 6
	*/

	const uint8_t logarithm = static_cast<uint8_t>(std::log(static_cast<uint16_t>(size)) / std::log(2)) - 3;

	switch (base)
	{
	case UD_R_AL:	case UD_R_AH:	case UD_R_AX:	case UD_R_EAX:	case UD_R_RAX:
		return accumulator_types[logarithm];

	case UD_R_CL:	case UD_R_CH:	case UD_R_CX:	case UD_R_ECX:	case UD_R_RCX:
		return counter_types[logarithm];

	case UD_R_DL:	case UD_R_DH:	case UD_R_DX:	case UD_R_EDX:	case UD_R_RDX:
		return data_types[logarithm];
		
	case UD_R_BL:	case UD_R_BH:	case UD_R_BX:	case UD_R_EBX:	case UD_R_RBX:
		return base_types[logarithm];

	case UD_R_SPL:					case UD_R_SP:	case UD_R_ESP:	case UD_R_RSP:
		return stack_pointer_types[logarithm];

	case UD_R_BPL:					case UD_R_BP:	case UD_R_EBP:	case UD_R_RBP: 
		return stack_base_types[logarithm];
		
	case UD_R_SIL:					case UD_R_SI:	case UD_R_ESI:	case UD_R_RSI:
		return source_index_types[logarithm];

	case UD_R_DIL:					case UD_R_DI:	case UD_R_EDI:	case UD_R_RDI:
		return destination_index_types[logarithm];
  
	case UD_R_ADDR1:
		return UD_R_ADDR1;

	case UD_R_ADDR2:
		return UD_R_ADDR2;

	default:
		break;
	}

	return UD_NONE;
}

uint32_t ud_instruction::get_params(uint32_t operand) const
{
	switch (this->operand[operand].type)
	{
	case UD_OP_REG:
		return this->get_base_type(operand);

	case UD_OP_IMM:
		return this->get_operand_data(operand);

	default:
		break;
	}

	return 0;
}

uint16_t ud_instruction::get_loword(uint32_t operand) const
{
	switch (this->operand[operand].type)
	{
	case UD_OP_REG:
		return this->get_base_type(operand);
		
	case UD_OP_IMM:
		return this->get_operand_data<uint16_t>(operand);

	case UD_OP_MEM:
		return (this->get_base_type(operand) << 8);

	default:
		break;
	}

	return 0;
}

bool ud_instruction::is_mnemonic(ud_mnemonic_code mnemonic) const
{
	return (this->mnemonic == mnemonic);
}

bool ud_instruction::is_mnemonic(std::initializer_list<ud_mnemonic_code> mnemonics) const
{
	for (std::initializer_list<ud_mnemonic_code>::const_iterator iter = mnemonics.begin(); iter != mnemonics.end(); iter++)
	{
		if (this->is_mnemonic(*iter))
			return true;
	}

	return false;
}

bool ud_instruction::is_mnemonic_not(ud_mnemonic_code mnemonic) const
{
	return (!this->is_mnemonic(mnemonic));
}

bool ud_instruction::is_mnemonic_not(std::initializer_list<ud_mnemonic_code> mnemonics) const
{
	return (!this->is_mnemonic(mnemonics));
}

bool ud_instruction::is_mnemonic_jcc() const
{
	return this->is_mnemonic({ UD_Ija, UD_Ijae, UD_Ijb, UD_Ijbe, UD_Ijz, UD_Ijnz, UD_Ijg, UD_Ijge, UD_Ijl, UD_Ijle, UD_Ijo, UD_Ijno, UD_Ijp, UD_Ijnp, UD_Ijs, UD_Ijns, UD_Ijcxz, UD_Ijecxz, UD_Ijrcxz });
}

bool ud_instruction::is_mnemonic_jcc_not() const
{
	return (!this->is_mnemonic_jcc());
}

bool ud_instruction::is_operand_null(std::size_t index) const
{
	return (this->operand[index].type == UD_NONE);
}

bool ud_instruction::is_operand_not_null(std::size_t index) const
{
	return (!this->is_operand_null(index));
}

bool ud_instruction::is_operand_type(std::size_t index, ud_type type, ud_size size) const
{
	return (this->operand[index].type == type && (size == UD_SIZE_NONE || this->operand[index].size == size));
}

bool ud_instruction::is_operand_type(std::size_t index, std::initializer_list<ud_type> types) const
{
	for (std::initializer_list<ud_type>::const_iterator iter = types.begin(); iter != types.end(); iter++)
	{
		if (this->is_operand_type(index, *iter))
			return true;
	}

	return false;
}

bool ud_instruction::is_operand_type(std::size_t index, ud_type type, std::initializer_list<ud_size> sizes) const
{
	for (std::initializer_list<ud_size>::const_iterator iter = sizes.begin(); iter != sizes.end(); iter++)
	{
		if (this->is_operand_type(index, type, *iter))
			return true;
	}

	return false;
}

bool ud_instruction::is_operand_type(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return this->is_operand_type(index, instruction.operand[instruction_index].type, static_cast<ud_size>(instruction.operand[instruction_index].size));
}

bool ud_instruction::is_operand_type_not(std::size_t index, ud_type type, ud_size size) const
{
	return (!this->is_operand_type(index, type, size));
}

bool ud_instruction::is_operand_type_not(std::size_t index, std::initializer_list<ud_type> types) const
{
	return (!this->is_operand_type(index, types));
}

bool ud_instruction::is_operand_type_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (!this->is_operand_type(index, instruction, instruction_index));
}

bool ud_instruction::is_operand_size(std::size_t index, ud_size size) const
{
	return (this->operand[index].size == size);
}

bool ud_instruction::is_operand_size_not(std::size_t index, ud_size size) const
{
	return (!this->is_operand_size(index, size));
}

bool ud_instruction::is_operand_sib(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (this->is_operand_base(index, instruction, instruction_index) &&
		this->is_operand_index(index, instruction, instruction_index) &&
		this->is_operand_scale(index, instruction, instruction_index));
}

bool ud_instruction::has_operand_base(std::size_t index) const
{
	return (this->operand[index].base != UD_NONE);
}

bool ud_instruction::has_operand_base_not(std::size_t index) const
{
	return (!this->has_operand_base(index));
}

bool ud_instruction::is_operand_base(std::size_t index, ud_type type) const
{
	return (this->operand[index].base == type);
}

bool ud_instruction::is_operand_base(std::size_t index, std::initializer_list<ud_type> types) const
{
	for (std::initializer_list<ud_type>::const_iterator iter = types.begin(); iter != types.end(); iter++)
	{
		if (this->is_operand_base(index, *iter))
			return true;
	}

	return false;
}

bool ud_instruction::is_operand_base(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (this->is_operand_base(index, instruction.operand[instruction_index].base));
}

bool ud_instruction::is_operand_base_not(std::size_t index, ud_type type) const
{
	return (!this->is_operand_base(index, type));
}

bool ud_instruction::is_operand_base_not(std::size_t index, std::initializer_list<ud_type> types) const
{
	return (!this->is_operand_base(index, types));
}

bool ud_instruction::is_operand_base_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (!this->is_operand_base(index, instruction, instruction_index));
}

bool ud_instruction::is_operand_base_size(std::size_t index, ud_size size) const
{
	return (this->get_base_size(index) == size);
}

bool ud_instruction::is_operand_base_size_not(std::size_t index, ud_size size) const
{
	return (!this->is_operand_base_size(index, size));
}

bool ud_instruction::is_operand_base_family(std::size_t index, ud_type family) const
{
	switch (family)
	{
	case UD_R_AL:	case UD_R_AH:	case UD_R_AX:	case UD_R_EAX:	case UD_R_RAX:
		return this->is_operand_base(index, { UD_R_AL, UD_R_AH, UD_R_AX, UD_R_EAX, UD_R_RAX });

	case UD_R_CL:	case UD_R_CH:	case UD_R_CX:	case UD_R_ECX:	case UD_R_RCX:
		return this->is_operand_base(index, { UD_R_CL, UD_R_CH, UD_R_CX, UD_R_ECX, UD_R_RCX });

	case UD_R_DL:	case UD_R_DH:	case UD_R_DX:	case UD_R_EDX:	case UD_R_RDX:
		return this->is_operand_base(index, { UD_R_DL, UD_R_DH, UD_R_DX, UD_R_EDX, UD_R_RDX });
		
	case UD_R_BL:	case UD_R_BH:	case UD_R_BX:	case UD_R_EBX:	case UD_R_RBX:
		return this->is_operand_base(index, { UD_R_BL, UD_R_BH, UD_R_BX, UD_R_EBX, UD_R_RBX });
		
	case UD_R_SPL:					case UD_R_SP:	case UD_R_ESP:	case UD_R_RSP:
		return this->is_operand_base(index, { UD_R_SPL, UD_R_SP, UD_R_ESP, UD_R_RSP });

	case UD_R_BPL:					case UD_R_BP:	case UD_R_EBP:	case UD_R_RBP: 
		return this->is_operand_base(index, { UD_R_BPL, UD_R_BP, UD_R_EBP, UD_R_RBP });
		
	case UD_R_SIL:					case UD_R_SI:	case UD_R_ESI:	case UD_R_RSI:
		return this->is_operand_base(index, { UD_R_SIL, UD_R_SI, UD_R_ESI, UD_R_RSI });

	case UD_R_DIL:					case UD_R_DI:	case UD_R_EDI:	case UD_R_RDI:
		return this->is_operand_base(index, { UD_R_DIL, UD_R_DI, UD_R_EDI, UD_R_RDI });
  
	default:
		break;
	}

	return false;
}

bool ud_instruction::is_operand_base_family(std::size_t index, std::initializer_list<ud_type> families) const
{
	for (std::initializer_list<ud_type>::const_iterator iter = families.begin(); iter != families.end(); iter++)
	{
		if (this->is_operand_base_family(index, *iter))
			return true;
	}

	return false;
}

bool ud_instruction::is_operand_base_family(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return this->is_operand_base_family(index, instruction.operand[instruction_index].base);
}

bool ud_instruction::is_operand_base_family_not(std::size_t index, ud_type family) const
{
	return (!this->is_operand_base_family(index, family));
}

bool ud_instruction::is_operand_base_family_not(std::size_t index, std::initializer_list<ud_type> families) const
{
	return (!this->is_operand_base_family(index, families));
}

bool ud_instruction::has_operand_index(std::size_t index) const
{
	return (this->operand[index].index != UD_NONE);
}

bool ud_instruction::has_operand_index_not(std::size_t index) const
{
	return (!this->has_operand_index(index));
}

bool ud_instruction::is_operand_index(std::size_t index, ud_type type) const
{
	return (this->operand[index].index == type);
}

bool ud_instruction::is_operand_index(std::size_t index, std::initializer_list<ud_type> types) const
{
	for (std::initializer_list<ud_type>::const_iterator iter = types.begin(); iter != types.end(); iter++)
	{
		if (this->is_operand_index(index, *iter))
			return true;
	}

	return false;
}
	
bool ud_instruction::is_operand_index(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (this->is_operand_index(index, instruction.operand[instruction_index].index));
}

bool ud_instruction::is_operand_index_not(std::size_t index, ud_type type) const
{
	return (!this->is_operand_index(index, type));
}

bool ud_instruction::is_operand_index_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (!this->is_operand_index(index, instruction, instruction_index));
}

bool ud_instruction::is_operand_index_by_base(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return this->is_operand_index(index, instruction.operand[instruction_index].base);
}

bool ud_instruction::has_operand_scale(std::size_t index) const
{
	return (this->operand[index].scale != 0);
}

bool ud_instruction::has_operand_scale_not(std::size_t index) const
{
	return (!this->has_operand_scale(index));
}

bool ud_instruction::is_operand_scale(std::size_t index, uint8_t scale) const
{
	return (this->operand[index].scale == scale);
}

bool ud_instruction::is_operand_scale(std::size_t index, std::initializer_list<uint8_t> scales) const
{
	for (std::initializer_list<uint8_t>::const_iterator iter = scales.begin(); iter != scales.end(); iter++)
	{
		if (this->is_operand_scale(index, *iter))
			return true;
	}

	return false;
}

bool ud_instruction::is_operand_scale(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (this->is_operand_scale(index, instruction.operand[instruction_index].scale));
}

bool ud_instruction::is_operand_scale_not(std::size_t index, uint8_t scale) const
{
	return (!this->is_operand_scale(index, scale));
}

bool ud_instruction::is_operand_scale_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (!this->is_operand_scale(index, instruction, instruction_index));
}

bool ud_instruction::has_operand_offset(std::size_t index) const
{
	return (this->operand[index].offset != 0);
}

bool ud_instruction::has_operand_offset_not(std::size_t index) const
{
	return (!this->has_operand_offset(index));
}

bool ud_instruction::is_operand_offset(std::size_t index, uint8_t offset) const
{
	return (this->operand[index].offset == offset);
}

bool ud_instruction::is_operand_offset(std::size_t index, std::initializer_list<uint8_t> offsets) const
{
	for (std::initializer_list<uint8_t>::const_iterator iter = offsets.begin(); iter != offsets.end(); iter++)
	{
		if (this->is_operand_offset(index, *iter))
			return true;
	}

	return false;
}

bool ud_instruction::is_operand_offset(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return this->is_operand_offset(index, instruction.operand[instruction_index].offset);
}

bool ud_instruction::is_operand_offset_not(std::size_t index, uint8_t offset) const
{
	return (!this->is_operand_offset(index, offset));
}

bool ud_instruction::is_operand_offset_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (!this->is_operand_offset(index, instruction, instruction_index));
}

bool ud_instruction::has_operand_data(std::size_t index) const
{
	if (this->is_operand_type(index, UD_OP_MEM))
		return (this->has_operand_offset(index) && this->is_operand_data_not<uint64_t>(index, 0));
	else
		return (this->is_operand_data_not<uint64_t>(index, 0));
}

bool ud_instruction::has_operand_data_not(std::size_t index) const
{
	return (!this->has_operand_data(index));
}

bool ud_instruction::compare_mnemonic(bool allow_mov, bool allow_unary, bool allow_binary)
{
	return ((allow_mov && this->is_mnemonic(UD_Imov)) ||
		(allow_unary && this->is_mnemonic({ UD_Idec, UD_Iinc, UD_Inot, UD_Ineg })) ||
		(allow_binary && this->is_mnemonic({ UD_Iadd, UD_Isub, UD_Ixor, UD_Ior, UD_Iand, UD_Ishl, UD_Ishr })));
}

bool ud_instruction::compare_mnemonic_not(bool allow_mov, bool allow_unary, bool allow_binary)
{
	return (!this->compare_mnemonic(allow_mov, allow_unary, allow_binary));
}

bool ud_instruction::compare_immediate()
{
	return (this->is_mnemonic({ UD_Iadd, UD_Isub }) && this->is_operand_type(1, UD_OP_IMM) && this->is_operand_data(1, { -1, 1 }));
}

bool ud_instruction::compare_base(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	ud_type base_type = instruction.operand[instruction_index].base;
	ud_size base_size = instruction.get_base_size(instruction_index);

	if (this->get_base_size(index) < base_size)
		return false;

	if (base_size == UD_SIZE_BYTE && (base_type >= UD_R_AH && base_type <= UD_R_BH))
		base_type = static_cast<ud_type>(base_type - (UD_R_AH - UD_R_AL));

	return (this->operand[index].base == base_type);
}

bool ud_instruction::compare_base_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (!this->compare_base(index, instruction, instruction_index));
}

void ud_instruction::set_mnemonic(ud_mnemonic_code mnemonic)
{
	this->mnemonic = mnemonic;
}

void ud_instruction::set_mnemonic(ud_instruction& instruction)
{
	this->set_mnemonic(instruction.mnemonic);
}

void ud_instruction::set_prefixes(ud_instruction& instruction)
{
	this->pfx_rex = instruction.pfx_rex;
	this->pfx_seg = instruction.pfx_seg;
	this->pfx_opr = instruction.pfx_opr;
	this->pfx_adr = instruction.pfx_adr;
	this->pfx_lock = instruction.pfx_lock;
	this->pfx_str = instruction.pfx_str;
	this->pfx_rep = instruction.pfx_rep;
	this->pfx_repe = instruction.pfx_repe;
	this->pfx_repne = instruction.pfx_repne;
}

void ud_instruction::set_operand_null(std::size_t index)
{
	this->set_operand_type_null(index);
	this->set_operand_base_null(index);
	this->set_operand_index_null(index);
	this->set_operand_scale_null(index);
	this->set_operand_offset_null(index);
	this->set_operand_data_null<uint64_t>(index);
}

void ud_instruction::set_operand_type(std::size_t index, ud_type type, ud_size size)
{
	this->operand[index].type = type;
	this->operand[index].size = size;
}

void ud_instruction::set_operand_type(std::size_t index, ud_instruction& instruction, std::size_t instruction_index)
{
	this->set_operand_type(index, instruction.operand[instruction_index].type, static_cast<ud_size>(instruction.operand[instruction_index].size));
}

void ud_instruction::set_operand_type_null(std::size_t index)
{
	this->set_operand_type(index, UD_NONE, UD_SIZE_NONE);
}

void ud_instruction::set_operand_size(std::size_t index, ud_size size)
{
	this->operand[index].size = size;
}

void ud_instruction::set_operand_base(std::size_t index, ud_type type)
{
	this->operand[index].base = type;
}

void ud_instruction::set_operand_base(std::size_t index, ud_instruction& instruction, std::size_t instruction_index)
{
	this->set_operand_base(index, instruction.operand[instruction_index].base);
}
	
void ud_instruction::set_operand_base(std::size_t index, ud_type type, ud_size size)
{
	this->set_operand_base(index, this->base_to_size_type(type, size));
}

void ud_instruction::set_operand_base_null(std::size_t index)
{
	this->set_operand_base(index, UD_NONE);
}

void ud_instruction::set_operand_index(std::size_t index, ud_type type)
{
	this->operand[index].index = type;
}

void ud_instruction::set_operand_index(std::size_t index, ud_instruction& instruction, std::size_t instruction_index)
{
	this->set_operand_index(index, instruction.operand[instruction_index].index);
}

void ud_instruction::set_operand_index_null(std::size_t index)
{
	this->set_operand_index(index, UD_NONE);
}

void ud_instruction::set_operand_index_by_base(std::size_t index, ud_instruction& instruction, std::size_t instruction_index)
{
	this->set_operand_index(index, instruction.operand[instruction_index].base);
}

void ud_instruction::set_operand_scale(std::size_t index, uint8_t scale)
{
	this->operand[index].scale = scale;
}

void ud_instruction::set_operand_scale(std::size_t index, ud_instruction& instruction, std::size_t instruction_index)
{
	this->set_operand_scale(index, instruction.operand[instruction_index].scale);
}

void ud_instruction::set_operand_scale_null(std::size_t index)
{
	this->set_operand_scale(index, 0);
}

void ud_instruction::set_operand_scale_by_exponent(std::size_t index, uint8_t scale_exp)
{
	if (scale_exp)
		this->set_operand_scale(index, static_cast<uint8_t>(std::pow(2, scale_exp)));
	else
		this->set_operand_scale_null(index);
}

void ud_instruction::set_operand_offset(std::size_t index, uint8_t offset)
{
	this->operand[index].offset = offset;
}

void ud_instruction::set_operand_offset(std::size_t index, ud_instruction& instruction, std::size_t instruction_index)
{
	this->set_operand_offset(index, instruction.operand[instruction_index].offset);
}

void ud_instruction::set_operand_offset_null(std::size_t index)
{
	this->set_operand_offset(index, 0);
}
```

`TDE/ud_instruction.hpp`:

```hpp
#ifndef UD_INSTRUCTION_HPP_
#define UD_INSTRUCTION_HPP_

#include "udis86.h"

#include <initializer_list>
#include <utility>

enum ud_size : uint16_t
{
	UD_SIZE_NONE = 0,
	UD_SIZE_BYTE = 8,
	UD_SIZE_WORD = 16,
	UD_SIZE_DWORD = 32,
	UD_SIZE_FWORD = 48,
	UD_SIZE_QWORD = 64
};

class ud_instruction : public ud_t
{
	void initialize(uint64_t base_address, uint8_t mode = 32);

public:
	ud_instruction();
	ud_instruction(uint64_t base_address);
	
public:
	uint32_t get_index();
	void set_index(uint32_t index);

	uint32_t get_key_data();
	void set_key_data(uint32_t key_data);

public:
	void set_input(uint8_t* address, uint32_t size);
	void set_input(std::pair<uint8_t*, uint32_t> input);
	
	void skip_input(uint32_t length);
	void reset_input(uint32_t address);

	void set_program_counter(uint64_t counter);

	template <typename T = uint64_t>
	T get_address() const;
	
	template <typename T = uint64_t>
	T get_address_next() const;
	
	template <typename T = uint64_t>
	bool is_address(T address) const;

public:
	template <typename T = uint32_t>
	T get_operand_data(std::size_t index) const;
	
	template <typename T = uint32_t>
	void set_operand_data(std::size_t index, T data);
	
	ud_mnemonic_code get_mnemonic() const;

	ud_type get_operand_type(std::size_t index) const;
	ud_size get_operand_size(std::size_t index) const;

	ud_type get_base_type(std::size_t index) const;
	ud_type get_base_high_type(std::size_t index) const;
	ud_type get_base_size_type(std::size_t index, ud_size size) const;
	ud_size get_base_size(std::size_t index) const;
	
	ud_size get_type_size(ud_type type) const;

	ud_type base_to_size_type(ud_type base, ud_size size) const;

public: // To be removed (?)
	uint32_t get_params(uint32_t operand) const;
	uint16_t get_loword(uint32_t operand) const;

public:
	bool is_mnemonic(ud_mnemonic_code mnemonic) const;
	bool is_mnemonic(std::initializer_list<ud_mnemonic_code> mnemonics) const;
	bool is_mnemonic_not(ud_mnemonic_code mnemonic) const;
	bool is_mnemonic_not(std::initializer_list<ud_mnemonic_code> mnemonics) const;
	bool is_mnemonic_jcc() const;
	bool is_mnemonic_jcc_not() const;

	bool is_operand_null(std::size_t index) const;
	bool is_operand_not_null(std::size_t index) const;
	
	template <typename T = uint32_t>
	bool is_operand(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	
	template <typename T = uint32_t>
	bool is_operand_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	
	bool is_operand_type(std::size_t index, ud_type type, ud_size size = UD_SIZE_NONE) const;
	bool is_operand_type(std::size_t index, std::initializer_list<ud_type> types) const;
	bool is_operand_type(std::size_t index, ud_type type, std::initializer_list<ud_size> sizes) const;
	bool is_operand_type(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	bool is_operand_type_not(std::size_t index, ud_type type, ud_size size = UD_SIZE_NONE) const;
	bool is_operand_type_not(std::size_t index, std::initializer_list<ud_type> types) const;
	bool is_operand_type_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	
	bool is_operand_size(std::size_t index, ud_size size) const;
	bool is_operand_size_not(std::size_t index, ud_size size) const;

	bool is_operand_sib(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;

	bool has_operand_base(std::size_t index) const;
	bool has_operand_base_not(std::size_t index) const;

	bool is_operand_base(std::size_t index, ud_type type) const;
	bool is_operand_base(std::size_t index, std::initializer_list<ud_type> types) const;
	bool is_operand_base(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	bool is_operand_base_not(std::size_t index, ud_type type) const;
	bool is_operand_base_not(std::size_t index, std::initializer_list<ud_type> types) const;
	bool is_operand_base_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	
	bool is_operand_base_size(std::size_t index, ud_size size) const;
	bool is_operand_base_size_not(std::size_t index, ud_size size) const;
		
	bool is_operand_base_family(std::size_t index, ud_type family) const;
	bool is_operand_base_family(std::size_t index, std::initializer_list<ud_type> families) const;
	bool is_operand_base_family(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	bool is_operand_base_family_not(std::size_t index, ud_type family) const;
	bool is_operand_base_family_not(std::size_t index, std::initializer_list<ud_type> families) const;
	
	bool has_operand_index(std::size_t index) const;
	bool has_operand_index_not(std::size_t index) const;

	bool is_operand_index(std::size_t index, ud_type type) const;
	bool is_operand_index(std::size_t index, std::initializer_list<ud_type> types) const;
	bool is_operand_index(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	bool is_operand_index_not(std::size_t index, ud_type type) const;
	bool is_operand_index_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	bool is_operand_index_by_base(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;

	bool has_operand_scale(std::size_t index) const;
	bool has_operand_scale_not(std::size_t index) const;
	
	bool is_operand_scale(std::size_t index, uint8_t scale) const;
	bool is_operand_scale(std::size_t index, std::initializer_list<uint8_t> scales) const;
	bool is_operand_scale(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	bool is_operand_scale_not(std::size_t index, uint8_t scale) const;
	bool is_operand_scale_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	
	bool has_operand_offset(std::size_t index) const;
	bool has_operand_offset_not(std::size_t index) const;

	bool is_operand_offset(std::size_t index, uint8_t offset) const;
	bool is_operand_offset(std::size_t index, std::initializer_list<uint8_t> offsets) const;
	bool is_operand_offset(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	bool is_operand_offset_not(std::size_t index, uint8_t offset) const;
	bool is_operand_offset_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;

	bool has_operand_data(std::size_t index) const;
	bool has_operand_data_not(std::size_t index) const;
	
	template <typename T = uint32_t>
	bool is_operand_data(std::size_t index, T data) const;
	
	template <typename T = uint32_t>
	bool is_operand_data(std::size_t index, std::initializer_list<T> datas) const;

	template <typename T = uint32_t>
	bool is_operand_data(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	
	template <typename T = uint32_t>
	bool is_operand_data_not(std::size_t index, T data) const;
	
	template <typename T = uint32_t>
	bool is_operand_data_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;

public:
	bool compare_mnemonic(bool allow_mov, bool allow_unary, bool allow_binary);
	bool compare_mnemonic_not(bool allow_mov, bool allow_unary, bool allow_binary);

	bool compare_immediate();

	bool compare_base(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	bool compare_base_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const;
	
public:
	void set_mnemonic(ud_mnemonic_code mnemonic);
	void set_mnemonic(ud_instruction& instruction);

	void set_prefixes(ud_instruction& instruction);

	template <typename T = uint32_t>
	void set_operand(std::size_t index, ud_instruction& instruction, std::size_t instruction_index);
	void set_operand_null(std::size_t index);
	
	void set_operand_type(std::size_t index, ud_type type, ud_size size);
	void set_operand_type(std::size_t index, ud_instruction& instruction, std::size_t instruction_index);
	void set_operand_type_null(std::size_t index);
	
	void set_operand_size(std::size_t index, ud_size size);

	void set_operand_base(std::size_t index, ud_type type);
	void set_operand_base(std::size_t index, ud_instruction& instruction, std::size_t instruction_index);
	void set_operand_base(std::size_t index, ud_type type, ud_size size);
	void set_operand_base_null(std::size_t index);
	
	void set_operand_index(std::size_t index, ud_type type);
	void set_operand_index(std::size_t index, ud_instruction& instruction, std::size_t instruction_index);
	void set_operand_index_null(std::size_t index);
	void set_operand_index_by_base(std::size_t index, ud_instruction& instruction, std::size_t instruction_index);

	void set_operand_scale(std::size_t index, uint8_t scale);
	void set_operand_scale(std::size_t index, ud_instruction& instruction, std::size_t instruction_index);
	void set_operand_scale_null(std::size_t index);
	void set_operand_scale_by_exponent(std::size_t index, uint8_t scale_exp);
	
	void set_operand_offset(std::size_t index, uint8_t offset);
	void set_operand_offset(std::size_t index, ud_instruction& instruction, std::size_t instruction_index);
	void set_operand_offset_null(std::size_t index);

	template <typename T = uint32_t>
	void set_operand_data(std::size_t index, ud_instruction& instruction, std::size_t instruction_index);

	template <typename T = uint32_t>
	void set_operand_data_null(std::size_t index);

	template <typename T = uint32_t>
	void inc_operand_data(std::size_t index, T data);
	
	template <typename T = uint32_t>
	void dec_operand_data(std::size_t index, T data);

private:
	uint32_t index;
	uint32_t key_data;
};

template <typename T>
T ud_instruction::get_address() const
{
	return static_cast<T>(ud_insn_off(this));
}

template <typename T>
T ud_instruction::get_address_next() const
{
	if (this->is_operand_type(0, UD_OP_JIMM))
		return static_cast<T>(ud_insn_off(this) + ud_insn_len(this) + this->get_operand_data<T>(0));
	else
		return static_cast<T>(ud_insn_off(this) + ud_insn_len(this));
}

template <typename T>
bool ud_instruction::is_address(T address) const
{
	return (this->get_address<T>() == address);
}

template <typename T>
bool ud_instruction::is_operand(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (this->is_operand_type(index, instruction, instruction_index) &&
		this->is_operand_base(index, instruction, instruction_index) &&
		this->is_operand_index(index, instruction, instruction_index) &&
		this->is_operand_scale(index, instruction, instruction_index) &&
		this->is_operand_offset(index, instruction, instruction_index) &&
		this->is_operand_data<T>(index, instruction, instruction_index));
}

template <typename T>
bool ud_instruction::is_operand_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (!this->is_operand<T>(index, instruction, instruction_index));
}

template <typename T>
bool ud_instruction::is_operand_data(std::size_t index, T data) const
{
	return (this->get_operand_data<T>(index) == data);
}

template <typename T>
bool ud_instruction::is_operand_data(std::size_t index, std::initializer_list<T> datas) const
{
	for (std::initializer_list<T>::const_iterator iter = datas.begin(); iter != datas.end(); iter++)
	{
		if (this->is_operand_data<T>(index, *iter))
			return true;
	}

	return false;
}

template <typename T>
bool ud_instruction::is_operand_data(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return this->is_operand_data<T>(index, instruction.get_operand_data<T>(instruction_index));
}

template <typename T>
bool ud_instruction::is_operand_data_not(std::size_t index, T data) const
{
	return (!this->is_operand_data<T>(index, data));
}

template <typename T>
bool ud_instruction::is_operand_data_not(std::size_t index, ud_instruction& instruction, std::size_t instruction_index) const
{
	return (!this->is_operand_data<T>(index, instruction, instruction_index));
}

template <typename T>
void ud_instruction::set_operand(std::size_t index, ud_instruction& instruction, std::size_t instruction_index)
{
	this->set_operand_type(index, instruction, instruction_index);
	this->set_operand_base(index, instruction, instruction_index);
	this->set_operand_index(index, instruction, instruction_index);
	this->set_operand_scale(index, instruction, instruction_index);
	this->set_operand_offset(index, instruction, instruction_index);
	this->set_operand_data<T>(index, instruction, instruction_index);
}

template <typename T>
void ud_instruction::set_operand_data(std::size_t index, ud_instruction& instruction, std::size_t instruction_index)
{
	if (this->is_operand_type(index, UD_OP_MEM))
	{
		if (instruction.is_operand_type(instruction_index, UD_OP_MEM))
			this->set_operand_offset(index, instruction, instruction_index);
		else if (instruction.is_operand_type(instruction_index, UD_OP_IMM))
			this->set_operand_offset(index, instruction.get_operand_size(instruction_index));
	}

	this->set_operand_data<T>(index, instruction.get_operand_data<T>(instruction_index));
}

template <typename T>
void ud_instruction::set_operand_data_null(std::size_t index)
{
	this->set_operand_data<T>(index, 0);
}

template <typename T>
void ud_instruction::inc_operand_data(std::size_t index, T data)
{
	this->set_operand_data<T>(index, this->get_operand_data<T>(index) + data);
}
	
template <typename T>
void ud_instruction::dec_operand_data(std::size_t index, T data)
{
	this->set_operand_data<T>(index, this->get_operand_data<T>(index) - data);
}

#endif
```

`TDE/udis86.h`:

```h
/* udis86 - udis86.h
 *
 * Copyright (c) 2002-2009 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef UDIS86_H
#define UDIS86_H

#include "libudis86/types.h"
#include "libudis86/extern.h"
#include "libudis86/itab.h"

#endif

```

`TDE/wild.hpp`:

```hpp
#ifndef WILD_HPP_
#define WILD_HPP_

#include "wild_base.hpp"

template <typename T>
class wild : public wild_base
{
	static_assert(std::is_base_of<wild_handler, T>::value, "Handler type in class 'wild' must be derived from class 'wild_handler'.");

public:
	wild(wild_context& context)
		: wild_base(context)
	{

	}

protected:
	bool parse_virtual_handler(instruction_container& instructions, uint32_t index, uint32_t compares)
	{
		T handler(index);

		if (!handler.decrypt(instructions, this->context, compares))
			return false;

		this->handlers.push_back(handler);
		return true;
	}

	bool fetch_virtual_handler(std::size_t index, wild_handler** handler)
	{
		if (index >= this->handlers.size())
			return false;

		*handler = &this->handlers.at(index);
		return true;
	}
	
protected:
	std::vector<T> handlers;
};

#endif
```

`TDE/wild_base.cpp`:

```cpp
#include "wild_base.hpp"

#include "instruction_emulator.hpp"

#include <idp.hpp>
#include <allins.hpp>

wild_base::wild_base(wild_context& context)
	: wild_handler_parser(context)
{

}

bool wild_base::devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions)
{
	if (!decode_insn(vm_function) || (cmd.itype != NN_jmp && cmd.itype != NN_call))
	{
		msg("[CodeDevirtualizer] Instruction at %08X either could not be decoded or is not a jump or call.\n", vm_function);
		return false;
	}
	
	context.set_initial_parameters(vm_instructions.at(0).get_operand_data(0), vm_instructions.at(1).get_operand_data(0));
	
	if (!decode_insn(vm_instructions.at(2).get_address<uint32_t>()))
	{
		msg("[CodeDevirtualizer] Instruction at %08X could not be decoded.\n", vm_instructions.at(2).get_address<uint32_t>());
		return false;
	}
	
	this->vm_function = vm_function;

	if (this->vm_entrance != cmd.Operands[0].addr)
	{
		if (!this->parse_virtual_machine(cmd.Operands[0].addr))
			return false;
	}
	
	context.prepare_initial_parameters();

	vm_instructions.clear();

	if (!this->trace_function(vm_instructions))
	{
		msg("[CodeDevirtualizer] Could not trace selected function.\n");
		return false;
	}

	this->process_virtual_function(vm_instructions);
	return true;
}

bool wild_base::parse_virtual_machine(uint32_t vm_entrance)
{
	this->context.clear();

	if (!this->context.make_segment_copy(vm_entrance))
	{
		msg("[CodeDevirtualizer] Could not create segment copy.\n");
		return false;
	}
				
	if (!this->context.decode_zero_data(vm_entrance))
	{
		msg("[CodeDevirtualizer] Could not decode zero data.\n");
		return false;
	}

	msg("VM vars:\n");
	msg("Imagebase:\t%08X\n", this->context.vm_imagebase);
	msg("Context:\t\t%08X\n", this->context.vm_context);
	msg("Imagebase o:\t%08X\n", this->context.vm_imagebase_offset);
	msg("PImagebase o:\t%08X\n", this->context.vm_imagebase_preferred_offset);
	msg("PImagebase:\t%08X\n", this->context.vm_imagebase_preferred);
	msg("Opcode o:\t\t%08X\n", this->context.vm_opcode_offset);
	msg("HTable:\t\t%08X\n", this->context.vm_handler_table);
	msg("HTable o:\t\t%08X\n", this->context.vm_handler_table_offset);
	msg("HTable count:\t%08X\n", this->context.vm_handler_count);

	if (!this->parse_initial_handlers())
	{
		msg("[CodeDevirtualizer] Could not parse the correct keys.\n");
		return false;
	}

	if (!this->parse_virtual_handlers())
	{
		msg("[CodeDevirtualizer] Could not parse virtual handlers.\n");
		return false;
	}
		
	if (!this->update_argument_data())
	{
		msg("[CodeDevirtualizer] Failed to update argument data.\n");
		return false;
	}

	this->vm_entrance = vm_entrance;
	return true;
}

bool wild_base::trace_function(instruction_container& instructions)
{
	this->context.reset_labels();
	this->context.create_label(this->context.initial_virtual_opcode, this->context.initial_handler_offset);
	this->context.current_register_type = (UD_R_EDI - UD_R_EAX);

	std::vector<wild_opcode_label>::iterator iter;

	while (this->context.find_label_unread(iter))
	{
		iter->is_read = true;
		msg("[CodeDevirtualizer] Reading virtual opcode label at %08X\n", iter->address);
		
		if (!instructions.has_address(iter->address))
		{
			this->context.current_virtual_opcode = iter->address;
			this->context.current_handler_offset = iter->offset;
			
			iter->offset = 0;

			if (!this->process_virtual_pointer(instructions, *iter))
			{
				printf("Failed to process virtual pointer.\n");
				return false;
			}
		}
	}

	return true;
}

bool wild_base::process_virtual_pointer(instruction_container& instructions, wild_opcode_label& label)
{
	label.offset = this->context.current_virtual_opcode;
	
	wild_handler* handler = nullptr;

	do
	{
		uint16_t handler_offset = static_cast<uint16_t>(this->context.current_handler_offset);

		if (!this->fetch_virtual_handler(handler_offset, &handler) || handler == nullptr)
		{
			msg("[CodeDevirtualizer] Handler out of bounds (%04X): %08X, Key: %04X.\n", handler_offset, this->context.current_virtual_opcode, this->context.current_handler_offset);
			return false;
		}

		uint8_t* virtual_opcode_address = this->context.to_segment(this->context.current_virtual_opcode).first;

		if (!virtual_opcode_address)
		{
			msg("[CodeDevirtualizer] Virtual opcode segment not found.\n");
			return false;
		}
		
		if (instructions.has_address(this->context.current_virtual_opcode))
			break;

		opcode_reader opcode(virtual_opcode_address);
		
		if (!handler->step_handler(instructions, this->context, opcode))
		{
			msg("[CodeDevirtualizer] Virtual pointer step failed with handler id %04X: %08X, Key: %04X.\n", handler->get_id(), this->context.current_virtual_opcode, this->context.current_handler_offset);
			return false;
		}
		
		instructions.print_syntax(this->context, instructions.back(), handler_offset);
		label.offset = std::max(this->context.current_virtual_opcode, label.offset);
	}
	while (!handler->is_flow_type());

	return true;
}

void wild_base::process_virtual_function(instruction_container& instructions)
{
	//std::sort(instructions.begin(), instructions.end());

	//this->deobfuscate_prologue(instructions);
	//this->deobfuscate_epilogue(instructions);
	//
	//this->deobfuscate_fish_addr_register(instructions);
	//this->deobfuscate_repeat_prefix(instructions);

	//for (std::size_t i = 0; i < instructions.size(); i++)
	//{
	//	if (instructions.at(i).mnemonic == FISH_MNEMONIC_CRYPT)
	//		instructions.at(i).mnemonic = MNEMONIC_MOV;
	//}

	//FILE* f = fopen("C:\\DEVIRTUALIZER\\fish_uv.txt", "w");

	//for (std::size_t i = 0; i < instructions.size(); i++)
	//	this->print_fish_assembly(f, instructions.at(i), 0xFFFF);

	//fclose(f);
}

bool wild_base::parse_initial_handlers()
{
	static const uint32_t max_key_attempts = 5;

	for (uint32_t i = 0, compares = 0; i < max_key_attempts; i++)
	{
		this->context.reset_keys();

		if (this->context.current_handler_offset < this->context.vm_handler_count)
		{
			instruction_container handler_instructions;
			this->decode_virtual_handler(handler_instructions, this->context.current_handler_offset, compares);

#ifdef CREATE_VM_DUMPS
			//handler_instructions.print_assembly();
#endif

			if (this->parse_initial_handler(handler_instructions))
				return true;

			if (!this->parse_next_handler_offset(handler_instructions))
				return false;
		}
	}

	return false;
}

bool wild_base::parse_virtual_handlers()
{
#ifdef CREATE_VM_DUMPS
	FILE* f = fopen("C:\\DEVIRTUALIZER\\fish_vm_raw.txt", "w");
#endif
	
	for (uint32_t i = 0, compares = 0; i < this->context.vm_handler_count; i++)
	{
		instruction_container handler_instructions;
		this->decode_virtual_handler(handler_instructions, i, compares);

		if (!this->parse_virtual_handler(handler_instructions, i, compares))
			return false;

#ifdef CREATE_VM_DUMPS
		fprintf(f,"//////////////////////////////////////////////\r\n// FISH Virtual Handler %04X 00000000\r\n\n", i);
		handler_instructions.print_assembly(f);
#endif
	}
	
#ifdef CREATE_VM_DUMPS
	fclose(f);
#endif

	return true;
}

bool wild_base::parse_next_handler_offset(instruction_container& instructions)
{
	if (instructions.size() >= 3)
	{
		std::size_t index = (instructions.size() - 2);
		
		/*
			0: add dword ptr [ebp+xx],imm
			1: jmp reg
		*/
		if (instructions.at(index).is_mnemonic(UD_Iadd) &&
			instructions.at(index).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) &&
			instructions.at(index).is_operand_base(0, UD_R_EBP) &&
			instructions.at(index).has_operand_index_not(0) &&
			instructions.at(index).has_operand_scale_not(0) &&
			instructions.at(index).is_operand_data(0, this->context.vm_opcode_offset) &&
			instructions.at(index).is_operand_type(1, UD_OP_IMM) &&
			instructions.at(index + 1).is_mnemonic(UD_Ijmp))
		{
			uint32_t vm_opcode_delta = instructions.at(index).get_operand_data(1);

			for (std::size_t i = index; static_cast<int32_t>(i) >= 0; i--)
			{
				/* 0: mov reg,dword ptr [ebp+xx] */
				if (instructions.at(i).is_mnemonic(UD_Imov) &&
					instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
					instructions.at(i).is_operand_base_not(0, UD_R_ESP) &&
					instructions.at(i).is_operand_base_not(0, UD_R_EBP) &&
					instructions.at(i).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
					instructions.at(i).is_operand_base(1, UD_R_EBP) &&
					instructions.at(i).has_operand_index_not(1) &&
					instructions.at(i).has_operand_scale_not(1) &&
					instructions.at(i).is_operand_data(1, this->context.vm_opcode_offset))
				{
					/* 1: add reg,imm */
					if (instructions.at(i + 1).is_mnemonic(UD_Iadd) &&
						instructions.at(i + 1).is_operand_type(0, UD_OP_REG) &&
						instructions.at(i + 1).is_operand_base(0, instructions.at(i), 0) &&
						instructions.at(i + 1).is_operand_type(1, UD_OP_IMM) &&
						vm_opcode_delta < 32)
					{
						opcode_reader opcode(this->context.to_segment(this->context.vm_imagebase + this->context.current_virtual_opcode).first);

						this->context.current_handler_offset = opcode.read<uint16_t>(instructions.at(i + 1).get_operand_data(1));
						this->context.current_virtual_opcode += vm_opcode_delta;
						return true;
					}

					break;
				}
			}
		}
	}

	return false;
}

//void fish32::deobfuscate_prologue(std::vector<x86_instruction>& instructions)
//{
//	for (std::size_t i = 0; i < instructions.size(); i++)
//	{
//		if ((instructions.at(i).mnemonic == FISH_MNEMONIC_STORE_STACK && instructions.at(i + 1).mnemonic == FISH_MNEMONIC_RESET) ||
//			(instructions.at(i).mnemonic == FISH_MNEMONIC_RESET && instructions.at(i + 1).mnemonic == FISH_MNEMONIC_STORE_STACK))
//		{
//			bool is_prologue = true;
//
//			for (std::size_t j = 0; j < 8; j++)
//			{
//				if (instructions.at(i + 2 + j).mnemonic != MNEMONIC_POP)
//				{
//					is_prologue = false;
//					break;
//				}
//			}
//
//			if (is_prologue &&
//				instructions.at(i + 10).mnemonic == MNEMONIC_POPF &&
//				instructions.at(i + 11).mnemonic == FISH_MNEMONIC_RESTORE_STACK)
//			{
//				this->remove_instructions(instructions, i--, 12);
//			}
//		}
//	}
//}
//
//void fish32::deobfuscate_epilogue(std::vector<x86_instruction>& instructions)
//{
//	for (std::size_t i = 0; i < instructions.size(); i++)
//	{
//		if ((i + 8) < instructions.size() &&
//			instructions.at(i).mnemonic == MNEMONIC_PUSHF)
//		{
//			bool is_epilogue = true;
//
//			for (std::size_t j = 0; j < 7; j++)
//			{
//				if (instructions.at(i + 1 + j).mnemonic != MNEMONIC_PUSH)
//				{
//					is_epilogue = false;
//					break;
//				}
//			}
//
//			if (is_epilogue && i > 2)
//			{
//				x86_instruction leave_instruction = instructions.at(i + 8);
//
//				if (leave_instruction.mnemonic == MNEMONIC_CALL)
//				{
//					if (instructions.at(i - 2).mnemonic == MNEMONIC_PUSH &&
//						instructions.at(i - 1).mnemonic == MNEMONIC_PUSH)
//					{
//						i -= 2;
//						this->remove_instructions(instructions, i--, 10);
//					}
//				}
//				else if (leave_instruction.mnemonic == MNEMONIC_JMP ||
//					leave_instruction.mnemonic == MNEMONIC_RETN ||
//					leave_instruction.mnemonic == FISH_MNEMONIC_UNDEF ||
//					(leave_instruction.mnemonic >= MNEMONIC_JA && leave_instruction.mnemonic <= MNEMONIC_JS))
//				{
//					if (instructions.at(i - 1).mnemonic == MNEMONIC_PUSH)
//					{
//						i -= 1;
//						this->remove_instructions(instructions, i--, 9);
//					}
//				}
//			}
//		}
//	}
//	
//	for (std::size_t i = 0; i < instructions.size(); i++)
//	{
//		if (instructions.at(i).mnemonic == FISH_MNEMONIC_LOAD_STACK ||
//			instructions.at(i).mnemonic == FISH_MNEMONIC_RESET)
//		{
//			this->remove_instructions(instructions, i--);
//		}
//	}
//}
//
//void fish32::deobfuscate_fish_addr_register(std::vector<x86_instruction>& instructions)
//{
//	for (std::size_t i = 0; i < instructions.size(); i++)
//	{
//		/* 0: mov addr1/2,___ */
//		if (instructions.at(i).mnemonic == MNEMONIC_MOV &&
//			instructions.at(i).operands[0].is_type(OPERAND_TYPE_REGISTER) &&
//			(instructions.at(i).operands[0].base.is_type(FISH_REGISTER_ADDR_1) ||
//			instructions.at(i).operands[0].base.is_type(FISH_REGISTER_ADDR_2)))
//		{
//			bool has_base = false;
//			x86_operand_register base_register;
//
//			bool has_index = false;
//			x86_operand_register index_register;
//
//			bool has_scale = false;
//			x86_operand_scale operand_scale = OPERAND_SCALE_NONE;
//
//			bool has_data = false;
//			unsigned int operand_data = 0;
//
//			bool has_align = false;
//			unsigned int operand_align = 0;
//
//			unsigned int registers = 0;
//
//			bool skipped_opposite_addr = false;
//			unsigned int skipped_addr_index = 0;
//
//			std::size_t j = 0;
//
//			for (j = 0; j < 5; j++)
//			{
//				/* 1: ___ reg,___ */
//				if (instructions.at(i + j).operands[0].is_not_type(OPERAND_TYPE_REGISTER) ||
//					instructions.at(i + j).operands[0].base.type != instructions.at(i).operands[0].base.type ||
//					instructions.at(i + j).operands[1].is_null())
//				{
//					break;
//				}
//
//				if (instructions.at(i + j).mnemonic == FISH_MNEMONIC_ALIGN)
//				{
//					has_align = true;
//					operand_align = instructions.at(i + j).operands[1].data.dword;
//				}
//				else if (instructions.at(i + j).mnemonic == MNEMONIC_SHL)
//				{
//					registers = (has_index ? 2 : 1);
//
//					has_scale = true;
//					operand_scale = static_cast<x86_operand_scale>(instructions.at(i + j).operands[1].data.dword);
//				}
//				else if (instructions.at(i + j).operands[1].is_type(OPERAND_TYPE_IMMEDIATE))
//				{
//					has_data = true;
//					operand_data = instructions.at(i + j).operands[1].data.dword;;
//				}
//				else if (instructions.at(i + j).operands[1].is_type(OPERAND_TYPE_REGISTER))
//				{
//					if (has_base)
//					{
//						has_index = true;
//						index_register = instructions.at(i + j).operands[1].base;
//					}
//					else
//					{
//						has_base = true;
//						base_register = instructions.at(i + j).operands[1].base;
//					}
//				}
//			}
//			
//			unsigned int operand = 0xFFFFFFFF;
//			
//			if (instructions.at(i + j).operands[0].is_type(OPERAND_TYPE_MEMORY) &&
//				instructions.at(i + j).operands[0].base.type == instructions.at(i).operands[0].base.type)
//			{
//				operand = 0;
//			}
//			else if (instructions.at(i + j).operands[0].is_type(OPERAND_TYPE_REGISTER) &&
//				instructions.at(i + j).operands[0].base.type == instructions.at(i).operands[0].base.type)
//			{
//				operand = 0;
//			}
//			else if (instructions.at(i + j).operands[1].is_type(OPERAND_TYPE_MEMORY) &&
//				instructions.at(i + j).operands[1].base.type == instructions.at(i).operands[0].base.type)
//			{
//				operand = 1;
//			}
//			else if (instructions.at(i + j).operands[1].is_type(OPERAND_TYPE_REGISTER) &&
//				instructions.at(i + j).operands[1].base.type == instructions.at(i).operands[0].base.type)
//			{
//				operand = 1;
//			}
//			else if (instructions.at(i + j).mnemonic == MNEMONIC_MOV &&
//				instructions.at(i + j).operands[0].is_type(OPERAND_TYPE_REGISTER) &&
//				(instructions.at(i + j).operands[0].base.is_type(FISH_REGISTER_ADDR_1) ||
//				instructions.at(i + j).operands[0].base.is_type(FISH_REGISTER_ADDR_2)) &&
//				instructions.at(i + j).operands[0].base.type != instructions.at(i).operands[0].base.type &&
//				this->skip_opposite_addr_register(instructions, i + j, instructions.at(i).operands[0].base.type, instructions.at(i + j).operands[0].base.type, skipped_addr_index, operand))
//			{
//				skipped_opposite_addr = true;
//			}
//			else
//			{
//				continue;				
//			}
//
//			this->remove_instructions(instructions, i, j);
//
//			if (skipped_opposite_addr)
//				j = (skipped_addr_index - j) - i;
//			else
//				j = 0;
//
//			if (operand == 1 &&
//				instructions.at(i + j).mnemonic == MNEMONIC_MOV && 
//				instructions.at(i + j).operands[0].is_type(OPERAND_TYPE_REGISTER) &&
//				instructions.at(i + j).operands[1].is_type(OPERAND_TYPE_REGISTER))
//			{
//				instructions.at(i + j).mnemonic = MNEMONIC_LEA;
//				instructions.at(i + j).operands[1].set_type(OPERAND_TYPE_MEMORY, instructions.at(i + j).operands[0].base.size);
//			}
//
//			if (instructions.at(i + j).operands[operand].is_type(OPERAND_TYPE_MEMORY))
//			{
//				memset(&instructions.at(i + j).operands[operand].base, 0, sizeof(x86_operand_register));
//				memset(&instructions.at(i + j).operands[operand].index, 0, sizeof(x86_operand_register));
//				instructions.at(i + j).operands[operand].scale = OPERAND_SCALE_NONE;
//				instructions.at(i + j).operands[operand].data.dword = 0;
//
//				if (has_data)
//				{
//					instructions.at(i + j).operands[operand].data.dword = operand_data;
//
//					if (has_align)
//						instructions.at(i + j).operands[operand].data.dword += this->imagebase;
//				}
//
//				if (has_scale)
//				{
//					instructions.at(i + j).operands[operand].scale = operand_scale;
//
//					if (registers == 2)
//					{
//						instructions.at(i + j).operands[operand].index = index_register;
//						instructions.at(i + j).operands[operand].base = base_register;
//					}
//					else
//					{
//						instructions.at(i + j).operands[operand].index = base_register;
//
//						if (has_base && has_index)
//							instructions.at(i + j).operands[operand].base = index_register;
//					}
//				}
//				else if (has_base && has_index)
//				{
//					instructions.at(i + j).operands[operand].index = index_register;
//					instructions.at(i + j).operands[operand].base = base_register;
//				}
//				else if (has_base && !has_index)
//				{
//					instructions.at(i + j).operands[operand].base = base_register;
//				}
//			}
//			else
//			{
//				instructions.at(i + j).operands[operand].set_type(OPERAND_TYPE_IMMEDIATE, OPERAND_SIZE_DWORD);
//				instructions.at(i + j).operands[operand].data.dword = operand_data;
//
//				if (has_align)
//					instructions.at(i + j).operands[operand].data.dword += this->imagebase;
//			}
//		}
//	}
//}
//
//bool fish32::skip_opposite_addr_register(std::vector<x86_instruction>& instructions, std::size_t index, unsigned char old_type, unsigned char new_type, unsigned int& new_index, unsigned int& operand)
//{
//	std::size_t i = 0;
//
//	while (i < 5 &&
//		(index + i) < instructions.size() &&
//		instructions.at(index + i).operands[0].is_type(OPERAND_TYPE_REGISTER) &&
//		instructions.at(index + i).operands[0].base.type == new_type &&
//		!instructions.at(index + i).operands[1].is_null())
//	{
//		i++;
//	}
//
//	if (instructions.at(index + i).operands[0].is_type(OPERAND_TYPE_REGISTER) &&
//		instructions.at(index + i).operands[0].base.type == new_type &&
//		!instructions.at(index + i).operands[1].is_null())
//	{
//		return false;
//	}
//	if (instructions.at(index + i).operands[0].is_type(OPERAND_TYPE_MEMORY) &&
//		instructions.at(index + i).operands[0].base.type == old_type)
//	{
//		new_index = index + i;
//		operand = 0;
//		return true;
//	}
//	else if (instructions.at(index + i).operands[0].is_type(OPERAND_TYPE_REGISTER) &&
//		instructions.at(index + i).operands[0].base.type == old_type)
//	{
//		new_index = index + i;
//		operand = 0;
//		return true;
//	}
//	else if (instructions.at(index + i).operands[1].is_type(OPERAND_TYPE_MEMORY) &&
//		instructions.at(index + i).operands[1].base.type == old_type)
//	{
//		new_index = index + i;
//		operand = 1;
//		return true;
//	}
//	else if (instructions.at(index + i).operands[1].is_type(OPERAND_TYPE_REGISTER) &&
//		instructions.at(index + i).operands[1].base.type == old_type)
//	{
//		new_index = index + i;
//		operand = 1;
//		return true;
//	}
//
//	return false;
//}
//
//void fish32::deobfuscate_repeat_prefix(std::vector<x86_instruction>& instructions)
//{
//	for (std::size_t i = 0; i < instructions.size(); i++)
//	{
//		switch (instructions.at(i).mnemonic)
//		{
//		case MNEMONIC_LODS:
//		case MNEMONIC_MOVS:
//		case MNEMONIC_STOS:
//			if (this->is_repeat_prefix(instructions, i))
//			{
//				i -= 2;
//				this->remove_instructions(instructions, i, 2);
//				
//				instructions.at(i).prefix.lock_repeat = lock_repeat_prefix::REP;
//
//				this->remove_instructions(instructions, i + 1, 2);
//			}
//
//			break;
//
//		case MNEMONIC_CMPS:
//		case MNEMONIC_SCAS:
//			if (this->is_repeat_prefix(instructions, i))
//			{
//				i -= 2;
//				this->remove_instructions(instructions, i, 2);
//
//				if (instructions.at(i + 1).mnemonic == MNEMONIC_JE)
//					instructions.at(i).prefix.lock_repeat = lock_repeat_prefix::REP;
//				else
//					instructions.at(i).prefix.lock_repeat = lock_repeat_prefix::REPNE;
//
//				this->remove_instructions(instructions, i + 1, 3);
//			}
//
//			break;
//
//		default:
//			break;
//		}
//	}
//}
//
//bool fish32::is_repeat_prefix(std::vector<x86_instruction>& instructions, std::size_t index)
//{
//	if (index >= 2)
//	{
//		/* 
//			0: cmp ecx,0x0 
//			1: je ___
//		*/
//		if (instructions.at(index - 2).mnemonic == MNEMONIC_CMP &&
//			instructions.at(index - 2).operands[0].is_type(OPERAND_TYPE_REGISTER) &&
//			instructions.at(index - 2).operands[0].base.is_type(REGISTER_ECX, OPERAND_SIZE_DWORD) &&
//			instructions.at(index - 2).operands[1].is_type(OPERAND_TYPE_IMMEDIATE) &&
//			instructions.at(index - 2).operands[1].data.dword == 0 &&
//			instructions.at(index - 1).mnemonic == MNEMONIC_JE)
//		{
//			/* 2: cmps/scas ___,___ */
//			if ((index + 3) < instructions.size() &&
//				instructions.at(index).mnemonic == MNEMONIC_CMPS ||
//				instructions.at(index).mnemonic == MNEMONIC_SCAS)
//			{
//				/*
//					3: j(n)e ___
//					4: dec ecx
//					5: jmp ___
//				*/
//				return ((instructions.at(index + 1).mnemonic == MNEMONIC_JE || 
//					instructions.at(index + 1).mnemonic == MNEMONIC_JNZ) &&
//					instructions.at(index + 2).mnemonic == MNEMONIC_DEC &&
//					instructions.at(index + 2).operands[0].is_type(OPERAND_TYPE_REGISTER) &&
//					instructions.at(index + 2).operands[0].base.is_type(REGISTER_ECX, OPERAND_SIZE_DWORD) &&
//					instructions.at(index + 3).mnemonic == MNEMONIC_JMP);
//			}
//			else if ((index + 2) < instructions.size())
//			{
//				/*
//					3: dec ecx
//					4: jmp ___
//				*/
//				return (instructions.at(index + 1).mnemonic == MNEMONIC_DEC &&
//					instructions.at(index + 1).operands[0].is_type(OPERAND_TYPE_REGISTER) &&
//					instructions.at(index + 1).operands[0].base.is_type(REGISTER_ECX, OPERAND_SIZE_DWORD) &&
//					instructions.at(index + 2).mnemonic == MNEMONIC_JMP);
//			}
//		}
//	}
//
//	return false;
//}
```

`TDE/wild_base.hpp`:

```hpp
#ifndef WILD_BASE_HPP_
#define WILD_BASE_HPP_

#include "wild_handler_parser.hpp"
#include "wild_handler.hpp"

class wild_base : public wild_handler_parser
{
	virtual bool parse_initial_handler(instruction_container& instructions) = 0;

	virtual bool parse_virtual_handler(instruction_container& instructions, uint32_t index, uint32_t compares) = 0;
	virtual bool fetch_virtual_handler(std::size_t index, wild_handler** handler) = 0;
	
	virtual bool update_argument_data() { return false; }

public:
	wild_base(wild_context& context);

public:
	bool devirtualize(uint32_t vm_function, uint32_t vm_entry, instruction_container& vm_instructions);

private:
	bool parse_virtual_machine(uint32_t vm_entrance);
	
	bool trace_function(instruction_container& instructions);

	bool process_virtual_pointer(instruction_container& instructions, wild_opcode_label& label);
	void process_virtual_function(instruction_container& instructions);
	
	bool parse_initial_handlers();
	bool parse_virtual_handlers();
	
	bool parse_next_handler_offset(instruction_container& instructions);
	
private:
	uint32_t vm_function;
	uint32_t vm_entrance;
};

#endif
```

`TDE/wild_context.cpp`:

```cpp
#include "wild_context.hpp"

#include "instruction_emulator.hpp"

#include <idp.hpp>
#include <allins.hpp>

void wild_context::clear()
{
	this->initialized_crypto_offset = false;
	this->crypto_offset = 0;

	this->initialized_jcc_types = false;
	this->initialized_eflags_types = false;

	this->current_register_type = 0;
	
	this->register_addr1_id = 0xFFFF;
	this->register_addr2_id = 0xFFFF;

	this->register_types.clear();
	this->mnemonic_types.clear();
	this->jcc_mnemonic_types.clear();
}

void wild_context::set_initial_parameters(uint32_t virtual_opcode, uint32_t handler_offset)
{
	this->initial_virtual_opcode = virtual_opcode;
	this->current_virtual_opcode = this->initial_virtual_opcode;
	
	this->initial_handler_offset = handler_offset;
	this->current_handler_offset = this->initial_handler_offset;
}
	
void wild_context::prepare_initial_parameters()
{
	this->initial_virtual_opcode += this->vm_imagebase;
	this->current_virtual_opcode += this->vm_imagebase;
}

bool wild_context::is_key_access_instruction(ud_instruction& instruction, bool allow_mov)
{
	if (instruction.compare_mnemonic(allow_mov, false, true))
	{
		/* 0: ___ unknown ptr [ebp+xx],___ */
		if (instruction.is_operand_type(0, UD_OP_MEM) &&
			instruction.is_operand_base(0, UD_R_EBP) &&
			instruction.has_operand_index_not(0) &&
			instruction.has_operand_scale_not(0))
		{
			if (this->get_key(instruction.get_operand_data(0), nullptr))
				return true;
		}
		/* 0: ___ ___,unknown ptr [ebp+xx] */
		else if (instruction.is_operand_type(1, UD_OP_MEM) &&
			instruction.is_operand_base(1, UD_R_EBP) &&
			instruction.has_operand_index_not(1) &&
			instruction.has_operand_scale_not(1))
		{
			if (this->get_key(instruction.get_operand_data(1), nullptr))
				return true;
		}
	}

	return false;
}
	
bool wild_context::is_opcode_access_instruction(ud_instruction& instruction)
{
	/* 0: ___ dword ptr [ebp+xx] */
	if (instruction.is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) &&
		instruction.is_operand_base(0, UD_R_EBP) &&
		instruction.has_operand_index_not(0) &&
		instruction.has_operand_scale_not(0) &&
		instruction.is_operand_data(0, this->vm_opcode_offset))
	{
		return true;
	}
	/* 0: ___ ___,dword ptr [ebp+xx] */
	else if (instruction.is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
		instruction.is_operand_base(1, UD_R_EBP) &&
		instruction.has_operand_index_not(1) &&
		instruction.has_operand_scale_not(1) &&
		instruction.is_operand_data(1, this->vm_opcode_offset))
	{
		/* 0: ___ reg,dword ptr [ebp+xx] */
		return instruction.is_operand_type(0, UD_OP_REG);
	}

	return false;
}

ud_type wild_context::get_vm_register(uint16_t id)
{
	std::map<uint16_t, ud_type>::const_iterator iter = this->register_types.find(id);

	if (iter != this->register_types.end())
		return iter->second;
	else
		return UD_NONE;
}
	
ud_type wild_context::get_vm_high_byte_register(uint16_t id)
{
	return static_cast<ud_type>(this->get_vm_register(id - 1) + (UD_R_AH - UD_R_AL));
}

bool wild_context::set_vm_register(uint16_t id, ud_type type)
{
	if (this->register_types.count(id) != 0)
		return false;

	this->register_types[id] = type;
	return true;
}

ud_mnemonic_code wild_context::get_mnemonic(uint8_t id)
{
	std::map<uint8_t, ud_mnemonic_code>::const_iterator iter = this->mnemonic_types.find(id);

	if (iter != this->mnemonic_types.end())
		return iter->second;
	else
		return UD_Inone;
}

bool wild_context::set_mnemonic(uint8_t id, ud_mnemonic_code mnemonic)
{
	if (this->mnemonic_types.count(id) != 0)
		return false;

	this->mnemonic_types[id] = mnemonic;
	return true;
}

ud_mnemonic_code wild_context::get_jcc_mnemonic(uint8_t id)
{
	std::map<uint8_t, ud_mnemonic_code>::const_iterator iter = this->jcc_mnemonic_types.find(id);

	if (iter != this->jcc_mnemonic_types.end())
		return iter->second;
	else
		return UD_Inone;
}

bool wild_context::set_jcc_mnemonic(uint8_t id, ud_mnemonic_code mnemonic)
{
	if (this->jcc_mnemonic_types.count(id) != 0)
		return false;

	this->jcc_mnemonic_types[id] = mnemonic;
	return true;
}

bool wild_context::decode_zero_data(uint32_t vm_entrance)
{
	ud_instruction instruction(vm_entrance);
	instruction.set_input(this->to_segment(vm_entrance));
	
	instruction_container instructions;
		
	do
	{
		if (!instructions.decode_assembly(instruction))
			return false;
	}
	while (instruction.is_mnemonic_not(UD_Ijmp) || instruction.is_operand_type_not(0, UD_OP_MEM));

	return this->parse_zero_data(instructions);
}

bool wild_context::parse_zero_data(instruction_container& instructions)
{
	std::size_t index = 0;

	return (this->parse_image_base(instructions, index) &&
		this->parse_vm_context(instructions, index) &&
		this->parse_vm_imagebase_offset(instructions, index) &&
		this->parse_vm_imagebase_preferred_offset(instructions, index) &&
		this->parse_vm_imagebase_preferred(instructions, index) &&
		this->parse_vm_opcode_offset(instructions, index) &&
		this->parse_vm_handler_table(instructions, index) &&
		this->parse_vm_handler_table_offset(instructions, index) &&
		this->parse_vm_handler_count(instructions, index));
}
	
bool wild_context::parse_image_base(instruction_container& instructions, std::size_t& index)
{
	this->vm_imagebase = 0;

	for (std::size_t i = index, stage = 0; i < instructions.size(); i++)
	{
		/* 0: call $+5 */
		if (instructions.at(i).is_mnemonic(UD_Icall) &&
			instructions.at(i).is_operand_type(0, UD_OP_JIMM) &&
			instructions.at(i).is_operand_data(0, 0))
		{
			this->vm_imagebase = instructions.at(i).get_address_next<uint32_t>();
			stage++;
		}
		/* 0: ___ ecx,imm */
		else if (stage == 1 &&
			instructions.at(i).compare_mnemonic(false, false, true) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_base(0, UD_R_ECX) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM))
		{
			instruction::emulate(instructions.at(i).get_mnemonic(), instructions.at(i).get_base_size(0), instructions.at(i).get_operand_data<uint32_t>(1), &this->vm_imagebase);
			stage++;
		}
		/* 0: ___ ecx,imm32 */
		else if (stage == 2 &&
			instructions.at(i).compare_mnemonic(false, false, true) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_base(0, UD_R_ECX) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD))
		{
			instruction::emulate(instructions.at(i).get_mnemonic(), instructions.at(i).get_base_size(0), instructions.at(i).get_operand_data<uint32_t>(1), &this->vm_imagebase);
			stage++;
		}
		/* 0: mov ebp,imm32 */
		else if (stage == 3 &&
			instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_base(0, UD_R_EBP) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD))
		{
			index = i;
			return true;
		}
		else if (instructions.at(i).is_mnemonic(UD_Ipush))
			break;
	}

	return false;
}

bool wild_context::parse_vm_context(instruction_container& instructions, std::size_t& index)
{
	this->vm_context = 0;

	for (std::size_t i = index, stage = 0, context_offset = 0; i < instructions.size(); i++)
	{
		/* 0: mov ebp,imm32 */
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_base(0, UD_R_EBP) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD))
		{
			context_offset = instructions.at(i).get_operand_data<uint32_t>(1);
			stage++;
		}
		/* 0: ___ ebp,ecx */
		else if (stage == 1 &&
			instructions.at(i).compare_mnemonic(false, false, true) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_base(0, UD_R_EBP) &&
			instructions.at(i).is_operand_type(1, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_base(1, UD_R_ECX))
		{
			index = i + 1;
			this->vm_context = this->vm_imagebase + context_offset;
			return true;
		}
		else if (instructions.at(i).is_mnemonic(UD_Ipush))
			break;
	}
	
	return false;
}

bool wild_context::parse_vm_imagebase_offset(instruction_container& instructions, std::size_t& index)
{
	this->vm_imagebase_offset = 0;

	if (instructions.find_mnemonic_index(UD_Ipop, index))
	{
		for (std::size_t i = index; i < instructions.size(); i++)
		{
			/*
				0: mov reg,imm32
				1: mov dword ptr [reg+reg],reg
			*/
			if (instructions.at(i).is_mnemonic(UD_Imov) &&
				instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
				instructions.at(i).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD) &&

				instructions.at(i + 1).is_mnemonic(UD_Imov) &&
				instructions.at(i + 1).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) &&
				(instructions.at(i + 1).is_operand_base(0, instructions.at(i), 0) ||
				instructions.at(i + 1).is_operand_index_by_base(0, instructions.at(i), 0)) &&
				instructions.at(i + 1).is_operand_type(1, UD_OP_REG, UD_SIZE_DWORD))
			{
				index = i + 2;
				this->vm_imagebase_offset = instructions.at(i).get_operand_data<uint32_t>(1);
				return true;
			}
			else if (instructions.at(i).is_mnemonic(UD_Icmp))
				break;
		}
	}

	return false;
}

bool wild_context::parse_vm_imagebase_preferred_offset(instruction_container& instructions, std::size_t& index)
{
	this->vm_imagebase_preferred_offset = 0;

	for (std::size_t i = index; i < instructions.size(); i++)
	{
		/*
			0: mov reg,imm32
			1: mov dword ptr [reg+reg],imm32
		*/
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD) &&

			instructions.at(i + 1).is_mnemonic(UD_Imov) &&
			instructions.at(i + 1).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) &&
			instructions.at(i + 1).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD) &&
			(instructions.at(i + 1).is_operand_base(0, instructions.at(i), 0) ||
			instructions.at(i + 1).is_operand_index_by_base(0, instructions.at(i), 0)))
		{
			index = i + 1;
			this->vm_imagebase_preferred_offset = instructions.at(i).get_operand_data<uint32_t>(1);
			return true;
		}
		else if (instructions.at(i).is_mnemonic(UD_Icmp))
			break;
	}
	
	return false;
}

bool wild_context::parse_vm_imagebase_preferred(instruction_container& instructions, std::size_t& index)
{
	this->vm_imagebase_preferred = 0;

	for (std::size_t i = index; i < instructions.size(); i++)
	{
		/* 0: mov dword ptr [reg+reg],imm32 */
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) &&
			instructions.at(i).has_operand_base(0) &&
			instructions.at(i).has_operand_index(0) &&
			instructions.at(i).has_operand_scale_not(0) &&
			instructions.at(i).has_operand_data_not(0) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD))
		{
			index = i + 1;
			this->vm_imagebase_preferred = instructions.at(i).get_operand_data<uint32_t>(1);
			return true;
		}
		else if (instructions.at(i).is_mnemonic(UD_Icmp))
			break;
	}
	
	return false;
}

bool wild_context::parse_vm_opcode_offset(instruction_container& instructions, std::size_t& index)
{
	this->vm_opcode_offset = 0;

	for (std::size_t i = index; i < instructions.size(); i++)
	{
		/*
			0: mov reg,imm32
			1: mov reg,dword ptr [esp+28]
		*/
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD) &&

			instructions.at(i + 1).is_mnemonic(UD_Imov) &&
			instructions.at(i + 1).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i + 1).is_operand_base_not(0, UD_R_ESP) &&
			instructions.at(i + 1).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
			instructions.at(i + 1).is_operand_base(1, UD_R_ESP) &&
			instructions.at(i + 1).has_operand_index_not(1) &&
			instructions.at(i + 1).has_operand_scale_not(1) &&
			instructions.at(i + 1).is_operand_data(1, 0x28))
		{
			index = i + 1;
			this->vm_opcode_offset = instructions.at(i).get_operand_data<uint32_t>(1);
			return true;
		}
		else if (instructions.at(i).is_mnemonic(UD_Icmp))
			break;
	}
	
	return false;
}

bool wild_context::parse_vm_handler_table(instruction_container& instructions, std::size_t& index)
{
	this->vm_handler_table = 0;

	for (std::size_t i = index, stage = 0; i < instructions.size(); i++)
	{
		/* 0: mov reg,dword ptr [esp+28] */
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_base_not(0, UD_R_ESP) &&
			instructions.at(i).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_base(1, UD_R_ESP) &&
			instructions.at(i).has_operand_index_not(1) &&
			instructions.at(i).has_operand_scale_not(1) &&
			instructions.at(i).is_operand_data(1, 0x28))
		{
			stage++;
		}
		/* 0: mov reg,imm32 */
		else if (stage == 1 &&
			instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_base_not(0, UD_R_ESP) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD) &&
			instructions.at(i).has_operand_data(1))
		{
			index = i + 1;
			this->vm_handler_table = this->vm_imagebase + instructions.at(i).get_operand_data<uint32_t>(1);
			return true;
		}
		else if (instructions.at(i).is_mnemonic(UD_Icmp))
			break;
	}
	
	return false;
}

bool wild_context::parse_vm_handler_table_offset(instruction_container& instructions, std::size_t& index)
{
	this->vm_handler_table_offset = 0;

	for (std::size_t i = index; i < instructions.size(); i++)
	{
		/* 
			0: mov reg,imm32
			1: mov reg,dword ptr [reg+reg]
		*/
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD) &&

			instructions.at(i + 1).is_mnemonic(UD_Imov) &&
			instructions.at(i + 1).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i + 1).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
			(instructions.at(i + 1).is_operand_base(1, instructions.at(i), 0) ||
			instructions.at(i + 1).is_operand_index_by_base(1, instructions.at(i), 0)))
		{
			index = i + 1;
			this->vm_handler_table_offset = instructions.at(i).get_operand_data<uint32_t>(1);
			return true;
		}
		else if (instructions.at(i).is_mnemonic(UD_Icmp))
			break;
	}
	
	return false;
}

bool wild_context::parse_vm_handler_count(instruction_container& instructions, std::size_t& index)
{
	this->vm_handler_count = 0;
	
	if (instructions.find_mnemonic_index(UD_Ipush, index))
	{
		for (std::size_t i = index; i < instructions.size(); i++)
		{
			/*
				0: push reg
				1: mov reg,imm32
			*/
			if (instructions.at(i).is_mnemonic(UD_Ipush) &&
				instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&

				instructions.at(i + 1).is_mnemonic(UD_Imov) &&
				instructions.at(i + 1).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
				instructions.at(i + 1).is_operand_base(0, instructions.at(i), 0) &&
				instructions.at(i + 1).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD))
			{
				this->vm_handler_count = (instructions.at(i + 1).get_operand_data<uint32_t>(1) >> 2);
				return true;
			}
			else if (instructions.at(i).is_mnemonic(UD_Ipush))
				break;
		}
	}

	return false;
}
```

`TDE/wild_context.hpp`:

```hpp
#ifndef WILD_CONTEXT_HPP_
#define WILD_CONTEXT_HPP_

#include "segment_manager.hpp"
#include "instruction_container.hpp"

#include "wild_context_keys.hpp"
#include "wild_opcode_label_manager.hpp"

#include <map>

class wild_context : public segment_manager, public wild_context_keys, public wild_opcode_label_manager
{
public:
	virtual void clear();
	
	void set_initial_parameters(uint32_t virtual_opcode, uint32_t handler_offset);
	void prepare_initial_parameters();	

public:
	bool is_key_access_instruction(ud_instruction& instruction, bool allow_mov);
	bool is_opcode_access_instruction(ud_instruction& instruction);

public:
	ud_type get_vm_register(uint16_t id);
	ud_type get_vm_high_byte_register(uint16_t id);
	bool set_vm_register(uint16_t id, ud_type type);
	
	ud_mnemonic_code get_mnemonic(uint8_t id);
	bool set_mnemonic(uint8_t id, ud_mnemonic_code mnemonic);

	ud_mnemonic_code get_jcc_mnemonic(uint8_t id);
	bool set_jcc_mnemonic(uint8_t id, ud_mnemonic_code mnemonic);

public:
	bool decode_zero_data(uint32_t vm_entrance);
	
private:
	bool parse_zero_data(instruction_container& instructions);

	bool parse_image_base(instruction_container& instructions, std::size_t& index);
	bool parse_vm_context(instruction_container& instructions, std::size_t& index);
	bool parse_vm_imagebase_offset(instruction_container& instructions, std::size_t& index);
	bool parse_vm_imagebase_preferred_offset(instruction_container& instructions, std::size_t& index);
	bool parse_vm_imagebase_preferred(instruction_container& instructions, std::size_t& index);
	bool parse_vm_opcode_offset(instruction_container& instructions, std::size_t& index);
	bool parse_vm_handler_table(instruction_container& instructions, std::size_t& index);
	bool parse_vm_handler_table_offset(instruction_container& instructions, std::size_t& index);
	bool parse_vm_handler_count(instruction_container& instructions, std::size_t& index);

public:
	bool initialized_crypto_offset;
	uint16_t crypto_offset;

	uint32_t vm_imagebase;
	uint32_t vm_context;					// Unknown 1 (00416D4E)
	uint32_t vm_imagebase_offset;			// Unknown 2 (00000075)
	uint32_t vm_imagebase_preferred_offset;	// Unknown 3 (0000003F)
	uint32_t vm_imagebase_preferred;		// Unknown 4 (00400000)
	uint32_t vm_opcode_offset;				// Unknown 5 (00000008)
	uint32_t vm_handler_table;				// Unknown 6 (004346A1)
	uint32_t vm_handler_table_offset;		// Unknown 7 (0000004F)
	uint32_t vm_handler_count;				// Unknown 8 (00000086)
	
	bool initialized_jcc_types;
	bool initialized_eflags_types;
	
	uint32_t step_params[5];
	
	/* ... */
	uint32_t initial_virtual_opcode;
	uint32_t current_virtual_opcode;
	
	uint32_t initial_handler_offset;
	uint32_t current_handler_offset;

	/* ... */
	int32_t current_register_type;
	uint16_t register_addr1_id;
	uint16_t register_addr2_id;

private:
	std::map<uint16_t, ud_type> register_types;
	std::map<uint8_t, ud_mnemonic_code> mnemonic_types;
	std::map<uint8_t, ud_mnemonic_code> jcc_mnemonic_types;
};

#endif
```

`TDE/wild_context_keys.cpp`:

```cpp
#include "wild_context_keys.hpp"

void wild_context_keys::reset_keys()
{
	this->keys.clear();
}

void wild_context_keys::reset_key_data()
{
	for (std::size_t i = 0; i < this->keys.size(); i++)
		this->keys.at(i).second = 0;
}

void wild_context_keys::add_key(uint32_t offset)
{
	this->keys.push_back(std::make_pair(offset, 0));
}

bool wild_context_keys::set_key(uint32_t offset, uint32_t data)
{
	for (std::size_t i = 0; i < this->keys.size(); i++)
	{
		if (this->keys.at(i).first == offset)
		{
			this->keys.at(i).second = data;
			return true;
		}
	}

	return false;
}

bool wild_context_keys::get_key(uint32_t offset, uint32_t* data) const
{
	for (std::size_t i = 0; i < this->keys.size(); i++)
	{
		if (this->keys.at(i).first == offset)
		{
			if (data != nullptr)
				*data = this->keys.at(i).second;

			return true;
		}
	}
		
	return false;
}

uint32_t wild_context_keys::get_key_offset(uint8_t index) const
{
	return (index < this->keys.size() ? this->keys.at(index).first : 0);
}

uint32_t wild_context_keys::get_key_data(uint8_t index) const
{
	return (index < this->keys.size() ? this->keys.at(index).second : 0);
}
```

`TDE/wild_context_keys.hpp`:

```hpp
#ifndef WILD_CONTEXT_KEYS_HPP_
#define WILD_CONTEXT_KEYS_HPP_

#include <stdint.h>
#include <vector>

class wild_context_keys
{
public:
	void reset_keys();
	void reset_key_data();

	void add_key(uint32_t offset);

	bool set_key(uint32_t offset, uint32_t data);
	bool get_key(uint32_t offset, uint32_t* data) const;

	uint32_t get_key_offset(uint8_t index) const;
	uint32_t get_key_data(uint8_t index) const;

private:
	/* <T1 = context_offset, T2 = key_data> */
	std::vector<std::pair<uint32_t, uint32_t>> keys;
};

#endif
```

`TDE/wild_handler.cpp`:

```cpp
#include "wild_handler.hpp"
#include "instruction_emulator.hpp"

#include <idp.hpp>

#include <algorithm>

bool wild_handler::map_handler_specific(instruction_container& instructions, wild_context& context)
{
	/* Placeholder for virtual function */
	return false;
}

bool wild_handler::step_handler_specific(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	/* Placeholder for virtual function */
	return false;
}

wild_handler::wild_handler(uint16_t index)
{
	this->id = WILD_HANDLER_INVALID;
	this->index = index;

	this->opcode_size = OPCODE_SIZE_INVALID;
	this->cmp_count = 0;
}

uint16_t wild_handler::get_id()
{
	return this->id;
}

bool wild_handler::is_flow_type()
{
	return (this->id == WILD_HANDLER_JUMP_INSIDE ||
		this->id == WILD_HANDLER_JUMP_OUTSIDE_REGISTER ||
		this->id == WILD_HANDLER_JUMP_OUTSIDE_MEMORY ||
		this->id == WILD_HANDLER_JUMP_OUTSIDE_IMMEDIATE ||
		this->id == WILD_HANDLER_RET ||
		this->id == WILD_HANDLER_CALL ||
		this->id == WILD_HANDLER_UNDEF);
}

bool wild_handler::decrypt(instruction_container& instructions, wild_context& context, uint32_t compares)
{
	this->cmp_count = compares;

	if (!this->decrypt_flow_data(instructions, context))
	{
		msg("[CodeDevirtualizer] Failed to decrypt flow data for handler %04X.\n", this->index);
		return false;
	}

	if (!this->decrypt_key_data(instructions, context))
	{
		msg("[CodeDevirtualizer] Failed to decrypt key data for handler %04X.\n", this->index);
		return false;
	}
	
	if (!this->map_handler(instructions, context))
	{
		if (!this->map_handler_specific(instructions, context))
			return false;
	}

	this->decrypt_opcode_regions(instructions, context);
	this->decrypt_opcode_size(instructions, context);
	return true;
}

bool wild_handler::decrypt_key_data(instruction_container& instructions, wild_context& context)
{
	this->decrypt_key_protection_template(instructions, context);

	for (std::size_t i = 0; i < instructions.size(); i++)
	{
		if (context.is_key_access_instruction(instructions.at(i), false))
		{
			bool is_base_operand_key = instructions.at(i).is_operand_type(0, UD_OP_MEM);

			unsigned int operand_key = (is_base_operand_key ? 0 : 1);
			unsigned int operand_data = (is_base_operand_key ? 1 : 0);
				
			wild_handler_key key_access;
			
			key_access.id = instructions.at(i).get_operand_data<uint16_t>(operand_key);
			key_access.index = instructions.at(i).get_index();

			key_access.mnemonic = instructions.at(i).get_mnemonic();
			key_access.operand = operand_key;

			key_access.type = instructions.at(i).get_operand_type(operand_data);
			key_access.size = instructions.at(i).get_operand_size(operand_data);

			if (instructions.at(i).get_key_data() & HAS_KEY_DATA_FLAG)
			{
				if (!is_base_operand_key)
				{
					msg("[CodeDevirtualizer] Direct access key is not base operand.\n");
					return false;
				}

				key_access.direct_key_parameter = true;
				key_access.parameter = instructions.at(i).get_key_data() & 0x7FFFFFFF;

				instructions.at(i).set_key_data(0);
			}
			else
			{
				key_access.direct_key_parameter = false;
				key_access.parameter = instructions.at(i).get_params(operand_data);
			}

			instructions.remove(i--);
			this->key_accessors.push_back(key_access);
		}
	}
	
	std::sort(this->key_accessors.begin(), this->key_accessors.end());
	return true;
}

void wild_handler::decrypt_key_protection_template(instruction_container& instructions, wild_context& context)
{
	for (std::size_t i = 0; i < instructions.size(); i++)
	{
		/* 0: mov reg,unknown ptr [ebp+xx] */
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG) &&
			context.is_key_access_instruction(instructions.at(i), true))
		{
			for (std::size_t j = (i + 1), binary_offset = 0; j < instructions.size(); j++)
			{
				if (instructions.at(j).is_operand_type(0, UD_OP_REG) &&
					instructions.at(j).is_operand_base(0, instructions.at(i), 0))
				{
					/* 1: ___ reg,___ */
					if (binary_offset == 0 &&
						instructions.at(j).compare_mnemonic(false, false, true))
					{
						binary_offset = j;
					}
					/*
						2: cmp reg,0x0
						3: je ___
						4: ___ unknown ptr [ebp+xx],___
					*/
					else if (binary_offset != 0 &&
						instructions.bounds(j, 3) &&
						instructions.at(j).is_mnemonic(UD_Icmp) &&
						instructions.at(j).is_operand_type(1, UD_OP_IMM) &&
						instructions.at(j).is_operand_data(1, 0) &&
						instructions.at(j + 1).is_mnemonic(UD_Ijz) &&
						instructions.at(j + 2).compare_mnemonic(false, false, true) &&
						instructions.at(j + 2).is_operand_type(0, UD_OP_MEM) &&
						context.is_key_access_instruction(instructions.at(j + 2), true) &&
						instructions.at(j + 2).is_operand_data(0, instructions.at(i), 1))
					{
						wild_handler_key key_access;
			
						key_access.id = instructions.at(j + 2).get_operand_data<uint16_t>(0);
						key_access.index = instructions.at(i).get_index();
						
						key_access.mnemonic = instructions.at(j + 2).get_mnemonic();
						key_access.operand = 0;

						key_access.type = instructions.at(j + 2).get_operand_type(1);
						key_access.size = instructions.at(j + 2).get_operand_size(0);

						key_access.direct_key_parameter = false;
						key_access.parameter = instructions.at(j + 2).get_params(1);
						
						key_access.condition = [](wild_context const& context, wild_handler_key const& key_accessor) -> bool
						{
							uint32_t key_data = 0;

							if (!context.get_key(key_accessor.id, &key_data))
								return false;
							
							return ((key_data & 1) != 0);
						};

						this->key_accessors.push_back(key_access);
						
						instructions.remove(j, 3);
						instructions.remove(binary_offset);
						instructions.remove(i--);
						break;
					}
					else
					{
						break;
					}
				}
			}
		}
	}
}

std::size_t wild_handler::find_first_key_after(std::size_t index)
{
	for (std::size_t i = 0; i < this->key_accessors.size(); i++)
	{
		if (this->key_accessors.at(i).index >= index)
			return i;
	}

	return static_cast<std::size_t>(-1);
}

std::size_t wild_handler::find_last_key_before(std::size_t index)
{
	for (std::size_t i = (this->key_accessors.size() - 1); static_cast<int32_t>(i) >= 0; i--)
	{
		if (this->key_accessors.at(i).index <= index)
			return i;
	}
		
	return static_cast<std::size_t>(-1);
}
	
void wild_handler::decrypt_opcode_size(instruction_container& instructions, wild_context& context)
{
	if (instructions.back().is_mnemonic(UD_Iret))
		this->opcode_size = OPCODE_SIZE_RETN;
	else if (instructions.back().is_mnemonic(UD_Ijmp))
	{
		std::size_t index = (instructions.size() - 2);

		if (context.is_opcode_access_instruction(instructions.at(index)))
		{
			if (instructions.at(index).is_mnemonic(UD_Isub))
				this->opcode_size = OPCODE_SIZE_SUB;
			else if (instructions.at(index).is_mnemonic(UD_Iadd))
				this->opcode_size = instructions.at(index).get_operand_data<uint16_t>(1);
		}
	}
}

void wild_handler::decrypt_opcode_regions(instruction_container& instructions, wild_context& context)
{
	for (std::size_t i = 0; i < instructions.size(); i++)
	{
		/* 0: mov reg,dword ptr [ebp+xx] */
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG) &&
			context.is_opcode_access_instruction(instructions.at(i)))
		{
			uint16_t opcode_offset = 0xFFFF;

			ud_type type = UD_NONE;
			ud_size size = UD_SIZE_NONE;

			std::size_t offset = 0;

			for (std::size_t j = i + 1; j < instructions.size(); j++)
			{
				if (instructions.at(j).is_mnemonic(UD_Iadd) &&
					instructions.at(j).is_operand_type(0, UD_OP_REG) &&
					instructions.at(j).is_operand_base(0, instructions.at(i), 0) &&
					instructions.at(j).is_operand_type(1, UD_OP_IMM))
				{
					opcode_offset = instructions.at(j).get_operand_data<uint16_t>(1);
				}
				else if (instructions.at(j).is_mnemonic({ UD_Imov, UD_Imovzx }) &&
					instructions.at(j).is_operand_type(1, UD_OP_MEM) &&
					instructions.at(j).is_operand_base(1, instructions.at(i), 0))
				{
					type = instructions.at(j).get_base_size_type(0, UD_SIZE_DWORD);
					size = instructions.at(j).get_operand_size(1);
					offset = j;
					break;
				}
				else if (instructions.at(j).is_mnemonic(UD_Imov) &&
					instructions.at(j).is_operand_type(0, UD_OP_REG) &&
					instructions.at(j).is_operand_base(0, instructions.at(i), 0))
				{
					break;
				}
			}
			
			if (opcode_offset != 0xFFFF && type != UD_NONE)
			{
				std::size_t index = offset;
				std::vector<std::size_t> indexes;

				while (instructions.bounds(++index) && 
					index < this->flow_read_index)
				{
					for (std::size_t j = 0; j < this->key_accessors.size(); j++)
					{
						wild_handler_key& key = this->key_accessors.at(j);

						if (key.index == index)
						{
							if (key.type == UD_OP_REG &&
								instructions.at(offset).is_operand_base_family(0, static_cast<ud_type>(key.parameter)))
							{
								indexes.push_back(index);
							}

							break;
						}
					}
					
					if (instructions.at(index).is_mnemonic(UD_Imov) &&
						instructions.at(index).is_operand_type(0, UD_OP_REG) &&
						instructions.at(index).is_operand_base_family(0, instructions.at(i), 0))
					{
						break;
					}
				}

				if (!indexes.empty())
					this->opcode_regions.push_back({ opcode_offset, size, indexes.front(), indexes.back() });
			}
		}
	}
}

bool wild_handler::map_handler(instruction_container& instructions, wild_context& context)
{
	return (this->map_handler_jmp(instructions, context) ||
		this->map_handler_jcc(instructions, context) ||
		this->map_handler_retn(instructions, context) ||
		this->map_handler_undef(instructions, context) ||
		this->map_handler_lods(instructions, context) ||
		this->map_handler_stos(instructions, context) ||
		this->map_handler_scas(instructions, context) ||
		this->map_handler_cmps(instructions, context) ||
		this->map_handler_movs(instructions, context) ||
		this->map_handler_eflags(instructions, context) ||
		this->map_handler_stack(instructions, context) ||
		this->map_handler_reset_eflags(instructions, context) ||
		this->map_handler_reset(instructions, context) ||
		this->map_handler_crypt(instructions, context));
}

bool wild_handler::map_handler_jmp(instruction_container& instructions, wild_context& context)
{
	if (instructions.bounds(0, 16) &&
		instructions.at(0).is_mnemonic(UD_Imov) &&
		instructions.at(1).is_mnemonic(UD_Iadd) &&
		instructions.at(2).is_mnemonic(UD_Imov) &&
		instructions.at(3).is_mnemonic(UD_Ishl) &&
		instructions.at(4).is_mnemonic(UD_Imov) &&
		instructions.at(5).is_mnemonic(UD_Iadd) &&
		instructions.at(6).is_mnemonic(UD_Imov) &&
		instructions.at(7).is_mnemonic(UD_Imov) &&
		instructions.at(8).is_mnemonic(UD_Iadd) &&
		instructions.at(9).is_mnemonic(UD_Imov) &&
		instructions.at(10).is_mnemonic(UD_Imov) &&
		instructions.at(11).is_mnemonic(UD_Iand) &&
		instructions.at(12).is_mnemonic(UD_Icmp) &&
		instructions.at(13).is_mnemonic(UD_Ijz) &&
		instructions.at(14).is_mnemonic(UD_Iand) &&
		instructions.at(15).is_mnemonic(UD_Isub) &&
		instructions.at(16).is_mnemonic(UD_Ijmp))
	{
		this->id = WILD_HANDLER_JUMP_INSIDE;
		this->opcode_offsets[0] = instructions.at(1).get_loword(1);
		this->opcode_offsets[1] = instructions.at(8).get_loword(1);
		return true;
	}
	else if (instructions.bounds(0, 10) &&
		instructions.at(0).is_mnemonic(UD_Imov) &&
		instructions.at(1).is_mnemonic(UD_Iadd) &&
		instructions.at(2).is_mnemonic(UD_Imov) &&
		instructions.at(3).is_mnemonic(UD_Iadd) &&
		instructions.at(4).is_mnemonic(UD_Imov) &&
		instructions.at(4).is_operand_base(1, instructions.at(3), 0) &&
		instructions.at(5).is_mnemonic(UD_Imov) &&
		instructions.at(6).is_mnemonic(UD_Iadd) &&
		instructions.at(7).is_mnemonic(UD_Imov) &&
		instructions.at(8).is_mnemonic(UD_Iadd) &&
		instructions.at(9).is_mnemonic(UD_Imov) &&
		instructions.at(9).is_operand_base(1, instructions.at(4), 0) &&
		instructions.at(10).is_mnemonic(UD_Imov))
	{
		this->id = WILD_HANDLER_JUMP_OUTSIDE_REGISTER;
		this->opcode_offsets[0] = instructions.at(1).get_loword(1);
		return true;
	}
	else if (instructions.bounds(0, 11) &&
		instructions.at(0).is_mnemonic(UD_Imov) &&
		instructions.at(1).is_mnemonic(UD_Iadd) &&
		instructions.at(2).is_mnemonic(UD_Imov) &&
		instructions.at(3).is_mnemonic(UD_Iadd) &&
		instructions.at(4).is_mnemonic(UD_Imov) &&
		instructions.at(4).is_operand_base(1, instructions.at(3), 0) &&
		instructions.at(5).is_mnemonic(UD_Imov) &&
		instructions.at(5).is_operand_base(1, instructions.at(4), 0) &&
		instructions.at(6).is_mnemonic(UD_Imov) &&
		instructions.at(7).is_mnemonic(UD_Iadd) &&
		instructions.at(8).is_mnemonic(UD_Imov) &&
		instructions.at(9).is_mnemonic(UD_Iadd) &&
		instructions.at(10).is_mnemonic(UD_Imov) &&
		instructions.at(11).is_mnemonic(UD_Imov))
	{
		this->id = WILD_HANDLER_JUMP_OUTSIDE_MEMORY;
		this->opcode_offsets[0] = instructions.at(1).get_loword(1);
		return true;
	}
	else if (instructions.bounds(0, 18) &&
		instructions.at(0).is_mnemonic(UD_Imov) &&
		instructions.at(1).is_mnemonic(UD_Iadd) &&
		instructions.at(2).is_mnemonic(UD_Imov) &&
		instructions.at(3).is_mnemonic(UD_Iadd) &&
		instructions.at(4).is_mnemonic(UD_Imov) &&
		instructions.at(5).is_mnemonic(UD_Iadd) &&
		instructions.at(6).is_mnemonic(UD_Imov) &&
		instructions.at(7).is_mnemonic(UD_Iadd) &&
		instructions.at(7).is_operand_type(1, UD_OP_REG, UD_SIZE_DWORD) &&
		instructions.at(7).is_operand_base(1, UD_R_ESP) &&
		instructions.at(8).is_mnemonic(UD_Imov) &&
		instructions.at(9).is_mnemonic(UD_Imov) &&
		instructions.at(10).is_mnemonic(UD_Ipop) &&
		instructions.at(11).is_mnemonic(UD_Ipop) &&
		instructions.at(12).is_mnemonic(UD_Ipop) &&
		instructions.at(13).is_mnemonic(UD_Ipop) &&
		instructions.at(14).is_mnemonic(UD_Ipop) &&
		instructions.at(15).is_mnemonic(UD_Ipop) &&
		instructions.at(16).is_mnemonic(UD_Ipop) &&
		instructions.at(17).is_mnemonic({ UD_Ipopfw, UD_Ipopfd, UD_Ipopfq }) &&
		instructions.at(18).is_mnemonic(UD_Iret))
	{
		this->id = WILD_HANDLER_JUMP_OUTSIDE_IMMEDIATE;
		this->opcode_offsets[0] = instructions.at(1).get_loword(1);
		return true;
	}

	return false;
}
	
bool wild_handler::map_handler_jcc(instruction_container& instructions, wild_context& context)
{
	if (instructions.bounds(0, 14) &&
		instructions.at(0).is_mnemonic(UD_Imov) &&
		instructions.at(1).is_mnemonic(UD_Imov) &&
		instructions.at(2).is_mnemonic(UD_Iadd) &&
		instructions.at(3).is_mnemonic(UD_Imov) &&
		instructions.at(4).is_mnemonic(UD_Iadd) &&
		instructions.at(5).is_mnemonic(UD_Imov) &&
		instructions.at(6).is_mnemonic(UD_Imov) &&
		instructions.at(7).is_mnemonic(UD_Iadd) &&
		instructions.at(8).is_mnemonic(UD_Imov) &&
		instructions.at(9).is_mnemonic(UD_Icmp) &&
		instructions.at(10).is_mnemonic(UD_Ijz) &&
		instructions.at(11).is_mnemonic(UD_Icmp) &&
		instructions.at(12).is_mnemonic(UD_Ijz) &&
		instructions.at(13).is_mnemonic(UD_Icmp) &&
		instructions.at(14).is_mnemonic(UD_Ijnz))
	{
		std::size_t index = (instructions.size() - 25);

		if (instructions.bounds(0, 25) &&
			instructions.find_mnemonic_index(UD_Iret, index))
		{
			this->id = WILD_HANDLER_JCC_OUTSIDE;
		}
		else
		{
			this->id = WILD_HANDLER_JCC_INSIDE;
		}
		
		this->opcode_offsets[0] = instructions.at(7).get_loword(1);
		return this->parse_jcc_parameters(instructions, context);
	}

	return false;
}

bool wild_handler::map_handler_retn(instruction_container& instructions, wild_context& context)
{
	for (std::size_t i = 2; i < 15 && i < instructions.size(); i++)
	{
		/* 0: std */
		if (instructions.at(i).is_mnemonic(UD_Istd))
		{
			this->id = WILD_HANDLER_RET;
			this->opcode_offsets[0] = instructions.at(1).get_loword(1);
			return true;
		}
	}
	
	return false;
}

bool wild_handler::map_handler_undef(instruction_container& instructions, wild_context& context)
{
	if (instructions.bounds(0, 10) &&
		instructions.at(0).is_mnemonic(UD_Imov) &&
		instructions.at(1).is_mnemonic(UD_Iadd) &&
		instructions.at(2).is_mnemonic(UD_Imov) &&
		instructions.at(3).is_mnemonic(UD_Icmp) &&
		instructions.at(4).is_mnemonic(UD_Ijz) &&
		instructions.at(5).is_mnemonic(UD_Icmp) &&
		instructions.at(6).is_mnemonic(UD_Ijz) &&
		instructions.at(7).is_mnemonic(UD_Imov) &&
		instructions.at(8).is_mnemonic(UD_Iadd) &&
		instructions.at(9).is_mnemonic(UD_Imov) &&
		instructions.at(10).is_mnemonic(UD_Iadd))
	{
		this->id = WILD_HANDLER_UNDEF;
		this->opcode_offsets[0] = instructions.at(1).get_loword(1);
		this->opcode_offsets[1] = instructions.at(8).get_loword(1);
		return true;
	}
	
	return false;
}
	
bool wild_handler::map_handler_lods(instruction_container& instructions, wild_context& context)
{
	std::size_t pop_index = 18;

	/*
		0: mov ___,___
		1: and ___,___
		2: pop ___
	*/
	if (instructions.find_mnemonic_index(UD_Ipop, pop_index) &&
		instructions.at(pop_index - 2).is_mnemonic(UD_Imov) &&
		instructions.at(pop_index - 1).is_mnemonic(UD_Iand))
	{
		std::size_t index = 2;
		
		/* 0: push reg */
		if (instructions.find_mnemonic_index(UD_Ipush, index) &&
			index < 15 &&
			instructions.at(index).is_operand_type(0, UD_OP_REG))
		{
			std::size_t memory_index = static_cast<std::size_t>(-1);

			for (std::size_t i = index; i < 16 && i < instructions.size(); i++)
			{
				/* 0: mov unknown ptr [reg],___ */
				if (instructions.at(i).is_mnemonic(UD_Imov) &&
					instructions.at(i).is_operand_type(0, UD_OP_MEM))
				{
					memory_index = i;
					break;
				}
			}
			
			/*
				3: cmp ___,0x0
				4: je  ___
				5: sub ___,___
			*/
			if (memory_index != static_cast<std::size_t>(-1) &&
				instructions.bounds(pop_index, 3) &&
				instructions.at(pop_index + 1).is_mnemonic(UD_Icmp) &&
				instructions.at(pop_index + 1).is_operand_type(1, UD_OP_IMM) &&
				instructions.at(pop_index + 1).is_operand_data(1, 0) &&
				instructions.at(pop_index + 2).is_mnemonic(UD_Ijz) &&
				instructions.at(pop_index + 3).is_mnemonic(UD_Isub))
			{
				if (instructions.at(memory_index).is_operand_base_not(0, instructions.at(index), 0))
				{
					switch (instructions.at(pop_index + 3).get_operand_data(1))
					{
					case 1:
						this->id = WILD_HANDLER_LODSB;
						return true;

					case 2:
						this->id = WILD_HANDLER_LODSW;
						return true;

					case 4:
						this->id = WILD_HANDLER_LODSD;
						return true;

					default:
						break;
					}
				}
			}
		}
	}

	return false;
}

bool wild_handler::map_handler_stos(instruction_container& instructions, wild_context& context)
{
	std::size_t pop_index = 18;

	/*
		0: mov ___,___
		1: and ___,___
		2: pop ___
	*/
	if (instructions.find_mnemonic_index(UD_Ipop, pop_index) &&
		instructions.at(pop_index - 2).is_mnemonic(UD_Imov) &&
		instructions.at(pop_index - 1).is_mnemonic(UD_Iand))
	{
		std::size_t index = 2;
		
		/* 0: push reg */
		if (instructions.find_mnemonic_index(UD_Ipush, index) &&
			index < 15 &&
			instructions.at(index).is_operand_type(0, UD_OP_REG))
		{
			std::size_t memory_index = static_cast<std::size_t>(-1);

			for (std::size_t i = index; i < 16 && i < instructions.size(); i++)
			{
				/* 0: mov unknown ptr [reg],___ */
				if (instructions.at(i).is_mnemonic(UD_Imov) &&
					instructions.at(i).is_operand_type(0, UD_OP_MEM))
				{
					memory_index = i;
					break;
				}
			}
			
			/*
				3: cmp ___,0x0
				4: je  ___
				5: sub ___,___
			*/
			if (memory_index != static_cast<std::size_t>(-1) &&
				instructions.bounds(pop_index, 3) &&
				instructions.at(pop_index + 1).is_mnemonic(UD_Icmp) &&
				instructions.at(pop_index + 1).is_operand_type(1, UD_OP_IMM) &&
				instructions.at(pop_index + 1).is_operand_data(1, 0) &&
				instructions.at(pop_index + 2).is_mnemonic(UD_Ijz) &&
				instructions.at(pop_index + 3).is_mnemonic(UD_Isub))
			{
				if (instructions.at(memory_index).is_operand_base(0, instructions.at(index), 0))
				{
					switch (instructions.at(pop_index + 3).get_operand_data(1))
					{
					case 1:
						this->id = WILD_HANDLER_STOSB;
						return true;

					case 2:
						this->id = WILD_HANDLER_STOSW;
						return true;

					case 4:
						this->id = WILD_HANDLER_STOSD;
						return true;

					default:
						break;
					}
				}
			}
		}
	}

	return false;
}

bool wild_handler::map_handler_scas(instruction_container& instructions, wild_context& context)
{
	std::size_t index = 10;

	/*
		11: sub ___,___
		12: pushfd
	*/
	if (instructions.find_mnemonic_index(UD_Ipushfd, index) &&
		instructions.at(index - 1).is_mnemonic(UD_Isub))
	{
		/* 
			0: cmp ___,0x0
			1: je  ___
			2: sub ___,imm
		*/
		if (instructions.find_mnemonic_index(UD_Icmp, index) &&
			instructions.bounds(index, 2) &&
			instructions.at(index).is_operand_type(1, UD_OP_IMM) &&
			instructions.at(index).is_operand_data(1, 0) &&
			instructions.at(index + 1).is_mnemonic(UD_Ijz) &&
			instructions.at(index + 2).is_mnemonic(UD_Isub) &&
			instructions.at(index + 2).is_operand_type(1, UD_OP_IMM))
		{
			switch (instructions.at(index + 2).get_operand_data(1))
			{
			case 1:
				this->id = WILD_HANDLER_SCASB;
				return true;

			case 2:
				this->id = WILD_HANDLER_SCASW;
				return true;

			case 4:
				this->id = WILD_HANDLER_SCASD;
				return true;

			default:
				break;
			}
		}
	}

	return false;
}

bool wild_handler::map_handler_cmps(instruction_container& instructions, wild_context& context)
{
	std::size_t index = 10;

	/*
		0: cmp ___,___
		1: pushfd
	*/
	if (instructions.find_mnemonic_index(UD_Ipushfd, index) &&
		instructions.at(index - 1).is_mnemonic(UD_Icmp))
	{
		/* 
			0: cmp ___,0x0
			1: je  ___
			2: sub ___,imm
			3: sub ___,___
		*/
		if (instructions.find_mnemonic_index(UD_Icmp, index) &&
			instructions.bounds(index, 3) &&
			instructions.at(index).is_operand_type(1, UD_OP_IMM) &&
			instructions.at(index).is_operand_data(1, 0) &&
			instructions.at(index + 1).is_mnemonic(UD_Ijz) &&
			instructions.at(index + 2).is_mnemonic(UD_Isub) &&
			instructions.at(index + 2).is_operand_type(1, UD_OP_IMM) &&
			instructions.at(index + 3).is_mnemonic(UD_Isub))
		{
			switch (instructions.at(index + 2).get_operand_data(1))
			{
			case 1:
				this->id = WILD_HANDLER_CMPSB;
				return true;

			case 2:
				this->id = WILD_HANDLER_CMPSW;
				return true;

			case 4:
				this->id = WILD_HANDLER_CMPSD;
				return true;

			default:
				break;
			}
		}
	}

	return false;
}

bool wild_handler::map_handler_movs(instruction_container& instructions, wild_context& context)
{
	std::size_t memory_index = static_cast<std::size_t>(-1);

	for (std::size_t i = 10; i < 25 && i < instructions.size(); i++)
	{
		/* 0: mov unknown ptr [reg],___ */
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_MEM))
		{
			memory_index = i;
			break;
		}
	}

	std::size_t index = memory_index;
			
	/*
		0: cmp ___,0x0
		1: je  ___
		2: sub ___,___
		3: sub ___,imm
	*/
	if ((memory_index != static_cast<std::size_t>(-1) &&
		instructions.find_mnemonic_index(UD_Icmp, index) &&
		instructions.bounds(index, 3) &&
		((index - memory_index) >= 10 && (index - memory_index) <= 20)) &&
		instructions.at(index).is_operand_type(1, UD_OP_IMM) &&
		instructions.at(index).is_operand_data(1, 0) &&
		instructions.at(index + 1).is_mnemonic(UD_Ijz) &&
		instructions.at(index + 2).is_mnemonic(UD_Isub) &&
		instructions.at(index + 3).is_mnemonic(UD_Isub) &&
		instructions.at(index + 3).is_operand_type(1, UD_OP_IMM))
	{
		switch (instructions.at(index + 3).get_operand_data(1))
		{
		case 1:
			this->id = WILD_HANDLER_MOVSB;
			return true;

		case 2:
			this->id = WILD_HANDLER_MOVSW;
			return true;

		case 4:
			this->id = WILD_HANDLER_MOVSD;
			return true;

		default:
			break;
		}
	}

	return false;
}
	
bool wild_handler::map_handler_eflags(instruction_container& instructions, wild_context& context)
{
	if (instructions.bounds(0, 8) &&
		instructions.at(0).is_mnemonic(UD_Imov) &&
		instructions.at(1).is_mnemonic(UD_Iadd) &&
		instructions.at(2).is_mnemonic(UD_Imov) &&
		instructions.at(3).is_mnemonic(UD_Iadd) &&
		instructions.at(3).is_operand_type(1, UD_OP_REG) &&
		instructions.at(4).is_mnemonic(UD_Imov) &&
		instructions.at(5).is_mnemonic(UD_Iadd) &&
		instructions.at(6).is_mnemonic(UD_Imov) &&
		instructions.at(7).is_mnemonic(UD_Icmp) &&
		instructions.at(8).is_mnemonic(UD_Ijnz))
	{
		this->id = WILD_HANDLER_EFLAGS;
		this->opcode_offsets[0] = instructions.at(1).get_loword(1);
		this->opcode_offsets[1] = instructions.at(5).get_loword(1);
		return this->parse_eflags_parameters(instructions, context);
	}
	else
	{
		std::vector<std::pair<std::size_t, ud_instruction>> matches;

		for (std::size_t i = 0; i < instructions.size(); i++)
		{
			/* 0: mov reg,dword ptr [ebp+xx] */
			if (instructions.at(i).is_mnemonic(UD_Imov) &&
				instructions.at(i).is_operand_type(0, UD_OP_REG) &&
				context.is_opcode_access_instruction(instructions.at(i)))
			{
				std::size_t index = i;
				ud_instruction instruction;

				/* 0: add reg,___ */
				if (!instructions.find_index_by_register_base(instructions.at(i).get_base_type(0), ++index, instruction) ||
					instruction.is_mnemonic_not(UD_Iadd))
				{
					continue;
				}
				
				/* 1: movzx ___,unknown ptr [reg] */
				if (!instructions.find_index_by_memory_base(instructions.at(i).get_base_type(0), 1, ++index, instruction) ||
					instruction.is_mnemonic_not(UD_Imovzx))
				{
					continue;
				}
				
				ud_type data_base = instruction.get_base_type(0);
				
				/* 2: add reg,ebp */
				if (!instructions.find_index_by_register_base(data_base, ++index, instruction) ||
					instruction.is_mnemonic_not(UD_Iadd) ||
					instruction.is_operand_type_not(1, UD_OP_REG, UD_SIZE_DWORD) ||
					instruction.is_operand_base_not(1, UD_R_EBP))
				{
					continue;
				}
				
				/* 3: ___ unknown ptr [reg] */
				if (!instructions.find_index_by_memory_base(data_base, 0, ++index, instruction) ||
					index > 20)
				{
					continue;
				}

				matches.push_back(std::make_pair(index, instruction));
			}
		}
		
		if (!matches.empty())
		{
			for (std::size_t i = 0; i < 2; i++)
			{
				uint32_t offset_count = 0;
				uint32_t operation_count = 0;

				for (std::size_t j = 0; j < matches.size(); j++)
				{
					/* 3: sub/add unknown ptr [reg],0x4 */
					if (matches.at(j).second.is_mnemonic(i == 0 ? UD_Isub : UD_Iadd) &&
						matches.at(j).second.is_operand_type(1, UD_OP_IMM) &&
						matches.at(j).second.is_operand_data(1, 4))
					{
						offset_count++;
					}
					/* 3: push/pop unknown ptr [reg] */
					else if (matches.at(j).second.is_mnemonic(i == 0 ? UD_Ipush : UD_Ipop))
					{
						if (matches.at(j).second.is_mnemonic(UD_Ipush) &&
							instructions.bounds(matches.at(j).first, 1) &&
							instructions.at(matches.at(j).first + 1).is_mnemonic({ UD_Ipopfw, UD_Ipopfd, UD_Ipopfq }))
						{
							break;
						}

						operation_count++;
					}
				}

				if (offset_count == 1 && operation_count == 1)
				{
					this->id = (i == 0 ? WILD_HANDLER_PUSHFD : WILD_HANDLER_POPFD);
					return true;
				}
			}
		}
	}

	return false;
}
	
//bool wild_handler::map_handler_eflags(instruction_container& instructions, wild_context& context)
//{
//	if (instructions.bounds(0, 8) &&
//		instructions.at(0).is_mnemonic(UD_Imov) &&
//		instructions.at(1).is_mnemonic(UD_Iadd) &&
//		instructions.at(2).is_mnemonic(UD_Imov) &&
//		instructions.at(3).is_mnemonic(UD_Iadd) &&
//		instructions.at(3).is_operand_type(1, UD_OP_REG) &&
//		instructions.at(4).is_mnemonic(UD_Imov) &&
//		instructions.at(5).is_mnemonic(UD_Iadd) &&
//		instructions.at(6).is_mnemonic(UD_Imov) &&
//		instructions.at(7).is_mnemonic(UD_Icmp) &&
//		instructions.at(8).is_mnemonic(UD_Ijnz))
//	{
//		this->id = WILD_HANDLER_EFLAGS;
//		this->opcode_offsets[0] = instructions.at(1).get_loword(1);
//		this->opcode_offsets[1] = instructions.at(5).get_loword(1);
//		return this->parse_eflags_parameters(instructions, context);
//	}
//	else
//	{
//		const unsigned int eflag_types = 2;
//
//		unsigned int read_opcode_instructions = 0;
//		std::pair<std::size_t, ud_type> opcode_read_instruction[eflag_types];
//
//		for (std::size_t i = 0; i < 10 && i < instructions.size() && read_opcode_instructions < 2; i++)
//		{
//			if (context.is_opcode_access_instruction(instructions.at(i)))
//			{
//				if (!read_opcode_instructions)
//					opcode_read_instruction[0] = std::make_pair(i, instructions.at(i).get_base_type(0));
//				else
//					opcode_read_instruction[1] = std::make_pair(i, instructions.at(i).get_base_type(0));
//
//				read_opcode_instructions++;
//			}
//		}
//
//		if (read_opcode_instructions < eflag_types)
//			return false;
//
//		ud_instruction eflag_instructions[eflag_types];
//
//		for (std::size_t i = 0; i < eflag_types; i++)
//		{
//			std::size_t index = opcode_read_instruction[i].first;
//
//			/* 0: add reg,___ */
//			if (!instructions.find_index_by_register_base(opcode_read_instruction[i].second, ++index, eflag_instructions[i]) ||
//				eflag_instructions[i].is_mnemonic_not(UD_Iadd))
//			{
//				return false;
//			}
//
//			/* 1: movzx ___,unknown ptr [reg] */
//			if (!instructions.find_index_by_memory_base(opcode_read_instruction[i].second, 1, ++index, eflag_instructions[i]) ||
//				eflag_instructions[i].is_mnemonic_not({ UD_Imov, UD_Imovzx }))
//			{
//				return false;
//			}
//
//			/* For TIGER */
//			if (eflag_instructions[i].is_mnemonic(UD_Imov))
//			{
//				bool found = false;
//
//				for (std::size_t j = std::max(opcode_read_instruction[0].first, opcode_read_instruction[1].first) + 1; j < 10 && j < instructions.size(); j++)
//				{
//					if (context.is_opcode_access_instruction(instructions.at(j)))
//					{
//						opcode_read_instruction[i--] = std::make_pair(j, instructions.at(j).get_base_type(0));
//						found = true;
//						break;
//					}
//				}
//
//				if (found)
//					continue;
//			}
//
//			ud_type opcode_base = eflag_instructions[i].get_base_type(0);
//
//			/* 2: add reg,ebp */
//			if (!instructions.find_index_by_register_base(opcode_base, ++index, eflag_instructions[i]) ||
//				eflag_instructions[i].is_mnemonic_not(UD_Iadd) ||
//				eflag_instructions[i].is_operand_type_not(1, UD_OP_REG, UD_SIZE_DWORD) ||
//				eflag_instructions[i].is_operand_base_not(1, UD_R_EBP))
//			{
//				return false;
//			}
//
//			/* 3: ___ unknown ptr [reg] */
//			if (!instructions.find_index_by_memory_base(opcode_base, 0, ++index, eflag_instructions[i]) ||
//				index > 20)
//			{
//				return false;
//			}
//		}
//
//		for (std::size_t i = 0; i < 2; i++)
//		{
//			bool found = true;
//
//			for (std::size_t j = 0; j < eflag_types; j++)
//			{
//				/* 3: sub/add unknown ptr [reg],___ */
//				if (eflag_instructions[j].is_mnemonic(i == 0 ? UD_Isub : UD_Iadd))
//				{
//					/* 3: sub/add unknown ptr [reg],0x4 */
//					if (eflag_instructions[j].is_operand_type_not(1, UD_OP_IMM) ||
//						eflag_instructions[j].is_operand_data_not(1, 4))
//					{
//						found = false;
//						break;
//					}
//				}
//				/* 3: push/pop unknown ptr [reg] */
//				else if (eflag_instructions[j].is_mnemonic_not(i == 0 ? UD_Ipush : UD_Ipop))
//				{
//					found = false;
//					break;
//				}
//			}
//
//			if (found)
//			{
//				this->id = (i == 0 ? WILD_HANDLER_PUSHFD : WILD_HANDLER_POPFD);
//				this->opcode_offsets[0] = instructions.at(3).get_loword(1);
//				return true;
//			}
//		}
//	}
//
//	return false;
//}

bool wild_handler::map_handler_stack(instruction_container& instructions, wild_context& context)
{
	/*
		0: mov ___,___
		1: add ___,___
		2: movzx ___,___
		3: add ___,___
		4: mov esp,___
	*/
	if (instructions.bounds(0, 4) &&
		instructions.at(0).is_mnemonic(UD_Imov) &&
		instructions.at(1).is_mnemonic(UD_Iadd) &&
		instructions.at(2).is_mnemonic(UD_Imovzx) &&
		instructions.at(3).is_mnemonic(UD_Iadd) &&
		instructions.at(4).is_mnemonic(UD_Imov) &&
		instructions.at(4).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
		instructions.at(4).is_operand_base(0, UD_R_ESP))
	{
		this->id = WILD_HANDLER_LOAD_STACK;
		this->opcode_offsets[0] = instructions.at(1).get_loword(1);
		return true;
	}
	/*
		0: mov ___,___
		1: add ___,___
		2: movzx ___,___
		3: add ___,___
		4: mov ___,esp
	*/
	else if (instructions.bounds(0, 4) &&
		instructions.at(0).is_mnemonic(UD_Imov) &&
		instructions.at(1).is_mnemonic(UD_Iadd) &&
		instructions.at(2).is_mnemonic(UD_Imovzx) &&
		instructions.at(3).is_mnemonic(UD_Iadd) &&
		instructions.at(4).is_mnemonic(UD_Imov) &&
		instructions.at(4).is_operand_type(1, UD_OP_REG, UD_SIZE_DWORD) &&
		instructions.at(4).is_operand_base(1, UD_R_ESP))
	{
		this->id = WILD_HANDLER_STORE_STACK;
		this->opcode_offsets[0] = instructions.at(1).get_loword(1);
		return true;
	}
	else
	{
		for (std::size_t i = 3; i < 9 && i < instructions.size(); i++)
		{
			/* 0: add esp,reg */
			if (instructions.at(i).is_mnemonic(UD_Iadd) &&
				instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
				instructions.at(i).is_operand_base(0, UD_R_ESP) &&
				instructions.at(i).is_operand_type(1, UD_OP_REG, UD_SIZE_DWORD) &&
				instructions.at(i).is_operand_base_not(1, UD_R_ESP))
			{
				this->id = WILD_HANDLER_RESTORE_STACK;
				this->opcode_offsets[0] = instructions.at(4).get_loword(1);
				return true;
			}
		}
	}

	return false;
}

bool wild_handler::map_handler_reset_eflags(instruction_container& instructions, wild_context& context)
{
	if (instructions.bounds(0) &&
		instructions.at(0).is_mnemonic(UD_Imov) &&
		instructions.at(0).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) &&
		instructions.at(0).is_operand_base(0, UD_R_EBP) &&
		instructions.at(0).is_operand_type(1, UD_OP_IMM) &&
		instructions.at(0).is_operand_data(1, 0) &&
		this->flow_read_index == 1)
	{
		this->id = WILD_HANDLER_RESET_EFLAGS;
		return true;
	}
	
	return false;
}

bool wild_handler::map_handler_reset(instruction_container& instructions, wild_context& context)
{
	for (std::size_t i = 0; i < 5 && i < instructions.size(); i++)
	{
		/* 0: mov ___,___ */
		if (instructions.at(i).is_mnemonic_not(UD_Imov))
			return false;
	}
	
	this->id = WILD_HANDLER_RESET;
	return true;
}

bool wild_handler::map_handler_crypt(instruction_container& instructions, wild_context& context)
{
	if (instructions.bounds(0, 6))
	{
		ud_type base = UD_NONE;
		uint32_t opcodes = 0;

		for (std::size_t i = 0; i < 5 && i < instructions.size(); i++)
		{
			/* 0: ___ unknown ptr [reg],___ */
			if (instructions.at(i).is_operand_type(0, UD_OP_MEM))
				return false;
			
			/* 0: mov ___,unknown ptr [reg] */
			if (instructions.at(i).is_mnemonic(UD_Imov) &&
				instructions.at(i).is_operand_type(1, UD_OP_MEM))
			{
				/* 0: mov ___,dword ptr [ebp+xx] */
				if (context.is_opcode_access_instruction(instructions.at(i)))
				{
					opcodes++;
				}
				/* 0: mov reg,dword ptr [ebp+xx] */
				else if (instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
					instructions.at(i).is_operand_base(1, UD_R_EBP) &&
					!context.get_key(instructions.at(i).get_operand_data(1), nullptr))
				{
					base = instructions.at(i).get_base_type(0);
				}
			}
		}

		if (opcodes == 1 &&
			instructions.at(5).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) &&
			instructions.at(5).is_operand_type(1, UD_OP_REG) &&
			instructions.at(5).is_operand_base(1, base))
		{
			this->id = WILD_HANDLER_CRYPT;
			
			for (std::size_t i = 0; i < 5; i++)
			{
				if (instructions.at(i).is_mnemonic(UD_Imov) &&
					instructions.at(i).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
					!context.is_opcode_access_instruction(instructions.at(i)))
				{
					this->opcode_offsets[1] = instructions.at(i).get_operand_data<uint16_t>(1);
				}
				else if (instructions.at(i).is_mnemonic(UD_Iadd) &&
					instructions.at(i).is_operand_type(1, UD_OP_IMM))
				{
					this->opcode_offsets[0] = instructions.at(i).get_operand_data<uint16_t>(1);
				}
			}

			return true;
		}
	}
	
	return false;
}

bool wild_handler::parse_jcc_parameters(instruction_container& instructions, wild_context& context)
{
	if (!context.initialized_jcc_types)
	{
		ud_type base = UD_NONE;

		for (std::size_t i = 0, index = 8; i < 17; i++)
		{
			while (true)
			{
				if (!instructions.find_mnemonic_index(UD_Icmp, ++index))
					return false;

				if (instructions.at(index).is_operand_type(0, UD_OP_REG, UD_SIZE_BYTE))
				{
					if (!base)
					{
						base = instructions.at(index).get_base_type(0);
						break;
					}
					else if (instructions.at(index).is_operand_base(0, base))
						break;
				}
			}

			static const ud_mnemonic_code jcc_type_table[] = 
			{
				UD_Ijz,		UD_Ijle,	UD_Ijnz,	UD_Ija, 
				UD_Ijae,	UD_Ijb, 	UD_Ijbe,	UD_Ijg,
				UD_Ijge,	UD_Ijl,		UD_Ijcxz, 	UD_Ijno,
				UD_Ijnp,	UD_Ijns,	UD_Ijo, 	UD_Ijp,
				UD_Ijs 
			};
			
			context.set_jcc_mnemonic(instructions.at(index).get_operand_data<uint8_t>(1), jcc_type_table[i]);
		}
		
		context.initialized_jcc_types = true;
	}

	for (std::size_t i = 40, occurances = 0; i < instructions.size(); i++)
	{
		if (instructions.bounds(i, 1) &&
			instructions.at(i).is_mnemonic(UD_Imov) &&
			context.is_opcode_access_instruction(instructions.at(i)))
		{
			if (occurances == 0)
				this->opcode_offsets[1] = instructions.at(i + 1).get_operand_data(1);
			else if (occurances == 1)
			{
				this->opcode_offsets[2] = instructions.at(i + 1).get_operand_data(1);
				return true;
			}

			occurances++;
		}
	}

	return false;
}

bool wild_handler::parse_eflags_parameters(instruction_container& instructions, wild_context& context)
{
	if (!context.initialized_eflags_types)
	{
		ud_type base = UD_NONE;

		for (std::size_t i = 0, index = 5; i < 7; i++)
		{
			while (true)
			{
				if (!instructions.find_mnemonic_index(UD_Icmp, ++index))
					return false;

				if (instructions.at(index).is_operand_type(0, UD_OP_REG, UD_SIZE_BYTE))
				{
					if (!base)
					{
						base = instructions.at(index).get_base_type(0);
						break;
					}
					else if (instructions.at(index).is_operand_base(0, base))
						break;
				}
			}

			if (context.get_mnemonic(instructions.at(index).get_operand_data(1)) != UD_Inone)
				msg("[CodeDevirtualizer] EFLAGS mnemonic table corrupt with %08X.\n", context.get_mnemonic(instructions.at(index).get_operand_data(1)));
			else
			{
				static const ud_mnemonic_code eflags_mnemonics[] = { UD_Iclc, UD_Icld, UD_Icli, UD_Icmc, UD_Istc, UD_Istd, UD_Isti };
				context.set_mnemonic(instructions.at(index).get_operand_data<uint8_t>(1), eflags_mnemonics[i]);
			}
		}

		context.initialized_eflags_types = true;
	}

	return true;
}

bool wild_handler::perform_key_sequence(wild_context& context, uint32_t first_index, uint32_t last_index, uint32_t* data)
{
	std::size_t first = this->find_first_key_after(first_index);
	std::size_t last = this->find_last_key_before(last_index);

	if (first != static_cast<std::size_t>(-1) && last != static_cast<std::size_t>(-1))
	{
		for (std::size_t i = first; i <= last; i++)
		{
			if (!this->key_accessors.at(i).perform(context, data))
				return false;
		}

		return true;
	}
	
	return false;
}

bool wild_handler::step_handler(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	memset(context.step_params, 0, sizeof(context.step_params));

	switch (this->id)
	{
	case WILD_HANDLER_JUMP_INSIDE:
		return this->step_handler_jmp_inside(instructions, context, opcode);
		
	case WILD_HANDLER_JUMP_OUTSIDE_REGISTER:
		return this->step_handler_jmp_outside_register(instructions, context, opcode);
		
	case WILD_HANDLER_JUMP_OUTSIDE_MEMORY:
		return this->step_handler_jmp_outside_memory(instructions, context, opcode);
		
	case WILD_HANDLER_JUMP_OUTSIDE_IMMEDIATE:
		return this->step_handler_jmp_outside_immediate(instructions, context, opcode);

	case WILD_HANDLER_JCC_INSIDE:
		return this->step_handler_jcc_inside(instructions, context, opcode);
		
	case WILD_HANDLER_JCC_OUTSIDE:
		return this->step_handler_jcc_outside(instructions, context, opcode);
		
	case WILD_HANDLER_RET:
		return this->step_handler_ret(instructions, context, opcode);

	case WILD_HANDLER_UNDEF:
		return this->step_handler_undef(instructions, context, opcode);

	case WILD_HANDLER_LODSB:
	case WILD_HANDLER_LODSW:
	case WILD_HANDLER_LODSD:
		return this->step_handler_lods(instructions, context, opcode);
		
	case WILD_HANDLER_STOSB:
	case WILD_HANDLER_STOSW:
	case WILD_HANDLER_STOSD:
		return this->step_handler_stos(instructions, context, opcode);
		
	case WILD_HANDLER_SCASB:
	case WILD_HANDLER_SCASW:
	case WILD_HANDLER_SCASD:
		return this->step_handler_scas(instructions, context, opcode);
		
	case WILD_HANDLER_CMPSB:
	case WILD_HANDLER_CMPSW:
	case WILD_HANDLER_CMPSD:
		return this->step_handler_cmps(instructions, context, opcode);
		
	case WILD_HANDLER_MOVSB:
	case WILD_HANDLER_MOVSW:
	case WILD_HANDLER_MOVSD:
		return this->step_handler_movs(instructions, context, opcode);

	case WILD_HANDLER_PUSHFD:
		return this->step_handler_pushfd(instructions, context, opcode);

	case WILD_HANDLER_POPFD:
		return this->step_handler_popfd(instructions, context, opcode);
		
	case WILD_HANDLER_EFLAGS:
		return this->step_handler_eflags(instructions, context, opcode);

	case WILD_HANDLER_RESTORE_STACK:
		return this->step_handler_restore_stack(instructions, context, opcode);

	case WILD_HANDLER_LOAD_STACK:
		return this->step_handler_load_stack(instructions, context, opcode);
		
	case WILD_HANDLER_STORE_STACK:
		return this->step_handler_store_stack(instructions, context, opcode);
		
	case WILD_HANDLER_RESET_EFLAGS:
		return this->step_handler_reset_eflags(instructions, context, opcode);

	case WILD_HANDLER_RESET:
		return this->step_handler_reset(instructions, context, opcode);

	case WILD_HANDLER_CRYPT:
		return this->step_handler_crypt(instructions, context, opcode);

	default:
		break;
	}

	return this->step_handler_specific(instructions, context, opcode);
}

bool wild_handler::step_handler_jmp_inside(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t handler_index = opcode.read<uint16_t>(this->opcode_offsets[0]);
	uint32_t distance = opcode.read<uint32_t>(this->opcode_offsets[1]);
	
	context.step_params[0] = handler_index;
	context.step_params[1] = distance;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Ijmp);
	instruction.set_operand_type(0, UD_OP_IMM, UD_SIZE_DWORD);

	if (distance & 0x80000000)
	{
		instruction.set_operand_data(0, -static_cast<int32_t>(distance & 0x7FFFFFFF));
		context.create_label(context.current_virtual_opcode - (distance & 0x7FFFFFFF), handler_index);
	}
	else
	{
		instruction.set_operand_data(0, distance);
		context.create_label(context.current_virtual_opcode + distance, handler_index);
	}

	instructions.push_back(instruction);
	return true;
}

bool wild_handler::step_handler_jmp_outside_register(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t register_id = opcode.read<uint32_t>(this->opcode_offsets[0]);
	
	context.step_params[0] = register_id;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Ijmp);
	instruction.set_operand_type(0, UD_OP_REG, UD_SIZE_DWORD);
	instruction.set_operand_base(0, context.get_vm_register(register_id));
	
	instructions.push_back(instruction);
	return true;
}

bool wild_handler::step_handler_jmp_outside_memory(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t register_id = opcode.read<uint32_t>(this->opcode_offsets[0]);
	
	context.step_params[0] = register_id;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Ijmp);
	instruction.set_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD);
	instruction.set_operand_base(0, context.get_vm_register(register_id));
	
	instructions.push_back(instruction);
	return true;
}

bool wild_handler::step_handler_jmp_outside_immediate(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t offset = opcode.read<uint32_t>(this->opcode_offsets[0]);
	
	context.step_params[2] = offset;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Ijmp);
	instruction.set_operand_type(0, UD_OP_IMM, UD_SIZE_DWORD);
	instruction.set_operand_data(0, context.vm_imagebase + offset);
	
	instructions.push_back(instruction);
	return true;
}

bool wild_handler::step_handler_jcc_inside(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t jcc_mnemonic_id = opcode.read<uint8_t>(this->opcode_offsets[0]);
	uint32_t handler_index = opcode.read<uint16_t>(this->opcode_offsets[1]);
	uint32_t distance = opcode.read<uint32_t>(this->opcode_offsets[2]);
	
	context.step_params[0] = jcc_mnemonic_id;
	context.step_params[1] = handler_index;
	context.step_params[2] = distance;
	
	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(context.get_jcc_mnemonic(jcc_mnemonic_id));
	instruction.set_operand_type(0, UD_OP_IMM, UD_SIZE_DWORD);
	
	if (distance & 0x80000000)
	{
		instruction.set_operand_data(0, -static_cast<int32_t>(distance & 0x7FFFFFFF));
		context.create_label(context.current_virtual_opcode - (distance & 0x7FFFFFFF), handler_index);
	}
	else
	{
		instruction.set_operand_data(0, distance);
		context.create_label(context.current_virtual_opcode + distance, handler_index);
	}
	
	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool wild_handler::step_handler_jcc_outside(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t jcc_mnemonic_id = opcode.read<uint8_t>(this->opcode_offsets[0]);
	uint32_t offset = opcode.read<uint32_t>(this->opcode_offsets[1]);
	
	context.step_params[0] = jcc_mnemonic_id;
	context.step_params[1] = offset;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(context.get_jcc_mnemonic(jcc_mnemonic_id));
	instruction.set_operand_type(0, UD_OP_IMM, UD_SIZE_DWORD);
	instruction.set_operand_data(0, context.vm_imagebase + offset);
	
	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool wild_handler::step_handler_ret(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t arguments = opcode.read<uint32_t>(this->opcode_offsets[0]);
	
	context.step_params[0] = arguments;
	
	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Iret);

	if (arguments)
	{
		instruction.set_operand_type(0, UD_OP_IMM, UD_SIZE_WORD);
		instruction.set_operand_data(0, arguments);
	}

	instructions.push_back(instruction);
	return true;
}

bool wild_handler::step_handler_undef(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t type = opcode.read<uint8_t>(this->opcode_offsets[0]);

	context.step_params[0] = UD_Iundef;
	context.step_params[1] = type;
	
	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Iundef);

	instructions.push_back(instruction);
	
	/* Decode return address and create label */
	uint32_t return_address = context.vm_imagebase + opcode.read<uint32_t>(this->opcode_offsets[1]);
	
	if (!return_address)
		return false;

	ud_instruction return_instruction(return_address);
	return_instruction.set_input(context.to_segment(return_address));
	
	instruction_container return_instructions;
	
	for (std::size_t i = 0; i < 3; i++)
	{
		if (!return_instructions.decode_assembly(return_instruction))
			return false;

		if (i == 0)
			instructions.back().set_index(return_address);
		else
		{
			if (return_instruction.is_mnemonic_not(UD_Ipush) ||
				return_instruction.is_operand_type_not(0, UD_OP_IMM, UD_SIZE_DWORD))
			{
				return false;
			}
		}
	}
	
	context.create_label(context.vm_imagebase + return_instructions.at(1).get_operand_data(0), return_instructions.at(2).get_operand_data(0));
	return true;
}

bool wild_handler::step_handler_lods(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	static const ud_mnemonic_code mnemonics[] = { UD_Ilodsb, UD_Ilodsw, UD_Ilodsd };
	
	this->step_opcode_regions(context, opcode);

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(mnemonics[this->id - WILD_HANDLER_LODSB]);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool wild_handler::step_handler_stos(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	static const ud_mnemonic_code mnemonics[] = { UD_Istosb, UD_Istosw, UD_Istosd };
	
	this->step_opcode_regions(context, opcode);
	
	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(mnemonics[this->id - WILD_HANDLER_STOSB]);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool wild_handler::step_handler_scas(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	static const ud_mnemonic_code mnemonics[] = { UD_Iscasb, UD_Iscasw, UD_Iscasd };
	
	this->step_opcode_regions(context, opcode);

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(mnemonics[this->id - WILD_HANDLER_SCASB]);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool wild_handler::step_handler_cmps(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	static const ud_mnemonic_code mnemonics[] = { UD_Icmpsb, UD_Icmpsw, UD_Icmpsd };
	
	this->step_opcode_regions(context, opcode);

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(mnemonics[this->id - WILD_HANDLER_CMPSB]);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool wild_handler::step_handler_movs(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	static const ud_mnemonic_code mnemonics[] = { UD_Imovsb, UD_Imovsw, UD_Imovsd };
	
	this->step_opcode_regions(context, opcode);
	
	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(mnemonics[this->id - WILD_HANDLER_MOVSB]);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}
	
bool wild_handler::step_handler_pushfd(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	this->step_opcode_regions(context, opcode);
	
	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Ipushfd);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool wild_handler::step_handler_popfd(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	this->step_opcode_regions(context, opcode);
	
	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Ipopfd);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}
	
bool wild_handler::step_handler_eflags(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t mnemonic_id = opcode.read<uint8_t>(this->opcode_offsets[1]);

	context.step_params[0] = mnemonic_id;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(context.get_mnemonic(mnemonic_id));

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool wild_handler::step_handler_restore_stack(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t value = opcode.read<uint8_t>(this->opcode_offsets[0]);

	context.step_params[0] = UD_Irestorestack;
	context.step_params[1] = value;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Irestorestack);
	instruction.set_operand_type(0, UD_OP_IMM, UD_SIZE_DWORD);
	instruction.set_operand_data(0, value);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool wild_handler::step_handler_load_stack(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t esp_register_id = opcode.read<uint16_t>(this->opcode_offsets[0]);

	context.step_params[0] = UD_Iloadstack;
	context.step_params[1] = esp_register_id;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Iloadstack);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool wild_handler::step_handler_store_stack(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t esp_register_id = opcode.read<uint16_t>(this->opcode_offsets[0]);
	context.set_vm_register(esp_register_id, UD_R_ESP);

	context.step_params[0] = UD_Istorestack;
	context.step_params[1] = esp_register_id;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Istorestack);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), true);
}
	
bool wild_handler::step_handler_reset_eflags(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	context.step_params[0] = UD_Ireseteflags;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Ireseteflags);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(0), true);
}

bool wild_handler::step_handler_reset(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	context.reset_key_data();

	context.step_params[0] = UD_Ireset;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Ireset);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(0), true);
}
	
bool wild_handler::step_handler_crypt(instruction_container& instructions, wild_context& context, opcode_reader& opcode)
{
	uint32_t register_id = opcode.read<uint16_t>(this->opcode_offsets[0]);
	uint32_t value = this->opcode_offsets[1];

	context.step_params[0] = UD_Icrypt;
	context.step_params[1] = register_id;
	context.step_params[2] = value;

	if (!get_many_bytes(context.vm_context + value, &value, sizeof(uint32_t)))
		return false;

	context.step_params[3] = value;

	ud_instruction instruction(context.current_virtual_opcode);
	instruction.set_mnemonic(UD_Icrypt);
	instruction.set_operand_type(0, UD_OP_REG, UD_SIZE_DWORD);
	instruction.set_operand_base(0, context.get_vm_register(register_id));
	instruction.set_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD);
	instruction.set_operand_data(1, value);

	instructions.push_back(instruction);
	return this->step_handler_flow(context, opcode.read<uint16_t>(this->flow_read_offset), false);
}

bool wild_handler::step_opcode_regions(wild_context& context, opcode_reader& opcode)
{
	uint32_t key_data = 0;

	if (this->opcode_regions.empty())
	{
		this->perform_key_sequence(context, 0, this->flow_data_index, &key_data);
	}
	else
	{
		if (this->key_accessors.size() > 0 && this->key_accessors.at(0).index < this->opcode_regions.at(0).index_start)
			this->perform_key_sequence(context, 0, this->opcode_regions.at(0).index_start - 1, &key_data);

		for (std::size_t i = 0; i < this->opcode_regions.size(); i++)
		{
			key_data = 0;

			switch (this->opcode_regions.at(i).opcode_size)
			{
			case UD_SIZE_BYTE:
				key_data = opcode.read<uint8_t>(this->opcode_regions.at(i).opcode_offset);
				break;

			case UD_SIZE_WORD:
				key_data = opcode.read<uint16_t>(this->opcode_regions.at(i).opcode_offset);
				break;

			case UD_SIZE_DWORD:
				key_data = opcode.read<uint32_t>(this->opcode_regions.at(i).opcode_offset);
				break;

			default:
				break;
			}
			
			uint32_t index_end = 0;

			if ((i + 1) < this->opcode_regions.size())
				index_end = this->opcode_regions.at(i + 1).index_start;
			else
				index_end = this->flow_read_index;

			this->perform_key_sequence(context, this->opcode_regions.at(i).index_start, index_end - 1, &key_data);
		}
	}

	return true;
}

bool wild_handler::step_handler_flow(wild_context& context, uint16_t raw_handler_offset, bool skip_flow_mutation)
{
	if (skip_flow_mutation)
	{
		context.current_handler_offset = raw_handler_offset;
		context.current_virtual_opcode += this->opcode_size;
	}
	else
	{
		uint32_t handler_offset = raw_handler_offset;

		if (this->opcode_size == OPCODE_SIZE_SUB || this->opcode_size == OPCODE_SIZE_RETN || this->opcode_size == OPCODE_SIZE_INVALID)
			return false;

		if (this->flow_key_indexes.empty())
		{
			if (this->flow_mutation_index)
				instruction::emulate(static_cast<ud_mnemonic_code>(this->flow_mutation_mnemonic), UD_SIZE_DWORD, this->flow_mutation_constant, &handler_offset);
		}
		else
		{
			std::size_t first = this->find_first_key_after(this->flow_key_indexes.front());
			std::size_t last = this->find_last_key_before(this->flow_key_indexes.back());
			
			if (first == static_cast<std::size_t>(-1) || last == static_cast<std::size_t>(-1))
				return false;

			bool flow_mutated = false;
				
			for (std::size_t i = first; i <= last; i++)
			{
				if (this->flow_mutation_index && !flow_mutated && this->key_accessors.at(i).index > this->flow_mutation_index)
				{
					instruction::emulate(static_cast<ud_mnemonic_code>(this->flow_mutation_mnemonic), UD_SIZE_DWORD, this->flow_mutation_constant, &handler_offset);
					flow_mutated = true;
				}
				
				if (!this->key_accessors.at(i).perform(context, &handler_offset))
					return false;
			}

			if (this->flow_mutation_index && !flow_mutated)
				instruction::emulate(static_cast<ud_mnemonic_code>(this->flow_mutation_mnemonic), UD_SIZE_DWORD, this->flow_mutation_constant, &handler_offset);
		}
		
		context.current_handler_offset = handler_offset;
		context.current_virtual_opcode += this->opcode_size;
	}

	return true;
}
```

`TDE/wild_handler.hpp`:

```hpp
#ifndef WILD_HANDLER_HPP_
#define WILD_HANDLER_HPP_

#include "wild_context.hpp"

#include "wild_handler_flow.hpp"
#include "wild_handler_key.hpp"
#include "wild_handler_types.hpp"

#include "wild_opcode_reader.hpp"

#define HAS_KEY_DATA_FLAG	0x80000000

class wild_handler : public wild_handler_flow
{
	typedef struct wild_opcode_region
	{
		uint16_t opcode_offset;
		ud_size opcode_size;

		uint32_t index_start;
		uint32_t index_end;
	} wild_opcode_region;

	enum opcode_size_type
	{
		OPCODE_SIZE_SUB = 0x4000,
		OPCODE_SIZE_RETN = 0x8000,
		OPCODE_SIZE_INVALID = 0xFFFF
	};
	
	virtual bool map_handler_specific(instruction_container& instructions, wild_context& context);
	virtual bool step_handler_specific(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	
public:
	wild_handler(uint16_t index);
	
	uint16_t get_id();
	bool is_flow_type();

public:
	bool decrypt(instruction_container& instructions, wild_context& context, uint32_t compares);

private:
	bool decrypt_key_data(instruction_container& instructions, wild_context& context);
	void decrypt_key_protection_template(instruction_container& instructions, wild_context& context);
	
protected:
	std::size_t find_first_key_after(std::size_t index);
	std::size_t find_last_key_before(std::size_t index);
	
private:
	void decrypt_opcode_size(instruction_container& instructions, wild_context& context);
	void decrypt_opcode_regions(instruction_container& instructions, wild_context& context);

private:
	bool map_handler(instruction_container& instructions, wild_context& context);
	
	bool map_handler_jmp(instruction_container& instructions, wild_context& context);
	bool map_handler_jcc(instruction_container& instructions, wild_context& context);
	bool map_handler_retn(instruction_container& instructions, wild_context& context);
	bool map_handler_undef(instruction_container& instructions, wild_context& context);
	bool map_handler_lods(instruction_container& instructions, wild_context& context);
	bool map_handler_stos(instruction_container& instructions, wild_context& context);
	bool map_handler_scas(instruction_container& instructions, wild_context& context);
	bool map_handler_cmps(instruction_container& instructions, wild_context& context);
	bool map_handler_movs(instruction_container& instructions, wild_context& context);
	bool map_handler_eflags(instruction_container& instructions, wild_context& context);
	bool map_handler_reset_eflags(instruction_container& instructions, wild_context& context);
	bool map_handler_reset(instruction_container& instructions, wild_context& context);
	bool map_handler_stack(instruction_container& instructions, wild_context& context);
	bool map_handler_crypt(instruction_container& instructions, wild_context& context);

private:
	bool parse_jcc_parameters(instruction_container& instructions, wild_context& context);
	bool parse_eflags_parameters(instruction_container& instructions, wild_context& context);
	
protected:
	bool perform_key_sequence(wild_context& context, uint32_t first_index, uint32_t last_index, uint32_t* data);
	
public:
	bool step_handler(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	
private:
	bool step_handler_jmp_inside(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_jmp_outside_register(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_jmp_outside_memory(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_jmp_outside_immediate(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_jcc_inside(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_jcc_outside(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_ret(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_undef(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_lods(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_stos(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_scas(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_cmps(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_movs(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_pushfd(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_popfd(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_eflags(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_restore_stack(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_load_stack(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_store_stack(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_reset_eflags(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_reset(instruction_container& instructions, wild_context& context, opcode_reader& opcode);
	bool step_handler_crypt(instruction_container& instructions, wild_context& context, opcode_reader& opcode);

protected:
	bool step_opcode_regions(wild_context& context, opcode_reader& opcode);
	bool step_handler_flow(wild_context& context, uint16_t raw_handler_offset, bool skip_flow_mutation);

protected:
	uint16_t id;
	uint16_t index;
	uint16_t opcode_size;
	uint8_t cmp_count;

	std::vector<wild_handler_key> key_accessors;		// x1 ; 

	uint16_t opcode_offsets[16];						// xx1
	std::vector<wild_opcode_region> opcode_regions;
};

#endif
```

`TDE/wild_handler_flow.cpp`:

```cpp
#include "wild_handler_flow.hpp"

wild_handler_flow::wild_handler_flow()
{
	memset(this, 0, sizeof(wild_handler_flow));
}

bool wild_handler_flow::decrypt_flow_data(instruction_container& instructions, wild_context& context)
{
	if (instructions.back().is_mnemonic(UD_Ijmp))
	{
		std::size_t index = 0;

		if (!this->find_read_index(instructions, context, index))
			return false;

		ud_type base = instructions.at(index).get_base_type(0);

		if (!this->find_read_offset(instructions, base, index))
			return false;

		ud_instruction& delta_instruction = instructions.at(instructions.size() - 2);

		if (delta_instruction.is_mnemonic(UD_Iadd))
			return this->find_add_data_index(instructions, context, base, index);
		else if (delta_instruction.is_mnemonic(UD_Isub))
			return this->find_sub_data_index(instructions, base, index);
	}

	return true;
}

bool wild_handler_flow::find_read_index(instruction_container& instructions, wild_context& context, std::size_t& index)
{
	for (std::size_t i = (instructions.size() - 1); static_cast<int32_t>(i) >= 0; i--)
	{
		/* 0: mov reg,[ebp+xx]*/
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG) &&
			context.is_opcode_access_instruction(instructions.at(i)))
		{
			this->flow_read_index = (index = i);
			return true;
		}
	}

	return false;
}

bool wild_handler_flow::find_read_offset(instruction_container& instructions, ud_type base, std::size_t& index)
{
	for (index++; index < instructions.size(); index++)
	{
		/* 0: add reg,imm */
		if (instructions.at(index).is_mnemonic(UD_Iadd) &&
			instructions.at(index).is_operand_type(0, UD_OP_REG) &&
			instructions.at(index).is_operand_base(0, base) &&
			instructions.at(index).is_operand_type(1, UD_OP_IMM))
		{
			this->flow_read_offset = instructions.at(index).get_operand_data<uint16_t>(1);
			return true;
		}
	}

	return false;
}

bool wild_handler_flow::find_add_data_index(instruction_container& instructions, wild_context& context, ud_type base, std::size_t& index)
{
	for (index++; index < instructions.size(); index++)
	{
		/* 0: movzx reg,word ptr [reg] */
		if (instructions.at(index).is_mnemonic(UD_Imovzx) &&
			instructions.at(index).is_operand_type(0, UD_OP_REG) &&
			instructions.at(index).is_operand_type(1, UD_OP_MEM, UD_SIZE_WORD) &&
			instructions.at(index).is_operand_base(1, base) &&
			instructions.at(index).has_operand_index_not(1) &&
			instructions.at(index).has_operand_scale_not(1) &&
			instructions.at(index).has_operand_data_not(1))
		{
			this->flow_data_index = index;
			return this->find_add_and(instructions, context, instructions.at(index).get_base_type(0), index);
		}
		/* 0: mov reg,word ptr [reg] */
		else if (instructions.at(index).is_mnemonic(UD_Imov) &&
			instructions.at(index).is_operand_type(0, UD_OP_REG) &&
			instructions.at(index).is_operand_type(1, UD_OP_MEM, UD_SIZE_WORD) &&
			instructions.at(index).is_operand_base(1, base) &&
			instructions.at(index).has_operand_index_not(1) &&
			instructions.at(index).has_operand_scale_not(1) &&
			instructions.at(index).has_operand_data_not(1))
		{
			this->flow_data_index = index;
			return true;
		}
	}

	return false;
}

bool wild_handler_flow::find_add_and(instruction_container& instructions, wild_context& context, ud_type base, std::size_t& index)
{
	for (index++; index < instructions.size(); index++)
	{
		/* 0: and reg,0xffff */
		if (instructions.at(index).is_mnemonic(UD_Iand) &&
			instructions.at(index).is_operand_type(0, UD_OP_REG) &&
			instructions.at(index).is_operand_base(0, base) &&
			instructions.at(index).is_operand_type(1, UD_OP_IMM) &&
			instructions.at(index).is_operand_data(1, 0xFFFF))
		{
			return true;
		}

		if (instructions.at(index).compare_mnemonic(false, false, true))
		{
			if (context.is_key_access_instruction(instructions.at(index), false))
			{
				/* 0: ___ reg,[ebp+xx] */
				if (instructions.at(index).is_operand_type(0, UD_OP_REG) &&
					instructions.at(index).is_operand_base(0, base))
				{
					this->flow_key_indexes.push_back(index);
				}
				/* 0: ___ [ebp+xx],reg */
				else if (instructions.at(index).is_operand_type(1, UD_OP_REG) &&
					instructions.at(index).is_operand_base(1, base))
				{
					this->flow_key_indexes.push_back(index);
				}
			}
			/* 0: ___ reg,imm  */
			else if (instructions.at(index).is_operand_type(0, UD_OP_REG) &&
				instructions.at(index).is_operand_base(0, base) &&
				instructions.at(index).is_operand_type(1, UD_OP_IMM))
			{
				this->flow_mutation_index = index;
				this->flow_mutation_mnemonic = instructions.at(index).get_mnemonic();
				this->flow_mutation_constant = instructions.at(index).get_operand_data(1);
			}
		}
	}

	return false;
}

bool wild_handler_flow::find_sub_data_index(instruction_container& instructions, ud_type base, std::size_t& index)
{
	for (index++; index < instructions.size(); index++)
	{
		/* 0: mov reg,dword ptr [reg] */
		if (instructions.at(index).is_mnemonic(UD_Imov) &&
			instructions.at(index).is_operand_type(0, UD_OP_REG) &&
			instructions.at(index).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
			instructions.at(index).is_operand_base(1, base) &&
			instructions.at(index).has_operand_index_not(1) &&
			instructions.at(index).has_operand_scale_not(1) &&
			instructions.at(index).has_operand_data_not(1))
		{
			this->flow_data_index = index;
			return this->find_sub_negative_check(instructions, instructions.at(index).get_base_type(0), index);
		}
	}

	return false;
}
	
bool wild_handler_flow::find_sub_negative_check(instruction_container& instructions, ud_type base, std::size_t& index)
{
	for (index++; index < instructions.size(); index++)
	{
		/* 0: and reg,0x80000000 */
		if (instructions.at(index).is_mnemonic(UD_Iand) &&
			instructions.at(index).is_operand_type(0, UD_OP_REG) &&
			instructions.at(index).is_operand_base(0, base) &&
			instructions.at(index).is_operand_type(1, UD_OP_IMM) &&
			instructions.at(index).is_operand_data(1, 0x80000000))
		{
			return true;
		}
	}

	return false;
}
```

`TDE/wild_handler_flow.hpp`:

```hpp
#ifndef WILD_HANDLER_FLOW_HPP_
#define WILD_HANDLER_FLOW_HPP_

#include "wild_context.hpp"
#include "instruction_container.hpp"

class wild_handler_flow
{
protected:
	wild_handler_flow();

protected:
	bool decrypt_flow_data(instruction_container& instructions, wild_context& context);
	
private:
	bool find_read_index(instruction_container& instructions, wild_context& context, std::size_t& index);
	bool find_read_offset(instruction_container& instructions, ud_type base, std::size_t& index);
		
	bool find_add_data_index(instruction_container& instructions, wild_context& context, ud_type base, std::size_t& index);
	bool find_add_and(instruction_container& instructions, wild_context& context, ud_type base, std::size_t& index);

	bool find_sub_data_index(instruction_container& instructions, ud_type base, std::size_t& index);
	bool find_sub_negative_check(instruction_container& instructions, ud_type base, std::size_t& index);

public:
	uint32_t flow_read_index;					// idk5	; Index of the instruction that reads the opcode address for the flow handling from the vm context
	uint16_t flow_read_offset;					// idk7 ; Offset of the opcode address whose data is being read

	uint32_t flow_data_index;					// idk6 ; Index of the instruction that reads data for the flow handling from the opcode address

	std::vector<uint32_t> flow_key_indexes;		// x3 ; Indexes of the instructions that accesses keys for modification of the flow handling opcode data
	
	uint16_t flow_mutation_mnemonic;			// idk10 ; The mnemonic of the instruction that mutates the key for the flow handling opcode data
	uint32_t flow_mutation_index;				// idk8 ; Index of the instruction that reads the mutation key for the flow handling opcode data
	uint32_t flow_mutation_constant;			// idk9 ; The data constant that is used on the mutation key for the flow handling opcode data
};

#endif
```

`TDE/wild_handler_key.cpp`:

```cpp
#include "wild_handler_key.hpp"
#include "instruction_emulator.hpp"

#include <idp.hpp>

wild_handler_key::wild_handler_key() :
    id(0),
    index(0),
    mnemonic(UD_Inone),
    operand(0),
    type(UD_NONE),
    size(UD_SIZE_NONE),
    direct_key_parameter(false),
    parameter(0)
{
    // Default condition: always true
    this->condition = [](wild_context const& context, wild_handler_key const& key) -> bool { return true; };
}

bool wild_handler_key::perform(wild_context& context, uint32_t* data)
{
    // Check if the condition is met
    if (this->condition(context, *this))
    {
        if (this->direct_key_parameter)
        {
            if (this->type != UD_OP_REG)
            {
                msg("Direct key parameter type is not OPERAND_TYPE_REGISTER.\n");
                return false;
            }

            // Get source key data
            uint32_t source_key_data = 0;
            if (!context.get_key(this->parameter, &source_key_data))
            {
                msg("Could not get key data from the source key.\n");
                return false;
            }

            // Get destination key data
            uint32_t destination_key_data = 0;
            if (!context.get_key(this->id, &destination_key_data))
            {
                msg("Could not get key data from the destination key.\n");
                return false;
            }

            // Emulate instruction
            instruction::emulate(this->mnemonic, this->size, source_key_data, &destination_key_data);

            // Set destination key data
            if (!context.set_key(this->id, destination_key_data))
            {
                msg("Could not set key data for the destination key.\n");
                return false;
            }
        }
        else
        {
            // Get key data
            uint32_t key_data = 0;
            if (!context.get_key(this->id, &key_data))
            {
                msg("Could not get data from the key.\n");
                return false;
            }

            // Emulate instruction based on the operand type
            if (this->operand > 0)
            {
                // Indirect key
                if (this->type != UD_OP_REG)
                {
                    msg("Indirect key type is not OPERAND_TYPE_REGISTER.\n");
                    return false;
                }
                instruction::emulate(this->mnemonic, this->size, key_data, data);
            }
            else if (this->type == UD_OP_IMM)
            {
                // Immediate value
                instruction::emulate(this->mnemonic, this->size, this->parameter, &key_data);
                // Set key data
                if (!context.set_key(this->id, key_data))
                {
                    msg("Could not set data for the key.\n");
                    return false;
                }
            }
            else
            {
                // Accessor key
                if (this->type != UD_OP_REG)
                {
                    msg("Accessor key type is not OPERAND_TYPE_REGISTER.\n");
                    return false;
                }
                instruction::emulate(this->mnemonic, this->size, *data, &key_data);
                // Set key data
                if (!context.set_key(this->id, key_data))
                {
                    msg("Could not set data for the key.\n");
                    return false;
                }
            }
        }
    }

    return true;
}

bool wild_handler_key::operator<(wild_handler_key const& key) const
{
    return (this->index < key.index);
}

```

`TDE/wild_handler_key.hpp`:

```hpp
#ifndef WILD_HANDLER_KEYS_HPP_
#define WILD_HANDLER_KEYS_HPP_

#include "wild_context.hpp"

#include <functional>

class wild_handler_key
{
	typedef std::function<bool(wild_context const&, wild_handler_key const&)> condition_predicate;

public:
	wild_handler_key();

	bool perform(wild_context& context, uint32_t* data);

public:
    bool operator<(wild_handler_key const& key) const;

public:
	uint16_t id;					// idk1 ; The ID of the key (offset in the vm context)
	uint32_t index;					// idk2 ; The index of the instruction (in the deobfuscated handler vector)

	ud_mnemonic_code mnemonic;		// idk6 ; The mnemonic of the key access instruction
	uint8_t operand;				// idk3 ; The operand that accesses the key
	
	ud_type type;					// idk5 ; size of key and type of data
	ud_size size;

	bool direct_key_parameter;		// idk4 ; Determines if the key gets its data directly from another key, in which case param will contain the key id.
	uint32_t parameter;				// idk7 ; The parameter for the key (reg/size for register, data for immediate)
	
	condition_predicate condition;	// Type of protection template (if any)
};

#endif
```

`TDE/wild_handler_mnemonics.hpp`:

```hpp
#ifndef WILD_HANDLER_MNEMONICS_HPP_
#define WILD_HANDLER_MNEMONICS_HPP_

#include <stdint.h>

enum wild_handler_mnemonics : uint16_t
{
	WILD_MNEMONIC_UNKNOWN = 0x6000,

	WILD_MNEMONIC_UNDEF,

	WILD_MNEMONIC_RESTORE_STACK,
	WILD_MNEMONIC_LOAD_STACK,
	WILD_MNEMONIC_STORE_STACK,

	WILD_MNEMONIC_RESET,
	WILD_MNEMONIC_RESET_EFLAGS,

	WILD_MNEMONIC_CRYPT,

	WILD_MNEMONIC_INVALID = 0xFFFF,
};

#endif
```

`TDE/wild_handler_parser.cpp`:

```cpp
#include "wild_handler_parser.hpp"
#include "wild_handler.hpp"

#include <idp.hpp>

wild_handler_parser::wild_handler_parser(wild_context& context)
	: wild_handler_tracer(context)
{

}

void wild_handler_parser::decode_virtual_handler(instruction_container& instructions, uint32_t vm_handler_offset, uint32_t& compares)
{
	compares = 0;

	uint32_t vm_delta = 0;
	get_many_bytes(this->context.vm_context + this->context.vm_handler_table_offset, &vm_delta, sizeof(uint32_t));

	if (vm_delta == this->context.vm_handler_table)
		vm_delta = 0;
	else
		vm_delta = this->context.vm_imagebase;

	uint32_t handler_offset = (vm_handler_offset * 4);
	uint32_t handler_address = *reinterpret_cast<uint32_t*>(this->context.to_segment(this->context.vm_handler_table + handler_offset).first);

	uint32_t vm_handler = handler_address + vm_delta;

	this->trace(vm_handler, compares, instructions);

	instructions.deobfuscate_wild();

	this->deobfuscate_vm_context_access(instructions);
	this->deobfuscate_unused_instructions(instructions);
	
	instructions.update_indexes();
}

void wild_handler_parser::deobfuscate_vm_context_access(instruction_container& instructions)
{
	for (std::size_t i = 0; i < instructions.size(); i++)
	{
		/* 0: mov reg,ebp */
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_base_not(0, UD_R_ESP) &&
			instructions.at(i).is_operand_base_not(0, UD_R_EBP) &&
			instructions.at(i).is_operand_type(1, UD_OP_REG, UD_SIZE_DWORD) &&
			instructions.at(i).is_operand_base(1, UD_R_EBP))
		{
			ud_type base = instructions.at(i).get_base_type(0);
				
			for (std::size_t j = i + 1, operations = 1; j < instructions.size() && operations < 2; j++)
			{
				/* 1: add reg,imm32 */
				if (instructions.at(j).is_mnemonic(UD_Iadd) &&
					instructions.at(j).is_operand_type(0, UD_OP_REG, UD_SIZE_DWORD) &&
					instructions.at(j).is_operand_base(0, base) &&
					instructions.at(j).is_operand_type(1, UD_OP_IMM, UD_SIZE_DWORD))
				{
					operations++;

					for (std::size_t k = j + 1; k < instructions.size() && operations < 3; k++)
					{
						if (instructions.at(k).is_mnemonic_not({ UD_Imovsb, UD_Imovsw, UD_Imovsd, UD_Imovsq }))
						{
							/* 2: ___ unknown ptr [reg],___ */
							if (instructions.at(k).is_operand_type(0, UD_OP_MEM) &&
								instructions.at(k).is_operand_base(0, base) &&
								instructions.at(k).has_operand_index_not(0) &&
								instructions.at(k).has_operand_scale_not(0) &&
								instructions.at(k).has_operand_data_not(0) &&
								operations == 2)
							{
								instructions.at(k).set_operand_base(0, UD_R_EBP);
								instructions.at(k).set_operand_offset(0, 32);
								instructions.at(k).set_operand_data(0, instructions.at(j).get_operand_data(1));
									
								instructions.remove(j);
								instructions.remove(i--);
								operations = 3;
							}
							/* 2: ___ ___,unknown ptr [reg] */
							else if (instructions.at(k).is_operand_type(1, UD_OP_MEM) &&
								instructions.at(k).is_operand_base(1, base) &&
								instructions.at(k).has_operand_index_not(1) &&
								instructions.at(k).has_operand_scale_not(1) &&
								instructions.at(k).has_operand_data_not(1) &&
								operations == 2)
							{
								instructions.at(k).set_operand_base(1, UD_R_EBP);
								instructions.at(k).set_operand_offset(1, 32);
								instructions.at(k).set_operand_data(1, instructions.at(j).get_operand_data(1));
									
								instructions.remove(j);
								instructions.remove(i--);
								operations = 3;
							}
							/* 2: ___ reg,___ */
							else if (instructions.at(k).is_operand_type(0, UD_OP_REG) &&
								instructions.at(k).is_operand_base(0, base))
							{
								operations++;
							}
						}
					}
				}
				/* 1: ___ reg,___ */
				else if (instructions.at(j).is_operand_type(0, UD_OP_REG) &&
					instructions.at(j).is_operand_base(0, base))
				{
					operations++;
				}
			}
		}
	}
	
	for (std::size_t i = 0; i < instructions.size(); i++)
	{
		/* 0: mov reg,imm */
		if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG) &&
			instructions.at(i).is_operand_type(1, UD_OP_IMM))
		{
			uint32_t operations = 0;

			for (std::size_t j = i + 1; j < instructions.size(); j++)
			{
				/* 1: ___ reg/unknown ptr [reg],___ */
				if ((instructions.at(j).is_operand_type(0, UD_OP_REG) &&
					instructions.at(j).is_operand_base(0, instructions.at(i), 0)) ||
					(instructions.at(j).is_operand_type(0, UD_OP_MEM) &&
					(instructions.at(j).is_operand_base(0, instructions.at(i), 0) ||
					instructions.at(j).is_operand_index_by_base(0, instructions.at(i), 0))))
				{
					break;
				}

				/* 1: ___ unknown ptr [ebp+xx],reg */
				if (instructions.at(j).is_operand_type(0, UD_OP_MEM) &&
					instructions.at(j).is_operand_base(0, UD_R_EBP) &&
					instructions.at(j).has_operand_index_not(0) &&
					instructions.at(j).has_operand_scale_not(0) &&
					instructions.at(j).is_operand_type(1, UD_OP_REG) &&
					instructions.at(j).is_operand_base(1, instructions.at(i), 0))
				{
					/* 1: mov unknown ptr [ebp+xx],imm */
					instructions.at(j).set_operand_type(1, UD_OP_IMM, instructions.at(j).get_base_size(1));
					instructions.at(j).set_operand_data(1, instructions.at(i), 1);
					operations++;
				}
			}

			if (operations > 0)
				instructions.remove(i--);
		}
		/* 0: mov reg,unknown ptr [ebp+xx] */
		else if (instructions.at(i).is_mnemonic(UD_Imov) &&
			instructions.at(i).is_operand_type(0, UD_OP_REG) &&
			instructions.at(i).is_operand_type(1, UD_OP_MEM) &&
			this->context.is_key_access_instruction(instructions.at(i), true))
		{
			for (std::size_t j = i + 1; j < instructions.size(); j++)
			{
				/* 1: ___ reg/unknown ptr [reg],___ */
				if ((instructions.at(j).is_operand_type(0, UD_OP_REG) &&
					instructions.at(j).is_operand_base(0, instructions.at(i), 0)) ||
					(instructions.at(j).is_operand_type(0, UD_OP_MEM) &&
					(instructions.at(j).is_operand_base(0, instructions.at(i), 0) ||
					instructions.at(j).is_operand_index_by_base(0, instructions.at(i), 0))))
				{
					break;
				}

				/* 1: ___ unknown ptr [ebp+xx],reg */
				if (instructions.at(j).is_operand_type(0, UD_OP_MEM) &&
					instructions.at(j).is_operand_type(1, UD_OP_REG) &&
					instructions.at(j).is_operand_base(1, instructions.at(i), 0) &&
					this->context.is_key_access_instruction(instructions.at(j), true))
				{
					instructions.at(j).set_key_data(HAS_KEY_DATA_FLAG | instructions.at(i).get_operand_data(1));
				}
			}
		}
	}
}

void wild_handler_parser::deobfuscate_unused_instructions(instruction_container& instructions)
{
	bool found_handler_table = false;

	for (std::size_t i = 0, not_index = static_cast<std::size_t>(-1); i < instructions.size(); i++)
	{
		switch (instructions.at(i).get_mnemonic())
		{
		case UD_Imovsb:
		case UD_Imovsw:
		case UD_Imovsd:
		case UD_Imovsq:
			{
				instructions.at(i).set_index(1);
				this->backtrace_base_to_root(instructions, i, 0);
				this->backtrace_base_to_root(instructions, i, 1);
			}

			break;
			
		case UD_Ipushfw:
		case UD_Ipushfd:
		case UD_Ipushfq:
			{
				/* In the NOT handler, PUSHFD is used 2 instructions ahead. Always keep. */
				if (not_index != static_cast<std::size_t>(-1) && i == (not_index + 2))
					instructions.at(i).set_index(1);
				else
				{
					instructions.at(i).set_index(1);

					if (i >= 1)
					{
						if (instructions.at(i - 1).is_operand_type(0, { UD_OP_REG, UD_OP_MEM }))
							this->backtrace_base_to_root(instructions, i - 1, 0);
						
						if (instructions.at(i - 1).is_operand_type(1, UD_OP_REG))
							this->backtrace_base_to_root(instructions, i - 1, 1);
					}
				}
			}

			break;

		case UD_Icall:
		case UD_Ijmp:
			{
				if (instructions.at(i).is_operand_type_not(0, UD_OP_JIMM))
					this->backtrace_base_to_root(instructions, i, 0);
			}
			
			break;
			
		case UD_Icmp:
		case UD_Itest:
			{
				/* In the NOT handler, CMP is used 1 instruction ahead. Always keep. */
				if (not_index != static_cast<std::size_t>(-1) && i == (not_index + 1))
					instructions.at(i).set_index(1);
				else
				{
					if (instructions.bounds(i, 1) && 
						(instructions.at(i + 1).is_mnemonic(UD_Ipushfd) || 
						instructions.at(i + 1).is_mnemonic_jcc()))
					{
						this->backtrace_base_to_root(instructions, i, 0);

						if (instructions.at(i).is_operand_type_not(1, UD_OP_IMM))
							this->backtrace_base_to_root(instructions, i, 1);
					}
				}
			}

			break;
			
		case UD_Ija:	case UD_Ijae:	case UD_Ijb:	case UD_Ijbe:
		case UD_Ijg:	case UD_Ijge:	case UD_Ijl:	case UD_Ijle:
		case UD_Ijz:	case UD_Ijnz:	case UD_Ijo:	case UD_Ijno:
		case UD_Ijp:	case UD_Ijnp:	case UD_Ijs:	case UD_Ijns:
			{
				instructions.at(i).set_index(1);

				if (i >= 1)
				{
					this->backtrace_base_to_root(instructions, i - 1, 0);

					if (instructions.at(i - 1).is_operand_type(1, UD_OP_REG))
						this->backtrace_base_to_root(instructions, i - 1, 1);
				}
			}

			break;

		case UD_Ipop:
			{
				instructions.at(i).set_index(1);
				
				if (instructions.at(i).is_operand_type(0, UD_OP_MEM))
					this->backtrace_base_to_root(instructions, i, 0);
			}

			break;

		case UD_Iret:
			{
				instructions.at(i).set_index(1);
			}

			break;

		default:
			{
				if (instructions.at(i).is_mnemonic(UD_Inot))
					not_index = i;
				
				if (found_handler_table)
				{
					/* ___ dword ptr [ebp+xx],reg */
					if (!this->context.initialized_crypto_offset &&
						instructions.at(i).compare_mnemonic(false, false, true) &&
						instructions.at(i).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) &&
						instructions.at(i).is_operand_base(0, UD_R_EBP) &&
						instructions.at(i).has_operand_index_not(0) &&
						instructions.at(i).has_operand_scale_not(0) &&
						instructions.at(i).is_operand_data_not(0, this->context.vm_opcode_offset) &&
						instructions.at(i).is_operand_type(1, UD_OP_REG) &&
						!this->context.get_key(instructions.at(i).get_operand_data(0), nullptr))
					{
						this->context.initialized_crypto_offset = true;
						this->context.crypto_offset = instructions.at(i).get_operand_data<uint16_t>(0);

						instructions.remove(i--);
						continue;
					}
					/* ___ dword ptr [ebp+xx],reg */
					else if (this->context.initialized_crypto_offset &&
						instructions.at(i).compare_mnemonic(false, false, true) &&
						instructions.at(i).is_operand_type(0, UD_OP_MEM, UD_SIZE_DWORD) &&
						instructions.at(i).is_operand_base(0, UD_R_EBP) &&
						instructions.at(i).has_operand_index_not(0) &&
						instructions.at(i).has_operand_scale_not(0) &&
						instructions.at(i).is_operand_data<uint16_t>(0, this->context.crypto_offset) &&
						instructions.at(i).is_operand_type(1, UD_OP_REG))
					{
						instructions.remove(i--);
						continue;
					}
				}
				
				/* 0: mov reg,dword ptr [ebp+xx] */
				if (!found_handler_table &&
					instructions.at(i).is_mnemonic(UD_Imov) &&
					instructions.at(i).is_operand_type(0, UD_OP_REG) &&
					instructions.at(i).is_operand_type(1, UD_OP_MEM, UD_SIZE_DWORD) &&
					instructions.at(i).is_operand_base(1, UD_R_EBP) &&
					instructions.at(i).has_operand_index_not(1) &&
					instructions.at(i).has_operand_scale_not(1) &&
					instructions.at(i).is_operand_data(1, this->context.vm_handler_table_offset))
				{
					found_handler_table = true;
				}
				
				/* ___ */ 
				if (instructions.at(i).is_operand_null(0))
				{
					instructions.at(i).set_index(1);
				}
				/* ___ imm */
				else if (instructions.at(i).is_operand_type(0, UD_OP_IMM))
				{
					instructions.at(i).set_index(1);
				}
				/* ___ unknown ptr [reg] */
				else if (instructions.at(i).is_operand_type(0, UD_OP_MEM))
				{
					instructions.at(i).set_index(1);
					this->backtrace_base_to_root(instructions, i, 0);

					/* ___ unknown ptr [reg],reg */
					if (instructions.at(i).is_operand_type(1, UD_OP_REG))
					{
						instructions.at(i).set_index(1);
						this->backtrace_base_to_root(instructions, i, 1);
					}
				}
				/* ___ ___,unknown ptr [reg] */
				else if (instructions.at(i).is_operand_type(1, UD_OP_MEM))
				{
					instructions.at(i).set_index(1);
					this->backtrace_base_to_root(instructions, i, 1);
				}
				/* push reg */
				else if (instructions.at(i).is_mnemonic(UD_Ipush) &&
					instructions.at(i).is_operand_type(0, UD_OP_REG))
				{
					instructions.at(i).set_index(1);
					this->backtrace_base_to_root(instructions, i, 0);
				}
				/* ___ esp */
				else if (instructions.at(i).is_operand_type(0, UD_OP_REG) &&
					instructions.at(i).is_operand_base(0, UD_R_ESP))
				{
					instructions.at(i).set_index(1);
				}
			}

			break;
		}
	}

	for (std::size_t i = 0; i < instructions.size(); i++)
	{
		if (!instructions.at(i).get_index())
			instructions.remove(i--);
	}
}

void wild_handler_parser::backtrace_base_to_root(instruction_container& instructions, std::size_t index, uint8_t operand)
{
	if (instructions.bounds(index))
		instructions.at(index).set_index(1);

	if (index > 0 && 
		instructions.at(index).is_operand_base_family_not(operand, UD_R_ESP) && 
		instructions.at(index).is_operand_base_family_not(operand, UD_R_EBP))
	{
		ud_type base = instructions.at(index).get_base_type(operand);

		bool found_root = false;

		for (std::size_t i = (index - 1); static_cast<int32_t>(i) >= 0 && !found_root; i--)
		{
			switch (instructions.at(i).get_mnemonic())
			{
			case UD_Ipop:
				{
					/* 0: pop reg */
					if (instructions.at(i).is_operand_type(0, UD_OP_REG) &&
						instructions.at(i).is_operand_base_family(0, base))
					{
						instructions.at(i).set_index(1);
						found_root = true;
					}
				}

				break;

			case UD_Imov:
			case UD_Imovsx:
			case UD_Imovzx:
				{
					/* 0: mov(sz/zx) reg,___ */
					if (instructions.at(i).is_operand_type(0, UD_OP_REG) &&
						instructions.at(i).is_operand_base_family(0, base))
					{
						instructions.at(i).set_index(1);
						found_root = true;
						
						/* 0: mov(sz/zx) reg,reg */
						if (instructions.at(i).is_operand_type(1, UD_OP_REG) &&
							instructions.at(i).is_operand_base_not(1, UD_R_ESP) &&
							instructions.at(i).is_operand_base_not(1, UD_R_EBP))
						{
							/* 0: mov reg,reg */
							if (instructions.at(i).is_mnemonic(UD_Imov) &&
								instructions.at(i).is_operand_base(0, instructions.at(i), 1))
							{
								instructions.at(index).set_index(0);
								found_root = false;
							}
							else
							{
								this->backtrace_base_to_root(instructions, i, 1);
							}
						}
					}
				}

				break;

				/* 0: cmp/test ___,___ */
			case UD_Icmp:
			case UD_Itest:
				if (instructions.bounds(i, 1) &&
					instructions.at(i + 1).is_mnemonic_not({ UD_Ipushfw, UD_Ipushfd, UD_Ipushfq }) &&
					instructions.at(i + 1).is_mnemonic_jcc_not())
				{
					break;
				}
				
				/* 
					0: cmp/test ___,___
					1: jcc/pushf (xxxxxxxx)

					Intentionally skipping break into default case here 
				*/

			default:
				/* 0: ___ reg */
				if (instructions.at(i).is_operand_type(0, UD_OP_REG) &&
					instructions.at(i).is_operand_base_family(0, base))
				{
					instructions.at(i).set_index(1);
					
					/* 0: ___ reg,reg */
					if (instructions.at(i).is_operand_type(1, UD_OP_REG) &&
						instructions.at(i).is_operand_base_not(1, UD_R_ESP) &&
						instructions.at(i).is_operand_base_not(1, UD_R_EBP))
					{
						this->backtrace_base_to_root(instructions, i, 1);
					}
				}
				
				break;
			}
		}
	}
}
```

`TDE/wild_handler_parser.hpp`:

```hpp
#ifndef WILD_HANDLER_PARSER_HPP_
#define WILD_HANDLER_PARSER_HPP_

#include "wild_handler_tracer.hpp"

class wild_handler_parser : public wild_handler_tracer
{
protected:
	wild_handler_parser(wild_context& context);
	
protected:
	void decode_virtual_handler(instruction_container& instructions, uint32_t vm_handler_offset, uint32_t& compares);
	
private:
	void deobfuscate_vm_context_access(instruction_container& instructions);
	void deobfuscate_unused_instructions(instruction_container& instructions);
	
	void backtrace_base_to_root(instruction_container& instructions, std::size_t index, uint8_t operand);
};

#endif
```

`TDE/wild_handler_tracer.cpp`:

```cpp
#include "wild_handler_tracer.hpp"

#include <idp.hpp>

#define OBFUSCATION_BRANCH_COUNT	15

wild_handler_tracer::wild_handler_tracer(wild_context& context)
	: context(context)
{

}

void wild_handler_tracer::trace(uint32_t vm_handler, uint32_t& compares, instruction_container& instructions)
{
	this->tracing_branch_obfuscation = false;

	this->branch_continue = 0;
	this->branch_remaining = 0;

	this->jcc_branches.clear();

	ud_instruction instruction(vm_handler);
	instruction.set_input(this->context.to_segment(vm_handler));

	while (instructions.decode_assembly(instruction))
	{
		if (instruction.is_mnemonic(UD_Icmp))
			this->trace_cmp(compares);
		else if (instruction.is_mnemonic(UD_Ijmp))
		{
			if (!this->trace_jmp(instructions, instruction))
				break;
		}
		else if (instruction.is_mnemonic(UD_Iret))
		{
			if (!this->trace_ret(instructions, instruction))
				break;
		}
		else if (instruction.is_mnemonic_jcc())
		{
			if (!this->trace_jcc(instructions, instruction, compares))
				break;
		}
	}
}

void wild_handler_tracer::trace_cmp(uint32_t& compares)
{
	compares++;
}

bool wild_handler_tracer::trace_jmp(instruction_container& instructions, ud_instruction& instruction)
{
	if (instruction.is_operand_type(0, UD_OP_JIMM))
	{
		if (instructions.has_address(instruction.get_address_next<uint32_t>()))
			return this->trace_jcc_back(instructions, instruction);
		
		instructions.pop_back();
		instruction.skip_input(instruction.get_operand_data<uint32_t>(0));
	}
	else
	{
		return this->trace_branch_obfuscation_continue(instruction);
	}

	return true;
}

bool wild_handler_tracer::trace_ret(instruction_container& instructions, ud_instruction& instruction)
{
	return this->trace_branch_obfuscation_continue(instruction);
}

bool wild_handler_tracer::trace_jcc(instruction_container& instructions, ud_instruction& instruction, uint32_t& compares)
{
	if (instructions.try_evaluate_branch_simple())
	{
		if (compares == 3)
			this->trace_branch_compares(instructions);

		if (this->tracing_branch_obfuscation)
			this->trace_branch_obfuscation(instruction);
		else
			this->jcc_branches.push(instruction.get_address_next<uint32_t>());
	}
	else if (instructions.try_evaluate_branch(instruction))
	{
		instructions.pop_back();
		instruction.skip_input(instruction.get_operand_data<uint32_t>(0));
	}
	
	return (!instructions.has_address(instruction.get_address_next<uint32_t>()));
}

void wild_handler_tracer::trace_branch_compares(instruction_container& instructions)
{
	if (this->is_branch_obfuscation(instructions))
	{
		this->tracing_branch_obfuscation = true;
		this->branch_remaining = OBFUSCATION_BRANCH_COUNT;
	}
	else
	{
		this->tracing_branch_obfuscation = false;
	}
}

void wild_handler_tracer::trace_branch_obfuscation(ud_instruction& instruction)
{
	if (this->branch_remaining > 0)
		instruction.skip_input(instruction.get_operand_data<uint32_t>(0));
	else if (this->branch_remaining == 0)
		this->branch_continue = instruction.get_address_next<uint32_t>();

	this->branch_remaining--;
}

bool wild_handler_tracer::trace_branch_obfuscation_continue(ud_instruction& instruction)
{
	if (this->tracing_branch_obfuscation && this->branch_continue)
	{
		instruction.reset_input(this->branch_continue);

		this->tracing_branch_obfuscation = false;
		this->branch_continue = 0;
		return true;
	}

	return false;
}

bool wild_handler_tracer::trace_jcc_back(instruction_container& instructions, ud_instruction& instruction)
{
	if (!this->jcc_branches.empty())
	{
		while (!this->jcc_branches.empty())
		{
			uint32_t jcc_destination = this->jcc_branches.top();

			this->jcc_branches.pop();

			if (!instructions.has_address(jcc_destination))
			{
				uint32_t base_address = static_cast<uint32_t>(instruction.pc - instruction.inp_buf_index);
				uint32_t base_offset = (jcc_destination - base_address);

				instruction.reset_input(jcc_destination);
				return true;
			}
		}
	}

	return false;
}

bool wild_handler_tracer::is_branch_obfuscation(instruction_container& instructions)
{
	if (instructions.size() > 6)
	{
		std::size_t index = (instructions.size() - 6);

		/*
			0: cmp reg,imm
			1: je ____
			2: cmp reg,imm
			3: je ____
			4: cmp reg,imm
			5: jne ___
		*/
		return (instructions.at(index).is_mnemonic(UD_Icmp) &&
			instructions.at(index).is_operand_type(0, UD_OP_REG, UD_SIZE_BYTE) &&
			instructions.at(index).is_operand_type(1, UD_OP_IMM) &&
			
			instructions.at(index + 1).is_mnemonic(UD_Ijz) &&

			instructions.at(index + 2).is_mnemonic(UD_Icmp) &&
			instructions.at(index + 2).is_operand_type(0, UD_OP_REG, UD_SIZE_BYTE) &&
			instructions.at(index + 2).is_operand_base(0, instructions.at(index), 0) &&
			instructions.at(index + 2).is_operand_type(1, UD_OP_IMM) &&
			
			instructions.at(index + 3).is_mnemonic(UD_Ijz) &&

			instructions.at(index + 4).is_mnemonic(UD_Icmp) &&
			instructions.at(index + 4).is_operand_type(0, UD_OP_REG, UD_SIZE_BYTE) &&
			instructions.at(index + 4).is_operand_base(0, instructions.at(index + 2), 0) &&
			instructions.at(index + 4).is_operand_type(1, UD_OP_IMM) &&
			
			instructions.at(index + 5).is_mnemonic(UD_Ijnz));
	}

	return false;
}
```

`TDE/wild_handler_tracer.hpp`:

```hpp
#ifndef WILD_HANDLER_TRACER_HPP_
#define WILD_HANDLER_TRACER_HPP_

#include "oreans_base.hpp"
#include "wild_context.hpp"

#include <stack>

class wild_handler_tracer : public oreans_base
{
	template <typename T>
	class clearable_stack : public std::stack<T>
	{
	public:
		void clear()
		{
			this->c.clear();
		}
	};

protected:
	wild_handler_tracer(wild_context& context);

protected:
	void trace(uint32_t vm_handler, uint32_t& compares, instruction_container& instructions);

private:
	void trace_cmp(uint32_t& compares);
	bool trace_jmp(instruction_container& instructions, ud_instruction& instruction);
	bool trace_ret(instruction_container& instructions, ud_instruction& instruction);
	bool trace_jcc(instruction_container& instructions, ud_instruction& instruction, uint32_t& compares);
	
	void trace_branch_compares(instruction_container& instructions);
	void trace_branch_obfuscation(ud_instruction& instruction);
	bool trace_branch_obfuscation_continue(ud_instruction& instruction);

	bool trace_jcc_back(instruction_container& instructions, ud_instruction& instruction);

	bool is_branch_obfuscation(instruction_container& instructions);
	
protected:
	wild_context& context;

private:
	bool tracing_branch_obfuscation;

	uint32_t branch_continue;
	uint32_t branch_remaining;

	clearable_stack<uint32_t> jcc_branches;
};

#endif
```

`TDE/wild_handler_types.hpp`:

```hpp
#ifndef WILD_HANDLER_TYPES_HPP_
#define WILD_HANDLER_TYPES_HPP_

#include <stdint.h>

enum wild_handler_types : uint16_t
{
	WILD_HANDLER_UNKNOWN = 0x0000,

	WILD_HANDLER_JUMP_INSIDE,
	WILD_HANDLER_JUMP_OUTSIDE_REGISTER,
	WILD_HANDLER_JUMP_OUTSIDE_MEMORY,
	WILD_HANDLER_JUMP_OUTSIDE_IMMEDIATE,
	
	WILD_HANDLER_JCC_INSIDE,
	WILD_HANDLER_JCC_OUTSIDE,

	WILD_HANDLER_RET,
	WILD_HANDLER_CALL,
	WILD_HANDLER_UNDEF,
	
	WILD_HANDLER_LODSB,	
	WILD_HANDLER_LODSW,
	WILD_HANDLER_LODSD,	

	WILD_HANDLER_STOSB,
	WILD_HANDLER_STOSW,
	WILD_HANDLER_STOSD,

	WILD_HANDLER_SCASB,
	WILD_HANDLER_SCASW,
	WILD_HANDLER_SCASD,	

	WILD_HANDLER_CMPSB,
	WILD_HANDLER_CMPSW,
	WILD_HANDLER_CMPSD,

	WILD_HANDLER_MOVSB,
	WILD_HANDLER_MOVSW,
	WILD_HANDLER_MOVSD,

	WILD_HANDLER_PUSHFD,
	WILD_HANDLER_POPFD,
	
	WILD_HANDLER_EFLAGS,					// EFLAGS operations (e.g. STD, STI, etc.)

	WILD_HANDLER_RESTORE_STACK,
	WILD_HANDLER_LOAD_STACK,
	WILD_HANDLER_STORE_STACK,
	
	WILD_HANDLER_RESET_EFLAGS,
	WILD_HANDLER_RESET,
	
	WILD_HANDLER_CRYPT,
	
	WILD_HANDLER_COUNT,

	WILD_HANDLER_INVALID = 0xFFFF,
};

#endif
```

`TDE/wild_hybrid_base.cpp`:

```cpp
#include "wild_hybrid_base.hpp"

```

`TDE/wild_hybrid_base.hpp`:

```hpp
#ifndef WILD_HYBRID_BASE_HPP_
#define WILD_HYBRID_BASE_HPP_

#include "wild_base.hpp"

template <class GuestT, class HostT>
class wild_hybrid_base
{
//	static_assert(std::is_base_of<wild_base, GuestT>::value, "GuestT (vm_guest) in class 'wild_hybrid_base' must be derived from class 'wild_base'.");
//	static_assert(std::is_base_of<wild_base, HostT>::value, "HostT (vm_host) in class 'wild_hybrid_base' must be derived from class 'wild_base'.");

public:
	/* ... */

private:
	GuestT vm_guest;	// Inner VM (virtualized by host)
	HostT vm_host;		// Outer VM
};

#endif
```

`TDE/wild_opcode_label.hpp`:

```hpp
#ifndef WILD_OPCODE_LABEL_HPP_
#define WILD_OPCODE_LABEL_HPP_

#include <stdint.h>

typedef struct wild_opcode_label
{
	wild_opcode_label(uint32_t address, uint32_t offset)
	{
		this->is_read = false;

		this->address = address;
		this->offset = offset;
	}
	
	bool is_read;

	uint32_t address;
	uint32_t offset;
} wild_opcode_label;

#endif
```

`TDE/wild_opcode_label_manager.hpp`:

```hpp
#ifndef WILD_OPCODE_LABEL_MANAGER_HPP_
#define WILD_OPCODE_LABEL_MANAGER_HPP_

#include "wild_opcode_label.hpp"

#include <algorithm>
#include <iterator>
#include <vector>

class wild_opcode_label_manager
{
public:
    void reset_labels()
    {
        this->virtual_opcode_labels.clear();
    }

public:
    bool find_unread_label(std::vector<wild_opcode_label>::iterator& iter)
    {
        iter = std::find_if(this->virtual_opcode_labels.begin(), this->virtual_opcode_labels.end(), [&](wild_opcode_label const& label) -> bool
        {
            return (!label.is_read);
        });
    
        return (iter != this->virtual_opcode_labels.end());
    }

    bool find_label_at_address(std::vector<wild_opcode_label>::iterator& iter, uint32_t address)
    {
        iter = std::find_if(this->virtual_opcode_labels.begin(), this->virtual_opcode_labels.end(), [&](wild_opcode_label const& label) -> bool
        {
            return (label.address == address);
        });
    
        return (iter != this->virtual_opcode_labels.end());
    }

public:
    bool exists_label(uint32_t address)
    {
        std::vector<wild_opcode_label>::iterator iter;
        return this->find_label_at_address(iter, address);
    }

    void create_label(uint32_t address, uint32_t offset)
    {
        if (!this->exists_label(address))
            this->virtual_opcode_labels.push_back(wild_opcode_label(address, offset));
    }

protected:
    std::vector<wild_opcode_label> virtual_opcode_labels;
};

#endif

```

`TDE/wild_opcode_reader.hpp`:

```hpp
#ifndef WILD_OPCODE_READER_HPP_
#define WILD_OPCODE_READER_HPP_

#include <cstdint>
#include <type_traits> // For static_assert

class opcode_reader
{
public:
    opcode_reader(uint8_t* opcode_address)
        : opcode_address(opcode_address)
    {

    }

    template <typename T>
    T read(uint32_t offset)
    {
        static_assert(std::is_trivially_copyable<T>::value, "T must be a trivially copyable type");
        if (this->opcode_address != nullptr)
            return *reinterpret_cast<T*>(this->opcode_address + offset);

        return static_cast<T>(0);
    }

private:
    uint8_t* opcode_address;
};

#endif

```