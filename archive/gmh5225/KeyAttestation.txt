Project Path: arc_gmh5225_KeyAttestation_g4vw8tr4

Source Tree:

```txt
arc_gmh5225_KeyAttestation_g4vw8tr4
├── README.md
├── app
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── java
│           │   └── io
│           │       └── github
│           │           └── vvb2060
│           │               └── keyattestation
│           │                   ├── AppApplication.kt
│           │                   ├── app
│           │                   │   ├── AlertDialogFragment.kt
│           │                   │   ├── AppActivity.kt
│           │                   │   ├── AppBarActivity.kt
│           │                   │   └── AppFragment.kt
│           │                   ├── attestation
│           │                   │   ├── Asn1Attestation.java
│           │                   │   ├── Asn1Utils.java
│           │                   │   ├── Attestation.java
│           │                   │   ├── AttestationApplicationId.java
│           │                   │   ├── AttestationPackageInfo.java
│           │                   │   ├── AttestationResult.kt
│           │                   │   ├── AuthorizationList.java
│           │                   │   ├── CborUtils.java
│           │                   │   ├── CertificateRevocationStatus.java
│           │                   │   ├── EatAttestation.java
│           │                   │   ├── EatClaim.java
│           │                   │   ├── RootOfTrust.java
│           │                   │   └── VerifyCertificateChain.java
│           │                   ├── home
│           │                   │   ├── BootStateViewHolder.kt
│           │                   │   ├── CommonItemViewHolder.kt
│           │                   │   ├── Data.kt
│           │                   │   ├── ErrorViewHolder.kt
│           │                   │   ├── HeaderViewHolder.kt
│           │                   │   ├── HomeActivity.kt
│           │                   │   ├── HomeAdapter.kt
│           │                   │   ├── HomeFragment.kt
│           │                   │   ├── HomeItemDecoration.kt
│           │                   │   ├── HomeViewHolder.kt
│           │                   │   ├── HomeViewModel.kt
│           │                   │   └── SubtitleViewHolder.kt
│           │                   ├── ktx
│           │                   │   ├── String.kt
│           │                   │   └── ViewModelLazy.kt
│           │                   ├── lang
│           │                   │   └── AttestationException.kt
│           │                   └── util
│           │                       ├── Resource.kt
│           │                       └── ViewBindingViewHolder.kt
│           └── res
│               ├── color
│               │   ├── material_on_surface_emphasis_high_type.xml
│               │   ├── material_on_surface_emphasis_medium.xml
│               │   └── mtrl_popupmenu_overlay_color.xml
│               ├── drawable
│               │   ├── home_item_background_solid.xml
│               │   ├── ic_boot_locked_24.xml
│               │   ├── ic_boot_unknown_24.xml
│               │   ├── ic_boot_unlocked_24.xml
│               │   ├── ic_error_outline_24.xml
│               │   ├── ic_help_outline_24.xml
│               │   ├── ic_launcher.xml
│               │   ├── ic_trustworthy_24.xml
│               │   ├── ic_untrustworthy_24.xml
│               │   └── ic_warning_24.xml
│               ├── drawable-v26
│               │   └── ic_launcher.xml
│               ├── layout
│               │   ├── appbar.xml
│               │   ├── appbar_activity.xml
│               │   ├── appbar_fragment_activity.xml
│               │   ├── home.xml
│               │   ├── home_boot_state.xml
│               │   ├── home_common_item.xml
│               │   ├── home_error.xml
│               │   ├── home_header.xml
│               │   └── home_subtitle.xml
│               ├── menu
│               │   └── home.xml
│               ├── mipmap-hdpi
│               │   ├── ic_key_attestation.png
│               │   ├── ic_key_attestation_background.png
│               │   └── ic_key_attestation_foreground.png
│               ├── mipmap-xhdpi
│               │   ├── ic_key_attestation.png
│               │   ├── ic_key_attestation_background.png
│               │   └── ic_key_attestation_foreground.png
│               ├── mipmap-xxhdpi
│               │   ├── ic_key_attestation.png
│               │   ├── ic_key_attestation_background.png
│               │   └── ic_key_attestation_foreground.png
│               ├── mipmap-xxxhdpi
│               │   ├── ic_key_attestation.png
│               │   ├── ic_key_attestation_background.png
│               │   └── ic_key_attestation_foreground.png
│               ├── raw
│               │   └── status.json
│               ├── values
│               │   ├── colors.xml
│               │   ├── dimens.xml
│               │   ├── strings.xml
│               │   ├── strings_no_translate.xml
│               │   ├── styles.xml
│               │   ├── themes.xml
│               │   └── themes_override.xml
│               ├── values-sw600dp
│               │   └── dimens.xml
│               ├── values-zh-rCN
│               │   └── strings.xml
│               └── values-zh-rTW
│                   └── strings.xml
├── art
│   ├── icon.ai
│   └── icon_playstore.png
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
└── settings.gradle

```

`README.md`:

```md
Android Key Attestation Sample App
==============================

This app supports generating, saving, loading, parsing and verifying Android [key and ID attestation](https://source.android.com/docs/security/features/keystore/attestation) data.

The app is used for self-testing, so it has no network permission. The certificate revocation data is embedded in the apk and will not be updated online. If the system is compromised, parsing and verifying is not safe, you should save the data to a file and then load the file on another device to verify it.

This app also supports parsing attestation data generated by other software, and the supported storage format is [PkiPath](https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html#certpath-encodings).

License
-------

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

```

`app/build.gradle`:

```gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

def gitCommitCount
try {
    gitCommitCount = Integer.parseInt('git rev-list --count HEAD'.execute([], project.rootDir).text.trim())
} catch (ignored) {
    gitCommitCount = 1
}

Properties properties = new Properties()
if (project.rootProject.file("local.properties").exists()) {
    properties.load(project.rootProject.file("local.properties").newDataInputStream())
}

android {
    compileSdk = 34
    buildToolsVersion = '34.0.0'
    namespace = 'io.github.vvb2060.keyattestation'
    defaultConfig {
        minSdk = 24
        targetSdk = 34
        versionCode = gitCommitCount
        versionName = '1.5.0'
        resConfigs "en", "zh-rCN", "zh-rTW"
    }

    signingConfigs {
        if (properties.getProperty("storeFile") != null) {
            sign {
                storeFile file(properties.getProperty("storeFile"))
                storePassword properties.getProperty("storePassword")
                keyAlias properties.getProperty("keyAlias")
                keyPassword properties.getProperty("keyPassword")
            }
        }
    }
    buildTypes {
        debug {
            if (properties.getProperty("storeFile") != null) {
                signingConfig signingConfigs.sign
            }
        }
        release {
            minifyEnabled true
            shrinkResources true
            if (properties.getProperty("storeFile") != null) {
                signingConfig signingConfigs.sign
            } else {
                signingConfig signingConfigs.debug
            }
            proguardFiles 'proguard-rules.pro'
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17
    }

    buildFeatures {
        viewBinding = true
        buildConfig = true
    }

    packagingOptions {
        resources {
            excludes += '**'
        }
    }

    lintOptions.checkReleaseBuilds false
    dependenciesInfo.includeInApk false
}

configurations.configureEach {
    exclude group: 'androidx.appcompat', module: 'appcompat'
    exclude group: 'org.jetbrains.kotlin', module: 'kotlin-stdlib-jdk7'
    exclude group: 'org.jetbrains.kotlin', module: 'kotlin-stdlib-jdk8'
}

dependencies {
    implementation 'org.bouncycastle:bcprov-jdk18on:1.73'
    implementation 'com.google.guava:guava:32.0.0-android'
    implementation 'com.google.code.gson:gson:2.10.1'
    implementation 'co.nstant.in:cbor:0.9'

    implementation 'dev.rikka.rikkax.appcompat:appcompat:1.6.1'
    implementation 'dev.rikka.rikkax.core:core-ktx:1.4.1'
    //noinspection GradleDependency
    implementation 'dev.rikka.rikkax.material:material:1.6.6'
    implementation 'dev.rikka.rikkax.html:html-ktx:1.1.2'
    implementation 'dev.rikka.rikkax.recyclerview:recyclerview-adapter:1.3.0'
    implementation 'dev.rikka.rikkax.widget:borderview:1.1.0'

    implementation 'com.google.android.material:material:1.9.0'

    implementation 'androidx.core:core-ktx:1.10.1'
    implementation 'androidx.fragment:fragment-ktx:1.6.0'
    implementation 'androidx.recyclerview:recyclerview:1.3.0'

    def lifecycleVersion = "2.6.1"
    implementation "androidx.lifecycle:lifecycle-common-java8:$lifecycleVersion"
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:$lifecycleVersion"
}

```

`app/proguard-rules.pro`:

```pro
-allowaccessmodification
-repackageclasses

-keepclassmembers class * implements android.os.Parcelable {
    public static final ** CREATOR;
}

-assumenosideeffects class kotlin.jvm.internal.Intrinsics {
	public static void check*(...);
	public static void throw*(...);
}

-assumenosideeffects class java.util.Objects{
    ** requireNonNull(...);
}

-assumenosideeffects class android.util.Log {
    public static int v(...);
    public static int d(...);
}

```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <permission
        android:name="${applicationId}.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"
        android:protectionLevel="signature"
        tools:node="remove" />

    <uses-permission
        android:name="${applicationId}.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"
        tools:node="remove" />

    <application
        android:name=".AppApplication"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@drawable/ic_launcher"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"
        tools:ignore="AllowBackup">
        <activity
            android:name=".home.HomeActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <provider
            android:name="androidx.startup.InitializationProvider"
            android:authorities="${applicationId}.androidx-startup"
            android:exported="false"
            tools:ignore="MissingClass"
            tools:node="remove" />
        <receiver
            android:name="androidx.profileinstaller.ProfileInstallReceiver"
            android:exported="false"
            tools:ignore="MissingClass"
            tools:node="remove" />
    </application>

</manifest>

```

`app/src/main/java/io/github/vvb2060/keyattestation/AppApplication.kt`:

```kt
package io.github.vvb2060.keyattestation

import android.app.Application
import android.content.Context
import android.os.Handler
import android.os.Looper
import org.bouncycastle.jce.provider.BouncyCastleProvider
import rikka.html.text.HtmlCompat
import rikka.material.app.DayNightDelegate
import java.security.Security
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class AppApplication : Application() {
    companion object {
        const val TAG = "KeyAttestation"
        lateinit var app: AppApplication
        lateinit var mainHandler: Handler
        val executor: ExecutorService = Executors.newCachedThreadPool()
    }

    init {
        app = this
        mainHandler = Handler(Looper.getMainLooper())
        DayNightDelegate.setApplicationContext(this)
        DayNightDelegate.setDefaultNightMode(DayNightDelegate.MODE_NIGHT_FOLLOW_SYSTEM)
        HtmlCompat.setContext(this)
        install(this)
    }

    private fun install(context: Context) = executor.execute {
        if (BuildConfig.DEBUG) {
            Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME)
            Security.insertProviderAt(BouncyCastleProvider(), 1)
            return@execute
        }
        runCatching {
            val gms = context.createPackageContext("com.google.android.gms",
                    Context.CONTEXT_INCLUDE_CODE or Context.CONTEXT_IGNORE_SECURITY)
            gms.classLoader
                    .loadClass("com.google.android.gms.common.security.ProviderInstallerImpl")
                    .getMethod("insertProvider", Context::class.java)
                    .invoke(null, gms)
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/app/AlertDialogFragment.kt`:

```kt
package io.github.vvb2060.keyattestation.app

import android.app.Dialog
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.os.Bundle
import android.os.Parcel
import android.os.Parcelable
import android.text.method.LinkMovementMethod
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.DialogFragment
import androidx.fragment.app.FragmentManager

open class AlertDialogFragment : DialogFragment() {

    fun show(fragmentManager: FragmentManager) {
        if (fragmentManager.isStateSaved) return
        show(fragmentManager, javaClass.simpleName)
    }

    open fun onCreateAlertDialogBuilder(context: Context): AlertDialog.Builder {
        return AlertDialog.Builder(context)
    }

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val context = requireContext()
        val builder = onCreateAlertDialogBuilder(context)
        onBuildAlertDialog(builder, savedInstanceState)
        val dialog = builder.create()
        dialog.setOnShowListener { onShow(dialog) }
        onAlertDialogCreated(dialog, savedInstanceState)
        return dialog
    }

    open fun onBuildAlertDialog(builder: AlertDialog.Builder, savedInstanceState: Bundle?) {
        val args = requireArguments()
        if (args.containsKey(INTERNAL_BUILDER_ARGS)) {
            val dialogBuilder: Builder = args.getParcelable(INTERNAL_BUILDER_ARGS)!!
            builder.setTitle(dialogBuilder.title)
            builder.setMessage(dialogBuilder.message)
            if (dialogBuilder.positiveButtonText != null) {
                builder.setPositiveButton(dialogBuilder.positiveButtonText) { _: DialogInterface?, _: Int -> launchIntent(dialogBuilder.positiveButtonIntent) }
            }
            if (dialogBuilder.negativeButtonText != null) {
                builder.setNegativeButton(dialogBuilder.negativeButtonText) { _: DialogInterface?, _: Int -> launchIntent(dialogBuilder.negativeButtonIntent) }
            }
            if (dialogBuilder.neutralButtonText != null) {
                builder.setNeutralButton(dialogBuilder.neutralButtonText) { _: DialogInterface?, _: Int -> launchIntent(dialogBuilder.neutralButtonIntent) }
            }
        }
    }

    open fun onAlertDialogCreated(dialog: AlertDialog, savedInstanceState: Bundle?) {}

    open fun onShow(dialog: AlertDialog) {
        dialog.findViewById<TextView>(android.R.id.message)?.movementMethod = LinkMovementMethod.getInstance()
    }

    override fun getDialog(): AlertDialog? {
        return super.getDialog() as AlertDialog?
    }

    open fun getButton(whichButton: Int): Button? {
        return dialog?.getButton(whichButton)
    }

    private fun launchIntent(intent: Intent?) {
        if (intent != null) {
            //Do nothing.
        }
    }

    class Builder(private val context: Context?) : Parcelable {

        var title: CharSequence? = null
            private set

        var message: CharSequence? = null
            private set

        var positiveButtonText: CharSequence? = null
            private set

        var negativeButtonText: CharSequence? = null
            private set

        var neutralButtonText: CharSequence? = null
            private set

        var positiveButtonIntent: Intent? = null
            private set

        var negativeButtonIntent: Intent? = null
            private set

        var neutralButtonIntent: Intent? = null
            private set

        private constructor(`in`: Parcel) : this(null) {
            title = `in`.readString()
            message = `in`.readString()
            positiveButtonText = `in`.readString()
            negativeButtonText = `in`.readString()
            neutralButtonText = `in`.readString()
            positiveButtonIntent = `in`.readParcelable(Intent::class.java.classLoader)
            negativeButtonIntent = `in`.readParcelable(Intent::class.java.classLoader)
            neutralButtonIntent = `in`.readParcelable(Intent::class.java.classLoader)
        }

        fun title(title: CharSequence?) = apply { this.title = title }

        fun title(title: Int) = title(context!!.getString(title))

        fun message(message: CharSequence?) = apply { this.message = message }

        fun message(message: Int) = message(context!!.getString(message))

        fun positiveButton(text: CharSequence?, intent: Intent? = null) = apply {
            positiveButtonText = text
            positiveButtonIntent = intent
        }

        fun positiveButton(text: Int, intent: Intent? = null) = positiveButton(context!!.getString(text), intent)

        fun negativeButton(text: CharSequence?, intent: Intent? = null) = apply {
            negativeButtonText = text
            negativeButtonIntent = intent
        }

        fun negativeButton(text: Int, intent: Intent? = null) = negativeButton(context!!.getString(text), intent)

        fun neutralButton(text: CharSequence?, intent: Intent? = null) = apply {
            neutralButtonText = text
            neutralButtonIntent = intent
        }

        fun neutralButton(text: Int, intent: Intent? = null) = neutralButton(context!!.getString(text), intent)

        fun build(): AlertDialogFragment {
            val fragment = AlertDialogFragment()
            val args = Bundle()
            args.putParcelable(INTERNAL_BUILDER_ARGS, this)
            fragment.arguments = args
            return fragment
        }

        override fun describeContents(): Int {
            return 0
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeString(title.toString())
            dest.writeString(message.toString())
            dest.writeString(positiveButtonText.toString())
            dest.writeString(negativeButtonText.toString())
            dest.writeString(neutralButtonText.toString())
            dest.writeParcelable(positiveButtonIntent, flags)
            dest.writeParcelable(negativeButtonIntent, flags)
            dest.writeParcelable(neutralButtonIntent, flags)
        }

        companion object {

            @JvmField
            val CREATOR: Parcelable.Creator<Builder> = object : Parcelable.Creator<Builder> {
                override fun createFromParcel(`in`: Parcel): Builder {
                    return Builder(`in`)
                }

                override fun newArray(size: Int): Array<Builder?> {
                    return arrayOfNulls(size)
                }
            }
        }
    }

    companion object {
        private val INTERNAL_BUILDER_ARGS = AlertDialogFragment::class.java.name + ".BUILDER_ARGS"
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/app/AppActivity.kt`:

```kt
package io.github.vvb2060.keyattestation.app

import android.content.res.Resources
import android.graphics.Color
import android.os.Build
import rikka.core.res.resolveColor
import rikka.material.app.MaterialActivity

open class AppActivity : MaterialActivity() {

    override fun shouldApplyTranslucentSystemBars(): Boolean {
        return true
    }

    override fun onApplyTranslucentSystemBars() {
        super.onApplyTranslucentSystemBars()

        val window = window
        val theme = theme

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            window?.decorView?.post {
                if (window.decorView.rootWindowInsets?.systemWindowInsetBottom ?: 0 >= Resources.getSystem().displayMetrics.density * 40) {
                    window.navigationBarColor = theme.resolveColor(android.R.attr.navigationBarColor) and 0x00ffffff or -0x20000000
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        window.isNavigationBarContrastEnforced = false
                    }
                } else {
                    window.navigationBarColor = Color.TRANSPARENT
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        window.isNavigationBarContrastEnforced = true
                    }
                }
            }
        }
    }
}
```

`app/src/main/java/io/github/vvb2060/keyattestation/app/AppBarActivity.kt`:

```kt
package io.github.vvb2060.keyattestation.app

import android.graphics.Color
import android.os.Bundle
import android.view.View
import android.view.ViewGroup
import android.widget.FrameLayout
import androidx.annotation.LayoutRes
import androidx.appcompat.widget.Toolbar
import io.github.vvb2060.keyattestation.R
import rikka.material.widget.AppBarLayout

abstract class AppBarActivity : AppActivity() {

    private val rootView: ViewGroup by lazy {
        findViewById<ViewGroup>(R.id.root)
    }

    private val toolbarContainer: AppBarLayout by lazy {
        findViewById<AppBarLayout>(R.id.toolbar_container)
    }

    private val toolbar: Toolbar by lazy {
        findViewById<Toolbar>(R.id.toolbar)
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        super.setContentView(getLayoutId())

        setAppBar(toolbarContainer, toolbar)
    }

    @LayoutRes
    open fun getLayoutId(): Int {
        return R.layout.appbar_activity
    }

    override fun setContentView(layoutResID: Int) {
        layoutInflater.inflate(layoutResID, rootView, true)
        rootView.bringChildToFront(toolbarContainer)
    }

    override fun setContentView(view: View?) {
        setContentView(view, FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
    }

    override fun setContentView(view: View?, params: ViewGroup.LayoutParams?) {
        rootView.addView(view, 0, params)
    }

    override fun shouldApplyTranslucentSystemBars(): Boolean {
        return true
    }

    override fun onApplyTranslucentSystemBars() {
        super.onApplyTranslucentSystemBars()
        window?.statusBarColor = Color.TRANSPARENT
    }
}

abstract class AppBarFragmentActivity : AppBarActivity() {

    override fun getLayoutId(): Int {
        return R.layout.appbar_fragment_activity
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/app/AppFragment.kt`:

```kt
package io.github.vvb2060.keyattestation.app

import androidx.fragment.app.Fragment

open class AppFragment : Fragment() {

    val appActivity: AppActivity? get() = activity as AppActivity?

    fun requireAppActivity(): AppActivity {
        return appActivity ?: throw IllegalStateException("Fragment $this not attached to an activity.")
    }
}
```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/Asn1Attestation.java`:

```java
/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import org.bouncycastle.asn1.ASN1Sequence;

import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;

public class Asn1Attestation extends Attestation {
    static final int ATTESTATION_VERSION_INDEX = 0;
    static final int ATTESTATION_SECURITY_LEVEL_INDEX = 1;
    static final int KEYMASTER_VERSION_INDEX = 2;
    static final int KEYMASTER_SECURITY_LEVEL_INDEX = 3;
    static final int ATTESTATION_CHALLENGE_INDEX = 4;
    static final int UNIQUE_ID_INDEX = 5;
    static final int SW_ENFORCED_INDEX = 6;
    static final int TEE_ENFORCED_INDEX = 7;

    int attestationSecurityLevel;

    /**
     * Constructs an {@code Asn1Attestation} object from the provided {@link X509Certificate},
     * extracting the attestation data from the attestation extension.
     *
     * @throws CertificateParsingException if the certificate does not contain a properly-formatted
     *     attestation extension.
     */

    public Asn1Attestation(X509Certificate x509Cert) throws CertificateParsingException {
        super(x509Cert);
        ASN1Sequence seq = getAttestationSequence(x509Cert);

        attestationVersion =
                Asn1Utils.getIntegerFromAsn1(seq.getObjectAt(ATTESTATION_VERSION_INDEX));
        attestationSecurityLevel =
                Asn1Utils.getIntegerFromAsn1(seq.getObjectAt(ATTESTATION_SECURITY_LEVEL_INDEX));
        keymasterVersion = Asn1Utils.getIntegerFromAsn1(seq.getObjectAt(KEYMASTER_VERSION_INDEX));
        keymasterSecurityLevel =
                Asn1Utils.getIntegerFromAsn1(seq.getObjectAt(KEYMASTER_SECURITY_LEVEL_INDEX));

        attestationChallenge =
                Asn1Utils.getByteArrayFromAsn1(seq.getObjectAt(ATTESTATION_CHALLENGE_INDEX));

        uniqueId = Asn1Utils.getByteArrayFromAsn1(seq.getObjectAt(UNIQUE_ID_INDEX));

        softwareEnforced = new AuthorizationList(seq.getObjectAt(SW_ENFORCED_INDEX));
        teeEnforced = new AuthorizationList(seq.getObjectAt(TEE_ENFORCED_INDEX));
    }

    ASN1Sequence getAttestationSequence(X509Certificate x509Cert)
            throws CertificateParsingException {
        byte[] attestationExtensionBytes = x509Cert.getExtensionValue(Attestation.ASN1_OID);
        if (attestationExtensionBytes == null || attestationExtensionBytes.length == 0) {
            throw new CertificateParsingException("Did not find extension with OID " + ASN1_OID);
        }
        return Asn1Utils.getAsn1SequenceFromBytes(attestationExtensionBytes);
    }

    public int getAttestationSecurityLevel() {
        return attestationSecurityLevel;
    }

    public RootOfTrust getRootOfTrust() {
        RootOfTrust tee = teeEnforced.getRootOfTrust();
        if (tee != null) return tee;
        return softwareEnforced.getRootOfTrust();
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/Asn1Utils.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import com.google.common.collect.ImmutableSet;

import org.bouncycastle.asn1.ASN1Boolean;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Enumerated;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1Set;
import org.bouncycastle.asn1.DEROctetString;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.cert.CertificateParsingException;
import java.util.Date;
import java.util.Enumeration;
import java.util.Set;

public class Asn1Utils {

    public static int getIntegerFromAsn1(ASN1Encodable asn1Value)
            throws CertificateParsingException {
        if (asn1Value instanceof ASN1Integer) {
            return bigIntegerToInt(((ASN1Integer) asn1Value).getValue());
        } else if (asn1Value instanceof ASN1Enumerated) {
            return bigIntegerToInt(((ASN1Enumerated) asn1Value).getValue());
        } else {
            throw new CertificateParsingException(
                    "Integer value expected, " + asn1Value.getClass().getName() + " found.");
        }
    }

    public static Long getLongFromAsn1(ASN1Encodable asn1Value) throws CertificateParsingException {
        if (asn1Value instanceof ASN1Integer) {
            return bigIntegerToLong(((ASN1Integer) asn1Value).getValue());
        } else {
            throw new CertificateParsingException(
                    "Integer value expected, " + asn1Value.getClass().getName() + " found.");
        }
    }

    public static byte[] getByteArrayFromAsn1(ASN1Encodable asn1Encodable)
            throws CertificateParsingException {
        if (asn1Encodable == null || !(asn1Encodable instanceof DEROctetString)) {
            throw new CertificateParsingException("Expected DEROctetString");
        }
        ASN1OctetString derOctectString = (ASN1OctetString) asn1Encodable;
        return derOctectString.getOctets();
    }

    public static ASN1Encodable getAsn1EncodableFromBytes(byte[] bytes)
            throws CertificateParsingException {
        try (ASN1InputStream asn1InputStream = new ASN1InputStream(bytes)) {
            return asn1InputStream.readObject();
        } catch (IOException e) {
            throw new CertificateParsingException("Failed to parse Encodable", e);
        }
    }

    public static ASN1Sequence getAsn1SequenceFromBytes(byte[] bytes)
            throws CertificateParsingException {
        try (ASN1InputStream asn1InputStream = new ASN1InputStream(bytes)) {
            return getAsn1SequenceFromStream(asn1InputStream);
        } catch (IOException e) {
            throw new CertificateParsingException("Failed to parse SEQUENCE", e);
        }
    }

    public static ASN1Sequence getAsn1SequenceFromStream(final ASN1InputStream asn1InputStream)
            throws IOException, CertificateParsingException {
        ASN1Primitive asn1Primitive = asn1InputStream.readObject();
        if (!(asn1Primitive instanceof ASN1OctetString)) {
            throw new CertificateParsingException(
                    "Expected octet stream, found " + asn1Primitive.getClass().getName());
        }
        try (ASN1InputStream seqInputStream = new ASN1InputStream(
                ((ASN1OctetString) asn1Primitive).getOctets())) {
            asn1Primitive = seqInputStream.readObject();
            if (!(asn1Primitive instanceof ASN1Sequence)) {
                throw new CertificateParsingException(
                        "Expected sequence, found " + asn1Primitive.getClass().getName());
            }
            return (ASN1Sequence) asn1Primitive;
        }
    }

    public static Set<Integer> getIntegersFromAsn1Set(ASN1Encodable set)
            throws CertificateParsingException {
        if (!(set instanceof ASN1Set)) {
            throw new CertificateParsingException(
                    "Expected set, found " + set.getClass().getName());
        }

        ImmutableSet.Builder<Integer> builder = ImmutableSet.builder();
        for (Enumeration<?> e = ((ASN1Set) set).getObjects(); e.hasMoreElements();) {
            builder.add(getIntegerFromAsn1((ASN1Integer) e.nextElement()));
        }
        return builder.build();
    }

    public static String getStringFromAsn1OctetStreamAssumingUTF8(ASN1Encodable encodable)
            throws CertificateParsingException, UnsupportedEncodingException {
        if (!(encodable instanceof ASN1OctetString)) {
            throw new CertificateParsingException(
                    "Expected octet string, found " + encodable.getClass().getName());
        }

        ASN1OctetString octetString = (ASN1OctetString) encodable;
        return new String(octetString.getOctets(), StandardCharsets.UTF_8);
    }

    public static Date getDateFromAsn1(ASN1Primitive value) throws CertificateParsingException {
        return new Date(getLongFromAsn1(value));
    }

    public static boolean getBooleanFromAsn1(ASN1Encodable value)
            throws CertificateParsingException {
        if (!(value instanceof ASN1Boolean)) {
            throw new CertificateParsingException(
                    "Expected boolean, found " + value.getClass().getName());
        }
        ASN1Boolean booleanValue = (ASN1Boolean) value;
        if (booleanValue.equals(ASN1Boolean.TRUE)) {
            return true;
        } else if (booleanValue.equals((ASN1Boolean.FALSE))) {
            return false;
        }

        throw new CertificateParsingException(
                "DER-encoded boolean values must contain either 0x00 or 0xFF");
    }

    private static int bigIntegerToInt(BigInteger bigInt) throws CertificateParsingException {
        if (bigInt.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0
                || bigInt.compareTo(BigInteger.ZERO) < 0) {
            throw new CertificateParsingException("INTEGER out of bounds");
        }
        return bigInt.intValue();
    }

    private static long bigIntegerToLong(BigInteger bigInt) throws CertificateParsingException {
        if (bigInt.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0
                || bigInt.compareTo(BigInteger.ZERO) < 0) {
            throw new CertificateParsingException("INTEGER out of bounds");
        }
        return bigInt.longValue();
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/Attestation.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import com.google.common.base.CharMatcher;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.BaseEncoding;

import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.util.Set;

import co.nstant.in.cbor.CborException;

/**
 * Parses an attestation certificate and provides an easy-to-use interface for examining the
 * contents.
 */
public abstract class Attestation {
    static final String EAT_OID = "1.3.6.1.4.1.11129.2.1.25";
    static final String ASN1_OID = "1.3.6.1.4.1.11129.2.1.17";
    static final String KEY_USAGE_OID = "2.5.29.15"; // Standard key usage extension.
    static final String CRL_DP_OID = "2.5.29.31"; // Standard CRL Distribution Points extension.

    public static final int KM_SECURITY_LEVEL_SOFTWARE = 0;
    public static final int KM_SECURITY_LEVEL_TRUSTED_ENVIRONMENT = 1;
    public static final int KM_SECURITY_LEVEL_STRONG_BOX = 2;

    int attestationVersion;
    int keymasterVersion;
    int keymasterSecurityLevel;
    byte[] attestationChallenge;
    byte[] uniqueId;
    AuthorizationList softwareEnforced;
    AuthorizationList teeEnforced;
    Set<String> unexpectedExtensionOids;

    /**
     * Constructs an {@code Attestation} object from the provided {@link X509Certificate},
     * extracting the attestation data from the attestation extension.
     *
     * <p>This method ensures that at most one attestation extension is included in the certificate.
     *
     * @throws CertificateParsingException if the certificate does not contain a properly-formatted
     *                                     attestation extension, if it contains multiple attestation extensions, or if the
     *                                     attestation extension can not be parsed.
     */

    public static Attestation loadFromCertificate(X509Certificate x509Cert) throws CertificateParsingException {
        if (x509Cert.getExtensionValue(EAT_OID) == null
                && x509Cert.getExtensionValue(ASN1_OID) == null) {
            throw new CertificateParsingException("No attestation extensions found");
        }
        if (x509Cert.getExtensionValue(EAT_OID) != null) {
            if (x509Cert.getExtensionValue(ASN1_OID) != null) {
                throw new CertificateParsingException("Multiple attestation extensions found");
            }
            try {
                return new EatAttestation(x509Cert);
            } catch (CborException cbe) {
                throw new CertificateParsingException("Unable to parse EAT extension", cbe);
            }
        }
        if (x509Cert.getExtensionValue(CRL_DP_OID) != null) {
            throw new CertificateParsingException(
                    "CRL Distribution Points extension found in leaf certificate.");
        }
        return new Asn1Attestation(x509Cert);
    }

    Attestation(X509Certificate x509Cert) {
        unexpectedExtensionOids = retrieveUnexpectedExtensionOids(x509Cert);
    }

    public static String securityLevelToString(int attestationSecurityLevel) {
        switch (attestationSecurityLevel) {
            case KM_SECURITY_LEVEL_SOFTWARE:
                return "Software";
            case KM_SECURITY_LEVEL_TRUSTED_ENVIRONMENT:
                return "TEE";
            case KM_SECURITY_LEVEL_STRONG_BOX:
                return "StrongBox";
            default:
                return "Unkown (" + attestationSecurityLevel + ")";
        }
    }

    public static String attestationVersionToString(int version) {
        switch (version) {
            case 1:
                return "Keymaster version 2.0";
            case 2:
                return "Keymaster version 3.0";
            case 3:
                return "Keymaster version 4.0";
            case 4:
                return "Keymaster version 4.1";
            case 100:
                return "KeyMint version 1.0";
            case 200:
                return "KeyMint version 2.0";
            case 300:
                return "KeyMint version 3.0";
            default:
                return "Unkown (" + version + ")";
        }
    }

    public static String keymasterVersionToString(int version) {
        switch (version) {
            case 0:
                return "Keymaster version 0.2 or 0.3";
            case 1:
                return "Keymaster version 1.0";
            case 2:
                return "Keymaster version 2.0";
            case 3:
                return "Keymaster version 3.0";
            case 4:
                return "Keymaster version 4.0";
            case 41:
                return "Keymaster version 4.1";
            case 100:
                return "KeyMint version 1.0";
            case 200:
                return "KeyMint version 2.0";
            case 300:
                return "KeyMint version 3.0";
            default:
                return "Unkown (" + version + ")";
        }
    }

    public int getAttestationVersion() {
        return attestationVersion;
    }

    public abstract int getAttestationSecurityLevel();

    public abstract RootOfTrust getRootOfTrust();

    // Returns one of the KM_VERSION_* values define above.
    public int getKeymasterVersion() {
        return keymasterVersion;
    }

    public int getKeymasterSecurityLevel() {
        return keymasterSecurityLevel;
    }

    public byte[] getAttestationChallenge() {
        return attestationChallenge;
    }

    public byte[] getUniqueId() {
        return uniqueId;
    }

    public AuthorizationList getSoftwareEnforced() {
        return softwareEnforced;
    }

    public AuthorizationList getTeeEnforced() {
        return teeEnforced;
    }

    public Set<String> getUnexpectedExtensionOids() {
        return unexpectedExtensionOids;
    }

    @Override
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append("Extension type: " + getClass());
        s.append("\nAttest version: " + attestationVersionToString(attestationVersion));
        s.append("\nAttest security: " + securityLevelToString(getAttestationSecurityLevel()));
        s.append("\nKM version: " + keymasterVersionToString(keymasterVersion));
        s.append("\nKM security: " + securityLevelToString(keymasterSecurityLevel));

        s.append("\nChallenge");
        String stringChallenge =
                attestationChallenge != null ? new String(attestationChallenge) : "null";
        if (CharMatcher.ascii().matchesAllOf(stringChallenge)) {
            s.append(": [" + stringChallenge + "]");
        } else {
            s.append(" (base64): [" + BaseEncoding.base64().encode(attestationChallenge) + "]");
        }
        if (uniqueId != null) {
            s.append("\nUnique ID (base64): [" + BaseEncoding.base64().encode(uniqueId) + "]");
        }

        s.append("\n-- SW enforced --");
        s.append(softwareEnforced);
        s.append("\n-- TEE enforced --");
        s.append(teeEnforced);

        return s.toString();
    }

    Set<String> retrieveUnexpectedExtensionOids(X509Certificate x509Cert) {
        return new ImmutableSet.Builder<String>()
                .addAll(x509Cert.getCriticalExtensionOIDs()
                        .stream()
                        .filter(s -> !KEY_USAGE_OID.equals(s))
                        .iterator())
                .addAll(x509Cert.getNonCriticalExtensionOIDs()
                        .stream()
                        .filter(s -> !ASN1_OID.equals(s) && !EAT_OID.equals(s))
                        .iterator())
                .build();
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/AttestationApplicationId.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.Signature;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1Set;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateParsingException;
import java.util.ArrayList;
import java.util.List;

public class AttestationApplicationId implements java.lang.Comparable<AttestationApplicationId> {
    private static final int PACKAGE_INFOS_INDEX = 0;
    private static final int SIGNATURE_DIGESTS_INDEX = 1;

    private final List<AttestationPackageInfo> packageInfos;
    private final List<byte[]> signatureDigests;

    public AttestationApplicationId(Context context)
            throws NoSuchAlgorithmException, NameNotFoundException {
        PackageManager pm = context.getPackageManager();
        int uid = context.getApplicationInfo().uid;
        String[] packageNames = pm.getPackagesForUid(uid);
        if (packageNames == null || packageNames.length == 0) {
            throw new NameNotFoundException("No names found for uid");
        }
        packageInfos = new ArrayList<AttestationPackageInfo>();
        for (String packageName : packageNames) {
            // get the package info for the given package name including
            // the signatures
            PackageInfo packageInfo = pm.getPackageInfo(packageName, 0);
            packageInfos.add(new AttestationPackageInfo(packageName, packageInfo.versionCode));
        }
        // The infos must be sorted, the implementation of Comparable relies on it.
        packageInfos.sort(null);

        // compute the sha256 digests of the signature blobs
        signatureDigests = new ArrayList<byte[]>();
        PackageInfo packageInfo = pm.getPackageInfo(packageNames[0], PackageManager.GET_SIGNATURES);
        for (Signature signature : packageInfo.signatures) {
            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
            signatureDigests.add(sha256.digest(signature.toByteArray()));
        }
        // The digests must be sorted. the implementation of Comparable relies on it
        signatureDigests.sort(new ByteArrayComparator());
    }

    public AttestationApplicationId(ASN1Encodable asn1Encodable)
            throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Sequence)) {
            throw new CertificateParsingException(
                    "Expected sequence for AttestationApplicationId, found "
                            + asn1Encodable.getClass().getName());
        }

        ASN1Sequence sequence = (ASN1Sequence) asn1Encodable;
        packageInfos = parseAttestationPackageInfos(sequence.getObjectAt(PACKAGE_INFOS_INDEX));
        // The infos must be sorted, the implementation of Comparable relies on it.
        packageInfos.sort(null);
        signatureDigests = parseSignatures(sequence.getObjectAt(SIGNATURE_DIGESTS_INDEX));
        // The digests must be sorted. the implementation of Comparable relies on it
        signatureDigests.sort(new ByteArrayComparator());
    }

    public List<AttestationPackageInfo> getAttestationPackageInfos() {
        return packageInfos;
    }

    public List<byte[]> getSignatureDigests() {
        return signatureDigests;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        int noOfInfos = packageInfos.size();
        int i = 1;
        for (AttestationPackageInfo info : packageInfos) {
            sb.append("Package info " + i++ + "/" + noOfInfos + ":\n");
            sb.append(info);
        }
        sb.append('\n');
        i = 1;
        int noOfSigs = signatureDigests.size();
        for (byte[] sig : signatureDigests) {
            sb.append("Signature digest " + i++ + "/" + noOfSigs + ":\n");
            for (byte b : sig) {
                sb.append(String.format("%02X ", b));
            }
            sb.append('\n');
        }
        return sb.toString();
    }

    @Override
    public int compareTo(AttestationApplicationId other) {
        int res = Integer.compare(packageInfos.size(), other.packageInfos.size());
        if (res != 0) return res;
        for (int i = 0; i < packageInfos.size(); ++i) {
            res = packageInfos.get(i).compareTo(other.packageInfos.get(i));
            if (res != 0) return res;
        }
        res = Integer.compare(signatureDigests.size(), other.signatureDigests.size());
        if (res != 0) return res;
        ByteArrayComparator cmp = new ByteArrayComparator();
        for (int i = 0; i < signatureDigests.size(); ++i) {
            res = cmp.compare(signatureDigests.get(i), other.signatureDigests.get(i));
            if (res != 0) return res;
        }
        return res;
    }

    @Override
    public boolean equals(Object o) {
        return (o instanceof AttestationApplicationId)
                && (0 == compareTo((AttestationApplicationId) o));
    }

    private List<AttestationPackageInfo> parseAttestationPackageInfos(ASN1Encodable asn1Encodable)
            throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Set)) {
            throw new CertificateParsingException(
                    "Expected set for AttestationApplicationsInfos, found "
                            + asn1Encodable.getClass().getName());
        }

        ASN1Set set = (ASN1Set) asn1Encodable;
        List<AttestationPackageInfo> result = new ArrayList<AttestationPackageInfo>();
        for (ASN1Encodable e : set) {
            result.add(new AttestationPackageInfo(e));
        }
        return result;
    }

    private List<byte[]> parseSignatures(ASN1Encodable asn1Encodable)
            throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Set)) {
            throw new CertificateParsingException("Expected set for Signature digests, found "
                    + asn1Encodable.getClass().getName());
        }

        ASN1Set set = (ASN1Set) asn1Encodable;
        List<byte[]> result = new ArrayList<byte[]>();

        for (ASN1Encodable e : set) {
            result.add(Asn1Utils.getByteArrayFromAsn1(e));
        }
        return result;
    }

    private static class ByteArrayComparator implements java.util.Comparator<byte[]> {
        @Override
        public int compare(byte[] a, byte[] b) {
            int res = Integer.compare(a.length, b.length);
            if (res != 0) return res;
            for (int i = 0; i < a.length; ++i) {
                res = Byte.compare(a[i], b[i]);
                if (res != 0) return res;
            }
            return res;
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/AttestationPackageInfo.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Sequence;

import java.io.UnsupportedEncodingException;
import java.security.cert.CertificateParsingException;

public class AttestationPackageInfo implements java.lang.Comparable<AttestationPackageInfo> {
    private static final int PACKAGE_NAME_INDEX = 0;
    private static final int VERSION_INDEX = 1;

    private final String packageName;
    private final long version;

    public AttestationPackageInfo(String packageName, long version) {
        this.packageName = packageName;
        this.version = version;
    }

    public AttestationPackageInfo(ASN1Encodable asn1Encodable) throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Sequence)) {
            throw new CertificateParsingException(
                    "Expected sequence for AttestationPackageInfo, found "
                            + asn1Encodable.getClass().getName());
        }

        ASN1Sequence sequence = (ASN1Sequence) asn1Encodable;
        try {
            packageName = Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(
                    sequence.getObjectAt(PACKAGE_NAME_INDEX));
        } catch (UnsupportedEncodingException e) {
            throw new CertificateParsingException(
                    "Converting octet stream to String triggered an UnsupportedEncodingException",
                    e);
        }
        version = Asn1Utils.getLongFromAsn1(sequence.getObjectAt(VERSION_INDEX));
    }

    public String getPackageName() {
        return packageName;
    }

    public long getVersion() {
        return version;
    }

    @Override
    public String toString() {
        return getPackageName() + " (version code " + getVersion() + ")\n";
    }

    @Override
    public int compareTo(AttestationPackageInfo other) {
        int res = packageName.compareTo(other.packageName);
        if (res != 0) return res;
        res = Long.compare(version, other.version);
        if (res != 0) return res;
        return res;
    }

    @Override
    public boolean equals(Object o) {
        return (o instanceof AttestationPackageInfo)
                && (0 == compareTo((AttestationPackageInfo) o));
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/AttestationResult.kt`:

```kt
package io.github.vvb2060.keyattestation.attestation

data class AttestationResult(val attestation: Attestation, val isGoogleRootCertificate: Int)

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/AuthorizationList.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import static com.google.common.base.Functions.forMap;
import static com.google.common.collect.Collections2.transform;

import android.security.keystore.KeyProperties;
import android.util.Log;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1SequenceParser;
import org.bouncycastle.asn1.ASN1TaggedObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.cert.CertificateParsingException;
import java.text.DateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Set;

import co.nstant.in.cbor.model.DataItem;
import co.nstant.in.cbor.model.Number;
import io.github.vvb2060.keyattestation.AppApplication;

public class AuthorizationList {
    // https://cs.android.com/android/platform/superproject/+/master:hardware/libhardware/include/hardware/keymaster_defs.h
    // https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/security/keymaster/KeymasterDefs.java

    // Algorithm values.
    public static final int KM_ALGORITHM_RSA = 1;
    public static final int KM_ALGORITHM_EC = 3;
    public static final int KM_ALGORITHM_AES = 32;
    public static final int KM_ALGORITHM_3DES = 33;
    public static final int KM_ALGORITHM_HMAC = 128;

    // EC Curves
    public static final int KM_EC_CURVE_P224 = 0;
    public static final int KM_EC_CURVE_P256 = 1;
    public static final int KM_EC_CURVE_P384 = 2;
    public static final int KM_EC_CURVE_P521 = 3;
    public static final int KM_EC_CURVE_CURVE_25519 = 4;

    // Padding modes.
    public static final int KM_PAD_NONE = 1;
    public static final int KM_PAD_RSA_OAEP = 2;
    public static final int KM_PAD_RSA_PSS = 3;
    public static final int KM_PAD_RSA_PKCS1_1_5_ENCRYPT = 4;
    public static final int KM_PAD_RSA_PKCS1_1_5_SIGN = 5;
    public static final int KM_PAD_PKCS7 = 64;

    // Digest modes.
    public static final int KM_DIGEST_NONE = 0;
    public static final int KM_DIGEST_MD5 = 1;
    public static final int KM_DIGEST_SHA1 = 2;
    public static final int KM_DIGEST_SHA_2_224 = 3;
    public static final int KM_DIGEST_SHA_2_256 = 4;
    public static final int KM_DIGEST_SHA_2_384 = 5;
    public static final int KM_DIGEST_SHA_2_512 = 6;

    // Key origins.
    public static final int KM_ORIGIN_GENERATED = 0;
    public static final int KM_ORIGIN_DERIVED = 1;
    public static final int KM_ORIGIN_IMPORTED = 2;
    public static final int KM_ORIGIN_UNKNOWN = 3;
    public static final int KM_ORIGIN_SECURELY_IMPORTED = 4;

    // Operation Purposes.
    public static final int KM_PURPOSE_ENCRYPT = 0;
    public static final int KM_PURPOSE_DECRYPT = 1;
    public static final int KM_PURPOSE_SIGN = 2;
    public static final int KM_PURPOSE_VERIFY = 3;
    public static final int KM_PURPOSE_WRAP = 5;

    // User authenticators.
    public static final int HW_AUTH_PASSWORD = 1 << 0;
    public static final int HW_AUTH_BIOMETRIC = 1 << 1;

    // Keymaster tag classes
    public static final int KM_ENUM = 1 << 28;
    public static final int KM_ENUM_REP = 2 << 28;
    public static final int KM_UINT = 3 << 28;
    public static final int KM_UINT_REP = 4 << 28;
    public static final int KM_ULONG = 5 << 28;
    public static final int KM_DATE = 6 << 28;
    public static final int KM_BOOL = 7 << 28;
    public static final int KM_BYTES = 9 << 28;
    public static final int KM_ULONG_REP = 10 << 28;

    // Tag class removal mask
    public static final int KEYMASTER_TAG_TYPE_MASK = 0x0FFFFFFF;

    // Keymaster tags
    public static final int KM_TAG_PURPOSE = KM_ENUM_REP | 1;
    public static final int KM_TAG_ALGORITHM = KM_ENUM | 2;
    public static final int KM_TAG_KEY_SIZE = KM_UINT | 3;
    public static final int KM_TAG_BLOCK_MODE = KM_ENUM_REP | 4;
    public static final int KM_TAG_DIGEST = KM_ENUM_REP | 5;
    public static final int KM_TAG_PADDING = KM_ENUM_REP | 6;
    public static final int KM_TAG_CALLER_NONCE = KM_BOOL | 7;
    public static final int KM_TAG_MIN_MAC_LENGTH = KM_UINT | 8;
    public static final int KM_TAG_KDF = KM_ENUM_REP | 9;
    public static final int KM_TAG_EC_CURVE = KM_ENUM | 10;
    public static final int KM_TAG_RSA_PUBLIC_EXPONENT = KM_ULONG | 200;
    public static final int KM_TAG_RSA_OAEP_MGF_DIGEST = KM_ENUM_REP | 203;
    public static final int KM_TAG_ROLLBACK_RESISTANCE = KM_BOOL | 303;
    public static final int KM_TAG_EARLY_BOOT_ONLY = KM_BOOL | 305;
    public static final int KM_TAG_ACTIVE_DATETIME = KM_DATE | 400;
    public static final int KM_TAG_ORIGINATION_EXPIRE_DATETIME = KM_DATE | 401;
    public static final int KM_TAG_USAGE_EXPIRE_DATETIME = KM_DATE | 402;
    public static final int KM_TAG_USAGE_COUNT_LIMIT = KM_UINT | 405;
    public static final int KM_TAG_NO_AUTH_REQUIRED = KM_BOOL | 503;
    public static final int KM_TAG_USER_AUTH_TYPE = KM_ENUM | 504;
    public static final int KM_TAG_AUTH_TIMEOUT = KM_UINT | 505;
    public static final int KM_TAG_ALLOW_WHILE_ON_BODY = KM_BOOL | 506;
    public static final int KM_TAG_TRUSTED_USER_PRESENCE_REQUIRED = KM_BOOL | 507;
    public static final int KM_TAG_TRUSTED_CONFIRMATION_REQUIRED = KM_BOOL | 508;
    public static final int KM_TAG_UNLOCKED_DEVICE_REQUIRED = KM_BOOL | 509;
    public static final int KM_TAG_ALL_APPLICATIONS = KM_BOOL | 600;
    public static final int KM_TAG_APPLICATION_ID = KM_BYTES | 601;
    public static final int KM_TAG_CREATION_DATETIME = KM_DATE | 701;
    public static final int KM_TAG_ORIGIN = KM_ENUM | 702;
    public static final int KM_TAG_ROLLBACK_RESISTANT = KM_BOOL | 703;
    public static final int KM_TAG_ROOT_OF_TRUST = KM_BYTES | 704;
    public static final int KM_TAG_OS_VERSION = KM_UINT | 705;
    public static final int KM_TAG_OS_PATCHLEVEL = KM_UINT | 706;
    public static final int KM_TAG_ATTESTATION_APPLICATION_ID = KM_BYTES | 709;
    public static final int KM_TAG_ATTESTATION_ID_BRAND = KM_BYTES | 710;
    public static final int KM_TAG_ATTESTATION_ID_DEVICE = KM_BYTES | 711;
    public static final int KM_TAG_ATTESTATION_ID_PRODUCT = KM_BYTES | 712;
    public static final int KM_TAG_ATTESTATION_ID_SERIAL = KM_BYTES | 713;
    public static final int KM_TAG_ATTESTATION_ID_IMEI = KM_BYTES | 714;
    public static final int KM_TAG_ATTESTATION_ID_MEID = KM_BYTES | 715;
    public static final int KM_TAG_ATTESTATION_ID_MANUFACTURER = KM_BYTES | 716;
    public static final int KM_TAG_ATTESTATION_ID_MODEL = KM_BYTES | 717;
    public static final int KM_TAG_VENDOR_PATCHLEVEL = KM_UINT | 718;
    public static final int KM_TAG_BOOT_PATCHLEVEL = KM_UINT | 719;
    public static final int KM_TAG_DEVICE_UNIQUE_ATTESTATION = KM_BOOL | 720;
    public static final int KM_TAG_IDENTITY_CREDENTIAL_KEY = KM_BOOL | 721;
    public static final int KM_TAG_ATTESTATION_ID_SECOND_IMEI = KM_BYTES | 723;

    // Map for converting padding values to strings
    private static final ImmutableMap<Integer, String> paddingMap = ImmutableMap
            .<Integer, String>builder()
            .put(KM_PAD_NONE, "NONE")
            .put(KM_PAD_RSA_OAEP, "OAEP")
            .put(KM_PAD_RSA_PSS, "PSS")
            .put(KM_PAD_RSA_PKCS1_1_5_ENCRYPT, "PKCS1 ENCRYPT")
            .put(KM_PAD_RSA_PKCS1_1_5_SIGN, "PKCS1 SIGN")
            .put(KM_PAD_PKCS7, "PKCS7")
            .build();

    // Map for converting digest values to strings
    private static final ImmutableMap<Integer, String> digestMap = ImmutableMap
            .<Integer, String>builder()
            .put(KM_DIGEST_NONE, "NONE")
            .put(KM_DIGEST_MD5, "MD5")
            .put(KM_DIGEST_SHA1, "SHA1")
            .put(KM_DIGEST_SHA_2_224, "SHA224")
            .put(KM_DIGEST_SHA_2_256, "SHA256")
            .put(KM_DIGEST_SHA_2_384, "SHA384")
            .put(KM_DIGEST_SHA_2_512, "SHA512")
            .build();

    // Map for converting purpose values to strings
    private static final ImmutableMap<Integer, String> purposeMap = ImmutableMap
            .<Integer, String>builder()
            .put(KM_PURPOSE_DECRYPT, "DECRYPT")
            .put(KM_PURPOSE_ENCRYPT, "ENCRYPT")
            .put(KM_PURPOSE_SIGN, "SIGN")
            .put(KM_PURPOSE_VERIFY, "VERIFY")
            .put(KM_PURPOSE_WRAP, "WRAP")
            .build();

    private Integer securityLevel;
    private Set<Integer> purposes;
    private Integer algorithm;
    private Integer keySize;
    private Set<Integer> digests;
    private Set<Integer> paddingModes;
    private Integer ecCurve;
    private Long rsaPublicExponent;
    private Set<Integer> mgfDigest;
    private Boolean earlyBootOnly;
    private Date activeDateTime;
    private Date originationExpireDateTime;
    private Date usageExpireDateTime;
    private Integer usageCountLimit;
    private Boolean noAuthRequired;
    private Integer userAuthType;
    private Integer authTimeout;
    private Boolean allowWhileOnBody;
    private Boolean allApplications;
    private String applicationId;
    private Date creationDateTime;
    private Integer origin;
    private Boolean rollbackResistant;
    private Boolean rollbackResistance;
    private RootOfTrust rootOfTrust;
    private Integer osVersion;
    private Integer osPatchLevel;
    private Integer vendorPatchLevel;
    private Integer bootPatchLevel;
    private AttestationApplicationId attestationApplicationId;
    private String brand;
    private String device;
    private String serialNumber;
    private String imei;
    private String secondImei;
    private String meid;
    private String product;
    private String manufacturer;
    private String model;
    private Boolean userPresenceRequired;
    private Boolean confirmationRequired;
    private Boolean unlockedDeviceRequired;
    private Boolean deviceUniqueAttestation;
    private Boolean identityCredentialKey;

    public AuthorizationList(ASN1Encodable sequence) throws CertificateParsingException {
        if (!(sequence instanceof ASN1Sequence)) {
            throw new CertificateParsingException("Expected sequence for authorization list, found "
                    + sequence.getClass().getName());
        }

        ASN1SequenceParser parser = ((ASN1Sequence) sequence).parser();
        ASN1TaggedObject entry = parseAsn1TaggedObject(parser);
        for (; entry != null; entry = parseAsn1TaggedObject(parser)) {
            int tag = entry.getTagNo();
            ASN1Primitive value = entry.getObject();
            Log.d(AppApplication.TAG, "Parsing tag: [" + tag + "], value: [" + value + "]");
            switch (tag) {
                default:
                    throw new CertificateParsingException("Unknown tag " + tag + " found");

                case KM_TAG_PURPOSE & KEYMASTER_TAG_TYPE_MASK:
                    purposes = Asn1Utils.getIntegersFromAsn1Set(value);
                    break;
                case KM_TAG_ALGORITHM & KEYMASTER_TAG_TYPE_MASK:
                    algorithm = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_KEY_SIZE & KEYMASTER_TAG_TYPE_MASK:
                    keySize = Asn1Utils.getIntegerFromAsn1(value);
                    Log.i(AppApplication.TAG, "Found KEY SIZE, value: " + keySize);
                    break;
                case KM_TAG_DIGEST & KEYMASTER_TAG_TYPE_MASK:
                    digests = Asn1Utils.getIntegersFromAsn1Set(value);
                    break;
                case KM_TAG_PADDING & KEYMASTER_TAG_TYPE_MASK:
                    paddingModes = Asn1Utils.getIntegersFromAsn1Set(value);
                    break;
                case KM_TAG_RSA_PUBLIC_EXPONENT & KEYMASTER_TAG_TYPE_MASK:
                    rsaPublicExponent = Asn1Utils.getLongFromAsn1(value);
                    break;
                case KM_TAG_RSA_OAEP_MGF_DIGEST & KEYMASTER_TAG_TYPE_MASK:
                    mgfDigest = Asn1Utils.getIntegersFromAsn1Set(value);
                    break;
                case KM_TAG_EARLY_BOOT_ONLY & KEYMASTER_TAG_TYPE_MASK:
                    earlyBootOnly = true;
                    break;
                case KM_TAG_NO_AUTH_REQUIRED & KEYMASTER_TAG_TYPE_MASK:
                    noAuthRequired = true;
                    break;
                case KM_TAG_CREATION_DATETIME & KEYMASTER_TAG_TYPE_MASK:
                    creationDateTime = Asn1Utils.getDateFromAsn1(value);
                    break;
                case KM_TAG_ORIGIN & KEYMASTER_TAG_TYPE_MASK:
                    origin = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_OS_VERSION & KEYMASTER_TAG_TYPE_MASK:
                    osVersion = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_OS_PATCHLEVEL & KEYMASTER_TAG_TYPE_MASK:
                    osPatchLevel = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_VENDOR_PATCHLEVEL & KEYMASTER_TAG_TYPE_MASK:
                    vendorPatchLevel = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_BOOT_PATCHLEVEL & KEYMASTER_TAG_TYPE_MASK:
                    bootPatchLevel = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_ACTIVE_DATETIME & KEYMASTER_TAG_TYPE_MASK:
                    activeDateTime = Asn1Utils.getDateFromAsn1(value);
                    break;
                case KM_TAG_ORIGINATION_EXPIRE_DATETIME & KEYMASTER_TAG_TYPE_MASK:
                    originationExpireDateTime = Asn1Utils.getDateFromAsn1(value);
                    break;
                case KM_TAG_USAGE_EXPIRE_DATETIME & KEYMASTER_TAG_TYPE_MASK:
                    usageExpireDateTime = Asn1Utils.getDateFromAsn1(value);
                    break;
                case KM_TAG_USAGE_COUNT_LIMIT & KEYMASTER_TAG_TYPE_MASK:
                    usageCountLimit = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_ROLLBACK_RESISTANT & KEYMASTER_TAG_TYPE_MASK:
                    rollbackResistant = true;
                    break;
                case KM_TAG_ROLLBACK_RESISTANCE & KEYMASTER_TAG_TYPE_MASK:
                    rollbackResistance = true;
                    break;
                case KM_TAG_AUTH_TIMEOUT & KEYMASTER_TAG_TYPE_MASK:
                    authTimeout = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_ALLOW_WHILE_ON_BODY & KEYMASTER_TAG_TYPE_MASK:
                    allowWhileOnBody = true;
                    break;
                case KM_TAG_EC_CURVE & KEYMASTER_TAG_TYPE_MASK:
                    ecCurve = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_USER_AUTH_TYPE & KEYMASTER_TAG_TYPE_MASK:
                    userAuthType = Asn1Utils.getIntegerFromAsn1(value);
                    break;
                case KM_TAG_ROOT_OF_TRUST & KEYMASTER_TAG_TYPE_MASK:
                    rootOfTrust = new RootOfTrust(value);
                    break;
                case KM_TAG_ATTESTATION_APPLICATION_ID & KEYMASTER_TAG_TYPE_MASK:
                    attestationApplicationId = new AttestationApplicationId(Asn1Utils
                            .getAsn1EncodableFromBytes(Asn1Utils.getByteArrayFromAsn1(value)));
                    break;
                case KM_TAG_ATTESTATION_ID_BRAND & KEYMASTER_TAG_TYPE_MASK:
                    brand = getStringFromAsn1Value(value);
                    break;
                case KM_TAG_ATTESTATION_ID_DEVICE & KEYMASTER_TAG_TYPE_MASK:
                    device = getStringFromAsn1Value(value);
                    break;
                case KM_TAG_ATTESTATION_ID_PRODUCT & KEYMASTER_TAG_TYPE_MASK:
                    product = getStringFromAsn1Value(value);
                    break;
                case KM_TAG_ATTESTATION_ID_SERIAL & KEYMASTER_TAG_TYPE_MASK:
                    serialNumber = getStringFromAsn1Value(value);
                    break;
                case KM_TAG_ATTESTATION_ID_IMEI & KEYMASTER_TAG_TYPE_MASK:
                    imei = getStringFromAsn1Value(value);
                    break;
                case KM_TAG_ATTESTATION_ID_MEID & KEYMASTER_TAG_TYPE_MASK:
                    meid = getStringFromAsn1Value(value);
                    break;
                case KM_TAG_ATTESTATION_ID_MANUFACTURER & KEYMASTER_TAG_TYPE_MASK:
                    manufacturer = getStringFromAsn1Value(value);
                    break;
                case KM_TAG_ATTESTATION_ID_MODEL & KEYMASTER_TAG_TYPE_MASK:
                    model = getStringFromAsn1Value(value);
                    break;
                case KM_TAG_ALL_APPLICATIONS & KEYMASTER_TAG_TYPE_MASK:
                    allApplications = true;
                    break;
                case KM_TAG_APPLICATION_ID & KEYMASTER_TAG_TYPE_MASK:
                    applicationId = new String(Asn1Utils.getByteArrayFromAsn1(value));
                    break;
                case KM_TAG_TRUSTED_USER_PRESENCE_REQUIRED & KEYMASTER_TAG_TYPE_MASK:
                    userPresenceRequired = true;
                    break;
                case KM_TAG_TRUSTED_CONFIRMATION_REQUIRED & KEYMASTER_TAG_TYPE_MASK:
                    confirmationRequired = true;
                    break;
                case KM_TAG_UNLOCKED_DEVICE_REQUIRED & KEYMASTER_TAG_TYPE_MASK:
                    unlockedDeviceRequired = true;
                    break;
                case KM_TAG_DEVICE_UNIQUE_ATTESTATION & KEYMASTER_TAG_TYPE_MASK:
                    deviceUniqueAttestation = true;
                    break;
                case KM_TAG_IDENTITY_CREDENTIAL_KEY & KEYMASTER_TAG_TYPE_MASK:
                    identityCredentialKey = true;
                    break;
                case KM_TAG_ATTESTATION_ID_SECOND_IMEI & KEYMASTER_TAG_TYPE_MASK:
                    secondImei = getStringFromAsn1Value(value);
                    break;
            }
        }

    }

    public AuthorizationList(co.nstant.in.cbor.model.Map submodMap)
            throws CertificateParsingException {
        for (DataItem key : submodMap.getKeys()) {
            int keyInt = ((Number) key).getValue().intValue();
            switch (keyInt) {
                default:
                    throw new CertificateParsingException("Unknown EAT tag: " + key);

                case EatClaim.SECURITY_LEVEL:
                    securityLevel = EatAttestation.eatSecurityLevelToKeymintSecurityLevel(
                            CborUtils.getInt(submodMap, key));
                    break;
                case EatClaim.PURPOSE:
                    purposes = CborUtils.getIntSet(submodMap, key);
                    break;
                case EatClaim.ALGORITHM:
                    algorithm = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.KEY_SIZE:
                    keySize = CborUtils.getInt(submodMap, key);
                    Log.i(AppApplication.TAG, "Found KEY SIZE, value: " + keySize);
                    break;
                case EatClaim.DIGEST:
                    digests = CborUtils.getIntSet(submodMap, key);
                    break;
                case EatClaim.PADDING:
                    paddingModes = CborUtils.getIntSet(submodMap, key);
                    break;
                case EatClaim.RSA_PUBLIC_EXPONENT:
                    rsaPublicExponent = CborUtils.getLong(submodMap, key);
                    break;
                case EatClaim.RSA_OAEP_MGF_DIGEST:
                    mgfDigest = CborUtils.getIntSet(submodMap, key);
                    break;
                case EatClaim.NO_AUTH_REQUIRED:
                    noAuthRequired = true;
                    break;
                case EatClaim.IAT:
                    creationDateTime = CborUtils.getDate(submodMap, key);
                    break;
                case EatClaim.ORIGIN:
                    origin = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.OS_VERSION:
                    osVersion = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.OS_PATCHLEVEL:
                    osPatchLevel = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.VENDOR_PATCHLEVEL:
                    vendorPatchLevel = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.BOOT_PATCHLEVEL:
                    bootPatchLevel = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.ACTIVE_DATETIME:
                    activeDateTime = CborUtils.getDate(submodMap, key);
                    break;
                case EatClaim.ORIGINATION_EXPIRE_DATETIME:
                    originationExpireDateTime = CborUtils.getDate(submodMap, key);
                    break;
                case EatClaim.USAGE_EXPIRE_DATETIME:
                    usageExpireDateTime = CborUtils.getDate(submodMap, key);
                    break;
                case EatClaim.ROLLBACK_RESISTANT:
                    rollbackResistant = true;
                    break;
                case EatClaim.ROLLBACK_RESISTANCE:
                    rollbackResistance = true;
                    break;
                case EatClaim.AUTH_TIMEOUT:
                    authTimeout = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.ALLOW_WHILE_ON_BODY:
                    allowWhileOnBody = true;
                    break;
                case EatClaim.EC_CURVE:
                    ecCurve = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.USER_AUTH_TYPE:
                    userAuthType = CborUtils.getInt(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_APPLICATION_ID:
                    // TODO: The attestation application ID is currently still encoded as an ASN.1
                    // structure. Parse a CBOR structure when it's available instead.
                    attestationApplicationId = new AttestationApplicationId(
                            Asn1Utils.getAsn1EncodableFromBytes(CborUtils.getBytes(submodMap, key)));
                    break;
                case EatClaim.ATTESTATION_ID_BRAND:
                    brand = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_DEVICE:
                    device = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_PRODUCT:
                    product = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_SERIAL:
                    serialNumber = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.UEID:
                    // TODO: Parse depending on encoding chosen in attestation_record.cpp.
                    imei = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_MEID:
                    meid = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_MANUFACTURER:
                    manufacturer = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.ATTESTATION_ID_MODEL:
                    model = CborUtils.getString(submodMap, key);
                    break;
                case EatClaim.USER_PRESENCE_REQUIRED:
                    userPresenceRequired = CborUtils.getBoolean(submodMap, key);
                    break;
                case EatClaim.TRUSTED_CONFIRMATION_REQUIRED:
                    confirmationRequired = true;
                    break;
                case EatClaim.UNLOCKED_DEVICE_REQUIRED:
                    unlockedDeviceRequired = true;
                    break;
                case EatClaim.APPLICATION_ID:
                    applicationId = CborUtils.getString(submodMap, key);
                case EatClaim.EARLY_BOOT_ONLY:
                    earlyBootOnly = true;
                    break;
                case EatClaim.DEVICE_UNIQUE_ATTESTATION:
                    deviceUniqueAttestation = true;
                    break;
            }
        }
    }

    public static String algorithmToString(int algorithm) {
        switch (algorithm) {
            case KM_ALGORITHM_RSA:
                return "RSA";
            case KM_ALGORITHM_EC:
                return "ECDSA";
            case KM_ALGORITHM_AES:
                return "AES";
            case KM_ALGORITHM_3DES:
                return "3DES";
            case KM_ALGORITHM_HMAC:
                return "HMAC";
            default:
                return "Unknown (" + algorithm + ")";
        }
    }

    public static String paddingModesToString(final Set<Integer> paddingModes) {
        return joinStrings(transform(paddingModes, forMap(paddingMap, "Unknown")));
    }

    public static String paddingModeToString(int paddingMode) {
        return forMap(paddingMap, "Unknown").apply(paddingMode);
    }

    public static String digestsToString(Set<Integer> digests) {
        return joinStrings(transform(digests, forMap(digestMap, "Unknown")));
    }

    public static String digestToString(int digest) {
        return forMap(digestMap, "Unknown").apply(digest);
    }

    public static String purposesToString(Set<Integer> purposes) {
        return joinStrings(transform(purposes, forMap(purposeMap, "Unknown")));
    }

    public static String userAuthTypeToString(int userAuthType) {
        List<String> types = Lists.newArrayList();
        if ((userAuthType & HW_AUTH_BIOMETRIC) != 0)
            types.add("Biometric");
        if ((userAuthType & HW_AUTH_PASSWORD) != 0)
            types.add("Password");
        return joinStrings(types);
    }

    public static String originToString(int origin) {
        switch (origin) {
            case KM_ORIGIN_GENERATED:
                return "Generated";
            case KM_ORIGIN_DERIVED:
                return "Derived";
            case KM_ORIGIN_IMPORTED:
                return "Imported";
            case KM_ORIGIN_UNKNOWN:
                return "Unknown (KM0)";
            case KM_ORIGIN_SECURELY_IMPORTED:
                return "Securely Imported";
            default:
                return "Unknown (" + origin + ")";
        }
    }

    private static String joinStrings(Collection<String> collection) {
        return "[" + Joiner.on(", ").join(collection) + "]";
    }

    public static String formatDate(Date date) {
        return DateFormat.getDateTimeInstance().format(date);
    }

    private static ASN1TaggedObject parseAsn1TaggedObject(ASN1SequenceParser parser)
            throws CertificateParsingException {
        ASN1Encodable asn1Encodable = parseAsn1Encodable(parser);
        if (asn1Encodable == null || asn1Encodable instanceof ASN1TaggedObject) {
            return (ASN1TaggedObject) asn1Encodable;
        }
        throw new CertificateParsingException(
                "Expected tagged object, found " + asn1Encodable.getClass().getName());
    }

    private static ASN1Encodable parseAsn1Encodable(ASN1SequenceParser parser)
            throws CertificateParsingException {
        try {
            return parser.readObject();
        } catch (IOException e) {
            throw new CertificateParsingException("Failed to parse ASN1 sequence", e);
        }
    }

    public Integer getSecurityLevel() {
        return securityLevel;
    }

    public Set<Integer> getPurposes() {
        return purposes;
    }

    public Integer getAlgorithm() {
        return algorithm;
    }

    public Integer getKeySize() {
        return keySize;
    }

    public Set<Integer> getDigests() {
        return digests;
    }

    public Set<Integer> getPaddingModes() {
        return paddingModes;
    }

    public Set<String> getPaddingModesAsStrings() throws CertificateParsingException {
        if (paddingModes == null) {
            return ImmutableSet.of();
        }

        ImmutableSet.Builder<String> builder = ImmutableSet.builder();
        for (int paddingMode : paddingModes) {
            switch (paddingMode) {
                case KM_PAD_NONE:
                    builder.add(KeyProperties.ENCRYPTION_PADDING_NONE);
                    break;
                case KM_PAD_RSA_OAEP:
                    builder.add(KeyProperties.ENCRYPTION_PADDING_RSA_OAEP);
                    break;
                case KM_PAD_RSA_PKCS1_1_5_ENCRYPT:
                    builder.add(KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1);
                    break;
                case KM_PAD_RSA_PKCS1_1_5_SIGN:
                    builder.add(KeyProperties.SIGNATURE_PADDING_RSA_PKCS1);
                    break;
                case KM_PAD_PKCS7:
                    builder.add(KeyProperties.ENCRYPTION_PADDING_PKCS7);
                    break;
                case KM_PAD_RSA_PSS:
                    builder.add(KeyProperties.SIGNATURE_PADDING_RSA_PSS);
                    break;
                default:
                    throw new CertificateParsingException("Invalid padding mode " + paddingMode);
            }
        }
        return builder.build();
    }

    public Integer getEcCurve() {
        return ecCurve;
    }

    public static String ecCurveAsString(Integer ecCurve) {
        if (ecCurve == null)
            return "NULL";

        switch (ecCurve) {
            case KM_EC_CURVE_P224:
                return "secp224r1";
            case KM_EC_CURVE_P256:
                return "secp256r1";
            case KM_EC_CURVE_P384:
                return "secp384r1";
            case KM_EC_CURVE_P521:
                return "secp521r1";
            case KM_EC_CURVE_CURVE_25519:
                return "CURVE_25519";
            default:
                return "unknown (" + ecCurve + ")";
        }
    }

    public Long getRsaPublicExponent() {
        return rsaPublicExponent;
    }

    public Date getActiveDateTime() {
        return activeDateTime;
    }

    public Date getOriginationExpireDateTime() {
        return originationExpireDateTime;
    }

    public Date getUsageExpireDateTime() {
        return usageExpireDateTime;
    }

    public Boolean getNoAuthRequired() {
        return noAuthRequired;
    }

    public Integer getUserAuthType() {
        return userAuthType;
    }

    public Integer getAuthTimeout() {
        return authTimeout;
    }

    public Boolean getAllowWhileOnBody() {
        return allowWhileOnBody;
    }

    public Boolean getAllApplications() {
        return allApplications;
    }

    public String getApplicationId() {
        return applicationId;
    }

    public Date getCreationDateTime() {
        return creationDateTime;
    }

    public Integer getOrigin() {
        return origin;
    }

    public Boolean getRollbackResistant() {
        return rollbackResistant;
    }

    public Boolean getRollbackResistance() {
        return rollbackResistance;
    }

    public Boolean getUnlockedDeviceRequired() {
        return unlockedDeviceRequired;
    }

    public RootOfTrust getRootOfTrust() {
        return rootOfTrust;
    }

    public Integer getOsVersion() {
        return osVersion;
    }

    public Integer getOsPatchLevel() {
        return osPatchLevel;
    }

    public Integer getVendorPatchLevel() {
        return vendorPatchLevel;
    }

    public Integer getBootPatchLevel() {
        return bootPatchLevel;
    }

    public AttestationApplicationId getAttestationApplicationId() {
        return attestationApplicationId;
    }

    public String getBrand() {
        return brand;
    }

    public String getDevice() {
        return device;
    }

    public String getSerialNumber() {
        return serialNumber;
    }

    public String getImei() {
        return imei;
    }

    public String getSecondImei() {
        return secondImei;
    }

    public String getMeid() {
        return meid;
    }

    public String getProduct() {
        return product;
    }

    public String getManufacturer() {
        return manufacturer;
    }

    public String getModel() {
        return model;
    }

    public Boolean getUserPresenceRequired() {
        return userPresenceRequired;
    }

    public Boolean getConfirmationRequired() {
        return confirmationRequired;
    }

    public Set<Integer> getMgfDigest() {
        return mgfDigest;
    }

    public Boolean getEarlyBootOnly() {
        return earlyBootOnly;
    }

    public Integer getUsageCountLimit() {
        return usageCountLimit;
    }

    public Boolean getDeviceUniqueAttestation() {
        return deviceUniqueAttestation;
    }

    public Boolean getIdentityCredentialKey() {
        return identityCredentialKey;
    }

    private String getStringFromAsn1Value(ASN1Primitive value) throws CertificateParsingException {
        try {
            return Asn1Utils.getStringFromAsn1OctetStreamAssumingUTF8(value);
        } catch (UnsupportedEncodingException e) {
            throw new CertificateParsingException("Error parsing ASN.1 value", e);
        }
    }

    @Override
    public String toString() {
        StringBuilder s = new StringBuilder();

        if (algorithm != null) {
            s.append("\nAlgorithm: ").append(algorithmToString(algorithm));
        }

        if (keySize != null) {
            s.append("\nKeySize: ").append(keySize);
        }

        if (purposes != null && !purposes.isEmpty()) {
            s.append("\nPurposes: ").append(purposesToString(purposes));
        }

        if (digests != null && !digests.isEmpty()) {
            s.append("\nDigests: ").append(digestsToString(digests));
        }

        if (paddingModes != null && !paddingModes.isEmpty()) {
            s.append("\nPadding modes: ").append(paddingModesToString(paddingModes));
        }

        if (ecCurve != null) {
            s.append("\nEC Curve: ").append(ecCurveAsString(ecCurve));
        }

        if (rsaPublicExponent != null) {
            s.append("\nRSA exponent: ").append(rsaPublicExponent);
        }

        if (mgfDigest != null && !mgfDigest.isEmpty()) {
            s.append("\nRsa Oaep Mgf Digest: ").append(digestsToString(mgfDigest));
        }

        if (earlyBootOnly != null) {
            s.append("\nEarly boot only");
        }

        if (activeDateTime != null) {
            s.append("\nActive: ").append(formatDate(activeDateTime));
        }

        if (originationExpireDateTime != null) {
            s.append("\nOrigination expire: ").append(formatDate(originationExpireDateTime));
        }

        if (usageExpireDateTime != null) {
            s.append("\nUsage expire: ").append(formatDate(usageExpireDateTime));
        }

        if (usageCountLimit != null) {
            s.append("\nUsage count limit: ").append(usageCountLimit);
        }

        if (noAuthRequired != null) {
            s.append("\nNo Auth Required");
        }

        if (userAuthType != null) {
            s.append("\nAuth types: ").append(userAuthTypeToString(userAuthType));
        }

        if (authTimeout != null) {
            s.append("\nAuth timeout: ").append(authTimeout);
        }

        if (allowWhileOnBody != null) {
            s.append("\nAllow While On Body");
        }

        if (allApplications != null) {
            s.append("\nAll Applications");
        }

        if (applicationId != null) {
            s.append("\nApplication ID: ").append(applicationId);
        }

        if (creationDateTime != null) {
            s.append("\nCreated: ").append(formatDate(creationDateTime));
        }

        if (origin != null) {
            s.append("\nOrigin: ").append(originToString(origin));
        }

        if (rollbackResistant != null) {
            s.append("\nRollback resistant");
        }

        if (rollbackResistance != null) {
            s.append("\nRollback resistance");
        }

        if (rootOfTrust != null) {
            s.append("\nRoot of Trust:\n");
            s.append(rootOfTrust);
        }

        if (osVersion != null) {
            s.append("\nOS Version: ").append(osVersion);
        }

        if (osPatchLevel != null) {
            s.append("\nOS Patchlevel: ").append(osPatchLevel);
        }

        if (vendorPatchLevel != null) {
            s.append("\nVendor Patchlevel: ").append(vendorPatchLevel);
        }

        if (bootPatchLevel != null) {
            s.append("\nBoot Patchlevel: ").append(bootPatchLevel);
        }

        if (attestationApplicationId != null) {
            s.append("\nAttestation Application Id:\n").append(attestationApplicationId);
        }

        if (userPresenceRequired != null) {
            s.append("\nUser presence required");
        }

        if (confirmationRequired != null) {
            s.append("\nConfirmation required");
        }

        if (unlockedDeviceRequired != null) {
            s.append("\nUnlocked Device Required");
        }

        if (deviceUniqueAttestation != null) {
            s.append("\nDevice unique attestation");
        }

        if (identityCredentialKey != null) {
            s.append("\nIdentity Credential Key");
        }

        if (brand != null) {
            s.append("\nBrand: ").append(brand);
        }
        if (device != null) {
            s.append("\nDevice type: ").append(device);
        }
        if (product != null) {
            s.append("\nProduct: ").append(product);
        }
        if (serialNumber != null) {
            s.append("\nSerial: ").append(serialNumber);
        }
        if (imei != null) {
            s.append("\nIMEI: ").append(imei);
        }
        if (secondImei != null) {
            s.append("\nSecond IMEI:").append(secondImei);
        }
        if (meid != null) {
            s.append("\nMEID: ").append(meid);
        }
        if (manufacturer != null) {
            s.append("\nManufacturer: ").append(manufacturer);
        }
        if (model != null) {
            s.append("\nModel: ").append(model);
        }
        return s.toString();
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/CborUtils.java`:

```java
/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import co.nstant.in.cbor.model.Array;
import co.nstant.in.cbor.model.ByteString;
import co.nstant.in.cbor.model.DataItem;
import co.nstant.in.cbor.model.Map;
import co.nstant.in.cbor.model.NegativeInteger;
import co.nstant.in.cbor.model.Number;
import co.nstant.in.cbor.model.SimpleValue;
import co.nstant.in.cbor.model.SimpleValueType;
import co.nstant.in.cbor.model.UnsignedInteger;

import java.nio.charset.StandardCharsets;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;


class CborUtils {
    public static Number toNumber(long l) {
        return l >= 0 ? new UnsignedInteger(l) : new NegativeInteger(l);
    }

    public static int getInt(Map map, long index) {
        DataItem item = map.get(CborUtils.toNumber(index));
        return ((Number) item).getValue().intValue();
    }

    public static int getInt(Map map, DataItem index) {
        DataItem item = map.get(index);
        return ((Number) item).getValue().intValue();
    }

    public static long getLong(Map map, DataItem index) {
        DataItem item = map.get(index);
        return ((Number) item).getValue().longValue();
    }

    public static Set<Integer> getIntSet(Map map, DataItem index) {
        Array array = (Array) map.get(index);
        Set<Integer> result = new HashSet<>();
        for (DataItem item : array.getDataItems()) {
            result.add(((Number) item).getValue().intValue());
        }
        return result;
    }

    public static Boolean getBoolean(Map map, DataItem index) {
        SimpleValueType value = ((SimpleValue) map.get(index)).getSimpleValueType();
        if (value != SimpleValueType.TRUE && value != SimpleValueType.FALSE) {
            throw new RuntimeException("Only expecting boolean values for " + index);
        }
        return (value == SimpleValueType.TRUE);
    }

    public static List<Boolean> getBooleanList(Map map, DataItem index) {
        Array array = (Array) map.get(index);
        List<Boolean> result = new ArrayList<>();
        for (DataItem item : array.getDataItems()) {
            SimpleValueType value = ((SimpleValue) item).getSimpleValueType();
            if (value == SimpleValueType.FALSE) {
                result.add(false);
            } else if (value == SimpleValueType.TRUE) {
                result.add(true);
            } else {
                throw new RuntimeException("Map contains more than booleans: " + map);
            }
        }
        return result;
    }

    public static Date getDate(Map map, DataItem index) {
        DataItem item = map.get(index);
        long epochMillis = ((Number) item).getValue().longValue();
        return new Date(epochMillis);
    }

    public static byte[] getBytes(Map map, DataItem index) {
        DataItem item = map.get(index);
        return ((ByteString) item).getBytes();
    }

    public static String getString(Map map, DataItem index) {
        byte[] bytes = getBytes(map, index);
        return new String(bytes, StandardCharsets.UTF_8);
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/CertificateRevocationStatus.java`:

```java
/* Copyright 2019, The Android Open Source Project, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.net.URL;


/**
 * Utils for fetching and decoding attestation certificate status.
 */
public class CertificateRevocationStatus {

    private static final String STATUS_URL = "https://android.googleapis.com/attestation/status";
    public final String status;
    public final String reason;
    public final String comment;
    public final String expires;

    public CertificateRevocationStatus(String status, String reason, String comment, String expires) {
        this.status = status;
        this.reason = reason;
        this.comment = comment;
        this.expires = expires;
    }

    public static JsonObject parseStatus(InputStream stream) {
        return JsonParser.parseReader(new InputStreamReader(stream))
                .getAsJsonObject()
                .getAsJsonObject("entries");
    }

    public static CertificateRevocationStatus fetchStatus(BigInteger serialNumber) throws IOException {
        URL url = new URL(STATUS_URL);
        return decodeStatus(serialNumber, parseStatus(url.openStream()));
    }

    public static CertificateRevocationStatus decodeStatus(BigInteger serialNumber,
                                                           JsonObject entries) {
        if (serialNumber == null) {
            throw new IllegalArgumentException("serialNumber cannot be null");
        }
        String serialNumberString = serialNumber.toString(16).toLowerCase();
        var entry = entries.getAsJsonObject(serialNumberString);
        if (entry == null) {
            return null;
        }

        return new CertificateRevocationStatus(
                entry.getAsJsonPrimitive("status").getAsString(),
                entry.getAsJsonPrimitive("reason").getAsString(),
                null, null);
    }

    public enum Status {
        REVOKED, SUSPENDED
    }

    public enum Reason {
        UNSPECIFIED, KEY_COMPROMISE, CA_COMPROMISE, SUPERSEDED, SOFTWARE_FLAW
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/EatAttestation.java`:

```java
/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import android.util.Log;

import co.nstant.in.cbor.CborDecoder;
import co.nstant.in.cbor.CborException;
import co.nstant.in.cbor.model.DataItem;
import co.nstant.in.cbor.model.Map;
import co.nstant.in.cbor.model.Number;
import co.nstant.in.cbor.model.UnicodeString;

import org.bouncycastle.asn1.ASN1Encodable;

import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.List;

public class EatAttestation extends Attestation {
    static final String TAG = "EatAttestation";
    final Map extension;
    final RootOfTrust rootOfTrust;

    /**
     * Constructs an {@code EatAttestation} object from the provided {@link X509Certificate},
     * extracting the attestation data from the attestation extension.
     *
     * @throws CertificateParsingException if the certificate does not contain a properly-formatted
     *     attestation extension.
     */
    public EatAttestation(X509Certificate x509Cert)
            throws CertificateParsingException, CborException {
        super(x509Cert);
        extension = getEatExtension(x509Cert);

        RootOfTrust.Builder rootOfTrustBuilder = new RootOfTrust.Builder();
        List<Boolean> bootState = null;
        boolean officialBuild = false;

        for (DataItem key : extension.getKeys()) {
            int keyInt = ((Number) key).getValue().intValue();
            switch (keyInt) {
                default:
                    throw new CertificateParsingException(
                            "Unknown EAT tag: " + key + "\n in EAT extension:\n" + this);

                case EatClaim.ATTESTATION_VERSION:
                    attestationVersion = CborUtils.getInt(extension, key);
                    break;
                case EatClaim.KEYMASTER_VERSION:
                    keymasterVersion = CborUtils.getInt(extension, key);
                    break;
                case EatClaim.SECURITY_LEVEL:
                    keymasterSecurityLevel =
                            eatSecurityLevelToKeymintSecurityLevel(
                                    CborUtils.getInt(extension, key));
                    break;
                case EatClaim.SUBMODS:
                    Map submods = (Map) extension.get(key);
                    softwareEnforced =
                            new AuthorizationList(
                                    (Map) submods.get(new UnicodeString(EatClaim.SUBMOD_SOFTWARE)));
                    teeEnforced =
                            new AuthorizationList(
                                    (Map) submods.get(new UnicodeString(EatClaim.SUBMOD_TEE)));
                    break;
                case EatClaim.VERIFIED_BOOT_KEY:
                    rootOfTrustBuilder.setVerifiedBootKey(CborUtils.getBytes(extension, key));
                    break;
                case EatClaim.DEVICE_LOCKED:
                    rootOfTrustBuilder.setDeviceLocked(CborUtils.getBoolean(extension, key));
                    break;
                case EatClaim.BOOT_STATE:
                    bootState = CborUtils.getBooleanList(extension, key);
                    break;
                case EatClaim.OFFICIAL_BUILD:
                    officialBuild = CborUtils.getBoolean(extension, key);
                    break;
                case EatClaim.NONCE:
                    attestationChallenge = CborUtils.getBytes(extension, key);
                    break;
                case EatClaim.CTI:
                    Log.i(TAG, "Got CTI claim: " + Arrays.toString(CborUtils.getBytes(extension, key)));
                    uniqueId = CborUtils.getBytes(extension, key);
                    break;
                case EatClaim.VERIFIED_BOOT_HASH:
                    rootOfTrustBuilder.setVerifiedBootHash(CborUtils.getBytes(extension, key));
                    break;
            }
        }

        if (bootState != null) {
            rootOfTrustBuilder.setVerifiedBootState(
                    eatBootStateTypeToVerifiedBootState(bootState, officialBuild));
        }
        rootOfTrust = rootOfTrustBuilder.build();
    }

    /** Find the submod containing the key information, and return its security level. */
    public int getAttestationSecurityLevel() {
        if (teeEnforced != null && teeEnforced.getAlgorithm() != null) {
            return teeEnforced.getSecurityLevel();
        } else if (softwareEnforced != null && softwareEnforced.getAlgorithm() != null) {
            return softwareEnforced.getSecurityLevel();
        } else {
            return -1;
        }
    }

    public RootOfTrust getRootOfTrust() {
        return rootOfTrust;
    }

    public String toString() {
        return super.toString() + "\nEncoded CBOR: " + extension;
    }

    Map getEatExtension(X509Certificate x509Cert)
            throws CertificateParsingException, CborException {
        byte[] attestationExtensionBytes = x509Cert.getExtensionValue(Attestation.EAT_OID);
        if (attestationExtensionBytes == null || attestationExtensionBytes.length == 0) {
            throw new CertificateParsingException("Did not find extension with OID " + EAT_OID);
        }
        ASN1Encodable asn1 = Asn1Utils.getAsn1EncodableFromBytes(attestationExtensionBytes);
        byte[] cborBytes = Asn1Utils.getByteArrayFromAsn1(asn1);
        List<DataItem> cbor = CborDecoder.decode(cborBytes);
        return (Map) cbor.get(0);
    }

    static int eatSecurityLevelToKeymintSecurityLevel(int eatSecurityLevel) {
        switch (eatSecurityLevel) {
            case EatClaim.SECURITY_LEVEL_UNRESTRICTED:
                return Attestation.KM_SECURITY_LEVEL_SOFTWARE;
            case EatClaim.SECURITY_LEVEL_SECURE_RESTRICTED:
                return Attestation.KM_SECURITY_LEVEL_TRUSTED_ENVIRONMENT;
            case EatClaim.SECURITY_LEVEL_HARDWARE:
                return Attestation.KM_SECURITY_LEVEL_STRONG_BOX;
            default:
                throw new RuntimeException("Invalid EAT security level: " + eatSecurityLevel);
        }
    }

    static int eatBootStateTypeToVerifiedBootState(List<Boolean> bootState, Boolean officialBuild) {
        if (bootState.size() != 5) {
            throw new RuntimeException("Boot state map has unexpected size: " + bootState.size());
        }
        if (bootState.get(4)) {
            throw new RuntimeException("debug-permanent-disable must never be true: " + bootState);
        }
        boolean verifiedOrSelfSigned = bootState.get(0);
        if (verifiedOrSelfSigned != bootState.get(1)
                && verifiedOrSelfSigned != bootState.get(2)
                && verifiedOrSelfSigned != bootState.get(3)) {
            throw new RuntimeException("Unexpected boot state: " + bootState);
        }

        if (officialBuild) {
            if (!verifiedOrSelfSigned) {
                throw new AssertionError("Non-verified official build");
            }
            return RootOfTrust.KM_VERIFIED_BOOT_VERIFIED;
        } else {
            return verifiedOrSelfSigned
                    ? RootOfTrust.KM_VERIFIED_BOOT_SELF_SIGNED
                    : RootOfTrust.KM_VERIFIED_BOOT_UNVERIFIED;
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/EatClaim.java`:

```java
package io.github.vvb2060.keyattestation.attestation;

import static io.github.vvb2060.keyattestation.attestation.AuthorizationList.*;

class EatClaim {
    public static final int IAT = 6;
    public static final int CTI = 7;

    public static final int NONCE = -75008;
    public static final int UEID = -75009;

    public static final int SECURITY_LEVEL = -76002;
    public static final int SECURITY_LEVEL_UNRESTRICTED = 1;
    public static final int SECURITY_LEVEL_SECURE_RESTRICTED = 3;
    public static final int SECURITY_LEVEL_HARDWARE = 4;

    public static final int BOOT_STATE = -76003;
    public static final int SUBMODS = -76000;

    private static final int PRIVATE_BASE = -80000;

    public static final int PURPOSE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_PURPOSE);
    public static final int ALGORITHM = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ALGORITHM);
    public static final int KEY_SIZE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_KEY_SIZE);
    public static final int BLOCK_MODE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_BLOCK_MODE);
    public static final int DIGEST = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_DIGEST);
    public static final int PADDING = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_PADDING);
    public static final int CALLER_NONCE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_CALLER_NONCE);
    public static final int MIN_MAC_LENGTH = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_MIN_MAC_LENGTH);
    public static final int KDF = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_KDF);

    public static final int EC_CURVE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_EC_CURVE);
    public static final int EAT_EC_CURVE_P_224 = 0;
    public static final int EAT_EC_CURVE_P_256 = 1;
    public static final int EAT_EC_CURVE_P_384 = 2;
    public static final int EAT_EC_CURVE_P_521 = 3;

    public static final int RSA_PUBLIC_EXPONENT = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_RSA_PUBLIC_EXPONENT);
    public static final int RSA_OAEP_MGF_DIGEST = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_RSA_OAEP_MGF_DIGEST);
    public static final int ROLLBACK_RESISTANCE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ROLLBACK_RESISTANCE);
    public static final int EARLY_BOOT_ONLY = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_EARLY_BOOT_ONLY);

    public static final int ACTIVE_DATETIME = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ACTIVE_DATETIME);
    public static final int ORIGINATION_EXPIRE_DATETIME = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ORIGINATION_EXPIRE_DATETIME);
    public static final int USAGE_EXPIRE_DATETIME = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_USAGE_EXPIRE_DATETIME);

    public static final int NO_AUTH_REQUIRED = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_NO_AUTH_REQUIRED);
    public static final int USER_AUTH_TYPE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_USER_AUTH_TYPE);
    public static final int AUTH_TIMEOUT = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_AUTH_TIMEOUT);
    public static final int ALLOW_WHILE_ON_BODY = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ALLOW_WHILE_ON_BODY);
    public static final int USER_PRESENCE_REQUIRED = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_TRUSTED_USER_PRESENCE_REQUIRED);
    public static final int TRUSTED_CONFIRMATION_REQUIRED = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_TRUSTED_CONFIRMATION_REQUIRED);
    public static final int UNLOCKED_DEVICE_REQUIRED = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_UNLOCKED_DEVICE_REQUIRED);

    public static final int APPLICATION_ID = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_APPLICATION_ID);

    public static final int ORIGIN = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ORIGIN);
    public static final int ROLLBACK_RESISTANT = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ROLLBACK_RESISTANT);
    public static final int OS_VERSION = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_OS_VERSION);
    public static final int OS_PATCHLEVEL = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_OS_PATCHLEVEL);
    public static final int ATTESTATION_APPLICATION_ID = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_APPLICATION_ID);
    public static final int ATTESTATION_ID_BRAND = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_BRAND);
    public static final int ATTESTATION_ID_DEVICE = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_DEVICE);
    public static final int ATTESTATION_ID_PRODUCT = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_PRODUCT);
    public static final int ATTESTATION_ID_SERIAL = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_SERIAL);
    public static final int ATTESTATION_ID_MEID = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_MEID);
    public static final int ATTESTATION_ID_MANUFACTURER = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_MANUFACTURER);
    public static final int ATTESTATION_ID_MODEL = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_ATTESTATION_ID_MODEL);
    public static final int VENDOR_PATCHLEVEL = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_VENDOR_PATCHLEVEL);
    public static final int BOOT_PATCHLEVEL = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_BOOT_PATCHLEVEL);
    public static final int DEVICE_UNIQUE_ATTESTATION = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_DEVICE_UNIQUE_ATTESTATION);
    public static final int IDENTITY_CREDENTIAL_KEY = PRIVATE_BASE - (KEYMASTER_TAG_TYPE_MASK & KM_TAG_IDENTITY_CREDENTIAL_KEY);

    private static final int NON_KM_BASE = PRIVATE_BASE - 2000;

    public static final int VERIFIED_BOOT_KEY = NON_KM_BASE - 1;
    public static final int DEVICE_LOCKED = NON_KM_BASE - 2;
    public static final int VERIFIED_BOOT_HASH = NON_KM_BASE - 3;
    public static final int ATTESTATION_VERSION = NON_KM_BASE - 4;
    public static final int KEYMASTER_VERSION = NON_KM_BASE - 5;
    public static final int OFFICIAL_BUILD = NON_KM_BASE - 6;

    public static final String SUBMOD_SOFTWARE = "software";
    public static final String SUBMOD_TEE = "tee";
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/RootOfTrust.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.vvb2060.keyattestation.attestation;

import com.google.common.io.BaseEncoding;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Sequence;

import java.security.cert.CertificateParsingException;

public class RootOfTrust {
    private static final int VERIFIED_BOOT_KEY_INDEX = 0;
    private static final int DEVICE_LOCKED_INDEX = 1;
    private static final int VERIFIED_BOOT_STATE_INDEX = 2;
    private static final int VERIFIED_BOOT_HASH_INDEX = 3;

    public static final int KM_VERIFIED_BOOT_VERIFIED = 0;
    public static final int KM_VERIFIED_BOOT_SELF_SIGNED = 1;
    public static final int KM_VERIFIED_BOOT_UNVERIFIED = 2;
    public static final int KM_VERIFIED_BOOT_FAILED = 3;

    private final byte[] verifiedBootKey;
    private final boolean deviceLocked;
    private final int verifiedBootState;
    private final byte[] verifiedBootHash;

    public RootOfTrust(ASN1Encodable asn1Encodable) throws CertificateParsingException {
        if (!(asn1Encodable instanceof ASN1Sequence sequence)) {
            throw new CertificateParsingException("Expected sequence for root of trust, found "
                    + asn1Encodable.getClass().getName());
        }

        verifiedBootKey =
                Asn1Utils.getByteArrayFromAsn1(sequence.getObjectAt(VERIFIED_BOOT_KEY_INDEX));
        deviceLocked = Asn1Utils.getBooleanFromAsn1(sequence.getObjectAt(DEVICE_LOCKED_INDEX));
        verifiedBootState =
                Asn1Utils.getIntegerFromAsn1(sequence.getObjectAt(VERIFIED_BOOT_STATE_INDEX));
        if (sequence.size() == 3) verifiedBootHash = null;
        else verifiedBootHash =
                Asn1Utils.getByteArrayFromAsn1(sequence.getObjectAt(VERIFIED_BOOT_HASH_INDEX));
    }

    RootOfTrust(byte[] verifiedBootKey, boolean deviceLocked,
                int verifiedBootState, byte[] verifiedBootHash) {
        this.verifiedBootKey = verifiedBootKey;
        this.deviceLocked = deviceLocked;
        this.verifiedBootState = verifiedBootState;
        this.verifiedBootHash = verifiedBootHash;
    }

    public static String verifiedBootStateToString(int verifiedBootState) {
        switch (verifiedBootState) {
            case KM_VERIFIED_BOOT_VERIFIED:
                return "Verified";
            case KM_VERIFIED_BOOT_SELF_SIGNED:
                return "Self-signed";
            case KM_VERIFIED_BOOT_UNVERIFIED:
                return "Unverified";
            case KM_VERIFIED_BOOT_FAILED:
                return "Failed";
            default:
                return "Unknown (" + verifiedBootState + ")";
        }
    }

    public byte[] getVerifiedBootKey() {
        return verifiedBootKey;
    }

    public boolean isDeviceLocked() {
        return deviceLocked;
    }

    public int getVerifiedBootState() {
        return verifiedBootState;
    }

    public byte[] getVerifiedBootHash() {
        return verifiedBootHash;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder()
                .append("Verified boot Key: ")
                .append(BaseEncoding.base64().encode(verifiedBootKey)).append(" (base64)").append('\n')
                .append("Device locked: ")
                .append(deviceLocked).append('\n')
                .append("Verified boot state: ")
                .append(verifiedBootStateToString(verifiedBootState)).append('\n');
        if (verifiedBootHash != null) sb.append("Verified boot hash: ")
                .append(BaseEncoding.base64().encode(verifiedBootHash)).append(" (base64)");
        return sb.toString();
    }

    public static class Builder {
        private byte[] verifiedBootKey;
        private boolean deviceLocked = false;
        private int verifiedBootState = -1;
        private byte[] verifiedBootHash;

        public Builder setVerifiedBootKey(byte[] verifiedBootKey) {
            this.verifiedBootKey = verifiedBootKey;
            return this;
        }

        public Builder setDeviceLocked(boolean deviceLocked) {
            this.deviceLocked = deviceLocked;
            return this;
        }

        public Builder setVerifiedBootState(int verifiedBootState) {
            this.verifiedBootState = verifiedBootState;
            return this;
        }

        public Builder setVerifiedBootHash(byte[] verifiedBootHash) {
            this.verifiedBootHash = verifiedBootHash;
            return this;
        }

        public RootOfTrust build() {
            return new RootOfTrust(verifiedBootKey, deviceLocked,
                    verifiedBootState, verifiedBootHash);
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/attestation/VerifyCertificateChain.java`:

```java
package io.github.vvb2060.keyattestation.attestation;

import android.util.Base64;
import android.util.Log;

import com.google.gson.JsonObject;

import java.security.GeneralSecurityException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.List;

import io.github.vvb2060.keyattestation.AppApplication;
import io.github.vvb2060.keyattestation.R;

public class VerifyCertificateChain {
    public static final int FAILED = -1;
    public static final int UNKNOWN = 0;
    public static final int AOSP = 1;
    public static final int GOOGLE = 2;

    private static final String GOOGLE_ROOT_PUBLIC_KEY = "" +
            "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xU" +
            "FmOr75gvMsd/dTEDDJdSSxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5j" +
            "lRfdnJLmN0pTy/4lj4/7tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y" +
            "//0rb+T+W8a9nsNL/ggjnar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73X" +
            "pXyTqRxB/M0n1n/W9nGqC4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYI" +
            "mQQcHtGl/m00QLVWutHQoVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB" +
            "+TxywElgS70vE0XmLD+OJtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7q" +
            "uvmag8jfPioyKvxnK/EgsTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgp" +
            "Zrt3i5MIlCaY504LzSRiigHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7" +
            "gLiMm0jhO2B6tUXHI/+MRPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82" +
            "ixPvZtXQpUpuL12ab+9EaDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+" +
            "NpUFgNPN9PvQi8WEg5UmAGMCAwEAAQ==";

    private static final String AOSP_ROOT_PUBLIC_KEY = "" +
            "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamgu" +
            "D/9/SQ59dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpA==";

    public static int verifyCertificateChain(List<X509Certificate> certs)
            throws GeneralSecurityException {
        JsonObject entries;
        try (var stream = AppApplication.app.getResources().openRawResource(R.raw.status)) {
            entries = CertificateRevocationStatus.parseStatus(stream);
        } catch (Exception e) {
            throw new GeneralSecurityException("Failed to parse certificate revocation status", e);
        }
        var root = certs.get(certs.size() - 1);
        var parent = root;
        for (int i = certs.size() - 1; i >= 0; i--) {
            var cert = certs.get(i);
            cert.checkValidity();
            cert.verify(parent.getPublicKey());
            parent = cert;
            var certStatus = CertificateRevocationStatus.decodeStatus(cert.getSerialNumber(), entries);
            if (certStatus != null) {
                throw new CertificateException("Certificate revocation status is " + certStatus.status
                        + ", reason " + certStatus.reason);
            }
        }

        var rootPublicKey = root.getPublicKey().getEncoded();
        if (Arrays.equals(rootPublicKey, Base64.decode(GOOGLE_ROOT_PUBLIC_KEY, 0))) {
            return GOOGLE;
        }
        if (Arrays.equals(rootPublicKey, Base64.decode(AOSP_ROOT_PUBLIC_KEY, 0))) {
            return AOSP;
        }
        Log.w(AppApplication.TAG, root.toString());
        Log.w(AppApplication.TAG, Base64.encodeToString(rootPublicKey, Base64.NO_WRAP));
        return UNKNOWN;
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/BootStateViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.content.res.ColorStateList
import android.view.View
import androidx.core.view.isVisible
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.attestation.Attestation
import io.github.vvb2060.keyattestation.attestation.AttestationResult
import io.github.vvb2060.keyattestation.attestation.RootOfTrust
import io.github.vvb2060.keyattestation.databinding.HomeHeaderBinding
import rikka.core.res.resolveColor
import rikka.recyclerview.BaseViewHolder.Creator

class BootStateViewHolder(itemView: View, binding: HomeHeaderBinding) :
        HomeViewHolder<AttestationResult, HomeHeaderBinding>(itemView, binding) {

    companion object {

        val CREATOR = Creator<AttestationResult> { inflater, parent ->
            val binding = HomeHeaderBinding.inflate(inflater, parent, false)
            BootStateViewHolder(binding.root, binding)
        }
    }

    override fun onBind() {
        val context = itemView.context

        val attestation = data.attestation
        val rootOfTrust = attestation.rootOfTrust
        val locked = rootOfTrust?.isDeviceLocked
        val bootUnverified = rootOfTrust?.verifiedBootState != RootOfTrust.KM_VERIFIED_BOOT_VERIFIED

        val titleRes: Int
        val summaryRes: Int
        val iconRes: Int
        val colorAttrRes: Int

        if (locked == null) {
            titleRes = R.string.bootloader_unknown
            iconRes = R.drawable.ic_boot_unknown_24
            colorAttrRes = rikka.material.R.attr.colorInactive
        } else if (!locked) {
            titleRes = R.string.bootloader_unlocked
            iconRes = R.drawable.ic_boot_unlocked_24
            colorAttrRes = rikka.material.R.attr.colorWarning
        } else if (bootUnverified) {
            titleRes = R.string.bootloader_user
            iconRes = R.drawable.ic_boot_locked_24
            colorAttrRes = rikka.material.R.attr.colorInactive
        } else {
            titleRes = R.string.bootloader_locked
            iconRes = R.drawable.ic_boot_locked_24
            colorAttrRes = rikka.material.R.attr.colorSafe
        }

        if (attestation.attestationSecurityLevel == Attestation.KM_SECURITY_LEVEL_SOFTWARE) {
            summaryRes = R.string.bootloader_summary_sw_level
        } else {
            summaryRes = 0
        }

        val color = context.theme.resolveColor(colorAttrRes)

        binding.apply {
            title.setText(titleRes)
            icon.setImageDrawable(context.getDrawable(iconRes))
            root.backgroundTintList = ColorStateList.valueOf(color)
            if (summaryRes == 0) {
                summary.isVisible = false
            } else {
                summary.isVisible = true
                summary.setText(summaryRes)
            }
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/CommonItemViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.view.View
import androidx.core.view.isVisible
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.attestation.Attestation.KM_SECURITY_LEVEL_STRONG_BOX
import io.github.vvb2060.keyattestation.attestation.Attestation.KM_SECURITY_LEVEL_TRUSTED_ENVIRONMENT
import io.github.vvb2060.keyattestation.databinding.HomeCommonItemBinding
import rikka.core.res.resolveColorStateList
import rikka.recyclerview.BaseViewHolder.Creator

open class CommonItemViewHolder<T>(itemView: View, binding: HomeCommonItemBinding) : HomeViewHolder<T, HomeCommonItemBinding>(itemView, binding) {

    companion object {

        val COMMON_CREATOR = Creator<CommonData> { inflater, parent ->
            val binding = HomeCommonItemBinding.inflate(inflater, parent, false)
            object : CommonItemViewHolder<CommonData>(binding.root, binding) {

                init {
                    this.binding.apply {
                        icon.isVisible = false
                        root.setOnClickListener {
                            listener.onCommonDataClick(data)
                        }
                    }
                }

                override fun onBind() {
                    binding.title.setText(data.title)
                    if (!data.data.isNullOrBlank()) {
                        binding.summary.text = data.data
                    } else {
                        binding.summary.setText(R.string.empty)
                    }
                }
            }
        }

        val AUTHORIZATION_ITEM_CREATOR = Creator<AuthorizationItemData> { inflater, parent ->
            val binding = HomeCommonItemBinding.inflate(inflater, parent, false)
            object : CommonItemViewHolder<AuthorizationItemData>(binding.root, binding) {

                init {
                    this.binding.apply {
                        root.setOnClickListener {
                            listener.onAuthorizationItemDataClick(data)
                        }
                        icon.isVisible = false
                    }
                }

                override fun onBind() {
                    binding.apply {
                        icon.setImageDrawable(context.getDrawable(R.drawable.ic_trustworthy_24))
                        title.setText(data.title)
                        if (!data.data.isNullOrBlank()) {
                            summary.text = data.data
                            text1.setText(if (data.tee) R.string.tee_enforced else R.string.sw_enforced)
                            text1.isVisible = true
                        } else {
                            summary.setText(R.string.empty)
                            text1.isVisible = false
                        }
                    }
                }
            }
        }

        val SECURITY_LEVEL_CREATOR = Creator<SecurityLevelData> { inflater, parent ->
            val binding = HomeCommonItemBinding.inflate(inflater, parent, false)
            object : CommonItemViewHolder<SecurityLevelData>(binding.root, binding) {

                init {
                    this.binding.apply {
                        text1.isVisible = false
                        icon.background = null
                        root.setOnClickListener {
                            listener.onSecurityLevelDataClick(data)
                        }
                    }
                }

                override fun onBind() {
                    val context = itemView.context
                    val data = data
                    val securityLevel: Int
                    val iconRes: Int
                    val colorAttr: Int
                    when (data.securityLevel) {
                        KM_SECURITY_LEVEL_TRUSTED_ENVIRONMENT -> {
                            securityLevel = R.string.security_level_trusted_environment
                            iconRes = R.drawable.ic_trustworthy_24
                            colorAttr = rikka.material.R.attr.colorSafe
                        }
                        KM_SECURITY_LEVEL_STRONG_BOX -> {
                            securityLevel = R.string.security_level_strongbox
                            iconRes = R.drawable.ic_trustworthy_24
                            colorAttr = rikka.material.R.attr.colorSafe
                        }
                        else -> {
                            securityLevel = R.string.security_level_software
                            iconRes = R.drawable.ic_untrustworthy_24
                            colorAttr = rikka.material.R.attr.colorWarning
                        }
                    }

                    binding.apply {
                        title.setText(data.title)
                        summary.text = context.getString(R.string.attestation_summary_format, data.version, context.getString(securityLevel))
                        icon.setImageDrawable(context.getDrawable(iconRes))
                        icon.imageTintList = context.theme.resolveColorStateList(colorAttr)
                    }
                }
            }
        }
    }

    init {
        setIsRecyclable(false)
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/Data.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import androidx.annotation.StringRes

abstract class Data {

    abstract val title: Int
        @StringRes get

    abstract val description: Int
        @StringRes get
}

data class HeaderData(override val title: Int, override val description: Int, val icon: Int, val color: Int) : Data()

data class CommonData(override val title: Int, override val description: Int, val data: String?) : Data()

data class AuthorizationItemData(override val title: Int, override val description: Int, val data: String?, val tee: Boolean) : Data() {
    constructor(title: Int, description: Int, data: String?, fallback: String?) : this(title, description, data ?: fallback, data != null)
}

data class SecurityLevelData(override val title: Int, override val description: Int, val securityLevelDescription: Int, val version: String, val securityLevel: Int) : Data()

data class SubtitleData(override val title: Int, override val description: Int) : Data()

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/ErrorViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.view.View
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.databinding.HomeErrorBinding
import io.github.vvb2060.keyattestation.ktx.toHtml
import io.github.vvb2060.keyattestation.lang.AttestationException
import rikka.html.text.HtmlCompat
import rikka.recyclerview.BaseViewHolder.Creator

class ErrorViewHolder(itemView: View, binding: HomeErrorBinding) : HomeViewHolder<AttestationException, HomeErrorBinding>(itemView, binding) {

    companion object {

        val CREATOR = Creator<AttestationException> { inflater, parent ->
            val binding = HomeErrorBinding.inflate(inflater, parent, false)
            ErrorViewHolder(binding.root, binding)
        }
    }

    override fun onBind() {
        val context = itemView.context
        binding.apply {
            val sb = StringBuilder()
            sb.append(context.getString(data.descriptionResId)).append("<p>")

            sb.append(context.getString(R.string.error_message_subtitle)).append("<br>")
            sb.append("<font face=\"monospace\">")
            var tr = data.cause
            while (tr != null) {
                sb.append("${tr::class.java.name}: ${tr.message}").append("<br>")
                tr = tr.cause
            }
            sb.append("</font>")
            text1.text = sb.toHtml(HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE)
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HeaderViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.view.View
import androidx.core.view.isVisible
import io.github.vvb2060.keyattestation.databinding.HomeHeaderBinding
import rikka.core.res.resolveColorStateList
import rikka.recyclerview.BaseViewHolder.Creator

class HeaderViewHolder(itemView: View, binding: HomeHeaderBinding) : HomeViewHolder<HeaderData, HomeHeaderBinding>(itemView, binding) {

    companion object {

        val CREATOR = Creator<HeaderData> { inflater, parent ->
            val binding = HomeHeaderBinding.inflate(inflater, parent, false)
            HeaderViewHolder(binding.root, binding)
        }
    }

    override fun onBind() {
        binding.apply {
            val context = root.context
            root.backgroundTintList = context.theme.resolveColorStateList(data.color)
            icon.setImageDrawable(context.getDrawable(data.icon))
            title.setText(data.title)
            if (data.description != 0) {
                summary.setText(data.description)
                summary.isVisible = true
            } else {
                summary.isVisible = false
            }
        }
    }
}
```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeActivity.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.os.Bundle
import io.github.vvb2060.keyattestation.BuildConfig
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.app.AppBarFragmentActivity

class HomeActivity : AppBarFragmentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        supportActionBar?.subtitle = BuildConfig.VERSION_NAME

        if (savedInstanceState == null) {
            supportFragmentManager.beginTransaction()
                    .replace(R.id.fragment_container, HomeFragment())
                    .commit()
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeAdapter.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import com.google.common.base.CharMatcher
import com.google.common.io.BaseEncoding
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.attestation.Attestation
import io.github.vvb2060.keyattestation.attestation.AttestationResult
import io.github.vvb2060.keyattestation.attestation.AuthorizationList
import io.github.vvb2060.keyattestation.attestation.VerifyCertificateChain
import io.github.vvb2060.keyattestation.lang.AttestationException
import rikka.recyclerview.IdBasedRecyclerViewAdapter

class HomeAdapter(listener: Listener) : IdBasedRecyclerViewAdapter() {

    interface Listener {

        fun onSubtitleDataClick(data: SubtitleData)

        fun onCommonDataClick(data: CommonData)

        fun onSecurityLevelDataClick(data: SecurityLevelData)

        fun onAuthorizationItemDataClick(data: AuthorizationItemData)
    }

    init {
        setHasStableIds(false)
        setListener(listener)
    }

    fun updateData(attestationResult: AttestationResult, showAll: Boolean) {
        val attestation = attestationResult.attestation
        val trustRootCertificate = attestationResult.isGoogleRootCertificate

        clear()
        when (trustRootCertificate) {
            VerifyCertificateChain.FAILED -> {
                addItem(HeaderViewHolder.CREATOR, HeaderData(
                        R.string.error_cert_not_trusted,
                        R.string.error_cert_not_trusted_summary,
                        R.drawable.ic_error_outline_24,
                        rikka.material.R.attr.colorAlert), ID_NOT_GOOGLE_CERT)
            }
            VerifyCertificateChain.UNKNOWN -> {
                addItem(HeaderViewHolder.CREATOR, HeaderData(
                        R.string.unknown_root_cert,
                        R.string.unknown_root_cert_summary,
                        R.drawable.ic_error_outline_24,
                        rikka.material.R.attr.colorWarning), ID_NOT_GOOGLE_CERT)
            }
            VerifyCertificateChain.AOSP -> {
                addItem(HeaderViewHolder.CREATOR, HeaderData(
                        R.string.aosp_root_cert,
                        R.string.aosp_root_cert_summary,
                        R.drawable.ic_error_outline_24,
                        rikka.material.R.attr.colorWarning), ID_NOT_GOOGLE_CERT)
            }
        }
        addItem(BootStateViewHolder.CREATOR, attestationResult, ID_BOOT_STATE)

        var id = ID_DESCRIPTION_START
        addItem(CommonItemViewHolder.SECURITY_LEVEL_CREATOR, SecurityLevelData(
                R.string.attestation,
                R.string.attestation_version_description,
                R.string.security_level_description,
                Attestation.attestationVersionToString(attestation.attestationVersion),
                attestation.attestationSecurityLevel), id++)

        addItem(CommonItemViewHolder.SECURITY_LEVEL_CREATOR, SecurityLevelData(
                R.string.keymaster,
                R.string.keymaster_version_description,
                R.string.security_level_description,
                Attestation.keymasterVersionToString(attestation.keymasterVersion),
                attestation.keymasterSecurityLevel), id++)

        addItem(CommonItemViewHolder.COMMON_CREATOR, CommonData(
                R.string.attestation_challenge,
                R.string.attestation_challenge_description,
                attestation.attestationChallenge?.let {
                    val stringChallenge = String(it)
                    if (CharMatcher.ascii().matchesAllOf(stringChallenge)) stringChallenge
                    else BaseEncoding.base64().encode(it) + " (base64)"
                }), id++)

        if (showAll) addItem(CommonItemViewHolder.COMMON_CREATOR, CommonData(
                R.string.unique_id,
                R.string.unique_id_description,
                attestation.uniqueId?.let { BaseEncoding.base64().encode(it) }), id)

        id = ID_AUTHORIZATION_LIST_START
        addItem(SubtitleViewHolder.CREATOR, SubtitleData(
                R.string.authorization_list,
                R.string.authorization_list_description), id++)

        val tee = createAuthorizationItems(attestation.teeEnforced)
        val sw = createAuthorizationItems(attestation.softwareEnforced)
        for (i in IntRange(if (showAll) 0 else 26, tee.lastIndex)) {
            if (tee[i] == null && sw[i] == null) {
                continue
            }

            addItem(CommonItemViewHolder.AUTHORIZATION_ITEM_CREATOR, AuthorizationItemData(
                    authorizationItemTitles[i],
                    authorizationItemDescriptions[i],
                    tee[i],
                    sw[i]), id++)

            if (tee[i] != null && sw[i] != null) {
                addItem(CommonItemViewHolder.AUTHORIZATION_ITEM_CREATOR, AuthorizationItemData(
                        authorizationItemTitles[i],
                        authorizationItemDescriptions[i],
                        sw[i],
                        false), id++)
            }
        }

        notifyDataSetChanged()
    }

    fun updateData(e: AttestationException) {
        clear()
        addItem(HeaderViewHolder.CREATOR, HeaderData(
                e.titleResId,
                0,
                R.drawable.ic_error_outline_24,
                rikka.material.R.attr.colorInactive), ID_ERROR)

        addItem(ErrorViewHolder.CREATOR, e, ID_ERROR_MESSAGE)
        notifyDataSetChanged()
    }

    fun allowFrameAt(position: Int): Boolean {
        if (position < 0) return false
        val id = getItemId(position)
        return id >= ID_DESCRIPTION_START
    }

    fun shouldCommitFrameAt(position: Int): Boolean {
        if (position < 0) return false
        val id = getItemId(position)
        if (position == itemCount - 1) {
            return true
        }
        return if (id < ID_DESCRIPTION_START) {
            false
        } else {
            (getItemId(position + 1) / 1000 - id / 1000) > 0
        }
    }

    companion object {

        private const val ID_ERROR = 0L
        private const val ID_BOOT_STATE = 1L
        private const val ID_NOT_GOOGLE_CERT = 2L
        private const val ID_DESCRIPTION_START = 3000L
        private const val ID_AUTHORIZATION_LIST_START = 4000L
        private const val ID_ERROR_MESSAGE = 100000L

        private fun createAuthorizationItems(list: AuthorizationList): Array<String?> {
            return arrayOf(
                    list.purposes?.let { AuthorizationList.purposesToString(it) },
                    list.algorithm?.let { AuthorizationList.algorithmToString(it) },
                    list.keySize?.toString(),
                    list.digests?.let { AuthorizationList.digestsToString(it) },
                    list.paddingModes?.let { AuthorizationList.paddingModesToString(it) },
                    list.ecCurve?.let { AuthorizationList.ecCurveAsString(it) },
                    list.rsaPublicExponent?.toString(),
                    list.mgfDigest?.let { AuthorizationList.digestsToString(it) },
                    list.rollbackResistance?.toString(),
                    list.earlyBootOnly?.toString(),
                    list.activeDateTime?.let { AuthorizationList.formatDate(it) },
                    list.originationExpireDateTime?.let { AuthorizationList.formatDate(it) },
                    list.usageExpireDateTime?.let { AuthorizationList.formatDate(it) },
                    list.usageCountLimit?.toString(),
                    list.noAuthRequired?.toString(),
                    list.userAuthType?.let { AuthorizationList.userAuthTypeToString(it) },
                    list.authTimeout?.toString(),
                    list.allowWhileOnBody?.toString(),
                    list.userPresenceRequired?.toString(),
                    list.confirmationRequired?.toString(),
                    list.unlockedDeviceRequired?.toString(),
                    list.allApplications?.toString(),
                    list.applicationId,
                    list.creationDateTime?.let { AuthorizationList.formatDate(it) },
                    list.origin?.let { AuthorizationList.originToString(it) },
                    list.rollbackResistant?.toString(),
                    list.rootOfTrust?.toString(),
                    list.osVersion?.toString(),
                    list.osPatchLevel?.toString(),
                    list.attestationApplicationId?.toString()?.trim(),
                    list.brand,
                    list.device,
                    list.product,
                    list.serialNumber,
                    list.imei,
                    list.secondImei,
                    list.meid,
                    list.manufacturer,
                    list.model,
                    list.vendorPatchLevel?.toString(),
                    list.bootPatchLevel?.toString(),
                    list.deviceUniqueAttestation?.toString(),
                    list.identityCredentialKey?.toString(),
            )
        }

        private val authorizationItemTitles = arrayOf(
                R.string.authorization_list_purpose,
                R.string.authorization_list_algorithm,
                R.string.authorization_list_keySize,
                R.string.authorization_list_digest,
                R.string.authorization_list_padding,
                R.string.authorization_list_ecCurve,
                R.string.authorization_list_rsaPublicExponent,
                R.string.authorization_list_mgfDigest,
                R.string.authorization_list_rollbackResistance,
                R.string.authorization_list_earlyBootOnly,
                R.string.authorization_list_activeDateTime,
                R.string.authorization_list_originationExpireDateTime,
                R.string.authorization_list_usageExpireDateTime,
                R.string.authorization_list_usageCountLimit,
                R.string.authorization_list_noAuthRequired,
                R.string.authorization_list_userAuthType,
                R.string.authorization_list_authTimeout,
                R.string.authorization_list_allowWhileOnBody,
                R.string.authorization_list_trustedUserPresenceRequired,
                R.string.authorization_list_trustedConfirmationRequired,
                R.string.authorization_list_unlockedDeviceRequired,
                R.string.authorization_list_allApplications,
                R.string.authorization_list_applicationId,
                R.string.authorization_list_creationDateTime,
                R.string.authorization_list_origin,
                R.string.authorization_list_rollbackResistant,
                R.string.authorization_list_rootOfTrust,
                R.string.authorization_list_osVersion,
                R.string.authorization_list_osPatchLevel,
                R.string.authorization_list_attestationApplicationId,
                R.string.authorization_list_attestationIdBrand,
                R.string.authorization_list_attestationIdDevice,
                R.string.authorization_list_attestationIdProduct,
                R.string.authorization_list_attestationIdSerial,
                R.string.authorization_list_attestationIdImei,
                R.string.authorization_list_attestationIdSecondImei,
                R.string.authorization_list_attestationIdMeid,
                R.string.authorization_list_attestationIdManufacturer,
                R.string.authorization_list_attestationIdModel,
                R.string.authorization_list_vendorPatchLevel,
                R.string.authorization_list_bootPatchLevel,
                R.string.authorization_list_deviceUniqueAttestation,
                R.string.authorization_list_identityCredentialKey,
        )

        private val authorizationItemDescriptions = arrayOf(
                R.string.authorization_list_purpose_description,
                R.string.authorization_list_algorithm_description,
                R.string.authorization_list_keySize_description,
                R.string.authorization_list_digest_description,
                R.string.authorization_list_padding_description,
                R.string.authorization_list_ecCurve_description,
                R.string.authorization_list_rsaPublicExponent_description,
                R.string.authorization_list_mgfDigest_description,
                R.string.authorization_list_rollbackResistance_description,
                R.string.authorization_list_earlyBootOnly_description,
                R.string.authorization_list_activeDateTime_description,
                R.string.authorization_list_originationExpireDateTime_description,
                R.string.authorization_list_usageExpireDateTime_description,
                R.string.authorization_list_usageCountLimit_description,
                R.string.authorization_list_noAuthRequired_description,
                R.string.authorization_list_userAuthType_description,
                R.string.authorization_list_authTimeout_description,
                R.string.authorization_list_allowWhileOnBody_description,
                R.string.authorization_list_trustedUserPresenceRequired_description,
                R.string.authorization_list_trustedConfirmationRequired_description,
                R.string.authorization_list_unlockedDeviceRequired_description,
                R.string.authorization_list_allApplications_description,
                R.string.authorization_list_applicationId_description,
                R.string.authorization_list_creationDateTime_description,
                R.string.authorization_list_origin_description,
                R.string.authorization_list_rollbackResistant_description,
                R.string.authorization_list_rootOfTrust_description,
                R.string.authorization_list_osVersion_description,
                R.string.authorization_list_osPatchLevel_description,
                R.string.authorization_list_attestationApplicationId_description,
                R.string.authorization_list_attestationIdBrand_description,
                R.string.authorization_list_attestationIdDevice_description,
                R.string.authorization_list_attestationIdProduct_description,
                R.string.authorization_list_attestationIdSerial_description,
                R.string.authorization_list_attestationIdImei_description,
                R.string.authorization_list_attestationIdSecondImei_description,
                R.string.authorization_list_attestationIdMeid_description,
                R.string.authorization_list_attestationIdManufacturer_description,
                R.string.authorization_list_attestationIdModel_description,
                R.string.authorization_list_vendorPatchLevel_description,
                R.string.authorization_list_bootPatchLevel_description,
                R.string.authorization_list_deviceUniqueAttestation_description,
                R.string.authorization_list_identityCredentialKey_description,
        )
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeFragment.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.app.Dialog
import android.content.Context
import android.os.Build
import android.os.Bundle
import android.text.method.LinkMovementMethod
import android.view.*
import android.widget.ImageView
import android.widget.TextView
import androidx.activity.result.contract.ActivityResultContracts.CreateDocument
import androidx.activity.result.contract.ActivityResultContracts.OpenDocument
import androidx.appcompat.app.AlertDialog
import androidx.core.content.edit
import androidx.core.view.MenuHost
import androidx.core.view.MenuProvider
import androidx.core.view.isVisible
import io.github.vvb2060.keyattestation.AppApplication
import io.github.vvb2060.keyattestation.BuildConfig
import io.github.vvb2060.keyattestation.R
import io.github.vvb2060.keyattestation.app.AlertDialogFragment
import io.github.vvb2060.keyattestation.app.AppActivity
import io.github.vvb2060.keyattestation.app.AppFragment
import io.github.vvb2060.keyattestation.databinding.HomeBinding
import io.github.vvb2060.keyattestation.ktx.activityViewModels
import io.github.vvb2060.keyattestation.ktx.toHtml
import io.github.vvb2060.keyattestation.lang.AttestationException
import io.github.vvb2060.keyattestation.util.Status
import rikka.html.text.HtmlCompat
import rikka.widget.borderview.BorderView

class HomeFragment : AppFragment(), HomeAdapter.Listener, MenuProvider {

    private var _binding: HomeBinding? = null

    private val binding: HomeBinding get() = _binding!!

    private val viewModel by activityViewModels { HomeViewModel(requireContext().packageManager) }

    private val save = registerForActivityResult(CreateDocument("application/pkix-pkipath")) {
        viewModel.save(requireContext().contentResolver, it)
    }

    private val load = registerForActivityResult(OpenDocument()) {
        viewModel.load(requireContext().contentResolver, it)
    }

    private val adapter by lazy {
        HomeAdapter(this)
    }

    private val preference by lazy {
        requireContext().getSharedPreferences("settings", Context.MODE_PRIVATE)
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        viewModel.preferStrongBox = preference.getBoolean("prefer_strongbox", true)
        viewModel.preferIncludeProps = preference.getBoolean("prefer_including_props", true)
        viewModel.preferShowAll = preference.getBoolean("prefer_show_all", false)
        viewModel.load()
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = HomeBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        (requireActivity() as MenuHost).addMenuProvider(this, viewLifecycleOwner)

        val context = view.context

        binding.list.borderVisibilityChangedListener = BorderView.OnBorderVisibilityChangedListener { top: Boolean, _: Boolean, _: Boolean, _: Boolean -> appActivity?.appBar?.setRaised(!top) }
        binding.list.adapter = adapter
        binding.list.addItemDecoration(HomeItemDecoration(context))

        viewModel.attestationResult.observe(viewLifecycleOwner) { res ->
            when (res.status) {
                Status.SUCCESS -> {
                    binding.progress.isVisible = false
                    binding.list.isVisible = true
                    adapter.updateData(res.data!!, viewModel.preferShowAll)
                }
                Status.ERROR -> {
                    binding.progress.isVisible = false
                    binding.list.isVisible = true
                    adapter.updateData(res.error as AttestationException)
                }
                Status.LOADING -> {
                    binding.progress.isVisible = true
                    binding.list.isVisible = false
                }
            }
        }
    }

    override fun onSubtitleDataClick(data: SubtitleData) {
        val context = requireContext()

        AlertDialogFragment.Builder(context)
                .title(data.title)
                .message(context.getString(data.description).toHtml(HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE))
                .positiveButton(android.R.string.ok)
                .build()
                .show(requireActivity().supportFragmentManager)
    }

    override fun onCommonDataClick(data: CommonData) {
        val context = requireContext()

        AlertDialogFragment.Builder(context)
                .title(data.title)
                .message(context.getString(data.description).toHtml(HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE))
                .positiveButton(android.R.string.ok)
                .build()
                .show(requireActivity().supportFragmentManager)
    }

    override fun onSecurityLevelDataClick(data: SecurityLevelData) {
        val context = requireContext()

        AlertDialogFragment.Builder(context)
                .title(data.title)
                .message("${context.getString(data.description)}<p>${context.getString(data.securityLevelDescription)}".toHtml(HtmlCompat.FROM_HTML_SEPARATOR_LINE_BREAK_LIST_ITEM or HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE))
                .positiveButton(android.R.string.ok)
                .build()
                .show((context as AppActivity).supportFragmentManager)
    }

    override fun onAuthorizationItemDataClick(data: AuthorizationItemData) {
        val context = requireContext()

        val message = if (!data.data.isNullOrBlank()) "${context.getString(data.description)}<p>* ${context.getString(if (data.tee) R.string.tee_enforced_description else R.string.sw_enforced_description)}"
                .toHtml(HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE)
        else
            context.getString(data.description).toHtml(HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE)

        AlertDialogFragment.Builder(context)
                .title(data.title)
                .message(message)
                .positiveButton(android.R.string.ok)
                .build()
                .show(requireActivity().supportFragmentManager)
    }

    override fun onPrepareMenu(menu: Menu) {
        menu.findItem(R.id.menu_use_strongbox).apply {
            isVisible = viewModel.hasStrongBox
            isChecked = viewModel.preferStrongBox
        }
        menu.findItem(R.id.menu_incluid_props).apply {
            isVisible = viewModel.hasDeviceIds
            isChecked = viewModel.preferIncludeProps
        }
        menu.findItem(R.id.menu_skip_verify).apply {
            isVisible = viewModel.showSkipVerify
            isChecked = viewModel.preferSkipVerify
        }
        menu.findItem(R.id.menu_show_all).apply {
            isVisible = viewModel.currentCerts != null
            isChecked = viewModel.preferShowAll
        }
        menu.findItem(R.id.menu_save).isVisible = viewModel.currentCerts != null
    }

    override fun onCreateMenu(menu: Menu, menuInflater: MenuInflater) {
        menuInflater.inflate(R.menu.home, menu)
    }

    override fun onMenuItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_use_strongbox -> {
                val status = !item.isChecked
                item.isChecked = status
                viewModel.preferStrongBox = status
                viewModel.load()
                preference.edit { putBoolean("prefer_strongbox", status) }
            }
            R.id.menu_incluid_props -> {
                val status = !item.isChecked
                item.isChecked = status
                viewModel.preferIncludeProps = status
                viewModel.load()
                preference.edit { putBoolean("prefer_including_props", status) }
            }
            R.id.menu_show_all -> {
                val status = !item.isChecked
                item.isChecked = status
                viewModel.preferShowAll = status
                viewModel.reload()
                preference.edit { putBoolean("prefer_show_all", status) }
            }
            R.id.menu_skip_verify -> {
                val status = !item.isChecked
                item.isChecked = status
                viewModel.preferSkipVerify = status
                viewModel.reload()
            }
            R.id.menu_save -> {
                save.launch("${Build.PRODUCT}-${AppApplication.TAG}.pkipath")
            }
            R.id.menu_load -> {
                load.launch(arrayOf("application/*"))
            }
            R.id.menu_about -> {
                val context = requireContext()
                val versionName = BuildConfig.VERSION_NAME

                val text = StringBuilder()
                text.append(versionName)
                        .append("<p>")
                        .append(getString(R.string.open_source_info, "<b><a href=\"${context.getString(R.string.github_url)}\">GitHub</a></b>", context.getString(R.string.license)))
                text.append("<p>").append(context.getString(R.string.copyright))

                val dialog: Dialog = AlertDialog.Builder(context)
                        .setView(rikka.material.R.layout.dialog_about)
                        .show()
                dialog.findViewById<ImageView>(rikka.material.R.id.design_about_icon).setImageDrawable(context.getDrawable(R.drawable.ic_launcher))
                dialog.findViewById<TextView>(rikka.material.R.id.design_about_title).text = getString(R.string.app_name)
                dialog.findViewById<TextView>(rikka.material.R.id.design_about_version).apply {
                    movementMethod = LinkMovementMethod.getInstance()
                    this.text = text.toHtml(HtmlCompat.FROM_HTML_OPTION_TRIM_WHITESPACE)
                }
                dialog.findViewById<TextView>(rikka.material.R.id.design_about_info).isVisible = false
            }
            else -> return false
        }
        return true
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeItemDecoration.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.content.Context
import android.graphics.Canvas
import android.graphics.Rect
import android.graphics.drawable.Drawable
import android.view.View
import androidx.recyclerview.widget.RecyclerView
import androidx.recyclerview.widget.RecyclerView.ItemDecoration
import rikka.core.res.resolveDrawable
import kotlin.math.roundToInt

class HomeItemDecoration(context: Context) : ItemDecoration() {

    private val drawable: Drawable = context.theme.resolveDrawable(rikka.material.R.attr.outlineButtonBackground)!!
    private val cardMargin: Int = (context.resources.displayMetrics.density * 8).roundToInt()
    private val cardPadding: Int = (context.resources.displayMetrics.density * 8).roundToInt()

    private fun hasTopMargin(@Suppress("UNUSED_PARAMETER") adapter: HomeAdapter, position: Int): Boolean {
        return position == 0
    }

    private fun hasBottomMargin(adapter: HomeAdapter, position: Int): Boolean {
        return position == adapter.itemCount - 1 || !(adapter.allowFrameAt(position) && adapter.allowFrameAt(position + 1) && !adapter.shouldCommitFrameAt(position))
    }

    private fun hasTopPadding(adapter: HomeAdapter, position: Int): Boolean {
        return adapter.allowFrameAt(position) && (position == 0 || adapter.shouldCommitFrameAt(position - 1) || !adapter.allowFrameAt(position - 1))
    }

    private fun hasBottomPadding(adapter: HomeAdapter, position: Int): Boolean {
        return adapter.shouldCommitFrameAt(position)// && (position == adapter.itemCount - 1 || adapter.shouldCommitFrameAt(position))
    }

    override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) {
        val adapter = parent.adapter as HomeAdapter
        val position = parent.getChildAdapterPosition(view)

        if (hasTopMargin(adapter, position)) {
            outRect.top = cardMargin
        }
        if (hasTopPadding(adapter, position)) {
            outRect.top += cardPadding
        }

        if (hasBottomMargin(adapter, position)) {
            outRect.bottom = cardMargin
        }
        if (hasBottomPadding(adapter, position)) {
            outRect.bottom += cardPadding
        }

        outRect.left = cardMargin
        outRect.right = cardMargin
    }

    override fun onDrawOver(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
        if (parent.childCount == 0) {
            return
        }
        val adapter = parent.adapter as HomeAdapter
        var invalidatedPosition = true
        var left = 0
        var top = 0
        var right = 0
        var bottom: Int

        for (i in 0 until parent.childCount) {
            val child = parent.getChildAt(i)
            val position = parent.getChildAdapterPosition(child)

            if (!adapter.allowFrameAt(position)) {
                continue
            }

            if (invalidatedPosition) {
                left = child.left
                top = child.top
                right = child.right
                invalidatedPosition = false
            }

            if ((i == parent.childCount - 1) || adapter.shouldCommitFrameAt(position)) {
                bottom = child.bottom

                drawable.setBounds(left, top - cardPadding, right, bottom + cardPadding)
                drawable.draw(c)

                invalidatedPosition = true
            } else {
                left = child.left.coerceAtLeast(left)
                right = child.right.coerceAtLeast(right)
            }
        }
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.view.View
import androidx.viewbinding.ViewBinding
import io.github.vvb2060.keyattestation.util.ViewBindingViewHolder

abstract class HomeViewHolder<T, VB : ViewBinding>(itemView: View, binding: VB) : ViewBindingViewHolder<T, VB, HomeAdapter.Listener>(itemView, binding)
```

`app/src/main/java/io/github/vvb2060/keyattestation/home/HomeViewModel.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.content.ContentResolver
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.provider.OpenableColumns
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.security.keystore.StrongBoxUnavailableException
import android.util.Log
import android.widget.Toast
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import io.github.vvb2060.keyattestation.AppApplication
import io.github.vvb2060.keyattestation.attestation.Attestation
import io.github.vvb2060.keyattestation.attestation.AttestationResult
import io.github.vvb2060.keyattestation.attestation.VerifyCertificateChain
import io.github.vvb2060.keyattestation.lang.AttestationException
import io.github.vvb2060.keyattestation.lang.AttestationException.Companion.CODE_CANT_PARSE_CERT
import io.github.vvb2060.keyattestation.lang.AttestationException.Companion.CODE_CERT_NOT_TRUSTED
import io.github.vvb2060.keyattestation.lang.AttestationException.Companion.CODE_DEVICEIDS_UNAVAILABLE
import io.github.vvb2060.keyattestation.lang.AttestationException.Companion.CODE_NOT_SUPPORT
import io.github.vvb2060.keyattestation.lang.AttestationException.Companion.CODE_STRONGBOX_UNAVAILABLE
import io.github.vvb2060.keyattestation.lang.AttestationException.Companion.CODE_UNKNOWN
import io.github.vvb2060.keyattestation.util.Resource
import java.io.ByteArrayInputStream
import java.io.IOException
import java.security.GeneralSecurityException
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.ProviderException
import java.security.cert.Certificate
import java.security.cert.CertificateException
import java.security.cert.CertificateFactory
import java.security.cert.CertificateParsingException
import java.security.cert.X509Certificate
import java.security.spec.ECGenParameterSpec
import java.util.Date

class HomeViewModel(pm: PackageManager) : ViewModel() {

    val attestationResult = MutableLiveData<Resource<AttestationResult>>()
    var currentCerts: List<X509Certificate>? = null

    val hasStrongBox = Build.VERSION.SDK_INT >= Build.VERSION_CODES.P &&
            pm.hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE)
    var preferStrongBox = true

    val hasDeviceIds = Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            pm.hasSystemFeature("android.software.device_id_attestation")
    var preferIncludeProps = true

    var preferShowAll = false

    var showSkipVerify = false
    var preferSkipVerify = false

    @Throws(GeneralSecurityException::class)
    private fun generateKey(alias: String, useStrongBox: Boolean, includeProps: Boolean) {
        val keyPairGenerator = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore")
        val now = Date()
        val originationEnd = Date(now.time + 1000000)
        val consumptionEnd = Date(now.time + 2000000)
        val builder = KeyGenParameterSpec.Builder(alias, KeyProperties.PURPOSE_SIGN)
                .setAlgorithmParameterSpec(ECGenParameterSpec("secp256r1"))
                .setKeyValidityStart(now)
                .setKeyValidityForOriginationEnd(originationEnd)
                .setKeyValidityForConsumptionEnd(consumptionEnd)
                .setAttestationChallenge(now.toString().toByteArray())
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S && includeProps) {
            builder.setDevicePropertiesAttestationIncluded(true)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P && useStrongBox) {
            builder.setIsStrongBoxBacked(true)
        }
        builder.setDigests(KeyProperties.DIGEST_NONE, KeyProperties.DIGEST_SHA256)
        keyPairGenerator.initialize(builder.build())
        keyPairGenerator.generateKeyPair()
    }

    @Throws(AttestationException::class)
    private fun parseCertificateChain(certs: List<X509Certificate>): AttestationResult {
        var attestation: Attestation? = null
        var exception: AttestationException? = null
        var isGoogleRootCertificate = VerifyCertificateChain.FAILED
        try {
            isGoogleRootCertificate = VerifyCertificateChain.verifyCertificateChain(certs)
        } catch (e: GeneralSecurityException) {
            showSkipVerify = true
            if (!preferSkipVerify) throw AttestationException(CODE_CERT_NOT_TRUSTED, e)
        }
        // Find first attestation record
        // Never use certs[0], as certificate chain can have arbitrary certificates appended
        for (i in certs.indices.reversed()) {
            try {
                attestation = Attestation.loadFromCertificate(certs[i])
                break
            } catch (e: CertificateParsingException) {
                exception = AttestationException(CODE_CANT_PARSE_CERT, e)
            }
        }
        if (attestation == null) {
            throw exception!!
        }
        return AttestationResult(attestation, isGoogleRootCertificate)
    }

    @Throws(AttestationException::class)
    private fun doAttestation(alias: String, useStrongBox: Boolean, includeProps: Boolean
    ): AttestationResult {
        val certs: List<Certificate>
        try {
            generateKey(alias, useStrongBox, includeProps)
            val keyStore = KeyStore.getInstance("AndroidKeyStore")
            keyStore.load(null)
            val certificates = keyStore.getCertificateChain(alias)
                    ?: throw CertificateException("Unable to get certificate chain")
            certs = ArrayList(certificates.size)
            val cf = CertificateFactory.getInstance("X.509")
            for (i in certificates.indices) {
                val buf = ByteArrayInputStream(certificates[i].encoded)
                certs.add(cf.generateCertificate(buf))
            }
        } catch (e: ProviderException) {
            if (Build.VERSION.SDK_INT >= 28 && e is StrongBoxUnavailableException) {
                throw AttestationException(CODE_STRONGBOX_UNAVAILABLE, e)
            } else if (e.cause?.message?.contains("device ids") == true) {
                // The device does not support device ids attestation
                throw AttestationException(CODE_DEVICEIDS_UNAVAILABLE, e)
            } else {
                // The device does not support key attestation
                throw AttestationException(CODE_NOT_SUPPORT, e)
            }
        } catch (e: Exception) {
            // Unable to get certificate chain
            throw AttestationException(CODE_NOT_SUPPORT, e)
        }
        @Suppress("UNCHECKED_CAST")
        currentCerts = certs as List<X509Certificate>
        return parseCertificateChain(certs)
    }

    fun save(cr: ContentResolver, uri: Uri?) = AppApplication.executor.execute {
        val certs = currentCerts
        if (uri == null || certs == null) return@execute
        var name = uri.toString()
        val projection = arrayOf(OpenableColumns.DISPLAY_NAME)
        cr.query(uri, projection, null, null, null)?.use { cursor ->
            val displayNameColumn = cursor.getColumnIndexOrThrow(OpenableColumns.DISPLAY_NAME)
            if (cursor.moveToFirst()) {
                name = cursor.getString(displayNameColumn)
            }
        }
        try {
            val cf = CertificateFactory.getInstance("X.509")
            cr.openOutputStream(uri)?.use {
                it.write(cf.generateCertPath(certs).encoded)
            } ?: throw IOException("openOutputStream $uri failed")
            AppApplication.mainHandler.post {
                Toast.makeText(AppApplication.app, name, Toast.LENGTH_SHORT).show()
            }
        } catch (e: Exception) {
            Log.e(AppApplication.TAG, "saveCerts: ", e)
        }
    }

    fun load(cr: ContentResolver, uri: Uri?) = AppApplication.executor.execute {
        if (uri == null) return@execute
        currentCerts = null
        attestationResult.postValue(Resource.loading(null))

        val result = try {
            val cf = CertificateFactory.getInstance("X.509")
            cr.openInputStream(uri).use {
                @Suppress("UNCHECKED_CAST")
                val certs = cf.generateCertPath(it).certificates as List<X509Certificate>
                if (certs.isEmpty()) throw CertificateParsingException("No certificate found")
                currentCerts = certs
                val attestationResult = parseCertificateChain(certs)
                Resource.success(attestationResult)
            }
        } catch (e: Throwable) {
            val cause = if (e is AttestationException) e.cause!! else e
            Log.w(AppApplication.TAG, "Load attestation error.", cause)

            when (e) {
                is AttestationException -> Resource.error(e, null)
                is CertificateException -> Resource.error(AttestationException(CODE_CANT_PARSE_CERT, e), null)
                else -> Resource.error(AttestationException(CODE_UNKNOWN, e), null)
            }
        }

        attestationResult.postValue(result)
    }

    fun load() = AppApplication.executor.execute {
        currentCerts = null
        attestationResult.postValue(Resource.loading(null))

        val useStrongBox = hasStrongBox && preferStrongBox
        val includeProps = hasDeviceIds && preferIncludeProps
        val result = try {
            val alias = "Key_${useStrongBox}_$includeProps"
            val attestationResult = doAttestation(alias, useStrongBox, includeProps)
            Resource.success(attestationResult)
        } catch (e: Throwable) {
            val cause = if (e is AttestationException) e.cause!! else e
            Log.w(AppApplication.TAG, "Do attestation error.", cause)

            when (e) {
                is AttestationException -> Resource.error(e, null)
                else -> Resource.error(AttestationException(CODE_UNKNOWN, e), null)
            }
        }

        attestationResult.postValue(result)
    }

    fun reload() = AppApplication.executor.execute {
        val certs = currentCerts ?: return@execute
        attestationResult.postValue(Resource.loading(null))

        val result = try {
            val attestationResult = parseCertificateChain(certs)
            Resource.success(attestationResult)
        } catch (e: Throwable) {
            val cause = if (e is AttestationException) e.cause!! else e
            Log.w(AppApplication.TAG, "Reload attestation error.", cause)

            when (e) {
                is AttestationException -> Resource.error(e, null)
                else -> Resource.error(AttestationException(CODE_UNKNOWN, e), null)
            }
        }

        attestationResult.postValue(result)
    }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/home/SubtitleViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.home

import android.view.View
import io.github.vvb2060.keyattestation.databinding.HomeSubtitleBinding
import rikka.recyclerview.BaseViewHolder.Creator

class SubtitleViewHolder(itemView: View, binding: HomeSubtitleBinding) : HomeViewHolder<SubtitleData, HomeSubtitleBinding>(itemView, binding) {

    companion object {

        val CREATOR = Creator<SubtitleData> { inflater, parent ->
            val binding = HomeSubtitleBinding.inflate(inflater, parent, false)
            SubtitleViewHolder(binding.root, binding)
        }
    }

    init {
        itemView.setOnClickListener {
            listener.onSubtitleDataClick(data)
        }
    }

    override fun onBind() {
        binding.title.setText(data.title)
    }
}
```

`app/src/main/java/io/github/vvb2060/keyattestation/ktx/String.kt`:

```kt
package io.github.vvb2060.keyattestation.ktx

import android.text.Spanned
import rikka.html.text.HtmlCompat

fun CharSequence.toHtml(flags: Int = 0): Spanned {
    return HtmlCompat.fromHtml(this.toString(), flags)
}

fun CharSequence.toHtml(tagHandler: HtmlCompat.TagHandler): Spanned {
    return HtmlCompat.fromHtml(this.toString(), null, tagHandler)
}

fun CharSequence.toHtml(flags: Int, tagHandler: HtmlCompat.TagHandler): Spanned {
    return HtmlCompat.fromHtml(this.toString(), flags, null, tagHandler)
}
```

`app/src/main/java/io/github/vvb2060/keyattestation/ktx/ViewModelLazy.kt`:

```kt
package io.github.vvb2060.keyattestation.ktx

import androidx.activity.ComponentActivity
import androidx.annotation.MainThread
import androidx.fragment.app.Fragment
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.ViewModelStore
import androidx.lifecycle.ViewModelStoreOwner

@MainThread
inline fun <reified VM : ViewModel> ComponentActivity.viewModels(
        noinline viewModelProducer: () -> VM
) = ViewModelLazy(
        { viewModelStore },
        viewModelProducer
)

inline fun <reified VM : ViewModel> Fragment.activityViewModels(
        noinline viewModelProducer: () -> VM
) = viewModels(::requireActivity, viewModelProducer)

@MainThread
inline fun <reified VM : ViewModel> Fragment.viewModels(
        noinline ownerProducer: () -> ViewModelStoreOwner = { this },
        noinline viewModelProducer: () -> VM
) = ViewModelLazy(
        { ownerProducer().viewModelStore },
        viewModelProducer
)

class ViewModelLazy<VM : ViewModel>(
        private val storeProducer: () -> ViewModelStore,
        private val viewModelProducer: () -> VM
) : Lazy<VM> {
    private var cached: VM? = null

    @Suppress("UNCHECKED_CAST")
    override val value: VM
        get() {
            val viewModel = cached
            return (if (viewModel == null) {
                val store = storeProducer()
                ViewModelProvider(store, object : ViewModelProvider.Factory {
                    override fun <T : ViewModel> create(modelClass: Class<T>): T {
                        return viewModelProducer() as T
                    }

                }).get(ViewModel::class.java).also {
                    cached = it as VM
                }
            } else {
                viewModel
            }) as VM
        }

    override fun isInitialized() = cached != null
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/lang/AttestationException.kt`:

```kt
package io.github.vvb2060.keyattestation.lang

import io.github.vvb2060.keyattestation.R

class AttestationException(private val code: Int, cause: Throwable?) : RuntimeException(cause) {

    companion object {
        const val CODE_UNKNOWN = -1
        const val CODE_NOT_SUPPORT = 0
        const val CODE_CERT_NOT_TRUSTED = 1
        const val CODE_CANT_PARSE_CERT = 2
        const val CODE_STRONGBOX_UNAVAILABLE = 3
        const val CODE_DEVICEIDS_UNAVAILABLE = 4
    }

    val titleResId: Int
        get() {
            return when (code) {
                CODE_NOT_SUPPORT -> {
                    R.string.error_not_support
                }
                CODE_CERT_NOT_TRUSTED -> {
                    R.string.error_cert_not_trusted
                }
                CODE_CANT_PARSE_CERT -> {
                    R.string.error_cant_parse_cert
                }
                CODE_STRONGBOX_UNAVAILABLE -> {
                    R.string.error_strongbox_unavailable
                }
                CODE_DEVICEIDS_UNAVAILABLE -> {
                    R.string.error_unable_attest_deviceids
                }
                else -> {
                    R.string.error_unknown
                }
            }
        }

    val descriptionResId: Int
        get() {
            return when (code) {
                CODE_NOT_SUPPORT -> {
                    R.string.error_not_support_summary
                }
                CODE_CERT_NOT_TRUSTED -> {
                    R.string.error_cert_not_trusted_summary
                }
                CODE_CANT_PARSE_CERT -> {
                    R.string.error_cant_parse_cert_summary
                }
                CODE_STRONGBOX_UNAVAILABLE -> {
                    R.string.error_strongbox_unavailable_summary
                }
                CODE_DEVICEIDS_UNAVAILABLE -> {
                    R.string.error_unable_attest_deviceids_summary
                }
                else -> {
                    R.string.error_unknown
                }
            }
        }
}

```

`app/src/main/java/io/github/vvb2060/keyattestation/util/Resource.kt`:

```kt
package io.github.vvb2060.keyattestation.util

/**
 * A generic class that holds a value with its loading status.
 * @param <T>
</T> */
open class Resource<out T>(val status: Status, val data: T?, val error: Throwable) {

    companion object {
        private val noError = Throwable("No error")

        fun <T> success(data: T?): Resource<T> {
            return Resource(Status.SUCCESS, data, noError)
        }

        fun <T> error(error: Throwable, data: T?): Resource<T> {
            return Resource(Status.ERROR, data, error)
        }

        fun <T> loading(data: T?): Resource<T> {
            return Resource(Status.LOADING, data, noError)
        }
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Resource<*>

        if (status != other.status) return false
        if (data != other.data) return false
        if (error != other.error) return false

        return true
    }

    override fun hashCode(): Int {
        var result = status.hashCode()
        result = 31 * result + (data?.hashCode() ?: 0)
        result = 31 * result + error.hashCode()
        return result
    }
}

enum class Status {
    SUCCESS,
    ERROR,
    LOADING
}

class SourcedResource<out T, out S>(status: Status, data: T?, error: Throwable, val source: S?) : Resource<T>(status, data, error) {

    companion object {
        private val noError = Throwable("No error")

        fun <T, S> success(data: T?, source: S?): SourcedResource<T, S> {
            return SourcedResource(Status.SUCCESS, data, noError, source)
        }

        fun <T, S> error(error: Throwable, data: T?, source: S?): SourcedResource<T, S> {
            return SourcedResource(Status.ERROR, data, error, source)
        }

        fun <T, S> loading(data: T?, source: S?): SourcedResource<T, S> {
            return SourcedResource(Status.LOADING, data, noError, source)
        }
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false
        if (!super.equals(other)) return false

        other as SourcedResource<*, *>

        if (source != other.source) return false
        return true
    }

    override fun hashCode(): Int {
        var result = super.hashCode()
        result = 31 * result + (source?.hashCode() ?: 0)
        return result
    }
}
```

`app/src/main/java/io/github/vvb2060/keyattestation/util/ViewBindingViewHolder.kt`:

```kt
package io.github.vvb2060.keyattestation.util

import android.view.View
import androidx.viewbinding.ViewBinding
import rikka.recyclerview.BaseListenerViewHolder

open class ViewBindingViewHolder<T, VB : ViewBinding, L>(itemView: View, internal val binding: VB) : BaseListenerViewHolder<T, L>(itemView)

```

`app/src/main/res/color/material_on_surface_emphasis_high_type.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:alpha="0.88" android:color="?attr/colorOnSurface" />
</selector>

```

`app/src/main/res/color/material_on_surface_emphasis_medium.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:alpha="0.75" android:color="?attr/colorOnSurface" />
</selector>

```

`app/src/main/res/color/mtrl_popupmenu_overlay_color.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:alpha="0.08" android:color="?attr/elevationOverlayColor" />
</selector>
```

`app/src/main/res/drawable-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@mipmap/ic_key_attestation_background" />
    <foreground android:drawable="@mipmap/ic_key_attestation_foreground" />
</adaptive-icon>
```

`app/src/main/res/drawable/home_item_background_solid.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape android:shape="rectangle"
    xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@android:color/white" />
    <corners android:radius="4dp" />
</shape>
```

`app/src/main/res/drawable/ic_boot_locked_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorControlNormal"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M18,8h-1L17,6c0,-2.76 -2.24,-5 -5,-5S7,3.24 7,6v2L6,8c-1.1,0 -2,0.9 -2,2v10c0,1.1 0.9,2 2,2h12c1.1,0 2,-0.9 2,-2L20,10c0,-1.1 -0.9,-2 -2,-2zM9,6c0,-1.66 1.34,-3 3,-3s3,1.34 3,3v2L9,8L9,6zM18,19c0,0.55 -0.45,1 -1,1L7,20c-0.55,0 -1,-0.45 -1,-1v-8c0,-0.55 0.45,-1 1,-1h10c0.55,0 1,0.45 1,1v8zM12,17c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9 -2,2 0.9,2 2,2z" />
</vector>

```

`app/src/main/res/drawable/ic_boot_unknown_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM11,16h2v2h-2zM12.61,6.04c-2.06,-0.3 -3.88,0.97 -4.43,2.79 -0.18,0.58 0.26,1.17 0.87,1.17h0.2c0.41,0 0.74,-0.29 0.88,-0.67 0.32,-0.89 1.27,-1.5 2.3,-1.28 0.95,0.2 1.65,1.13 1.57,2.1 -0.1,1.34 -1.62,1.63 -2.45,2.88 0,0.01 -0.01,0.01 -0.01,0.02 -0.01,0.02 -0.02,0.03 -0.03,0.05 -0.09,0.15 -0.18,0.32 -0.25,0.5 -0.01,0.03 -0.03,0.05 -0.04,0.08 -0.01,0.02 -0.01,0.04 -0.02,0.07 -0.12,0.34 -0.2,0.75 -0.2,1.25h2c0,-0.42 0.11,-0.77 0.28,-1.07 0.02,-0.03 0.03,-0.06 0.05,-0.09 0.08,-0.14 0.18,-0.27 0.28,-0.39 0.01,-0.01 0.02,-0.03 0.03,-0.04 0.1,-0.12 0.21,-0.23 0.33,-0.34 0.96,-0.91 2.26,-1.65 1.99,-3.56 -0.24,-1.74 -1.61,-3.21 -3.35,-3.47z" />
</vector>

```

`app/src/main/res/drawable/ic_boot_unlocked_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,13c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2zM18,8h-1L17,6c0,-2.76 -2.24,-5 -5,-5 -2.28,0 -4.27,1.54 -4.84,3.75 -0.14,0.54 0.18,1.08 0.72,1.22 0.53,0.14 1.08,-0.18 1.22,-0.72C9.44,3.93 10.63,3 12,3c1.65,0 3,1.35 3,3v2L6,8c-1.1,0 -2,0.9 -2,2v10c0,1.1 0.9,2 2,2h12c1.1,0 2,-0.9 2,-2L20,10c0,-1.1 -0.9,-2 -2,-2zM18,19c0,0.55 -0.45,1 -1,1L7,20c-0.55,0 -1,-0.45 -1,-1v-8c0,-0.55 0.45,-1 1,-1h10c0.55,0 1,0.45 1,1v8z" />
</vector>

```

`app/src/main/res/drawable/ic_error_outline_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,7c0.55,0 1,0.45 1,1v4c0,0.55 -0.45,1 -1,1s-1,-0.45 -1,-1L11,8c0,-0.55 0.45,-1 1,-1zM11.99,2C6.47,2 2,6.48 2,12s4.47,10 9.99,10C17.52,22 22,17.52 22,12S17.52,2 11.99,2zM12,20c-4.42,0 -8,-3.58 -8,-8s3.58,-8 8,-8 8,3.58 8,8 -3.58,8 -8,8zM13,17h-2v-2h2v2z" />
</vector>

```

`app/src/main/res/drawable/ic_help_outline_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM11,16h2v2h-2zM12.61,6.04c-2.06,-0.3 -3.88,0.97 -4.43,2.79 -0.18,0.58 0.26,1.17 0.87,1.17h0.2c0.41,0 0.74,-0.29 0.88,-0.67 0.32,-0.89 1.27,-1.5 2.3,-1.28 0.95,0.2 1.65,1.13 1.57,2.1 -0.1,1.34 -1.62,1.63 -2.45,2.88 0,0.01 -0.01,0.01 -0.01,0.02 -0.01,0.02 -0.02,0.03 -0.03,0.05 -0.09,0.15 -0.18,0.32 -0.25,0.5 -0.01,0.03 -0.03,0.05 -0.04,0.08 -0.01,0.02 -0.01,0.04 -0.02,0.07 -0.12,0.34 -0.2,0.75 -0.2,1.25h2c0,-0.42 0.11,-0.77 0.28,-1.07 0.02,-0.03 0.03,-0.06 0.05,-0.09 0.08,-0.14 0.18,-0.27 0.28,-0.39 0.01,-0.01 0.02,-0.03 0.03,-0.04 0.1,-0.12 0.21,-0.23 0.33,-0.34 0.96,-0.91 2.26,-1.65 1.99,-3.56 -0.24,-1.74 -1.61,-3.21 -3.35,-3.47z" />
</vector>

```

`app/src/main/res/drawable/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<bitmap xmlns:android="http://schemas.android.com/apk/res/android"
    android:src="@mipmap/ic_key_attestation" />
```

`app/src/main/res/drawable/ic_trustworthy_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,1L3,5v6c0,5.55 3.84,10.74 9,12 5.16,-1.26 9,-6.45 9,-12L21,5l-9,-4zM19,11c0,4.52 -2.98,8.69 -7,9.93 -4.02,-1.24 -7,-5.41 -7,-9.93L5,6.3l7,-3.11 7,3.11L19,11zM7.41,11.59L6,13l4,4 8,-8 -1.41,-1.42L10,14.17z" />
</vector>

```

`app/src/main/res/drawable/ic_untrustworthy_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,11C21,16.55 17.16,21.74 12,23C6.84,21.74 3,16.55 3,11V5L12,1L21,5V11M12,21C15.75,20 19,15.54 19,11.22V6.3L12,3.18L5,6.3V11.22C5,15.54 8.25,20 12,21M11,7H13V13H11V7M11,15H13V17H11V15Z" />
</vector>

```

`app/src/main/res/drawable/ic_warning_24.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M4.47,21h15.06c1.54,0 2.5,-1.67 1.73,-3L13.73,4.99c-0.77,-1.33 -2.69,-1.33 -3.46,0L2.74,18c-0.77,1.33 0.19,3 1.73,3zM12,14c-0.55,0 -1,-0.45 -1,-1v-2c0,-0.55 0.45,-1 1,-1s1,0.45 1,1v2c0,0.55 -0.45,1 -1,1zM13,18h-2v-2h2v2z" />
</vector>

```

`app/src/main/res/layout/appbar.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<rikka.material.widget.AppBarLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/toolbar_container"
    style="?appBarStyle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:fitsSystemWindows="true"
    tools:viewBindingIgnore="true">

    <androidx.appcompat.widget.Toolbar
        android:id="@+id/toolbar"
        style="?actionBarStyle"
        android:layout_width="match_parent"
        android:layout_height="?actionBarSize"
        android:layout_gravity="bottom"
        android:layout_marginTop="0dp"
        android:background="@null"
        android:elevation="0dp"
        android:gravity="center_vertical"
        android:paddingTop="0dp"
        android:paddingBottom="0dp"
        app:subtitleTextAppearance="@android:style/TextAppearance.Material.Widget.Toolbar.Subtitle"
        app:titleTextAppearance="@android:style/TextAppearance.Material.Widget.Toolbar.Title"
        tools:text="Title" />

</rikka.material.widget.AppBarLayout>
```

`app/src/main/res/layout/appbar_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/root"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="false"
    app:consumeSystemWindowsInsets="start|end"
    app:edgeToEdge="true"
    app:fitsSystemWindowsInsets="start|end"
    tools:viewBindingIgnore="true">

    <include layout="@layout/appbar" />

</FrameLayout>

```

`app/src/main/res/layout/appbar_fragment_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/root"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="false"
    app:consumeSystemWindowsInsets="start|end"
    app:edgeToEdge="true"
    app:fitsSystemWindowsInsets="start|end"
    tools:viewBindingIgnore="true">

    <FrameLayout
        android:id="@+id/fragment_container"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <include layout="@layout/appbar" />

</FrameLayout>

```

`app/src/main/res/layout/home.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_marginStart="@dimen/rd_activity_horizontal_margin"
    android:layout_marginEnd="@dimen/rd_activity_horizontal_margin"
    android:paddingStart="@dimen/home_padding"
    android:paddingEnd="@dimen/home_padding"
    android:animateLayoutChanges="true">

    <rikka.widget.borderview.BorderRecyclerView
        android:id="@+id/list"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false"
        android:paddingTop="?actionBarSize"
        android:scrollbarStyle="insideOverlay"
        android:scrollbars="vertical"
        android:visibility="gone"
        app:borderBottomVisibility="never"
        app:borderTopDrawable="@null"
        app:borderTopVisibility="whenTop"
        app:fitsSystemWindowsInsets="top|bottom"
        app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
        tools:listitem="@layout/home_header"
        tools:visibility="visible" />

    <ProgressBar
        android:id="@+id/progress"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        app:layout_fitsSystemWindowsInsets="top|bottom" />

</FrameLayout>

```

`app/src/main/res/layout/home_boot_state.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/title"
    style="@style/HomeCardStyle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/home_item_background_solid"
    android:backgroundTintMode="src_in"
    android:drawablePadding="24dp"
    android:drawableTint="?android:textColorPrimaryInverse"
    android:drawableTintMode="src_in"
    android:gravity="center_vertical"
    android:textAppearance="?textAppearanceSubtitle2"
    android:textColor="?android:textColorPrimaryInverse"
    android:textSize="16sp"
    tools:backgroundTint="?colorSafe"
    tools:drawableStart="@drawable/ic_boot_locked_24"
    tools:text="@string/bootloader_locked" />

```

`app/src/main/res/layout/home_common_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@android:id/content"
    style="@style/HomeCardStyle"
    android:background="?android:selectableItemBackground"
    android:gravity="center_vertical"
    android:orientation="horizontal">

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginEnd="16dp"
        android:layout_weight="1"
        android:orientation="vertical">

        <TextView
            android:id="@+id/title"
            style="@style/HomeItemTitleText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            tools:text="title" />

        <TextView
            android:id="@+id/summary"
            style="@style/HomeItemSummaryText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            tools:text="summary" />

    </LinearLayout>

    <ImageView
        android:id="@+id/icon"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="-4dp"
        android:background="?android:selectableItemBackgroundBorderless"
        android:importantForAccessibility="no"
        android:padding="4dp"
        android:tintMode="src_in"
        tools:src="@drawable/ic_trustworthy_24"
        tools:tint="?colorSafe" />

    <TextView
        android:id="@+id/text1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="@null"
        android:fontFamily="sans-serif"
        android:letterSpacing="0"
        android:minWidth="0dp"
        android:textColor="?colorAccent"
        android:textStyle="bold"
        tools:text="SW" />

</LinearLayout>

```

`app/src/main/res/layout/home_error.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    style="@style/HomeCardStyle"
    android:orientation="horizontal">

    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/ic_help_outline_24" />

    <TextView
        android:id="@+id/text1"
        style="@style/HomeItemSummaryText"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginStart="24dp"
        android:gravity="center_vertical"
        android:textIsSelectable="true"
        android:minHeight="24dp"
        tools:text="text" />

</LinearLayout>

```

`app/src/main/res/layout/home_header.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    style="@style/HomeCardStyle"
    android:background="@drawable/home_item_background_solid"
    android:backgroundTintMode="src_in"
    android:gravity="center_vertical"
    android:orientation="horizontal"
    tools:backgroundTint="?colorAlert">

    <ImageView
        android:id="@+id/icon"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:importantForAccessibility="no"
        android:tint="?android:textColorPrimaryInverse"
        android:tintMode="src_in"
        tools:src="@drawable/ic_error_outline_24" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginStart="24dp"
        android:orientation="vertical">

        <TextView
            android:id="@+id/title"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center_vertical"
            android:textAppearance="?textAppearanceSubtitle2"
            android:textColor="?android:textColorPrimaryInverse"
            android:textSize="16sp"
            tools:text="@string/error_strongbox_unavailable" />

        <TextView
            android:id="@+id/summary"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center_vertical"
            android:textAppearance="?textAppearanceBody2"
            android:textColor="?android:textColorPrimaryInverse"
            android:textSize="14sp"
            tools:text="@string/error_strongbox_unavailable_summary" />

    </LinearLayout>

</LinearLayout>

```

`app/src/main/res/layout/home_subtitle.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/title"
    style="@style/HomeCardStyle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="?android:selectableItemBackground"
    android:gravity="bottom"
    android:textAppearance="?textAppearanceSubtitle2"
    android:textColor="?colorAccent"
    tools:text="@string/app_name" />

```

`app/src/main/res/menu/home.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/menu_use_strongbox"
        android:showAsAction="never"
        android:checkable="true"
        android:title="@string/use_strongbox" />

    <item
        android:id="@+id/menu_incluid_props"
        android:showAsAction="never"
        android:checkable="true"
        android:title="@string/attest_device_props" />

    <item
        android:id="@+id/menu_show_all"
        android:showAsAction="never"
        android:checkable="true"
        android:title="@string/show_all" />

    <item
        android:id="@+id/menu_skip_verify"
        android:showAsAction="never"
        android:checkable="true"
        android:title="@string/skip_verify" />

    <item
        android:id="@+id/menu_save"
        android:showAsAction="never"
        android:title="@string/save_certs" />

    <item
        android:id="@+id/menu_load"
        android:showAsAction="never"
        android:title="@string/load_certs" />

    <item
        android:id="@+id/menu_about"
        android:showAsAction="never"
        android:title="@string/about" />

</menu>

```

`app/src/main/res/raw/status.json`:

```json
{
  "entries": {
    "6681152659205225093" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8350192447815228107" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9408173275444922801" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "11244410301401252959" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "15346629759498347257" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1228286566665971148" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "17471682139930361099" : {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    },
    "1545991490585406285": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "16799496319142405818": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2621004353020741590": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1051246719628187981": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c35747a084470c3135aeefe2b8d40cd6": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ee3ac673107ddf0831027a84c532bee4": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1f4363f4acefdf83ae59202b934cead9": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "633d72164968d2b7ec1a927a14c8efbe": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f3a6cc97099ae7311ca7d1c55625a9e2": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c360da616de6583ae816cdefdda66221": {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1476c32be5b4788386062ca1d6a3ec01" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c9b95f08cb46c66e778a996bb04eb063" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "1f4363f4acefdf83ae59202b934cead9" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "ee3ac673107ddf0831027a84c532bee4" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "633d72164968d2b7ec1a927a14c8efbe" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c35747a084470c3135aeefe2b8d40cd6" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2775678662643671941" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "10478051501886118140" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "15304424745846567057" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2540354691047989632" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9605027729693255932" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "7266970422002561562" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "2121480040206509646" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "4722071905782261079" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "13791718860221210775" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "5318853256439367328" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "16619986970074733637" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "8090691296252605665" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9422579570321443809" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "14441488828221950432" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "cfd09f492467a8d78f3c87f8ae82b0ed" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "843184b4161e8dfbb711061d3483ad81" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "f2e14b3039c35d54fb9661b60b17ec94" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "836d1498921ff86a22fe3768042849a2" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c95180267ba53a50b636e36d32976065" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "9414602a0ce3f77d9ac05af532785ef" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "c21b00ddf8c5a26106a03e8c11b37998" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "d9e9fa3c6021bcca273b524f551feab9" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "6a0c9ef31f814ebb8d8301eb443f7940" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "78d6b0810af9e6897b62ef2e26a853d2" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "e8063fd19d678b46998c5d25bf6bcd2" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "a23891b8cf1e06bea42599aecd9bc9cf" : {
      "status": "REVOKED",
      "reason": "KEY_COMPROMISE"
    },
    "fc609574570c3e0a1d347e02a2ad6d4d" : {
      "status": "REVOKED",
      "reason": "SOFTWARE_FLAW"
    }
  }
}

```

`app/src/main/res/values-sw600dp/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <dimen name="home_padding">8dp</dimen>
</resources>
```

`app/src/main/res/values-zh-rCN/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">密钥认证</string>
    <string name="use_strongbox">使用 StrongBox</string>
    <string name="attest_device_props">认证设备属性</string>
    <string name="show_all">显示全部</string>
    <string name="skip_verify">跳过验证证书链</string>
    <string name="load_certs">从文件加载</string>
    <string name="save_certs">保存到文件</string>
    <string name="about">关于</string>
    <string name="open_source_info"><![CDATA[
此软件是 %2$s 下的开源软件（%1$s）。
    ]]></string>

    <string name="bootloader_locked">Bootloader 已锁定</string>
    <string name="bootloader_user">信任根由用户设置</string>
    <string name="bootloader_unlocked">Bootloader 已解锁</string>
    <string name="bootloader_unknown">Bootloader 状态未知</string>
    <string name="bootloader_summary_sw_level">该设备不支持硬件级别的密钥认证。</string>
    <string name="unknown_root_cert">未知的根证书</string>
    <string name="unknown_root_cert_summary">根证书不受信任，可能由厂商自签名。</string>
    <string name="aosp_root_cert">来自AOSP的根证书</string>
    <string name="aosp_root_cert_summary">根证书的私钥众所周知，认证结果可以被篡改。</string>

    <string name="error_message_subtitle">详细信息：</string>
    <string name="error_unknown">未知错误</string>
    <string name="error_not_support">该设备不支持密钥认证</string>
    <string name="error_not_support_summary"><![CDATA[
    该设备未实现密钥认证功能，或设备的安全环境已损坏。<br>处理方法：咨询该设备的制造商，是否支持密钥认证功能以及安全环境损坏条件，例如解锁 Bootloader。
    ]]></string>
    <string name="error_cert_not_trusted">证书不受信任</string>
    <string name="error_cert_not_trusted_summary"><![CDATA[
    证书链中有证书已过期、被吊销或无法通过签名验证。
    ]]></string>
    <string name="error_cant_parse_cert">无法解析证书</string>
    <string name="error_cant_parse_cert_summary"><![CDATA[
    证书格式错误或存在尚未支持的功能。
    ]]></string>
    <string name="error_strongbox_unavailable">StrongBox 不可用</string>
    <string name="error_strongbox_unavailable_summary"><![CDATA[
    该设备声明具有 StrongBox 支持，但实际上不可用。
    ]]></string>
    <string name="error_unable_attest_deviceids">无法认证设备 ID</string>
    <string name="error_unable_attest_deviceids_summary"><![CDATA[
    该设备声明支持 ID 认证，但 ID 不匹配或设备已无法再证明其 ID。
    ]]></string>

    <string name="attestation_version_description"><![CDATA[<font face="sans-serif-medium">版本：</font><br>密钥认证功能的版本。]]></string>
    <string name="keymaster_version_description"><![CDATA[<font face="sans-serif-medium">版本：</font><br>Keymaster 硬件抽象层 (HAL) 的版本。使用 0 表示版本 0.2 或 0.3，使用 1 表示版本 1.0，使用 2 表示版本 2.0。]]></string>
    <string name="security_level_description"><![CDATA[<font face="sans-serif-medium">安全等级：</font><br>表示功能受保护的程度基于其在设备中的位置。<p><ul><li gap="8sp"><font face="sans-serif-medium">Software</font><br>在 Android 系统中实现。此位置没有 TEE 安全，但比应用的进程空间安全，能抵御针对应用的攻击。</li><li gap="8sp"><font face="sans-serif-medium">TrustedEnvironment</font><br>在安全硬件中实现，例如 TEE（Trusted Execution Environment，受信任的执行环境），能抵御远程攻击。</li><li gap="8sp"><font face="sans-serif-medium">StrongBox</font><br>在专用的硬件安全模块中实现，能抵御远程攻击和针对模块的硬件攻击。</li></ul>]]></string>
    <string name="attestation_summary_format">版本：%1$s\n安全等级：%2$s</string>
    <string name="attestation_challenge_description"><![CDATA[质询值的目的是使依赖方能够验证是否已响应特定请求创建了密钥。<p>在生产环境中，质询值应每次都随机生成。]]></string>
    <string name="unique_id_description"><![CDATA[此值用于标识设备，但只能在限定时间段内使用。此值通过计算得出，而且只能由系统应用使用。在所有其他应用中，uniqueId 为空。]]></string>

    <string name="empty">（空）</string>

    <string name="sw_enforced" translatable="false">SW</string>
    <string name="sw_enforced_description"><![CDATA[此项目由 Android 系统（而非设备的 TEE）强制执行。]]></string>
    <string name="tee_enforced" translatable="false">TEE</string>
    <string name="tee_enforced_description"><![CDATA[此项目由设备的 TEE 强制执行。]]></string>

    <string name="authorization_list_description"><![CDATA[
    此数据结构包含密钥对的属性本身，如 Keymaster 硬件抽象层 (HAL) 中所定义。<p>应用开发者将这些值与设备的当前状态或一组预期值进行比较，以验证密钥对是否仍适用。
    ]]></string>
    <string name="authorization_list_purpose_description"><![CDATA[
    用于指定相应密钥可用于哪些目的。
    ]]></string>
    <string name="authorization_list_algorithm_description"><![CDATA[
    用于指定与相应密钥配合使用的加密算法。在认证 AuthorizationList 对象中，算法值始终为 RSA 或 EC。
    ]]></string>
    <string name="authorization_list_keySize_description"><![CDATA[
    用于指定相应密钥的大小（以位数计，按适用于相应密钥算法的一般方式衡量）。
    ]]></string>
    <string name="authorization_list_digest_description"><![CDATA[
    用于指定可与相应密钥配合使用以执行签名和验证操作的摘要算法。此标记与 RSA 密钥、ECDSA 密钥和 HMAC 密钥有关。
    ]]></string>
    <string name="authorization_list_padding_description"><![CDATA[
    用于指定可与相应密钥配合使用的填充模式。此标记与 RSA 密钥和 AES 密钥有关。
    ]]></string>
    <string name="authorization_list_ecCurve_description"><![CDATA[
    用于生成椭圆曲线 (EC) 密钥对的参数集，该参数集在 Android 系统密钥库中使用 ECDSA 进行签名和验证。
    ]]></string>
    <string name="authorization_list_rsaPublicExponent_description"><![CDATA[
    用于为 RSA 密钥对指定公开指数的值。此标记仅与 RSA 密钥有关，而且是所有 RSA 密钥都必需的标记。
    ]]></string>
    <string name="authorization_list_rollbackResistance_description"><![CDATA[
    用于表明密钥可抗回滚，也就是说，当通过 deleteKey 或 deleteAllKeys 删除密钥后，可保证该密钥已被永久删除且无法再使用。如果密钥不带此标记，那么在被删除后，可能能够从备份中恢复。
    ]]></string>
    <string name="authorization_list_activeDateTime_description"><![CDATA[
    用于指定相应密钥变为有效状态的日期和时间。
    ]]></string>
    <string name="authorization_list_originationExpireDateTime_description"><![CDATA[
    用于指定相应密钥无法再用于签名和加密目的的过期日期和时间。
    ]]></string>
    <string name="authorization_list_usageExpireDateTime_description"><![CDATA[
    用于指定相应密钥无法再用于验证和解密目的的过期日期和时间。
    ]]></string>
    <string name="authorization_list_noAuthRequired_description"><![CDATA[
    用于指定无需进行身份验证即可使用相应密钥。
    ]]></string>
    <string name="authorization_list_userAuthType_description"><![CDATA[
    用于指定可以使用哪些类型的用户身份验证程序来授权使用相应密钥。
    ]]></string>
    <string name="authorization_list_authTimeout_description"><![CDATA[
    用于指定授权在多长时间内使用相应密钥（以秒数计，从通过身份验证开始算起）。
    ]]></string>
    <string name="authorization_list_allowWhileOnBody_description"><![CDATA[
    此标记仅适用于配备贴身传感器的 Android Wear 设备。目前，TEE 并不能提供对贴身传感器的安全访问，贴身传感器也不是非常安全，因此这应该是一项完全由软件强制执行的功能。
    ]]></string>
    <string name="authorization_list_trustedUserPresenceRequired_description"><![CDATA[
    指定仅在用户提供了物理存在证明时，此密钥才可用。
    ]]></string>
    <string name="authorization_list_trustedConfirmationRequired_description"><![CDATA[
    指定仅在用户确认使用审批令牌签署数据时，此密钥才可用。
    ]]></string>
    <string name="authorization_list_unlockedDeviceRequired_description"><![CDATA[
    要求解锁设备屏幕后才能使用该密钥。
    ]]></string>
    <string name="authorization_list_allApplications_description"><![CDATA[
    指示设备上的所有应用是否都可以访问密钥对。
    ]]></string>
    <string name="authorization_list_applicationId_description"><![CDATA[
    将此标记提供给 generateKey 或 importKey 后，此标记用于指定使用相应密钥时均须提供的数据。
    ]]></string>
    <string name="authorization_list_creationDateTime_description"><![CDATA[
    用于指定相应密钥的创建日期和时间（以距 1970 年 1 月 1 日的毫秒数计）。此标记为可选标记，仅供参考。
    ]]></string>
    <string name="authorization_list_origin_description"><![CDATA[
    用于指定相应密钥是在哪里创建的（如果知道）。在生成或导入密钥期间可以不指定此标记，但此标记必须要由 Trustlet 添加到密钥特性中。
    ]]></string>
    <string name="authorization_list_rollbackResistant_description"><![CDATA[
    用于表明密钥可抗回滚，也就是说，当通过 deleteKey 或 deleteAllKeys 删除密钥后，可保证该密钥已被永久删除且无法再使用。如果密钥不带此标记，那么在被删除后，可能能够从备份中恢复。
    ]]></string>
    <string name="authorization_list_rootOfTrust_description"><![CDATA[
    这个值集合可以定义与设备状态有关的密钥信息。
    ]]></string>
    <string name="authorization_list_osVersion_description"><![CDATA[
    与 Keymaster 关联的 Android 操作系统的版本，使用一个 6 位整数表示。例如，版本 8.1.0 表示为 080100。
    ]]></string>
    <string name="authorization_list_osPatchLevel_description"><![CDATA[
    与 Keymaster 中使用的安全补丁程序关联的月份和年度，使用一个 6 位整数表示。例如，2018 年 8 月的补丁程序表示为 201808。
    ]]></string>
    <string name="authorization_list_attestationApplicationId_description"><![CDATA[
    此数据结构反映了 Android 平台对于允许哪些应用使用认证中的密钥材料的观点。当且仅当多个软件包共享同一 UID 时，此 ID 才可以包含多个软件包。
    ]]></string>
    <string name="authorization_list_attestationIdBrand_description"><![CDATA[
    提供设备的品牌名称（由 Android 中的 Build.BRAND 返回）。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdDevice_description"><![CDATA[
    提供设备的设备名称（由 Android 中的 Build.DEVICE 返回）。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdProduct_description"><![CDATA[
    提供设备的产品名称（由 Android 中的 Build.PRODUCT 返回）。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdSerial_description"><![CDATA[
    提供设备的序列号。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdImei_description"><![CDATA[
    为设备上的所有无线装置提供 IMEI。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdMeid_description"><![CDATA[
    为设备上的所有无线装置提供 MEID。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdManufacturer_description"><![CDATA[
    提供设备的制造商名称（由 Android 中的 Build.MANUFACTURER 返回）。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_attestationIdModel_description"><![CDATA[
    提供设备的型号名称（由 Android 中的 Build.MODEL 返回）。仅在请求认证该设备的标识符时才会设置此字段。
    ]]></string>
    <string name="authorization_list_vendorPatchLevel_description"><![CDATA[
    指定要使用此密钥必须在设备上安装的供应商映像安全补丁程序级别。此值以 YYYYMMDD 的形式显示，表示供应商安全补丁程序的日期。例如，如果密钥在 Android 设备上生成，且相应设备安装了供应商于 2018 年 8 月 1 日提供的安全补丁程序，其值将表示为 20180801。
    ]]></string>
    <string name="authorization_list_bootPatchLevel_description"><![CDATA[
    指定要使用此密钥必须在设备上安装的内核映像安全补丁程序级别。此值以 YYYYMMDD 的形式显示，表示系统安全补丁程序的日期。例如，如果密钥在 Android 设备上生成，且相应设备安装了系统于 2018 年 8 月 5 日提供的安全补丁程序，其值将表示为 20180805。
    ]]></string>
</resources>

```

`app/src/main/res/values-zh-rTW/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">金鑰認證</string>
    <string name="use_strongbox">使用 StrongBox</string>
    <string name="attest_device_props">認證裝置屬性</string>
    <string name="about">關於</string>
    <string name="open_source_info"><![CDATA[
此軟體是 %2$s 下的開源軟體（%1$s）。
    ]]></string>

    <string name="bootloader_locked">Bootloader 已鎖定</string>
    <string name="bootloader_user">信任根由使用者設定</string>
    <string name="bootloader_unlocked">Bootloader 已解鎖</string>
    <string name="bootloader_unknown">Bootloader 狀態未知</string>
    <string name="bootloader_summary_sw_level">該裝置不支援硬體等級的金鑰認證。</string>
    <string name="unknown_root_cert">未知的根證書</string>
    <string name="unknown_root_cert_summary">根證書不受信任，認證結果可以被篡改。</string>

    <string name="error_message_subtitle">細節訊息：</string>
    <string name="error_unknown">未知錯誤</string>
    <string name="error_not_support">該裝置不支援金鑰認證</string>
    <string name="error_not_support_summary"><![CDATA[
    該裝置未實現金鑰認證功能，或裝置的安全環境已損壞。<br>處理方法：諮詢該裝置的製造商，是否支援金鑰認證功能以及安全環境損壞的條件，例如：解鎖 Bootloader。
    ]]></string>
    <string name="error_cert_not_trusted">證書不受信任</string>
    <string name="error_cert_not_trusted_summary"><![CDATA[
    證書鏈中有證書被吊銷或產生的證書無效。
    ]]></string>
    <string name="error_cant_parse_cert">無法剖析證書</string>
    <string name="error_strongbox_unavailable">無法使用 StrongBox</string>
    <string name="error_strongbox_unavailable_summary"><![CDATA[
    該裝置宣告具有 StrongBox 的支援，但實際上無法使用。
    ]]></string>
    <string name="error_unable_attest_deviceids">無法認證裝置 ID</string>
    <string name="error_unable_attest_deviceids_summary"><![CDATA[
    該裝置宣告支援 ID 認證，但 ID 不匹配且該裝置已無法再證明其 ID。
    ]]></string>

    <string name="attestation_version_description"><![CDATA[<font face="sans-serif-medium">版本：</font><br>金鑰認證功能的版本。]]></string>
    <string name="keymaster_version_description"><![CDATA[<font face="sans-serif-medium">版本：</font><br>Keymaster 硬體抽像層 (HAL) 的版本。使用 0 表示版本 0.2 或 0.3，使用 1 表示版本 1.0，使用 2 表示版本 2.0。]]></string>
    <string name="security_level_description"><![CDATA[<font face="sans-serif-medium">安全等級：</font><br>表示功能受保護的程度是以在裝置中的位置為基準。<p><ul><li gap="8sp"><font face="sans-serif-medium">Software</font><br>在 Android 系統中實現。此位置沒有 TEE 安全，但比應用程式的程式空間安全，能抵禦針對應用程式的攻擊。</li><li gap="8sp"><font face="sans-serif-medium">TrustedEnvironment</font><br>在安全硬體中實現，例如：TEE（Trusted Execution Environment，受信任的執行環境），能抵禦遠端攻擊。</li><li gap="8sp"><font face="sans-serif-medium">StrongBox</font><br>在專用的硬體安全模組中實現，能抵禦遠端攻擊和針對模組的硬體攻擊。</li></ul>]]></string>
    <string name="attestation_summary_format">版本：%1$s\n安全等級：%2$s</string>
    <string name="attestation_challenge_description"><![CDATA[質詢值的目的是使依賴方能夠驗證是否已回應特定要求建立了金鑰。<p>在生產環境中，質詢值應每次都隨機產生。]]></string>
    <string name="unique_id_description"><![CDATA[此值用於標識裝置，但只能在限定時間段內使用。此值透過計算得出，而且只能由系統應用程式使用。在所有其他應用程式中，uniqueId 為空。]]></string>

    <string name="empty">（空）</string>

    <string name="sw_enforced" translatable="false">SW</string>
    <string name="sw_enforced_description"><![CDATA[此專案由 Android 系統（而非裝置的 TEE）強制執行。]]></string>
    <string name="tee_enforced" translatable="false">TEE</string>
    <string name="tee_enforced_description"><![CDATA[此專案由裝置的 TEE 強制執行。]]></string>

    <string name="authorization_list_description"><![CDATA[
    此資料結構包含金鑰對的屬性本身，如 Keymaster 硬體抽像層 (HAL) 中所定義。<p>應用程式開發者將這些值與裝置的目前狀態或一組預期值進行比較，以驗證金鑰對是否仍適用。
    ]]></string>
    <string name="authorization_list_purpose_description"><![CDATA[
    用於指定對應金鑰可用於哪些目的。
    ]]></string>
    <string name="authorization_list_algorithm_description"><![CDATA[
    用於指定與對應金鑰配合使用的加密演算法。在認證 AuthorizationList 物件當中，演算法值始終為 RSA 或 EC。
    ]]></string>
    <string name="authorization_list_keySize_description"><![CDATA[
    用於指定對應金鑰的大小（以位元為單位，按適用於對應金鑰演算法的一般方式衡量）。
    ]]></string>
    <string name="authorization_list_digest_description"><![CDATA[
    用於指定可與對應金鑰配合使用以執行簽名和驗證操作的概觀演算法。此標記與 RSA 金鑰、ECDSA 金鑰和 HMAC 金鑰有關。
    ]]></string>
    <string name="authorization_list_padding_description"><![CDATA[
    用於指定可與對應金鑰配合使用的填充模式。此標記與 RSA 金鑰和 AES 金鑰有關。
    ]]></string>
    <string name="authorization_list_ecCurve_description"><![CDATA[
    用於產生橢圓曲線 (EC) 金鑰對的引數集，該引數集在 Android 系統金鑰庫中使用 ECDSA 進行簽名和驗證。
    ]]></string>
    <string name="authorization_list_rsaPublicExponent_description"><![CDATA[
    用於為 RSA 金鑰對指定公開指數的值。此標記僅與 RSA 金鑰有關，而且是所有 RSA 金鑰都必需的標記。
    ]]></string>
    <string name="authorization_list_rollbackResistance_description"><![CDATA[
    用於表明金鑰不可復原。也就是說，當透過 deleteKey 或 deleteAllKeys 刪除金鑰後，可保證該金鑰已被永久刪除且無法再使用。如果金鑰不帶此標記，那麼在被刪除後，可能能夠從備份中恢復。
    ]]></string>
    <string name="authorization_list_activeDateTime_description"><![CDATA[
    用於指定對應金鑰變為有效狀態的日期和時間。
    ]]></string>
    <string name="authorization_list_originationExpireDateTime_description"><![CDATA[
    用於指定對應金鑰無法再用於簽名和加密目的的過期日期和時間。
    ]]></string>
    <string name="authorization_list_usageExpireDateTime_description"><![CDATA[
    用於指定對應金鑰無法再用於驗證和解密目的的過期日期和時間。
    ]]></string>
    <string name="authorization_list_noAuthRequired_description"><![CDATA[
    用於指定無需進行身份驗證即可使用對應金鑰。
    ]]></string>
    <string name="authorization_list_userAuthType_description"><![CDATA[
    用於指定可以使用哪些型別的使用者身份驗證程式來授權使用對應金鑰。
    ]]></string>
    <string name="authorization_list_authTimeout_description"><![CDATA[
    用於指定授權在多長時間內使用對應金鑰（以秒為單位，從透過身份驗證開始算起）。
    ]]></string>
    <string name="authorization_list_allowWhileOnBody_description"><![CDATA[
    此標記僅適用於配備貼身感測器的 Android Wear 裝置。目前，TEE 並不能提供對貼身感測器的安全存取，貼身感測器也不是非常安全，因此這應該是一項完全由軟體強制執行的功能。
    ]]></string>
    <string name="authorization_list_trustedUserPresenceRequired_description"><![CDATA[
    指定只有在使用者提供了物理存在證明時，此金鑰才可用。
    ]]></string>
    <string name="authorization_list_trustedConfirmationRequired_description"><![CDATA[
    指定只有在使用者確認使用審核權杖簽署資料時，此金鑰才可用。
    ]]></string>
    <string name="authorization_list_unlockedDeviceRequired_description"><![CDATA[
    要求解鎖裝置螢幕後才能使用該金鑰。
    ]]></string>
    <string name="authorization_list_allApplications_description"><![CDATA[
    指示裝置上的所有應用程式是否都可以存取金鑰對。
    ]]></string>
    <string name="authorization_list_applicationId_description"><![CDATA[
    當提供 generateKey 或 importKey 後，此標記用於指定使用對應金鑰時均須提供的資料。
    ]]></string>
    <string name="authorization_list_creationDateTime_description"><![CDATA[
    用於從 1970 年 1 月 1 日以毫秒為單位計算指定對應金鑰的建立日期和時間。此標記為可選標記，僅供參考。
    ]]></string>
    <string name="authorization_list_origin_description"><![CDATA[
    用於指定相對應的金鑰是在哪裡建立的。在產生或匯入金鑰期間可以不指定此標記，但此標記必須要由 Trustlet 新增到金鑰特性中。
    ]]></string>
    <string name="authorization_list_rollbackResistant_description"><![CDATA[
    用於表明金鑰可抗回復，也就是說，當透過 deleteKey 或 deleteAllKeys 刪除金鑰後，可保證該金鑰已被永久刪除且無法再使用。如果金鑰不帶此標記，那麼在被刪除後，可能能夠從備份中恢復。
    ]]></string>
    <string name="authorization_list_rootOfTrust_description"><![CDATA[
    這個值集合可以定義與裝置狀態有關的金鑰訊息。
    ]]></string>
    <string name="authorization_list_osVersion_description"><![CDATA[
    與 Keymaster 關聯的 Android 作業系統的版本，使用一個 6 位整數表示。例如：版本 8.1.0 表示為 080100。
    ]]></string>
    <string name="authorization_list_osPatchLevel_description"><![CDATA[
    與 Keymaster 中使用的安全性更新程式關聯的月份和年度，使用一個 6 位整數表示。例如：2018 年 8 月的安全性更新程式表示為 201808。
    ]]></string>
    <string name="authorization_list_attestationApplicationId_description"><![CDATA[
    此資料結構反映了 Android 平臺對於允許哪些應用程式使用認證中的金鑰材料的觀點。當且僅當多個軟體包共用同一 UID 時，此 ID 才可以包含多個軟體包。
    ]]></string>
    <string name="authorization_list_attestationIdBrand_description"><![CDATA[
    提供裝置的品牌名稱（由 Android 中的 Build.BRAND 回傳值）。僅在要求認證該裝置的識別碼時才會設定此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdDevice_description"><![CDATA[
    提供裝置的裝置名稱（由 Android 中的 Build.DEVICE 回傳值）。僅在要求認證該裝置的識別碼時才會設定此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdProduct_description"><![CDATA[
    提供裝置的產品名稱（由 Android 中的 Build.PRODUCT 回傳值）。僅在要求認證該裝置的識別碼時才會設定此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdSerial_description"><![CDATA[
    提供裝置的序號。僅在要求認證該裝置的識別碼時才會設定此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdImei_description"><![CDATA[
    為裝置上的所有無線裝置提供 IMEI。僅在要求認證該裝置的識別碼時才會設定此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdMeid_description"><![CDATA[
    為裝置上的所有無線裝置提供 MEID。僅在要求認證該裝置的識別碼時才會設定此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdManufacturer_description"><![CDATA[
    提供裝置的製造商名稱（由 Android 中的 Build.MANUFACTURER 回傳值）。僅在要求認證該裝置的識別碼時才會設定此欄位。
    ]]></string>
    <string name="authorization_list_attestationIdModel_description"><![CDATA[
    提供裝置的型號名稱（由 Android 中的 Build.MODEL 回傳值）。僅在要求認證該裝置的識別碼時才會設定此欄位。
    ]]></string>
    <string name="authorization_list_vendorPatchLevel_description"><![CDATA[
    指定要使用此金鑰必須在裝置上安裝的供應商映像安全性更新程式等級。此值以 YYYYMMDD 的形式顯示，表示供應商安全性更新程式的日期。例如：如果金鑰在 Android 裝置上產生，且對應裝置安裝了供應商於 2018 年 8 月 1 日提供的安全性更新程式，其值將表示為 20180801。
    ]]></string>
    <string name="authorization_list_bootPatchLevel_description"><![CDATA[
    指定要使用此金鑰必須在裝置上安裝的核心映像安全性更新程式等級。此值以 YYYYMMDD 的形式顯示，表示系統安全性更新程式的日期。例如：如果金鑰在 Android 裝置上產生，且對應裝置安裝了系統於 2018 年 8 月 5 日提供的安全性更新程式，其值將表示為 20180805。
    ]]></string>
</resources>

```

`app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="color_background_dark">#365161</color>
    <color name="color_floating_background_dark">#465f6d</color>
    <color name="icon_background">#1765a4</color>
    <color name="color_safe">#efe0f7fA</color>
    <color name="color_warning">#efffd180</color>
    <color name="color_alert">#efff8a80</color>
    <color name="color_inactive">#88ffffff</color>
    <color name="color_accent">#E1F5FE</color>
</resources>
```

`app/src/main/res/values/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <dimen name="home_padding">0dp</dimen>
</resources>
```

`app/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Key Attestation</string>
    <string name="use_strongbox">Use StrongBox</string>
    <string name="attest_device_props">Attest device props</string>
    <string name="show_all">Show all</string>
    <string name="skip_verify">Skip verify certificate chain</string>
    <string name="load_certs">Load from file</string>
    <string name="save_certs">Save to file</string>
    <string name="about">About</string>
    <string name="open_source_info"><![CDATA[
This software is open source under %2$s (%1$s).
    ]]></string>

    <string name="bootloader_locked">Bootloader is locked</string>
    <string name="bootloader_user">Root of trust set by user</string>
    <string name="bootloader_unlocked">Bootloader is unlocked</string>
    <string name="bootloader_unknown">Bootloader status is unknown</string>
    <string name="bootloader_summary_sw_level">This device does not support hardware-level key attestation.</string>
    <string name="unknown_root_cert">Unknown Root certificate</string>
    <string name="unknown_root_cert_summary">Root certificate is not trusted, may self-signed by OEM.</string>
    <string name="aosp_root_cert">AOSP Root certificate</string>
    <string name="aosp_root_cert_summary">Private key of root certificate is well known, the attestation result can be tampered with.</string>

    <string name="error_message_subtitle">Detailed messages:</string>
    <string name="error_unknown">Unknown error</string>
    <string name="error_not_support">Not supported by this device</string>
    <string name="error_not_support_summary"><![CDATA[
    This device does not support key attestation or the trusted environment on this device is broken.<br>Solution: Consult the device manufacturer whether the device supports key attestation function and the destruction conditions of the trusted environment, such as unlocking the bootloader.
    ]]></string>
    <string name="error_cert_not_trusted">Certificate is not trusted</string>
    <string name="error_cert_not_trusted_summary"><![CDATA[
    A certificate in the certificate chain has expired, been revoked, or not verified by signature.
    ]]></string>
    <string name="error_cant_parse_cert">Unable to parse certificate</string>
    <string name="error_cant_parse_cert_summary"><![CDATA[
    The certificate is in the wrong format or there is a feature that is not yet supported.
    ]]></string>
    <string name="error_strongbox_unavailable">StrongBox not available</string>
    <string name="error_strongbox_unavailable_summary"><![CDATA[
    This device is declared to have StrongBox support but it is actually unavailable.
    ]]></string>
    <string name="error_unable_attest_deviceids">Unable to attest device ids</string>
    <string name="error_unable_attest_deviceids_summary"><![CDATA[
    This device is declared to have ID attestation support, but IDs do not match or the device can no longer attest its IDs.
    ]]></string>

    <string name="attestation" translatable="false">Attestation</string>
    <string name="attestation_version_description"><![CDATA[<font face="sans-serif-medium">Version:</font><br>The version of the key attestation feature.]]></string>
    <string name="keymaster" translatable="false">Keymaster</string>
    <string name="keymaster_version_description"><![CDATA[<font face="sans-serif-medium">Version:</font><br>The version of the Keymaster hardware abstraction layer (HAL). Use 0 to represent version 0.2 or 0.3, 1 to represent version 1.0, and 2 to represent version 2.0.]]></string>
    <string name="security_level_description"><![CDATA[<font face="sans-serif-medium">Security level:</font><br>The security of the implementation.<p><ul><li gap="8sp"><font face="sans-serif-medium">Software</font><br>Implemented by the Android system. This location is less secure than the TEE but is more secure than app\'s process space.</li><li gap="8sp"><font face="sans-serif-medium">TrustedEnvironment</font><br>Implemented in secure hardware, such as a TEE (Trusted Execution Environment). This location is more secure because secure hardware is highly resistant to remote compromise.</li><li gap="8sp"><font face="sans-serif-medium">StrongBox</font><br>Implemented in a dedicated hardware security module. This location is more secure because it is highly resistant to remote compromise and hardware attacks against the module.</li></ul>]]></string>
    <string name="attestation_summary_format">Version: %1$s\nSecurity level: %2$s</string>
    <string name="attestation_challenge" translatable="false">Attestation challenge</string>
    <string name="attestation_challenge_description"><![CDATA[The purpose of the challenge value is to enable relying parties to verify that the key was created in response to a specific request.<p>In production environment, the challenge value should be randomly generated every time.]]></string>
    <string name="unique_id" translatable="false">Unique ID</string>
    <string name="unique_id_description"><![CDATA[This value identifies the device—but only for a limited period of time. It is computed and is only used by system apps. In all other apps, uniqueId is empty.]]></string>

    <string name="empty">(empty)</string>
    <string name="security_level_software" translatable="false">Software</string>
    <string name="security_level_trusted_environment" translatable="false">TrustedEnvironment</string>
    <string name="security_level_strongbox" translatable="false">StrongBox</string>

    <string name="sw_enforced" translatable="false">SW</string>
    <string name="sw_enforced_description"><![CDATA[This item is enforced by the Android system, not by the device\'s TEE.]]></string>
    <string name="tee_enforced" translatable="false">TEE</string>
    <string name="tee_enforced_description"><![CDATA[This item is enforced by the device\'s TEE.]]></string>

    <string name="authorization_list">Authorization list</string>
    <string name="authorization_list_purpose">Purpose</string>
    <string name="authorization_list_algorithm">Algorithm</string>
    <string name="authorization_list_keySize">Key size</string>
    <string name="authorization_list_digest">Digests</string>
    <string name="authorization_list_padding">Padding</string>
    <string name="authorization_list_ecCurve">EC curve</string>
    <string name="authorization_list_rsaPublicExponent">RSA public exponent</string>
    <string name="authorization_list_rollbackResistance">Rollback resistance</string>
    <string name="authorization_list_activeDateTime">Active date time</string>
    <string name="authorization_list_originationExpireDateTime">Origination expire date time</string>
    <string name="authorization_list_usageExpireDateTime">Usage expire date time</string>
    <string name="authorization_list_noAuthRequired">No auth required</string>
    <string name="authorization_list_userAuthType">User auth type</string>
    <string name="authorization_list_authTimeout">Auth timeout</string>
    <string name="authorization_list_allowWhileOnBody">Allow while on body</string>
    <string name="authorization_list_trustedUserPresenceRequired">Trusted user presence required</string>
    <string name="authorization_list_trustedConfirmationRequired">Trusted Confirmation required</string>
    <string name="authorization_list_unlockedDeviceRequired">Unlocked device required</string>
    <string name="authorization_list_allApplications">All applications</string>
    <string name="authorization_list_applicationId">Application ID</string>
    <string name="authorization_list_creationDateTime">Creation date time</string>
    <string name="authorization_list_origin">Origin</string>
    <string name="authorization_list_rollbackResistant">Rollback resistant</string>
    <string name="authorization_list_rootOfTrust">Root of trust</string>
    <string name="authorization_list_osVersion">OS version</string>
    <string name="authorization_list_osPatchLevel">OS patch level</string>
    <string name="authorization_list_attestationApplicationId">Attestation application ID</string>
    <string name="authorization_list_attestationIdBrand">Attestation ID brand</string>
    <string name="authorization_list_attestationIdDevice">Attestation ID device</string>
    <string name="authorization_list_attestationIdProduct">Attestation ID product</string>
    <string name="authorization_list_attestationIdSerial">Attestation ID serial</string>
    <string name="authorization_list_attestationIdImei">Attestation ID IMEI</string>
    <string name="authorization_list_attestationIdSecondImei">Attestation ID second IMEI</string>
    <string name="authorization_list_attestationIdMeid">Attestation ID MEID</string>
    <string name="authorization_list_attestationIdManufacturer">Attestation ID manufacturer</string>
    <string name="authorization_list_attestationIdModel">Attestation ID model</string>
    <string name="authorization_list_vendorPatchLevel">Vendor patch level</string>
    <string name="authorization_list_bootPatchLevel">Boot patch level</string>
    <string name="authorization_list_mgfDigest">Rsa Oaep Mgf Digest</string>
    <string name="authorization_list_earlyBootOnly">Early boot only</string>
    <string name="authorization_list_usageCountLimit">Usage count limit</string>
    <string name="authorization_list_deviceUniqueAttestation">Device unique attestation</string>
    <string name="authorization_list_identityCredentialKey">Identity credential key</string>

    <!-- https://cs.android.com/android/platform/superproject/+/master:hardware/interfaces/security/keymint/aidl/android/hardware/security/keymint/Tag.aidl -->
    <string name="authorization_list_description"><![CDATA[
    This data structure contains the key pair\'s properties themselves, as defined in the Keymaster hardware abstraction layer (HAL).<p>App developers can compare these values to the device\'s current state or to a set of expected values to verify that a key pair is still valid for use.
    ]]></string>
    <string name="authorization_list_purpose_description"><![CDATA[
    Specifies the set of purposes for which the key may be used.
    ]]></string>
    <string name="authorization_list_algorithm_description"><![CDATA[
    Specifies the cryptographic algorithm with which the key is used. In an attestation AuthorizationList object, the algorithm value is always RSA or EC.
    ]]></string>
    <string name="authorization_list_keySize_description"><![CDATA[
    Specifies the size, in bits, of the key, measuring in the normal way for the key\'s algorithm.
    ]]></string>
    <string name="authorization_list_digest_description"><![CDATA[
    Specifies the digest algorithms that may be used with the key to perform signing and verification operations. This tag is relevant to RSA, ECDSA and HMAC keys.
    ]]></string>
    <string name="authorization_list_padding_description"><![CDATA[
    Specifies the padding modes that may be used with the key. This tag is relevant to RSA and AES keys.
    ]]></string>
    <string name="authorization_list_ecCurve_description"><![CDATA[
    The set of parameters used to generate an elliptic curve (EC) key pair, which uses ECDSA for signing and verification, within the Android system keystore.
    ]]></string>
    <string name="authorization_list_rsaPublicExponent_description"><![CDATA[
    Specifies the value of the public exponent for an RSA key pair. This tag is relevant only to RSA keys, and necessary for all RSA keys.
    ]]></string>
    <string name="authorization_list_rollbackResistance_description"><![CDATA[
    Indicates that the key is rollback-resistant, meaning that when deleted by deleteKey or deleteAllKeys, the key is guaranteed to be permanently deleted and unusable. It\'s possible that keys without this tag could be deleted and then restored from backup.
    ]]></string>
    <string name="authorization_list_activeDateTime_description"><![CDATA[
    Specifies the date and time at which the key becomes active.
    ]]></string>
    <string name="authorization_list_originationExpireDateTime_description"><![CDATA[
    Specifies the date and time at which the key expires for signing and encryption purposes.
    ]]></string>
    <string name="authorization_list_usageExpireDateTime_description"><![CDATA[
    Specifies the date and time at which the key expires for verification and decryption purposes.
    ]]></string>
    <string name="authorization_list_noAuthRequired_description"><![CDATA[
    Specifies that no authentication is required to use this key.
    ]]></string>
    <string name="authorization_list_userAuthType_description"><![CDATA[
    Specifies the types of user authenticators that may be used to authorize this key.
    ]]></string>
    <string name="authorization_list_authTimeout_description"><![CDATA[
    Specifies the time in seconds for which the key is authorized for use, after authentication.
    ]]></string>
    <string name="authorization_list_allowWhileOnBody_description"><![CDATA[
    This tag is applicable only for Android Wear devices with on-body sensors. At this point, it\'s not expected that any TEE will be able to provide secure access to an on-body sensor, or that on-body sensors are very secure, so this is expected to be a purely software-enforced feature.
    ]]></string>
    <string name="authorization_list_trustedUserPresenceRequired_description"><![CDATA[
    Specifies that this key is usable only if the user has provided proof of physical presence.
    ]]></string>
    <string name="authorization_list_trustedConfirmationRequired_description"><![CDATA[
    Specifies that the key is usable only if the user provides confirmation of the data to be signed using an approval token.
    ]]></string>
    <string name="authorization_list_unlockedDeviceRequired_description"><![CDATA[
    Require the device screen to be unlocked if the key is used.
    ]]></string>
    <string name="authorization_list_allApplications_description"><![CDATA[
    Indicates whether all apps on a device can access the key pair.
    ]]></string>
    <string name="authorization_list_applicationId_description"><![CDATA[
    When provided to generateKey or importKey, this tag specifies data that is necessary during all uses of the key.
    ]]></string>
    <string name="authorization_list_creationDateTime_description"><![CDATA[
    Specifies the date and time the key was created, in milliseconds since January 1, 1970. This tag is optional and informational only.
    ]]></string>
    <string name="authorization_list_origin_description"><![CDATA[
    Specifies where the key was created, if known. This tag may not be specified during key generation or import, and must be added to the key characteristics by the trustlet.
    ]]></string>
    <string name="authorization_list_rollbackResistant_description"><![CDATA[
    Indicates that the key is rollback-resistant, meaning that when deleted by deleteKey or deleteAllKeys, the key is guaranteed to be permanently deleted and unusable. It\'s possible that keys without this tag could be deleted and then restored from backup.
    ]]></string>
    <string name="authorization_list_rootOfTrust_description"><![CDATA[
    This collection of values defines key information about the device\'s status.
    ]]></string>
    <string name="authorization_list_osVersion_description"><![CDATA[
    The version of the Android operating system associated with the Keymaster, specified as a six-digit integer. For example, version 8.1.0 is represented as 080100.
    ]]></string>
    <string name="authorization_list_osPatchLevel_description"><![CDATA[
    The month and year associated with the security patch that is being used within the Keymaster, specified as a six-digit integer. For example, the August 2018 patch is represented as 201808.
    ]]></string>
    <string name="authorization_list_attestationApplicationId_description"><![CDATA[
    This data structure reflects the Android platform\'s belief as to which apps are allowed to use the secret key material under attestation. The ID can comprise multiple packages if and only if multiple packages share the same UID.
    ]]></string>
    <string name="authorization_list_attestationIdBrand_description"><![CDATA[
    Provides the device\'s brand name, as returned by Build.BRAND in Android. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdDevice_description"><![CDATA[
    Provides the device\'s device name, as returned by Build.DEVICE in Android. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdProduct_description"><![CDATA[
    Provides the device\'s product name, as returned by Build.PRODUCT in Android. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdSerial_description"><![CDATA[
    Provides the device\'s serial number. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdImei_description"><![CDATA[
    Provides the IMEI one of the radios on the device to attested key generation/import operations.  This field must be set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdSecondImei_description"><![CDATA[
    Provides an additional IMEI of one of the radios on the device to attested key generation/import operations.
    ]]></string>
    <string name="authorization_list_attestationIdMeid_description"><![CDATA[
    Provides the MEIDs for all radios on the device. This field will only be set when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdManufacturer_description"><![CDATA[
    Provides the device\'s manufacturer name, as returned by Build.MANUFACTURER in Android. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_attestationIdModel_description"><![CDATA[
    Provides the device\'s model name, as returned by Build.MODEL in Android. This field is set only when requesting attestation of the device\'s identifiers.
    ]]></string>
    <string name="authorization_list_vendorPatchLevel_description"><![CDATA[
    Specifies the vendor image security patch level that must be installed on the device for this key to be used. The value appears in the form YYYYMMDD, representing the date of the vendor security patch. For example, if a key were generated on an Android device with the vendor\'s August 1, 2018 security patch installed, this value would be 20180801.
    ]]></string>
    <string name="authorization_list_bootPatchLevel_description"><![CDATA[
    Specifies the kernel image security patch level that must be installed on the device for this key to be used. The value appears in the form YYYYMMDD, representing the date of the system security patch. For example, if a key were generated on an Android device with the system\'s August 5, 2018 security patch installed, this value would be 20180805.
    ]]></string>
    <string name="authorization_list_mgfDigest_description"><![CDATA[
    Specifies the MGF1 digest algorithms that may be used with RSA encryption/decryption with OAEP padding. Possible values are defined by the Digest enum.
    ]]></string>
    <string name="authorization_list_earlyBootOnly_description"><![CDATA[
    Keys tagged with EARLY_BOOT_ONLY may only be used during early boot, until IKeyMintDevice::earlyBootEnded() is called.
    ]]></string>
    <string name="authorization_list_usageCountLimit_description"><![CDATA[
    Specifies the number of times that a key may be used. This can be used to limit the use of a key. The value is a 32-bit integer representing the current number of attempts left.
    ]]></string>
    <string name="authorization_list_deviceUniqueAttestation_description"><![CDATA[
    It indicates that attestation using a device-unique key is requested, rather than a batch key. When a device-unique key is used, the returned chain should contain two or three certificates.
    ]]></string>
    <string name="authorization_list_identityCredentialKey_description"><![CDATA[
    It is used in attestations produced by the IIdentityCredential HAL when that HAL attests to Credential Keys. IIdentityCredential produces KeyMint-style attestations.
    ]]></string>
</resources>

```

`app/src/main/res/values/strings_no_translate.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="copyright" translatable="false">Copyright © vvb2060, Rikka</string>
    <string name="github_url" translatable="false">https://github.com/vvb2060/KeyAttestation</string>
    <string name="license" translatable="false">Apache License 2.0</string>
</resources>
```

`app/src/main/res/values/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="AppTheme" parent="Theme" />

    <style name="HomeCardStyle">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:paddingStart">16dp</item>
        <item name="android:paddingTop">16dp</item>
        <item name="android:paddingEnd">16dp</item>
        <item name="android:paddingBottom">16dp</item>
        <!--<item name="android:background">?outlineButtonBackground</item>-->
    </style>

    <style name="HomeItemTitleText">
        <item name="android:textSize">16sp</item>
        <item name="android:gravity">center_vertical</item>
        <item name="android:textAppearance">?textAppearanceSubtitle2</item>
        <item name="android:textColor">@color/material_on_surface_emphasis_high_type</item>
    </style>

    <style name="HomeItemSummaryText">
        <item name="android:textSize">14sp</item>
        <item name="android:gravity">center_vertical</item>
        <item name="android:textAppearance">?textAppearanceBody2</item>
        <item name="android:textColor">@color/material_on_surface_emphasis_medium</item>
        <item name="android:lineSpacingExtra">1sp</item>
    </style>

</resources>
```

`app/src/main/res/values/themes.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Base theme -->
    <style name="Theme" parent="Theme.Material">
        <item name="android:statusBarColor">?toolbarColor</item>
        <item name="android:colorPrimary">?toolbarColor</item>
        <item name="android:colorBackground">@color/color_background_dark</item>
        <item name="actionBarPopupTheme">@style/ThemeOverlay.ActionBar.PopupTheme</item>

        <item name="colorBackgroundFloating">@color/color_floating_background_dark</item>
        <item name="android:colorBackgroundFloating">@color/color_floating_background_dark</item>

        <item name="colorPrimary">@color/color_accent</item>
        <item name="colorPrimaryVariant">@color/color_accent</item>
        <item name="colorSecondary">@color/color_accent</item>
        <item name="colorSecondaryVariant">@color/color_accent</item>
        <item name="colorOnSecondary">@android:color/black</item>
        <item name="actionBarTheme">@style/ThemeOverlay.ActionBar</item>
        <item name="toolbarStyle">@style/Widget.Material.Toolbar</item>
        <item name="notificationColor">@color/material_teal_500</item>

        <!--<item name="preferenceTheme">@style/ThemeOverlay.Preference</item>-->
        <item name="appBarStyle">@style/Widget.AppBar</item>
        <item name="toolbarColor">@color/color_background_dark</item>
        <item name="colorSafe">@color/color_safe</item>
        <item name="colorWarning">@color/color_warning</item>
        <item name="colorAlert">@color/color_alert</item>
        <item name="colorInactive">@color/color_inactive</item>

        <item name="android:windowNoTitle">true</item>
        <item name="android:windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="windowActionBar">false</item>
    </style>

    <style name="Widget.AppBar" parent="">
        <item name="android:theme">?actionBarTheme</item>
        <item name="android:background">?android:colorBackground</item>
        <item name="android:stateListAnimator">@animator/raise_animator</item>
        <item name="android:elevation">0dp</item>
    </style>

    <style name="ThemeOverlay.ActionBar.PopupTheme" parent="ThemeOverlay.MaterialComponents">
        <item name="colorSurface">@color/color_background_dark</item>
    </style>

    <style name="ThemeOverlay.ActionBar" parent="ThemeOverlay.MaterialComponents.ActionBar">
        <item name="titleTextAppearance">@android:style/TextAppearance.Material.Widget.Toolbar.Title</item>
        <item name="subtitleTextAppearance">@android:style/TextAppearance.Material.Widget.Toolbar.Subtitle</item>
    </style>

    <style name="ThemeOverlay.ActionBar.Dark" parent="ThemeOverlay.MaterialComponents.Dark.ActionBar">
        <item name="titleTextAppearance">@android:style/TextAppearance.Material.Widget.Toolbar.Title</item>
        <item name="subtitleTextAppearance">@android:style/TextAppearance.Material.Widget.Toolbar.Subtitle</item>
    </style>

    <style name="Widget.Material.Toolbar" parent="Widget.MaterialComponents.Toolbar">
        <item name="android:elevation">4dp</item>
        <item name="android:background">?toolbarColor</item>
    </style>

</resources>
```

`app/src/main/res/values/themes_override.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools" tools:ignore="PrivateResource">

    <!-- Add android:colorControlNormal -->
    <style name="Base.ThemeOverlay.AppCompat.ActionBar" tools:override="true">
        <item name="android:colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="searchViewStyle">@style/Widget.AppCompat.SearchView.ActionBar</item>
    </style>

    <style name="Base.ThemeOverlay.AppCompat.Dark.ActionBar" tools:override="true">
        <item name="android:colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="colorControlNormal">?android:attr/textColorPrimary</item>
        <item name="searchViewStyle">@style/Widget.AppCompat.SearchView.ActionBar</item>
    </style>

    <style name="Widget.MaterialComponents.CompoundButton.CheckBox" parent="Widget.AppCompat.CompoundButton.CheckBox" tools:override="true">
        <item name="enforceMaterialTheme">true</item>
        <item name="useMaterialThemeColors">true</item>
    </style>

    <style name="Widget.MaterialComponents.CompoundButton.RadioButton" parent="Widget.AppCompat.CompoundButton.RadioButton" tools:override="true">
        <item name="enforceMaterialTheme">true</item>
        <item name="useMaterialThemeColors">true</item>
    </style>
</resources>
```

`gradle.properties`:

```properties
android.useAndroidX=true
android.nonTransitiveRClass=true
android.enableAppCompileTimeRClass=true

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.1.1-bin.zip
networkTimeout=10000
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command;
#   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
#     shell script including quotes and variable substitutions, so put them in
#     double quotes to make sure that they get re-expanded; and
#   * put everything else in single quotes, so that it's not re-expanded.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`settings.gradle`:

```gradle
pluginManagement {
    repositories {
        gradlePluginPortal()
        google()
        mavenCentral()
    }
    plugins {
        id("com.android.application") version "8.0.2"
        id("com.android.library") version "8.0.2"
        id("org.jetbrains.kotlin.android") version "1.8.21"
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}
rootProject.name = "KeyAttestation"
include(":app")

```