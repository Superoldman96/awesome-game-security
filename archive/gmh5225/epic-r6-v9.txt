Project Path: arc_gmh5225_epic-r6-v9_kefqoue8

Source Tree:

```txt
arc_gmh5225_epic-r6-v9_kefqoue8
├── README.md
├── game.hpp
├── includes.hpp
├── main.cpp
├── memory.hpp
├── offsets.hpp
└── renderer.hpp

```

`README.md`:

```md
# epic-r6-v9

box style esp and memory aimbot for Rainbow Six Siege

dependencies: directx sdk

```

`game.hpp`:

```hpp
#pragma once
#include "includes.hpp"
#include "memory.hpp"

void resolve_pointers() {
	g_game_manager = RPM<uintptr_t>((uintptr_t)g_module.modBaseAddr + g_game_man_offset);
	g_entity_list = RPM<uintptr_t>(g_game_manager + OFFSET_GAMEMANAGER_ENTITYLIST);

	g_camera = RPM<uintptr_t>((uintptr_t)g_module.modBaseAddr + g_prof_man_offset);
	g_camera = RPM<uintptr_t>(g_camera + GAMEPROFILE_CHAIN1);
	g_camera = RPM<uintptr_t>(g_camera + GAMEPROFILE_CHAIN2);
	g_camera = RPM<uintptr_t>(g_camera + GAMEPROFILE_CHAIN3);
}

struct entity_t {
	uintptr_t m_ptr = 0x0;
	int m_health = 0;
	D3DXVECTOR3 m_origin = { 0.f, 0.f, 0.f }, m_top_origin = { 0.f, 0.f, 0.f }, m_headpos = { 0.f, 0.f, 0.f };

	void set_health() {
		auto buffer = RPM<uintptr_t>(m_ptr + OFFSET_ENTITY_ENTITYINFO);
		buffer = RPM<uintptr_t>(buffer + OFFSET_ENTITYINFO_MAINCOMPONENT);
		buffer = RPM<uintptr_t>(buffer + OFFSET_MAINCOMPONENT_CHILDCOMPONENT);
		m_health = RPM<int>(buffer + OFFSET_CHILDCOMPONENT_HEALTH_INT);
	}

	void set_origin() {
		struct bone_t {
			uint8_t padding[OFFSET_ENTITY_HEAD];
			D3DXVECTOR3 head; //+ 0x6A0
			uint8_t filler[OFFSET_ENTITY_FEET - OFFSET_ENTITY_HEAD - sizeof(D3DXVECTOR3)];
			D3DXVECTOR3 feet; //+ 0x700
		};

		auto buffer = RPM<uintptr_t>(m_ptr + OFFSET_ENTITY_REF);
		auto bones = RPM<bone_t>(buffer);
		m_origin = bones.feet;
		m_headpos = bones.head;
		m_top_origin = bones.head + D3DXVECTOR3(0.f, 0.f, 0.2f);
	}

	void set_all() {
		set_health();
		set_origin();
	}
};

struct view_matrix_t {
	uint8_t padding[OFFSET_CAMERA_VIEWRIGHT];
	D3DXVECTOR3 ViewRight; //+ 0x1C0
	uint8_t filler0[OFFSET_CAMERA_VIEWUP - OFFSET_CAMERA_VIEWRIGHT - sizeof(D3DXVECTOR3)];
	D3DXVECTOR3 ViewUp; //+ 0x1D0
	uint8_t filler1[OFFSET_CAMERA_VIEWFORWARD - OFFSET_CAMERA_VIEWUP - sizeof(D3DXVECTOR3)];
	D3DXVECTOR3 ViewForward; //+ 0x1E0
	uint8_t filler2[OFFSET_CAMERA_VIEWTRANSLATION - OFFSET_CAMERA_VIEWFORWARD - sizeof(D3DXVECTOR3)];
	D3DXVECTOR3 ViewTranslation; //+ 0x1F0
	uint8_t filler3[OFFSET_CAMERA_VIEWFOVX - OFFSET_CAMERA_VIEWTRANSLATION - sizeof(D3DXVECTOR3)];
	D3DXVECTOR2 fov; //+ 0x380

	void update() {
		auto buffer     = RPM<view_matrix_t>(g_camera);
		ViewRight       = buffer.ViewRight;
		ViewUp          = buffer.ViewUp;
		ViewForward     = buffer.ViewForward;
		ViewForward    *= -1;
		ViewTranslation = buffer.ViewTranslation;
		fov             = buffer.fov;
	}

	D3DXVECTOR3 world_to_screen(D3DXVECTOR3 position) {
		D3DXVECTOR3 temp = position - ViewTranslation;

		fov.x = std::abs(fov.x);
		fov.y = std::abs(fov.y);

		float x = temp.x * ViewRight.x + temp.y * ViewRight.y + temp.z * ViewRight.z;
		float y = temp.x * ViewUp.x + temp.y * ViewUp.y + temp.z * ViewUp.z;
		float z = temp.x * ViewForward.x + temp.y * ViewForward.y + temp.z * ViewForward.z;

		return D3DXVECTOR3{
			(g_screen_width / 2) * (1 + x / fov.x / z),
			(g_screen_height / 2) * (1 - y / fov.y / z),
			z
		};
	}
};

extern view_matrix_t g_vm;
```

`includes.hpp`:

```hpp
#pragma once
#include <iostream>
#include <thread>
#include <vector>

#include <Windows.h>
#include <TlHelp32.h>
#include <dwmapi.h>

#include <d3d9.h>
#include <d3dx9.h>
#include <D3dtypes.h>

#include "offsets.hpp"

//globals
extern const unsigned int g_screen_width, g_screen_height;

extern HWND g_hwnd, g_game_hwnd;

extern DWORD g_process_id;
extern HANDLE g_process_handle;
extern MODULEENTRY32 g_module;

extern uintptr_t g_game_man_offset, g_prof_man_offset;
extern uintptr_t g_game_manager, g_entity_list, g_camera;

extern IDirect3D9* g_d3;
extern IDirect3DDevice9* g_d3dev;
extern ID3DXFont* g_d3Font;
extern ID3DXLine* g_d3Line;

```

`main.cpp`:

```cpp
#include "includes.hpp"
#include "memory.hpp"
#include "game.hpp"
#include "renderer.hpp"

//defining globals
const unsigned int g_screen_width  = GetSystemMetrics(SM_CXSCREEN);
const unsigned int g_screen_height = GetSystemMetrics(SM_CYSCREEN);

HWND g_hwnd, g_game_hwnd;

DWORD g_process_id;
HANDLE g_process_handle;
MODULEENTRY32 g_module;

uintptr_t g_game_man_offset, g_prof_man_offset;
uintptr_t g_game_manager, g_entity_list, g_camera;
view_matrix_t g_vm;

IDirect3D9* g_d3;
IDirect3DDevice9* g_d3dev;
ID3DXFont* g_d3Font;
ID3DXLine* g_d3Line;

std::vector<entity_t> ents;

void populate_entity_vector() {
	struct entity_list_t { uintptr_t ent_ptrs[31]; } entity_list;
	std::vector<entity_t> buffer;

	while (1) {
		entity_list = RPM<entity_list_t>(g_entity_list + 1 * OFFSET_GAMEMANAGER_ENTITY);
		buffer.clear();

		for (uintptr_t ent_ptr : entity_list.ent_ptrs) {
			entity_t ent;
			ent.m_ptr = ent_ptr;
			ent.set_all(); if (ent.m_health < 1 || ent.m_health > 100) continue;

			buffer.push_back(ent);
		}
		
		ents = buffer;
		std::this_thread::sleep_for(std::chrono::milliseconds(16));
	}
}

void render() {
	g_d3dev->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_ARGB(0, 0, 0, 0), 1.0f, 0);
	g_d3dev->BeginScene();

	g_vm.update();

	for (entity_t ent : ents) {
		auto feet_position = g_vm.world_to_screen(ent.m_origin);  if (feet_position.z < 0.f) continue;
		auto head_position = g_vm.world_to_screen(ent.m_headpos); if (head_position.z < 0.f) continue;
		auto box_top = g_vm.world_to_screen(ent.m_top_origin);    if (box_top.z < 0.f)       continue;

		float box_height = feet_position.y - box_top.y;
		float box_width = box_height / 2.4;
		
		draw_outlined_rect(box_top.x - box_width / 2, box_top.y, box_width, box_height, epic_blue);
		draw_healthbars(box_top.x - box_width / 2 - 6, box_top.y, 2, box_height, ent.m_health, 100, epic_blue);
		draw_circle(head_position.x, head_position.y, box_height / 12.5f, 60, epic_blue);
	}

	g_d3dev->EndScene();
	g_d3dev->Present(NULL, NULL, NULL, NULL);
}

void pause(const char* msg) {
	std::cout << msg << "\nPress enter to continue . . ."; getchar();
	exit(EXIT_FAILURE);
}

int main() {
	SetConsoleTitleA("jizzware R6 v2");

	g_game_hwnd = FindWindowA(NULL, "Rainbow Six");

	if (g_game_hwnd) {
		std::cout << "[+] Attached to process" << std::endl;

		GetWindowThreadProcessId(g_game_hwnd, &g_process_id);
		g_process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, g_process_id);

		if (g_process_handle == INVALID_HANDLE_VALUE || g_process_handle == NULL) { pause("[+] Could not attach to process"); }

		g_module = get_module("RainbowSix.exe", g_process_id);

		setup_window();
		std::cout << "[+] Created overlay" << std::endl;

		g_game_man_offset = find_pattern(g_module, "\x48\x8B\x05\x00\x00\x00\x00\x8B\x8E", "xxx????xx") + 0x3;
		g_game_man_offset += (uint64_t)RPM<uint32_t>(g_game_man_offset) + 0x4 - (uintptr_t)g_module.modBaseAddr;
		printf("[+] Found GameManager @ 0x%X\n", g_game_man_offset);

		g_prof_man_offset = find_pattern(g_module, "\x48\x8B\x05\x00\x00\x00\x00\x33\xD2\x4C\x8B\x40\x78", "xxx????xxxxxx") + 0x3;
		g_prof_man_offset += (uint64_t)RPM<uint32_t>(g_prof_man_offset) + 0x4 - (uintptr_t)g_module.modBaseAddr;
		printf("[+] Found ProfileManager @ 0x%X\n", g_prof_man_offset);

		resolve_pointers();

		std::cout << "[+] Started reading thread, starting rendering" << std::endl;
		std::thread populate_entity_vector_thread(populate_entity_vector);
		loop();
	} else { pause("[+] Game must be running to continue"); }
}

```

`memory.hpp`:

```hpp
#pragma once
#include "includes.hpp"

auto get_module(const char* modName, DWORD procId) {
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
	if (hSnap != INVALID_HANDLE_VALUE) {
		MODULEENTRY32 modEntry;
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnap, &modEntry)) {
			do {
				if (!strcmp(modEntry.szModule, modName)) {
					CloseHandle(hSnap);
					return modEntry;
				}
			} while (Module32Next(hSnap, &modEntry));
		}
	}
}

template<typename T> T RPM(SIZE_T address) {
	T buffer; ReadProcessMemory(g_process_handle, (void*)address, &buffer, sizeof(T), nullptr);
	return buffer;
}

template<typename T> void WPM(SIZE_T address, T buffer) {
	WriteProcessMemory(g_process_handle, (void*)address, &buffer, sizeof(T), nullptr);
}

uintptr_t find_pattern(MODULEENTRY32 module, const char* pattern, const char* mask) {
	SIZE_T bytesRead;
	DWORD oldprotect;
	MEMORY_BASIC_INFORMATION mbi = { 0 };

	auto scan = [](const char* pattern, const char* mask, char* begin, unsigned int size) -> char* {
		size_t patternLen = strlen(mask);
		for (unsigned int i = 0; i < size - patternLen; i++) {
			bool found = true;
			for (unsigned int j = 0; j < patternLen; j++) {
				if (mask[j] != '?' && pattern[j] != *(begin + i + j)) {
					found = false;
					break;
				}
			}
			if (found) { return (begin + i); }
		}
		return nullptr;
	};

	for (uintptr_t curr = (uintptr_t)module.modBaseAddr; curr < (uintptr_t)module.modBaseAddr + module.modBaseSize; curr += mbi.RegionSize) {
		if (!VirtualQueryEx(g_process_handle, (void*)curr, &mbi, sizeof(mbi))) continue;
		if (mbi.State != MEM_COMMIT || mbi.Protect == PAGE_NOACCESS) continue;

		char* buffer = new char[mbi.RegionSize];

		if (VirtualProtectEx(g_process_handle, mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &oldprotect)) {
			ReadProcessMemory(g_process_handle, mbi.BaseAddress, buffer, mbi.RegionSize, &bytesRead);
			VirtualProtectEx(g_process_handle, mbi.BaseAddress, mbi.RegionSize, oldprotect, &oldprotect);

			char* internalAddr = scan(pattern, mask, buffer, bytesRead);

			if (internalAddr != nullptr) { return curr + (uintptr_t)(internalAddr - buffer); }
		}
		delete[] buffer;
	}
	return 0x0;
}
```

`offsets.hpp`:

```hpp
#pragma once
//Game -> GameProfile ->
constexpr uintptr_t GAMEPROFILE_CHAIN1 = 0x78;
constexpr uintptr_t GAMEPROFILE_CHAIN2 = 0x0;
constexpr uintptr_t GAMEPROFILE_CHAIN3 = 0x130;

//Game -> GameProfile -> Camera ->
constexpr uintptr_t OFFSET_CAMERA_VIEWRIGHT = 0x1C0;
constexpr uintptr_t OFFSET_CAMERA_VIEWUP = 0x1D0;
constexpr uintptr_t OFFSET_CAMERA_VIEWFORWARD = 0x1E0;
constexpr uintptr_t OFFSET_CAMERA_VIEWTRANSLATION = 0x1F0;
constexpr uintptr_t OFFSET_CAMERA_VIEWFOVX = 0x380;
constexpr uintptr_t OFFSET_CAMERA_VIEWFOVY = 0x384;

//Game -> GameManager ->
constexpr uintptr_t OFFSET_GAMEMANAGER_ENTITYLIST = 0xC8;
constexpr uintptr_t OFFSET_GAMEMANAGER_ENTITY = 0x8; //Size

//Game -> GameManager -> EntityList -> INDEX -> Entity ->
constexpr uintptr_t OFFSET_ENTITY_ENTITYINFO = 0x28;
constexpr uintptr_t OFFSET_ENTITYINFO_MAINCOMPONENT = 0xD8; // EntityInfo ->
constexpr uintptr_t OFFSET_MAINCOMPONENT_CHILDCOMPONENT = 0x8; // MainComponent ->
constexpr uintptr_t OFFSET_CHILDCOMPONENT_HEALTH_INT = 0x168; // ChildComponent ->

//Game -> GameManager -> EntityList -> INDEX ->
constexpr uintptr_t OFFSET_ENTITY_REF = 0x20;
constexpr uintptr_t OFFSET_ENTITY_HEAD = 0x6A0;
constexpr uintptr_t OFFSET_ENTITY_FEET = 0x700;
```

`renderer.hpp`:

```hpp
#pragma once
#include "includes.hpp"

//window stuff
void render();

WPARAM loop() {
	MSG message;
	RECT rect;
	ZeroMemory(&rect, sizeof(RECT));
	GetWindowRect(g_game_hwnd, &rect);

	while (true) {
		ZeroMemory(&message, sizeof(MSG));

		if (PeekMessage(&message, NULL, 0, 0, PM_REMOVE)) {
			TranslateMessage(&message);
			DispatchMessage(&message);
		}

		if (message.message == WM_QUIT) { exit(0); }

		MoveWindow(g_hwnd, rect.left, rect.top, g_screen_width, g_screen_height, true);

		HWND hWindow2 = GetForegroundWindow();
		HWND hWindow3 = GetWindow(hWindow2, GW_HWNDPREV);

		SetWindowPos(g_hwnd, hWindow3, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
		UpdateWindow(g_hwnd);

		render();
		
		Sleep(5);
	}
	return message.wParam;
}

void init_d3d(HWND hwnd) {
	g_d3 = Direct3DCreate9(D3D_SDK_VERSION);

	D3DPRESENT_PARAMETERS direct3DPresetParams;
	ZeroMemory(&direct3DPresetParams, sizeof(direct3DPresetParams));

	direct3DPresetParams.Windowed = true;
	direct3DPresetParams.SwapEffect = D3DSWAPEFFECT_DISCARD;
	direct3DPresetParams.hDeviceWindow = hwnd;
	direct3DPresetParams.BackBufferFormat = D3DFMT_A8R8G8B8;
	direct3DPresetParams.BackBufferWidth = g_screen_width;
	direct3DPresetParams.BackBufferHeight = g_screen_height;
	direct3DPresetParams.EnableAutoDepthStencil = TRUE;
	direct3DPresetParams.AutoDepthStencilFormat = D3DFMT_D16;

	g_d3->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hwnd, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &direct3DPresetParams, &g_d3dev);
	D3DXCreateFontA(g_d3dev, 12, NULL, FW_BOLD, 1, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Tahoma", &g_d3Font);
	D3DXCreateLine(g_d3dev, &g_d3Line);
}

LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
	static MARGINS margins = { 0, 0, g_screen_width, g_screen_height };

	switch (message) {
		case WM_CREATE:
			DwmExtendFrameIntoClientArea(hWnd, &margins);
			break;
		case WM_DESTROY:
			PostQuitMessage(0);
			return 0;
	}
	return DefWindowProcA(hWnd, message, wParam, lParam);
}

void setup_window() {
	RECT rect;
	GetWindowRect(g_game_hwnd, &rect);

	WNDCLASSEX windowClass;
	ZeroMemory(&windowClass, sizeof(WNDCLASSEX));

	windowClass.cbSize = sizeof(WNDCLASSEX);
	windowClass.style = CS_HREDRAW | CS_VREDRAW;
	windowClass.lpfnWndProc = WindowProc;
	windowClass.hInstance = GetModuleHandleA(0);
	windowClass.hCursor = LoadCursorA(NULL, IDC_ARROW);
	windowClass.hbrBackground = (HBRUSH)RGB(0, 0, 0);
	windowClass.lpszClassName = "epic overlay";
	RegisterClassExA(&windowClass);

	g_hwnd = CreateWindowExA(WS_EX_LAYERED | WS_EX_TRANSPARENT, windowClass.lpszClassName, " ", WS_POPUP, rect.left, rect.top, g_screen_width, g_screen_height, NULL, NULL, windowClass.hInstance, NULL);

	SetLayeredWindowAttributes(g_hwnd, RGB(0, 0, 0), 0, ULW_COLORKEY);
	SetLayeredWindowAttributes(g_hwnd, 0, 255, LWA_ALPHA);

	ShowWindow(g_hwnd, SW_SHOW);
	init_d3d(g_hwnd);
}

//drawing functions
constexpr double M_PI = 3.141592653589793116;
constexpr D3DCOLOR epic_blue = D3DCOLOR_RGBA(0x41, 0x87, 0xF5, 0xFF);

constexpr D3DCOLOR red       = D3DCOLOR_RGBA(0xFF, 0x00, 0x00, 0xFF);
constexpr D3DCOLOR green     = D3DCOLOR_RGBA(0x00, 0xFF, 0x00, 0xFF);
constexpr D3DCOLOR blue      = D3DCOLOR_RGBA(0x00, 0x00, 0xFF, 0xFF);
constexpr D3DCOLOR black     = D3DCOLOR_RGBA(0x00, 0x00, 0x00, 0xFF);
constexpr D3DCOLOR white     = D3DCOLOR_RGBA(0xFF, 0xFF, 0xFF, 0xFF);

void draw_line(float x0, float y0, float x1, float y1, D3DCOLOR color) {
	D3DXVECTOR2 lines[2] = {
		D3DXVECTOR2(x0, y0),
		D3DXVECTOR2(x1, y1)
	};
	g_d3Line->Begin();
	g_d3Line->Draw(lines, 2, color);
	g_d3Line->End();
}

void draw_rect(float x, float y, float w, float h, D3DCOLOR color) {
	draw_line(x, y, x + w, y, color);
	draw_line(x, y, x, y + h, color);
	draw_line(x + w, y, x + w, y + h, color);
	draw_line(x, y + h, x + w + 1, y + h, color);
}

void draw_filled_rect(float x, float y, float w, float h, D3DCOLOR color) {
	D3DTLVERTEX qV[4] = {
		{ x, y + h, 0.f, 1.f, color },
		{ x, y, 0.f, 1.f, color },
		{ x + w, y + h, 0.f, 1.f, color },
		{ x + w, y , 0.f, 1.f, color }
	};
	g_d3dev->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
	g_d3dev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_d3dev->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1);
	g_d3dev->SetTexture(0, nullptr);
	g_d3dev->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, qV, sizeof(D3DTLVERTEX));
}

void draw_healthbars(float x, float y, float w, float h, float val, float max, D3DCOLOR color) {
	draw_rect(x, y - 1, w + 1, h + 2, black);
	draw_filled_rect(x, y, w, val / max * h, color);
	
}

void draw_outlined_rect(float x, float y, float w, float h, D3DCOLOR color) {
	draw_rect(x - 1, y - 1, w + 2, h + 2, black);
	draw_rect(x + 1, y + 1, w - 2, h - 2, black);
	draw_rect(x, y, w, h, color);
}

void draw_circle(float x, float y, float r, int num_sides, D3DCOLOR color) {
	D3DXVECTOR2 Line[128];
	double Step = M_PI * 2.0 / num_sides;
	int Count = 0;
	for (double a = 0; a < M_PI * 2.0; a += Step)
	{
		float X1 = r * cos(a) + x;
		float Y1 = r * sin(a) + y;
		float X2 = r * cos(a + Step) + x;
		float Y2 = r * sin(a + Step) + y;
		Line[Count].x = X1;
		Line[Count].y = Y1;
		Line[Count + 1].x = X2;
		Line[Count + 1].y = Y2;
		Count += 2;
	}
	g_d3Line->Draw(Line, Count, color);
}
```