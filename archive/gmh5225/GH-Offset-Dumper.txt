Project Path: arc_gmh5225_GH-Offset-Dumper_jhov9tvz

Source Tree:

```txt
arc_gmh5225_GH-Offset-Dumper_jhov9tvz
├── GH-Offset-Dumper.rc
├── GH-Offset-Dumper.sln
├── GH-Offset-Dumper.vcxproj
├── GH-Offset-Dumper.vcxproj.filters
├── GHDumper.cpp
├── GHDumper.h
├── Netvar.cpp
├── Netvar.h
├── SigData.cpp
├── SigData.h
├── SrcDumper.cpp
├── SrcDumper.h
├── SrcSDK.cpp
├── SrcSDK.h
├── config.json
├── csgo.h
├── icon-96px.ico
├── jsonxx
│   ├── LICENSE
│   ├── README.md
│   ├── circle.yml
│   ├── jsonxx.cc
│   ├── jsonxx.h
│   └── jsonxx_test.cc
├── main.cpp
├── modules
│   ├── Mod.cpp
│   ├── Mod.h
│   ├── ProcEx.cpp
│   ├── ProcEx.h
│   ├── ProcIn.cpp
│   ├── ProcIn.h
│   ├── patternscan.cpp
│   ├── patternscan.h
│   ├── proc.cpp
│   ├── proc.h
│   ├── rfw_ntapi.cpp
│   ├── rfw_ntapi.h
│   ├── rfw_ntdll.h
│   ├── stdafx.h
│   ├── util.cpp
│   └── util.h
├── readme.md
├── resource.h
├── stdafx.cpp
├── stdafx.h
└── targetver.h

```

`GH-Offset-Dumper.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
"resource.h\0"
END

2 TEXTINCLUDE
BEGIN
"#include ""winres.h""\r\n"
"\0"
END

3 TEXTINCLUDE
BEGIN
"\r\n"
"\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "icon-96px.ico"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
```

`GH-Offset-Dumper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29411.108
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GH-Offset-Dumper", "GH-Offset-Dumper.vcxproj", "{1722F02C-911E-44E4-8613-37AB98D08C22}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1722F02C-911E-44E4-8613-37AB98D08C22}.Debug|x64.ActiveCfg = Debug|x64
		{1722F02C-911E-44E4-8613-37AB98D08C22}.Debug|x64.Build.0 = Debug|x64
		{1722F02C-911E-44E4-8613-37AB98D08C22}.Debug|x86.ActiveCfg = Debug|Win32
		{1722F02C-911E-44E4-8613-37AB98D08C22}.Debug|x86.Build.0 = Debug|Win32
		{1722F02C-911E-44E4-8613-37AB98D08C22}.Release|x64.ActiveCfg = Release|x64
		{1722F02C-911E-44E4-8613-37AB98D08C22}.Release|x64.Build.0 = Release|x64
		{1722F02C-911E-44E4-8613-37AB98D08C22}.Release|x86.ActiveCfg = Release|Win32
		{1722F02C-911E-44E4-8613-37AB98D08C22}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C90DC54D-4A37-427A-8304-6EA885222B8F}
	EndGlobalSection
EndGlobal

```

`GH-Offset-Dumper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{1722F02C-911E-44E4-8613-37AB98D08C22}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>GHOffsetDumper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>true</GenerateManifest>
    <IncludePath>$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x64;$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>true</GenerateManifest>
    <IncludePath>$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x64;$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>true</GenerateManifest>
    <IncludePath>$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x64;$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>true</GenerateManifest>
    <IncludePath>$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x64;$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="GHDumper.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="jsonxx\jsonxx.cc">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="modules\Mod.cpp" />
    <ClCompile Include="modules\patternscan.cpp" />
    <ClCompile Include="modules\proc.cpp" />
    <ClCompile Include="modules\ProcEx.cpp" />
    <ClCompile Include="modules\ProcIn.cpp" />
    <ClCompile Include="modules\rfw_ntapi.cpp" />
    <ClCompile Include="modules\util.cpp" />
    <ClCompile Include="Netvar.cpp" />
    <ClCompile Include="SigData.cpp" />
    <ClCompile Include="SrcDumper.cpp" />
    <ClCompile Include="SrcSDK.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="GHDumper.h" />
    <ClInclude Include="jsonxx\jsonxx.h" />
    <ClInclude Include="modules\Mod.h" />
    <ClInclude Include="modules\patternscan.h" />
    <ClInclude Include="modules\proc.h" />
    <ClInclude Include="modules\ProcEx.h" />
    <ClInclude Include="modules\ProcIn.h" />
    <ClInclude Include="modules\rfw_ntapi.h" />
    <ClInclude Include="modules\rfw_ntdll.h" />
    <ClInclude Include="modules\util.h" />
    <ClInclude Include="Netvar.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="SigData.h" />
    <ClInclude Include="SrcDumper.h" />
    <ClInclude Include="SrcSDK.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="config.json" />
    <None Include="readme.md" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="GH-Offset-Dumper.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon-96px.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GH-Offset-Dumper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="jsonxx">
      <UniqueIdentifier>{a2455463-112f-4497-b005-963fcc5f517f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Dumper">
      <UniqueIdentifier>{54116524-0a94-4cfb-b795-71da8ebdcefc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Dumper-SrcEngine">
      <UniqueIdentifier>{726d3c21-22b5-460b-86f1-bac63c3aaa64}</UniqueIdentifier>
    </Filter>
    <Filter Include="rfw-modules">
      <UniqueIdentifier>{56cb912a-b69b-4393-9832-9bba5cbf9a25}</UniqueIdentifier>
    </Filter>
    <Filter Include="pch">
      <UniqueIdentifier>{c82d6899-0147-4933-885e-4a8e03e862d4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resources">
      <UniqueIdentifier>{149d1953-6852-4a53-aded-e86b651ee13e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="jsonxx\jsonxx.cc">
      <Filter>jsonxx</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>pch</Filter>
    </ClCompile>
    <ClCompile Include="GHDumper.cpp">
      <Filter>Dumper</Filter>
    </ClCompile>
    <ClCompile Include="SrcDumper.cpp">
      <Filter>Dumper-SrcEngine</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="modules\Mod.cpp">
      <Filter>rfw-modules</Filter>
    </ClCompile>
    <ClCompile Include="modules\proc.cpp">
      <Filter>rfw-modules</Filter>
    </ClCompile>
    <ClCompile Include="modules\ProcEx.cpp">
      <Filter>rfw-modules</Filter>
    </ClCompile>
    <ClCompile Include="modules\ProcIn.cpp">
      <Filter>rfw-modules</Filter>
    </ClCompile>
    <ClCompile Include="modules\rfw_ntapi.cpp">
      <Filter>rfw-modules</Filter>
    </ClCompile>
    <ClCompile Include="modules\util.cpp">
      <Filter>rfw-modules</Filter>
    </ClCompile>
    <ClCompile Include="modules\patternscan.cpp">
      <Filter>rfw-modules</Filter>
    </ClCompile>
    <ClCompile Include="SigData.cpp">
      <Filter>Dumper</Filter>
    </ClCompile>
    <ClCompile Include="Netvar.cpp">
      <Filter>Dumper-SrcEngine</Filter>
    </ClCompile>
    <ClCompile Include="SrcSDK.cpp">
      <Filter>Dumper-SrcEngine</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="jsonxx\jsonxx.h">
      <Filter>jsonxx</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>pch</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>pch</Filter>
    </ClInclude>
    <ClInclude Include="GHDumper.h">
      <Filter>Dumper</Filter>
    </ClInclude>
    <ClInclude Include="SrcDumper.h">
      <Filter>Dumper-SrcEngine</Filter>
    </ClInclude>
    <ClInclude Include="modules\Mod.h">
      <Filter>rfw-modules</Filter>
    </ClInclude>
    <ClInclude Include="modules\proc.h">
      <Filter>rfw-modules</Filter>
    </ClInclude>
    <ClInclude Include="modules\ProcEx.h">
      <Filter>rfw-modules</Filter>
    </ClInclude>
    <ClInclude Include="modules\ProcIn.h">
      <Filter>rfw-modules</Filter>
    </ClInclude>
    <ClInclude Include="modules\rfw_ntapi.h">
      <Filter>rfw-modules</Filter>
    </ClInclude>
    <ClInclude Include="modules\rfw_ntdll.h">
      <Filter>rfw-modules</Filter>
    </ClInclude>
    <ClInclude Include="modules\util.h">
      <Filter>rfw-modules</Filter>
    </ClInclude>
    <ClInclude Include="modules\patternscan.h">
      <Filter>rfw-modules</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Resources</Filter>
    </ClInclude>
    <ClInclude Include="SigData.h">
      <Filter>Dumper</Filter>
    </ClInclude>
    <ClInclude Include="Netvar.h">
      <Filter>Dumper-SrcEngine</Filter>
    </ClInclude>
    <ClInclude Include="SrcSDK.h">
      <Filter>Dumper-SrcEngine</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="config.json" />
    <None Include="readme.md" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="GH-Offset-Dumper.rc">
      <Filter>Resources</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon-96px.ico">
      <Filter>Resources</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`GHDumper.cpp`:

```cpp
#include "stdafx.h"
#include "GHDumper.h"
#include "SigData.h"

jsonxx::Object ParseConfig()
{
	//Open File Stream & parse JSON data into object
	std::ifstream f("config.json", std::ios::in);
	std::string jsonBuffer((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());
	jsonxx::Object o;
	o.parse(jsonBuffer);
	return o;
}

Dumper::Dumper() {}

Dumper::Dumper(jsonxx::Object* json)
{
	jsonConfig = json;

	//Get & attach to process
	//std::string procName = jsonConfig->get<std::string>("executable");
	std::string procName = "hl2.exe";

	//Find proc & open handle
	ProcEx proc((char*)procName.c_str());
}

void Dumper::ProcessSignatures()
{
	//select signature array in json
	jsonxx::Array sigs = jsonConfig->get<jsonxx::Array>("signatures");

	//Loop through json signature array
	for (size_t i = 0; i < sigs.size(); i++)
	{
		jsonxx::Object curr = sigs.get<jsonxx::Object>(i);
		SigData currData;

		currData.name = curr.get<std::string>("name");
		currData.extra = (int)curr.get<jsonxx::Number>("extra");
		currData.relative = curr.get<jsonxx::Boolean>("relative");
		currData.module = curr.get<std::string>("module");

		//dump offsets from json into vector, not all have offsets
		jsonxx::Array offsetArray;

		//only grab them if they exist
		if (curr.has<jsonxx::Array>("offsets"))
		{
			offsetArray = curr.get<jsonxx::Array>("offsets");

			//Despite most only have 1 offset, it's an arrays
			for (size_t j = 0; j < offsetArray.size(); j++)
			{
				currData.offsets.push_back((int)offsetArray.get<jsonxx::Number>(j));
			}
		}

		currData.comboPattern = curr.get<std::string>("pattern");
		signatures.push_back(currData);
	}

	for (auto& s : signatures)
	{
		//Scan for the pattern, process the relative & extra offsets
		s.Scan(proc);
	}
}

void Dumper::GenerateHeaderOuput()
{
	//TODO: convert to string output
	std::ofstream file;
	file.open(jsonConfig->get<std::string>("filename") + ".h");

	file << "#pragma once\n#include <cstdint>\n";
	//timestamp

	file << "//GuidedHacking.com r0x0rs ur b0x0rs\n";

	file << "namespace offsets\n{\n";

	for (auto s : signatures)
	{
		file << "constexpr ptrdiff_t " << s.name << " = 0x" << std::uppercase << std::hex << s.result << ";\n";
	}

	file << "\n}\n";

	file.close();
}

void Dumper::Dump()
{
	ProcessSignatures();

	//Generate header output
	GenerateHeaderOuput();

	//Generate Cheat Engine output

	//Generate ReClass.NET output

	//Write Output files
}
```

`GHDumper.h`:

```h
#pragma once
#include "stdafx.h"
#include <Windows.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <Windows.h>
#include "modules\ProcEx.h"
#include "modules\Mod.h"
#include "modules\patternscan.h"
#include "jsonxx\jsonxx.h"
#include "SigData.h"

jsonxx::Object ParseConfig();

class Dumper
{
public:
	jsonxx::Object* jsonConfig{ nullptr };
	ProcEx proc{};
	std::vector<SigData> signatures;

	Dumper();
	Dumper(jsonxx::Object* json);

	void ProcessSignatures();

	void GenerateHeaderOuput();

	virtual void Dump();
};
```

`Netvar.cpp`:

```cpp
#include "stdafx.h"
#include "Netvar.h"

void NetvarData::Get(ProcEx proc, SigData dwGetAllClasses)
{
	//https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/public/client_class.h
	//https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/public/client_class.cpp
}

DataType NetvarData::GetDataType()
{
	if (name.find("m_b") != std::string::npos)
		return DataType::DT_BYTE; //boolean

	else if (name.find("m_fl") != std::string::npos)
		return DataType::DT_FLOAT;

	else if (name.find("m_vec") != std::string::npos)
		return DataType::DT_FLOAT;

	else if (strfindi(name ,"angle") != std::string::npos)
		return DataType::DT_FLOAT;

	else if (name.find("m_i") != std::string::npos)
		return DataType::DT_INT;

	else return DataType::DT_INT_HEX;
}

std::string NetvarData::GetCEVariableTypeString()
{
	std::string result;

	DataType dt = GetDataType();

	switch (dt)
	{
	//Just making a basic CE table for now, finish later
	/*
	case DataType::DT_BYTE:
		result = "<VariableType>Byte</VariableType>\n"; break;
		
	case DataType::DT_FLOAT:
		result = "<VariableType>Float</VariableType>\n"; break;

	case DataType::DT_INT_HEX:
		result = "<ShowAsHex>1</ShowAsHex>\n<VariableType>4 Bytes</VariableType>\n"; break;
	*/
	default:
		result = result + "<ShowAsHex>1</ShowAsHex>\n" + "<VariableType>4 Bytes</VariableType>\n"; break;
	}
	return result;
}
```

`Netvar.h`:

```h
#pragma once
#include <Windows.h>
#include "modules\ProcEx.h"
#include "modules\Mod.h"
#include "SigData.h"

const std::string LocalEntityOffsetNames[] =
{
	"m_iHealth"
};

struct NetvarData
{
	intptr_t result;
	std::string name;
	std::string prop;
	std::string table;
	int offset{ 0 };

	void Get(ProcEx proc, SigData dwGetAllClasses);

	DataType GetDataType();
	std::string GetCEVariableTypeString();
};
```

`SigData.cpp`:

```cpp
#include "stdafx.h"
#include "SigData.h"

void SigData::Scan(ProcEx proc)
{
	//TODO: Remove this when we detach this project from RFW
	ModEx mod((char*)module.c_str(), proc);

	//Scan for the pattern
	result = (intptr_t)Pattern::Ex::ScanMod((char*)comboPattern.c_str(), mod);

	//first offset is relative to pattern location, different than FindDMAAddy, you must add offset first, then RPM
	if (offsets.size() != 0)
	{
		for (auto o : offsets)
		{
			result = result + o;
			ReadProcessMemory(proc.handle, (BYTE*)result, &result, sizeof(o), NULL);
		}
	}

	//offset into the resulting address, if necessary
	if (extra)
	{
		result = result + extra;
	}

	//if a relative offset, get the relative offset
	if (relative)
	{
		result = result - (uintptr_t)mod.modEntry.modBaseAddr;
	}
}
```

`SigData.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <Windows.h>
#include "modules\ProcEx.h"
#include "modules\Mod.h"
#include "modules\patternscan.h"
#include "jsonxx\jsonxx.h"

enum class DataType
{
	DT_BYTE, DT_FLOAT, DT_INT, DT_INT_HEX
};

struct SigData
{
	//json config vars
	std::string name;
	int extra{ 0 };
	bool relative{ false };
	std::string module;
	std::vector<int> offsets;
	std::string comboPattern;

	intptr_t result;

	//extra vars for output
	DataType dataType;
	std::string offsetBase;

	//Perform the pattern scan
	void Scan(ProcEx proc);
};
```

`SrcDumper.cpp`:

```cpp
#include "stdafx.h"
#include "SrcDumper.h"

SrcDumper::SrcDumper() {}

SrcDumper::SrcDumper(jsonxx::Object* json)
{
	jsonConfig = json;

	std::string procName = jsonConfig->get<std::string>("executable");

	//Find proc & open handle
	proc = ProcEx((char*)procName.c_str());
}

intptr_t SrcDumper::GetdwGetAllClassesAddr()
{
	for (auto s : signatures)
	{
		if (s.name == "dwGetAllClasses")
		{
			return s.result;
		}
	}
	return 0;
}

HMODULE SrcDumper::LoadClientDLL(ProcEx proc)
{
	ModEx mod(_T("client.dll"), proc);
	std::filesystem::path p(mod.modEntry.szExePath);

	p = p.parent_path().parent_path().parent_path() / "bin";
	AddDllDirectory(p.wstring().c_str());

	return LoadLibraryEx(mod.modEntry.szExePath, NULL, LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
}

intptr_t GetOffset(RecvTable* table, const char* tableName, const char* netvarName)
{
	for (int i = 0; i < table->m_nProps; i++)
	{
		RecvProp prop = table->m_pProps[i];

		if (!_stricmp(prop.m_pVarName, netvarName))
		{
			return prop.m_Offset;
		}

		if (prop.m_pDataTable)
		{
			intptr_t offset = GetOffset(prop.m_pDataTable, tableName, netvarName);

			if (offset)
			{
				return offset + prop.m_Offset;
			}
		}
	}
	return 0;
}

intptr_t SrcDumper::GetNetVarOffset(const char* tableName, const char* netvarName, ClientClass* clientClass)
{
	ClientClass* currNode = clientClass;

	for (auto currNode = clientClass; currNode; currNode = currNode->m_pNext)
	{
		if (!_stricmp(tableName, currNode->m_pRecvTable->m_pNetTableName))
		{
			return GetOffset(currNode->m_pRecvTable, tableName, netvarName);
		}
	}

	return 0;
}

void SrcDumper::ProcessNetvars()
{
	jsonxx::Array netvars = jsonConfig->get<jsonxx::Array>("netvars");

	//Loop through JSON netvar array
	for (size_t i = 0; i < netvars.size(); i++)
	{
		jsonxx::Object curr = netvars.get<jsonxx::Object>(i);
		NetvarData currData;

		currData.name = curr.get<jsonxx::String>("name");
		currData.prop = curr.get<jsonxx::String>("prop");
		currData.table = curr.get<jsonxx::String>("table");

		//dump offsets from json into vector
		if (curr.has<jsonxx::Number>("offset"))
		{
			jsonxx::Number offset = curr.get<jsonxx::Number>("offset");
			currData.offset = (int)offset;
		}

		Netvars.push_back(currData);
	}

	//^ we parsed the json into Netvars

	//now we can locally load client_panorama.dll and get the netvar offsets internally
	HMODULE hMod = LoadClientDLL(proc);

	//Get First ClientClass in the linked list
	ClientClass* dwGetallClassesAddr = (ClientClass*)((intptr_t)hMod + GetdwGetAllClassesAddr());
	
	//for each netvar in netvars, get the offset
	
	for (NetvarData& n : Netvars)
	{
		n.result = GetNetVarOffset(n.table.c_str(), n.prop.c_str(), dwGetallClassesAddr);

		if (n.offset)
		{
			n.result += n.offset;
		}
	}
}

void SrcDumper::GenerateHeaderOuput()
{
	//TODO: convert to string output
	std::ofstream file;
	file.open(jsonConfig->get<std::string>("filename") + ".h");

	file << "#pragma once\n#include <cstdint>\n";
	//timestamp

	file << "//GuidedHacking.com r0x0rs ur b0x0rs\n";

	file << "namespace offsets\n{\n";

	file << "//signatures\n";

	for (auto s : signatures)
	{
		file << "constexpr ptrdiff_t " << s.name << " = 0x" << std::uppercase << std::hex << s.result << ";\n";
	}

	file << "\n//netvars\n";

	for (auto n : Netvars)
	{
		file << "constexpr ptrdiff_t " << n.name << " = 0x" << std::uppercase << std::hex << n.result << ";\n";
	}

	file << "}";

	file.close();
}

void SrcDumper::GenerateCheatEngineOutput()
{
	std::string output;

	//header
	output += "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
	output += "<CheatTable CheatEngineTableVersion=\"31\">\n";

	//todo: add all vars to the cheat table in module.dll + symbol form
	//most are offset from client base address, some from clientstate I believe
	//most are prefixed with f, i, etc... to define the variable type, we can use substring search to pull this info maybe
	
	//Work In Progress: We are only adding symbol names and adding each sig/netvar as a relative offset
	//not currently displaying correct data type and the full address, just a basic CE Table

	int count = 0;
	
	output += "<CheatEntries>\n";

	for (auto n : Netvars)
	{
		std::string netvarOutput;

		netvarOutput += "<CheatEntry>\n<ID>";
		netvarOutput += std::to_string(count); //decimal
		netvarOutput += "</ID>\n<Description>";
		netvarOutput += n.name;
		netvarOutput += "</Description>\n";
		netvarOutput += n.GetCEVariableTypeString();

		//netvarOutput += "<LastState/>\n<Address>client_panorama.dll + ";
		//netvarOutput += AddrToHexString(n.result); //hex uppercase

		//temporary output for basic CE table
		netvarOutput += "<LastState/>\n<Address>" + n.name;

		//end temp output
		
		netvarOutput += "</Address>\n</CheatEntry>\n";;

		output += netvarOutput;
		count++;
	}

	for (auto s : signatures)
	{
		std::string sigOutput;

		sigOutput += "<CheatEntry>\n";
		sigOutput += "<ID>" + std::to_string(count);
		sigOutput += "</ID>\n";
		sigOutput += "<Description>" + s.name + "</Description>\n";

		//sigOutput += "<LastState/>\n";
		//sigOutput += "<Address>client_panorama.dll + ";
		//sigOutput += AddrToHexString(s.result);

		//temporary output for basic CE table
		sigOutput += "<LastState/>\n<Address>" + s.name;
		//end temp output

		sigOutput += "</Address>\n</CheatEntry>\n";

		output += sigOutput;
		count++;
	}

	output += "</CheatEntries>";
	//end cheat entries output

	//Add all offsets as User Defined Symbols, these are aliases for addresses you can use throughout your table
	output += "<UserdefinedSymbols>";

	for (auto n : Netvars)
	{
		output += "<SymbolEntry>\n";
		output += "<Name>" + n.name + "</Name>\n";
		output += "<Address>";
		output += AddrToHexString(n.result);
		output += "</Address>\n";
		output += "</SymbolEntry>\n";
	}

	for (auto s : signatures)
	{
		output += "<SymbolEntry>\n";
		output += "<Name>" + s.name + "</Name>\n";
		output += "<Address>";
		output += AddrToHexString(s.result);
		output += "</Address>\n";
		output += "</SymbolEntry>\n";
	}

	output += "</UserdefinedSymbols>\n";
	//end symbol output



	//footer
	output += "</CheatTable>";

	std::ofstream file;
	file.open(jsonConfig->get<std::string>("filename") + ".CT");
	file << output;
	file.close();
}

void SrcDumper::Dump()
{
	ProcessSignatures();

	ProcessNetvars();

	//Generate header output
	GenerateHeaderOuput();

	//Generate Cheat Engine output
	GenerateCheatEngineOutput();

	//Generate ReClass.NET output
}

std::string SrcDumper::GetSigBase(SigData sigdata)
{
	std::string sigBase;

	if (sigdata.name.find("clientstate_") != std::string::npos)
	{
		sigBase = "[" + sigdata.module + "dwClientState]";
	}

	else
	{
		sigBase = sigdata.module;
	}

	return sigBase;
	//does sig.module define the base module of the offset as well as signature?  think so
}
```

`SrcDumper.h`:

```h
#pragma once
#include <Windows.h>
#include <filesystem>
#include "GHDumper.h"
#include "SrcSDK.h"
#include "Netvar.h"
#include "SigData.h"

class SrcDumper : public Dumper
{
public:
	std::vector<NetvarData> Netvars;

	SrcDumper();
	SrcDumper(jsonxx::Object* json);

	intptr_t GetdwGetAllClassesAddr();

	HMODULE LoadClientDLL(ProcEx proc);

	intptr_t GetNetVarOffset(const char* tableName, const char* netvarName, ClientClass* clientClass);

	void ProcessNetvars();

	virtual void Dump();

	void GenerateHeaderOuput();

	void GenerateCheatEngineOutput();

	std::string GetSigBase(SigData sigdata);
};
```

`SrcSDK.cpp`:

```cpp
#include "stdafx.h"
#include "SrcSDK.h"

```

`SrcSDK.h`:

```h
#pragma once
#include <Windows.h>

class RecvProp;

class RecvTable
{
public:

	RecvProp*	m_pProps;
	int			m_nProps;
	void*		m_pDecoder;
	char*		m_pNetTableName;
	bool		m_bInitialized;
	bool		m_bInMainList;
};

//unnecessary class pointers have been converted to void* for simplicity

class RecvProp
{
public:
	char*					m_pVarName;
	void*					m_RecvType;
	int                     m_Flags;
	int                     m_StringBufferSize;
	int                     m_bInsideArray;
	const void*				m_pExtraData;
	RecvProp*				m_pArrayProp;
	void*					m_ArrayLengthProxy;
	void*					m_ProxyFn;
	void*					m_DataTableProxyFn;
	RecvTable* m_pDataTable;
	int                     m_Offset;
	int                     m_ElementStride;
	int                     m_nElements;
	const char*				m_pParentArrayPropName;
};

class ClientClass
{
public:
	void*			m_pCreateFn;
	void*			m_pCreateEventFn;
	char*			m_pNetworkName;
	RecvTable*		m_pRecvTable;
	ClientClass*	m_pNext;
	int				m_ClassID;
};
```

`config.json`:

```json
{
  "executable": "csgo.exe",
  "filename": "csgo",
  "signatures": [
    {
      "name": "dwClientState",
      "extra": 0,
      "relative": true,
      "module": "engine.dll",
      "offsets": [
        1
      ],
      "pattern": "A1 ? ? ? ? 33 D2 6A 00 6A 00 33 C9 89 B0"
    },
    {
      "name": "dwClientState_GetLocalPlayer",
      "extra": 0,
      "relative": false,
      "module": "engine.dll",
      "offsets": [
        2
      ],
      "pattern": "8B 80 ? ? ? ? 40 C3"
    },
    {
      "name": "dwClientState_IsHLTV",
      "extra": 0,
      "relative": false,
      "module": "engine.dll",
      "offsets": [
        2
      ],
      "pattern": "80 BF ? ? ? ? ? 0F 84 ? ? ? ? 32 DB"
    },
    {
      "name": "dwClientState_Map",
      "extra": 0,
      "relative": false,
      "module": "engine.dll",
      "offsets": [
        1
      ],
      "pattern": "05 ? ? ? ? C3 CC CC CC CC CC CC CC A1"
    },
    {
      "name": "dwClientState_MapDirectory",
      "extra": 0,
      "relative": false,
      "module": "engine.dll",
      "offsets": [
        7
      ],
      "pattern": "B8 ? ? ? ? C3 05 ? ? ? ? C3"
    },
    {
      "name": "dwClientState_MaxPlayer",
      "extra": 0,
      "relative": false,
      "module": "engine.dll",
      "offsets": [
        7
      ],
      "pattern": "A1 ? ? ? ? 8B 80 ? ? ? ? C3 CC CC CC CC 55 8B EC 8A 45 08"
    },
    {
      "name": "dwClientState_PlayerInfo",
      "extra": 0,
      "relative": false,
      "module": "engine.dll",
      "offsets": [
        2
      ],
      "pattern": "8B 89 ? ? ? ? 85 C9 0F 84 ? ? ? ? 8B 01"
    },
    {
      "name": "dwClientState_State",
      "extra": 0,
      "relative": false,
      "module": "engine.dll",
      "offsets": [
        2
      ],
      "pattern": "83 B8 ? ? ? ? ? 0F 94 C0 C3"
    },
    {
      "name": "dwClientState_ViewAngles",
      "extra": 0,
      "relative": false,
      "module": "engine.dll",
      "offsets": [
        4
      ],
      "pattern": "F3 0F 11 80 ? ? ? ? D9 46 04 D9 05"
    },
    {
        "name": "clientstate_delta_ticks",
        "extra": 0,
        "relative": false,
        "module": "engine.dll",
        "offsets": [
            2
        ],
        "pattern": "C7 87 ? ? ? ? ? ? ? ? FF 15 ? ? ? ? 83 C4 08"
    },
    {
        "name": "clientstate_last_outgoing_command",
        "extra": 0,
        "relative": false,
        "module": "engine.dll",
        "offsets": [
            2
        ],
        "pattern": "8B 8F ? ? ? ? 8B 87 ? ? ? ? 41"
    },
    {
        "name": "clientstate_choked_commands",
        "extra": 0,
        "relative": false,
        "module": "engine.dll",
        "offsets": [
            2
        ],
        "pattern": "8B 87 ? ? ? ? 41"
    },
    {
      "name": "clientstate_net_channel",
      "extra": 0,
      "relative": false,
      "module": "engine.dll",
      "offsets": [
        2
      ],
      "pattern": "8B 8F ? ? ? ? 8B 01 8B 40 18"
    },
    {
      "name": "dwEntityList",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        1
      ],
      "pattern": "BB ? ? ? ? 83 FF 01 0F 8C ? ? ? ? 3B F8"
    },
    {
      "name": "dwForceAttack",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "89 0D ? ? ? ? 8B 0D ? ? ? ? 8B F2 8B C1 83 CE 04"
    },
    {
      "name": "dwForceAttack2",
      "extra": 12,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "89 0D ? ? ? ? 8B 0D ? ? ? ? 8B F2 8B C1 83 CE 04"
    },
    {
      "name": "dwForceBackward",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        287
      ],
      "pattern": "55 8B EC 51 53 8A 5D 08"
    },
    {
      "name": "dwForceForward",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        245
      ],
      "pattern": "55 8B EC 51 53 8A 5D 08"
    },
    {
      "name": "dwForceJump",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "8B 0D ? ? ? ? 8B D6 8B C1 83 CA 02"
    },
    {
      "name": "dwForceLeft",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        465
      ],
      "pattern": "55 8B EC 51 53 8A 5D 08"
    },
    {
      "name": "dwForceRight",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        512
      ],
      "pattern": "55 8B EC 51 53 8A 5D 08"
    },
    {
      "name": "dwGameDir",
      "extra": 0,
      "relative": true,
      "module": "engine.dll",
      "offsets": [
        1
      ],
      "pattern": "68 ? ? ? ? 8D 85 ? ? ? ? 50 68 ? ? ? ? 68"
    },
    {
      "name": "dwGameRulesProxy",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        1
      ],
      "pattern": "A1 ? ? ? ? 85 C0 0F 84 ? ? ? ? 80 B8 ? ? ? ? ? 74 7A"
    },
    {
      "name": "dwGetAllClasses",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        1,
        0
      ],
      "pattern": "A1 ? ? ? ? C3 CC CC CC CC CC CC CC CC CC CC A1 ? ? ? ? B9"
    },
    {
      "name": "dwGlobalVars",
      "extra": 0,
      "relative": true,
      "module": "engine.dll",
      "offsets": [
        1
      ],
      "pattern": "68 ? ? ? ? 68 ? ? ? ? FF 50 08 85 C0"
    },
    {
      "name": "dwGlowObjectManager",
      "extra": 4,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        1
      ],
      "pattern": "A1 ? ? ? ? A8 01 75 4B"
    },
    {
      "name": "dwInput",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        1
      ],
      "pattern": "B9 ? ? ? ? F3 0F 11 04 24 FF 50 10"
    },
    {
      "name": "dwInterfaceLinkList",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [],
      "pattern": "8B 35 ? ? ? ? 57 85 F6 74 ? 8B 7D 08 8B 4E 04 8B C7 8A 11 3A 10"
    },
    {
      "name": "dwLocalPlayer",
      "extra": 4,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        3
      ],
      "pattern": "8D 34 85 ? ? ? ? 89 15 ? ? ? ? 8B 41 08 8B 48 04 83 F9 FF"
    },
    {
      "name": "dwMouseEnable",
      "extra": 48,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        1
      ],
      "pattern": "B9 ? ? ? ? FF 50 34 85 C0 75 10"
    },
    {
      "name": "dwMouseEnablePtr",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        1
      ],
      "pattern": "B9 ? ? ? ? FF 50 34 85 C0 75 10"
    },
    {
      "name": "dwPlayerResource",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "8B 3D ? ? ? ? 85 FF 0F 84 ? ? ? ? 81 C7"
    },
    {
      "name": "dwRadarBase",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        1
      ],
      "pattern": "A1 ? ? ? ? 8B 0C B0 8B 01 FF 50 ? 46 3B 35 ? ? ? ? 7C EA 8B 0D"
    },
    {
      "name": "dwSensitivity",
      "extra": 44,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "81 F9 ? ? ? ? 75 1D F3 0F 10 05 ? ? ? ? F3 0F 11 44 24 ? 8B 44 24 18 35 ? ? ? ? 89 44 24 0C EB 0B"
    },
    {
      "name": "dwSensitivityPtr",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "81 F9 ? ? ? ? 75 1D F3 0F 10 05 ? ? ? ? F3 0F 11 44 24 ? 8B 44 24 18 35 ? ? ? ? 89 44 24 0C EB 0B"
    },
    {
      "name": "dwSetClanTag",
      "extra": 0,
      "relative": true,
      "module": "engine.dll",
      "offsets": [],
      "pattern": "53 56 57 8B DA 8B F9 FF 15"
    },
    {
      "name": "dwViewMatrix",
      "extra": 176,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        3
      ],
      "pattern": "0F 10 05 ? ? ? ? 8D 85 ? ? ? ? B9"
    },
    {
      "name": "dwWeaponTable",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        1
      ],
      "pattern": "B9 ? ? ? ? 6A 00 FF 50 08 C3"
    },
    {
      "name": "dwWeaponTableIndex",
      "extra": 0,
      "relative": false,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "39 86 ? ? ? ? 74 06 89 86 ? ? ? ? 8B 86"
    },
    {
      "name": "dwYawPtr",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "81 F9 ? ? ? ? 75 1D F3 0F 10 05 ? ? ? ? F3 0F 11 44 24 ? 8B 44 24 1C 35 ? ? ? ? 89 44 24 18 EB 0B 8B 01 8B 40 30 FF D0 D9 5C 24 18 F3 0F 10 06"
    },
    {
      "name": "dwZoomSensitivityRatioPtr",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "81 F9 ? ? ? ? 75 1A F3 0F 10 05 ? ? ? ? F3 0F 11 45 ? 8B 45 F4 35 ? ? ? ? 89 45 FC EB 0A 8B 01 8B 40 30 FF D0 D9 5D FC A1"
    },
    {
      "name": "dwbSendPackets",
      "extra": 1,
      "relative": true,
      "module": "engine.dll",
      "offsets": [],
      "pattern": "B3 01 8B 01 8B 40 10 FF D0 84 C0 74 0F 80 BF ? ? ? ? ? 0F 84"
    },
    {
      "name": "dwppDirect3DDevice9",
      "extra": 0,
      "relative": true,
      "module": "shaderapidx9.dll",
      "offsets": [
        1
      ],
      "pattern": "A1 ? ? ? ? 50 8B 08 FF 51 0C"
    },
    {
      "name": "m_pStudioHdr",
      "extra": 0,
      "relative": false,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "8B B6 ? ? ? ? 85 F6 74 05 83 3E 00 75 02 33 F6 F3 0F 10 44 24"
    },
    {
      "name": "m_yawClassPtr",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "81 F9 ? ? ? ? 75 16 F3 0F 10 05 ? ? ? ? F3 0F 11 45 ? 81 75 ? ? ? ? ? EB 0A 8B 01 8B 40 30 FF D0 D9 5D 0C 8B 55 08"
    },
    {
      "name": "m_pitchClassPtr",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "offsets": [
        1
      ],
      "pattern": "A1 ? ? ? ? 89 74 24 28"
    },
    {
        "name": "interface_engine_cvar",
        "extra": 0,
        "relative": true,
        "module": "vstdlib.dll",
        "offsets": [
            2
        ],
        "pattern": "8B 0D ? ? ? ? C7 05"
    },
    {
        "name": "convar_name_hash_table",
        "extra": 0,
        "relative": true,
        "module": "vstdlib.dll",
        "offsets": [
            3
        ],
        "pattern": "8B 3C 85"
    },
    {
        "name": "m_bDormant",
        "extra": 8,
        "relative": false,
        "module": "client.dll",
        "offsets": [
            2
        ],
        "pattern": "8A 81 ? ? ? ? C3 32 C0"
    },
    {
       "name": "model_ambient_min",
       "extra": 0,
       "relative": true,
       "module": "engine.dll",
       "offsets": [
         4
       ],
       "pattern": "F3 0F 10 0D ? ? ? ? F3 0F 11 4C 24 ? 8B 44 24 20 35 ? ? ? ? 89 44 24 0C"
    },
    {
      "name": "set_abs_angles",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "pattern": "55 8B EC 83 E4 F8 83 EC 64 53 56 57 8B F1 E8"
    },
    {
      "name": "set_abs_origin",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "pattern": "55 8B EC 83 E4 F8 51 53 56 57 8B F1 E8"
    },
    {
      "name": "is_c4_owner",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "pattern": "56 8B F1 85 F6 74 31"
    },
    {
      "name": "force_update_spectator_glow",
      "extra": 0,
      "relative": true,
      "module": "client.dll",
      "pattern": "74 07 8B CB E8 ? ? ? ? 83 C7 10"
    },
    {
      "name": "anim_overlays",
      "extra": 0,
      "relative": false,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "8B 89 ? ? ? ? 8D 0C D1"
    },
    {
      "name": "m_flSpawnTime",
      "extra": 0,
      "relative": false,
      "module": "client.dll",
      "offsets": [
        2
      ],
      "pattern": "89 86 ? ? ? ? E8 ? ? ? ? 80 BE ? ? ? ? ?"
    },
    {
      "name": "find_hud_element",
      "extra": 0,
      "relative": false,
      "module": "client.dll",
      "pattern": "55 8B EC 53 8B 5D 08 56 57 8B F9 33 F6 39 77 28"
    }
  ],
  "netvars": [
    {
      "name": "m_ArmorValue",
      "prop": "m_ArmorValue",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_Collision",
      "prop": "m_Collision",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_CollisionGroup",
      "prop": "m_CollisionGroup",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_Local",
      "prop": "m_Local",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_MoveType",
      "prop": "m_nRenderMode",
      "offset": 1,
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_OriginalOwnerXuidHigh",
      "prop": "m_OriginalOwnerXuidHigh",
      "table": "DT_BaseAttributableItem"
    },
    {
      "name": "m_OriginalOwnerXuidLow",
      "prop": "m_OriginalOwnerXuidLow",
      "table": "DT_BaseAttributableItem"
    },
    {
      "name": "m_aimPunchAngle",
      "prop": "m_aimPunchAngle",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_aimPunchAngleVel",
      "prop": "m_aimPunchAngleVel",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_bGunGameImmunity",
      "prop": "m_bGunGameImmunity",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_bHasDefuser",
      "prop": "m_bHasDefuser",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_bHasHelmet",
      "prop": "m_bHasHelmet",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_bInReload",
      "prop": "m_flNextPrimaryAttack",
      "offset": 109,
      "table": "DT_BaseCombatWeapon"
    },
    {
      "name": "m_bIsDefusing",
      "prop": "m_bIsDefusing",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_bIsScoped",
      "prop": "m_bIsScoped",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_bSpotted",
      "prop": "m_bSpotted",
      "table": "DT_BaseEntity"
    },
    {
      "name": "m_bSpottedByMask",
      "prop": "m_bSpottedByMask",
      "table": "DT_BaseEntity"
    },
    {
      "name": "m_dwBoneMatrix",
      "prop": "m_nForceBone",
      "offset": 28,
      "table": "DT_BaseAnimating"
    },
    {
      "name": "m_fAccuracyPenalty",
      "prop": "m_fAccuracyPenalty",
      "table": "DT_WeaponCSBase"
    },
    {
      "name": "m_fFlags",
      "prop": "m_fFlags",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_flFallbackWear",
      "prop": "m_flFallbackWear",
      "table": "DT_BaseAttributableItem"
    },
    {
      "name": "m_flFlashDuration",
      "prop": "m_flFlashDuration",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_flFlashMaxAlpha",
      "prop": "m_flFlashMaxAlpha",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_flNextPrimaryAttack",
      "prop": "m_flNextPrimaryAttack",
      "table": "DT_BaseCombatWeapon"
    },
    {
      "name": "m_hActiveWeapon",
      "prop": "m_hActiveWeapon",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_hMyWeapons",
      "prop": "m_hActiveWeapon",
      "offset": -256,
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_hObserverTarget",
      "prop": "m_hObserverTarget",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_hOwner",
      "prop": "m_hOwner",
      "table": "DT_PredictedViewModel"
    },
    {
      "name": "m_hOwnerEntity",
      "prop": "m_hOwnerEntity",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_iAccountID",
      "prop": "m_iAccountID",
      "table": "DT_BaseAttributableItem"
    },
    {
      "name": "m_iClip1",
      "prop": "m_iClip1",
      "table": "DT_BaseCombatWeapon"
    },
    {
      "name": "m_iCompetitiveRanking",
      "prop": "m_iCompetitiveRanking",
      "table": "DT_CSPlayerResource"
    },
    {
      "name": "m_iCompetitiveWins",
      "prop": "m_iCompetitiveWins",
      "table": "DT_CSPlayerResource"
    },
    {
      "name": "m_iCrosshairId",
      "prop": "m_bHasDefuser",
      "offset": 92,
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_iEntityQuality",
      "prop": "m_iEntityQuality",
      "table": "DT_BaseAttributableItem"
    },
    {
      "name": "m_iFOVStart",
      "prop": "m_iFOVStart",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_iFOV",
      "prop": "m_iFOV",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_iGlowIndex",
      "prop": "m_flFlashDuration",
      "offset": 24,
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_iHealth",
      "prop": "m_iHealth",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_iItemDefinitionIndex",
      "prop": "m_iItemDefinitionIndex",
      "table": "DT_BaseCombatWeapon"
    },
    {
      "name": "m_iItemIDHigh",
      "prop": "m_iItemIDHigh",
      "table": "DT_BaseAttributableItem"
    },
    {
      "name": "m_iObserverMode",
      "prop": "m_iObserverMode",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_iShotsFired",
      "prop": "m_iShotsFired",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_iState",
      "prop": "m_iState",
      "table": "DT_BaseCombatWeapon"
    },
    {
      "name": "m_iTeamNum",
      "prop": "m_iTeamNum",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_lifeState",
      "prop": "m_lifeState",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_nFallbackPaintKit",
      "prop": "m_nFallbackPaintKit",
      "table": "DT_BaseAttributableItem"
    },
    {
      "name": "m_nFallbackSeed",
      "prop": "m_nFallbackSeed",
      "table": "DT_BaseAttributableItem"
    },
    {
      "name": "m_nFallbackStatTrak",
      "prop": "m_nFallbackStatTrak",
      "table": "DT_BaseAttributableItem"
    },
    {
      "name": "m_nForceBone",
      "prop": "m_nForceBone",
      "table": "DT_BaseAnimating"
    },
    {
      "name": "m_nTickBase",
      "prop": "m_nTickBase",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_rgflCoordinateFrame",
      "prop": "m_CollisionGroup",
      "offset": -48,
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_szCustomName",
      "prop": "m_szCustomName",
      "table": "DT_BaseAttributableItem"
    },
    {
      "name": "m_szLastPlaceName",
      "prop": "m_szLastPlaceName",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_vecOrigin",
      "prop": "m_vecOrigin",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_vecVelocity",
      "prop": "m_vecVelocity[0]",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_vecViewOffset",
      "prop": "m_vecViewOffset[0]",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_viewPunchAngle",
      "prop": "m_viewPunchAngle",
      "table": "DT_BasePlayer"
    },
    {
      "name": "m_thirdPersonViewAngles",
      "prop": "deadflag",
      "offset": 4,
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_clrRender",
      "prop": "m_clrRender",
      "table": "DT_BaseEntity"
    },
    {
      "name": "m_flC4Blow",
      "prop": "m_flC4Blow",
      "table": "DT_PlantedC4"
    },
    {
      "name": "m_flTimerLength",
      "prop": "m_flTimerLength",
      "table": "DT_PlantedC4"
    },
    {
      "name": "m_flDefuseLength",
      "prop": "m_flDefuseLength",
      "table": "DT_PlantedC4"
    },
    {
      "name": "m_flDefuseCountDown",
      "prop": "m_flDefuseCountDown",
      "table": "DT_PlantedC4"
    },
    {
      "name": "cs_gamerules_data",
      "prop": "cs_gamerules_data",
      "table": "DT_CSGameRulesProxy"
    },
    {
      "name": "m_SurvivalRules",
      "prop": "m_SurvivalRules",
      "table": "DT_CSGameRulesProxy"
    },
    {
      "name": "m_SurvivalGameRuleDecisionTypes",
      "prop": "m_SurvivalGameRuleDecisionTypes",
      "table": "DT_CSGameRulesProxy"
    },
    {
      "name": "m_bIsValveDS",
      "prop": "m_bIsValveDS",
      "table": "DT_CSGameRulesProxy"
    },
    {
      "name": "m_bFreezePeriod",
      "prop": "m_bFreezePeriod",
      "table": "DT_CSGameRulesProxy"
    },
    {
      "name": "m_bBombPlanted",
      "prop": "m_bBombPlanted",
      "table": "DT_CSGameRulesProxy"
    },
    {
      "name": "m_bIsQueuedMatchmaking",
      "prop": "m_bIsQueuedMatchmaking",
      "table": "DT_CSGameRulesProxy"
    },
    {
      "name": "m_flSimulationTime",
      "prop": "m_flSimulationTime",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_flLowerBodyYawTarget",
      "prop": "m_flLowerBodyYawTarget",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_angEyeAnglesX",
      "prop": "m_angEyeAngles[0]",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_angEyeAnglesY",
      "prop": "m_angEyeAngles[1]",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_flNextAttack",
      "prop": "m_flNextAttack",
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_iMostRecentModelBoneCounter",
      "prop": "m_nForceBone",
      "offset": 4,
      "table": "DT_CSPlayer"
    },
    {
      "name": "m_flLastBoneSetupTime",
      "prop": "m_nSequence",
      "offset": 104,
      "table": "DT_BaseAnimating"
    },
    {
      "name": "m_bStartedArming",
      "prop": "m_bStartedArming",
      "table": "DT_WeaponC4"
    },
    {
      "name": "m_bUseCustomBloomScale",
      "prop": "m_bUseCustomBloomScale",
      "table": "DT_EnvTonemapController"
    },
    {
      "name": "m_bUseCustomAutoExposureMin",
      "prop": "m_bUseCustomAutoExposureMin",
      "table": "DT_EnvTonemapController"
    },
    {
      "name": "m_bUseCustomAutoExposureMax",
      "prop": "m_bUseCustomAutoExposureMax",
      "table": "DT_EnvTonemapController"
    },
    {
      "name": "m_flCustomBloomScale",
      "prop": "m_flCustomBloomScale",
      "table": "DT_EnvTonemapController"
    },
    {
      "name": "m_flCustomAutoExposureMin",
      "prop": "m_flCustomAutoExposureMin",
      "table": "DT_EnvTonemapController"
    },
    {
      "name": "m_flCustomAutoExposureMax",
      "prop": "m_flCustomAutoExposureMax",
      "table": "DT_EnvTonemapController"
    }
  ]
}
```

`csgo.h`:

```h
#pragma once
#include <cstdint>
//GuidedHacking.com r0x0rs ur b0x0rs
namespace offsets
{

//signatures

constexpr ptrdiff_t dwClientState = 0x588DC4;
constexpr ptrdiff_t dwClientState_GetLocalPlayer = 0x180;
constexpr ptrdiff_t dwClientState_IsHLTV = 0x4D40;
constexpr ptrdiff_t dwClientState_Map = 0x28C;
constexpr ptrdiff_t dwClientState_MapDirectory = 0x188;
constexpr ptrdiff_t dwClientState_MaxPlayer = 0x388;
constexpr ptrdiff_t dwClientState_PlayerInfo = 0x52B8;
constexpr ptrdiff_t dwClientState_State = 0x108;
constexpr ptrdiff_t dwClientState_ViewAngles = 0x4D88;
constexpr ptrdiff_t clientstate_delta_ticks = 0x174;
constexpr ptrdiff_t clientstate_last_outgoing_command = 0x4D24;
constexpr ptrdiff_t clientstate_choked_commands = 0x4D28;
constexpr ptrdiff_t clientstate_net_channel = 0x9C;
constexpr ptrdiff_t dwEntityList = 0x4D3B69C;
constexpr ptrdiff_t dwForceAttack = 0x316CD44;
constexpr ptrdiff_t dwForceAttack2 = 0x316CD50;
constexpr ptrdiff_t dwForceBackward = 0x316CD98;
constexpr ptrdiff_t dwForceForward = 0x316CDA4;
constexpr ptrdiff_t dwForceJump = 0x51DEE88;
constexpr ptrdiff_t dwForceLeft = 0x316CDBC;
constexpr ptrdiff_t dwForceRight = 0x316CDB0;
constexpr ptrdiff_t dwGameDir = 0x62F4F0;
constexpr ptrdiff_t dwGameRulesProxy = 0x525216C;
constexpr ptrdiff_t dwGetAllClasses = 0xD4DC9C;
constexpr ptrdiff_t dwGlobalVars = 0x588AC8;
constexpr ptrdiff_t dwGlowObjectManager = 0x527CEB8;
constexpr ptrdiff_t dwInput = 0x5186838;
constexpr ptrdiff_t dwInterfaceLinkList = 0x8F3B94;
constexpr ptrdiff_t dwLocalPlayer = 0xD27AAC;
constexpr ptrdiff_t dwMouseEnable = 0xD2D650;
constexpr ptrdiff_t dwMouseEnablePtr = 0xD2D620;
constexpr ptrdiff_t dwPlayerResource = 0x316B0DC;
constexpr ptrdiff_t dwRadarBase = 0x51703FC;
constexpr ptrdiff_t dwSensitivity = 0xD2D4EC;
constexpr ptrdiff_t dwSensitivityPtr = 0xD2D4C0;
constexpr ptrdiff_t dwSetClanTag = 0x89B40;
constexpr ptrdiff_t dwViewMatrix = 0x4D2D0B4;
constexpr ptrdiff_t dwWeaponTable = 0x51872FC;
constexpr ptrdiff_t dwWeaponTableIndex = 0x323C;
constexpr ptrdiff_t dwYawPtr = 0xD2D2B0;
constexpr ptrdiff_t dwZoomSensitivityRatioPtr = 0xD324D0;
constexpr ptrdiff_t dwbSendPackets = 0xD330A;
constexpr ptrdiff_t dwppDirect3DDevice9 = 0xA6030;
constexpr ptrdiff_t m_pStudioHdr = 0x294C;
constexpr ptrdiff_t m_yawClassPtr = 0xD2D2B0;
constexpr ptrdiff_t m_pitchClassPtr = 0x5170698;
constexpr ptrdiff_t interface_engine_cvar = 0x3E9EC;
constexpr ptrdiff_t convar_name_hash_table = 0x2F0F8;
constexpr ptrdiff_t m_bDormant = 0xED;
constexpr ptrdiff_t model_ambient_min = 0x58BDE4;
constexpr ptrdiff_t set_abs_angles = 0x1CEA80;
constexpr ptrdiff_t set_abs_origin = 0x1CE8C0;
constexpr ptrdiff_t is_c4_owner = 0x3A4160;
constexpr ptrdiff_t force_update_spectator_glow = 0x397D32;
constexpr ptrdiff_t anim_overlays = 0x2980;
constexpr ptrdiff_t m_flSpawnTime = 0xA360;
constexpr ptrdiff_t find_hud_element = 0x2B46B5B0;

//netvars

constexpr ptrdiff_t m_ArmorValue = 0xB368;
constexpr ptrdiff_t m_Collision = 0x320;
constexpr ptrdiff_t m_CollisionGroup = 0x474;
constexpr ptrdiff_t m_Local = 0x2FBC;
constexpr ptrdiff_t m_MoveType = 0x25C;
constexpr ptrdiff_t m_OriginalOwnerXuidHigh = 0x31B4;
constexpr ptrdiff_t m_OriginalOwnerXuidLow = 0x31B0;
constexpr ptrdiff_t m_aimPunchAngle = 0x302C;
constexpr ptrdiff_t m_aimPunchAngleVel = 0x3038;
constexpr ptrdiff_t m_bGunGameImmunity = 0x3930;
constexpr ptrdiff_t m_bHasDefuser = 0xB378;
constexpr ptrdiff_t m_bHasHelmet = 0xB35C;
constexpr ptrdiff_t m_bInReload = 0x3285;
constexpr ptrdiff_t m_bIsDefusing = 0x391C;
constexpr ptrdiff_t m_bIsScoped = 0x3914;
constexpr ptrdiff_t m_bSpotted = 0x93D;
constexpr ptrdiff_t m_bSpottedByMask = 0x980;
constexpr ptrdiff_t m_dwBoneMatrix = 0x26A8;
constexpr ptrdiff_t m_fAccuracyPenalty = 0x3310;
constexpr ptrdiff_t m_fFlags = 0x104;
constexpr ptrdiff_t m_flFallbackWear = 0x31C0;
constexpr ptrdiff_t m_flFlashDuration = 0xA410;
constexpr ptrdiff_t m_flFlashMaxAlpha = 0xA40C;
constexpr ptrdiff_t m_flNextPrimaryAttack = 0x3218;
constexpr ptrdiff_t m_hActiveWeapon = 0x2EF8;
constexpr ptrdiff_t m_hMyWeapons = 0x2DF8;
constexpr ptrdiff_t m_hObserverTarget = 0x3388;
constexpr ptrdiff_t m_hOwner = 0x29CC;
constexpr ptrdiff_t m_hOwnerEntity = 0x14C;
constexpr ptrdiff_t m_iAccountID = 0x2FC8;
constexpr ptrdiff_t m_iClip1 = 0x3244;
constexpr ptrdiff_t m_iCompetitiveRanking = 0x1A84;
constexpr ptrdiff_t m_iCompetitiveWins = 0x1B88;
constexpr ptrdiff_t m_iCrosshairId = 0xB3D4;
constexpr ptrdiff_t m_iEntityQuality = 0x2FAC;
constexpr ptrdiff_t m_iFOVStart = 0x31E8;
constexpr ptrdiff_t m_iFOV = 0x31E4;
constexpr ptrdiff_t m_iGlowIndex = 0xA428;
constexpr ptrdiff_t m_iHealth = 0x100;
constexpr ptrdiff_t m_iItemDefinitionIndex = 0x2FAA;
constexpr ptrdiff_t m_iItemIDHigh = 0x2FC0;
constexpr ptrdiff_t m_iObserverMode = 0x3374;
constexpr ptrdiff_t m_iShotsFired = 0xA380;
constexpr ptrdiff_t m_iState = 0x3238;
constexpr ptrdiff_t m_iTeamNum = 0xF4;
constexpr ptrdiff_t m_lifeState = 0x25F;
constexpr ptrdiff_t m_nFallbackPaintKit = 0x31B8;
constexpr ptrdiff_t m_nFallbackSeed = 0x31BC;
constexpr ptrdiff_t m_nFallbackStatTrak = 0x31C4;
constexpr ptrdiff_t m_nForceBone = 0x268C;
constexpr ptrdiff_t m_nTickBase = 0x342C;
constexpr ptrdiff_t m_rgflCoordinateFrame = 0x444;
constexpr ptrdiff_t m_szCustomName = 0x303C;
constexpr ptrdiff_t m_szLastPlaceName = 0x35B0;
constexpr ptrdiff_t m_vecOrigin = 0x138;
constexpr ptrdiff_t m_vecVelocity = 0x114;
constexpr ptrdiff_t m_vecViewOffset = 0x108;
constexpr ptrdiff_t m_viewPunchAngle = 0x3020;
constexpr ptrdiff_t m_thirdPersonViewAngles = 0x31D8;
constexpr ptrdiff_t m_clrRender = 0x70;
constexpr ptrdiff_t m_flC4Blow = 0x2990;
constexpr ptrdiff_t m_flTimerLength = 0x2994;
constexpr ptrdiff_t m_flDefuseLength = 0x29A8;
constexpr ptrdiff_t m_flDefuseCountDown = 0x29AC;
constexpr ptrdiff_t cs_gamerules_data = 0x0;
constexpr ptrdiff_t m_SurvivalRules = 0xCF8;
constexpr ptrdiff_t m_SurvivalGameRuleDecisionTypes = 0x1320;
constexpr ptrdiff_t m_bIsValveDS = 0x75;
constexpr ptrdiff_t m_bFreezePeriod = 0x20;
constexpr ptrdiff_t m_bBombPlanted = 0x99D;
constexpr ptrdiff_t m_bIsQueuedMatchmaking = 0x74;
constexpr ptrdiff_t m_flSimulationTime = 0x268;
constexpr ptrdiff_t m_flLowerBodyYawTarget = 0x3A7C;
constexpr ptrdiff_t m_angEyeAnglesX = 0xB36C;
constexpr ptrdiff_t m_angEyeAnglesY = 0xB370;
constexpr ptrdiff_t m_flNextAttack = 0x2D70;
constexpr ptrdiff_t m_iMostRecentModelBoneCounter = 0x2690;
constexpr ptrdiff_t m_flLastBoneSetupTime = 0x2924;
constexpr ptrdiff_t m_bStartedArming = 0x33D0;
constexpr ptrdiff_t m_bUseCustomBloomScale = 0x9DA;
constexpr ptrdiff_t m_bUseCustomAutoExposureMin = 0x9D8;
constexpr ptrdiff_t m_bUseCustomAutoExposureMax = 0x9D9;
constexpr ptrdiff_t m_flCustomBloomScale = 0x9E4;
constexpr ptrdiff_t m_flCustomAutoExposureMin = 0x9DC;
constexpr ptrdiff_t m_flCustomAutoExposureMax = 0x9E0;

}

```

`jsonxx/LICENSE`:

```
Copyright (c) 2010 Hong Jiang

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.


```

`jsonxx/README.md`:

```md
# JSON++

[![Build Status](https://travis-ci.org/hjiang/jsonxx.svg?branch=master)](https://travis-ci.org/hjiang/jsonxx)

## Introduction

JSON++ is a light-weight JSON parser, writer and reader written in C++.
JSON++ can also convert JSON documents into lossless XML documents.

## Contributors

* http://github.com/hjiang
* http://github.com/elanthis
* http://github.com/r-lyeh

If you've made substantial contribution, please add your link here. 

## Why another JSON parser?

Perhaps because web service clients are usually written in dynamic languages these days, none of the existing C++ JSON parsers fitted my needs very well, so I wrote one that I used in another project. My goals for JSON++ were:

* Efficient in both memory and speed.
* No third party dependencies. JSON++ only depends on the standard C++ library.
* Cross platform.
* Robust.
* Small and convenient API. Most of the time, you only need to call one function and two function templates.
* Easy to integrate. JSON++ only has one source file and one header file. Just compile the source file and link with your program.
* Able to construct documents dynamically.
* JSON writer: write documents in JSON format.

Other contributors have sinced added more functionalities:

* XML writer: convert documents to JSONx format. See http://goo.gl/I3cxs for details.
* XML writer: convert documents to JXML format. See https://github.com/r-lyeh/JXML for details.
* XML writer: convert documents to JXMLex format. See https://github.com/r-lyeh/JXMLex for details.
* XML writer: convert documents to tagged XML format. See https://github.com/hjiang/jsonxx/issues/12 for details.

## Compiler version

You need a modern C++ compiler. For older compilers, please try [legacy branch](https://github.com/hjiang/jsonxx/tree/legacy).

## Configuration

### Strict/permissive parsing

JSONxx can parse JSON documents both in strict or permissive mode.

When `jsonxx::Settings::Parser` is set to `Strict`, JSONxx parser will accept:
* Fully conformant JSON documents *only*.

When `jsonxx::Settings::Parser` is set to `Permissive`, JSONxx parser will accept:
* Fully conformant JSON documents
* Ending commas in arrays and objects: `{ "array": [0,1,2,], }`
* Single quoted strings: `['hello', "world"]`
* C++ style comments: `{ "width": 320, "height": 240 } //Picture details`

Default value is `Permissive`.

When `jsonxx::Settings::UnquotedKeys` is set to `Enabled`, JSONxx parser will accept:
* Unquoted keys: `{name: "world"}`

Default value is `Disabled`.

### Assertions

JSONxx uses internally `JSONXX_ASSERT(...)` macro that works both in debug and release mode. Set `jsonxx::Settings::Assertions` value to `Disabled` to disable assertions.

Default value is `Enabled`.

## Usage

The following snippets are from one of the unit tests. They are quite self-descriptive.

~~~C++
using namespace std;
using namespace jsonxx;

string teststr(
        "{"
        "  \"foo\" : 1,"
        "  \"bar\" : false,"
        "  \"person\" : {\"name\" : \"GWB\", \"age\" : 60,},"
        "  \"data\": [\"abcd\", 42],"
        "}"
);

// Parse string or stream
Object o;
assert(o.parse(teststr));

// Validation. Checking for JSON types and values as well
assert(1 == o.get<Number>("foo"));
assert(o.has<Boolean>("bar"));
assert(o.has<Object>("person"));
assert(o.get<Object>("person").has<Number>("age"));
assert(!o.get<Object>("person").has<Boolean>("old"));
assert(o.get<Object>("person").get<Boolean>("old", false));
assert(o.has<Array>("data"));
assert(o.get<Array>("data").get<Number>(1) == 42);
assert(o.get<Array>("data").get<String>(0) == "abcd");
assert(o.get<Array>("data").get<String>(2, "hello") == "hello");
assert(!o.has<Number>("data"));
cout << o.json() << endl;                     // JSON output
cout << o.xml(JSONx) << endl;                 // JSON to XML conversion (JSONx subtype)
cout << o.xml(JXML) << endl;                  // JSON to XML conversion (JXML subtype)
cout << o.xml(JXMLex) << endl;                // JSON to XML conversion (JXMLex subtype)
~~~

~~~C++
// Generate JSON document dynamically
using namespace std;
using namespace jsonxx;
Array a;
a << 123;
a << "hello world";
a << 3.1415;
a << 99.95f;
a << 'h';
a << Object("key", "value");
Object o;
o << "key1" << "value";
o << "key2" << 123;
o << "key3" << a;
cout << o.json() << endl;
~~~

## To do

* Custom JSON comments (C style /**/) when permissive parsing is enabled.

```

`jsonxx/circle.yml`:

```yml
compile:
  override:
    - make

test:
  override:
    - make test

```

`jsonxx/jsonxx.cc`:

```cc
// -*- mode: c++; c-basic-offset: 4; -*-

// Author: Hong Jiang <hong@hjiang.net>
// Contributors:
//   Sean Middleditch <sean@middleditch.us>
//   rlyeh <https://github.com/r-lyeh>
#include "jsonxx.h"

#include <cctype>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <vector>
#include <limits>
#include <mutex>

// Snippet that creates an assertion function that works both in DEBUG & RELEASE mode.
// JSONXX_ASSERT(...) macro will redirect to this. assert() macro is kept untouched.
#if defined(NDEBUG) || defined(_NDEBUG)
#   define JSONXX_REENABLE_NDEBUG
#   undef  NDEBUG
#   undef _NDEBUG
#endif
#include <stdio.h>
#include <cassert>
void jsonxx::assertion(const char* file, int line, const char* expression, bool result) {
	if (!result) {
		fprintf(stderr, "[JSONXX] expression '%s' failed at %s:%d -> ", expression, file, line);
		assert(0);
	}
}
#if defined(JSONXX_REENABLE_NDEBUG)
#   define  NDEBUG
#   define _NDEBUG
#endif
#include <cassert>

namespace jsonxx {

	//static_assert( sizeof(unsigned long long) < sizeof(long double), "'long double' cannot hold 64bit values in this compiler :(");

	bool match(const char* pattern, std::istream& input);
	bool parse_array(std::istream& input, Array& array);
	bool parse_bool(std::istream& input, Boolean& value);
	bool parse_comment(std::istream& input);
	bool parse_null(std::istream& input);
	bool parse_number(std::istream& input, Number& value);
	bool parse_object(std::istream& input, Object& object);
	bool parse_string(std::istream& input, String& value);
	bool parse_identifier(std::istream& input, String& value);
	bool parse_value(std::istream& input, Value& value);

	// Try to consume characters from the input stream and match the
	// pattern string.
	bool match(const char* pattern, std::istream& input) {
		input >> std::ws;
		const char* cur(pattern);
		char ch(0);
		while (input && !input.eof() && *cur != 0) {
			input.get(ch);
			if (ch != *cur) {
				input.putback(ch);
				if (parse_comment(input))
					continue;
				while (cur > pattern) {
					cur--;
					input.putback(*cur);
				}
				return false;
			}
			else {
				cur++;
			}
		}
		return *cur == 0;
	}

	bool parse_string(std::istream& input, String& value) {
		char ch = '\0', delimiter = '"';
		if (!match("\"", input)) {
			if (parser_is_strict()) {
				return false;
			}
			delimiter = '\'';
			if (input.peek() != delimiter) {
				return false;
			}
			input.get(ch);
		}
		while (!input.eof() && input.good()) {
			input.get(ch);
			if (ch == delimiter) {
				break;
			}
			if (ch == '\\') {
				input.get(ch);
				switch (ch) {
				case '\\':
				case '/':
					value.push_back(ch);
					break;
				case 'b':
					value.push_back('\b');
					break;
				case 'f':
					value.push_back('\f');
					break;
				case 'n':
					value.push_back('\n');
					break;
				case 'r':
					value.push_back('\r');
					break;
				case 't':
					value.push_back('\t');
					break;
				case 'u': {
					int i;
					std::stringstream ss;
					for (i = 0; (!input.eof() && input.good()) && i < 4; ++i) {
						input.get(ch);
						ss << std::hex << ch;
					}
					if (input.good() && (ss >> i))
						value.push_back(static_cast<char>(i));
				}
						break;
				default:
					if (ch != delimiter) {
						value.push_back('\\');
						value.push_back(ch);
					}
					else value.push_back(ch);
					break;
				}
			}
			else {
				value.push_back(ch);
			}
		}
		if (input && ch == delimiter) {
			return true;
		}
		else {
			return false;
		}
	}

	bool parse_identifier(std::istream& input, String& value) {
		input >> std::ws;

		char ch = '\0', delimiter = ':';
		bool first = true;

		while (!input.eof() && input.good()) {
			input.get(ch);

			if (ch == delimiter) {
				input.unget();
				break;
			}

			if (first) {
				if ((ch != '_' && ch != '$') &&
					(ch < 'a' || ch > 'z') &&
					(ch < 'A' || ch > 'Z')) {
					return false;
				}
				first = false;
			}
			if (ch == '_' || ch == '$' ||
				(ch >= 'a' && ch <= 'z') ||
				(ch >= 'A' && ch <= 'Z') ||
				(ch >= '0' && ch <= '9')) {
				value.push_back(ch);
			}
			else if (ch == '\t' || ch == ' ') {
				input >> std::ws;
			}
		}
		if (input && ch == delimiter) {
			return true;
		}
		else {
			return false;
		}
	}

	bool parse_number(std::istream& input, Number& value) {
		input >> std::ws;
		std::streampos rollback = input.tellg();
		input >> value;
		if (input.fail()) {
			input.clear();
			input.seekg(rollback);
			return false;
		}
		return true;
	}

	bool parse_bool(std::istream& input, Boolean& value) {
		if (match("true", input)) {
			value = true;
			return true;
		}
		if (match("false", input)) {
			value = false;
			return true;
		}
		return false;
	}

	bool parse_null(std::istream& input) {
		if (match("null", input)) {
			return true;
		}
		if (parser_is_strict()) {
			return false;
		}
		return (input.peek() == ',');
	}

	bool parse_array(std::istream& input, Array& array) {
		return array.parse(input);
	}

	bool parse_object(std::istream& input, Object& object) {
		return object.parse(input);
	}

	bool parse_comment(std::istream& input) {
		if (parser_is_permissive())
			if (!input.eof() && input.peek() == '/')
			{
				char ch0(0);
				input.get(ch0);

				if (!input.eof())
				{
					char ch1(0);
					input.get(ch1);

					if (ch0 == '/' && ch1 == '/')
					{
						// trim chars till \r or \n
						for (char ch(0); !input.eof() && (input.peek() != '\r' && input.peek() != '\n'); )
							input.get(ch);

						// consume spaces, tabs, \r or \n, in case no eof is found
						if (!input.eof())
							input >> std::ws;
						return true;
					}

					input.unget();
					input.clear();
				}

				input.unget();
				input.clear();
			}

		return false;
	}

	bool parse_value(std::istream& input, Value& value) {
		return value.parse(input);
	}

	Object::Object() : value_map_() {}

	Object::~Object() {
		reset();
	}

	bool Object::parse(std::istream& input, Object& object) {
		object.reset();

		if (!match("{", input)) {
			return false;
		}
		if (match("}", input)) {
			return true;
		}

		do {
			std::string key;
			if (unquoted_keys_are_enabled()) {
				if (!parse_identifier(input, key)) {
					if (parser_is_permissive()) {
						if (input.peek() == '}')
							break;
					}
					return false;
				}
			}
			else {
				if (!parse_string(input, key)) {
					if (parser_is_permissive()) {
						if (input.peek() == '}')
							break;
					}
					return false;
				}
			}
			if (!match(":", input)) {
				return false;
			}
			Value* v = new Value();
			if (!parse_value(input, *v)) {
				delete v;
				break;
			}
			// TODO(hjiang): Add an option to allow duplicated keys?
			if (object.value_map_.find(key) == object.value_map_.end()) {
				object.value_map_[key] = v;
			}
			else {
				if (parser_is_permissive()) {
					delete object.value_map_[key];
					object.value_map_[key] = v;
				}
				else {
					delete v;
					return false;
				}
			}
		} while (match(",", input));

		if (!match("}", input)) {
			return false;
		}

		return true;
	}

	Value::Value() : type_(INVALID_) {}

	void Value::reset() {
		if (type_ == STRING_) {
			delete string_value_;
			string_value_ = 0;
		}
		else if (type_ == OBJECT_) {
			delete object_value_;
			object_value_ = 0;
		}
		else if (type_ == ARRAY_) {
			delete array_value_;
			array_value_ = 0;
		}
	}

	bool Value::parse(std::istream& input, Value& value) {
		value.reset();

		std::string string_value;
		if (parse_string(input, string_value)) {
			value.string_value_ = new std::string();
			value.string_value_->swap(string_value);
			value.type_ = STRING_;
			return true;
		}
		if (parse_number(input, value.number_value_)) {
			value.type_ = NUMBER_;
			return true;
		}

		if (parse_bool(input, value.bool_value_)) {
			value.type_ = BOOL_;
			return true;
		}
		if (parse_null(input)) {
			value.type_ = NULL_;
			return true;
		}
		if (input.peek() == '[') {
			value.array_value_ = new Array();
			if (parse_array(input, *value.array_value_)) {
				value.type_ = ARRAY_;
				return true;
			}
			delete value.array_value_;
		}
		value.object_value_ = new Object();
		if (parse_object(input, *value.object_value_)) {
			value.type_ = OBJECT_;
			return true;
		}
		delete value.object_value_;
		return false;
	}

	Array::Array() : values_() {}

	Array::~Array() {
		reset();
	}

	bool Array::parse(std::istream& input, Array& array) {
		array.reset();

		if (!match("[", input)) {
			return false;
		}
		if (match("]", input)) {
			return true;
		}

		do {
			Value* v = new Value();
			if (!parse_value(input, *v)) {
				delete v;
				break;
			}
			array.values_.push_back(v);
		} while (match(",", input));

		if (!match("]", input)) {
			return false;
		}
		return true;
	}

	static std::ostream& stream_string(std::ostream& stream,
		const std::string& string) {
		stream << '"';
		for (std::string::const_iterator i = string.begin(),
			e = string.end(); i != e; ++i) {
			switch (*i) {
			case '"':
				stream << "\\\"";
				break;
			case '\\':
				stream << "\\\\";
				break;
			case '/':
				stream << "\\/";
				break;
			case '\b':
				stream << "\\b";
				break;
			case '\f':
				stream << "\\f";
				break;
			case '\n':
				stream << "\\n";
				break;
			case '\r':
				stream << "\\r";
				break;
			case '\t':
				stream << "\\t";
				break;
			default:
				if (*i < 32) {
					stream << "\\u" << std::hex << std::setw(4) <<
						std::setfill('0') << static_cast<int>(*i) << std::dec <<
						std::setw(0);
				}
				else {
					stream << *i;
				}
			}
		}
		stream << '"';
		return stream;
	}

}  // namespace jsonxx

std::ostream& operator<<(std::ostream& stream, const jsonxx::Value& v) {
	using namespace jsonxx;
	if (v.is<Number>()) {
		return stream << v.get<Number>();
	}
	else if (v.is<String>()) {
		return stream_string(stream, v.get<std::string>());
	}
	else if (v.is<Boolean>()) {
		if (v.get<Boolean>()) {
			return stream << "true";
		}
		else {
			return stream << "false";
		}
	}
	else if (v.is<Null>()) {
		return stream << "null";
	}
	else if (v.is<Object>()) {
		return stream << v.get<Object>();
	}
	else if (v.is<Array>()) {
		return stream << v.get<Array>();
	}
	// Shouldn't reach here.
	return stream;
}

std::ostream& operator<<(std::ostream& stream, const jsonxx::Array& v) {
	stream << "[";
	jsonxx::Array::container::const_iterator
		it = v.values().begin(),
		end = v.values().end();
	while (it != end) {
		stream << *(*it);
		++it;
		if (it != end) {
			stream << ", ";
		}
	}
	return stream << "]";
}

std::ostream& operator<<(std::ostream& stream, const jsonxx::Object& v) {
	stream << "{";
	jsonxx::Object::container::const_iterator
		it = v.kv_map().begin(),
		end = v.kv_map().end();
	while (it != end) {
		jsonxx::stream_string(stream, it->first);
		stream << ": " << *(it->second);
		++it;
		if (it != end) {
			stream << ", ";
		}
	}
	return stream << "}";
}

namespace jsonxx {
	namespace {

		typedef unsigned char byte;

		//template<bool quote>
		std::string escape_string(const std::string& input, const bool quote = false) {
			static std::string map[256], * once = 0;
			static std::mutex mutex;
			if (!once) {
				// The problem here is that, once is initializing at the end of job, but if multithreaded application is starting this for the first time
				// it will jump into this part with several threads and cause double free or corruptions.
				// To prevent it, it is required to have mutex, to lock other threads while only one of them is constructing the static map.
				mutex.lock();
				if (!once) {
					// base
					for (int i = 0; i < 256; ++i) {
						map[i] = std::string() + char(i);
					}
					// non-printable
					for (int i = 0; i < 32; ++i) {
						std::stringstream str;
						str << "\\u" << std::hex << std::setw(4) << std::setfill('0') << i;
						map[i] = str.str();
					}
					// exceptions
					map[byte('"')] = "\\\"";
					map[byte('\\')] = "\\\\";
					map[byte('/')] = "\\/";
					map[byte('\b')] = "\\b";
					map[byte('\f')] = "\\f";
					map[byte('\n')] = "\\n";
					map[byte('\r')] = "\\r";
					map[byte('\t')] = "\\t";

					once = map;
				}
				mutex.unlock();
			}
			std::string output;
			output.reserve(input.size() * 2 + 2); // worst scenario
			if (quote) output += '"';
			for (std::string::const_iterator it = input.begin(), end = input.end(); it != end; ++it)
				output += map[byte(*it)];
			if (quote) output += '"';
			return output;
		}

		namespace json {

			std::string remove_last_comma(const std::string& _input) {
				std::string input(_input);
				size_t size = input.size();
				if (size > 2)
					if (input[size - 2] == ',')
						input[size - 2] = ' ';
				return input;
			}

			std::string tag(unsigned format, unsigned depth, const std::string& name, const jsonxx::Value& t) {
				std::stringstream ss;
				const std::string tab(depth, '\t');

				if (!name.empty())
					ss << tab << '\"' << escape_string(name) << '\"' << ':' << ' ';
				else
					ss << tab;

				switch (t.type_)
				{
				default:
				case jsonxx::Value::NULL_:
					ss << "null";
					return ss.str() + ",\n";

				case jsonxx::Value::BOOL_:
					ss << (t.bool_value_ ? "true" : "false");
					return ss.str() + ",\n";

				case jsonxx::Value::ARRAY_:
					ss << "[\n";
					for (Array::container::const_iterator it = t.array_value_->values().begin(),
						end = t.array_value_->values().end(); it != end; ++it)
						ss << tag(format, depth + 1, std::string(), **it);
					return remove_last_comma(ss.str()) + tab + "]" ",\n";

				case jsonxx::Value::STRING_:
					ss << '\"' << escape_string(*t.string_value_) << '\"';
					return ss.str() + ",\n";

				case jsonxx::Value::OBJECT_:
					ss << "{\n";
					for (Object::container::const_iterator it = t.object_value_->kv_map().begin(),
						end = t.object_value_->kv_map().end(); it != end; ++it)
						ss << tag(format, depth + 1, it->first, *it->second);
					return remove_last_comma(ss.str()) + tab + "}" ",\n";

				case jsonxx::Value::NUMBER_:
					// max precision
					ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1);
					ss << t.number_value_;
					return ss.str() + ",\n";
				}
			}
		} // namespace jsonxx::anon::json

		namespace xml {

			std::string escape_attrib(const std::string& input) {
				static std::string map[256], * once = 0;
				if (!once) {
					for (int i = 0; i < 256; ++i)
						map[i] = "_";
					for (int i = int('a'); i <= int('z'); ++i)
						map[i] = std::string() + char(i);
					for (int i = int('A'); i <= int('Z'); ++i)
						map[i] = std::string() + char(i);
					for (int i = int('0'); i <= int('9'); ++i)
						map[i] = std::string() + char(i);
					once = map;
				}
				std::string output;
				output.reserve(input.size()); // worst scenario
				for (std::string::const_iterator it = input.begin(), end = input.end(); it != end; ++it)
					output += map[byte(*it)];
				return output;
			}

			std::string escape_tag(const std::string& input, unsigned format) {
				static std::string map[256], * once = 0;
				if (!once) {
					for (int i = 0; i < 256; ++i)
						map[i] = std::string() + char(i);
					map[byte('<')] = "&lt;";
					map[byte('>')] = "&gt;";

					switch (format)
					{
					default:
						break;

					case jsonxx::JXML:
					case jsonxx::JXMLex:
					case jsonxx::JSONx:
					case jsonxx::TaggedXML:
						map[byte('&')] = "&amp;";
						break;
					}

					once = map;
				}
				std::string output;
				output.reserve(input.size() * 5); // worst scenario
				for (std::string::const_iterator it = input.begin(), end = input.end(); it != end; ++it)
					output += map[byte(*it)];
				return output;
			}

			std::string open_tag(unsigned format, char type, const std::string& name, const std::string& attr = std::string(), const std::string& text = std::string()) {
				std::string tagname;
				switch (format)
				{
				default:
					return std::string();

				case jsonxx::JXML:
					if (name.empty())
						tagname = std::string("j son=\"") + type + '\"';
					else
						tagname = std::string("j son=\"") + type + ':' + escape_string(name) + '\"';
					break;

				case jsonxx::JXMLex:
					if (name.empty())
						tagname = std::string("j son=\"") + type + '\"';
					else
						tagname = std::string("j son=\"") + type + ':' + escape_string(name) + "\" " + escape_attrib(name) + "=\"" + escape_string(text) + "\"";
					break;

				case jsonxx::JSONx:
					if (!name.empty())
						tagname = std::string(" name=\"") + escape_string(name) + "\"";
					switch (type) {
					default:
					case '0': tagname = "json:null" + tagname; break;
					case 'b': tagname = "json:boolean" + tagname; break;
					case 'a': tagname = "json:array" + tagname; break;
					case 's': tagname = "json:string" + tagname; break;
					case 'o': tagname = "json:object" + tagname; break;
					case 'n': tagname = "json:number" + tagname; break;
					}
					break;

				case jsonxx::TaggedXML: // @TheMadButcher
					if (!name.empty())
						tagname = escape_attrib(name);
					else
						tagname = "JsonItem";
					switch (type) {
					default:
					case '0': tagname += " type=\"json:null\""; break;
					case 'b': tagname += " type=\"json:boolean\""; break;
					case 'a': tagname += " type=\"json:array\""; break;
					case 's': tagname += " type=\"json:string\""; break;
					case 'o': tagname += " type=\"json:object\""; break;
					case 'n': tagname += " type=\"json:number\""; break;
					}

					if (!name.empty())
						tagname += std::string(" name=\"") + escape_string(name) + "\"";

					break;
				}

				return std::string("<") + tagname + attr + ">";
			}

			std::string close_tag(unsigned format, char type, const std::string& name) {
				switch (format)
				{
				default:
					return std::string();

				case jsonxx::JXML:
				case jsonxx::JXMLex:
					return "</j>";

				case jsonxx::JSONx:
					switch (type) {
					default:
					case '0': return "</json:null>";
					case 'b': return "</json:boolean>";
					case 'a': return "</json:array>";
					case 'o': return "</json:object>";
					case 's': return "</json:string>";
					case 'n': return "</json:number>";
					}
					break;

				case jsonxx::TaggedXML: // @TheMadButcher
					if (!name.empty())
						return "</" + escape_attrib(name) + ">";
					else
						return "</JsonItem>";
				}
			}

			std::string tag(unsigned format, unsigned depth, const std::string& name, const jsonxx::Value& t, const std::string& attr = std::string()) {
				std::stringstream ss;
				const std::string tab(depth, '\t');

				switch (t.type_)
				{
				default:
				case jsonxx::Value::NULL_:
					return tab + open_tag(format, '0', name, " /") + '\n';

				case jsonxx::Value::BOOL_:
					ss << (t.bool_value_ ? "true" : "false");
					return tab + open_tag(format, 'b', name, std::string(), format == jsonxx::JXMLex ? ss.str() : std::string())
						+ ss.str()
						+ close_tag(format, 'b', name) + '\n';

				case jsonxx::Value::ARRAY_:
					for (Array::container::const_iterator it = t.array_value_->values().begin(),
						end = t.array_value_->values().end(); it != end; ++it)
						ss << tag(format, depth + 1, std::string(), **it);
					return tab + open_tag(format, 'a', name, attr) + '\n'
						+ ss.str()
						+ tab + close_tag(format, 'a', name) + '\n';

				case jsonxx::Value::STRING_:
					ss << escape_tag(*t.string_value_, format);
					return tab + open_tag(format, 's', name, std::string(), format == jsonxx::JXMLex ? ss.str() : std::string())
						+ ss.str()
						+ close_tag(format, 's', name) + '\n';

				case jsonxx::Value::OBJECT_:
					for (Object::container::const_iterator it = t.object_value_->kv_map().begin(),
						end = t.object_value_->kv_map().end(); it != end; ++it)
						ss << tag(format, depth + 1, it->first, *it->second);
					return tab + open_tag(format, 'o', name, attr) + '\n'
						+ ss.str()
						+ tab + close_tag(format, 'o', name) + '\n';

				case jsonxx::Value::NUMBER_:
					// max precision
					ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1);
					ss << t.number_value_;
					return tab + open_tag(format, 'n', name, std::string(), format == jsonxx::JXMLex ? ss.str() : std::string())
						+ ss.str()
						+ close_tag(format, 'n', name) + '\n';
				}
			}

			// order here matches jsonxx::Format enum
			const char* defheader[] = {
				"",

				"<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
					 JSONXX_XML_TAG "\n",

				"<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
					 JSONXX_XML_TAG "\n",

				"<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
					 JSONXX_XML_TAG "\n",

				"<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
					 JSONXX_XML_TAG "\n"
			};

			// order here matches jsonxx::Format enum
			const char* defrootattrib[] = {
				"",

				" xsi:schemaLocation=\"http://www.datapower.com/schemas/json jsonx.xsd\""
					" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
					" xmlns:json=\"http://www.ibm.com/xmlns/prod/2009/jsonx\"",

				"",

				"",

				""
			};

		} // namespace jsonxx::anon::xml

	} // namespace jsonxx::anon

	std::string Object::json() const {
		using namespace json;

		jsonxx::Value v;
		v.object_value_ = const_cast<jsonxx::Object*>(this);
		v.type_ = jsonxx::Value::OBJECT_;

		std::string result = tag(jsonxx::JSON, 0, std::string(), v);

		v.object_value_ = 0;
		return remove_last_comma(result);
	}

	std::string Object::xml(unsigned format, const std::string& header, const std::string& attrib) const {
		using namespace xml;
		JSONXX_ASSERT(format == jsonxx::JSONx || format == jsonxx::JXML || format == jsonxx::JXMLex || format == jsonxx::TaggedXML);

		jsonxx::Value v;
		v.object_value_ = const_cast<jsonxx::Object*>(this);
		v.type_ = jsonxx::Value::OBJECT_;

		std::string result = tag(format, 0, std::string(), v, attrib.empty() ? std::string(defrootattrib[format]) : attrib);

		v.object_value_ = 0;
		return (header.empty() ? std::string(defheader[format]) : header) + result;
	}

	std::string Array::json() const {
		using namespace json;

		jsonxx::Value v;
		v.array_value_ = const_cast<jsonxx::Array*>(this);
		v.type_ = jsonxx::Value::ARRAY_;

		std::string result = tag(jsonxx::JSON, 0, std::string(), v);

		v.array_value_ = 0;
		return remove_last_comma(result);
	}

	std::string Array::xml(unsigned format, const std::string& header, const std::string& attrib) const {
		using namespace xml;
		JSONXX_ASSERT(format == jsonxx::JSONx || format == jsonxx::JXML || format == jsonxx::JXMLex || format == jsonxx::TaggedXML);

		jsonxx::Value v;
		v.array_value_ = const_cast<jsonxx::Array*>(this);
		v.type_ = jsonxx::Value::ARRAY_;

		std::string result = tag(format, 0, std::string(), v, attrib.empty() ? std::string(defrootattrib[format]) : attrib);

		v.array_value_ = 0;
		return (header.empty() ? std::string(defheader[format]) : header) + result;
	}

	bool validate(std::istream& input) {

		// trim non-printable chars
		for (char ch(0); !input.eof() && input.peek() <= 32; )
			input.get(ch);

		// validate json
		if (input.peek() == '{')
		{
			jsonxx::Object o;
			if (parse_object(input, o))
				return true;
		}
		else
			if (input.peek() == '[')
			{
				jsonxx::Array a;
				if (parse_array(input, a))
					return true;
			}

		// bad json input
		return false;
	}

	bool validate(const std::string& input) {
		std::istringstream is(input);
		return jsonxx::validate(is);
	}

	std::string reformat(std::istream& input) {

		// trim non-printable chars
		for (char ch(0); !input.eof() && input.peek() <= 32; )
			input.get(ch);

		// validate json
		if (input.peek() == '{')
		{
			jsonxx::Object o;
			if (parse_object(input, o))
				return o.json();
		}
		else
			if (input.peek() == '[')
			{
				jsonxx::Array a;
				if (parse_array(input, a))
					return a.json();
			}

		// bad json input
		return std::string();
	}

	std::string reformat(const std::string& input) {
		std::istringstream is(input);
		return jsonxx::reformat(is);
	}

	std::string xml(std::istream& input, unsigned format) {
		using namespace xml;
		JSONXX_ASSERT(format == jsonxx::JSONx || format == jsonxx::JXML || format == jsonxx::JXMLex || format == jsonxx::TaggedXML);

		// trim non-printable chars
		for (char ch(0); !input.eof() && input.peek() <= 32; )
			input.get(ch);

		// validate json, then transform
		if (input.peek() == '{')
		{
			jsonxx::Object o;
			if (parse_object(input, o))
				return o.xml(format);
		}
		else
			if (input.peek() == '[')
			{
				jsonxx::Array a;
				if (parse_array(input, a))
					return a.xml(format);
			}

		// bad json, return empty xml
		return defheader[format];
	}

	std::string xml(const std::string& input, unsigned format) {
		std::istringstream is(input);
		return jsonxx::xml(is, format);
	}

	Object::Object(const Object& other) {
		import(other);
	}
	Object::Object(const std::string& key, const Value& value) {
		import(key, value);
	}
	void Object::import(const Object& other) {
		odd.clear();
		if (this != &other) {
			// default
			container::const_iterator
				it = other.value_map_.begin(),
				end = other.value_map_.end();
			for (/**/; it != end; ++it) {
				container::iterator found = value_map_.find(it->first);
				if (found != value_map_.end()) {
					delete found->second;
				}
				value_map_[it->first] = new Value(*it->second);
			}
		}
		else {
			// recursion is supported here
			import(Object(*this));
		}
	}
	void Object::import(const std::string& key, const Value& value) {
		odd.clear();
		container::iterator found = value_map_.find(key);
		if (found != value_map_.end()) {
			delete found->second;
		}
		value_map_[key] = new Value(value);
	}
	Object& Object::operator=(const Object& other) {
		odd.clear();
		if (this != &other) {
			reset();
			import(other);
		}
		return *this;
	}
	Object& Object::operator<<(const Value& value) {
		if (odd.empty()) {
			odd = value.get<String>();
		}
		else {
			import(Object(odd, value));
			odd.clear();
		}
		return *this;
	}
	Object& Object::operator<<(const Object& value) {
		import(std::string(odd), value);
		odd.clear();
		return *this;
	}
	size_t Object::size() const {
		return value_map_.size();
	}
	bool Object::empty() const {
		return value_map_.size() == 0;
	}
	const std::map<std::string, Value*>& Object::kv_map() const {
		return value_map_;
	}
	std::string Object::write(unsigned format) const {
		return format == JSON ? json() : xml(format);
	}
	void Object::reset() {
		container::iterator i;
		for (i = value_map_.begin(); i != value_map_.end(); ++i) {
			delete i->second;
		}
		value_map_.clear();
	}
	bool Object::parse(std::istream& input) {
		return parse(input, *this);
	}
	bool Object::parse(const std::string& input) {
		std::istringstream is(input);
		return parse(is, *this);
	}

	Array::Array(const Array& other) {
		import(other);
	}
	Array::Array(const Value& value) {
		import(value);
	}
	void Array::append(const Array& other) {
		if (this != &other) {
			values_.push_back(new Value(other));
		}
		else {
			append(Array(*this));
		}
	}
	void Array::import(const Array& other) {
		if (this != &other) {
			// default
			container::const_iterator
				it = other.values_.begin(),
				end = other.values_.end();
			for (/**/; it != end; ++it) {
				values_.push_back(new Value(**it));
			}
		}
		else {
			// recursion is supported here
			import(Array(*this));
		}
	}
	void Array::import(const Value& value) {
		values_.push_back(new Value(value));
	}
	size_t Array::size() const {
		return values_.size();
	}
	bool Array::empty() const {
		return values_.size() == 0;
	}
	void Array::reset() {
		for (container::iterator i = values_.begin(); i != values_.end(); ++i) {
			delete* i;
		}
		values_.clear();
	}
	bool Array::parse(std::istream& input) {
		return parse(input, *this);
	}
	bool Array::parse(const std::string& input) {
		std::istringstream is(input);
		return parse(is, *this);
	}
	Array& Array::operator<<(const Array& other) {
		import(other);
		return *this;
	}
	Array& Array::operator<<(const Value& value) {
		import(value);
		return *this;
	}
	Array& Array::operator=(const Array& other) {
		if (this != &other) {
			reset();
			import(other);
		}
		return *this;
	}
	Array& Array::operator=(const Value& value) {
		reset();
		import(value);
		return *this;
	}

	Value::Value(const Value& other) : type_(INVALID_) {
		import(other);
	}
	bool Value::empty() const {
		if (type_ == INVALID_) return true;
		if (type_ == STRING_ && string_value_ == 0) return true;
		if (type_ == ARRAY_ && array_value_ == 0) return true;
		if (type_ == OBJECT_ && object_value_ == 0) return true;
		return false;
	}
	bool Value::parse(std::istream& input) {
		return parse(input, *this);
	}
	bool Value::parse(const std::string& input) {
		std::istringstream is(input);
		return parse(is, *this);
	}

}  // namespace jsonxx
```

`jsonxx/jsonxx.h`:

```h
// -*- mode: c++; c-basic-offset: 4; -*-

// Author: Hong Jiang <hong@hjiang.net>
// Contributors:
//   Sean Middleditch <sean@middleditch.us>
//   rlyeh <https://github.com/r-lyeh>

#pragma once
#include "..\stdafx.h"
#include <cstddef>
#include <cassert>
#include <iostream>
#include <map>
#include <vector>
#include <string>
#include <sstream>

// jsonxx versioning: major.minor-extra where
// major = { number }
// minor = { number }
// extra = { 'a':alpha, 'b':beta, 'rc': release candidate, 'r': release, 's':stable }
#define JSONXX_MAJOR    "0"
#define JSONXX_MINOR    "22"
#define JSONXX_EXTRA    "a"
#define JSONXX_VERSION  JSONXX_MAJOR "." JSONXX_MINOR "-" JSONXX_EXTRA
#define JSONXX_XML_TAG  "<!-- generated by jsonxx " JSONXX_VERSION " -->"

#if __cplusplus > 199711L
#define JSONXX_COMPILER_HAS_CXX11 1
#elif defined(_MSC_VER) && _MSC_VER > 1700
#define JSONXX_COMPILER_HAS_CXX11 1
#else
#define JSONXX_COMPILER_HAS_CXX11 0
#endif

#ifdef _MSC_VER
// disable the C4127 warning if using VC, see http://stackoverflow.com/a/12042515
#define JSONXX_ASSERT(...) \
  do { \
    __pragma(warning(push)) __pragma(warning(disable:4127)) \
    if( jsonxx::Assertions ) \
    __pragma(warning(pop)) \
      jsonxx::assertion(__FILE__,__LINE__,#__VA_ARGS__,bool(__VA_ARGS__)); \
  __pragma(warning(push)) __pragma(warning(disable:4127)) \
  } while(0) \
  __pragma(warning(pop))
#else
#define JSONXX_ASSERT(...) do { if( jsonxx::Assertions ) \
  jsonxx::assertion(__FILE__,__LINE__,#__VA_ARGS__,bool(__VA_ARGS__)); } while(0)
#endif

namespace jsonxx {

	// FIXME(hjiang): Those should really be dynamic.
	// Settings
	enum Settings {
		// constants
		Enabled = true,
		Disabled = false,
		Permissive = true,
		Strict = false,
		// values
		Parser = Permissive,  // permissive or strict parsing
		UnquotedKeys = Disabled, // support of unquoted keys
		Assertions = Enabled  // enabled or disabled assertions (these asserts work both in DEBUG and RELEASE builds)
	};

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4127)
#endif
	inline bool parser_is_strict() { return Parser == Strict; }
	inline bool parser_is_permissive() { return Parser == Permissive; }
	inline bool unquoted_keys_are_enabled() { return UnquotedKeys == Enabled; }
#ifdef _MSC_VER
#pragma warning(pop)
#endif

	// Constants for .write() and .xml() methods
	enum Format {
		JSON = 0,     // JSON output
		JSONx = 1,     // XML output, JSONx  format. see http://goo.gl/I3cxs
		JXML = 2,     // XML output, JXML   format. see https://github.com/r-lyeh/JXML
		JXMLex = 3,     // XML output, JXMLex format. see https://github.com/r-lyeh/JXMLex
		TaggedXML = 4      // XML output, tagged XML format. see https://github.com/hjiang/jsonxx/issues/12
	};

	// Types
	typedef long double Number;
	typedef bool Boolean;
	typedef std::string String;
	struct Null {};
	class Value;
	class Object;
	class Array;

	// Identity meta-function
	template <typename T>
	struct identity {
		typedef T type;
	};

	// Tools
	bool validate(const std::string& input);
	bool validate(std::istream& input);
	std::string reformat(const std::string& input);
	std::string reformat(std::istream& input);
	std::string xml(const std::string& input, unsigned format = JSONx);
	std::string xml(std::istream& input, unsigned format = JSONx);

	// Detail
	void assertion(const char* file, int line, const char* expression, bool result);

	// A JSON Object
	class Object {
	public:
		Object();
		~Object();

		template <typename T>
		bool has(const std::string& key) const;

		// Always call has<>() first. If the key doesn't exist, consider
		// the behavior undefined.
		template <typename T>
		T& get(const std::string& key);
		template <typename T>
		const T& get(const std::string& key) const;

		template <typename T>
		const T& get(const std::string& key, const typename identity<T>::type& default_value) const;

		size_t size() const;
		bool empty() const;

		const std::map<std::string, Value*>& kv_map() const;
		std::string json() const;
		std::string xml(unsigned format = JSONx, const std::string& header = std::string(), const std::string& attrib = std::string()) const;
		std::string write(unsigned format) const;

		void reset();
		bool parse(std::istream& input);
		bool parse(const std::string& input);
		typedef std::map<std::string, Value*> container;
		void import(const Object& other);
		void import(const std::string& key, const Value& value);
		Object& operator<<(const Value& value);
		Object& operator<<(const Object& value);
		Object& operator=(const Object& value);
		Object(const Object& other);
		Object(const std::string& key, const Value& value);
		template<size_t N>
		Object(const char(&key)[N], const Value& value) {
			import(key, value);
		}
		template<typename T>
		Object& operator<<(const T& value);

	protected:
		static bool parse(std::istream& input, Object& object);
		container value_map_;
		std::string odd;
	};

	class Array {
	public:
		Array();
		~Array();

		size_t size() const;
		bool empty() const;

		template <typename T>
		bool has(unsigned int i) const;

		template <typename T>
		T& get(unsigned int i);
		template <typename T>
		const T& get(unsigned int i) const;

		template <typename T>
		const T& get(unsigned int i, const typename identity<T>::type& default_value) const;

		const std::vector<Value*>& values() const {
			return values_;
		}
		std::string json() const;
		std::string xml(unsigned format = JSONx, const std::string& header = std::string(), const std::string& attrib = std::string()) const;

		std::string write(unsigned format) const { return format == JSON ? json() : xml(format); }
		void reset();
		bool parse(std::istream& input);
		bool parse(const std::string& input);
		typedef std::vector<Value*> container;
		void append(const Array& other);
		void append(const Value& value) { import(value); }
		void import(const Array& other);
		void import(const Value& value);
		Array& operator<<(const Array& other);
		Array& operator<<(const Value& value);
		Array& operator=(const Array& other);
		Array& operator=(const Value& value);
		Array(const Array& other);
		Array(const Value& value);
	protected:
		static bool parse(std::istream& input, Array& array);
		container values_;
	};

	// A value could be a number, an array, a string, an object, a
	// boolean, or null
	class Value {
	public:

		Value();
		~Value() { reset(); }
		void reset();

		template<typename T>
		void import(const T&) {
			reset();
			type_ = INVALID_;
			// debug
			// std::cout << "[WARN] No support for " << typeid(t).name() << std::endl;
		}
		void import(const bool& b) {
			reset();
			type_ = BOOL_;
			bool_value_ = b;
		}
#define $number(TYPE) \
  void import( const TYPE &n ) { \
    reset(); \
    type_ = NUMBER_; \
    number_value_ = static_cast<long double>(n); \
  }
		$number(char)
			$number(int)
			$number(long)
			$number(long long)
			$number(unsigned char)
			$number(unsigned int)
			$number(unsigned long)
			$number(unsigned long long)
			$number(float)
			$number(double)
			$number(long double)
#undef $number
#if JSONXX_COMPILER_HAS_CXX11 > 0
			void import(const std::nullptr_t&) {
			reset();
			type_ = NULL_;
		}
#endif
		void import(const Null&) {
			reset();
			type_ = NULL_;
		}
		void import(const String& s) {
			reset();
			type_ = STRING_;
			*(string_value_ = new String()) = s;
		}
		void import(const Array& a) {
			reset();
			type_ = ARRAY_;
			*(array_value_ = new Array()) = a;
		}
		void import(const Object& o) {
			reset();
			type_ = OBJECT_;
			*(object_value_ = new Object()) = o;
		}
		void import(const Value& other) {
			if (this != &other)
				switch (other.type_) {
				case NULL_:
					import(Null());
					break;
				case BOOL_:
					import(other.bool_value_);
					break;
				case NUMBER_:
					import(other.number_value_);
					break;
				case STRING_:
					import(*other.string_value_);
					break;
				case ARRAY_:
					import(*other.array_value_);
					break;
				case OBJECT_:
					import(*other.object_value_);
					break;
				case INVALID_:
					type_ = INVALID_;
					break;
				default:
					JSONXX_ASSERT(!"not implemented");
				}
		}
		template<typename T>
		Value& operator <<(const T& t) {
			import(t);
			return *this;
		}
		template<typename T>
		Value& operator =(const T& t) {
			reset();
			import(t);
			return *this;
		}
		Value(const Value& other);
		template<typename T>
		Value(const T& t) : type_(INVALID_) { import(t); }
		template<size_t N>
		Value(const char(&t)[N]) : type_(INVALID_) { import(std::string(t)); }

		bool parse(std::istream& input);
		bool parse(const std::string& input);

		template<typename T>
		bool is() const;
		template<typename T>
		T& get();
		template<typename T>
		const T& get() const;

		bool empty() const;

	public:
		enum {
			NUMBER_,
			STRING_,
			BOOL_,
			NULL_,
			ARRAY_,
			OBJECT_,
			INVALID_
		} type_;
		union {
			Number number_value_;
			String* string_value_;
			Boolean bool_value_;
			Array* array_value_;
			Object* object_value_;
		};

	protected:
		static bool parse(std::istream& input, Value& value);
	};

	template <typename T>
	bool Array::has(unsigned int i) const {
		if (i >= size()) {
			return false;
		}
		else {
			Value* v = values_.at(i);
			return v->is<T>();
		}
	}

	template <typename T>
	T& Array::get(unsigned int i) {
		JSONXX_ASSERT(i < size());
		Value* v = values_.at(i);
		return v->get<T>();
	}

	template <typename T>
	const T& Array::get(unsigned int i) const {
		JSONXX_ASSERT(i < size());
		const Value* v = values_.at(i);
		return v->get<T>();
	}

	template <typename T>
	const T& Array::get(unsigned int i, const typename identity<T>::type& default_value) const {
		if (has<T>(i)) {
			const Value* v = values_.at(i);
			return v->get<T>();
		}
		else {
			return default_value;
		}
	}

	template <typename T>
	bool Object::has(const std::string& key) const {
		container::const_iterator it(value_map_.find(key));
		return it != value_map_.end() && it->second->is<T>();
	}

	template <typename T>
	T& Object::get(const std::string& key) {
		JSONXX_ASSERT(has<T>(key));
		return value_map_.find(key)->second->get<T>();
	}

	template <typename T>
	const T& Object::get(const std::string& key) const {
		JSONXX_ASSERT(has<T>(key));
		return value_map_.find(key)->second->get<T>();
	}

	template <typename T>
	const T& Object::get(const std::string& key, const typename identity<T>::type& default_value) const {
		if (has<T>(key)) {
			return value_map_.find(key)->second->get<T>();
		}
		else {
			return default_value;
		}
	}

	template<>
	inline bool Value::is<Value>() const {
		return true;
	}

	template<>
	inline bool Value::is<Null>() const {
		return type_ == NULL_;
	}

	template<>
	inline bool Value::is<Boolean>() const {
		return type_ == BOOL_;
	}

	template<>
	inline bool Value::is<String>() const {
		return type_ == STRING_;
	}

	template<>
	inline bool Value::is<Number>() const {
		return type_ == NUMBER_;
	}

	template<>
	inline bool Value::is<Array>() const {
		return type_ == ARRAY_;
	}

	template<>
	inline bool Value::is<Object>() const {
		return type_ == OBJECT_;
	}

	template<>
	inline Value& Value::get<Value>() {
		return *this;
	}

	template<>
	inline const Value& Value::get<Value>() const {
		return *this;
	}

	template<>
	inline bool& Value::get<Boolean>() {
		JSONXX_ASSERT(is<Boolean>());
		return bool_value_;
	}

	template<>
	inline std::string& Value::get<String>() {
		JSONXX_ASSERT(is<String>());
		return *string_value_;
	}

	template<>
	inline Number& Value::get<Number>() {
		JSONXX_ASSERT(is<Number>());
		return number_value_;
	}

	template<>
	inline Array& Value::get<Array>() {
		JSONXX_ASSERT(is<Array>());
		return *array_value_;
	}

	template<>
	inline Object& Value::get<Object>() {
		JSONXX_ASSERT(is<Object>());
		return *object_value_;
	}

	template<>
	inline const Boolean& Value::get<Boolean>() const {
		JSONXX_ASSERT(is<Boolean>());
		return bool_value_;
	}

	template<>
	inline const String& Value::get<String>() const {
		JSONXX_ASSERT(is<String>());
		return *string_value_;
	}

	template<>
	inline const Number& Value::get<Number>() const {
		JSONXX_ASSERT(is<Number>());
		return number_value_;
	}

	template<>
	inline const Array& Value::get<Array>() const {
		JSONXX_ASSERT(is<Array>());
		return *array_value_;
	}

	template<>
	inline const Object& Value::get<Object>() const {
		JSONXX_ASSERT(is<Object>());
		return *object_value_;
	}

	template<typename T>
	inline Object& Object::operator<<(const T& value) {
		return *this << Value(value), * this;
	}

}  // namespace jsonxx

std::ostream& operator<<(std::ostream& stream, const jsonxx::Value& v);
std::ostream& operator<<(std::ostream& stream, const jsonxx::Object& v);
std::ostream& operator<<(std::ostream& stream, const jsonxx::Array& v);

```

`jsonxx/jsonxx_test.cc`:

```cc
// -*- mode: c++; c-basic-offset: 4; -*-

// Author: Hong Jiang <hong@hjiang.net>
// Include a few sanity tests from https://github.com/isubiker/mljson/
// Include a few samples from http://www.json.org

#include <cassert>
#include <sstream>
#include <string>
#include <iostream>
#include <fstream>

#include "jsonxx.h"

namespace jsonxx {
    extern bool parse_string(std::istream& input, String& value);
    extern bool parse_number(std::istream& input, Number& value);
    extern bool match(const char* pattern, std::istream& input);
}

bool is_asserting() {
    bool asserting = false;
    JSONXX_ASSERT( asserting |= true );
    return asserting;
}

struct custom_type {};      // Used in a test elsewhere

int main(int argc, const char **argv) {

    if( !is_asserting() ) {
        std::cout << "JSONXX_ASSERT(...) is not working. Assertions are disabled somehow. Tests aborted." << std::endl;
        return -1;
    }

    bool verbose = false;
    if( argc > 1 && (std::string(argv[1]) == "-v")) {
        verbose = true;
    }

#   define TEST_ARRAY(...)  TEST( Array().parse(istringstream(#__VA_ARGS__).str()) )
#   define TEST_OBJECT(...) TEST( Object().parse(istringstream(#__VA_ARGS__).str()) )
#   define TEST(...) do { JSONXX_ASSERT( __VA_ARGS__ ); \
    if( verbose ) std::cout << "[OK] " #__VA_ARGS__ << std::endl; \
    } while(0)

    using namespace jsonxx;
    using namespace std;
    {
        string teststr("\"field1\"");
        string value;
        istringstream input(teststr);
        TEST(parse_string(input, value));
        TEST(value == "field1");
    }
    if( Parser != Strict )
    {
        string teststr("'field1'");
        string value;
        istringstream input(teststr);
        TEST(parse_string(input, value));
        TEST(value == "field1");
    }
    {
        string teststr("\"  field1\"");
        string value;
        istringstream input(teststr);
        TEST(parse_string(input, value));
        TEST(value == "  field1");
    }
    if( Parser != Strict )
    {
        string teststr("'  field1'");
        string value;
        istringstream input(teststr);
        TEST(parse_string(input, value));
        TEST(value == "  field1");
    }
    {
        string teststr("  \"field1\"");
        string value;
        istringstream input(teststr);
        TEST(parse_string(input, value));
        TEST(value == "field1");
    }
    if( Parser != Strict )
    {
        string teststr("  'field1'");
        string value;
        istringstream input(teststr);
        TEST(parse_string(input, value));
        TEST(value == "field1");
    }
    {
        // 'escaped text to unescaped text' test
        string teststr("\"\\b\\f\\n\\r\\t\\u000e\\u0002\"");
        string value;
        istringstream input(teststr);
        TEST(parse_string(input, value));
        TEST( value == "\b\f\n\r\t\xe\x2" );
    }
    {
        string teststr("6");
        istringstream input(teststr);
        Number value;
        TEST(parse_number(input, value));
        TEST(value == 6);
    }
    {
        string teststr(" }");
        istringstream input(teststr);
        TEST(match("}", input));
    }
    {
        string teststr("{ \"field1\" : 6 }");
        if(UnquotedKeys == Enabled) {
            teststr = "{ field1 : 6 }";
        }
        istringstream input(teststr);
        Object o;
        TEST(o.parse(input));
    }
    {
        string teststr("{ \"field1 : 6 }");
        istringstream input(teststr);
        Object o;
        TEST(!o.parse(input));
    }
    {
        string teststr("6");
        istringstream input(teststr);
        Value v;
        TEST(v.parse(input));
        TEST(v.is<Number>());
        TEST(v.get<Number>() == 6);
    }
    {
        string teststr("+6");
        istringstream input(teststr);
        Value v;
        TEST(v.parse(input));
        TEST(v.is<Number>());
        TEST(v.get<Number>() == 6);
    }
    {
        string teststr("-6");
        istringstream input(teststr);
        Value v;
        TEST(v.parse(input));
        TEST(v.is<Number>());
        TEST(v.get<Number>() == -6);
    }
    {
        string teststr("asdf");
        istringstream input(teststr);
        Value v;
        TEST(!v.parse(input));
    }
    {
        string teststr("true");
        istringstream input(teststr);
        Value v;
        TEST(v.parse(input));
        TEST(v.is<Boolean>());
        TEST(v.get<Boolean>());
    }
    {
        string teststr("false");
        istringstream input(teststr);
        Value v;
        TEST(v.parse(input));
        TEST(v.is<Boolean>());
        TEST(!v.get<Boolean>());
    }
    {
        string teststr("null");
        istringstream input(teststr);
        Value v;
        TEST(v.parse(input));
        TEST(v.is<Null>());
        TEST(!v.is<Boolean>());
    }
    {
        string teststr("\"field1\"");
        istringstream input(teststr);
        Value v;
        TEST(v.parse(input));
        TEST(v.is<String>());
        TEST("field1" == v.get<String>());
        ostringstream stream;
        stream << v;
        TEST(stream.str() == "\"field1\"");
    }
    if( Parser != Strict )
    {
        string teststr("'field1'");
        istringstream input(teststr);
        Value v;
        TEST(v.parse(input));
        TEST(v.is<String>());
        TEST("field1" == v.get<String>());
        ostringstream stream;
        stream << v;
        TEST(stream.str() == "\"field1\"");
    }
    {
        string teststr("[\"field1\", 6]");
        istringstream input(teststr);
        Array a;
        TEST(a.parse(input));
        TEST(a.has<String>(0));
        TEST("field1" == a.get<String>(0));
        TEST(a.has<Number>(1));
        TEST(6 == a.get<Number>(1));
        TEST(!a.has<Boolean>(2));
    }
    {
        string teststr(
                "{"
                "  \"foo\" : 1,"
                "  \"bar\" : false,"
                "  \"person\" : {\"name\" : \"GWB\", \"age\" : 60},"
                "  \"data\": [\"abcd\", 42, 54.7]"
                "}"
                );
        if(UnquotedKeys == Enabled) {
            teststr = 
                    "{"
                    "  foo : 1,"
                    "  bar : false,"
                    "  person : {name : \"GWB\", age : 60},"
                    "  data: [\"abcd\", 42, 54.7]"
                    "}";
        }
        istringstream input(teststr);
        Object o;
        TEST(o.parse(input));
        TEST(1 == o.get<Number>("foo"));
        TEST(o.has<Boolean>("bar"));
        TEST(o.has<Object>("person"));
        TEST(o.get<Object>("person").has<Number>("age"));
        TEST(o.has<Array>("data"));
        TEST(o.get<Array>("data").get<Number>(1) == 42);
        TEST(o.get<Array>("data").get<String>(0) == "abcd");
        TEST(o.get<Array>("data").get<Number>(2) - 54.7 < 1e-6 ||
                - o.get<Array>("data").get<Number>(2) + 54.7 < 1e-6 );
        TEST(!o.has<Number>("data"));
    }
    {
        string teststr("{\"bar\": \"a\\rb\\nc\\td\", \"foo\": true}");
        if(UnquotedKeys == Enabled) {
            teststr = "{bar: \"a\\rb\\nc\\td\", foo: true}";
        }
        istringstream input(teststr);
        Object o;
        TEST(o.parse(input));
        TEST(o.has<String>("bar"));
        TEST(o.get<String>("bar") == "a\rb\nc\td");
        TEST(o.has<Boolean>("foo"));
        TEST(o.get<Boolean>("foo") == true);
    }
    {
        string teststr("[ ]");
        istringstream input(teststr);
        ostringstream output;
        Array root;
        TEST(root.parse(input));
        output << root;
    }

    {
        string teststr("{}");
        istringstream input(teststr);
        Object o;
        TEST(o.parse(input));
    }

    {
        string teststr("{\"attrs\":{}}");
        if(UnquotedKeys == Enabled) {
            teststr = "{attrs:{}}";
        }
        istringstream input(teststr);
        Object o;
        TEST(o.parse(input));
        TEST(o.has<Object>("attrs"));
    }

    {
        string teststr("{\"place\":{\"full_name\":\"Limburg, The Netherlands\""
                       ",\"attributes\":{},\"name\":\"Limburg\","
                       "\"place_type\":\"admin\",\"bounding_box\":{"
                       "\"type\":\"Polygon\",\"coordinates\":"
                       "[[[5.5661376,50.750449],[6.2268848,50.750449],"
                       "[6.2268848,51.7784841],[5.5661376,51.7784841]]]},"
                       "\"url\":\"http:\\/\\/api.twitter.com\\/1\\/geo\\/id\\/"
                       "4ef0c00cbdff9ac8.json\",\"country_code\":\"NL\","
                       "\"id\":\"4ef0c00cbdff9ac8\","
                       "\"country\":\"The Netherlands\"}}");
        if(UnquotedKeys == Enabled) {
            teststr = "{place:{full_name:\"Limburg, The Netherlands\""
                           ",attributes:{},name:\"Limburg\","
                           "place_type:\"admin\",bounding_box:{"
                           "type:\"Polygon\",coordinates:"
                           "[[[5.5661376,50.750449],[6.2268848,50.750449],"
                           "[6.2268848,51.7784841],[5.5661376,51.7784841]]]},"
                           "url:\"http:\\/\\/api.twitter.com\\/1\\/geo\\/id\\/"
                           "4ef0c00cbdff9ac8.json\",country_code:\"NL\","
                           "id:\"4ef0c00cbdff9ac8\","
                           "country:\"The Netherlands\"}}";
        }

        istringstream input(teststr);
        Object o;
        TEST(o.parse(input));
        TEST(o.has<Object>("place"));
        TEST(o.get<Object>("place").has<Object>("attributes"));
    }


    {
        string teststr("{\"file\": \"test.txt\", \"types\": {\"one\": 1, \"two\": 2},"
                       "\"list\": [\"string\", 10]}");
        if(UnquotedKeys == Enabled) {
            teststr = "{file: \"test.txt\", types: {one: 1, two: 2},"
                           "list: [\"string\", 10]}";
        }
        istringstream input(teststr);
        Object o;
        TEST(o.parse(input));
        TEST(o.has<String>("file"));
        TEST(o.has<Object>("types"));
        TEST(o.get<String>("file", "lol.txt") == "test.txt");
        TEST(o.get<Object>("types").has<Number>("one"));
        TEST(!o.get<Object>("types").has<Number>("three"));
        TEST(o.get<Object>("types").get<Number>("three", 3) == 3);
        TEST(o.has<Array>("list"));
        TEST(o.get<Array>("list").has<String>(0));
        TEST(!o.get<Array>("list").has<String>(2));
        TEST(o.get<Array>("list").get<String>(0) == "string");
        TEST(o.get<Array>("list").get<String>(2, "test") == "test");
    }

    if( Parser != Strict && UnquotedKeys == Disabled /* '/' not supported as an identifier */ ) 
    {
        #define QUOTE(...) #__VA_ARGS__
        string input = QUOTE(
        {
          "name/surname":"John Smith",
          'alias': 'Joe',
          "address": {
            "streetAddress": "21 2nd Street",
            "city": "New York",
            "state": "NY",
            "postal-code": 10021,
          },
          "phoneNumbers": [
            "212 555-1111",
            "212 555-2222",
          ],
          "additionalInfo": null,
          "remote": false,
          "height": 62.4,
          "ficoScore": " > 640",
        }
        );

        string sample_output = QUOTE(
        <?xml version="1.0" encoding="UTF-8"?>
        <json:object xsi:schemaLocation="http://www.datapower.com/schemas/json jsonx.xsd"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:json="http://www.ibm.com/xmlns/prod/2009/jsonx">
          <json:string name="name/surname">John Smith</json:string>
          <json:string name="alias">Joe</json:string>
          <json:object name="address">
            <json:string name="streetAddress">21 2nd Street</json:string>
            <json:string name="city">New York</json:string>
            <json:string name="state">NY</json:string>
            <json:number name="postal-code">10021</json:number>
          </json:object>
          <json:array name="phoneNumbers">
            <json:string>212 555-1111</json:string>
            <json:string>212 555-2222</json:string>
          </json:array>
          <json:null name="additionalInfo" />
          <json:boolean name="remote">false</json:boolean>
          <json:number name="height">62.4</json:number>
          <json:string name="ficoScore">&gt; 640</json:string>
        </json:object>
        );

        Object o;
        if( o.parse(input) ) {
            if( verbose ) {
                cout << o.xml(JSONx) << endl;            // XML output, JSONx flavor
                cout << o.xml(JXML) << endl;             // XML output, JXML flavor
                cout << o.xml(JXMLex) << endl;           // XML output, JXMLex flavor
                cout << o.xml(TaggedXML) << endl;        // XML output, tagged XML flavor
            }
        } else {
            TEST( !"provided JSON is valid. jsonxx::Object::operator<<() is broken!" );
        }

        TEST( jsonxx::validate(input) );
    }

    if(UnquotedKeys == Enabled) {
        cout << "Some of tests with 'UnquotedKeys = Enabled' ok." << endl;
        return 0;
    }

    // Four samples from www.json.org
    TEST_OBJECT( {
        "name": "Jack (\"Bee\") Nimble",
        "format": {
            "type":       "rect",
            "width":      1920,
            "height":     1080,
            "interlace":  false,
            "frame rate": 24
        }
    } );
    TEST_OBJECT( { "color": "blue", "closed": true, "points": [[10,10], [20,10], [20,20], [10,20]] } );
    TEST_ARRAY( [ [0, -1, 0], [1, 0, 0], [0, 0, 1] ] );
    TEST_ARRAY( ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] );

    // Empty/raw datatypes
    TEST_ARRAY( [true, false, null, [], {}] );

    // Various numbers
    TEST_ARRAY( [[-1], [1.2]] );

    // General array with all data types
    TEST_ARRAY( ["hello", 0, [], {}, null, false, true] );

    // Nested objects
    TEST_OBJECT( {"foo":1, "bar":{"baz":2, "yaz":3}} );

    // Nested objects with trailing key/value
    TEST_OBJECT( {"foo":1, "em":{"a":"b"}, "bar":"aa"} );

    // Nested arrays
    TEST_ARRAY( [1, 2, 3, [4, 5, [7, 8, 9], 6]] );

    // Nested arrays with trailing values
    TEST_ARRAY( [1, 2, 3, [4, 5, [7, 8, 9], 6], 10] );

    // UTF-8
    TEST_OBJECT( {"text":"は 2010/11/4 at 5:50 AM に 6'45\"/km のペースで 8.42 km を走りました http://go.nike.com/9rlcovd"} );
    
    // Escaped UTF-8
    TEST_OBJECT( {"text":"\u3050\u3089\u307e\u3041\u3067\u3061\u3085\u306d\u2665\u304a\u306f\u3088\u3046\u3067\u3059\uff01"} );

    // Empty values
    TEST_OBJECT( {"foo":"", "bar":""} );

    // Escaped quotes
    TEST_OBJECT( {"foo":"\"bar\""} );

    // Newline
    TEST_OBJECT( {"foo":"bar\nbaz"} );

    // Could use more tests around escaping odd characters in key names that can't be used as an element name
    // Escaping invalid xml element names
    TEST_OBJECT( {"f•o":"bar"} );

    // Escaping our invalid xml element name escaping
    TEST_OBJECT( {"_foo":"bar"} );

    // Empty key name (about to check in a fix)
    TEST_OBJECT( {"":"bar"} );

    // Trailing commas (if permissive mode is enabled)
    if( Parser != Strict ) {
        TEST_ARRAY( [ true, 42, 54.7, ] );
        TEST_OBJECT( { "hello": "world",} );
    }

    // Single-quoted strings (if permissive mode is enabled)
    if( Parser != Strict ) {
        TEST_OBJECT( { 'single-quoted-strings': 'are "handy"' } );
    }

    {
        jsonxx::Array a;
        a << true;
        a << false;
        a << 'A';
        a << 65;
        a << 65L;
        a << 65LL;
        a << 65U;
        a << 65UL;
        a << 65ULL;
        a << 65.f;
        a << 65.0;
        a << jsonxx::Value( "hello world" );
        a << std::string("hello world");
        a << "hello world";

        TEST( jsonxx::Array().parse( a.json() ) );   // self-evaluation
        TEST( validate( a.json() ) );                // self-evaluation
    }

    {
        jsonxx::Object o;
        o << "hello" << "world";
        o << "hola" << "mundo";
        TEST( o.get<String>("hello") == "world" );
        TEST( o.get<String>("hola") == "mundo" );
        o << "hello" << "mundo";
        o << "hola" << "world";
        TEST( o.get<String>("hello") == "mundo" );
        TEST( o.get<String>("hola") == "world" );
    }

    {
        // Generate JSON document dinamically
        jsonxx::Array a;
        a << jsonxx::Null();           // C++11: 'a << nullptr' is preferred
        a << 123;
        a << "hello \"world\"";
        a << 3.1415;
        a << 99.95f;
        a << 'h';

        jsonxx::Object o;
        o << "key1" << "value";
        o << "key2" << 123;
        o << "key3" << a;

        a << o;

        TEST( jsonxx::Array().parse( a.json() ) );   // self-evaluation
        TEST( validate( a.json() ) );                // self-evaluation
    }

    {
        // Generate JSON document dinamically
        jsonxx::Object o1;
        o1 << "key1" << "value 1";
        o1 << "key2" << 123;

        jsonxx::Object o2;
        o2 << "key3" << "value 2";
        o2 << "key4" << 456;

        o1 << "key3" << o2;

        TEST( jsonxx::Object().parse( o1.json() ) );  // self-evaluation
        TEST( validate( o1.json() ) );                // self-evaluation
    }

    {
        jsonxx::Array a;
        a << true;
        a << false;

        jsonxx::Object o;
        o << "number" << 123;
        o << "string" << "hello world";
        o << "boolean" << false;
        o << "null" << static_cast<void*>(0);
        o << "array" << a;
        o << "object" << jsonxx::Object("child", "object");
        o << "undefined" << custom_type();

        if( verbose ) {
            cout << o.write(JSON) << std::endl;        // same than o.json()
            cout << o.write(JSONx) << std::endl;       // same than o.xml()
            cout << o.write(JXML) << std::endl;        // same than o.xml(JXML)
            cout << o.write(JXMLex) << std::endl;      // same than o.xml(JXMLex)
        }

        TEST( jsonxx::Object().parse( o.json() ) );   // self-evaluation
        TEST( validate( o.json() ) );                 // self-evaluation
    }

    {
        // recursion test
        jsonxx::Array a;
        a << 123;
        a << "hello world";
        a << a;
        TEST( a.size() == 4 );
    }

    {
        // recursion test
        jsonxx::Object o;
        o << "number" << 123;
        o << "string" << "world";
        o << "recursion" << o;
        TEST( o.size() == 3 );
    }

    if( Parser != Strict )
    {
        // C++ style comments test
        string teststr(
                "//this is comment #1 {\n"
                "{"
                "  \"foo\" : 1,"
                "  \"bar\" : false, //this is comment #2\n"
                "  \"person\" : {\"name //this shall not be removed\" : \"GWB\", \"age\" : 60},"
                "  \"data\": [\"abcd\", 42, 54.7]"
                "} //this is comment #3"
       );
        jsonxx::Object o;
        TEST( o.parse(teststr) );
    }

    if( argc > 1 )
    {
        std::ifstream ifs( argv[1] );

        if( ifs.good() ) {
            std::string read = jsonxx::reformat(ifs);
            TEST( read.size() );
            cout << read << endl;
        } else {
            cout << "Cant find '" << argv[1] << "'" << endl;
        }
    }

    cout << "All tests ok." << endl;
    return 0;
}

```

`main.cpp`:

```cpp
#include "stdafx.h"
#include <iostream>
#include <fstream>
#include <vector>
#include <Windows.h>
#include "jsonxx\jsonxx.h"
#include "modules\ProcEx.h"
#include "GHDumper.h"
#include "SrcDumper.h"

const std::string srcEngineGames[] = { "csgo.exe", "hl2.exe" };

int main()
{
	SetDebugPrivilege(true);

	Dumper* dumper;
	bool bSrcEngine = false;

	jsonxx::Object jsonConfig = ParseConfig();

	if (std::find(std::begin(srcEngineGames), std::end(srcEngineGames), jsonConfig.get<std::string>("executable")) != std::end(srcEngineGames))
	{
		bSrcEngine = true;
		dumper = new SrcDumper(&jsonConfig);
	}
	else dumper = new Dumper(&jsonConfig);

	dumper->Dump();

	return 0;
}
```

`modules/Mod.cpp`:

```cpp
#include "stdafx.h"
#include "Mod.h"

ModIn::ModIn(TCHAR* modName)
{
	name = modName;
	Get();
}

ModIn::ModIn(TCHAR* modName, ProcIn& process)
{
	name = modName;
	proc = &process;
	Get();
}

ModEx::ModEx(TCHAR* modName) {}

ModEx::~ModEx()
{
	//CloseHandle(proc->handle);
}

ModEx::ModEx(TCHAR* modName, ProcEx& process)
{
	name = modName;
	proc = &process;
	if (!proc->handle)
	{
		proc->Get();
	}
	this->Get();
}

bool ModEx::Get()
{
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, proc->procEntry.th32ProcessID);
	if (hSnap != INVALID_HANDLE_VALUE)
	{
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnap, &modEntry))
		{
			do
			{
				if (!_tcsicmp(modEntry.szModule, name))
				{
					CloseHandle(hSnap);
					return true;
				}
			} while (Module32Next(hSnap, &modEntry));
		}
	}

	CloseHandle(hSnap);
	modEntry = {};
	return false;
}

bool ModIn::Get()
{
	return GetLDREntry();
}

bool ModIn::GetLDREntry()
{
	proc->GetPEB();

	LIST_ENTRY head = proc->peb->Ldr->InMemoryOrderModuleList;

	LIST_ENTRY curr = head;

	while (curr.Flink != head.Blink)
	{
		RFW_LDR_DATA_TABLE_ENTRY* mod = (RFW_LDR_DATA_TABLE_ENTRY*)CONTAINING_RECORD(curr.Flink, RFW_LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

		if (mod->FullDllName.Buffer)
		{
			char* cName = TO_CHAR(mod->BaseDllName.Buffer);

			if (_tcsicmp(cName, name) == 0)
			{
				ldr = *mod;
				return true;
			}
			delete[] cName;
		}
		curr = *curr.Flink;
	}
	return false;
}

IMod::~IMod() {}
```

`modules/Mod.h`:

```h
#pragma once

#include "ProcEx.h"
#include "ProcIn.h"
#include "util.h"

//delete Mod, rename ModIn to Mod, have ModEx inherit from Mod ?

class IMod
{
public:
	TCHAR* name{ nullptr };
	MODULEENTRY32 modEntry{};
	RFW_LDR_DATA_TABLE_ENTRY ldr{};

	~IMod();

	virtual bool Get() = 0; //Find module and get the modEntry
};

class ModEx : public IMod
{
public:
	ProcEx* proc{ nullptr };

	ModEx(TCHAR* modName);
	ModEx(TCHAR* modName, ProcEx& process);

	~ModEx();

	virtual bool Get();
};

class ModIn : public IMod
{
public:
	ProcIn* proc{ nullptr };

	ModIn(TCHAR* modName);
	ModIn(TCHAR* modName, ProcIn& process);

	virtual bool Get();
	bool GetLDREntry();
};
```

`modules/ProcEx.cpp`:

```cpp
#include "stdafx.h"
#include "ProcEx.h"

ProcEx::ProcEx() {}

ProcEx::~ProcEx()
{
	//procex proc = procEx() will close the handle = bad
	//CloseHandle(handle);
}

//Get ProcEx by name
bool ProcEx::Get()
{
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (hSnapshot != INVALID_HANDLE_VALUE)
	{
		procEntry.dwSize = sizeof(procEntry);

		if (Process32First(hSnapshot, &procEntry))
		{
			do
			{
				if (!_tcscmp(procEntry.szExeFile, this->name))
				{
					CloseHandle(hSnapshot);
					return true;
				}
			} while (Process32Next(hSnapshot, &procEntry));
		}
	}
	CloseHandle(hSnapshot);
	procEntry = {};
	return false;
}

ProcEx::ProcEx(TCHAR* exeName)
{
	this->name = exeName;
	Get();
	Attach();
	GetPEB();
	//exeMod = ModEx(exeName);
	//exeMod = new ModEx(exeName);
}

bool ProcEx::Attach()
{
	handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procEntry.th32ProcessID);

	if (handle)
	{
		return true;
	}
	else return false;
}

bool ProcEx::GetPEB()
{
	if (!NtQueryInfoProc) ImportNTQueryInfo();

	if (NtQueryInfoProc)
	{
		NTSTATUS status = NtQueryInfoProc(handle, ProcessBasicInformation, &pbi, sizeof(pbi), 0);
		if (NT_SUCCESS(status))
		{
			ReadProcessMemory(handle, pbi.PebBaseAddress, &peb, sizeof(peb), 0);
			return true;
		}
	}
	return false;
}

bool SetDebugPrivilege(bool Enable)
{
	HANDLE hToken{ nullptr };
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken))
		return false;

	TOKEN_PRIVILEGES TokenPrivileges{};
	TokenPrivileges.PrivilegeCount = 1;
	TokenPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

	if (!LookupPrivilegeValueA(nullptr, "SeDebugPrivilege", &TokenPrivileges.Privileges[0].Luid))
	{
		CloseHandle(hToken);
		return false;
	}

	if (!AdjustTokenPrivileges(hToken, FALSE, &TokenPrivileges, sizeof(TOKEN_PRIVILEGES), nullptr, nullptr))
	{
		CloseHandle(hToken);
		return false;
	}

	CloseHandle(hToken);

	return true;
}
```

`modules/ProcEx.h`:

```h
#pragma once
#include <Windows.h>
#include <TlHelp32.h>
#include <stdlib.h>
#include <vector>
#include <intrin.h>
#include "RFW_ntapi.h"
#include "proc.h"

class ModEx;

class ProcEx : public IProc
{
public:
	RFW_PROCESS_BASIC_INFORMATION pbi{ 0 };
	_RFW_PEB peb{};
	ModEx* exeMod; //IMod* ?

	ProcEx();
	ProcEx(TCHAR* exeName);

	~ProcEx();

	virtual bool Get(); //Finds process and get the procEntry
	virtual bool Attach(); //Gets Handle to process with PROCESS_ALL_ACCESS
	virtual bool GetPEB(); //Use NTQueryInformation to get the PEB address and make a copy of it
};

```

`modules/ProcIn.cpp`:

```cpp
#include "stdafx.h"
#include "ProcIn.h"

ProcIn::ProcIn()
{
	TCHAR path[MAX_PATH]{};
	TCHAR file[MAX_PATH]{};
	TCHAR ext[MAX_PATH]{};
	TCHAR filename[MAX_PATH]{};
	GetModuleFileName(NULL, path, MAX_PATH);
	_tsplitpath_s(path, 0, 0, 0, 0, file, MAX_PATH, ext, MAX_PATH);
	_tcscpy_s(filename, file);
	_tcscat_s(filename, ext);
	name = filename;
	Get();
}

ProcIn::~ProcIn()
{}

//internal
bool ProcIn::GetPEB()
{
#ifdef _WIN64
	peb = (_RFW_PEB*)__readgsword(0x60);

#else
	peb = (_RFW_PEB*)__readfsdword(0x30);
#endif

	return peb != nullptr;
}

bool ProcIn::Get()
{
	return GetPEB();
}
```

`modules/ProcIn.h`:

```h
#pragma once
#include <Windows.h>
#include <TlHelp32.h>
#include <stdlib.h>
#include <vector>
#include <intrin.h>
#include "RFW_ntapi.h"
#include "proc.h"

class ProcIn : public IProc
{
public:
	ProcIn();
	~ProcIn();

	_RFW_PEB* peb{ nullptr };

	virtual bool Get();
	virtual bool GetPEB();
};

```

`modules/patternscan.cpp`:

```cpp
#include "stdafx.h"
#include "patternscan.h"

constexpr int ModuleFinder = 1337;

//Splits combo pattern into mask/pattern, accepts all wildcard variations
void Pattern::Parse(char* combo, char* pattern, char* mask)
{
	char lastChar = ' ';
	int j = 0;

	for (unsigned int i = 0; i < strlen(combo); i++)
	{
		if ((combo[i] == '?' || combo[i] == '*') && (lastChar != '?' && lastChar != '*'))
		{
			pattern[j] = mask[j] = '?';
			j++;
		}

		else if (isspace(lastChar))
		{
			pattern[j] = lastChar = (char)strtol(&combo[i], 0, 16);
			mask[j] = 'x';
			j++;
		}
		lastChar = combo[i];
	}
	pattern[j] = mask[j] = '\0';
}

//Basic Scan
char* Pattern::ScanBasic(char* pattern, char* mask, char* begin, intptr_t size)
{
	intptr_t patternLen = strlen(mask);

	//for (int i = 0; i < size - patternLen; i++)
	for (int i = 0; i < size; i++)
	{
		bool found = true;
		for (int j = 0; j < patternLen; j++)
		{
			if (mask[j] != '?' && pattern[j] != *(char*)((intptr_t)begin + i + j))
			{
				found = false;
				break;
			}
		}
		if (found)
		{
			return (begin + i);
		}
	}
	return nullptr;
}

HMODULE GetModuleNameByAddress(char* addr)
{
	MEMORY_BASIC_INFORMATION mbi{};
	TCHAR szPath[MAX_PATH + 1]{};
	if (VirtualQuery(addr, &mbi, sizeof(mbi)))
	{
		GetModuleFileName((HMODULE)(mbi.AllocationBase), szPath, MAX_PATH);
	}

	return (HMODULE)mbi.AllocationBase;
}

//External Wrapper
//TODO: Fix issue with missing patterns that bridge regions
char* Pattern::Ex::Scan(char* pattern, char* mask, char* begin, intptr_t size, HANDLE hProc)
{
	char* match{ nullptr };
	SIZE_T bytesRead;
	DWORD oldprotect;
	char* buffer{ nullptr };
	MEMORY_BASIC_INFORMATION mbi;
	mbi.RegionSize = 0x1000;//

	VirtualQueryEx(hProc, (LPCVOID)begin, &mbi, sizeof(mbi));

	for (char* curr = begin; curr < begin + size; curr += mbi.RegionSize)
	{
		if (!VirtualQueryEx(hProc, curr, &mbi, sizeof(mbi))) continue;
		if (mbi.State != MEM_COMMIT || mbi.Protect == PAGE_NOACCESS) continue;

		delete[] buffer;
		buffer = new char[mbi.RegionSize];

		if (VirtualProtectEx(hProc, mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &oldprotect))
		{
			ReadProcessMemory(hProc, mbi.BaseAddress, buffer, mbi.RegionSize, &bytesRead);
			VirtualProtectEx(hProc, mbi.BaseAddress, mbi.RegionSize, oldprotect, &oldprotect);

			char* internalAddr = ScanBasic(pattern, mask, buffer, (intptr_t)bytesRead);

			if (internalAddr != nullptr)
			{
				//calculate from internal to external
				match = curr + (internalAddr - buffer);
				break;
			}
		}
	}
	delete[] buffer;
	return match;
}

//Module wrapper for external pattern scan
char* Pattern::Ex::ScanMod(char* pattern, char* mask, ModEx& mod)
{
	return Scan(pattern, mask, (char*)mod.modEntry.modBaseAddr, mod.modEntry.modBaseSize, mod.proc->handle);
}

//combo
char* Pattern::Ex::ScanMod(char* combopattern, ModEx& mod)
{
	char pattern[100]{};
	char mask[100]{};
	Pattern::Parse(combopattern, pattern, mask);
	return Pattern::Ex::ScanMod(pattern, mask, mod);
}

//Loops through all modules and scans them
char* Pattern::Ex::ScanAllMods(char* pattern, char* mask, ProcEx& proc)
{
	MODULEENTRY32 modEntry{};
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, proc.procEntry.th32ProcessID);
	if (hSnapshot != INVALID_HANDLE_VALUE)
	{
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnapshot, &modEntry))
		{
			do
			{
				char* match = Scan(pattern, mask, (char*)modEntry.modBaseAddr, modEntry.modBaseSize, proc.handle);
				if (match != nullptr)
				{
					CloseHandle(hSnapshot);
					return match;
				}
			} while (Module32Next(hSnapshot, &modEntry));
		}
		CloseHandle(hSnapshot);
	}
	return nullptr;
}

char* Pattern::Ex::ScanProc(char* pattern, char* mask, ProcEx& proc)
{
	//TODO: this should only scan good memory like the other one

	unsigned long long int kernelMemory = IsWow64Proc(proc.handle) ? 0x80000000 : 0x800000000000;

	return Scan(pattern, mask, 0x0, (intptr_t)kernelMemory, proc.handle);
}
```

`modules/patternscan.h`:

```h
#pragma once
#include <Windows.h>
#include <TlHelp32.h>
#include "proc.h"
#include "Mod.h"
#include <vector>
#include "util.h"

namespace Pattern
{
	//Split combo pattern into mask/pattern
	void Parse(char* combo, char* pattern, char* mask);

	//Pattern Scan
	char* ScanBasic(char* pattern, char* mask, char* begin, intptr_t size);

	namespace Ex
	{
		//External Wrapper
		char* Scan(char* pattern, char* mask, char* begin, intptr_t size, HANDLE hProc);

		//Scan a single module
		char* ScanMod(char* pattern, char* mask, ModEx& module);

		char* ScanMod(char* combopattern, ModEx& mod);

		//Scan all modules from process
		char* ScanAllMods(char* pattern, char* mask, ProcEx& proc);

		//Scan entire process
		char* ScanProc(char* pattern, char* mask, ProcEx& proc);
	}
}
```

`modules/proc.cpp`:

```cpp
#include "stdafx.h"
#include "proc.h"
#include "rfw_ntapi.h"

IProc::~IProc()
{
	//if (handle != nullptr)
	//CloseHandle(handle);
}

bool IsWow64Proc(HANDLE hProc)
{
	BOOL bWow64;
	IsWow64Process(hProc, &bWow64);
	return bWow64;
}

//basic function for quick projects
DWORD GetProcId(const TCHAR* procName)
{
	DWORD procId = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap != INVALID_HANDLE_VALUE)
	{
		PROCESSENTRY32 procEntry;
		procEntry.dwSize = sizeof(procEntry);

		if (Process32First(hSnap, &procEntry))
		{
			do
			{
				if (!_tcsicmp(procEntry.szExeFile, procName))
				{
					procId = procEntry.th32ProcessID;
					break;
				}
			} while (Process32Next(hSnap, &procEntry));

		}
	}
	CloseHandle(hSnap);
	return procId;
}

char* GetModuleBaseAddress(const TCHAR* modName, DWORD procId)
{
	char* modBaseAddr{ nullptr };
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
	if (hSnap != INVALID_HANDLE_VALUE)
	{
		MODULEENTRY32 modEntry{};
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnap, &modEntry))
		{
			do
			{
				if (!_tcsicmp(modEntry.szModule, modName))
				{
					modBaseAddr = (char*)modEntry.modBaseAddr;
					break;
				}
			} while (Module32Next(hSnap, &modEntry));
		}
	}
	CloseHandle(hSnap);
	return modBaseAddr;
}
```

`modules/proc.h`:

```h
#pragma once
#include <Windows.h>
#include <TlHelp32.h>
#include <stdlib.h>
#include <vector>
#include <intrin.h>
#include "RFW_ntapi.h"

extern tNtQueryInformationProcess NtQueryInfoProc;

class IMod;

class IProc
{
public:
	TCHAR* name{ nullptr };
	PROCESSENTRY32 procEntry{};
	HANDLE handle{ nullptr }; //optional in internal

	~IProc();

	virtual bool Get() = 0;
};

//basic functions
DWORD GetProcId(const TCHAR* procName);
char* GetModuleBaseAddress(const TCHAR* modName, DWORD procId);
bool IsWow64Proc(HANDLE hProc);
bool SetDebugPrivilege(bool Enable);
```

`modules/rfw_ntapi.cpp`:

```cpp
#include "stdafx.h"
#include "rfw_ntapi.h"

tNtQueryInformationProcess NtQueryInfoProc{ nullptr };

tNtQueryInformationProcess ImportNTQueryInfo()
{
	NtQueryInfoProc = (tNtQueryInformationProcess)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationProcess");

	if (NtQueryInfoProc)
	{
		return NtQueryInfoProc;
	}
	else return false;
}

//redundant, already included in IProc
PEB* GetPEB()
{
#ifdef _WIN64
	PEB* peb = (PEB*)__readgsword(0x60); //64bit

#else
	PEB* peb = (PEB*)__readfsdword(0x30); //32bit
#endif

	return peb;
}
```

`modules/rfw_ntapi.h`:

```h
#pragma once

#include <windows.h>
#include <winternl.h>
#include "rfw_ntdll.h"
#include "util.h"

typedef NTSTATUS(__stdcall* tNtQueryInformationProcess)
(
	HANDLE ProcessHandle,
	PROCESSINFOCLASS ProcInformationClass,
	PVOID ProcInformation,
	ULONG ProcInformationLength,
	PULONG ReturnLength
	);

tNtQueryInformationProcess ImportNTQueryInfo();

PEB* GetPEB();
```

`modules/rfw_ntdll.h`:

```h
#pragma once
//Sources:
//https://github.com/x64dbg/x64dbg/blob/development/src/dbg/ntdll/ntdll.h
//this will conflict with winternl.h, need to modify everything to avoid conflict
//for each struct you import, prefix with RFW_, if it starts with _, make it _RFW_
//delete the redefinition that follows } and prefix the *P with RFW_

#define GDI_HANDLE_BUFFER_SIZE32	34
#define GDI_HANDLE_BUFFER_SIZE64	60

#ifndef _WIN64
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];
typedef LONG KPRIORITY, * PKPRIORITY;
#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

typedef struct _RFW_UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} *RFW_P_RFW_UNICODE_STRING;

typedef const _RFW_UNICODE_STRING* RFW_PC_RFW_UNICODE_STRING;

typedef struct _RFW_CURDIR
{
	_RFW_UNICODE_STRING DosPath;
	HANDLE Handle;
} *RFW_PCURDIR;

typedef struct _RFW_RTL_DRIVE_LETTER_CURDIR
{
	USHORT Flags;
	USHORT Length;
	ULONG TimeStamp;
	_RFW_UNICODE_STRING DosPath;
} *RFW_PRTL_DRIVE_LETTER_CURDIR;

typedef struct _RFW_RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;
	ULONG Length;

	ULONG Flags;
	ULONG DebugFlags;

	HANDLE ConsoleHandle;
	ULONG ConsoleFlags;
	HANDLE StandardInput;
	HANDLE StandardOutput;
	HANDLE StandardError;

	_RFW_CURDIR CurrentDirectory;
	_RFW_UNICODE_STRING DllPath;
	_RFW_UNICODE_STRING ImagePathName;
	_RFW_UNICODE_STRING CommandLine;
	PWCHAR Environment;

	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;

	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	_RFW_UNICODE_STRING WindowTitle;
	_RFW_UNICODE_STRING DesktopInfo;
	_RFW_UNICODE_STRING ShellInfo;
	_RFW_UNICODE_STRING RuntimeData;
	_RFW_RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

	ULONG_PTR EnvironmentSize;
	ULONG_PTR EnvironmentVersion;
	PVOID PackageDependencyData;
	ULONG ProcessGroupId;
	ULONG LoaderThreads;
} *RFW_PRTL_USER_PROCESS_PARAMETERS;

//typedef struct _RFW_PEB_LDR_DATA
typedef struct _RFW_PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
} *RFW_PPEB_LDR_DATA;

typedef struct _RFW_PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN IsPackagedProcess : 1;
			BOOLEAN IsAppContainer : 1;
			BOOLEAN IsProtectedProcessLight : 1;
			BOOLEAN IsLongPathAwareProcess : 1;
		} s1;
	} u1;

	HANDLE Mutant;

	PVOID ImageBaseAddress;
	RFW_PPEB_LDR_DATA Ldr;
	RFW_PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PRTL_CRITICAL_SECTION FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ProcessPreviouslyThrottled : 1;
			ULONG ProcessCurrentlyThrottled : 1;
			ULONG ReservedBits0 : 25;
		} s2;
	} u2;
	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	} u3;
	ULONG SystemReserved[1];
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
	ULONG TlsExpansionCounter;
	PVOID TlsBitmap;
	ULONG TlsBitmapBits[2];

	PVOID ReadOnlySharedMemoryBase;
	PVOID SharedData; // HotpatchInformation
	PVOID* ReadOnlyStaticServerData;

	PVOID AnsiCodePageData; // PCPTABLEINFO
	PVOID OemCodePageData; // PCPTABLEINFO
	PVOID UnicodeCaseTableData; // PNLSTABLEINFO

	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;

	LARGE_INTEGER CriticalSectionTimeout;
	SIZE_T HeapSegmentReserve;
	SIZE_T HeapSegmentCommit;
	SIZE_T HeapDeCommitTotalFreeThreshold;
	SIZE_T HeapDeCommitFreeBlockThreshold;

	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	PVOID* ProcessHeaps; // PHEAP

	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper;
	ULONG GdiDCAttributeList;

	PRTL_CRITICAL_SECTION LoaderLock;

	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
	ULONG OSPlatformId;
	ULONG ImageSubsystem;
	ULONG ImageSubsystemMajorVersion;
	ULONG ImageSubsystemMinorVersion;
	ULONG_PTR ActiveProcessAffinityMask;
	GDI_HANDLE_BUFFER GdiHandleBuffer;
	PVOID PostProcessInitRoutine;

	PVOID TlsExpansionBitmap;
	ULONG TlsExpansionBitmapBits[32];

	ULONG SessionId;

	ULARGE_INTEGER AppCompatFlags;
	ULARGE_INTEGER AppCompatFlagsUser;
	PVOID pShimData;
	PVOID AppCompatInfo; // APPCOMPAT_EXE_DATA

	_RFW_UNICODE_STRING CSDVersion;

	PVOID ActivationContextData; // ACTIVATION_CONTEXT_DATA
	PVOID ProcessAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP
	PVOID SystemDefaultActivationContextData; // ACTIVATION_CONTEXT_DATA
	PVOID SystemAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP

	SIZE_T MinimumStackCommit;

	PVOID* FlsCallback;
	LIST_ENTRY FlsListHead;
	PVOID FlsBitmap;
	ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
	ULONG FlsHighIndex;

	PVOID WerRegistrationData;
	PVOID WerShipAssertPtr;
	PVOID pUnused; // pContextData
	PVOID pImageHeaderHash;
	union
	{
		ULONG TracingFlags;
		struct
		{
			ULONG HeapTracingEnabled : 1;
			ULONG CritSecTracingEnabled : 1;
			ULONG LibLoaderTracingEnabled : 1;
			ULONG SpareTracingBits : 29;
		} s3;
	} u4;
	ULONGLONG CsrServerReadOnlySharedMemoryBase;
	PVOID TppWorkerpListLock;
	LIST_ENTRY TppWorkerpList;
	PVOID WaitOnAddressHashTable[128];
	PVOID TelemetryCoverageHeader; // REDSTONE3
	ULONG CloudFileFlags;
}*RFW_PPEB;

#define RTL_BALANCED_NODE_RESERVED_PARENT_MASK 3

enum _RFW_LDR_DDAG_STATE
{
	LdrModulesMerged = -5,
	LdrModulesInitError = -4,
	LdrModulesSnapError = -3,
	LdrModulesUnloaded = -2,
	LdrModulesUnloading = -1,
	LdrModulesPlaceHolder = 0,
	LdrModulesMapping = 1,
	LdrModulesMapped = 2,
	LdrModulesWaitingForDependencies = 3,
	LdrModulesSnapping = 4,
	LdrModulesSnapped = 5,
	LdrModulesCondensed = 6,
	LdrModulesReadyToInit = 7,
	LdrModulesInitializing = 8,
	LdrModulesReadyToRun = 9
};

typedef struct _RFW_RTL_BALANCED_NODE
{
	union
	{
		struct _RFW_RTL_BALANCED_NODE* Children[2];
		struct
		{
			struct _RFW_RTL_BALANCED_NODE* Left;
			struct _RFW_RTL_BALANCED_NODE* Right;
		} s;
	};
	union
	{
		UCHAR Red : 1;
		UCHAR Balance : 2;
		ULONG_PTR ParentValue;
	} u;
} *RFW_PRTL_BALANCED_NODE;

typedef struct _RFW_LDR_SERVICE_TAG_RECORD
{
	struct _RFW_LDR_SERVICE_TAG_RECORD* Next;
	ULONG ServiceTag;
} *RFW_PLDR_SERVICE_TAG_RECORD;

enum _LDR_DLL_LOAD_REASON
{
	LoadReasonStaticDependency,
	LoadReasonStaticForwarderDependency,
	LoadReasonDynamicForwarderDependency,
	LoadReasonDelayloadDependency,
	LoadReasonDynamicLoad,
	LoadReasonAsImageLoad,
	LoadReasonAsDataLoad,
	LoadReasonUnknown = -1
}; //*RFW_PLDR_DLL_LOAD_REASON;

typedef struct _RFW_LDRP_CSLIST
{
	PSINGLE_LIST_ENTRY Tail;
} *RFW_PLDRP_CSLIST;

typedef struct _RFW_LDR_DDAG_NODE
{
	LIST_ENTRY Modules;
	RFW_PLDR_SERVICE_TAG_RECORD ServiceTagList;
	ULONG LoadCount;
	ULONG LoadWhileUnloadingCount;
	ULONG LowestLink;
	union
	{
		_RFW_LDRP_CSLIST Dependencies;
		SINGLE_LIST_ENTRY RemovalLink;
	};
	_RFW_LDRP_CSLIST IncomingDependencies;
	_RFW_LDR_DDAG_STATE State;
	SINGLE_LIST_ENTRY CondenseLink;
	ULONG PreorderNumber;
} *RFW_PLDR_DDAG_NODE;

enum class _RFW_LDR_DLL_LOAD_REASON
{
	LoadReasonStaticDependency,
	LoadReasonStaticForwarderDependency,
	LoadReasonDynamicForwarderDependency,
	LoadReasonDelayloadDependency,
	LoadReasonDynamicLoad,
	LoadReasonAsImageLoad,
	LoadReasonAsDataLoad,
	LoadReasonUnknown = -1
}; //*RFW_PLDR_DLL_LOAD_REASON;

typedef struct RFW_LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	_RFW_UNICODE_STRING FullDllName;
	_RFW_UNICODE_STRING BaseDllName;
	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;
		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG LoadConfigProcessed : 1;
			ULONG EntryProcessed : 1;
			ULONG ProtectDelayLoad : 1;
			ULONG ReservedFlags3 : 2;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ReservedFlags5 : 3;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		} s;
	} u;
	USHORT ObsoleteLoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
	struct _ACTIVATION_CONTEXT* EntryPointActivationContext;
	PVOID Lock;
	RFW_PLDR_DDAG_NODE DdagNode;
	LIST_ENTRY NodeModuleLink;
	struct _LDRP_LOAD_CONTEXT* LoadContext;
	PVOID ParentDllBase;
	PVOID SwitchBackContext;
	_RFW_RTL_BALANCED_NODE BaseAddressIndexNode;
	_RFW_RTL_BALANCED_NODE MappingInfoIndexNode;
	ULONG_PTR OriginalBase;
	LARGE_INTEGER LoadTime;
	ULONG BaseNameHashValue;
	_RFW_LDR_DLL_LOAD_REASON LoadReason;
	ULONG ImplicitPathOptions;
	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel; // Since Windows 10 RS2
}*RFW_PLDR_DATA_TABLE_ENTRY;

union RFW_UNION_LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY list;
	RFW_LDR_DATA_TABLE_ENTRY dataEntry;
};

typedef struct RFW_PROCESS_BASIC_INFORMATION
{
	NTSTATUS ExitStatus;
	PPEB PebBaseAddress;
	ULONG_PTR AffinityMask;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
} *RFW_PPROCESS_BASIC_INFORMATION;

```

`modules/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// TODO: reference additional headers your program requires here
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <thread>
#include <TlHelp32.h>
#include <Winternl.h>
#include <stdlib.h>
#include <winnt.h>
#include <intrin.h>
#include <dwmapi.h>
```

`modules/util.cpp`:

```cpp
#include "stdafx.h"
#include "util.h"

wchar_t* TO_WCHAR_T(char* string)
{
	size_t len = strlen(string) + 1;
	wchar_t* wc_string = new wchar_t[len];
	size_t numCharsRead;
	mbstowcs_s(&numCharsRead, wc_string, len, string, _TRUNCATE);
	return wc_string;
}

char* TO_CHAR(wchar_t* string)
{
	size_t len = wcslen(string) + 1;
	char* c_string = new char[len];
	size_t numCharsRead;
	wcstombs_s(&numCharsRead, c_string, len, string, _TRUNCATE);
	return c_string;
}

std::string AddrToHexString(intptr_t addr)
{
	std::stringstream ss;
	ss << "0x" << std::uppercase << std::hex << addr;
	return ss.str();
}

size_t strfindi(std::string buffer, std::string find)
{
	std::transform(buffer.begin(), buffer.end(), buffer.begin(), std::tolower);
	std::transform(find.begin(), find.end(), find.begin(), std::tolower);
	return buffer.find(find);
}
```

`modules/util.h`:

```h
#pragma once
#include <windows.h>
#include <string>
#include <sstream>

wchar_t* TO_WCHAR_T(char* string);

char* TO_CHAR(wchar_t* string);

std::string AddrToHexString(intptr_t addr);

size_t strfindi(std::string buffer, std::string find);
```

`readme.md`:

```md
# Guided Hacking Offset Dumper aka GH Offset Dumper  

Version 0.7

### What does it do
Externally scan a process for signatures and dump the relative offsets to a header file which is easy to incorporate into your Visual Studio project.  When an update is released for a game, you run the dumper to get the latest offsets.

### Why
Scrubs don't know how to pattern scan so they manually update their offsets in their game hacks after running an offset dumper like this.

### How to use
1. Put an updated config.json in the same folder as GH-Offset-Dumper.exe
2. Run the game
3. Run the dumper
4. Include the .h file which gets generated into your project


### How is this different from HazeDumper?
This dumper was inspired by [hazedumper](https://github.com/frk1/hazedumper) so thank you to frk1, rN' and the other contributors to that project.

I started learning Rust when messing with HazeDumper and I decided we needed a C++ version, I also wanted to extend the functionality.

GH Dumper will do the same thing as HazeDumper with the addition of dumping ReClass files and Cheat Engine Tables.

Our dumper uses the same json config file format, so they are interchangeable

### Notes
Ignore the files in the modules folder, these are just modules from my framework which I use to do some of the background stuff.

The main code is GHDumper and SrcDumper

### TODO
* Reduce bloat from modules folder
* Improve CE Output
* Add ReClass.NET output
* Turn into a lib which can be incorporated into hacks
* Make an internal version
* Seperate CSGO vs regular functionality
* Add CSS functionality
* organize output of offsets or put comments showing what module they are for and what base object
* Other ideas to make it kewl

### Credits
Thank you to frk1, rN' and the contributors to [hazedumper](https://github.com/frk1/hazedumper)

Thank you to hjiang and the contributors of [jsonxx](https://github.com/hjiang/jsonxx/)
```

`resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by GH-Offset-Dumper.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`stdafx.cpp`:

```cpp
#include "stdafx.h"
```

`stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// TODO: reference additional headers your program requires here
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <thread>
#include <TlHelp32.h>
#include <Winternl.h>
#include <stdlib.h>
#include <winnt.h>
#include <intrin.h>
#include <dwmapi.h>
```

`targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

/*
#define WINVER _WIN32_WINNT_WIN8
#define _WIN32_WINNT _WIN32_WINNT_WIN8
*/

#include <SDKDDKVer.h>

```