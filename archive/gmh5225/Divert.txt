Project Path: arc_gmh5225_Divert_febgjgxz

Source Tree:

```txt
arc_gmh5225_Divert_febgjgxz
├── CHANGELOG
├── LICENSE
├── README
├── VERSION
├── dirs
├── dll
│   ├── windivert.c
│   ├── windivert.def
│   ├── windivert.vcxproj
│   ├── windivert_hash.c
│   ├── windivert_helper.c
│   └── windivert_shared.c
├── doc
│   └── windivert.html
├── examples
│   ├── flowtrack
│   │   ├── flowtrack.c
│   │   └── flowtrack.vcxproj
│   ├── netdump
│   │   ├── netdump.c
│   │   └── netdump.vcxproj
│   ├── netfilter
│   │   ├── netfilter.c
│   │   └── netfilter.vcxproj
│   ├── passthru
│   │   ├── passthru.c
│   │   └── passthru.vcxproj
│   ├── socketdump
│   │   ├── socketdump.c
│   │   └── socketdump.vcxproj
│   ├── streamdump
│   │   ├── streamdump.c
│   │   └── streamdump.vcxproj
│   ├── webfilter
│   │   ├── webfilter.c
│   │   └── webfilter.vcxproj
│   └── windivertctl
│       ├── windivertctl.c
│       └── windivertctl.vcxproj
├── include
│   ├── windivert.h
│   └── windivert_device.h
├── inf
│   ├── windivert32.inf
│   └── windivert64.inf
├── mingw-build.sh
├── msvc-build.bat
├── release-build.sh
├── sys
│   ├── Makefile
│   ├── Makefile.inc
│   ├── sources
│   ├── windivert.c
│   ├── windivert.rc
│   ├── windivert.vcxproj
│   └── windivert_log.mc
├── test
│   ├── build.sh
│   ├── test.c
│   ├── test.vcxproj
│   └── test_data.c
└── wddk-build.bat

```

`CHANGELOG`:

```
WinDivert 1.0.0
    - First release of WinDivert 1.0
WinDivert 1.0.1
    - Fixed stack overflow bug in 32bit versions of the driver.
WinDivert 1.0.2
    - WinDivert now requires Administrator privileges in order to access
      (as opposed to just install) the WinDivert device.
WinDivert 1.0.3
    - Fix bug(s) relating to the parsing of IPv6 addresses.
    - DivertOpen() now returns more meaningful error codes on failure.
    - Two new helper API functions: DivertHelperParseIPvXAddress(..), X=4,6.
    - Renamed DivertHelperParse(..) to DivertHelperParsePacket(..).
WinDivert 1.0.4
    - Same as WinDivert 1.0.3 except:
      * Released with signed drivers.
      * MinGW compiled gcc-4.6
      * Minor documentation changes.
WinDivert 1.0.5
    - Fix the DIVERT_NETWORK_FORWARD_LAYER implementation.
    - Upgrade Visual Studio support to 2012.
WinDivert 1.1.0-rc
    - Re-brand "DIVERT" to "WINDIVERT" throughout the code-base.
    - New flag:
      * WINDIVERT_FLAG_NO_CHECKSUM: Do not guarantee that diverted packets
        have a correct checksum.
    - New default values and limits for various WinDivert parameters,
      including WINDIVERT_PARAM_QUEUE_LEN, WINDIVERT_PARAM_QUEUE_TIME, and
      the maximum filter length.
    - New extended WinDivert functions that support asynchronous I/O:
      * WinDivertRecvEx(..)
      * WinDivertSendEx(..)
    - The WinDivert driver now services reads (WinDivertRecv()) out-of-band.
    - The WinDivert driver now protects packet data from modification by
      other callout drivers and the user program.
    - The WinDivert service is no longer created when the driver fails to
      load.
WinDivert 1.1.1
    - Fixed a BSOD that sometimes occurs when the driver is unloaded.
WinDivert 1.1.2-rc
    - Renamed drivers to "WinDivert32.sys" and "WinDivert64.sys".  Both can
      exist in the same directory, and WinDivert.dll automatically loads the
      correct version.
    - Deprecate both the WinDivert.inf and WdfCoInstaller*.dll files.
WinDivert 1.1.3
    - Fixed a bug that causes some outbound TCP packets to be lost.
WinDivert 1.1.4
    - Fixed a BSOD that occurs when NULL is passed as the address parameter to
      WinDivertRecv(..) or WinDivertSend(..).
WinDivert 1.1.5
    - Insert WinDivert as the highest priority WFP sublayer.
WinDivert 1.1.6
    - WinDivert now searches for the driver files in the application's
      directory (as opposed to the current directory).
WinDivert 1.1.7
    - Improved IPv6 support:
     * Fixed incorrect IPV6 TCP/UDP checksum calculation in
       WinDivertHelperCalcChecksums().
     * WinDivert driver now calculates checksums for IPV6 packets.
     * WinDivert can now handle IPV6 extension headers.
     * Fixed WinDivertHelperParseIPv6Address().
WinDivert 1.1.8
    - Fix ip.TOS handling bug.
    - Fix IPv6 comparison bug.
WinDivert 1.2.0-rc
    - The WinDivert filter language now supports C-style "(F1? F2: F3)"
      expressions, where {F1,F2,F3} are themselves filter expressions.
    - New WinDivert helper functions:
      * WinDivertHelperCheckFilter() checks if a filter string is valid.
      * WinDivertHelperEvalFilter() evaluates a filter on a packet.
    - Some packets (specifically outbound or loopback packets) returned by
      WinDivertRecv() or WinDivertRecvEx() are no longer required to have
      correct checksums.  Absent checksum fields will be set to zero.  If need
      be the checksums can be recovered by WinDivertHelperCalcChecksums().
    - The WINDIVERT_FLAG_NO_CHECKSUM flag has been deprecated.
    - The WinDivertHelperCalcChecksums() function now accepts a new
      WINDIVERT_HELPER_NO_REPLACE flag, which indicates that non-zero checksum
      fields should not be replaced.
    - Support for the old WinDivert1.0 API has been removed.
WinDivert 1.2.1
    - Identical to WinDivert 1.2.0-rc.
WinDivert 1.3.0
    - Fix BSOD that sometimes occurs after abnormal user application exit.
    - Fix BSOD that sometimes occurs when WinDivert is combined with other
      callout drivers.
    - WinDivertSend() has been optimized.  However, it may not detect as
      many packet injection errors as it could before.
WinDivert 1.4.0-rc
    - Add a new WINDIVERT_PARAM_QUEUE_SIZE parameter that can be used to
      control the maximum number of bytes used by the packet queue.
    - Add a new WINDIVERT_FLAG_DEBUG flag that causes WinDivertSend() to
      block until the packet exits the Windows TCP/IP stack.  This is slower
      but provides better error messages, so is useful for debugging.
    - Internally queued packets are now reinjected when WinDivertClose() is
      called instead of being dropped.
    - WINDIVERT_ADDRESS now includes a Timestamp field that indicates when
      the packet was first captured by WinDivert.  The timestamp uses the
      same clock as QueryPerformanceCounter().
    - WINDIVERT_ADDRESS now includes a Loopback field that indicates whether
      the packet is a loopback packet or not.
    - The filter language has been extended to include a loopback field that
      matches loopback packets.
    - Loopback packets are now considered to be outbound-only.
    - WINDIVERT_ADDRESS now includes an Impostor field which indicates that the
      packet originated from another driver rather than from the network or
      TCP/IP stack.
    - WinDivertRecv() will eventually fail with ERROR_HOST_UNREACHABLE if
      an impostor packet enters an infinite loop (see #41).
    - The filter language has been extended to include an impostor field that 
      matches impostor packets.
    - WINDIVERT_ADDRESS now includes three new flags relating to checksums:
      * PseudoIPChecksum
      * PseudoTCPChecksum
      * PseudoUDPChecksum
      When set, these flags indicate that the corresponding packet uses
      "pseudo" IP/TCP/UDP checksums instead of the default full checksums.
      Pseudo checksums are cheaper to calculate, and can be used when the
      network hardware supports checksum offloading.
    - WinDivertHelperCalcChecksums() now takes an optional pointer to a
      WINDIVERT_ADDRESS structure, and calculates pseudo checksums if the
      corresponding Pseudo*Checksum flag is set.
    - The WINDIVERT_HELPER_NO_REPLACE flag for WinDivertHelperCalcChecksums()
      has been deprecated.  It is no longer necessary to calculate checksums
      for unmodified packets.
WinDivert 1.4.1
    - Dual license WinDivert under LGPLv3 and GPLv2.
WinDivert 1.4.2
    - Add workaround for pseudo checksum issue (see #134).
WinDivert 1.4.3
    - WinDivert.dll no longer depends on MSVCRT*.dll.
WinDivert 2.0.0-rc
    - Add 3 new layers:
      * WINDIVERT_LAYER_FLOW for tracking network "flow" events.
      * WINDIVERT_LAYER_SOCKET for tracking "socket" events.
      * WINDIVERT_LAYER_REFLECT for tracking WinDivert events.
    - WINDIVERT_ADDRESS has been re-factored as follows:
      * addr.Layer: The WINDIVERT_LAYER_* value for the handle.
      * addr.Event: A WINDIVERT_EVENT_* value representing the event (see
        below).
      * addr.Sniffed: Indicates that the event was sniffed.
      * addr.Outbound: Replaces addr.Direction.
      * addr.IPv6: Indicates an IPv6 packet.
      * addr.Network.IfIdx: Replaces addr.IfIdx.
      * addr.Network.SubIfIdx: Replaces addr.SubIfIdx.
      * addr.Flow.EndpointId: The endpoint ID of the flow.
      * addr.Flow.ParentEndpointId: The parent endpoint ID of the flow.
      * addr.Flow.ProcessId: The ID of process that created the flow.
      * addr.Flow.LocalAddr: The flow's local address.
      * addr.Flow.RemoteAddr: The flow's remote address.
      * addr.Flow.LocalPort: The flow's local port.
      * addr.Flow.RemotePort: The flow's remote port.
      * addr.Flow.Protocol: The flow's protocol.
      * addr.Socket.EndpointId: The endpoint ID of the operation.
      * addr.Socket.ParentEndpointId: The parent endpoint ID of the operation.
      * addr.Socket.ProcessId: The ID of process that created the socket.
      * addr.Socket.LocalAddr: The socket's local address.
      * addr.Socket.RemoteAddr: The socket's remote address.
      * addr.Socket.LocalPort: The socket's local port.
      * addr.Socket.RemotePort: The socket's remote port.
      * addr.Socket.Protocol: The socket's protocol.
      * addr.Reflect.ProcessId: The ID of process that created opened the
        handle.
      * addr.Reflect.Timestamp: The timestamp of the handle.
      * addr.Reflect.Layer: The layer of the handle.
      * addr.Reflect.Flags: The flags of the handle.
      * addr.Reflect.Priority: The priority of the handle.
    - The addr.Event field can take the following values:
      * WINDIVERT_EVENT_NETWORK_PACKET: (NETWORK/NETWORK_FORWARD layers) a new
        packet was diverted.
      * WINDIVERT_EVENT_FLOW_ESTABLISHED: (FLOW layer) a new flow is
        established.
      * WINDIVERT_EVENT_FLOW_DELETED: (FLOW layer) an existing flow is
        deleted.
      * WINDIVERT_EVENT_SOCKET_BIND: (SOCKET layer) a socket bind()
        operation occurred.
      * WINDIVERT_EVENT_SOCKET_CONNECT: (SOCKET layer) a socket connect()
        operation occurred.
      * WINDIVERT_EVENT_SOCKET_LISTEN: (SOCKET layer) a socket listen()
        operation occurred.
      * WINDIVERT_EVENT_SOCKET_ACCEPT: (SOCKET layer) a socket accept()
        operation occurred.
      * WINDIVERT_EVENT_SOCKET_CLOSE: (SOCKET layer) a socket endpoint is
        closed.
      * WINDIVERT_EVENT_REFLECT_OPEN: (REFLECT layer) a WinDivertOpen()
        operation occurred.
      * WINDIVERT_EVENT_REFLECT_CLOSE: (REFLECT layer) a WinDivertClose()
        operation occurred.
    - The WinDivert filter language has been expanded with new fields:
      * event: The event value.
      * timestamp: The event timestamp.
      * endpointId: (FLOW/SOCKET layers) the endpoint ID.
      * parentEndpointId: (FLOW/SOCKET layers) the parent endpoint ID.
      * processId: (FLOW/SOCKET/REFLECT layers) the process ID.
      * localAddr: (NETWORK/NETWORK_FORWARD/FLOW/SOCKET layers) the local
        address.
      * localPort: (NETWORK/NETWORK_FORWARD/FLOW/SOCKET layers) the local
        port.
      * remoteAddr: (NETWORK/NETWORK_FORWARD/FLOW/SOCKET layers) the remote
        address.
      * remotePort: (NETWORK/NETWORK_FORWARD/FLOW/SOCKET layers) the remote
        port.
      * protocol: (NETWORK/NETWORK_FORWARD/FLOW/SOCKET layers) the protocol.
      * priority: (REFLECT layer) the handle's priority.
      * layer: (REFLECT layer) the handle's layer.
      * random8: (NETWORK/NETWORK_FORWARD layers) an 8-bit pseudo random
        number.
      * random16: (NETWORK/NETWORK_FORWARD layers) a 16-bit pseudo random
        number.
      * random32: (NETWORK/NETWORK_FORWARD layers) a 32-bit pseudo random
        number.
      * length: (NETWORK/NETWORK_FORWARD layers) the packet length.
      * zero: The value "0".
    - The WinDivert filter language can now address packet/payload data for
      the NETWORK/NETWORK_FORWARD layers:
      * packet[i]: the ith packet byte.
      * packet16[i]: the ith packet 16bit word.
      * packet32[i]: the ith packet 32bit word.
      * tcp.payload[i]: the ith TCP payload byte.
      * tcp.payload16[i]: the ith TCP 16bit word.
      * tcp.payload32[i]: the ith TCP 32bit word.
      * udp.payload[i]: the ith UDP payload byte.
      * udp.payload16[i]: the ith UDP 16bit word.
      * udp.payload32[i]: the ith UDP 32bit word.
      The index (i) can be:
      * An ordinary integer representing word addressing.
      * A 'b' decorated integer representing byte-level addressing.
      Furthermore, the index can be:
      * Positive, representing addressing from the start of the
        packet/payload.
      * Negative, representing addressing from the end of the packet/payload.
    - The WinDivert filter language now supports several symbolic values:
      * PACKET: (NETWORK/NETWORK_FORWARD layers) equal to
        WINDIVERT_EVENT_NETWORK_PACKET
      * ESTABLISHED: (FLOW layer) equal to WINDIVERT_EVENT_FLOW_ESTABLISHED.
      * DELETED: (FLOW LAYER) equal to WINDIVERT_EVENT_FLOW_DELETED.
      * BIND: (SOCKET layer) equal to WINDIVERT_EVENT_SOCKET_BIND.
      * CONNECT: (SOCKET layer) equal to WINDIVERT_EVENT_SOCKET_CONNECT.
      * LISTEN: (SOCKET layer) equal to WINDIVERT_EVENT_SOCKET_LISTEN.
      * ACCEPT: (SOCKET layer) equal to WINDIVERT_EVENT_SOCKET_ACCEPT.
        WINDIVERT_LAYER_NETWORK_FORWARD.
      * CLOSE: (SOCKET layer) equal to WINDIVERT_EVENT_SOCKET_CLOSE.
      * OPEN: (REFLECT layer) equal to WINDIVERT_EVENT_REFLECT_OPEN.
      * CLOSE: (REFLECT layer) equal to WINDIVERT_EVENT_REFLECT_CLOSE.
      * NETWORK: (REFLECT layer) equal to WINDIVERT_LAYER_NETWORK.
      * NETWORK_FORWARD: (REFLECT layer) equal to
      * FLOW: (REFLECT layer) equal to WINDIVERT_LAYER_FLOW.
      * SOCKET: (REFLECT layer) equal to WINDIVERT_LAYER_SOCKET.
      * REFLECT: (REFLECT layer) equal to WINDIVERT_LAYER_REFLECT.
      * TRUE: equal to 1.
      * FALSE: equal to 0.
      * TCP: equal to IPPROTO_TCP (6).
      * UDP: equal to IPPROTO_UDP (17).
      * ICMP: equal to IPPROTO_ICMP (1).
      * ICMPV6: equal to IPPROTO_ICMPV6 (58).
    - WinDivertOpen() now supports several new flags:
      * WINDIVERT_FLAG_RECV_ONLY/WINDIVERT_FLAG_READ_ONLY: The handle cannot
        be used for send operations.
      * WINDIVERT_FLAG_SEND_ONLY/WINDIVERT_FLAG_WRITE_ONLY: The handle cannot
        be used for receive operations.
      * WINDIVERT_FLAG_NO_INSTALL: If the WinDivert driver is not already
        installed/loaded, then WinDivertOpen() will fail with an error.
    - WinDivertRecvEx()/WinDivertSendEx() now support a "batch" mode that
      allows more than one packet to be received/sent at once.  The number
      of packets is determined by a new pAddrLen/addrLen parameter.
    - Add a new WinDivertShutdown() function that supports the following
      modes:
      * WINDIVERT_SHUTDOWN_RECV: Disable the queuing new packets.
      * WINDIVERT_SHUTDOWN_SEND: Disable the sending of new packets.
      * WINDIVERT_SHUTDOWN_BOTH: Equivalent to
        (WINDIVERT_SHUTDOWN_RECV | WINDIVERT_SHUTDOWN_SEND).
    - Add new "read-only" WinDivert parameters:
      * WINDIVERT_PARAM_VERSION_MAJOR: Driver version (major).
      * WINDIVERT_PARAM_VERSION_MINOR: Driver version (minor).
    - Add a new WinDivertHelperHashPacket() helper function that calculates
      a 64bit hash value of a packet.
    - Add new WinDivertHelperFormatIPv4Address() and
      WinDivertHelperFormatIPv6Address() helper functions that format
      IPv4 and IPv6 addresses respectively.
    - Replace WinDivertHelperCheckFilter() with a new
      WinDivertHelperCompileFilter() helper function.  The latter can also be
      used to compile a human-readable filter string into a more compact
      "object" format.  The object format can be used in place of the
      human readable format for all WinDivert operations.
    - Add a new WinDivertHelperFormatFilter() helper function that formats a
      filter string into a normalized form.  It also can be used to
      "de-compile" the object format into a human readable form.
    - Add a new WinDivertHelperDecrementTTL() function that decrements the
      ip.TTL/ipv6.HopLimit field of a packet.
    - Add new WinDivertHelperNto*()/WinDivertHelperHton*() helper functions
      for swapping from network to host byte ordering, and vice versa.
    - WinDivertOpen() priorities now are ascending, meaning that higher
      values correspond to higher priorities.
    - The last two arguments for WinDivertRecv() and WinDivertSend() have been
      swapped.
WinDivert 2.0.1-rc
    - Fix WFP callout install optimization bug.
    - Fix WinDivertHelperNtohIpv6Address/WinDivertHelperHtonIpv6Address bug.
    - Rename the following functions for consistency:
      * WinDivertHelperNtohIpv6Address -> WinDivertHelperNtohIPv6Address
      * WinDivertHelperHtonIpv6Address -> WinDivertHelperHtonIPv6Address
WinDivert 2.1.0
    - WinDivertOpen() now supports a new flag:
      * WINDIVERT_FLAG_FRAGMENTS: If set, the handle will capture inbound IP
        fragments, but not inbound reassembled IP packets.  Otherwise, if not
        set (the default), the handle will capture inbound reassembled IP
        packets, but not inbound IP fragments.  This flag only affects
        inbound packets at the NETWORK layer.
    - Filter fields inbound/outbound are now supported at the SOCKET layer.
    - Fix BSOD caused by packets with missing or incomplete transport
      headers (introduced in 2.0.0).
    - Fix missing Flow.EndpointId and Flow.ParentEndpointId for IPv6 flows.
WinDivert 2.2.0
    - Implement new packet parser that correctly handles IP fragments.
    - Add a new "fragment" filter field that matches IP fragments.
    - (Un)Loading the WinDivert driver will cause a system event to be logged.

```

`LICENSE`:

```
WinDivert is dual-licensed under your choice of the GNU Lesser General Public
License (LGPL) Version 3 or the GNU General Public License (GPL) Version 2.
Copies of the LGPLv3, GPLv3 and GPLv2 are provided below.

==============================================================================

                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

==============================================================================

                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

==============================================================================

                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.


```

`README`:

```
WinDivert 2.2: Windows Packet Divert
====================================

1. Introduction
---------------

Windows Packet Divert (WinDivert) is a user-mode packet interception library
for Windows 7, Windows 8 and Windows 10.

WinDivert enables user-mode capturing/modifying/dropping of network packets
sent to/from the Windows network stack.  In summary, WinDivert can:
    - capture network packets
    - filter/drop network packets
    - sniff network packets
    - (re)inject network packets
    - modify network packets
WinDivert can be used to implement user-mode packet filters, sniffers,
firewalls, NATs, VPNs, IDSs, tunneling applications, etc..

WinDivert supports the following features:
    - packet interception, sniffing, or dropping modes
    - support for loopback (localhost) traffic
    - full IPv6 support
    - network layer
    - simple yet powerful API
    - high-level filtering language
    - filter priorities
    - freely available under the terms of the GNU Lesser General Public
      License (LGPLv3)

For more information see doc/windivert.html

2. Architecture
---------------

The basic architecture of WinDivert is as follows:

                              +-----------------+
                              |                 |
                     +------->|    PROGRAM      |--------+
                     |        | (WinDivert.dll) |        |
                     |        +-----------------+        |
                     |                                   | (3) re-injected
                     | (2a) matching packet              |     packet
                     |                                   |
                     |                                   |
 [user mode]         |                                   |
 ....................|...................................|...................
 [kernel mode]       |                                   |
                     |                                   |
                     |                                   |
              +---------------+                          +----------------->
  (1) packet  |               | (2b) non-matching packet
 ------------>| WinDivert.sys |-------------------------------------------->
              |               |
              +---------------+

The WinDivert.sys driver is installed below the Windows network stack.  The
following actions occur:

(1) A new packet enters the network stack and is intercepted by WinDivert.sys
(2a) If the packet matches the PROGRAM-defined filter, it is diverted.  The
    PROGRAM can then read the packet using a call to WinDivertRecv().
(2b) If the packet does not match the filter, the packet continues as normal.
(3) PROGRAM either drops, modifies, or re-injects the packet.  PROGRAM can
    re-inject the (modified) using a call to WinDivertSend().

3. License
----------

WinDivert is dual-licensed under your choice of the GNU Lesser General Public
License (LGPL) Version 3 or the GNU General Public License (GPL) Version 2.
See the LICENSE file for more information.

4. About
--------

WinDivert was written by basil.

For further information, or bug reports, please contact:

    basil@reqrypt.org

The homepage for WinDivert is:

    https://reqrypt.org/windivert.html

The source code for WinDivert is hosted by GitHub at:

    https://github.com/basil00/Divert


```

`VERSION`:

```
2.2.0

```

`dirs`:

```
DIRS= \
     sys

```

`dll/windivert.c`:

```c
/*
 * windivert.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#ifndef UNICODE
#define UNICODE
#endif

#include <winsock2.h>
#include <windows.h>
#include <winioctl.h>

#include <stdio.h>
#include <stdlib.h>

#ifndef WINDIVERTEXPORT
#define WINDIVERTEXPORT extern
#endif
#include "windivert.h"
#include "windivert_device.h"

#define WINDIVERT_DRIVER_NAME           L"WinDivert"
#define WINDIVERT_DRIVER32_SYS          L"\\" WINDIVERT_DRIVER_NAME L"32.sys"
#define WINDIVERT_DRIVER64_SYS          L"\\" WINDIVERT_DRIVER_NAME L"64.sys"
#define WINDIVERT_VERSION_MAJOR_MIN     2

#ifndef ERROR_DRIVER_FAILED_PRIOR_UNLOAD
#define ERROR_DRIVER_FAILED_PRIOR_UNLOAD    ((DWORD)654)
#endif

static BOOLEAN WinDivertIsDigit(char c);
static BOOLEAN WinDivertIsXDigit(char c);
static BOOLEAN WinDivertIsSpace(char c);
static BOOLEAN WinDivertIsAlNum(char c);
static char WinDivertToLower(char c);
static BOOLEAN WinDivertStrLen(const wchar_t *s, size_t maxlen,
    size_t *lenptr);
static BOOLEAN WinDivertStrCpy(wchar_t *dst, size_t dstlen,
    const wchar_t *src);
static int WinDivertStrCmp(const char *s, const char *t);
static BOOLEAN WinDivertAToI(const char *str, char **endptr, UINT32 *intptr,
    UINT size);
static BOOLEAN WinDivertAToX(const char *str, char **endptr, UINT32 *intptr,
    UINT size, BOOL prefix);
static UINT32 WinDivertDivTen128(UINT32 *a);

/*
 * Misc.
 */
#ifndef UINT8_MAX
#define UINT8_MAX       0xFF
#endif
#ifndef UINT16_MAX
#define UINT16_MAX      0xFFFF
#endif
#ifndef UINT32_MAX
#define UINT32_MAX      0xFFFFFFFF
#endif

#define IPPROTO_MH      135

#ifdef _MSC_VER

#pragma intrinsic(memcpy)
#pragma function(memcpy)
void *memcpy(void *dst, const void *src, size_t n)
{
    size_t i;
    for (i = 0; i < n; i++)
        ((UINT8 *)dst)[i] = ((const UINT8 *)src)[i];
    return dst;
}

#pragma intrinsic(memset)
#pragma function(memset)
void *memset(void *dst, int c, size_t n)
{
    size_t i;
    for (i = 0; i < n; i++)
        ((UINT8 *)dst)[i] = (UINT8)c;
    return dst;
}

#define WINDIVERT_INLINE    __forceinline

#else       /* _MSC_VER */

#define WINDIVERT_INLINE    __attribute__((__always_inline__)) inline

#endif      /* _MSC_VER */

/*
 * Filter interpreter config.
 */
static BOOL WinDivertGetData(const VOID *packet, UINT packet_len, INT min,
    INT max, INT idx, PVOID data, UINT size);
#define WINDIVERT_GET_DATA(packet, packet_len, min, max, index, data, size) \
    WinDivertGetData((packet), (packet_len), (min), (max), (index), (data), \
        (size))

/*
 * Prototypes.
 */
static BOOLEAN WinDivertUse32Bit(void);
static BOOLEAN WinDivertGetDriverFileName(LPWSTR sys_str);
static BOOLEAN WinDivertDriverInstall(VOID);

/*
 * Include the helper API implementation.
 */
#include "windivert_shared.c"
#include "windivert_helper.c"

/*
 * Thread local.
 */
static DWORD windivert_tls_idx;

/*
 * Current DLL hmodule.
 */
static HMODULE module = NULL;

/*
 * Dll Entry
 */
BOOL APIENTRY WinDivertDllEntry(HANDLE module0, DWORD reason, LPVOID reserved)
{
    HANDLE event;
    switch (reason)
    {
        case DLL_PROCESS_ATTACH:
            module = module0;
            if ((windivert_tls_idx = TlsAlloc()) == TLS_OUT_OF_INDEXES)
            {
                return FALSE;
            }
            // Fallthrough
        case DLL_THREAD_ATTACH:
            event = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (event == NULL)
            {
                return FALSE;
            }
            TlsSetValue(windivert_tls_idx, (LPVOID)event);
            break;

        case DLL_PROCESS_DETACH:
            event = (HANDLE)TlsGetValue(windivert_tls_idx);
            if (event != (HANDLE)NULL)
            {
                CloseHandle(event);
            }
            TlsFree(windivert_tls_idx);
            break;

        case DLL_THREAD_DETACH:
            event = (HANDLE)TlsGetValue(windivert_tls_idx);
            if (event != (HANDLE)NULL)
            {
                CloseHandle(event);
            }
            break;
    }
    return TRUE;
}

/*
 * Test if we should use the 32-bit or 64-bit driver.
 */
static BOOLEAN WinDivertUse32Bit(void)
{
    BOOL is_wow64;

    if (sizeof(void *) == sizeof(UINT64))
    {
        return FALSE;
    }
    if (!IsWow64Process(GetCurrentProcess(), &is_wow64))
    {
        // Just guess:
        return FALSE;
    }
    return (is_wow64? FALSE: TRUE);
}

/*
 * Locate the WinDivert driver files.
 */
static BOOLEAN WinDivertGetDriverFileName(LPWSTR sys_str)
{
    size_t dir_len, sys_len;
    BOOLEAN is_32bit;

    is_32bit = WinDivertUse32Bit();

    if (is_32bit)
    {
        if (!WinDivertStrLen(WINDIVERT_DRIVER32_SYS, MAX_PATH, &sys_len))
        {
            SetLastError(ERROR_BAD_PATHNAME);
            return FALSE;
        }
    }
    else
    {
        if (!WinDivertStrLen(WINDIVERT_DRIVER64_SYS, MAX_PATH, &sys_len))
        {
            SetLastError(ERROR_BAD_PATHNAME);
            return FALSE;
        }
    }

    dir_len = (size_t)GetModuleFileName(module, sys_str, MAX_PATH);
    if (dir_len == 0)
    {
        return FALSE;
    }
    for (; dir_len > 0 && sys_str[dir_len] != L'\\'; dir_len--)
        ;
    if (sys_str[dir_len] != L'\\' || dir_len + sys_len + 1 >= MAX_PATH)
    {
        SetLastError(ERROR_BAD_PATHNAME);
        return FALSE;
    }
    if (!WinDivertStrCpy(sys_str + dir_len, MAX_PATH-dir_len-1,
            (is_32bit? WINDIVERT_DRIVER32_SYS: WINDIVERT_DRIVER64_SYS)))
    {
        SetLastError(ERROR_BAD_PATHNAME);
        return FALSE;
    }

    return TRUE;
}

/*
 * Register event log.  It is not an error if this function fails.
 */
static void WinDivertRegisterEventSource(const wchar_t *windivert_sys)
{
    HKEY key;
    size_t len;
    DWORD types = 7;

    if (!WinDivertStrLen(windivert_sys, MAX_PATH, &len))
    {
        return;
    }
    if (RegCreateKeyExA(HKEY_LOCAL_MACHINE,
            "System\\CurrentControlSet\\Services\\EventLog\\System\\WinDivert",
            0, NULL, REG_OPTION_VOLATILE, KEY_SET_VALUE, NULL, &key, NULL)
                != ERROR_SUCCESS)
    {
        return;
    }
    RegSetValueExW(key, L"EventMessageFile", 0, REG_SZ, (LPBYTE)windivert_sys,
            (len + 1) * sizeof(wchar_t));
    RegSetValueExA(key, "TypesSupported", 0, REG_DWORD, (LPBYTE)&types,
            sizeof(types));
    RegCloseKey(key);
}

/*
 * Install the WinDivert driver.
 */
static BOOLEAN WinDivertDriverInstall(VOID)
{
    DWORD err;
    SC_HANDLE manager = NULL, service = NULL;
    wchar_t windivert_sys[MAX_PATH+1];
    HANDLE mutex = NULL;
    BOOL success = TRUE;

    // Create & lock a named mutex.  This is to stop two processes trying
    // to start the driver at the same time.
    mutex = CreateMutex(NULL, FALSE, L"WinDivertDriverInstallMutex");
    if (mutex == NULL)
    {
        return FALSE;
    }
    switch (WaitForSingleObject(mutex, INFINITE))
    {
        case WAIT_OBJECT_0: case WAIT_ABANDONED:
            break;
        default:
            return FALSE;
    }

    // Open the service manager:
    manager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (manager == NULL)
    {
        goto WinDivertDriverInstallExit;
    }

    // Check if the WinDivert service already exists; if so, start it.
    service = OpenService(manager, WINDIVERT_DEVICE_NAME, SERVICE_ALL_ACCESS);
    if (service != NULL)
    {
        goto WinDivertDriverInstallExit;
    }

    // Get driver file:
    if (!WinDivertGetDriverFileName(windivert_sys))
    {
        goto WinDivertDriverInstallExit;
    }

    // Create the service:
    service = CreateService(manager, WINDIVERT_DEVICE_NAME,
        WINDIVERT_DEVICE_NAME, SERVICE_ALL_ACCESS, SERVICE_KERNEL_DRIVER,
        SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, windivert_sys, NULL, NULL,
        NULL, NULL, NULL);
    if (service == NULL)
    {
        if (GetLastError() == ERROR_SERVICE_EXISTS) 
        {
            service = OpenService(manager, WINDIVERT_DEVICE_NAME,
                SERVICE_ALL_ACCESS);
        }
        goto WinDivertDriverInstallExit;
    }

    // Register event logging:
    WinDivertRegisterEventSource(windivert_sys);

WinDivertDriverInstallExit:

    success = (service != NULL);
    if (service != NULL)
    {
        // Start the service:
        success = StartService(service, 0, NULL);
        if (!success)
        {
            success = (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING);
        }
        else
        {
            // Mark the service for deletion.  This will cause the driver to
            // unload if (1) there are no more open handles, and (2) the
            // service is STOPPED or on system reboot.
            (VOID)DeleteService(service);
        }
    }

    err = GetLastError();
    if (manager != NULL)
    {
        CloseServiceHandle(manager);
    }
    if (service != NULL)
    {
        CloseServiceHandle(service);
    }
    ReleaseMutex(mutex);
    CloseHandle(mutex);
    SetLastError(err);

    return success;
}

/*
 * Perform an (overlapped) DeviceIoControl.
 */
static BOOL WinDivertIoControlEx(HANDLE handle, DWORD code,
    PWINDIVERT_IOCTL ioctl, PVOID buf, UINT len, UINT *iolen,
    LPOVERLAPPED overlapped)
{
    BOOL result;
    DWORD iolen0;

    result = DeviceIoControl(handle, code, ioctl, sizeof(WINDIVERT_IOCTL), buf,
        (DWORD)len, &iolen0, overlapped);
    if (result && iolen != NULL)
    {
        *iolen = (UINT)iolen0;
    }
    return result;
}

/*
 * Perform a DeviceIoControl.
 */
static BOOL WinDivertIoControl(HANDLE handle, DWORD code,
    PWINDIVERT_IOCTL ioctl, PVOID buf, UINT len, UINT *iolen)
{
    OVERLAPPED overlapped;
    DWORD iolen0;
    HANDLE event;

    event = (HANDLE)TlsGetValue(windivert_tls_idx);
    if (event == (HANDLE)NULL)
    {
        event = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (event == NULL)
        {
            return FALSE;
        }
        TlsSetValue(windivert_tls_idx, (LPVOID)event);
    }

    memset(&overlapped, 0, sizeof(overlapped));
    overlapped.hEvent = event;
    if (!WinDivertIoControlEx(handle, code, ioctl, buf, len, iolen,
            &overlapped))
    {
        if (GetLastError() != ERROR_IO_PENDING ||
            !GetOverlappedResult(handle, &overlapped, &iolen0, TRUE))
        {
            return FALSE;
        }
        if (iolen != NULL)
        {
            *iolen = (UINT)iolen0;
        }
    }
    return TRUE;
}

/*
 * Open a WinDivert handle.
 */
HANDLE WinDivertOpen(const char *filter, WINDIVERT_LAYER layer, INT16 priority,
    UINT64 flags)
{
    WINDIVERT_FILTER *object;
    UINT obj_len;
    ERROR comp_err;
    DWORD err;
    HANDLE handle, pool;
    UINT64 filter_flags;
    WINDIVERT_IOCTL ioctl;
    WINDIVERT_VERSION version;

    // Static checks (should be compiled away if TRUE):
    if (sizeof(WINDIVERT_ADDRESS) != 80 ||
        sizeof(WINDIVERT_DATA_NETWORK) != 8 ||
        offsetof(WINDIVERT_DATA_FLOW, Protocol) != 56 ||
        offsetof(WINDIVERT_DATA_SOCKET, Protocol) != 56 ||
        offsetof(WINDIVERT_DATA_REFLECT, Priority) != 24 ||
        sizeof(WINDIVERT_FILTER) != 24 ||
        offsetof(WINDIVERT_ADDRESS, Reserved3) != 16)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    // Parameter checking:
    switch (layer)
    {
        case WINDIVERT_LAYER_NETWORK:
        case WINDIVERT_LAYER_NETWORK_FORWARD:
        case WINDIVERT_LAYER_FLOW:
        case WINDIVERT_LAYER_SOCKET:
        case WINDIVERT_LAYER_REFLECT:
            break;
        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
    }
    if (!WINDIVERT_FLAGS_VALID(flags))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if (priority < WINDIVERT_PRIORITY_MIN ||
        priority > WINDIVERT_PRIORITY_MAX)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    // Compile & analyze the filter:
    pool = HeapCreate(HEAP_NO_SERIALIZE, WINDIVERT_MIN_POOL_SIZE,
        WINDIVERT_MAX_POOL_SIZE);
    if (pool == NULL)
    {
        return FALSE;
    }
    object = HeapAlloc(pool, 0,
        WINDIVERT_FILTER_MAXLEN * sizeof(WINDIVERT_FILTER));
    if (object == NULL)
    {
        err = GetLastError();
        HeapDestroy(pool);
        SetLastError(err);
        return FALSE;
    }
    comp_err = WinDivertCompileFilter(filter, pool, layer, object, &obj_len);
    if (IS_ERROR(comp_err))
    {
        HeapDestroy(pool);
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }
    filter_flags = WinDivertAnalyzeFilter(layer, object, obj_len);

    // Attempt to open the WinDivert device:
    handle = CreateFile(L"\\\\.\\" WINDIVERT_DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, INVALID_HANDLE_VALUE);
    if (handle == INVALID_HANDLE_VALUE)
    {
        err = GetLastError();
        if (err != ERROR_FILE_NOT_FOUND && err != ERROR_PATH_NOT_FOUND)
        {
            HeapDestroy(pool);
            SetLastError(err);
            return INVALID_HANDLE_VALUE;
        }

        // Open failed because the device isn't installed; install it now.
        if ((flags & WINDIVERT_FLAG_NO_INSTALL) != 0)
        {
            HeapDestroy(pool);
            SetLastError(ERROR_SERVICE_DOES_NOT_EXIST);
            return INVALID_HANDLE_VALUE;
        }
        SetLastError(0);
        if (!WinDivertDriverInstall())
        {
            err = GetLastError();
            err = (err == 0? ERROR_OPEN_FAILED: err);
            HeapDestroy(pool);
            SetLastError(err);
            return INVALID_HANDLE_VALUE;
        }
        handle = CreateFile(L"\\\\.\\" WINDIVERT_DEVICE_NAME,
            GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            INVALID_HANDLE_VALUE);
        if (handle == INVALID_HANDLE_VALUE)
        {
            err = GetLastError();
            HeapDestroy(pool);
            SetLastError(err);
            return INVALID_HANDLE_VALUE;
        }
    }

    // Initialize the handle:
    memset(&ioctl, 0, sizeof(ioctl));
    ioctl.initialize.layer    = layer;
    ioctl.initialize.priority = (INT32)priority + WINDIVERT_PRIORITY_MAX;
    ioctl.initialize.flags    = flags;
    memset(&version, 0, sizeof(version));
    version.magic             = WINDIVERT_MAGIC_DLL;
    version.major             = WINDIVERT_VERSION_MAJOR;
    version.minor             = WINDIVERT_VERSION_MINOR;
    version.bits              = 8 * sizeof(void *);
    if (!WinDivertIoControl(handle, IOCTL_WINDIVERT_INITIALIZE, &ioctl,
            &version, sizeof(version), NULL))
    {
        err = GetLastError();
        CloseHandle(handle);
        HeapDestroy(pool);
        SetLastError(err);
        return INVALID_HANDLE_VALUE;
    }
    if (version.magic != WINDIVERT_MAGIC_SYS ||
        version.major < WINDIVERT_VERSION_MAJOR_MIN)
    {
        CloseHandle(handle);
        HeapDestroy(pool);
        SetLastError(ERROR_DRIVER_FAILED_PRIOR_UNLOAD);
        return INVALID_HANDLE_VALUE;
    }

    // Start the filter:
    memset(&ioctl, 0, sizeof(ioctl));
    ioctl.startup.flags = filter_flags;
    if (!WinDivertIoControl(handle, IOCTL_WINDIVERT_STARTUP, &ioctl,
            object, obj_len * sizeof(WINDIVERT_FILTER), NULL))
    {
        err = GetLastError();
        CloseHandle(handle);
        HeapDestroy(pool);
        SetLastError(err);
        return INVALID_HANDLE_VALUE;
    }
    HeapDestroy(pool);

    // Success!
    return handle;
}

/*
 * Receive a WinDivert packet.
 */
BOOL WinDivertRecv(HANDLE handle, PVOID pPacket, UINT packetLen, UINT *readLen,
    PWINDIVERT_ADDRESS addr)
{
    WINDIVERT_IOCTL ioctl;
    memset(&ioctl, 0, sizeof(ioctl));
    ioctl.recv.addr = (UINT64)(ULONG_PTR)addr;
    ioctl.recv.addr_len_ptr = (UINT64)(ULONG_PTR)NULL;
    return WinDivertIoControl(handle, IOCTL_WINDIVERT_RECV, &ioctl,
        pPacket, packetLen, readLen);
}

/*
 * Receive a WinDivert packet.
 */
BOOL WinDivertRecvEx(HANDLE handle, PVOID pPacket, UINT packetLen,
    UINT *readLen, UINT64 flags, PWINDIVERT_ADDRESS addr, UINT *pAddrLen,
    LPOVERLAPPED overlapped)
{
    WINDIVERT_IOCTL ioctl;
    memset(&ioctl, 0, sizeof(ioctl));
    ioctl.recv.addr = (UINT64)(ULONG_PTR)addr;
    ioctl.recv.addr_len_ptr = (UINT64)(ULONG_PTR)pAddrLen;
    if (flags != 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (overlapped == NULL)
    {
        return WinDivertIoControl(handle, IOCTL_WINDIVERT_RECV, &ioctl,
            pPacket, packetLen, readLen);
    }
    else
    {
        return WinDivertIoControlEx(handle, IOCTL_WINDIVERT_RECV, &ioctl,
            pPacket, packetLen, readLen, overlapped);
    }
}

/*
 * Send a WinDivert packet.
 */
BOOL WinDivertSend(HANDLE handle, const VOID *pPacket, UINT packetLen,
    UINT *writeLen, const WINDIVERT_ADDRESS *addr)
{
    WINDIVERT_IOCTL ioctl;
    memset(&ioctl, 0, sizeof(ioctl));
    ioctl.send.addr = (UINT64)(ULONG_PTR)addr;
    ioctl.send.addr_len = sizeof(WINDIVERT_ADDRESS);
    return WinDivertIoControl(handle, IOCTL_WINDIVERT_SEND, &ioctl,
        (PVOID)pPacket, packetLen, writeLen);
}

/*
 * Send a WinDivert packet.
 */
BOOL WinDivertSendEx(HANDLE handle, const VOID *pPacket, UINT packetLen,
    UINT *writeLen, UINT64 flags, const WINDIVERT_ADDRESS *addr, UINT addrLen,
    LPOVERLAPPED overlapped)
{
    WINDIVERT_IOCTL ioctl;
    memset(&ioctl, 0, sizeof(ioctl));
    ioctl.send.addr = (UINT64)(ULONG_PTR)addr;
    ioctl.send.addr_len = addrLen;
    if (flags != 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (overlapped == NULL)
    {
        return WinDivertIoControl(handle, IOCTL_WINDIVERT_SEND, &ioctl,
            (PVOID)pPacket, packetLen, writeLen);
    }
    else
    {
        return WinDivertIoControlEx(handle, IOCTL_WINDIVERT_SEND, &ioctl,
            (PVOID)pPacket, packetLen, writeLen, overlapped);
    }
}

/*
 * Shutdown a WinDivert handle.
 */
BOOL WinDivertShutdown(HANDLE handle, WINDIVERT_SHUTDOWN how)
{
    WINDIVERT_IOCTL ioctl;
    memset(&ioctl, 0, sizeof(ioctl));
    ioctl.shutdown.how = (UINT32)how;
    return WinDivertIoControl(handle, IOCTL_WINDIVERT_SHUTDOWN, &ioctl, NULL,
        0, NULL);
}

/*
 * Close a WinDivert handle.
 */
BOOL WinDivertClose(HANDLE handle)
{
    return CloseHandle(handle);
}

/*
 * Set a WinDivert parameter.
 */
BOOL WinDivertSetParam(HANDLE handle, WINDIVERT_PARAM param, UINT64 value)
{
    WINDIVERT_IOCTL ioctl;
    memset(&ioctl, 0, sizeof(ioctl));
    ioctl.set_param.param = (UINT32)param;
    ioctl.set_param.val   = value;
    return WinDivertIoControl(handle, IOCTL_WINDIVERT_SET_PARAM, &ioctl, NULL,
        0, NULL);
}

/*
 * Get a WinDivert parameter.
 */
BOOL WinDivertGetParam(HANDLE handle, WINDIVERT_PARAM param, UINT64 *pValue)
{
    WINDIVERT_IOCTL ioctl;
    memset(&ioctl, 0, sizeof(ioctl));
    ioctl.get_param.param = (UINT32)param;
    return WinDivertIoControl(handle, IOCTL_WINDIVERT_GET_PARAM, &ioctl,
        pValue, sizeof(UINT64), NULL);
}

/*****************************************************************************/
/* REPLACEMENTS                                                              */
/*****************************************************************************/

static BOOLEAN WinDivertIsDigit(char c)
{
    return (c >= '0' && c <= '9');
}

static BOOLEAN WinDivertIsXDigit(char c)
{
    return (c >= '0' && c <= '9') ||
           (c >= 'a' && c <= 'f') ||
           (c >= 'A' && c <= 'F');
}

static BOOLEAN WinDivertIsSpace(char c)
{
    return (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f' ||
            c == '\v');
}

static BOOLEAN WinDivertIsAlNum(char c)
{
    return (c >= 'a' && c <= 'z') ||
           (c >= 'A' && c <= 'Z') ||
           (c >= '0' && c <= '9');
}

static char WinDivertToLower(char c)
{
    if (c >= 'A' && c <= 'Z')
        return 'a' + (c - 'A');
    return c;
}

static BOOLEAN WinDivertStrLen(const wchar_t *s, size_t maxlen,
    size_t *lenptr)
{
    size_t i;
    for (i = 0; s[i]; i++)
    {
        if (i > maxlen)
        {
            return FALSE;
        }
    }
    *lenptr = i;
    return TRUE;
}

static BOOLEAN WinDivertStrCpy(wchar_t *dst, size_t dstlen, const wchar_t *src)
{
    size_t i;
    for (i = 0; src[i]; i++)
    {
        if (i > dstlen)
        {
            return FALSE;
        }
        dst[i] = src[i];
    }
    if (i > dstlen)
    {
        return FALSE;
    }
    dst[i] = src[i];
    return TRUE;
}

static int WinDivertStrCmp(const char *s, const char *t)
{
    int cmp;
    size_t i;
    for (i = 0; ; i++)
    {
        cmp = s[i] - t[i];
        if (cmp != 0)
        {
            return cmp;
        }
        if (s[i] == '\0')
        {
            return 0;
        }
    }
}

static BOOLEAN WinDivertMul128(UINT32 *n, UINT32 m)
{
    UINT64 n64 = (UINT64)n[0] * (UINT64)m;
    n[0] = (UINT32)n64;
    n64 = (UINT64)n[1] * (UINT64)m + (n64 >> 32);
    n[1] = (UINT32)n64;
    n64 = (UINT64)n[2] * (UINT64)m + (n64 >> 32);
    n[2] = (UINT32)n64;
    n64 = (UINT64)n[3] * (UINT64)m + (n64 >> 32);
    n[3] = (UINT32)n64;
    return ((n64 >> 32) == 0);
}

static BOOLEAN WinDivertAdd128(UINT32 *n, UINT32 a)
{
    UINT64 n64 = (UINT64)n[0] + (UINT64)a;
    n[0] = (UINT32)n64;
    n64 = (UINT64)n[1] + (n64 >> 32);
    n[1] = (UINT32)n64;
    n64 = (UINT64)n[2] + (n64 >> 32);
    n[2] = (UINT32)n64;
    n64 = (UINT64)n[3] + (n64 >> 32);
    n[3] = (UINT32)n64;
    return ((n64 >> 32) == 0);
}

static BOOLEAN WinDivertAToI(const char *str, char **endptr, UINT32 *intptr,
    UINT size)
{
    size_t i = 0;
    UINT32 n[4] = {0};
    BOOLEAN result = TRUE;
    for (; str[i] && WinDivertIsDigit(str[i]); i++)
    {
        if (!WinDivertMul128(n, 10) || !WinDivertAdd128(n, str[i] - '0'))
        {
            return FALSE;
        }
    }
    if (i == 0)
    {
        return FALSE;
    }
    if (endptr != NULL)
    {
        *endptr = (char *)str + i;
    }
    for (i = 0; i < size; i++)
    {
        intptr[i] = n[i];
    }
    for (; result && i < size && i < 4; i++)
    {
        result = result && (n[i] == 0);
    }
    return result;
}

static BOOLEAN WinDivertAToX(const char *str, char **endptr, UINT32 *intptr,
    UINT size, BOOL prefix)
{
    size_t i = 0;
    UINT32 n[4] = {0}, dig;
    BOOLEAN result = TRUE;
    if (prefix)
    {
        if (str[i] == '0' && str[i+1] == 'x')
        {
            i += 2;
        }
        else
        {
            return FALSE;
        }
    }
    for (; str[i] && WinDivertIsXDigit(str[i]); i++)
    {
        if (WinDivertIsDigit(str[i]))
        {
            dig = (UINT32)(str[i] - '0');
        }
        else
        {
            dig = (UINT32)(WinDivertToLower(str[i]) - 'a') + 0x0A;
        }
        if (!WinDivertMul128(n, 16) || !WinDivertAdd128(n, dig))
        {
            return FALSE;
        }
    }
    if (i == 0)
    {
        return FALSE;
    }
    if (endptr != NULL)
    {
        *endptr = (char *)str + i;
    }
    for (i = 0; i < size; i++)
    {
        intptr[i] = n[i];
    }
    for (; result && i < size && i < 4; i++)
    {
        result = result && (n[i] == 0);
    }
    return result;
}

/*
 * Divide by 10 and return the remainder.
 */
#define WINDIVERT_BIG_MUL_ROUND(a, c, r, i)                                 \
    do {                                                                    \
        UINT64 t = WINDIVERT_MUL64((UINT64)(a), (UINT64)(c));               \
        UINT k;                                                             \
        for (k = (i); k < 9 && t != 0; k++)                                 \
        {                                                                   \
            UINT64 s = (UINT64)(r)[k] + (t & 0xFFFFFFFF);                   \
            (r)[k] = (UINT32)s;                                             \
            t = (t >> 32) + (s >> 32);                                      \
        }                                                                   \
    } while (FALSE)
static UINT32 WinDivertDivTen128(UINT32 *a)
{
    const UINT32 c[5] =
    {
        0x9999999A, 0x99999999, 0x99999999, 0x99999999, 0x19999999
    };
    UINT32 r[9] = {0}, m[6] = {0};
    UINT i, j;

    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 5; j++)
        {
            WINDIVERT_BIG_MUL_ROUND(a[i], c[j], r, i+j);
        }
    }

    a[0] = r[5];
    a[1] = r[6];
    a[2] = r[7];
    a[3] = r[8];
    
    for (i = 0; i < 5; i++)
    {
        WINDIVERT_BIG_MUL_ROUND(r[i], 10, m, i);
    }
    
    return m[5];
}


```

`dll/windivert.def`:

```def
LIBRARY WinDivert
EXPORTS
    WinDivertOpen
    WinDivertRecv
    WinDivertRecvEx
    WinDivertSend
    WinDivertSendEx
    WinDivertShutdown
    WinDivertClose
    WinDivertSetParam
    WinDivertGetParam
    WinDivertHelperCalcChecksums
    WinDivertHelperDecrementTTL
    WinDivertHelperHashPacket
    WinDivertHelperParsePacket
    WinDivertHelperParseIPv4Address
    WinDivertHelperParseIPv6Address
    WinDivertHelperFormatIPv4Address
    WinDivertHelperFormatIPv6Address
    WinDivertHelperCompileFilter
    WinDivertHelperEvalFilter
    WinDivertHelperFormatFilter
    WinDivertHelperNtohs
    WinDivertHelperHtons
    WinDivertHelperNtohl
    WinDivertHelperHtonl
    WinDivertHelperNtohll
    WinDivertHelperHtonll
    WinDivertHelperNtohIPv6Address
    WinDivertHelperHtonIPv6Address
    WinDivertHelperNtohIpv6Address
    WinDivertHelperHtonIpv6Address

```

`dll/windivert.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<!--

    windivert.vcxproj
    (C) 2019, all rights reserved,
    
    This file is part of WinDivert.
    
    WinDivert is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    WinDivert is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc., 51
    Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
    
-->
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 <ItemGroup Label="ProjectConfigurations">
  <ProjectConfiguration Include="Release|Win32">
   <Configuration>Release</Configuration>
   <Platform>Win32</Platform>
  </ProjectConfiguration>
  <ProjectConfiguration Include="Release|x64">
   <Configuration>Release</Configuration>
   <Platform>x64</Platform>
  </ProjectConfiguration>
 </ItemGroup>
 <ItemGroup>
  <ClCompile Include="windivert.c">
   <TreatWarningAsError>false</TreatWarningAsError>
   <Optimization>MinSpace</Optimization>
   <IntrinsicFunctions>true</IntrinsicFunctions>
   <BasicRuntimeChecks>Default</BasicRuntimeChecks>
   <BufferSecurityCheck>false</BufferSecurityCheck>
   <AdditionalIncludeDirectories>..\include</AdditionalIncludeDirectories>
  </ClCompile>
 </ItemGroup>
 <PropertyGroup Label="Globals">
  <RootNamespace>WinDivert</RootNamespace>
  <ProjectName>WinDivert</ProjectName>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props"/>
 <PropertyGroup Label="Configuration">
  <PlatformToolset>v140</PlatformToolset>
  <UseDebugLibraries>true</UseDebugLibraries>
  <ConfigurationType>DynamicLibrary</ConfigurationType>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
 <ItemDefinitionGroup>
  <ClCompile>
   <WppEnabled>false</WppEnabled>
   <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">WIN32;NDEBUG;_WINDOWS;_USRDLL;DLL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
   <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">WIN32;NDEBUG;_WINDOWS;_USRDLL;DLL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
  </ClCompile>
  <Link>
   <EntryPointSymbol>WinDivertDllEntry</EntryPointSymbol>
   <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
   <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
   <ModuleDefinitionFile>windivert.def</ModuleDefinitionFile>
   <ImportLibrary>WinDivert.lib</ImportLibrary>
  </Link>
 </ItemDefinitionGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>

```

`dll/windivert_hash.c`:

```c
/*
 * windivert_hash.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 * xxHash - Fast Hash algorithm
 * Copyright (C) 2012-2016, Yann Collet
 *
 * BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

/*
 * This is a modified version of the 64bit xxHash algorithm:
 * - The algorithm is seeded with packet data rather than the single 64bit
 *   "seed" value.
 * - The input sized is fixed to 32bytes (excluding the seed), so there is
 *   only ever a single round.  As such, the algorithm has been specialized.
 */

#define WINDIVERT_ROTL64(x, r)  (((x) << (r)) | ((x) >> (64 - (r))))

static const UINT64 WINDIVERT_PRIME64_1 = 11400714785074694791ull;
static const UINT64 WINDIVERT_PRIME64_2 = 14029467366897019727ull;
static const UINT64 WINDIVERT_PRIME64_3 = 1609587929392839161ull;
static const UINT64 WINDIVERT_PRIME64_4 = 9650029242287828579ull;

static UINT64 WinDivertXXH64Round(UINT64 acc, UINT64 input)
{
    acc += WINDIVERT_MUL64(input, WINDIVERT_PRIME64_2);
    acc  = WINDIVERT_ROTL64(acc, 31);
    acc  = WINDIVERT_MUL64(acc, WINDIVERT_PRIME64_1);
    return acc;
}

static UINT64 WinDivertXXH64MergeRound(UINT64 acc, UINT64 val)
{
    val  = WinDivertXXH64Round(0, val);
    acc ^= val;
    acc  = WINDIVERT_MUL64(acc, WINDIVERT_PRIME64_1) + WINDIVERT_PRIME64_4;
    return acc;
}

static UINT64 WinDivertXXH64Avalanche(UINT64 h64)
{
    h64 ^= h64 >> 33;
    h64  = WINDIVERT_MUL64(h64, WINDIVERT_PRIME64_2);
    h64 ^= h64 >> 29;
    h64  = WINDIVERT_MUL64(h64, WINDIVERT_PRIME64_3);
    h64 ^= h64 >> 32;
    return h64;
}

/*
 * WinDivert packet hash function.
 */
static UINT64 WinDivertHashPacket(UINT64 seed,
    const WINDIVERT_IPHDR *ip_header, const WINDIVERT_IPV6HDR *ipv6_header,
    const WINDIVERT_ICMPHDR *icmp_header,
    const WINDIVERT_ICMPV6HDR *icmpv6_header,
    const WINDIVERT_TCPHDR *tcp_header, const WINDIVERT_UDPHDR *udp_header)
{
    UINT64 h64, v1, v2, v3, v4, v[4];
    const UINT64 *data64;
    const UINT32 *data32;
    UINT i;
    static const UINT64 padding64[] =               // SHA2 IV
    {
        0x428A2F9871374491ull, 0xB5C0FBCFE9B5DBA5ull, 0x3956C25B59F111F1ull,
        0x923F82A4AB1C5ED5ull, 0xD807AA9812835B01ull, 0x243185BE550C7DC3ull,
        0x72BE5D7480DEB1FEull, 0x9BDC06A7C19BF174ull, 0xE49B69C1EFBE4786ull,
    };

    // Set-up seed & data
    v1 = seed ^ padding64[0];
    if (ip_header != NULL)
    {
        data64 = (const UINT64 *)ip_header;
        v2 = data64[0] ^ padding64[1];
        v3 = data64[1] ^ padding64[2];
        data32 = (const UINT32 *)ip_header;
        v4 = (UINT64)data32[4] ^ padding64[3];
        i = 0;
    }
    else if (ipv6_header != NULL)
    {
        data64 = (const UINT64 *)ipv6_header;
        v2 = data64[0] ^ padding64[1];
        v3 = data64[1] ^ padding64[2];
        v4 = data64[2] ^ padding64[3];
        v[0] = data64[3] ^ padding64[4];
        v[1] = data64[4] ^ padding64[5];
        i = 2;
    }
    else
        return 0;

    if (tcp_header != NULL)
    {
        data64 = (const UINT64 *)tcp_header;
        v[i] = data64[0] ^ padding64[i+4]; i++;
        v[i] = data64[1] ^ padding64[i+4]; i++;
        data32 = (const UINT32 *)tcp_header;
        if (i <= 3)
        {
            v[i] = (UINT64)data32[4] ^ padding64[i+4]; i++;
        }
        else
        {
            v2 ^= ((UINT64)data32[4] << 32);
        }
    }
    else
    {
        if (udp_header != NULL)
        {
            data64 = (const UINT64 *)udp_header;
            v[i] = data64[0] ^ padding64[i+4]; i++;
        }
        else if (icmp_header != NULL)
        {
            data64 = (const UINT64 *)icmp_header;
            v[i] = data64[0] ^ padding64[i+4]; i++;
        }
        else if (icmpv6_header != NULL)
        {
            data64 = (const UINT64 *)icmpv6_header;
            v[i] = data64[0] ^ padding64[i+4]; i++;
        }
    }

    while (i <= 3)
    {
        v[i] = seed ^ padding64[i+4]; i++;
    }

    // Hash
    v1 = WinDivertXXH64Round(v[0], v1);
    v2 = WinDivertXXH64Round(v[1], v2);
    v3 = WinDivertXXH64Round(v[2], v3);
    v4 = WinDivertXXH64Round(v[3], v4);
    h64 = WINDIVERT_ROTL64(v1, 1) + WINDIVERT_ROTL64(v2, 7) +
          WINDIVERT_ROTL64(v3, 12) + WINDIVERT_ROTL64(v4, 18);
    h64 = WinDivertXXH64MergeRound(h64, v1);
    h64 = WinDivertXXH64MergeRound(h64, v2);
    h64 = WinDivertXXH64MergeRound(h64, v3);
    h64 = WinDivertXXH64MergeRound(h64, v4); 
    h64 += 32;          // "length"
    h64 = WinDivertXXH64Avalanche(h64);

    return h64;
}


```

`dll/windivert_helper.c`:

```c
/*
 * windivert_helper.c
 * (C) 2021, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/****************************************************************************/
/* WINDIVERT HELPER IMPLEMENTATION                                          */
/****************************************************************************/

/*
 * Protocols.
 */
#define IPPROTO_HOPOPTS     0
#define IPPROTO_ICMP        1
#define IPPROTO_TCP         6
#define IPPROTO_UDP         17
#define IPPROTO_ROUTING     43
#define IPPROTO_FRAGMENT    44
#define IPPROTO_AH          51
#define IPPROTO_ICMPV6      58
#define IPPROTO_NONE        59
#define IPPROTO_DSTOPTS     60

/*
 * Filter tokens.
 */
typedef enum
{
    TOKEN_ICMP,
    TOKEN_ICMP_BODY,
    TOKEN_ICMP_CHECKSUM,
    TOKEN_ICMP_CODE,
    TOKEN_ICMP_TYPE,
    TOKEN_ICMPV6,
    TOKEN_ICMPV6_BODY,
    TOKEN_ICMPV6_CHECKSUM,
    TOKEN_ICMPV6_CODE,
    TOKEN_ICMPV6_TYPE,
    TOKEN_IP,
    TOKEN_IP_CHECKSUM,
    TOKEN_IP_DF,
    TOKEN_IP_DST_ADDR,
    TOKEN_IP_FRAG_OFF,
    TOKEN_IP_HDR_LENGTH,
    TOKEN_IP_ID,
    TOKEN_IP_LENGTH,
    TOKEN_IP_MF,
    TOKEN_IP_PROTOCOL,
    TOKEN_IP_SRC_ADDR,
    TOKEN_IP_TOS,
    TOKEN_IP_TTL,
    TOKEN_IPV6,
    TOKEN_IPV6_DST_ADDR,
    TOKEN_IPV6_FLOW_LABEL,
    TOKEN_IPV6_HOP_LIMIT,
    TOKEN_IPV6_LENGTH,
    TOKEN_IPV6_NEXT_HDR,
    TOKEN_IPV6_SRC_ADDR,
    TOKEN_IPV6_TRAFFIC_CLASS,
    TOKEN_TCP,
    TOKEN_TCP_ACK,
    TOKEN_TCP_ACK_NUM,
    TOKEN_TCP_CHECKSUM,
    TOKEN_TCP_DST_PORT,
    TOKEN_TCP_FIN,
    TOKEN_TCP_HDR_LENGTH,
    TOKEN_TCP_PAYLOAD,
    TOKEN_TCP_PAYLOAD16,
    TOKEN_TCP_PAYLOAD32,
    TOKEN_TCP_PAYLOAD_LENGTH,
    TOKEN_TCP_PSH,
    TOKEN_TCP_RST,
    TOKEN_TCP_SEQ_NUM,
    TOKEN_TCP_SRC_PORT,
    TOKEN_TCP_SYN,
    TOKEN_TCP_URG,
    TOKEN_TCP_URG_PTR,
    TOKEN_TCP_WINDOW,
    TOKEN_UDP,
    TOKEN_UDP_CHECKSUM,
    TOKEN_UDP_DST_PORT,
    TOKEN_UDP_LENGTH,
    TOKEN_UDP_PAYLOAD,
    TOKEN_UDP_PAYLOAD16,
    TOKEN_UDP_PAYLOAD32,
    TOKEN_UDP_PAYLOAD_LENGTH,
    TOKEN_UDP_SRC_PORT,
    TOKEN_ZERO,
    TOKEN_EVENT,
    TOKEN_RANDOM8,
    TOKEN_RANDOM16,
    TOKEN_RANDOM32,
    TOKEN_PACKET,
    TOKEN_PACKET16,
    TOKEN_PACKET32,
    TOKEN_LENGTH,
    TOKEN_TIMESTAMP,
    TOKEN_TRUE,
    TOKEN_FALSE,
    TOKEN_INBOUND,
    TOKEN_OUTBOUND,
    TOKEN_FRAGMENT,
    TOKEN_IF_IDX,
    TOKEN_SUB_IF_IDX,
    TOKEN_LOOPBACK,
    TOKEN_IMPOSTOR,
    TOKEN_PROCESS_ID,
    TOKEN_LOCAL_ADDR,
    TOKEN_REMOTE_ADDR,
    TOKEN_LOCAL_PORT,
    TOKEN_REMOTE_PORT,
    TOKEN_PROTOCOL,
    TOKEN_ENDPOINT_ID,
    TOKEN_PARENT_ENDPOINT_ID,
    TOKEN_LAYER,
    TOKEN_PRIORITY,
    TOKEN_FLOW,
    TOKEN_SOCKET,
    TOKEN_NETWORK,
    TOKEN_NETWORK_FORWARD,
    TOKEN_REFLECT,
    TOKEN_EVENT_PACKET,
    TOKEN_EVENT_ESTABLISHED,
    TOKEN_EVENT_DELETED,
    TOKEN_EVENT_BIND,
    TOKEN_EVENT_CONNECT,
    TOKEN_EVENT_LISTEN,
    TOKEN_EVENT_ACCEPT,
    TOKEN_EVENT_OPEN,
    TOKEN_EVENT_CLOSE,
    TOKEN_MACRO_TRUE,
    TOKEN_MACRO_FALSE,
    TOKEN_MACRO_TCP,
    TOKEN_MACRO_UDP,
    TOKEN_MACRO_ICMP,
    TOKEN_MACRO_ICMPV6,
    TOKEN_OPEN,
    TOKEN_CLOSE,
    TOKEN_SQUARE_OPEN,
    TOKEN_SQUARE_CLOSE,
    TOKEN_MINUS,
    TOKEN_BYTES,
    TOKEN_EQ,
    TOKEN_NEQ,
    TOKEN_LT,
    TOKEN_LEQ,
    TOKEN_GT,
    TOKEN_GEQ,
    TOKEN_NOT,
    TOKEN_AND,
    TOKEN_OR,
    TOKEN_COLON,
    TOKEN_QUESTION,
    TOKEN_NUMBER,
    TOKEN_END,
} KIND;

typedef struct
{
    KIND kind;
    UINT pos;
    UINT32 val[4];
} TOKEN;
#define TOKEN_MAXLEN                            40

typedef struct
{
    char *name;
    KIND kind;
    UINT8 flags;
} TOKEN_INFO, *PTOKEN_INFO;

/*
 * Filter expressions.
 */
typedef struct EXPR EXPR;
typedef struct EXPR *PEXPR;
struct EXPR
{
    union
    {
        UINT32 val[4];
        PEXPR arg[3];
    };
    UINT8 kind;
    UINT8 count;
    BOOLEAN neg;
    UINT16 succ;
    UINT16 fail;
};

/*
 * Error handling.
 */
#undef ERROR
typedef UINT64 ERROR, *PERROR;

#define WINDIVERT_ERROR_NONE                    0
#define WINDIVERT_ERROR_NO_MEMORY               1
#define WINDIVERT_ERROR_TOO_DEEP                2
#define WINDIVERT_ERROR_TOO_LONG                3
#define WINDIVERT_ERROR_BAD_TOKEN               4
#define WINDIVERT_ERROR_BAD_TOKEN_FOR_LAYER     5
#define WINDIVERT_ERROR_UNEXPECTED_TOKEN        6
#define WINDIVERT_ERROR_INDEX_OOB               7
#define WINDIVERT_ERROR_OUTPUT_TOO_SHORT        8
#define WINDIVERT_ERROR_BAD_OBJECT              9
#define WINDIVERT_ERROR_ASSERTION_FAILED        10

#define WINDIVERT_MIN_POOL_SIZE                 12288
#define WINDIVERT_MAX_POOL_SIZE                 131072

#define MAKE_ERROR(code, pos)                   \
    (((ERROR)(code) << 32) | (ERROR)(pos));
#define GET_CODE(err)                           \
    ((UINT)((err) >> 32))
#define GET_POS(err)                            \
    ((UINT)((err) & 0xFFFFFFFF))
#undef IS_ERROR
#define IS_ERROR(err)                           \
    (GET_CODE(err) != WINDIVERT_ERROR_NONE)

/*
 * Prototypes.
 */
static UINT32 WinDivertKindToField(KIND kind);
static PEXPR WinDivertParseFilter(HANDLE pool, TOKEN *toks, UINT *i,
    INT depth, BOOL and, PERROR error);
static BOOL WinDivertCondExecFilter(PWINDIVERT_FILTER filter, UINT length,
    UINT8 field, UINT32 arg);
static int WinDivertCompare128(BOOL neg_a, const UINT32 *a, BOOL neg_b,
    const UINT32 *b, BOOL big);
static BOOL WinDivertDeserializeFilter(PWINDIVERT_STREAM stream,
    PWINDIVERT_FILTER filter, UINT *length);
static void WinDivertFormatExpr(PWINDIVERT_STREAM stream, PEXPR expr,
    WINDIVERT_LAYER layer, BOOL top_level, BOOL and);

/*
 * Parse an IPv4 address.
 */
BOOL WinDivertHelperParseIPv4Address(const char *str, UINT32 *addr_ptr)
{
    UINT32 addr = 0;
    UINT32 part, i;

    if (str == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    for (i = 0; i < 4; i++)
    {
        if (!WinDivertAToI(str, (char **)&str, &part, 1) || part > UINT8_MAX)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        if (i != 3 && *str++ != '.')
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        addr |= part << (8*(3-i));
    }
    if (*str != '\0')
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (addr_ptr != NULL)
    {
        *addr_ptr = addr;
    }
    return TRUE;
}

/*
 * Parse an IPv6 address.
 */
BOOL WinDivertHelperParseIPv6Address(const char *str, UINT32 *addr_ptr)
{
    UINT16 laddr[8] = {0};
    UINT16 raddr[8] = {0};
    UINT32 addr[4];
    BOOL left = TRUE, ipv4 = FALSE;
    UINT32 ipv4_addr;
    UINT i, j, k, l, part;
    char part_str[5];

    j = 0;
    if (*str == ':')
    {
        str++;
        if (*str != ':')
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        left = FALSE;
        str++;
        if (*str == '\0')
        {
            goto WinDivertHelperParseIPv6AddressSuccess;
        }
    }

    for (i = 0, k = 0; k < 8; k++)
    {
        if (*str == ':')
        {
            if (!left)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            left = FALSE;
            str++;
            if (*str == '\0')
            {
                break;
            }
        }

        if (i < 6 && WinDivertHelperParseIPv4Address(str, &ipv4_addr))
        {
            // Tail is IPv4 address:
            ipv4 = TRUE;
            j += 2;
            goto WinDivertHelperParseIPv6AddressSuccess;
        }
        for (l = 0; l < 4 && WinDivertIsXDigit(*str); l++)
        {
            part_str[l] = *str;
            str++;
        }
        if (l == 0)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        part_str[l] = '\0';
        if (*str != ':' && *str != '\0')
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        WinDivertAToX(part_str, NULL, &part, /*size=*/1, /*prefix=*/FALSE);
        if (left)
        {
            laddr[i++] = (UINT16)part;
        }
        else
        {
            raddr[j++] = (UINT16)part;
        }
        if (*str == '\0')
        {
            if (!left || k == 7)
            {
                break;
            }
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        str++;
    }

WinDivertHelperParseIPv6AddressSuccess:

    if (!ipv4 && addr_ptr == NULL)
    {
        return TRUE;
    }
    for (i = 0; i < 4; i++)
    {
        k = 2 * i + j;
        l = k + 1;
        k = (k >= 8? k - 8: k);
        l = (l >= 8? l - 8: l);
        addr[3 - i] =
            (UINT32)laddr[2 * i + 1] |
            (UINT32)laddr[2 * i] << 16 |
            (UINT32)raddr[l] |
            (UINT32)raddr[k] << 16;
    }
    if (ipv4)
    {
        // Validate IPv4 address
        if (addr[3] != 0 || addr[2] != 0 || addr[0] != 0 ||
                (addr[1] != 0x0000FFFF && addr[1] != 0))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        addr[0] = ipv4_addr;
    }
    if (addr_ptr != NULL)
    {
        memcpy(addr_ptr, addr, sizeof(addr));
    }
    return TRUE;
}

/*
 * Lookup a token.
 */
static PTOKEN_INFO WinDivertTokenLookup(PTOKEN_INFO token_info,
    size_t token_info_len, const char *name)
{
    int lo = 0, hi = (int)token_info_len-1, mid;
    int cmp;
    while (hi >= lo)
    {
        mid = (lo + hi) / 2;
        cmp = WinDivertStrCmp(token_info[mid].name, name);
        if (cmp < 0)
        {
            lo = mid+1;
        }
        else if (cmp > 0)
        {
            hi = mid-1;
        }
        else
        {
            return &token_info[mid];
        }
    }
    return NULL;
}

/*
 * Parse IPv4/IPv6/ICMP/ICMPv6/TCP/UDP headers from a raw packet.
 */
BOOL WinDivertHelperParsePacket(const VOID *pPacket, UINT packetLen,
    PWINDIVERT_IPHDR *ppIPHeader, PWINDIVERT_IPV6HDR *ppIPv6Header,
    UINT8 *pProtocol, PWINDIVERT_ICMPHDR *ppICMPHeader,
    PWINDIVERT_ICMPV6HDR *ppICMPv6Header, PWINDIVERT_TCPHDR *ppTCPHeader,
    PWINDIVERT_UDPHDR *ppUDPHeader, PVOID *ppData, UINT *pDataLen,
    PVOID *ppNext, UINT *pNextLen)
{
    WINDIVERT_PACKET info;
    if (!WinDivertHelperParsePacketEx(pPacket, packetLen, &info))
    {
        return FALSE;
    }
    if (info.Truncated)
    {
        return FALSE;
    }

    if (pProtocol != NULL)
    {
        *pProtocol = info.Protocol;
    }
    if (ppIPHeader != NULL)
    {
        *ppIPHeader = info.IPHeader;
    }
    if (ppIPv6Header != NULL)
    {
        *ppIPv6Header = info.IPv6Header;
    }
    if (ppICMPHeader != NULL)
    {
        *ppICMPHeader = info.ICMPHeader;
    }
    if (ppICMPv6Header != NULL)
    {
        *ppICMPv6Header = info.ICMPv6Header;
    }
    if (ppTCPHeader != NULL)
    {
        *ppTCPHeader = info.TCPHeader;
    }
    if (ppUDPHeader != NULL)
    {
        *ppUDPHeader = info.UDPHeader;
    }
    if (ppData != NULL)
    {
        *ppData = info.Payload;
    }
    if (pDataLen != NULL)
    {
        *pDataLen = info.PayloadLength;
    }
    if (ppNext != NULL)
    {
        *ppNext = (info.Extended? (PVOID)((UINT8 *)pPacket +
            (info.HeaderLength + info.PayloadLength)): NULL);
    }
    if (pNextLen != NULL)
    {
        *pNextLen = (info.Extended?
            packetLen - (info.HeaderLength + info.PayloadLength): 0);
    }

    return TRUE;
}

/*
 * Expand a "macro" value.
 */
static BOOL WinDivertExpandMacro(KIND kind, WINDIVERT_LAYER layer, UINT32 *val)
{
    switch (kind)
    {
        case TOKEN_NETWORK:
            *val = WINDIVERT_LAYER_NETWORK;
            return TRUE;
        case TOKEN_NETWORK_FORWARD:
            *val = WINDIVERT_LAYER_NETWORK_FORWARD;
            return TRUE;
        case TOKEN_FLOW:
            *val = WINDIVERT_LAYER_FLOW;
            return TRUE;
        case TOKEN_SOCKET:
            *val = WINDIVERT_LAYER_SOCKET;
            return TRUE;
        case TOKEN_REFLECT:
            *val = WINDIVERT_LAYER_REFLECT;
            return TRUE;
        case TOKEN_EVENT_PACKET:
            *val = WINDIVERT_EVENT_NETWORK_PACKET;
            return (layer == WINDIVERT_LAYER_NETWORK ||
                    layer == WINDIVERT_LAYER_NETWORK_FORWARD);
        case TOKEN_EVENT_ESTABLISHED:
            *val = WINDIVERT_EVENT_FLOW_ESTABLISHED;
            return (layer == WINDIVERT_LAYER_FLOW);
        case TOKEN_EVENT_DELETED:
            *val = WINDIVERT_EVENT_FLOW_DELETED;
            return (layer == WINDIVERT_LAYER_FLOW);
        case TOKEN_EVENT_BIND:
            *val = WINDIVERT_EVENT_SOCKET_BIND;
            return (layer == WINDIVERT_LAYER_SOCKET);
        case TOKEN_EVENT_CONNECT:
            *val = WINDIVERT_EVENT_SOCKET_CONNECT;
            return (layer == WINDIVERT_LAYER_SOCKET);
        case TOKEN_EVENT_LISTEN:
            *val = WINDIVERT_EVENT_SOCKET_LISTEN;
            return (layer == WINDIVERT_LAYER_SOCKET);
        case TOKEN_EVENT_ACCEPT:
            *val = WINDIVERT_EVENT_SOCKET_ACCEPT;
            return (layer == WINDIVERT_LAYER_SOCKET);
        case TOKEN_EVENT_OPEN:
            *val = WINDIVERT_EVENT_REFLECT_OPEN;
            return (layer == WINDIVERT_LAYER_REFLECT);
        case TOKEN_EVENT_CLOSE:
            switch (layer)
            {
                case WINDIVERT_LAYER_SOCKET:
                    *val = WINDIVERT_EVENT_SOCKET_CLOSE;
                    return TRUE;
                case WINDIVERT_LAYER_REFLECT:
                    *val = WINDIVERT_EVENT_REFLECT_CLOSE;
                    return TRUE;
                default:
                    return FALSE;
            }
        case TOKEN_MACRO_TRUE:
            *val = 1;
            return TRUE;
        case TOKEN_MACRO_FALSE:
            *val = 0;
            return TRUE;
        case TOKEN_MACRO_TCP:
            *val = IPPROTO_TCP;
            return TRUE;
        case TOKEN_MACRO_UDP:
            *val = IPPROTO_UDP;
            return TRUE;
        case TOKEN_MACRO_ICMP:
            *val = IPPROTO_ICMP;
            return TRUE;
        case TOKEN_MACRO_ICMPV6:
            *val = IPPROTO_ICMPV6;
            return TRUE;
        default:
            return FALSE;
    }
}

/*
 * Tokenize the given filter string.
 */
static ERROR WinDivertTokenizeFilter(const char *filter, WINDIVERT_LAYER layer,
    TOKEN *tokens, UINT tokensmax)
{
    static const TOKEN_INFO token_info[] =
    {
        {"ACCEPT",              TOKEN_EVENT_ACCEPT      },
        {"BIND",                TOKEN_EVENT_BIND        },
        {"CLOSE",               TOKEN_EVENT_CLOSE       },
        {"CONNECT",             TOKEN_EVENT_CONNECT     },
        {"DELETED",             TOKEN_EVENT_DELETED     },
        {"ESTABLISHED",         TOKEN_EVENT_ESTABLISHED },
        {"FALSE",               TOKEN_MACRO_FALSE       },
        {"FLOW",                TOKEN_FLOW              },
        {"ICMP",                TOKEN_MACRO_ICMP        },
        {"ICMPV6",              TOKEN_MACRO_ICMPV6      },
        {"LISTEN",              TOKEN_EVENT_LISTEN      },
        {"NETWORK",             TOKEN_NETWORK           },
        {"NETWORK_FORWARD",     TOKEN_NETWORK_FORWARD   },
        {"OPEN",                TOKEN_EVENT_OPEN        },
        {"PACKET",              TOKEN_EVENT_PACKET      },
        {"REFLECT",             TOKEN_REFLECT           },
        {"SOCKET",              TOKEN_SOCKET            },
        {"TCP",                 TOKEN_MACRO_TCP         },
        {"TRUE",                TOKEN_MACRO_TRUE        },
        {"UDP",                 TOKEN_MACRO_UDP         },
        {"and",                 TOKEN_AND               },
        {"endpointId",          TOKEN_ENDPOINT_ID       },
        {"event",               TOKEN_EVENT             },
        {"false",               TOKEN_FALSE             },
        {"fragment",            TOKEN_FRAGMENT          },
        {"icmp",                TOKEN_ICMP              },
        {"icmp.Body",           TOKEN_ICMP_BODY         },
        {"icmp.Checksum",       TOKEN_ICMP_CHECKSUM     },
        {"icmp.Code",           TOKEN_ICMP_CODE         },
        {"icmp.Type",           TOKEN_ICMP_TYPE         },
        {"icmpv6",              TOKEN_ICMPV6            },
        {"icmpv6.Body",         TOKEN_ICMPV6_BODY       },
        {"icmpv6.Checksum",     TOKEN_ICMPV6_CHECKSUM   },
        {"icmpv6.Code",         TOKEN_ICMPV6_CODE       },
        {"icmpv6.Type",         TOKEN_ICMPV6_TYPE       },
        {"ifIdx",               TOKEN_IF_IDX            },
        {"impostor",            TOKEN_IMPOSTOR          },
        {"inbound",             TOKEN_INBOUND           },
        {"ip",                  TOKEN_IP                },
        {"ip.Checksum",         TOKEN_IP_CHECKSUM       },
        {"ip.DF",               TOKEN_IP_DF             },
        {"ip.DstAddr",          TOKEN_IP_DST_ADDR       },
        {"ip.FragOff",          TOKEN_IP_FRAG_OFF       },
        {"ip.HdrLength",        TOKEN_IP_HDR_LENGTH     },
        {"ip.Id",               TOKEN_IP_ID             },
        {"ip.Length",           TOKEN_IP_LENGTH         },
        {"ip.MF",               TOKEN_IP_MF             },
        {"ip.Protocol",         TOKEN_IP_PROTOCOL       },
        {"ip.SrcAddr",          TOKEN_IP_SRC_ADDR       },
        {"ip.TOS",              TOKEN_IP_TOS            },
        {"ip.TTL",              TOKEN_IP_TTL            },
        {"ipv6",                TOKEN_IPV6              },
        {"ipv6.DstAddr",        TOKEN_IPV6_DST_ADDR     },
        {"ipv6.FlowLabel",      TOKEN_IPV6_FLOW_LABEL   },
        {"ipv6.HopLimit",       TOKEN_IPV6_HOP_LIMIT    },
        {"ipv6.Length",         TOKEN_IPV6_LENGTH       },
        {"ipv6.NextHdr",        TOKEN_IPV6_NEXT_HDR     },
        {"ipv6.SrcAddr",        TOKEN_IPV6_SRC_ADDR     },
        {"ipv6.TrafficClass",   TOKEN_IPV6_TRAFFIC_CLASS},
        {"layer",               TOKEN_LAYER             },
        {"length",              TOKEN_LENGTH            },
        {"localAddr",           TOKEN_LOCAL_ADDR        },
        {"localPort",           TOKEN_LOCAL_PORT        },
        {"loopback",            TOKEN_LOOPBACK          },
        {"not",                 TOKEN_NOT               },
        {"or",                  TOKEN_OR                },
        {"outbound",            TOKEN_OUTBOUND          },
        {"packet",              TOKEN_PACKET            },
        {"packet16",            TOKEN_PACKET16          },
        {"packet32",            TOKEN_PACKET32          },
        {"parentEndpointId",    TOKEN_PARENT_ENDPOINT_ID},
        {"priority",            TOKEN_PRIORITY          },
        {"processId",           TOKEN_PROCESS_ID        },
        {"protocol",            TOKEN_PROTOCOL          },
        {"random16",            TOKEN_RANDOM16          },
        {"random32",            TOKEN_RANDOM32          },
        {"random8",             TOKEN_RANDOM8           },
        {"remoteAddr",          TOKEN_REMOTE_ADDR       },
        {"remotePort",          TOKEN_REMOTE_PORT       },
        {"subIfIdx",            TOKEN_SUB_IF_IDX        },
        {"tcp",                 TOKEN_TCP               },
        {"tcp.Ack",             TOKEN_TCP_ACK           },
        {"tcp.AckNum",          TOKEN_TCP_ACK_NUM       },
        {"tcp.Checksum",        TOKEN_TCP_CHECKSUM      },
        {"tcp.DstPort",         TOKEN_TCP_DST_PORT      },
        {"tcp.Fin",             TOKEN_TCP_FIN           },
        {"tcp.HdrLength",       TOKEN_TCP_HDR_LENGTH    },
        {"tcp.Payload",         TOKEN_TCP_PAYLOAD       },
        {"tcp.Payload16",       TOKEN_TCP_PAYLOAD16     },
        {"tcp.Payload32",       TOKEN_TCP_PAYLOAD32     },
        {"tcp.PayloadLength",   TOKEN_TCP_PAYLOAD_LENGTH},
        {"tcp.Psh",             TOKEN_TCP_PSH           },
        {"tcp.Rst",             TOKEN_TCP_RST           },
        {"tcp.SeqNum",          TOKEN_TCP_SEQ_NUM       },
        {"tcp.SrcPort",         TOKEN_TCP_SRC_PORT      },
        {"tcp.Syn",             TOKEN_TCP_SYN           },
        {"tcp.Urg",             TOKEN_TCP_URG           },
        {"tcp.UrgPtr",          TOKEN_TCP_URG_PTR       },
        {"tcp.Window",          TOKEN_TCP_WINDOW        },
        {"timestamp",           TOKEN_TIMESTAMP         },
        {"true",                TOKEN_TRUE              },
        {"udp",                 TOKEN_UDP               },
        {"udp.Checksum",        TOKEN_UDP_CHECKSUM      },
        {"udp.DstPort",         TOKEN_UDP_DST_PORT      },
        {"udp.Length",          TOKEN_UDP_LENGTH        },
        {"udp.Payload",         TOKEN_UDP_PAYLOAD       },
        {"udp.Payload16",       TOKEN_UDP_PAYLOAD16     },
        {"udp.Payload32",       TOKEN_UDP_PAYLOAD32     },
        {"udp.PayloadLength",   TOKEN_UDP_PAYLOAD_LENGTH},
        {"udp.SrcPort",         TOKEN_UDP_SRC_PORT      },
        {"zero",                TOKEN_ZERO              },
    };
    TOKEN_INFO *result;
    char c;
    char token[TOKEN_MAXLEN];
    UINT32 field;
    UINT i = 0, j;
    UINT tp = 0;

    while (TRUE)
    {
        if (tp >= tokensmax-1)
        {
            return MAKE_ERROR(WINDIVERT_ERROR_TOO_LONG, i);
        }
        memset(tokens[tp].val, 0, sizeof(tokens[tp].val));
        while (WinDivertIsSpace(filter[i]))
        {
            i++;
        }
        tokens[tp].pos = i;
        c = filter[i++];
        switch (c)
        {
            case '\0':
                tokens[tp].kind = TOKEN_END;
                return MAKE_ERROR(WINDIVERT_ERROR_NONE, 0);
            case '(':
                tokens[tp++].kind = TOKEN_OPEN;
                continue;
            case ')':
                tokens[tp++].kind = TOKEN_CLOSE;
                continue;
            case '[':
                tokens[tp++].kind = TOKEN_SQUARE_OPEN;
                continue;
            case ']':
                tokens[tp++].kind = TOKEN_SQUARE_CLOSE;
                continue;
            case '-':
                tokens[tp++].kind = TOKEN_MINUS;
                continue;
            case '!':
                if (filter[i] == '=')
                {
                    i++;
                    tokens[tp++].kind = TOKEN_NEQ;
                }
                else
                {
                    tokens[tp++].kind = TOKEN_NOT;
                }
                continue;
            case '=':
                if (filter[i] == '=')
                {
                    i++;
                }
                tokens[tp++].kind = TOKEN_EQ;
                continue;
            case '<':
                if (filter[i] == '=')
                {
                    i++;
                    tokens[tp++].kind = TOKEN_LEQ;
                }
                else
                {
                    tokens[tp++].kind = TOKEN_LT;
                }
                continue;
            case '>':
                if (filter[i] == '=')
                {
                    i++;
                    tokens[tp++].kind = TOKEN_GEQ;
                }
                else
                {
                    tokens[tp++].kind = TOKEN_GT;
                }
                continue;
            case ':':
                if (filter[i] == ':')
                {
                    break;      // Probably ipv6 address, e.g. ::1.
                }
                tokens[tp++].kind = TOKEN_COLON;
                continue;
            case '?':
                tokens[tp++].kind = TOKEN_QUESTION;
                continue;
            case '&':
                if (filter[i++] != '&')
                {
                    return MAKE_ERROR(WINDIVERT_ERROR_BAD_TOKEN, i-1);
                }
                tokens[tp++].kind = TOKEN_AND;
                continue;
            case '|':
                if (filter[i++] != '|')
                {
                    return MAKE_ERROR(WINDIVERT_ERROR_BAD_TOKEN, i-1);
                }
                tokens[tp++].kind = TOKEN_OR;
                continue;
            default:
                break;
        }
        token[0] = c;
        if (WinDivertIsAlNum(c) || c == '.' || c == ':' || c == '_')
        {
            UINT32 num[4];
            char *end;
            for (j = 1; j < TOKEN_MAXLEN && (WinDivertIsAlNum(filter[i]) ||
                    filter[i] == '.' || filter[i] == ':' || filter[i] == '_');
                    j++, i++)
            {
                token[j] = filter[i];
            }
            if (j >= TOKEN_MAXLEN)
            {
                return MAKE_ERROR(WINDIVERT_ERROR_BAD_TOKEN, i-j);
            }
            token[j] = '\0';

            // Handle trailing colons:
            if (j >= 1 && token[j-1] == ':')
            {
                if (j == 1 || token[j-2] != ':')
                {
                    token[j-1] = '\0';
                    i--;
                }
            }

            // Check for symbol:
            result = WinDivertTokenLookup((PTOKEN_INFO)token_info,
                sizeof(token_info) / sizeof(TOKEN_INFO), token);
            if (result != NULL)
            {
                field = WinDivertKindToField(result->kind);
                if (field <= WINDIVERT_FILTER_FIELD_MAX &&
                        !WinDivertValidateField(layer, field))
                {
                    return MAKE_ERROR(WINDIVERT_ERROR_BAD_TOKEN_FOR_LAYER,
                        i-j);
                }
                if (WinDivertExpandMacro(result->kind, layer,
                        &tokens[tp].val[0]))
                {
                    tokens[tp].kind = TOKEN_NUMBER;
                }
                else
                {
                    tokens[tp].kind = result->kind;
                }
                tp++;
                continue;
            }

            // Check for 'b':
            if (token[0] == 'b' && token[1] == '\0')
            {
                tokens[tp].kind = TOKEN_BYTES;
                continue;
            }

            // Check for base 10 number:
            if (WinDivertAToI(token, &end, num, sizeof(num)/sizeof(num[0])))
            {
                BOOL b = (*end == 'b' && *(end+1) == '\0');
                if (*end == '\0' || b)
                {
                    tokens[tp].kind = TOKEN_NUMBER;
                    memcpy(tokens[tp].val, num, sizeof(tokens[tp].val));
                    tp++;
                    if (b)
                    {
                        memset(tokens[tp].val, 0, sizeof(tokens[tp].val));
                        tokens[tp].kind = TOKEN_BYTES;
                        tp++;
                    }
                    continue;
                }
            }

            // Check for base 16 number:
            if (token[0] == '0' && token[1] == 'x' &&
                WinDivertAToX(token, &end, num, sizeof(num)/sizeof(num[0]),
                    /*prefix=*/TRUE) &&
                *end == '\0')
            {
                tokens[tp].kind = TOKEN_NUMBER;
                memcpy(tokens[tp].val, num, sizeof(tokens[tp].val));
                tp++;
                continue;
            }

            // Check for IPv4 address:
            if (WinDivertHelperParseIPv4Address(token, tokens[tp].val))
            {
                tokens[tp].val[1] = 0x0000FFFF;
                tokens[tp].kind = TOKEN_NUMBER;
                tp++;
                continue;
            }

            // Check for IPv6 address:
            SetLastError(0);
            if (WinDivertHelperParseIPv6Address(token, tokens[tp].val))
            {
                tokens[tp].kind = TOKEN_NUMBER;
                tp++;
                continue;
            }

            return MAKE_ERROR(WINDIVERT_ERROR_BAD_TOKEN, i-j);
        }
        else
        {
            return MAKE_ERROR(WINDIVERT_ERROR_BAD_TOKEN, i);
        }
    }
}

/*
 * Construct a variable/field.
 */
static PEXPR WinDivertMakeVar(KIND kind, PERROR error)
{
    // NOTE: must be in order of kind.
    static const EXPR vars[] =
    {
        {{{0}}, TOKEN_ICMP},
        {{{0}}, TOKEN_ICMP_BODY},
        {{{0}}, TOKEN_ICMP_CHECKSUM},
        {{{0}}, TOKEN_ICMP_CODE},
        {{{0}}, TOKEN_ICMP_TYPE},
        {{{0}}, TOKEN_ICMPV6},
        {{{0}}, TOKEN_ICMPV6_BODY},
        {{{0}}, TOKEN_ICMPV6_CHECKSUM},
        {{{0}}, TOKEN_ICMPV6_CODE},
        {{{0}}, TOKEN_ICMPV6_TYPE},
        {{{0}}, TOKEN_IP},
        {{{0}}, TOKEN_IP_CHECKSUM},
        {{{0}}, TOKEN_IP_DF},
        {{{0}}, TOKEN_IP_DST_ADDR},
        {{{0}}, TOKEN_IP_FRAG_OFF},
        {{{0}}, TOKEN_IP_HDR_LENGTH},
        {{{0}}, TOKEN_IP_ID},
        {{{0}}, TOKEN_IP_LENGTH},
        {{{0}}, TOKEN_IP_MF},
        {{{0}}, TOKEN_IP_PROTOCOL},
        {{{0}}, TOKEN_IP_SRC_ADDR},
        {{{0}}, TOKEN_IP_TOS},
        {{{0}}, TOKEN_IP_TTL},
        {{{0}}, TOKEN_IPV6},
        {{{0}}, TOKEN_IPV6_DST_ADDR},
        {{{0}}, TOKEN_IPV6_FLOW_LABEL},
        {{{0}}, TOKEN_IPV6_HOP_LIMIT},
        {{{0}}, TOKEN_IPV6_LENGTH},
        {{{0}}, TOKEN_IPV6_NEXT_HDR},
        {{{0}}, TOKEN_IPV6_SRC_ADDR},
        {{{0}}, TOKEN_IPV6_TRAFFIC_CLASS},
        {{{0}}, TOKEN_TCP},
        {{{0}}, TOKEN_TCP_ACK},
        {{{0}}, TOKEN_TCP_ACK_NUM},
        {{{0}}, TOKEN_TCP_CHECKSUM},
        {{{0}}, TOKEN_TCP_DST_PORT},
        {{{0}}, TOKEN_TCP_FIN},
        {{{0}}, TOKEN_TCP_HDR_LENGTH},
        {{{0}}, TOKEN_TCP_PAYLOAD_LENGTH},
        {{{0}}, TOKEN_TCP_PSH},
        {{{0}}, TOKEN_TCP_RST},
        {{{0}}, TOKEN_TCP_SEQ_NUM},
        {{{0}}, TOKEN_TCP_SRC_PORT},
        {{{0}}, TOKEN_TCP_SYN},
        {{{0}}, TOKEN_TCP_URG},
        {{{0}}, TOKEN_TCP_URG_PTR},
        {{{0}}, TOKEN_TCP_WINDOW},
        {{{0}}, TOKEN_UDP},
        {{{0}}, TOKEN_UDP_CHECKSUM},
        {{{0}}, TOKEN_UDP_DST_PORT},
        {{{0}}, TOKEN_UDP_LENGTH},
        {{{0}}, TOKEN_UDP_PAYLOAD_LENGTH},
        {{{0}}, TOKEN_UDP_SRC_PORT},
        {{{0}}, TOKEN_ZERO},
        {{{0}}, TOKEN_EVENT},
        {{{0}}, TOKEN_RANDOM8},
        {{{0}}, TOKEN_RANDOM16},
        {{{0}}, TOKEN_RANDOM32},
        {{{0}}, TOKEN_LENGTH},
        {{{0}}, TOKEN_TIMESTAMP},
        {{{0}}, TOKEN_TRUE},
        {{{0}}, TOKEN_FALSE},
        {{{0}}, TOKEN_INBOUND},
        {{{0}}, TOKEN_OUTBOUND},
        {{{0}}, TOKEN_FRAGMENT},
        {{{0}}, TOKEN_IF_IDX},
        {{{0}}, TOKEN_SUB_IF_IDX},
        {{{0}}, TOKEN_LOOPBACK},
        {{{0}}, TOKEN_IMPOSTOR},
        {{{0}}, TOKEN_PROCESS_ID},
        {{{0}}, TOKEN_LOCAL_ADDR},
        {{{0}}, TOKEN_REMOTE_ADDR},
        {{{0}}, TOKEN_LOCAL_PORT},
        {{{0}}, TOKEN_REMOTE_PORT},
        {{{0}}, TOKEN_PROTOCOL},
        {{{0}}, TOKEN_ENDPOINT_ID},
        {{{0}}, TOKEN_PARENT_ENDPOINT_ID},
        {{{0}}, TOKEN_LAYER},
        {{{0}}, TOKEN_PRIORITY},
    };

    // Binary search:
    UINT lo = 0, hi = sizeof(vars) / sizeof(vars[0]) - 1, mid;
    while (lo <= hi)
    {
        mid = (hi + lo) / 2;
        if (vars[mid].kind < kind)
        {
            lo = mid + 1;
            continue;
        }
        if (vars[mid].kind > kind)
        {
            hi = mid - 1;
            continue;
        }
        return (PEXPR)(vars + mid);
    }
    if (error != NULL)
    {
        *error = MAKE_ERROR(WINDIVERT_ERROR_ASSERTION_FAILED, 0);
    }
    return NULL;
}

/*
 * Construct array varable.
 */
static PEXPR WinDivertMakeArrayVar(HANDLE pool, KIND kind, INT idx,
    PERROR error)
{
    PEXPR var = (PEXPR)HeapAlloc(pool, HEAP_ZERO_MEMORY, sizeof(EXPR));
    if (var == NULL)
    {
        *error = MAKE_ERROR(WINDIVERT_ERROR_NO_MEMORY, 0);
        return NULL;
    }
    var->kind = kind;
    var->val[0] = (UINT32)idx;
    return var;
}

/*
 * Construct zero.
 */
static PEXPR WinDivertMakeZero(void)
{
    static const EXPR zero = {{{0, 0, 0, 0}}, TOKEN_NUMBER};
    return (PEXPR)&zero;
}

/*
 * Construct one.
 */
static PEXPR WinDivertMakeOne(void)
{
    static const EXPR one = {{{1, 0, 0, 0}}, TOKEN_NUMBER};
    return (PEXPR)&one;
}

/*
 * Construct a number.
 */
static PEXPR WinDivertMakeNumber(HANDLE pool, UINT32 *val, PERROR error)
{
    PEXPR expr = (PEXPR)HeapAlloc(pool, HEAP_ZERO_MEMORY, sizeof(EXPR));
    if (expr == NULL)
    {
        *error = MAKE_ERROR(WINDIVERT_ERROR_NO_MEMORY, 0);
        return NULL;
    }
    expr->kind = TOKEN_NUMBER;
    expr->val[0] = val[0];
    expr->val[1] = val[1];
    expr->val[2] = val[2];
    expr->val[3] = val[3];
    return expr;
}

/*
 * Construct a binary operator.
 */
static PEXPR WinDivertMakeBinOp(HANDLE pool, KIND kind, PEXPR arg0, PEXPR arg1,
    PERROR error)
{
    PEXPR expr;
    if (arg0 == NULL || arg1 == NULL)
    {
        return NULL;
    }
    expr = (PEXPR)HeapAlloc(pool, HEAP_ZERO_MEMORY, sizeof(EXPR));
    if (expr == NULL)
    {
        *error = MAKE_ERROR(WINDIVERT_ERROR_NO_MEMORY, 0);
        return NULL;
    }
    expr->kind = kind;
    expr->arg[0] = arg0;
    expr->arg[1] = arg1;
    return expr;
}

/*
 * Construct an if-then-else.
 */
static PEXPR WinDivertMakeIfThenElse(HANDLE pool, PEXPR cond, PEXPR th,
    PEXPR el, PERROR error)
{
    PEXPR expr = (PEXPR)HeapAlloc(pool, HEAP_ZERO_MEMORY, sizeof(EXPR));
    if (expr == NULL)
    {
        *error = MAKE_ERROR(WINDIVERT_ERROR_NO_MEMORY, 0);
        return NULL;
    }
    expr->kind = TOKEN_QUESTION;
    expr->arg[0] = cond;
    expr->arg[1] = th;
    expr->arg[2] = el;
    return expr;
}

/*
 * Parse a filter test.
 */
static PEXPR WinDivertParseTest(HANDLE pool, TOKEN *toks, UINT *i, PERROR error)
{
    PEXPR var, val;
    KIND kind;
    BOOL not = FALSE, neg;
    UINT idx, size;
    while (toks[*i].kind == TOKEN_NOT)
    {
        not = !not;
        *i = *i + 1;
    }
    switch (toks[*i].kind)
    {
        case TOKEN_TIMESTAMP:
        case TOKEN_PRIORITY:
        case TOKEN_ZERO:
        case TOKEN_EVENT:
        case TOKEN_RANDOM8:
        case TOKEN_RANDOM16:
        case TOKEN_RANDOM32:
        case TOKEN_TRUE:
        case TOKEN_FALSE:
        case TOKEN_OUTBOUND:
        case TOKEN_INBOUND:
        case TOKEN_FRAGMENT:
        case TOKEN_IF_IDX:
        case TOKEN_SUB_IF_IDX:
        case TOKEN_LOOPBACK:
        case TOKEN_IMPOSTOR:
        case TOKEN_IP:
        case TOKEN_IPV6:
        case TOKEN_ICMP:
        case TOKEN_ICMPV6:
        case TOKEN_TCP:
        case TOKEN_UDP:
        case TOKEN_PROCESS_ID:
        case TOKEN_LOCAL_ADDR:
        case TOKEN_REMOTE_ADDR:
        case TOKEN_LOCAL_PORT:
        case TOKEN_REMOTE_PORT:
        case TOKEN_PROTOCOL:
        case TOKEN_ENDPOINT_ID:
        case TOKEN_PARENT_ENDPOINT_ID:
        case TOKEN_LENGTH:
        case TOKEN_LAYER:
        case TOKEN_IP_HDR_LENGTH:
        case TOKEN_IP_TOS:
        case TOKEN_IP_LENGTH:
        case TOKEN_IP_ID:
        case TOKEN_IP_DF:
        case TOKEN_IP_MF:
        case TOKEN_IP_FRAG_OFF:
        case TOKEN_IP_TTL:
        case TOKEN_IP_PROTOCOL:
        case TOKEN_IP_CHECKSUM:
        case TOKEN_IP_SRC_ADDR:
        case TOKEN_IP_DST_ADDR:
        case TOKEN_IPV6_TRAFFIC_CLASS:
        case TOKEN_IPV6_FLOW_LABEL:
        case TOKEN_IPV6_LENGTH:
        case TOKEN_IPV6_NEXT_HDR:
        case TOKEN_IPV6_HOP_LIMIT:
        case TOKEN_IPV6_SRC_ADDR:
        case TOKEN_IPV6_DST_ADDR:
        case TOKEN_ICMP_TYPE:
        case TOKEN_ICMP_CODE:
        case TOKEN_ICMP_CHECKSUM:
        case TOKEN_ICMP_BODY:
        case TOKEN_ICMPV6_TYPE:
        case TOKEN_ICMPV6_CODE:
        case TOKEN_ICMPV6_CHECKSUM:
        case TOKEN_ICMPV6_BODY:
        case TOKEN_TCP_SRC_PORT:
        case TOKEN_TCP_DST_PORT:
        case TOKEN_TCP_SEQ_NUM:
        case TOKEN_TCP_ACK_NUM:
        case TOKEN_TCP_HDR_LENGTH:
        case TOKEN_TCP_URG:
        case TOKEN_TCP_ACK:
        case TOKEN_TCP_PSH:
        case TOKEN_TCP_RST:
        case TOKEN_TCP_SYN:
        case TOKEN_TCP_FIN:
        case TOKEN_TCP_WINDOW:
        case TOKEN_TCP_CHECKSUM:
        case TOKEN_TCP_URG_PTR:
        case TOKEN_TCP_PAYLOAD_LENGTH:
        case TOKEN_UDP_SRC_PORT:
        case TOKEN_UDP_DST_PORT:
        case TOKEN_UDP_LENGTH:
        case TOKEN_UDP_CHECKSUM:
        case TOKEN_UDP_PAYLOAD_LENGTH:
            var = WinDivertMakeVar(toks[*i].kind, error);
            *i = *i + 1;
            break;
        case TOKEN_PACKET:
        case TOKEN_TCP_PAYLOAD:
        case TOKEN_UDP_PAYLOAD:
            size = sizeof(UINT8);
            goto array;
        case TOKEN_PACKET16:
        case TOKEN_TCP_PAYLOAD16:
        case TOKEN_UDP_PAYLOAD16:
            size = sizeof(UINT16);
            goto array;
        case TOKEN_PACKET32:
        case TOKEN_TCP_PAYLOAD32:
        case TOKEN_UDP_PAYLOAD32:
            size = sizeof(UINT32);
        array:
            kind = toks[*i].kind;
            *i = *i + 1;
            if (toks[*i].kind != TOKEN_SQUARE_OPEN)
            {
                goto unexpected_token;
            }
            *i = *i + 1;
            neg = FALSE;
            if (toks[*i].kind == TOKEN_MINUS)
            {
                neg = TRUE;
                *i = *i + 1;
            }
            if (toks[*i].kind != TOKEN_NUMBER)
            {
                goto unexpected_token;
            }
            if (toks[*i].val[3] != 0 || toks[*i].val[2] != 0 ||
                toks[*i].val[1] != 0 || toks[*i].val[0] > WINDIVERT_MTU_MAX)
            {
                *error = MAKE_ERROR(WINDIVERT_ERROR_INDEX_OOB, toks[*i].pos);
                return NULL;
            }
            idx = toks[*i].val[0];
            *i = *i + 1;
            if (toks[*i].kind == TOKEN_BYTES)
            {
                *i = *i + 1;
            }
            else
            {
                idx *= size;
            }
            if ((!neg && idx > UINT16_MAX - size) ||
                (neg && idx > UINT16_MAX) || (neg && idx < size))
            {
                *error = MAKE_ERROR(WINDIVERT_ERROR_INDEX_OOB, toks[*i].pos);
                return NULL;
            }
            var = WinDivertMakeArrayVar(pool, kind, (neg? -(INT)idx: (INT)idx),
                error);
            if (var == NULL)
            {
                return NULL;
            }
            if (toks[*i].kind != TOKEN_SQUARE_CLOSE)
            {
                goto unexpected_token;
            }
            *i = *i + 1;
            break;
        default:
        unexpected_token:
            *error = MAKE_ERROR(WINDIVERT_ERROR_UNEXPECTED_TOKEN, toks[*i].pos);
            return NULL;
    }
    switch (toks[*i].kind)
    {
        case TOKEN_EQ:
        case TOKEN_NEQ:
        case TOKEN_LT:
        case TOKEN_LEQ:
        case TOKEN_GT:
        case TOKEN_GEQ:
            kind = toks[*i].kind;
            break;
        default:
            return WinDivertMakeBinOp(pool, (not? TOKEN_EQ: TOKEN_NEQ), var,
                WinDivertMakeZero(), error);
    }
    if (not)
    {
        switch (kind)
        {
            case TOKEN_EQ:
                kind = TOKEN_NEQ;
                break;
            case TOKEN_NEQ:
                kind = TOKEN_EQ;
                break;
            case TOKEN_LT:
                kind = TOKEN_GEQ;
                break;
            case TOKEN_LEQ:
                kind = TOKEN_GT;
                break;
            case TOKEN_GT:
                kind = TOKEN_LEQ;
                break;
            case TOKEN_GEQ:
                kind = TOKEN_LT;
                break;
            default:
                break;
        }
    }
    *i = *i + 1;
    neg = FALSE;
    if (toks[*i].kind == TOKEN_MINUS)
    {
        neg = TRUE;
        *i = *i + 1;
    }
    if (toks[*i].kind != TOKEN_NUMBER)
    {
        *error = MAKE_ERROR(WINDIVERT_ERROR_UNEXPECTED_TOKEN, toks[*i].pos);
        return NULL;
    }
    val = WinDivertMakeNumber(pool, toks[*i].val, error);
    val->neg = neg;
    *i = *i + 1;
    return WinDivertMakeBinOp(pool, kind, var, val, error);
}

/*
 * Parse a filter argument to an (and) (or) operator.
 */
static PEXPR WinDivertParseAndOrArg(HANDLE pool, TOKEN *toks, UINT *i,
    INT depth, PERROR error)
{
    PEXPR arg, th, el;
    if (depth-- < 0)
    {
        *error = MAKE_ERROR(WINDIVERT_ERROR_TOO_DEEP, toks[*i].pos);
        return NULL;
    }
    switch (toks[*i].kind)
    {
        case TOKEN_OPEN:
            *i = *i + 1;
            arg = WinDivertParseFilter(pool, toks, i, depth, FALSE, error);
            if (toks[*i].kind == TOKEN_CLOSE)
            {
                *i = *i + 1;
                return arg;
            }
            if (toks[*i].kind == TOKEN_QUESTION)
            {
                *i = *i + 1;
                th = WinDivertParseFilter(pool, toks, i, depth, FALSE, error);
                if (th == NULL)
                {
                    return NULL;
                }
                if (toks[*i].kind != TOKEN_COLON)
                {
                    *error = MAKE_ERROR(WINDIVERT_ERROR_UNEXPECTED_TOKEN,
                        toks[*i].pos);
                    return NULL;
                }
                *i = *i + 1;
                el = WinDivertParseFilter(pool, toks, i, depth, FALSE, error);
                if (el == NULL)
                {
                    return NULL;
                }
                if (toks[*i].kind != TOKEN_CLOSE)
                {
                    *error = MAKE_ERROR(WINDIVERT_ERROR_UNEXPECTED_TOKEN,
                        toks[*i].pos);
                    return NULL;
                }
                *i = *i + 1;
                arg = WinDivertMakeIfThenElse(pool, arg, th, el, error);
                return arg;
            }
            *error = MAKE_ERROR(WINDIVERT_ERROR_UNEXPECTED_TOKEN, toks[*i].pos);
            return NULL;
        default:
            return WinDivertParseTest(pool, toks, i, error);
    }
}

/*
 * Parse the filter into an expression object.
 */
static PEXPR WinDivertParseFilter(HANDLE pool, TOKEN *toks, UINT *i, INT depth,
    BOOL and, PERROR error)
{
    PEXPR expr, arg;
    if (depth-- < 0)
    {
        *error = MAKE_ERROR(WINDIVERT_ERROR_TOO_DEEP, toks[*i].pos);
        return NULL;
    }
    if (and)
        expr = WinDivertParseAndOrArg(pool, toks, i, depth, error);
    else
        expr = WinDivertParseFilter(pool, toks, i, depth, TRUE, error);
    do
    {
        if (expr == NULL)
        {
            return NULL;
        }
        switch (toks[*i].kind)
        {
            case TOKEN_AND:
                *i = *i + 1;
                arg = WinDivertParseAndOrArg(pool, toks, i, depth, error);
                expr = WinDivertMakeBinOp(pool, TOKEN_AND, expr, arg, error);
                continue;
            case TOKEN_OR:
                *i = *i + 1;
                arg = WinDivertParseFilter(pool, toks, i, depth, TRUE, error);
                expr = WinDivertMakeBinOp(pool, TOKEN_OR, expr, arg, error);
                continue;
            default:
                return expr;
        }
    }
    while (TRUE);
}

/*
 * Simplify a test if possible.
 */
static void WinDivertSimplifyTest(PEXPR test)
{
    PEXPR var = test->arg[0];
    PEXPR val = test->arg[1];
    BOOL neg_lb = FALSE, neg_ub = FALSE, neg;
    UINT32 lb[4] = {0}, ub[4] = {0};
    int result_lb, result_ub;
    BOOL eq = FALSE, result = FALSE;
    KIND type = TOKEN_TRUE;

    switch (var->kind)
    {
        case TOKEN_ZERO:
        case TOKEN_FALSE:
            eq = TRUE;
            lb[0] = ub[0] = 0;
            break;
        case TOKEN_TRUE:
            eq = TRUE;
            lb[0] = ub[0] = 1;
            break;
        case TOKEN_LAYER:
            lb[0] = 0; ub[0] = WINDIVERT_LAYER_MAX;
            break;
        case TOKEN_PRIORITY:
            neg_lb = TRUE;
            lb[0] = ub[0] = WINDIVERT_PRIORITY_MAX;
            break;
        case TOKEN_EVENT:
            lb[0] = 0; ub[0] = WINDIVERT_EVENT_MAX;
            break;
        case TOKEN_IP_DF:
        case TOKEN_IP_MF:
            type = TOKEN_IP;
            lb[0] = 0; ub[0] = 1;
            break;
        case TOKEN_TCP_URG:
        case TOKEN_TCP_ACK:
        case TOKEN_TCP_PSH:
        case TOKEN_TCP_RST:
        case TOKEN_TCP_SYN:
        case TOKEN_TCP_FIN:
            type = TOKEN_TCP;
            lb[0] = 0; ub[0] = 1;
            break;
        case TOKEN_INBOUND:
        case TOKEN_OUTBOUND:
        case TOKEN_FRAGMENT:
        case TOKEN_IP:
        case TOKEN_IPV6:
        case TOKEN_ICMP:
        case TOKEN_ICMPV6:
        case TOKEN_TCP:
        case TOKEN_UDP:
            lb[0] = 0; ub[0] = 1;
            break;
        case TOKEN_IP_HDR_LENGTH:
            type = TOKEN_IP;
            lb[0] = 0; ub[0] = 0x0F;
            break;
        case TOKEN_TCP_HDR_LENGTH:
            type = TOKEN_TCP;
            lb[0] = 0; ub[0] = 0x0F;
            break;
        case TOKEN_IP_TTL:
        case TOKEN_IP_PROTOCOL:
            type = TOKEN_IP;
            lb[0] = 0; ub[0] = 0xFF;
            break;
        case TOKEN_IPV6_TRAFFIC_CLASS:
        case TOKEN_IPV6_NEXT_HDR:
        case TOKEN_IPV6_HOP_LIMIT:
            type = TOKEN_IPV6;
            lb[0] = 0; ub[0] = 0xFF;
            break;
        case TOKEN_ICMP_TYPE:
        case TOKEN_ICMP_CODE:
            type = TOKEN_ICMP;
            lb[0] = 0; ub[0] = 0xFF;
            break;
        case TOKEN_ICMPV6_TYPE:
        case TOKEN_ICMPV6_CODE:
            type = TOKEN_ICMPV6;
            lb[0] = 0; ub[0] = 0xFF;
            break;
        case TOKEN_TCP_PAYLOAD:
            type = TOKEN_TCP;
            lb[0] = 0; ub[0] = 0xFF;
            break;
        case TOKEN_UDP_PAYLOAD:
            type = TOKEN_UDP;
            lb[0] = 0; ub[0] = 0xFF;
            break;
        case TOKEN_PROTOCOL:
        case TOKEN_PACKET:
        case TOKEN_RANDOM8:
            lb[0] = 0; ub[0] = 0xFF;
            break;
        case TOKEN_IP_FRAG_OFF:
            type = TOKEN_IP;
            lb[0] = 0; ub[0] = 0x1FFF;
            break;
        case TOKEN_IP_TOS:
        case TOKEN_IP_LENGTH:
        case TOKEN_IP_ID:
        case TOKEN_IP_CHECKSUM:
            type = TOKEN_IP;
            lb[0] = 0; ub[0] = 0xFFFF;
            break;
        case TOKEN_IPV6_LENGTH:
            type = TOKEN_IPV6;
            lb[0] = 0; ub[0] = 0xFFFF;
            break;
        case TOKEN_ICMP_CHECKSUM:
            type = TOKEN_ICMP;
            lb[0] = 0; ub[0] = 0xFFFF;
            break;
        case TOKEN_ICMPV6_CHECKSUM:
            type = TOKEN_ICMPV6;
            lb[0] = 0; ub[0] = 0xFFFF;
            break;
        case TOKEN_TCP_SRC_PORT:
        case TOKEN_TCP_DST_PORT:
        case TOKEN_TCP_WINDOW:
        case TOKEN_TCP_CHECKSUM:
        case TOKEN_TCP_URG_PTR:
        case TOKEN_TCP_PAYLOAD_LENGTH:
        case TOKEN_TCP_PAYLOAD16:
            type = TOKEN_TCP;
            lb[0] = 0; ub[0] = 0xFFFF;
            break;
        case TOKEN_UDP_SRC_PORT:
        case TOKEN_UDP_DST_PORT:
        case TOKEN_UDP_LENGTH:
        case TOKEN_UDP_CHECKSUM:
        case TOKEN_UDP_PAYLOAD_LENGTH:
        case TOKEN_UDP_PAYLOAD16:
            type = TOKEN_UDP;
            lb[0] = 0; ub[0] = 0xFFFF;
            break;
        case TOKEN_LOCAL_PORT:
        case TOKEN_REMOTE_PORT:
        case TOKEN_PACKET16:
        case TOKEN_RANDOM16:
            lb[0] = 0; ub[0] = 0xFFFF;
            break;
        case TOKEN_LENGTH:
            lb[0] = sizeof(WINDIVERT_IPHDR); ub[0] = WINDIVERT_MTU_MAX;
            break;
        case TOKEN_IPV6_FLOW_LABEL:
            type = TOKEN_IPV6;
            lb[0] = 0; ub[0] = 0x000FFFFF;
            break;
        case TOKEN_IP_SRC_ADDR:
        case TOKEN_IP_DST_ADDR:
            type = TOKEN_IP;
            lb[0] = 0;
            lb[1] = 0xFFFF;
            ub[0] = 0xFFFFFFFF;
            ub[1] = 0xFFFF;
            break;
        case TOKEN_IPV6_SRC_ADDR:
        case TOKEN_IPV6_DST_ADDR:
            type = TOKEN_IPV6;
            // Fallthrough
        case TOKEN_LOCAL_ADDR:
        case TOKEN_REMOTE_ADDR:
            lb[0] = lb[1] = lb[2] = lb[3] = 0;
            ub[0] = ub[1] = ub[2] = ub[3] = 0xFFFFFFFF;
            break;
        case TOKEN_TIMESTAMP:
            lb[0] = 0;
            lb[1] = 0x80000000;
            ub[0] = 0xFFFFFFFF;
            ub[1] = 0x7FFFFFFF;
            neg_lb = TRUE;
            break;
        case TOKEN_TCP_PAYLOAD32:
            type = TOKEN_TCP;
            lb[0] = 0; ub[0] = 0xFFFFFFFF;
            break;
        case TOKEN_UDP_PAYLOAD32:
            type = TOKEN_UDP;
            lb[0] = 0; ub[0] = 0xFFFFFFFF;
            break;
        case TOKEN_IF_IDX:
        case TOKEN_SUB_IF_IDX:
        case TOKEN_RANDOM32:
        case TOKEN_PROCESS_ID:
            lb[0] = 0; ub[0] = 0xFFFFFFFF;
            break;
        case TOKEN_ENDPOINT_ID:
        case TOKEN_PARENT_ENDPOINT_ID:
            lb[0] = lb[1] = 0;
            ub[0] = ub[1] = 0xFFFFFFFF;
            break;
        default:
            return;
    }
    neg = (val->neg? TRUE: FALSE);
    result_lb = WinDivertCompare128(neg, val->val, neg_lb, lb, /*big=*/TRUE);
    result_ub = WinDivertCompare128(neg, val->val, neg_ub, ub, /*big=*/TRUE);
    switch (test->kind)
    {
        case TOKEN_EQ:
            if (result_lb < 0 || result_ub > 0)
            {
                result = FALSE;
                break;
            }
            if (eq && result_lb == 0)
            {
                result = TRUE;
                break;
            }
            return;
        case TOKEN_NEQ:
            if (result_lb < 0 || result_ub > 0)
            {
                result = TRUE;
                break;
            }
            if (eq && result_lb == 0)
            {
                result = FALSE;
                break;
            }
            return;
        case TOKEN_LT:
            if (result_ub > 0)
            {
                result = TRUE;
                break;
            }
            if (result_lb <= 0)
            {
                result = FALSE;
                break;
            }
            return;
        case TOKEN_LEQ:
            if (result_ub >= 0)
            {
                result = TRUE;
                break;
            }
            if (result_lb < 0)
            {
                result = FALSE;
                break;
            }
            return;
        case TOKEN_GT:
            if (result_ub >= 0)
            {
                result = FALSE;
                break;
            }
            if (result_lb < 0)
            {
                result = TRUE;
                break;
            }
            return;
        case TOKEN_GEQ:
            if (result_ub > 0)
            {
                result = FALSE;
                break;
            }
            if (result_lb <= 0)
            {
                result = TRUE;
                break;
            }
            return;
        default:
            return;
    }
    test->arg[0] = WinDivertMakeVar(type, NULL);
    test->arg[1] = (result? WinDivertMakeOne(): WinDivertMakeZero());
    test->kind   = TOKEN_EQ;
}

/*
 * Flatten an expression into a sequence of tests and jumps.
 */
static INT16 WinDivertFlattenExpr(PEXPR expr, INT16 *label, INT16 succ,
    INT16 fail, PEXPR *stack)
{
    INT16 succ1, fail1;
    if (succ < 0 || fail < 0)
    {
        return -1;
    }
    switch (expr->kind)
    {
        case TOKEN_AND:
            succ = WinDivertFlattenExpr(expr->arg[1], label, succ, fail, stack);
            succ = WinDivertFlattenExpr(expr->arg[0], label, succ, fail, stack);
            return succ;
        case TOKEN_OR:
            fail = WinDivertFlattenExpr(expr->arg[1], label, succ, fail, stack);
            fail = WinDivertFlattenExpr(expr->arg[0], label, succ, fail, stack);
            return fail;
        case TOKEN_QUESTION:
            fail1 = WinDivertFlattenExpr(expr->arg[2], label, succ, fail,
                stack);
            succ1 = WinDivertFlattenExpr(expr->arg[1], label, succ, fail,
                stack);
            succ = WinDivertFlattenExpr(expr->arg[0], label, succ1, fail1,
                stack);
            return succ;
        default:
            WinDivertSimplifyTest(expr);
            if (expr->kind == TOKEN_EQ &&
                expr->arg[0]->kind == TOKEN_TRUE)
            {
                return (expr->arg[1]->val[0] != 0? succ: fail);
            }
            if (*label >= WINDIVERT_FILTER_MAXLEN)
            {
                return -1;
            }
            stack[*label] = expr;
            expr->succ = succ;
            expr->fail = fail;
            succ = *label;
            *label = *label + 1;
            return succ;
    }
}

/*
 * Convert a kind to a field.
 */
static UINT32 WinDivertKindToField(KIND kind)
{
    switch (kind)
    {
        case TOKEN_ZERO:
            return WINDIVERT_FILTER_FIELD_ZERO;
        case TOKEN_EVENT:
            return WINDIVERT_FILTER_FIELD_EVENT;
        case TOKEN_RANDOM8:
            return WINDIVERT_FILTER_FIELD_RANDOM8;
        case TOKEN_RANDOM16:
            return WINDIVERT_FILTER_FIELD_RANDOM16;
        case TOKEN_RANDOM32:
            return WINDIVERT_FILTER_FIELD_RANDOM32;
        case TOKEN_PACKET:
            return WINDIVERT_FILTER_FIELD_PACKET;
        case TOKEN_PACKET16:
            return WINDIVERT_FILTER_FIELD_PACKET16;
        case TOKEN_PACKET32:
            return WINDIVERT_FILTER_FIELD_PACKET32;
        case TOKEN_LENGTH:
            return WINDIVERT_FILTER_FIELD_LENGTH;
        case TOKEN_TIMESTAMP:
            return WINDIVERT_FILTER_FIELD_TIMESTAMP;
        case TOKEN_TCP_PAYLOAD:
            return WINDIVERT_FILTER_FIELD_TCP_PAYLOAD;
        case TOKEN_TCP_PAYLOAD16:
            return WINDIVERT_FILTER_FIELD_TCP_PAYLOAD16;
        case TOKEN_TCP_PAYLOAD32:
            return WINDIVERT_FILTER_FIELD_TCP_PAYLOAD32;
        case TOKEN_UDP_PAYLOAD:
            return WINDIVERT_FILTER_FIELD_UDP_PAYLOAD;
        case TOKEN_UDP_PAYLOAD16:
            return WINDIVERT_FILTER_FIELD_UDP_PAYLOAD16;
        case TOKEN_UDP_PAYLOAD32:
            return WINDIVERT_FILTER_FIELD_UDP_PAYLOAD32;
        case TOKEN_OUTBOUND:
            return WINDIVERT_FILTER_FIELD_OUTBOUND;
        case TOKEN_INBOUND:
            return WINDIVERT_FILTER_FIELD_INBOUND;
        case TOKEN_FRAGMENT:
            return WINDIVERT_FILTER_FIELD_FRAGMENT;
        case TOKEN_IF_IDX:
            return WINDIVERT_FILTER_FIELD_IFIDX;
        case TOKEN_SUB_IF_IDX:
            return WINDIVERT_FILTER_FIELD_SUBIFIDX;
        case TOKEN_LOOPBACK:
            return WINDIVERT_FILTER_FIELD_LOOPBACK;
        case TOKEN_IMPOSTOR:
            return WINDIVERT_FILTER_FIELD_IMPOSTOR;
        case TOKEN_PROCESS_ID:
            return WINDIVERT_FILTER_FIELD_PROCESSID;
        case TOKEN_LOCAL_ADDR:
            return WINDIVERT_FILTER_FIELD_LOCALADDR;
        case TOKEN_REMOTE_ADDR:
            return WINDIVERT_FILTER_FIELD_REMOTEADDR;
        case TOKEN_LOCAL_PORT:
            return WINDIVERT_FILTER_FIELD_LOCALPORT;
        case TOKEN_REMOTE_PORT:
            return WINDIVERT_FILTER_FIELD_REMOTEPORT;
        case TOKEN_PROTOCOL:
            return WINDIVERT_FILTER_FIELD_PROTOCOL;
        case TOKEN_ENDPOINT_ID:
            return WINDIVERT_FILTER_FIELD_ENDPOINTID;
        case TOKEN_PARENT_ENDPOINT_ID:
            return WINDIVERT_FILTER_FIELD_PARENTENDPOINTID;
        case TOKEN_LAYER:
            return WINDIVERT_FILTER_FIELD_LAYER;
        case TOKEN_PRIORITY:
            return WINDIVERT_FILTER_FIELD_PRIORITY;
        case TOKEN_IP:
            return WINDIVERT_FILTER_FIELD_IP;
        case TOKEN_IPV6:
            return WINDIVERT_FILTER_FIELD_IPV6;
        case TOKEN_ICMP:
            return WINDIVERT_FILTER_FIELD_ICMP;
        case TOKEN_ICMPV6:
            return WINDIVERT_FILTER_FIELD_ICMPV6;
        case TOKEN_TCP:
            return WINDIVERT_FILTER_FIELD_TCP;
        case TOKEN_UDP:
            return WINDIVERT_FILTER_FIELD_UDP;
        case TOKEN_IP_HDR_LENGTH:
            return WINDIVERT_FILTER_FIELD_IP_HDRLENGTH;
        case TOKEN_IP_TOS:
            return WINDIVERT_FILTER_FIELD_IP_TOS;
        case TOKEN_IP_LENGTH:
            return WINDIVERT_FILTER_FIELD_IP_LENGTH;
        case TOKEN_IP_ID:
            return WINDIVERT_FILTER_FIELD_IP_ID;
        case TOKEN_IP_DF:
            return WINDIVERT_FILTER_FIELD_IP_DF;
        case TOKEN_IP_MF:
            return WINDIVERT_FILTER_FIELD_IP_MF;
        case TOKEN_IP_FRAG_OFF:
            return WINDIVERT_FILTER_FIELD_IP_FRAGOFF;
        case TOKEN_IP_TTL:
            return WINDIVERT_FILTER_FIELD_IP_TTL;
        case TOKEN_IP_PROTOCOL:
            return WINDIVERT_FILTER_FIELD_IP_PROTOCOL;
        case TOKEN_IP_CHECKSUM:
            return WINDIVERT_FILTER_FIELD_IP_CHECKSUM;
        case TOKEN_IP_SRC_ADDR:
            return WINDIVERT_FILTER_FIELD_IP_SRCADDR;
        case TOKEN_IP_DST_ADDR:
            return WINDIVERT_FILTER_FIELD_IP_DSTADDR;
        case TOKEN_IPV6_TRAFFIC_CLASS:
            return WINDIVERT_FILTER_FIELD_IPV6_TRAFFICCLASS;
        case TOKEN_IPV6_FLOW_LABEL:
            return WINDIVERT_FILTER_FIELD_IPV6_FLOWLABEL;
        case TOKEN_IPV6_LENGTH:
            return WINDIVERT_FILTER_FIELD_IPV6_LENGTH;
        case TOKEN_IPV6_NEXT_HDR:
            return WINDIVERT_FILTER_FIELD_IPV6_NEXTHDR;
        case TOKEN_IPV6_HOP_LIMIT:
            return WINDIVERT_FILTER_FIELD_IPV6_HOPLIMIT;
        case TOKEN_IPV6_SRC_ADDR:
            return WINDIVERT_FILTER_FIELD_IPV6_SRCADDR;
        case TOKEN_IPV6_DST_ADDR:
            return WINDIVERT_FILTER_FIELD_IPV6_DSTADDR;
        case TOKEN_ICMP_TYPE:
            return WINDIVERT_FILTER_FIELD_ICMP_TYPE;
        case TOKEN_ICMP_CODE:
            return WINDIVERT_FILTER_FIELD_ICMP_CODE;
        case TOKEN_ICMP_CHECKSUM:
            return WINDIVERT_FILTER_FIELD_ICMP_CHECKSUM;
        case TOKEN_ICMP_BODY:
            return WINDIVERT_FILTER_FIELD_ICMP_BODY;
        case TOKEN_ICMPV6_TYPE:
            return WINDIVERT_FILTER_FIELD_ICMPV6_TYPE;
        case TOKEN_ICMPV6_CODE:
            return WINDIVERT_FILTER_FIELD_ICMPV6_CODE;
        case TOKEN_ICMPV6_CHECKSUM:
            return WINDIVERT_FILTER_FIELD_ICMPV6_CHECKSUM;
        case TOKEN_ICMPV6_BODY:
            return WINDIVERT_FILTER_FIELD_ICMPV6_BODY;
        case TOKEN_TCP_SRC_PORT:
            return WINDIVERT_FILTER_FIELD_TCP_SRCPORT;
        case TOKEN_TCP_DST_PORT:
            return WINDIVERT_FILTER_FIELD_TCP_DSTPORT;
        case TOKEN_TCP_SEQ_NUM:
            return WINDIVERT_FILTER_FIELD_TCP_SEQNUM;
        case TOKEN_TCP_ACK_NUM:
            return WINDIVERT_FILTER_FIELD_TCP_ACKNUM;
        case TOKEN_TCP_HDR_LENGTH:
            return WINDIVERT_FILTER_FIELD_TCP_HDRLENGTH;
        case TOKEN_TCP_URG:
            return WINDIVERT_FILTER_FIELD_TCP_URG;
        case TOKEN_TCP_ACK:
            return WINDIVERT_FILTER_FIELD_TCP_ACK;
        case TOKEN_TCP_PSH:
            return WINDIVERT_FILTER_FIELD_TCP_PSH;
        case TOKEN_TCP_RST:
            return WINDIVERT_FILTER_FIELD_TCP_RST;
        case TOKEN_TCP_SYN:
            return WINDIVERT_FILTER_FIELD_TCP_SYN;
        case TOKEN_TCP_FIN:
            return WINDIVERT_FILTER_FIELD_TCP_FIN;
        case TOKEN_TCP_WINDOW:
            return WINDIVERT_FILTER_FIELD_TCP_WINDOW;
        case TOKEN_TCP_CHECKSUM:
            return WINDIVERT_FILTER_FIELD_TCP_CHECKSUM;
        case TOKEN_TCP_URG_PTR:
            return WINDIVERT_FILTER_FIELD_TCP_URGPTR;
        case TOKEN_TCP_PAYLOAD_LENGTH:
            return WINDIVERT_FILTER_FIELD_TCP_PAYLOADLENGTH;
        case TOKEN_UDP_SRC_PORT:
            return WINDIVERT_FILTER_FIELD_UDP_SRCPORT;
        case TOKEN_UDP_DST_PORT:
            return WINDIVERT_FILTER_FIELD_UDP_DSTPORT;
        case TOKEN_UDP_LENGTH:
            return WINDIVERT_FILTER_FIELD_UDP_LENGTH;
        case TOKEN_UDP_CHECKSUM:
            return WINDIVERT_FILTER_FIELD_UDP_CHECKSUM;
        case TOKEN_UDP_PAYLOAD_LENGTH:
            return WINDIVERT_FILTER_FIELD_UDP_PAYLOADLENGTH;
        default:
            return UINT32_MAX;
    }
}

/*
 * Emit a test.
 */
static void WinDivertEmitTest(PEXPR test, UINT16 offset,
    PWINDIVERT_FILTER object)
{
    PEXPR var = test->arg[0], val = test->arg[1];
    switch (test->kind)
    {
        case TOKEN_EQ:
            object->test = WINDIVERT_FILTER_TEST_EQ;
            break;
        case TOKEN_NEQ:
            object->test = WINDIVERT_FILTER_TEST_NEQ;
            break;
        case TOKEN_LT:
            object->test = WINDIVERT_FILTER_TEST_LT;
            break;
        case TOKEN_LEQ:
            object->test = WINDIVERT_FILTER_TEST_LEQ;
            break;
        case TOKEN_GT:
            object->test = WINDIVERT_FILTER_TEST_GT;
            break;
        case TOKEN_GEQ:
            object->test = WINDIVERT_FILTER_TEST_GEQ;
            break;
        default:
            return;
    }
    object->field = WinDivertKindToField(var->kind);
    object->neg = (val->neg? 1: 0);
    object->arg[0] = val->val[0];
    object->arg[1] = val->val[1];
    object->arg[2] = val->val[2];
    object->arg[3] = val->val[3];
    switch (var->kind)
    {
        case TOKEN_PACKET:
        case TOKEN_PACKET16:
        case TOKEN_PACKET32:
        case TOKEN_TCP_PAYLOAD:
        case TOKEN_TCP_PAYLOAD16:
        case TOKEN_TCP_PAYLOAD32:
        case TOKEN_UDP_PAYLOAD:
        case TOKEN_UDP_PAYLOAD16:
        case TOKEN_UDP_PAYLOAD32:
            object->arg[1] = var->val[0];
            break;
        default:
            break;
    }
    switch (test->succ)
    {
        case WINDIVERT_FILTER_RESULT_ACCEPT:
        case WINDIVERT_FILTER_RESULT_REJECT:
            object->success = test->succ;
            break;
        default:
            object->success = offset - test->succ;
            break;
    }
    switch (test->fail)
    {
        case WINDIVERT_FILTER_RESULT_ACCEPT:
        case WINDIVERT_FILTER_RESULT_REJECT:
            object->failure = test->fail;
            break;
        default:
            object->failure = offset - test->fail;
            break;
    }
    return;
}

/*
 * Emit a filter object.
 */
static void WinDivertEmitFilter(PEXPR *stack, UINT len, UINT16 label,
    PWINDIVERT_FILTER object, UINT *obj_len)
{
    UINT i;
    switch (label)
    {
        case WINDIVERT_FILTER_RESULT_ACCEPT:
        case WINDIVERT_FILTER_RESULT_REJECT:
            object[0].field   = WINDIVERT_FILTER_FIELD_ZERO;
            object[0].test    = WINDIVERT_FILTER_TEST_EQ;
            object[0].neg     = 0;
            object[0].arg[0]  = 0;
            object[0].arg[1]  = 0;
            object[0].arg[2]  = 0;
            object[0].arg[3]  = 0;
            object[0].success = label;
            object[0].failure = label;
            *obj_len = 1;
            return;
        default:
            break;
    }
    *obj_len = len + 1;
    for (i = 0; i <= len; i++)
    {
        WinDivertEmitTest(stack[len - i], label, object + i);
    }
}

/*
 * Analyze a filter object.
 */
static UINT64 WinDivertAnalyzeFilter(WINDIVERT_LAYER layer,
    PWINDIVERT_FILTER filter, UINT length)
{
    BOOL result;
    UINT64 flags = 0;

    // False filter?
    result = WinDivertCondExecFilter(filter, length,
        WINDIVERT_FILTER_FIELD_ZERO, 0);
    if (!result)
    {
        return 0;
    }

    if (layer == WINDIVERT_LAYER_NETWORK ||
        layer == WINDIVERT_LAYER_NETWORK_FORWARD)
    {
        // Inbound?
        result = WinDivertCondExecFilter(filter, length,
            WINDIVERT_FILTER_FIELD_INBOUND, 1);
        if (result)
        {
            result = WinDivertCondExecFilter(filter, length,
                WINDIVERT_FILTER_FIELD_OUTBOUND, 0);
        }
        flags |= (result? WINDIVERT_FILTER_FLAG_INBOUND: 0);

        // Outbound?
        result = WinDivertCondExecFilter(filter, length,
            WINDIVERT_FILTER_FIELD_OUTBOUND, 1);
        if (result)
        {
            result = WinDivertCondExecFilter(filter, length,
                WINDIVERT_FILTER_FIELD_INBOUND, 0);
        }
        flags |= (result? WINDIVERT_FILTER_FLAG_OUTBOUND: 0);
    }

    if (layer != WINDIVERT_LAYER_REFLECT)
    {
        // IPv4? 
        result = WinDivertCondExecFilter(filter, length,
            WINDIVERT_FILTER_FIELD_IP, 1);
        if (result)
        {   
            result = WinDivertCondExecFilter(filter, length,
                WINDIVERT_FILTER_FIELD_IPV6, 0);
        }
        flags |= (result? WINDIVERT_FILTER_FLAG_IP: 0);

        // Ipv6? 
        result = WinDivertCondExecFilter(filter, length,
            WINDIVERT_FILTER_FIELD_IPV6, 1);
        if (result)
        {   
            result = WinDivertCondExecFilter(filter, length,
                WINDIVERT_FILTER_FIELD_IP, 0);
        }
        flags |= (result? WINDIVERT_FILTER_FLAG_IPV6: 0);
    }

    // Events:
    switch (layer)
    {
        case WINDIVERT_LAYER_FLOW:
            result = WinDivertCondExecFilter(filter, length,
                WINDIVERT_FILTER_FIELD_EVENT, WINDIVERT_EVENT_FLOW_DELETED);
            flags |= (result? WINDIVERT_FILTER_FLAG_EVENT_FLOW_DELETED: 0);
            break;

        case WINDIVERT_LAYER_SOCKET:
            result = WinDivertCondExecFilter(filter, length,
                WINDIVERT_FILTER_FIELD_EVENT, WINDIVERT_EVENT_SOCKET_BIND);
            flags |= (result? WINDIVERT_FILTER_FLAG_EVENT_SOCKET_BIND: 0);
            result = WinDivertCondExecFilter(filter, length,
                WINDIVERT_FILTER_FIELD_EVENT, WINDIVERT_EVENT_SOCKET_CONNECT);
            flags |= (result? WINDIVERT_FILTER_FLAG_EVENT_SOCKET_CONNECT: 0);
            result = WinDivertCondExecFilter(filter, length,
                WINDIVERT_FILTER_FIELD_EVENT, WINDIVERT_EVENT_SOCKET_CLOSE);
            flags |= (result? WINDIVERT_FILTER_FLAG_EVENT_SOCKET_CLOSE: 0);
            result = WinDivertCondExecFilter(filter, length,
                WINDIVERT_FILTER_FIELD_EVENT, WINDIVERT_EVENT_SOCKET_LISTEN);
            flags |= (result? WINDIVERT_FILTER_FLAG_EVENT_SOCKET_LISTEN: 0);
            result = WinDivertCondExecFilter(filter, length,
                WINDIVERT_FILTER_FIELD_EVENT, WINDIVERT_EVENT_SOCKET_ACCEPT);
            flags |= (result? WINDIVERT_FILTER_FLAG_EVENT_SOCKET_ACCEPT: 0);
            break;

        default:
            break;
    }

    return flags;
}

/*
 * Execute a filter object with respect to an assumption/condition.
 * FALSE = definite reject; TRUE = maybe accept.
 */
static BOOL WinDivertCondExecFilter(PWINDIVERT_FILTER filter, UINT length,
    UINT8 field, UINT32 arg)
{
    INT16 ip;
    UINT16 succ, fail;
    BOOLEAN result[WINDIVERT_FILTER_MAXLEN];
    BOOLEAN result_succ, result_fail, result_test;

    if (length == 0)
    {
        return TRUE;
    }

    for (ip = (INT16)(length-1); ip >= 0; ip--)
    {
        succ = filter[ip].success;
        switch (succ)
        {
            case WINDIVERT_FILTER_RESULT_ACCEPT:
                result_succ = TRUE;
                break;
            case WINDIVERT_FILTER_RESULT_REJECT:
                result_succ = FALSE;
                break;
            default:
                result_succ = (succ > ip && succ < length? result[succ]: TRUE);
                break;
        }

        fail = filter[ip].failure;
        switch (fail)
        {
            case WINDIVERT_FILTER_RESULT_ACCEPT:
                result_fail = TRUE;
                break;
            case WINDIVERT_FILTER_RESULT_REJECT:
                result_fail = FALSE;
                break;
            default:
                result_fail = (fail > ip && fail < length? result[fail]: TRUE);
                break;
        }

        if (result_succ && result_fail)
        {
            result[ip] = TRUE;
        }
        else if (!result_succ && !result_fail)
        {
            result[ip] = FALSE;
        }
        else if (filter[ip].field == field)
        {
            if (filter[ip].neg || filter[ip].arg[1] != 0 ||
                filter[ip].arg[2] != 0 || filter[ip].arg[3] != 0)
            {
                result[ip] = TRUE;
            }
            else
            {
                switch (filter[ip].test)
                {
                    case WINDIVERT_FILTER_TEST_EQ:
                        result_test = (arg == filter[ip].arg[0]);
                        break;
                    case WINDIVERT_FILTER_TEST_NEQ:
                        result_test = (arg != filter[ip].arg[0]);
                        break;
                    case WINDIVERT_FILTER_TEST_LT:
                        result_test = (arg < filter[ip].arg[0]);
                        break;
                    case WINDIVERT_FILTER_TEST_LEQ:
                        result_test = (arg <= filter[ip].arg[0]);
                        break;
                    case WINDIVERT_FILTER_TEST_GT:
                        result_test = (arg > filter[ip].arg[0]);
                        break;
                    case WINDIVERT_FILTER_TEST_GEQ:
                        result_test = (arg >= filter[ip].arg[0]);
                        break;
                    default:
                        result[ip] = TRUE;
                        continue;
                }
                result[ip] = (result_test? result_succ: result_fail);
            }
        }
        else
        {
            result[ip] = TRUE;
        }
    }

    return result[0];
}

/*
 * Compile a filter string into an executable filter object.
 */
static ERROR WinDivertCompileFilter(const char *filter, HANDLE pool,
    WINDIVERT_LAYER layer, PWINDIVERT_FILTER object, UINT *obj_len)
{
    TOKEN *tokens;
    PEXPR *stack;
    PEXPR expr;
    UINT i, max_depth, pos;
    INT16 label;
    const SIZE_T tokens_size = 5 * WINDIVERT_FILTER_MAXLEN;
    ERROR error;

    // Check for pre-compiled filter object:
    if (filter[0] == '@')
    {
        WINDIVERT_STREAM stream;
        stream.data     = (char *)filter;
        stream.pos      = 0;
        stream.max      = UINT_MAX;
        stream.overflow = FALSE;

        if (!WinDivertDeserializeFilter(&stream, object, obj_len))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return MAKE_ERROR(WINDIVERT_ERROR_BAD_OBJECT, 0);
        }
        return MAKE_ERROR(WINDIVERT_ERROR_NONE, 0);
    }

    tokens = (TOKEN *)HeapAlloc(pool, 0, tokens_size * sizeof(TOKEN));
    stack  = (PEXPR *)HeapAlloc(pool, 0,
        WINDIVERT_FILTER_MAXLEN * sizeof(PEXPR));
    if (tokens == NULL || stack == NULL)
    {
        return MAKE_ERROR(WINDIVERT_ERROR_NO_MEMORY, 0);
    }

    // Tokenize the filter string:
    error = WinDivertTokenizeFilter(filter, layer, tokens, tokens_size-1);
    if (IS_ERROR(error))
    {
        return error;
    }

    // Parse the filter into an expression:
    i = 0;
    max_depth = 1024;
    expr = WinDivertParseFilter(pool, tokens, &i, max_depth, FALSE, &error);
    if (expr == NULL)
    {
        return error;
    }
    if (tokens[i].kind != TOKEN_END)
    {
        pos = tokens[i].pos;
        return MAKE_ERROR(WINDIVERT_ERROR_UNEXPECTED_TOKEN, pos);
    }

    // Construct the filter tree:
    label = 0;
    label = WinDivertFlattenExpr(expr, &label, WINDIVERT_FILTER_RESULT_ACCEPT,
        WINDIVERT_FILTER_RESULT_REJECT, stack);
    if (label < 0)
    {
        return MAKE_ERROR(WINDIVERT_ERROR_TOO_LONG, 0);
    }

    // Emit the final object.
    if (object != NULL)
    {
        WinDivertEmitFilter(stack, label, label, object, obj_len);
    }

    return MAKE_ERROR(WINDIVERT_ERROR_NONE, 0);
}

/*
 * Convert a error code into a user readable string.
 */
static const char *WinDivertErrorString(UINT code)
{
    switch (code)
    {
        case WINDIVERT_ERROR_NONE:
            return "No error";
        case WINDIVERT_ERROR_NO_MEMORY:
            return "Out of memory";
        case WINDIVERT_ERROR_TOO_DEEP:
            return "Filter expression too deep";
        case WINDIVERT_ERROR_TOO_LONG:
            return "Filter expression too long";
        case WINDIVERT_ERROR_BAD_TOKEN:
            return "Filter expression contains a bad token";
        case WINDIVERT_ERROR_BAD_TOKEN_FOR_LAYER:
            return "Filter expression contains a bad token for layer";
        case WINDIVERT_ERROR_UNEXPECTED_TOKEN:
            return "Filter expression parse error";
        case WINDIVERT_ERROR_INDEX_OOB:
            return "Filter expression array index is out-of-bounds";
        case WINDIVERT_ERROR_OUTPUT_TOO_SHORT:
            return "Filter object buffer is too short";
        case WINDIVERT_ERROR_BAD_OBJECT:
            return "Filter object is invalid";
        case WINDIVERT_ERROR_ASSERTION_FAILED:
            return "Internal assertion failed";
        default:
            return "Unknown error";
    }
}

/*
 * Compile the given filter string.
 */
BOOL WinDivertHelperCompileFilter(const char *filter_str, WINDIVERT_LAYER layer,
    char *object, UINT obj_len, const char **error, UINT *error_pos)
{
    HANDLE pool;
    ERROR err;

    if (filter_str == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pool = HeapCreate(HEAP_NO_SERIALIZE, WINDIVERT_MIN_POOL_SIZE,
        WINDIVERT_MAX_POOL_SIZE);
    if (pool == NULL)
    {
        return FALSE;
    }

    SetLastError(ERROR_SUCCESS);
    if (object == NULL)
    {
        err = WinDivertCompileFilter(filter_str, pool, layer, NULL, NULL);
    }
    else
    {
        WINDIVERT_FILTER *filter_obj = HeapAlloc(pool, 0,
            WINDIVERT_FILTER_MAXLEN * sizeof(WINDIVERT_FILTER));
        UINT filter_obj_len;
        err = WINDIVERT_ERROR_NO_MEMORY;
        if (filter_obj != NULL)
        {
            err = WinDivertCompileFilter(filter_str, pool, layer, filter_obj,
                &filter_obj_len);
            if (!IS_ERROR(err))
            {
                WINDIVERT_STREAM stream;
                stream.data     = object;
                stream.pos      = 0;
                stream.max      = obj_len;
                stream.overflow = FALSE;
            
                WinDivertSerializeFilter(&stream, filter_obj, filter_obj_len);
                if (stream.overflow)
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    err = MAKE_ERROR(WINDIVERT_ERROR_OUTPUT_TOO_SHORT, 0);
                }
            }
        }
    }
    HeapDestroy(pool);

    if (error != NULL)
    {
        *error = WinDivertErrorString(GET_CODE(err));
    }
    if (error_pos != NULL)
    {
        *error_pos = GET_POS(err);
    }
    return !IS_ERROR(err);
}

/*
 * Get packet/payload data.
 */
static BOOL WinDivertGetData(const VOID *packet, UINT packet_len, INT min,
    INT max, INT idx, PVOID data, UINT size)
{
    idx += (idx < 0? max: min);
    if (idx < min || idx > (max - (INT)size))
    {
        return FALSE;
    }

    memcpy(data, (UINT8 *)packet + idx, size);
    return TRUE;
}

/*
 * Evaluate the given filter with the given packet as input.
 */
BOOL WinDivertHelperEvalFilter(const char *filter, const VOID *packet,
    UINT packet_len, const WINDIVERT_ADDRESS *addr)
{
    ERROR err;
    DWORD error;
    WINDIVERT_PACKET info;
    PWINDIVERT_IPHDR ip_header = NULL;
    PWINDIVERT_IPV6HDR ipv6_header = NULL;
    PWINDIVERT_ICMPHDR icmp_header = NULL;
    PWINDIVERT_ICMPV6HDR icmpv6_header = NULL;
    PWINDIVERT_TCPHDR tcp_header = NULL;
    PWINDIVERT_UDPHDR udp_header = NULL;
    const WINDIVERT_DATA_NETWORK *network_data = NULL;
    const WINDIVERT_DATA_FLOW *flow_data = NULL;
    const WINDIVERT_DATA_SOCKET *socket_data = NULL;
    const WINDIVERT_DATA_REFLECT *reflect_data = NULL;
    BOOL fragment = FALSE;
    UINT8 protocol = 0;
    UINT header_len = 0, payload_len = 0;
    int result;
    HANDLE pool;
    WINDIVERT_FILTER *object;
    UINT obj_len;

    if (filter == NULL || addr == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    switch (addr->Layer)
    {
        case WINDIVERT_LAYER_NETWORK:
        case WINDIVERT_LAYER_NETWORK_FORWARD:
            if (packet == NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            if (!WinDivertHelperParsePacketEx((PVOID)packet, packet_len, &info))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            protocol      = info.Protocol;
            ip_header     = info.IPHeader;
            ipv6_header   = info.IPv6Header;
            icmp_header   = info.ICMPHeader;
            icmpv6_header = info.ICMPv6Header;
            tcp_header    = info.TCPHeader;
            udp_header    = info.UDPHeader;
            payload_len   = info.PayloadLength;
            header_len    = info.HeaderLength;
            fragment      = info.Fragment;
            if ((addr->IPv6 && ipv6_header == NULL) ||
                (!addr->IPv6 && ip_header == NULL))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            break;
        case WINDIVERT_LAYER_FLOW:
        case WINDIVERT_LAYER_SOCKET:
            if (packet != NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            break;
        case WINDIVERT_LAYER_REFLECT:
            break;
        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
    }
    switch (addr->Layer)
    {
        case WINDIVERT_LAYER_NETWORK:
        case WINDIVERT_LAYER_NETWORK_FORWARD:
            network_data = &addr->Network;
            break;
        case WINDIVERT_LAYER_FLOW:
            flow_data = &addr->Flow;
            break;
        case WINDIVERT_LAYER_SOCKET:
            socket_data = &addr->Socket;
            break;
        case WINDIVERT_LAYER_REFLECT:
            reflect_data = &addr->Reflect;
            break;
        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
    }

    pool = HeapCreate(HEAP_NO_SERIALIZE, WINDIVERT_MIN_POOL_SIZE,
        WINDIVERT_MAX_POOL_SIZE);
    if (pool == NULL)
    {
        return FALSE;
    }
    object = HeapAlloc(pool, 0,
        WINDIVERT_FILTER_MAXLEN * sizeof(WINDIVERT_FILTER));
    if (object == NULL)
    {
        goto WinDivertHelperEvalFilterError;
    }
    err = WinDivertCompileFilter(filter, pool, addr->Layer, object, &obj_len);
    if (IS_ERROR(err))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto WinDivertHelperEvalFilterError;
    }

    result = WinDivertExecuteFilter(
        object,
        addr->Layer,
        addr->Timestamp,
        addr->Event,
        (addr->IPv6 != 0? FALSE: TRUE),
        (addr->Outbound != 0? TRUE: FALSE),
        (addr->Loopback != 0? TRUE: FALSE),
        (addr->Impostor != 0? TRUE: FALSE),
        fragment,
        network_data,
        flow_data,
        socket_data,
        reflect_data,
        ip_header,
        ipv6_header,
        icmp_header,
        icmpv6_header,
        tcp_header,
        udp_header,
        protocol,
        packet,
        packet_len,
        header_len,
        payload_len);

    HeapDestroy(pool);
    if (result < 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    else if (result == 0)
    {
        SetLastError(0);
        return FALSE;
    }
    else
    {
        return TRUE;
    }

WinDivertHelperEvalFilterError:
    error = GetLastError();
    HeapDestroy(pool);
    SetLastError(error);
    return FALSE;
}

/*
 * Get a char from a stream.
 */
static char WinDivertGetChar(PWINDIVERT_STREAM stream)
{
    char c;
    if (stream->pos >= stream->max)
    {
        stream->overflow = TRUE;
        return EOF;
    }
    c = stream->data[stream->pos];
    stream->pos++;
    return c;
}

/*
 * Decode a digit.
 */
static BOOL WinDivertDecodeDigit(char c, UINT8 *digit, BOOL *final)
{
    if (c >= '0' && c <= '9')
    {
        *digit = c - '0';
        *final = FALSE;
        return TRUE;
    }
    if (c >= 'A' && c <= 'V')
    {
        *digit = c - 'A' + 10;
        *final = FALSE;
        return TRUE;
    }
    if (c >= 'W' && c <= 'Z')
    {
        *digit = c - 'W';
        *final = TRUE;
        return TRUE;
    }
    if (c >= 'a' && c <= 'z')
    {
        *digit = c - 'a' + 4;
        *final = TRUE;
        return TRUE;
    }
    if (c == '+')
    {
        *digit = 30;
        *final = TRUE;
        return TRUE;
    }
    if (c == '=')
    {
        *digit = 31;
        *final = TRUE;
        return TRUE;
    }
    return FALSE;
}

/*
 * Deserialize a number.
 */
static BOOL WinDivertDeserializeNumber(PWINDIVERT_STREAM stream, UINT max_len,
    UINT32 *result)
{
    UINT32 i, val = 0;
    UINT8 digit;
    BOOL final;
    char c;

    for (i = 0; i < max_len; i++)
    {
        if ((val & 0xF8000000) != 0)
        {
            return FALSE;       // Overflow
        }
        val <<= 5;
        c = WinDivertGetChar(stream);
        if (!WinDivertDecodeDigit(c, &digit, &final))
        {
            return FALSE;
        }
        val += digit;
        if (final)
        {
            *result = val;
            return TRUE;
        }
    }
    return FALSE;
}

/*
 * Deserialize a label.
 */
static BOOL WinDivertDeserializeLabel(PWINDIVERT_STREAM stream, UINT16 *label)
{
    UINT32 val;

    switch (WinDivertGetChar(stream))
    {
        case 'A':
            *label = WINDIVERT_FILTER_RESULT_ACCEPT;
            return TRUE;
        case 'X':
            *label = WINDIVERT_FILTER_RESULT_REJECT;
            return TRUE;
        case 'L':
            if (!WinDivertDeserializeNumber(stream, 2, &val) ||
                    val > WINDIVERT_FILTER_MAXLEN)
            {
                return FALSE;
            }
            *label = (UINT16)val;
            return TRUE;
        default:
            return FALSE;
    }
}

/*
 * Deserialize a test.
 */
static BOOL WinDivertDeserializeTest(PWINDIVERT_STREAM stream,
    PWINDIVERT_FILTER filter)
{
    UINT32 val;
    UINT16 success, failure;
    UINT i;

    if (WinDivertGetChar(stream) != '_')
    {
        return FALSE;
    }

    if (!WinDivertDeserializeNumber(stream, 2, &val) ||
            val > WINDIVERT_FILTER_FIELD_MAX)
    {
        return FALSE;
    }
    filter->field = (UINT16)val;

    if (!WinDivertDeserializeNumber(stream, 2, &val) ||
            val > WINDIVERT_FILTER_TEST_MAX)
    {
        return FALSE;
    }
    filter->test = (UINT16)val;

    if (!WinDivertDeserializeNumber(stream, 1, &val) || val > 1)
    {
        return FALSE;
    }
    filter->neg = (UINT16)val;

    if (!WinDivertDeserializeNumber(stream, 7, &filter->arg[0]))
    {
        return FALSE;
    }

    switch (filter->field)
    {
        case WINDIVERT_FILTER_FIELD_IPV6_SRCADDR:
        case WINDIVERT_FILTER_FIELD_IPV6_DSTADDR:
        case WINDIVERT_FILTER_FIELD_LOCALADDR:
        case WINDIVERT_FILTER_FIELD_REMOTEADDR:
            for (i = 1; i < 4; i++)
            {
                if (!WinDivertDeserializeNumber(stream, 7, &filter->arg[i]))
                {
                    return FALSE;
                }
            }
            break;
        case WINDIVERT_FILTER_FIELD_ENDPOINTID:
        case WINDIVERT_FILTER_FIELD_PARENTENDPOINTID:
        case WINDIVERT_FILTER_FIELD_TIMESTAMP:
            if (!WinDivertDeserializeNumber(stream, 7, &filter->arg[1]))
            {
                return FALSE;
            }
            filter->arg[2] = filter->arg[3] = 0;
            break;
        case WINDIVERT_FILTER_FIELD_IP_SRCADDR:
        case WINDIVERT_FILTER_FIELD_IP_DSTADDR:
            filter->arg[1] = 0x0000FFFF;
            filter->arg[2] = filter->arg[3] = 0;
            break;
        case WINDIVERT_FILTER_FIELD_PACKET:
        case WINDIVERT_FILTER_FIELD_PACKET16:
        case WINDIVERT_FILTER_FIELD_PACKET32:
        case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD:
        case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD16:
        case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD32:
        case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD:
        case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD16:
        case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD32:
            if (!WinDivertDeserializeNumber(stream, 7, &val))
            {
                return FALSE;
            }
            filter->arg[1] = (UINT32)((INT)val - UINT16_MAX);
            filter->arg[2] = filter->arg[3] = 0;
            break;
        default:
            filter->arg[1] = filter->arg[2] = filter->arg[3] = 0;
            break;
    }

    if (!WinDivertDeserializeLabel(stream, &success) ||
        !WinDivertDeserializeLabel(stream, &failure))
    {
        return FALSE;
    }
    filter->success = success;
    filter->failure = failure;
    return TRUE;
}

/*
 * Deserialize a filter header.
 */
static BOOL WinDivertDeserializeFilterHeader(PWINDIVERT_STREAM stream,
    UINT *length)
{
    UINT32 version, length32;

    if (WinDivertGetChar(stream) != '@' ||
        WinDivertGetChar(stream) != 'W' ||
        WinDivertGetChar(stream) != 'i' ||
        WinDivertGetChar(stream) != 'n' ||
        WinDivertGetChar(stream) != 'D' ||
        WinDivertGetChar(stream) != 'i' ||
        WinDivertGetChar(stream) != 'v' ||
        WinDivertGetChar(stream) != '_')
    {
        return FALSE;
    }

    if (!WinDivertDeserializeNumber(stream, 4, &version) || (version != 0))
    {
        return FALSE;
    }

    if (!WinDivertDeserializeNumber(stream, 2, &length32) ||
            length32 == 0 || length32 > WINDIVERT_FILTER_MAXLEN)
    {
        return FALSE;
    }
    *length = length32;

    return TRUE;
}

/*
 * Deserialize a filter.
 */
static BOOL WinDivertDeserializeFilter(PWINDIVERT_STREAM stream,
    PWINDIVERT_FILTER filter, UINT *length)
{
    UINT i;

    if (!WinDivertDeserializeFilterHeader(stream, length))
    {
        return FALSE;
    }

    for (i = 0; i < *length; i++)
    {
        if (!WinDivertDeserializeTest(stream, filter + i))
        {
            return FALSE;
        }
        switch (filter[i].success)
        {
            case WINDIVERT_FILTER_RESULT_ACCEPT:
            case WINDIVERT_FILTER_RESULT_REJECT:
                break;
            default:
                if (filter[i].success <= i || filter[i].success >= *length)
                {
                    return FALSE;
                }
        }
        switch (filter[i].failure)
        {
            case WINDIVERT_FILTER_RESULT_ACCEPT:
            case WINDIVERT_FILTER_RESULT_REJECT:
                break;
            default:
                if (filter[i].failure <= i || filter[i].failure >= *length)
                {
                    return FALSE;
                }
        }
    }

    if (WinDivertGetChar(stream) != '\0')
    {
        return FALSE;
    }

    return TRUE;
}

/*
 * Decompile a test into an expression.
 */
static PEXPR WinDivertDecompileTest(HANDLE pool, PWINDIVERT_FILTER test)
{
    KIND kind;
    PEXPR var, val, expr;
    UINT32 tmp[4];
    ERROR error;

    switch (test->field)
    {
        case WINDIVERT_FILTER_FIELD_ZERO:
            kind = TOKEN_ZERO; break;
        case WINDIVERT_FILTER_FIELD_EVENT:
            kind = TOKEN_EVENT; break;
        case WINDIVERT_FILTER_FIELD_RANDOM8:
            kind = TOKEN_RANDOM8; break;
        case WINDIVERT_FILTER_FIELD_RANDOM16:
            kind = TOKEN_RANDOM16; break;
        case WINDIVERT_FILTER_FIELD_RANDOM32:
            kind = TOKEN_RANDOM32; break;
        case WINDIVERT_FILTER_FIELD_PACKET:
            kind = TOKEN_PACKET; break;
        case WINDIVERT_FILTER_FIELD_PACKET16:
            kind = TOKEN_PACKET16; break;
        case WINDIVERT_FILTER_FIELD_PACKET32:
            kind = TOKEN_PACKET32; break;
        case WINDIVERT_FILTER_FIELD_LENGTH:
            kind = TOKEN_LENGTH; break;
        case WINDIVERT_FILTER_FIELD_TIMESTAMP:
            kind = TOKEN_TIMESTAMP; break;
        case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD:
            kind = TOKEN_TCP_PAYLOAD; break;
        case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD16:
            kind = TOKEN_TCP_PAYLOAD16; break;
        case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD32:
            kind = TOKEN_TCP_PAYLOAD32; break;
        case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD:
            kind = TOKEN_UDP_PAYLOAD; break;
        case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD16:
            kind = TOKEN_UDP_PAYLOAD16; break;
        case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD32:
            kind = TOKEN_UDP_PAYLOAD32; break;
        case WINDIVERT_FILTER_FIELD_INBOUND:
            kind = TOKEN_INBOUND; break;
        case WINDIVERT_FILTER_FIELD_OUTBOUND:
            kind = TOKEN_OUTBOUND; break;
        case WINDIVERT_FILTER_FIELD_FRAGMENT:
            kind = TOKEN_FRAGMENT; break;
        case WINDIVERT_FILTER_FIELD_IFIDX:
            kind = TOKEN_IF_IDX; break;
        case WINDIVERT_FILTER_FIELD_SUBIFIDX:
            kind = TOKEN_SUB_IF_IDX; break;
        case WINDIVERT_FILTER_FIELD_IP:
            kind = TOKEN_IP; break;
        case WINDIVERT_FILTER_FIELD_IPV6:
            kind = TOKEN_IPV6; break;
        case WINDIVERT_FILTER_FIELD_ICMP:
            kind = TOKEN_ICMP; break;
        case WINDIVERT_FILTER_FIELD_TCP:
            kind = TOKEN_TCP; break;
        case WINDIVERT_FILTER_FIELD_UDP:
            kind = TOKEN_UDP; break;
        case WINDIVERT_FILTER_FIELD_ICMPV6:
            kind = TOKEN_ICMPV6; break;
        case WINDIVERT_FILTER_FIELD_IP_HDRLENGTH:
            kind = TOKEN_IP_HDR_LENGTH; break;
        case WINDIVERT_FILTER_FIELD_IP_TOS:
            kind = TOKEN_IP_TOS; break;
        case WINDIVERT_FILTER_FIELD_IP_LENGTH:
            kind = TOKEN_IP_LENGTH; break;
        case WINDIVERT_FILTER_FIELD_IP_ID:
            kind = TOKEN_IP_ID; break;
        case WINDIVERT_FILTER_FIELD_IP_DF:
            kind = TOKEN_IP_DF; break;
        case WINDIVERT_FILTER_FIELD_IP_MF:
            kind = TOKEN_IP_MF; break;
        case WINDIVERT_FILTER_FIELD_IP_FRAGOFF:
            kind = TOKEN_IP_FRAG_OFF; break;
        case WINDIVERT_FILTER_FIELD_IP_TTL:
            kind = TOKEN_IP_TTL; break;
        case WINDIVERT_FILTER_FIELD_IP_PROTOCOL:
            kind = TOKEN_IP_PROTOCOL; break;
        case WINDIVERT_FILTER_FIELD_IP_CHECKSUM:
            kind = TOKEN_IP_CHECKSUM; break;
        case WINDIVERT_FILTER_FIELD_IP_SRCADDR:
            kind = TOKEN_IP_SRC_ADDR; break;
        case WINDIVERT_FILTER_FIELD_IP_DSTADDR:
            kind = TOKEN_IP_DST_ADDR; break;
        case WINDIVERT_FILTER_FIELD_IPV6_TRAFFICCLASS:
            kind = TOKEN_IPV6_TRAFFIC_CLASS; break;
        case WINDIVERT_FILTER_FIELD_IPV6_FLOWLABEL:
            kind = TOKEN_IPV6_FLOW_LABEL; break;
        case WINDIVERT_FILTER_FIELD_IPV6_LENGTH:
            kind = TOKEN_IPV6_LENGTH; break;
        case WINDIVERT_FILTER_FIELD_IPV6_NEXTHDR:
            kind = TOKEN_IPV6_NEXT_HDR; break;
        case WINDIVERT_FILTER_FIELD_IPV6_HOPLIMIT:
            kind = TOKEN_IPV6_HOP_LIMIT; break;
        case WINDIVERT_FILTER_FIELD_IPV6_SRCADDR:
            kind = TOKEN_IPV6_SRC_ADDR; break;
        case WINDIVERT_FILTER_FIELD_IPV6_DSTADDR:
            kind = TOKEN_IPV6_DST_ADDR; break;
        case WINDIVERT_FILTER_FIELD_ICMP_TYPE:
            kind = TOKEN_ICMP_TYPE; break;
        case WINDIVERT_FILTER_FIELD_ICMP_CODE:
            kind = TOKEN_ICMP_CODE; break;
        case WINDIVERT_FILTER_FIELD_ICMP_CHECKSUM:
            kind = TOKEN_ICMP_CHECKSUM; break;
        case WINDIVERT_FILTER_FIELD_ICMP_BODY:
            kind = TOKEN_ICMP_BODY; break;
        case WINDIVERT_FILTER_FIELD_ICMPV6_TYPE:
            kind = TOKEN_ICMPV6_TYPE; break;
        case WINDIVERT_FILTER_FIELD_ICMPV6_CODE:
            kind = TOKEN_ICMPV6_CODE; break;
        case WINDIVERT_FILTER_FIELD_ICMPV6_CHECKSUM:
            kind = TOKEN_ICMPV6_CHECKSUM; break;
        case WINDIVERT_FILTER_FIELD_ICMPV6_BODY:
            kind = TOKEN_ICMPV6_BODY; break;
        case WINDIVERT_FILTER_FIELD_TCP_SRCPORT:
            kind = TOKEN_TCP_SRC_PORT; break;
        case WINDIVERT_FILTER_FIELD_TCP_DSTPORT:
            kind = TOKEN_TCP_DST_PORT; break;
        case WINDIVERT_FILTER_FIELD_TCP_SEQNUM:
            kind = TOKEN_TCP_SEQ_NUM; break;
        case WINDIVERT_FILTER_FIELD_TCP_ACKNUM:
            kind = TOKEN_TCP_ACK_NUM; break;
        case WINDIVERT_FILTER_FIELD_TCP_HDRLENGTH:
            kind = TOKEN_TCP_HDR_LENGTH; break;
        case WINDIVERT_FILTER_FIELD_TCP_URG:
            kind = TOKEN_TCP_URG; break;
        case WINDIVERT_FILTER_FIELD_TCP_ACK:
            kind = TOKEN_TCP_ACK; break;
        case WINDIVERT_FILTER_FIELD_TCP_PSH:
            kind = TOKEN_TCP_PSH; break;
        case WINDIVERT_FILTER_FIELD_TCP_RST:
            kind = TOKEN_TCP_RST; break;
        case WINDIVERT_FILTER_FIELD_TCP_SYN:
            kind = TOKEN_TCP_SYN; break;
        case WINDIVERT_FILTER_FIELD_TCP_FIN:
            kind = TOKEN_TCP_FIN; break;
        case WINDIVERT_FILTER_FIELD_TCP_WINDOW:
            kind = TOKEN_TCP_WINDOW; break;
        case WINDIVERT_FILTER_FIELD_TCP_CHECKSUM:
            kind = TOKEN_TCP_CHECKSUM; break;
        case WINDIVERT_FILTER_FIELD_TCP_URGPTR:
            kind = TOKEN_TCP_URG_PTR; break;
        case WINDIVERT_FILTER_FIELD_TCP_PAYLOADLENGTH:
            kind = TOKEN_TCP_PAYLOAD_LENGTH; break;
        case WINDIVERT_FILTER_FIELD_UDP_SRCPORT:
            kind = TOKEN_UDP_SRC_PORT; break;
        case WINDIVERT_FILTER_FIELD_UDP_DSTPORT:
            kind = TOKEN_UDP_DST_PORT; break;
        case WINDIVERT_FILTER_FIELD_UDP_LENGTH:
            kind = TOKEN_UDP_LENGTH; break;
        case WINDIVERT_FILTER_FIELD_UDP_CHECKSUM:
            kind = TOKEN_UDP_CHECKSUM; break;
        case WINDIVERT_FILTER_FIELD_UDP_PAYLOADLENGTH:
            kind = TOKEN_UDP_PAYLOAD_LENGTH; break;
        case WINDIVERT_FILTER_FIELD_LOOPBACK:
            kind = TOKEN_LOOPBACK; break;
        case WINDIVERT_FILTER_FIELD_IMPOSTOR:
            kind = TOKEN_IMPOSTOR; break;
        case WINDIVERT_FILTER_FIELD_PROCESSID:
            kind = TOKEN_PROCESS_ID; break;
        case WINDIVERT_FILTER_FIELD_LOCALADDR:
            kind = TOKEN_LOCAL_ADDR; break;
        case WINDIVERT_FILTER_FIELD_REMOTEADDR:
            kind = TOKEN_REMOTE_ADDR; break;
        case WINDIVERT_FILTER_FIELD_LOCALPORT:
            kind = TOKEN_LOCAL_PORT; break;
        case WINDIVERT_FILTER_FIELD_REMOTEPORT:
            kind = TOKEN_REMOTE_PORT; break;
        case WINDIVERT_FILTER_FIELD_PROTOCOL:
            kind = TOKEN_PROTOCOL; break;
        case WINDIVERT_FILTER_FIELD_ENDPOINTID:
            kind = TOKEN_ENDPOINT_ID; break;
        case WINDIVERT_FILTER_FIELD_PARENTENDPOINTID:
            kind = TOKEN_PARENT_ENDPOINT_ID; break;
        case WINDIVERT_FILTER_FIELD_LAYER:
            kind = TOKEN_LAYER; break;
        case WINDIVERT_FILTER_FIELD_PRIORITY:
            kind = TOKEN_PRIORITY; break;
        default:
            return NULL;
    }

    switch (kind)
    {
        case TOKEN_PACKET:
        case TOKEN_PACKET16:
        case TOKEN_PACKET32:
        case TOKEN_TCP_PAYLOAD:
        case TOKEN_TCP_PAYLOAD16:
        case TOKEN_TCP_PAYLOAD32:
        case TOKEN_UDP_PAYLOAD:
        case TOKEN_UDP_PAYLOAD16:
        case TOKEN_UDP_PAYLOAD32:
            var = WinDivertMakeArrayVar(pool, kind, test->arg[1], &error);
            if (var == NULL)
            {
                return NULL;
            }
            tmp[0] = test->arg[0];
            tmp[1] = tmp[2] = tmp[3] = 0;
            val = WinDivertMakeNumber(pool, tmp, &error);
            if (val == NULL)
            {
                return NULL;
            }
            break;
        default:
            var = WinDivertMakeVar(kind, &error);
            if (var == NULL)
            {
                return NULL;
            }
            val = WinDivertMakeNumber(pool, test->arg, &error);
            if (val == NULL)
            {
                return NULL;
            }
            if (test->neg)
            {
                val->neg = TRUE;
            }
            break;
    }

    switch (test->test)
    {
        case WINDIVERT_FILTER_TEST_EQ:
            kind = TOKEN_EQ; break;
        case WINDIVERT_FILTER_TEST_NEQ:
            kind = TOKEN_NEQ; break;
        case WINDIVERT_FILTER_TEST_LT:
            kind = TOKEN_LT; break;
        case WINDIVERT_FILTER_TEST_LEQ:
            kind = TOKEN_LEQ; break;
        case WINDIVERT_FILTER_TEST_GT:
            kind = TOKEN_GT; break;
        case WINDIVERT_FILTER_TEST_GEQ:
            kind = TOKEN_GEQ; break;
        default:
            return NULL;
    }

    expr = WinDivertMakeBinOp(pool, kind, var, val, &error);
    if (expr == NULL)
    {
        return NULL;
    }
    expr->succ = test->success;
    expr->fail = test->failure;
    return expr;
}

/*
 * Dereference an expression.
 */
static void WinDivertDerefExpr(PEXPR *exprs, UINT16 i)
{
    switch (i)
    {
        case WINDIVERT_FILTER_RESULT_ACCEPT:
        case WINDIVERT_FILTER_RESULT_REJECT:
            return;
        default:
            exprs[i]->count--;
            if (exprs[i]->count == 0)
            {
                exprs[i] = NULL;
            }
            return;
    }
}

/*
 * Apply an and/or simplification for WinDivertCoalesceAndOr().
 */
static PEXPR WinDivertSimplifyAndOr(HANDLE pool, PEXPR *exprs, PEXPR expr,
    BOOL and, UINT16 next, UINT16 other)
{
    PEXPR next_expr = exprs[next], new_expr;
    ERROR error;

    new_expr = WinDivertMakeBinOp(pool, (and? TOKEN_AND: TOKEN_OR), expr,
        next_expr, &error);
    if (new_expr == NULL)
    {
        return NULL;
    }
    new_expr->succ   = next_expr->succ;
    new_expr->fail   = next_expr->fail;
    new_expr->count  = expr->count;
    WinDivertDerefExpr(exprs, next);
    WinDivertDerefExpr(exprs, other);
    return new_expr;
}

/*
 * Detect and coalesce and/or (& (?:)) expression patterns.
 */
static PEXPR WinDivertCoalesceAndOr(HANDLE pool, PEXPR *exprs, UINT16 i,
    ERROR *error)
{
    PEXPR expr, next_expr, new_expr;
    BOOL singleton;
    static const EXPR true_expr  = {{{0}}, TOKEN_TRUE};
    static const EXPR false_expr = {{{0}}, TOKEN_FALSE};
    
    expr = exprs[i];
    while (TRUE)
    {
        if (expr == NULL || expr->count == 0)
        {
            return NULL;
        }

        singleton = FALSE;
        switch (expr->succ)
        {
            case WINDIVERT_FILTER_RESULT_ACCEPT:
            case WINDIVERT_FILTER_RESULT_REJECT:
                break;
            default:
                next_expr = exprs[expr->succ];
                if (next_expr->count != 1)
                {
                    break;
                }
                singleton = TRUE;
                if (next_expr->fail == expr->fail)
                {
                    expr = WinDivertSimplifyAndOr(pool, exprs, expr,
                        /*and=*/TRUE, expr->succ, expr->fail);
                    continue;
                }
                else if (next_expr->succ == expr->fail)
                {
                    new_expr = (PEXPR)HeapAlloc(pool, HEAP_ZERO_MEMORY,
                        sizeof(EXPR));
                    if (new_expr == NULL)
                    {
                        return NULL;
                    }
                    new_expr->kind   = TOKEN_QUESTION;
                    new_expr->arg[0] = expr;
                    new_expr->arg[1] = next_expr;
                    new_expr->arg[2] = (PEXPR)&true_expr;
                    new_expr->succ   = next_expr->succ;
                    new_expr->fail   = next_expr->fail;
                    new_expr->count  = expr->count;
                    WinDivertDerefExpr(exprs, expr->succ);
                    WinDivertDerefExpr(exprs, expr->fail);
                    expr = new_expr;
                    continue;
                }
                break;
        }
        switch (expr->fail)
        {
            case WINDIVERT_FILTER_RESULT_ACCEPT:
            case WINDIVERT_FILTER_RESULT_REJECT:
                singleton = FALSE;
                break;
            default:
                next_expr = exprs[expr->fail];
                if (next_expr->count != 1)
                {
                    singleton = FALSE;
                    break;
                }
                if (next_expr->succ == expr->succ)
                {
                    expr = WinDivertSimplifyAndOr(pool, exprs, expr,
                        /*and=*/FALSE, expr->fail, expr->succ);
                    continue;
                }
                else if (next_expr->fail == expr->succ)
                {
                    new_expr = (PEXPR)HeapAlloc(pool, HEAP_ZERO_MEMORY,
                        sizeof(EXPR));
                    if (new_expr == NULL)
                    {
                        return NULL;
                    }
                    new_expr->kind   = TOKEN_QUESTION;
                    new_expr->arg[0] = expr;
                    new_expr->arg[1] = (PEXPR)&false_expr;
                    new_expr->arg[2] = next_expr;
                    new_expr->succ   = next_expr->succ;
                    new_expr->fail   = next_expr->fail;
                    new_expr->count  = expr->count;
                    WinDivertDerefExpr(exprs, expr->succ);
                    WinDivertDerefExpr(exprs, expr->fail);
                    expr = new_expr;
                    continue;
                }
                break;
        }

        if (singleton)
        {
            // Both branches have count==1; simplify into a (?:) expression:
            PEXPR succ_expr, fail_expr;
            succ_expr = exprs[expr->succ];
            fail_expr = exprs[expr->fail];
            if (succ_expr->succ != fail_expr->succ ||
                succ_expr->fail != fail_expr->fail)
            {
                break;
            }
            new_expr = (PEXPR)HeapAlloc(pool, HEAP_ZERO_MEMORY, sizeof(EXPR));
            if (new_expr == NULL)
            {
                return NULL;
            }
            new_expr->kind = TOKEN_QUESTION;
            new_expr->arg[0] = expr;
            new_expr->arg[1] = succ_expr;
            new_expr->arg[2] = fail_expr;
            new_expr->succ   = succ_expr->succ;
            new_expr->fail   = fail_expr->fail;
            new_expr->count  = expr->count;
            WinDivertDerefExpr(exprs, expr->succ);
            WinDivertDerefExpr(exprs, expr->fail);
            WinDivertDerefExpr(exprs, new_expr->succ);
            WinDivertDerefExpr(exprs, new_expr->fail);
            expr = new_expr;
            continue;
        }

        // No simplifications, so we are done.
        break;
    }

    exprs[i] = expr;
    return expr;
}

/*
 * Coalesce all remaining expressions.
 */
static PEXPR WinDivertCoalesceExpr(HANDLE pool, PEXPR *exprs, UINT16 i)
{
    PEXPR expr, succ_expr, fail_expr, new_expr;
    static const EXPR true_expr  = {{{0}}, TOKEN_TRUE};
    static const EXPR false_expr = {{{0}}, TOKEN_FALSE};

    switch (i)
    {
        case WINDIVERT_FILTER_RESULT_ACCEPT:
            return (PEXPR)&true_expr;
        case WINDIVERT_FILTER_RESULT_REJECT:
            return (PEXPR)&false_expr;
        default:
            break;
    }
    
    expr = exprs[i];
    if (expr == NULL)
    {
        return NULL;
    }

    if (expr->succ == expr->fail)
    {
        return WinDivertCoalesceExpr(pool, exprs, expr->succ);
    }

    succ_expr = WinDivertCoalesceExpr(pool, exprs, expr->succ);
    fail_expr = WinDivertCoalesceExpr(pool, exprs, expr->fail);
    if (succ_expr == NULL || fail_expr == NULL)
    {
        return NULL;
    }
    if (succ_expr->kind == TOKEN_TRUE && fail_expr->kind == TOKEN_FALSE)
    {
        return expr;
    }

    new_expr = (PEXPR)HeapAlloc(pool, HEAP_ZERO_MEMORY, sizeof(EXPR));
    if (new_expr == NULL)
    {
        return NULL;
    }

    new_expr->kind = TOKEN_QUESTION;
    new_expr->arg[0] = expr;
    new_expr->arg[1] = succ_expr;
    new_expr->arg[2] = fail_expr;
    return new_expr;
}

/*
 * Format a 32bit decimal number.
 */
static void WinDivertFormatDecNumber32(PWINDIVERT_STREAM stream, UINT32 val)
{
    UINT32 r = 1000000000ul, dig;
    BOOL zeroes = FALSE;

    while (r != 0)
    {
        dig = val / r;
        val = val % r;
        r = r / 10;
        if (dig == 0 && !zeroes && r != 0)
        {
            continue;
        }
        WinDivertPutChar(stream, '0' + dig);
        zeroes = TRUE;
    }
}

/*
 * Format a 128bit decimal number.
 */
static void WinDivertFormatDecNumber(PWINDIVERT_STREAM stream,
    const UINT32 *val0)
{
    UINT32 val[4];
    char buf[40];
    UINT i, j;

    if (val0[0] == 0 && val0[1] == 0 && val0[2] == 0 && val0[3] == 0)
    {
        WinDivertPutChar(stream, '0');
        return;
    }
    val[0] = val0[0];
    val[1] = val0[1];
    val[2] = val0[2];
    val[3] = val0[3];
    for (i = 0; i < sizeof(buf) &&
            (val[0] != 0 || val[1] != 0 || val[2] != 0 || val[3] != 0); i++)
    {
        buf[i] = '0' + WinDivertDivTen128(val);
    }
    for (j = 0; j < i; j++)
    {
        WinDivertPutChar(stream, buf[i - j - 1]);
    }
}

/*
 * Format a 128bit hexidecimal number.
 */
static void WinDivertFormatHexNumber(PWINDIVERT_STREAM stream,
    const UINT32 *val)
{
    INT i, s;
    UINT32 dig;
    BOOL zeroes = FALSE;

    for (i = 3; val[i] == 0 && i >= 1; i--)
        ;
    for (; i >= 0; i--)
    {
        s = 28;
        while (s >= 0)
        {
            dig = (val[i] & ((UINT32)0xF << s)) >> s;
            s -= 4;
            if (dig == 0 && !zeroes)
            {
                continue;
            }
            WinDivertPutChar(stream, (dig <= 9? '0' + dig: 'a' + (dig - 10)));
            zeroes = TRUE;
        }
    }
    if (!zeroes)
    {
        WinDivertPutChar(stream, '0');
    }
}

/*
 * Format an IPv4 address.
 */
static void WinDivertFormatIPv4Addr(PWINDIVERT_STREAM stream, UINT32 addr)
{
    WinDivertFormatDecNumber32(stream, (addr & 0xFF000000) >> 24);
    WinDivertPutChar(stream, '.');
    WinDivertFormatDecNumber32(stream, (addr & 0x00FF0000) >> 16);
    WinDivertPutChar(stream, '.');
    WinDivertFormatDecNumber32(stream, (addr & 0x0000FF00) >> 8);
    WinDivertPutChar(stream, '.');
    WinDivertFormatDecNumber32(stream, (addr & 0x000000FF) >> 0);
}

/*
 * Format an IPv6 address.
 */
static void WinDivertFormatIPv6Addr(PWINDIVERT_STREAM stream,
    const UINT32 *addr32)
{
    INT i, z_curr, z_count, z_start, z_max;
    UINT16 addr[8];
    UINT32 part[4] = {0};

    // IPv4 special case:
    if (addr32[3] == 0 && addr32[2] == 0 && addr32[1] == 0x0000FFFF)
    {
        WinDivertFormatIPv4Addr(stream, addr32[0]);
        return;
    }

    // Find zeroes:
    memcpy(addr, addr32, sizeof(addr));
    z_curr = 7;
    z_count = 0;
    z_start = z_max = -1;
    for (i = 7; i >= 0; i--)
    {
        if (addr[i] == 0)
        {
            z_count++;
            z_start = (z_count > z_max? z_curr: z_start);
            z_max = (z_count > z_max? z_count: z_max);
        }
        else
        {
            z_curr = i-1;
            z_count = 0;
        }
    }

    // Format address:
    for (i = 7; i >= 0; i--)
    {
        if (i == z_start)
        {
            WinDivertPutString(stream, (i == 7? "::": ":"));
            i -= (z_max-1);
            continue;
        }
        part[0] = (UINT32)addr[i];
        WinDivertFormatHexNumber(stream, part);
        WinDivertPutString(stream, (i != 0? ":": ""));
    }
}

/*
 * Format an IPv4 address.
 */
BOOL WinDivertHelperFormatIPv4Address(UINT32 addr, char *buffer, UINT bufLen)
{
    WINDIVERT_STREAM stream;
    stream.data     = buffer;
    stream.pos      = 0;
    stream.max      = bufLen;
    stream.overflow = FALSE;
    WinDivertFormatIPv4Addr(&stream, addr);
    WinDivertPutNul(&stream);
    if (stream.overflow)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    return TRUE;
}

/*
 * Format an IPv6 address.
 */
BOOL WinDivertHelperFormatIPv6Address(const UINT32 *addr, char *buffer,
    UINT bufLen)
{
    WINDIVERT_STREAM stream;
    stream.data     = buffer;
    stream.pos      = 0;
    stream.max      = bufLen;
    stream.overflow = FALSE;
    WinDivertFormatIPv6Addr(&stream, addr);
    WinDivertPutNul(&stream);
    if (stream.overflow)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    return TRUE;
}

/*
 * Format a test expression.
 */
static void WinDivertFormatTestExpr(PWINDIVERT_STREAM stream, PEXPR expr,
    WINDIVERT_LAYER layer)
{
    PEXPR field = expr->arg[0], val = expr->arg[1];
    BOOL is_ipv4_addr = FALSE, is_ipv6_addr = FALSE, is_layer = FALSE,
        is_event = FALSE, is_hex = FALSE;

    switch (field->kind)
    {
        case TOKEN_ZERO:
        case TOKEN_INBOUND:
        case TOKEN_OUTBOUND:
        case TOKEN_FRAGMENT:
        case TOKEN_IP:
        case TOKEN_IPV6:
        case TOKEN_ICMP:
        case TOKEN_TCP:
        case TOKEN_UDP:
        case TOKEN_ICMPV6:
        case TOKEN_IP_DF:
        case TOKEN_IP_MF:
        case TOKEN_TCP_URG:
        case TOKEN_TCP_ACK:
        case TOKEN_TCP_PSH:
        case TOKEN_TCP_RST:
        case TOKEN_TCP_SYN:
        case TOKEN_TCP_FIN:
        case TOKEN_LOOPBACK:
        case TOKEN_IMPOSTOR:
            if (val->val[1] != 0 || val->val[2] != 0 || val->val[3] != 0 ||
                val->val[0] > 1)
            {
                break;
            }
            switch (expr->kind)
            {
                case TOKEN_EQ:
                    WinDivertPutString(stream, (val->val[0] == 0? "not ": ""));
                    WinDivertFormatExpr(stream, field, layer,
                        /*top_level=*/FALSE, /*and=*/FALSE);
                    return;
                case TOKEN_NEQ:
                    WinDivertPutString(stream, (val->val[0] != 0? "not ": ""));
                    WinDivertFormatExpr(stream, field, layer,
                        /*top_level=*/FALSE, /*and=*/FALSE);
                    return;
                default:
                    break;
            }
            break;
        case TOKEN_IP_SRC_ADDR:
        case TOKEN_IP_DST_ADDR:
            is_ipv4_addr = TRUE;
            break;
        case TOKEN_IPV6_SRC_ADDR:
        case TOKEN_IPV6_DST_ADDR:
        case TOKEN_LOCAL_ADDR:
        case TOKEN_REMOTE_ADDR:
            is_ipv6_addr = TRUE;
            break;
        case TOKEN_LAYER:
            is_layer = TRUE;
            break;
        case TOKEN_EVENT:
            is_event = TRUE;
            break;
        case TOKEN_PACKET:
        case TOKEN_PACKET16:
        case TOKEN_PACKET32:
        case TOKEN_IP_ID:
        case TOKEN_IP_CHECKSUM:
        case TOKEN_TCP_CHECKSUM:
        case TOKEN_TCP_PAYLOAD:
        case TOKEN_TCP_PAYLOAD16:
        case TOKEN_TCP_PAYLOAD32:
        case TOKEN_UDP_CHECKSUM:
        case TOKEN_UDP_PAYLOAD:
        case TOKEN_UDP_PAYLOAD16:
        case TOKEN_UDP_PAYLOAD32:
        case TOKEN_ICMP_CHECKSUM:
        case TOKEN_ICMPV6_CHECKSUM:
            is_hex = TRUE;
            break;
        default:
            break;
    }

    WinDivertFormatExpr(stream, field, layer, /*top_level=*/FALSE,
        /*and=*/FALSE);
    switch (expr->kind)
    {
        case TOKEN_EQ:
            WinDivertPutString(stream, " = "); break;
        case TOKEN_NEQ:
            WinDivertPutString(stream, " != "); break;
        case TOKEN_LT:
            WinDivertPutString(stream, " < "); break;
        case TOKEN_LEQ:
            WinDivertPutString(stream, " <= "); break;
        case TOKEN_GT:
            WinDivertPutString(stream, " > "); break;
        case TOKEN_GEQ:
            WinDivertPutString(stream, " >= "); break;
    }
    if (val->neg)
    {
        WinDivertPutChar(stream, '-');
    }
    if (is_ipv4_addr)
    {
        WinDivertFormatIPv4Addr(stream, val->val[0]);
    }
    else if (is_ipv6_addr)
    {
        WinDivertFormatIPv6Addr(stream, val->val);
    }
    else if (is_layer)
    {
        switch (val->val[0])
        {
            case WINDIVERT_LAYER_NETWORK:
                WinDivertPutString(stream, "NETWORK"); break;
            case WINDIVERT_LAYER_NETWORK_FORWARD:
                WinDivertPutString(stream, "NETWORK_FORWARD"); break;
            case WINDIVERT_LAYER_FLOW:
                WinDivertPutString(stream, "FLOW"); break;
            case WINDIVERT_LAYER_SOCKET:
                WinDivertPutString(stream, "SOCKET"); break;
            case WINDIVERT_LAYER_REFLECT:
                WinDivertPutString(stream, "REFLECT"); break;
            default:
                WinDivertFormatDecNumber32(stream, val->val[0]); break;
        }
    }
    else if (is_event)
    {
        switch (layer)
        {
            case WINDIVERT_LAYER_NETWORK:
            case WINDIVERT_LAYER_NETWORK_FORWARD:
                if (val->val[0] == WINDIVERT_EVENT_NETWORK_PACKET)
                {
                    WinDivertPutString(stream, "PACKET");
                }
                else
                {
                    WinDivertFormatDecNumber32(stream, val->val[0]);
                }
                break;
            case WINDIVERT_LAYER_FLOW:
                switch (val->val[0])
                {
                    case WINDIVERT_EVENT_FLOW_ESTABLISHED:
                        WinDivertPutString(stream, "ESTABLISHED"); break;
                    case WINDIVERT_EVENT_FLOW_DELETED:
                        WinDivertPutString(stream, "DELETED"); break;
                    default:
                        WinDivertFormatDecNumber32(stream, val->val[0]); break;
                }
                break;
            case WINDIVERT_LAYER_SOCKET:
                switch (val->val[0])
                {
                    case WINDIVERT_EVENT_SOCKET_BIND:
                        WinDivertPutString(stream, "BIND"); break;
                    case WINDIVERT_EVENT_SOCKET_CONNECT:
                        WinDivertPutString(stream, "CONNECT"); break;
                    case WINDIVERT_EVENT_SOCKET_LISTEN:
                        WinDivertPutString(stream, "LISTEN"); break;
                    case WINDIVERT_EVENT_SOCKET_ACCEPT:
                        WinDivertPutString(stream, "ACCEPT"); break;
                    case WINDIVERT_EVENT_SOCKET_CLOSE:
                        WinDivertPutString(stream, "CLOSE"); break;
                    default:
                        WinDivertFormatDecNumber32(stream, val->val[0]); break;
                }
                break;
            case WINDIVERT_LAYER_REFLECT:
                switch (val->val[0])
                {
                    case WINDIVERT_EVENT_REFLECT_OPEN:
                        WinDivertPutString(stream, "OPEN"); break;
                    case WINDIVERT_EVENT_REFLECT_CLOSE:
                        WinDivertPutString(stream, "CLOSE"); break;
                    default:
                        WinDivertFormatDecNumber32(stream, val->val[0]); break;
                }
                break;
            default:
                WinDivertFormatDecNumber32(stream, val->val[0]); break;
        }
    }
    else if (is_hex)
    {
        WinDivertPutString(stream, "0x");
        WinDivertFormatHexNumber(stream, val->val);
    }
    else
    {
        WinDivertFormatDecNumber(stream, val->val);
    }
}

/*
 * Format an expression.
 */
static void WinDivertFormatExpr(PWINDIVERT_STREAM stream, PEXPR expr,
    WINDIVERT_LAYER layer, BOOL top_level, BOOL and)
{
    INT idx;

    if (stream->pos >= stream->max)
    {
        return;
    }

    switch (expr->kind)
    {
        case TOKEN_AND:
            if (!top_level && !and)
            {
                WinDivertPutChar(stream, '(');
            }
            WinDivertFormatExpr(stream, expr->arg[0], layer,
                /*top_level=*/FALSE, /*and=*/TRUE);
            WinDivertPutString(stream, " and ");
            WinDivertFormatExpr(stream, expr->arg[1], layer,
                /*top_level=*/FALSE, /*and=*/TRUE);
            if (!top_level && !and)
            {
                WinDivertPutChar(stream, ')');
            }
            return;
        case TOKEN_OR:
            if (!top_level && and)
            {
                WinDivertPutChar(stream, '(');
            }
            WinDivertFormatExpr(stream, expr->arg[0], layer,
                /*top_level=*/FALSE, /*and=*/FALSE);
            WinDivertPutString(stream, " or ");
            WinDivertFormatExpr(stream, expr->arg[1], layer,
                /*top_level=*/FALSE, /*and=*/FALSE);
            if (!top_level && and)
            {
                WinDivertPutChar(stream, ')');
            }
            return;
        case TOKEN_QUESTION:
            WinDivertPutChar(stream, '(');
            WinDivertFormatExpr(stream, expr->arg[0], layer,
                /*top_level=*/TRUE, /*and=*/FALSE);
            WinDivertPutString(stream, "? ");
            WinDivertFormatExpr(stream, expr->arg[1], layer,
                /*top_level=*/TRUE, /*and=*/FALSE);
            WinDivertPutString(stream, ": ");
            WinDivertFormatExpr(stream, expr->arg[2], layer,
                /*top_level=*/TRUE, /*and=*/FALSE);
            WinDivertPutChar(stream, ')');
            return;
        case TOKEN_TRUE:
            WinDivertPutString(stream, "true");
            return;
        case TOKEN_FALSE:
            WinDivertPutString(stream, "false");
            return;
        case TOKEN_EQ:
        case TOKEN_NEQ:
        case TOKEN_LT:
        case TOKEN_LEQ:
        case TOKEN_GT:
        case TOKEN_GEQ:
            WinDivertFormatTestExpr(stream, expr, layer);
            return;
        case TOKEN_ZERO:
            WinDivertPutString(stream, "zero"); return;
        case TOKEN_EVENT:
            WinDivertPutString(stream, "event"); return;
        case TOKEN_RANDOM8:
            WinDivertPutString(stream, "random8"); return;
        case TOKEN_RANDOM16:
            WinDivertPutString(stream, "random16"); return;
        case TOKEN_RANDOM32:
            WinDivertPutString(stream, "random32"); return;
        case TOKEN_PACKET:
            WinDivertPutString(stream, "packet"); break;
        case TOKEN_PACKET16:
            WinDivertPutString(stream, "packet16"); break;
        case TOKEN_PACKET32:
            WinDivertPutString(stream, "packet32"); break;
        case TOKEN_LENGTH:
            WinDivertPutString(stream, "length"); return;
        case TOKEN_TIMESTAMP:
            WinDivertPutString(stream, "timestamp"); return;
        case TOKEN_TCP_PAYLOAD:
            WinDivertPutString(stream, "tcp.Payload"); break;
        case TOKEN_TCP_PAYLOAD16:
            WinDivertPutString(stream, "tcp.Payload16"); break;
        case TOKEN_TCP_PAYLOAD32:
            WinDivertPutString(stream, "tcp.Payload32"); break;
        case TOKEN_UDP_PAYLOAD:
            WinDivertPutString(stream, "udp.Payload"); break;
        case TOKEN_UDP_PAYLOAD16:
            WinDivertPutString(stream, "udp.Payload16"); break;
        case TOKEN_UDP_PAYLOAD32:
            WinDivertPutString(stream, "udp.Payload32"); break;
        case TOKEN_INBOUND:
            WinDivertPutString(stream, "inbound"); return;
        case TOKEN_OUTBOUND:
            WinDivertPutString(stream, "outbound"); return;
        case TOKEN_FRAGMENT:
            WinDivertPutString(stream, "fragment"); return;
        case TOKEN_IF_IDX:
            WinDivertPutString(stream, "ifIdx"); return;
        case TOKEN_SUB_IF_IDX:
            WinDivertPutString(stream, "subIfIdx"); return;
        case TOKEN_IP:
            WinDivertPutString(stream, "ip"); return;
        case TOKEN_IPV6:
            WinDivertPutString(stream, "ipv6"); return;
        case TOKEN_ICMP:
            WinDivertPutString(stream, "icmp"); return;
        case TOKEN_TCP:
            WinDivertPutString(stream, "tcp"); return;
        case TOKEN_UDP:
            WinDivertPutString(stream, "udp"); return;
        case TOKEN_ICMPV6:
            WinDivertPutString(stream, "icmpv6"); return;
        case TOKEN_IP_HDR_LENGTH:
            WinDivertPutString(stream, "ip.HdrLength"); return;
        case TOKEN_IP_TOS:
            WinDivertPutString(stream, "ip.TOS"); return;
        case TOKEN_IP_LENGTH:
            WinDivertPutString(stream, "ip.Length"); return;
        case TOKEN_IP_ID:
            WinDivertPutString(stream, "ip.Id"); return;
        case TOKEN_IP_DF:
            WinDivertPutString(stream, "ip.DF"); return;
        case TOKEN_IP_MF:
            WinDivertPutString(stream, "ip.MF"); return;
        case TOKEN_IP_FRAG_OFF:
            WinDivertPutString(stream, "ip.FragOff"); return;
        case TOKEN_IP_TTL:
            WinDivertPutString(stream, "ip.TTL"); return;
        case TOKEN_IP_PROTOCOL:
            WinDivertPutString(stream, "ip.Protocol"); return;
        case TOKEN_IP_CHECKSUM:
            WinDivertPutString(stream, "ip.Checksum"); return;
        case TOKEN_IP_SRC_ADDR:
            WinDivertPutString(stream, "ip.SrcAddr"); return;
        case TOKEN_IP_DST_ADDR:
            WinDivertPutString(stream, "ip.DstAddr"); return;
        case TOKEN_IPV6_TRAFFIC_CLASS:
            WinDivertPutString(stream, "ipv6.TrafficClass"); return;
        case TOKEN_IPV6_FLOW_LABEL:
            WinDivertPutString(stream, "ipv6.FlowLabel"); return;
        case TOKEN_IPV6_LENGTH:
            WinDivertPutString(stream, "ipv6.Length"); return;
        case TOKEN_IPV6_NEXT_HDR:
            WinDivertPutString(stream, "ipv6.NextHdr"); return;
        case TOKEN_IPV6_HOP_LIMIT:
            WinDivertPutString(stream, "ipv6.HopLimit"); return;
        case TOKEN_IPV6_SRC_ADDR:
            WinDivertPutString(stream, "ipv6.SrcAddr"); return;
        case TOKEN_IPV6_DST_ADDR:
            WinDivertPutString(stream, "ipv6.DstAddr"); return;
        case TOKEN_ICMP_TYPE:
            WinDivertPutString(stream, "icmp.Type"); return;
        case TOKEN_ICMP_CODE:
            WinDivertPutString(stream, "icmp.Code"); return;
        case TOKEN_ICMP_CHECKSUM:
            WinDivertPutString(stream, "icmp.Checksum"); return;
        case TOKEN_ICMP_BODY:
            WinDivertPutString(stream, "icmp.Body"); return;
        case TOKEN_ICMPV6_TYPE:
            WinDivertPutString(stream, "icmpv6.Type"); return;
        case TOKEN_ICMPV6_CODE:
            WinDivertPutString(stream, "icmpv6.Code"); return;
        case TOKEN_ICMPV6_CHECKSUM:
            WinDivertPutString(stream, "icmpv6.Checksum"); return;
        case TOKEN_ICMPV6_BODY:
            WinDivertPutString(stream, "icmpv6.Body"); return;
        case TOKEN_TCP_SRC_PORT:
            WinDivertPutString(stream, "tcp.SrcPort"); return;
        case TOKEN_TCP_DST_PORT:
            WinDivertPutString(stream, "tcp.DstPort"); return;
        case TOKEN_TCP_SEQ_NUM:
            WinDivertPutString(stream, "tcp.SeqNum"); return;
        case TOKEN_TCP_ACK_NUM:
            WinDivertPutString(stream, "tcp.AckNum"); return;
        case TOKEN_TCP_HDR_LENGTH:
            WinDivertPutString(stream, "tcp.HdrLength"); return;
        case TOKEN_TCP_URG:
            WinDivertPutString(stream, "tcp.Urg"); return;
        case TOKEN_TCP_ACK:
            WinDivertPutString(stream, "tcp.Ack"); return;
        case TOKEN_TCP_PSH:
            WinDivertPutString(stream, "tcp.Psh"); return;
        case TOKEN_TCP_RST:
            WinDivertPutString(stream, "tcp.Rst"); return;
        case TOKEN_TCP_SYN:
            WinDivertPutString(stream, "tcp.Syn"); return;
        case TOKEN_TCP_FIN:
            WinDivertPutString(stream, "tcp.Fin"); return;
        case TOKEN_TCP_WINDOW:
            WinDivertPutString(stream, "tcp.Window"); return;
        case TOKEN_TCP_CHECKSUM:
            WinDivertPutString(stream, "tcp.Checksum"); return;
        case TOKEN_TCP_URG_PTR:
            WinDivertPutString(stream, "tcp.UrgPtr"); return;
        case TOKEN_TCP_PAYLOAD_LENGTH:
            WinDivertPutString(stream, "tcp.PayloadLength"); return;
        case TOKEN_UDP_SRC_PORT:
            WinDivertPutString(stream, "udp.SrcPort"); return;
        case TOKEN_UDP_DST_PORT:
            WinDivertPutString(stream, "udp.DstPort"); return;
        case TOKEN_UDP_LENGTH:
            WinDivertPutString(stream, "udp.Length"); return;
        case TOKEN_UDP_CHECKSUM:
            WinDivertPutString(stream, "udp.Checksum"); return;
        case TOKEN_UDP_PAYLOAD_LENGTH:
            WinDivertPutString(stream, "udp.PayloadLength"); return;
        case TOKEN_LOOPBACK:
            WinDivertPutString(stream, "loopback"); return;
        case TOKEN_IMPOSTOR:
            WinDivertPutString(stream, "impostor"); return;
        case TOKEN_PROCESS_ID:
            WinDivertPutString(stream, "processId"); return;
        case TOKEN_LOCAL_ADDR:
            WinDivertPutString(stream, "localAddr"); return;
        case TOKEN_REMOTE_ADDR:
            WinDivertPutString(stream, "remoteAddr"); return;
        case TOKEN_LOCAL_PORT:
            WinDivertPutString(stream, "localPort"); return;
        case TOKEN_REMOTE_PORT:
            WinDivertPutString(stream, "remotePort"); return;
        case TOKEN_PROTOCOL:
            WinDivertPutString(stream, "protocol"); return;
        case TOKEN_ENDPOINT_ID:
            WinDivertPutString(stream, "endpointId"); return;
        case TOKEN_PARENT_ENDPOINT_ID:
            WinDivertPutString(stream, "parentEndpointId"); return;
        case TOKEN_LAYER:
            WinDivertPutString(stream, "layer"); return;
        case TOKEN_PRIORITY:
            WinDivertPutString(stream, "priority"); return;
        case TOKEN_NUMBER:
            WinDivertFormatDecNumber(stream, expr->val); return;
    }

    WinDivertPutChar(stream, '[');
    idx = (INT)expr->val[0];
    if (idx < 0)
    {
        WinDivertPutChar(stream, '-');
        idx = -idx;
    }
    WinDivertFormatDecNumber32(stream, (UINT32)idx);
    WinDivertPutString(stream, "b]");
}

/*
 * Format a filter string.
 */
BOOL WinDivertHelperFormatFilter(const char *filter, WINDIVERT_LAYER layer,
    char *buffer, UINT buflen)
{
    PEXPR exprs[WINDIVERT_FILTER_MAXLEN], expr;
    ERROR err;
    DWORD error;
    WINDIVERT_FILTER *object;
    UINT obj_len;
    INT i;
    HANDLE pool;
    WINDIVERT_STREAM stream;

    if (filter == NULL || buffer == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pool = HeapCreate(HEAP_NO_SERIALIZE, WINDIVERT_MIN_POOL_SIZE,
        WINDIVERT_MAX_POOL_SIZE);
    if (pool == NULL)
    {
        return FALSE;
    }
    object = HeapAlloc(pool, 0,
        WINDIVERT_FILTER_MAXLEN * sizeof(WINDIVERT_FILTER));
    if (object == NULL)
    {
        goto WinDivertHelperFormatFilterError;
    }
    err = WinDivertCompileFilter(filter, pool, layer, object, &obj_len);
    if (IS_ERROR(err))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto WinDivertHelperFormatFilterError;
    }

    // Decompile all tests:
    for (i = (INT)obj_len-1; i >= 0; i--)
    {
        expr = WinDivertDecompileTest(pool, object + i);
        if (expr == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto WinDivertHelperFormatFilterError;
        }
        exprs[i] = expr;
        switch (expr->succ)
        {
            case WINDIVERT_FILTER_RESULT_ACCEPT:
            case WINDIVERT_FILTER_RESULT_REJECT:
                break;
            default:
                exprs[expr->succ]->count++;
                break;
        }
        switch (expr->fail)
        {
            case WINDIVERT_FILTER_RESULT_ACCEPT:
            case WINDIVERT_FILTER_RESULT_REJECT:
                break;
            default:
                exprs[expr->fail]->count++;
                break;
        }
    }
    exprs[0]->count++;

    // Coalesce (unflatten) tests into and/or expressions:
    for (i = (INT)obj_len-1; i >= 0; i--)
    {
        err = MAKE_ERROR(WINDIVERT_ERROR_NONE, 0);
        (PVOID)WinDivertCoalesceAndOr(pool, exprs, i, &err);
        if (IS_ERROR(err))
        {
            goto WinDivertHelperFormatFilterError;
        }
    }

    // Coalesce remaining expressions:
    expr = WinDivertCoalesceExpr(pool, exprs, 0);
    if (expr == NULL)
    {
        goto WinDivertHelperFormatFilterError;
    }

    // Format the final expression:
    stream.data     = buffer;
    stream.pos      = 0;
    stream.max      = buflen;
    stream.overflow = FALSE;
    WinDivertFormatExpr(&stream, expr, layer, /*top_level=*/TRUE,
        /*and=*/FALSE);
    WinDivertPutNul(&stream);

    // Clean-up:
    HeapDestroy(pool);
    if (!stream.overflow)
    {
        return TRUE;
    }
    SetLastError(ERROR_INSUFFICIENT_BUFFER);
    return FALSE;

WinDivertHelperFormatFilterError:
    error = GetLastError();
    HeapDestroy(pool);
    SetLastError(error);
    return FALSE;
}

/*
 * WinDivert packet hash function.
 */
UINT64 WinDivertHelperHashPacket(const VOID *pPacket, UINT packetLen,
    UINT64 seed)
{
    PWINDIVERT_IPHDR ip_header = NULL;
    PWINDIVERT_IPV6HDR ipv6_header = NULL;
    PWINDIVERT_ICMPHDR icmp_header = NULL;
    PWINDIVERT_ICMPV6HDR icmpv6_header = NULL;
    PWINDIVERT_TCPHDR tcp_header = NULL;
    PWINDIVERT_UDPHDR udp_header = NULL;

    if (!WinDivertHelperParsePacket((PVOID)pPacket, packetLen, &ip_header,
            &ipv6_header, NULL, &icmp_header, &icmpv6_header, &tcp_header,
            &udp_header, NULL, NULL, NULL, NULL))
    {
        return 0;
    }
    return WinDivertHashPacket(seed, ip_header, ipv6_header, icmp_header,
        icmpv6_header, tcp_header, udp_header);
}

/*
 * Byte ordering.
 */
UINT16 WinDivertHelperNtohs(UINT16 x)
{
    return BYTESWAP16(x);
}
UINT16 WinDivertHelperHtons(UINT16 x)
{
    return BYTESWAP16(x);
}
UINT32 WinDivertHelperNtohl(UINT32 x)
{
    return BYTESWAP32(x);
}
UINT32 WinDivertHelperHtonl(UINT32 x)
{
    return BYTESWAP32(x);
}
UINT64 WinDivertHelperNtohll(UINT64 x)
{
    return BYTESWAP64(x);
}
UINT64 WinDivertHelperHtonll(UINT64 x)
{
    return BYTESWAP64(x);
}
static void WinDivertByteSwap128(const UINT *inAddr, UINT *outAddr)
{
    UINT32 tmp[4], i;   // tmp[] allows overlapping inAddr/outAddr
    for (i = 0; i < 4; i++)
    {
        tmp[3-i] = BYTESWAP32(inAddr[i]);
    }
    for (i = 0; i < 4; i++)
    {
        outAddr[i] = tmp[i];
    }
}
void WinDivertHelperNtohIPv6Address(const UINT *inAddr, UINT *outAddr)
{
    WinDivertByteSwap128(inAddr, outAddr);
}
void WinDivertHelperHtonIPv6Address(const UINT *inAddr, UINT *outAddr)
{
    WinDivertByteSwap128(inAddr, outAddr);
}

// Old names to be removed in next version
void WinDivertHelperNtohIpv6Address(const UINT *inAddr, UINT *outAddr)
{
    WinDivertByteSwap128(inAddr, outAddr);
}
void WinDivertHelperHtonIpv6Address(const UINT *inAddr, UINT *outAddr)
{
    WinDivertByteSwap128(inAddr, outAddr);
}

```

`dll/windivert_shared.c`:

```c
/*
 * windivert_shared.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#define WINDIVERT_OBJECT_MAXLEN                                         \
    (8 + 4 + 2 + WINDIVERT_FILTER_MAXLEN * (1 + 1 + 2 + 2 + 4*7 + 3 + 3) + 1)

#define MAX(a, b)                               ((a) > (b)? (a): (b))

/*
 * Definitions to remove (some) external dependencies:
 */
#define BYTESWAP16(x)                   \
    ((((x) >> 8) & 0x00FFu) | (((x) << 8) & 0xFF00u))
#define BYTESWAP32(x)                   \
    ((((x) >> 24) & 0x000000FFu) | (((x) >> 8) & 0x0000FF00u) | \
     (((x) << 8) & 0x00FF0000u) | (((x) << 24) & 0xFF000000u))
#define BYTESWAP64(x)                   \
    ((((x) >> 56) & 0x00000000000000FFull) | \
     (((x) >> 40) & 0x000000000000FF00ull) | \
     (((x) >> 24) & 0x0000000000FF0000ull) | \
     (((x) >> 8)  & 0x00000000FF000000ull) | \
     (((x) << 8)  & 0x000000FF00000000ull) | \
     (((x) << 24) & 0x0000FF0000000000ull) | \
     (((x) << 40) & 0x00FF000000000000ull) | \
     (((x) << 56) & 0xFF00000000000000ull))
#define ntohs(x)                        BYTESWAP16(x)
#define htons(x)                        BYTESWAP16(x)
#define ntohl(x)                        BYTESWAP32(x)
#define htonl(x)                        BYTESWAP32(x)

/*
 * Layer flags shorthand.
 */
#define WINDIVERT_LAYER_FLAG_NETWORK            (1 << WINDIVERT_LAYER_NETWORK)
#define WINDIVERT_LAYER_FLAG_NETWORK_FORWARD    \
    (1 << WINDIVERT_LAYER_NETWORK_FORWARD)
#define WINDIVERT_LAYER_FLAG_FLOW               (1 << WINDIVERT_LAYER_FLOW)
#define WINDIVERT_LAYER_FLAG_SOCKET             (1 << WINDIVERT_LAYER_SOCKET)
#define WINDIVERT_LAYER_FLAG_REFLECT            (1 << WINDIVERT_LAYER_REFLECT)
#define LNMFSR          (WINDIVERT_LAYER_FLAG_NETWORK |                     \
                         WINDIVERT_LAYER_FLAG_NETWORK_FORWARD |             \
                         WINDIVERT_LAYER_FLAG_FLOW |                        \
                         WINDIVERT_LAYER_FLAG_SOCKET |                      \
                         WINDIVERT_LAYER_FLAG_REFLECT)
#define LNMFS_          (WINDIVERT_LAYER_FLAG_NETWORK |                     \
                         WINDIVERT_LAYER_FLAG_NETWORK_FORWARD |             \
                         WINDIVERT_LAYER_FLAG_FLOW |                        \
                         WINDIVERT_LAYER_FLAG_SOCKET)
#define L__F_R          (WINDIVERT_LAYER_FLAG_FLOW |                        \
                         WINDIVERT_LAYER_FLAG_REFLECT)
#define LN_FS_          (WINDIVERT_LAYER_FLAG_NETWORK |                     \
                         WINDIVERT_LAYER_FLAG_FLOW |                        \
                         WINDIVERT_LAYER_FLAG_SOCKET)
#define L__FS_          (WINDIVERT_LAYER_FLAG_FLOW |                        \
                         WINDIVERT_LAYER_FLAG_SOCKET)
#define L___SR          (WINDIVERT_LAYER_FLAG_SOCKET |                      \
                         WINDIVERT_LAYER_FLAG_REFLECT)
#define L__FSR          (WINDIVERT_LAYER_FLAG_FLOW |                        \
                         WINDIVERT_LAYER_FLAG_SOCKET |                      \
                         WINDIVERT_LAYER_FLAG_REFLECT)
#define LNM___          (WINDIVERT_LAYER_FLAG_NETWORK |                     \
                         WINDIVERT_LAYER_FLAG_NETWORK_FORWARD)
#define L__F__          WINDIVERT_LAYER_FLAG_FLOW
#define L___S_          WINDIVERT_LAYER_FLAG_SOCKET
#define L____R          WINDIVERT_LAYER_FLAG_REFLECT

#if defined(WIN32) && defined(_MSC_VER)
#pragma intrinsic(__emulu)
static UINT64 WinDivertMul64(UINT64 a, UINT64 b)
{
    UINT64 r = __emulu((UINT32)a, (UINT32)b);
    r += __emulu((UINT32)(a >> 32), (UINT32)b) << 32;
    r += __emulu((UINT32)a, (UINT32)(b >> 32)) << 32;
    return r;
}
#define WINDIVERT_MUL64(a, b)   WinDivertMul64(a, b)
#else       /* WIN32 */
#define WINDIVERT_MUL64(a, b)   ((a) * (b))
#endif      /* WIN32 */

/*
 * IPv6 fragment header.
 */
typedef struct
{
    UINT8 NextHdr;
    UINT8 Reserved;
    UINT16 FragOff0;
    UINT32 Id;
} WINDIVERT_IPV6FRAGHDR, *PWINDIVERT_IPV6FRAGHDR;
#define WINDIVERT_IPV6FRAGHDR_GET_FRAGOFF(hdr)                          \
    (((hdr)->FragOff0) & 0xF8FF)
#define WINDIVERT_IPV6FRAGHDR_GET_MF(hdr)                               \
    ((((hdr)->FragOff0) & 0x0100) != 0)

#include "windivert_hash.c"

/*
 * IPv4/IPv6 pseudo headers.
 */
typedef struct
{
    UINT32 SrcAddr;
    UINT32 DstAddr;
    UINT8  Zero;
    UINT8  Protocol;
    UINT16 Length;
} WINDIVERT_PSEUDOHDR, *PWINDIVERT_PSEUDOHDR;

typedef struct
{
    UINT32 SrcAddr[4];
    UINT32 DstAddr[4];
    UINT32 Length;
    UINT32 Zero:24;
    UINT32 NextHdr:8;
} WINDIVERT_PSEUDOV6HDR, *PWINDIVERT_PSEUDOV6HDR;

/*
 * Packet info.
 */
typedef struct
{
    UINT32 HeaderLength:17;
    UINT32 FragOff:13;
    UINT32 Fragment:1;
    UINT32 MF:1;
    UINT32 PayloadLength:16;
    UINT32 Protocol:8;
    UINT32 Truncated:1;
    UINT32 Extended:1;
    UINT32 Reserved1:6;
    PWINDIVERT_IPHDR IPHeader;
    PWINDIVERT_IPV6HDR IPv6Header;
    PWINDIVERT_ICMPHDR ICMPHeader;
    PWINDIVERT_ICMPV6HDR ICMPv6Header;
    PWINDIVERT_TCPHDR TCPHeader;
    PWINDIVERT_UDPHDR UDPHeader;
    UINT8 *Payload;
} WINDIVERT_PACKET, *PWINDIVERT_PACKET;

/*
 * Streams.
 */
typedef struct
{
    char *data;
    UINT pos;
    UINT max;
    BOOL overflow;
} WINDIVERT_STREAM, *PWINDIVERT_STREAM;

/*
 * Prototypes.
 */
static UINT16 WinDivertInitPseudoHeader(PWINDIVERT_IPHDR ip_header,
    PWINDIVERT_IPV6HDR ipv6_header, UINT8 protocol, UINT len,
    void *pseudo_header);
static UINT16 WinDivertCalcChecksum(PVOID pseudo_header,
    UINT16 pseudo_header_len, PVOID data, UINT len);

/*
 * Put a char into a stream.
 */
static void WinDivertPutChar(PWINDIVERT_STREAM stream, char c)
{
    if (stream->pos >= stream->max)
    {
        stream->overflow = TRUE;
        return;
    }
    stream->data[stream->pos] = c;
    stream->pos++;
}

/*
 * Put a string into a stream.
 */
static void WinDivertPutString(PWINDIVERT_STREAM stream, const char *str)
{
    while (*str)
    {
        WinDivertPutChar(stream, *str);
        str++;
    }
}

/*
 * Put a NUL character into a stream.
 */
static void WinDivertPutNul(PWINDIVERT_STREAM stream)
{
    if (stream->pos >= stream->max && stream->max > 0)
    {
        stream->data[stream->max-1] = '\0';     // Truncate
    }
    else
    {
        WinDivertPutChar(stream, '\0');
    }
}

/*
 * Encode a digit.
 */
static char WinDivertEncodeDigit(UINT8 dig, BOOL final)
{
    static const char windivert_digits[64+1] =
        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+=";
    return windivert_digits[(dig & 0x1F) + (final? 32: 0)];
}

/*
 * Serialize a number.
 */
static void WinDivertSerializeNumber(PWINDIVERT_STREAM stream, UINT32 val)
{
    UINT32 mask = 0xC0000000;
    UINT dig = 6;
    UINT8 digit;
    BOOL final;

    while ((mask & val) == 0 && dig != 0)
    {
        mask = (dig == 6? 0x3E000000: mask >> 5);
        dig--;
    }
    while (TRUE)
    {
        final = (dig == 0);
        digit = (UINT8)((mask & val) >> (5 * dig));
        WinDivertPutChar(stream, WinDivertEncodeDigit(digit, final));
        if (final)
        {
            break;
        }
        mask = (dig == 6? 0x3E000000: mask >> 5);
        dig--;
    }
}

/*
 * Serialize a label.
 */
static void WinDivertSerializeLabel(PWINDIVERT_STREAM stream, UINT16 label)
{
    switch (label)
    {
        case WINDIVERT_FILTER_RESULT_ACCEPT:
            WinDivertPutChar(stream, 'A');
            break;
        case WINDIVERT_FILTER_RESULT_REJECT:
            WinDivertPutChar(stream, 'X');
            break;
        default:
            WinDivertPutChar(stream, 'L');
            WinDivertSerializeNumber(stream, label);
            break;
    }
}

/*
 * Serialize a test.
 */
static void WinDivertSerializeTest(PWINDIVERT_STREAM stream,
    const WINDIVERT_FILTER *filter)
{
    INT idx;
    UINT i;

    WinDivertPutChar(stream, '_');
    WinDivertSerializeNumber(stream, filter->field);
    WinDivertSerializeNumber(stream, filter->test);
    WinDivertSerializeNumber(stream, filter->neg);
    WinDivertSerializeNumber(stream, filter->arg[0]);
    switch (filter->field)
    {
        case WINDIVERT_FILTER_FIELD_IPV6_SRCADDR:
        case WINDIVERT_FILTER_FIELD_IPV6_DSTADDR:
        case WINDIVERT_FILTER_FIELD_LOCALADDR:
        case WINDIVERT_FILTER_FIELD_REMOTEADDR:
            for (i = 1; i < 4; i++)
            {
                WinDivertSerializeNumber(stream, filter->arg[i]);
            }
            break;
        case WINDIVERT_FILTER_FIELD_ENDPOINTID:
        case WINDIVERT_FILTER_FIELD_PARENTENDPOINTID:
        case WINDIVERT_FILTER_FIELD_TIMESTAMP:
            WinDivertSerializeNumber(stream, filter->arg[1]);
            break;
        case WINDIVERT_FILTER_FIELD_PACKET:
        case WINDIVERT_FILTER_FIELD_PACKET16:
        case WINDIVERT_FILTER_FIELD_PACKET32:
        case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD:
        case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD16:
        case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD32:
        case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD:
        case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD16:
        case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD32:
            idx = (INT)filter->arg[1];
            idx += UINT16_MAX;
            WinDivertSerializeNumber(stream, (UINT32)idx);
            break;
        default:
            break;
    }
    WinDivertSerializeLabel(stream, (UINT16)filter->success);
    WinDivertSerializeLabel(stream, (UINT16)filter->failure);
}

/*
 * Serialize a test.
 */
static void WinDivertSerializeFilter(PWINDIVERT_STREAM stream,
    const WINDIVERT_FILTER *filter, UINT8 length)
{
    UINT8 i;
    WinDivertPutString(stream, "@WinDiv_");     // Magic
    WinDivertSerializeNumber(stream, 0);        // Version
    WinDivertSerializeNumber(stream, length);   // Length
    for (i = 0; i < length; i++)
    {
        WinDivertSerializeTest(stream, filter + i);
    }
    WinDivertPutNul(stream);
}

/*
 * Parse IPv4/IPv6/ICMP/ICMPv6/TCP/UDP headers from a raw packet.
 */
static BOOL WinDivertHelperParsePacketEx(const VOID *pPacket, UINT packetLen,
    PWINDIVERT_PACKET pInfo)
{
    PWINDIVERT_IPHDR ip_header = NULL;
    PWINDIVERT_IPV6HDR ipv6_header = NULL;
    PWINDIVERT_ICMPHDR icmp_header = NULL;
    PWINDIVERT_ICMPV6HDR icmpv6_header = NULL;
    PWINDIVERT_TCPHDR tcp_header = NULL;
    PWINDIVERT_UDPHDR udp_header = NULL;
    PWINDIVERT_IPV6FRAGHDR frag_header;
    UINT8 protocol = 0;
    UINT8 *data = NULL;
    UINT packet_len, total_len, header_len, data_len = 0, frag_off = 0;
    BOOL MF = FALSE, fragment = FALSE, is_ext_header;

    if (pPacket == NULL || packetLen < sizeof(WINDIVERT_IPHDR))
    {
        return FALSE;
    }
    data = (UINT8 *)pPacket;
    data_len = packetLen;

    ip_header = (PWINDIVERT_IPHDR)data;
    switch (ip_header->Version)
    {
        case 4:
            if (packetLen < sizeof(WINDIVERT_IPHDR) ||
                ip_header->HdrLength < 5)
            {
                return FALSE;
            }
            total_len  = (UINT)ntohs(ip_header->Length);
            protocol   = ip_header->Protocol;
            header_len = ip_header->HdrLength * sizeof(UINT32);
            if (total_len < header_len || packetLen < header_len)
            {
                return FALSE;
            }
            frag_off   = ntohs(WINDIVERT_IPHDR_GET_FRAGOFF(ip_header));
            MF         = (WINDIVERT_IPHDR_GET_MF(ip_header) != 0);
            fragment   = (MF || frag_off != 0);
            packet_len = (total_len < packetLen? total_len: packetLen);
            data      += header_len;
            data_len   = packet_len - header_len;
            break;

        case 6:
            ip_header   = NULL;
            ipv6_header = (PWINDIVERT_IPV6HDR)data;
            if (packetLen < sizeof(WINDIVERT_IPV6HDR))
            {
                return FALSE;
            }
            protocol   = ipv6_header->NextHdr;
            total_len  = (UINT)ntohs(ipv6_header->Length) +
                sizeof(WINDIVERT_IPV6HDR);
            packet_len = (total_len < packetLen? total_len: packetLen);
            data      += sizeof(WINDIVERT_IPV6HDR);
            data_len   = packet_len - sizeof(WINDIVERT_IPV6HDR);

            while (frag_off == 0 && data_len >= 2)
            {
                header_len = (UINT)data[1];
                is_ext_header = TRUE;
                switch (protocol)
                {
                    case IPPROTO_FRAGMENT:
                        header_len = 8;
                        if (fragment || data_len < header_len)
                        {
                            is_ext_header = FALSE;
                            break;
                        }
                        frag_header = (PWINDIVERT_IPV6FRAGHDR)data;
                        frag_off    = ntohs(
                            WINDIVERT_IPV6FRAGHDR_GET_FRAGOFF(frag_header));
                        MF          = WINDIVERT_IPV6FRAGHDR_GET_MF(frag_header);
                        fragment    = TRUE;
                        break;
                    case IPPROTO_AH:
                        header_len += 2;
                        header_len *= 4;
                        break;
                    case IPPROTO_HOPOPTS:
                    case IPPROTO_DSTOPTS:
                    case IPPROTO_ROUTING:
                    case IPPROTO_MH:
                        header_len++;
                        header_len *= 8;
                        break;
                    default:
                        is_ext_header = FALSE;
                        break;
                }
                if (!is_ext_header || data_len < header_len)
                {
                    break;
                }
                protocol  = data[0];
                data     += header_len;
                data_len -= header_len;
            }
            break;

        default:
            return FALSE;
    }

    if (frag_off != 0)
    {
        goto WinDivertHelperParsePacketExit;
    }
    switch (protocol)
    {
        case IPPROTO_TCP:
            tcp_header = (PWINDIVERT_TCPHDR)data;
            if (data_len < sizeof(WINDIVERT_TCPHDR) ||
                tcp_header->HdrLength < 5)
            {
                tcp_header = NULL;
                goto WinDivertHelperParsePacketExit;
            }
            header_len = tcp_header->HdrLength * sizeof(UINT32);
            header_len = (header_len > data_len? data_len: header_len);
            break;

        case IPPROTO_UDP:
            if (data_len < sizeof(WINDIVERT_UDPHDR))
            {
                goto WinDivertHelperParsePacketExit;
            }
            udp_header = (PWINDIVERT_UDPHDR)data;
            header_len = sizeof(WINDIVERT_UDPHDR);
            break;

        case IPPROTO_ICMP:
            if (ip_header == NULL ||
                data_len < sizeof(WINDIVERT_ICMPHDR))
            {
                goto WinDivertHelperParsePacketExit;
            }
            icmp_header = (PWINDIVERT_ICMPHDR)data;
            header_len  = sizeof(WINDIVERT_ICMPHDR);
            break;

        case IPPROTO_ICMPV6:
            if (ipv6_header == NULL ||
                data_len < sizeof(WINDIVERT_ICMPV6HDR))
            {
                goto WinDivertHelperParsePacketExit;
            }
            icmpv6_header = (PWINDIVERT_ICMPV6HDR)data;
            header_len    = sizeof(WINDIVERT_ICMPV6HDR);
            break;

        default:
            goto WinDivertHelperParsePacketExit;
    }
    data     += header_len;
    data_len -= header_len;

WinDivertHelperParsePacketExit:
    if (pInfo == NULL)
    {
        return TRUE;
    }
    data                 = (data_len == 0? NULL: data);
    pInfo->Protocol      = (UINT32)protocol;
    pInfo->Fragment      = (fragment? 1: 0);
    pInfo->MF            = (MF? 1: 0);
    pInfo->FragOff       = (UINT32)frag_off;
    pInfo->Truncated     = (total_len > packetLen? 1: 0);
    pInfo->Extended      = (total_len < packetLen? 1: 0);
    pInfo->Reserved1     = 0;
    pInfo->IPHeader      = ip_header;
    pInfo->IPv6Header    = ipv6_header;
    pInfo->ICMPHeader    = icmp_header;
    pInfo->ICMPv6Header  = icmpv6_header;
    pInfo->TCPHeader     = tcp_header;
    pInfo->UDPHeader     = udp_header;
    pInfo->Payload       = data;
    pInfo->HeaderLength  = (UINT32)(packet_len - data_len);
    pInfo->PayloadLength = (UINT32)data_len;
    return TRUE;
}

/*
 * Calculate IPv4/IPv6/ICMP/ICMPv6/TCP/UDP checksums.
 */
BOOL WinDivertHelperCalcChecksums(PVOID pPacket, UINT packetLen,
    WINDIVERT_ADDRESS *pAddr, UINT64 flags)
{
    UINT8 pseudo_header[
        MAX(sizeof(WINDIVERT_PSEUDOHDR), sizeof(WINDIVERT_PSEUDOV6HDR))];
    UINT16 pseudo_header_len;
    PWINDIVERT_IPHDR ip_header;
    PWINDIVERT_IPV6HDR ipv6_header;
    PWINDIVERT_ICMPHDR icmp_header;
    PWINDIVERT_ICMPV6HDR icmpv6_header;
    PWINDIVERT_TCPHDR tcp_header;
    PWINDIVERT_UDPHDR udp_header;
    WINDIVERT_PACKET info;
    UINT payload_len, checksum_len;
    BOOL truncated;

    if (!WinDivertHelperParsePacketEx(pPacket, packetLen, &info))
    {
        return FALSE;
    }

    ip_header = info.IPHeader;
    if (ip_header != NULL && !(flags & WINDIVERT_HELPER_NO_IP_CHECKSUM))
    {
        ip_header->Checksum = 0;
        ip_header->Checksum = WinDivertCalcChecksum(NULL, 0, ip_header,
            ip_header->HdrLength * sizeof(UINT32));
        if (pAddr != NULL)
        {
            pAddr->IPChecksum = 1;
        }
    }

    payload_len = info.PayloadLength;
    truncated   = (info.Truncated || info.MF || info.FragOff != 0);
 
    icmp_header = info.ICMPHeader;
    if (icmp_header != NULL)
    {
        if ((flags & WINDIVERT_HELPER_NO_ICMP_CHECKSUM) != 0)
        {
            return TRUE;
        }
        if (truncated)
        {
            return FALSE;
        }
        icmp_header->Checksum = 0;
        icmp_header->Checksum = WinDivertCalcChecksum(NULL, 0,
            icmp_header, payload_len + sizeof(WINDIVERT_ICMPHDR));
        return TRUE;
    }

    icmpv6_header = info.ICMPv6Header;
    if (icmpv6_header != NULL)
    {
        if ((flags & WINDIVERT_HELPER_NO_ICMPV6_CHECKSUM) != 0)
        {
            return TRUE;
        }
        if (truncated)
        {
            return FALSE;
        }
        ipv6_header = info.IPv6Header;
        checksum_len = payload_len + sizeof(WINDIVERT_ICMPV6HDR);
        pseudo_header_len = WinDivertInitPseudoHeader(NULL, ipv6_header, 
            IPPROTO_ICMPV6, checksum_len, pseudo_header);
        icmpv6_header->Checksum = 0;
        icmpv6_header->Checksum = WinDivertCalcChecksum(pseudo_header,
            pseudo_header_len, icmpv6_header, checksum_len);
        return TRUE;
    }

    tcp_header = info.TCPHeader;
    if (tcp_header != NULL)
    {
        if ((flags & WINDIVERT_HELPER_NO_TCP_CHECKSUM) != 0)
        {
            return TRUE;
        }
        if (truncated)
        {
            return FALSE;
        }
        checksum_len = payload_len + tcp_header->HdrLength * sizeof(UINT32);
        ipv6_header = info.IPv6Header;
        pseudo_header_len = WinDivertInitPseudoHeader(ip_header,
            ipv6_header, IPPROTO_TCP, checksum_len, pseudo_header);
        tcp_header->Checksum = 0;
        tcp_header->Checksum = WinDivertCalcChecksum(
            pseudo_header, pseudo_header_len, tcp_header, checksum_len);
        if (pAddr != NULL)
        {
            pAddr->TCPChecksum = 1;
        }
        return TRUE;
    }

    udp_header = info.UDPHeader;
    if (udp_header != NULL)
    {
        if ((flags & WINDIVERT_HELPER_NO_UDP_CHECKSUM) != 0)
        {
            return TRUE;
        }
        if (truncated)
        {
            return FALSE;
        }
        // Full UDP checksum
        checksum_len = payload_len + sizeof(WINDIVERT_UDPHDR);
        ipv6_header = info.IPv6Header;
        pseudo_header_len = WinDivertInitPseudoHeader(ip_header,
            ipv6_header, IPPROTO_UDP, checksum_len, pseudo_header);
        udp_header->Checksum = 0;
        udp_header->Checksum = WinDivertCalcChecksum(
            pseudo_header, pseudo_header_len, udp_header, checksum_len);
        if (udp_header->Checksum == 0)
        {
            udp_header->Checksum = 0xFFFF;
        }
        if (pAddr != NULL)
        {
            pAddr->UDPChecksum = 1;
        }
        return TRUE;
    }

    return TRUE;
}

/*
 * Initialize the IP/IPv6 pseudo header.
 */
static UINT16 WinDivertInitPseudoHeader(PWINDIVERT_IPHDR ip_header,
    PWINDIVERT_IPV6HDR ipv6_header, UINT8 protocol, UINT len,
    void *pseudo_header)
{
    if (ip_header != NULL)
    {
        PWINDIVERT_PSEUDOHDR pseudo_header_v4 =
            (PWINDIVERT_PSEUDOHDR)pseudo_header;
        pseudo_header_v4->SrcAddr  = ip_header->SrcAddr;
        pseudo_header_v4->DstAddr  = ip_header->DstAddr;
        pseudo_header_v4->Zero     = 0;
        pseudo_header_v4->Protocol = protocol;
        pseudo_header_v4->Length   = htons((UINT16)len);
        return sizeof(WINDIVERT_PSEUDOHDR);
    }
    else
    {
        PWINDIVERT_PSEUDOV6HDR pseudo_header_v6 =
            (PWINDIVERT_PSEUDOV6HDR)pseudo_header;
        memcpy(pseudo_header_v6->SrcAddr, ipv6_header->SrcAddr,
            sizeof(pseudo_header_v6->SrcAddr));
        memcpy(pseudo_header_v6->DstAddr, ipv6_header->DstAddr,
            sizeof(pseudo_header_v6->DstAddr));
        pseudo_header_v6->Length  = htonl((UINT32)len);
        pseudo_header_v6->NextHdr = protocol;
        pseudo_header_v6->Zero    = 0;
        return sizeof(WINDIVERT_PSEUDOV6HDR);
    }
}

/*
 * Generic checksum computation.
 */
static UINT16 WinDivertCalcChecksum(PVOID pseudo_header,
    UINT16 pseudo_header_len, PVOID data, UINT len)
{
    register const UINT16 *data16 = (const UINT16 *)pseudo_header;
    register size_t len16 = pseudo_header_len >> 1;
    register UINT32 sum = 0;
    size_t i;

    // Pseudo header:
    for (i = 0; i < len16; i++)
    {
        sum += (UINT32)data16[i];
    }

    // Main data:
    data16 = (const UINT16 *)data;
    len16 = len >> 1;
    for (i = 0; i < len16; i++)
    {
        sum += (UINT32)data16[i];
    }

    if (len & 0x1)
    {
        const UINT8 *data8 = (const UINT8 *)data;
        sum += (UINT16)data8[len-1];
    }

    sum = (sum & 0xFFFF) + (sum >> 16);
    sum += (sum >> 16);
    sum = ~sum;
    return (UINT16)sum;
}

/*
 * Decrement the TTL.
 */
BOOL WinDivertHelperDecrementTTL(VOID *packet, UINT packetLen)
{
    PWINDIVERT_IPHDR ip_header;
    PWINDIVERT_IPV6HDR ipv6_header;

    if (packet == NULL || packetLen < sizeof(WINDIVERT_IPHDR))
    {
        return FALSE;
    }

    ip_header = (PWINDIVERT_IPHDR)packet;
    switch (ip_header->Version)
    {
        case 4:
            if (ip_header->TTL <= 1)
            {
                return FALSE;
            }
            ip_header->TTL--;
    
            // Incremental checksum update:
            if (ip_header->Checksum >= 0xFFFE)
            {
                ip_header->Checksum -= 0xFFFE;
            }
            else
            {
                ip_header->Checksum += 1;
            }
            return TRUE;

        case 6:
            if (packetLen < sizeof(WINDIVERT_IPV6HDR))
            {
                return FALSE;
            }
            ipv6_header = (PWINDIVERT_IPV6HDR)packet;
            if (ipv6_header->HopLimit <= 1)
            {
                return FALSE;
            }
            ipv6_header->HopLimit--;
            return TRUE;

        default:
            return FALSE;
    }
}

/*
 * Validate a WinDivert field for given layer.
 */
static BOOL WinDivertValidateField(WINDIVERT_LAYER layer, UINT32 field)
{
    static const UINT8 flags[] =
    {
        LNMFSR,     /* WINDIVERT_FILTER_FIELD_ZERO */
        LN_FS_,     /* WINDIVERT_FILTER_FIELD_INBOUND */
        LN_FS_,     /* WINDIVERT_FILTER_FIELD_OUTBOUND */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IFIDX */
        LNM___,     /* WINDIVERT_FILTER_FIELD_SUBIFIDX */
        LNMFS_,     /* WINDIVERT_FILTER_FIELD_IP */
        LNMFS_,     /* WINDIVERT_FILTER_FIELD_IPV6 */
        LNMFS_,     /* WINDIVERT_FILTER_FIELD_ICMP */
        LNMFS_,     /* WINDIVERT_FILTER_FIELD_TCP */
        LNMFS_,     /* WINDIVERT_FILTER_FIELD_UDP */
        LNMFS_,     /* WINDIVERT_FILTER_FIELD_ICMPV6 */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_HDRLENGTH */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_TOS */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_LENGTH */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_ID */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_DF */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_MF */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_FRAGOFF */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_TTL */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_PROTOCOL */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_CHECKSUM */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_SRCADDR */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IP_DSTADDR */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IPV6_TRAFFICCLASS */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IPV6_FLOWLABEL */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IPV6_LENGTH */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IPV6_NEXTHDR */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IPV6_HOPLIMIT */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IPV6_SRCADDR */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IPV6_DSTADDR */
        LNM___,     /* WINDIVERT_FILTER_FIELD_ICMP_TYPE */
        LNM___,     /* WINDIVERT_FILTER_FIELD_ICMP_CODE */
        LNM___,     /* WINDIVERT_FILTER_FIELD_ICMP_CHECKSUM */
        LNM___,     /* WINDIVERT_FILTER_FIELD_ICMP_BODY */
        LNM___,     /* WINDIVERT_FILTER_FIELD_ICMPV6_TYPE */
        LNM___,     /* WINDIVERT_FILTER_FIELD_ICMPV6_CODE */
        LNM___,     /* WINDIVERT_FILTER_FIELD_ICMPV6_CHECKSUM */
        LNM___,     /* WINDIVERT_FILTER_FIELD_ICMPV6_BODY */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_SRCPORT */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_DSTPORT */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_SEQNUM */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_ACKNUM */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_HDRLENGTH */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_URG */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_ACK */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_PSH */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_RST */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_SYN */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_FIN */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_WINDOW */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_CHECKSUM */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_URGPTR */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_PAYLOADLENGTH */
        LNM___,     /* WINDIVERT_FILTER_FIELD_UDP_SRCPORT */
        LNM___,     /* WINDIVERT_FILTER_FIELD_UDP_DSTPORT */
        LNM___,     /* WINDIVERT_FILTER_FIELD_UDP_LENGTH */
        LNM___,     /* WINDIVERT_FILTER_FIELD_UDP_CHECKSUM */
        LNM___,     /* WINDIVERT_FILTER_FIELD_UDP_PAYLOADLENGTH */
        LN_FS_,     /* WINDIVERT_FILTER_FIELD_LOOPBACK */
        LNM___,     /* WINDIVERT_FILTER_FIELD_IMPOSTOR */
        L__FSR,     /* WINDIVERT_FILTER_FIELD_PROCESSID */
        LN_FS_,     /* WINDIVERT_FILTER_FIELD_LOCALADDR */
        LN_FS_,     /* WINDIVERT_FILTER_FIELD_REMOTEADDR */
        LN_FS_,     /* WINDIVERT_FILTER_FIELD_LOCALPORT */
        LN_FS_,     /* WINDIVERT_FILTER_FIELD_REMOTEPORT */
        LN_FS_,     /* WINDIVERT_FILTER_FIELD_PROTOCOL */
        L__FS_,     /* WINDIVERT_FILTER_FIELD_ENDPOINTID */
        L__FS_,     /* WINDIVERT_FILTER_FIELD_PARENTENDPOINTID */
        L____R,     /* WINDIVERT_FILTER_FIELD_LAYER */
        L____R,     /* WINDIVERT_FILTER_FIELD_PRIORITY */
        LNMFSR,     /* WINDIVERT_FILTER_FIELD_EVENT */
        LNM___,     /* WINDIVERT_FILTER_FIELD_PACKET */
        LNM___,     /* WINDIVERT_FILTER_FIELD_PACKET16 */
        LNM___,     /* WINDIVERT_FILTER_FIELD_PACKET32 */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_PAYLOAD */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_PAYLOAD16 */
        LNM___,     /* WINDIVERT_FILTER_FIELD_TCP_PAYLOAD32 */
        LNM___,     /* WINDIVERT_FILTER_FIELD_UDP_PAYLOAD */
        LNM___,     /* WINDIVERT_FILTER_FIELD_UDP_PAYLOAD16 */
        LNM___,     /* WINDIVERT_FILTER_FIELD_UDP_PAYLOAD32 */
        LNM___,     /* WINDIVERT_FILTER_FIELD_LENGTH */
        LNMFSR,     /* WINDIVERT_FILTER_FIELD_TIMESTAMP */
        LNM___,     /* WINDIVERT_FILTER_FIELD_RANDOM8 */
        LNM___,     /* WINDIVERT_FILTER_FIELD_RANDOM16 */
        LNM___,     /* WINDIVERT_FILTER_FIELD_RANDOM32 */
        LNM___,     /* WINDIVERT_FILTER_FIELD_FRAGMENT */
    };

    if (field > WINDIVERT_FILTER_FIELD_MAX)
    {
        return FALSE;
    }
    return ((flags[field] & (1 << layer)) != 0);
}

/*
 * Big number comparison.
 */
static int WinDivertCompare128(BOOL neg_a, const UINT32 *a, BOOL neg_b,
    const UINT32 *b, BOOL big)
{
    int neg;
    if (neg_a && !neg_b)
    {
        return -1;
    }
    if (!neg_a && neg_b)
    {
        return 1;
    }
    neg = (neg_a? -1: 1);
    if (big)
    {
        if (a[3] < b[3])
        {
            return -neg;
        }
        if (a[3] > b[3])
        {
            return neg;
        }
        if (a[2] < b[2])
        {
            return -neg;
        }
        if (a[2] > b[2])
        {
            return neg;
        }
        if (a[1] < b[1])
        {
            return -neg;
        }
        if (a[1] > b[1])
        {
            return neg;
        }
    }
    if (a[0] < b[0])
    {
        return -neg;
    }
    if (a[0] > b[0])
    {
        return neg;
    }
    return 0;
}

/*
 * WinDivert filter execute function.
 */
static WINDIVERT_INLINE int WinDivertExecuteFilter(
    const WINDIVERT_FILTER *filter,
    WINDIVERT_LAYER layer,
    LONGLONG timestamp,
    WINDIVERT_EVENT event,
    BOOL ipv4,
    BOOL outbound,
    BOOL loopback,
    BOOL impostor,
    BOOL fragment,
    const WINDIVERT_DATA_NETWORK *network_data,
    const WINDIVERT_DATA_FLOW *flow_data,
    const WINDIVERT_DATA_SOCKET *socket_data,
    const WINDIVERT_DATA_REFLECT *reflect_data,
    const WINDIVERT_IPHDR *ip_header,
    const WINDIVERT_IPV6HDR *ipv6_header,
    const WINDIVERT_ICMPHDR *icmp_header,
    const WINDIVERT_ICMPV6HDR *icmpv6_header,
    const WINDIVERT_TCPHDR *tcp_header,
    const WINDIVERT_UDPHDR *udp_header,
    UINT8 protocol,
    const void *packet,
    UINT packet_len,
    UINT header_len,
    UINT payload_len)
{
    UINT64 random64 = 0;
    UINT16 ip, ttl;
    UINT8 data8;
    UINT16 data16;
    UINT32 data32;
    ULARGE_INTEGER val64;

    ip = 0;
    ttl = WINDIVERT_FILTER_MAXLEN+1;
    while (ttl-- != 0)
    {
        BOOL result = TRUE;
        BOOL big    = FALSE;
        BOOL neg    = FALSE;
        int cmp;
        UINT32 val[4];

        if (!WinDivertValidateField(layer, filter[ip].field))
        {
            return -1;
        }
        switch (filter[ip].field)
        {
            case WINDIVERT_FILTER_FIELD_RANDOM8:
            case WINDIVERT_FILTER_FIELD_RANDOM16:
            case WINDIVERT_FILTER_FIELD_RANDOM32:
                if (random64 == 0)
                {
                    random64 = WinDivertHashPacket((UINT64)timestamp,
                        ip_header, ipv6_header, icmp_header, icmpv6_header,
                        tcp_header, udp_header);
                    random64 |= 0xFF00000000000000ull;  // Make non-zero.
                }
                break;
            case WINDIVERT_FILTER_FIELD_IP_HDRLENGTH:
            case WINDIVERT_FILTER_FIELD_IP_TOS:
            case WINDIVERT_FILTER_FIELD_IP_LENGTH:
            case WINDIVERT_FILTER_FIELD_IP_ID:
            case WINDIVERT_FILTER_FIELD_IP_DF:
            case WINDIVERT_FILTER_FIELD_IP_MF:
            case WINDIVERT_FILTER_FIELD_IP_FRAGOFF:
            case WINDIVERT_FILTER_FIELD_IP_TTL:
            case WINDIVERT_FILTER_FIELD_IP_PROTOCOL:
            case WINDIVERT_FILTER_FIELD_IP_CHECKSUM:
            case WINDIVERT_FILTER_FIELD_IP_SRCADDR:
            case WINDIVERT_FILTER_FIELD_IP_DSTADDR:
                result = (ip_header != NULL);
                break;
            case WINDIVERT_FILTER_FIELD_IPV6_TRAFFICCLASS:
            case WINDIVERT_FILTER_FIELD_IPV6_FLOWLABEL:
            case WINDIVERT_FILTER_FIELD_IPV6_LENGTH:
            case WINDIVERT_FILTER_FIELD_IPV6_NEXTHDR:
            case WINDIVERT_FILTER_FIELD_IPV6_HOPLIMIT:
            case WINDIVERT_FILTER_FIELD_IPV6_SRCADDR:
            case WINDIVERT_FILTER_FIELD_IPV6_DSTADDR:
                result = (ipv6_header != NULL);
                break;
            case WINDIVERT_FILTER_FIELD_ICMP_TYPE:
            case WINDIVERT_FILTER_FIELD_ICMP_CODE:
            case WINDIVERT_FILTER_FIELD_ICMP_CHECKSUM:
            case WINDIVERT_FILTER_FIELD_ICMP_BODY:
                result = (icmp_header != NULL);
                break;
            case WINDIVERT_FILTER_FIELD_ICMPV6_TYPE:
            case WINDIVERT_FILTER_FIELD_ICMPV6_CODE:
            case WINDIVERT_FILTER_FIELD_ICMPV6_CHECKSUM:
            case WINDIVERT_FILTER_FIELD_ICMPV6_BODY:
                result = (icmpv6_header != NULL);
                break;
            case WINDIVERT_FILTER_FIELD_TCP_SRCPORT:
            case WINDIVERT_FILTER_FIELD_TCP_DSTPORT:
            case WINDIVERT_FILTER_FIELD_TCP_SEQNUM:
            case WINDIVERT_FILTER_FIELD_TCP_ACKNUM:
            case WINDIVERT_FILTER_FIELD_TCP_HDRLENGTH:
            case WINDIVERT_FILTER_FIELD_TCP_URG:
            case WINDIVERT_FILTER_FIELD_TCP_ACK:
            case WINDIVERT_FILTER_FIELD_TCP_PSH:
            case WINDIVERT_FILTER_FIELD_TCP_RST:
            case WINDIVERT_FILTER_FIELD_TCP_SYN:
            case WINDIVERT_FILTER_FIELD_TCP_FIN:
            case WINDIVERT_FILTER_FIELD_TCP_WINDOW:
            case WINDIVERT_FILTER_FIELD_TCP_CHECKSUM:
            case WINDIVERT_FILTER_FIELD_TCP_URGPTR:
            case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD:
            case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD16:
            case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD32:
            case WINDIVERT_FILTER_FIELD_TCP_PAYLOADLENGTH:
                result = (tcp_header != NULL);
                break;
            case WINDIVERT_FILTER_FIELD_UDP_SRCPORT:
            case WINDIVERT_FILTER_FIELD_UDP_DSTPORT:
            case WINDIVERT_FILTER_FIELD_UDP_LENGTH:
            case WINDIVERT_FILTER_FIELD_UDP_CHECKSUM:
            case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD:
            case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD16:
            case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD32:
            case WINDIVERT_FILTER_FIELD_UDP_PAYLOADLENGTH:
                result = (udp_header != NULL);
                break;
            default:
                break;
        }

        if (result)
        {
            switch (filter[ip].field)
            {
                case WINDIVERT_FILTER_FIELD_ZERO:
                    val[0] = 0;
                    break;
                case WINDIVERT_FILTER_FIELD_EVENT:
                    val[0] = (UINT32)event;
                    break;
                case WINDIVERT_FILTER_FIELD_LENGTH:
                    val[0] = (UINT32)packet_len;
                    break;
                case WINDIVERT_FILTER_FIELD_TIMESTAMP:
                    big = TRUE;
                    neg = (timestamp < 0);
                    val64.QuadPart = (UINT64)(neg? -timestamp: timestamp);
                    val[0] = (UINT32)val64.LowPart;
                    val[1] = (UINT32)val64.HighPart;
                    val[2] = val[3] = 0;
                    break;
                case WINDIVERT_FILTER_FIELD_RANDOM8:
                    val64.QuadPart = random64;
                    val[0] = ((UINT32)val64.HighPart >> 16) & 0xFF;
                    break; 
                case WINDIVERT_FILTER_FIELD_RANDOM16:
                    val64.QuadPart = random64;
                    val[0] = (UINT32)val64.HighPart & 0xFFFF;
                    break;
                case WINDIVERT_FILTER_FIELD_RANDOM32:
                    val[0] = (UINT32)random64;
                    break;
                case WINDIVERT_FILTER_FIELD_PACKET:
                    result = WINDIVERT_GET_DATA(packet, packet_len, 0,
                        packet_len, (INT)filter[ip].arg[1], &data8,
                        sizeof(data8));
                    val[0] = (UINT32)data8;
                    break;
                case WINDIVERT_FILTER_FIELD_PACKET16:
                    result = WINDIVERT_GET_DATA(packet, packet_len, 0,
                        packet_len, (INT)filter[ip].arg[1], &data16,
                        sizeof(data16));
                    val[0] = (UINT32)ntohs(data16);
                    break;
                case WINDIVERT_FILTER_FIELD_PACKET32:
                    result = WINDIVERT_GET_DATA(packet, packet_len, 0,
                        packet_len, (INT)filter[ip].arg[1], &data32,
                        sizeof(data32));
                    val[0] = ntohl(data32);
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD:
                case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD:
                    result = WINDIVERT_GET_DATA(packet, packet_len,
                        header_len, header_len + payload_len,
                        (INT)filter[ip].arg[1], &data8, sizeof(data8));
                    val[0] = (UINT32)data8;
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD16:
                case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD16:
                    result = WINDIVERT_GET_DATA(packet, packet_len,
                        header_len, header_len + payload_len,
                        (INT)filter[ip].arg[1], &data16, sizeof(data16));
                    val[0] = (UINT32)ntohs(data16);
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD32:
                case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD32:
                    result = WINDIVERT_GET_DATA(packet, packet_len,
                        header_len, header_len + payload_len,
                        (INT)filter[ip].arg[1], &data32, sizeof(data32));
                    val[0] = ntohl(data32);
                    break;
                case WINDIVERT_FILTER_FIELD_INBOUND:
                    val[0] = (UINT32)!outbound;
                    break;
                case WINDIVERT_FILTER_FIELD_OUTBOUND:
                    val[0] = (UINT32)outbound;
                    break;
                case WINDIVERT_FILTER_FIELD_FRAGMENT:
                    val[0] = (UINT32)fragment;
                    break;
                case WINDIVERT_FILTER_FIELD_IFIDX:
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_NETWORK:
                        case WINDIVERT_LAYER_NETWORK_FORWARD:
                            val[0] = network_data->IfIdx;
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_SUBIFIDX:
                    val[0] = network_data->SubIfIdx;
                    break;
                case WINDIVERT_FILTER_FIELD_LOOPBACK:
                    val[0] = (UINT32)loopback;
                    break;
                case WINDIVERT_FILTER_FIELD_IMPOSTOR:
                    val[0] = (UINT32)impostor;
                    break;
                case WINDIVERT_FILTER_FIELD_IP:
                    val[0] = (UINT32)(ip_header != NULL);
                    break;
                case WINDIVERT_FILTER_FIELD_IPV6:
                    val[0] = (UINT32)(ipv6_header != NULL);
                    break;
                case WINDIVERT_FILTER_FIELD_ICMP:
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_NETWORK:
                        case WINDIVERT_LAYER_NETWORK_FORWARD:
                            val[0] = (UINT32)(icmp_header != NULL);
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val[0] = (UINT32)(ipv4 &&
                                socket_data->Protocol == IPPROTO_ICMP);
                            break;
                        case WINDIVERT_LAYER_FLOW:
                            val[0] = (UINT32)(ipv4 &&
                                flow_data->Protocol == IPPROTO_ICMP);
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_ICMPV6:
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_NETWORK:
                        case WINDIVERT_LAYER_NETWORK_FORWARD:
                            val[0] = (UINT32)(icmpv6_header != NULL);
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val[0] = (UINT32)(!ipv4 &&
                                socket_data->Protocol == IPPROTO_ICMPV6);
                            break;
                        case WINDIVERT_LAYER_FLOW:
                            val[0] = (UINT32)(!ipv4 &&
                                flow_data->Protocol == IPPROTO_ICMPV6);
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_TCP:
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_NETWORK:
                        case WINDIVERT_LAYER_NETWORK_FORWARD:
                            val[0] = (UINT32)(tcp_header != NULL);
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val[0] =
                                (UINT32)(socket_data->Protocol == IPPROTO_TCP);
                            break;
                        case WINDIVERT_LAYER_FLOW:
                            val[0] =
                                (UINT32)(flow_data->Protocol == IPPROTO_TCP);
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_UDP:
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_NETWORK:
                        case WINDIVERT_LAYER_NETWORK_FORWARD:
                            val[0] = (UINT32)(udp_header != NULL);
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val[0] =
                                (UINT32)(socket_data->Protocol == IPPROTO_UDP);
                            break;
                        case WINDIVERT_LAYER_FLOW:
                            val[0] =
                                (UINT32)(flow_data->Protocol == IPPROTO_UDP);
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_IP_HDRLENGTH:
                    val[0] = (UINT32)ip_header->HdrLength;
                    break;
                case WINDIVERT_FILTER_FIELD_IP_TOS:
                    val[0] = (UINT32)ip_header->TOS;
                    break;
                case WINDIVERT_FILTER_FIELD_IP_LENGTH:
                    val[0] = (UINT32)ntohs(ip_header->Length);
                    break;
                case WINDIVERT_FILTER_FIELD_IP_ID:
                    val[0] = (UINT32)ntohs(ip_header->Id);
                    break;
                case WINDIVERT_FILTER_FIELD_IP_DF:
                    val[0] = (UINT32)WINDIVERT_IPHDR_GET_DF(ip_header);
                    break;
                case WINDIVERT_FILTER_FIELD_IP_MF:
                    val[0] = (UINT32)WINDIVERT_IPHDR_GET_MF(ip_header);
                    break;
                case WINDIVERT_FILTER_FIELD_IP_FRAGOFF:
                    val[0] = (UINT32)ntohs(
                        WINDIVERT_IPHDR_GET_FRAGOFF(ip_header));
                    break;
                case WINDIVERT_FILTER_FIELD_IP_TTL:
                    val[0] = (UINT32)ip_header->TTL;
                    break;
                case WINDIVERT_FILTER_FIELD_IP_PROTOCOL:
                    val[0] = (UINT32)ip_header->Protocol;
                    break;
                case WINDIVERT_FILTER_FIELD_IP_CHECKSUM:
                    val[0] = (UINT32)ntohs(ip_header->Checksum);
                    break;
                case WINDIVERT_FILTER_FIELD_IP_SRCADDR:
                    big = TRUE;
                    val[3] = val[2] = 0;
                    val[1] = 0x0000FFFF;
                    val[0] = (UINT32)ntohl(ip_header->SrcAddr);
                    break;
                case WINDIVERT_FILTER_FIELD_IP_DSTADDR:
                    big = TRUE;
                    val[3] = val[2] = 0;
                    val[1] = 0x0000FFFF;
                    val[0] = (UINT32)ntohl(ip_header->DstAddr);
                    break;
                case WINDIVERT_FILTER_FIELD_IPV6_TRAFFICCLASS:
                    val[0] =
                        (UINT32)WINDIVERT_IPV6HDR_GET_TRAFFICCLASS(ipv6_header);
                    break;
                case WINDIVERT_FILTER_FIELD_IPV6_FLOWLABEL:
                    val[0] = (UINT32)ntohl(
                        WINDIVERT_IPV6HDR_GET_FLOWLABEL(ipv6_header));
                    break;
                case WINDIVERT_FILTER_FIELD_IPV6_LENGTH:
                    val[0] = (UINT32)ntohs(ipv6_header->Length);
                    break;
                case WINDIVERT_FILTER_FIELD_IPV6_NEXTHDR:
                    val[0] = (UINT32)ipv6_header->NextHdr;
                    break;
                case WINDIVERT_FILTER_FIELD_IPV6_HOPLIMIT:
                    val[0] = (UINT32)ipv6_header->HopLimit;
                    break;
                case WINDIVERT_FILTER_FIELD_IPV6_SRCADDR:
                    big = TRUE;
                    val[3] = (UINT32)ntohl(ipv6_header->SrcAddr[0]);
                    val[2] = (UINT32)ntohl(ipv6_header->SrcAddr[1]);
                    val[1] = (UINT32)ntohl(ipv6_header->SrcAddr[2]);
                    val[0] = (UINT32)ntohl(ipv6_header->SrcAddr[3]);
                    break;
                case WINDIVERT_FILTER_FIELD_IPV6_DSTADDR:
                    big = TRUE;
                    val[3] = (UINT32)ntohl(ipv6_header->DstAddr[0]);
                    val[2] = (UINT32)ntohl(ipv6_header->DstAddr[1]);
                    val[1] = (UINT32)ntohl(ipv6_header->DstAddr[2]);
                    val[0] = (UINT32)ntohl(ipv6_header->DstAddr[3]);
                    break;
                case WINDIVERT_FILTER_FIELD_ICMP_TYPE:
                    val[0] = (UINT32)icmp_header->Type;
                    break;
                case WINDIVERT_FILTER_FIELD_ICMP_CODE:
                    val[0] = (UINT32)icmp_header->Code;
                    break;
                case WINDIVERT_FILTER_FIELD_ICMP_CHECKSUM:
                    val[0] = (UINT32)ntohs(icmp_header->Checksum);
                    break;
                case WINDIVERT_FILTER_FIELD_ICMP_BODY:
                    val[0] = (UINT32)ntohl(icmp_header->Body);
                    break;
                case WINDIVERT_FILTER_FIELD_ICMPV6_TYPE:
                    val[0] = (UINT32)icmpv6_header->Type;
                    break;
                case WINDIVERT_FILTER_FIELD_ICMPV6_CODE:
                    val[0] = (UINT32)icmpv6_header->Code;
                    break;
                case WINDIVERT_FILTER_FIELD_ICMPV6_CHECKSUM:
                    val[0] = (UINT32)ntohs(icmpv6_header->Checksum);
                    break;
                case WINDIVERT_FILTER_FIELD_ICMPV6_BODY:
                    val[0] = (UINT32)ntohl(icmpv6_header->Body);
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_SRCPORT:
                    val[0] = (UINT32)ntohs(tcp_header->SrcPort);
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_DSTPORT:
                    val[0] = (UINT32)ntohs(tcp_header->DstPort);
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_SEQNUM:
                    val[0] = (UINT32)ntohl(tcp_header->SeqNum);
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_ACKNUM:
                    val[0] = (UINT32)ntohl(tcp_header->AckNum);
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_HDRLENGTH:
                    val[0] = (UINT32)tcp_header->HdrLength;
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_URG:
                    val[0] = (UINT32)tcp_header->Urg;
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_ACK:
                    val[0] = (UINT32)tcp_header->Ack;
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_PSH:
                    val[0] = (UINT32)tcp_header->Psh;
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_RST:
                    val[0] = (UINT32)tcp_header->Rst;
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_SYN:
                    val[0] = (UINT32)tcp_header->Syn;
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_FIN:
                    val[0] = (UINT32)tcp_header->Fin;
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_WINDOW:
                    val[0] = (UINT32)ntohs(tcp_header->Window);
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_CHECKSUM:
                    val[0] = (UINT32)ntohs(tcp_header->Checksum);
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_URGPTR:
                    val[0] = (UINT32)ntohs(tcp_header->UrgPtr);
                    break;
                case WINDIVERT_FILTER_FIELD_TCP_PAYLOADLENGTH:
                    val[0] = (UINT32)payload_len;
                    break;
                case WINDIVERT_FILTER_FIELD_UDP_SRCPORT:
                    val[0] = (UINT32)ntohs(udp_header->SrcPort);
                    break;
                case WINDIVERT_FILTER_FIELD_UDP_DSTPORT:
                    val[0] = (UINT32)ntohs(udp_header->DstPort);
                    break;
                case WINDIVERT_FILTER_FIELD_UDP_LENGTH:
                    val[0] = (UINT32)ntohs(udp_header->Length);
                    break;
                case WINDIVERT_FILTER_FIELD_UDP_CHECKSUM:
                    val[0] = (UINT32)ntohs(udp_header->Checksum);
                    break;
                case WINDIVERT_FILTER_FIELD_UDP_PAYLOADLENGTH:
                    val[0] = (UINT32)payload_len;
                    break;
                case WINDIVERT_FILTER_FIELD_LOCALADDR:
                    big = TRUE;
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_NETWORK:
                            if (ip_header != NULL)
                            {
                                val[3] = val[2] = 0;
                                val[1] = 0x0000FFFF;
                                val[0] = (UINT32)ntohl(
                                    (outbound? ip_header->SrcAddr:
                                               ip_header->DstAddr));
                            }
                            else if (ipv6_header != NULL && outbound)
                            {
                                val[3] = (UINT32)ntohl(ipv6_header->SrcAddr[0]);
                                val[2] = (UINT32)ntohl(ipv6_header->SrcAddr[1]);
                                val[1] = (UINT32)ntohl(ipv6_header->SrcAddr[2]);
                                val[0] = (UINT32)ntohl(ipv6_header->SrcAddr[3]);
                            }
                            else if (ipv6_header != NULL)
                            {
                                val[3] = (UINT32)ntohl(ipv6_header->DstAddr[0]);
                                val[2] = (UINT32)ntohl(ipv6_header->DstAddr[1]);
                                val[1] = (UINT32)ntohl(ipv6_header->DstAddr[2]);
                                val[0] = (UINT32)ntohl(ipv6_header->DstAddr[3]);
                            }
                            else
                            {
                                val[3] = val[2] = val[1] = val[0] = 0;
                            }
                            break;
                        case WINDIVERT_LAYER_FLOW:
                            val[0] = flow_data->LocalAddr[0];
                            val[1] = flow_data->LocalAddr[1];
                            val[2] = flow_data->LocalAddr[2];
                            val[3] = flow_data->LocalAddr[3];
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val[0] = socket_data->LocalAddr[0];
                            val[1] = socket_data->LocalAddr[1];
                            val[2] = socket_data->LocalAddr[2];
                            val[3] = socket_data->LocalAddr[3];
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_REMOTEADDR:
                    big = TRUE;
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_NETWORK:
                            if (ip_header != NULL)
                            {
                                val[3] = val[2] = 0;
                                val[1] = 0x0000FFFF;
                                val[0] = (UINT32)ntohl(
                                    (!outbound? ip_header->SrcAddr:
                                                ip_header->DstAddr));
                            }
                            else if (ipv6_header != NULL && !outbound)
                            {
                                val[3] = (UINT32)ntohl(ipv6_header->SrcAddr[0]);
                                val[2] = (UINT32)ntohl(ipv6_header->SrcAddr[1]);
                                val[1] = (UINT32)ntohl(ipv6_header->SrcAddr[2]);
                                val[0] = (UINT32)ntohl(ipv6_header->SrcAddr[3]);
                            }
                            else if (ipv6_header != NULL)
                            {
                                val[3] = (UINT32)ntohl(ipv6_header->DstAddr[0]);
                                val[2] = (UINT32)ntohl(ipv6_header->DstAddr[1]);
                                val[1] = (UINT32)ntohl(ipv6_header->DstAddr[2]);
                                val[0] = (UINT32)ntohl(ipv6_header->DstAddr[3]);
                            }
                            else
                            {
                                val[3] = val[2] = val[1] = val[0] = 0;
                            }
                            break;
                        case WINDIVERT_LAYER_FLOW:
                            val[0] = flow_data->RemoteAddr[0];
                            val[1] = flow_data->RemoteAddr[1];
                            val[2] = flow_data->RemoteAddr[2];
                            val[3] = flow_data->RemoteAddr[3];
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val[0] = socket_data->RemoteAddr[0];
                            val[1] = socket_data->RemoteAddr[1];
                            val[2] = socket_data->RemoteAddr[2];
                            val[3] = socket_data->RemoteAddr[3];
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_LOCALPORT:
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_NETWORK:
                            if (tcp_header != NULL)
                            {
                                val[0] = (UINT32)ntohs(
                                    (outbound? tcp_header->SrcPort:
                                               tcp_header->DstPort));
                            }
                            else if (udp_header != NULL)
                            {
                                val[0] = (UINT32)ntohs(
                                    (outbound? udp_header->SrcPort:
                                               udp_header->DstPort));
                            }
                            else if (icmp_header != NULL)
                            {
                                val[0] = (outbound?
                                    (UINT32)icmp_header->Type: 0);
                            }
                            else if (icmpv6_header != NULL)
                            {
                                val[0] = (outbound?
                                    (UINT32)icmpv6_header->Type: 0);
                            }
                            else
                            {
                                val[0] = 0;
                            }
                            break;
                        case WINDIVERT_LAYER_FLOW:
                            val[0] = (UINT32)flow_data->LocalPort;
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val[0] = (UINT32)socket_data->LocalPort;
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_REMOTEPORT:
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_NETWORK:
                            if (tcp_header != NULL)
                            {
                                val[0] = (UINT32)ntohs(
                                    (!outbound? tcp_header->SrcPort:
                                                tcp_header->DstPort));
                            }
                            else if (udp_header != NULL)
                            {
                                val[0] = (UINT32)ntohs(
                                    (!outbound? udp_header->SrcPort:
                                                udp_header->DstPort));
                            }
                            else if (icmp_header != NULL)
                            {
                                val[0] = (!outbound?
                                    (UINT32)icmp_header->Type: 0);
                            }
                            else if (icmpv6_header != NULL)
                            {
                                val[0] = (!outbound?
                                    (UINT32)icmpv6_header->Type: 0);
                            }
                            else
                            {
                                val[0] = 0;
                            }
                            break;
                        case WINDIVERT_LAYER_FLOW:
                            val[0] = (UINT32)flow_data->RemotePort;
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val[0] = (UINT32)socket_data->RemotePort;
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_PROTOCOL:
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_NETWORK:
                            val[0] = (UINT32)protocol;
                            break;
                        case WINDIVERT_LAYER_FLOW:
                            val[0] = (UINT32)flow_data->Protocol;
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val[0] = (UINT32)socket_data->Protocol;
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_PROCESSID:
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_FLOW:
                            val[0] = flow_data->ProcessId;
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val[0] = socket_data->ProcessId;
                            break;
                        case WINDIVERT_LAYER_REFLECT:
                            val[0] = reflect_data->ProcessId;
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_ENDPOINTID:
                    big = TRUE;
                    val[2] = val[3] = 0;
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_FLOW:
                            val64.QuadPart = flow_data->EndpointId;
                            val[0] = (UINT32)val64.LowPart;
                            val[1] = (UINT32)val64.HighPart;
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val64.QuadPart = socket_data->EndpointId;
                            val[0] = (UINT32)val64.LowPart;
                            val[1] = (UINT32)val64.HighPart;
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_PARENTENDPOINTID:
                    big = TRUE;
                    val[2] = val[3] = 0;
                    switch (layer)
                    {
                        case WINDIVERT_LAYER_FLOW:
                            val64.QuadPart = flow_data->ParentEndpointId;
                            val[0] = (UINT32)val64.LowPart;
                            val[1] = (UINT32)val64.HighPart;
                            break;
                        case WINDIVERT_LAYER_SOCKET:
                            val64.QuadPart = socket_data->ParentEndpointId;
                            val[0] = (UINT32)val64.LowPart;
                            val[1] = (UINT32)val64.HighPart;
                            break;
                        default:
                            return -1;
                    }
                    break;
                case WINDIVERT_FILTER_FIELD_LAYER:
                    val[0] = (UINT32)reflect_data->Layer;
                    break;
                case WINDIVERT_FILTER_FIELD_PRIORITY:
                    neg = (reflect_data->Priority < 0);
                    val[0] = (UINT32)(neg? -reflect_data->Priority:
                        reflect_data->Priority);
                    break;
                default:
                    return -1;
            }
        }

        if (result)
        {
            cmp = WinDivertCompare128(neg, val,
                (filter[ip].neg? TRUE: FALSE), filter[ip].arg, big);
            switch (filter[ip].test)
            {
                case WINDIVERT_FILTER_TEST_EQ:
                    result = (cmp == 0);
                    break;
                case WINDIVERT_FILTER_TEST_NEQ:
                    result = (cmp != 0);
                    break;
                case WINDIVERT_FILTER_TEST_LT:
                    result = (cmp < 0);
                    break;
                case WINDIVERT_FILTER_TEST_LEQ:
                    result = (cmp <= 0);
                    break;
                case WINDIVERT_FILTER_TEST_GT:
                    result = (cmp > 0);
                    break;
                case WINDIVERT_FILTER_TEST_GEQ:
                    result = (cmp >= 0);
                    break;
                default:
                    return -1;
            }
        }

        ip = (UINT16)(result? filter[ip].success: filter[ip].failure);
        switch (ip)
        {
            case WINDIVERT_FILTER_RESULT_ACCEPT:
                return 1;
            case WINDIVERT_FILTER_RESULT_REJECT:
                return 0;
            default:
                break;
        }
    }

    return -1;
}


```

`doc/windivert.html`:

```html
<!doctype html>
<html lang="en">
<head>
    <title>WinDivert 2.2 Documentation</title>
    <meta charset="UTF-8"/>
</head>
<body>
<h1>WinDivert 2.2: Windows Packet Divert</h1>
<h2>Table of Contents</h2>
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#building">2. Building</a>
<ul>
<li><a href="#driver_signing">2.1 Driver Signing</a></li>
</ul>
</li>
<li><a href="#installing">3. Installing</a></li>
<li><a href="#uninstalling">4. Uninstalling</a></li>
<li><a href="#programming_api">5. Programming API</a>
<ul>
<li><a href="#divert_layers">5.1 WINDIVERT_LAYER</a></li>
<li><a href="#divert_events">5.2 WINDIVERT_EVENT</a></li>
<li><a href="#divert_address">5.3 WINDIVERT_ADDRESS</a></li>
<li><a href="#divert_open">5.4 WinDivertOpen</a></li>
<li><a href="#divert_recv">5.5 WinDivertRecv</a></li>
<li><a href="#divert_recv_ex">5.6 WinDivertRecvEx</a></li>
<li><a href="#divert_send">5.7 WinDivertSend</a></li>
<li><a href="#divert_send_ex">5.8 WinDivertSendEx</a></li>
<li><a href="#divert_shutdown">5.9 WinDivertShutdown</a></li>
<li><a href="#divert_close">5.19 WinDivertClose</a></li>
<li><a href="#divert_set_param">5.11 WinDivertSetParam</a></li>
<li><a href="#divert_get_param">5.12 WinDivertGetParam</a></li>
</ul>
</li>
<li><a href="#helper_programming_api">6. Helper Programming API</a>
<ul>
<li><a href="#divert_iphdr">6.1 WINDIVERT_IPHDR</a></li>
<li><a href="#divert_ipv6hdr">6.2 WINDIVERT_IPV6HDR</a></li>
<li><a href="#divert_icmphdr">6.3 WINDIVERT_ICMPHDR</a></li>
<li><a href="#divert_icmpv6hdr">6.4 WINDIVERT_ICMPV6HDR</a></li>
<li><a href="#divert_tcphdr">6.5 WINDIVERT_TCPHDR</a></li>
<li><a href="#divert_udphdr">6.6 WINDIVERT_UDPHDR</a></li>
<li><a href="#divert_helper_parse_packet">6.7 WinDivertHelperParsePacket</a></li>
<li><a href="#divert_helper_hash_packet">6.8 WinDivertHelperHashPacket</a></li>
<li><a href="#divert_helper_parse_ipv4_address">6.9 WinDivertHelperParseIPv4Address</a></li>
<li><a href="#divert_helper_parse_ipv6_address">6.10 WinDivertHelperParseIPv6Address</a></li>
<li><a href="#divert_helper_format_ipv4_address">6.11 WinDivertHelperFormatIPv4Address</a></li>
<li><a href="#divert_helper_format_ipv6_address">6.12 WinDivertHelperFormatIPv6Address</a></li>
<li><a href="#divert_helper_calc_checksums">6.13 WinDivertHelperCalcChecksums</a></li>
<li><a href="#divert_helper_dec_ttl">6.14 WinDivertHelperDecrementTTL</a></li>
<li><a href="#divert_helper_compile_filter">6.15 WinDivertHelperCompileFilter</a></li>
<li><a href="#divert_helper_eval_filter">6.16 WinDivertHelperEvalFilter</a></li>
<li><a href="#divert_helper_format_filter">6.17 WinDivertHelperFormatFilter</a></li>
<li><a href="#divert_helper_ntoh">6.18 WinDivertHelperNtoh*</a></li>
<li><a href="#divert_helper_hton">6.19 WinDivertHelperHton*</a></li>
</ul>
</li>
<li><a href="#filter_language">7. Filter Language</a>
<ul>
<li><a href="#filter_examples">7.1 Filter Examples</a></li>
<li><a href="#filter_usage">7.2 Filter Usage</a></li>
</ul>
</li>
<li><a href="#performance">8. Performance</a></li>
<li><a href="#samples">9. Samples</a></li>
<li><a href="#known_issues">10. Known Issues</a></li>
<li><a href="#license">11. License</a></li>
</ul>

<hr>
<a name="introduction"><h2>1. Introduction</h2></a>
<p>
WinDivert is a powerful user-mode 
capture/sniffing/modification/blocking/re-injection package for
Windows 7, Windows 8 and Windows 10.
WinDivert can be used to implement user-mode packet filters, packet sniffers,
firewalls, NAT, VPNs, tunneling applications, etc., without the need to
write kernel-mode code.
</p>
<p>
The main features of the WinDivert are:
</p>
<ul>
<li> User-mode packet capture, sniffing, dropping, filtering, modification,
     re-injection, etc.</li>
<li> Simple, high-level, programming API.</li>
<li> Fully documented with sample programs.</li>
<li> Full IPv6 support.</li>
<li> Full loopback (localhost) support.</li>
<li> A modern WDF/WFP driver implementation.</li>
<li> Open source; Licensed under GNU Lesser General Public License (LGPL)
     version 3.
     See the <a href="#license">License</a> for more information.</li>
</ul>
<p>
WinDivert provides similar functionality to
<code>divert</code> sockets from FreeBSD/MacOS, <code>NETLINK</code> sockets
from Linux.
</p>

<hr>
<a name="building"><h2>2. Building</h2></a>
<p>
Note that pre-built WinDivert binary distributions are available from the
<a href="https://reqrypt.org/windivert.html">WinDivert website</a>.
Most users do not need to build their own version of WinDivert from source.
</p>
<p>
The source code for WinDivert is available for download at:
</p>
<blockquote>
<a href="https://github.com/basil00/Divert">
    https://github.com/basil00/Divert</a>
</blockquote>
<p>
To build the WinDivert drivers from source:
</p>
<ol>
<li> Download and install <a href="http://www.microsoft.com/whdc/devtools/wdk/default.mspx">
Windows Driver Kit 7.1.0</a>.</li>
<li> Open a <i>x86 Free Build Environment</i> console.</li>
<li> In the WinDivert package root directory, run the command:
<pre>
wddk-build.bat
</pre>
This will build the <code>install\WDDK\i386\WinDivert32.sys</code> driver.</li>
<li> Next, open a <i>x64 Free Build Environment</i> console.</li>
<li> Re-run the <code>wddk-build.bat</code> command to build the
<code>install\WDDK\amd64\WinDivert64.sys</code> driver.</li>
</ol>
<p>
To build the WinDivert user-mode library (<code>WinDivert.dll</code>) and sample
programs:
</p>
<ol>
<li> First, build the WinDivert drivers by running the
<code>wddk-build.bat</code> command described above.</li>
<li> In Linux (with the MinGW cross-compilers installed) and in the
WinDivert package root directory, run the command:
<pre>
sh mingw-build.sh
</pre>
This will the user-mode library and sample programs which will be placed
in the <code>install\MINGW</code> subdirectory.</li>
</ol>
<p>
The generated <code>WinDivert.dll</code>/<code>WinDivert.lib</code> files
should be compatible with all major compilers, including both MinGW and
Visual Studio.
</p>

<a name="driver_signing"><h3>2.1 Driver Signing</h3></a>
<p>
If you built your own 
<code>WinDivert32.sys</code>/<code>WinDivert64.sys</code> drivers,
they must be digitally signed before they can be used.
See <a href="http://msdn.microsoft.com/en-us/windows/hardware/gg487317.aspx">Driver Signing Requirements for Windows</a>
for more information.
</p>
<p>
Note that the pre-built <code>WinDivert32.sys</code>/<code>WinDivert64.sys</code>
drivers from the official WinDivert distribution are already digitally signed.
</p>

<hr>
<a name="installing"><h2>3. Installing</h2></a>
<p>
WinDivert does not require any special installation.
Depending on your target configuration, simply place the following files in
your application's home directory:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Application Type
</th>
<th>
Target Windows Type
</th>
<th>
Files Required
</th>
</tr>
<tr>
<td>
32-bit
</td>
<td>
32-bit Windows only
</td>
<td>
<code>WinDivert.dll</code> (32-bit version) and <code>WinDivert32.sys</code>
</td>
</tr>
<tr>
<td>
64-bit
</td>
<td>
64-bit Windows only
</td>
<td>
<code>WinDivert.dll</code> (64-bit version) and <code>WinDivert64.sys</code>
</td>
</tr>
<tr>
<td>
32-bit
</td>
<td>
Both 32-bit and 64-bit Windows
</td>
<td>
<code>WinDivert.dll</code> (32-bit version), <code>WinDivert32.sys</code>,
    and <code>WinDivert64.sys</code>
</td>
</tr>
</table>
</center>
<p>
The WinDivert driver is automatically (and silently) installed on demand
whenever your application calls
<a href="#divert_open"><code>WinDivertOpen()</code></a>.
The calling application must have Administrator privileges.
</p>

<hr>
<a name="uninstalling"><h2>4. Uninstalling</h2></a>
<p>
To uninstall, simply delete the <code>WinDivert.dll</code>,
<code>WinDivert32.sys</code>, and <code>WinDivert64.sys</code> files.
If already running, the WinDivert driver will be automatically
uninstalled during the next machine reboot.
The WinDivert driver can also be manually removed by (1) terminating
all processes that are using WinDivert, and (2) issuing the following
commands at the command prompt
</p>
<pre>
    sc stop WinDivert
    sc delete WinDivert
</pre>
<p>
Alternatively, the WinDivert driver can be removed by using the
<code>windivertctl.exe</code> <a href="#samples">sample program</a> by
issuing the following command:
</p>
<pre>
    windivertctl uninstall
</pre>

<hr>
<a name="programming_api"><h2>5. Programming API</h2></a>
<p>
To use the WinDivert package, a program/application must:
<ol>
<li> Include the <code>windivert.h</code> header file
<pre>
#include "windivert.h"
</pre></li>
<li> Link against or dynamically load the <code>WinDivert.dll</code> dynamic link
library.</li>
</ol>

<a name="divert_layers"><h3>5.1 WINDIVERT_LAYER</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef enum
{
    WINDIVERT_LAYER_NETWORK = 0,
    WINDIVERT_LAYER_NETWORK_FORWARD,
    WINDIVERT_LAYER_FLOW,
    WINDIVERT_LAYER_SOCKET,
    WINDIVERT_LAYER_REFLECT,
} <b>WINDIVERT_LAYER</b>, *<b>PWINDIVERT_LAYER</b>;
</pre>
</td></tr></table>
<dl><dd>
<b>Remarks</b><br>
<p>
WinDivert supports several <i>layers</i> for diverting or capturing
network packets/events.
Each layer has its own capabilities, such as the ability to block
events or to inject new events, etc.
The list of supported WinDivert layers is summarized below:
</p>
<center>
<table border="1" cellpadding="5">
<tr>
<th>Layer</th>
<th colspan="4">Capability</th>
<th>Description</th>
</tr>
<tr>
<th>
</th>
<th>
Block?
</th>
<th>
Inject?
</th>
<th>
Data?
</th>
<th>
PID?
</th>
<th>
</th>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_NETWORK</code>
</td>
<td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td>
<td>
Network packets to/from the local machine.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_NETWORK_FORWARD</code>
</td>
<td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td>
<td>
Network packets passing through the local machine.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_FLOW</code>
</td>
<td></td><td></td><td></td><td>&#10004;</td>
<td>
Network flow established/deleted events.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_SOCKET</code>
</td>
<td>&#10004;</td><td></td><td></td><td>&#10004;</td>
<td>
Socket operation events.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_REFLECT</code>
</td>
<td></td><td></td><td>&#10004;</td><td>&#10004;</td>
<td>
WinDivert handle events.
</td>
</tr>
</table>
</center>
<p>
Here, the layer capabilities are:
</p>
<ul>
<li> (Block?) the layer can block events/packets;</li>
<li> (Inject?) the layer can inject new events/packets;</li>
<li> (Data?) whether the layer returns packets/data or not; and</li>
<li> (PID?) whether the ID for the process associated with
     an event/packet is available at this layer, or not.
</ul>
<p>
The <code>WINDIVERT_LAYER_NETWORK</code> and
<code>WINDIVERT_LAYER_NETWORK_FORWARD</code>
layers allow the user application to capture/block/inject network packets
passing to/from (and through) the local machine.
Due to technical limitations, process ID information is not available
at these layers.
</p>
<p>
The <code>WINDIVERT_LAYER_FLOW</code> layer captures information about
network flow establishment/deletion events.
Here, a <i>flow</i> represents either (1) a
TCP connection, or (2) an implicit <q>flow</q> created by the first
sent/received packet for non-TCP traffic, e.g., UDP.
Old flows are deleted when the corresponding connection is closed (for TCP),
or based on an activity timeout (non-TCP).
Flow-related events can be captured, but not blocked nor injected.
Process ID information is also available at this layer.
Due to technical limitations, the
<code>WINDIVERT_LAYER_FLOW</code> layer cannot capture flow events that
occurred before the handle was opened.
</p>
<p>
The <code>WINDIVERT_LAYER_SOCKET</code> layer can capture or block events
corresponding to socket operations, such as <code>bind()</code>,
<code>connect()</code>, <code>listen()</code>, etc., or the termination
of socket operations, such as a TCP socket disconnection.
Unlike the flow layer, most socket-related events can be blocked.
However, it is not possible to inject new or modified socket events.
Process ID information (of the process responsible for the socket operation)
is available at this layer.
Due to technical limitations, this layer cannot capture events that
occurred before the handle was opened.
</p>
<p>
Finally, the <code>WINDIVERT_LAYER_REFLECT</code> layer can capture events
relating to WinDivert itself, such as when another process opens a
new WinDivert handle, or closes an old WinDivert handle.
WinDivert events can be captured but not injected nor blocked.
Process ID information (of the process responsible for opening the
WinDivert handle) is available at this layer.
This layer also returns data in the form of an <q>object</q> representation
of the filter string used to open the handle.
The object representation can be converted back into a human-readable
filter string using the
<a href="#divert_helper_format_filter"><code>WinDivertHelperFormatFilter()</code></a>
function.
This layer can also capture events that occurred before the handle was opened.
This layer cannot capture events related to other
<code>WINDIVERT_LAYER_REFLECT</code>-layer handles.
</p>
</dd></dl>

<a name="divert_events"><h3>5.2 WINDIVERT_EVENT</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef enum
{
    WINDIVERT_EVENT_NETWORK_PACKET,
    WINDIVERT_EVENT_FLOW_ESTABLISHED,
    WINDIVERT_EVENT_FLOW_DELETED,
    WINDIVERT_EVENT_SOCKET_BIND,
    WINDIVERT_EVENT_SOCKET_CONNECT,
    WINDIVERT_EVENT_SOCKET_LISTEN,
    WINDIVERT_EVENT_SOCKET_ACCEPT,
    WINDIVERT_EVENT_SOCKET_CLOSE,
    WINDIVERT_EVENT_REFLECT_OPEN,
    WINDIVERT_EVENT_REFLECT_CLOSE,
} <b>WINDIVERT_EVENT</b>, *<b>PWINDIVERT_EVENT</b>;
</pre>
</td></tr></table>
<dl><dd>
<b>Remarks</b><br>
<p>
Each layer supports one or more <i>events</i> summarized below:
</p>
<ul>
<li>
<p>
<b><code>WINDIVERT_LAYER_NETWORK</code></b> and
<b><code>WINDIVERT_LAYER_NETWORK_FORWARD</code></b>:
Only a single event is supported:
</p>
<center>
<table border="1" cellpadding="5" width="50%">
<tr>
<th>Event</th>
<th>Description</th>
<tr>
<td>
<code>WINDIVERT_EVENT_NETWORK_PACKET</code>
</td>
<td>
A new network packet.
</td>
</tr>
</table>
</center>
<ul>
</ul>
</li>
<li>
<p>
<b><code>WINDIVERT_LAYER_FLOW</code></b>:
Two events are supported:
</p>
<center>
<table border="1" cellpadding="5" width="50%">
<tr>
<th>Event</th>
<th>Description</th>
<tr>
<td>
<code>WINDIVERT_EVENT_FLOW_ESTABLISHED</code>
</td>
<td>
A new flow is created.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_EVENT_FLOW_DELETED</code>
</td>
<td>
An old flow is deleted.
</td>
</tr>
</table>
</center>
</li>
<li>
<p>
<b><code>WINDIVERT_LAYER_SOCKET</code></b>:
The following events are supported:
</p>
<center>
<table border="1" cellpadding="5" width="50%">
<tr>
<th>Event</th>
<th>Description</th>
<tr>
<td>
<code>WINDIVERT_EVENT_SOCKET_BIND</code>
</td>
<td>
A <code>bind()</code> operation.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_EVENT_SOCKET_CONNECT</code>
</td>
<td>
A <code>connect()</code> operation.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_EVENT_SOCKET_LISTEN</code>
</td>
<td>
A <code>listen()</code> operation.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_EVENT_SOCKET_ACCEPT</code>
</td>
<td>
An <code>accept()</code> operation.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_EVENT_SOCKET_CLOSE</code>
</td>
<td>
A socket endpoint is closed.
This corresponds to a previous binding being released, or an established
connection being terminated.
The event cannot be blocked.
</table>
</center>
</li>
<li>
<p>
<b><code>WINDIVERT_LAYER_REFLECT</code></b>:
Two events are supported:
</p>
<center>
<table border="1" cellpadding="5" width="50%">
<tr>
<th>Event</th>
<th>Description</th>
<tr>
<td>
<code>WINDIVERT_EVENT_REFLECT_OPEN</code>
</td>
<td>
A new WinDivert handle was opened.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_EVENT_REFLECT_CLOSE</code>
</td>
<td>
An old WinDivert handle was closed.
</td>
</tr>
</table>
</center>
</li>
</ul>
</dd></dl>

<a name="divert_address"><h3>5.3 WINDIVERT_ADDRESS</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT32 IfIdx;
    UINT32 SubIfIdx;
} <b>WINDIVERT_DATA_NETWORK</b>, *<b>PWINDIVERT_DATA_NETWORK</b>;

typedef struct
{
    UINT64 Endpoint;
    UINT64 ParentEndpoint;
    UINT32 ProcessId;
    UINT32 LocalAddr[4];
    UINT32 RemoteAddr[4];
    UINT16 LocalPort;
    UINT16 RemotePort;
    UINT8  Protocol;
} <b>WINDIVERT_DATA_FLOW</b>, *<b>PWINDIVERT_DATA_FLOW</b>;

typedef struct
{
    UINT64 Endpoint;
    UINT64 ParentEndpoint;
    UINT32 ProcessId;
    UINT32 LocalAddr[4];
    UINT32 RemoteAddr[4];
    UINT16 LocalPort;
    UINT16 RemotePort;
    UINT8  Protocol;
} <b>WINDIVERT_DATA_SOCKET</b>, *<b>PWINDIVERT_DATA_SOCKET</b>;

typedef struct
{
    INT64  Timestamp;
    UINT32 ProcessId;
    WINDIVERT_LAYER Layer;
    UINT64 Flags;
    INT16  Priority;
} <b>WINDIVERT_DATA_REFLECT</b>, *<b>PWINDIVERT_DATA_REFLECT</b>;

typedef struct
{
    INT64  Timestamp;
    UINT64 Layer:8;
    UINT64 Event:8;
    UINT64 Sniffed:1;
    UINT64 Outbound:1;
    UINT64 Loopback:1;
    UINT64 Impostor:1;
    UINT64 IPv6:1;
    UINT64 IPChecksum:1;
    UINT64 TCPChecksum:1;
    UINT64 UDPChecksum:1;
    union
    {
        WINDIVERT_DATA_NETWORK Network;
        WINDIVERT_DATA_FLOW    Flow;
        WINDIVERT_DATA_SOCKET  Socket;
        WINDIVERT_DATA_REFLECT Reflect;
    };
} <b>WINDIVERT_ADDRESS</b>, *<b>PWINDIVERT_ADDRESS</b>;
</pre>
</td></tr></table>
<dl><dd>
<p><b>Fields</b></p>
<ul>
<li> <code>Timestamp</code>: A timestamp indicating when event occurred.</li>
<li> <code>Layer</code>: The handle's layer (<code>WINDIVERT_LAYER_*</code>).</li>
<li> <code>Event</code>: The captured event (<code>WINDIVERT_EVENT_*</code>).</li>
<li> <code>Sniffed</code>: Set to <code>1</code> if the event was
    <q>sniffed</q> (i.e., not blocked), <code>0</code> otherwise..</li>
<li> <code>Outbound</code>: Set to <code>1</code> for <i>outbound</i>
    packets/event, <code>0</code> for <i>inbound</i> or otherwise.</li>
<li> <code>Loopback</code>: Set to <code>1</code> for loopback packets, <code>0</code>
otherwise</li>
<li> <code>Impostor</code>: Set to <code>1</code> for <q>impostor</q> packets,
<code>0</code> otherwise.</li>
<li> <code>IPv6</code>: Set to <code>1</code> for IPv6 packets/events, <code>0</code>
otherwise</li>
<li> <code>IPChecksum</code>: Set to <code>1</code> if the IPv4 checksum is
valid, <code>0</code> otherwise.</li>
<li> <code>TCPChecksum</code>: Set to <code>1</code> if the TCP checksum is
valid, <code>0</code> otherwise.</li>
<li> <code>UDPChecksum</code>: Set to <code>1</code> if the UDP checksum is
valid, <code>0</code> otherwise.</li>
<li> <code>Network.IfIdx</code>: The interface index on which the packet arrived
    (for inbound packets), or is to be sent (for outbound packets).</li>
<li> <code>Network.SubIfIdx</code>: The sub-interface index for <code>IfIdx</code>.</li>
<li> <code>Flow.EndpointId</code>: The endpoint ID of the flow.</li>
<li> <code>Flow.ParentEndpointId</code>: The parent endpoint ID of the
     flow.</li>
<li> <code>Flow.ProcessId</code>: The ID of the process associated with the
     flow.</li>
<li> <code>Flow.LocalAddr</code>, <code>Flow.RemoteAddr</code>,
     <code>Flow.LocalPort</code>, <code>Flow.RemotePort</code>, and
     <code>Flow.Protocol</code>: The network 5-tuple associated with the
     flow.</li>
<li> <code>Socket.EndpointId</code>: The endpoint ID of the socket
     operation.</li>
<li> <code>Socket.ParentEndpointId</code>: The parent endpoint ID of the 
     socket operation.</li>
<li> <code>Socket.ProcessId</code>: The ID of the process associated with the
     socket operation.</li>
<li> <code>Socket.LocalAddr</code>, <code>Socket.RemoteAddr</code>,
     <code>Socket.LocalPort</code>, <code>Socket.RemotePort</code>, and
     <code>Socket.Protocol</code>: The network 5-tuple associated with the
     socket operation.</li>
<li> <code>Reflect.Timestamp</code>: A timestamp indicating when the handle was 
     opened.</li>
<li> <code>Reflect.ProcessId</code>: The ID of the process that opened the
     handle.</li>
<li> <code>Reflect.Layer</code>, <code>Reflect.Flags</code>, and
     <code>Reflect.Priority</code>: The
     <a href="#divert_open"><code>WinDivertOpen()</code></a> parameters of
     the opened handle.</li>
</ul>
<p>
<b>Remarks</b><br>
The <a href="#divert_address"><code>WINDIVERT_ADDRESS</code></a> structure
represents the "address" of a captured or injected packet.
The address includes the packet's timestamp, layer, event, flags, and
layer-specific data.
All fields are set by <a href="#divert_recv"><code>WinDivertRecv()</code></a>
when the packet/event is captured.
Only some fields are used by
<a href="#divert_send"><code>WinDivertSend()</code></a> when a packet
is injected.
</p><p>
The <code>Timestamp</code> indicates when the packet/event was first
captured by WinDivert.
It uses the same clock as
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644904(v=vs.85).aspx"><code>QueryPerformanceCounter()</code></a>.
</p><p>
The <code>Layer</code> indicates the <i>layer</i> parameter
(<a href="#divert_layers"><code>WINDIVERT_LAYER_*</code></a>) that was passed to
<a href="#divert_open"><code>WinDivertOpen()</code></a>.
It is included in the address to make the structure self-contained.
</p><p>
The <code>Event</code> indicates the layer-specific <i>event</i>
(<a href="#divert_events"><code>WINDIVERT_EVENT_*</code></a>) that was captured.
</p><p>
The <code>Outbound</code> flag is set for <i>outbound</i>
packets/events, and is cleared
for <i>inbound</i> or direction-less packets/events.
</p><p>
The <code>Loopback</code> flag is set for <i>loopback</i> packets.
Note that Windows considers any packet originating from, and destined to, the
current machine to be a loopback packet, so loopback packets are not
limited to localhost addresses.
Note that WinDivert considers loopback packets to be
<i>outbound only</i>, and will not capture loopback packets on the
inbound path.
</p><p>
The <code>Impostor</code> flag is set for <i>impostor</i> packets.
An impostor packet is any packet injected by another driver rather than
originating from the network or Windows TCP/IP stack.
Impostor packets are problematic since they can cause infinite loops,
where a packet injected by <a href="#divert_send"><code>WinDivertSend()</code></a> 
is captured again by <a href="#divert_recv"><code>WinDivertRecv()</code></a>.
For more information, see <a href="#divert_send"><code>WinDivertSend()</code></a>.
</p><p>
The <code>IPv6</code> flag is set for <i>IPv6</i> packets/events, and cleared
for <i>IPv4</i> packets/events.
</p><p>
The <code>*Checksum</code> flags indicate whether the packet has valid checksums
or not.
When <i>IP/TCP/UDP checksum offloading</i> is enabled, it is possible that
captured packets do not have valid checksums.
Invalid checksums may be arbitrary values.
</p><p>
The <code>Network.*</code> fields are only valid at the
<code>WINDIVERT_LAYER_NETWORK</code> and
<code>WINDIVERT_LAYER_NETWORK_FORWARD</code> layers.
The <code>Network.IfIdx</code>/<code>Network.SubIfIdx</code> indicate the packet's
network adapter (a.k.a. interface) index.
These values are ignored for <i>outbound</i> packets.
</p><p>
The <code>Flow.*</code> fields are only valid at the
<code>WINDIVERT_LAYER_FLOW</code> layer.
The <code>Flow.ProcessId</code> is the <i>ID</i> of the process that
created the flow (for outbound), or receives the flow (for inbound).
The
(<code>Flow.LocalAddr</code>, <code>Flow.LocalPort</code>,
 <code>Flow.RemoteAddr</code>, <code>Flow.RemotePort</code>, <code>Flow.Protocol</code>)
fields form the network 5-tuple associated with the flow.
For IPv4, the <code>Flow.LocalAddr</code> and <code>Flow.RemoteAddr</code>
fields will be IPv4-mapped IPv6 addresses,
e.g. the IPv4 address <code>X.Y.Z.W</code> will be represented by
<code>::ffff:X.Y.Z.W</code>.
</p><p>
The <code>Socket.*</code> fields are only valid at the
<code>WINDIVERT_LAYER_SOCKET</code> layer.
The <code>Socket.ProcessId</code> is the <i>ID</i> of the process that executed
the socket operation.
The
(<code>Socket.LocalAddr</code>, <code>Socket.LocalPort</code>,
 <code>Socket.RemoteAddr</code>, <code>Socket.RemotePort</code>,
 <code>Socket.Protocol</code>)
fields form the network 5-tuple associated with the operation.
For IPv4, the <code>Socket.LocalAddr</code> and <code>Socket.RemoteAddr</code>
fields will be IPv4-mapped IPv6 addresses.
The <code>WINDIVERT_EVENT_SOCKET_BIND</code> and
<code>WINDIVERT_EVENT_SOCKET_LISTEN</code> events can occur before a
connection attempt has been made, meaning that the
<code>Socket.RemoteAddr</code> and <code>Socket.RemotePort</code> fields
for these events will be zero.
</p><p>
The <code>Reflect.*</code> fields are only valid at the
<code>WINDIVERT_LAYER_REFLECT</code> layer.
The <code>Reflect.ProcessId</code> is the <i>ID</i> of the process that
opened the WinDivert handle.
The <code>Reflect.Timestamp</code> field is a timestamp indicating when the
handle was opened, using
the same clock as
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644904(v=vs.85).aspx"><code>QueryPerformanceCounter()</code></a>.
The <code>Reflect.Layer</code>, <code>Reflect.Flags</code>, and
    <code>Reflect.Priority</code> fields correspond to the
<a href="#divert_open"><code>WinDivertOpen()</code></a> parameters of
the opened handle.
</p><p>
Most address fields are ignored by
<a href="#divert_send"><code>WinDivertSend()</code></a>.
The exceptions are
<code>Outbound</code> (for <code>WINDIVERT_LAYER_NETWORK</code> only),
<code>Impostor</code>, <code>IPChecksum</code>, <code>TCPChecksum</code>,
<code>UDPChecksum</code>, <code>Network.IfIdx</code> and
<code>Network.SubIfIdx</code>.
</p>
</dd></dl>

<a name="divert_open"><h3>5.4 WinDivertOpen</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
HANDLE <b>WinDivertOpen</b>(
    __in const char *filter,
    __in WINDIVERT_LAYER layer,
    __in INT16 priority,
    __in UINT64 flags
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>filter</code>: A packet filter string specified in the WinDivert
    <a href="#filter_language">filter language</a>.</li>
<li> <code>layer</code>: The layer.</li>
<li> <code>priority</code>: The priority of the handle.</li>
<li> <code>flags</code>: Additional flags.</li>
</ul>
<p>
<b>Return Value</b><br>
A valid WinDivert handle on success, or
<code>INVALID_HANDLE_VALUE</code> if an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
Common errors include:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Name
</th>
<th>
Code
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<code>ERROR_FILE_NOT_FOUND</code>
</td>
<td>
2
</td>
<td>
The driver files
<code>WinDivert32.sys</code> or <code>WinDivert64.sys</code>
were not found.
</td>
</tr>
<tr>
<td>
<code>ERROR_ACCESS_DENIED</code>
</td>
<td>
5
</td>
<td>
The calling application does not have Administrator privileges.
</td>
</tr>
<tr>
<td>
<code>ERROR_INVALID_PARAMETER</code>
</td>
<td>
87
</td>
<td>
This indicates an invalid packet filter string, layer, priority, or flags.
</td>
</tr>
<tr>
<td>
<code>ERROR_INVALID_IMAGE_HASH</code>
</td>
<td>
577
</td>
<td>
The <code>WinDivert32.sys</code> or <code>WinDivert64.sys</code> driver does not
have a valid digital signature
(see the <a href="#driver_signing">driver signing requirements</a> above).
</td>
</tr>
<tr>
<td>
<code>ERROR_DRIVER_FAILED_PRIOR_UNLOAD</code>
</td>
<td>
654
</td>
<td>
An incompatible version of the WinDivert driver is currently loaded.
</td>
<tr>
<td>
<code>ERROR_SERVICE_DOES_NOT_EXIST</code>
</td>
<td>
1060
</td>
<td>
The handle was opened with the <code>WINDIVERT_FLAG_NO_INSTALL</code> flag and
the WinDivert driver is not already installed.
</td>
</tr>
<tr>
<td>
<code>ERROR_DRIVER_BLOCKED</code>
</td>
<td>
1275
</td>
<td>
This error occurs for various reasons, including:
<ol>
<li> the WinDivert driver is blocked by security software; or</li>
<li> you are using a virtualization environment that does not support
drivers.</li>
</ol>
</td>
</tr>
<tr>
<td>
<code>EPT_S_NOT_REGISTERED</code>
</td>
<td>
1753
</td>
<td>
This error occurs when the <i>Base Filtering Engine</i> service has been
disabled.
</td>
</tr>
</table>
</center>
<p>
<b>Remarks</b><br>
Opens a WinDivert handle for the given filter.
Unless otherwise specified by <code>flags</code>, any packet or event that
matches the filter will be diverted to the handle.
Diverted packets/events can be read by the application with
<a href="#divert_recv"><code>WinDivertRecv()</code></a>.
</p>
<p>
A typical application is only interested in a subset of all network traffic
or events.
In this case the filter should <i>match as closely as possible</i> to
the subset of interest.
This avoids unnecessary overheads introduced by diverting packets to the
user-mode application.
See the <a href="#filter_language">filter language</a> section for more
information.
</p>
<p>
The <i>layer</i> of the WinDivert handle is determined by the <code>layer</code>
parameter.
See <a href="#divert_layers"><code>WINDIVERT_LAYER</code></a> for more
information.
Currently the following layers are supported:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Layer
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_NETWORK = 0</code>
</td>
<td>
Network packets to/from the local machine.
This is the default layer.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_NETWORK_FORWARD</code>
</td>
<td>
Network packets passing through the local machine.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_FLOW</code>
</td>
<td>
Network flow established/deleted events.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_SOCKET</code>
</td>
<td>
Socket operation events.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_REFLECT</code>
</td>
<td>
WinDivert handle events.
</td>
</tr>
</table>
</center>
<p>
Different WinDivert handles can be assigned different priorities by the
<code>priority</code> parameter.
Packets are diverted to higher priority handles before lower priority
handles.
Packets injected by a handle are then diverted to the next priority handle,
and so on, provided the packet matches the handle's filter.
A packet is only diverted once per priority level, so handles should not
share priority levels unless they use mutually exclusive filters.
Otherwise it is not defined which handle will receive the packet first.
Higher <code>priority</code> values represent higher priorities, with
<code>WINDIVERT_PRIORITY_HIGHEST</code> being the highest priority,
<code>0</code> the middle (and a good default) priority,
and <code>WINDIVERT_PRIORITY_LOWEST</code> the lowest priority.
</p>
<p>
Different flags affect how the opened handle behaves.
The following flags are supported:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Flag
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<code>WINDIVERT_FLAG_SNIFF</code>
</td>
<td>
This flag opens the WinDivert handle in <i>packet sniffing</i> mode.
In packet sniffing mode the original packet is not dropped-and-diverted
(the default) but copied-and-diverted.
This mode is useful for implementing packet sniffing tools similar to those
applications that currently use <code>Winpcap</code>.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_FLAG_DROP</code>
</td>
<td>
This flag indicates that the user application does not intend to read matching
packets with <a href="#divert_recv"><code>WinDivertRecv()</code></a>, instead the
packets should be silently dropped.
This is useful for implementing simple packet filters using the
WinDivert <a href="#filter_language">filter language</a>.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_FLAG_RECV_ONLY</code>
</td>
<td>
This flags forces the handle into <q>receive only</q> mode which effectively
disables <a href="#divert_send"><code>WinDivertSend()</code></a>.
This means that it is possible to block/capture packets or events but not
inject them.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_FLAG_READ_ONLY</code>
</td>
<td>
An alias for <code>WINDIVERT_FLAG_RECV_ONLY</code>.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_FLAG_SEND_ONLY</code>
</td>
<td>
This flags forces the handle into <q>send only</q> mode which effectively
disables <a href="#divert_recv"><code>WinDivertRecv()</code></a>.
This means that it is possible to inject packets or events, but not
block/capture them.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_FLAG_WRITE_ONLY</code>
</td>
<td>
An alias for <code>WINDIVERT_FLAG_SEND_ONLY</code>.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_FLAG_NO_INSTALL</code>
</td>
<td>
This flags causes <code>WinDivertOpen()</code> to fail with 
<code>ERROR_SERVICE_DOES_NOT_EXIST</code> if the WinDivert driver
is not already installed.
This flag is useful for querying the WinDivert state using a
<code>WINDIVERT_LAYER_REFLECT</code> handle.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_FLAG_FRAGMENTS</code>
</td>
<td>
If set, the handle will capture inbound IP fragments, but not inbound
reassembled IP packets.
Otherwise, if not set (the default), the handle will capture inbound
reassembled IP packets, but not inbound IP fragments.
This flag only affects inbound packets at the
<code>WINDIVERT_LAYER_NETWORK</code> layer, else the flag is ignored.
</td>
</tr>
</table>
</center>
<p>
Note that any combination of
<code>(WINDIVERT_FLAG_SNIFF | WINDIVERT_FLAG_DROP)</code> or
<code>(WINDIVERT_FLAG_RECV_ONLY | WINDIVERT_FLAG_SEND_ONLY)</code> 
are considered invalid.
</p>
<p>
Some layers have mandatory flags, as listed below:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Layer
</th>
<th>
Required Flags
</th>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_FLOW</code>
</td>
<td>
<code>WINDIVERT_FLAG_SNIFF | WINDIVERT_FLAG_RECV_ONLY</code>
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_SOCKET</code>
</td>
<td>
<code>WINDIVERT_FLAG_RECV_ONLY</code>
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_REFLECT</code>
</td>
<td>
<code>WINDIVERT_FLAG_SNIFF | WINDIVERT_FLAG_RECV_ONLY</code>
</td>
</tr>
</table>
</center>
</dd></dl>

<a name="divert_recv"><h3>5.5 WinDivertRecv</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertRecv</b>(
    __in HANDLE handle,
    __out_opt PVOID pPacket,
    __in UINT packetLen,
    __out_opt UINT *pRecvLen,
    __out_opt WINDIVERT_ADDRESS *pAddr
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>handle</code>: A valid WinDivert handle created by
     <a href="#divert_open"><code>WinDivertOpen()</code></a>.</li>
<li> <code>pPacket</code>: An optional buffer for the captured packet.</li>
<li> <code>packetLen</code>: The length of the <code>pPacket</code> buffer.</li>
<li> <code>pRecvLen</code>: The total number of bytes written to <code>pPacket</code>.
     Can be <code>NULL</code> if this information is not required.</li>
<li> <code>pAddr</code>: An optional buffer for the
    <a href="#divert_address">address</a> of the captured packet/event.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if a packet/event was successfully received, or <code>FALSE</code> if
an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
</p><p>
Common errors include:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Name
</th>
<th>
Code
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<code>ERROR_INSUFFICIENT_BUFFER</code>
</td>
<td>
122
</td>
<td>
The captured packet is larger than the <code>pPacket</code> buffer.
</td>
</tr>
<tr>
<td>
<code>ERROR_NO_DATA</code>
</td>
<td>
232
</td>
<td>
The <code>handle</code> has been shutdown using
<a href="#divert_shutdown"><code>WinDivertShutdown()</code></a>
and the packet queue is empty.
</td>
</tr>
</table>
</center>
<p>
<b>Remarks</b><br>
Receives a single captured packet/event matching the filter passed to
<a href="#divert_open"><code>WinDivertOpen()</code></a>.
The received packet/event is guaranteed to match the filter.
</p><p>
Only some <a href="#divert_layers">layers</a> can capture packets/data, as
summarized below:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Layer
</th>
<th>
Data?
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_NETWORK</code>
</td>
<td>
&#10004;
</td>
<td>
Network packet.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_NETWORK_FORWARD</code>
</td>
<td>
&#10004;
</td>
<td>
Network packet.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_FLOW</code>
</td>
<td>
</td>
<td>
-
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_SOCKET</code>
</td>
<td>
</td>
<td>
-
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_REFLECT</code>
</td>
<td>
&#10004;
</td>
<td>
Filter object.
</td>
</tr>
</table>
</center>
<p>
For layers that do support capturing, the captured packet/data will be written
to the <code>pPacket</code> buffer.
If non-<code>NULL</code>, then the total number of bytes
written to <code>pPacket</code> will be written to <code>pRecvLen</code>.
If the <code>pPacket</code> buffer is too small, the packet will be
truncated and the operation will fail with the
<code>ERROR_INSUFFICIENT_BUFFER</code> error code.
This error can be ignored if the application only intends to receive part
of the packet, e.g., the IP headers only.
For layers that do not capture packets/data, the <code>pPacket</code> parameter
should be <code>NULL</code> and <code>packetLen</code> should be zero.
</p><p>
If non-<code>NULL</code>, the <a href="#divert_address">address</a> of the
packet/event will be written to the <code>pAddr</code> buffer.
</p><p>
An application should call <a href="#divert_recv"><code>WinDivertRecv()</code></a>
<i>as soon as possible</i>
after a successful call to <a href="#divert_open"><code>WinDivertOpen()</code></a>.
When a WinDivert handle is open, any packet/event that matches the filter will
be captured and queued until handled by
<a href="#divert_recv"><code>WinDivertRecv()</code></a>.
Packets/events are not queued indefinitely, and if not handled in a timely
manner, data may be lost.
The amount of time a packet/event is queued can be controlled using the
<a href="#divert_set_param"><code>WinDivertSetParam()</code></a> function.
</p><p>
Captured packets are 
guaranteed to have correct checksums or have the corresponding
<code>*Checksum</code> flag unset
(see <a href="#divert_address"><code>WINDIVERT_ADDRESS</code></a>).
</p><p>
<a href="#divert_recv"><code>WinDivertRecv()</code></a> should not be used on any
WinDivert handle created with the <code>WINDIVERT_FLAG_DROP</code> set.
</p>
</dd></dl>

<a name="divert_recv_ex"><h3>5.6 WinDivertRecvEx</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertRecvEx</b>(
    __in HANDLE handle,
    __out VOID *pPacket,
    __in UINT packetLen,
    __out_opt UINT *pRecvLen,
    __in UINT64 flags,
    __out_opt WINDIVERT_ADDRESS *pAddr,
    __inout_opt UINT *pAddrLen,
    __inout_opt LPOVERLAPPED lpOverlapped
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>handle</code>: A valid WinDivert handle created by
     <a href="#divert_open"><code>WinDivertOpen()</code></a>.</li>
<li> <code>pPacket</code>: A buffer for the captured packet(s).</li>
<li> <code>packetLen</code>: The length of the <code>pPacket</code> buffer in
    bytes.</li>
<li> <code>pRecvLen</code>: The total number of bytes written to <code>pPacket</code>.
     Can be <code>NULL</code> if this information is not required.</li>
<li> <code>flags</code>: Reserved, set to zero.</li>
<li> <code>pAddr</code>: The
    <a href="#divert_address"><code>WINDIVERT_ADDRESS</code></a> of the captured
    packet(s).</li>
<li> <code>pAddrLen</code>: Initially, a pointer to the length of the
    <code>pAddr</code> buffer in bytes.
    This value is updated to the total bytes written to <code>pAddr</code>.
    If <code>NULL</code>, a fixed length of <code>sizeof(WINDIVERT_ADDRESS)</code> is
    assumed.</li>
<li> <code>lpOverlapped</code>: An optional pointer to a <code>OVERLAPPED</code>
     structure.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if a packet was successfully received, or <code>FALSE</code> 
otherwise.
Use <code>GetLastError()</code> to get the reason.
The error code <code>ERROR_IO_PENDING</code> indicates that the overlapped
operation has been successfully initiated and that completion will be
indicated at a later time.
All other codes indicate an error.
</p><p>
<b>Remarks</b><br>
This function is equivalent to
<a href="#divert_recv"><code>WinDivertRecv()</code></a> except:
</p>
<ul>
<li> <i>Overlapped I/O</i> is supported via the <code>lpOverlapped</code>
    parameter.</li>
<li> <i>Batched I/O</i> (i.e., receiving multiple packets at once) is
    supported.</li>
</ul>
<p>
Batched I/O makes it possible to receive up to <code>WINDIVERT_BATCH_MAX</code>
packets at once using a single operation, reducing the number of
kernel/user-mode context switches and improving performance.
To enable batched I/O:
</p>
<ol>
<li> pass an array of more than one <code>WINDIVERT_ADDRESS</code>
     to <code>pAddr</code>;</li>
<li> set <code>pAddrLen</code> to be the total size (in bytes) of the
     <code>pAddr</code> buffer; and</li>
<li> ensure that <code>pPacket</code> points to a sufficiently large buffer 
     capable of receiving multiple packets.</li>
</ol>
<p>
For example:
</p>
<pre>
    UINT8 packets[10 * MTU];        // Space for up to 10 packets
    WINDIVERT_ADDRESS addr[10];     // Addresses for up to 10 packets
    UINT addr_len = sizeof(addr);
    BOOL result = WinDivertRecvEx(handle, packets, ..., addr, &amp;addr_len, ...);
</pre>
<p>
upon successful completion, the value pointed to by <code>pAddrLen</code>
is updated to the total number of address bytes actually received.
For example, if a total of <code>5</code> packets were received, then
the value pointed to by <code>pAddrLen</code> will be set to
<code>(5*sizeof(WINDIVERT_ADDRESS))</code>.
The received packets are packed contiguously (i.e., no gaps) into the
<code>pPacket</code> buffer.
</dd></dl>

<a name="divert_send"><h3>5.7 WinDivertSend</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertSend</b>(
    __in HANDLE handle,
    __in const VOID *pPacket,
    __in UINT packetLen,
    __out_opt UINT *pSendLen,
    __in const WINDIVERT_ADDRESS *pAddr
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>handle</code>: A valid WinDivert handle created by
     <a href="#divert_open"><code>WinDivertOpen()</code></a>.</li>
<li> <code>pPacket</code>: A buffer containing a packet to be injected.</li>
<li> <code>packetLen</code>: The total length of the <code>pPacket</code> buffer.</li> 
<li> <code>pSendLen</code>: The total number of bytes injected.
     Can be <code>NULL</code> if this information is not required.</li>
<li> <code>pAddr</code>: The
    <a href="#divert_address">address</a> of the injected packet.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if a packet was successfully injected, or <code>FALSE</code> if
an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
</p><p>
Common errors include:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Name
</th>
<th>
Code
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<code>ERROR_HOST_UNREACHABLE</code>
</td>
<td>
1232
</td>
<td>
This error occurs when an <i>impostor</i> packet (with
<code>pAddr-&gt;Impostor</code> set to <code>1</code>) is injected and the
<code>ip.TTL</code> or <code>ipv6.HopLimit</code> field goes to zero.
This is a defense of <q>last resort</q> against infinite loops caused by
impostor packets.
</td>
</tr>
</table>
</center>
<p>
<b>Remarks</b><br>
Injects a packet into the network stack.
The injected packet may be one received from
<a href="#divert_recv"><code>WinDivertRecv()</code></a>, or a
modified version, or a completely new packet.
Injected packets can be captured and diverted again by other WinDivert
handles with lower priorities.
</p><p>
Only the <code>WINDIVERT_LAYER_NETWORK</code> and
<code>WINDIVERT_LAYER_NETWORK_FORWARD</code> <a href="#divert_layers">layers</a>
support packet injection, as summarized below:
</p>
<center>
<table border="1" cellpadding="5" width="40%">
<tr>
<th>
Layer
</th>
<th>
Inject?
</th>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_NETWORK</code>
</td>
<td>
&#10004;
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_NETWORK_FORWARD</code>
</td>
<td>
&#10004;
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_FLOW</code>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_SOCKET</code>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_LAYER_REFLECT</code>
</td>
<td>
</td>
</tr>
</table>
</center>
<p>
For the <code>WINDIVERT_LAYER_NETWORK</code> layer the
<code>pAddr-&gt;Outbound</code> value determines which direction the packet
is injected.
If the <code>pAddr-&gt;Outbound</code> field is <code>1</code>,
the packet will be injected into the <i>outbound</i> path
(i.e. a packet leaving the local machine).
Else, if <code>pAddr-&gt;Outbound</code> is <code>0</code>,
the packet is injected into the <i>inbound</i> path (i.e. a packet arriving
to the local machine).
Note that only the <code>Outbound</code> field, and <i>not</i> the IP addresses in 
the injected packet, determines the packet's direction.
</p><p>
For packets injected into the <i>inbound</i> path, the
<code>pAddr-&gt;Network.IfIdx</code> and
<code>pAddr-&gt;Network.SubIfIdx</code> fields are assumed to contain valid
interface numbers.
These may be retrieved from <a href="#divert_recv"><code>WinDivertRecv()</code></a>
(for packet modification),
or from the <a href="http://msdn.microsoft.com/en-us/library/aa366073%28v=VS.85%29.aspx">IP Helper API</a>.
</p><p>
For <i>outbound</i> injected packets, the <code>IfIdx</code> and <code>SubIfIdx</code>
fields are currently ignored and may be arbitrary values.
Injecting an inbound packet on the outbound path <i>may</i> work (for some
types of packets), however this should be considered "undocumented" behavior,
and may be changed in the future.
</p><p>
For <i>impostor</i> packets (where <code>pAddr-&gt;Impostor</code> is set to
<code>1</code>) WinDivert will automatically decrement the
<code>ip.TTL</code> or <code>ipv6.HopLimit</code> fields before reinjection.
This is to mitigate infinite loops since WinDivert cannot prevent
impostor packets from being captured again by
<a href="#divert_recv"><code>WinDivertRecv()</code></a>.
</p><p>
Injected packets must have the correct checksums or have the corresponding
<code>pAddr-&gt;*Checksum</code> flag unset.
A packet/address pair captured by
<a href="#divert_recv"><code>WinDivertRecv()</code></a> is guaranteed to satisfy
this condition, so can be reinjected unmodified without recalculating
checksums.
Otherwise, if a modification is necessary,
checksums can be recalculated using the
<a href="#divert_helper_calc_checksums"><code>WinDivertHelperCalcChecksums()</code></a>
function.
</p>
</dd></dl>

<a name="divert_send_ex"><h3>5.8 WinDivertSendEx</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertSendEx</b>(
    __in HANDLE handle,
    __in const VOID *pPacket,
    __in UINT packetLen,
    __out_opt UINT *pSendLen,
    __in UINT64 flags,
    __in const WINDIVERT_ADDRESS *pAddr,
    __in UINT addrLen,
    __inout_opt LPOVERLAPPED lpOverlapped
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>handle</code>: A valid WinDivert handle created by
     <a href="#divert_open"><code>WinDivertOpen()</code></a>.</li>
<li> <code>pPacket</code>: A buffer containing the packet(s) to be injected.</li>
<li> <code>packetLen</code>: The total length of the buffer <code>pPacket</code>.</li>
<li> <code>pSendLen</code>: The total number of bytes injected.
     Can be <code>NULL</code> if this information is not required.</li>
<li> <code>flags</code>: Reserved, set to zero.</li>
<li> <code>pAddr</code>: The
     <a href="#divert_address"><code>address(es)</code></a> of the injected
     packet(s).</li>
<li> <code>addrLen</code>: The total length (in bytes) of the <code>pAddr</code>
     buffer.</li>
<li> <code>lpOverlapped</code>: An optional pointer to a <code>OVERLAPPED</code>
     structure.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if a packet was successfully injected, or <code>FALSE</code>
otherwise.
Use <code>GetLastError()</code> to get the reason.
The error code <code>ERROR_IO_PENDING</code> indicates that the overlapped
operation has been successfully initiated and that completion will be
indicated at a later time.
All other codes indicate an error.
</p><p>
<b>Remarks</b><br>
This function is equivalent to
<a href="#divert_recv"><code>WinDivertSend()</code></a> except:
</p>
<ul>
<li> <i>Overlapped I/O</i> is supported via the <code>lpOverlapped</code>
    parameter.</li>
<li> <i>Batched I/O</i> (i.e., sending multiple packets at once) is
    supported.</li>
</ul>
<p>
Batched I/O makes it possible to send up to <code>WINDIVERT_BATCH_MAX</code>
packets at once using a single operation, reducing the number of
kernel/user-mode context switches and improving performance.
To use batched I/O:
</p>
<ol>
<li> pack <i>N</i> packets into the <code>pPacket</code> buffer
     (with no gaps between packets);</li>
<li> set <code>packetLen</code> to be the total sum of the <i>N</i> packet lengths;
     </li>
<li> pack the corresponding <i>N</i> <code>WINDIVERT_ADDRESS</code>
     address structures into the <code>pAddr</code> buffer; and </li>
<li> set <code>addrLen</code> to be the total size (in bytes) of the <code>pAddr</code>
    buffer.</li>
</ol>
</dd></dl>

<a name="divert_shutdown"><h3>5.9 WinDivertShutdown</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertShutdown</b>(
    __in HANDLE handle,
    __in WINDIVERT_SHUTDOWN how);
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>handle</code>: A valid WinDivert handle created by
     <a href="#divert_open"><code>WinDivertOpen()</code></a>.</li>
<li> <code>how</code>: A <code>WINDIVERT_SHUTDOWN</code> value to indicate how
     the handle should be shutdown.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
This operation causes all or part of a WinDivert handle to be shut down.
The possible values for <code>how</code> are:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
How
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<code>WINDIVERT_SHUTDOWN_RECV</code>
</td>
<td>
Stop new packets being queued for
<a href="#divert_recv"><code>WinDivertRecv()</code></a>.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_SHUTDOWN_SEND</code>
</td>
<td>
Stop new packets being injected via
<a href="#divert_send"><code>WinDivertSend()</code></a>.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_SHUTDOWN_BOTH</code>
</td>
<td>
Equivalent to <code>(WINDIVERT_SHUTDOWN_RECV | WINDIVERT_SHUTDOWN_SEND)</code>.
</td>
</tr>
</table>
</center>
<p>
Note that previously queued packets can still be received after
<code>WINDIVERT_SHUTDOWN_RECV</code>.
When the packet queue is empty,
<a href="#divert_recv"><code>WinDivertRecv()</code></a>
will fail with <code>ERROR_NO_DATA</code>.
</p>
</dd></dl>

<a name="divert_close"><h3>5.10 WinDivertClose</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertClose</b>(
    __in HANDLE handle
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>handle</code>: A valid WinDivert handle created by
     <a href="#divert_open"><code>WinDivertOpen()</code></a>.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Closes a WinDivert handle created by
<a href="#divert_open"><code>WinDivertOpen()</code></a>.
</p>
</dd></dl>

<a name="divert_set_param"><h3>5.11 WinDivertSetParam</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertSetParam</b>(
    __in HANDLE handle,
    __in WINDIVERT_PARAM param,
    __in UINT64 value);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>handle</code>: A valid WinDivert handle created by
     <a href="#divert_open"><code>WinDivertOpen()</code></a>.</li>
<li> <code>param</code>: A WinDivert parameter name.</li>
<li> <code>value</code>: The parameter's new value.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Sets a WinDivert parameter.
Currently, the following WinDivert parameters are defined.
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Parameter
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<code>WINDIVERT_PARAM_QUEUE_LENGTH</code>
</td>
<td>
Sets the maximum length of the packet queue for
<a href="#divert_recv"><code>WinDivertRecv()</code></a>.
The default value is <code>WINDIVERT_PARAM_QUEUE_LENGTH_DEFAULT</code>,
the minimum is <code>WINDIVERT_PARAM_QUEUE_LENGTH_MIN</code>, and the maximum
is <code>WINDIVERT_PARAM_QUEUE_LENGTH_MAX</code>.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_PARAM_QUEUE_TIME</code>
</td>
<td>
Sets the minimum time, in milliseconds, a packet can be queued before it is
automatically dropped.
Packets cannot be queued indefinitely, and ideally, packets should be
processed by the application as soon as is possible.
Note that this sets the <i>minimum</i> time a packet can be queued before 
it can be dropped.
The actual time may be exceed this value.
Currently the default value is <code>WINDIVERT_PARAM_QUEUE_TIME_DEFAULT</code>,
the minimum is <code>WINDIVERT_PARAM_QUEUE_TIME_MIN</code>, and the
maximum is <code>WINDIVERT_PARAM_QUEUE_TIME_MAX</code>.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_PARAM_QUEUE_SIZE</code>
</td>
<td>
Sets the maximum number of bytes that can be stored in the packet queue for
<a href="#divert_recv"><code>WinDivertRecv()</code></a>.
Currently the default value is <code>WINDIVERT_PARAM_QUEUE_SIZE_DEFAULT</code>,
the minimum is <code>WINDIVERT_PARAM_QUEUE_SIZE_MIN</code>,
and the maximum is <code>WINDIVERT_PARAM_QUEUE_SIZE_MAX</code>.
</td>
</tr>
</table>
</center>
</dd></dl>

<a name="divert_get_param"><h3>5.12 WinDivertGetParam</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertGetParam</b>(
    __in HANDLE handle,
    __in WINDIVERT_PARAM param,
    __out UINT64 *pValue);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>handle</code>: A valid WinDivert handle created by
     <a href="#divert_open"><code>WinDivertOpen()</code></a>.</li>
<li> <code>param</code>: A WinDivert parameter name.</li>
<li> <code>value</code>: The parameter's current value.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Gets a WinDivert parameter.
This function supports all the parameters from
<a href="#divert_set_param"><code>WinDivertSetParam()</code></a>,
and the following additional <q>read-only</q> parameters:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr>
<th>
Parameter
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
<code>WINDIVERT_PARAM_VERSION_MAJOR</code>
</td>
<td>
Returns the major version of the driver.
</td>
</tr>
<tr>
<td>
<code>WINDIVERT_PARAM_VERSION_MINOR</code>
</td>
<td>
Returns the minor version of the driver.
</td>
</tr>
</table>
</center>
</dd></dl>

<hr>
<a name="helper_programming_api"><h2>6. Helper Programming API</h2></a>

The WinDivert helper programming API is a collection of definitions
and functions designed to make writing WinDivert applications easier.
The use of the helper API is optional.

<a name="divert_iphdr"><h3>6.1 WINDIVERT_IPHDR</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT8  HdrLength:4;
    UINT8  Version:4;
    UINT8  TOS;
    UINT16 Length;
    UINT16 Id;
    UINT16 <i>...</i>;
    UINT8  TTL;
    UINT8  Protocol;
    UINT16 Checksum;
    UINT32 SrcAddr;
    UINT32 DstAddr;
} <b>WINDIVERT_IPHDR</b>, *<b>PWINDIVERT_IPHDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/IPv4#Packet_structure">here</a>
for more information.
</p><p>
<b>Remarks</b><br>
IPv4 header definition.
</p><p>
The following fields can only be get/set using the following macro
definitions:
</p>
<ul>
<li><i>FragOff</i> with <code>WINDIVERT_IPHDR_GET_FRAGOFF(<i>hdr</i>)</code> and
    <code>WINDIVERT_IPHDR_SET_FRAGOFF(<i>hdr</i>, <i>val</i>)</code></li>
<li><i>MF</i> with <code>WINDIVERT_IPHDR_GET_MF(<i>hdr</i>)</code> and
    <code>WINDIVERT_IPHDR_SET_MF(<i>hdr</i>, <i>val</i>)</code></li>
<li><i>DF</i> with <code>WINDIVERT_IPHDR_GET_DF(<i>hdr</i>)</code> and
    <code>WINDIVERT_IPHDR_SET_DF(<i>hdr</i>, <i>val</i>)</code></li>
<li><i>Reserved</i> with <code>WINDIVERT_IPHDR_GET_RESERVED(<i>hdr</i>)</code> and
    <code>WINDIVERT_IPHDR_SET_RESERVED(<i>hdr</i>, <i>val</i>)</code></li>
</ul>
</dl></dd>

<a name="divert_ipv6hdr"><h3>6.2 WINDIVERT_IPV6HDR</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT32 Version:4;
    UINT32 ...:28;
    UINT16 Length;
    UINT8  NextHdr;
    UINT8  HopLimit;
    UINT32 SrcAddr[4];
    UINT32 DstAddr[4];
} <b>WINDIVERT_IPV6HDR</b>, *<b>PWINDIVERT_IPV6HDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/IPv6_packet#Fixed_header">here</a>
for more information.
</p><p>
<b>Remarks</b><br>
IPv6 header definition.
</p><p>
The following fields can only be get/set using the following macro
definitions:
</p>
<ul>
<li><i>TrafficClass</i> with
    <code>WINDIVERT_IPV6HDR_GET_TRAFFICCLASS(<i>hdr</i>)</code> and
    <code>WINDIVERT_IPV6HDR_SET_TRAFFICCLASS(<i>hdr</i>, <i>val</i>)</code></li>
<li><i>FlowLabel</i> with <code>WINDIVERT_IPV6HDR_GET_FLOWLABEL(<i>hdr</i>)</code> and
    <code>WINDIVERT_IPV6HDR_SET_FLOWLABEL(<i>hdr</i>, <i>val</i>)</code></li>
</ul>
</dl></dd>

<a name="divert_icmphdr"><h3>6.3 WINDIVERT_ICMPHDR</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT8  Type;
    UINT8  Code;
    UINT16 Checksum;
    UINT32 Body;
} <b>WINDIVERT_ICMPHDR</b>, *<b>PWINDIVERT_ICMPHDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#ICMP_segment_structure">here</a>
for more information.
</p><p>
<b>Remarks</b><br>
ICMP header definition.
</p>
</dl></dd>

<a name="divert_icmpv6hdr"><h3>6.4 WINDIVERT_ICMPV6HDR</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT8  Type;
    UINT8  Code;
    UINT16 Checksum;
    UINT32 Body;
} <b>WINDIVERT_ICMPV6HDR</b>, *<b>PWINDIVERT_ICMPV6HDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/ICMPv6#Packet_format">here</a> for
more information.
</p><p>
<b>Remarks</b><br>
ICMPv6 header definition.
</p>
</dl></dd>

<a name="divert_tcphdr"><h3>6.5 WINDIVERT_TCPHDR</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT16 SrcPort;
    UINT16 DstPort;
    UINT32 SeqNum;
    UINT32 AckNum;
    UINT16 Reserved1:4;
    UINT16 HdrLength:4;
    UINT16 Fin:1;
    UINT16 Syn:1;
    UINT16 Rst:1;
    UINT16 Psh:1;
    UINT16 Ack:1;
    UINT16 Urg:1;
    UINT16 Reserved2:2;
    UINT16 Window;
    UINT16 Checksum;
    UINT16 UrgPtr;
} <b>WINDIVERT_TCPHDR</b>, *<b>PWINDIVERT_TCPHDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">here</a>
for more information.
</p><p>
<b>Remarks</b><br>
TCP header definition.
</p>
</dl></dd>

<a name="divert_udphdr"><h3>6.6 WINDIVERT_UDPHDR</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
typedef struct
{
    UINT16 SrcPort;
    UINT16 DstPort;
    UINT16 Length;
    UINT16 Checksum;
} <b>WINDIVERT_UDPHDR</b>, *<b>PWINDIVERT_UDPHDR</b>;
</pre>
</td></tr></table>
<dl><dd>
<p>
<b>Fields</b><br>
See <a href="http://en.wikipedia.org/wiki/User_Datagram_Protocol#Packet_structure">here</a>
for more information.
</p><p>
<b>Remarks</b><br>
UDP header definition.
</p>
</dl></dd>

<a name="divert_helper_parse_packet"><h3>6.7 WinDivertHelperParsePacket</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperParsePacket</b>(
    __in PVOID pPacket,
    __in UINT packetLen,
    __out_opt PWINDIVERT_IPHDR *ppIpHdr,
    __out_opt PWINDIVERT_IPV6HDR *ppIpv6Hdr,
    __out_opt UINT8 *pProtocol,
    __out_opt PWINDIVERT_ICMPHDR *ppIcmpHdr,
    __out_opt PWINDIVERT_ICMPV6HDR *ppIcmpv6Hdr,
    __out_opt PWINDIVERT_TCPHDR *ppTcpHdr,
    __out_opt PWINDIVERT_UDPHDR *ppUdpHdr,
    __out_opt PVOID *ppData,
    __out_opt UINT *pDataLen,
    __out_opt PVOID *ppNext,
    __out_opt UINT *pNextLen
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>pPacket</code>: The packet(s) to be parsed.</li>
<li> <code>packetLen</code>: The total length of the packet(s) <code>pPacket</code>.</li>
<li> <code>ppIpHdr</code>: Output pointer to a <code>WINDIVERT_IPHDR</code>.</li>
<li> <code>ppIpv6Hdr</code>: Output pointer to a <code>WINDIVERT_IPV6HDR</code>.</li>
<li> <code>pProtocol</code>: Output transport protocol.</li>
<li> <code>ppIcmpHdr</code>: Output pointer to a <code>WINDIVERT_ICMPHDR</code>.</li>
<li> <code>ppIcmpv6Hdr</code>: Output pointer to a <code>WINDIVERT_ICMPV6HDR</code>.</li>
<li> <code>ppTcpHdr</code>: Output pointer to a <code>WINDIVERT_TCPHDR</code>.</li>
<li> <code>ppUdpHdr</code>: Output pointer to a <code>WINDIVERT_UDPHDR</code>.</li>
<li> <code>ppData</code>: Output pointer to the packet's data/payload.</li>
<li> <code>pDataLen</code>: Output data/payload length.</li>
<li> <code>ppNext</code>: Output pointer to the next packet (if present).</li>
<li> <code>pNextLen</code>: Output next packet length.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
</p><p>
<b>Remarks</b><br>
Parses a raw packet or batch of packets (e.g. from <a
href="#divert_recv"><code>WinDivertRecv()</code></a>) into the
various packet headers and/or payloads that may or may not be present.
</p><p>
Each output parameter may be <code>NULL</code> or non-<code>NULL</code>.
For non-<code>NULL</code> parameters, this function will write the pointer to
the corresponding header/payload if it exists, or will write <code>NULL</code>
otherwise.
Any non-<code>NULL</code> pointer that is returned:
</p>
<ol>
<li> Is a pointer into the original <code>pPacket</code> packet buffer; and</li>
<li> There is enough space in <code>pPacket</code> to fit the header.</li>
</ol>
<p>
This function does not do any verification of the header/payload contents
beyond checking the header length and any other minimal information required
for parsing.
This function will always succeed provided the <code>pPacket</code> buffer
contains at least one IPv4 or IPv6 header and the <code>packetLen</code> is
correct.
</p><p>
By default this function will parse a single packet.
However, if either <code>ppNext</code> or <code>pNextLen</code> are
non-<code>NULL</code>, then the <code>pPacket</code> parameter can point
to a batch (&gt;1) of packets
(and <code>packetLen</code> can be the total length of the batch).
In this case, the function will parse the first packet, and a pointer to the
remaining packet(s) will be written to <code>ppNext</code>,
and the remaining length will be written to <code>pNextLen</code>.
This makes it convenient to loop over every packet in the batch as follows:
</p>
<pre>
    while (WinDivertHelperParsePacket(pPacket, packetLen, ..., &amp;pPacket, &amp;packetLen))
    {
        ...
    }
</pre>
</dd></dl>

<a name="divert_helper_hash_packet"><h3>6.8 WinDivertHelperHashPacket</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
UINT64 <b>WinDivertHelperHashPacket</b>(
    __in const VOID *pPacket,
    __in UINT packetLen,
    __in UINT64 seed = 0
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>pPacket</code>: The packet to be hashed.</li>
<li> <code>packetLen</code>: The total length of the packet <code>pPacket</code>.</li>
<li> <code>seed</code>: An optional seed value.</li>
</ul>
<p>
<b>Return Value</b><br>
A 64bit hash value.
</p><p>
<b>Remarks</b><br>
Calculates a 64bit hash value of the given packet.
Note that the hash function depends on the <i>packet's
IP and transport headers only</i>, and not the payload of the packet.
That said, a weak dependency on the payload will exist if the
TCP/UDP checksums are valid.
The hash function itself is based on the
<a href="https://cyan4973.github.io/xxHash/">xxHash</a> algorithm
and is <b>not</b> cryptographic.
</p><p>
The optional <code>seed</code> value is also incorporated into the hash.
<p>
</dd></dl>

<a name="divert_helper_parse_ipv4_address"><h3>6.9 WinDivertHelperParseIPv4Address</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperParseIPv4Address</b>(
    __in const char *addrStr,
    __out_opt UINT32 *pAddr
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>addrStr</code>: The address string.</li>
<li> <code>pAddr</code>: Output address.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Parses an IPv4 address stored in <code>addrStr</code>.
If <code>pAddr</code> is non-<code>NULL</code>, the result is be stored in
host-byte-order.
Use <a href="#divert_helper_hton"><code>WinDivertHelperHtonl()</code></a>
to convert the result into network-byte-order.
</p>
</dd></dl>

<a name="divert_helper_parse_ipv6_address"><h3>6.10 WinDivertHelperParseIPv6Address</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperParseIPv6Address</b>(
    __in const char *addrStr,
    __out_opt UINT32 *pAddr
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>addrStr</code>: The address string.</li>
<li> <code>pAddr</code>: Output address.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Parses an IPv6 address stored in <code>addrStr</code>.
If <code>pAddr</code> is non-<code>NULL</code>, the buffer assumed 
to be large enough to hold a 16-byte IPv6 address.
The result is stored in host-byte-order.
Use <a href="#divert_helper_hton"><code>WinDivertHelperHtonIPv6Address()</code></a>
to convert the result into network-byte-order.
</p>
</dd></dl>

<a name="divert_helper_format_ipv4_address"><h3>6.11 WinDivertHelperFormatIPv4Address</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperFormatIPv4Address</b>(
    __in UINT32 addr,
    __out char *buffer,
    __in UINT bufLen
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>addr</code>: The IPv4 address in host-byte order.</li>
<li> <code>buffer</code>: The buffer to store the formatted string.</li>
<li> <code>bufLen</code>: The length of <code>buffer</code>.
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Convert an IPv4 address into a string.
</p>
</dd></dl>

<a name="divert_helper_format_ipv6_address"><h3>6.12 WinDivertHelperParseIPv6Address</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperFormatIPv6Address</b>(
    __in const UINT32 *pAddr,
    __out char *buffer,
    __in UINT bufLen
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>pAddr</code>: The IPv6 address in host-byte order.</li>
<li> <code>buffer</code>: The buffer to store the formatted string.</li>
<li> <code>bufLen</code>: The length of <code>buffer</code>.
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Convert an IPv6 address into a string.
</p>
</dd></dl>

<a name="divert_helper_calc_checksums"><h3>6.13 WinDivertHelperCalcChecksums</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperCalcChecksums</b>(
    __inout VOID *pPacket,
    __in UINT packetLen,
    __out_opt WINDIVERT_ADDRESS *pAddr,
    __in UINT64 flags
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>pPacket</code>: The packet to be modified.</li>
<li> <code>packetLen</code>: The total length of the packet <code>pPacket</code>.</li>
<li> <code>pAddr</code>: Optional pointer to a
    <a href="#divert_address"><code>WINDIVERT_ADDRESS</code></a> structure.</li>
<li> <code>flags</code>: One or more of the following flags:
<ul>
<li> <code>WINDIVERT_HELPER_NO_IP_CHECKSUM</code>: Do not calculate the IPv4
    checksum.</li>
<li> <code>WINDIVERT_HELPER_NO_ICMP_CHECKSUM</code>: Do not calculate the ICMP
    checksum.</li>
<li> <code>WINDIVERT_HELPER_NO_ICMPV6_CHECKSUM</code>: Do not calculate the ICMPv6
    checksum.</li>
<li> <code>WINDIVERT_HELPER_NO_TCP_CHECKSUM</code>: Do not calculate the TCP
    checksum.</li>
<li> <code>WINDIVERT_HELPER_NO_UDP_CHECKSUM</code>: Do not calculate the UDP
    checksum.</li>
</ul></li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
</p><p>
<b>Remarks</b><br>
(Re)calculates the checksum for any IPv4/ICMP/ICMPv6/TCP/UDP checksum present
in the given packet.
Individual checksum calculations may be disabled via the appropriate flag.
Typically this function should be invoked on a modified packet before it is
injected with <a href="#divert_send"><code>WinDivertSend()</code></a>.
</p><p>
By default this function will calculate each checksum from scratch, even if
the existing checksum is correct.
This may be inefficient for some applications.
For better performance, incremental checksum calculations should be used
instead (not provided by this API).
</p><p>
If <code>pAddr</code> is non-<code>NULL</code>, this function sets
the corresponding <code>*Checksum</code> flag
(see <a href="#divert_address"><code>WINDIVERT_ADDRESS</code></a>).
Normally, <code>pAddr</code> should point to the address 
passed to <a href="#divert_send"><code>WinDivertSend()</code></a> for
packet injection.
</p>
</dd></dl>

<a name="divert_helper_dec_ttl"><h3>6.14 WinDivertHelperDecrementTTL</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperDecrementTTL</b>(
    __inout VOID *packet,
    __in packetLen
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>pPacket</code>: The packet to be modified.</li>
<li> <code>packetLen</code>: The total length of the packet <code>pPacket</code>.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
Returns <code>FALSE</code> if the <code>ip.TTL</code> or
<code>ipv6.HopHimit</code> fields go to <code>0</code>.
</p><p>
<b>Remarks</b><br>
Decrements the <code>ip.TTL</code> or
<code>ipv6.HopHimit</code> field by <code>1</code>, and returns
<code>TRUE</code> only if the result is non-zero.
This is useful for applications where packet loops may be a problem.
</p><p>
For IPv4, this function will preserve the validity of the IPv4 checksum.
That is, if the packet had a valid checksum before the operation, the
resulting checksum will also be valid after the operation.
This function updates the checksum field incrementally.
</p>
</dd></dl>

<a name="divert_helper_compile_filter"><h3>6.15 WinDivertHelperCompileFilter</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperCompileFilter</b>(
    __in const char *filter,
    __in WINDIVERT_LAYER layer,
    __out_opt char *object,
    __in UINT objLen,
    __out_opt const char **errorStr,
    __out_opt UINT *errorPos
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>filter</code>: The packet filter string to be checked.</li>
<li> <code>layer</code>: The layer.</li>
<li> <code>object</code>: The compiled filter object.</li>
<li> <code>objLen</code>: The length of the <code>object</code> buffer.</li>
<li> <code>errorStr</code>: The error description.</li>
<li> <code>errorPos</code>: The error position.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if the packet filter compilation is successful, <code>FALSE</code>
otherwise.
</p><p>
<b>Remarks</b><br>
Compiles the given packet filter string into a compact <q>object</q>
representation that is optionally stored in <code>object</code> if non-NULL.
The <q>object</q> representation is a valid null terminated C string, but is
otherwise opaque and not meant to be human readable.
The object representation can be passed to all WinDivert functions,
such as <a href="#divert_open"><code>WinDivertOpen()</code></a>, in place of the
human-readable filter string equivalent.
</p>
<p>
The compilation operation will succeed if the given filter string is
valid with respect to the
<a href="#filter_language">filter language</a>.
Otherwise, if the filter is invalid, then a human readable description of
the error is
returned by <code>errorStr</code> (if non-<code>NULL</code>), and the error's
position is returned by <code>errorPos</code> (if non-<code>NULL</code>).
</p><p>
Note that all strings returned through <code>errorStr</code> are global static
objects, and therefore do not need to be deallocated.
<p>
</dd></dl>

<a name="divert_helper_eval_filter"><h3>6.16 WinDivertHelperEvalFilter</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperEvalFilter</b>(
    __in const char *filter,
    __in const VOID *pPacket,
    __in UINT packetLen,
    __in const WINDIVERT_ADDRESS *pAddr
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>filter</code>: The packet filter string to be evaluated.</li>
<li> <code>pPacket</code>: The packet.</li>
<li> <code>packetLen</code>: The total length of the packet <code>pPacket</code>.</li>
<li> <code>pAddr</code>: The <code>WINDIVERT_ADDRESS</code> of the packet
    <code>pPacket</code>.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if the packet matches the filter string,
    <code>FALSE</code> otherwise.
</p><p>
<b>Remarks</b><br>
Evaluates the given packet against the given packet filter string.
This function returns <code>TRUE</code> if the packet matches, and
returns <code>FALSE</code> otherwise.
</p><p>
This function also returns <code>FALSE</code> if an error occurs, in which
case <code>GetLastError()</code> can be used to get the reason for the error.
Otherwise, if no error occurred, <code>GetLastError()</code> will return
<code>0</code>.
</p><p>
Note that this function is relatively slow since the packet filter string
will be (re)compiled for each call.
This overhead can be minimized by pre-compiling the filter string into the
object representation using the
<a href="#divert_helper_compile_filter"><code>WinDivertHelperCompileFilter()</code></a>
function.
<p>
</dd></dl>

<a name="divert_helper_format_filter"><h3>6.17 WinDivertHelperFormatFilter</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
BOOL <b>WinDivertHelperEvalFilter</b>(
    __in const char *filter,
    __in WINDIVERT_LAYER layer,
    __out char *buffer,
    __in UINT bufLen
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>filter</code>: The packet filter string to be evaluated.</li>
<li> <code>layer</code>: The layer.</li>
<li> <code>buffer</code>: A buffer for the formatted filter.</li>
<li> <code>bufLen</code>: The length of <code>buffer</code>.</li>
</ul>
<p>
<b>Return Value</b><br>
<code>TRUE</code> if successful, <code>FALSE</code> if an error occurred.
Use <code>GetLastError()</code> to get the reason for the error.
</p><p>
<b>Remarks</b><br>
Formats the given filter string or object.
This function is mainly useful for <q>decompiling</q> the filter object
representation back into a human-readable filter string representation.
One application is the <code>WINDIVERT_LAYER_REFLECT</code> layer,
where the filter object associated with the reflection event is
returned by <a href="#divert_recv"><code>WinDivertRecv()</code></a>.
</p>
</dd></dl>

<a name="divert_helper_ntoh"><h3>6.18 WinDivertHelperNtoh*</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
UINT16 <b>WinDivertHelperNtohs</b>(
    __in UINT16 x
);
UINT32 <b>WinDivertHelperNtohl</b>(
    __in UINT32 x
);
UINT64 <b>WinDivertHelperNtohll</b>(
    __in UINT64 x
);
void <b>WinDivertHelperNtohIPv6Address</b>(
    __in const UINT *inAddr,
    __out UINT *outAddr
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>x</code>: The input value in network byte-order.</li>
<li> <code>inAddr</code>: The input IPv6 address in network byte-order.</li>
<li> <code>outAddr</code>: A buffer for the output IPv6 address in host
	byte-order.</li>
</ul>
<p>
<b>Return Value</b><br>
The output value in host byte order.
</p><p>
<b>Remarks</b><br>
Converts a value/IPv6-address from network to host byte-order.
</p>
</dd></dl>

<a name="divert_helper_hton"><h3>6.19 WinDivertHelperHton*</h3></a>
<table border="1" cellpadding="5"><tr><td>
<pre>
UINT16 <b>WinDivertHelperHtons</b>(
    __in UINT16 x
);
UINT32 <b>WinDivertHelperHtonl</b>(
    __in UINT32 x
);
UINT64 <b>WinDivertHelperHtonll</b>(
    __in UINT64 x
);
void <b>WinDivertHelperHtonIPv6Address</b>(
    __in const UINT *inAddr,
    __out UINT *outAddr
);
</pre>
</td></tr></table>
<dl><dd>
<p><b>Parameters</b></p>
<ul>
<li> <code>x</code>: The input value in host byte-order.</li>
<li> <code>inAddr</code>: The input IPv6 address in host byte-order.</li>
<li> <code>outAddr</code>: A buffer for the output IPv6 address in network
	byte-order.</li>
</ul>
<p>
<b>Return Value</b><br>
The output value in network byte order.
</p><p>
<b>Remarks</b><br>
Converts a value/IPv6-address from host to network byte-order.
</p>
</dd></dl>

<hr>
<a name="filter_language"><h2>7. Filter Language</h2></a>

<p>
The <a href="#divert_open"><code>WinDivertOpen()</code></a> function accepts a
string containing a <i>filter</i>.
Only packets/events that match the filter will be blocked and/or captured.
All other non-matching packets/events will be allowed to continue as normal.
</p><p>
The filter allows an application to select only a subset traffic that is of
interest.
For example, a HTTP blacklist filter is only interested in packets that
might contain URLs.
This could be achieved using the following filter.
</p>
<pre>
HANDLE handle = WinDivertOpen(
    "outbound and "
    "tcp.PayloadLength &gt; 0 and "
    "tcp.DstPort == 80", 0, 0, 0);
</pre>
<p>
This filter selects only the subset of all traffic that is:
</p>
<ol>
<li>outbound;</li>
<li>contains a non-empty payload; and</li>
<li>has TCP destination port 80 (i.e. HTTP web traffic).
</ol>
<p>
A <i>filter</i> is a Boolean expression of the form:
</p>
<pre>
        <i>FILTER</i> := true | false | <i>FILTER</i> and <i>FILTER</i> | <i>FILTER</i> or <i>FILTER</i> | (<i>FILTER</i>) | (<i>FILTER</i>? <i>FILTER</i>: <i>FILTER</i>) | <i>TEST</i>
</pre>
<p>
C-style syntax <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> may also
be used instead of <code>and</code>, <code>or</code>, and <code>not</code>, respectively.
C-style <i>conditional operators</i> are also supported,
where the expression <code>(A? B: C)</code> evaluates to:
</p>
<ul>
<li> <code>B</code> if <code>A</code> evaluates to <code>true</code>; or</li>
<li> <code>C</code> if <code>A</code> evaluates to <code>false</code>.
</ul>
<p>
A <i>test</i> is of the following form:
</p>
<pre>
        <i>TEST</i> := <i>TEST0</i> | not <i>TEST0</i>
        <i>TEST0</i> := <i>FIELD</i> | <i>FIELD</i> op <i>VAL</i>
</pre>
<p>
where <code>op</code> is one of the following:
</p>
<center>
<table border="1" cellpadding="5">
<tr><th>Operator</th><th>Description</th></tr>
<tr><td><code>==</code> or <code>=</code></td><td>Equal</td></tr>
<tr><td><code>!=</code></td><td>Not equal</td></tr>
<tr><td><code>&lt;</code></td><td>Less-than</td></tr>
<tr><td><code>&gt;</code></td><td>Greater-than</td></tr>
<tr><td><code>&lt;=</code></td><td>Less-than-or-equal</td></tr>
<tr><td><code>&gt;=</code></td><td>Greater-than-or-equal</td></tr>
</table>
</center>
<p>
and <code><i>VAL</i></code> is a decimal number, hexadecimal number, IPv4
address, IPv6 address or a layer-specific macro.
If the <q><code>op <i>VAL</i></code></q> is missing, the test is implicitly
<q><code><i>FIELD</i> != 0</code></q>.
</p><p>
Finally, a <i>field</i> is some layer-specific property matching the packet
or event.
The possible fields are:
</p>
<center>
<table border="1" cellpadding="5">
<tr><th>Field</th><th colspan="5">Layer</th><th>Description</th></tr>
<tr><th></th><th><code>NETWORK</code></th><th><code>FORWARD</code></th><th><code>FLOW&nbsp;&nbsp;&nbsp;</code></th><th><code>SOCKET&nbsp;</code></th><th><code>REFLECT</code></th><th></th></tr>
<tr><td><code>zero</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>The value zero</td></tr>
<tr><td><code>timestamp</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>The packet/event timestamp</td></tr>
<tr><td><code>event</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>The event</td></tr>
<tr><td><code>outbound</code></td><td>&#10004;</td><td></td><td>&#10004;</td><td></td><td></td><td>Is outbound?</td></tr>
<tr><td><code>inbound</code></td><td>&#10004;</td><td></td><td>&#10004;</td><td></td><td></td><td>Is inbound?</td></tr>
<tr><td><code>ifIdx</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>Interface index</td></tr>
<tr><td><code>subIfIdx</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>Sub-interface index</td></tr>
<tr><td><code>loopback</code></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is loopback packet?</td></tr>
<tr><td><code>impostor</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>Is impostor packet?</td></tr>
<tr><td><code>fragment</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>Is IP fragment packet?</td></tr>
<tr><td><code>endpointId</code></td><td></td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>Endpoint ID</td></tr>
<tr><td><code>parentEndpointId</code></td><td></td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>Parent endpoint ID</td></tr>
<tr><td><code>processId</code></td><td></td><td></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>Process ID</td></tr>
<tr><td><code>random8</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>8-bit random number</td></tr>
<tr><td><code>random16</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>16-bit random number</td></tr>
<tr><td><code>random32</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>32-bit random number</td></tr>
<tr><td><code>layer</code></td><td></td><td></td><td></td><td></td><td>&#10004;</td><td>The handle's layer</td></tr>
<tr><td><code>priority</code></td><td></td><td></td><td></td><td></td><td>&#10004;</td><td>The handle's priority</td></tr>
<tr><td><code>packet[i]</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <code>i</code><sup>th</sup> 8-bit word of the packet</td></tr>
<tr><td><code>packet16[i]</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <code>i</code><sup>th</sup> 16-bit word of the packet</td></tr>
<tr><td><code>packet32[i]</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <code>i</code><sup>th</sup> 32-bit word of the packet</td></tr>
<tr><td><code>length</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The packet length</td></tr>
<tr><td><code>ip</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is IPv4?</td></tr>
<tr><td><code>ipv6</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is IPv6?</td></tr>
<tr><td><code>icmp</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is ICMP?</td></tr>
<tr><td><code>icmpv6</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is ICMPv6?</td></tr>
<tr><td><code>tcp</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is TCP?</td></tr>
<tr><td><code>udp</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td><td>Is UDP?</td></tr>
<tr><td><code>protocol</code></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>The protocol</td></tr>
<tr><td><code>localAddr</code></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>The local address</td></tr>
<tr><td><code>localPort</code></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>The local port</td></tr>
<tr><td><code>remoteAddr</code></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>The remote address</td></tr>
<tr><td><code>remotePort</code></td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td></td><td>The remote port</td></tr>
<tr><td><code>ip.*</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>IPv4 fields (see <code>WINDIVERT_IPHDR</code>)</td></tr>
<tr><td><code>ipv6.*</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>IPv6 fields (see <code>WINDIVERT_IPV6HDR</code>)</td></tr>
<tr><td><code>icmp.*</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>ICMP fields (see <code>WINDIVERT_ICMPHDR</code>)</td></tr>
<tr><td><code>icmpv6.*</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>ICMPV6 fields (see <code>WINDIVERT_ICMPV6HDR</code>)</td></tr>
<tr><td><code>tcp.*</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>TCP fields (see <code>WINDIVERT_TCPHDR</code>)</td></tr>
<tr><td><code>tcp.PayloadLength</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The TCP payload length</td></tr>
<tr><td><code>tcp.Payload[i]</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <code>i</code><sup>th</sup> 8-bit word of the TCP payload</td></tr>
<tr><td><code>tcp.Payload16[i]</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <code>i</code><sup>th</sup> 16-bit word of the TCP payload</td></tr>
<tr><td><code>tcp.Payload32[i]</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <code>i</code><sup>th</sup> 32-bit word of the TCP payload</td></tr>
<tr><td><code>udp.*</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>UDP fields (see <code>WINDIVERT_UDPHDR</code>)</td></tr>
<tr><td><code>udp.PayloadLength</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The UDP payload length</td></tr>
<tr><td><code>udp.Payload[i]</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <code>i</code><sup>th</sup> 8-bit word of the UDP payload</td></tr>
<tr><td><code>udp.Payload16[i]</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <code>i</code><sup>th</sup> 16-bit word of the UDP payload</td></tr>
<tr><td><code>udp.Payload32[i]</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td>The <code>i</code><sup>th</sup> 32-bit word of the UDP payload</td></tr>
</table>
</center>
<p>
A <i>test</i> will also fails if the field is not relevant.
For example, the test <q><code>tcp.DstPort == 80</code></q> will fail if the
packet does not contain a TCP header.
</p><p>
The <code>processId</code> field matches the ID of the process associated
to an event.
Due to technical limitations, this field is not supported by the
<code>WINDIVERT_LAYER_NETWORK*</code> layers.
That said, it is usually possible to associate process IDs to network packets 
matching the same network 5-tuple.
Note that a fundamental race condition exists between the <code>processId</code>
and the termination of the corresponding process, see
the <a href="#known_issues">know issues</a> listed below.
</p><p>
The <code>packet*[i]</code>, <code>tcp.Payload*[i]</code> and
<code>udp.Payload*[i]</code> fields take an <i>index</i> parameter (<code>i</code>).
The following indexing schemes are supported:
</p>
<ul>
<li> <i>Undecorated integer</i> (e.g., <code>packet32[10]</code>):
    evaluates to the <code>i</code><sup>th</sup> word from the start of
    the packet/payload.
    This is essentially C-style array indexing; </li>
<li> <i>Negative decorated integer</i> (e.g., <code>packet32[-10]</code>):
    evaluates to the <code>i</code><sup>th</sup> word from the <b>end</b>
    of the packet/payload.
    Here the index (<code>-1</code>) is the first full word that fits; and </li>
<li> <i>Byte decorated (negative) integer</i> (e.g., <code>packet32[10b]</code>
    or <code>packet32[-10b]</code>):
    evaluated to the word offset by <code>i</code> bytes from the
    start (or end) of the packet/payload.
</ul>
<p>
These fields can be used to match filters against the contents of
packets/payloads in addition to address/header information.
Words are assumed to be in network-byte ordering.
If the index is out-of-bounds then the corresponding <i>test</i> is
deemed to have failed.
</p><p>
The <code>random*</code> fields are not really random but use a
deterministic hash value calculated using the
<a href="#divert_helper_hash_packet"><code>WinDivertHelperHashPacket()</code></a>
function.
</p><p>
Layer-specific macros make it possible to match events
and layers symbolically, e.g., <q><code>event == CONNECT</code></q> or
<q><code>layer == SOCKET</code></q>.
The possible macros are:
</p>
<center>
<table border="1" cellpadding="5" width="75%">
<tr><th>Macro</th><th colspan="5">Layer</th><th>Value</th></tr>
<tr><th></th><th><code>NETWORK</code></th><th><code>FORWARD</code></th><th><code>FLOW&nbsp;&nbsp;&nbsp;</code></th><th><code>SOCKET&nbsp;</code></th><th><code>REFLECT</code></th><th></th></tr>
<tr><td><code>TRUE</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td><code>1</code></td></tr>
<tr><td><code>FALSE</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td><code>0</code></td></tr>
<tr><td><code>TCP</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td><code>IPPROTO_TCP</code> (<code>6</code>)</td></tr>
<tr><td><code>UDP</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td><code>IPPROTO_UDP</code> (<code>17</code>)</td></tr>
<tr><td><code>ICMP</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td><code>IPPROTO_ICMP</code> (<code>1</code>)</td></tr>
<tr><td><code>ICMPV6</code></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td><code>IPPROTO_ICMPV6</code> (<code>58</code>)</td></tr>
<tr><td><code>PACKET</code></td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td></td><td><code>WINDIVERT_EVENT_NETWORK_PACKET</code></td></tr>
<tr><td><code>ESTABLISHED</code></td><td></td><td></td><td>&#10004;</td><td></td><td></td><td><code>WINDIVERT_EVENT_FLOW_ESTABLISHED</code></td></tr>
<tr><td><code>DELETED</code></td><td></td><td></td><td>&#10004;</td><td></td><td></td><td><code>WINDIVERT_EVENT_FLOW_DELETED</code></td></tr>
<tr><td><code>BIND</code></td><td></td><td></td><td></td><td>&#10004;</td><td></td><td><code>WINDIVERT_EVENT_SOCKET_BIND</code></td></tr>
<tr><td><code>CONNECT</code></td><td></td><td></td><td></td><td>&#10004;</td><td></td><td><code>WINDIVERT_EVENT_SOCKET_CONNECT</code></td></tr>
<tr><td><code>ACCEPT</code></td><td></td><td></td><td></td><td>&#10004;</td><td></td><td><code>WINDIVERT_EVENT_SOCKET_ACCEPT</code></td></tr>
<tr><td><code>LISTEN</code></td><td></td><td></td><td></td><td>&#10004;</td><td></td><td><code>WINDIVERT_EVENT_SOCKET_LISTEN</code></td></tr>
<tr><td><code>OPEN</code></td><td></td><td></td><td></td><td></td><td>&#10004;</td><td><code>WINDIVERT_EVENT_REFLECT_OPEN</code></td></tr>
<tr><td><code>CLOSE</code></td><td></td><td></td><td></td><td>&#10004;</td><td>&#10004;</td><td><code>WINDIVERT_EVENT_SOCKET_CLOSE</code>
for the <code>SOCKET</code> layer, or
<code>WINDIVERT_EVENT_REFLECT_CLOSE</code> for the <code>REFLECT</code>
layer.</td></tr>
<tr><td><code>NETWORK</code></td><td></td><td></td><td></td><td></td><td>&#10004;</td><td><code>WINDIVERT_LAYER_NETWORK</code></td></tr>
<tr><td><code>NETWORK_FORWARD</code></td><td></td><td></td><td></td><td></td><td>&#10004;</td><td><code>WINDIVERT_LAYER_NETWORK_FORWARD</code></td></tr>
<tr><td><code>FLOW</code></td><td></td><td></td><td></td><td></td><td>&#10004;</td><td><code>WINDIVERT_LAYER_FLOW</code></td></tr>
<tr><td><code>SOCKET</code></td><td></td><td></td><td></td><td></td><td>&#10004;</td><td><code>WINDIVERT_LAYER_SOCKET</code></td></tr>
<tr><td><code>REFLECT</code></td><td></td><td></td><td></td><td></td><td>&#10004;</td><td><code>WINDIVERT_LAYER_REFLECT</code></td></tr>
</table>
</center>

<a name="filter_examples"><h3>7.1 Filter Examples</h3></a>

<ol>
<li>
Divert all outbound (non-local) web traffic:
<pre>
HANDLE handle = WinDivertOpen(
        "outbound and !loopback and "
        "(tcp.DstPort == 80 or udp.DstPort == 53)",
        0, 0, 0
    );
</pre>
</li>
<li>
Divert all inbound TCP SYNs:
<pre>
HANDLE handle = WinDivertOpen(
        "inbound and "
        "tcp.Syn",
        0, 0, 0
    );
</pre>
</li>
<li>
Divert all traffic:
<pre>
HANDLE handle = WinDivertOpen("true", 0, 0, 0);
</pre>
</li>
<li>
Divert no traffic:
<pre>
HANDLE handle = WinDivertOpen("false", 0, 0, 0);
</pre>
This is useful for packet injection.
</ol>

<a name="filter_usage"><h3>7.2 Filter Usage</h3></a>

<p>
The purpose of the filter is to help applications select the subset of
all network traffic that the application is interested in.
Ideally the filter should be
</p>
<ol>
<li> As short as possible; and</li>
<li> As selective as possible.</li>
</ol>
<p>
For some applications these two objectives can conflict.
That is, a selective filter is not short, and a short filter is not selective.
For such applications the developer should experiment with different
filter configurations and carefully measure the performance impact to
find the optimal solution.
</p>

<hr>
<a name="performance"><h2>8. Performance</h2></a>

<p>
Using WinDivert to redirect network traffic to/from a user application incurs
performance overheads, such as copying packet data and user/kernel mode
context switching.
Under heavy load (&geq;1Gbps) these overheads can be significant.
The following techniques can be used to
reduce overheads (in order of importance):
</p>
<ol>
<li><i>Selective Filter</i>: Only select the subset of network traffic
    the user application is interested in.
    Non-matching traffic will continue to use the default path without
    incurring additional overheads.</li>
<li><i>Batch Mode</i>: The
    <a href="#divert_recv_ex">WinDivertRecvEx()</a> and
    <a href="#divert_send_ex">WinDivertSendEx()</a> functions
    support <i>batching</i> that allows several packets to be
    received/sent at once.
    This can significantly reduce the overheads relating to
    user/kernel mode context switching.</li>
<li><i>Multi-threading</i>: It is possible to spread packet processing
    over multiple threads ensuring that the user application does not
    become a bottleneck.
    That said, sometimes spawning too many threads can degrade performance.
    </li>
<li><i>Small Buffers</i>: Large buffers generally incur more overhead
    compared to smaller buffers.
    In general, the buffer size should reflect the expected usage
    as closely as possible.</li>
<li><i>Simple Filters</i>: 
    Currently WinDivert does not optimize the filter compilation, so it
    is up to the user application to ensure the filter is simple/optimized.
    </li>
<li><i>Overlapped I/O</i>: This allows the user application to do
    additional tasks at the same time as receive/send operations, which may
    improve performance for some applications.
    It is also possible for a single thread to initiate several
    receive/send operations at once.
    However, using overlapped I/O can be tricky, and it is important
    that all buffers passed to
    <a href="#divert_recv_ex">WinDivertRecvEx()</a> or
    <a href="#divert_send_ex">WinDivertSendEx()</a> 
    (including the <code>OVERLAPPED</code> structure)
    are not modified by the user application until the operation
    completes.</li>
<li><i>Queue length/size/time</i>: If these values are too small then some
    packets may be dropped under heavy load.
    These values can be controlled using the
    <a href="#divert_set_param">WinDivertSetParam()</a> function.</li>
</ol>
<p>
The <code>passthru.exe</code> <a href="#samples">sample program</a> can
be used to experiment with different batch sizes and thread counts.
</p>

<hr>
<a name="samples"><h2>9. Samples</h2></a>

<p>
Some samples have been provided to demonstrate the WinDivert API.
The sample programs are:
</p>
<ul>
<li><code>webfilter.exe</code>: A simple URL blacklist filter.
    This program monitors outbound HTTP traffic.
    If it finds a URL request that matches the blacklist, it hijacks the
    TCP connection, reseting the connection at the server's end, and
    sending a simple block-page to the browser.
    The blacklist(s) are specified at the command-line.</li>
<li><code>netdump.exe</code>: A simple packet sniffer based on the
    WinDivert filter language.
    This program takes a filter specified at the command line, and prints
    information about any packet that matches the filter.
    This example uses WinDivert in "packet sniffing" mode, similar to
    <code>winpcap</code>.
    However, unlike <code>winpcap</code>, WinDivert can see local (loopback)
    packets.
<li><code>netfilter.exe</code>: A simple firewall based on the WinDivert
    filter language.
    This program takes a filter specified at the command line, and blocks
    any packet that matches the filter.
    It blocks TCP by sending a TCP reset, UDP by an ICMP message, and all
    other traffic it simply drops.
    This is similar to the Linux <code>iptables</code> command with the
    <code>-j REJECT</code> option.</li>
<li><code>passthru.exe</code>: A simple program that simply re-injects every
    packet it captures.
    This example has a configurable batch-size and thread count,
    and so is useful for performance testing or as a starting point
    for more interesting applications.</li>
<li><code>streamdump.exe</code>: A simple program that demonstrates how to
    handle streams using WinDivert.
    The basic idea is to divert outbound TCP connections to a local proxy
    server which can capture or manipulate the stream.</li>
<li><code>flowtrack.exe</code>: A program that tracks all network flows
    to and from the local machine, including information such as the ID of the
    responsible process.
    The <code>flowtrack</code> sample demonstrates the
    <code>WINDIVERT_LAYER_FLOW</code> layer.</li>
<li><code>socketdump.exe</code>: Dumps socket operations
    (<code>bind()</code>, <code>connect()</code>, etc.) and the ID of the
    responsible process.
    The <code>socketdump</code> sample demonstrates the
    <code>WINDIVERT_LAYER_SOCKET</code> layer.</li>
<li><code>windivertctl.exe</code> allows the user to query which processes
    are using WinDivert via the <code>list</code> or <code>watch</code>
    commands, or to terminate all such processes using the
    <code>kill</code> command.
    The <code>windivertctl.exe</code> can also forcibly remove the
    WinDivert driver using the <code>uninstall</code> command.
    The <code>windivertctl</code> sample demonstrates the
    <code>WINDIVERT_LAYER_REFLECT</code> layer.</li>
</ul>
<p>
The samples are intended for educational purposes only, and are not
fully-featured applications.
</p><p>
The following basic template for a WinDivert application using the
<code>WINDIVERT_LAYER_NETWORK</code> layer.
The basic idea is to open a WinDivert handle, then enter a
capture-modify-reinject loop:
</p>
<pre>
    HANDLE handle;          // WinDivert handle
    WINDIVERT_ADDRESS addr; // Packet address
    char packet[MAXBUF];    // Packet buffer
    UINT packetLen;

    // Open some filter
    handle = WinDivertOpen("...", WINDIVERT_LAYER_NETWORK, 0, 0);
    if (handle == INVALID_HANDLE_VALUE)
    {
        // Handle error
        exit(1);
    }

    // Main capture-modify-inject loop:
    while (TRUE)
    {
        if (!WinDivertRecv(handle, packet, sizeof(packet), &amp;packetLen, &amp;addr))
        {
            // Handle recv error
            continue;
        }

        // Modify packet.

        WinDivertHelperCalcChecksums(packet, packetLen, &amp;addr, 0);
        if (!WinDivertSend(handle, packet, packetLen, NULL, &amp;addr))
        {
            // Handle send error
            continue;
        }
    }
</pre>
<p>
For applications that do not need to modify the packet, a better approach is
to open the WinDivert handle with the <code>WINDIVERT_FLAG_SNIFF</code> flag set,
and not re-inject the packet with
<a href="#divert_send"><code>WinDivertSend()</code></a>.
See the <code>netdump.exe</code> sample program for an example of this usage.
</p>

<hr>
<a name="known_issues"><h2>10. Known Issues</h2></a>

<p>
WinDivert has some known limitations listed below:
</p>
<ul>
<li><i>Injecting inbound ICMP/ICMPv6 messages</i>:
    Calling <a href="#divert_send"><code>WinDivertSend()</code></a> will fail
    with an error for certain types of inbound ICMP/ICMPv6 messages.
    This is probably because the Windows TCP/IP stack does not handle
    such messages.
    Such errors are harmless and can be ignored.
    </li>
<li><i>The forward layer does not interact well with the Windows NAT</i>:
    It is not possible to block packets pre-NAT with WinDivert.
    As a general principle, you should not try and mix WinDivert at the
    forward layer with the Windows NAT implementation.
    </li>
<li><i>Re-injecting unmodified packets can lead to infinite loops</i>:
    If two or more Windows Filtering Platform (WFP) callout drivers
    (including WinDivert applications) block and inject unmodified copies of
    packets then this can lead to an infinite loop.
    If such a loop occurs, 
    <a href="#divert_send"><code>WinDivertSend()</code></a> will eventually fail
    with error <code>ERROR_HOST_UNREACHABLE</code>.
    Unfortunately, such errors are not easy to fix.
    Some crude solutions include: (1) removing the incompatible driver, or
    (2) ignoring all packets with <code>ip.TTL</code> or
    <code>ipv6.HopLimit</code> less than the Windows <code>DefaultTTL</code>
    registry value.
    See <a href="https://github.com/basil00/Divert/issues/41">
    GitHub issue #41</a> for more information.
    </li>
<li><i>WinDivert can cause the MSVC x86_64 debugger to deadlock</i>:
    The deadlock occurs because the debugger uses local sockets.
    Thus: the debugger pauses the WinDivert
    application, which stops packets from being processed, which 
    causes the debugger wait forever on input from a socket.
    The deadlock can be avoided by ignoring loopback traffic.
    See <a href="https://github.com/basil00/Divert/issues/26">
    GitHub issue #26</a> for more information.
    </li>
<li><i>WinDivert can cause packets to be out-of-order</i>:
    Simply running the <code>passthru.exe</code> sample program can cause
    packets to become out-of-order.
    This is not a bug, since there is no requirement for packets to
    remain in-order.
    However, this may affect other buggy software
    (e.g. some buggy NAT implementations)
    that incorrectly assume packets to be in-order.
    </li>
<li><i>A race condition exists between <q><code>addr.*.processId</code></q> and
    process termination.</i>
    By the time an event is received using
    <a href="#divert_recv"><code>WinDivertRecv()</code></a>,
    it is possible that the process responsible for the event has already
    terminated.
    Furthermore, it is theoretically possible that the
    <code>processId</code> has been reassigned to an unrelated process.
    This problem can be partly mitigated by comparing the timestamp
    (<code>addr.Timestamp</code>) with the creation time of the process.
    If the process is newer, then the ID has been reassigned.
    This race condition does <b>not</b> affect the
    <code>WINDIVERT_EVENT_REFLECT_OPEN</code> event.
    In this special case, the <code>addr.Reflect.processId</code> is
    guaranteed to be valid until the corresponding
    <code>WINDIVERT_EVENT_REFLECT_CLOSE</code> event is
    received by the user application or is dropped
    (filter mismatch or timeout).
	</li>
</ul>

<hr>
<a name="license"><h2>11. License</h2></a>
<p>
WinDivert is dual-licensed under your choice of either the
<a href="http://www.gnu.org/licenses/lgpl-3.0.txt">GNU Lesser General
Public License (LGPL) Version 3</a> or the
<a href="https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt">
GNU General Public License (GPL) Version 2</a>.
Please see the notices below:
</p>
<p>
<b>LGPL version 3</b>:
</p>
<pre>
WinDivert is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
</pre>
<p>
<b>GPL version 2</b>:
</p>
<pre>
WinDivert is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
</pre>
</body>
</html>

```

`examples/flowtrack/flowtrack.c`:

```c
/*
 * flowtrack.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * DESCRIPTION:
 *
 * usage: flowtrack.exe [filter]
 */

#include <winsock2.h>
#include <windows.h>
#include <psapi.h>
#include <shlwapi.h>
#include <stdio.h>
#include <stdlib.h>

#include "windivert.h"

#define MAX_FLOWS           256
#define INET6_ADDRSTRLEN    45

/*
 * Flow tracking.
 */
typedef struct FLOW
{
    WINDIVERT_ADDRESS addr;
    struct FLOW *next;
} FLOW, *PFLOW;

static HANDLE lock;
static PFLOW flows = NULL;

/*
 * Draw flows to console in a delayed loop.
 *
 * This function does minimal error checking.
 */
static DWORD draw(LPVOID arg)
{
    const COORD top_left  = {0, 0};
    HANDLE process, console = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO screen;
    char path[MAX_PATH+1];
    char addr_str[INET6_ADDRSTRLEN+1];
    char *filename;
    const char header[] = "PID        PROGRAM              PROT   FLOW";
    DWORD rows, columns, written, fill_len, path_len, i;
    PFLOW flow;
    WINDIVERT_ADDRESS addrs[MAX_FLOWS], *addr;
    UINT num_addrs;

    while (TRUE)
    {
        GetConsoleScreenBufferInfo(console, &screen);
        SetConsoleCursorPosition(console, top_left); 

        rows = screen.srWindow.Bottom - screen.srWindow.Top + 1;
        columns = screen.srWindow.Right - screen.srWindow.Left + 1;

        // Copy a snapshot of the current flows:
        WaitForSingleObject(lock, INFINITE);
        flow = flows;
        num_addrs = 0;
        for (i = 0; flow != NULL && i < rows && i < MAX_FLOWS; i++)
        {
            memcpy(&addrs[i], &flow->addr, sizeof(addrs[i]));
            num_addrs++;
            flow = flow->next;
        }
        ReleaseMutex(lock);

        // Print the flows:
        SetConsoleTextAttribute(console, BACKGROUND_RED | BACKGROUND_GREEN |
            BACKGROUND_BLUE);
        WriteConsole(console, header, sizeof(header)-1, &written, NULL);
        fill_len = columns - (sizeof(header)-1);
        if (fill_len > 0)
        {
            COORD pos = {sizeof(header)-1, 0};
            FillConsoleOutputCharacterA(console, ' ', fill_len, pos,
                &written);
            FillConsoleOutputAttribute(console,
                BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE,
                fill_len, pos, &written);
        }
        putchar('\n');
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        for (i = 0; i < num_addrs && i < rows-1; i++)
        {
            COORD pos = {0, i+1};
            addr = &addrs[i];
            FillConsoleOutputCharacterA(console, ' ', columns, pos, &written);
            FillConsoleOutputAttribute(console,
                FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE,
                columns, pos, &written);
            SetConsoleCursorPosition(console, pos);
            if (i == rows-2 && (i+1) < num_addrs)
            {
                fputs("...", stdout);
                fflush(stdout);
                continue;
            }

            printf("%-10d ", addr->Flow.ProcessId);

            process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE,
                addr->Flow.ProcessId);
            path_len = 0;
            if (process != NULL)
            {
                path_len = GetProcessImageFileName(process, path, sizeof(path));
                CloseHandle(process);
            }
            SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
            if (path_len != 0)
            {
                filename = PathFindFileName(path);
                printf("%-20.20s ", filename);
            }
            else if (addr->Flow.ProcessId == 4)
            {
                fputs("Windows              ", stdout);
            }
            else
            {
                fputs("???                  ", stdout);
            }
            SetConsoleTextAttribute(console,
                FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
            switch (addr->Flow.Protocol)
            {
                case IPPROTO_TCP:
                    SetConsoleTextAttribute(console, FOREGROUND_GREEN);
                    printf("TCP    ");
                    break;
                case IPPROTO_UDP:
                    SetConsoleTextAttribute(console,
                        FOREGROUND_RED | FOREGROUND_GREEN);
                    printf("UDP    ");
                    break;
                case IPPROTO_ICMP:
                    SetConsoleTextAttribute(console, FOREGROUND_RED);
                    printf("ICMP   ");
                    break;
                case IPPROTO_ICMPV6:
                    SetConsoleTextAttribute(console, FOREGROUND_RED);
                    printf("ICMPV6 ");
                    break;
                default:
                    printf("%-6u ", addr->Flow.Protocol);
                    break;
            }
            SetConsoleTextAttribute(console,
                FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
            WinDivertHelperFormatIPv6Address(addr->Flow.LocalAddr, addr_str,
                sizeof(addr_str));
            printf("%s:%u %s ", addr_str, addr->Flow.LocalPort,
                (addr->Outbound? "---->": "<----"));
            WinDivertHelperFormatIPv6Address(addr->Flow.RemoteAddr, addr_str,
                sizeof(addr_str));
            printf("%s:%u", addr_str, addr->Flow.RemotePort);
            fflush(stdout);
        }
        for (; i < rows-1; i++)
        {
            COORD pos = {0, i+1};
            FillConsoleOutputCharacterA(console, ' ', columns, pos, &written);
            FillConsoleOutputAttribute(console,
                FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE,
                columns, pos, &written);
        }

        Sleep(1000);
    }
}

/*
 * Entry.
 */
int __cdecl main(int argc, char **argv)
{
    HANDLE handle, thread;
    INT16 priority = 776;       // Arbitrary.
    const char *filter = "true", *err_str;
    UINT packet_len;
    WINDIVERT_ADDRESS addr;
    PFLOW flow, prev;

    switch (argc)
    {
        case 1:
            break;
        case 2:
            filter = argv[1];
            break;
        default:
            fprintf(stderr, "usage: %s [filter]\n", argv[0]);
            exit(EXIT_FAILURE);
    }

    // Open WinDivert FLOW handle:
    handle = WinDivertOpen(filter, WINDIVERT_LAYER_FLOW, priority, 
        WINDIVERT_FLAG_SNIFF | WINDIVERT_FLAG_RECV_ONLY);
    if (handle == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_INVALID_PARAMETER &&
            !WinDivertHelperCompileFilter(filter, WINDIVERT_LAYER_FLOW,
                NULL, 0, &err_str, NULL))
        {
            fprintf(stderr, "error: invalid filter \"%s\"\n", err_str);
            exit(EXIT_FAILURE);
        }
        fprintf(stderr, "error: failed to open the WinDivert device (%d)\n",
            GetLastError());
        return EXIT_FAILURE;
    }

    // Spawn the draw() thread.
    lock = CreateMutex(NULL, FALSE, NULL);
    thread = CreateThread(NULL, 1, (LPTHREAD_START_ROUTINE)draw, NULL, 0,
        NULL);
    if (thread == NULL)
    {
        fprintf(stderr, "error: failed to create thread (%d)\n",
            GetLastError());
        return EXIT_FAILURE;
    }
    CloseHandle(thread);

    // Main loop:
    while (TRUE)
    {
        if (!WinDivertRecv(handle, NULL, 0, NULL, &addr))
        {
            fprintf(stderr, "failed to read packet (%d)\n", GetLastError());
            continue;
        }

        switch (addr.Event)
        {
            case WINDIVERT_EVENT_FLOW_ESTABLISHED:

                // Flow established:
                flow = (PFLOW)malloc(sizeof(FLOW));
                if (flow == NULL)
                {
                    fprintf(stderr, "error: failed to allocate memory\n");
                    exit(EXIT_FAILURE);
                }
                memcpy(&flow->addr, &addr, sizeof(flow->addr));
                WaitForSingleObject(lock, INFINITE);
                flow->next = flows;
                flows = flow;
                ReleaseMutex(lock);
                break;

            case WINDIVERT_EVENT_FLOW_DELETED:

                // Flow deleted:
                prev = NULL;
                WaitForSingleObject(lock, INFINITE);
                flow = flows;
                while (flow != NULL)
                {
                    if (memcmp(&addr.Flow, &flow->addr.Flow,
                            sizeof(addr.Flow)) == 0)
                    {
                        if (prev != NULL)
                        {
                            prev->next = flow->next;
                        }
                        else
                        {
                            flows = flow->next;
                        }
                        break;
                    }
                    prev = flow;
                    flow = flow->next;
                }
                ReleaseMutex(lock);
                free(flow);
        }
    }

    return 0;
}


```

`examples/flowtrack/flowtrack.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<!--

    flowtrack.vcxproj
    (C) 2019, all rights reserved,
    
    This file is part of WinDivert.
    
    WinDivert is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    WinDivert is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc., 51
    Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
    
-->
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 <ItemGroup Label="ProjectConfigurations">
  <ProjectConfiguration Include="Release|Win32">
   <Configuration>Release</Configuration>
   <Platform>Win32</Platform>
  </ProjectConfiguration>
  <ProjectConfiguration Include="Release|x64">
   <Configuration>Release</Configuration>
   <Platform>x64</Platform>
  </ProjectConfiguration>
 </ItemGroup>
 <ItemGroup>
  <ClCompile Include="flowtrack.c">
   <TreatWarningAsError>false</TreatWarningAsError>
   <Optimization>MinSpace</Optimization>
   <BasicRuntimeChecks>Default</BasicRuntimeChecks>
   <AdditionalIncludeDirectories>..\..\include</AdditionalIncludeDirectories>
  </ClCompile>
 </ItemGroup>
 <PropertyGroup Label="Globals">
  <RootNamespace>flowtrack</RootNamespace>
  <ProjectName>flowtrack</ProjectName>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props"/>
 <PropertyGroup Label="Configuration">
  <PlatformToolset>v140</PlatformToolset>
  <ConfigurationType>Application</ConfigurationType>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
 <ItemDefinitionGroup>
  <Link>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\install\MSVC\i386\WinDivert.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\install\MSVC\amd64\WinDivert.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
  </Link>
 </ItemDefinitionGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>

```

`examples/netdump/netdump.c`:

```c
/*
 * netdump.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * DESCRIPTION:
 * This is a simple traffic monitor.  It uses a WinDivert handle in SNIFF mode.
 * The SNIFF mode copies packets and does not block the original.
 *
 * usage: netdump.exe windivert-filter [priority]
 *
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "windivert.h"

#define ntohs(x)            WinDivertHelperNtohs(x)
#define ntohl(x)            WinDivertHelperNtohl(x)

#define MAXBUF              WINDIVERT_MTU_MAX
#define INET6_ADDRSTRLEN    45

/*
 * Entry.
 */
int __cdecl main(int argc, char **argv)
{
    HANDLE handle, console;
    UINT i;
    INT16 priority = 0;
    unsigned char packet[MAXBUF];
    UINT packet_len;
    WINDIVERT_ADDRESS addr;
    PWINDIVERT_IPHDR ip_header;
    PWINDIVERT_IPV6HDR ipv6_header;
    PWINDIVERT_ICMPHDR icmp_header;
    PWINDIVERT_ICMPV6HDR icmpv6_header;
    PWINDIVERT_TCPHDR tcp_header;
    PWINDIVERT_UDPHDR udp_header;
    UINT32 src_addr[4], dst_addr[4];
    UINT64 hash;
    char src_str[INET6_ADDRSTRLEN+1], dst_str[INET6_ADDRSTRLEN+1];
    const char *err_str;
    LARGE_INTEGER base, freq;
    double time_passed;

    // Check arguments.
    switch (argc)
    {
        case 2:
            break;
        case 3:
            priority = (INT16)atoi(argv[2]);
            break;
        default:
            fprintf(stderr, "usage: %s windivert-filter [priority]\n",
                argv[0]);
            fprintf(stderr, "examples:\n");
            fprintf(stderr, "\t%s true\n", argv[0]);
            fprintf(stderr, "\t%s \"outbound and tcp.DstPort == 80\" 1000\n",
                argv[0]);
            fprintf(stderr, "\t%s \"inbound and tcp.Syn\" -400\n", argv[0]);
            exit(EXIT_FAILURE);
    }

    // Get console for pretty colors.
    console = GetStdHandle(STD_OUTPUT_HANDLE);

    // Divert traffic matching the filter:
    handle = WinDivertOpen(argv[1], WINDIVERT_LAYER_NETWORK, priority,
        WINDIVERT_FLAG_SNIFF | WINDIVERT_FLAG_FRAGMENTS);
    if (handle == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_INVALID_PARAMETER &&
            !WinDivertHelperCompileFilter(argv[1], WINDIVERT_LAYER_NETWORK,
                NULL, 0, &err_str, NULL))
        {
            fprintf(stderr, "error: invalid filter \"%s\"\n", err_str);
            exit(EXIT_FAILURE);
        }
        fprintf(stderr, "error: failed to open the WinDivert device (%d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }

    // Max-out the packet queue:
    if (!WinDivertSetParam(handle, WINDIVERT_PARAM_QUEUE_LENGTH, 
            WINDIVERT_PARAM_QUEUE_LENGTH_MAX))
    {
        fprintf(stderr, "error: failed to set packet queue length (%d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }
    if (!WinDivertSetParam(handle, WINDIVERT_PARAM_QUEUE_TIME,
            WINDIVERT_PARAM_QUEUE_TIME_MAX))
    {
        fprintf(stderr, "error: failed to set packet queue time (%d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }
    if (!WinDivertSetParam(handle, WINDIVERT_PARAM_QUEUE_SIZE,
            WINDIVERT_PARAM_QUEUE_SIZE_MAX))
    {
        fprintf(stderr, "error: failed to set packet queue size (%d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }

    // Set up timing:
    QueryPerformanceFrequency(&freq);
    QueryPerformanceCounter(&base);

    // Main loop:
    while (TRUE)
    {
        // Read a matching packet.
        if (!WinDivertRecv(handle, packet, sizeof(packet), &packet_len, &addr))
        {
            fprintf(stderr, "warning: failed to read packet (%d)\n",
                GetLastError());
            continue;
        }

        // Print info about the matching packet.
        WinDivertHelperParsePacket(packet, packet_len, &ip_header, &ipv6_header,
            NULL, &icmp_header, &icmpv6_header, &tcp_header, &udp_header, NULL,
            NULL, NULL, NULL);
        if (ip_header == NULL && ipv6_header == NULL)
        {
            fprintf(stderr, "warning: junk packet\n");
        }

        // Dump packet info: 
        putchar('\n');
        SetConsoleTextAttribute(console, FOREGROUND_RED);
        time_passed = (double)(addr.Timestamp - base.QuadPart) /
            (double)freq.QuadPart;
        hash = WinDivertHelperHashPacket(packet, packet_len, 0);
        printf("Packet [Timestamp=%.8g, Direction=%s IfIdx=%u SubIfIdx=%u "
            "Loopback=%u Hash=0x%.16llX]\n",
            time_passed, (addr.Outbound?  "outbound": "inbound"),
            addr.Network.IfIdx, addr.Network.SubIfIdx, addr.Loopback, hash);
        if (ip_header != NULL)
        {
            WinDivertHelperFormatIPv4Address(ntohl(ip_header->SrcAddr),
                src_str, sizeof(src_str));
            WinDivertHelperFormatIPv4Address(ntohl(ip_header->DstAddr),
                dst_str, sizeof(dst_str));
            SetConsoleTextAttribute(console,
                FOREGROUND_GREEN | FOREGROUND_RED);
            printf("IPv4 [Version=%u HdrLength=%u TOS=%u Length=%u Id=0x%.4X "
                "Reserved=%u DF=%u MF=%u FragOff=%u TTL=%u Protocol=%u "
                "Checksum=0x%.4X SrcAddr=%s DstAddr=%s]\n",
                ip_header->Version, ip_header->HdrLength,
                ntohs(ip_header->TOS), ntohs(ip_header->Length),
                ntohs(ip_header->Id), WINDIVERT_IPHDR_GET_RESERVED(ip_header),
                WINDIVERT_IPHDR_GET_DF(ip_header),
                WINDIVERT_IPHDR_GET_MF(ip_header),
                ntohs(WINDIVERT_IPHDR_GET_FRAGOFF(ip_header)), ip_header->TTL,
                ip_header->Protocol, ntohs(ip_header->Checksum), src_str,
                dst_str);

        }
        if (ipv6_header != NULL)
        {
            WinDivertHelperNtohIPv6Address(ipv6_header->SrcAddr, src_addr);
            WinDivertHelperNtohIPv6Address(ipv6_header->DstAddr, dst_addr);
            WinDivertHelperFormatIPv6Address(src_addr, src_str,
                sizeof(src_str));
            WinDivertHelperFormatIPv6Address(dst_addr, dst_str,
                sizeof(dst_str));
            SetConsoleTextAttribute(console,
                FOREGROUND_GREEN | FOREGROUND_RED);
            printf("IPv6 [Version=%u TrafficClass=%u FlowLabel=%u Length=%u "
                "NextHdr=%u HopLimit=%u SrcAddr=%s DstAddr=%s]\n",
                ipv6_header->Version,
                WINDIVERT_IPV6HDR_GET_TRAFFICCLASS(ipv6_header),
                ntohl(WINDIVERT_IPV6HDR_GET_FLOWLABEL(ipv6_header)),
                ntohs(ipv6_header->Length), ipv6_header->NextHdr,
                ipv6_header->HopLimit, src_str, dst_str);
        }
        if (icmp_header != NULL)
        {
            SetConsoleTextAttribute(console, FOREGROUND_RED);
            printf("ICMP [Type=%u Code=%u Checksum=0x%.4X Body=0x%.8X]\n",
                icmp_header->Type, icmp_header->Code,
                ntohs(icmp_header->Checksum), ntohl(icmp_header->Body));
        }
        if (icmpv6_header != NULL)
        {
            SetConsoleTextAttribute(console, FOREGROUND_RED);
            printf("ICMPV6 [Type=%u Code=%u Checksum=0x%.4X Body=0x%.8X]\n",
                icmpv6_header->Type, icmpv6_header->Code,
                ntohs(icmpv6_header->Checksum), ntohl(icmpv6_header->Body));
        }
        if (tcp_header != NULL)
        {
            SetConsoleTextAttribute(console, FOREGROUND_GREEN);
            printf("TCP [SrcPort=%u DstPort=%u SeqNum=%u AckNum=%u "
                "HdrLength=%u Reserved1=%u Reserved2=%u Urg=%u Ack=%u "
                "Psh=%u Rst=%u Syn=%u Fin=%u Window=%u Checksum=0x%.4X "
                "UrgPtr=%u]\n",
                ntohs(tcp_header->SrcPort), ntohs(tcp_header->DstPort),
                ntohl(tcp_header->SeqNum), ntohl(tcp_header->AckNum),
                tcp_header->HdrLength, tcp_header->Reserved1,
                tcp_header->Reserved2, tcp_header->Urg, tcp_header->Ack,
                tcp_header->Psh, tcp_header->Rst, tcp_header->Syn,
                tcp_header->Fin, ntohs(tcp_header->Window),
                ntohs(tcp_header->Checksum), ntohs(tcp_header->UrgPtr));
        }
        if (udp_header != NULL)
        {
            SetConsoleTextAttribute(console, FOREGROUND_GREEN);
            printf("UDP [SrcPort=%u DstPort=%u Length=%u "
                "Checksum=0x%.4X]\n",
                ntohs(udp_header->SrcPort), ntohs(udp_header->DstPort),
                ntohs(udp_header->Length), ntohs(udp_header->Checksum));
        }
        SetConsoleTextAttribute(console, FOREGROUND_GREEN | FOREGROUND_BLUE);
        for (i = 0; i < packet_len; i++)
        {
            if (i % 20 == 0)
            {
                printf("\n\t");
            }
            printf("%.2X", (UINT8)packet[i]);
        }
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_BLUE);
        for (i = 0; i < packet_len; i++)
        {
            if (i % 40 == 0)
            {
                printf("\n\t");
            }
            if (isprint(packet[i]))
            {
                putchar(packet[i]);
            }
            else
            {
                putchar('.');
            }
        }
        putchar('\n');
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
    }
}


```

`examples/netdump/netdump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<!--

    netdump.vcxproj
    (C) 2019, all rights reserved,
    
    This file is part of WinDivert.
    
    WinDivert is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    WinDivert is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc., 51
    Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
    
-->
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 <ItemGroup Label="ProjectConfigurations">
  <ProjectConfiguration Include="Release|Win32">
   <Configuration>Release</Configuration>
   <Platform>Win32</Platform>
  </ProjectConfiguration>
  <ProjectConfiguration Include="Release|x64">
   <Configuration>Release</Configuration>
   <Platform>x64</Platform>
  </ProjectConfiguration>
 </ItemGroup>
 <ItemGroup>
  <ClCompile Include="netdump.c">
   <TreatWarningAsError>false</TreatWarningAsError>
   <Optimization>MinSpace</Optimization>
   <BasicRuntimeChecks>Default</BasicRuntimeChecks>
   <AdditionalIncludeDirectories>..\..\include</AdditionalIncludeDirectories>
  </ClCompile>
 </ItemGroup>
 <PropertyGroup Label="Globals">
  <RootNamespace>netdump</RootNamespace>
  <ProjectName>netdump</ProjectName>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props"/>
 <PropertyGroup Label="Configuration">
  <PlatformToolset>v140</PlatformToolset>
  <ConfigurationType>Application</ConfigurationType>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
 <ItemDefinitionGroup>
  <Link>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\install\MSVC\i386\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\install\MSVC\amd64\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
  </Link>
 </ItemDefinitionGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>

```

`examples/netfilter/netfilter.c`:

```c
/*
 * netfilter.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * DESCRIPTION:
 * This is a simple traffic filter/firewall using WinDivert.
 *
 * usage: netfilter.exe windivert-filter [priority]
 *
 * Any traffic that matches the windivert-filter will be blocked using one of
 * the following methods:
 * - TCP: send a TCP RST to the packet's source.
 * - UDP: send a ICMP(v6) "destination unreachable" to the packet's source.
 * - ICMP/ICMPv6: Drop the packet.
 *
 * This program is similar to Linux's iptables with the "-j REJECT" target.
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "windivert.h"

#define ntohs(x)            WinDivertHelperNtohs(x)
#define ntohl(x)            WinDivertHelperNtohl(x)
#define htons(x)            WinDivertHelperHtons(x)
#define htonl(x)            WinDivertHelperHtonl(x)

#define MAXBUF              WINDIVERT_MTU_MAX
#define INET6_ADDRSTRLEN    45
#define IPPROTO_ICMPV6      58

/*
 * Pre-fabricated packets.
 */
typedef struct
{
    WINDIVERT_IPHDR ip;
    WINDIVERT_TCPHDR tcp;
} TCPPACKET, *PTCPPACKET;

typedef struct
{
    WINDIVERT_IPV6HDR ipv6;
    WINDIVERT_TCPHDR tcp;
} TCPV6PACKET, *PTCPV6PACKET;

typedef struct
{
    WINDIVERT_IPHDR ip;
    WINDIVERT_ICMPHDR icmp;
    UINT8 data[];
} ICMPPACKET, *PICMPPACKET;

typedef struct
{
    WINDIVERT_IPV6HDR ipv6;
    WINDIVERT_ICMPV6HDR icmpv6;
    UINT8 data[];
} ICMPV6PACKET, *PICMPV6PACKET;

/*
 * Prototypes.
 */
static void PacketIpInit(PWINDIVERT_IPHDR packet);
static void PacketIpTcpInit(PTCPPACKET packet);
static void PacketIpIcmpInit(PICMPPACKET packet);
static void PacketIpv6Init(PWINDIVERT_IPV6HDR packet);
static void PacketIpv6TcpInit(PTCPV6PACKET packet);
static void PacketIpv6Icmpv6Init(PICMPV6PACKET packet);

/*
 * Entry.
 */
int __cdecl main(int argc, char **argv)
{
    HANDLE handle, console;
    UINT i;
    INT16 priority = 0;
    unsigned char packet[MAXBUF];
    UINT packet_len;
    WINDIVERT_ADDRESS recv_addr, send_addr;
    PWINDIVERT_IPHDR ip_header;
    PWINDIVERT_IPV6HDR ipv6_header;
    PWINDIVERT_ICMPHDR icmp_header;
    PWINDIVERT_ICMPV6HDR icmpv6_header;
    PWINDIVERT_TCPHDR tcp_header;
    PWINDIVERT_UDPHDR udp_header;
    UINT32 src_addr[4], dst_addr[4];
    char src_str[INET6_ADDRSTRLEN+1], dst_str[INET6_ADDRSTRLEN+1];
    UINT payload_len;
    const char *err_str;
    
    TCPPACKET reset0;
    PTCPPACKET reset = &reset0;
    UINT8 dnr0[sizeof(ICMPPACKET) + 0x0F*sizeof(UINT32) + 8 + 1];
    PICMPPACKET dnr = (PICMPPACKET)dnr0;

    TCPV6PACKET resetv6_0;
    PTCPV6PACKET resetv6 = &resetv6_0;
    UINT8 dnrv6_0[sizeof(ICMPV6PACKET) + sizeof(WINDIVERT_IPV6HDR) +
        sizeof(WINDIVERT_TCPHDR)];
    PICMPV6PACKET dnrv6 = (PICMPV6PACKET)dnrv6_0;

    // Check arguments.
    switch (argc)
    {
        case 2:
            break;
        case 3:
            priority = (INT16)atoi(argv[2]);
            break;
        default:
            fprintf(stderr, "usage: %s windivert-filter [priority]\n",
                argv[0]);
            fprintf(stderr, "examples:\n");
            fprintf(stderr, "\t%s true\n", argv[0]);
            fprintf(stderr, "\t%s \"outbound and tcp.DstPort == 80\" 1000\n",
                argv[0]);
            fprintf(stderr, "\t%s \"inbound and tcp.Syn\" -400\n", argv[0]);
            exit(EXIT_FAILURE);
    }

    // Initialize all packets.
    PacketIpTcpInit(reset);
    reset->tcp.Rst = 1;
    reset->tcp.Ack = 1;
    PacketIpIcmpInit(dnr);
    dnr->icmp.Type = 3;         // Destination not reachable.
    dnr->icmp.Code = 3;         // Port not reachable.
    PacketIpv6TcpInit(resetv6);
    resetv6->tcp.Rst = 1;
    resetv6->tcp.Ack = 1;
    PacketIpv6Icmpv6Init(dnrv6);
    dnrv6->ipv6.Length = htons(sizeof(WINDIVERT_ICMPV6HDR) + 4 +
        sizeof(WINDIVERT_IPV6HDR) + sizeof(WINDIVERT_TCPHDR));
    dnrv6->icmpv6.Type = 1;     // Destination not reachable.
    dnrv6->icmpv6.Code = 4;     // Port not reachable.

    // Get console for pretty colors.
    console = GetStdHandle(STD_OUTPUT_HANDLE);

    // Divert traffic matching the filter:
    handle = WinDivertOpen(argv[1], WINDIVERT_LAYER_NETWORK, priority, 0);
    if (handle == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_INVALID_PARAMETER &&
            !WinDivertHelperCompileFilter(argv[1], WINDIVERT_LAYER_NETWORK,
                NULL, 0, &err_str, NULL))
        {
            fprintf(stderr, "error: invalid filter \"%s\"\n", err_str);
            exit(EXIT_FAILURE);
        }
        fprintf(stderr, "error: failed to open the WinDivert device (%d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }

    // Main loop:
    while (TRUE)
    {
        // Read a matching packet.
        if (!WinDivertRecv(handle, packet, sizeof(packet), &packet_len,
                &recv_addr))
        {
            fprintf(stderr, "warning: failed to read packet\n");
            continue;
        }
       
        // Print info about the matching packet.
        WinDivertHelperParsePacket(packet, packet_len, &ip_header, &ipv6_header,
            NULL, &icmp_header, &icmpv6_header, &tcp_header, &udp_header, NULL,
            &payload_len, NULL, NULL);
        if (ip_header == NULL && ipv6_header == NULL)
        {
            continue;
        }

        // Dump packet info: 
        SetConsoleTextAttribute(console, FOREGROUND_RED);
        fputs("BLOCK ", stdout);
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        if (ip_header != NULL)
        {
            WinDivertHelperFormatIPv4Address(ntohl(ip_header->SrcAddr),
                src_str, sizeof(src_str));
            WinDivertHelperFormatIPv4Address(ntohl(ip_header->DstAddr),
                dst_str, sizeof(dst_str));
        }
        if (ipv6_header != NULL)
        {
            WinDivertHelperNtohIPv6Address(ipv6_header->SrcAddr, src_addr);
            WinDivertHelperNtohIPv6Address(ipv6_header->DstAddr, dst_addr);
            WinDivertHelperFormatIPv6Address(src_addr, src_str,
                sizeof(src_str));
            WinDivertHelperFormatIPv6Address(dst_addr, dst_str,
                sizeof(dst_str));
        }
        printf("ip.SrcAddr=%s ip.DstAddr=%s ", src_str, dst_str);
        if (icmp_header != NULL)
        {
            printf("icmp.Type=%u icmp.Code=%u ",
                icmp_header->Type, icmp_header->Code);
            // Simply drop ICMP
        }
        if (icmpv6_header != NULL)
        {
            printf("icmpv6.Type=%u icmpv6.Code=%u ",
                icmpv6_header->Type, icmpv6_header->Code);
            // Simply drop ICMPv6
        }
        if (tcp_header != NULL)
        {
            printf("tcp.SrcPort=%u tcp.DstPort=%u tcp.Flags=",
                ntohs(tcp_header->SrcPort), ntohs(tcp_header->DstPort));
            if (tcp_header->Fin)
            {
                fputs("[FIN]", stdout);
            }
            if (tcp_header->Rst)
            {
                fputs("[RST]", stdout);
            }
            if (tcp_header->Urg)
            {
                fputs("[URG]", stdout);
            }
            if (tcp_header->Syn)
            {
                fputs("[SYN]", stdout);
            }
            if (tcp_header->Psh)
            {
                fputs("[PSH]", stdout);
            }
            if (tcp_header->Ack)
            {
                fputs("[ACK]", stdout);
            }
            putchar(' ');


            if (ip_header != NULL && !tcp_header->Rst && !tcp_header->Fin)
            {
                reset->ip.SrcAddr = ip_header->DstAddr;
                reset->ip.DstAddr = ip_header->SrcAddr;
                reset->tcp.SrcPort = tcp_header->DstPort;
                reset->tcp.DstPort = tcp_header->SrcPort;
                reset->tcp.SeqNum = 
                    (tcp_header->Ack? tcp_header->AckNum: 0);
                reset->tcp.AckNum =
                    (tcp_header->Syn?
                        htonl(ntohl(tcp_header->SeqNum) + 1):
                        htonl(ntohl(tcp_header->SeqNum) + payload_len));

                memcpy(&send_addr, &recv_addr, sizeof(send_addr));
                send_addr.Outbound = !recv_addr.Outbound;
                WinDivertHelperCalcChecksums((PVOID)reset, sizeof(TCPPACKET),
                    &send_addr, 0);
                if (!WinDivertSend(handle, (PVOID)reset, sizeof(TCPPACKET),
                        NULL, &send_addr))
                {
                    fprintf(stderr, "warning: failed to send TCP reset (%d)\n",
                        GetLastError());
                }
            }

            if (ipv6_header != NULL && !tcp_header->Rst && !tcp_header->Fin)
            {
                memcpy(resetv6->ipv6.SrcAddr, ipv6_header->DstAddr,
                    sizeof(resetv6->ipv6.SrcAddr));
                memcpy(resetv6->ipv6.DstAddr, ipv6_header->SrcAddr,
                    sizeof(resetv6->ipv6.DstAddr));
                resetv6->tcp.SrcPort = tcp_header->DstPort;
                resetv6->tcp.DstPort = tcp_header->SrcPort;
                resetv6->tcp.SeqNum =
                    (tcp_header->Ack? tcp_header->AckNum: 0);
                resetv6->tcp.AckNum =
                    (tcp_header->Syn?
                        htonl(ntohl(tcp_header->SeqNum) + 1):
                        htonl(ntohl(tcp_header->SeqNum) + payload_len));

                memcpy(&send_addr, &recv_addr, sizeof(send_addr));
                send_addr.Outbound = !recv_addr.Outbound;
                WinDivertHelperCalcChecksums((PVOID)resetv6,
                    sizeof(TCPV6PACKET), &send_addr, 0);
                if (!WinDivertSend(handle, (PVOID)resetv6, sizeof(TCPV6PACKET),
                        NULL, &send_addr))
                {
                    fprintf(stderr, "warning: failed to send TCP (IPV6) "
                        "reset (%d)\n", GetLastError());
                }
            }
        }
        if (udp_header != NULL)
        {
            printf("udp.SrcPort=%u udp.DstPort=%u ",
                ntohs(udp_header->SrcPort), ntohs(udp_header->DstPort));
        
            if (ip_header != NULL)
            {
                UINT icmp_length = ip_header->HdrLength*sizeof(UINT32) + 8;
                memcpy(dnr->data, ip_header, icmp_length);
                icmp_length += sizeof(ICMPPACKET);
                dnr->ip.Length = htons((UINT16)icmp_length);
                dnr->ip.SrcAddr = ip_header->DstAddr;
                dnr->ip.DstAddr = ip_header->SrcAddr;
                
                memcpy(&send_addr, &recv_addr, sizeof(send_addr));
                send_addr.Outbound = !recv_addr.Outbound;
                WinDivertHelperCalcChecksums((PVOID)dnr, icmp_length,
                    &send_addr, 0);
                if (!WinDivertSend(handle, (PVOID)dnr, icmp_length, NULL,
                        &send_addr))
                {
                    fprintf(stderr, "warning: failed to send ICMP message "
                        "(%d)\n", GetLastError());
                }
            }
        
            if (ipv6_header != NULL)
            {
                UINT icmpv6_length = sizeof(WINDIVERT_IPV6HDR) +
                    sizeof(WINDIVERT_TCPHDR);
                memcpy(dnrv6->data, ipv6_header, icmpv6_length);
                icmpv6_length += sizeof(ICMPV6PACKET);
                memcpy(dnrv6->ipv6.SrcAddr, ipv6_header->DstAddr,
                    sizeof(dnrv6->ipv6.SrcAddr));
                memcpy(dnrv6->ipv6.DstAddr, ipv6_header->SrcAddr,
                    sizeof(dnrv6->ipv6.DstAddr));
                
                memcpy(&send_addr, &recv_addr, sizeof(send_addr));
                send_addr.Outbound = !recv_addr.Outbound;
                WinDivertHelperCalcChecksums((PVOID)dnrv6, icmpv6_length,
                    &send_addr, 0);
                if (!WinDivertSend(handle, (PVOID)dnrv6, icmpv6_length,
                        NULL, &send_addr))
                {
                    fprintf(stderr, "warning: failed to send ICMPv6 message "
                        "(%d)\n", GetLastError());
                }
            }
        }
        putchar('\n');
    }
}

/*
 * Initialize a PACKET.
 */
static void PacketIpInit(PWINDIVERT_IPHDR packet)
{
    memset(packet, 0, sizeof(WINDIVERT_IPHDR));
    packet->Version = 4;
    packet->HdrLength = sizeof(WINDIVERT_IPHDR) / sizeof(UINT32);
    packet->Id = ntohs(0xDEAD);
    packet->TTL = 64;
}

/*
 * Initialize a TCPPACKET.
 */
static void PacketIpTcpInit(PTCPPACKET packet)
{
    memset(packet, 0, sizeof(TCPPACKET));
    PacketIpInit(&packet->ip);
    packet->ip.Length = htons(sizeof(TCPPACKET));
    packet->ip.Protocol = IPPROTO_TCP;
    packet->tcp.HdrLength = sizeof(WINDIVERT_TCPHDR) / sizeof(UINT32);
}

/*
 * Initialize an ICMPPACKET.
 */
static void PacketIpIcmpInit(PICMPPACKET packet)
{
    memset(packet, 0, sizeof(ICMPPACKET));
    PacketIpInit(&packet->ip);
    packet->ip.Protocol = IPPROTO_ICMP;
}

/*
 * Initialize a PACKETV6.
 */
static void PacketIpv6Init(PWINDIVERT_IPV6HDR packet)
{
    memset(packet, 0, sizeof(WINDIVERT_IPV6HDR));
    packet->Version = 6;
    packet->HopLimit = 64;
}

/*
 * Initialize a TCPV6PACKET.
 */
static void PacketIpv6TcpInit(PTCPV6PACKET packet)
{
    memset(packet, 0, sizeof(TCPV6PACKET));
    PacketIpv6Init(&packet->ipv6);
    packet->ipv6.Length = htons(sizeof(WINDIVERT_TCPHDR));
    packet->ipv6.NextHdr = IPPROTO_TCP;
    packet->tcp.HdrLength = sizeof(WINDIVERT_TCPHDR) / sizeof(UINT32);
}

/*
 * Initialize an ICMP PACKET.
 */
static void PacketIpv6Icmpv6Init(PICMPV6PACKET packet)
{
    memset(packet, 0, sizeof(ICMPV6PACKET));
    PacketIpv6Init(&packet->ipv6);
    packet->ipv6.NextHdr = IPPROTO_ICMPV6;
}


```

`examples/netfilter/netfilter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<!--

    netfilter.vcxproj
    (C) 2019, all rights reserved,
    
    This file is part of WinDivert.
    
    WinDivert is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    WinDivert is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc., 51
    Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
    
-->
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 <ItemGroup Label="ProjectConfigurations">
  <ProjectConfiguration Include="Release|Win32">
   <Configuration>Release</Configuration>
   <Platform>Win32</Platform>
  </ProjectConfiguration>
  <ProjectConfiguration Include="Release|x64">
   <Configuration>Release</Configuration>
   <Platform>x64</Platform>
  </ProjectConfiguration>
 </ItemGroup>
 <ItemGroup>
  <ClCompile Include="netfilter.c">
   <TreatWarningAsError>false</TreatWarningAsError>
   <Optimization>MinSpace</Optimization>
   <BasicRuntimeChecks>Default</BasicRuntimeChecks>
   <AdditionalIncludeDirectories>..\..\include</AdditionalIncludeDirectories>
  </ClCompile>
 </ItemGroup>
 <PropertyGroup Label="Globals">
  <RootNamespace>netfilter</RootNamespace>
  <ProjectName>netfilter</ProjectName>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props"/>
 <PropertyGroup Label="Configuration">
  <PlatformToolset>v140</PlatformToolset>
  <ConfigurationType>Application</ConfigurationType>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
 <ItemDefinitionGroup>
  <Link>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\install\MSVC\i386\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\install\MSVC\amd64\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
  </Link>
 </ItemDefinitionGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>

```

`examples/passthru/passthru.c`:

```c
/*
 * passthru.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * DESCRIPTION:
 * This program does nothing except divert packets and re-inject them.  This is
 * useful for performance testing.
 *
 * usage: passthru.exe [windivert-filter] [num-threads] [batch-size] [priority]
 */

#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "windivert.h"

#define MTU 1500

typedef struct
{
    HANDLE handle;
    int batch;
} CONFIG, *PCONFIG;

static DWORD passthru(LPVOID arg);

/*
 * Entry.
 */
int __cdecl main(int argc, char **argv)
{
    const char *filter = "true";
    int threads = 1, batch = 1, priority = 0;
    int i;
    HANDLE handle, thread;
    CONFIG config;

    if (argc > 5)
    {
        fprintf(stderr, "usage: %s [filter] [num-threads] [batch-size] "
            "[priority]\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    if (argc >= 2)
    {
        filter = argv[1];
    }
    if (argc >= 3)
    {
        threads = atoi(argv[2]);
        if (threads < 1 || threads > 64)
        {
            fprintf(stderr, "error: invalid number of threads\n");
            exit(EXIT_FAILURE);
        }
    }
    if (argc >= 4)
    {
        batch = atoi(argv[3]);
        if (batch <= 0 || batch > WINDIVERT_BATCH_MAX)
        {
            fprintf(stderr, "error: invalid batch size\n");
            exit(EXIT_FAILURE);
        }
    }
    if (argc >= 5)
    {
        priority = atoi(argv[4]);
        if (priority < WINDIVERT_PRIORITY_LOWEST ||
            priority > WINDIVERT_PRIORITY_HIGHEST)
        {
            fprintf(stderr, "error: invalid priority value\n");
            exit(EXIT_FAILURE);
        }
    }

    // Divert traffic matching the filter:
    handle = WinDivertOpen(filter, WINDIVERT_LAYER_NETWORK, (INT16)priority,
        0);
    if (handle == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_INVALID_PARAMETER)
        {
            fprintf(stderr, "error: filter syntax error\n");
            exit(EXIT_FAILURE);
        }
        fprintf(stderr, "error: failed to open the WinDivert device (%d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }

    // Start the threads
    config.handle = handle;
    config.batch = batch;
    for (i = 1; i < threads; i++)
    {
        thread = CreateThread(NULL, 1, (LPTHREAD_START_ROUTINE)passthru,
            (LPVOID)&config, 0, NULL);
        if (thread == NULL)
        {
            fprintf(stderr, "error: failed to start passthru thread (%d)\n",
                GetLastError());
            exit(EXIT_FAILURE);
        }
    }

    // Main thread:
    passthru((LPVOID)&config);

    return 0;
}

// Passthru thread.
static DWORD passthru(LPVOID arg)
{
    UINT8 *packet;
    UINT packet_len, recv_len, addr_len;
    WINDIVERT_ADDRESS *addr;
    PCONFIG config = (PCONFIG)arg;
    HANDLE handle;
    int batch;

    handle = config->handle;
    batch = config->batch;

    packet_len = batch * MTU;
    packet_len =
        (packet_len < WINDIVERT_MTU_MAX? WINDIVERT_MTU_MAX: packet_len);
    packet = (UINT8 *)malloc(packet_len);
    addr = (WINDIVERT_ADDRESS *)malloc(batch * sizeof(WINDIVERT_ADDRESS));
    if (packet == NULL || addr == NULL)
    {
        fprintf(stderr, "error: failed to allocate buffer (%d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }

    // Main loop:
    while (TRUE)
    {
        // Read a matching packet.
        addr_len = batch * sizeof(WINDIVERT_ADDRESS);
        if (!WinDivertRecvEx(handle, packet, packet_len, &recv_len, 0,
                addr, &addr_len, NULL))
        {
            fprintf(stderr, "warning: failed to read packet (%d)\n",
                GetLastError());
            continue;
        }

        // Re-inject the matching packet.
        if (!WinDivertSendEx(handle, packet, recv_len, NULL, 0, addr,
                addr_len, NULL))
        {
            fprintf(stderr, "warning: failed to reinject packet (%d)\n",
                GetLastError());
        }
    }
}


```

`examples/passthru/passthru.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<!--

    passthru.vcxproj
    (C) 2019, all rights reserved,
    
    This file is part of WinDivert.
    
    WinDivert is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    WinDivert is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc., 51
    Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
    
-->
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 <ItemGroup Label="ProjectConfigurations">
  <ProjectConfiguration Include="Release|Win32">
   <Configuration>Release</Configuration>
   <Platform>Win32</Platform>
  </ProjectConfiguration>
  <ProjectConfiguration Include="Release|x64">
   <Configuration>Release</Configuration>
   <Platform>x64</Platform>
  </ProjectConfiguration>
 </ItemGroup>
 <ItemGroup>
  <ClCompile Include="passthru.c">
   <TreatWarningAsError>false</TreatWarningAsError>
   <Optimization>MinSpace</Optimization>
   <BasicRuntimeChecks>Default</BasicRuntimeChecks>
   <AdditionalIncludeDirectories>..\..\include</AdditionalIncludeDirectories>
  </ClCompile>
 </ItemGroup>
 <PropertyGroup Label="Globals">
  <RootNamespace>passthru</RootNamespace>
  <ProjectName>passthru</ProjectName>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props"/>
 <PropertyGroup Label="Configuration">
  <PlatformToolset>v140</PlatformToolset>
  <ConfigurationType>Application</ConfigurationType>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
 <ItemDefinitionGroup>
  <Link>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\install\MSVC\i386\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\install\MSVC\amd64\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
  </Link>
 </ItemDefinitionGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>

```

`examples/socketdump/socketdump.c`:

```c
/*
 * socketdump.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * DESCRIPTION:
 *
 * usage: socketdump.exe [filter]
 *        socketdump.exe --block [filter]
 */

#include <winsock2.h>
#include <windows.h>
#include <psapi.h>
#include <shlwapi.h>
#include <stdio.h>
#include <stdlib.h>

#include "windivert.h"

#define INET6_ADDRSTRLEN    45

/*
 * Entry.
 */
int __cdecl main(int argc, char **argv)
{
    HANDLE handle, process, console;
    INT16 priority = 1121;          // Arbitrary.
    const char *filter = "true", *err_str;
    char path[MAX_PATH+1];
    char local_str[INET6_ADDRSTRLEN+1], remote_str[INET6_ADDRSTRLEN+1];
    char *filename;
    DWORD path_len;
    WINDIVERT_ADDRESS addr;
    BOOL block = FALSE;

    switch (argc)
    {
        case 1:
            break;
        case 2:
            if (strcmp(argv[1], "--block") == 0)
            {
                block = TRUE;
            }
            else
            {
                filter = argv[1];
            }
            break;
        case 3:
            if (strcmp(argv[1], "--block") == 0)
            {
                block = TRUE;
                filter = argv[2];
                break;
            }
            // Fallthrough:
        default:
            fprintf(stderr, "usage: %s [filter]\n", argv[0]);
            fprintf(stderr, "       %s --block [filter]\n", argv[0]);
            exit(EXIT_FAILURE);
    }

    // Open WinDivert SOCKET handle:
    handle = WinDivertOpen(filter, WINDIVERT_LAYER_SOCKET, priority, 
        (block? 0: WINDIVERT_FLAG_SNIFF) | WINDIVERT_FLAG_RECV_ONLY);
    if (handle == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_INVALID_PARAMETER &&
            !WinDivertHelperCompileFilter(filter, WINDIVERT_LAYER_SOCKET,
                NULL, 0, &err_str, NULL))
        {
            fprintf(stderr, "error: invalid filter \"%s\"\n", err_str);
            exit(EXIT_FAILURE);
        }
        fprintf(stderr, "error: failed to open the WinDivert device (%d)\n",
            GetLastError());
        return EXIT_FAILURE;
    }

    // Main loop:
    console = GetStdHandle(STD_OUTPUT_HANDLE);
    while (TRUE)
    {
        if (!WinDivertRecv(handle, NULL, 0, NULL, &addr))
        {
            fprintf(stderr, "failed to read packet (%d)\n", GetLastError());
            continue;
        }

        switch (addr.Event)
        {
            case WINDIVERT_EVENT_SOCKET_BIND:
                SetConsoleTextAttribute(console, FOREGROUND_GREEN);
                printf("BIND");
                break;
            case WINDIVERT_EVENT_SOCKET_LISTEN:
                SetConsoleTextAttribute(console, FOREGROUND_GREEN);
                printf("LISTEN");
                break;
            case WINDIVERT_EVENT_SOCKET_CONNECT:
                SetConsoleTextAttribute(console, FOREGROUND_GREEN);
                printf("CONNECT");
                break;
            case WINDIVERT_EVENT_SOCKET_ACCEPT:
                SetConsoleTextAttribute(console, FOREGROUND_GREEN);
                printf("ACCEPT");
                break;
            case WINDIVERT_EVENT_SOCKET_CLOSE:
                SetConsoleTextAttribute(console, FOREGROUND_RED);
                printf("CLOSE");
                break;
            default:
                SetConsoleTextAttribute(console, FOREGROUND_BLUE);
                printf("???");
                break;
        }
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);

        printf(" pid=");
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        printf("%u", addr.Socket.ProcessId);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);

        printf(" program=");
        process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE,
            addr.Socket.ProcessId);
        path_len = 0;
        if (process != NULL)
        {
            path_len = GetProcessImageFileName(process, path, sizeof(path));
            CloseHandle(process);
        }
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        if (path_len != 0)
        {
            filename = PathFindFileName(path);
            printf("%s", filename);
        }
        else if (addr.Socket.ProcessId == 4)
        {
            printf("Windows");
        }
        else
        {
            printf("???");
        }
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);

        printf(" endpoint=");
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        printf("%lu", addr.Socket.EndpointId);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);

        printf(" parent=");
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        printf("%lu", addr.Socket.ParentEndpointId);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);

        printf(" protocol=");
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        switch (addr.Socket.Protocol)
        {
            case IPPROTO_TCP:
                printf("TCP");
                break;
            case IPPROTO_UDP:
                printf("UDP");
                break;
            case IPPROTO_ICMP:
                printf("ICMP");
                break;
            case IPPROTO_ICMPV6:
                printf("ICMPV6");
                break;
            default:
                printf("%u", addr.Socket.Protocol);
                break;
        }
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);

        WinDivertHelperFormatIPv6Address(addr.Socket.LocalAddr, local_str,
            sizeof(local_str));
        if (addr.Socket.LocalPort != 0 || strcmp(local_str, "::") != 0)
        {
            printf(" local=");
            SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
            printf("[%s]:%u", local_str, addr.Socket.LocalPort);
            SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
                FOREGROUND_BLUE);
        }

        WinDivertHelperFormatIPv6Address(addr.Socket.RemoteAddr, remote_str,
            sizeof(remote_str));
        if (addr.Socket.RemotePort != 0 || strcmp(remote_str, "::") != 0)
        {
            printf(" remote=");
            SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
            printf("[%s]:%u", remote_str, addr.Socket.RemotePort);
            SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
                FOREGROUND_BLUE);
        }

        putchar('\n');
    }

    return 0;
}


```

`examples/socketdump/socketdump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<!--

    socketdump.vcxproj
    (C) 2019, all rights reserved,
    
    This file is part of WinDivert.
    
    WinDivert is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    WinDivert is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc., 51
    Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
    
-->
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 <ItemGroup Label="ProjectConfigurations">
  <ProjectConfiguration Include="Release|Win32">
   <Configuration>Release</Configuration>
   <Platform>Win32</Platform>
  </ProjectConfiguration>
  <ProjectConfiguration Include="Release|x64">
   <Configuration>Release</Configuration>
   <Platform>x64</Platform>
  </ProjectConfiguration>
 </ItemGroup>
 <ItemGroup>
  <ClCompile Include="socketdump.c">
   <TreatWarningAsError>false</TreatWarningAsError>
   <Optimization>MinSpace</Optimization>
   <BasicRuntimeChecks>Default</BasicRuntimeChecks>
   <AdditionalIncludeDirectories>..\..\include</AdditionalIncludeDirectories>
  </ClCompile>
 </ItemGroup>
 <PropertyGroup Label="Globals">
  <RootNamespace>socketdump</RootNamespace>
  <ProjectName>socketdump</ProjectName>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props"/>
 <PropertyGroup Label="Configuration">
  <PlatformToolset>v140</PlatformToolset>
  <ConfigurationType>Application</ConfigurationType>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
 <ItemDefinitionGroup>
  <Link>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\install\MSVC\i386\WinDivert.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\install\MSVC\amd64\WinDivert.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
  </Link>
 </ItemDefinitionGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>

```

`examples/streamdump/streamdump.c`:

```c
/*
 * streamdump.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * DESCRIPTION:
 *
 * This program demonstrates how to handle streams using WinDivert.
 *
 * The program works by "reflecting" outbound TCP connections into inbound
 * TCP connections that are handled by a simple proxy server.
 *
 * usage: streamdump.exe port
 */

#include <winsock2.h>
#include <windows.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>

#include "windivert.h"

#define MAXBUF          WINDIVERT_MTU_MAX
#define PROXY_PORT      34010
#define ALT_PORT        43010
#define MAX_LINE        65

/*
 * Proxy server configuration.
 */
typedef struct
{
    UINT16 proxy_port;
    UINT16 alt_port;
} PROXY_CONFIG, *PPROXY_CONFIG;

typedef struct
{
    SOCKET s;
    UINT16 alt_port;
    struct in_addr dest;
} PROXY_CONNECTION_CONFIG, *PPROXY_CONNECTION_CONFIG;

typedef struct
{
    BOOL inbound;
    SOCKET s;
    SOCKET t;
} PROXY_TRANSFER_CONFIG, *PPROXY_TRANSFER_CONFIG;

/*
 * Lock to sync output.
 */
static HANDLE lock;

/*
 * Prototypes.
 */
static DWORD proxy(LPVOID arg);
static DWORD proxy_connection_handler(LPVOID arg);
static DWORD proxy_transfer_handler(LPVOID arg);

/*
 * Error handling.
 */
static void message(const char *msg, ...)
{
    va_list args;
    va_start(args, msg);
    WaitForSingleObject(lock, INFINITE);
    vfprintf(stderr, msg, args);
    putc('\n', stderr);
    ReleaseMutex(lock);
    va_end(args);
}
#define error(msg, ...)                         \
    do {                                        \
        message("error: " msg, ## __VA_ARGS__); \
        exit(EXIT_FAILURE);                     \
    } while (FALSE)
#define warning(msg, ...)                       \
    message("warning: " msg, ## __VA_ARGS__)

/*
 * Entry.
 */
int __cdecl main(int argc, char **argv)
{
    HANDLE handle, thread;
    UINT16 port, proxy_port, alt_port;
    int r;
    char filter[256];
    INT16 priority = 123;       // Arbitrary.
    PPROXY_CONFIG config;
    unsigned char packet[MAXBUF];
    UINT packet_len;
    WINDIVERT_ADDRESS addr;
    PWINDIVERT_IPHDR ip_header;
    PWINDIVERT_TCPHDR tcp_header;
    DWORD len;

    // Init.
    if (argc != 2)
    {
        fprintf(stderr, "usage: %s dest-port\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    port = (UINT16)atoi(argv[1]);
    if (port < 0 || port > 0xFFFF)
    {
        fprintf(stderr, "error: invalid port number (%d)\n", port);
        exit(EXIT_FAILURE);
    }
    proxy_port = (port == PROXY_PORT? PROXY_PORT+1: PROXY_PORT);
    alt_port = (port == ALT_PORT? ALT_PORT+1: ALT_PORT);
    lock = CreateMutex(NULL, FALSE, NULL);
    if (lock == NULL)
    {
        fprintf(stderr, "error: failed to create mutex (%d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }

    // Divert all traffic to/from `port', `proxy_port' and `alt_port'.
    r = snprintf(filter, sizeof(filter),
        "tcp and "
        "(tcp.DstPort == %d or tcp.DstPort == %d or tcp.DstPort == %d or "
         "tcp.SrcPort == %d or tcp.SrcPort == %d or tcp.SrcPort == %d)",
        port, proxy_port, alt_port, port, proxy_port, alt_port);
    if (r < 0 || r >= sizeof(filter))
    {
        error("failed to create filter string");
    }
    handle = WinDivertOpen(filter, WINDIVERT_LAYER_NETWORK, priority, 0);
    if (handle == INVALID_HANDLE_VALUE)
    {
        error("failed to open the WinDivert device (%d)", GetLastError());
    }

    // Spawn proxy thread,
    config = (PPROXY_CONFIG)malloc(sizeof(PROXY_CONFIG));
    if (config == NULL)
    {
        error("failed to allocate memory");
    }
    config->proxy_port = proxy_port;
    config->alt_port = alt_port;
    thread = CreateThread(NULL, 1, (LPTHREAD_START_ROUTINE)proxy,
        (LPVOID)config, 0, NULL);
    if (thread == NULL)
    {
        error("failed to create thread (%d)", GetLastError());
    }
    CloseHandle(thread);

    // Main loop:
    while (TRUE)
    {
        if (!WinDivertRecv(handle, packet, sizeof(packet), &packet_len, &addr))
        {
            warning("failed to read packet (%d)", GetLastError());
            continue;
        }

        WinDivertHelperParsePacket(packet, packet_len, &ip_header, NULL, NULL,
            NULL, NULL, &tcp_header, NULL, NULL, NULL, NULL, NULL);
        if (ip_header == NULL || tcp_header == NULL)
        {
            warning("failed to parse packet (%d)", GetLastError());
            continue;
        }

        if (addr.Outbound)
        {
            if (tcp_header->DstPort == htons(port))
            {
                // Reflect: PORT ---> PROXY
                UINT32 dst_addr = ip_header->DstAddr;
                tcp_header->DstPort = htons(proxy_port);
                ip_header->DstAddr = ip_header->SrcAddr;
                ip_header->SrcAddr = dst_addr;
                addr.Outbound = FALSE;
            }
            else if (tcp_header->SrcPort == htons(proxy_port))
            {
                // Reflect: PROXY ---> PORT
                UINT32 dst_addr = ip_header->DstAddr;
                tcp_header->SrcPort = htons(port);
                ip_header->DstAddr = ip_header->SrcAddr;
                ip_header->SrcAddr = dst_addr;
                addr.Outbound = FALSE;
            }
            else if (tcp_header->DstPort == htons(alt_port))
            {
                // Redirect: ALT ---> PORT
                tcp_header->DstPort = htons(port);
            }
        }
        else
        {
            if (tcp_header->SrcPort == htons(port))
            {
                // Redirect: PORT ---> ALT
                tcp_header->SrcPort = htons(alt_port);
            }
        }

        WinDivertHelperCalcChecksums(packet, packet_len, &addr, 0);
        if (!WinDivertSend(handle, packet, packet_len, NULL, &addr))
        {
            warning("failed to send packet (%d)", GetLastError());
            continue;
        }
    }

    return 0;
}

/*
 * Proxy server thread.
 */
static DWORD proxy(LPVOID arg)
{
    PPROXY_CONFIG config = (PPROXY_CONFIG)arg;
    UINT16 proxy_port = config->proxy_port;
    UINT16 alt_port = config->alt_port;
    int on = 1;
    WSADATA wsa_data;
    WORD wsa_version = MAKEWORD(2, 2);
    struct sockaddr_in addr;
    SOCKET s;
    HANDLE thread;
    
    free(config);

    if (WSAStartup(wsa_version, &wsa_data) != 0)
    {
        error("failed to start WSA (%d)", GetLastError());
    }
    
    s = socket(AF_INET, SOCK_STREAM, 0);
    if (s == INVALID_SOCKET)
    {
        error("failed to create socket (%d)", WSAGetLastError());
    }

    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (const char*)&on, sizeof(int))
            == SOCKET_ERROR)
    {
        error("failed to re-use address (%d)", GetLastError());
    }

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(proxy_port);
    if (bind(s, (SOCKADDR *)&addr, sizeof(addr)) == SOCKET_ERROR)
    {
        error("failed to bind socket (%d)", WSAGetLastError());
    }

    if (listen(s, 16) == SOCKET_ERROR)
    {
        error("failed to listen socket (%d)", WSAGetLastError());
    }

    while (TRUE)
    {
        // Wait for a new connection.
        PPROXY_CONNECTION_CONFIG config;
        int size = sizeof(addr);
        SOCKET t = accept(s, (SOCKADDR *)&addr, &size);
        if (t == INVALID_SOCKET)
        {
            warning("failed to accept socket (%d)", WSAGetLastError());
            continue;
        }

        // Spawn proxy connection handler thread.
        config = (PPROXY_CONNECTION_CONFIG)
            malloc(sizeof(PROXY_CONNECTION_CONFIG));
        if (config == NULL)
        {
            error("failed to allocate memory");
        }
        config->s = t;
        config->alt_port = alt_port;
        config->dest = addr.sin_addr;
        thread = CreateThread(NULL, 1,
            (LPTHREAD_START_ROUTINE)proxy_connection_handler,
            (LPVOID)config, 0, NULL);
        if (thread == NULL)
        {
            warning("failed to create thread (%d)", GetLastError());
            closesocket(t);
            free(config);
            continue;
        }
        CloseHandle(thread);
    }
}

/*
 * Proxy connection handler thread.
 */
static DWORD proxy_connection_handler(LPVOID arg)
{
    PPROXY_TRANSFER_CONFIG config1, config2;
    HANDLE thread;
    PPROXY_CONNECTION_CONFIG config = (PPROXY_CONNECTION_CONFIG)arg;
    SOCKET s = config->s, t;
    UINT16 alt_port = config->alt_port;
    struct in_addr dest = config->dest;
    struct sockaddr_in addr;
    
    free(config);

    t = socket(AF_INET, SOCK_STREAM, 0);
    if (t == INVALID_SOCKET)
    {
        warning("failed to create socket (%d)", WSAGetLastError());
        closesocket(s);
        return 0;
    }

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(alt_port);
    addr.sin_addr = dest;
    if (connect(t, (SOCKADDR *)&addr, sizeof(addr)) == SOCKET_ERROR)
    {
        warning("failed to connect socket (%d)", WSAGetLastError());
        closesocket(s);
        closesocket(t);
        return 0;
    }

    config1 = (PPROXY_TRANSFER_CONFIG)malloc(sizeof(PROXY_TRANSFER_CONFIG));
    config2 = (PPROXY_TRANSFER_CONFIG)malloc(sizeof(PROXY_TRANSFER_CONFIG));
    if (config1 == NULL || config2 == NULL)
    {
        error("failed to allocate memory");
    }
    config1->inbound = FALSE;
    config2->inbound = TRUE;
    config2->t = config1->s = s;
    config2->s = config1->t = t;
    thread = CreateThread(NULL, 1,
        (LPTHREAD_START_ROUTINE)proxy_transfer_handler, (LPVOID)config1, 0,
        NULL);
    if (thread == NULL)
    {
        warning("failed to create thread (%d)", GetLastError());
        closesocket(s);
        closesocket(t);
        free(config1);
        free(config2);
        return 0;
    }
    proxy_transfer_handler((LPVOID)config2);
    WaitForSingleObject(thread, INFINITE);
    CloseHandle(thread);
    closesocket(s);
    closesocket(t);
    return 0;
}

/*
 * Handle the transfer of data from one socket to another.
 */
static DWORD proxy_transfer_handler(LPVOID arg)
{
    PPROXY_TRANSFER_CONFIG config = (PPROXY_TRANSFER_CONFIG)arg;
    BOOL inbound = config->inbound;
    SOCKET s = config->s, t = config->t;
    char buf[8192];
    int len, len2, i;
    HANDLE console;

    free(config);

    while (TRUE)
    {
        // Read data from s.
        len = recv(s, buf, sizeof(buf), 0);
        if (len == SOCKET_ERROR)
        {
            warning("failed to recv from socket (%d)", WSAGetLastError());
            shutdown(s, SD_BOTH);
            shutdown(t, SD_BOTH);
            return 0;
        }
        if (len == 0)
        {
            shutdown(s, SD_RECEIVE);
            shutdown(t, SD_SEND);
            return 0;
        }

        // Dump stream information to the screen.
        console = GetStdHandle(STD_OUTPUT_HANDLE);
        WaitForSingleObject(lock, INFINITE);
        printf("[%.4d] ", len);
        SetConsoleTextAttribute(console,
            (inbound? FOREGROUND_RED: FOREGROUND_GREEN));
        for (i = 0; i < len && i < MAX_LINE; i++)
        {
            putchar((isprint(buf[i])? buf[i]: '.'));
        }
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        printf("%s\n", (len > MAX_LINE? "...": ""));
        ReleaseMutex(lock);

        // Send data to t.
        for (i = 0; i < len; )
        {
            len2 = send(t, buf+i, len-i, 0);
            if (len2 == SOCKET_ERROR)
            {
                warning("failed to send to socket (%d)", WSAGetLastError());
                shutdown(s, SD_BOTH);
                shutdown(t, SD_BOTH);
                return 0;
            }
            i += len2;
        }
    }

    return 0;
}


```

`examples/streamdump/streamdump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<!--

    streamdump.vcxproj
    (C) 2019, all rights reserved,
    
    This file is part of WinDivert.
    
    WinDivert is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    WinDivert is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc., 51
    Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
    
-->
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 <ItemGroup Label="ProjectConfigurations">
  <ProjectConfiguration Include="Release|Win32">
   <Configuration>Release</Configuration>
   <Platform>Win32</Platform>
  </ProjectConfiguration>
  <ProjectConfiguration Include="Release|x64">
   <Configuration>Release</Configuration>
   <Platform>x64</Platform>
  </ProjectConfiguration>
 </ItemGroup>
 <ItemGroup>
  <ClCompile Include="streamdump.c">
   <TreatWarningAsError>false</TreatWarningAsError>
   <Optimization>MinSpace</Optimization>
   <BasicRuntimeChecks>Default</BasicRuntimeChecks>
   <AdditionalIncludeDirectories>..\..\include</AdditionalIncludeDirectories>
  </ClCompile>
 </ItemGroup>
 <PropertyGroup Label="Globals">
  <RootNamespace>streamdump</RootNamespace>
  <ProjectName>streamdump</ProjectName>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props"/>
 <PropertyGroup Label="Configuration">
  <PlatformToolset>v140</PlatformToolset>
  <ConfigurationType>Application</ConfigurationType>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
 <ItemDefinitionGroup>
  <Link>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\install\MSVC\i386\WinDivert.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\install\MSVC\amd64\WinDivert.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>
  </Link>
 </ItemDefinitionGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>

```

`examples/webfilter/webfilter.c`:

```c
/*
 * webfilter.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * DESCRIPTION:
 * This is a simple web (HTTP) filter using WinDivert.
 *
 * It works by intercepting outbound HTTP GET/POST requests and matching
 * the URL against a blacklist.  If the URL is matched, we hijack the TCP
 * connection, reseting the connection at the server end, and sending a
 * blockpage to the browser.
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "windivert.h"

#define ntohs(x)            WinDivertHelperNtohs(x)
#define ntohl(x)            WinDivertHelperNtohl(x)
#define htons(x)            WinDivertHelperHtons(x)
#define htonl(x)            WinDivertHelperHtonl(x)

#define MAXBUF              WINDIVERT_MTU_MAX
#define MAXURL              4096

/*
 * URL and blacklist representation.
 */
typedef struct
{
    char *domain;
    char *uri;
} URL, *PURL;
typedef struct
{
    UINT size;
    UINT length;
    PURL *urls;
} BLACKLIST, *PBLACKLIST;

/*
 * Pre-fabricated packets.
 */
typedef struct
{
    WINDIVERT_IPHDR  ip;
    WINDIVERT_TCPHDR tcp;
} PACKET, *PPACKET;
typedef struct 
{
    PACKET header;
    UINT8 data[];
} DATAPACKET, *PDATAPACKET;

/*
 * THe block page contents.
 */
const char block_data[] =
    "HTTP/1.1 200 OK\r\n"
    "Connection: close\r\n"
    "Content-Type: text/html\r\n"
    "\r\n"
    "<!doctype html>\n"
    "<html>\n"
    "\t<head>\n"
    "\t\t<title>BLOCKED!</title>\n"
    "\t</head>\n"
    "\t<body>\n"
    "\t\t<h1>BLOCKED!</h1>\n"
    "\t\t<hr>\n"
    "\t\t<p>This URL has been blocked!</p>\n"
    "\t</body>\n"
    "</html>\n";

/*
 * Prototypes
 */
static void PacketInit(PPACKET packet);
static int __cdecl UrlCompare(const void *a, const void *b);
static int UrlMatch(PURL urla, PURL urlb);
static PBLACKLIST BlackListInit(void);
static void BlackListInsert(PBLACKLIST blacklist, PURL url);
static void BlackListSort(PBLACKLIST blacklist);
static BOOL BlackListMatch(PBLACKLIST blacklist, PURL url);
static void BlackListRead(PBLACKLIST blacklist, const char *filename);
static BOOL BlackListPayloadMatch(PBLACKLIST blacklist, char *data,
    UINT16 len);

/*
 * Entry.
 */
int __cdecl main(int argc, char **argv)
{
    HANDLE handle;
    WINDIVERT_ADDRESS addr;
    UINT8 packet[MAXBUF];
    UINT packet_len;
    PWINDIVERT_IPHDR ip_header;
    PWINDIVERT_TCPHDR tcp_header;
    PVOID payload;
    UINT payload_len;
    PACKET reset0;
    PPACKET reset = &reset0;
    PACKET finish0;
    PPACKET finish = &finish0;
    PDATAPACKET blockpage;
    UINT16 blockpage_len;
    PBLACKLIST blacklist;
    unsigned i;
    INT16 priority = 404;       // Arbitrary.

    // Read the blacklists.
    if (argc <= 1)
    {
        fprintf(stderr, "usage: %s blacklist.txt [blacklist2.txt ...]\n",
            argv[0]);
        exit(EXIT_FAILURE);
    }
    blacklist = BlackListInit();
    for (i = 1; i < (UINT)argc; i++)
    {
        BlackListRead(blacklist, argv[i]);
    }
    BlackListSort(blacklist);

    // Initialize the pre-frabricated packets:
    blockpage_len = sizeof(DATAPACKET)+sizeof(block_data)-1;
    blockpage = (PDATAPACKET)malloc(blockpage_len);
    if (blockpage == NULL)
    {
        fprintf(stderr, "error: memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    PacketInit(&blockpage->header);
    blockpage->header.ip.Length   = htons(blockpage_len);
    blockpage->header.tcp.SrcPort = htons(80);
    blockpage->header.tcp.Psh     = 1;
    blockpage->header.tcp.Ack     = 1;
    memcpy(blockpage->data, block_data, sizeof(block_data)-1);
    PacketInit(reset);
    reset->tcp.Rst = 1;
    reset->tcp.Ack = 1;
    PacketInit(finish);
    finish->tcp.Fin = 1;
    finish->tcp.Ack = 1;

    // Open the Divert device:
    handle = WinDivertOpen(
            "outbound && "              // Outbound traffic only
            "!loopback && "             // No loopback traffic
            "ip && "                    // Only IPv4 supported
            "tcp.DstPort == 80 && "     // HTTP (port 80) only
            "tcp.PayloadLength > 0",    // TCP data packets only
            WINDIVERT_LAYER_NETWORK, priority, 0
        );
    if (handle == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "error: failed to open the WinDivert device (%d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }
    printf("OPENED WinDivert\n");

    // Main loop:
    while (TRUE)
    {
        if (!WinDivertRecv(handle, packet, sizeof(packet), &packet_len, &addr))
        {
            fprintf(stderr, "warning: failed to read packet (%d)\n",
                GetLastError());
            continue;
        }

        WinDivertHelperParsePacket(packet, packet_len, &ip_header, NULL,
            NULL, NULL, NULL, &tcp_header, NULL, &payload, &payload_len,
            NULL, NULL);
        if (ip_header == NULL || tcp_header == NULL || payload == NULL ||
            !BlackListPayloadMatch(blacklist, payload, (UINT16)payload_len))
        {
            // Packet does not match the blacklist; simply reinject it.
            if (!WinDivertSend(handle, packet, packet_len, NULL, &addr))
            {
                fprintf(stderr, "warning: failed to reinject packet (%d)\n",
                    GetLastError());
            }
            continue;
        }

        // The URL matched the blacklist; we block it by hijacking the TCP
        // connection.

        // (1) Send a TCP RST to the server; immediately closing the
        //     connection at the server's end.
        reset->ip.SrcAddr       = ip_header->SrcAddr;
        reset->ip.DstAddr       = ip_header->DstAddr;
        reset->tcp.SrcPort      = tcp_header->SrcPort;
        reset->tcp.DstPort      = htons(80);
        reset->tcp.SeqNum       = tcp_header->SeqNum;
        reset->tcp.AckNum       = tcp_header->AckNum;
        WinDivertHelperCalcChecksums((PVOID)reset, sizeof(PACKET), &addr, 0);
        if (!WinDivertSend(handle, (PVOID)reset, sizeof(PACKET), NULL, &addr))
        {
            fprintf(stderr, "warning: failed to send reset packet (%d)\n",
                GetLastError());
        }

        // (2) Send the blockpage to the browser:
        blockpage->header.ip.SrcAddr       = ip_header->DstAddr;
        blockpage->header.ip.DstAddr       = ip_header->SrcAddr;
        blockpage->header.tcp.DstPort      = tcp_header->SrcPort;
        blockpage->header.tcp.SeqNum       = tcp_header->AckNum;
        blockpage->header.tcp.AckNum       =
            htonl(ntohl(tcp_header->SeqNum) + payload_len);
        addr.Outbound = !addr.Outbound;     // Reverse direction.
        WinDivertHelperCalcChecksums((PVOID)blockpage, blockpage_len, &addr, 0);
        if (!WinDivertSend(handle, (PVOID)blockpage, blockpage_len, NULL,
                &addr))
        {
            fprintf(stderr, "warning: failed to send block page packet (%d)\n",
                GetLastError());
        }

        // (3) Send a TCP FIN to the browser; closing the connection at the 
        //     browser's end.
        finish->ip.SrcAddr       = ip_header->DstAddr;
        finish->ip.DstAddr       = ip_header->SrcAddr;
        finish->tcp.SrcPort      = htons(80);
        finish->tcp.DstPort      = tcp_header->SrcPort;
        finish->tcp.SeqNum       =
            htonl(ntohl(tcp_header->AckNum) + sizeof(block_data) - 1); 
        finish->tcp.AckNum       =
            htonl(ntohl(tcp_header->SeqNum) + payload_len);
        WinDivertHelperCalcChecksums((PVOID)finish, sizeof(PACKET), &addr, 0);
        if (!WinDivertSend(handle, (PVOID)finish, sizeof(PACKET), NULL, &addr))
        {
            fprintf(stderr, "warning: failed to send finish packet (%d)\n",
                GetLastError());
        }
    }
}

/*
 * Initialize a PACKET.
 */
static void PacketInit(PPACKET packet)
{
    memset(packet, 0, sizeof(PACKET));
    packet->ip.Version = 4;
    packet->ip.HdrLength = sizeof(WINDIVERT_IPHDR) / sizeof(UINT32);
    packet->ip.Length = htons(sizeof(PACKET));
    packet->ip.TTL = 64;
    packet->ip.Protocol = IPPROTO_TCP;
    packet->tcp.HdrLength = sizeof(WINDIVERT_TCPHDR) / sizeof(UINT32);
}

/*
 * Initialize an empty blacklist.
 */
static PBLACKLIST BlackListInit(void)
{
    PBLACKLIST blacklist = (PBLACKLIST)malloc(sizeof(BLACKLIST));
    UINT size;
    if (blacklist == NULL)
    {
        goto memory_error;
    }
    size = 1024;
    blacklist->urls = (PURL *)malloc(size*sizeof(PURL));
    if (blacklist->urls == NULL)
    {
        goto memory_error;
    }
    blacklist->size = size;
    blacklist->length = 0;

    return blacklist;

memory_error:
    fprintf(stderr, "error: failed to allocate memory\n");
    exit(EXIT_FAILURE);
}

/*
 * Insert a URL into a blacklist.
 */
static void BlackListInsert(PBLACKLIST blacklist, PURL url)
{
    if (blacklist->length >= blacklist->size)
    {
        blacklist->size = (blacklist->size*3) / 2;
        printf("GROW blacklist to %u\n", blacklist->size);
        blacklist->urls = (PURL *)realloc(blacklist->urls,
            blacklist->size*sizeof(PURL));
        if (blacklist->urls == NULL)
        {
            fprintf(stderr, "error: failed to reallocate memory\n");
            exit(EXIT_FAILURE);
        }
    }

    blacklist->urls[blacklist->length++] = url;
}

/*
 * Sort the blacklist (for searching).
 */
static void BlackListSort(PBLACKLIST blacklist)
{
    qsort(blacklist->urls, blacklist->length, sizeof(PURL), UrlCompare);
}

/*
 * Match a URL against the blacklist.
 */
static BOOL BlackListMatch(PBLACKLIST blacklist, PURL url)
{
    int lo = 0, hi = ((int)blacklist->length)-1;

    while (lo <= hi)
    {
        INT mid = (lo + hi) / 2;
        int cmp = UrlMatch(url, blacklist->urls[mid]);
        if (cmp > 0)
        {
            hi = mid-1;
        }
        else if (cmp < 0)
        {
            lo = mid+1;
        }
        else
        {
            return TRUE;
        }
    }
    return FALSE;
}


/*
 * Read URLs from a file.
 */
static void BlackListRead(PBLACKLIST blacklist, const char *filename)
{
    char domain[MAXURL+1];
    char uri[MAXURL+1];
    int c;
    UINT16 i, j;
    PURL url;
    FILE *file = fopen(filename, "r");
    
    if (file == NULL)
    {
        fprintf(stderr, "error: could not open blacklist file %s\n",
            filename);
        exit(EXIT_FAILURE);
    }

    // Read URLs from the file and add them to the blacklist: 
    while (TRUE)
    {
        while (isspace(c = getc(file)))
            ;
        if (c == EOF)
        {
            break;
        }
        if (c != '-' && !isalnum(c))
        {
            while (!isspace(c = getc(file)) && c != EOF)
                ;
            if (c == EOF)
            {
                break;
            }
            continue;
        }
        i = 0;
        domain[i++] = (char)c;
        while ((isalnum(c = getc(file)) || c == '-' || c == '.') && i < MAXURL)
        {
            domain[i++] = (char)c;
        }
        domain[i] = '\0';
        j = 0;
        if (c == '/')
        {
            while (!isspace(c = getc(file)) && c != EOF && j < MAXURL)
            {
                uri[j++] = (char)c;
            }
            uri[j] = '\0';
        }
        else if (isspace(c))
        {
            uri[j] = '\0';
        }
        else
        {
            while (!isspace(c = getc(file)) && c != EOF)
                ;
            continue;
        }

        printf("ADD %s/%s\n", domain, uri);

        url = (PURL)malloc(sizeof(URL));
        if (url == NULL)
        {
            goto memory_error;
        }
        url->domain = (char *)malloc((i+1)*sizeof(char));
        url->uri    = (char *)malloc((j+1)*sizeof(char));
        if (url->domain == NULL || url->uri == NULL)
        {
            goto memory_error;
        }
        strcpy(url->uri, uri);
        for (j = 0; j < i; j++)
        {
            url->domain[j] = domain[i-j-1];
        }
        url->domain[j] = '\0';

        BlackListInsert(blacklist, url);
    }

    fclose(file);
    return;

memory_error:
    fprintf(stderr, "error: memory allocation failed\n");
    exit(EXIT_FAILURE);
}

/*
 * Attempt to parse a URL and match it with the blacklist.
 *
 * BUG:
 * - This function makes several assumptions about HTTP requests, such as:
 *      1) The URL will be contained within one packet;
 *      2) The HTTP request begins at a packet boundary;
 *      3) The Host header immediately follows the GET/POST line.
 *   Some browsers, such as Internet Explorer, violate these assumptions
 *   and therefore matching will not work.
 */
static BOOL BlackListPayloadMatch(PBLACKLIST blacklist, char *data, UINT16 len)
{
    static const char get_str[] = "GET /";
    static const char post_str[] = "POST /";
    static const char http_host_str[] = " HTTP/1.1\r\nHost: ";
    char domain[MAXURL];
    char uri[MAXURL];
    URL url = {domain, uri};
    UINT16 i = 0, j;
    BOOL result;
    HANDLE console;

    if (len <= sizeof(post_str) + sizeof(http_host_str))
    {
        return FALSE;
    }
    if (strncmp(data, get_str, sizeof(get_str)-1) == 0)
    {
        i += sizeof(get_str)-1;
    }
    else if (strncmp(data, post_str, sizeof(post_str)-1) == 0)
    {
        i += sizeof(post_str)-1;
    }
    else
    {
        return FALSE;
    }

    for (j = 0; i < len && data[i] != ' '; j++, i++)
    {
        uri[j] = data[i];
    }
    uri[j] = '\0';
    if (i + sizeof(http_host_str)-1 >= len)
    {
        return FALSE;
    }

    if (strncmp(data+i, http_host_str, sizeof(http_host_str)-1) != 0)
    {
        return FALSE;
    }
    i += sizeof(http_host_str)-1;

    for (j = 0; i < len && data[i] != '\r'; j++, i++)
    {
        domain[j] = data[i];
    }
    if (i >= len)
    {
        return FALSE;
    }
    if (j == 0)
    {
        return FALSE;
    }
    if (domain[j-1] == '.')
    {
        // Nice try...
        j--;
        if (j == 0)
        {
            return FALSE;
        }
    }
    domain[j] = '\0';

    printf("URL %s/%s: ", domain, uri);

    // Reverse the domain:
    for (i = 0; i < j / 2; i++)
    {
        char t = domain[i];
        domain[i] = domain[j-i-1];
        domain[j-i-1] = t;
    }

    // Search the blacklist:
    result = BlackListMatch(blacklist, &url);
    
    // Print the verdict:
    console = GetStdHandle(STD_OUTPUT_HANDLE);
    if (result)
    {
        SetConsoleTextAttribute(console, FOREGROUND_RED);
        puts("BLOCKED!");
    }
    else
    {
        SetConsoleTextAttribute(console, FOREGROUND_GREEN);
        puts("allowed");
    }
    SetConsoleTextAttribute(console,
        FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
    return result;
}

/*
 * URL comparison.
 */
static int __cdecl UrlCompare(const void *a, const void *b)
{
    PURL urla = *(PURL *)a;
    PURL urlb = *(PURL *)b;
    int cmp = strcmp(urla->domain, urlb->domain);
    if (cmp != 0)
    {
        return cmp;
    }
    return strcmp(urla->uri, urlb->uri);
}

/*
 * URL matching
 */
static int UrlMatch(PURL urla, PURL urlb)
{
    UINT16 i;

    for (i = 0; urla->domain[i] && urlb->domain[i]; i++)
    {
        int cmp = (int)urlb->domain[i] - (int)urla->domain[i];
        if (cmp != 0)
        {
            return cmp;
        }
    }
    if (urla->domain[i] == '\0' && urlb->domain[i] != '\0')
    {
        return 1;
    }

    for (i = 0; urla->uri[i] && urlb->uri[i]; i++)
    {
        int cmp = (int)urlb->uri[i] - (int)urla->uri[i];
        if (cmp != 0)
        {
            return cmp;
        }
    }
    if (urla->uri[i] == '\0' && urlb->uri[i] != '\0')
    {
        return 1;
    }
    return 0;
}


```

`examples/webfilter/webfilter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<!--

    webfilter.vcxproj
    (C) 2019, all rights reserved,
    
    This file is part of WinDivert.
    
    WinDivert is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    WinDivert is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc., 51
    Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
    
-->
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 <ItemGroup Label="ProjectConfigurations">
  <ProjectConfiguration Include="Release|Win32">
   <Configuration>Release</Configuration>
   <Platform>Win32</Platform>
  </ProjectConfiguration>
  <ProjectConfiguration Include="Release|x64">
   <Configuration>Release</Configuration>
   <Platform>x64</Platform>
  </ProjectConfiguration>
 </ItemGroup>
 <ItemGroup>
  <ClCompile Include="webfilter.c">
   <TreatWarningAsError>false</TreatWarningAsError>
   <Optimization>MinSpace</Optimization>
   <BasicRuntimeChecks>Default</BasicRuntimeChecks>
   <AdditionalIncludeDirectories>..\..\include</AdditionalIncludeDirectories>
  </ClCompile>
 </ItemGroup>
 <PropertyGroup Label="Globals">
  <RootNamespace>webfilter</RootNamespace>
  <ProjectName>webfilter</ProjectName>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props"/>
 <PropertyGroup Label="Configuration">
  <PlatformToolset>v140</PlatformToolset>
  <ConfigurationType>Application</ConfigurationType>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
 <ItemDefinitionGroup>
  <Link>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\install\MSVC\i386\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\install\MSVC\amd64\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
  </Link>
 </ItemDefinitionGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>

```

`examples/windivertctl/windivertctl.c`:

```c
/*
 * windivertctl.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * DESCRIPTION:
 *
 * usage: windivertctl.exe list
 */

#include <winsock2.h>
#include <windows.h>
#include <psapi.h>
#include <shlwapi.h>
#include <stdio.h>
#include <stdlib.h>

#include "windivert.h"

#define MAX_PACKET          0xFFFF
#define MAX_FILTER_LEN      30000

/*
 * Modes.
 */
typedef enum
{
    LIST,
    WATCH,
    KILL,
    UNINSTALL
} MODE;

/*
 * Entry.
 */
int __cdecl main(int argc, char **argv)
{
    HANDLE handle, process, console, mutex;
    INT16 priority = -333;      // Arbitrary.
    UINT packet_len;
    static UINT8 packet[MAX_PACKET];
    static char path[MAX_PATH+1];
    static char filter_str[MAX_FILTER_LEN];
    DWORD path_len;
    BOOL or;
    WINDIVERT_ADDRESS addr;
    ULONGLONG freq, start_count;
    LARGE_INTEGER li;
    MODE mode;
    SC_HANDLE manager = NULL, service = NULL;
    SERVICE_STATUS status;
    const char *filter = "true";
    const char *err_str = NULL;

    if (argc != 2 && argc != 3)
    {
usage:
        fprintf(stderr, "usage: %s (list|watch|kill) [filter]\n", argv[0]);
        fprintf(stderr, "       %s uninstall\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    if (strcmp(argv[1], "list") == 0)
    {
        mode = LIST;
    }
    else if (strcmp(argv[1], "watch") == 0)
    {
        mode = WATCH;
    }
    else if (strcmp(argv[1], "kill") == 0)
    {
        mode = KILL;
    }
    else if (strcmp(argv[1], "uninstall") == 0)
    {
        if (argc != 2)
        {
            goto usage;
        }
        mode = UNINSTALL;
    }
    else
    {
        goto usage;
    }
    if (argc == 3)
    {
        filter = argv[2];
    }

    // Time management
    QueryPerformanceFrequency(&li);
    freq = li.QuadPart;
    QueryPerformanceCounter(&li);
    start_count = li.QuadPart;

    // Open WinDivert REFLECT handle:
    handle = WinDivertOpen(filter, WINDIVERT_LAYER_REFLECT, priority, 
        WINDIVERT_FLAG_SNIFF | WINDIVERT_FLAG_RECV_ONLY |
            (mode == WATCH? 0: WINDIVERT_FLAG_NO_INSTALL));
    if (handle == INVALID_HANDLE_VALUE)
    {
        if (mode != WATCH && GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST)
        {
            // WinDivert driver is not running, so no open handles.
            return 0;
        }
        if (GetLastError() == ERROR_INVALID_PARAMETER &&
            !WinDivertHelperCompileFilter(filter, WINDIVERT_LAYER_REFLECT,
                NULL, 0, &err_str, NULL))
        {
            fprintf(stderr, "error: invalid filter \"%s\"\n", err_str);
            exit(EXIT_FAILURE);
        }
        fprintf(stderr, "error: failed to open the WinDivert device (%d)\n",
            GetLastError());
        return EXIT_FAILURE;
    }
    if (mode != WATCH && !WinDivertShutdown(handle, WINDIVERT_SHUTDOWN_BOTH))
    {
        fprintf(stderr, "error: failed to shutdown WinDivert handle (%d)\n",
            GetLastError());
        return EXIT_FAILURE;
    }
    if (!WinDivertSetParam(handle, WINDIVERT_PARAM_QUEUE_LENGTH,
            WINDIVERT_PARAM_QUEUE_LENGTH_MAX) ||
        !WinDivertSetParam(handle, WINDIVERT_PARAM_QUEUE_SIZE,
            WINDIVERT_PARAM_QUEUE_SIZE_MAX) ||
        !WinDivertSetParam(handle, WINDIVERT_PARAM_QUEUE_TIME,
            WINDIVERT_PARAM_QUEUE_TIME_MAX))
    {
        fprintf(stderr, "error: failed to set WinDivert handle params (%d)\n",
            GetLastError());
        return EXIT_FAILURE;
    }

    // Main loop:
    console = GetStdHandle(STD_OUTPUT_HANDLE);
    while (TRUE)
    {
        if (!WinDivertRecv(handle, packet, sizeof(packet), &packet_len, &addr))
        {
            if (mode != WATCH && GetLastError() == ERROR_NO_DATA)
            {
                break;
            }
            fprintf(stderr, "failed to receive event (%d)\n", GetLastError());
            continue;
        }

        switch (addr.Event)
        {
            case WINDIVERT_EVENT_REFLECT_OPEN:
                // Open handle:
                if (mode == KILL || mode == UNINSTALL)
                {
                    SetConsoleTextAttribute(console, FOREGROUND_RED);
                    fputs("KILL", stdout);
                }
                else
                {
                    SetConsoleTextAttribute(console, FOREGROUND_GREEN);
                    fputs("OPEN", stdout);
                }
                break;

            case WINDIVERT_EVENT_REFLECT_CLOSE:
                // Close handle:
                if (mode != WATCH)
                {
                    continue;
                }
                SetConsoleTextAttribute(console, FOREGROUND_RED);
                fputs("CLOSE", stdout);
                break;
            
            default:
                fputs("???", stdout);
                break;
        }
        process = OpenProcess(
            PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_TERMINATE,
            FALSE, addr.Reflect.ProcessId);
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        fputs(" time=", stdout);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        printf("%.3fs", (double)(addr.Reflect.Timestamp - (INT64)start_count) /
            (double)freq);
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        fputs(" pid=", stdout);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        printf("%u", addr.Reflect.ProcessId);
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        fputs(" exe=", stdout);
        path_len = 0;
        if (process != NULL)
        {
            path_len = GetProcessImageFileName(process, path, sizeof(path));
            if (mode == KILL || mode == UNINSTALL)
            {
                TerminateProcess(process, 0);
            }
            CloseHandle(process);
        }
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        printf("%s", (path_len != 0? path: "???"));
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        fputs(" layer=", stdout);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        switch (addr.Reflect.Layer)
        {
            case WINDIVERT_LAYER_NETWORK:
                fputs("NETWORK", stdout);
                break;
            case WINDIVERT_LAYER_NETWORK_FORWARD:
                fputs("NETWORK_FORWARD", stdout);
                break;
            case WINDIVERT_LAYER_FLOW:
                fputs("FLOW", stdout);
                break;
            case WINDIVERT_LAYER_SOCKET:
                fputs("SOCKET", stdout);
                break;
            case WINDIVERT_LAYER_REFLECT:
                fputs("REFLECT", stdout);
                break;
            default:
                fputs("???", stdout);
                break;
        }
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        fputs(" flags=", stdout);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        if (addr.Reflect.Flags == 0)
        {
            fputs("0", stdout);
        }
        else
        {
            or = FALSE;
            if ((addr.Reflect.Flags & WINDIVERT_FLAG_SNIFF) != 0)
            {
                fputs("SNIFF", stdout);
                or = TRUE;
            }
            if ((addr.Reflect.Flags & WINDIVERT_FLAG_DROP) != 0)
            {
                printf("%sDROP", (or? "|": ""));
                or = TRUE;
            }
            if ((addr.Reflect.Flags & WINDIVERT_FLAG_RECV_ONLY) != 0)
            {
                printf("%sRECV_ONLY", (or? "|": ""));
                or = TRUE;
            }
            if ((addr.Reflect.Flags & WINDIVERT_FLAG_SEND_ONLY) != 0)
            {
                printf("%sSEND_ONLY", (or? "|": ""));
                or = TRUE;
            }
            if ((addr.Reflect.Flags & WINDIVERT_FLAG_NO_INSTALL) != 0)
            {
                printf("%sNO_INSTALL", (or? "|": ""));
                or = TRUE;
            }
        }
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        fputs(" priority=", stdout);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        printf("%d", addr.Reflect.Priority);
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        fputs(" filter=", stdout);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        if (WinDivertHelperFormatFilter((char *)packet, addr.Reflect.Layer,
            filter_str, sizeof(filter_str)))
        {
            printf("\"%s\"", filter_str);
        }
        else
        {
            printf("\"%s\"", (char *)packet);
        }
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        putchar('\n');
    }

    if (!WinDivertClose(handle))
    {
        fprintf(stderr, "error: failed to close WinDivert handle (%d)\n",
            GetLastError());
        return EXIT_FAILURE;
    }

    if (mode == UNINSTALL)
    {
        // Stop & delete the WinDivert service:
        mutex = CreateMutex(NULL, FALSE, "WinDivertDriverInstallMutex");
        if (mutex == NULL)
        {
            fprintf(stderr, "error: failed to create WinDivert driver "
                "install mutex (%d)\n", GetLastError());
            return EXIT_FAILURE;
        }
        switch (WaitForSingleObject(mutex, INFINITE))
        {
            case WAIT_OBJECT_0: case WAIT_ABANDONED:
                break;
            default:
                fprintf(stderr, "error: failed to acquire WinDivert driver "
                    "install mutex (%d)\n", GetLastError());
                return EXIT_FAILURE;
        }
        manager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (manager == NULL)
        {
            fprintf(stderr, "error: failed to open service manager (%d)\n",
                GetLastError());
            return EXIT_FAILURE;
        }
        service = OpenService(manager, "WinDivert", SERVICE_ALL_ACCESS);
        if (service == NULL)
        {
            fprintf(stderr, "error: failed to open WinDivert service (%d)\n",
                GetLastError());
            return EXIT_FAILURE;
        }
        if (!ControlService(service, SERVICE_CONTROL_STOP, &status))
        {
            fprintf(stderr, "error: failed to stop WinDivert service (%d)\n",
                GetLastError());
            return EXIT_FAILURE;
        }
        if (status.dwCurrentState != SERVICE_STOPPED)
        {
            fprintf(stderr, "error: failed to stop WinDivert service");
            return EXIT_FAILURE;
        }
        CloseServiceHandle(service);
        CloseServiceHandle(manager);

        SetConsoleTextAttribute(console, FOREGROUND_GREEN);
        fputs("UNINSTALL", stdout);
        SetConsoleTextAttribute(console,
            FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        puts(" WinDivert");

        ReleaseMutex(mutex);
        CloseHandle(mutex);
    }

    return 0;
}


```

`examples/windivertctl/windivertctl.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<!--

    windivertctl.vcxproj
    (C) 2019, all rights reserved,
    
    This file is part of WinDivert.
    
    WinDivert is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    WinDivert is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc., 51
    Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
    
-->
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 <ItemGroup Label="ProjectConfigurations">
  <ProjectConfiguration Include="Release|Win32">
   <Configuration>Release</Configuration>
   <Platform>Win32</Platform>
  </ProjectConfiguration>
  <ProjectConfiguration Include="Release|x64">
   <Configuration>Release</Configuration>
   <Platform>x64</Platform>
  </ProjectConfiguration>
 </ItemGroup>
 <ItemGroup>
  <ClCompile Include="windivertctl.c">
   <TreatWarningAsError>false</TreatWarningAsError>
   <Optimization>MinSpace</Optimization>
   <BasicRuntimeChecks>Default</BasicRuntimeChecks>
   <AdditionalIncludeDirectories>..\..\include</AdditionalIncludeDirectories>
  </ClCompile>
 </ItemGroup>
 <PropertyGroup Label="Globals">
  <RootNamespace>windivertctl</RootNamespace>
  <ProjectName>windivertctl</ProjectName>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props"/>
 <PropertyGroup Label="Configuration">
  <PlatformToolset>v140</PlatformToolset>
  <ConfigurationType>Application</ConfigurationType>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
 <ItemDefinitionGroup>
  <Link>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\install\MSVC\i386\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\install\MSVC\amd64\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
  </Link>
 </ItemDefinitionGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>

```

`include/windivert.h`:

```h
/*
 * windivert.h
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#ifndef __WINDIVERT_H
#define __WINDIVERT_H

#ifndef WINDIVERT_KERNEL
#include <windows.h>
#endif      /* WINDIVERT_KERNEL */

#ifndef WINDIVERTEXPORT
#define WINDIVERTEXPORT     extern __declspec(dllimport)
#endif      /* WINDIVERTEXPORT */

#ifdef __MINGW32__
#define __in
#define __in_opt
#define __out
#define __out_opt
#define __inout
#define __inout_opt
#include <stdint.h>
#define INT8    int8_t
#define UINT8   uint8_t
#define INT16   int16_t
#define UINT16  uint16_t
#define INT32   int32_t
#define UINT32  uint32_t
#define INT64   int64_t
#define UINT64  uint64_t
#endif      /* __MINGW32__ */

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************/
/* WINDIVERT API                                                            */
/****************************************************************************/

/*
 * WinDivert layers.
 */
typedef enum
{
    WINDIVERT_LAYER_NETWORK = 0,        /* Network layer. */
    WINDIVERT_LAYER_NETWORK_FORWARD = 1,/* Network layer (forwarded packets) */
    WINDIVERT_LAYER_FLOW = 2,           /* Flow layer. */
    WINDIVERT_LAYER_SOCKET = 3,         /* Socket layer. */
    WINDIVERT_LAYER_REFLECT = 4,        /* Reflect layer. */
} WINDIVERT_LAYER, *PWINDIVERT_LAYER;

/*
 * WinDivert NETWORK and NETWORK_FORWARD layer data.
 */
typedef struct
{
    UINT32 IfIdx;                       /* Packet's interface index. */
    UINT32 SubIfIdx;                    /* Packet's sub-interface index. */
} WINDIVERT_DATA_NETWORK, *PWINDIVERT_DATA_NETWORK;

/*
 * WinDivert FLOW layer data.
 */
typedef struct
{
    UINT64 EndpointId;                  /* Endpoint ID. */
    UINT64 ParentEndpointId;            /* Parent endpoint ID. */
    UINT32 ProcessId;                   /* Process ID. */
    UINT32 LocalAddr[4];                /* Local address. */
    UINT32 RemoteAddr[4];               /* Remote address. */
    UINT16 LocalPort;                   /* Local port. */
    UINT16 RemotePort;                  /* Remote port. */
    UINT8  Protocol;                    /* Protocol. */
} WINDIVERT_DATA_FLOW, *PWINDIVERT_DATA_FLOW;

/*
 * WinDivert SOCKET layer data.
 */
typedef struct
{
    UINT64 EndpointId;                  /* Endpoint ID. */
    UINT64 ParentEndpointId;            /* Parent Endpoint ID. */
    UINT32 ProcessId;                   /* Process ID. */
    UINT32 LocalAddr[4];                /* Local address. */
    UINT32 RemoteAddr[4];               /* Remote address. */
    UINT16 LocalPort;                   /* Local port. */
    UINT16 RemotePort;                  /* Remote port. */
    UINT8  Protocol;                    /* Protocol. */
} WINDIVERT_DATA_SOCKET, *PWINDIVERT_DATA_SOCKET;

/*
 * WinDivert REFLECTION layer data.
 */
typedef struct
{
    INT64  Timestamp;                   /* Handle open time. */
    UINT32 ProcessId;                   /* Handle process ID. */
    WINDIVERT_LAYER Layer;              /* Handle layer. */
    UINT64 Flags;                       /* Handle flags. */
    INT16  Priority;                    /* Handle priority. */
} WINDIVERT_DATA_REFLECT, *PWINDIVERT_DATA_REFLECT;

/*
 * WinDivert address.
 */
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4201)
#endif
typedef struct
{
    INT64  Timestamp;                   /* Packet's timestamp. */
    UINT32 Layer:8;                     /* Packet's layer. */
    UINT32 Event:8;                     /* Packet event. */
    UINT32 Sniffed:1;                   /* Packet was sniffed? */
    UINT32 Outbound:1;                  /* Packet is outound? */
    UINT32 Loopback:1;                  /* Packet is loopback? */
    UINT32 Impostor:1;                  /* Packet is impostor? */
    UINT32 IPv6:1;                      /* Packet is IPv6? */
    UINT32 IPChecksum:1;                /* Packet has valid IPv4 checksum? */
    UINT32 TCPChecksum:1;               /* Packet has valid TCP checksum? */
    UINT32 UDPChecksum:1;               /* Packet has valid UDP checksum? */
    UINT32 Reserved1:8;
    UINT32 Reserved2;
    union
    {
        WINDIVERT_DATA_NETWORK Network; /* Network layer data. */
        WINDIVERT_DATA_FLOW Flow;       /* Flow layer data. */
        WINDIVERT_DATA_SOCKET Socket;   /* Socket layer data. */
        WINDIVERT_DATA_REFLECT Reflect; /* Reflect layer data. */
        UINT8 Reserved3[64];
    };
} WINDIVERT_ADDRESS, *PWINDIVERT_ADDRESS;
#ifdef _MSC_VER
#pragma warning(pop)
#endif

/*
 * WinDivert events.
 */
typedef enum
{
    WINDIVERT_EVENT_NETWORK_PACKET = 0, /* Network packet. */
    WINDIVERT_EVENT_FLOW_ESTABLISHED = 1,
                                        /* Flow established. */
    WINDIVERT_EVENT_FLOW_DELETED = 2,   /* Flow deleted. */
    WINDIVERT_EVENT_SOCKET_BIND = 3,    /* Socket bind. */
    WINDIVERT_EVENT_SOCKET_CONNECT = 4, /* Socket connect. */
    WINDIVERT_EVENT_SOCKET_LISTEN = 5,  /* Socket listen. */
    WINDIVERT_EVENT_SOCKET_ACCEPT = 6,  /* Socket accept. */
    WINDIVERT_EVENT_SOCKET_CLOSE = 7,   /* Socket close. */
    WINDIVERT_EVENT_REFLECT_OPEN = 8,   /* WinDivert handle opened. */
    WINDIVERT_EVENT_REFLECT_CLOSE = 9,  /* WinDivert handle closed. */
} WINDIVERT_EVENT, *PWINDIVERT_EVENT;

/*
 * WinDivert flags.
 */
#define WINDIVERT_FLAG_SNIFF            0x0001
#define WINDIVERT_FLAG_DROP             0x0002
#define WINDIVERT_FLAG_RECV_ONLY        0x0004
#define WINDIVERT_FLAG_READ_ONLY        WINDIVERT_FLAG_RECV_ONLY
#define WINDIVERT_FLAG_SEND_ONLY        0x0008
#define WINDIVERT_FLAG_WRITE_ONLY       WINDIVERT_FLAG_SEND_ONLY
#define WINDIVERT_FLAG_NO_INSTALL       0x0010
#define WINDIVERT_FLAG_FRAGMENTS        0x0020

/*
 * WinDivert parameters.
 */
typedef enum
{
    WINDIVERT_PARAM_QUEUE_LENGTH = 0,   /* Packet queue length. */
    WINDIVERT_PARAM_QUEUE_TIME = 1,     /* Packet queue time. */
    WINDIVERT_PARAM_QUEUE_SIZE = 2,     /* Packet queue size. */
    WINDIVERT_PARAM_VERSION_MAJOR = 3,  /* Driver version (major). */
    WINDIVERT_PARAM_VERSION_MINOR = 4,  /* Driver version (minor). */
} WINDIVERT_PARAM, *PWINDIVERT_PARAM;
#define WINDIVERT_PARAM_MAX             WINDIVERT_PARAM_VERSION_MINOR

/*
 * WinDivert shutdown parameter.
 */
typedef enum
{
    WINDIVERT_SHUTDOWN_RECV = 0x1,      /* Shutdown recv. */
    WINDIVERT_SHUTDOWN_SEND = 0x2,      /* Shutdown send. */
    WINDIVERT_SHUTDOWN_BOTH = 0x3,      /* Shutdown recv and send. */
} WINDIVERT_SHUTDOWN, *PWINDIVERT_SHUTDOWN;
#define WINDIVERT_SHUTDOWN_MAX          WINDIVERT_SHUTDOWN_BOTH

#ifndef WINDIVERT_KERNEL

/*
 * Open a WinDivert handle.
 */
WINDIVERTEXPORT HANDLE WinDivertOpen(
    __in        const char *filter,
    __in        WINDIVERT_LAYER layer,
    __in        INT16 priority,
    __in        UINT64 flags);

/*
 * Receive (read) a packet from a WinDivert handle.
 */
WINDIVERTEXPORT BOOL WinDivertRecv(
    __in        HANDLE handle,
    __out_opt   VOID *pPacket,
    __in        UINT packetLen,
    __out_opt   UINT *pRecvLen,
    __out_opt   WINDIVERT_ADDRESS *pAddr);

/*
 * Receive (read) a packet from a WinDivert handle.
 */
WINDIVERTEXPORT BOOL WinDivertRecvEx(
    __in        HANDLE handle,
    __out_opt   VOID *pPacket,
    __in        UINT packetLen,
    __out_opt   UINT *pRecvLen,
    __in        UINT64 flags,
    __out       WINDIVERT_ADDRESS *pAddr,
    __inout_opt UINT *pAddrLen,
    __inout_opt LPOVERLAPPED lpOverlapped);

/*
 * Send (write/inject) a packet to a WinDivert handle.
 */
WINDIVERTEXPORT BOOL WinDivertSend(
    __in        HANDLE handle,
    __in        const VOID *pPacket,
    __in        UINT packetLen,
    __out_opt   UINT *pSendLen,
    __in        const WINDIVERT_ADDRESS *pAddr);

/*
 * Send (write/inject) a packet to a WinDivert handle.
 */
WINDIVERTEXPORT BOOL WinDivertSendEx(
    __in        HANDLE handle,
    __in        const VOID *pPacket,
    __in        UINT packetLen,
    __out_opt   UINT *pSendLen,
    __in        UINT64 flags,
    __in        const WINDIVERT_ADDRESS *pAddr,
    __in        UINT addrLen,
    __inout_opt LPOVERLAPPED lpOverlapped);

/*
 * Shutdown a WinDivert handle.
 */
WINDIVERTEXPORT BOOL WinDivertShutdown(
    __in        HANDLE handle,
    __in        WINDIVERT_SHUTDOWN how);

/*
 * Close a WinDivert handle.
 */
WINDIVERTEXPORT BOOL WinDivertClose(
    __in        HANDLE handle);

/*
 * Set a WinDivert handle parameter.
 */
WINDIVERTEXPORT BOOL WinDivertSetParam(
    __in        HANDLE handle,
    __in        WINDIVERT_PARAM param,
    __in        UINT64 value);

/*
 * Get a WinDivert handle parameter.
 */
WINDIVERTEXPORT BOOL WinDivertGetParam(
    __in        HANDLE handle,
    __in        WINDIVERT_PARAM param,
    __out       UINT64 *pValue);

#endif      /* WINDIVERT_KERNEL */

/*
 * WinDivert constants.
 */
#define WINDIVERT_PRIORITY_HIGHEST              30000
#define WINDIVERT_PRIORITY_LOWEST               (-WINDIVERT_PRIORITY_HIGHEST)
#define WINDIVERT_PARAM_QUEUE_LENGTH_DEFAULT    4096
#define WINDIVERT_PARAM_QUEUE_LENGTH_MIN        32
#define WINDIVERT_PARAM_QUEUE_LENGTH_MAX        16384
#define WINDIVERT_PARAM_QUEUE_TIME_DEFAULT      2000        /* 2s */
#define WINDIVERT_PARAM_QUEUE_TIME_MIN          100         /* 100ms */
#define WINDIVERT_PARAM_QUEUE_TIME_MAX          16000       /* 16s */
#define WINDIVERT_PARAM_QUEUE_SIZE_DEFAULT      4194304     /* 4MB */
#define WINDIVERT_PARAM_QUEUE_SIZE_MIN          65535       /* 64KB */
#define WINDIVERT_PARAM_QUEUE_SIZE_MAX          33554432    /* 32MB */
#define WINDIVERT_BATCH_MAX                     0xFF        /* 255 */
#define WINDIVERT_MTU_MAX                       (40 + 0xFFFF)

/****************************************************************************/
/* WINDIVERT HELPER API                                                     */
/****************************************************************************/

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4214)
#endif

/*
 * IPv4/IPv6/ICMP/ICMPv6/TCP/UDP header definitions.
 */
typedef struct
{
    UINT8  HdrLength:4;
    UINT8  Version:4;
    UINT8  TOS;
    UINT16 Length;
    UINT16 Id;
    UINT16 FragOff0;
    UINT8  TTL;
    UINT8  Protocol;
    UINT16 Checksum;
    UINT32 SrcAddr;
    UINT32 DstAddr;
} WINDIVERT_IPHDR, *PWINDIVERT_IPHDR;

#define WINDIVERT_IPHDR_GET_FRAGOFF(hdr)                    \
    (((hdr)->FragOff0) & 0xFF1F)
#define WINDIVERT_IPHDR_GET_MF(hdr)                         \
    ((((hdr)->FragOff0) & 0x0020) != 0)
#define WINDIVERT_IPHDR_GET_DF(hdr)                         \
    ((((hdr)->FragOff0) & 0x0040) != 0)
#define WINDIVERT_IPHDR_GET_RESERVED(hdr)                   \
    ((((hdr)->FragOff0) & 0x0080) != 0)

#define WINDIVERT_IPHDR_SET_FRAGOFF(hdr, val)               \
    do                                                      \
    {                                                       \
        (hdr)->FragOff0 = (((hdr)->FragOff0) & 0x00E0) |    \
            ((val) & 0xFF1F);                               \
    }                                                       \
    while (FALSE)
#define WINDIVERT_IPHDR_SET_MF(hdr, val)                    \
    do                                                      \
    {                                                       \
        (hdr)->FragOff0 = (((hdr)->FragOff0) & 0xFFDF) |    \
            (((val) & 0x0001) << 5);                        \
    }                                                       \
    while (FALSE)
#define WINDIVERT_IPHDR_SET_DF(hdr, val)                    \
    do                                                      \
    {                                                       \
        (hdr)->FragOff0 = (((hdr)->FragOff0) & 0xFFBF) |    \
            (((val) & 0x0001) << 6);                        \
    }                                                       \
    while (FALSE)
#define WINDIVERT_IPHDR_SET_RESERVED(hdr, val)              \
    do                                                      \
    {                                                       \
        (hdr)->FragOff0 = (((hdr)->FragOff0) & 0xFF7F) |    \
            (((val) & 0x0001) << 7);                        \
    }                                                       \
    while (FALSE)

typedef struct
{
    UINT8  TrafficClass0:4;
    UINT8  Version:4;
    UINT8  FlowLabel0:4;
    UINT8  TrafficClass1:4;
    UINT16 FlowLabel1;
    UINT16 Length;
    UINT8  NextHdr;
    UINT8  HopLimit;
    UINT32 SrcAddr[4];
    UINT32 DstAddr[4];
} WINDIVERT_IPV6HDR, *PWINDIVERT_IPV6HDR;

#define WINDIVERT_IPV6HDR_GET_TRAFFICCLASS(hdr)             \
    ((((hdr)->TrafficClass0) << 4) | ((hdr)->TrafficClass1))
#define WINDIVERT_IPV6HDR_GET_FLOWLABEL(hdr)                \
    ((((UINT32)(hdr)->FlowLabel0) << 16) | ((UINT32)(hdr)->FlowLabel1))

#define WINDIVERT_IPV6HDR_SET_TRAFFICCLASS(hdr, val)        \
    do                                                      \
    {                                                       \
        (hdr)->TrafficClass0 = ((UINT8)(val) >> 4);         \
        (hdr)->TrafficClass1 = (UINT8)(val);                \
    }                                                       \
    while (FALSE)
#define WINDIVERT_IPV6HDR_SET_FLOWLABEL(hdr, val)           \
    do                                                      \
    {                                                       \
        (hdr)->FlowLabel0 = (UINT8)((val) >> 16);           \
        (hdr)->FlowLabel1 = (UINT16)(val);                  \
    }                                                       \
    while (FALSE)

typedef struct
{
    UINT8  Type;
    UINT8  Code;
    UINT16 Checksum;
    UINT32 Body;
} WINDIVERT_ICMPHDR, *PWINDIVERT_ICMPHDR;

typedef struct
{
    UINT8  Type;
    UINT8  Code;
    UINT16 Checksum;
    UINT32 Body;
} WINDIVERT_ICMPV6HDR, *PWINDIVERT_ICMPV6HDR;

typedef struct
{
    UINT16 SrcPort;
    UINT16 DstPort;
    UINT32 SeqNum;
    UINT32 AckNum;
    UINT16 Reserved1:4;
    UINT16 HdrLength:4;
    UINT16 Fin:1;
    UINT16 Syn:1;
    UINT16 Rst:1;
    UINT16 Psh:1;
    UINT16 Ack:1;
    UINT16 Urg:1;
    UINT16 Reserved2:2;
    UINT16 Window;
    UINT16 Checksum;
    UINT16 UrgPtr;
} WINDIVERT_TCPHDR, *PWINDIVERT_TCPHDR;

typedef struct
{
    UINT16 SrcPort;
    UINT16 DstPort;
    UINT16 Length;
    UINT16 Checksum;
} WINDIVERT_UDPHDR, *PWINDIVERT_UDPHDR;

#ifdef _MSC_VER
#pragma warning(pop)
#endif

/*
 * Flags for WinDivertHelperCalcChecksums()
 */
#define WINDIVERT_HELPER_NO_IP_CHECKSUM                     1
#define WINDIVERT_HELPER_NO_ICMP_CHECKSUM                   2
#define WINDIVERT_HELPER_NO_ICMPV6_CHECKSUM                 4
#define WINDIVERT_HELPER_NO_TCP_CHECKSUM                    8
#define WINDIVERT_HELPER_NO_UDP_CHECKSUM                    16

#ifndef WINDIVERT_KERNEL

/*
 * Hash a packet.
 */
WINDIVERTEXPORT UINT64 WinDivertHelperHashPacket(
    __in        const VOID *pPacket,
    __in        UINT packetLen,
    __in        UINT64 seed
#ifdef __cplusplus
                = 0
#endif
);

/*
 * Parse IPv4/IPv6/ICMP/ICMPv6/TCP/UDP headers from a raw packet.
 */
WINDIVERTEXPORT BOOL WinDivertHelperParsePacket(
    __in        const VOID *pPacket,
    __in        UINT packetLen,
    __out_opt   PWINDIVERT_IPHDR *ppIpHdr,
    __out_opt   PWINDIVERT_IPV6HDR *ppIpv6Hdr,
    __out_opt   UINT8 *pProtocol,
    __out_opt   PWINDIVERT_ICMPHDR *ppIcmpHdr,
    __out_opt   PWINDIVERT_ICMPV6HDR *ppIcmpv6Hdr,
    __out_opt   PWINDIVERT_TCPHDR *ppTcpHdr,
    __out_opt   PWINDIVERT_UDPHDR *ppUdpHdr,
    __out_opt   PVOID *ppData,
    __out_opt   UINT *pDataLen,
    __out_opt   PVOID *ppNext,
    __out_opt   UINT *pNextLen);

/*
 * Parse an IPv4 address.
 */
WINDIVERTEXPORT BOOL WinDivertHelperParseIPv4Address(
    __in        const char *addrStr,
    __out_opt   UINT32 *pAddr);

/*
 * Parse an IPv6 address.
 */
WINDIVERTEXPORT BOOL WinDivertHelperParseIPv6Address(
    __in        const char *addrStr,
    __out_opt   UINT32 *pAddr);

/*
 * Format an IPv4 address.
 */
WINDIVERTEXPORT BOOL WinDivertHelperFormatIPv4Address(
    __in        UINT32 addr,
    __out       char *buffer,
    __in        UINT bufLen);

/*
 * Format an IPv6 address.
 */
WINDIVERTEXPORT BOOL WinDivertHelperFormatIPv6Address(
    __in        const UINT32 *pAddr,
    __out       char *buffer,
    __in        UINT bufLen);

/*
 * Calculate IPv4/IPv6/ICMP/ICMPv6/TCP/UDP checksums.
 */
WINDIVERTEXPORT BOOL WinDivertHelperCalcChecksums(
    __inout     VOID *pPacket, 
    __in        UINT packetLen,
    __out_opt   WINDIVERT_ADDRESS *pAddr,
    __in        UINT64 flags);

/*
 * Decrement the TTL/HopLimit.
 */
WINDIVERTEXPORT BOOL WinDivertHelperDecrementTTL(
    __inout     VOID *pPacket,
    __in        UINT packetLen);

/*
 * Compile the given filter string.
 */
WINDIVERTEXPORT BOOL WinDivertHelperCompileFilter(
    __in        const char *filter,
    __in        WINDIVERT_LAYER layer,
    __out_opt   char *object,
    __in        UINT objLen,
    __out_opt   const char **errorStr,
    __out_opt   UINT *errorPos);

/*
 * Evaluate the given filter string.
 */
WINDIVERTEXPORT BOOL WinDivertHelperEvalFilter(
    __in        const char *filter,
    __in        const VOID *pPacket,
    __in        UINT packetLen,
    __in        const WINDIVERT_ADDRESS *pAddr);

/*
 * Format the given filter string.
 */
WINDIVERTEXPORT BOOL WinDivertHelperFormatFilter(
    __in        const char *filter,
    __in        WINDIVERT_LAYER layer,
    __out       char *buffer,
    __in        UINT bufLen);

/*
 * Byte ordering.
 */
WINDIVERTEXPORT UINT16 WinDivertHelperNtohs(
    __in        UINT16 x);
WINDIVERTEXPORT UINT16 WinDivertHelperHtons(
    __in        UINT16 x);
WINDIVERTEXPORT UINT32 WinDivertHelperNtohl(
    __in        UINT32 x);
WINDIVERTEXPORT UINT32 WinDivertHelperHtonl(
    __in        UINT32 x);
WINDIVERTEXPORT UINT64 WinDivertHelperNtohll(
    __in        UINT64 x);
WINDIVERTEXPORT UINT64 WinDivertHelperHtonll(
    __in        UINT64 x);
WINDIVERTEXPORT void WinDivertHelperNtohIPv6Address(
    __in        const UINT *inAddr,
    __out       UINT *outAddr);
WINDIVERTEXPORT void WinDivertHelperHtonIPv6Address(
    __in        const UINT *inAddr,
    __out       UINT *outAddr);

/*
 * Old names to be removed in the next version.
 */
WINDIVERTEXPORT void WinDivertHelperNtohIpv6Address(
    __in        const UINT *inAddr,
    __out       UINT *outAddr);
WINDIVERTEXPORT void WinDivertHelperHtonIpv6Address(
    __in        const UINT *inAddr,
    __out       UINT *outAddr);

#endif      /* WINDIVERT_KERNEL */

#ifdef __cplusplus
}
#endif

#endif      /* __WINDIVERT_H */

```

`include/windivert_device.h`:

```h
/*
 * windivert_device.h
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#ifndef __WINDIVERT_DEVICE_H
#define __WINDIVERT_DEVICE_H

/*
 * NOTE: This is the low-level interface to the WinDivert device driver.
 *       This interface should not be used directly, instead use the high-level
 *       interface provided by the WinDivert API.
 */

#define WINDIVERT_KERNEL
#include "windivert.h"

#define WINDIVERT_VERSION_MAJOR                     2
#define WINDIVERT_VERSION_MINOR                     2

#define WINDIVERT_MAGIC_DLL                         0x4C4C447669645724ull
#define WINDIVERT_MAGIC_SYS                         0x5359537669645723ull

#define WINDIVERT_STR2(s)                           #s
#define WINDIVERT_STR(s)                            WINDIVERT_STR2(s)
#define WINDIVERT_LSTR2(s)                          L ## #s
#define WINDIVERT_LSTR(s)                           WINDIVERT_LSTR2(s)

#define WINDIVERT_VERSION_LSTR                                              \
    WINDIVERT_LSTR(WINDIVERT_VERSION_MAJOR) L"."                            \
        WINDIVERT_LSTR(WINDIVERT_VERSION_MINOR)

#define WINDIVERT_DEVICE_NAME                                               \
    L"WinDivert"
#define WINDIVERT_LAYER_NAME                                                \
    WINDIVERT_DEVICE_NAME WINDIVERT_VERSION_LSTR

#define WINDIVERT_FILTER_FIELD_ZERO                 0
#define WINDIVERT_FILTER_FIELD_INBOUND              1
#define WINDIVERT_FILTER_FIELD_OUTBOUND             2
#define WINDIVERT_FILTER_FIELD_IFIDX                3
#define WINDIVERT_FILTER_FIELD_SUBIFIDX             4
#define WINDIVERT_FILTER_FIELD_IP                   5
#define WINDIVERT_FILTER_FIELD_IPV6                 6
#define WINDIVERT_FILTER_FIELD_ICMP                 7
#define WINDIVERT_FILTER_FIELD_TCP                  8
#define WINDIVERT_FILTER_FIELD_UDP                  9
#define WINDIVERT_FILTER_FIELD_ICMPV6               10
#define WINDIVERT_FILTER_FIELD_IP_HDRLENGTH         11
#define WINDIVERT_FILTER_FIELD_IP_TOS               12
#define WINDIVERT_FILTER_FIELD_IP_LENGTH            13
#define WINDIVERT_FILTER_FIELD_IP_ID                14
#define WINDIVERT_FILTER_FIELD_IP_DF                15
#define WINDIVERT_FILTER_FIELD_IP_MF                16
#define WINDIVERT_FILTER_FIELD_IP_FRAGOFF           17
#define WINDIVERT_FILTER_FIELD_IP_TTL               18
#define WINDIVERT_FILTER_FIELD_IP_PROTOCOL          19
#define WINDIVERT_FILTER_FIELD_IP_CHECKSUM          20
#define WINDIVERT_FILTER_FIELD_IP_SRCADDR           21
#define WINDIVERT_FILTER_FIELD_IP_DSTADDR           22
#define WINDIVERT_FILTER_FIELD_IPV6_TRAFFICCLASS    23
#define WINDIVERT_FILTER_FIELD_IPV6_FLOWLABEL       24
#define WINDIVERT_FILTER_FIELD_IPV6_LENGTH          25
#define WINDIVERT_FILTER_FIELD_IPV6_NEXTHDR         26
#define WINDIVERT_FILTER_FIELD_IPV6_HOPLIMIT        27
#define WINDIVERT_FILTER_FIELD_IPV6_SRCADDR         28
#define WINDIVERT_FILTER_FIELD_IPV6_DSTADDR         29
#define WINDIVERT_FILTER_FIELD_ICMP_TYPE            30
#define WINDIVERT_FILTER_FIELD_ICMP_CODE            31
#define WINDIVERT_FILTER_FIELD_ICMP_CHECKSUM        32
#define WINDIVERT_FILTER_FIELD_ICMP_BODY            33
#define WINDIVERT_FILTER_FIELD_ICMPV6_TYPE          34
#define WINDIVERT_FILTER_FIELD_ICMPV6_CODE          35
#define WINDIVERT_FILTER_FIELD_ICMPV6_CHECKSUM      36
#define WINDIVERT_FILTER_FIELD_ICMPV6_BODY          37
#define WINDIVERT_FILTER_FIELD_TCP_SRCPORT          38
#define WINDIVERT_FILTER_FIELD_TCP_DSTPORT          39
#define WINDIVERT_FILTER_FIELD_TCP_SEQNUM           40
#define WINDIVERT_FILTER_FIELD_TCP_ACKNUM           41
#define WINDIVERT_FILTER_FIELD_TCP_HDRLENGTH        42
#define WINDIVERT_FILTER_FIELD_TCP_URG              43
#define WINDIVERT_FILTER_FIELD_TCP_ACK              44
#define WINDIVERT_FILTER_FIELD_TCP_PSH              45
#define WINDIVERT_FILTER_FIELD_TCP_RST              46
#define WINDIVERT_FILTER_FIELD_TCP_SYN              47
#define WINDIVERT_FILTER_FIELD_TCP_FIN              48
#define WINDIVERT_FILTER_FIELD_TCP_WINDOW           49
#define WINDIVERT_FILTER_FIELD_TCP_CHECKSUM         50
#define WINDIVERT_FILTER_FIELD_TCP_URGPTR           51
#define WINDIVERT_FILTER_FIELD_TCP_PAYLOADLENGTH    52
#define WINDIVERT_FILTER_FIELD_UDP_SRCPORT          53
#define WINDIVERT_FILTER_FIELD_UDP_DSTPORT          54
#define WINDIVERT_FILTER_FIELD_UDP_LENGTH           55
#define WINDIVERT_FILTER_FIELD_UDP_CHECKSUM         56
#define WINDIVERT_FILTER_FIELD_UDP_PAYLOADLENGTH    57
#define WINDIVERT_FILTER_FIELD_LOOPBACK             58
#define WINDIVERT_FILTER_FIELD_IMPOSTOR             59
#define WINDIVERT_FILTER_FIELD_PROCESSID            60
#define WINDIVERT_FILTER_FIELD_LOCALADDR            61
#define WINDIVERT_FILTER_FIELD_REMOTEADDR           62
#define WINDIVERT_FILTER_FIELD_LOCALPORT            63
#define WINDIVERT_FILTER_FIELD_REMOTEPORT           64
#define WINDIVERT_FILTER_FIELD_PROTOCOL             65
#define WINDIVERT_FILTER_FIELD_ENDPOINTID           66
#define WINDIVERT_FILTER_FIELD_PARENTENDPOINTID     67
#define WINDIVERT_FILTER_FIELD_LAYER                68
#define WINDIVERT_FILTER_FIELD_PRIORITY             69
#define WINDIVERT_FILTER_FIELD_EVENT                70
#define WINDIVERT_FILTER_FIELD_PACKET               71
#define WINDIVERT_FILTER_FIELD_PACKET16             72
#define WINDIVERT_FILTER_FIELD_PACKET32             73
#define WINDIVERT_FILTER_FIELD_TCP_PAYLOAD          74
#define WINDIVERT_FILTER_FIELD_TCP_PAYLOAD16        75
#define WINDIVERT_FILTER_FIELD_TCP_PAYLOAD32        76
#define WINDIVERT_FILTER_FIELD_UDP_PAYLOAD          77
#define WINDIVERT_FILTER_FIELD_UDP_PAYLOAD16        78
#define WINDIVERT_FILTER_FIELD_UDP_PAYLOAD32        79
#define WINDIVERT_FILTER_FIELD_LENGTH               80
#define WINDIVERT_FILTER_FIELD_TIMESTAMP            81
#define WINDIVERT_FILTER_FIELD_RANDOM8              82
#define WINDIVERT_FILTER_FIELD_RANDOM16             83
#define WINDIVERT_FILTER_FIELD_RANDOM32             84
#define WINDIVERT_FILTER_FIELD_FRAGMENT             85
#define WINDIVERT_FILTER_FIELD_MAX                  \
    WINDIVERT_FILTER_FIELD_FRAGMENT

#define WINDIVERT_FILTER_TEST_EQ                    0
#define WINDIVERT_FILTER_TEST_NEQ                   1
#define WINDIVERT_FILTER_TEST_LT                    2
#define WINDIVERT_FILTER_TEST_LEQ                   3
#define WINDIVERT_FILTER_TEST_GT                    4
#define WINDIVERT_FILTER_TEST_GEQ                   5
#define WINDIVERT_FILTER_TEST_MAX                   WINDIVERT_FILTER_TEST_GEQ

#define WINDIVERT_FILTER_MAXLEN                     256

#define WINDIVERT_FILTER_RESULT_ACCEPT              0x7FFE
#define WINDIVERT_FILTER_RESULT_REJECT              0x7FFF

/*
 * WinDivert layers.
 */
#define WINDIVERT_LAYER_MAX                         WINDIVERT_LAYER_REFLECT

/*
 * WinDivert events.
 */
#define WINDIVERT_EVENT_MAX                         \
    WINDIVERT_EVENT_REFLECT_CLOSE

/*
 * WinDivert flags.
 */
#define WINDIVERT_FLAGS_ALL                                                 \
    (WINDIVERT_FLAG_SNIFF | WINDIVERT_FLAG_DROP | WINDIVERT_FLAG_RECV_ONLY |\
        WINDIVERT_FLAG_SEND_ONLY | WINDIVERT_FLAG_NO_INSTALL |              \
        WINDIVERT_FLAG_FRAGMENTS)
#define WINDIVERT_FLAGS_EXCLUDE(flags, flag1, flag2)                        \
    (((flags) & ((flag1) | (flag2))) != ((flag1) | (flag2)))
#define WINDIVERT_FLAGS_VALID(flags)                                        \
    ((((flags) & ~WINDIVERT_FLAGS_ALL) == 0) &&                             \
     WINDIVERT_FLAGS_EXCLUDE(flags, WINDIVERT_FLAG_SNIFF,                   \
        WINDIVERT_FLAG_DROP) &&                                             \
     WINDIVERT_FLAGS_EXCLUDE(flags, WINDIVERT_FLAG_RECV_ONLY,               \
        WINDIVERT_FLAG_SEND_ONLY))

/*
 * WinDivert filter flags.
 */
#define WINDIVERT_FILTER_FLAG_INBOUND               0x0000000000000010ull
#define WINDIVERT_FILTER_FLAG_OUTBOUND              0x0000000000000020ull
#define WINDIVERT_FILTER_FLAG_IP                    0x0000000000000040ull
#define WINDIVERT_FILTER_FLAG_IPV6                  0x0000000000000080ull
#define WINDIVERT_FILTER_FLAG_EVENT_FLOW_DELETED    0x0000000000000100ull
#define WINDIVERT_FILTER_FLAG_EVENT_SOCKET_BIND     0x0000000000000200ull
#define WINDIVERT_FILTER_FLAG_EVENT_SOCKET_CONNECT  0x0000000000000400ull
#define WINDIVERT_FILTER_FLAG_EVENT_SOCKET_LISTEN   0x0000000000000800ull
#define WINDIVERT_FILTER_FLAG_EVENT_SOCKET_ACCEPT   0x0000000000001000ull
#define WINDIVERT_FILTER_FLAG_EVENT_SOCKET_CLOSE    0x0000000000002000ull

#define WINDIVERT_FILTER_FLAGS_ALL                                          \
    (WINDIVERT_FILTER_FLAG_INBOUND |                                        \
        WINDIVERT_FILTER_FLAG_OUTBOUND |                                    \
        WINDIVERT_FILTER_FLAG_IP |                                          \
        WINDIVERT_FILTER_FLAG_IPV6 |                                        \
        WINDIVERT_FILTER_FLAG_EVENT_FLOW_DELETED |                          \
        WINDIVERT_FILTER_FLAG_EVENT_SOCKET_BIND |                           \
        WINDIVERT_FILTER_FLAG_EVENT_SOCKET_CONNECT |                        \
        WINDIVERT_FILTER_FLAG_EVENT_SOCKET_LISTEN |                         \
        WINDIVERT_FILTER_FLAG_EVENT_SOCKET_ACCEPT |                         \
        WINDIVERT_FILTER_FLAG_EVENT_SOCKET_CLOSE)

/*
 * WinDivert priorities.
 */
#define WINDIVERT_PRIORITY_MAX                      WINDIVERT_PRIORITY_HIGHEST
#define WINDIVERT_PRIORITY_MIN                      WINDIVERT_PRIORITY_LOWEST

/*
 * WinDivert timestamps.
 */
#define WINDIVERT_TIMESTAMP_MAX                     0x7FFFFFFFFFFFFFFFull

/*
 * WinDivert message definitions.
 */
#pragma pack(push, 1)
typedef union
{
    struct
    {
        UINT64 addr;                // WINDIVERT_ADDRESS pointer.
        UINT64 addr_len_ptr;        // sizeof(addr) pointer.
    } recv;
    struct
    {
        UINT64 addr;                // WINDIVERT_ADDRESS pointer.
        UINT64 addr_len;            // sizeof(addr).
    } send;
    struct
    {
        UINT32 layer;               // Handle layer.
        UINT32 priority;            // Handle priority.
        UINT64 flags;               // Handle flags.
    } initialize;
    struct
    {
        UINT64 flags;               // Filter flags.
    } startup;
    struct
    {
        UINT32 how;                 // WINDIVERT_SHUTDOWN_*
    } shutdown;
    struct
    {
        UINT32 param;               // WINDIVERT_PARAM_*
    } get_param;
    struct
    {
        UINT64 val;                 // Value pointer.
        UINT32 param;               // WINDIVERT_PARAM_*
    } set_param;
} WINDIVERT_IOCTL, *PWINDIVERT_IOCTL;

/*
 * WinDivert initialization structure.
 */
typedef struct
{
    UINT64 magic;                   // Magic number (in/out).
    UINT32 major;                   // Driver major version (in/out).
    UINT32 minor;                   // Driver minor version (in/out).
    UINT32 bits;                    // 32 or 64 (in/out).
    UINT32 reserved32[3];
    UINT64 reserved64[4];
} WINDIVERT_VERSION, *PWINDIVERT_VERSION;

/*
 * WinDivert filter structure.
 */
typedef struct
{
    UINT32 field:11;                // WINDIVERT_FILTER_FIELD_*
    UINT32 test:5;                  // WINDIVERT_FILTER_TEST_*
    UINT32 success:16;              // Success continuation.
    UINT32 failure:16;              // Fail continuation.
    UINT32 neg:1;                   // Argument negative?
    UINT32 reserved:15;
    UINT32 arg[4];                  // Argument.
} WINDIVERT_FILTER, *PWINDIVERT_FILTER;
#pragma pack(pop)

/*
 * IOCTL codes.
 */
#define IOCTL_WINDIVERT_INITIALIZE                                          \
    CTL_CODE(FILE_DEVICE_NETWORK, 0x921, METHOD_OUT_DIRECT, FILE_READ_DATA |\
        FILE_WRITE_DATA)
#define IOCTL_WINDIVERT_STARTUP                                             \
    CTL_CODE(FILE_DEVICE_NETWORK, 0x922, METHOD_IN_DIRECT, FILE_READ_DATA | \
        FILE_WRITE_DATA)
#define IOCTL_WINDIVERT_RECV                                                \
    CTL_CODE(FILE_DEVICE_NETWORK, 0x923, METHOD_OUT_DIRECT, FILE_READ_DATA)
#define IOCTL_WINDIVERT_SEND                                                \
    CTL_CODE(FILE_DEVICE_NETWORK, 0x924, METHOD_IN_DIRECT, FILE_READ_DATA | \
        FILE_WRITE_DATA)
#define IOCTL_WINDIVERT_SET_PARAM                                           \
    CTL_CODE(FILE_DEVICE_NETWORK, 0x925, METHOD_IN_DIRECT, FILE_READ_DATA | \
        FILE_WRITE_DATA)
#define IOCTL_WINDIVERT_GET_PARAM                                           \
    CTL_CODE(FILE_DEVICE_NETWORK, 0x926, METHOD_OUT_DIRECT, FILE_READ_DATA)
#define IOCTL_WINDIVERT_SHUTDOWN                                            \
    CTL_CODE(FILE_DEVICE_NETWORK, 0x927, METHOD_IN_DIRECT, FILE_READ_DATA | \
        FILE_WRITE_DATA)

#endif      /* __WINDIVERT_DEVICE_H */

```

`inf/windivert32.inf`:

```inf
[Version]
Signature = "$Windows NT$"
Class = WFPCALLOUTS
ClassGuid = {57465043-616C-6C6F-7574-5F636C617373}
Provider = %Basil%
CatalogFile = WinDivert32.Cat
DriverVer = 08/08/2019,2.2.0

[SourceDisksNames]
1 = %DiskName%

[SourceDisksFiles]
WinDivert32.sys = 1

[DestinationDirs]
DefaultDestDir = 12 ; %windir%\system32\drivers
WinDivertCalloutDriver.DriverFiles = 12 ; %windir%\system32\drivers

[DefaultInstall]
OptionDesc = %Description%
CopyFiles = WinDivertCalloutDriver.DriverFiles

[DefaultInstall.Services]
AddService = %ServiceName%,,WinDivertCalloutDriver.Service

[WinDivertCalloutDriver.DriverFiles]
WinDivert32.sys,,,0x00000040 ; COPYFLG_OVERWRITE_OLDER_ONLY

[WinDivertCalloutDriver.Service]
DisplayName = %ServiceName%
Description = %ServiceDesc%
ServiceType = 1  ; SERVICE_KERNEL_DRIVER
StartType = 0    ; SERVICE_BOOT_START
ErrorControl = 1 ; SERVICE_ERROR_NORMAL
ServiceBinary = %12%\WinDivert32.sys

[Strings]
Basil = "Basil"
DiskName = "WinDivert Installation Disk"
Description = "WinDivert Driver"
ServiceName = "WinDivert"
ServiceDesc = "WinDivert Driver"

```

`inf/windivert64.inf`:

```inf
[Version]
Signature = "$Windows NT$"
Class = WFPCALLOUTS
ClassGuid = {57465043-616C-6C6F-7574-5F636C617373}
Provider = %Basil%
CatalogFile = WinDivert64.Cat
DriverVer = 08/08/2019,2.2.0

[SourceDisksNames]
1 = %DiskName%

[SourceDisksFiles]
WinDivert64.sys = 1

[DestinationDirs]
DefaultDestDir = 12 ; %windir%\system32\drivers
WinDivertCalloutDriver.DriverFiles = 12 ; %windir%\system32\drivers

[DefaultInstall]
OptionDesc = %Description%
CopyFiles = WinDivertCalloutDriver.DriverFiles

[DefaultInstall.Services]
AddService = %ServiceName%,,WinDivertCalloutDriver.Service

[WinDivertCalloutDriver.DriverFiles]
WinDivert64.sys,,,0x00000040 ; COPYFLG_OVERWRITE_OLDER_ONLY

[WinDivertCalloutDriver.Service]
DisplayName = %ServiceName%
Description = %ServiceDesc%
ServiceType = 1  ; SERVICE_KERNEL_DRIVER
StartType = 0    ; SERVICE_BOOT_START
ErrorControl = 1 ; SERVICE_ERROR_NORMAL
ServiceBinary = %12%\WinDivert64.sys

[Strings]
Basil = "Basil"
DiskName = "WinDivert Installation Disk"
Description = "WinDivert Driver"
ServiceName = "WinDivert"
ServiceDesc = "WinDivert Driver"

```

`mingw-build.sh`:

```sh
#!/bin/bash
#
# mingw-build.sh
# (C) 2019, all rights reserved,
#
# This file is part of WinDivert.
#
# WinDivert is free software: you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
# License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# WinDivert is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

# Script for MinGW/Linux cross compilation.
# NOTE: run msvc-build.bat before this script.

set -e

ENVS="i686-w64-mingw32 x86_64-w64-mingw32"

if [ "$1" = "debug" ]
then
    EXTRA_OPTS="-lmsvcrt -include stdio.h"
fi 

for ENV in $ENVS
do
    if [ $ENV = "i686-w64-mingw32" ]
    then
        CPU=i386
        BITS=32
        MANGLE=_
    else
        CPU=amd64
        BITS=64
        MANGLE=
    fi
    HAVE_SYS=yes
    if [ ! -d install/MSVC/$CPU ]
    then
        echo "WARNING: missing MSVC build; run msvc-build.bat first"
        HAVE_SYS=no
    fi
    echo "BUILD MINGW-$CPU"
    CC="$ENV-gcc"
    COPTS="-fno-ident -shared -Wall -Wno-pointer-to-int-cast -Os -Iinclude/ 
        -Wl,--enable-stdcall-fixup -Wl,--entry=${MANGLE}WinDivertDllEntry"
    CLIBS="-lkernel32 -ladvapi32 $EXTRA_OPTS"
    STRIP="$ENV-strip"
    DLLTOOL="$ENV-dlltool"
    if [ -x "`which $CC`" ]
    then
        echo "\tmake install/MINGW/$CPU..."
        mkdir -p "install/MINGW/$CPU"
        echo "\tbuild install/MINGW/$CPU/WinDivert.dll..."
        $CC $COPTS -c dll/windivert.c -o dll/windivert.o
        $CC $COPTS -o "install/MINGW/$CPU/WinDivert.dll" \
            dll/windivert.o dll/windivert.def -nostdlib $CLIBS
        $STRIP "install/MINGW/$CPU/WinDivert.dll"
        echo "\tbuild install/MINGW/$CPU/WinDivert.lib..."
        $DLLTOOL --dllname install/MINGW/$CPU/WinDivert.dll \
            --def dll/windivert.def \
            --output-lib install/MINGW/$CPU/WinDivert.lib 2>/dev/null
        echo "\tbuild install/MINGW/$CPU/netdump.exe..."
        $CC -s -O2 -Iinclude/ examples/netdump/netdump.c \
            -o "install/MINGW/$CPU/netdump.exe" -lWinDivert \
            -L"install/MINGW/$CPU/"
        echo "\tbuild install/MINGW/$CPU/netfilter.exe..."
        $CC -s -O2 -Iinclude/ examples/netfilter/netfilter.c \
            -o "install/MINGW/$CPU/netfilter.exe" -lWinDivert \
            -L"install/MINGW/$CPU/"
        echo "\tbuild install/MINGW/$CPU/passthru.exe..."
        $CC -s -O2 -Iinclude/ examples/passthru/passthru.c \
            -o "install/MINGW/$CPU/passthru.exe" -lWinDivert \
            -L"install/MINGW/$CPU/"
        echo "\tbuild install/MINGW/$CPU/webfilter.exe..."
        $CC -s -O2 -Iinclude/ examples/webfilter/webfilter.c \
            -o "install/MINGW/$CPU/webfilter.exe" -lWinDivert \
            -L"install/MINGW/$CPU/"
        echo "\tbuild install/MINGW/$CPU/streamdump.exe..."
        $CC -s -O2 -Iinclude/ examples/streamdump/streamdump.c \
            -o "install/MINGW/$CPU/streamdump.exe" -lWinDivert -lws2_32 \
            -L"install/MINGW/$CPU/"
        echo "\tbuild install/MINGW/$CPU/flowtrack.exe..."
        $CC -s -O2 -Iinclude/ examples/flowtrack/flowtrack.c \
            -o "install/MINGW/$CPU/flowtrack.exe" -lWinDivert -lpsapi \
            -lshlwapi -L"install/MINGW/$CPU/"
        echo "\tbuild install/MINGW/$CPU/windivertctl.exe..."
        $CC -s -O2 -Iinclude/ examples/windivertctl/windivertctl.c \
            -o "install/MINGW/$CPU/windivertctl.exe" -lWinDivert \
            -lpsapi -lshlwapi -L"install/MINGW/$CPU/"
        echo "\tbuild install/MINGW/$CPU/socketdump.exe..."
        $CC -s -O2 -Iinclude/ examples/socketdump/socketdump.c \
            -o "install/MINGW/$CPU/socketdump.exe" -lWinDivert \
            -lpsapi -lshlwapi -L"install/MINGW/$CPU/"
        echo "\tbuild install/MINGW/$CPU/test.exe..."
        $CC -s -O2 -Iinclude/ test/test.c \
            -o "install/MINGW/$CPU/test.exe" -lWinDivert \
            -L"install/MINGW/$CPU/"
        if [ $HAVE_SYS = yes ]
        then
            echo "\tcopy install/MINGW/$CPU/WinDivert$BITS.sys..."
            cp install/MSVC/$CPU/WinDivert$BITS.sys install/MINGW/$CPU
        fi
    else
        echo "WARNING: $CC not found"
    fi
done


```

`msvc-build.bat`:

```bat
:: msvc-build.bat
:: (C) 2019, all rights reserved,
::
:: This file is part of WinDivert.
::
:: WinDivert is free software: you can redistribute it and/or modify it under
:: the terms of the GNU Lesser General Public License as published by the
:: Free Software Foundation, either version 3 of the License, or (at your
:: option) any later version.
::
:: This program is distributed in the hope that it will be useful, but
:: WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
:: or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
:: License for more details.
::
:: You should have received a copy of the GNU Lesser General Public License
:: along with this program.  If not, see <http://www.gnu.org/licenses/>.
::
:: WinDivert is free software; you can redistribute it and/or modify it under
:: the terms of the GNU General Public License as published by the Free
:: Software Foundation; either version 2 of the License, or (at your option)
:: any later version.
:: 
:: This program is distributed in the hope that it will be useful, but
:: WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
:: or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
:: for more details.
:: 
:: You should have received a copy of the GNU General Public License along
:: with this program; if not, write to the Free Software Foundation, Inc., 51
:: Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

@echo off

msbuild sys\windivert.vcxproj ^
    /p:Configuration=Release ^
    /p:platform=Win32 ^
    /p:SignMode=Off ^
    /p:OutDir=..\install\MSVC\i386\ ^
    /p:AssemblyName=WinDivert32

msbuild sys\windivert.vcxproj ^
    /p:Configuration=Release ^
    /p:platform=x64 ^
    /p:SignMode=Off ^
    /p:OutDir=..\install\MSVC\amd64\ ^
    /p:AssemblyName=WinDivert64

msbuild dll\windivert.vcxproj ^
    /p:Configuration=Release ^
    /p:platform=Win32 ^
    /p:OutDir=..\install\MSVC\i386\
move dll\WinDivert.lib install\MSVC\i386\.

msbuild dll\windivert.vcxproj ^
    /p:Configuration=Release ^
    /p:platform=x64 ^
    /p:OutDir=..\install\MSVC\amd64\
move dll\WinDivert.lib install\MSVC\amd64\.

msbuild examples\flowtrack\flowtrack.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=Win32 ^
    /p:OutDir=..\..\install\MSVC\i386\

msbuild examples\flowtrack\flowtrack.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=x64 ^
    /p:OutDir=..\..\install\MSVC\amd64\

msbuild examples\netdump\netdump.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=Win32 ^
    /p:OutDir=..\..\install\MSVC\i386\

msbuild examples\netdump\netdump.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=x64 ^
    /p:OutDir=..\..\install\MSVC\amd64\

msbuild examples\netfilter\netfilter.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=Win32 ^
    /p:OutDir=..\..\install\MSVC\i386\

msbuild examples\netfilter\netfilter.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=x64 ^
    /p:OutDir=..\..\install\MSVC\amd64\

msbuild examples\passthru\passthru.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=Win32 ^
    /p:OutDir=..\..\install\MSVC\i386\

msbuild examples\passthru\passthru.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=x64 ^
    /p:OutDir=..\..\install\MSVC\amd64\

msbuild examples\socketdump\socketdump.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=Win32 ^
    /p:OutDir=..\..\install\MSVC\i386\

msbuild examples\socketdump\socketdump.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=x64 ^
    /p:OutDir=..\..\install\MSVC\amd64\

msbuild examples\streamdump\streamdump.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=Win32 ^
    /p:OutDir=..\..\install\MSVC\i386\

msbuild examples\streamdump\streamdump.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=x64 ^
    /p:OutDir=..\..\install\MSVC\amd64\

msbuild examples\webfilter\webfilter.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=Win32 ^
    /p:OutDir=..\..\install\MSVC\i386\

msbuild examples\webfilter\webfilter.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=x64 ^
    /p:OutDir=..\..\install\MSVC\amd64\

msbuild examples\windivertctl\windivertctl.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=Win32 ^
    /p:OutDir=..\..\install\MSVC\i386\

msbuild examples\windivertctl\windivertctl.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=x64 ^
    /p:OutDir=..\..\install\MSVC\amd64\

msbuild test\test.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=Win32 ^
    /p:OutDir=..\install\MSVC\i386\

msbuild test\test.vcxproj ^
    /p:Configuration=Release ^
    /p:Platform=x64 ^
    /p:OutDir=..\install\MSVC\amd64\


```

`release-build.sh`:

```sh
#!/bin/bash
#
# release-build.sh
# (C) 2019, all rights reserved,
#
# This file is part of WinDivert.
#
# WinDivert is free software: you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
# License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# WinDivert is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# Script for building WinDivert binary packages.  This script assumes the
# binaries are already built and are in the install/ subdirectory.

set -e

LABEL=
if [ $# -ge 1 ]
then
    LABEL="-$1"
fi

TARGET=MINGW

WINDIVERT32_SYS=install/$TARGET/i386/WinDivert32.sys
if [ $# -ge 2 ]
then
    WINDIVERT32_SYS=$2
fi

WINDIVERT64_SYS=install/$TARGET/amd64/WinDivert64.sys
if [ $# -ge 3 ]
then
    WINDIVERT64_SYS=$3
fi

VERSION=`cat ./VERSION`
NAME=WinDivert-$VERSION

echo "BUILD $NAME$LABEL"
INSTALL=install/$NAME$LABEL
echo "\tmake $INSTALL..."
rm -rf $INSTALL
mkdir -p $INSTALL
echo "\tcopy $INSTALL/README..."
cp README $INSTALL
echo "\tcopy $INSTALL/CHANGELOG..."
cp CHANGELOG $INSTALL
echo "\tcopy $INSTALL/LICENSE..."
cp LICENSE $INSTALL
echo "\tcopy $INSTALL/VERSION..."
cp VERSION $INSTALL
echo "\tmake $INSTALL/include..."
mkdir -p $INSTALL/include
echo "\tcopy $INSTALL/include/windivert.h..."
cp include/windivert.h $INSTALL/include
echo "\tmake $INSTALL/doc..."
mkdir -p $INSTALL/doc
echo "\tcopy $INSTALL/doc/WinDivert.html..."
cp doc/windivert.html $INSTALL/doc/WinDivert.html
echo "\tmake $INSTALL/x86..."
mkdir -p $INSTALL/x86
echo "\tcopy $INSTALL/x86/WinDivert32.sys..."
cp "$WINDIVERT32_SYS" $INSTALL/x86
if ! grep "DigiCert High Assurance EV Root" $INSTALL/x86/WinDivert32.sys \
    2>&1 >/dev/null
then
    echo "\t\033[33mWARNING\033[0m: unsigned WinDivert32.sys..."
fi
if [ -e "$WINDIVERT64_SYS" ]
then
    echo "\tcopy $INSTALL/x64/WinDivert64.sys..."
    cp "$WINDIVERT64_SYS" $INSTALL/x86
fi
echo "\tcopy $INSTALL/x86/WinDivert.lib..."
cp install/$TARGET/i386/WinDivert.lib $INSTALL/x86
echo "\tcopy $INSTALL/x86/WinDivert.dll..."
cp install/$TARGET/i386/WinDivert.dll $INSTALL/x86
echo "\tcopy $INSTALL/x86/netdump.exe..."
cp install/$TARGET/i386/netdump.exe $INSTALL/x86
echo "\tcopy $INSTALL/x86/netfilter.exe..."
cp install/$TARGET/i386/netfilter.exe $INSTALL/x86
echo "\tcopy $INSTALL/x86/passtru.exe..."
cp install/$TARGET/i386/passthru.exe $INSTALL/x86
echo "\tcopy $INSTALL/x86/webfilter.exe..."
cp install/$TARGET/i386/webfilter.exe $INSTALL/x86
echo "\tcopy $INSTALL/x86/streamdump.exe..."
cp install/$TARGET/i386/streamdump.exe $INSTALL/x86
echo "\tcopy $INSTALL/x86/flowtrack.exe..."
cp install/$TARGET/i386/flowtrack.exe $INSTALL/x86
echo "\tcopy $INSTALL/x86/socketdump.exe..."
cp install/$TARGET/i386/socketdump.exe $INSTALL/x86
echo "\tcopy $INSTALL/x86/windivertctl.exe..."
cp install/$TARGET/i386/windivertctl.exe $INSTALL/x86
echo "\tcopy $INSTALL/x86/test.exe..."
cp install/$TARGET/i386/test.exe $INSTALL/x86
if [ -d "install/$TARGET/amd64" ]
then
    echo "\tmake $INSTALL/amd64..."
    mkdir -p $INSTALL/x64
    echo "\tcopy $INSTALL/amd64/WinDivert64.sys..."
    cp "$WINDIVERT64_SYS" $INSTALL/x64
    if ! grep "DigiCert High Assurance EV Root" \
        $INSTALL/x64/WinDivert64.sys 2>&1 >/dev/null
    then
        echo "\t\033[33mWARNING\033[0m: unsigned WinDivert64.sys..."
    fi
    echo "\tcopy $INSTALL/x64/WinDivert.lib..."
    cp install/$TARGET/amd64/WinDivert.lib $INSTALL/x64
    echo "\tcopy $INSTALL/x64/WinDivert.dll..."
    cp install/$TARGET/amd64/WinDivert.dll $INSTALL/x64
    echo "\tcopy $INSTALL/x64/netdump.exe..."
    cp install/$TARGET/amd64/netdump.exe $INSTALL/x64
    echo "\tcopy $INSTALL/x64/netfilter.exe..."
    cp install/$TARGET/amd64/netfilter.exe $INSTALL/x64
    echo "\tcopy $INSTALL/x64/passtru.exe..."
    cp install/$TARGET/amd64/passthru.exe $INSTALL/x64
    echo "\tcopy $INSTALL/x64/webfilter.exe..."
    cp install/$TARGET/amd64/webfilter.exe $INSTALL/x64
    echo "\tcopy $INSTALL/x64/streamdump.exe..."
    cp install/$TARGET/amd64/streamdump.exe $INSTALL/x64
    echo "\tcopy $INSTALL/x64/flowtrack.exe..."
    cp install/$TARGET/amd64/flowtrack.exe $INSTALL/x64
    echo "\tcopy $INSTALL/x64/socketdump.exe..."
    cp install/$TARGET/amd64/socketdump.exe $INSTALL/x64
    echo "\tcopy $INSTALL/x64/windivertctl.exe..."
    cp install/$TARGET/amd64/windivertctl.exe $INSTALL/x64
    echo "\tcopy $INSTALL/x64/test.exe..."
    cp install/$TARGET/amd64/test.exe $INSTALL/x64
else
    echo "\tWARNING: skipping missing AMD64 build..."
fi
PACKAGE=$NAME$LABEL.zip
echo "\tbuilding $PACKAGE..."
(
    cd install;
    zip -r $PACKAGE $NAME$LABEL > /dev/null
)
echo -n "\tclean $INSTALL..."
rm -rf $INSTALL
echo "DONE"


```

`sys/Makefile`:

```
!INCLUDE $(NTMAKEENV)\makefile.def

```

`sys/Makefile.inc`:

```inc
!IF "$(_BUILDARCH)" == "x86"
CPU=i386
!ELSE
CPU=$(_BUILDARCH)
!ENDIF

$(TARGETPATH)\$(CPU)\WinDivert.inf: windivert.inf
	copy /y windivert.inf $@
$(TARGETPATH)\$(CPU)\WdfCoInstaller01009.dll:
	copy /y $(BASEDIR)\redist\wdf\$(_BUILDARCH)\WdfCoInstaller01009.dll $@

```

`sys/sources`:

```

!IF "$(_BUILDARCH)" == "x86"
CPU=i386
BITS=32
!ELSE
CPU=$(_BUILDARCH)
BITS=64
!ENDIF

TARGETNAME=WinDivert$(BITS)
TARGETTYPE=DRIVER
TARGETPATH=..\install\WDDK
TARGETLIBS=\
    $(DDK_LIB_PATH)\wdmsec.lib \
    $(DDK_LIB_PATH)\ndis.lib \
    $(DDK_LIB_PATH)\fwpkclnt.lib \
    $(SDK_LIB_PATH)\uuid.lib
NTTARGETFILES=
KMDF_VERSION_MAJOR=1
C_DEFINES=$(C_DEFINES) -DBINARY_COMPATIBLE=0 -DNT -DUNICODE -D_UNICODE \
    -DNDIS60 -DNDIS_SUPPORT_NDIS60
INCLUDES=$(DDK_INC_PATH);..\include;..\dll
SOURCES=windivert.rc windivert.c


```

`sys/windivert.c`:

```c
/*
 * windivert.c
 * (C) 2022, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#include <ntifs.h>
#include <ntddk.h>
#include <fwpsk.h>
#include <fwpmk.h>
#include <wdf.h>
#include <stdarg.h>
#include <ntstrsafe.h>
#define INITGUID
#include <guiddef.h>

#include "windivert_device.h"
#include "windivert_log.h"

/*
 * WDK function declaration cruft.
 */
DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_UNLOAD windivert_unload;
EVT_WDF_IO_IN_CALLER_CONTEXT windivert_caller_context;
EVT_WDF_IO_QUEUE_IO_DEVICE_CONTROL windivert_ioctl;
EVT_WDF_DEVICE_FILE_CREATE windivert_create;
EVT_WDF_FILE_CLEANUP windivert_cleanup;
EVT_WDF_FILE_CLOSE windivert_close;
EVT_WDF_OBJECT_CONTEXT_DESTROY windivert_destroy;
EVT_WDF_WORKITEM windivert_worker;
EVT_WDF_WORKITEM windivert_reflect_worker;

/*
 * Debugging macros.
 */
// #define DEBUG_ON
#ifdef DEBUG_ON
#define DEBUG(format, ...)                                                  \
    DbgPrint("WINDIVERT: " format "\n", ##__VA_ARGS__)
#define DEBUG_ERROR(format, status, ...)                                    \
    DbgPrint("WINDIVERT: *** ERROR ***: (status = 0x%x): " format "\n",     \
        (status), ##__VA_ARGS__)
static void DEBUG_BOUNDS_CHECK(PVOID start, PVOID end, PVOID access_start,
    PVOID access_end)
{
    if (access_end > end || access_start < start)
    {
        DbgPrint("WINDIVERT: *** BOUNDS ERROR ***: access %p..%p outside "
            "of buffer bounds %p..%p", access_start, access_end, start, end);
    }
}
#else       // DEBUG_ON
#define DEBUG(format, ...)
#define DEBUG_ERROR(format, status, ...)
#define DEBUG_BOUNDS_CHECK(start, end, access_start, access_end)
#endif

#define WINDIVERT_VERSION_MAJOR_MIN             2
#define WINDIVERT_TAG                           'viDW'

/*
 * WinDivert reflect event.
 */
typedef struct context_s *context_t;
struct reflect_event_s
{
    LIST_ENTRY entry;                           // Entry.
    context_t context;                          // Context.
    WINDIVERT_EVENT event;                      // Event.
};
typedef struct reflect_event_s *reflect_event_t;

/*
 * WinDivert reflect context information.
 */
struct reflect_context_s
{
    LIST_ENTRY entry;                           // Open handle entry.
    LONGLONG timestamp;                         // Open timestamp.
    WINDIVERT_DATA_REFLECT data;                // Reflect data.
    struct reflect_event_s open_event;          // Open event.
    struct reflect_event_s close_event;         // Close event
    BOOL open;                                  // Seen open event?
};

/*
 * WinDivert context information.
 */
#define WINDIVERT_CONTEXT_SIZE                  (sizeof(struct context_s))
#define WINDIVERT_CONTEXT_MAXLAYERS             12
typedef enum
{
    WINDIVERT_CONTEXT_STATE_OPENING = 0xA0,     // Context is opening.
    WINDIVERT_CONTEXT_STATE_OPEN    = 0xB1,     // Context is open.
    WINDIVERT_CONTEXT_STATE_CLOSING = 0xC2,     // Context is closing.
    WINDIVERT_CONTEXT_STATE_CLOSED  = 0xD3,     // Context is closed.
} context_state_t;
struct context_s
{
    context_state_t state;                      // Context's state.
    KSPIN_LOCK lock;                            // Context-wide lock.
    WDFDEVICE device;                           // Context's device.
    WDFFILEOBJECT object;                       // Context's parent object.
    PEPROCESS process;                          // Context's process.
    LIST_ENTRY flow_set;                        // All active flows.
    UINT32 flow_v4_callout_id;                  // Flow established callout id.
    UINT32 flow_v6_callout_id;                  // Flow established callout id.
    LIST_ENTRY work_queue;                      // Work queue.
    LIST_ENTRY packet_queue;                    // Packet queue.
    ULONGLONG work_queue_length;                // Work queue length.
    ULONGLONG packet_queue_length;              // Packet queue length.
    ULONGLONG packet_queue_maxlength;           // Packet queue max length.
    ULONGLONG packet_queue_size;                // Packet queue size (in bytes).
    ULONGLONG packet_queue_maxsize;             // Packet queue max size.
    LONGLONG packet_queue_maxcounts;            // Packet queue max counts.
    ULONGLONG packet_queue_maxtime;             // Packet queue max time.
    WDFQUEUE read_queue;                        // Read queue.
    WDFWORKITEM worker;                         // Read worker.
    WINDIVERT_LAYER layer;                      // Context's layer.
    UINT64 flags;                               // Context's flags.
    BOOL initialized;                           // Context initialized?
    BOOL shutdown_recv;                         // Shutdown recv.
    BOOL shutdown_send;                         // Shutdown send.
    BOOL shutdown_recv_enabled;                 // Shutdown recv enabled?
    UINT32 priority;                            // Context (internal) priority.
    INT16 priority16;                           // Context (user) priority.
    GUID callout_guid[WINDIVERT_CONTEXT_MAXLAYERS];
                                                // Callout GUIDs.
    GUID filter_guid[WINDIVERT_CONTEXT_MAXLAYERS];
                                                // Filter GUIDs.
    BOOL installed[WINDIVERT_CONTEXT_MAXLAYERS];// What is installed?
    HANDLE engine_handle;                       // WFP engine handle.
    const WINDIVERT_FILTER *filter;             // Packet filter.
    UINT16 filter_len;                          // Length of filter.
    UINT64 filter_flags;                        // Filter flags.
    struct reflect_context_s reflect;           // Reflection info.
};
typedef struct context_s context_s;
WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(context_s, windivert_context_get);

#define WINDIVERT_TIMEOUT(context, t0, t1)                                  \
     (((t1) >= (t0)? (t1) - (t0): (t0) - (t1)) >                            \
        (context)->packet_queue_maxcounts)

/*
 * WinDivert Layer information.
 */
typedef void (*windivert_classify_t)(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
typedef void (*windivert_flow_delete_notify_t)(
    IN UINT16 layer_id, IN UINT32 callout_id, IN UINT64 flow_context);
struct layer_s
{
    wchar_t *sublayer_name;                 // Sub-layer name.
    wchar_t *sublayer_desc;                 // Sub-layer description.
    wchar_t *callout_name;                  // Call-out name.
    wchar_t *callout_desc;                  // Call-out description.
    wchar_t *filter_name;                   // Filter name.
    wchar_t *filter_desc;                   // Filter description.
    const GUID *layer_guid;                 // WFP layer GUID.
    const GUID *sublayer_guid;              // Sub-layer GUID.
    windivert_classify_t classify;          // Classify function.
    windivert_flow_delete_notify_t flow_delete;
                                            // Flow delete function.
    UINT16 sublayer_weight;                 // Sub-layer weight.
};
typedef const struct layer_s *layer_t;

/*
 * WinDivert request context.
 */
struct req_context_s
{
    PWINDIVERT_ADDRESS addr;                // Pointer to address structure.
    UINT *addr_len_ptr;                     // Pointer to address length.
    UINT addr_len;                          // Address length (in bytes).
};
typedef struct req_context_s req_context_s;
typedef struct req_context_s *req_context_t;
WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(req_context_s, windivert_req_context_get);

/*
 * WinDivert packet structure.  Layout is as follows:
 *
 *     +-----------------+------------+-------------+
 *     | struct packet_s | layer data | packet data |
 *     +-----------------+------------+-------------+
 *
 * Note the packet data must be pointer-aligned.
 */
#define WINDIVERT_WORK_QUEUE_LENGTH_MAX     4096
#ifdef _WIN64
#define WINDIVERT_ALIGN_SIZE                8
#define WINDIVERT_DATA_ALIGN                __declspec(align(8))
#else
#define WINDIVERT_ALIGN_SIZE                4
#define WINDIVERT_DATA_ALIGN                __declspec(align(4))
#endif
struct packet_s
{
    LIST_ENTRY entry;                       // Entry for queue.
    LONGLONG timestamp;                     // Packet timestamp.
    UINT32 layer:8;                         // Layer.
    UINT32 event:8;                         // Event.
    UINT32 sniffed:1;                       // Packet was sniffed?
    UINT32 outbound:1;                      // Packet is outound?
    UINT32 loopback:1;                      // Packet is loopback?
    UINT32 impostor:1;                      // Packet is impostor?
    UINT32 ipv6:1;                          // Packet is IPv6?
    UINT32 ip_checksum:1;                   // Packet has IPv4 checksum?
    UINT32 tcp_checksum:1;                  // Packet has TCP checksum?
    UINT32 udp_checksum:1;                  // Packet has UDP checksum?
    UINT32 icmp_checksum:1;                 // Packet has ICMP(V6) checksum?
    UINT32 match:1;                         // Packet matches filter?
    UINT32 padding:6;                       // Padding for alignment.
    UINT32 packet_size;                     // Packet total size.
    PVOID object;                           // Object associated with packet.
    UINT32 priority;                        // Packet priority.
    UINT32 packet_len;                      // Length of the packet.
    WINDIVERT_DATA_ALIGN UINT8 data[1];     // Packet/layer data.
};
typedef struct packet_s *packet_t;

#define WINDIVERT_DATA_SIZE(size)                                           \
    ((((size) + WINDIVERT_ALIGN_SIZE - 1) / WINDIVERT_ALIGN_SIZE) *         \
        WINDIVERT_ALIGN_SIZE)
#define WINDIVERT_PACKET_SIZE(layer_type, packet_len)                       \
    (sizeof(struct packet_s)-1 + WINDIVERT_DATA_SIZE(sizeof(layer_type)) +  \
        (packet_len))
#define WINDIVERT_LAYER_DATA_PTR(packet)                                    \
    ((packet)->data)
#define WINDIVERT_PACKET_DATA_PTR(layer_type, packet)                       \
    ((packet)->data + WINDIVERT_DATA_SIZE(sizeof(layer_type)))

/*
 * WinDivert flow structure.
 */
struct flow_s
{
    LIST_ENTRY entry;                       // Entry for tracking.
    context_t context;                      // Context.
    UINT64 flow_id;                         // WFP flow ID.
    UINT32 callout_id;                      // WFP callout ID.
    UINT16 layer_id;                        // WFP layout ID.
    BOOL inserted:1;                        // Flow inserted into context?
    BOOL deleted:1;                         // Flow deleted from context?
    BOOL outbound:1;                        // Flow is outound?
    BOOL loopback:1;                        // Flow is loopback?
    BOOL ipv6:1;                            // Flow is ipv6?
    WINDIVERT_DATA_FLOW data;               // Flow data.
};
typedef struct flow_s *flow_t;

/*
 * Misc.
 */
#define UINT8_MAX       0xFF
#define UINT16_MAX      0xFFFF
#define UINT32_MAX      0xFFFFFFFF
#define IPPROTO_MH      135

/*
 * Global state.
 */
static HANDLE inject_handle_forward = NULL;
static HANDLE injectv6_handle_forward = NULL;
static HANDLE inject_handle_in = NULL;
static HANDLE inject_handle_out = NULL;
static HANDLE injectv6_handle_in = NULL;
static HANDLE injectv6_handle_out = NULL;
static NDIS_HANDLE nbl_pool_handle = NULL;
static NDIS_HANDLE nb_pool_handle = NULL;
static HANDLE engine_handle = NULL;
static LONG priority_counter = 0;
static LONGLONG counts_per_ms = 0;
static POOL_TYPE non_paged_pool = NonPagedPool;
static MM_PAGE_PRIORITY no_write_flag = 0;
static MM_PAGE_PRIORITY no_exec_flag  = 0;
static LONG64 num_opens = 0;

/*
 * Priorities.
 */
static UINT32 windivert_context_priority(UINT32 priority)
{
    UINT32 increment;
    priority = (priority << 16);
    increment = (UINT32)InterlockedIncrement(&priority_counter);
    priority |= (increment & 0x0000FFFF);
    return priority;
}

/*
 * Prototypes.
 */
static void windivert_driver_unload(void);
extern VOID windivert_ioctl(IN WDFQUEUE queue, IN WDFREQUEST request,
    IN size_t in_length, IN size_t out_len, IN ULONG code);
static NTSTATUS windivert_read(context_t context, WDFREQUEST request);
extern VOID windivert_worker(IN WDFWORKITEM item);
static void windivert_read_service(context_t context);
extern VOID windivert_create(IN WDFDEVICE device, IN WDFREQUEST request,
    IN WDFFILEOBJECT object);
static NTSTATUS windivert_install_provider(void);
static NTSTATUS windivert_install_sublayer(layer_t layer);
static NTSTATUS windivert_install_callouts(context_t context, UINT8 layer,
    UINT64 flags);
static NTSTATUS windivert_install_callout(context_t context, UINT idx,
    layer_t layer, UINT32 *callout_id_ptr);
static void windivert_uninstall_callouts(context_t context,
    context_state_t state);
extern VOID windivert_cleanup(IN WDFFILEOBJECT object);
extern VOID windivert_close(IN WDFFILEOBJECT object);
extern VOID windivert_destroy(IN WDFOBJECT object);
static NTSTATUS windivert_write(context_t context, WDFREQUEST request,
    req_context_t req_context);
static void NTAPI windivert_inject_complete(VOID *context,
    NET_BUFFER_LIST *packets, BOOLEAN dispatch_level);
static void windivert_inject_packet_too_big(packet_t packet);
static NTSTATUS windivert_notify(IN FWPS_CALLOUT_NOTIFY_TYPE type,
    IN const GUID *filter_key, IN const FWPS_FILTER0 *filter);
static void windivert_outbound_network_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_inbound_network_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_outbound_network_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_inbound_network_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_forward_network_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_forward_network_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_flow_established_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_flow_established_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_resource_assignment_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_resource_assignment_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_resource_release_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_resource_release_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_auth_connect_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_auth_connect_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_endpoint_closure_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_endpoint_closure_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_auth_listen_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_auth_listen_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_auth_recv_accept_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_auth_recv_accept_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_flow_established_classify(context_t context, 
    IN UINT64 flow_id, IN PWINDIVERT_DATA_FLOW flow_data, IN BOOL ipv4,
    IN BOOL outbound, IN BOOL loopback, OUT FWPS_CLASSIFY_OUT0 *result);
static void windivert_flow_delete_notify(UINT16 layer_id, UINT32 callout_id,
    UINT64 flow_context);
static void windivert_socket_classify(context_t context,
    PWINDIVERT_DATA_SOCKET socket_data, WINDIVERT_EVENT event, BOOL ipv4,
    BOOL outbound, BOOL loopback, FWPS_CLASSIFY_OUT0 *result);
static void windivert_network_classify(context_t context,
    IN PWINDIVERT_DATA_NETWORK network_data, IN BOOL ipv4, IN BOOL outbound,
    IN BOOL loopback, IN BOOL reassembled, IN UINT advance, IN OUT void *data,
    OUT FWPS_CLASSIFY_OUT0 *result);
static BOOL windivert_queue_work(context_t context, PVOID packet,
    ULONG packet_len, PNET_BUFFER_LIST buffers, PVOID object,
    WINDIVERT_LAYER layer, PVOID layer_data, WINDIVERT_EVENT event,
    UINT64 flags, UINT32 priority, BOOL ipv4, BOOL outbound, BOOL loopback,
    BOOL impostor, BOOL match, LONGLONG timestamp);
static void windivert_queue_packet(context_t context, packet_t packet);
static NTSTATUS windivert_inject_packet(packet_t packet);
static void windivert_free_packet(packet_t packet);
static BOOL windivert_copy_data(PNET_BUFFER buffer, PVOID data, UINT size);
static BOOL windivert_get_data(PNET_BUFFER buffer, UINT length, INT min,
    INT max, INT idx, PVOID data, UINT size);
static BOOL windivert_parse_headers(PNET_BUFFER buffer, BOOL ipv4,
    BOOL *fragment_ptr, PWINDIVERT_IPHDR *ip_header_ptr,
    PWINDIVERT_IPV6HDR *ipv6_header_ptr, PWINDIVERT_ICMPHDR *icmp_header_ptr,
    PWINDIVERT_ICMPV6HDR *icmpv6_header_ptr, PWINDIVERT_TCPHDR *tcp_header_ptr,
    PWINDIVERT_UDPHDR *udp_header_ptr, UINT8 *proto_ptr, UINT *header_len_ptr,
    UINT *payload_len_ptr);
static BOOL windivert_filter(PNET_BUFFER buffer, WINDIVERT_LAYER layer,
    const VOID *layer_data, LONGLONG timestamp, WINDIVERT_EVENT event,
    BOOL ipv4, BOOL outbound, BOOL loopback, BOOL impostor, BOOL frag_mode,
    const WINDIVERT_FILTER *filter);
static const WINDIVERT_FILTER *windivert_filter_compile(
    const WINDIVERT_FILTER *ioctl_filter, size_t ioctl_filter_len,
    WINDIVERT_LAYER layer);
static NTSTATUS windivert_reflect_init(WDFOBJECT parent);
static void windivert_reflect_close(void);
static void windivert_reflect_open_event(context_t context);
static void windivert_reflect_close_event(context_t context);
static void windivert_reflect_event_notify(context_t context,
    LONGLONG timestamp, WINDIVERT_EVENT event);
static void windivert_reflect_established_notify(context_t context,
    LONGLONG timestamp);
extern void windivert_reflect_worker(IN WDFWORKITEM item);
static void windivert_log_event(PEPROCESS process, PDRIVER_OBJECT driver,
    const wchar_t *msg_str);

/*
 * WinDivert provider GUIDs
 */
DEFINE_GUID(WINDIVERT_PROVIDER_GUID,
    0x450EC398, 0x1EAF, 0x49F5,
    0x85, 0xE0, 0x22, 0x8F, 0x0D, 0x29, 0x39, 0x21);
#define WINDIVERT_PROVIDER_NAME WINDIVERT_DEVICE_NAME
#define WINDIVERT_PROVIDER_DESC WINDIVERT_DEVICE_NAME L" provider"

/*
 * WinDivert sublayer GUIDs
 */
DEFINE_GUID(WINDIVERT_SUBLAYER_INBOUND_IPV4_GUID,
    0x82A99281, 0x0389, 0x4DE2,
    0xAE, 0x2D, 0xA4, 0x51, 0x59, 0x16, 0x26, 0x06);
DEFINE_GUID(WINDIVERT_SUBLAYER_OUTBOUND_IPV4_GUID,
    0xB0BB07C6, 0x3B3B, 0x41FE,
    0x83, 0x8B, 0xD8, 0x37, 0xDD, 0xB8, 0x75, 0x41);
DEFINE_GUID(WINDIVERT_SUBLAYER_INBOUND_IPV6_GUID,
    0xD7674846, 0x3AB5, 0x4E93,
    0x82, 0xD0, 0x2F, 0xCC, 0x03, 0xA2, 0x88, 0x7A);
DEFINE_GUID(WINDIVERT_SUBLAYER_OUTBOUND_IPV6_GUID,
    0x6672F761, 0xA0F2, 0x4578,
    0x92, 0x50, 0x09, 0x03, 0x0D, 0x4E, 0x8C, 0x46);
DEFINE_GUID(WINDIVERT_SUBLAYER_FORWARD_IPV4_GUID,
    0x4622DCC6, 0xBD71, 0x48ED,
    0x9D, 0x1A, 0x72, 0xC9, 0x0D, 0xEB, 0xA1, 0x74);
DEFINE_GUID(WINDIVERT_SUBLAYER_FORWARD_IPV6_GUID,
    0x7E5B39EC, 0xB54C, 0x41B3,
    0xA7, 0x99, 0x47, 0x5E, 0x57, 0x41, 0xA4, 0x33);
DEFINE_GUID(WINDIVERT_SUBLAYER_FLOW_ESTABLISHED_IPV4_GUID,
    0x53D6C270, 0xEB79, 0x44CD,
    0x83, 0xCD, 0x14, 0x34, 0xE6, 0x13, 0x91, 0x68);
DEFINE_GUID(WINDIVERT_SUBLAYER_FLOW_ESTABLISHED_IPV6_GUID,
    0x44B0CDED, 0xAA11, 0x4704,
    0x92, 0xA7, 0x99, 0xD2, 0xB7, 0x59, 0x7A, 0x68);
DEFINE_GUID(WINDIVERT_SUBLAYER_RESOURCE_ASSIGNMENT_IPV4_GUID,
    0x736848B6, 0xBE0D, 0x4A8D,
    0xA0, 0xC2, 0xE2, 0x02, 0xDC, 0x29, 0x32, 0xBC);
DEFINE_GUID(WINDIVERT_SUBLAYER_RESOURCE_ASSIGNMENT_IPV6_GUID,
    0xF3458E58, 0xD123, 0x439B,
    0xB6, 0x40, 0x74, 0x3C, 0xC7, 0x53, 0x9E, 0x36);
DEFINE_GUID(WINDIVERT_SUBLAYER_RESOURCE_RELEASE_IPV4_GUID,
    0x02366282, 0x9099, 0x43A7,
    0x95, 0xC3, 0xAB, 0x52, 0x87, 0xB3, 0xF2, 0xDC);
DEFINE_GUID(WINDIVERT_SUBLAYER_RESOURCE_RELEASE_IPV6_GUID,
    0x60FCA14A, 0x7677, 0x45D2,
    0xBB, 0x5C, 0x15, 0xDB, 0xAE, 0x4B, 0x7B, 0x6B);
DEFINE_GUID(WINDIVERT_SUBLAYER_AUTH_CONNECT_IPV4_GUID,
    0x2F97411F, 0x6350, 0x450A,
    0xBF, 0x45, 0x4C, 0x0B, 0xC1, 0xDB, 0x3F, 0x7E);
DEFINE_GUID(WINDIVERT_SUBLAYER_AUTH_CONNECT_IPV6_GUID,
    0x7BAFEEEB, 0x84F0, 0x4BB0,
    0x91, 0x1F, 0x7E, 0x62, 0x2D, 0x73, 0x24, 0x2C);
DEFINE_GUID(WINDIVERT_SUBLAYER_ENDPOINT_CLOSURE_IPV4_GUID,
    0x8180D216, 0xB3BD, 0x4014,
    0x99, 0x69, 0xA3, 0xDF, 0x0F, 0x3E, 0x61, 0x85);
DEFINE_GUID(WINDIVERT_SUBLAYER_ENDPOINT_CLOSURE_IPV6_GUID,
    0x2535A264, 0xEC8B, 0x49CC,
    0xA4, 0xD6, 0x83, 0x81, 0xD7, 0x5F, 0xAB, 0xE6);
DEFINE_GUID(WINDIVERT_SUBLAYER_AUTH_LISTEN_IPV4_GUID,
    0x49F2A9AD, 0x805E, 0x4328,
    0xBB, 0xDA, 0x92, 0x57, 0xB5, 0x18, 0x3A, 0x40);
DEFINE_GUID(WINDIVERT_SUBLAYER_AUTH_LISTEN_IPV6_GUID,
    0xC1BB250E, 0xDE07, 0x41AB,
    0x82, 0xEE, 0xAD, 0x7B, 0xFF, 0x13, 0xCE, 0x35);
DEFINE_GUID(WINDIVERT_SUBLAYER_AUTH_RECV_ACCEPT_IPV4_GUID,
    0x7A012579, 0xC75A, 0x4D29,
    0xB7, 0x47, 0x04, 0xAD, 0x3C, 0x7B, 0x32, 0x69);
DEFINE_GUID(WINDIVERT_SUBLAYER_AUTH_RECV_ACCEPT_IPV6_GUID,
    0x1C51DD53, 0x6BA4, 0x4149,
    0x89, 0x97, 0x1C, 0xD4, 0x8B, 0x51, 0x1B, 0x7D);

/*
 * WinDivert supported layers.
 */
static const struct layer_s windivert_layer_inbound_network_ipv4 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerInboundNetworkIPv4",
    L"" WINDIVERT_LAYER_NAME L" sublayer network (inbound IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutInboundNetworkIPv4",
    L"" WINDIVERT_LAYER_NAME L" callout network (inbound IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_FilterInboundNetworkIPv4",
    L"" WINDIVERT_LAYER_NAME L" filter network (inbound IPv4)",
    &FWPM_LAYER_INBOUND_IPPACKET_V4,
    &WINDIVERT_SUBLAYER_INBOUND_IPV4_GUID,
    windivert_inbound_network_v4_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_INBOUND_NETWORK_IPV4                                \
    (&windivert_layer_inbound_network_ipv4)

static const struct layer_s windivert_layer_outbound_network_ipv4 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerOutboundNetworkIPv4",
    L"" WINDIVERT_LAYER_NAME L" sublayer network (outbound IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutOutboundNetworkIPv4",
    L"" WINDIVERT_LAYER_NAME L" callout network (outbound IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_FilterOutboundNetworkIPv4",
    L"" WINDIVERT_LAYER_NAME L" filter network (outbound IPv4)",
    &FWPM_LAYER_OUTBOUND_IPPACKET_V4,
    &WINDIVERT_SUBLAYER_OUTBOUND_IPV4_GUID,
    windivert_outbound_network_v4_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_OUTBOUND_NETWORK_IPV4                               \
    (&windivert_layer_outbound_network_ipv4)

static const struct layer_s windivert_layer_inbound_network_ipv6 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerInboundNetworkIPv6",
    L"" WINDIVERT_LAYER_NAME L" sublayer network (inbound IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutInboundNetworkIPv6",
    L"" WINDIVERT_LAYER_NAME L" callout network (inbound IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_FilterInboundNetworkIPv6",
    L"" WINDIVERT_LAYER_NAME L" filter network (inbound IPv6)",
    &FWPM_LAYER_INBOUND_IPPACKET_V6,
    &WINDIVERT_SUBLAYER_INBOUND_IPV6_GUID,
    windivert_inbound_network_v6_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_INBOUND_NETWORK_IPV6                                \
    (&windivert_layer_inbound_network_ipv6)

static const struct layer_s windivert_layer_outbound_network_ipv6 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerOutboundNetworkIPv6",
    L"" WINDIVERT_LAYER_NAME L" sublayer network (outbound IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutOutboundNetworkIPv6",
    L"" WINDIVERT_LAYER_NAME L" callout network (outbound IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_FilterOutboundNetworkIPv6",
    L"" WINDIVERT_LAYER_NAME L" filter network (outbound IPv6)",
    &FWPM_LAYER_OUTBOUND_IPPACKET_V6,
    &WINDIVERT_SUBLAYER_OUTBOUND_IPV6_GUID,
    windivert_outbound_network_v6_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_OUTBOUND_NETWORK_IPV6                               \
    (&windivert_layer_outbound_network_ipv6)

static const struct layer_s windivert_layer_forward_network_ipv4 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerForwardNetworkIPv4",
    L"" WINDIVERT_LAYER_NAME L" sublayer network (forward IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutForwardNetworkIPv4",
    L"" WINDIVERT_LAYER_NAME L" callout network (forward IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_FilterForwardNetworkIPv4",
    L"" WINDIVERT_LAYER_NAME L" filter network (forward IPv4)",
    &FWPM_LAYER_IPFORWARD_V4,
    &WINDIVERT_SUBLAYER_FORWARD_IPV4_GUID,
    windivert_forward_network_v4_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_FORWARD_NETWORK_IPV4                                \
    (&windivert_layer_forward_network_ipv4)

static const struct layer_s windivert_layer_forward_network_ipv6 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerForwardNetworkIPv6",
    L"" WINDIVERT_LAYER_NAME L" sublayer network (forward IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutForwardNetworkIPv6",
    L"" WINDIVERT_LAYER_NAME L" callout network (forward IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_FilterForwardNetworkIPv6",
    L"" WINDIVERT_LAYER_NAME L" filter network (forward IPv6)",
    &FWPM_LAYER_IPFORWARD_V6,
    &WINDIVERT_SUBLAYER_FORWARD_IPV6_GUID,
    windivert_forward_network_v6_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_FORWARD_NETWORK_IPV6                                \
    (&windivert_layer_forward_network_ipv6)

static const struct layer_s windivert_layer_resource_assignment_ipv4 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerResourceAssignmentIPv4",
    L"" WINDIVERT_LAYER_NAME L" sublayer resource assignment (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutResourceAssignmentIPv4",
    L"" WINDIVERT_LAYER_NAME L" callout resource assignment (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_FilterResourceAssignmentIPv4",
    L"" WINDIVERT_LAYER_NAME L" filter resource assignment (IPv4)",
    &FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4,
    &WINDIVERT_SUBLAYER_RESOURCE_ASSIGNMENT_IPV4_GUID,
    windivert_resource_assignment_v4_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_RESOURCE_ASSIGNMENT_IPV4                            \
    (&windivert_layer_resource_assignment_ipv4)

static const struct layer_s windivert_layer_resource_assignment_ipv6 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerResourceAssignmentIPv6",
    L"" WINDIVERT_LAYER_NAME L" sublayer resource assignment (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutResourceAssignmentIPv6",
    L"" WINDIVERT_LAYER_NAME L" callout resource assignment (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_FilterResourceAssignmentIPv6",
    L"" WINDIVERT_LAYER_NAME L" filter resource assignment (IPv6)",
    &FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V6,
    &WINDIVERT_SUBLAYER_RESOURCE_ASSIGNMENT_IPV6_GUID,
    windivert_resource_assignment_v6_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_RESOURCE_ASSIGNMENT_IPV6                            \
    (&windivert_layer_resource_assignment_ipv6)

static const struct layer_s windivert_layer_resource_release_ipv4 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerResourceReleaseIPv4",
    L"" WINDIVERT_LAYER_NAME L" sublayer resource release (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutResourceReleaseIPv4",
    L"" WINDIVERT_LAYER_NAME L" callout resource release (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_FilterResourceReleaseIPv4",
    L"" WINDIVERT_LAYER_NAME L" filter resource release (IPv4)",
    &FWPM_LAYER_ALE_RESOURCE_RELEASE_V4,
    &WINDIVERT_SUBLAYER_RESOURCE_RELEASE_IPV4_GUID,
    windivert_resource_release_v4_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_RESOURCE_RELEASE_IPV4                              \
    (&windivert_layer_resource_release_ipv4)

static const struct layer_s windivert_layer_resource_release_ipv6 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerResourceReleaseIPv6",
    L"" WINDIVERT_LAYER_NAME L" sublayer resource release (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutResourceReleaseIPv6",
    L"" WINDIVERT_LAYER_NAME L" callout resource release (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_FilterResourceReleaseIPv6",
    L"" WINDIVERT_LAYER_NAME L" filter resource release (IPv6)",
    &FWPM_LAYER_ALE_RESOURCE_RELEASE_V6,
    &WINDIVERT_SUBLAYER_RESOURCE_RELEASE_IPV6_GUID,
    windivert_resource_release_v6_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_RESOURCE_RELEASE_IPV6                              \
    (&windivert_layer_resource_release_ipv6)

static const struct layer_s windivert_layer_auth_connect_ipv4 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerAuthConnectIPv4",
    L"" WINDIVERT_LAYER_NAME L" sublayer auth connect (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutAuthConnectIPv4",
    L"" WINDIVERT_LAYER_NAME L" callout auth connect (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_FilterAuthConnectIPv4",
    L"" WINDIVERT_LAYER_NAME L" filter auth connect (IPv4)",
    &FWPM_LAYER_ALE_AUTH_CONNECT_V4,
    &WINDIVERT_SUBLAYER_AUTH_CONNECT_IPV4_GUID,
    windivert_auth_connect_v4_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_AUTH_CONNECT_IPV4                                   \
    (&windivert_layer_auth_connect_ipv4)

static const struct layer_s windivert_layer_auth_connect_ipv6 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerAuthConnectIPv6",
    L"" WINDIVERT_LAYER_NAME L" sublayer auth connect (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutAuthConnectIPv6",
    L"" WINDIVERT_LAYER_NAME L" callout auth connect (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_FilterAuthConnectIPv6",
    L"" WINDIVERT_LAYER_NAME L" filter auth connect (IPv6)",
    &FWPM_LAYER_ALE_AUTH_CONNECT_V6,
    &WINDIVERT_SUBLAYER_AUTH_CONNECT_IPV6_GUID,
    windivert_auth_connect_v6_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_AUTH_CONNECT_IPV6                                   \
    (&windivert_layer_auth_connect_ipv6)

static const struct layer_s windivert_layer_endpoint_closure_ipv4 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerEndpointClosureIPv4",
    L"" WINDIVERT_LAYER_NAME L" sublayer endpoint closure (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutEndpointClosureIPv4",
    L"" WINDIVERT_LAYER_NAME L" callout endpoint closure (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_FilterEndpointClosureIPv4",
    L"" WINDIVERT_LAYER_NAME L" filter endpoint closure (IPv4)",
    &FWPM_LAYER_ALE_ENDPOINT_CLOSURE_V4,
    &WINDIVERT_SUBLAYER_ENDPOINT_CLOSURE_IPV4_GUID,
    windivert_endpoint_closure_v4_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_ENDPOINT_CLOSURE_IPV4                               \
    (&windivert_layer_endpoint_closure_ipv4)

static const struct layer_s windivert_layer_endpoint_closure_ipv6 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerEndpointClosureIPv6",
    L"" WINDIVERT_LAYER_NAME L" sublayer endpoint closure (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutEndpointClosureIPv6",
    L"" WINDIVERT_LAYER_NAME L" callout endpoint closure (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_FilterEndpointClosureIPv6",
    L"" WINDIVERT_LAYER_NAME L" filter endpoint closure (IPv6)",
    &FWPM_LAYER_ALE_ENDPOINT_CLOSURE_V6,
    &WINDIVERT_SUBLAYER_ENDPOINT_CLOSURE_IPV6_GUID,
    windivert_endpoint_closure_v6_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_ENDPOINT_CLOSURE_IPV6                               \
    (&windivert_layer_endpoint_closure_ipv6)

static const struct layer_s windivert_layer_auth_listen_ipv4 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerAuthListenIPv4",
    L"" WINDIVERT_LAYER_NAME L" sublayer auth listen (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutAuthListenIPv4",
    L"" WINDIVERT_LAYER_NAME L" callout auth listen (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_FilterAuthListenIPv4",
    L"" WINDIVERT_LAYER_NAME L" filter auth listen (IPv4)",
    &FWPM_LAYER_ALE_AUTH_LISTEN_V4,
    &WINDIVERT_SUBLAYER_AUTH_LISTEN_IPV4_GUID,
    windivert_auth_listen_v4_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_AUTH_LISTEN_IPV4                                    \
    (&windivert_layer_auth_listen_ipv4)

static const struct layer_s windivert_layer_auth_listen_ipv6 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerAuthListenIPv6",
    L"" WINDIVERT_LAYER_NAME L" sublayer auth listen (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutAuthListenIPv6",
    L"" WINDIVERT_LAYER_NAME L" callout auth listen (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_FilterAuthListenIPv6",
    L"" WINDIVERT_LAYER_NAME L" filter auth listen (IPv6)",
    &FWPM_LAYER_ALE_AUTH_LISTEN_V6,
    &WINDIVERT_SUBLAYER_AUTH_LISTEN_IPV6_GUID,
    windivert_auth_listen_v6_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_AUTH_LISTEN_IPV6                                    \
    (&windivert_layer_auth_listen_ipv6)

static const struct layer_s windivert_layer_auth_recv_accept_ipv4 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerAuthRecvAcceptIPv4",
    L"" WINDIVERT_LAYER_NAME L" sublayer auth recv accept (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutAuthRecvAcceptIPv4",
    L"" WINDIVERT_LAYER_NAME L" callout auth recv accept (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_FilterAuthRecvAcceptIPv4",
    L"" WINDIVERT_LAYER_NAME L" filter auth recv accept (IPv4)",
    &FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4,
    &WINDIVERT_SUBLAYER_AUTH_RECV_ACCEPT_IPV4_GUID,
    windivert_auth_recv_accept_v4_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_AUTH_RECV_ACCEPT_IPV4                               \
    (&windivert_layer_auth_recv_accept_ipv4)

static const struct layer_s windivert_layer_auth_recv_accept_ipv6 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerAuthRecvAcceptIPv6",
    L"" WINDIVERT_LAYER_NAME L" sublayer auth recv accept (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutAuthRecvAcceptIPv6",
    L"" WINDIVERT_LAYER_NAME L" callout auth recv accept (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_FilterAuthRecvAcceptIPv6",
    L"" WINDIVERT_LAYER_NAME L" filter auth recv accept (IPv6)",
    &FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6,
    &WINDIVERT_SUBLAYER_AUTH_RECV_ACCEPT_IPV6_GUID,
    windivert_auth_recv_accept_v6_classify,
    NULL,
    UINT16_MAX
};
#define WINDIVERT_LAYER_AUTH_RECV_ACCEPT_IPV6                               \
    (&windivert_layer_auth_recv_accept_ipv6)

static const struct layer_s windivert_layer_flow_established_ipv4 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerFlowEstablishedIPv4",
    L"" WINDIVERT_LAYER_NAME L" sublayer flow established (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutFlowEstablishedIPv4",
    L"" WINDIVERT_LAYER_NAME L" callout flow established (IPv4)",
    L"" WINDIVERT_LAYER_NAME L"_FilterFlowEstablishedIPv4",
    L"" WINDIVERT_LAYER_NAME L" filter flow established (IPv4)",
    &FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4,
    &WINDIVERT_SUBLAYER_FLOW_ESTABLISHED_IPV4_GUID,
    windivert_flow_established_v4_classify,
    windivert_flow_delete_notify,
    UINT16_MAX
};
#define WINDIVERT_LAYER_FLOW_ESTABLISHED_IPV4                               \
    (&windivert_layer_flow_established_ipv4)

static const struct layer_s windivert_layer_flow_established_ipv6 =
{
    L"" WINDIVERT_LAYER_NAME L"_SubLayerFlowEstablishedIPv6",
    L"" WINDIVERT_LAYER_NAME L" sublayer flow established (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_CalloutFlowEstablishedIPv6",
    L"" WINDIVERT_LAYER_NAME L" callout flow established (IPv6)",
    L"" WINDIVERT_LAYER_NAME L"_FilterFlowEstablishedIPv6",
    L"" WINDIVERT_LAYER_NAME L" filter flow established (IPv6)",
    &FWPM_LAYER_ALE_FLOW_ESTABLISHED_V6,
    &WINDIVERT_SUBLAYER_FLOW_ESTABLISHED_IPV6_GUID,
    windivert_flow_established_v6_classify,
    windivert_flow_delete_notify,
    UINT16_MAX
};
#define WINDIVERT_LAYER_FLOW_ESTABLISHED_IPV6                               \
    (&windivert_layer_flow_established_ipv6)

/*
 * Filter interpreter config.
 */
#define WINDIVERT_INLINE    __forceinline
#define WINDIVERT_GET_DATA(packet, packet_len, min, max, index, data, size) \
    windivert_get_data((PNET_BUFFER)(packet), (packet_len), (min), (max),   \
        (index), (data), (size))

/*
 * Shared functions.
 */
#include "windivert_shared.c"

/*
 * WinDivert malloc/free.
 */
static PVOID windivert_malloc(SIZE_T size, BOOL paged)
{
    POOL_TYPE pool = (paged? PagedPool: non_paged_pool);
    if (size == 0)
    {
        return NULL;
    }
    return ExAllocatePoolWithTag(pool, size, WINDIVERT_TAG);
}
static VOID windivert_free(PVOID ptr)
{
    if (ptr != NULL)
    {
        ExFreePoolWithTag(ptr, WINDIVERT_TAG);
    }
}

/*
 * WinDivert driver entry routine.
 */
extern NTSTATUS DriverEntry(IN PDRIVER_OBJECT driver_obj,
    IN PUNICODE_STRING reg_path)
{
    WDF_DRIVER_CONFIG config;
    WDFDRIVER driver;
    PWDFDEVICE_INIT device_init;
    WDFDEVICE device;
    WDF_FILEOBJECT_CONFIG file_config;
    WDF_IO_QUEUE_CONFIG queue_config;
    WDFQUEUE queue;
    WDF_OBJECT_ATTRIBUTES obj_attrs;
    NET_BUFFER_LIST_POOL_PARAMETERS nbl_pool_params;
    NET_BUFFER_POOL_PARAMETERS nb_pool_params;
    RTL_OSVERSIONINFOW version;
    LARGE_INTEGER freq;
    NTSTATUS status;
    DECLARE_CONST_UNICODE_STRING(device_name,
        L"\\Device\\" WINDIVERT_DEVICE_NAME);
    DECLARE_CONST_UNICODE_STRING(dos_device_name,
        L"\\??\\" WINDIVERT_DEVICE_NAME);

    DEBUG("LOAD: loading WinDivert driver");

    // Use the "no execute" pool if available:
    status = RtlGetVersion(&version);
    if (NT_SUCCESS(status))
    {
        if (version.dwMajorVersion > 6 ||
            (version.dwMajorVersion == 6 && version.dwMinorVersion >= 2))
        {
            non_paged_pool = (POOL_TYPE)512;    // NonPagedPoolNx (documented)
            no_exec_flag   = (MM_PAGE_PRIORITY)0x40000000;
                                                // MdlMappingNoExecute
            no_write_flag  = (MM_PAGE_PRIORITY)0x80000000;
                                                // MdlMappingNoWrite
        }
    }

    // Initialize timer info.
    KeQueryPerformanceCounter(&freq);
    counts_per_ms = freq.QuadPart / 1000;
    counts_per_ms = (counts_per_ms == 0? 1: counts_per_ms);

    // Configure ourself as a non-PnP driver:
    WDF_DRIVER_CONFIG_INIT(&config, WDF_NO_EVENT_CALLBACK);
    config.DriverInitFlags |= WdfDriverInitNonPnpDriver;
    config.EvtDriverUnload = windivert_unload;
    status = WdfDriverCreate(driver_obj, reg_path, WDF_NO_OBJECT_ATTRIBUTES,
        &config, &driver);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create WDF driver", status);
        goto driver_entry_exit;
    }
    device_init = WdfControlDeviceInitAllocate(driver,
        &SDDL_DEVOBJ_SYS_ALL_ADM_ALL);
    if (device_init == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        DEBUG_ERROR("failed to allocate WDF control device init structure",
            status);
        goto driver_entry_exit;
    }
    WdfDeviceInitSetDeviceType(device_init, FILE_DEVICE_NETWORK);
    WdfDeviceInitSetIoType(device_init, WdfDeviceIoDirect);
    status = WdfDeviceInitAssignName(device_init, &device_name);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create WDF device name", status);
        WdfDeviceInitFree(device_init);
        goto driver_entry_exit;
    }
    WDF_FILEOBJECT_CONFIG_INIT(&file_config, windivert_create, windivert_close,
        windivert_cleanup);
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&obj_attrs, context_s);
    obj_attrs.ExecutionLevel = WdfExecutionLevelPassive;
    obj_attrs.SynchronizationScope = WdfSynchronizationScopeNone;
    obj_attrs.EvtDestroyCallback = windivert_destroy;
    WdfDeviceInitSetFileObjectConfig(device_init, &file_config, &obj_attrs);
    WdfDeviceInitSetIoInCallerContextCallback(device_init,
        windivert_caller_context);
    WDF_OBJECT_ATTRIBUTES_INIT(&obj_attrs);
    status = WdfDeviceCreate(&device_init, &obj_attrs, &device);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create WDF control device", status);
        WdfDeviceInitFree(device_init);
        goto driver_entry_exit;
    }
    WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&queue_config,
        WdfIoQueueDispatchParallel);
    queue_config.EvtIoRead          = NULL;
    queue_config.EvtIoWrite         = NULL;
    queue_config.EvtIoDeviceControl = windivert_ioctl;
    WDF_OBJECT_ATTRIBUTES_INIT(&obj_attrs);
    obj_attrs.ExecutionLevel = WdfExecutionLevelPassive;
    obj_attrs.SynchronizationScope = WdfSynchronizationScopeNone;
    status = WdfIoQueueCreate(device, &queue_config, &obj_attrs, &queue);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create default WDF queue", status);
        goto driver_entry_exit;
    }
    status = WdfDeviceCreateSymbolicLink(device, &dos_device_name);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create device symbolic link", status);
        goto driver_entry_exit;
    }
    WdfControlFinishInitializing(device);

    // Create the packet injection handles.
    status = FwpsInjectionHandleCreate0(AF_INET,
        FWPS_INJECTION_TYPE_NETWORK | FWPS_INJECTION_TYPE_FORWARD,
        &inject_handle_forward);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create WFP forward packet injection handle",
            status);
        goto driver_entry_exit;
    }
    status = FwpsInjectionHandleCreate0(AF_INET6,
        FWPS_INJECTION_TYPE_NETWORK | FWPS_INJECTION_TYPE_FORWARD,
        &injectv6_handle_forward);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create WFP ipv6 forward packet injection handle",
            status);
        goto driver_entry_exit;
    }
    status = FwpsInjectionHandleCreate0(AF_INET,
        FWPS_INJECTION_TYPE_NETWORK | FWPS_INJECTION_TYPE_FORWARD,
        &inject_handle_in);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create WFP inbound packet injection handle",
            status);
        goto driver_entry_exit;
    }
    status = FwpsInjectionHandleCreate0(AF_INET,
        FWPS_INJECTION_TYPE_NETWORK | FWPS_INJECTION_TYPE_FORWARD,
        &inject_handle_out);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create WFP outbound packet injection handle",
            status);
        goto driver_entry_exit;
    }
    status = FwpsInjectionHandleCreate0(AF_INET6,
        FWPS_INJECTION_TYPE_NETWORK | FWPS_INJECTION_TYPE_FORWARD,
        &injectv6_handle_in);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create WFP ipv6 inbound packet injection handle",
            status);
        goto driver_entry_exit;
    }
    status = FwpsInjectionHandleCreate0(AF_INET6,
        FWPS_INJECTION_TYPE_NETWORK | FWPS_INJECTION_TYPE_FORWARD,
        &injectv6_handle_out);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create WFP ipv6 outbound packet injection handle",
            status);
        goto driver_entry_exit;
    }

    // Create a NET_BUFFER_LIST pool handle.
    RtlZeroMemory(&nbl_pool_params, sizeof(nbl_pool_params));
    nbl_pool_params.Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    nbl_pool_params.Header.Revision =
        NET_BUFFER_LIST_POOL_PARAMETERS_REVISION_1;
    nbl_pool_params.Header.Size = sizeof(nbl_pool_params);
    nbl_pool_params.fAllocateNetBuffer = TRUE;
    nbl_pool_params.PoolTag = WINDIVERT_TAG;
    nbl_pool_params.DataSize = 0;
    nbl_pool_handle = NdisAllocateNetBufferListPool(NULL, &nbl_pool_params);
    if (nbl_pool_handle == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        DEBUG_ERROR("failed to allocate net buffer list pool", status);
        goto driver_entry_exit;
    }

    // Create a NET_BUFFER pool handle.
    RtlZeroMemory(&nb_pool_params, sizeof(nb_pool_params));
    nb_pool_params.Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    nb_pool_params.Header.Revision = NET_BUFFER_POOL_PARAMETERS_REVISION_1;
    nb_pool_params.Header.Size =
        NDIS_SIZEOF_NET_BUFFER_POOL_PARAMETERS_REVISION_1;
    nb_pool_params.PoolTag = WINDIVERT_TAG;
    nb_pool_params.DataSize = 0;
    nb_pool_handle = NdisAllocateNetBufferPool(NULL, &nb_pool_params);
    if (nb_pool_handle == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        DEBUG_ERROR("failed to allocate net buffer pool", status);
        goto driver_entry_exit;
    }

    // Open a handle to the filter engine:
    status = FwpmEngineOpen0(NULL, RPC_C_AUTHN_DEFAULT, NULL, NULL,
        &engine_handle);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create WFP engine handle", status);
        goto driver_entry_exit;
    }

    // Register WFP sub-layers:
    status = FwpmTransactionBegin0(engine_handle, 0);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to begin WFP transaction", status);
        FwpmTransactionAbort0(engine_handle);
        goto driver_entry_exit;
    }
    status = windivert_install_provider();
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to install provider", status);
        FwpmTransactionAbort0(engine_handle);
        goto driver_entry_exit;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_INBOUND_NETWORK_IPV4);
    if (!NT_SUCCESS(status))
    {
driver_entry_sublayer_error:
        DEBUG_ERROR("failed to install WFP sub-layer", status);
        FwpmTransactionAbort0(engine_handle);
        goto driver_entry_exit;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_OUTBOUND_NETWORK_IPV4);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_INBOUND_NETWORK_IPV6);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_OUTBOUND_NETWORK_IPV6);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_FORWARD_NETWORK_IPV4);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_FORWARD_NETWORK_IPV6);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_FLOW_ESTABLISHED_IPV4);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_FLOW_ESTABLISHED_IPV6);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(
        WINDIVERT_LAYER_RESOURCE_ASSIGNMENT_IPV4);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(
        WINDIVERT_LAYER_RESOURCE_ASSIGNMENT_IPV6);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_RESOURCE_RELEASE_IPV4);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_RESOURCE_RELEASE_IPV6);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_AUTH_CONNECT_IPV4);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_AUTH_CONNECT_IPV6);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_ENDPOINT_CLOSURE_IPV4);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_ENDPOINT_CLOSURE_IPV6);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_AUTH_LISTEN_IPV4);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_AUTH_LISTEN_IPV6);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_AUTH_RECV_ACCEPT_IPV4);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = windivert_install_sublayer(WINDIVERT_LAYER_AUTH_RECV_ACCEPT_IPV6);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_sublayer_error;
    }
    status = FwpmTransactionCommit0(engine_handle);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to commit WFP transaction", status);
        FwpmTransactionAbort0(engine_handle);
        goto driver_entry_exit;
    }

    status = windivert_reflect_init((WDFOBJECT)device);
    if (!NT_SUCCESS(status))
    {
        goto driver_entry_exit;
    }

driver_entry_exit:

    if (!NT_SUCCESS(status))
    {
        windivert_driver_unload();
    }

    return status;
}

/*
 * WinDivert driver unload routine.
 */
extern VOID windivert_unload(IN WDFDRIVER driver_0)
{
    PDRIVER_OBJECT driver = WdfDriverWdmGetDriverObject(driver_0);
    windivert_driver_unload();
    windivert_log_event(PsGetCurrentProcess(), driver, L"UNLOAD");
}

/*
 * WinDivert driver unload.
 */
static void windivert_driver_unload(void)
{
    NTSTATUS status;

    DEBUG("UNLOAD: unloading the WinDivert driver");

    if (inject_handle_forward != NULL)
    {
        FwpsInjectionHandleDestroy0(inject_handle_forward);
    }
    if (injectv6_handle_forward != NULL)
    {
        FwpsInjectionHandleDestroy0(injectv6_handle_forward);
    }
    if (inject_handle_in != NULL)
    {
        FwpsInjectionHandleDestroy0(inject_handle_in);
    }
    if (inject_handle_out != NULL)
    {
        FwpsInjectionHandleDestroy0(inject_handle_out);
    }
    if (injectv6_handle_in != NULL)
    {
        FwpsInjectionHandleDestroy0(injectv6_handle_in);
    }
    if (injectv6_handle_out != NULL)
    {
        FwpsInjectionHandleDestroy0(injectv6_handle_out);
    }
    if (nbl_pool_handle != NULL)
    {
        NdisFreeNetBufferListPool(nbl_pool_handle);
    }
    if (nb_pool_handle != NULL)
    {
        NdisFreeNetBufferPool(nb_pool_handle);
    }
    if (engine_handle != NULL)
    {
        status = FwpmTransactionBegin0(engine_handle, 0);
        if (!NT_SUCCESS(status))
        {
            DEBUG_ERROR("failed to begin WFP transaction", status);
            FwpmTransactionAbort0(engine_handle);
            FwpmEngineClose0(engine_handle);
            return;
        }
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_INBOUND_NETWORK_IPV4->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_OUTBOUND_NETWORK_IPV4->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_INBOUND_NETWORK_IPV6->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_OUTBOUND_NETWORK_IPV6->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_FORWARD_NETWORK_IPV4->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_FORWARD_NETWORK_IPV6->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_FLOW_ESTABLISHED_IPV4->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_FLOW_ESTABLISHED_IPV6->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_RESOURCE_ASSIGNMENT_IPV4->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_RESOURCE_ASSIGNMENT_IPV6->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_RESOURCE_RELEASE_IPV4->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_RESOURCE_RELEASE_IPV6->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_AUTH_CONNECT_IPV4->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_AUTH_CONNECT_IPV6->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_ENDPOINT_CLOSURE_IPV4->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_ENDPOINT_CLOSURE_IPV6->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_AUTH_LISTEN_IPV4->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_AUTH_LISTEN_IPV6->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_AUTH_RECV_ACCEPT_IPV4->sublayer_guid);
        FwpmSubLayerDeleteByKey0(engine_handle,
            WINDIVERT_LAYER_AUTH_RECV_ACCEPT_IPV6->sublayer_guid);

        FwpmProviderDeleteByKey0(engine_handle,
            &WINDIVERT_PROVIDER_GUID);

        status = FwpmTransactionCommit0(engine_handle);
        if (!NT_SUCCESS(status))
        {
            FwpmTransactionAbort0(engine_handle);
            DEBUG_ERROR("failed to commit WFP transaction", status);
        }
        FwpmEngineClose0(engine_handle);
    }
}

/*
 * Register provider.
 */
static NTSTATUS windivert_install_provider()
{
    FWPM_PROVIDER0 provider;
    NTSTATUS status;

    RtlZeroMemory(&provider, sizeof(provider));
    provider.providerKey             = WINDIVERT_PROVIDER_GUID;
    provider.displayData.name        = WINDIVERT_PROVIDER_NAME;
    provider.displayData.description = WINDIVERT_PROVIDER_DESC;

    // We don't care about the install result as this provider
    // is only for passing HLK test.
    FwpmProviderAdd0(engine_handle, &provider, NULL);
    return STATUS_SUCCESS;
}

/*
 * Register a sub-layer.
 */
static NTSTATUS windivert_install_sublayer(layer_t layer)
{
    FWPM_SUBLAYER0 sublayer;
    NTSTATUS status;

    RtlZeroMemory(&sublayer, sizeof(sublayer));
    sublayer.subLayerKey             = *(layer->sublayer_guid);
    sublayer.displayData.name        = layer->sublayer_name;
    sublayer.displayData.description = layer->sublayer_desc;
    sublayer.weight                  = layer->sublayer_weight;

    status = FwpmSubLayerAdd0(engine_handle, &sublayer, NULL);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to add WFP sub-layer", status);
    }
    
    return status;
}

/*
 * WinDivert create routine.
 */
extern VOID windivert_create(IN WDFDEVICE device, IN WDFREQUEST request,
    IN WDFFILEOBJECT object)
{
    WDF_IO_QUEUE_CONFIG queue_config;
    WDF_WORKITEM_CONFIG item_config;
    WDF_OBJECT_ATTRIBUTES obj_attrs;
    FWPM_SESSION0 session;
    PIRP irp;
    NTSTATUS status = STATUS_SUCCESS;
    UINT8 i;
    context_t context = windivert_context_get(object);

    DEBUG("CREATE: creating a new WinDivert context (context=%p)", context);

    // Initialise the new context:
    RtlZeroMemory(context, sizeof(struct context_s));
    context->state  = WINDIVERT_CONTEXT_STATE_OPENING;
    context->device = device;
    context->object = object;
    context->work_queue_length = 0;
    context->packet_queue_length = 0;
    context->packet_queue_maxlength = WINDIVERT_PARAM_QUEUE_LENGTH_DEFAULT;
    context->packet_queue_size = 0;
    context->packet_queue_maxsize = WINDIVERT_PARAM_QUEUE_SIZE_DEFAULT;
    context->packet_queue_maxcounts =
        WINDIVERT_PARAM_QUEUE_TIME_DEFAULT * counts_per_ms;
    context->packet_queue_maxtime = WINDIVERT_PARAM_QUEUE_TIME_DEFAULT;
    context->layer = 0;
    context->flags = 0;
    context->initialized = FALSE;
    context->shutdown_recv = FALSE;
    context->shutdown_recv_enabled = FALSE;
    context->shutdown_send = FALSE;
    context->priority = 0;
    context->priority16 = 0;
    context->filter = NULL;
    context->filter_len = 0;
    context->filter_flags = 0;
    context->worker = NULL;
    context->process = NULL;
    for (i = 0; i < WINDIVERT_CONTEXT_MAXLAYERS; i++)
    {
        context->installed[i] = FALSE;
    }
    KeInitializeSpinLock(&context->lock);
    InitializeListHead(&context->flow_set);
    context->flow_v4_callout_id = 0;
    context->flow_v6_callout_id = 0;
    InitializeListHead(&context->work_queue);
    InitializeListHead(&context->packet_queue);
    for (i = 0; i < WINDIVERT_CONTEXT_MAXLAYERS; i++)
    {
        status = ExUuidCreate(&context->callout_guid[i]);
        if (!NT_SUCCESS(status))
        {
            DEBUG_ERROR("failed to create callout GUID", status);
            goto windivert_create_exit;
        }
        status = ExUuidCreate(&context->filter_guid[i]);
        if (!NT_SUCCESS(status))
        {
            DEBUG_ERROR("failed to create filter GUID", status);
            goto windivert_create_exit;
        }
    }
    WDF_IO_QUEUE_CONFIG_INIT(&queue_config, WdfIoQueueDispatchManual);
    status = WdfIoQueueCreate(device, &queue_config, WDF_NO_OBJECT_ATTRIBUTES,
        &context->read_queue);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create I/O read queue", status);
        goto windivert_create_exit;
    }
    WDF_WORKITEM_CONFIG_INIT(&item_config, windivert_worker);
    item_config.AutomaticSerialization = FALSE;
    WDF_OBJECT_ATTRIBUTES_INIT(&obj_attrs);
    obj_attrs.ParentObject = (WDFOBJECT)object;
    status = WdfWorkItemCreate(&item_config, &obj_attrs, &context->worker);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create read service work item", status);
        goto windivert_create_exit;
    }
    RtlZeroMemory(&session, sizeof(session));
    session.flags |= FWPM_SESSION_FLAG_DYNAMIC;
    status = FwpmEngineOpen0(NULL, RPC_C_AUTHN_DEFAULT, NULL, &session,
        &context->engine_handle);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create WFP engine handle", status);
        goto windivert_create_exit;
    }
    RtlZeroMemory(&context->reflect, sizeof(context->reflect));
    irp = WdfRequestWdmGetIrp(request);
    context->process = IoGetRequestorProcess(irp);
    if (context->process == NULL)
    {
        status = STATUS_INVALID_DEVICE_REQUEST;
        DEBUG_ERROR("no process associated with IRP", status);
        goto windivert_create_exit;
    }
    ObfReferenceObject(context->process);

windivert_create_exit:

    // Clean-up on error:
    if (!NT_SUCCESS(status))
    {
        context->state = WINDIVERT_CONTEXT_STATE_CLOSED;
        if (context->read_queue != NULL)
        {
            WdfObjectDelete(context->read_queue);
        }
        if (context->worker != NULL)
        {
            WdfObjectDelete(context->worker);
        }
        // process/engine_handle handled by windivert_destroy()
    }

    WdfRequestComplete(request, status);
}

/*
 * Register all WFP callouts.
 */
static NTSTATUS windivert_install_callouts(context_t context, UINT8 layer,
    UINT64 flags)
{
    UINT8 i, j;
    layer_t layers[WINDIVERT_CONTEXT_MAXLAYERS];
    UINT32 *callout_ids[WINDIVERT_CONTEXT_MAXLAYERS] = {NULL};
    BOOL inbound, outbound, ipv4, ipv6, bind, connect, listen,
        accept, close;
    NTSTATUS status = STATUS_SUCCESS;

    inbound  = ((flags & WINDIVERT_FILTER_FLAG_INBOUND) != 0);
    outbound = ((flags & WINDIVERT_FILTER_FLAG_OUTBOUND) != 0);
    ipv4     = ((flags & WINDIVERT_FILTER_FLAG_IP) != 0);
    ipv6     = ((flags & WINDIVERT_FILTER_FLAG_IPV6) != 0);
    bind     = ((flags & WINDIVERT_FILTER_FLAG_EVENT_SOCKET_BIND) != 0);
    connect  = ((flags & WINDIVERT_FILTER_FLAG_EVENT_SOCKET_CONNECT) != 0);
    listen   = ((flags & WINDIVERT_FILTER_FLAG_EVENT_SOCKET_LISTEN) != 0);
    accept   = ((flags & WINDIVERT_FILTER_FLAG_EVENT_SOCKET_ACCEPT) != 0);
    close    = ((flags & WINDIVERT_FILTER_FLAG_EVENT_SOCKET_CLOSE) != 0);

    i = 0;
    switch (layer)
    {
        case WINDIVERT_LAYER_NETWORK:
            if (inbound && ipv4)
            {
                layers[i++] = WINDIVERT_LAYER_INBOUND_NETWORK_IPV4;
            }
            if (outbound && ipv4)
            {
                layers[i++] = WINDIVERT_LAYER_OUTBOUND_NETWORK_IPV4;
            }
            if (inbound && ipv6)
            {
                layers[i++] = WINDIVERT_LAYER_INBOUND_NETWORK_IPV6;
            }
            if (outbound && ipv6)
            {
                layers[i++] = WINDIVERT_LAYER_OUTBOUND_NETWORK_IPV6;
            }
            break;

        case WINDIVERT_LAYER_NETWORK_FORWARD:
            if (ipv4)
            {
                layers[i++] = WINDIVERT_LAYER_FORWARD_NETWORK_IPV4;
            }
            if (ipv6)
            {
                layers[i++] = WINDIVERT_LAYER_FORWARD_NETWORK_IPV6;
            }
            break;
        
        case WINDIVERT_LAYER_FLOW:
            if (ipv4)
            {
                callout_ids[i] = &context->flow_v4_callout_id;
                layers[i++] = WINDIVERT_LAYER_FLOW_ESTABLISHED_IPV4;
            }
            if (ipv6)
            {
                callout_ids[i] = &context->flow_v6_callout_id;
                layers[i++] = WINDIVERT_LAYER_FLOW_ESTABLISHED_IPV6;
            }
            break;

        case WINDIVERT_LAYER_SOCKET:
            if (ipv4 && bind)
            {
                layers[i++] = WINDIVERT_LAYER_RESOURCE_ASSIGNMENT_IPV4;
            }
            if (ipv4 && connect)
            {
                layers[i++] = WINDIVERT_LAYER_AUTH_CONNECT_IPV4;
            }
            if (ipv4 && listen)
            {
                layers[i++] = WINDIVERT_LAYER_AUTH_LISTEN_IPV4;
            }
            if (ipv4 && accept)
            {
                layers[i++] = WINDIVERT_LAYER_AUTH_RECV_ACCEPT_IPV4;
            }
            if (ipv4 && close)
            {
                layers[i++] = WINDIVERT_LAYER_RESOURCE_RELEASE_IPV4;
                layers[i++] = WINDIVERT_LAYER_ENDPOINT_CLOSURE_IPV4;
            }
            if (ipv6 && bind)
            {
                layers[i++] = WINDIVERT_LAYER_RESOURCE_ASSIGNMENT_IPV6;
            }
            if (ipv6 && connect)
            {
                layers[i++] = WINDIVERT_LAYER_AUTH_CONNECT_IPV6;
            }
            if (ipv6 && listen)
            {
                layers[i++] = WINDIVERT_LAYER_AUTH_LISTEN_IPV6;
            }
            if (ipv6 && accept)
            {
                layers[i++] = WINDIVERT_LAYER_AUTH_RECV_ACCEPT_IPV6;
            }
            if (ipv6 && close)
            {
                layers[i++] = WINDIVERT_LAYER_RESOURCE_RELEASE_IPV6;
                layers[i++] = WINDIVERT_LAYER_ENDPOINT_CLOSURE_IPV6;
            }
            break;

        case WINDIVERT_LAYER_REFLECT:
            break;

        default:
            return STATUS_INVALID_PARAMETER;
    }

    for (j = 0; j < i; j++)
    {
        status = windivert_install_callout(context, j, layers[j],
            callout_ids[j]);
        if (!NT_SUCCESS(status))
        {
            goto windivert_install_callouts_exit;
        }
    }

windivert_install_callouts_exit:

    if (!NT_SUCCESS(status))
    {
        windivert_uninstall_callouts(context, WINDIVERT_CONTEXT_STATE_OPEN);
    }

    return status;
}

/*
 * Register a WFP callout.
 */
static NTSTATUS windivert_install_callout(context_t context, UINT idx,
    layer_t layer, UINT32 *callout_id_ptr)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    FWPS_CALLOUT0 scallout;
    FWPM_CALLOUT0 mcallout;
    FWPM_FILTER0 filter;
    UINT64 weight;
    UINT32 priority;
    GUID callout_guid, filter_guid;
    UINT32 callout_id;
    WDFDEVICE device;
    HANDLE engine;
    NTSTATUS status;

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        status = STATUS_INVALID_DEVICE_STATE;
        return status;
    }
    priority = context->priority;
    callout_guid = context->callout_guid[idx];
    filter_guid = context->filter_guid[idx];
    device = context->device;
    engine = context->engine_handle;
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    weight = (UINT64)priority;
    
    RtlZeroMemory(&scallout, sizeof(scallout));
    scallout.calloutKey              = callout_guid;
    scallout.classifyFn              = layer->classify;
    scallout.notifyFn                = windivert_notify;
    scallout.flowDeleteFn            = layer->flow_delete;
    RtlZeroMemory(&mcallout, sizeof(mcallout));
    mcallout.calloutKey              = callout_guid;
    mcallout.displayData.name        = layer->callout_name;
    mcallout.displayData.description = layer->callout_desc;
    mcallout.applicableLayer         = *(layer->layer_guid);
    RtlZeroMemory(&filter, sizeof(filter));
    filter.filterKey                 = filter_guid;
    filter.layerKey                  = *(layer->layer_guid);
    filter.displayData.name          = layer->filter_name;
    filter.displayData.description   = layer->filter_desc;
    filter.action.type               = FWP_ACTION_CALLOUT_UNKNOWN;
    filter.action.calloutKey         = callout_guid;
    filter.subLayerKey               = *(layer->sublayer_guid);
    filter.weight.type               = FWP_UINT64;
    filter.weight.uint64             = &weight;
    filter.rawContext                = (UINT64)context;
    status = FwpsCalloutRegister0(WdfDeviceWdmGetDeviceObject(device),
        &scallout, &callout_id);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to install WFP callout", status);
        return status;
    }
    if (callout_id_ptr != NULL)
    {
        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
        *callout_id_ptr = callout_id;
        KeReleaseInStackQueuedSpinLock(&lock_handle);
    }
    status = FwpmTransactionBegin0(engine, 0);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to begin WFP transaction", status);
        goto windivert_install_callout_error;
    }
    status = FwpmCalloutAdd0(engine, &mcallout, NULL, NULL);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to add WFP callout", status);
        goto windivert_install_callout_error;
    }
    status = FwpmFilterAdd0(engine, &filter, NULL, NULL);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to add WFP filter", status);
        goto windivert_install_callout_error;
    }
    status = FwpmTransactionCommit0(engine);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to commit WFP transaction", status);
        goto windivert_install_callout_error;
    }

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        FwpsCalloutUnregisterByKey0(&callout_guid);
        status = STATUS_INVALID_DEVICE_STATE;
        return status;
    }
    context->installed[idx] = TRUE;
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    return STATUS_SUCCESS;

windivert_install_callout_error:
    FwpmTransactionAbort0(engine);
    FwpsCalloutUnregisterByKey0(&callout_guid);
    return status;
}

/*
 * WinDivert uninstall callouts routine.
 */
static void windivert_uninstall_callouts(context_t context,
    context_state_t state)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    UINT i;
    HANDLE engine;
    BOOL installed;
    GUID callout_guid, filter_guid;
    NTSTATUS status;

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != state)
    {
windivert_uninstall_callouts_error:
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        status = STATUS_INVALID_DEVICE_STATE;
        DEBUG_ERROR("failed to delete filters and callouts", status);
        return;
    }
    engine = context->engine_handle;
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    status = FwpmTransactionBegin0(engine, 0);
    if (!NT_SUCCESS(status))
    {
        // If the userspace app closes without closing the handle to
        // WinDivert, any actions on engine fail because the
        // RPC handle was closed first. So, this path is "normal" if
        // the user's app crashed or never closed the WinDivert handle.
        DEBUG_ERROR("failed to begin WFP transaction", status);
        FwpmTransactionAbort0(engine);
        goto windivert_uninstall_callouts_unregister;
    }
    for (i = 0; i < WINDIVERT_CONTEXT_MAXLAYERS; i++)
    {
        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
        if (context->state != state)
        {
            KeReleaseInStackQueuedSpinLock(&lock_handle);
            FwpmTransactionAbort0(engine);
            status = STATUS_INVALID_DEVICE_STATE;
            DEBUG_ERROR("failed to delete filters and callouts", status);
            return;
        }
        installed = context->installed[i];
        callout_guid = context->callout_guid[i];
        filter_guid = context->filter_guid[i];
        KeReleaseInStackQueuedSpinLock(&lock_handle);

        if (!installed)
        {
            continue;
        }
        status = FwpmFilterDeleteByKey0(engine, &filter_guid);
        if (!NT_SUCCESS(status))
        {
            DEBUG_ERROR("failed to delete filter", status);
            break;
        }
        status = FwpmCalloutDeleteByKey0(engine, &callout_guid);
        if (!NT_SUCCESS(status))
        {
            DEBUG_ERROR("failed to delete callout", status);
            break;
        }
    }
    if (!NT_SUCCESS(status))
    {
        FwpmTransactionAbort0(engine);
        goto windivert_uninstall_callouts_unregister;
    }
    status = FwpmTransactionCommit0(engine);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to commit WFP transaction", status);
        FwpmTransactionAbort0(engine);
        // continue
    }

windivert_uninstall_callouts_unregister:
    for (i = 0; i < WINDIVERT_CONTEXT_MAXLAYERS; i++)
    {
        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
        if (context->state != state)
        {
            goto windivert_uninstall_callouts_error;
        }
        installed = context->installed[i];
        callout_guid = context->callout_guid[i];
        context->installed[i] = FALSE;
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        if (!installed)
        {
            continue;
        }
        status = FwpsCalloutUnregisterByKey0(&callout_guid);
        if (!NT_SUCCESS(status))
        {
            DEBUG_ERROR("failed to delete callout", status);
            continue;
        }
    }
}

/*
 * Divert cleanup routine.
 */
extern VOID windivert_cleanup(IN WDFFILEOBJECT object)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    PLIST_ENTRY entry;
    context_t context = windivert_context_get(object);
    flow_t flow;
    packet_t work, packet;
    WDFQUEUE read_queue;
    WDFWORKITEM worker;
    LONGLONG timestamp;
    BOOL sniff_mode, timeout, forward;
    NTSTATUS status;
    
    DEBUG("CLEANUP: cleaning up WinDivert context (context=%p)", context);

    windivert_reflect_close_event(context);
    timestamp = KeQueryPerformanceCounter(NULL).QuadPart;
    
    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPENING &&
            context->state != WINDIVERT_CONTEXT_STATE_OPEN)
    {
windivert_cleanup_error:
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        status = STATUS_INVALID_DEVICE_STATE;
        DEBUG_ERROR("failed to verify state for cleanup routine", status);
        return;
    }
    context->state = WINDIVERT_CONTEXT_STATE_CLOSING;
    sniff_mode = ((context->flags & WINDIVERT_FLAG_SNIFF) != 0);
    forward = (context->layer == WINDIVERT_LAYER_NETWORK_FORWARD);
    while (!IsListEmpty(&context->flow_set))
    {
        entry = RemoveHeadList(&context->flow_set);
        flow = CONTAINING_RECORD(entry, struct flow_s, entry);
        flow->deleted = TRUE;
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        status = FwpsFlowRemoveContext0(flow->flow_id, flow->layer_id,
            flow->callout_id);
        if (!NT_SUCCESS(status))
        {
            windivert_free(flow);
        }
        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    }
    while (!IsListEmpty(&context->packet_queue))
    {
        entry = RemoveHeadList(&context->packet_queue);
        packet = CONTAINING_RECORD(entry, struct packet_s, entry);
        context->packet_queue_length--;
        context->packet_queue_size -= packet->packet_size;
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        timeout = WINDIVERT_TIMEOUT(context, packet->timestamp, timestamp);
        if (!sniff_mode && !timeout)
        {
            windivert_inject_packet(packet);
        }
        else
        {
            windivert_free_packet(packet);
        }
        timestamp = KeQueryPerformanceCounter(NULL).QuadPart;
        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
        if (context->state != WINDIVERT_CONTEXT_STATE_CLOSING)
        {
            goto windivert_cleanup_error;
        }
    }
    while (!IsListEmpty(&context->work_queue))
    {
        entry = RemoveHeadList(&context->work_queue);
        context->work_queue_length--;
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        work = CONTAINING_RECORD(entry, struct packet_s, entry);
        timeout = WINDIVERT_TIMEOUT(context, work->timestamp, timestamp);
        if (!sniff_mode && !timeout)
        {
            windivert_inject_packet(work);
        }
        else
        {
            windivert_free_packet(work);
        }
        timestamp = KeQueryPerformanceCounter(NULL).QuadPart;
        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
        if (context->state != WINDIVERT_CONTEXT_STATE_CLOSING)
        {
            goto windivert_cleanup_error;
        }
    }
    read_queue = context->read_queue;
    KeReleaseInStackQueuedSpinLock(&lock_handle);
    WdfIoQueuePurge(read_queue, NULL, NULL);
    WdfObjectDelete(read_queue);
    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_CLOSING)
    {
        goto windivert_cleanup_error;
    }
    worker = context->worker;
    KeReleaseInStackQueuedSpinLock(&lock_handle);
    WdfWorkItemFlush(worker);
    WdfObjectDelete(worker);
}

/*
 * WinDivert close routine.
 */
extern VOID windivert_close(IN WDFFILEOBJECT object)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    context_t context = windivert_context_get(object);
    NTSTATUS status;
    
    DEBUG("CLOSE: closing WinDivert context (context=%p)", context);
    
    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_CLOSING)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        status = STATUS_INVALID_DEVICE_STATE;
        DEBUG_ERROR("failed to verify state for close routine", status);
        return;
    }
    context->state = WINDIVERT_CONTEXT_STATE_CLOSED;
    KeReleaseInStackQueuedSpinLock(&lock_handle);
}

/*
 * WinDivert destroy routine.
 */
extern VOID windivert_destroy(IN WDFOBJECT object)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    context_t context = windivert_context_get((WDFFILEOBJECT)object);
    const WINDIVERT_FILTER *filter;
    NTSTATUS status;

    DEBUG("DESTROY: destroying WinDivert context (context=%p)", context);

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_CLOSED)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        status = STATUS_INVALID_DEVICE_STATE;
        DEBUG_ERROR("failed to verify state for destroy routine", status);
        return;
    }
    filter = context->filter;
    KeReleaseInStackQueuedSpinLock(&lock_handle);
    windivert_uninstall_callouts(context, WINDIVERT_CONTEXT_STATE_CLOSED);
    if (context->engine_handle != NULL)
    {
        FwpmEngineClose0(context->engine_handle);
    }
    windivert_free((PVOID)filter);
    if (context->process != NULL)
    {
        ObDereferenceObject(context->process);
    }
}

/*
 * WinDivert read routine.
 */
static NTSTATUS windivert_read(context_t context, WDFREQUEST request)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    NTSTATUS status = STATUS_SUCCESS;

    DEBUG("READ: reading diverted packet (context=%p, request=%p)", context,
        request);

    // Forward the request to the pending read queue:
    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        return STATUS_INVALID_DEVICE_STATE;
    }
    if ((context->flags & WINDIVERT_FLAG_SEND_ONLY) != 0)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        status = STATUS_INVALID_PARAMETER;
        DEBUG_ERROR("failed to inject; send-only flag is set", status);
        return status;
    }
    status = WdfRequestForwardToIoQueue(request, context->read_queue);
    KeReleaseInStackQueuedSpinLock(&lock_handle);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to forward I/O request to read queue", status);
        return status;
    }

    // Service the read request:
    windivert_read_service(context);

    return STATUS_SUCCESS;
}

/*
 * WinDivert service a single read request.
 */
static void windivert_read_service_request(context_t context, packet_t packet,
    LONGLONG timestamp, WDFREQUEST request)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    PLIST_ENTRY entry;
    PMDL dst_mdl;
    UINT8 *layer_data, *src, *dst;
    ULONG dst_len, src_len, read_len = 0;
    BOOL timeout;
    packet_t new_packet;
    req_context_t req_context;
    PWINDIVERT_ADDRESS addr;
    UINT i, addr_len, addr_len_max;
    UINT *addr_len_ptr;
    NTSTATUS status;

    if (request == NULL)
    {
        // This occurs if the packet timed out.
        windivert_free_packet(packet);
        return;
    }

    DEBUG("SERVICE: servicing read request (request=%p, packet=%p)", request,
        packet);

    // Get the packet and address buffers: 
    switch (packet->layer)
    {
        case WINDIVERT_LAYER_NETWORK:
        case WINDIVERT_LAYER_NETWORK_FORWARD:
        case WINDIVERT_LAYER_REFLECT:

            status = WdfRequestRetrieveOutputWdmMdl(request, &dst_mdl);
            if (!NT_SUCCESS(status))
            {
                DEBUG_ERROR("failed to retrieve output MDL", status);
                goto windivert_read_service_request_exit;
            }
            dst = MmGetSystemAddressForMdlSafe(dst_mdl,
                NormalPagePriority | no_exec_flag);
            if (dst == NULL)
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                DEBUG_ERROR("failed to get address of output MDL", status);
                goto windivert_read_service_request_exit;
            }
            dst_len = MmGetMdlByteCount(dst_mdl);
            break;

        case WINDIVERT_LAYER_FLOW:
        case WINDIVERT_LAYER_SOCKET:

            status = STATUS_SUCCESS;
            dst = NULL;
            dst_len = 0;
            break;

        default:
            status = STATUS_INVALID_DEVICE_STATE;
            DEBUG_ERROR("invalid packet layer", status);
            goto windivert_read_service_request_exit;
    }

    req_context  = windivert_req_context_get(request);
    addr         = req_context->addr;
    addr_len     = 0;
    addr_len_max = (UINT)req_context->addr_len;
    addr_len_ptr = req_context->addr_len_ptr;
    i            = 0;
    while (TRUE)
    {
        // Copy the packet data:
        switch (packet->layer)
        {
            case WINDIVERT_LAYER_NETWORK:
            case WINDIVERT_LAYER_NETWORK_FORWARD:
            case WINDIVERT_LAYER_REFLECT:

                if (packet->layer != WINDIVERT_LAYER_REFLECT)
                {
                    src = WINDIVERT_PACKET_DATA_PTR(WINDIVERT_DATA_NETWORK,
                        packet);
                }
                else
                {
                    src = WINDIVERT_PACKET_DATA_PTR(WINDIVERT_DATA_REFLECT,
                        packet);
                }
                src_len = packet->packet_len;
                if (src_len > dst_len)
                {
                    status = STATUS_BUFFER_TOO_SMALL;
                }
                src_len = (src_len < dst_len? src_len: dst_len);
                RtlCopyMemory(dst, src, src_len);
                dst += src_len;
                dst_len -= src_len;
                read_len += src_len;
                break;

            default:
                break;
        }

        // Copy the address data:
        if (addr != NULL)
        {
            DEBUG_BOUNDS_CHECK((PVOID)addr, (UINT8 *)addr + addr_len_max,
                (PVOID)&addr[i], (PVOID)&addr[i+1]);

            addr[i].Timestamp   = (INT64)packet->timestamp;
            addr[i].Layer       = packet->layer;
            addr[i].Event       = packet->event;
            addr[i].Sniffed     = packet->sniffed;
            addr[i].Outbound    = packet->outbound;
            addr[i].Loopback    = packet->loopback;
            addr[i].Impostor    = packet->impostor;
            addr[i].IPv6        = packet->ipv6;
            addr[i].IPChecksum  = packet->ip_checksum;
            addr[i].TCPChecksum = packet->tcp_checksum;
            addr[i].UDPChecksum = packet->udp_checksum;
            addr[i].Reserved1   = 0;
            addr[i].Reserved2   = 0;
            layer_data = (PVOID)packet->data;
            switch (packet->layer)
            {
                case WINDIVERT_LAYER_NETWORK:
                case WINDIVERT_LAYER_NETWORK_FORWARD:
                    RtlCopyMemory(&addr[i].Network, layer_data,
                        sizeof(WINDIVERT_DATA_NETWORK));
                    break;

                case WINDIVERT_LAYER_FLOW:
                    RtlCopyMemory(&addr[i].Flow, layer_data,
                        sizeof(WINDIVERT_DATA_FLOW));
                    break;

                case WINDIVERT_LAYER_SOCKET:
                    RtlCopyMemory(&addr[i].Socket, layer_data,
                        sizeof(WINDIVERT_DATA_SOCKET));
                    break;

                case WINDIVERT_LAYER_REFLECT:
                    RtlCopyMemory(&addr[i].Reflect, layer_data,
                        sizeof(WINDIVERT_DATA_REFLECT));
                    break;

                default:
                    break;
            }
        }

        i++;
        addr_len += sizeof(WINDIVERT_ADDRESS);
        if (addr_len + sizeof(WINDIVERT_ADDRESS) > addr_len_max ||
                i >= WINDIVERT_BATCH_MAX)
        {
            // addr[] is full:
            break;
        }

        // Attempt to fill the buffer with more packets:
        new_packet = NULL;
        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
        if (context->state == WINDIVERT_CONTEXT_STATE_OPEN &&
                !IsListEmpty(&context->packet_queue))
        {
            entry = RemoveHeadList(&context->packet_queue);
            new_packet = CONTAINING_RECORD(entry, struct packet_s, entry);
            timeout = WINDIVERT_TIMEOUT(context, new_packet->timestamp,
                timestamp);
            if (new_packet->packet_len > dst_len || timeout)
            {
                // Note: timeouts to be handled elsewhere.
                InsertHeadList(&context->packet_queue, entry);
                new_packet = NULL;
            }
            else
            {
                context->packet_queue_length--;
                context->packet_queue_size -= new_packet->packet_size;
            }
        }
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        if (new_packet == NULL)
        {
            // No suitable packet:
            break;
        }

        windivert_free_packet(packet);
        packet = new_packet;
    }

    if (addr_len_ptr != NULL)
    {
        *addr_len_ptr = addr_len;
    }

windivert_read_service_request_exit:

    windivert_free_packet(packet);
    WdfRequestCompleteWithInformation(request, status, read_len);
}

/*
 * Opportunistic read service request.
 */
static void windivert_fast_read_service_request(PVOID packet, ULONG packet_len,
    PNET_BUFFER_LIST buffers, WINDIVERT_LAYER layer, PVOID layer_data,
    WINDIVERT_EVENT event, UINT64 flags, BOOL ipv4, BOOL outbound,
    BOOL loopback, BOOL impostor, LONGLONG timestamp, WDFREQUEST request)
{
    PNET_BUFFER buffer;
    PMDL dst_mdl;
    UINT dst_len, read_len = 0;
    UINT8 *dst;
    req_context_t req_context;
    PWINDIVERT_ADDRESS addr;
    UINT *addr_len_ptr;
    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO checksums;
    BOOL sniffed, ip_checksum, tcp_checksum, udp_checksum;
    NTSTATUS status = STATUS_SUCCESS;

    // This function bypasses the normal work_queue -> packet_queue flow, but
    // is limited to a single packet+request pair.  This eliminates an extra
    // packet copy, allocation+deallocation, and at least one context switch.

    switch (layer)
    {
        case WINDIVERT_LAYER_NETWORK:
        case WINDIVERT_LAYER_NETWORK_FORWARD:
        case WINDIVERT_LAYER_REFLECT:

            status = WdfRequestRetrieveOutputWdmMdl(request, &dst_mdl);
            if (!NT_SUCCESS(status))
            {
                goto windivert_fast_read_service_request_exit;
            }
            dst = MmGetSystemAddressForMdlSafe(dst_mdl,
                NormalPagePriority | no_exec_flag);
            if (dst == NULL)
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto windivert_fast_read_service_request_exit;
            }
            dst_len = MmGetMdlByteCount(dst_mdl);
            break;

        case WINDIVERT_LAYER_FLOW:
        case WINDIVERT_LAYER_SOCKET:
            status = STATUS_SUCCESS;
            dst = NULL;
            dst_len = 0;
            break;

        default:
            status = STATUS_INVALID_DEVICE_STATE;
            goto windivert_fast_read_service_request_exit;
    }

    switch (layer)
    {
        case WINDIVERT_LAYER_NETWORK:
        case WINDIVERT_LAYER_NETWORK_FORWARD:
            buffer = (PNET_BUFFER)packet;
            dst_len = (dst_len < packet_len? dst_len: packet_len);
            if (!windivert_copy_data(buffer, dst, dst_len))
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else if (dst_len < packet_len)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            read_len = dst_len;
            checksums.Value = NET_BUFFER_LIST_INFO(buffers,
                TcpIpChecksumNetBufferListInfo);
            if (outbound)
            {
                ip_checksum = (checksums.Transmit.IpHeaderChecksum == 0);
                tcp_checksum = (checksums.Transmit.TcpChecksum == 0);
                udp_checksum = (checksums.Transmit.UdpChecksum == 0);
            }
            else
            {
                ip_checksum = (checksums.Receive.IpChecksumSucceeded == 0);
                tcp_checksum = (checksums.Receive.TcpChecksumSucceeded == 0);
                udp_checksum = (checksums.Receive.UdpChecksumSucceeded == 0);
            }
            break;

        case WINDIVERT_LAYER_REFLECT:
            dst_len = (dst_len < packet_len? dst_len: packet_len);
            RtlCopyMemory(dst, packet, dst_len);
            read_len = dst_len;
            ip_checksum = tcp_checksum = udp_checksum = FALSE;
            break;

        default:
            read_len = 0;
            ip_checksum = tcp_checksum = udp_checksum = FALSE;
            break;
    }

    req_context  = windivert_req_context_get(request);
    addr         = req_context->addr;
    addr_len_ptr = req_context->addr_len_ptr;

    if (addr != NULL)
    {
        sniffed = ((flags & WINDIVERT_FLAG_SNIFF) != 0 ||
            event == WINDIVERT_EVENT_SOCKET_CLOSE);

        addr->Timestamp   = timestamp;
        addr->Layer       = layer;
        addr->Event       = event;
        addr->Sniffed     = (sniffed? 1: 0);
        addr->Outbound    = (outbound? 1: 0);
        addr->Loopback    = (loopback? 1: 0);
        addr->Impostor    = (impostor? 1: 0);
        addr->IPv6        = (ipv4? 0: 1);
        addr->IPChecksum  = (ip_checksum? 1: 0);
        addr->TCPChecksum = (tcp_checksum? 1: 0);
        addr->UDPChecksum = (udp_checksum? 1: 0);
        addr->Reserved1   = 0;
        addr->Reserved2   = 0;
        switch (layer)
        {
            case WINDIVERT_LAYER_NETWORK:
            case WINDIVERT_LAYER_NETWORK_FORWARD:
                RtlCopyMemory(&addr->Network, layer_data,
                    sizeof(WINDIVERT_DATA_NETWORK));
                break;

            case WINDIVERT_LAYER_FLOW:
                RtlCopyMemory(&addr->Flow, layer_data,
                    sizeof(WINDIVERT_DATA_FLOW));
                break;

            case WINDIVERT_LAYER_SOCKET:
                RtlCopyMemory(&addr->Socket, layer_data,
                    sizeof(WINDIVERT_DATA_SOCKET));
                break;

            case WINDIVERT_LAYER_REFLECT:
                RtlCopyMemory(&addr->Reflect, layer_data,
                    sizeof(WINDIVERT_DATA_REFLECT));
                break;

            default:
                break;
        }
    }
    if (addr_len_ptr != NULL)
    {
        *addr_len_ptr = sizeof(WINDIVERT_ADDRESS);
    }

windivert_fast_read_service_request_exit:

    WdfRequestCompleteWithInformation(request, status, read_len);
}

/*
 * WinDivert read request service.
 */
static void windivert_read_service(context_t context)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    WDFREQUEST request;
    PLIST_ENTRY entry;
    LONGLONG timestamp;
    BOOL timeout;
    NTSTATUS status;
    packet_t packet;

    timestamp = KeQueryPerformanceCounter(NULL).QuadPart;
    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    while (context->state == WINDIVERT_CONTEXT_STATE_OPEN &&
           !IsListEmpty(&context->packet_queue))
    {
        entry = RemoveHeadList(&context->packet_queue);
        packet = CONTAINING_RECORD(entry, struct packet_s, entry);
        timeout = WINDIVERT_TIMEOUT(context, packet->timestamp, timestamp);
        request = NULL;
        if (!timeout)
        {
            status = WdfIoQueueRetrieveNextRequest(context->read_queue,
                &request);
            if (!NT_SUCCESS(status))
            {
                InsertHeadList(&context->packet_queue, entry);
                break;
            }
        }
        context->packet_queue_length--;
        context->packet_queue_size -= packet->packet_size;
        KeReleaseInStackQueuedSpinLock(&lock_handle);

        windivert_read_service_request(context, packet, timestamp, request);

        timestamp = KeQueryPerformanceCounter(NULL).QuadPart;
        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    }

    if (context->shutdown_recv && context->shutdown_recv_enabled &&
            IsListEmpty(&context->packet_queue) &&
            IsListEmpty(&context->work_queue))
    {
        // The handle has shutdown, the queue is empty, and no more packets
        // will be queued.  Notify any remaining requests.
        while (context->state == WINDIVERT_CONTEXT_STATE_OPEN)
        {
            status = WdfIoQueueRetrieveNextRequest(context->read_queue,
                &request);
            if (!NT_SUCCESS(status))
            {
                break;
            }
            KeReleaseInStackQueuedSpinLock(&lock_handle);
            WdfRequestComplete(request, STATUS_PIPE_EMPTY);
            KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
        }
    }
    KeReleaseInStackQueuedSpinLock(&lock_handle);
}

/*
 * WinDivert write routine.
 */
static NTSTATUS windivert_write(context_t context, WDFREQUEST request,
    req_context_t req_context)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    PMDL mdl = NULL;
    PVOID data, data_copy;
    packet_t packet;
    UINT data_len, packet_len, packet_size, inject_len;
    PWINDIVERT_DATA_NETWORK network_data;
    PWINDIVERT_IPHDR ip_header;
    PWINDIVERT_IPV6HDR ipv6_header;
    UINT8 layer;
    UINT32 priority;
    UINT64 flags, checksums;
    HANDLE handle;
    PNET_BUFFER_LIST buffers = NULL;
    PWINDIVERT_ADDRESS addr;
    UINT i, addr_len, addr_len_max, version;
    NTSTATUS status = STATUS_SUCCESS, status_soft_error = STATUS_SUCCESS;

    DEBUG("WRITE: writing/injecting a packet (context=%p, request=%p)",
        context, request);
    
    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        status = STATUS_INVALID_DEVICE_STATE;
        goto windivert_write_hard_error;
    }
    if (context->shutdown_send)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        status = STATUS_PIPE_EMPTY;
        goto windivert_write_hard_error;
    }
    layer = context->layer;
    priority = context->priority;
    flags = context->flags;
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    if ((flags & WINDIVERT_FLAG_RECV_ONLY) != 0)
    {
        status = STATUS_INVALID_PARAMETER;
        DEBUG_ERROR("failed to inject; recv-only flag is set", status);
        goto windivert_write_hard_error;
    }

    switch (layer)
    {
        case WINDIVERT_LAYER_FLOW:
        case WINDIVERT_LAYER_SOCKET:
        case WINDIVERT_LAYER_REFLECT:
            status = STATUS_INVALID_PARAMETER;
            DEBUG_ERROR("failed to inject at layer", status);
            goto windivert_write_hard_error;
        default:
            break;
    }

    status = WdfRequestRetrieveOutputWdmMdl(request, &mdl);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to retrieve input MDL", status);
        goto windivert_write_hard_error;
    }

    data = MmGetSystemAddressForMdlSafe(mdl,
        NormalPagePriority | no_write_flag | no_exec_flag);
    if (data == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        DEBUG_ERROR("failed to get MDL address", status);
        goto windivert_write_hard_error;
    }
    
    data_len     = MmGetMdlByteCount(mdl);
    inject_len   = 0;
    addr         = req_context->addr;
    addr_len_max = (ULONG)req_context->addr_len;
    addr_len     = 0;

    for (i = 0; addr_len + sizeof(WINDIVERT_ADDRESS) <= addr_len_max &&
            i < WINDIVERT_BATCH_MAX;
            i++, addr_len += sizeof(WINDIVERT_ADDRESS))
    {
        // Get the packet length:
        if (data_len < sizeof(WINDIVERT_IPHDR))
        {
windivert_write_too_small_packet:
            status = STATUS_BUFFER_TOO_SMALL;
            DEBUG_ERROR("failed to inject partial packet", status);
            goto windivert_write_hard_error;
        }
        ip_header = (PWINDIVERT_IPHDR)data;
        version = ip_header->Version;
        switch (version)
        {
            case 4:
                packet_len = RtlUshortByteSwap(ip_header->Length);
                if (packet_len < sizeof(WINDIVERT_IPHDR))
                {
                    goto windivert_write_invalid_packet;
                }
                break;
            case 6:
                if (data_len < sizeof(WINDIVERT_IPV6HDR))
                {
                    goto windivert_write_too_small_packet;
                }
                ipv6_header = (PWINDIVERT_IPV6HDR)data;
                packet_len = RtlUshortByteSwap(ipv6_header->Length) +
                    sizeof(WINDIVERT_IPV6HDR);
                break;
            default:
windivert_write_invalid_packet:
                status = STATUS_INVALID_PARAMETER;
                DEBUG_ERROR("failed to inject invalid packet", status);
                goto windivert_write_hard_error;
        }
        if (data_len < packet_len)
        {
            goto windivert_write_too_small_packet;
        }

        // Copy packet & data:
        packet_size = WINDIVERT_PACKET_SIZE(WINDIVERT_DATA_NETWORK,
            packet_len);
        packet = (packet_t)windivert_malloc(packet_size, FALSE);
        if (packet == NULL)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            DEBUG_ERROR("failed to allocate memory for injected packet",
                status);
            goto windivert_write_hard_error;
        }
        packet->layer         = layer;
        packet->event         = WINDIVERT_EVENT_NETWORK_PACKET;
        packet->sniffed       = 0;      // Unused
        packet->outbound      = addr[i].Outbound;
        packet->loopback      = 0;      // Unused
        packet->impostor      = addr[i].Impostor;
        packet->ipv6          = (version == 6? 1: 0);
        packet->ip_checksum   = addr[i].IPChecksum;
        packet->tcp_checksum  = addr[i].TCPChecksum;
        packet->udp_checksum  = addr[i].UDPChecksum;
        packet->icmp_checksum = 1;      // Assumed valid
        packet->match         = 0;      // Unused
        packet->packet_size   = packet_size;
        packet->packet_len    = packet_len;
        packet->priority      = priority;
        packet->timestamp     = 0;      // Unused
        packet->object        = NULL;
        network_data =
            (PWINDIVERT_DATA_NETWORK)WINDIVERT_LAYER_DATA_PTR(packet);
        RtlCopyMemory(network_data, &addr[i].Network, sizeof(network_data));
        data_copy = WINDIVERT_PACKET_DATA_PTR(WINDIVERT_DATA_NETWORK, packet);
        RtlCopyMemory(data_copy, data, packet_len);
        switch (version)
        {
            case 4:
                ip_header = (PWINDIVERT_IPHDR)data_copy;
                if (ip_header->Version != 4 ||
                        packet_len != RtlUshortByteSwap(ip_header->Length))
                {
                    windivert_free(packet);
                    goto windivert_write_invalid_packet;
                }
                break;
            case 6:
                ipv6_header = (PWINDIVERT_IPV6HDR)data_copy;
                if (ipv6_header->Version != 6 ||
                        packet_len != RtlUshortByteSwap(ipv6_header->Length) +
                            sizeof(WINDIVERT_IPV6HDR))
                {
                    windivert_free(packet);
                    goto windivert_write_invalid_packet;
                }
                break;
        }

        // Check bounds:
        DEBUG_BOUNDS_CHECK((PVOID)addr, (UINT8 *)addr + addr_len_max,
            (PVOID)&addr[i], (PVOID)&addr[i+1]);

        // Inject packet:
        status = windivert_inject_packet(packet);
        if (!NT_SUCCESS(status))
        {
            if (status == STATUS_INSUFFICIENT_RESOURCES)
            {
                goto windivert_write_hard_error;
            }
            status_soft_error = status;
        }

        // Reset state:
        inject_len += packet_len;
        data        = (PVOID)((UINT8 *)data + packet_len);
        data_len   -= packet_len;
    }

    // Note: status_soft_error is for "soft" errors that do not prevent other
    //       batched packets from being injected.
    WdfRequestCompleteWithInformation(request, status_soft_error, inject_len);
    return STATUS_SUCCESS;

windivert_write_hard_error:

    // Request to be completed in windivert_ioctl()
    return status;
}


/*
 * WinDivert caller context preprocessing.
 */
VOID windivert_caller_context(IN WDFDEVICE device, IN WDFREQUEST request)
{
    PCHAR inbuf;
    size_t inbuflen;
    WDF_REQUEST_PARAMETERS params;
    WDFMEMORY memobj;
    PWINDIVERT_ADDRESS addr = NULL;
    UINT *addr_len_ptr = NULL;
    UINT64 addr_len = 0;
    PWINDIVERT_IOCTL ioctl;
    WDF_OBJECT_ATTRIBUTES attributes;
    req_context_t req_context = NULL;
    NTSTATUS status;

    WDF_REQUEST_PARAMETERS_INIT(&params);
    WdfRequestGetParameters(request, &params);

    if (params.Type != WdfRequestTypeDeviceControl)
    {
        goto windivert_caller_context_exit;
    }

    // Get and verify the input buffer.
    status = WdfRequestRetrieveInputBuffer(request, 0, &inbuf, &inbuflen);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to retrieve input buffer", status);
        goto windivert_caller_context_error;
    }
    if (inbuflen < sizeof(WINDIVERT_IOCTL))
    {
        status = STATUS_INVALID_PARAMETER;
        DEBUG_ERROR("input buffer not an ioctl message header", status);
        goto windivert_caller_context_error;
    }

    // Probe and lock user buffers here (if required).
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&attributes, req_context_s);
    status = WdfObjectAllocateContext(request, &attributes, &req_context);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to allocate request context for ioctl", status);
        goto windivert_caller_context_error;
    }
    switch (params.Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_WINDIVERT_RECV:
            ioctl        = (PWINDIVERT_IOCTL)inbuf;
            addr         = (PWINDIVERT_ADDRESS)(ULONG_PTR)ioctl->recv.addr;
            addr_len_ptr = (UINT *)(ULONG_PTR)ioctl->recv.addr_len_ptr;
            addr_len     = sizeof(WINDIVERT_ADDRESS);
            if (addr_len_ptr != NULL)
            {
                status = WdfRequestProbeAndLockUserBufferForWrite(request,
                    addr_len_ptr, sizeof(UINT), &memobj);
                if (!NT_SUCCESS(status))
                {
                    DEBUG_ERROR("invalid address length pointer for RECV ioctl",
                        status);
                    goto windivert_caller_context_error;
                }
                addr_len_ptr = (UINT *)WdfMemoryGetBuffer(memobj, NULL);
                addr_len     = *addr_len_ptr;
                if (addr_len < sizeof(WINDIVERT_ADDRESS) ||
                    addr_len > WINDIVERT_BATCH_MAX * sizeof(WINDIVERT_ADDRESS))
                {
                    status = STATUS_INVALID_PARAMETER;
                    DEBUG_ERROR("out-of-range address length (%u) for RECV "
                        "ioctl", status, addr_len);
                    goto windivert_caller_context_error;
                }
                if (addr == NULL)
                {
                    status = STATUS_INVALID_PARAMETER;
                    DEBUG_ERROR("null address for RECV ioctl", status);
                    goto windivert_caller_context_error;
                }
            }
            if (addr != NULL)
            {
                status = WdfRequestProbeAndLockUserBufferForWrite(request,
                    addr, (size_t)addr_len, &memobj);
                if (!NT_SUCCESS(status))
                {
                    DEBUG_ERROR("invalid address for RECV ioctl", status);
                    goto windivert_caller_context_error;
                }
                addr = (PWINDIVERT_ADDRESS)WdfMemoryGetBuffer(memobj, NULL);
            }
            break;

        case IOCTL_WINDIVERT_SEND:
            ioctl    = (PWINDIVERT_IOCTL)inbuf;
            addr     = (PWINDIVERT_ADDRESS)(ULONG_PTR)ioctl->send.addr;
            addr_len = ioctl->send.addr_len;
            if (addr_len < sizeof(WINDIVERT_ADDRESS) ||
                addr_len > WINDIVERT_BATCH_MAX * sizeof(WINDIVERT_ADDRESS))
            {
                status = STATUS_INVALID_PARAMETER;
                DEBUG_ERROR("out-of-range address length (%u) for SEND ioctl",
                    status, addr_len);
                goto windivert_caller_context_error;
            }
            if (addr == NULL)
            {
                status = STATUS_INVALID_PARAMETER;
                DEBUG_ERROR("null address for SEND ioctl", status);
                goto windivert_caller_context_error;
            }
            status = WdfRequestProbeAndLockUserBufferForRead(request, addr,
                (size_t)addr_len, &memobj);
            if (!NT_SUCCESS(status))
            {
                DEBUG_ERROR("invalid address for SEND ioctl", status);
                goto windivert_caller_context_error;
            }
            addr = (PWINDIVERT_ADDRESS)WdfMemoryGetBuffer(memobj, NULL);
            break;

        case IOCTL_WINDIVERT_INITIALIZE:
        case IOCTL_WINDIVERT_STARTUP:
        case IOCTL_WINDIVERT_SHUTDOWN:
        case IOCTL_WINDIVERT_SET_PARAM:
        case IOCTL_WINDIVERT_GET_PARAM:
            break;
        
        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            DEBUG_ERROR("failed to complete I/O control; invalid request",
                status);
            goto windivert_caller_context_error;
    }
    
    req_context->addr         = addr;
    req_context->addr_len     = (UINT)addr_len;
    req_context->addr_len_ptr = addr_len_ptr;

windivert_caller_context_exit:

    status = WdfDeviceEnqueueRequest(device, request);
    
windivert_caller_context_error:    
    
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to enqueue request", status);
        WdfRequestComplete(request, status);
    }
}

/*
 * WinDivert I/O control.
 */
extern VOID windivert_ioctl(IN WDFQUEUE queue, IN WDFREQUEST request,
    IN size_t out_length, IN size_t in_length, IN ULONG code)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    PCHAR inbuf, outbuf;
    size_t inbuflen, outbuflen, ioctl_filter_len;
    PWINDIVERT_IOCTL ioctl;
    const WINDIVERT_FILTER *ioctl_filter, *filter;
    req_context_t req_context;
    NTSTATUS status = STATUS_SUCCESS;
    context_t context =
        windivert_context_get(WdfRequestGetFileObject(request));
    UINT64 *valptr;

    UNREFERENCED_PARAMETER(queue);
    UNREFERENCED_PARAMETER(out_length);
    UNREFERENCED_PARAMETER(in_length);

    DEBUG("IOCTL: I/O control request (context=%p)", context);

    // Get the buffers and do sanity checks.
    switch (code)
    {
        case IOCTL_WINDIVERT_INITIALIZE:
        case IOCTL_WINDIVERT_STARTUP:
        case IOCTL_WINDIVERT_SHUTDOWN:
        case IOCTL_WINDIVERT_SET_PARAM:
        case IOCTL_WINDIVERT_GET_PARAM:
            status = WdfRequestRetrieveInputBuffer(request, 0, &inbuf,
                &inbuflen);
            if (!NT_SUCCESS(status))
            {
                DEBUG_ERROR("failed to retrieve input buffer", status);
                goto windivert_ioctl_exit;
            }
            if (inbuflen < sizeof(WINDIVERT_IOCTL))
            {
                status = STATUS_INVALID_PARAMETER;
                DEBUG_ERROR("input buffer too small", status);
                goto windivert_ioctl_exit;
            }
            break;
        default:
            inbuf = NULL;
            inbuflen = 0;
            break;
    }
    switch (code)
    {
        case IOCTL_WINDIVERT_INITIALIZE:
        case IOCTL_WINDIVERT_STARTUP:
        case IOCTL_WINDIVERT_GET_PARAM:
            status = WdfRequestRetrieveOutputBuffer(request, 0, &outbuf,
                &outbuflen);
            if (!NT_SUCCESS(status))
            {
                DEBUG_ERROR("failed to retrieve output buffer", status);
                goto windivert_ioctl_exit;
            }
            break;
        default:
            outbuf = NULL;
            outbuflen = 0;
            break;
    }

    // Handle the ioctl:
    switch (code)
    {
        case IOCTL_WINDIVERT_RECV:
            status = windivert_read(context, request);
            if (NT_SUCCESS(status))
            {
                return;
            }
            break;
        
        case IOCTL_WINDIVERT_SEND:
            
            req_context = windivert_req_context_get(request);
            status = windivert_write(context, request, req_context);
            if (NT_SUCCESS(status))
            {
                return;
            }
            break;

        case IOCTL_WINDIVERT_INITIALIZE:
        {
            PWINDIVERT_VERSION version;
            WINDIVERT_LAYER layer;
            UINT32 priority;
            UINT64 flags;
            INT16 priority16;
            
            ioctl = (PWINDIVERT_IOCTL)inbuf;
            version = (WINDIVERT_VERSION *)outbuf;
            if (outbuflen != sizeof(WINDIVERT_VERSION) ||
                version->magic != WINDIVERT_MAGIC_DLL ||
                version->major < WINDIVERT_VERSION_MAJOR_MIN ||
                (version->bits != 8 * sizeof(UINT32) &&
                 version->bits != 8 * sizeof(UINT64)))
            {
                status = STATUS_INVALID_PARAMETER;
                DEBUG_ERROR("failed to initialize; invalid version buffer",
                    status);
                goto windivert_ioctl_exit;
            }
            
            layer = (WINDIVERT_LAYER)ioctl->initialize.layer;
            priority = ioctl->initialize.priority;
            flags = ioctl->initialize.flags;
            version->magic = WINDIVERT_MAGIC_SYS;
            version->major = WINDIVERT_VERSION_MAJOR;
            version->minor = WINDIVERT_VERSION_MINOR;
            version->bits  = 8 * sizeof(void *);
            
            switch ((UINT32)layer)
            {
                case WINDIVERT_LAYER_NETWORK:
                case WINDIVERT_LAYER_NETWORK_FORWARD:
                case WINDIVERT_LAYER_FLOW:
                case WINDIVERT_LAYER_SOCKET:
                case WINDIVERT_LAYER_REFLECT:
                    break;
                default:
                    status = STATUS_INVALID_PARAMETER;
                    DEBUG_ERROR("failed to set layer; invalid value", status);
                    goto windivert_ioctl_exit;
            }

            if (priority > 2 * WINDIVERT_PRIORITY_MAX)
            {
                status = STATUS_INVALID_PARAMETER;
                DEBUG_ERROR("failed to set priority; value out of range",
                    status);
                goto windivert_ioctl_exit;
            }
            priority16 = (INT16)priority - WINDIVERT_PRIORITY_MAX;
            priority = windivert_context_priority(priority);

            if (!WINDIVERT_FLAGS_VALID(flags))
            {
windivert_ioctl_bad_flags:
                status = STATUS_INVALID_PARAMETER;
                DEBUG_ERROR("failed to set flags; invalid flags value",
                    status);
                goto windivert_ioctl_exit;
            }
            switch ((UINT32)layer)
            {
                case WINDIVERT_LAYER_FLOW:
                case WINDIVERT_LAYER_REFLECT:
                    if ((flags & WINDIVERT_FLAG_SNIFF) == 0 ||
                        (flags & WINDIVERT_FLAG_RECV_ONLY) == 0)
                    {
                        goto windivert_ioctl_bad_flags;
                    }
                    break;

                case WINDIVERT_LAYER_SOCKET:
                    if ((flags & WINDIVERT_FLAG_RECV_ONLY) == 0)
                    {
                        goto windivert_ioctl_bad_flags;
                    }
                    break;

                default:
                    break;
            }

            KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
            if (context->state != WINDIVERT_CONTEXT_STATE_OPENING ||
                    context->initialized)
            {
                KeReleaseInStackQueuedSpinLock(&lock_handle);
                status = STATUS_INVALID_DEVICE_STATE;
                goto windivert_ioctl_exit;
            }
            context->layer = (WINDIVERT_LAYER)layer;
            context->priority16 = priority16;
            context->priority = priority;
            context->flags = flags;
            context->initialized = TRUE;
            KeReleaseInStackQueuedSpinLock(&lock_handle);

            break;
        }

        case IOCTL_WINDIVERT_STARTUP:
        {
            PEPROCESS process;
            LONGLONG timestamp;
            UINT64 filter_flags;
            UINT32 process_id;
            WINDIVERT_LAYER layer;
            UINT8 filter_len;
            WDFDEVICE device;

            ioctl = (PWINDIVERT_IOCTL)inbuf;
            filter_flags = ioctl->startup.flags;
            if ((filter_flags & ~WINDIVERT_FILTER_FLAGS_ALL) != 0)
            {
                status = STATUS_INVALID_PARAMETER;
                DEBUG_ERROR("failed to start filter; invalid flags", status);
                goto windivert_ioctl_exit;
            }
 
            KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
            if (context->state != WINDIVERT_CONTEXT_STATE_OPENING ||
                    !context->initialized)
            {
                KeReleaseInStackQueuedSpinLock(&lock_handle);
                status = STATUS_INVALID_DEVICE_STATE;
                goto windivert_ioctl_exit;
            }
            context->state = WINDIVERT_CONTEXT_STATE_OPEN;
            layer = context->layer;
            process = context->process;
            KeReleaseInStackQueuedSpinLock(&lock_handle);

            ioctl_filter = (const WINDIVERT_FILTER *)outbuf;
            ioctl_filter_len = outbuflen;
            filter = windivert_filter_compile(ioctl_filter, ioctl_filter_len,
                layer);
            if (filter == NULL)
            {
                status = STATUS_INVALID_PARAMETER;
                DEBUG_ERROR("failed to compile filter", status);
                goto windivert_ioctl_exit;
            }
            filter_len = (UINT8)(ioctl_filter_len / sizeof(WINDIVERT_FILTER));
            process_id = (UINT32)(ULONG_PTR)PsGetProcessId(process);
            timestamp = KeQueryPerformanceCounter(NULL).QuadPart;

            KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
            if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
            {
                KeReleaseInStackQueuedSpinLock(&lock_handle);
                windivert_free((PVOID)filter);
                status = STATUS_INVALID_DEVICE_STATE;
                goto windivert_ioctl_exit;
            }
            context->filter                 = filter;
            context->filter_len             = filter_len;
            context->filter_flags           = filter_flags;
            context->reflect.data.Timestamp = timestamp;
            context->reflect.data.ProcessId = process_id;
            context->reflect.data.Layer     = context->layer;
            context->reflect.data.Flags     = context->flags;
            context->reflect.data.Priority  = context->priority16;
            context->reflect.open           = FALSE;
            context->shutdown_recv_enabled  =
                (layer != WINDIVERT_LAYER_REFLECT);
            device = context->device;
            KeReleaseInStackQueuedSpinLock(&lock_handle);

            if (InterlockedIncrement64(&num_opens) == 1)
            {
                PDRIVER_OBJECT driver = WdfDriverWdmGetDriverObject(
                    WdfDeviceGetDriver(device));
                windivert_log_event(process, driver, L"LOAD");
            }
            windivert_reflect_open_event(context);

            status = windivert_install_callouts(context, layer, filter_flags);

            break;
        }

        case IOCTL_WINDIVERT_SHUTDOWN:
        {
            WINDIVERT_SHUTDOWN how;

            ioctl = (PWINDIVERT_IOCTL)inbuf;
            how = (WINDIVERT_SHUTDOWN)ioctl->shutdown.how;
            KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
            if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
            {
                KeReleaseInStackQueuedSpinLock(&lock_handle);
                status = STATUS_INVALID_DEVICE_STATE;
                goto windivert_ioctl_exit;
            }
            switch ((UINT32)how)
            {
                case WINDIVERT_SHUTDOWN_RECV:
                    context->shutdown_recv = TRUE;
                    break;
                case WINDIVERT_SHUTDOWN_SEND:
                    context->shutdown_send = TRUE;
                    break;
                case WINDIVERT_SHUTDOWN_BOTH:
                    context->shutdown_recv = context->shutdown_send = TRUE;
                    break;
                default:
                    KeReleaseInStackQueuedSpinLock(&lock_handle);
                    status = STATUS_INVALID_PARAMETER;
                    DEBUG_ERROR("failed to shutdown handle; invalid how",
                        status);
                    goto windivert_ioctl_exit;
            }
            KeReleaseInStackQueuedSpinLock(&lock_handle);
            windivert_read_service(context);
            break;
        }
 
        case IOCTL_WINDIVERT_SET_PARAM:
        {
            WINDIVERT_PARAM param;
            UINT64 value;

            ioctl = (PWINDIVERT_IOCTL)inbuf;
            param = (WINDIVERT_PARAM)ioctl->set_param.param;
            value = ioctl->set_param.val;
            KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
            if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
            {
                KeReleaseInStackQueuedSpinLock(&lock_handle);
                status = STATUS_INVALID_DEVICE_STATE;
                goto windivert_ioctl_exit;
            }
            switch ((UINT32)param)
            {
                case WINDIVERT_PARAM_QUEUE_LENGTH:
                    if (value < WINDIVERT_PARAM_QUEUE_LENGTH_MIN ||
                        value > WINDIVERT_PARAM_QUEUE_LENGTH_MAX)
                    {
                        KeReleaseInStackQueuedSpinLock(&lock_handle);
                        status = STATUS_INVALID_PARAMETER;
                        DEBUG_ERROR("failed to set queue length; invalid "
                            "value", status);
                        goto windivert_ioctl_exit;
                    }
                    context->packet_queue_maxlength = (ULONG)value;
                    break;

                case WINDIVERT_PARAM_QUEUE_TIME:
                    if (value < WINDIVERT_PARAM_QUEUE_TIME_MIN ||
                        value > WINDIVERT_PARAM_QUEUE_TIME_MAX)
                    {
                        KeReleaseInStackQueuedSpinLock(&lock_handle);
                        status = STATUS_INVALID_PARAMETER;
                        DEBUG_ERROR("failed to set queue time; invalid "
                            "value", status);
                        goto windivert_ioctl_exit;
                    }
                    context->packet_queue_maxcounts =
                        (LONGLONG)value * counts_per_ms;
                    context->packet_queue_maxtime = (ULONG)value;
                    break;

                case WINDIVERT_PARAM_QUEUE_SIZE:
                    if (value < WINDIVERT_PARAM_QUEUE_SIZE_MIN ||
                        value > WINDIVERT_PARAM_QUEUE_SIZE_MAX)
                    {
                        KeReleaseInStackQueuedSpinLock(&lock_handle);
                        status = STATUS_INVALID_PARAMETER;
                        DEBUG_ERROR("failed to set queue size; invalid "
                            "value", status);
                        goto windivert_ioctl_exit;
                    }
                    context->packet_queue_maxsize = (ULONG)value;
                    break;

                default:
                    KeReleaseInStackQueuedSpinLock(&lock_handle);
                    status = STATUS_INVALID_PARAMETER;
                    DEBUG_ERROR("failed to set parameter; invalid parameter",
                        status);
                    goto windivert_ioctl_exit;
            }
            KeReleaseInStackQueuedSpinLock(&lock_handle);
            break;
        }

        case IOCTL_WINDIVERT_GET_PARAM:
        {
            WINDIVERT_PARAM param;

            ioctl = (PWINDIVERT_IOCTL)inbuf;
            param = (WINDIVERT_PARAM)ioctl->get_param.param;
            if (outbuflen != sizeof(UINT64))
            {
                status = STATUS_INVALID_PARAMETER;
                DEBUG_ERROR("failed to get parameter; invalid output "
                    "buffer size", status);
                goto windivert_ioctl_exit;
            }
            valptr = (UINT64 *)outbuf;
            KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
            if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
            {
                KeReleaseInStackQueuedSpinLock(&lock_handle);
                status = STATUS_INVALID_DEVICE_STATE;
                goto windivert_ioctl_exit;
            }
            switch ((UINT32)param)
            {
                case WINDIVERT_PARAM_QUEUE_LENGTH:
                    *valptr = context->packet_queue_maxlength;
                    break;
                case WINDIVERT_PARAM_QUEUE_TIME:
                    *valptr = context->packet_queue_maxtime;
                    break;
                case WINDIVERT_PARAM_QUEUE_SIZE:
                    *valptr = context->packet_queue_maxsize;
                    break;
                case WINDIVERT_PARAM_VERSION_MAJOR:
                    *valptr = WINDIVERT_VERSION_MAJOR;
                    break;
                case WINDIVERT_PARAM_VERSION_MINOR:
                    *valptr = WINDIVERT_VERSION_MINOR;
                    break;
                default:
                    KeReleaseInStackQueuedSpinLock(&lock_handle);
                    status = STATUS_INVALID_PARAMETER;
                    DEBUG_ERROR("failed to get parameter; invalid parameter",
                        status);
                    goto windivert_ioctl_exit;
            }
            KeReleaseInStackQueuedSpinLock(&lock_handle);
            break;
        }

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            DEBUG_ERROR("failed to complete I/O control; invalid request",
                status);
            break;
    }

windivert_ioctl_exit:
    WdfRequestComplete(request, status);
}

/*
 * WinDivert notify function.
 */
static NTSTATUS windivert_notify(IN FWPS_CALLOUT_NOTIFY_TYPE type,
    IN const GUID *filter_key, IN const FWPS_FILTER0 *filter)
{
    UNREFERENCED_PARAMETER(type);
    UNREFERENCED_PARAMETER(filter_key);
    UNREFERENCED_PARAMETER(filter);
    return STATUS_SUCCESS;
}

/*
 * WinDivert get fixed values.
 */
static UINT8 windivert_get_val8(const FWPS_INCOMING_VALUES0 *fixed_vals,
    int idx)
{
    FWP_VALUE0 value = fixed_vals->incomingValue[idx].value;
    return (value.type != FWP_UINT8? 0: value.uint8);
}
static UINT16 windivert_get_val16(const FWPS_INCOMING_VALUES0 *fixed_vals,
    int idx)
{
    FWP_VALUE0 value = fixed_vals->incomingValue[idx].value;
    return (value.type != FWP_UINT16? 0: value.uint16);
}
static UINT32 windivert_get_val32(const FWPS_INCOMING_VALUES0 *fixed_vals,
    int idx)
{
    FWP_VALUE0 value = fixed_vals->incomingValue[idx].value;
    return (value.type != FWP_UINT32? 0: value.uint32);
}
static void windivert_get_ipv4_addr(const FWPS_INCOMING_VALUES0 *fixed_vals,
    int idx, UINT32 *addr)
{
    FWP_VALUE0 value = fixed_vals->incomingValue[idx].value;
    addr[2] = addr[3] = 0;
    if (value.type != FWP_UINT32)
    {
        addr[0] = addr[1] = 0;
    }
    else
    {
        addr[0] = value.uint32;
        addr[1] = 0x0000FFFF;
    }
}
static void windivert_get_ipv6_addr(const FWPS_INCOMING_VALUES0 *fixed_vals,
    int idx, UINT32 *addr)
{
    UINT8 *addr8 = (UINT8 *)addr;
    INT i;
    FWP_VALUE0 value = fixed_vals->incomingValue[idx].value;
    if (value.type != FWP_BYTE_ARRAY16_TYPE)
    {
        addr[0] = addr[1] = addr[2] = addr[3] = 0;
        return;
    }
    for (i = 16-1; i >= 0; i--)
    {
        addr8[16-i-1] = value.byteArray16->byteArray16[i];
    }
}

/*
 * WinDivert classify outbound IPv4 function.
 */
static void windivert_outbound_network_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_NETWORK network_data;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(meta_vals);
    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0 || data == NULL)
    {
        return;
    }

    network_data.IfIdx = windivert_get_val32(fixed_vals,
        FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_INDEX);
    network_data.SubIfIdx = windivert_get_val32(fixed_vals,
        FWPS_FIELD_OUTBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX);
    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_OUTBOUND_IPPACKET_V4_FLAGS) &
            FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_network_classify(context, &network_data, /*ipv4=*/TRUE,
        /*outbound=*/TRUE, loopback, /*reassembled=*/FALSE, /*advance=*/0,
        data, result);
}

/*
 * WinDivert classify outbound IPv6 function.
 */
static void windivert_outbound_network_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_NETWORK network_data;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;
 
    UNREFERENCED_PARAMETER(meta_vals);
    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0 || data == NULL)
    {
        return;
    }

    network_data.IfIdx = windivert_get_val32(fixed_vals,
        FWPS_FIELD_OUTBOUND_IPPACKET_V6_INTERFACE_INDEX);
    network_data.SubIfIdx = windivert_get_val32(fixed_vals,
        FWPS_FIELD_OUTBOUND_IPPACKET_V6_SUB_INTERFACE_INDEX);
    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_OUTBOUND_IPPACKET_V6_FLAGS) &
            FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_network_classify(context, &network_data, /*ipv4=*/FALSE,
        /*outbound=*/TRUE, loopback, /*reassembled=*/FALSE, /*advance=*/0,
        data, result);
}

/*
 * WinDivert classify inbound IPv4 function.
 */
static void windivert_inbound_network_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_NETWORK network_data;
    UINT advance;
    UINT32 flags;
    BOOL fragment, loopback, reassembled;
    context_t context = (context_t)(ULONG_PTR)filter->context;
 
    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0 || data == NULL)
    {
        return;
    }

    flags = windivert_get_val32(fixed_vals,
        FWPS_FIELD_INBOUND_IPPACKET_V4_FLAGS);
    fragment = ((flags & FWP_CONDITION_FLAG_IS_FRAGMENT) != 0);
    if (fragment)
    {
        result->actionType = FWP_ACTION_CONTINUE;
        return;
    }
    loopback = ((flags & FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);
    if (loopback)
    {
        result->actionType = FWP_ACTION_CONTINUE;
        return;
    }
    reassembled = ((flags & FWP_CONDITION_FLAG_IS_REASSEMBLED) != 0);

    network_data.IfIdx = windivert_get_val32(fixed_vals,
        FWPS_FIELD_INBOUND_IPPACKET_V4_INTERFACE_INDEX);
    network_data.SubIfIdx = windivert_get_val32(fixed_vals,
        FWPS_FIELD_INBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX);
    advance = meta_vals->ipHeaderSize;
    
    windivert_network_classify(context, &network_data, /*ipv4=*/TRUE,
        /*outbound=*/FALSE, loopback, reassembled, advance, data, result);
}

/*
 * WinDivert classify inbound IPv6 function.
 */
static void windivert_inbound_network_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_NETWORK network_data;
    UINT advance;
    UINT32 flags;
    BOOL fragment, loopback, reassembled;
    context_t context = (context_t)(ULONG_PTR)filter->context;
 
    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0 || data == NULL)
    {
        return;
    }

    flags = windivert_get_val32(fixed_vals,
        FWPS_FIELD_INBOUND_IPPACKET_V6_FLAGS);
    fragment = ((flags & FWP_CONDITION_FLAG_IS_FRAGMENT) != 0);
    if (fragment)
    {
        result->actionType = FWP_ACTION_CONTINUE;
        return;
    }
    loopback = ((flags & FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);
    if (loopback)
    {
        result->actionType = FWP_ACTION_CONTINUE;
        return;
    }
    reassembled = ((flags & FWP_CONDITION_FLAG_IS_REASSEMBLED) != 0);

    network_data.IfIdx = windivert_get_val32(fixed_vals,
        FWPS_FIELD_INBOUND_IPPACKET_V6_INTERFACE_INDEX);
    network_data.SubIfIdx = windivert_get_val32(fixed_vals,
        FWPS_FIELD_INBOUND_IPPACKET_V6_SUB_INTERFACE_INDEX);
    advance = meta_vals->ipHeaderSize;
    
    windivert_network_classify(context, &network_data, /*ipv4=*/FALSE,
        /*outbound=*/FALSE, loopback, reassembled, advance, data, result);
}

/*
 * WinDivert classify forward IPv4 function.
 */
static void windivert_forward_network_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_NETWORK network_data;
    UINT32 flags;
    BOOL group;
    context_t context = (context_t)(ULONG_PTR)filter->context;
 
    UNREFERENCED_PARAMETER(meta_vals);
    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0 || data == NULL)
    {
        return;
    }
    flags = windivert_get_val32(fixed_vals, FWPS_FIELD_IPFORWARD_V4_FLAGS);
    group = ((flags & FWP_CONDITION_FLAG_IS_FRAGMENT_GROUP) != 0);
    if (group)
    {
        result->actionType = FWP_ACTION_CONTINUE;
        return;
    }
 
    network_data.IfIdx = windivert_get_val32(fixed_vals,
        FWPS_FIELD_IPFORWARD_V4_DESTINATION_INTERFACE_INDEX);
    network_data.SubIfIdx = 0;

    windivert_network_classify(context, &network_data, /*ipv4=*/TRUE,
        /*outbound=*/TRUE, /*loopback=*/FALSE, /*reassembled=*/FALSE,
        /*advance=*/0, data, result);
}

/*
 * WinDivert classify forward IPv6 function.
 */
static void windivert_forward_network_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_NETWORK network_data;
    UINT32 flags;
    BOOL group;
    context_t context = (context_t)(ULONG_PTR)filter->context;
 
    UNREFERENCED_PARAMETER(meta_vals);
    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0 || data == NULL)
    {
        return;
    }
    flags = windivert_get_val32(fixed_vals, FWPS_FIELD_IPFORWARD_V6_FLAGS);
    group = ((flags & FWP_CONDITION_FLAG_IS_FRAGMENT_GROUP) != 0);
    if (group)
    {
        result->actionType = FWP_ACTION_CONTINUE;
        return;
    }

    network_data.IfIdx = windivert_get_val32(fixed_vals,
        FWPS_FIELD_IPFORWARD_V6_DESTINATION_INTERFACE_INDEX);
    network_data.SubIfIdx = 0;

    windivert_network_classify(context, &network_data, /*ipv4=*/FALSE,
        /*outbound=*/TRUE, /*loopback=*/FALSE, /*reassembled=*/FALSE,
        /*advance=*/0, data, result);
}

/*
 * WinDivert network classify function.
 */
static void windivert_network_classify(context_t context,
    IN PWINDIVERT_DATA_NETWORK network_data, IN BOOL ipv4, IN BOOL outbound,
    IN BOOL loopback, IN BOOL reassembled, IN UINT advance, IN OUT void *data,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    FWPS_PACKET_INJECTION_STATE packet_state;
    HANDLE packet_context;
    UINT32 priority, packet_priority;
    UINT64 flags;
    WINDIVERT_LAYER layer;
    PNET_BUFFER_LIST buffers;
    PNET_BUFFER buffer, buffer_fst, buffer_itr;
    BOOL impostor, sniff_mode, frag_mode, ok;
    WDFOBJECT object;
    const WINDIVERT_FILTER *filter;
    LONGLONG timestamp;
    NTSTATUS status;

    result->actionType = FWP_ACTION_CONTINUE;
    buffers = (PNET_BUFFER_LIST)data;
    buffer = NET_BUFFER_LIST_FIRST_NB(buffers);
    if (NET_BUFFER_LIST_NEXT_NBL(buffers) != NULL)
    {
        // This is a fragment group.  This can be ignored since each fragment
        // should have already been indicated.
        return;
    }
    if (ipv4)
    {
        if (context->layer == WINDIVERT_LAYER_NETWORK_FORWARD)
        {
            packet_state = FwpsQueryPacketInjectionState0(inject_handle_forward,
                buffers, &packet_context);
        }
        else if (outbound)
        {
            packet_state = FwpsQueryPacketInjectionState0(inject_handle_out,
                buffers, &packet_context);
        }
        else
        {
            packet_state = FwpsQueryPacketInjectionState0(inject_handle_in,
                buffers, &packet_context);
        }
    }
    else
    {
        if (context->layer == WINDIVERT_LAYER_NETWORK_FORWARD)
        {
            packet_state = FwpsQueryPacketInjectionState0(
                injectv6_handle_forward, buffers, &packet_context);
        }
        else if (outbound)
        {
            packet_state = FwpsQueryPacketInjectionState0(injectv6_handle_out,
                buffers, &packet_context);
        }
        else
        {
            packet_state = FwpsQueryPacketInjectionState0(injectv6_handle_in,
                buffers, &packet_context);
        }
    }

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN ||
        context->shutdown_recv)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        return;
    }
    flags = context->flags;
    priority = context->priority;
    filter = context->filter;
    layer = context->layer;
    object = (WDFOBJECT)context->object;
    WdfObjectReference(object);
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    impostor = FALSE;
    if (packet_state == FWPS_PACKET_INJECTED_BY_SELF ||
        packet_state == FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF)
    {
        packet_priority = (UINT32)(ULONG_PTR)packet_context;
        if (packet_priority <= priority)
        {
            WdfObjectDereference(object);
            return;
        }
    }
    else if (packet_state == FWPS_PACKET_INJECTED_BY_OTHER)
    {
        // This is a packet injected by another driver, possibly an older
        // version of WinDivert.  To prevent block-clone-reinject infinite
        // loops, we mark this packet as an "impostor".
        impostor = TRUE;
    }

    // Get the timestamp.
    timestamp = KeQueryPerformanceCounter(NULL).QuadPart;

    // Filter fragments or reassembled packets.
    frag_mode =
        (outbound || layer == WINDIVERT_LAYER_NETWORK_FORWARD? TRUE:
            (flags & WINDIVERT_FLAG_FRAGMENTS) != 0);
    if (frag_mode && reassembled)
    {
        WdfObjectDereference(object);
        return;
    }

    // Retreat the NET_BUFFER to the IP header, if necessary.
    // If (advance != 0) then this must be in the inbound path, and the
    // NET_BUFFER_LIST must contain exactly one NET_BUFFER.
    if (advance != 0)
    {
        status = NdisRetreatNetBufferDataStart(buffer, advance, 0, NULL);
        if (!NT_SUCCESS(status))
        {
            WdfObjectDereference(object);
            return;
        }
    }

    /*
     * This code is complicated by the fact the a single NET_BUFFER_LIST
     * may contain several NET_BUFFER structures.  Each NET_BUFFER needs to
     * be filtered independently.  To achieve this we do the following:
     * 1) First check if any NET_BUFFER passes the filter.
     * 2) If no, then CONTINUE the entire NET_BUFFER_LIST.
     * 3) Else, split the NET_BUFFER_LIST into individual NET_BUFFERs; and
     *    either queue or re-inject based on the filter.
     */

    // Find the first NET_BUFFER we need to queue:
    buffer_fst = buffer;
    do
    {
        BOOL match = windivert_filter(buffer_fst, layer, (PVOID)network_data,
            timestamp, /*event=*/WINDIVERT_EVENT_NETWORK_PACKET, ipv4,
            outbound, loopback, impostor, frag_mode, filter);
        if (match)
        {
            break;
        }
        buffer_fst = NET_BUFFER_NEXT_NB(buffer_fst);
    }
    while (buffer_fst != NULL);

    // If no packet matches the filter, CONTINUE the entire NET_BUFFER_LIST.
    if (buffer_fst == NULL)
    {
        WdfObjectDereference(object);
        if (advance != 0)
        {
            NdisAdvanceNetBufferDataStart(buffer, advance, FALSE, NULL);
        }
        return;
    }

    // At least one packet matches the filter.  Queue or re-inject all
    // packets depending on whether they match the filter or not.

    // STEP (1): Queue all non-matching packets up to buffer_fst.
    buffer_itr = buffer;
    sniff_mode = ((flags & WINDIVERT_FLAG_SNIFF) != 0);
    while (!sniff_mode && buffer_itr != buffer_fst)
    {
        ok = windivert_queue_work(context, (PVOID)buffer_itr,
            NET_BUFFER_DATA_LENGTH(buffer_itr), buffers, /*object=*/NULL, layer,
            (PVOID)network_data, /*event=*/WINDIVERT_EVENT_NETWORK_PACKET,
            flags, priority, ipv4, outbound, loopback, impostor,
            /*match=*/FALSE, timestamp);
        if (!ok)
        {
            goto windivert_network_classify_exit;
        }
        buffer_itr = NET_BUFFER_NEXT_NB(buffer_itr);
    }

    // STEP (2): Queue the first matching packet buffer_fst:
    ok = windivert_queue_work(context, (PVOID)buffer_itr,
        NET_BUFFER_DATA_LENGTH(buffer_itr), buffers, /*object=*/NULL, layer,
        (PVOID)network_data, /*event=*/WINDIVERT_EVENT_NETWORK_PACKET,
        flags, priority, ipv4, outbound, loopback, impostor, /*match=*/TRUE,
        timestamp);
    if (advance != 0)
    {
        // Advance the NET_BUFFER to its original position.  Note that we can
        // do this here, since if (advance != 0) then there is only one
        // NET_BUFFER in the NET_BUFFER_LIST, meaning that STEPS (1) and (3)
        // will be empty.
        NdisAdvanceNetBufferDataStart(buffer, advance, FALSE, NULL);
    }
    if (!ok)
    {
        goto windivert_network_classify_exit;
    }

    // STEP (3): Queue all remaining packets:
    buffer_itr = NET_BUFFER_NEXT_NB(buffer_fst);
    while (buffer_itr != NULL)
    {
        BOOL match = windivert_filter(buffer_itr, layer, (PVOID)network_data,
            timestamp, /*event=*/WINDIVERT_EVENT_NETWORK_PACKET, ipv4,
            outbound, loopback, impostor, frag_mode, filter);
        ok = windivert_queue_work(context, (PVOID)buffer_itr,
            NET_BUFFER_DATA_LENGTH(buffer_itr), buffers, /*object=*/NULL, layer,
            (PVOID)network_data, /*event=*/WINDIVERT_EVENT_NETWORK_PACKET,
            flags, priority, ipv4, outbound, loopback, impostor, match,
            timestamp);
        if (!ok)
        {
            goto windivert_network_classify_exit;
        }
        buffer_itr = NET_BUFFER_NEXT_NB(buffer_itr);
    }

windivert_network_classify_exit:

    WdfObjectDereference(object);
    if (!sniff_mode)
    {
        result->actionType = FWP_ACTION_BLOCK;
        result->flags |= FWPS_CLASSIFY_OUT_FLAG_ABSORB;
        result->rights &= ~FWPS_RIGHT_ACTION_WRITE;
    }
}

/*
 * WinDivert classify flow established IPv4 function.
 */
static void windivert_flow_established_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_FLOW flow_data;
    BOOL outbound, loopback;
    UINT64 flow_id;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    flow_data.EndpointId = meta_vals->transportEndpointHandle;
    flow_data.ParentEndpointId = meta_vals->parentEndpointHandle;
    flow_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv4_addr(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_ADDRESS,
        flow_data.LocalAddr);
    windivert_get_ipv4_addr(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_ADDRESS,
        flow_data.RemoteAddr);
    flow_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_PORT);
    flow_data.RemotePort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_PORT);
    flow_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_PROTOCOL);

    outbound = (windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_DIRECTION) ==
        FWP_DIRECTION_OUTBOUND);
    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_FLAGS) &
        FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);
    flow_id = meta_vals->flowHandle;

    windivert_flow_established_classify(context, flow_id, &flow_data,
        /*ipv4=*/TRUE, outbound, loopback, result);
}

/*
 * WinDivert classify flow established IPv6 function.
 */
static void windivert_flow_established_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_FLOW flow_data;
    BOOL outbound, loopback;
    UINT64 flow_id;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    flow_data.EndpointId = meta_vals->transportEndpointHandle;
    flow_data.ParentEndpointId = meta_vals->parentEndpointHandle;
    flow_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv6_addr(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_ADDRESS,
        flow_data.LocalAddr);
    windivert_get_ipv6_addr(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_ADDRESS,
        flow_data.RemoteAddr);
    flow_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_PORT);
    flow_data.RemotePort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_PORT);
    flow_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_PROTOCOL);
    
    outbound = (windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_DIRECTION) ==
        FWP_DIRECTION_OUTBOUND);
    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_FLAGS) &
        FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);
    flow_id = meta_vals->flowHandle;
    
    windivert_flow_established_classify(context, flow_id, &flow_data,
        /*ipv4=*/FALSE, outbound, loopback, result);
}

/*
 * WinDivert flow established classify function.
 */
static void windivert_flow_established_classify(context_t context,
    IN UINT64 flow_id, IN PWINDIVERT_DATA_FLOW flow_data, IN BOOL ipv4,
    IN BOOL outbound, IN BOOL loopback, OUT FWPS_CLASSIFY_OUT0 *result)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    UINT64 flags, filter_flags;
    UINT32 callout_id;
    UINT16 layer_id;
    BOOL match, ok;
    WDFOBJECT object;
    const WINDIVERT_FILTER *filter;
    LONGLONG timestamp;
    flow_t flow;
    NTSTATUS status;

    // Basic checks:
    if (!(result->rights & FWPS_RIGHT_ACTION_WRITE))
    {
        return;
    }

    // Get the timestamp.
    timestamp = KeQueryPerformanceCounter(NULL).QuadPart;
    
    result->actionType = FWP_ACTION_CONTINUE;

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN ||
        context->shutdown_recv)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        return;
    }
    filter = context->filter;
    flags = context->flags;
    filter_flags = context->filter_flags;
    callout_id = (ipv4? context->flow_v4_callout_id:
        context->flow_v6_callout_id);
    object = (WDFOBJECT)context->object;

    // Reference only released once the flow has been deleted.  This is to
    // prevent the callout being unregistered while flow deletions are still
    // pending, causing the operation to fail with STATUS_DEVICE_BUSY.
    WdfObjectReference(object);
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    match = windivert_filter(/*buffer=*/NULL, /*layer=*/WINDIVERT_LAYER_FLOW,
        (PVOID)flow_data, timestamp,
        /*event=*/WINDIVERT_EVENT_FLOW_ESTABLISHED, ipv4, outbound, loopback,
        /*impostor=*/FALSE, /*frag_mode=*/FALSE, filter);
    if (match)
    {
        ok = windivert_queue_work(context, /*packet=*/NULL, /*packet_len=*/0,
            /*buffers=*/NULL, /*object=*/NULL, /*layer=*/WINDIVERT_LAYER_FLOW,
            (PVOID)flow_data, /*event=*/WINDIVERT_EVENT_FLOW_ESTABLISHED,
            flags, /*priority=*/0, ipv4, outbound, loopback, /*impostor=*/FALSE,
            match, timestamp);
        if (!ok)
        {
            WdfObjectDereference(object);
            return;
        }
    }

    // Associate a context with the flow.  This is so we can detect the
    // FLOW_DELETED event.
    if ((filter_flags & WINDIVERT_FILTER_FLAG_EVENT_FLOW_DELETED) == 0)
    {
        // We don't care about FLOW_DELETED.
        WdfObjectDereference(object);
        return;
    }
    flow = windivert_malloc(sizeof(struct flow_s), FALSE);
    if (flow == NULL)
    {
        WdfObjectDereference(object);
        return;
    }
    layer_id = (ipv4? FWPS_LAYER_ALE_FLOW_ESTABLISHED_V4:
                      FWPS_LAYER_ALE_FLOW_ESTABLISHED_V6);
    flow->context = context;
    flow->flow_id = flow_id;
    flow->callout_id = callout_id;
    flow->layer_id = layer_id;
    flow->inserted = FALSE;
    flow->deleted = FALSE;
    flow->outbound = outbound;
    flow->loopback = loopback;
    flow->ipv6 = !ipv4;
    RtlCopyMemory(&flow->data, flow_data, sizeof(flow->data));

    status = FwpsFlowAssociateContext0(flow_id, layer_id, callout_id,
        (UINT64)flow);
    if (!NT_SUCCESS(status))
    {
        windivert_free(flow);
        WdfObjectDereference(object);
        return;
    }

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN ||
        context->shutdown_recv)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        windivert_free(flow);
        WdfObjectDereference(object);
        return;
    }
    if (!flow->deleted)
    {
        InsertTailList(&context->flow_set, &flow->entry);
        flow->inserted = TRUE;
    }
    else
    {
        // Flow was deleted before insertion; we are responsible for cleanup.
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        windivert_free(flow);
        WdfObjectDereference(object);
        return;
    }
    KeReleaseInStackQueuedSpinLock(&lock_handle);
}

/*
 * WinDivert flow delete notify function.
 */
static void windivert_flow_delete_notify(UINT16 layer_id, UINT32 callout_id,
    UINT64 flow_context)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    UINT64 flags;
    BOOL match, cleanup;
    WDFOBJECT object;
    context_t context;
    const WINDIVERT_FILTER *filter;
    LONGLONG timestamp;
    flow_t flow;

    UNREFERENCED_PARAMETER(layer_id);
    UNREFERENCED_PARAMETER(callout_id);
 
    flow = (flow_t)(ULONG_PTR)flow_context;
    if (flow == NULL)
    {
        return;
    }

    timestamp = KeQueryPerformanceCounter(NULL).QuadPart;
    context = flow->context;

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    object = (WDFOBJECT)context->object; // referenced in flow_established.
    if (flow->inserted && !flow->deleted)
    {
        RemoveEntryList(&flow->entry);
    }
    flow->deleted = TRUE;
    cleanup = flow->inserted;
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN ||
        context->shutdown_recv)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        goto windivert_flow_delete_notify_exit;
    }
    filter = context->filter;
    flags = context->flags;
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    match = windivert_filter(/*buffer=*/NULL, /*layer=*/WINDIVERT_LAYER_FLOW,
        (PVOID)&flow->data, timestamp, /*event=*/WINDIVERT_EVENT_FLOW_DELETED,
        !flow->ipv6, flow->outbound, flow->loopback, /*impostor=*/FALSE,
        /*frag_mode=*/FALSE, filter);
    if (match)
    {
        (VOID)windivert_queue_work(context, /*packet=*/NULL, /*packet_len=*/0,
            /*buffers=*/NULL, /*object=*/NULL, /*layer=*/WINDIVERT_LAYER_FLOW,
            (PVOID)&flow->data, /*event=*/WINDIVERT_EVENT_FLOW_DELETED, flags,
            /*priority=*/0, !flow->ipv6, flow->outbound, flow->loopback,
            /*impostor=*/FALSE, match, timestamp);
    }

windivert_flow_delete_notify_exit:

    if (cleanup)
    {
        windivert_free(flow);
        WdfObjectDereference(object);
    }
}

/*
 * WinDivert classify resource assignment IPv4 function.
 */
static void windivert_resource_assignment_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0)
    {
        return;
    }

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = 0;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv4_addr(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    RtlZeroMemory(&socket_data.RemoteAddr, sizeof(socket_data.RemoteAddr));
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_PORT);
    socket_data.RemotePort = 0;
    socket_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_PROTOCOL);

    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_FLAGS) &
        FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_BIND, /*ipv4=*/TRUE,
        /*outbound=*/TRUE, loopback, result);
}

/*
 * WinDivert classify resource assignment IPv6 function.
 */
static void windivert_resource_assignment_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0)
    {
        return;
    }

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = 0;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv6_addr(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    RtlZeroMemory(&socket_data.RemoteAddr, sizeof(socket_data.RemoteAddr));
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_PORT);
    socket_data.RemotePort = 0;
    socket_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_PROTOCOL);

    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_FLAGS) &
        FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_BIND, /*ipv4=*/FALSE,
        /*outbound=*/TRUE, loopback, result);
}

/*
 * WinDivert classify resource release IPv4 function.
 */
static void windivert_resource_release_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = 0;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv4_addr(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_RELEASE_V4_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    RtlZeroMemory(&socket_data.RemoteAddr, sizeof(socket_data.RemoteAddr));
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_RELEASE_V4_IP_LOCAL_PORT);
    socket_data.RemotePort = 0;
    socket_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_RELEASE_V4_IP_PROTOCOL);

    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_RELEASE_V4_FLAGS) &
        FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_CLOSE, /*ipv4=*/TRUE,
        /*outbound=*/TRUE, loopback, result);
}

/*
 * WinDivert classify resource release IPv6 function.
 */
static void windivert_resource_release_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = 0;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv6_addr(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_RELEASE_V6_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    RtlZeroMemory(&socket_data.RemoteAddr, sizeof(socket_data.RemoteAddr));
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_RELEASE_V6_IP_LOCAL_PORT);
    socket_data.RemotePort = 0;
    socket_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_RELEASE_V6_IP_PROTOCOL);

    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_RESOURCE_RELEASE_V6_FLAGS) &
        FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_CLOSE, /*ipv4=*/FALSE,
        /*outbound=*/TRUE, loopback, result);
}

/*
 * WinDivert classify auth connect IPv4 function.
 */
static void windivert_auth_connect_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    UINT32 flags;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0)
    {
        return;
    }
    flags = windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_FLAGS);
    if ((flags & FWP_CONDITION_FLAG_IS_REAUTHORIZE) != 0)
    {
        result->actionType = FWP_ACTION_CONTINUE;
        return;
    }

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = meta_vals->parentEndpointHandle;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv4_addr(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    windivert_get_ipv4_addr(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_ADDRESS,
        socket_data.RemoteAddr);
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_PORT);
    socket_data.RemotePort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_PORT);
    socket_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_PROTOCOL);

    loopback = ((flags & FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_CONNECT, /*ipv4=*/TRUE,
        /*outbound=*/TRUE, loopback, result);
}

/*
 * WinDivert classify auth connect IPv6 function.
 */
static void windivert_auth_connect_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    UINT32 flags;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0)
    {
        return;
    }
    flags = windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_FLAGS);
    if ((flags & FWP_CONDITION_FLAG_IS_REAUTHORIZE) != 0)
    {
        result->actionType = FWP_ACTION_CONTINUE;
        return;
    }

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = meta_vals->parentEndpointHandle;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv6_addr(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    windivert_get_ipv6_addr(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_ADDRESS,
        socket_data.RemoteAddr);
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_PORT);
    socket_data.RemotePort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_PORT);
    socket_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_PROTOCOL);

    loopback = ((flags & FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_CONNECT, /*ipv4=*/FALSE,
        /*outbound=*/TRUE, loopback, result);
}

/*
 * WinDivert classify endpoint closure IPv4 function.
 */
static void windivert_endpoint_closure_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = meta_vals->parentEndpointHandle;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv4_addr(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V4_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    windivert_get_ipv4_addr(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V4_IP_REMOTE_ADDRESS,
        socket_data.RemoteAddr);
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V4_IP_LOCAL_PORT);
    socket_data.RemotePort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V4_IP_REMOTE_PORT);
    socket_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V4_IP_PROTOCOL);

    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V4_FLAGS) &
        FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_CLOSE, /*ipv4=*/TRUE,
        /*outbound=*/TRUE, loopback, result);
}

/*
 * WinDivert classify endpoint closure IPv6 function.
 */
static void windivert_endpoint_closure_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = meta_vals->parentEndpointHandle;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv6_addr(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V6_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    windivert_get_ipv6_addr(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V6_IP_REMOTE_ADDRESS,
        socket_data.RemoteAddr);
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V6_IP_LOCAL_PORT);
    socket_data.RemotePort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V6_IP_REMOTE_PORT);
    socket_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V6_IP_PROTOCOL);

    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_ENDPOINT_CLOSURE_V6_FLAGS) &
        FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_CLOSE, /*ipv4=*/FALSE,
        /*outbound=*/TRUE, loopback, result);
}

/*
 * WinDivert classify auth listen IPv4 function.
 */
static void windivert_auth_listen_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0)
    {
        return;
    }

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = 0;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv4_addr(fixed_vals,
        FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    RtlZeroMemory(&socket_data.RemoteAddr, sizeof(socket_data.RemoteAddr));
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_PORT);
    socket_data.RemotePort = 0;
    socket_data.Protocol = IPPROTO_TCP;

    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_AUTH_LISTEN_V4_FLAGS) &
        FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_LISTEN, /*ipv4=*/TRUE,
        /*outbound=*/TRUE, loopback, result);
}

/*
 * WinDivert classify auth listen IPv6 function.
 */
static void windivert_auth_listen_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0)
    {
        return;
    }

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = 0;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv6_addr(fixed_vals,
        FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    RtlZeroMemory(&socket_data.RemoteAddr, sizeof(socket_data.RemoteAddr));
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_PORT);
    socket_data.RemotePort = 0;
    socket_data.Protocol = IPPROTO_TCP;

    loopback = ((windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_AUTH_LISTEN_V6_FLAGS) &
        FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_LISTEN, /*ipv4=*/FALSE,
        /*outbound=*/TRUE, loopback, result);
}

/*
 * WinDivert classify auth recv accept IPv4 function.
 */
static void windivert_auth_recv_accept_v4_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    UINT32 flags;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;

    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0)
    {
        return;
    }
    flags = windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_FLAGS);
    if ((flags & FWP_CONDITION_FLAG_IS_REAUTHORIZE) != 0)
    {
        result->actionType = FWP_ACTION_CONTINUE;
        return;
    }

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = meta_vals->parentEndpointHandle;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv4_addr(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    windivert_get_ipv4_addr(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_ADDRESS,
        socket_data.RemoteAddr);
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_PORT);
    socket_data.RemotePort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_PORT);
    socket_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_PROTOCOL);

    loopback = ((flags & FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_ACCEPT, /*ipv4=*/TRUE,
        /*outbound=*/FALSE, loopback, result);
}

/*
 * WinDivert classify auth recv accept IPv6 function.
 */
static void windivert_auth_recv_accept_v6_classify(
    IN const FWPS_INCOMING_VALUES0 *fixed_vals,
    IN const FWPS_INCOMING_METADATA_VALUES0 *meta_vals, IN OUT void *data,
    const FWPS_FILTER0 *filter, IN UINT64 flow_context,
    OUT FWPS_CLASSIFY_OUT0 *result)
{
    WINDIVERT_DATA_SOCKET socket_data;
    UINT32 flags;
    BOOL loopback;
    context_t context = (context_t)(ULONG_PTR)filter->context;
    
    UNREFERENCED_PARAMETER(data);
    UNREFERENCED_PARAMETER(flow_context);

    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) == 0)
    {
        return;
    }
    flags = windivert_get_val32(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_FLAGS);
    if ((flags & FWP_CONDITION_FLAG_IS_REAUTHORIZE) != 0)
    {
        result->actionType = FWP_ACTION_CONTINUE;
        return;
    }

    socket_data.EndpointId = meta_vals->transportEndpointHandle;
    socket_data.ParentEndpointId = meta_vals->parentEndpointHandle;
    socket_data.ProcessId = (UINT32)meta_vals->processId;
    windivert_get_ipv6_addr(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_ADDRESS,
        socket_data.LocalAddr);
    windivert_get_ipv6_addr(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_ADDRESS,
        socket_data.RemoteAddr);
    socket_data.LocalPort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_PORT);
    socket_data.RemotePort = windivert_get_val16(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_PORT);
    socket_data.Protocol = windivert_get_val8(fixed_vals,
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_PROTOCOL);

    loopback = ((flags & FWP_CONDITION_FLAG_IS_LOOPBACK) != 0);

    windivert_socket_classify(context, &socket_data,
        /*event=*/WINDIVERT_EVENT_SOCKET_ACCEPT, /*ipv4=*/FALSE,
        /*outbound=*/FALSE, loopback, result);
}

/*
 * WinDivert socket classify function.
 */
static void windivert_socket_classify(context_t context,
    PWINDIVERT_DATA_SOCKET socket_data, WINDIVERT_EVENT event, BOOL ipv4,
    BOOL outbound, BOOL loopback, FWPS_CLASSIFY_OUT0 *result)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    UINT64 flags;
    BOOL match, ok;
    WDFOBJECT object;
    const WINDIVERT_FILTER *filter;
    LONGLONG timestamp;

    // Get the timestamp.
    timestamp = KeQueryPerformanceCounter(NULL).QuadPart;
    
    if ((result->rights & FWPS_RIGHT_ACTION_WRITE) != 0)
    {
        result->actionType = FWP_ACTION_CONTINUE;
    }

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN ||
        context->shutdown_recv)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        return;
    }
    filter = context->filter;
    flags = context->flags;
    object = (WDFOBJECT)context->object;
    WdfObjectReference(object);
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    match = windivert_filter(/*buffer=*/NULL, /*layer=*/WINDIVERT_LAYER_SOCKET,
        (PVOID)socket_data, timestamp, event, ipv4, outbound, loopback,
        /*impostor=*/FALSE, /*frag_mode=*/FALSE, filter);
    if (match)
    {
        ok = windivert_queue_work(context, /*packet=*/NULL, /*packet_len=*/0,
            /*buffers=*/NULL, /*object=*/NULL, /*layer=*/WINDIVERT_LAYER_SOCKET,
            (PVOID)socket_data, event, flags, /*priority=*/0, ipv4, outbound,
            loopback, /*impostor=*/FALSE, match, timestamp);
        if (!ok)
        {
            WdfObjectDereference(object);
            return;
        }
    }

    WdfObjectDereference(object);
    if (match && (result->rights & FWPS_RIGHT_ACTION_WRITE) != 0 &&
        event != WINDIVERT_EVENT_SOCKET_CLOSE &&
        (flags & WINDIVERT_FLAG_SNIFF) == 0)
    {
        result->actionType = FWP_ACTION_BLOCK;
        result->flags |= FWPS_CLASSIFY_OUT_FLAG_ABSORB;
        result->rights &= ~FWPS_RIGHT_ACTION_WRITE;
    }
}

/*
 * WinDivert work item routine for out-of-band filtering.
 */
VOID windivert_worker(IN WDFWORKITEM item)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    WDFFILEOBJECT object = (WDFFILEOBJECT)WdfWorkItemGetParentObject(item);
    context_t context = windivert_context_get(object);
    PLIST_ENTRY entry;
    packet_t work;

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    while (context->state == WINDIVERT_CONTEXT_STATE_OPEN &&
            !IsListEmpty(&context->work_queue))
    {
        entry = RemoveHeadList(&context->work_queue);
        context->work_queue_length--;
        KeReleaseInStackQueuedSpinLock(&lock_handle);

        work = CONTAINING_RECORD(entry, struct packet_s, entry);
        if (work->match)
        {
            windivert_queue_packet(context, work);
        }
        else
        {
            windivert_inject_packet(work);
        }

        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    }
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    windivert_read_service(context);
}

/*
 * Queue work.
 */
static BOOL windivert_queue_work(context_t context, PVOID packet,
    ULONG packet_len, PNET_BUFFER_LIST buffers, PVOID object,
    WINDIVERT_LAYER layer, PVOID layer_data, WINDIVERT_EVENT event,
    UINT64 flags, UINT32 priority, BOOL ipv4, BOOL outbound, BOOL loopback,
    BOOL impostor, BOOL match, LONGLONG timestamp)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    PNET_BUFFER buffer;
    packet_t work;
    ULONG packet_size;
    UINT8 *data;
    PLIST_ENTRY old_entry;
    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO checksums;
    PWINDIVERT_DATA_NETWORK network_data;
    PWINDIVERT_DATA_FLOW flow_data;
    PWINDIVERT_DATA_SOCKET socket_data;
    PWINDIVERT_DATA_REFLECT reflect_data;
    BOOL sniffed, ip_checksum, tcp_checksum, udp_checksum;
    WDFREQUEST request = NULL;
    NTSTATUS status;

    sniffed = ((flags & WINDIVERT_FLAG_SNIFF) != 0 ||
        event == WINDIVERT_EVENT_SOCKET_CLOSE);

    if (!match && sniffed)
    {
        return TRUE;
    }
    if (match && (flags & WINDIVERT_FLAG_DROP) != 0)
    {
        return TRUE;
    }

    // Check for fast-path:
    if (match)
    {
        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
        if (context->state == WINDIVERT_CONTEXT_STATE_OPEN &&
            !context->shutdown_recv && IsListEmpty(&context->packet_queue) &&
            IsListEmpty(&context->work_queue))
        {
            status = WdfIoQueueRetrieveNextRequest(context->read_queue,
                &request);
            request = (!NT_SUCCESS(status)? NULL: request);
        }
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        if (request != NULL)
        {
            windivert_fast_read_service_request(packet, packet_len, buffers,
                layer, layer_data, event, flags, ipv4, outbound, loopback,
                impostor, timestamp, request);
            return TRUE;
        }
    }

    // Copy the packet & layer data.
    switch (layer)
    {
        case WINDIVERT_LAYER_NETWORK:
        case WINDIVERT_LAYER_NETWORK_FORWARD:
            buffer = (PNET_BUFFER)packet;
            network_data = (PWINDIVERT_DATA_NETWORK)layer_data;
            if (packet_len > WINDIVERT_MTU_MAX)
            {
                // Cannot handle oversized packet
                return TRUE;
            }
            packet_size = WINDIVERT_PACKET_SIZE(WINDIVERT_DATA_NETWORK,
                packet_len);
            work = (packet_t)windivert_malloc(packet_size, FALSE);
            if (work == NULL)
            {
                return TRUE;
            }
            work->packet_len = (UINT32)packet_len;
            data = WINDIVERT_LAYER_DATA_PTR(work);
            RtlCopyMemory(data, network_data, sizeof(WINDIVERT_DATA_NETWORK));
            data = WINDIVERT_PACKET_DATA_PTR(WINDIVERT_DATA_NETWORK, work);
            if (!windivert_copy_data(buffer, data, packet_len))
            {
                windivert_free(work);
                return TRUE;
            }
            checksums.Value = NET_BUFFER_LIST_INFO(buffers,
                TcpIpChecksumNetBufferListInfo);
            if (outbound)
            {
                ip_checksum = (checksums.Transmit.IpHeaderChecksum == 0);
                tcp_checksum = (checksums.Transmit.TcpChecksum == 0);
                udp_checksum = (checksums.Transmit.UdpChecksum == 0);
            }
            else
            {
                ip_checksum = (checksums.Receive.IpChecksumSucceeded == 0);
                tcp_checksum = (checksums.Receive.TcpChecksumSucceeded == 0);
                udp_checksum = (checksums.Receive.UdpChecksumSucceeded == 0);
            }
            break;

        case WINDIVERT_LAYER_FLOW:
            flow_data = (PWINDIVERT_DATA_FLOW)layer_data;
            packet_size = WINDIVERT_PACKET_SIZE(WINDIVERT_DATA_FLOW, 0);
            work = (packet_t)windivert_malloc(packet_size, FALSE);
            if (work == NULL)
            {
                return TRUE;
            }
            work->packet_len = 0;
            data = WINDIVERT_LAYER_DATA_PTR(work);
            RtlCopyMemory(data, flow_data, sizeof(WINDIVERT_DATA_FLOW));
            ip_checksum = tcp_checksum = udp_checksum = FALSE;
            break;
 
        case WINDIVERT_LAYER_SOCKET:
            socket_data = (PWINDIVERT_DATA_SOCKET)layer_data;
            packet_size = WINDIVERT_PACKET_SIZE(WINDIVERT_DATA_SOCKET, 0);
            work = (packet_t)windivert_malloc(packet_size, FALSE);
            if (work == NULL)
            {
                return TRUE;
            }
            work->packet_len = 0;
            data = WINDIVERT_LAYER_DATA_PTR(work);
            RtlCopyMemory(data, socket_data, sizeof(WINDIVERT_DATA_SOCKET));
            ip_checksum = tcp_checksum = udp_checksum = FALSE;
            break;

        case WINDIVERT_LAYER_REFLECT:
            reflect_data = (PWINDIVERT_DATA_REFLECT)layer_data;
            packet_size = WINDIVERT_PACKET_SIZE(WINDIVERT_DATA_REFLECT,
                packet_len);
            work = (packet_t)windivert_malloc(packet_size, FALSE);
            if (work == NULL)
            {
                return TRUE;
            }
            work->packet_len = packet_len;
            data = WINDIVERT_LAYER_DATA_PTR(work);
            RtlCopyMemory(data, reflect_data, sizeof(WINDIVERT_DATA_REFLECT));
            data = WINDIVERT_PACKET_DATA_PTR(WINDIVERT_DATA_REFLECT, work);
            RtlCopyMemory(data, packet, packet_len);
            ip_checksum = tcp_checksum = udp_checksum = FALSE;
            break;

        default:
            return TRUE;
    }

    work->layer         = layer;
    work->event         = event;
    work->sniffed       = (sniffed? 1: 0);
    work->outbound      = (outbound? 1: 0);
    work->loopback      = (loopback? 1: 0);
    work->impostor      = (impostor? 1: 0);
    work->ipv6          = (!ipv4? 1: 0);
    work->ip_checksum   = (ip_checksum? 1: 0);
    work->tcp_checksum  = (tcp_checksum? 1: 0);
    work->udp_checksum  = (udp_checksum? 1: 0);
    work->icmp_checksum = 1;
    work->match         = match;
    work->packet_size   = packet_size;
    work->priority      = priority;
    work->timestamp     = timestamp;
    work->object        = object;
    if (object != NULL)
    {
        ObfReferenceObject(object);
    }

    old_entry = NULL;
    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        windivert_free_packet(work);
        return FALSE;
    }
    if (context->shutdown_recv && context->shutdown_recv_enabled)
    {
        if ((flags & WINDIVERT_FLAG_SNIFF) != 0)
        {
            KeReleaseInStackQueuedSpinLock(&lock_handle);
            windivert_free_packet(work);
            return FALSE;
        }
        work->match = FALSE;
    }
    context->work_queue_length++;
    if (context->work_queue_length > WINDIVERT_WORK_QUEUE_LENGTH_MAX)
    {
        // The work queue is full; as an emergency we drop packets.
        old_entry = RemoveHeadList(&context->work_queue);
        context->work_queue_length--;
    }
    InsertTailList(&context->work_queue, &work->entry);
    WdfWorkItemEnqueue(context->worker);
    KeReleaseInStackQueuedSpinLock(&lock_handle);
    
    if (old_entry != NULL)
    {
        work = CONTAINING_RECORD(old_entry, struct packet_s, entry);
        windivert_free_packet(work);
    }

    return TRUE;
}

/*
 * Queue a packet.
 */
static void windivert_queue_packet(context_t context, packet_t packet)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    PLIST_ENTRY old_entry;
    packet_t old_packet;
    LONGLONG timestamp;
    BOOL timeout;

    timestamp = KeQueryPerformanceCounter(NULL).QuadPart;
    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    while (TRUE)
    {
        if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
        {
            KeReleaseInStackQueuedSpinLock(&lock_handle);
            windivert_inject_packet(packet);
            return;
        }
        if (packet->packet_size > context->packet_queue_maxsize)
        {
            // (Corner case) the packet is larger than the max queue size:
            KeReleaseInStackQueuedSpinLock(&lock_handle);
            windivert_free_packet(packet);
            return;
        }
        timeout = WINDIVERT_TIMEOUT(context, packet->timestamp, timestamp);
        if (timeout)
        {
            // (Corner case) the packet has already expired:
            KeReleaseInStackQueuedSpinLock(&lock_handle);
            windivert_free_packet(packet);
            return;
        }

        if (context->packet_queue_size + packet->packet_size >
                context->packet_queue_maxsize ||
            context->packet_queue_length + 1 > context->packet_queue_maxlength)
        {
            // The queue is full; drop a packet & try again:
            old_entry = RemoveHeadList(&context->packet_queue);
            old_packet = CONTAINING_RECORD(old_entry, struct packet_s, entry);
            context->packet_queue_length--;
            context->packet_queue_size -= old_packet->packet_size;
            KeReleaseInStackQueuedSpinLock(&lock_handle);
            DEBUG("DROP: packet queue is full, dropping packet");
            windivert_free_packet(old_packet);
            timestamp = KeQueryPerformanceCounter(NULL).QuadPart;
            KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
            continue;
        }
        else
        {
            // Queue the packet:
            InsertTailList(&context->packet_queue, &packet->entry);
            context->packet_queue_length++;
            context->packet_queue_size += packet->packet_size;
            break;
        }
    }
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    DEBUG("PACKET: queued packet (packet=%p)", packet);

    return;
}

/*
 * Inject a packet.
 */
static NTSTATUS windivert_inject_packet(packet_t packet)
{
    UINT8 *packet_data;
    UINT32 packet_len;
    UINT64 checksums;
    PWINDIVERT_DATA_NETWORK network_data;
    PMDL mdl;
    PNET_BUFFER_LIST buffers;
    HANDLE handle;
    UINT32 priority;
    NTSTATUS status;

    if (packet->layer != WINDIVERT_LAYER_NETWORK &&
        packet->layer != WINDIVERT_LAYER_NETWORK_FORWARD)
    {
        windivert_free_packet(packet);
        return STATUS_INVALID_PARAMETER;
    }

    network_data = (PWINDIVERT_DATA_NETWORK)WINDIVERT_LAYER_DATA_PTR(packet);
    packet_data = WINDIVERT_PACKET_DATA_PTR(WINDIVERT_DATA_NETWORK, packet);
    packet_len = packet->packet_len;

    // Fix checksums:
    checksums =
        (packet->ip_checksum == 0?   0: WINDIVERT_HELPER_NO_IP_CHECKSUM) |
        (packet->tcp_checksum == 0?  0: WINDIVERT_HELPER_NO_TCP_CHECKSUM) |
        (packet->udp_checksum == 0?  0: WINDIVERT_HELPER_NO_UDP_CHECKSUM) |
        (packet->icmp_checksum == 0? 0: WINDIVERT_HELPER_NO_ICMP_CHECKSUM |
                                        WINDIVERT_HELPER_NO_ICMPV6_CHECKSUM);
    WinDivertHelperCalcChecksums(packet_data, packet_len, NULL, checksums);

    // Decrement TTL for impostor packets:
    if (packet->impostor != 0 &&
            !WinDivertHelperDecrementTTL(packet_data, packet_len))
    {
        status = STATUS_HOPLIMIT_EXCEEDED;
        DEBUG_ERROR("failed to inject ttl-exceeded impostor packet", status);
        windivert_free_packet(packet);
        return status;
    }

    // Inject packet:
    mdl = IoAllocateMdl(packet_data, packet_len, FALSE, FALSE, NULL);
    if (mdl == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        DEBUG_ERROR("failed to allocate MDL for injected packet", status);
        windivert_free_packet(packet);
        return status;
    }
    MmBuildMdlForNonPagedPool(mdl);
    status = FwpsAllocateNetBufferAndNetBufferList0(nbl_pool_handle, 0, 0,
        mdl, 0, packet_len, &buffers);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create NET_BUFFER_LIST for injected packet",
            status);
        IoFreeMdl(mdl);
        windivert_free_packet(packet);
        return status;
    }
    priority = packet->priority;
    if (packet->layer == WINDIVERT_LAYER_NETWORK_FORWARD)
    {
        handle = (packet->ipv6? injectv6_handle_forward: inject_handle_forward);
        status = FwpsInjectForwardAsync0(handle, (HANDLE)priority, 0,
            (packet->ipv6? AF_INET6: AF_INET), UNSPECIFIED_COMPARTMENT_ID,
            network_data->IfIdx, buffers, windivert_inject_complete,
            (HANDLE)packet);
    }
    else if (packet->outbound)
    {
        handle = (packet->ipv6? injectv6_handle_out: inject_handle_out);
        status = FwpsInjectNetworkSendAsync0(handle, (HANDLE)priority, 0,
            UNSPECIFIED_COMPARTMENT_ID, buffers, windivert_inject_complete,
            (HANDLE)packet);
    }
    else
    {
        handle = (packet->ipv6? injectv6_handle_in: inject_handle_in);
        status = FwpsInjectNetworkReceiveAsync0(handle, (HANDLE)priority, 0,
            UNSPECIFIED_COMPARTMENT_ID, network_data->IfIdx,
            network_data->SubIfIdx, buffers, windivert_inject_complete,
            (HANDLE)packet);
    }

    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to inject (packet=%p)", status, packet);
        FwpsFreeNetBufferList0(buffers);
        IoFreeMdl(mdl);
        windivert_free_packet(packet);
    }
    return status;
}

/*
 * Free a packet.
 */
static void windivert_free_packet(packet_t packet)
{
    if (packet->object != NULL)
    {
        ObDereferenceObject(packet->object);
    }
    windivert_free(packet);
}

/*
 * WinDivert inject complete routine.
 */
static void NTAPI windivert_inject_complete(VOID *context,
    NET_BUFFER_LIST *buffers, BOOLEAN dispatch_level)
{
    PMDL mdl;
    PNET_BUFFER buffer;
    packet_t packet;
    UNREFERENCED_PARAMETER(dispatch_level);

    packet = (packet_t)context;
    if (buffers->Status == STATUS_INVALID_BUFFER_SIZE)
    {
        // STATUS_INVALID_BUFFER_SIZE indicates that the send failed because
        // the packet was larger than the MTU.  We generate an ICMP
        // Fragmentation Needed (for IPv4) or an ICMPV6 Packet Too Big (for
        // IPv6) message to allow for PMTU discovery.
        windivert_inject_packet_too_big(packet);
    }

    buffer = NET_BUFFER_LIST_FIRST_NB(buffers);
    mdl = NET_BUFFER_FIRST_MDL(buffer);
    IoFreeMdl(mdl);
    FwpsFreeNetBufferList0(buffers);
    windivert_free_packet(packet);
}

/*
 * WinDivert inject an ICMP(V6) Packet Too Big message.
 */
static void windivert_inject_packet_too_big(packet_t packet)
{
    const UINT mtus[] =
    {
        568, 768, 1024, 1192, 1280, 1372, 1452, 1500, 4096, UINT16_MAX,
            UINT32_MAX
    };
    PWINDIVERT_IPHDR ip_header, ip_header_2;
    PWINDIVERT_IPV6HDR ipv6_header, ipv6_header_2;
    PWINDIVERT_ICMPHDR icmp_header;
    PWINDIVERT_ICMPV6HDR icmpv6_header;
    packet_t icmp;
    UINT version, packet_len, copy_len, icmp_len;
    UINT icmp_size;
    UINT i, min_mtu = /*ipv4 min MTU=*/568, mtu;
    UINT32 flowlabel;
    UINT8 *data;

    if (packet->layer != WINDIVERT_LAYER_NETWORK || !packet->outbound ||
            packet->loopback)
    {
        return;
    }
    ip_header = (PWINDIVERT_IPHDR)WINDIVERT_PACKET_DATA_PTR(
        WINDIVERT_DATA_NETWORK, packet);
    version = ip_header->Version;
    switch (version)
    {
        case 4:
            packet_len = RtlUshortByteSwap(ip_header->Length);
            copy_len = ip_header->HdrLength * sizeof(UINT32) + 8;
            copy_len = (packet_len < copy_len? packet_len: copy_len);
            icmp_len = sizeof(WINDIVERT_IPHDR) + sizeof(WINDIVERT_ICMPHDR) +
                copy_len;
            break;
        case 6:
            ipv6_header = (PWINDIVERT_IPV6HDR)ip_header;
            packet_len = RtlUshortByteSwap(ipv6_header->Length) +
                sizeof(WINDIVERT_IPV6HDR);
            min_mtu = /*ipv6 min MTU=*/1280;
            copy_len = min_mtu - sizeof(WINDIVERT_IPV6HDR) -
                sizeof(WINDIVERT_ICMPV6HDR);
            copy_len = (packet_len < copy_len? packet_len: copy_len);
            icmp_len = sizeof(WINDIVERT_IPV6HDR) +
                sizeof(WINDIVERT_ICMPV6HDR) + copy_len;
            break;
        default:
            return;
    }
    if (packet_len <= min_mtu)
    {
        return;
    }

    // We do not actually know the MTU value, so we make an educated guess.
    for (i = 0; packet_len > mtus[i]; i++)
        ;
    mtu = (i == 0? min_mtu: mtus[i-1]);
    mtu = (mtu < min_mtu? min_mtu: mtu);

    icmp_size = WINDIVERT_PACKET_SIZE(WINDIVERT_DATA_NETWORK, icmp_len);
    icmp = (packet_t)windivert_malloc(icmp_size, FALSE);
    if (icmp == NULL)
    {
        return;
    }
    icmp->layer         = WINDIVERT_LAYER_NETWORK;
    icmp->event         = WINDIVERT_EVENT_NETWORK_PACKET;
    icmp->sniffed       = 0;        // Unused
    icmp->outbound      = 0;        // Inbound
    icmp->loopback      = 0;        // Unused
    icmp->impostor      = 0;        // Treat as non-impostor
    icmp->ipv6          = (version == 6? 1: 0);
    icmp->ip_checksum   = 0;        // IP checksum valid
    icmp->tcp_checksum  = 0;        // Unused
    icmp->udp_checksum  = 0;        // Unused
    icmp->icmp_checksum = 0;        // ICMP(V6) checksum invalid
    icmp->match         = 0;        // Unused
    icmp->packet_size   = icmp_size;
    icmp->packet_len    = icmp_len;
    icmp->priority      = packet->priority;
    icmp->timestamp     = 0;        // Unused
    icmp->object        = NULL;
    RtlCopyMemory(WINDIVERT_LAYER_DATA_PTR(icmp),
        WINDIVERT_LAYER_DATA_PTR(packet), sizeof(WINDIVERT_DATA_NETWORK));
    data = WINDIVERT_PACKET_DATA_PTR(WINDIVERT_DATA_NETWORK, icmp);
    switch (version)
    {
        case 4:
            ip_header_2 = (PWINDIVERT_IPHDR)data;
            ip_header_2->Version   = 4;
            ip_header_2->HdrLength = sizeof(WINDIVERT_IPHDR) / sizeof(UINT32);
            ip_header_2->TOS       = 0x0;
            ip_header_2->Length    = RtlUshortByteSwap(icmp_len);
            ip_header_2->Id        = 0x0;
            ip_header_2->TTL       = 64;
            ip_header_2->Protocol  = IPPROTO_ICMP;
            ip_header_2->SrcAddr   = ip_header->DstAddr;
            ip_header_2->DstAddr   = ip_header->SrcAddr;
            WINDIVERT_IPHDR_SET_FRAGOFF(ip_header_2, 0x0);
            WINDIVERT_IPHDR_SET_MF(ip_header_2, 0);
            WINDIVERT_IPHDR_SET_DF(ip_header_2, 1);
            WINDIVERT_IPHDR_SET_RESERVED(ip_header_2, 0x0);
            icmp_header = (PWINDIVERT_ICMPHDR)(ip_header_2 + 1);
            icmp_header->Type      = /*Destination Unreachable=*/3;
            icmp_header->Code      = /*Fragmentation required=*/4;
            icmp_header->Body      = ((UINT32)RtlUshortByteSwap(mtu)) << 16;
            data = (UINT8 *)(icmp_header + 1);
            RtlCopyMemory(data, ip_header, copy_len);
            break;
        case 6:
            icmp_len -= sizeof(WINDIVERT_IPV6HDR);
            ipv6_header_2 = (PWINDIVERT_IPV6HDR)data;
            ipv6_header_2->Version  = 6;
            ipv6_header_2->Length   = RtlUshortByteSwap(icmp_len);
            ipv6_header_2->NextHdr  = IPPROTO_ICMPV6;
            ipv6_header_2->HopLimit = 64;
            RtlCopyMemory(ipv6_header_2->SrcAddr, ipv6_header->DstAddr,
                sizeof(ipv6_header_2->SrcAddr));
            RtlCopyMemory(ipv6_header_2->DstAddr, ipv6_header->SrcAddr,
                sizeof(ipv6_header_2->DstAddr));
            WINDIVERT_IPV6HDR_SET_TRAFFICCLASS(ipv6_header_2, 0x0);
            flowlabel = WINDIVERT_IPV6HDR_GET_FLOWLABEL(ipv6_header);
            WINDIVERT_IPV6HDR_SET_FLOWLABEL(ipv6_header_2, flowlabel);
            icmpv6_header = (PWINDIVERT_ICMPV6HDR)(ipv6_header_2 + 1);
            icmpv6_header->Type = /*Packet Too Big=*/2;
            icmpv6_header->Code = 0;
            icmpv6_header->Body = RtlUlongByteSwap(mtu);
            data = (UINT8 *)(icmpv6_header + 1);
            RtlCopyMemory(data, ipv6_header, copy_len);
            break;
    }
    windivert_inject_packet(icmp);
}

/*
 * Copy data from a NET_BUFFER.
 */
static BOOL windivert_copy_data(PNET_BUFFER buffer, PVOID data, UINT size)
{
    PVOID ptr;

    ptr = NdisGetDataBuffer(buffer, size, NULL, 1, 0);
    if (ptr != NULL)
    {
        // Contiguous (common) case:
        RtlCopyMemory(data, ptr, size);
    }
    else
    {
        // Non-contigious case:
        ptr = NdisGetDataBuffer(buffer, size, data, 1, 0);
        if (ptr == NULL)
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*
 * Lookup packet/payload data at given index.
 */
static BOOL windivert_get_data(PNET_BUFFER buffer, UINT length, INT min,
    INT max, INT idx, PVOID data, UINT size)
{
    BOOL success;
    UNREFERENCED_PARAMETER(length);

    idx += (idx < 0? max: min);
    if (idx < min || idx > (max - (INT)size))
    {
        return FALSE;       // OOB
    }

    if (idx > 0)
    {
        NdisAdvanceNetBufferDataStart(buffer, idx, FALSE, NULL);
    }
    success = windivert_copy_data(buffer, data, size);
    if (idx > 0)
    {
        (VOID)NdisRetreatNetBufferDataStart(buffer, idx, 0, NULL);
    }
    return success;
}

/*
 * Parse packet headers.
 */
static WINDIVERT_INLINE BOOL windivert_parse_headers(PNET_BUFFER buffer,
    BOOL ipv4, BOOL *fragment_ptr, PWINDIVERT_IPHDR *ip_header_ptr,
    PWINDIVERT_IPV6HDR *ipv6_header_ptr, PWINDIVERT_ICMPHDR *icmp_header_ptr,
    PWINDIVERT_ICMPV6HDR *icmpv6_header_ptr, PWINDIVERT_TCPHDR *tcp_header_ptr,
    PWINDIVERT_UDPHDR *udp_header_ptr, UINT8 *proto_ptr, UINT *header_len_ptr,
    UINT *payload_len_ptr)
{
    UINT total_len, ip_header_len = 0;
    PWINDIVERT_IPHDR ip_header = NULL;
    PWINDIVERT_IPV6HDR ipv6_header = NULL;
    PWINDIVERT_ICMPHDR icmp_header = NULL;
    PWINDIVERT_ICMPV6HDR icmpv6_header = NULL;
    PWINDIVERT_TCPHDR tcp_header = NULL;
    PWINDIVERT_UDPHDR udp_header = NULL;
    PWINDIVERT_IPV6FRAGHDR frag_header;
    BOOL fragment = FALSE;
    UINT8 protocol = 0;
    UINT16 frag_off = 0;
    UINT header_len = 0;
    NTSTATUS status;

    // Parse the headers:
    if (buffer == NULL)
    {
        DEBUG("FILTER: REJECT (packet is NULL)");
        return FALSE;
    }
    total_len = NET_BUFFER_DATA_LENGTH(buffer);
    if (total_len < sizeof(WINDIVERT_IPHDR))
    {
        DEBUG("FILTER: REJECT (packet length too small)");
        return FALSE;
    }

    // Get the IP header.
    if (ipv4)
    {
        // IPv4:
        if (total_len < sizeof(WINDIVERT_IPHDR))
        {
            DEBUG("FILTER: REJECT (packet length too small)");
            return FALSE;
        }
        ip_header = (PWINDIVERT_IPHDR)NdisGetDataBuffer(buffer,
            sizeof(WINDIVERT_IPHDR), NULL, 1, 0);
        if (ip_header == NULL)
        {
            DEBUG("FILTER: REJECT (failed to get IPv4 header)");
            return FALSE;
        }
        ip_header_len = ip_header->HdrLength*sizeof(UINT32);
        if (ip_header->Version != 4 ||
            RtlUshortByteSwap(ip_header->Length) != total_len ||
            ip_header->HdrLength < 5 ||
            ip_header_len > total_len)
        {
            DEBUG("FILTER: REJECT (bad IPv4 packet)");
            return FALSE;
        }
        frag_off = RtlUshortByteSwap(WINDIVERT_IPHDR_GET_FRAGOFF(ip_header));
        fragment = (frag_off != 0 || WINDIVERT_IPHDR_GET_MF(ip_header) != 0);
        protocol = ip_header->Protocol;
        NdisAdvanceNetBufferDataStart(buffer, ip_header_len, FALSE, NULL);
    }
    else
    {
        // IPv6:
        if (total_len < sizeof(WINDIVERT_IPV6HDR))
        {
            DEBUG("FILTER: REJECT (packet length too small)");
            return FALSE;
        }
        ipv6_header = (PWINDIVERT_IPV6HDR)NdisGetDataBuffer(buffer,
            sizeof(WINDIVERT_IPV6HDR), NULL, 1, 0);
        if (ipv6_header == NULL)
        {
            DEBUG("FILTER: REJECT (failed to get IPv6 header)");
            return FALSE;
        }
        ip_header_len = sizeof(WINDIVERT_IPV6HDR);
        if (ipv6_header->Version != 6 ||
            ip_header_len > total_len ||
            RtlUshortByteSwap(ipv6_header->Length) +
                sizeof(WINDIVERT_IPV6HDR) != total_len)
        {
            DEBUG("FILTER: REJECT (bad IPv6 packet)");
            return FALSE;
        }
        protocol = ipv6_header->NextHdr;
        NdisAdvanceNetBufferDataStart(buffer, ip_header_len, FALSE, NULL);

        // Skip extension headers:
        while (frag_off == 0)
        {
            UINT8 *ext_header = NULL;
            UINT ext_header_len = 0;
            BOOL is_ext_header;
            switch (protocol)
            {
                case IPPROTO_FRAGMENT:
                    frag_header = (PWINDIVERT_IPV6FRAGHDR)
                        NdisGetDataBuffer(buffer, 8, NULL, 1, 0);
                    ext_header = (UINT8 *)frag_header;
                    if (fragment || frag_header == NULL)
                    {
                        is_ext_header = FALSE;
                        break;
                    }
                    fragment = TRUE;
                    frag_off = RtlUshortByteSwap(
                        WINDIVERT_IPV6FRAGHDR_GET_FRAGOFF(frag_header));
                    ext_header_len = 8;
                    is_ext_header  = TRUE;
                    break;

                case IPPROTO_AH:
                case IPPROTO_HOPOPTS:
                case IPPROTO_DSTOPTS:
                case IPPROTO_ROUTING:
                case IPPROTO_MH:
                    ext_header = (UINT8 *)NdisGetDataBuffer(buffer, 2, NULL,
                        1, 0);
                    if (ext_header == NULL)
                    {
                        is_ext_header = FALSE;
                        break;
                    }
                    ext_header_len = (UINT)ext_header[1];
                    if (protocol == IPPROTO_AH)
                    {
                        ext_header_len += 2;
                        ext_header_len *= 4;
                    }
                    else
                    {
                        ext_header_len++;
                        ext_header_len *= 8;
                    }
                    is_ext_header = TRUE;
                    break;
                default:

                    is_ext_header = FALSE;
                    break;
            }

            if (!is_ext_header || ip_header_len + ext_header_len > total_len)
            {
                break;
            }
            protocol = ext_header[0];
            ip_header_len += ext_header_len;
            NdisAdvanceNetBufferDataStart(buffer, ext_header_len, FALSE,
                NULL);
        }
    }

    header_len = ip_header_len;
    if (frag_off == 0)
    {
        switch (protocol)
        {
            case IPPROTO_ICMP:
                if (ip_header == NULL)
                {
                    break;
                }
                icmp_header = (PWINDIVERT_ICMPHDR)NdisGetDataBuffer(buffer,
                    sizeof(WINDIVERT_ICMPHDR), NULL, 1, 0);
                header_len +=
                    (icmp_header == NULL? 0: sizeof(WINDIVERT_ICMPHDR));
                break;

            case IPPROTO_ICMPV6:
                if (ipv6_header == NULL)
                {
                    break;
                }
                icmpv6_header = (PWINDIVERT_ICMPV6HDR)NdisGetDataBuffer(buffer,
                    sizeof(WINDIVERT_ICMPV6HDR), NULL, 1, 0);
                header_len +=
                    (icmpv6_header == NULL? 0: sizeof(WINDIVERT_ICMPV6HDR));
                break;

            case IPPROTO_TCP:
                tcp_header = (PWINDIVERT_TCPHDR)NdisGetDataBuffer(buffer,
                    sizeof(WINDIVERT_TCPHDR), NULL, 1, 0);
                if (tcp_header != NULL)
                {
                    if (tcp_header->HdrLength < 5)
                    {
                        tcp_header = NULL;
                    }
                    else
                    {
                        UINT tcp_header_len =
                            tcp_header->HdrLength * sizeof(UINT32);
                        tcp_header_len =
                            (header_len + tcp_header_len > total_len?
                                total_len - header_len: tcp_header_len);
                        header_len += tcp_header_len;
                    }
                }
                break;

            case IPPROTO_UDP:
                udp_header = (PWINDIVERT_UDPHDR)NdisGetDataBuffer(buffer,
                    sizeof(WINDIVERT_UDPHDR), NULL, 1, 0);
                header_len +=
                    (udp_header == NULL? 0: sizeof(WINDIVERT_UDPHDR));
                break;
            default:
                break;
        }
    }

    status = NdisRetreatNetBufferDataStart(buffer, ip_header_len, 0, NULL);
    if (!NT_SUCCESS(status))
    {
        // Should never occur.
        DEBUG("FILTER: REJECT (failed to retreat buffer)");
        return FALSE;
    }

    *fragment_ptr      = fragment;
    *ip_header_ptr     = ip_header;
    *ipv6_header_ptr   = ipv6_header;
    *icmp_header_ptr   = icmp_header;
    *icmpv6_header_ptr = icmpv6_header;
    *tcp_header_ptr    = tcp_header;
    *udp_header_ptr    = udp_header;
    *proto_ptr         = protocol;
    *header_len_ptr    = header_len;
    *payload_len_ptr   = total_len - header_len;

    return TRUE;
}

/*
 * Checks if the given network packet is of interest.
 */
static BOOL windivert_filter(PNET_BUFFER buffer, WINDIVERT_LAYER layer,
    const VOID *layer_data, LONGLONG timestamp, WINDIVERT_EVENT event,
    BOOL ipv4, BOOL outbound, BOOL loopback, BOOL impostor, BOOL frag_mode,
    const WINDIVERT_FILTER *filter)
{
    PWINDIVERT_IPHDR ip_header = NULL;
    PWINDIVERT_IPV6HDR ipv6_header = NULL;
    PWINDIVERT_ICMPHDR icmp_header = NULL;
    PWINDIVERT_ICMPV6HDR icmpv6_header = NULL;
    PWINDIVERT_TCPHDR tcp_header = NULL;
    PWINDIVERT_UDPHDR udp_header = NULL;
    BOOL fragment = FALSE;
    UINT8 protocol = 0;
    UINT header_len = 0, payload_len = 0, total_len = 0;
    PWINDIVERT_DATA_NETWORK network_data = NULL;
    PWINDIVERT_DATA_FLOW flow_data = NULL;
    PWINDIVERT_DATA_SOCKET socket_data = NULL;
    PWINDIVERT_DATA_REFLECT reflect_data = NULL;
    int result;

    switch (layer)
    {
        case WINDIVERT_LAYER_NETWORK:
        case WINDIVERT_LAYER_NETWORK_FORWARD:
            if (!windivert_parse_headers(buffer, ipv4, &fragment, &ip_header,
                    &ipv6_header, &icmp_header, &icmpv6_header, &tcp_header,
                    &udp_header, &protocol, &header_len, &payload_len))
            {
                return FALSE;
            }
            if (fragment && !frag_mode)
            {
                return FALSE;
            }
            network_data = (PWINDIVERT_DATA_NETWORK)layer_data;
            break;
        case WINDIVERT_LAYER_FLOW:
            flow_data = (PWINDIVERT_DATA_FLOW)layer_data;
            break;
        case WINDIVERT_LAYER_SOCKET:
            socket_data = (PWINDIVERT_DATA_SOCKET)layer_data;
            break;
        case WINDIVERT_LAYER_REFLECT:
            reflect_data = (PWINDIVERT_DATA_REFLECT)layer_data;
            break;
        default:
            DEBUG("FILTER: REJECT (invalid parameter)");
            return FALSE;
    }

    result = WinDivertExecuteFilter(
        filter,
        layer,
        timestamp,
        event,
        ipv4,
        outbound,
        loopback,
        impostor,
        fragment,
        network_data,
        flow_data,
        socket_data,
        reflect_data,
        ip_header,
        ipv6_header,
        icmp_header,
        icmpv6_header,
        tcp_header,
        udp_header,
        protocol,
        (const VOID *)buffer,
        header_len + payload_len,
        header_len,
        payload_len);

    return (result == 1);
}

/*
 * Compile a WinDivert filter from an IOCTL.
 */
static const WINDIVERT_FILTER *windivert_filter_compile(
    const WINDIVERT_FILTER *ioctl_filter, size_t ioctl_filter_len,
    WINDIVERT_LAYER layer)
{
    PWINDIVERT_FILTER filter = NULL;
    WINDIVERT_EVENT event;
    BOOL neg_lb, neg_ub, neg;
    UINT32 lb[4], ub[4];
    int result;
    UINT16 i;
    size_t length;

    if (ioctl_filter_len % sizeof(WINDIVERT_FILTER) != 0)
    {
        goto windivert_filter_compile_error;
    }
    length = ioctl_filter_len / sizeof(WINDIVERT_FILTER);
    if (length >= WINDIVERT_FILTER_MAXLEN || length == 0)
    {
        goto windivert_filter_compile_error;
    }

    filter = (PWINDIVERT_FILTER)windivert_malloc(
        length * sizeof(WINDIVERT_FILTER), FALSE);
    if (filter == NULL)
    {
        goto windivert_filter_compile_error;
    }
 
    for (i = 0; i < length; i++)
    {
        if (ioctl_filter[i].field > WINDIVERT_FILTER_FIELD_MAX ||
            ioctl_filter[i].test > WINDIVERT_FILTER_TEST_MAX)
        {
            goto windivert_filter_compile_error;
        }
        switch (ioctl_filter[i].success)
        {
            case WINDIVERT_FILTER_RESULT_ACCEPT:
            case WINDIVERT_FILTER_RESULT_REJECT:
                break;
            default:
                if (ioctl_filter[i].success <= i ||
                    ioctl_filter[i].success >= length)
                {
                    goto windivert_filter_compile_error;
                }
                break;
        }
        switch (ioctl_filter[i].failure)
        {
            case WINDIVERT_FILTER_RESULT_ACCEPT:
            case WINDIVERT_FILTER_RESULT_REJECT:
                break;
            default:
                if (ioctl_filter[i].failure <= i ||
                    ioctl_filter[i].failure >= length)
                {
                    goto windivert_filter_compile_error;
                }
                break;
        }

        // Enforce layers:
        if (!WinDivertValidateField(layer, ioctl_filter[i].field))
        {
            goto windivert_filter_compile_error;
        }

        // Enforce ranges:
        neg_lb = neg_ub = 0;
        lb[0] = lb[1] = lb[2] = lb[3] = 0;
        ub[0] = ub[1] = ub[2] = ub[3] = 0;
        switch (ioctl_filter[i].field)
        {
            case WINDIVERT_FILTER_FIELD_PACKET:
            case WINDIVERT_FILTER_FIELD_PACKET16:
            case WINDIVERT_FILTER_FIELD_PACKET32:
            case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD:
            case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD16:
            case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD32:
            case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD:
            case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD16:
            case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD32:
            {
                INT idx = (INT)ioctl_filter[i].arg[1];
                if (ioctl_filter[i].neg)
                {
                    goto windivert_filter_compile_error;
                }
                if (idx > WINDIVERT_MTU_MAX || idx < -WINDIVERT_MTU_MAX)
                {
                    goto windivert_filter_compile_error;
                }
                lb[1] = ub[1] = ioctl_filter[i].arg[1];
                break;
            }
            default:
                break;
        }
        switch (ioctl_filter[i].field)
        {
            case WINDIVERT_FILTER_FIELD_ZERO:
            case WINDIVERT_FILTER_FIELD_INBOUND:
            case WINDIVERT_FILTER_FIELD_OUTBOUND:
            case WINDIVERT_FILTER_FIELD_FRAGMENT:
            case WINDIVERT_FILTER_FIELD_IP:
            case WINDIVERT_FILTER_FIELD_IPV6:
            case WINDIVERT_FILTER_FIELD_ICMP:
            case WINDIVERT_FILTER_FIELD_ICMPV6:
            case WINDIVERT_FILTER_FIELD_TCP:
            case WINDIVERT_FILTER_FIELD_UDP:
            case WINDIVERT_FILTER_FIELD_IP_DF:
            case WINDIVERT_FILTER_FIELD_IP_MF:
            case WINDIVERT_FILTER_FIELD_TCP_URG:
            case WINDIVERT_FILTER_FIELD_TCP_ACK:
            case WINDIVERT_FILTER_FIELD_TCP_PSH:
            case WINDIVERT_FILTER_FIELD_TCP_RST:
            case WINDIVERT_FILTER_FIELD_TCP_SYN:
            case WINDIVERT_FILTER_FIELD_TCP_FIN:
                ub[0] = 1;
                break;
            case WINDIVERT_FILTER_FIELD_LAYER:
                ub[0] = WINDIVERT_LAYER_MAX;
                break;
            case WINDIVERT_FILTER_FIELD_PRIORITY:
                neg_lb = TRUE;
                lb[0] = ub[0] = WINDIVERT_PRIORITY_MAX;
                break;
            case WINDIVERT_FILTER_FIELD_EVENT:
                event = (WINDIVERT_EVENT)ioctl_filter[i].arg[0];
                switch (layer)
                {
                    case WINDIVERT_LAYER_NETWORK:
                    case WINDIVERT_LAYER_NETWORK_FORWARD:
                        if (event != WINDIVERT_EVENT_NETWORK_PACKET)
                        {
                            goto windivert_filter_compile_error;
                        }
                        break;
                    case WINDIVERT_LAYER_FLOW:
                        if (event != WINDIVERT_EVENT_FLOW_ESTABLISHED &&
                            event != WINDIVERT_EVENT_FLOW_DELETED)
                        {
                            goto windivert_filter_compile_error;
                        }
                        break;
                    case WINDIVERT_LAYER_SOCKET:
                        if (event != WINDIVERT_EVENT_SOCKET_BIND &&
                            event != WINDIVERT_EVENT_SOCKET_CONNECT &&
                            event != WINDIVERT_EVENT_SOCKET_LISTEN &&
                            event != WINDIVERT_EVENT_SOCKET_ACCEPT &&
                            event != WINDIVERT_EVENT_SOCKET_CLOSE)
                        {
                            goto windivert_filter_compile_error;
                        }
                        break;
                    case WINDIVERT_LAYER_REFLECT:
                        if (event != WINDIVERT_EVENT_REFLECT_OPEN &&
                            event != WINDIVERT_EVENT_REFLECT_CLOSE)
                        {
                            goto windivert_filter_compile_error;
                        }
                        break;
                    default:
                        goto windivert_filter_compile_error;
                }
                ub[0] = WINDIVERT_EVENT_MAX;
                break;
            case WINDIVERT_FILTER_FIELD_IP_HDRLENGTH:
            case WINDIVERT_FILTER_FIELD_TCP_HDRLENGTH:
                ub[0] = 0x0F;
                break;
            case WINDIVERT_FILTER_FIELD_IP_TOS:
            case WINDIVERT_FILTER_FIELD_IP_TTL:
            case WINDIVERT_FILTER_FIELD_IP_PROTOCOL:
            case WINDIVERT_FILTER_FIELD_IPV6_TRAFFICCLASS:
            case WINDIVERT_FILTER_FIELD_IPV6_NEXTHDR:
            case WINDIVERT_FILTER_FIELD_IPV6_HOPLIMIT:
            case WINDIVERT_FILTER_FIELD_ICMP_TYPE:
            case WINDIVERT_FILTER_FIELD_ICMP_CODE:
            case WINDIVERT_FILTER_FIELD_ICMPV6_TYPE:
            case WINDIVERT_FILTER_FIELD_ICMPV6_CODE:
            case WINDIVERT_FILTER_FIELD_PROTOCOL:
            case WINDIVERT_FILTER_FIELD_PACKET:
            case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD:
            case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD:
            case WINDIVERT_FILTER_FIELD_RANDOM8:
                ub[0] = 0xFF;
                break;
            case WINDIVERT_FILTER_FIELD_IP_FRAGOFF:
                ub[0] = 0x1FFF;
                break;
            case WINDIVERT_FILTER_FIELD_IP_LENGTH:
            case WINDIVERT_FILTER_FIELD_IP_ID:
            case WINDIVERT_FILTER_FIELD_IP_CHECKSUM:
            case WINDIVERT_FILTER_FIELD_IPV6_LENGTH:
            case WINDIVERT_FILTER_FIELD_ICMP_CHECKSUM:
            case WINDIVERT_FILTER_FIELD_ICMPV6_CHECKSUM:
            case WINDIVERT_FILTER_FIELD_TCP_SRCPORT:
            case WINDIVERT_FILTER_FIELD_TCP_DSTPORT:
            case WINDIVERT_FILTER_FIELD_TCP_WINDOW:
            case WINDIVERT_FILTER_FIELD_TCP_CHECKSUM:
            case WINDIVERT_FILTER_FIELD_TCP_URGPTR:
            case WINDIVERT_FILTER_FIELD_TCP_PAYLOADLENGTH:
            case WINDIVERT_FILTER_FIELD_UDP_SRCPORT:
            case WINDIVERT_FILTER_FIELD_UDP_DSTPORT:
            case WINDIVERT_FILTER_FIELD_UDP_LENGTH:
            case WINDIVERT_FILTER_FIELD_UDP_CHECKSUM:
            case WINDIVERT_FILTER_FIELD_UDP_PAYLOADLENGTH:
            case WINDIVERT_FILTER_FIELD_LOCALPORT:
            case WINDIVERT_FILTER_FIELD_REMOTEPORT:
            case WINDIVERT_FILTER_FIELD_PACKET16:
            case WINDIVERT_FILTER_FIELD_TCP_PAYLOAD16:
            case WINDIVERT_FILTER_FIELD_UDP_PAYLOAD16:
            case WINDIVERT_FILTER_FIELD_RANDOM16:
                ub[0] = 0xFFFF;
                break;
            case WINDIVERT_FILTER_FIELD_LENGTH:
                lb[0] = sizeof(WINDIVERT_IPHDR);
                ub[0] = WINDIVERT_MTU_MAX;
                break;
            case WINDIVERT_FILTER_FIELD_IPV6_FLOWLABEL:
                ub[0] = 0x000FFFFF;
                break;
            case WINDIVERT_FILTER_FIELD_IP_SRCADDR:
            case WINDIVERT_FILTER_FIELD_IP_DSTADDR:
                ub[0] = 0xFFFFFFFF;
                ub[1] = lb[1] = 0x0000FFFF;
                break;
            case WINDIVERT_FILTER_FIELD_TIMESTAMP:
                lb[1] = 0x80000000;
                ub[0] = 0xFFFFFFFF;
                ub[1] = 0x7FFFFFFF;
                neg_lb = TRUE;
                break;
            case WINDIVERT_FILTER_FIELD_ENDPOINTID:
            case WINDIVERT_FILTER_FIELD_PARENTENDPOINTID:
                ub[0] = ub[1] = 0xFFFFFFFF;
                break;
            case WINDIVERT_FILTER_FIELD_IPV6_SRCADDR:
            case WINDIVERT_FILTER_FIELD_IPV6_DSTADDR:
            case WINDIVERT_FILTER_FIELD_LOCALADDR:
            case WINDIVERT_FILTER_FIELD_REMOTEADDR:
                ub[0] = ub[1] = ub[2] = ub[3] = 0xFFFFFFFF;
                break;
            default:
                ub[0] = 0xFFFFFFFF;
                break;
        }
        neg = (ioctl_filter[i].neg? TRUE: FALSE);
        result = WinDivertCompare128(neg, ioctl_filter[i].arg, neg_lb,
            lb, /*big=*/TRUE);
        if (result < 0)
        {
            goto windivert_filter_compile_error;
        }
        result = WinDivertCompare128(neg, ioctl_filter[i].arg, neg_ub,
            ub, /*big=*/TRUE);
        if (result > 0)
        {
            goto windivert_filter_compile_error;
        }

        // Disallow negative zero:
        if (neg &&
                ioctl_filter[i].arg[0] == 0 && ioctl_filter[i].arg[1] == 0 &&
                ioctl_filter[i].arg[2] == 0 && ioctl_filter[i].arg[3] == 0)
        {
            goto windivert_filter_compile_error;
        }

        filter[i].field   = ioctl_filter[i].field;
        filter[i].test    = ioctl_filter[i].test;
        filter[i].success = ioctl_filter[i].success;
        filter[i].failure = ioctl_filter[i].failure;
        filter[i].neg     = ioctl_filter[i].neg;
        filter[i].arg[0]  = ioctl_filter[i].arg[0];
        filter[i].arg[1]  = ioctl_filter[i].arg[1];
        filter[i].arg[2]  = ioctl_filter[i].arg[2];
        filter[i].arg[3]  = ioctl_filter[i].arg[3];
    }
    
    return filter;

windivert_filter_compile_error:

    windivert_free((PVOID)filter);
    return NULL;
}

/****************************************************************************/
/* WINDIVERT REFLECT MANAGER IMPLEMENTATION                                 */
/****************************************************************************/

#define WINDIVERT_REFLECT_PACKET_MAX        12288

/*
 * WinDivert reflect state.
 */
static BOOL reflect_inited = FALSE;         // Reflection initialized?
static BOOL reflect_worker_queued = FALSE;  // Reflect worker queued?
static KSPIN_LOCK reflect_lock;             // Reflect lock.
static LIST_ENTRY reflect_event_queue;      // Reflect event queue.
static LIST_ENTRY reflect_contexts;         // All open (non-REFLECT) contexts.
static LIST_ENTRY reflect_waiters;          // All open REFLECT contexts.
static WDFWORKITEM reflect_worker;          // Reflect work item.
#pragma data_seg(push, stack, "PAGE")
static char reflect_packet[WINDIVERT_REFLECT_PACKET_MAX];
#pragma data_seg(pop, stack)

/*
 * Initialize the reflection layer implementation.
 */
static NTSTATUS windivert_reflect_init(WDFOBJECT parent)
{
    WDF_WORKITEM_CONFIG item_config;
    WDF_OBJECT_ATTRIBUTES obj_attrs;
    NTSTATUS status;

    KeInitializeSpinLock(&reflect_lock);
    InitializeListHead(&reflect_event_queue);
    InitializeListHead(&reflect_contexts);
    InitializeListHead(&reflect_waiters);
    WDF_WORKITEM_CONFIG_INIT(&item_config, windivert_reflect_worker);
    item_config.AutomaticSerialization = FALSE;
    WDF_OBJECT_ATTRIBUTES_INIT(&obj_attrs);
    obj_attrs.ParentObject = parent;
    status = WdfWorkItemCreate(&item_config, &obj_attrs, &reflect_worker);
    if (!NT_SUCCESS(status))
    {
        DEBUG_ERROR("failed to create reflection work item", status);
        return status;
    }
    reflect_inited = TRUE;
    return STATUS_SUCCESS;
}

/*
 * Cleanup the reflection layer implementation.
 */
static void windivert_reflect_close(void)
{
    if (!reflect_inited)
    {
        return;
    }
    WdfWorkItemFlush(reflect_worker);
    WdfObjectDelete(reflect_worker);
}

/*
 * WinDivert handle reflect open event.
 */
static void windivert_reflect_open_event(context_t context)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    WDFOBJECT object;
    reflect_event_t reflect_event;

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    object = (WDFOBJECT)context->object;
    // To be released on the close event.  This ensures the context object
    // remains valid until the close event has been handled.
    WdfObjectReference(object);
    context->reflect.open = TRUE;
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    // Queue the event:
    reflect_event = &context->reflect.open_event;
    reflect_event->context = context;
    reflect_event->event   = WINDIVERT_EVENT_REFLECT_OPEN;
    KeAcquireInStackQueuedSpinLock(&reflect_lock, &lock_handle);
    InsertTailList(&reflect_event_queue, &reflect_event->entry);
    if (!reflect_worker_queued)
    {
        WdfWorkItemEnqueue(reflect_worker);
        reflect_worker_queued = TRUE;
    }
    KeReleaseInStackQueuedSpinLock(&lock_handle);
}

/*
 * WinDivert handle reflect close event.
 */
static void windivert_reflect_close_event(context_t context)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    reflect_event_t reflect_event;
    BOOL open;

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    open = context->reflect.open;
    KeReleaseInStackQueuedSpinLock(&lock_handle);
    if (!open)
    {
        return;
    }

    // Queue the event:
    reflect_event = &context->reflect.close_event;
    reflect_event->context = context;
    reflect_event->event   = WINDIVERT_EVENT_REFLECT_CLOSE;
    KeAcquireInStackQueuedSpinLock(&reflect_lock, &lock_handle);
    InsertTailList(&reflect_event_queue, &reflect_event->entry);
    if (!reflect_worker_queued)
    {
        WdfWorkItemEnqueue(reflect_worker);
        reflect_worker_queued = TRUE;
    }
    KeReleaseInStackQueuedSpinLock(&lock_handle);
}

/*
 * Create REFLECT layer packet to pass the filter.
 */
static PVOID windivert_reflect_packet(context_t context, ULONG *len_ptr)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    const WINDIVERT_FILTER *filter;
    UINT16 filter_len;
    WINDIVERT_STREAM stream;

    stream.data     = reflect_packet;
    stream.pos      = 0;
    stream.max      = sizeof(reflect_packet) - 1;
    stream.overflow = FALSE;

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    filter = context->filter;
    filter_len = context->filter_len;
    KeReleaseInStackQueuedSpinLock(&lock_handle);
    
    WinDivertSerializeFilter(&stream, filter, (UINT8)filter_len);
    *len_ptr = stream.pos;
    return (PVOID)stream.data;
}

/*
 * Notify all REFLECT layer contexts a new event.
 */
static void windivert_reflect_event_notify(context_t context,
    LONGLONG timestamp, WINDIVERT_EVENT event)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    PLIST_ENTRY entry;
    context_t waiter;
    const WINDIVERT_FILTER *filter;
    PVOID packet = NULL, process;
    ULONG packet_len = 0;
    UINT64 flags;
    BOOL match;

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    process = (PVOID)context->process;
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    entry = reflect_waiters.Flink;
    while (entry != &reflect_waiters)
    {
        waiter = CONTAINING_RECORD(entry, struct context_s, reflect.entry);
        entry = entry->Flink;
        KeAcquireInStackQueuedSpinLock(&waiter->lock, &lock_handle);
        filter = waiter->filter;
        flags  = waiter->flags;
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        match = windivert_filter(/*buffer=*/NULL,
            /*layer=*/WINDIVERT_LAYER_REFLECT, (PVOID)&context->reflect.data,
            timestamp, event, /*ipv4=*/TRUE, /*outbound=*/FALSE,
            /*loopback=*/FALSE, /*impostor=*/FALSE, /*frag_mode=*/FALSE,
            filter);
        if (!match)
        {
            continue;
        }
        if (packet == NULL)
        {
            packet = windivert_reflect_packet(context, &packet_len);
        }
        (VOID)windivert_queue_work(waiter, packet, packet_len,
            /*buffers=*/NULL, process, /*layer=*/WINDIVERT_LAYER_REFLECT,
            (PVOID)&context->reflect.data, event, flags, /*priority=*/0,
            /*ipv4=*/TRUE, /*outbound=*/FALSE, /*loopback=*/FALSE,
            /*impostor=*/FALSE, /*match=*/TRUE, timestamp);
    }
}

/*
 * Notify a new REFLECT layer context of all existing open handles.
 */
static void windivert_reflect_established_notify(context_t context,
    LONGLONG timestamp)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    PLIST_ENTRY entry;
    BOOL match, ok;
    context_t waiter;
    const WINDIVERT_FILTER *filter;
    PVOID packet, process;
    ULONG packet_len;
    UINT64 flags;

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        return;
    }
    filter = context->filter;
    flags = context->flags;
    KeReleaseInStackQueuedSpinLock(&lock_handle);

    entry = reflect_contexts.Flink;
    while (entry != &reflect_contexts)
    {
        waiter = CONTAINING_RECORD(entry, struct context_s, reflect.entry);
        entry = entry->Flink;
        match = windivert_filter(/*buffer=*/NULL,
            /*layer=*/WINDIVERT_LAYER_REFLECT, (PVOID)&waiter->reflect.data,
            timestamp, /*event=*/WINDIVERT_EVENT_REFLECT_OPEN, /*ipv4=*/TRUE,
            /*outbound=*/FALSE, /*loopback=*/FALSE, /*impostor=*/FALSE,
            /*frag_mode=*/FALSE, filter);
        if (!match)
        {
            continue;
        }
        packet = windivert_reflect_packet(waiter, &packet_len);
        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
        process = (PVOID)waiter->process;
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        ok = windivert_queue_work(context, packet, packet_len,
            /*buffers=*/NULL, process, /*layer=*/WINDIVERT_LAYER_REFLECT,
            (PVOID)&waiter->reflect.data,
            /*event=*/WINDIVERT_EVENT_REFLECT_OPEN, flags, /*priority=*/0,
            /*ipv4=*/TRUE, /*outbound=*/FALSE, /*loopback=*/FALSE,
            /*impostor=*/FALSE, /*match=*/TRUE, timestamp);
        if (!ok)
        {
            break;
        }
    }

    KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
    if (context->state != WINDIVERT_CONTEXT_STATE_OPEN)
    {
        KeReleaseInStackQueuedSpinLock(&lock_handle);
        return;
    }
    // REFLECT layer shutdown is disabled until all previously open handles
    // have been queued.
    context->shutdown_recv_enabled = TRUE;
    KeReleaseInStackQueuedSpinLock(&lock_handle);
    windivert_read_service(context);
}

/*
 * WinDivert REFLECT worker.
 */
void windivert_reflect_worker(IN WDFWORKITEM item)
{
    KLOCK_QUEUE_HANDLE lock_handle;
    PLIST_ENTRY entry;
    context_t context;
    LONGLONG timestamp;
    WINDIVERT_EVENT event;
    reflect_event_t reflect_event;
    WDFOBJECT object;
    WINDIVERT_LAYER layer;

    UNREFERENCED_PARAMETER(item);

    // All reflection events are serialized and handled by this worker.
    // This ensures that we are always operating on a consistent "snapshot"
    // of the WinDivert handle state.  This worker also has exclusive control 
    // over reflect_contexts/reflect_waiters, so locking is not required.

    KeAcquireInStackQueuedSpinLock(&reflect_lock, &lock_handle);
    while (!IsListEmpty(&reflect_event_queue))
    {
        entry = RemoveHeadList(&reflect_event_queue);
        KeReleaseInStackQueuedSpinLock(&lock_handle);

        reflect_event = CONTAINING_RECORD(entry, struct reflect_event_s, entry);
        context       = reflect_event->context;
        event         = reflect_event->event;

        DEBUG("REFLECT: %s event for WinDivert context (context=%p)",
            (event == WINDIVERT_EVENT_REFLECT_OPEN? "open": "close"), context);

        KeAcquireInStackQueuedSpinLock(&context->lock, &lock_handle);
        object = (WDFOBJECT)context->object;
        layer = context->layer;
        KeReleaseInStackQueuedSpinLock(&lock_handle);

        timestamp = KeQueryPerformanceCounter(NULL).QuadPart;
        switch (event)
        {
            case WINDIVERT_EVENT_REFLECT_OPEN:
                if (layer != WINDIVERT_LAYER_REFLECT)
                {
                    InsertTailList(&reflect_contexts, &context->reflect.entry);
                }
                else
                {
                    InsertTailList(&reflect_waiters, &context->reflect.entry);
                    windivert_reflect_established_notify(context, timestamp);
                }
                break;

            case WINDIVERT_EVENT_REFLECT_CLOSE:
                RemoveEntryList(&context->reflect.entry);
                break;
        }

        if (layer != WINDIVERT_LAYER_REFLECT)
        {
            windivert_reflect_event_notify(context, timestamp, event);
        }
        if (event == WINDIVERT_EVENT_REFLECT_CLOSE)
        {
            WdfObjectDereference(object);
        }

        KeAcquireInStackQueuedSpinLock(&reflect_lock, &lock_handle);
    }
    reflect_worker_queued = FALSE;
    KeReleaseInStackQueuedSpinLock(&lock_handle);
}

/*
 * Log a driver event.
 */
static void windivert_log_event(PEPROCESS process, PDRIVER_OBJECT driver,
    const wchar_t *msg_str)
{
    const wchar_t windivert_str[] = WINDIVERT_DEVICE_NAME
        WINDIVERT_VERSION_LSTR;
    wchar_t pid_str[16];
    size_t windivert_size = sizeof(windivert_str), msg_size, pid_size, size;
    UNICODE_STRING string;
    UINT8 *str;
    PIO_ERROR_LOG_PACKET packet;
    NTSTATUS status;

    size = ERROR_LOG_MAXIMUM_SIZE - sizeof(wchar_t) -
        (sizeof(IO_ERROR_LOG_PACKET) + windivert_size + sizeof(pid_str));
    status = RtlStringCbLengthW(msg_str, size, &msg_size);
    if (!NT_SUCCESS(status))
    {
        return;
    }
    msg_size += sizeof(wchar_t);

    if (process != NULL)
    {
        string.Length        = 0;
        string.MaximumLength = sizeof(pid_str);
        string.Buffer        = pid_str;
        status = RtlIntegerToUnicodeString(
            (UINT32)(ULONG_PTR)PsGetProcessId(process), 10, &string);
        pid_size = string.Length + sizeof(wchar_t);
    }
    if (process == NULL || !NT_SUCCESS(status))
    {
        pid_str[0] = pid_str[1] = pid_str[2] = L'?';
        pid_str[3] = L'\0';
        pid_size = 4 * sizeof(wchar_t);
    }

    size = sizeof(IO_ERROR_LOG_PACKET) + windivert_size + msg_size + pid_size;
    if (size > ERROR_LOG_MAXIMUM_SIZE)
    {
        return;
    }
    packet = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(driver, (UCHAR)size);
    if (packet == NULL)
    {
        return;
    }
    RtlZeroMemory(packet, size);
    packet->NumberOfStrings = 3;
    packet->StringOffset    = sizeof(IO_ERROR_LOG_PACKET);
    packet->ErrorCode       = WINDIVERT_INFO_EVENT;
    str = (UINT8 *)packet + packet->StringOffset;
    RtlCopyMemory(str, windivert_str, windivert_size);
    str += windivert_size;
    RtlCopyMemory(str, msg_str, msg_size);
    str += msg_size;
    RtlCopyMemory(str, pid_str, pid_size);

    IoWriteErrorLogEntry(packet);
}


```

`sys/windivert.rc`:

```rc
/*
 * windivert.rc
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#include <windows.h>
#include <ntverp.h>

#include "windivert_log.rc"

#define VER_FILETYPE                VFT_DRV
#define VER_FILESUBTYPE             VFT2_DRV_NETWORK
#define VER_FILEDESCRIPTION_STR     \
    "The WinDivert 2.2 driver " \
    "[URL: https://reqrypt.org/windivert.html] " \
    "[Bitcoin: 1C5vZVSbizPeZ8ydTYhUfm4LA2cNwBfcYh]"
#define VER_INTERNALNAME_STR        "WinDivert.sys"
#define VER_ORIGINALFILENAME_STR    "WinDivert.sys"
#define VER_PRODUCTVERSION          2.2
#define VER_PRODUCTVERSION_STR      "2.2"
#define VER_COMPANYNAME_STR         "Basil"
#define VER_LEGALCOPYRIGHT_YEARS    "2011-2019"
#define VER_LEGALCOPYRIGHT_STR      \
    "Copyright \251 " VER_COMPANYNAME_STR " " VER_LEGALCOPYRIGHT_YEARS 
#define VER_FILEVERSION             VER_PRODUCTVERSION
#define VER_FILEVERSION_STR         VER_PRODUCTVERSION_STR
#define VER_PRODUCTNAME_STR         "WinDivert 2.2 driver"

#include "common.ver"


```

`sys/windivert.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<!--

    windivert.vcxproj
    (C) 2019, all rights reserved,
    
    This file is part of WinDivert.
    
    WinDivert is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    WinDivert is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc., 51
    Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
    
-->
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 <ItemGroup Label="ProjectConfigurations">
  <ProjectConfiguration Include="Release|Win32">
   <Configuration>Release</Configuration>
   <Platform>Win32</Platform>
  </ProjectConfiguration>
  <ProjectConfiguration Include="Release|x64">
   <Configuration>Release</Configuration>
   <Platform>x64</Platform>
  </ProjectConfiguration>
 </ItemGroup>
 <ItemGroup>
  <MessageCompile Include="windivert_log.mc">
   <RCFilePath>.</RCFilePath>
   <HeaderFilePath>.</HeaderFilePath>
  </MessageCompile>
 </ItemGroup>
 <ItemGroup>
  <ResourceCompile Include="windivert.rc" />
 </ItemGroup>
 <ItemGroup>
  <ClCompile Include="windivert.c">
   <TreatWarningAsError>false</TreatWarningAsError>
   <Optimization>MaxSpeed</Optimization>
   <AdditionalIncludeDirectories>..\include;..\dll;.</AdditionalIncludeDirectories>
  </ClCompile>
 </ItemGroup>
 <PropertyGroup Label="Globals">
  <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
  <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
  <RootNamespace>WinDivert</RootNamespace>
  <ProjectName>WinDivert</ProjectName>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props"/>
 <PropertyGroup Label="Configuration">
  <TargetVersion>Windows7</TargetVersion>
  <UseDebugLibraries>true</UseDebugLibraries>
  <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
  <ConfigurationType>Driver</ConfigurationType>
  <DriverType>KMDF</DriverType>
  <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  <EnableInf2cat>false</EnableInf2cat>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
 <ItemDefinitionGroup>
  <ClCompile>
   <WppEnabled>false</WppEnabled>
   <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_X86_=1;i386=1;STD_CALL;%(PreprocessorDefinitions);NDIS60;UNICODE;_UNICODE;NDIS_SUPPORT_NDIS60;NT;BINARY_COMPATIBLE=0</PreprocessorDefinitions>
   <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);NDIS60;UNICODE;_UNICODE;NDIS_SUPPORT_NDIS60;NT;BINARY_COMPATIBLE=0</PreprocessorDefinitions>
  </ClCompile>
  <Link>
   <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfLdr.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfDriverEntry.lib;$(DDK_LIB_PATH)\wdmsec.lib;$(DDK_LIB_PATH)\ndis.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib</AdditionalDependencies>
  </Link>
 </ItemDefinitionGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>

```

`sys/windivert_log.mc`:

```mc
;/*
; * windivert_log.mc
; * (C) 2019, all rights reserved,
; *
; * This file is part of WinDivert.
; *
; * WinDivert is free software: you can redistribute it and/or modify it under
; * the terms of the GNU Lesser General Public License as published by the
; * Free Software Foundation, either version 3 of the License, or (at your
; * option) any later version.
; *
; * This program is distributed in the hope that it will be useful, but
; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
; * License for more details.
; *
; * You should have received a copy of the GNU Lesser General Public License
; * along with this program.  If not, see <http://www.gnu.org/licenses/>.
; *
; * WinDivert is free software; you can redistribute it and/or modify it under
; * the terms of the GNU General Public License as published by the Free
; * Software Foundation; either version 2 of the License, or (at your option)
; * any later version.
; * 
; * This program is distributed in the hope that it will be useful, but
; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
; * for more details.
; * 
; * You should have received a copy of the GNU General Public License along
; * with this program; if not, write to the Free Software Foundation, Inc., 51
; * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
; */

MessageIdTypedef=NTSTATUS

SeverityNames = (
    Success       = 0x0:STATUS_SEVERITY_SUCCESS
    Informational = 0x1:STATUS_SEVERITY_INFORMATIONAL
    Warning       = 0x2:STATUS_SEVERITY_WARNING
    Error         = 0x3:STATUS_SEVERITY_ERROR
)

FacilityNames = (
    System    = 0x0:FACILITY_SYSTEM
    Runtime   = 0x2:FACILITY_RUNTIME
    Stubs     = 0x3:FACILITY_STUBS
    Io        = 0x4:FACILITY_IO_ERROR_CODE
    WinDivert = 0x574:FACILITY_WINDIVERT
)

MessageId=0x312D
Facility=WinDivert
Severity=Informational
SymbolicName=WINDIVERT_INFO_EVENT
Language=English
%2 %3 (processId=%4)
.


```

`test/build.sh`:

```sh
#!/bin/bash
#
# build.sh
# (C) 2019, all rights reserved,
#
# This file is part of WinDivert.
#
# WinDivert is free software: you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
# License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# WinDivert is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# Script for MinGW/Linux cross compilation.
# NOTE: run wddk-build.bat before this script.

CC=i686-w64-mingw32-gcc
$CC -fno-ident -s -O2 -I../include/ test.c \
    -o ../install/MINGW/i386/test.exe -lWinDivert -L"../install/MINGW/i386/" 

CC=x86_64-w64-mingw32-gcc
$CC -fno-ident -s -O2 -I../include/ test.c -o ../install/MINGW/amd64/test.exe \
    -lWinDivert -L"../install/MINGW/amd64/"


```

`test/test.c`:

```c
/*
 * test.c
 * (C) 2021, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * WinDivert testing framework.
 */

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include "windivert.h"

#define MAX_PACKET  2048
#define MIN(a, b)   ((a) < (b)? (a): (b))

/*
 * Packet data.
 */
#include "test_data.c"

/*
 * Test entry.
 */
struct packet
{
    const char *packet;
    size_t packet_len;
    char *name;
};

struct test
{
    const char *filter;
    const struct packet *packet;
    BOOL match;
};

/*
 * Prototypes.
 */
static BOOL run_test(HANDLE inject_handle, const char *filter,
    const char *packet, const size_t packet_len, BOOL match, INT64 *diff);
static DWORD monitor_worker(LPVOID arg);

/*
 * Test data.
 */
static const struct packet pkt_echo_request =
{
    echo_request,
    sizeof(echo_request),
    "ipv4_icmp_echo_req"
};
static const struct packet pkt_http_request =
{
    http_request,
    sizeof(http_request),
    "ipv4_tcp_http_req"
};
static const struct packet pkt_dns_request =
{
    dns_request,
    sizeof(dns_request),
    "ipv4_udp_dns_req"
};
static const struct packet pkt_ipv6_tcp_syn =
{
    ipv6_tcp_syn,
    sizeof(ipv6_tcp_syn),
    "ipv6_tcp_syn"
};
static const struct packet pkt_ipv6_echo_reply =
{
    ipv6_echo_reply,
    sizeof(ipv6_echo_reply),
    "ipv6_icmpv6_echo_rep"
};
static const struct packet pkt_ipv6_exthdrs_udp =
{
    ipv6_exthdrs_udp,
    sizeof(ipv6_exthdrs_udp),
    "ipv6_exthdrs_udp"
};
static const struct packet pkt_ipv4_fragment_0 =
{
    ipv4_fragment_0,
    sizeof(ipv4_fragment_0),
    "ipv4_fragemnt_0"
};
static const struct packet pkt_ipv4_fragment_1 =
{
    ipv4_fragment_1,
    sizeof(ipv4_fragment_1),
    "ipv4_fragment_1"
};
static const struct packet pkt_ipv6_fragment_0 =
{
    ipv6_fragment_0,
    sizeof(ipv6_fragment_0),
    "ipv6_fragment_0"
};
static const struct packet pkt_ipv6_fragment_1 =
{
    ipv6_fragment_1,
    sizeof(ipv6_fragment_1),
    "ipv6_fragment_1"
};
static const struct test tests[] =
{
    {"event = PACKET",                         &pkt_echo_request, TRUE},
    {"packet[0] == 0x45",                      &pkt_echo_request, TRUE},
    {"packet[0] == 0x33",                      &pkt_echo_request, FALSE},
    {"packet[55] == 0x1b",                     &pkt_echo_request, TRUE},
    {"packet[55b] == 0x1b",                    &pkt_echo_request, TRUE},
    {"packet[1000] <= 0 || packet[-1000] = 7", &pkt_echo_request, FALSE},
    {"packet[-1] == 0x37 && packet[-2] == 0x36 && packet[-3] == 0x35 && "
     "packet[-4] == 0x34",                     &pkt_echo_request, TRUE},
    {"packet16[0] == 0x4500",                  &pkt_echo_request, TRUE},
    {"packet16[0] == 0x0045",                  &pkt_echo_request, FALSE},
    {"packet16[2b] == 0x0054",                 &pkt_echo_request, TRUE},
    {"packet16[1] == 0x0054",                  &pkt_echo_request, TRUE},
    {"packet16[0] == 0x4500 && packet16[1] == 0x0054 && "
     "packet16[-1] == 0x3637",                 &pkt_echo_request, TRUE},
    {"packet32[0b] == 0x45000054 && packet32[3b] == 0x54123440 && "
     "packet32[-4b] == 0x34353637 && packet32[-5b] == 0x33343536",
                                               &pkt_echo_request, TRUE},
    {"random8 < 10",                           &pkt_echo_request, TRUE},
    {"random16 >= 2222",                       &pkt_echo_request, TRUE},
    {"random32 <= 0x80000000",                 &pkt_echo_request, TRUE},
    {"(random8 < 128? icmp: udp)",             &pkt_echo_request, TRUE},
    {"(random8 <= 128? "
        "(random16 <= 0x8000?"
            "(random32 <= 0x80000000? ip: ipv6): "
            "(random32 <= 0x80000000? icmpv6: icmp)): "
        "(random16 <= 0x8000?"
            "(random32 <= 0x80000000? tcp: icmp.Type >= 8): "
            "(random32 <= 0x80000000? outbound: loopback)))",
                                               &pkt_echo_request, TRUE},
    {"outbound and icmp",                      &pkt_echo_request, TRUE},
    {"outbound",                               &pkt_echo_request, TRUE},
    {"outbound and inbound",                   &pkt_echo_request, FALSE},
    {"loopback",                               &pkt_echo_request, FALSE},
    {"impostor",                               &pkt_echo_request, FALSE},
    {"icmp",                                   &pkt_echo_request, TRUE},
    {"not icmp",                               &pkt_echo_request, FALSE},
    {"ip or ipv6",                             &pkt_echo_request, TRUE},
    {"inbound",                                &pkt_echo_request, FALSE},
    {"tcp",                                    &pkt_echo_request, FALSE},
    {"tcp == TRUE",                            &pkt_echo_request, FALSE},
    {"tcp == FALSE",                           &pkt_echo_request, TRUE},
    {"icmp.Type == 8",                         &pkt_echo_request, TRUE},
    {"icmp.Type == 9",                         &pkt_echo_request, FALSE},
    {"(tcp? ip.Checksum == 0: icmp)",          &pkt_echo_request, TRUE},
    {"(udp? icmp: icmp.Body == 5555)",         &pkt_echo_request, FALSE},
    {"(false? false: false)",                  &pkt_echo_request, FALSE},
    {"(true? true: true)",                     &pkt_echo_request, TRUE},
    {"(tcp or udp or icmpv6 or ipv6? true: false)",
                                               &pkt_echo_request, FALSE},
    {"(ip and ipv6 and tcp and udp? false: icmp > 0)",
                                               &pkt_echo_request, TRUE},
    {"(tcp? tcp.DstPort == 80: true) and (udp? udp.DstPort == 80: true)",
                                               &pkt_echo_request, TRUE},
    {"fragment",                               &pkt_echo_request, FALSE},
    {"ip and ip and ip and ip and ip and "     // Max filter length:
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip and ip and ip and "
     "ip and ip and ip",                       &pkt_echo_request, TRUE},
    {"not true or false or not icmp or "       // All fields:
     "icmp.Body == 33 or icmp.Checksum==2 or "
     "icmp.Code == 0x777 or "
     "icmp.Type == 0x333 or icmpv6 or "
     "icmpv6.Body or icmpv6.Checksum or "
     "icmpv6.Code or icmpv6.Type or "
     "ifIdx == 93923 or inbound or "
     "not ip or ip.Checksum == 8 or "
     "not ip.DF or ip.DstAddr == 1.2.3.4 or "
     "ip.FragOff == 4212 or "
     "ip.HdrLength == 2 or ip.Id = 0x0987 or "
     "ip.Length == 788 or ip.MF == 1 or "
     "ip.Protocol == 999 or "
     "ip.SrcAddr == 9.8.7.255 or "
     "ip.TOS == 3 or ip.TTL = 221 or ipv6 or "
     "ipv6.DstAddr or ipv6.FlowLabel or "
     "ipv6.HopLimit or ipv6.Length or "
     "ipv6.NextHdr or ipv6.SrcAddr or "
     "ipv6.TrafficClass or not outbound or "
     "subIfIdx == 888 or tcp or tcp.Ack or "
     "tcp.AckNum or tcp.Checksum or "
     "tcp.DstPort or tcp.Fin or "
     "tcp.HdrLength or tcp.PayloadLength or "
     "tcp.Psh or tcp.Rst or tcp.SeqNum or "
     "tcp.SrcPort or tcp.Syn or tcp.Urg or "
     "tcp.UrgPtr or tcp.Window or udp or "
     "udp.Checksum or udp.DstPort or "
     "udp.Length or udp.PayloadLength or "
     "udp.SrcPort",                            &pkt_echo_request, FALSE},
    {"(true and (true and (true and (true and "// Deep nesting:
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(true and (true and (true and (true and "
     "(((((((((((((((icmp)))))))))))))))))))"
     "))))))))))))))))))))))))))))))))))))))"
     "))))))))))))))))))))))))))))))))))))))", &pkt_echo_request, TRUE},
    {"not not not not not not not not icmp",   &pkt_echo_request, TRUE},
    {"not not not not not not not icmp",       &pkt_echo_request, FALSE},
    {"!!!!!!!icmp",                            &pkt_echo_request, FALSE},
    {"false and true or true",                 &pkt_echo_request, TRUE},
    {"true and false or false",                &pkt_echo_request, FALSE},
    {"true or true and false",                 &pkt_echo_request, TRUE},
    {"false or false and true",                &pkt_echo_request, FALSE},
    {"tcp && icmp || ip",                      &pkt_echo_request, TRUE},
    {"icmp && udp || tcp",                     &pkt_echo_request, FALSE},
    {"ip || icmp && icmpv6",                   &pkt_echo_request, TRUE},
    {"!ip || !icmp && !udp",                   &pkt_echo_request, FALSE},
    {"(((icmp)? (true): (false)) and "
     "(((tcp)? (false): (true)) and "
     "((ipv6)? (false): (true))))",            &pkt_echo_request, TRUE},
    {"((((packet[31] > 0x54 or (packet[46] == 0x12 and "
     "not packet[78] >= 0x32)) and (not packet[79] <= 0x33 and "
     "not packet[81] > 0x35)) and (((not packet[62] <= 0x22 and "
     "not packet[54] <= 0x1A) and (not packet[69] <= 0x29 or "
     "packet[55] > 0x1B)) or ((not packet[78] != 0x32 and "
     "packet[22] != 0x3C)? (not packet[11] <= 0x00? packet[7] >= 0x00: "
     "packet[67] >= 0x27): (packet[1] < 0x00? not packet[49] == 0x15: "
     "not packet[44] != 0x10))))? ((((not packet[11] > 0x00 and "
     "not packet[62] <= 0x22) or (packet[7] < 0x00? packet[23] < 0xD2: "
     "not packet[10] != 0x00)) and not packet[74] != 0x2E) or "
     "packet[43] >= 0x00): ((((packet[3] == 0x54? packet[19] == 0x08: "
     "packet[8] > 0x40) or not packet[80] > 0x34)? ((packet[9] >= 0x01? "
     "packet[5] != 0x34: packet[61] > 0x21) or (packet[44] > 0x10 and "
     "packet[63] < 0x23)): ((packet[80] <= 0x34 or not packet[78] < 0x32)? "
     "(packet[19] != 0x08? packet[40] == 0x00: not packet[71] == 0x2B): "
     "(not packet[39] < 0x00 or packet[38] != 0x0A))) or "
     "(((not packet[81] > 0x35 and packet[22] <= 0x3C)? "
     "(not packet[60] != 0x20? packet[28] < 0x8B: not packet[74] != 0x2E): "
     "packet[8] <= 0x40) or ((packet[60] == 0x20? packet[57] <= 0x1D: "
     "packet[24] >= 0x0D)? (packet[34] > 0x00 or not packet[53] < 0x19): "
     "(packet[11] < 0x00 and packet[35] != 0x00)))))",
                                               &pkt_echo_request, TRUE},
    {"(((((packet[23] <= 0xD2 and not packet[1] >= 0x00)? "
     "(packet[3] != 0x54 or packet[45] >= 0x11): (packet[4] > 0x12 and "
     "packet[2] != 0x00)) or packet[24] > 0x0D) or (((not packet[57] > 0x1D? "
     "packet[62] == 0x22: not packet[12] < 0x0A) or (packet[28] > 0x8B? "
     "not packet[48] > 0x14: not packet[64] > 0x24)) or ((packet[80] >= 0x34? "
     "not packet[3] != 0x54: not packet[26] <= 0x00) and "
     "(packet[68] != 0x28 and packet[32] == 0x00))))? not packet[1] == 0x00: "
     "((((not packet[36] > 0xF9 and not packet[70] == 0x2A) or "
     "(not packet[3] <= 0x54? packet[1] > 0x00: not packet[14] != 0x00)) and "
     "packet[57] <= 0x1D)? packet[38] == 0x0A: (((not packet[59] != 0x1F? "
     "packet[46] < 0x12: not packet[81] < 0x35) and (packet[27] >= 0x01? "
     "not packet[50] > 0x16: not packet[7] <= 0x00))? ((packet[76] >= 0x30 or "
     "not packet[54] >= 0x1A) and packet[64] < 0x24): "
     "((packet[58] <= 0x1E and packet[81] < 0x35)? (packet[20] < 0x08 or "
     "packet[22] <= 0x3C): (not packet[70] >= 0x2A? packet[31] < 0x54: "
     "not packet[69] <= 0x29)))))",            &pkt_echo_request, FALSE},
    {"ip.HdrLength == 5 and ip.TOS == 0 and ip.Length == 84 and "
     "ip.Id == 0x1234 and ip.FragOff == 0 and ip.MF == 0 and ip.DF == 1 and "
     "ip.TTL == 64 and ip.Protocol == 1 and ip.SrcAddr == 0xFFFF0A000001 and "
     "ip.DstAddr == 0xFFFF08080808 and icmp.Type == 8 and icmp.Code == 0 and "
     "icmp.Body == 0x0D560001",                &pkt_echo_request, TRUE},
    {"ip.HdrLength > 5 or ip.TOS > 0 or ip.Length != 84 or ip.Id < 0x1234 or "
     "ip.FragOff != 0 or ip.MF < 0 or ip.DF != 1 or ip.TTL > 64 or "
     "ip.Protocol != 1 or ip.SrcAddr < 0xFFFF0A000001 or "
     "ip.DstAddr < 0xFFFF08080808 or icmp.Type != 8 or icmp.Code != 0 or "
     "icmp.Body != 0x0D560001",                &pkt_echo_request, FALSE},
    {"localAddr == 10.0.0.1 && remoteAddr == 8.8.8.8 && localPort == 8 && "
     "remotePort == 0 && protocol == 1",       &pkt_echo_request, TRUE},
    {"packet[0] == 0x45",                      &pkt_echo_request, TRUE},
    {"ip.MF or ip.FragOff != 0",               &pkt_echo_request, FALSE},
    {"icmp.Body != 123 || icmp.Body == 123",   &pkt_echo_request, TRUE},
    {"length == 84 && ip.Length == 84",        &pkt_echo_request, TRUE},
    {"tcp",                                    &pkt_http_request, TRUE},
    {"protocol == TCP",                        &pkt_http_request, TRUE},
    {"outbound and tcp and tcp.DstPort == 80", &pkt_http_request, TRUE},
    {"outbound and tcp and tcp.DstPort == 81", &pkt_http_request, FALSE},
    {"outbound and tcp and tcp.DstPort != 80", &pkt_http_request, FALSE},
    {"inbound and tcp and tcp.DstPort == 80",  &pkt_http_request, FALSE},
    {"tcp.PayloadLength == 469",               &pkt_http_request, TRUE},
    {"tcp.PayloadLength != 469",               &pkt_http_request, FALSE},
    {"tcp.PayloadLength >= 469",               &pkt_http_request, TRUE},
    {"tcp.PayloadLength <= 469",               &pkt_http_request, TRUE},
    {"tcp.PayloadLength > 469",                &pkt_http_request, FALSE},
    {"tcp.PayloadLength < 469",                &pkt_http_request, FALSE},
    {"(outbound? (ip? (tcp.DstPort == 80? (tcp.PayloadLength > 0? true: "
        "false): false): false): false)",      &pkt_http_request, TRUE},
    {"(outbound? (ip? (tcp.DstPort == 80? (tcp.PayloadLength == 0? true: "
        "false): false): false): false)",      &pkt_http_request, FALSE},
    {"(ipv6? tcp and tcp.DstPort = 1234 and (tcp.SrcPort = 999? !tcp.UrgPtr: "
     "tcp.Syn) or udp: ip and tcp.DstPort == 80)",
                                               &pkt_http_request, TRUE},
    {"packet32[0] = 0x45000209 && packet32[1] = 0x482d4000 && "
     "packet16[8b] = 0x4006 && packet32[3] = 0x0a0a0a0a && "
     "packet32[4] = 0x5db8d877 && packet32[5] = 0xa31a0050 && "
     "packet32[6] = 0x5338ccc2 && packet32[7] = 0x5637b355 && "
     "packet32[8] = 0x80180073 && packet16[38b] = 0x0000 && "
     "packet32[10] = 0x0101080a && packet32[11] = 0x002c851b && "
     "packet32[12] = 0x1b7f3a71 && packet32[13] = 0x47455420 && "
     "packet32[14] = 0x2f204854 && packet32[15] = 0x54502f31 && "
     "packet32[16] = 0x2e310d0a && packet32[17] = 0x486f7374 && "
     "packet32[18] = 0x3a207777 && packet32[19] = 0x772e6578 && "
     "packet32[20] = 0x616d706c && packet32[21] = 0x652e636f && "
     "packet32[22] = 0x6d0d0a43 && packet32[23] = 0x6f6e6e65 && "
     "packet32[24] = 0x6374696f && packet32[25] = 0x6e3a206b && "
     "packet32[26] = 0x6565702d && packet32[27] = 0x616c6976 && "
     "packet32[28] = 0x650d0a43 && packet32[29] = 0x61636865 && "
     "packet32[30] = 0x2d436f6e && packet32[31] = 0x74726f6c && "
     "packet32[32] = 0x3a206d61 && packet32[33] = 0x782d6167 && "
     "packet32[34] = 0x653d300d && packet32[35] = 0x0a416363 && "
     "packet32[36] = 0x6570743a && packet32[37] = 0x20746578 && "
     "packet32[38] = 0x742f6874 && packet32[39] = 0x6d6c2c61 && "
     "packet32[40] = 0x70706c69 && packet32[41] = 0x63617469 && "
     "packet32[42] = 0x6f6e2f78 && packet32[43] = 0x68746d6c && "
     "packet32[44] = 0x2b786d6c && packet32[45] = 0x2c617070 && "
     "packet32[46] = 0x6c696361 && packet32[47] = 0x74696f6e && "
     "packet32[48] = 0x2f786d6c && packet32[49] = 0x3b713d30 && "
     "packet32[50] = 0x2e392c69 && packet32[51] = 0x6d616765 && "
     "packet32[52] = 0x2f776562 && packet32[53] = 0x702c2a2f && "
     "packet32[54] = 0x2a3b713d && packet32[55] = 0x302e380d && "
     "packet32[56] = 0x0a557365 && packet32[57] = 0x722d4167 && "
     "packet32[58] = 0x656e743a && packet32[59] = 0x20585858 && "
     "packet32[60] = 0x58585858 && packet32[61] = 0x58585858 && "
     "packet32[62] = 0x58585858 && packet32[63] = 0x58585858 && "
     "packet32[64] = 0x58585858 && packet32[65] = 0x58585858 && "
     "packet32[66] = 0x58585858 && packet32[67] = 0x58585858 && "
     "packet32[68] = 0x58585858 && packet32[69] = 0x58585858 && "
     "packet32[70] = 0x58585858 && packet32[71] = 0x58585858 && "
     "packet32[72] = 0x58585858 && packet32[73] = 0x58585858 && "
     "packet32[74] = 0x58585858 && packet32[75] = 0x58585858 && "
     "packet32[76] = 0x58585858 && packet32[77] = 0x58585858 && "
     "packet32[78] = 0x58585858 && packet32[79] = 0x58585858 && "
     "packet32[80] = 0x58585858 && packet32[81] = 0x58585858 && "
     "packet32[82] = 0x58585858 && packet32[83] = 0x58585858 && "
     "packet32[84] = 0x58585858 && packet32[85] = 0x58585858 && "
     "packet32[86] = 0x58585858 && packet32[87] = 0x58585858 && "
     "packet32[88] = 0x58585858 && packet32[89] = 0x58585858 && "
     "packet32[90] = 0x58585858 && packet32[91] = 0x58585858 && "
     "packet32[92] = 0x58580d0a && packet32[93] = 0x41636365 && "
     "packet32[94] = 0x70742d45 && packet32[95] = 0x6e636f64 && "
     "packet32[96] = 0x696e673a && packet32[97] = 0x20677a69 && "
     "packet32[98] = 0x702c6465 && packet32[99] = 0x666c6174 && "
     "packet32[100] = 0x652c7364 && packet32[101] = 0x63680d0a && "
     "packet32[102] = 0x41636365 && packet32[103] = 0x70742d4c && "
     "packet32[104] = 0x616e6775 && packet32[105] = 0x6167653a && "
     "packet32[106] = 0x20656e2d && packet32[107] = 0x55532c65 && "
     "packet32[108] = 0x6e3b713d && packet32[109] = 0x302e380d && "
     "packet32[110] = 0x0a49662d && packet32[111] = 0x4e6f6e65 && "
     "packet32[112] = 0x2d4d6174 && packet32[113] = 0x63683a20 && "
     "packet32[114] = 0x22333333 && packet32[115] = 0x33333333 && "
     "packet32[116] = 0x3333220d && packet32[117] = 0x0a49662d && "
     "packet32[118] = 0x4d6f6469 && packet32[119] = 0x66696564 && "
     "packet32[120] = 0x2d53696e && packet32[121] = 0x63653a20 && "
     "packet32[122] = 0x4672692c && packet32[123] = 0x20303320 && "
     "packet32[124] = 0x41756720 && packet32[125] = 0x32303134 && "
     "packet32[126] = 0x2031333a && packet32[127] = 0x33333a33 && "
     "packet32[128] = 0x3320474d && packet32[129] = 0x540d0a0d && "
     "packet[-1] = 0x0a",                      &pkt_http_request, TRUE},
    {"tcp.Payload16[-1] == 0x0d0a",            &pkt_http_request, TRUE},
    {"tcp.Payload32[-2] == 0x20474d54",        &pkt_http_request, TRUE},
    {"(ipv6? true: false) or (udp? udp.DstPort != 53: false) or "
     "(not tcp and not udp? true: false)",     &pkt_http_request, FALSE},
    {"ip and !loopback and (outbound? tcp.DstPort == 80 or"
     " tcp.DstPort == 443 or udp.DstPort == 53 :"
     " icmp.Type == 11 and icmp.Code == 0)",   &pkt_http_request, TRUE},
    {"random8 < 128",                          &pkt_http_request, TRUE},
    {"(random8 < 128? random16 < 0x8000: random32 < 0x80000000)",
                                               &pkt_http_request, TRUE},
    {"(random32 < 0x22223333? packet32[72] == 0x58585858: udp)",
                                               &pkt_http_request, TRUE},
    {"(((((not packet[340] != 0x58? not packet[173] < 0x74: "
     "not packet[376] > 0x70) or not packet[87] != 0x6F) or "
     "not packet[226] > 0x73) and (((not packet[289] <= 0x58 and "
     "not packet[76] > 0x77) and (packet[231] < 0x67 and "
     "not packet[24] < 0x53))? ((packet[365] > 0x58? not packet[91] <= 0x43: "
     "not packet[310] <= 0x58) or (not packet[515] < 0x4D or "
     "packet[518] >= 0x0A)): ((not packet[209] < 0x77? "
     "not packet[237] > 0x58: not packet[286] == 0x58)? "
     "(packet[354] == 0x58 or packet[502] > 0x31): not packet[2] > 0x02)))? "
     "(((packet[520] <= 0x0A? (packet[484] == 0x63 and packet[83] >= 0x6C): "
     "(packet[384] >= 0x69 or packet[245] >= 0x58)) and "
     "(packet[106] > 0x70 or packet[45] != 0x2C))? (((packet[153] == 0x2F or "
     "packet[139] >= 0x0D) and (packet[136] != 0x65? packet[100] == 0x6E: "
     "not packet[128] == 0x3A))? ((not packet[288] != 0x58 or "
     "not packet[309] == 0x58) and packet[350] <= 0x58): "
     "not packet[129] >= 0x20): (not packet[493] != 0x30 and "
     "((packet[465] != 0x33 or not packet[386] >= 0x67)? "
     "(packet[470] >= 0x66 or not packet[259] >= 0x58): "
     "packet[408] != 0x41))): ((((not packet[500] > 0x32 or "
     "not packet[163] < 0x69) and not packet[122] == 0x6F) and "
     "((packet[324] <= 0x58 and packet[481] > 0x53)? "
     "(not packet[17] > 0xB8 and packet[102] != 0x20): (packet[303] > 0x58 or "
     "packet[345] >= 0x58)))? (packet[191] < 0x6E and ((packet[429] <= 0x53? "
     "not packet[239] >= 0x58: packet[258] < 0x58)? packet[382] >= 0x6F: "
     "(packet[443] == 0x2D? not packet[67] < 0x0A: packet[168] <= 0x6F))): "
     "(((packet[34] == 0x00 and not packet[77] != 0x2E)? "
     "(packet[27] != 0xC2? not packet[477] <= 0x69: not packet[472] != 0x4D): "
     "(not packet[157] >= 0x6C or not packet[308] <= 0x58)) or "
     "((not packet[293] == 0x58? not packet[83] != 0x6C: packet[70] > 0x73)? "
     "(not packet[260] < 0x58? packet[98] != 0x69: not packet[226] <= 0x73): "
     "(packet[139] < 0x0D and not packet[171] == 0x78)))))",
                                                &pkt_http_request, FALSE},
    {"(((((packet[307] > 0x58 or packet[437] == 0x2E)? (packet[331] <= 0x58? "
     "packet[39] != 0x00: not packet[503] > 0x34): not packet[248] >= 0x58)? "
     "((not packet[266] >= 0x58? packet[510] != 0x3A: "
     "not packet[343] == 0x58)? (not packet[183] == 0x70 and "
     "not packet[333] <= 0x58): (packet[456] >= 0x22? packet[400] <= 0x65: "
     "not packet[218] <= 0x71)): (packet[482] <= 0x69? "
     "(packet[288] > 0x58 and packet[142] == 0x63): (packet[8] >= 0x40 or "
     "not packet[211] == 0x62))) or ((packet[267] <= 0x58 and "
     "(packet[35] != 0x73? packet[36] == 0x02: not packet[100] > 0x6E)) and "
     "(not packet[170] > 0x2F and (not packet[289] != 0x58 and "
     "not packet[344] < 0x58)))) or ((((not packet[468] > 0x0A and "
     "not packet[372] >= 0x41) and (packet[513] < 0x20 or "
     "packet[306] == 0x58)) or ((not packet[431] <= 0x65 and "
     "not packet[144] < 0x65)? (packet[478] != 0x65? packet[37] <= 0xA4: "
     "not packet[26] < 0xCC): (not packet[269] != 0x58 and "
     "packet[149] != 0x74)))? (((packet[422] <= 0x65 and "
     "not packet[176] > 0x2B) and (not packet[417] > 0x6E? "
     "not packet[451] <= 0x74: packet[348] >= 0x58)) and "
     "packet[284] != 0x58): (((packet[200] < 0x2E and packet[89] < 0x0D) or "
     "(packet[469] == 0x49 and not packet[384] == 0x69))? "
     "((not packet[105] >= 0x65 or packet[128] == 0x3A) or "
     "packet[389] <= 0x67): not packet[271] >= 0x58)))",
                                                &pkt_http_request, TRUE},
    {"(packet[248] != 0x58? ((packet[470] > 0x66 and ((packet[96] < 0x63? "
     "not packet[216] >= 0x2A: packet[261] == 0x58)? "
     "(not packet[166] > 0x74? packet[502] >= 0x31: not packet[387] > 0x3A): "
     "(not packet[387] > 0x3A? not packet[265] < 0x58: "
     "packet[237] < 0x58))) and ((not packet[264] < 0x58 or "
     "(not packet[113] >= 0x0D? not packet[423] == 0x3A: "
     "packet[329] == 0x58)) and (not packet[515] < 0x4D? "
     "(packet[172] >= 0x68? packet[286] != 0x58: not packet[121] != 0x43): "
     "(not packet[160] < 0x70? not packet[322] != 0x58: "
     "not packet[398] < 0x61)))): ((((packet[298] < 0x58 and "
     "packet[268] > 0x58) and (not packet[447] <= 0x65 or "
     "packet[149] >= 0x74)) or ((not packet[517] != 0x0D or "
     "packet[179] < 0x6C)? (not packet[343] > 0x58 or "
     "not packet[186] < 0x63): (not packet[255] > 0x58 or "
     "not packet[487] == 0x20))) and (((not packet[149] < 0x74? "
     "not packet[125] == 0x72: packet[496] < 0x41) and "
     "(not packet[344] == 0x58? not packet[261] != 0x58: "
     "not packet[317] >= 0x58))? (packet[100] == 0x6E? "
     "(not packet[233] == 0x6E? packet[120] >= 0x2D: not packet[186] > 0x63): "
     "(not packet[360] == 0x58 or packet[133] > 0x2D)): "
     "not packet[477] == 0x69)))",              &pkt_http_request, FALSE},
    {"ip.HdrLength == 5 and ip.TOS == 0 and ip.Length == 521 and "
     "ip.Id == 0x482D and ip.FragOff == 0 and ip.MF == 0 and ip.DF == 1 and "
     "ip.TTL == 64 and ip.Protocol == 6 and ip.SrcAddr == 0xFFFF0A0A0A0A and "
     "ip.DstAddr == 0xFFFF5DB8D877 and tcp.SrcPort == 41754 and "
     "tcp.DstPort == 80 and tcp.SeqNum == 1396231362 and "
     "tcp.AckNum == 1446490965 and tcp.HdrLength == 8 and tcp.Fin == 0 and "
     "tcp.Syn == 0 and tcp.Rst == 0 and tcp.Psh == 1 and tcp.Ack == 1 and "
     "tcp.Urg == 0 and tcp.Window == 115 and tcp.UrgPtr == 0",
                                               &pkt_http_request, TRUE},
    {"ip.HdrLength > 5 or ip.TOS < 0 or ip.Length < 521 or ip.Id != 0x482D or "
     "ip.FragOff != 0 or ip.MF != 0 or ip.DF < 1 or ip.TTL < 64 or "
     "ip.Protocol > 6 or ip.SrcAddr != 0xFFFF0A0A0A0A or "
     "ip.DstAddr < 0xFFFF5DB8D877 or tcp.SrcPort < 41754 or "
     "tcp.DstPort < 80 or tcp.SeqNum != 1396231362 or "
     "tcp.AckNum < 1446490965 or tcp.HdrLength < 8 or tcp.Fin != 0 or "
     "tcp.Syn != 0 or tcp.Rst != 0 or tcp.Psh != 1 or tcp.Ack > 1 or "
     "tcp.Urg != 0 or tcp.Window < 115 or tcp.UrgPtr < 0",
                                               &pkt_http_request, FALSE},
    {"localAddr == 10.10.10.10 && remoteAddr == 93.184.216.119 && "
     "localPort == 41754 && remotePort == 80 && protocol == 6",
                                               &pkt_http_request, TRUE},
    {"udp",                                    &pkt_dns_request, TRUE},
    {"udp && udp.SrcPort > 1 && ipv6",         &pkt_dns_request, FALSE},
    {"udp.DstPort == 53",                      &pkt_dns_request, TRUE},
    {"udp.DstPort > 100",                      &pkt_dns_request, FALSE},
    {"zero = 0",                               &pkt_dns_request, TRUE},
    {"zero = 1",                               &pkt_dns_request, FALSE},
    {"ip.DstAddr = 8.8.4.4",                   &pkt_dns_request, TRUE},
    {"ip.DstAddr = 8.8.8.8",                   &pkt_dns_request, FALSE},
    {"ip.DstAddr >= 8.8.0.0 &&"
     "ip.DstAddr <= 8.8.255.255",              &pkt_dns_request, TRUE},
    {"ip.SrcAddr >= 10.0.0.0 && ip.SrcAddr <= 10.255.255.255",
                                               &pkt_dns_request, TRUE},
    {"ip.SrcAddr < 10.0.0.0 or ip.SrcAddr > 10.255.255.255",
                                               &pkt_dns_request, FALSE},
    {"ip.DstAddr == ::ffff:8.8.4.4",           &pkt_dns_request, TRUE},
    {"ip.DstAddr == ::0:ffff:8.8.4.4",         &pkt_dns_request, TRUE},
    {"remoteAddr == 8.8.4.4",                  &pkt_dns_request, TRUE},
    {"remoteAddr == ::ffff:8.8.4.4",           &pkt_dns_request, TRUE},
    {"protocol == 17",                         &pkt_dns_request, TRUE},
    {"remotePort == 53",                       &pkt_dns_request, TRUE},
    {"(ipv6? true: false) or (udp? udp.DstPort != 53: false) or "
     "(not tcp and not udp? true: false)",     &pkt_dns_request, FALSE},
    {"ipv6 or (not tcp and udp.DstPort != 53)",&pkt_dns_request, FALSE},
    {"udp.PayloadLength == 29",                &pkt_dns_request, TRUE},
    {"udp.Payload16[-1] == 0x0001 && udp.Payload16[-2] == 0x0001",
                                               &pkt_dns_request, TRUE},
    {"packet16[-1] == 0x0001 && packet16[-2] == 0x0001",
                                               &pkt_dns_request, TRUE},
    {"tcp.Payload32[0] > 0",                   &pkt_dns_request, FALSE},
    {"udp.Payload32[1] > 0",                   &pkt_dns_request, TRUE},
    {"length == 57",                           &pkt_dns_request, TRUE},
    {"(length > 57? udp: tcp)",                &pkt_dns_request, FALSE},
    {"protocol == UDP",                        &pkt_dns_request, TRUE},
    {"random8 < 128",                          &pkt_dns_request, TRUE},
    {"(random8 < 128? random16 < 0x8000: random32 < 0x80000000)",
                                               &pkt_dns_request, TRUE},
    {"((((not packet[22] < 0x00 or (packet[14] > 0x00 and "
     "packet[8] <= 0x49))? (not packet[3] > 0x39 and packet[22] <= 0x00): "
     "not packet[1] <= 0x00) and (((packet[27] != 0xA7 or "
     "packet[16] != 0x08) or (packet[3] > 0x39? packet[18] > 0x04: "
     "not packet[32] != 0x00))? ((packet[32] == 0x00? not packet[51] > 0x6D: "
     "packet[54] == 0x01)? (not packet[3] >= 0x39 and packet[7] != 0x00): "
     "not packet[45] >= 0x70): ((not packet[5] != 0x90? packet[52] > 0x00: "
     "packet[49] == 0x63) and (not packet[46] >= 0x6C? packet[15] <= 0x01: "
     "not packet[27] >= 0xA7))))? ((((packet[22] > 0x00? "
     "not packet[36] >= 0x00: packet[0] > 0x45)? (packet[31] != 0x00? "
     "not packet[40] == 0x07: packet[31] >= 0x00): not packet[43] > 0x61) and "
     "((not packet[16] == 0x08 and not packet[13] >= 0x00)? "
     "(packet[24] <= 0x00 or packet[15] != 0x01): "
     "(packet[56] < 0x01? packet[50] > 0x6F: not packet[56] == 0x01)))? "
     "(packet[15] >= 0x01 or ((not packet[14] < 0x00? not packet[39] >= 0x00: "
     "not packet[4] == 0x20)? (packet[12] >= 0x0A and "
     "not packet[25] <= 0x25): packet[2] < 0x00)): "
     "(((not packet[19] <= 0x04 or not packet[25] < 0x25)? "
     "(packet[10] != 0x00 or packet[25] < 0x25): (not packet[46] > 0x6C? "
     "not packet[23] <= 0x35: packet[56] < 0x01))? "
     "((not packet[48] >= 0x03 or not packet[1] == 0x00)? "
     "(packet[47] >= 0x65 and not packet[13] == 0x00): (packet[34] <= 0x00? "
     "packet[22] <= 0x00: packet[43] >= 0x61)): (not packet[6] < 0x00 and "
     "not packet[41] < 0x65))): (((not packet[21] != 0x45 and "
     "(packet[26] < 0x22 or not packet[46] <= 0x6C)) and "
     "((not packet[56] > 0x01? packet[3] == 0x39: not packet[42] >= 0x78)? "
     "(not packet[4] > 0x20 or not packet[8] >= 0x49): "
     "packet[34] > 0x00)) and ((packet[50] >= 0x6F and "
     "(packet[1] != 0x00 and not packet[37] != 0x00)) and "
     "((packet[28] == 0x17 or not packet[11] < 0x00) or (packet[40] == 0x07? "
     "not packet[54] > 0x01: packet[18] < 0x04)))))",
                                               &pkt_dns_request, FALSE},
    {"((((packet[26] > 0x22 or packet[19] != 0x04)? ((not packet[17] > 0x08? "
     "packet[20] != 0xE0: packet[52] < 0x00) and not packet[31] == 0x00): "
     "((not packet[23] == 0x35 and packet[13] < 0x00) and "
     "(not packet[44] > 0x6D and packet[22] <= 0x00)))? "
     "(((not packet[27] >= 0xA7? packet[34] >= 0x00: "
     "not packet[38] < 0x00) and (not packet[37] < 0x00? packet[40] > 0x07: "
     "not packet[50] >= 0x6F)) and packet[36] != 0x00): "
     "(((packet[16] == 0x08? not packet[50] > 0x6F: packet[51] != 0x6D)? "
     "not packet[29] != 0x08: packet[16] <= 0x08)? "
     "((not packet[32] != 0x00 or not packet[26] != 0x22) or "
     "(not packet[27] != 0xA7 and not packet[21] == 0x45)): "
     "((packet[30] >= 0x01 or packet[40] > 0x07) or "
     "(not packet[46] < 0x6C and packet[56] <= 0x01))))? packet[31] <= 0x00: "
     "(not packet[50] >= 0x6F and not packet[9] <= 0x11))",
                                               &pkt_dns_request, TRUE},
    {"packet32[13] <= 0xFFFFFFE",              &pkt_dns_request, TRUE},
    {"packet32[53b] <= 0xFFFFFFE",             &pkt_dns_request, TRUE},
    {"packet32[14] <= 0xFFFFFFE",              &pkt_dns_request, FALSE},
    {"packet32[54b] <= 0xFFFFFFE",             &pkt_dns_request, FALSE},
    {"ip.HdrLength == 5 and ip.TOS == 0 and ip.Length == 57 and "
     "ip.Id == 0x2090 and ip.FragOff == 0 and ip.MF == 0 and ip.DF == 0 and "
     "ip.TTL == 73 and ip.Protocol == 17 and ip.SrcAddr == 0xFFFF0A000001 and "
     "ip.DstAddr == 0xFFFF08080404 and udp.SrcPort == 57413 and "
     "udp.DstPort == 53 and udp.Length == 37", &pkt_dns_request, TRUE},
    {"ip.HdrLength > 5 or ip.TOS > 0 or ip.Length < 57 or ip.Id > 0x2090 or "
     "ip.FragOff != 0 or ip.MF < 0 or ip.DF < 0 or ip.TTL > 73 or "
     "ip.Protocol < 17 or ip.SrcAddr < 0xFFFF0A000001 or "
     "ip.DstAddr > 0xFFFF08080404 or udp.SrcPort > 57413 or "
     "udp.DstPort != 53 or udp.Length < 37",   &pkt_dns_request, FALSE},
    {"localAddr == 10.0.0.1 && remoteAddr == 8.8.4.4 && "
     "localPort == 57413 && remotePort == 53 && protocol == 17",
                                               &pkt_dns_request, TRUE},
    {"ipv6.DstAddr >= ::",                     &pkt_dns_request, FALSE},
    {"ipv6",                                   &pkt_ipv6_tcp_syn, TRUE},
    {"ip",                                     &pkt_ipv6_tcp_syn, FALSE},
    {"tcp.Syn",                                &pkt_ipv6_tcp_syn, TRUE},
    {"tcp.Syn == ::1 && tcp.Syn < ::ffff:aaaa:bbbb:cccc:dddd",
                                               &pkt_ipv6_tcp_syn, TRUE},
    {"tcp.DstPort >= 23 && tcp.DstPort <= 23", &pkt_ipv6_tcp_syn, TRUE},
    {"tcp.Syn and not tcp.Ack",                &pkt_ipv6_tcp_syn, TRUE},
    {"tcp.Syn == 1 && tcp.Ack == 0",           &pkt_ipv6_tcp_syn, TRUE},
    {"tcp.Rst or tcp.Fin",                     &pkt_ipv6_tcp_syn, FALSE},
    {"(tcp.Syn? !tcp.Rst && !tcp.Fin: true)",  &pkt_ipv6_tcp_syn, TRUE},
    {"(tcp.Rst? !tcp.Syn: (tcp.Fin? !tcp.Syn: tcp.Syn))",
                                               &pkt_ipv6_tcp_syn, TRUE},
    {"(tcp.Rst or tcp.Urg or tcp.Psh or tcp.Fin? false: tcp.Syn)",
                                               &pkt_ipv6_tcp_syn, TRUE},
    {"(tcp.Rst and tcp.Urg and tcp.Psh and tcp.Fin? false: tcp.Syn)",
                                               &pkt_ipv6_tcp_syn, TRUE},
    {"tcp.PayloadLength == 0",                 &pkt_ipv6_tcp_syn, TRUE},
    {"ip and !loopback and (outbound? tcp.DstPort == 80 or"
     " tcp.DstPort == 443 or udp.DstPort == 53 :"
     " icmp.Type == 11 and icmp.Code == 0)",   &pkt_ipv6_tcp_syn, FALSE},
    {"ipv6.SrcAddr == 1234:5678:1::aabb:ccdd", &pkt_ipv6_tcp_syn, TRUE},
    {"ipv6.SrcAddr == aabb:5678:1::1234:ccdd", &pkt_ipv6_tcp_syn, FALSE},
    {"tcp.SrcPort == 50046",                   &pkt_ipv6_tcp_syn, TRUE},
    {"tcp.SrcPort == 0x0000C37E",              &pkt_ipv6_tcp_syn, TRUE},
    {"packet32[0b] == 0x60000000 && packet32[1b] == 0x00000000 && "
     "packet32[2b] == 0x00000028 && packet32[3b] == 0x00002806 && "
     "packet32[4b] == 0x00280640 && packet32[5b] == 0x28064012 && "
     "packet32[-4b] == 0x01030307 && packet32[-5b] == 0x00010303",
                                               &pkt_ipv6_tcp_syn, TRUE},
    {"tcp.Payload32[0] > 0",                   &pkt_ipv6_tcp_syn, FALSE},
    {"random8 < 128",                          &pkt_ipv6_tcp_syn, TRUE},
    {"(random8 < 128? random16 < 0x8000: random32 < 0x80000000)",
                                               &pkt_ipv6_tcp_syn, TRUE},
    {"((((packet[56] != 0xC3? not packet[26] > 0x00: (packet[50] <= 0x00? "
     "packet[62] < 0xFF: not packet[43] < 0x17))? not packet[2] > 0x00: "
     "(packet[69] != 0xFF or (not packet[28] >= 0x00 and "
     "not packet[79] > 0x07)))? (((packet[46] < 0xC8 or "
     "packet[47] == 0xAA) or (packet[51] == 0x00 and packet[0] >= 0x60))? "
     "packet[55] == 0xAA: not packet[79] >= 0x07): not packet[53] < 0x02)? "
     "((not packet[65] > 0x02 and ((packet[36] >= 0x00 or "
     "packet[24] < 0x00) and packet[3] != 0x00)) and (not packet[56] < 0xC3? "
     "(not packet[0] <= 0x60 and (not packet[38] == 0x00 and "
     "packet[78] > 0x03)): ((not packet[56] == 0xC3 and "
     "not packet[9] < 0x34) and (packet[21] > 0xBB? not packet[67] < 0x0A: "
     "not packet[75] >= 0x00)))): not packet[5] > 0x28)",
                                                &pkt_ipv6_tcp_syn, FALSE},
    {"(((packet[8] >= 0x12 and ((not packet[36] >= 0x00? "
     "not packet[57] > 0x5E: packet[66] > 0x08) and "
     "(not packet[53] > 0x02? not packet[2] == 0x00: packet[76] < 0x01))) or "
     "(((not packet[26] <= 0x00? not packet[57] <= 0x5E: packet[7] >= 0x40)? "
     "packet[60] > 0x02: not packet[11] <= 0x78) or ((packet[71] != 0x86? "
     "packet[65] > 0x02: not packet[4] > 0x00)? (not packet[2] != 0x00? "
     "not packet[57] < 0x5E: not packet[14] == 0x00): "
     "(not packet[25] != 0x00 or packet[29] >= 0x00)))) or "
     "(not packet[59] <= 0x00 or ((packet[76] < 0x01? not packet[7] < 0x40: "
     "(packet[66] != 0x08 and not packet[30] > 0x00)) or "
     "not packet[20] <= 0xAA)))",               &pkt_ipv6_tcp_syn, TRUE},
    {"((packet[50] >= 0x00? packet[8] != 0x12: (((packet[33] > 0x00? "
     "packet[15] >= 0x00: not packet[21] == 0xBB) or (packet[67] > 0x0A? "
     "packet[9] == 0x34: packet[36] > 0x00)) and (packet[74] < 0x00? "
     "(packet[60] != 0x02 and not packet[26] >= 0x00): "
     "(not packet[29] == 0x00 and not packet[25] < 0x00)))) or "
     "((((not packet[69] != 0xFF or packet[10] >= 0x56)? packet[8] >= 0x12: "
     "(packet[78] < 0x03 and packet[9] >= 0x34))? ((packet[40] <= 0xC3? "
     "not packet[15] > 0x00: not packet[71] != 0x86) and "
     "not packet[45] != 0xD7): ((not packet[50] >= 0x00 or "
     "not packet[1] == 0x00) or not packet[55] >= 0xAA))? "
     "(not packet[32] == 0x00? (not packet[58] <= 0x00 and "
     "not packet[8] > 0x12): (not packet[7] < 0x40 or "
     "not packet[4] >= 0x00)): (((not packet[23] < 0xDD or "
     "packet[68] >= 0xFF) and (packet[50] == 0x00 and "
     "not packet[12] >= 0x00))? packet[48] >= 0x00: ((packet[10] != 0x56 and "
     "not packet[4] == 0x00) and (packet[11] >= 0x78? not packet[18] > 0x00: "
     "not packet[55] == 0xAA)))))",             &pkt_ipv6_tcp_syn, TRUE},
    {"((packet[79] <= 0x07 and not packet[62] == 0xFF) and "
     "((((not packet[20] > 0xAA? packet[20] <= 0xAA: packet[27] <= 0x00) and "
     "(packet[62] > 0xFF? packet[12] == 0x00: not packet[19] == 0x00)) and "
     "((not packet[68] == 0xFF and packet[75] > 0x00)? (packet[6] <= 0x06 or "
     "packet[76] <= 0x01): not packet[50] == 0x00)) and (packet[57] >= 0x5E? "
     "((not packet[75] >= 0x00? packet[75] != 0x00: not packet[63] != 0xC4)? "
     "not packet[1] < 0x00: (packet[30] > 0x00? packet[16] == 0x00: "
     "packet[36] == 0x00)): ((packet[66] < 0x08? not packet[0] < 0x60: "
     "packet[72] != 0x00)? (packet[25] > 0x00 or not packet[13] < 0x01): "
     "(packet[47] <= 0xAA and not packet[15] != 0x00)))))",
                                                &pkt_ipv6_tcp_syn, FALSE},
    {"packet32[-4b] < 0xFFFFFFFE",              &pkt_ipv6_tcp_syn, TRUE},
    {"ipv6.TrafficClass == 0x00000000 and ipv6.FlowLabel == 0x0000 and "
     "ipv6.Length == 40 and ipv6.NextHdr == 6 and ipv6.HopLimit == 64 and "
     "ipv6.SrcAddr == 1234:5678:1:0:0:0:aabb:ccdd and "
     "ipv6.DstAddr == 0:0:0:0:0:0:0:1 and tcp.SrcPort == 50046 and "
     "tcp.DstPort == 23 and tcp.SeqNum == 3789015210 and tcp.AckNum == 0 and "
     "tcp.HdrLength == 10 and tcp.Fin == 0 and tcp.Syn == 1 and "
     "tcp.Rst == 0 and tcp.Psh == 0 and tcp.Ack == 0 and tcp.Urg == 0 and "
     "tcp.Window == 43690 and tcp.UrgPtr == 0",&pkt_ipv6_tcp_syn, TRUE},
    {"ipv6.TrafficClass > 0x00000000 or ipv6.FlowLabel < 0x0000 or "
     "ipv6.Length < 40 or ipv6.NextHdr != 6 or ipv6.HopLimit > 64 or "
     "ipv6.SrcAddr != 1234:5678:1:0:0:0:aabb:ccdd or "
     "ipv6.DstAddr < 0:0:0:0:0:0:0:1 or tcp.SrcPort < 50046 or "
     "tcp.DstPort > 23 or tcp.SeqNum < 3789015210 or tcp.AckNum < 0 or "
     "tcp.HdrLength != 10 or tcp.Fin > 0 or tcp.Syn > 1 or tcp.Rst > 0 or "
     "tcp.Psh > 0 or tcp.Ack != 0 or tcp.Urg != 0 or tcp.Window != 43690 or "
     "tcp.UrgPtr != 0",                        &pkt_ipv6_tcp_syn, FALSE},
    {"localAddr == 1234:5678:1::aabb:ccdd && remoteAddr == ::1 && "
     "localPort == 50046 && remotePort == 23 && protocol == 6",
                                               &pkt_ipv6_tcp_syn, TRUE},
    {"packet[0] == 0x60",                      &pkt_ipv6_tcp_syn, TRUE},
    {"icmpv6",                                 &pkt_ipv6_echo_reply, TRUE},
    {"icmp",                                   &pkt_ipv6_echo_reply, FALSE},
    {"protocol == ICMPV6",                     &pkt_ipv6_echo_reply, TRUE},
    {"protocol == ICMP",                       &pkt_ipv6_echo_reply, FALSE},
    {"icmp or icmpv6",                         &pkt_ipv6_echo_reply, TRUE},
    {"not icmp",                               &pkt_ipv6_echo_reply, TRUE},
    {"icmpv6.Type == 129",                     &pkt_ipv6_echo_reply, TRUE},
    {"icmpv6.Code == 0",                       &pkt_ipv6_echo_reply, TRUE},
    {"icmpv6.Body == 0x10720003",              &pkt_ipv6_echo_reply, TRUE},
    {"ipv6.DstAddr >= 1000",                   &pkt_ipv6_echo_reply, FALSE},
    {"ipv6.DstAddr <= 1",                      &pkt_ipv6_echo_reply, TRUE},
    {"length == 104 && ipv6.Length == 64",     &pkt_ipv6_echo_reply, TRUE},
    {"ip and !loopback and (outbound? tcp.DstPort == 80 or"
     " tcp.DstPort == 443 or udp.DstPort == 53 :"
     " icmp.Type == 11 and icmp.Code == 0)",   &pkt_ipv6_echo_reply, FALSE},
    {"fragment",                               &pkt_ipv6_echo_reply, FALSE},
    {"random8 < 128",                          &pkt_ipv6_echo_reply, TRUE},
    {"(random8 < 128? random16 < 0x8000: random32 < 0x80000000)",
                                               &pkt_ipv6_echo_reply, TRUE},
    {"(((((not packet[68] != 0x44? packet[58] >= 0x00: "
     "not packet[39] >= 0x01) and not packet[101] != 0x55) and "
     "((not packet[70] >= 0x66? not packet[68] > 0x44: "
     "not packet[77] > 0xDD) and (not packet[72] <= 0x88 or "
     "packet[5] >= 0x40)))? (((not packet[88] <= 0x88 and "
     "packet[13] > 0x00) and (packet[52] >= 0x00 and "
     "not packet[96] == 0x00)) or packet[32] < 0x00): "
     "(((packet[57] <= 0x75? not packet[27] == 0x00: packet[0] >= 0x60) or "
     "(packet[90] == 0xAA or packet[62] > 0x00))? "
     "((not packet[39] <= 0x01 and packet[48] != 0xA4) or "
     "packet[86] <= 0x66): not packet[61] >= 0x00)) and "
     "((packet[64] >= 0x00? (not packet[50] != 0x69 or "
     "(not packet[92] != 0xCC? not packet[9] < 0x00: packet[93] >= 0xDD)): "
     "((packet[58] <= 0x00 and not packet[103] != 0x77) or "
     "(not packet[22] < 0x00? not packet[93] <= 0xDD: "
     "not packet[55] < 0x00))) or (packet[87] <= 0x77 and "
     "((packet[70] <= 0x66 and not packet[59] <= 0x00) and "
     "(not packet[8] != 0x00 or packet[82] == 0x22)))))",
                                               &pkt_ipv6_echo_reply, FALSE},
    {"((((packet[14] == 0x00? (packet[102] > 0x66 or packet[16] != 0x00): "
     "(packet[81] >= 0x11 or not packet[35] <= 0x00))? "
     "((packet[88] < 0x88? packet[8] <= 0x00: packet[18] > 0x00) or "
     "(not packet[82] <= 0x22? not packet[13] == 0x00: "
     "not packet[37] == 0x00)): (packet[38] < 0x00 and "
     "not packet[83] < 0x33))? packet[95] >= 0xFF: "
     "(((not packet[96] <= 0x00? packet[84] != 0x44: "
     "not packet[34] <= 0x00) or not packet[47] <= 0x03) or "
     "((packet[78] == 0xEE? packet[101] >= 0x55: not packet[25] >= 0x00) or "
     "packet[9] <= 0x00))) or (packet[59] == 0x00 and ((packet[72] < 0x88 and "
     "(packet[52] == 0x00 or not packet[54] >= 0x00)) or "
     "(packet[13] >= 0x00 or (not packet[93] == 0xDD and "
     "not packet[99] < 0x33)))))",             &pkt_ipv6_echo_reply, TRUE},
    {"ipv6.TrafficClass == 0x00000000 and ipv6.FlowLabel == 0x0000 and "
     "ipv6.Length == 64 and ipv6.NextHdr == 58 and ipv6.HopLimit == 31 and "
     "ipv6.SrcAddr == 0:0:0:0:0:0:0:1 and ipv6.DstAddr == 0:0:0:0:0:0:0:1 and "
     "icmpv6.Type == 129 and icmpv6.Code == 0 and icmpv6.Body == 0x10720003",
                                               &pkt_ipv6_echo_reply, TRUE},
    {"ipv6.TrafficClass != 0x00000000 or ipv6.FlowLabel != 0x0000 or "
     "ipv6.Length < 64 or ipv6.NextHdr > 58 or ipv6.HopLimit != 31 or "
     "ipv6.SrcAddr != 0:0:0:0:0:0:0:1 or ipv6.DstAddr > 0:0:0:0:0:0:0:1 or "
     "icmpv6.Type > 129 or icmpv6.Code > 0 or icmpv6.Body != 0x10720003",
                                               &pkt_ipv6_echo_reply, FALSE},
    {"localAddr == ::1 && remoteAddr == ::1 && localPort == 129 && "
     "remotePort == 0 && protocol == 58",      &pkt_ipv6_echo_reply, TRUE},
    {"true",                                   &pkt_ipv6_exthdrs_udp, TRUE},
    {"false",                                  &pkt_ipv6_exthdrs_udp, FALSE},
    {"protocol == 0",                          &pkt_ipv6_exthdrs_udp, FALSE},
    {"udp",                                    &pkt_ipv6_exthdrs_udp, TRUE},
    {"tcp",                                    &pkt_ipv6_exthdrs_udp, FALSE},
    {"ipv6.SrcAddr == ::",                     &pkt_ipv6_exthdrs_udp, FALSE},
    {"ipv6.SrcAddr == ::1",                    &pkt_ipv6_exthdrs_udp, TRUE},
    {"ipv6.SrcAddr == ::2",                    &pkt_ipv6_exthdrs_udp, FALSE},
    {"ipv6.SrcAddr == ::8.8.4.4",              &pkt_ipv6_exthdrs_udp, FALSE},
    {"ipv6.SrcAddr < abcd::1",                 &pkt_ipv6_exthdrs_udp, TRUE},
    {"ipv6.SrcAddr <= abcd::1",                &pkt_ipv6_exthdrs_udp, TRUE},
    {"ipv6.SrcAddr != abcd::1",                &pkt_ipv6_exthdrs_udp, TRUE},
    {"ipv6.SrcAddr >= abcd::1",                &pkt_ipv6_exthdrs_udp, FALSE},
    {"ipv6.SrcAddr > abcd::1",                 &pkt_ipv6_exthdrs_udp, FALSE},
    {"ipv6.DstAddr >= ::",                     &pkt_ipv6_exthdrs_udp, TRUE},
    {"timestamp > -1",                         &pkt_ipv6_exthdrs_udp, TRUE},
    {"udp.SrcPort == 4660 and udp.DstPort == 43690",
                                               &pkt_ipv6_exthdrs_udp, TRUE},
    {"udp.SrcPort == 4660 and udp.DstPort == 12345",
                                               &pkt_ipv6_exthdrs_udp, FALSE},
    {"localAddr == ::1",                       &pkt_ipv6_exthdrs_udp, TRUE},
    {"localPort == 4660 and remotePort == 43690",
                                               &pkt_ipv6_exthdrs_udp, TRUE},
    {"(outbound and tcp? tcp.DstPort == 0xABAB: false) or "
     "(outbound and udp? udp.DstPort == 0xAAAA: false) or "
     "(inbound and tcp? tcp.SrcPort == 0xABAB: false) or "
     "(inbound and udp? udp.SrcPort == 0xAAAA: false)",
                                               &pkt_ipv6_exthdrs_udp, TRUE},
    {"(ipv6? true: false) or (udp? udp.DstPort != 53: false) or "
     "(not tcp and not udp? true: false)",     &pkt_ipv6_exthdrs_udp, TRUE},
    {"(tcp or udp) and (ip or ipv6) and (icmp or !icmpv6) and "
     "(tcp.Payload16[-1] == 0x1234 or udp.Payload16[-1] == 0x2101)",
                                               &pkt_ipv6_exthdrs_udp, TRUE},
    {"udp.PayloadLength == 13",                &pkt_ipv6_exthdrs_udp, TRUE},
    {"(udp.Length == 13? false: udp.Length == 21)",
                                               &pkt_ipv6_exthdrs_udp, TRUE},
    {"(tcp or icmp or icmpv6 or ip or !udp or ipv6? udp.PayloadLength > 0: "
        "udp.DstPort == 39482)",               &pkt_ipv6_exthdrs_udp, TRUE},
    {"random8 < 128",                          &pkt_ipv6_exthdrs_udp, TRUE},
    {"(random8 < 128? random16 < 0x8000: random32 < 0x80000000)",
                                               &pkt_ipv6_exthdrs_udp, TRUE},
    {"timestamp != -0x8000000000000000",       &pkt_ipv6_exthdrs_udp, TRUE},
    {"timestamp !=  0x7fffffffffffffff",       &pkt_ipv6_exthdrs_udp, TRUE},
    {"timestamp == -0x1deadbeef1234567",       &pkt_ipv6_exthdrs_udp, FALSE},
    {"((packet[2] <= 0x00 or (((packet[29] < 0x00 or "
     "not packet[35] != 0x00) and packet[32] != 0x00) and "
     "((not packet[31] != 0x00 and packet[52] > 0x00) and "
     "(packet[28] < 0x00? not packet[28] <= 0x00: packet[73] == 0x65))))? "
     "((((packet[9] <= 0x00? not packet[28] == 0x00: "
     "not packet[22] >= 0x00) and (not packet[20] != 0x00 and "
     "not packet[22] >= 0x00)) and ((packet[42] > 0x00 and "
     "not packet[12] < 0x00) or packet[66] == 0xAA)) or "
     "(not packet[23] >= 0x01 and (packet[79] > 0x6F and "
     "(not packet[18] > 0x00 or not packet[82] <= 0x64)))): "
     "packet[62] <= 0x00)",
                                               &pkt_ipv6_exthdrs_udp, FALSE},
    {"((packet[56] > 0x11? (((not packet[0] > 0x60? not packet[22] < 0x00: "
     "not packet[15] > 0x00)? (not packet[5] >= 0x2D and packet[18] != 0x00): "
     "packet[45] == 0x00) or ((packet[47] >= 0x00 or not packet[32] >= 0x00)? "
     "(packet[29] >= 0x00 or not packet[20] == 0x00): (packet[32] > 0x00 and "
     "packet[46] > 0x00))): not packet[76] != 0x6F) or "
     "((not packet[32] > 0x00 or (packet[13] == 0x00 or (packet[4] > 0x00 or "
     "packet[21] < 0x00))) or (((packet[55] != 0x00? packet[67] != 0xAA: "
     "not packet[66] >= 0xAA)? (packet[8] > 0x00? not packet[28] > 0x00: "
     "packet[28] <= 0x00): not packet[78] != 0x57)? ((packet[79] == 0x6F or "
     "packet[25] == 0x00) or (packet[68] == 0x00? not packet[50] < 0x00: "
     "not packet[68] < 0x00)): ((not packet[78] > 0x57 and "
     "not packet[8] == 0x00) or packet[32] <= 0x00))))",
                                               &pkt_ipv6_exthdrs_udp, TRUE},
    {"ipv6.TrafficClass == 0x00000000 and ipv6.FlowLabel == 0x0000 and "
     "ipv6.Length == 45 and ipv6.NextHdr == 0 and ipv6.HopLimit == 100 and "
     "ipv6.SrcAddr == 0:0:0:0:0:0:0:1 and ipv6.DstAddr == 0:0:0:0:0:0:0:1 and "
     "udp.SrcPort == 4660 and udp.DstPort == 43690 and udp.Length == 21",
                                               &pkt_ipv6_exthdrs_udp, TRUE},
    {"(ipv6.TrafficClass == 0x00000000 and ipv6.FlowLabel == 0x0000 and "
     "ipv6.Length == 45 and ipv6.NextHdr == 0 and ipv6.HopLimit == 101? false: "
     "(ipv6.SrcAddr == 0:0:0:0:0:0:0:1 and ipv6.DstAddr == 0:0:0:0:0:0:0:1 and "
     "udp.SrcPort == 4660 and udp.DstPort == 43691? false: udp.Length == 22))",
                                               &pkt_ipv6_exthdrs_udp, FALSE},
    {"ipv6.TrafficClass != 0x00000000 or ipv6.FlowLabel > 0x0000 or "
     "ipv6.Length < 45 or ipv6.NextHdr != 0 or ipv6.HopLimit < 100 or "
     "ipv6.SrcAddr > 0:0:0:0:0:0:0:1 or ipv6.DstAddr < 0:0:0:0:0:0:0:1 or "
     "udp.SrcPort > 4660 or udp.DstPort < 43690 or udp.Length > 21",
                                               &pkt_ipv6_exthdrs_udp, FALSE},
    {"localAddr == ::1 and remoteAddr == 1 and localPort == 4660 and "
     "remotePort == 43690 and protocol == 17", &pkt_ipv6_exthdrs_udp, TRUE},
    {"fragment",                               &pkt_ipv4_fragment_0, TRUE},
    {"ip.MF or ip.FragOff != 0",               &pkt_ipv4_fragment_0, TRUE},
    {"icmp",                                   &pkt_ipv4_fragment_0, TRUE},
    {"icmp.Body != 123 || icmp.Body == 123",   &pkt_ipv4_fragment_0, TRUE},
    {"length == 84 || ip.Length == 84",        &pkt_ipv4_fragment_0, FALSE},
    {"ip.HdrLength == 5 and ip.TOS == 0 and ip.Length == 28 and "
     "ip.Id == 0x1234 and ip.FragOff == 0 and ip.MF == 1 and ip.DF == 0 and "
     "ip.TTL == 64 and ip.Protocol == 1 and ip.SrcAddr == 0xFFFF0A000001 and "
     "ip.DstAddr == 0xFFFF08080808 and icmp.Type == 8 and icmp.Code == 0 and "
     "icmp.Body == 0x0D560001",                &pkt_ipv4_fragment_0, TRUE},
    {"fragment",                               &pkt_ipv4_fragment_1, TRUE},
    {"ip.MF or ip.FragOff != 0",               &pkt_ipv4_fragment_1, TRUE},
    {"icmp",                                   &pkt_ipv4_fragment_1, FALSE},
    {"icmp.Body != 123 || icmp.Body == 123",   &pkt_ipv4_fragment_1, FALSE},
    {"length == 84 || ip.Length == 84",        &pkt_ipv4_fragment_1, FALSE},
    {"ip.HdrLength == 5 and ip.TOS == 0 and ip.Length == 76 and "
     "ip.Id == 0x1234 and ip.FragOff == 1 and ip.MF == 0 and ip.DF == 0 and "
     "ip.TTL == 64 and ip.Protocol == 1 and ip.SrcAddr == 0xFFFF0A000001 and "
     "ip.DstAddr == 0xFFFF08080808",           &pkt_ipv4_fragment_1, TRUE},
    {"fragment",                               &pkt_ipv6_fragment_0, TRUE},
    {"icmpv6",                                 &pkt_ipv6_fragment_0, TRUE},
    {"length == 104 || ipv6.Length == 64",     &pkt_ipv6_fragment_0, FALSE},
    {"ipv6.TrafficClass == 0x00000000 and ipv6.FlowLabel == 0x0000 and "
     "ipv6.Length == 32 and ipv6.NextHdr == 44 and ipv6.HopLimit == 31 and "
     "ipv6.SrcAddr == 0:0:0:0:0:0:0:1 and ipv6.DstAddr == 0:0:0:0:0:0:0:1 and "
     "icmpv6.Type == 129 and icmpv6.Code == 0 and icmpv6.Body == 0x10720003",
                                               &pkt_ipv6_fragment_0, TRUE},
    {"fragment",                               &pkt_ipv6_fragment_1, TRUE},
    {"icmpv6",                                 &pkt_ipv6_fragment_1, FALSE},
    {"length == 104 || ipv6.Length == 64",     &pkt_ipv6_fragment_1, FALSE},
    {"ipv6.TrafficClass == 0x00000000 and ipv6.FlowLabel == 0x0000 and "
     "ipv6.Length == 48 and ipv6.NextHdr == 44 and ipv6.HopLimit == 31 and "
     "ipv6.SrcAddr == 0:0:0:0:0:0:0:1 and ipv6.DstAddr == 0:0:0:0:0:0:0:1",
                                               &pkt_ipv6_fragment_1, TRUE},
};

/*
 * Test range.
 */
static size_t lo = 0, hi = UINT_MAX;

/*
 * Main.
 */
int main(int argc, char **argv)
{
    HANDLE upper_handle, lower_handle;
    HANDLE console, monitor;
    BOOL passed[sizeof(tests) / sizeof(struct test)], first;
    DWORD result;
    LARGE_INTEGER freq;
    UINT64 diff;
    size_t i;
    size_t num_tests = sizeof(tests) / sizeof(struct test), passed_tests;

    switch (argc)
    {
        case 1:
            break;
        case 3:
            lo = atoi(argv[1]);
            hi = atoi(argv[2]);
            if (hi >= lo)
            {
                break;
            }
            // Fallthrough
        default:
            fprintf(stderr, "usage: %s [low high]\n", argv[0]);
            exit(EXIT_FAILURE);
    }
    hi = MIN(num_tests, hi);

    // Open handles to:
    // (1) stop normal traffic from interacting with the tests; and
    // (2) stop test packets escaping to the Internet or TCP/IP stack.
    upper_handle = WinDivertOpen("true", WINDIVERT_LAYER_NETWORK, 9999,
        WINDIVERT_FLAG_DROP);
    lower_handle = WinDivertOpen("true", WINDIVERT_LAYER_NETWORK, -9999,
        WINDIVERT_FLAG_DROP);
    if (upper_handle == INVALID_HANDLE_VALUE ||
        lower_handle == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "error: failed to open WinDivert handle (err = %d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }

    console = GetStdHandle(STD_OUTPUT_HANDLE);
    QueryPerformanceFrequency(&freq);

    // Spawn monitor thread:
    monitor = CreateThread(NULL, 1, (LPTHREAD_START_ROUTINE)monitor_worker,
        NULL, 0, NULL);
    if (monitor == NULL)
    {
        fprintf(stderr, "error: failed to spawn monitor thread (err = %d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }

    // Wait for existing packets to flush:
    Sleep(150);

    // Run tests:
    passed_tests = 0;
    for (i = lo; i < num_tests && i <= hi; i++)
    {
        const char *filter = tests[i].filter;
        const char *packet = tests[i].packet->packet;
        size_t packet_len = tests[i].packet->packet_len;
        char *name = tests[i].packet->name;
        BOOL match = tests[i].match;

        // Run the test:
        passed[i] = run_test(upper_handle, filter, packet, packet_len, match,
            &diff);
        diff = 1000000 * diff / freq.QuadPart;
        printf("%.3u ", (unsigned)i);
        if (passed[i])
        {
            SetConsoleTextAttribute(console, FOREGROUND_GREEN);
            printf("PASSED");
            passed_tests++;
        }
        else
        {
            SetConsoleTextAttribute(console, FOREGROUND_RED);
            printf("FAILED");
        }
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);
        printf(" %.5llu p=[", diff);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        printf("%s", name);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);
        printf("] f=[");
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        printf("%s", filter);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);
        printf("]\n");
    }

    WinDivertClose(upper_handle);
    WinDivertClose(lower_handle);

    result = WaitForSingleObject(monitor, 1000);
    switch (result)
    {
        case WAIT_OBJECT_0:
            break;
        case WAIT_TIMEOUT:
            fprintf(stderr, "error: failed to wait for monitor thread "
                "(timeout)\n");
            exit(EXIT_FAILURE);
        default:
            fprintf(stderr, "error: failed to wait for monitor thread "
                "(err = %d)\n", result);
            exit(EXIT_FAILURE);
    }

    printf("\npassed = %.2f%%\n",
        ((double)passed_tests / (double)(hi - lo)) * 100.0);

    first = TRUE;
    for (i = lo; i < num_tests && i <= hi; i++)
    {
        const char *filter = tests[i].filter;
        char *name = tests[i].packet->name;
 
        if (passed[i])
        {
            continue;
        }
        if (first)
        {
            SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_BLUE);
            printf("\nFAILED TESTS");
            SetConsoleTextAttribute(console, FOREGROUND_RED |
                FOREGROUND_GREEN | FOREGROUND_BLUE);
            printf("\n------------\n\n");
            first = FALSE;
        }
        printf("%.3u ", (unsigned)i);
        SetConsoleTextAttribute(console, FOREGROUND_RED);
        printf("FAILED");
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);
        printf(" p=[");
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        printf("%s", name);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);
        printf("] f=[");
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN);
        printf("%s", filter);
        SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN |
            FOREGROUND_BLUE);
        printf("]\n");
    }

    return 0;
}

/*
 * Run a test case.
 */
static BOOL run_test(HANDLE inject_handle, const char *filter,
    const char *packet, const size_t packet_len, BOOL match, INT64 *diff)
{
    static char object[8192];
    char buf[2][MAX_PACKET];
    UINT buf_len[2], i, idx;
    DWORD iolen;
    WINDIVERT_ADDRESS addr[2], addr_send;
    OVERLAPPED overlapped[2];
    const char *err_str;
    UINT err_pos;
    PWINDIVERT_IPHDR iphdr = NULL;
    HANDLE handle[2] = {INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE};
    HANDLE event[2] = {NULL, NULL};
    BOOL random, result, ipv4;
    LARGE_INTEGER end;
    UINT64 val;

    *diff = 0;

    // (0) Verify the test data:
    if (!WinDivertHelperCompileFilter(filter, WINDIVERT_LAYER_NETWORK,
            object, sizeof(object), &err_str, &err_pos))
    {
        fprintf(stderr, "error: filter string \"%s\" is invalid with error "
            "\"%s\" (position=%u)\n", filter, err_str, err_pos);
        goto failed;
    }

    // (1) Open WinDivert handles:
    handle[0] = WinDivertOpen(object, WINDIVERT_LAYER_NETWORK, 8888, 0);
    if (handle[0] == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "error: failed to open WinDivert handle for filter "
            "\"%s\" (err = %d)\n", filter, GetLastError());
        goto failed;
    }
    handle[1] = WinDivertOpen("true", WINDIVERT_LAYER_NETWORK, 7777, 0);
    if (handle[1] == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "error: failed to open WinDivert handle "
            "(err = %d)\n", GetLastError());
        goto failed;
    }
    if (!WinDivertSetParam(handle[0], WINDIVERT_PARAM_QUEUE_LENGTH,
            WINDIVERT_PARAM_QUEUE_LENGTH_MAX) ||
        !WinDivertGetParam(handle[0], WINDIVERT_PARAM_QUEUE_LENGTH, &val) ||
        val != WINDIVERT_PARAM_QUEUE_LENGTH_MAX)
    {
        fprintf(stderr, "error: failed to set WINDIVERT_PARAM_QUEUE_LENGTH "
            "parameter (err = %d)\n", GetLastError());
        goto failed;
    }
    if (!WinDivertSetParam(handle[0], WINDIVERT_PARAM_QUEUE_SIZE,
            WINDIVERT_PARAM_QUEUE_SIZE_MAX) ||
        !WinDivertGetParam(handle[0], WINDIVERT_PARAM_QUEUE_SIZE, &val) ||
        val != WINDIVERT_PARAM_QUEUE_SIZE_MAX)
    {
        fprintf(stderr, "error: failed to set WINDIVERT_PARAM_QUEUE_SIZE "
            "parameter (err = %d)\n", GetLastError());
        goto failed;
    }
    if (!WinDivertSetParam(handle[0], WINDIVERT_PARAM_QUEUE_TIME,
            WINDIVERT_PARAM_QUEUE_TIME_MAX) ||
        !WinDivertGetParam(handle[0], WINDIVERT_PARAM_QUEUE_TIME, &val) ||
        val != WINDIVERT_PARAM_QUEUE_TIME_MAX)
    {
        fprintf(stderr, "error: failed to set WINDIVERT_PARAM_QUEUE_TIME "
            "parameter (err = %d)\n", GetLastError());
        goto failed;
    }

    // (2) Create pended recv requests:
    event[0] = CreateEvent(NULL, FALSE, FALSE, NULL);
    event[1] = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (event[0] == NULL || event[1] == NULL)
    {
        fprintf(stderr, "error: failed to create event (err = %d)\n",
            GetLastError());
        goto failed;
    }
    memset(&overlapped[0], 0, sizeof(overlapped[0]));
    memset(&overlapped[1], 0, sizeof(overlapped[1]));
    overlapped[0].hEvent = event[0];
    overlapped[1].hEvent = event[1];
    if (WinDivertRecvEx(handle[0], buf[0], sizeof(buf[0]), &buf_len[0], 0,
                &addr[0], NULL, &overlapped[0]) ||
            GetLastError() != ERROR_IO_PENDING ||
        WinDivertRecvEx(handle[1], buf[1], sizeof(buf[1]), &buf_len[1], 0,
                &addr[1], NULL, &overlapped[1]) ||
            GetLastError() != ERROR_IO_PENDING)
    {
        fprintf(stderr, "error: failed to created pended recv from WinDivert "
                "handle (err = %d)\n", GetLastError());
        goto failed;
    }

    // (2) Inject the packet:
    memset(&addr_send, 0, sizeof(addr_send));
    addr_send.Outbound    = TRUE;
    addr_send.IPChecksum  = FALSE;
    addr_send.TCPChecksum = FALSE;
    addr_send.UDPChecksum = FALSE;
    if (!WinDivertSend(inject_handle, (PVOID)packet, packet_len, NULL,
            &addr_send))
    {
        fprintf(stderr, "error: failed to inject test packet (err = %d)\n",
            GetLastError());
        goto failed;
    }

    // (3) Wait for the packet to arrive.
    // NOTE: This may fail, so set a generous time-out of 250ms.
    switch (WaitForMultipleObjects(2, event, FALSE, 250))
    {
        case WAIT_OBJECT_0:
            QueryPerformanceCounter(&end);
            result = TRUE;
            idx = 0;
            break;
        case WAIT_OBJECT_0+1:
            QueryPerformanceCounter(&end);
            result = FALSE;
            idx = 1;
            break;
        case WAIT_TIMEOUT:
            fprintf(stderr, "error: failed to read packet from WinDivert "
                "handle (timeout)\n", GetLastError());
            goto failed;
        default:
            fprintf(stderr, "error: failed to wait for packet (err = %d)\n",
                GetLastError());
            goto failed;
    }
    if (!GetOverlappedResult(handle[idx], &overlapped[idx], &iolen, TRUE))
    {
        fprintf(stderr, "error: failed to get the overlapped result from "
            "WinDivert handle (err = %d)\n", GetLastError());
        goto failed;
    }
    buf_len[idx] = (UINT)iolen;
    *diff = end.QuadPart - addr[idx].Timestamp;

    // (4) Verify that the packet is the same & matches.
    if (buf_len[idx] != packet_len)
    {
        fprintf(stderr, "error: packet length mis-match, expected (%u), got "
            "(%u)\n", (unsigned)packet_len, buf_len[idx]);
        goto failed;
    }
    iphdr = (PWINDIVERT_IPHDR)buf[idx];
    ipv4 = (iphdr->Version == 4);
    for (i = 0; i < packet_len; i++)
    {
        if (ipv4 && i >= offsetof(WINDIVERT_IPHDR, Checksum) &&
                    i < offsetof(WINDIVERT_IPHDR, Checksum) + sizeof(UINT16))
        {
            // The IPv4 checksum can change, so ignore it.
            continue;
        }
        if (packet[i] != buf[idx][i])
        {
            fprintf(stderr, "error: packet data mis-match, expected byte #%u "
                "to be (0x%.2X), got (0x%.2X)\n", i, (unsigned char)packet[i],
                (unsigned char)buf[idx][i]);
            for (i = 0; i < packet_len; i++)
            {
                printf("%c", (packet[i] == buf[idx][i]? '.': 'X'));
            }
            putchar('\n');
            goto failed;
        }
    }

    random = (strstr(filter, "random") != 0);
    // If (random && !result), then we cannot verify since the original
    // non-matching random values have been lost:
    if ((!random &&
            WinDivertHelperEvalFilter(filter, buf[idx], buf_len[idx],
                &addr[idx]) != result) ||
        (random && result && 
            !WinDivertHelperEvalFilter(filter, buf[idx], buf_len[idx],
                &addr[idx])))
    {
        fprintf(stderr, "error: filter \"%s\" does not match the given "
            "packet\n", filter);
        goto failed;
    }
    if (!random && result != match)
    {
        fprintf(stderr, "error: filter \"%s\" does not match the expected "
            "result\n", filter);
        goto failed;
    }

    // (5) Clean-up:
    if (!WinDivertShutdown(handle[0], WINDIVERT_SHUTDOWN_BOTH) ||
        !WinDivertShutdown(handle[1], WINDIVERT_SHUTDOWN_BOTH))
    {
        fprintf(stderr, "error: failed to shutdown WinDivert handle (err = "
            "%d)\n", GetLastError());
        goto failed;
    }
    for (i = 0; i < 1000 && WinDivertRecv(handle[0], NULL, 0, NULL, NULL); i++)
        ;
    if (GetLastError() != ERROR_NO_DATA)
    {
        fprintf(stderr, "error: failed to recv NO_DATA from shutdown "
            "WinDivert handle (err = %d)\n", GetLastError());
        goto failed;
    }
    for (i = 0; i < 1000 && WinDivertRecv(handle[1], NULL, 0, NULL, NULL); i++)
        ;
    if (GetLastError() != ERROR_NO_DATA)
    {
        fprintf(stderr, "error: failed to recv NO_DATA from shutdown "
            "WinDivert handle (err = %d)\n", GetLastError());
        goto failed;
    }
    if (!WinDivertClose(handle[0]) || !WinDivertClose(handle[1]))
    {
        fprintf(stderr, "error: failed to close WinDivert handle (err = %d)\n",
            GetLastError());
        goto failed;
    }
    CloseHandle(event[0]);
    CloseHandle(event[1]);

    return TRUE;

failed:
    for (i = 0; i < 2; i++)
    {
        if (handle[i] != INVALID_HANDLE_VALUE)
        {
            WinDivertClose(handle[i]);
        }
        if (event[i] != NULL)
        {
            CloseHandle(event[i]);
        }
    }
    return FALSE;
}

/*
 * Monitor thread.
 */
static DWORD monitor_worker(LPVOID arg)
{
    char filter[100], packet[4096], object_1[4096], *object_2, filter_2[8192];
    UINT packet_len;
    WINDIVERT_ADDRESS addr;
    PWINDIVERT_IPHDR iphdr;
    UINT i;

    snprintf(filter, sizeof(filter), "processId=%d and priority=8888 and "
        "event=OPEN", GetCurrentProcessId());
    HANDLE handle = WinDivertOpen(filter, WINDIVERT_LAYER_REFLECT, 0,
        WINDIVERT_FLAG_SNIFF | WINDIVERT_FLAG_RECV_ONLY);
    if (handle == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "error: failed to open reflect handle (err = %d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }

    size_t num_tests = sizeof(tests) / sizeof(struct test);
    for (i = lo; i < num_tests && i <= hi; i++)
    {
        // (1) Read the reflected filter:
        WinDivertHelperCompileFilter(tests[i].filter, WINDIVERT_LAYER_NETWORK,
            object_1, sizeof(object_1), NULL, NULL);
        if (!WinDivertRecv(handle, packet, sizeof(packet), &packet_len, &addr))
        {
            fprintf(stderr, "error: failed to read OPEN event (err = %d)\n",
                GetLastError());
            exit(EXIT_FAILURE);
        }
        object_2 = packet;
        if (strcmp(object_1, object_2) != 0)
        {
            // Filter is not the same.
            fprintf(stderr, "error: filter object mismatch (%s vs %s)\n",
                object_1, object_2);
            exit(EXIT_FAILURE);
        }

        // (2) Test if formatted filter is equivalent:
        if (!WinDivertHelperFormatFilter(object_1, WINDIVERT_LAYER_NETWORK,
                filter_2, sizeof(filter_2)))
        {
            fprintf(stderr, "error: failed to format filter (err = %d)\n",
                GetLastError());
            exit(EXIT_FAILURE);
        }
        if (!WinDivertHelperCompileFilter(filter_2, WINDIVERT_LAYER_NETWORK,
                object_1, sizeof(object_1), NULL, NULL))
        {
            fprintf(stderr, "error: failed to recompile filter (err = %d)\n",
                GetLastError());
            exit(EXIT_FAILURE);
        }
        if (strcmp(object_1, object_2) == 0)
        {
            // Recompiled filter is exactly the same; test has passed.
            continue;
        }
        if (strstr(filter_2, "random") != NULL)
        {
            // Cannot verify random filters.
            continue;
        }
        iphdr = (PWINDIVERT_IPHDR)tests[i].packet->packet;
        memset(&addr, 0, sizeof(addr));
        addr.Event    = WINDIVERT_EVENT_NETWORK_PACKET;
        addr.Layer    = WINDIVERT_LAYER_NETWORK;
        addr.Outbound = TRUE;
        addr.IPv6     = (iphdr->Version == 4? FALSE: TRUE);
        if (WinDivertHelperEvalFilter(object_1, tests[i].packet->packet,
                tests[i].packet->packet_len, &addr) != tests[i].match)
        {
            fprintf(stderr, "error: failed to match recompiled filter "
                "(test = %.3u, filter = \"%s\" formatted = \"%s\", "
                "err = %d)\n", i, tests[i].filter, filter_2, GetLastError());
            exit(EXIT_FAILURE);
        }
    }

    WinDivertClose(handle);
    return 0;
}


```

`test/test.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<!--

    test.vcxproj
    (C) 2019, all rights reserved,
    
    This file is part of WinDivert.
    
    WinDivert is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
    License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    WinDivert is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2 of the License, or (at your option)
    any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc., 51
    Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
    
-->
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 <ItemGroup Label="ProjectConfigurations">
  <ProjectConfiguration Include="Release|Win32">
   <Configuration>Release</Configuration>
   <Platform>Win32</Platform>
  </ProjectConfiguration>
  <ProjectConfiguration Include="Release|x64">
   <Configuration>Release</Configuration>
   <Platform>x64</Platform>
  </ProjectConfiguration>
 </ItemGroup>
 <ItemGroup>
  <ClCompile Include="test.c">
   <TreatWarningAsError>false</TreatWarningAsError>
   <Optimization>MinSpace</Optimization>
   <BasicRuntimeChecks>Default</BasicRuntimeChecks>
   <AdditionalIncludeDirectories>..\include</AdditionalIncludeDirectories>
  </ClCompile>
 </ItemGroup>
 <PropertyGroup Label="Globals">
  <RootNamespace>test</RootNamespace>
  <ProjectName>test</ProjectName>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props"/>
 <PropertyGroup Label="Configuration">
  <PlatformToolset>v140</PlatformToolset>
  <ConfigurationType>Application</ConfigurationType>
 </PropertyGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
 <ItemDefinitionGroup>
  <Link>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\install\MSVC\i386\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
   <AdditionalDependencies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\install\MSVC\amd64\WinDivert.lib;%(AdditionalDependencies)</AdditionalDependencies>
  </Link>
 </ItemDefinitionGroup>
 <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>

```

`test/test_data.c`:

```c
/*
 * test_data.c
 * (C) 2019, all rights reserved,
 *
 * This file is part of WinDivert.
 *
 * WinDivert is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WinDivert is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// IPV4 ICMP ECHO REQUEST
static const unsigned char echo_request[] =
{
    0x45, 0x00, 0x00, 0x54, 0x12, 0x34, 0x40, 0x00,
    0x40, 0x01, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x01,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x3c, 0xd2,
    0x0d, 0x56, 0x00, 0x01, 0x8b, 0xa6, 0x60, 0x54,
    0x00, 0x00, 0x00, 0x00, 0xf9, 0x08, 0x0a, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13,
    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37
};

// IPV4 TCP HTTP GET REQUEST
static const unsigned char http_request[] =
{
    0x45, 0x00, 0x02, 0x09, 0x48, 0x2d, 0x40, 0x00,
    0x40, 0x06, 0x00, 0x00, 0x0a, 0x0a, 0x0a, 0x0a,
    0x5d, 0xb8, 0xd8, 0x77, 0xa3, 0x1a, 0x00, 0x50,
    0x53, 0x38, 0xcc, 0xc2, 0x56, 0x37, 0xb3, 0x55,
    0x80, 0x18, 0x00, 0x73, 0x02, 0xa4, 0x00, 0x00,
    0x01, 0x01, 0x08, 0x0a, 0x00, 0x2c, 0x85, 0x1b,
    0x1b, 0x7f, 0x3a, 0x71, 0x47, 0x45, 0x54, 0x20,
    0x2f, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31,
    0x2e, 0x31, 0x0d, 0x0a, 0x48, 0x6f, 0x73, 0x74,
    0x3a, 0x20, 0x77, 0x77, 0x77, 0x2e, 0x65, 0x78,
    0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f,
    0x6d, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x6e, 0x65,
    0x63, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x6b,
    0x65, 0x65, 0x70, 0x2d, 0x61, 0x6c, 0x69, 0x76,
    0x65, 0x0d, 0x0a, 0x43, 0x61, 0x63, 0x68, 0x65,
    0x2d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
    0x3a, 0x20, 0x6d, 0x61, 0x78, 0x2d, 0x61, 0x67,
    0x65, 0x3d, 0x30, 0x0d, 0x0a, 0x41, 0x63, 0x63,
    0x65, 0x70, 0x74, 0x3a, 0x20, 0x74, 0x65, 0x78,
    0x74, 0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x2c, 0x61,
    0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x2f, 0x78, 0x68, 0x74, 0x6d, 0x6c,
    0x2b, 0x78, 0x6d, 0x6c, 0x2c, 0x61, 0x70, 0x70,
    0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x2f, 0x78, 0x6d, 0x6c, 0x3b, 0x71, 0x3d, 0x30,
    0x2e, 0x39, 0x2c, 0x69, 0x6d, 0x61, 0x67, 0x65,
    0x2f, 0x77, 0x65, 0x62, 0x70, 0x2c, 0x2a, 0x2f,
    0x2a, 0x3b, 0x71, 0x3d, 0x30, 0x2e, 0x38, 0x0d,
    0x0a, 0x55, 0x73, 0x65, 0x72, 0x2d, 0x41, 0x67,
    0x65, 0x6e, 0x74, 0x3a, 0x20, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x58, 0x58, 0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65,
    0x70, 0x74, 0x2d, 0x45, 0x6e, 0x63, 0x6f, 0x64,
    0x69, 0x6e, 0x67, 0x3a, 0x20, 0x67, 0x7a, 0x69,
    0x70, 0x2c, 0x64, 0x65, 0x66, 0x6c, 0x61, 0x74,
    0x65, 0x2c, 0x73, 0x64, 0x63, 0x68, 0x0d, 0x0a,
    0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x4c,
    0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x3a,
    0x20, 0x65, 0x6e, 0x2d, 0x55, 0x53, 0x2c, 0x65,
    0x6e, 0x3b, 0x71, 0x3d, 0x30, 0x2e, 0x38, 0x0d,
    0x0a, 0x49, 0x66, 0x2d, 0x4e, 0x6f, 0x6e, 0x65,
    0x2d, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x3a, 0x20,
    0x22, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
    0x33, 0x33, 0x22, 0x0d, 0x0a, 0x49, 0x66, 0x2d,
    0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64,
    0x2d, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x3a, 0x20,
    0x46, 0x72, 0x69, 0x2c, 0x20, 0x30, 0x33, 0x20,
    0x41, 0x75, 0x67, 0x20, 0x32, 0x30, 0x31, 0x34,
    0x20, 0x31, 0x33, 0x3a, 0x33, 0x33, 0x3a, 0x33,
    0x33, 0x20, 0x47, 0x4d, 0x54, 0x0d, 0x0a, 0x0d,
    0x0a 
};

// IPV4 DNS REQUEST
static const unsigned char dns_request[] =
{
    0x45, 0x00, 0x00, 0x39, 0x20, 0x90, 0x00, 0x00,
    0x49, 0x11, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x01,
    0x08, 0x08, 0x04, 0x04, 0xe0, 0x45, 0x00, 0x35,
    0x00, 0x25, 0x22, 0xa7, 0x17, 0x08, 0x01, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
    0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00,
    0x01
};

// IPV6 TCP SYN
static const unsigned char ipv6_tcp_syn[] =
{
    0x60, 0x00, 0x00, 0x00, 0x00, 0x28, 0x06, 0x40,
    0x12, 0x34, 0x56, 0x78, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc, 0xdd,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0xc3, 0x7e, 0x00, 0x17, 0xe1, 0xd7, 0xc8, 0xaa,
    0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0xaa, 0xaa,
    0xc3, 0x5e, 0x00, 0x00, 0x02, 0x04, 0xff, 0xc4,
    0x04, 0x02, 0x08, 0x0a, 0xff, 0xff, 0x91, 0x86,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07            
};

// IPV6 ICMPV6 ECHO REPLY
static const unsigned char ipv6_echo_reply[] =
{
    0x60, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3a, 0x1f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x81, 0x00, 0x6e, 0xd6, 0x10, 0x72, 0x00, 0x03,
    0xa4, 0xd5, 0x69, 0x54, 0x00, 0x00, 0x00, 0x00,
    0xab, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
    0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
    0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77
};

// IPV6 EXTENSION HEADERS UDP 
static const unsigned char ipv6_exthdrs_udp[] =
{
    0x60, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x64,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x12, 0x34, 0xaa, 0xaa, 0x00, 0x15, 0xef, 0xf4,
    0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f,
    0x72, 0x6c, 0x64, 0x21, 0x01
};

// IPV4 FRAGMENT #0
static const unsigned char ipv4_fragment_0[] =
{
    0x45, 0x00, 0x00, 0x1C, 0x12, 0x34, 0x20, 0x00,
    0x40, 0x01, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x01,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x3c, 0xd2,
    0x0d, 0x56, 0x00, 0x01
};

// IPV4 FRAGMENT #1
static const unsigned char ipv4_fragment_1[] =
{
    0x45, 0x00, 0x00, 0x4C, 0x12, 0x34, 0x00, 0x01,
    0x40, 0x01, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x01,
    0x08, 0x08, 0x08, 0x08, 0x8b, 0xa6, 0x60, 0x54,
    0x00, 0x00, 0x00, 0x00, 0xf9, 0x08, 0x0a, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13,
    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37
};

// IPV6 FRAGMENT #0
static const unsigned char ipv6_fragment_0[] =
{
    0x60, 0x00, 0x00, 0x00, 0x00, 0x20, 0x2c, 0x1f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x3a, 0x00, 0x00, 0x01, 0xc7, 0xf6, 0xce, 0x53,
    0x81, 0x00, 0x6e, 0xd6, 0x10, 0x72, 0x00, 0x03,
    0xa4, 0xd5, 0x69, 0x54, 0x00, 0x00, 0x00, 0x00,
    0xab, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// IPV6 FRAGMENT #1
static const unsigned char ipv6_fragment_1[] =
{
    0x60, 0x00, 0x00, 0x00, 0x00, 0x30, 0x2c, 0x1f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x3a, 0x00, 0x00, 0x18, 0xc7, 0xf6, 0xce, 0x53,
    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
    0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
    0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77
};

```

`wddk-build.bat`:

```bat
:: wddk-build.bat
:: (C) 2019, all rights reserved,
::
:: This file is part of WinDivert.
::
:: WinDivert is free software: you can redistribute it and/or modify it under
:: the terms of the GNU Lesser General Public License as published by the
:: Free Software Foundation, either version 3 of the License, or (at your
:: option) any later version.
::
:: This program is distributed in the hope that it will be useful, but
:: WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
:: or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
:: License for more details.
::
:: You should have received a copy of the GNU Lesser General Public License
:: along with this program.  If not, see <http://www.gnu.org/licenses/>.
::
:: WinDivert is free software; you can redistribute it and/or modify it under
:: the terms of the GNU General Public License as published by the Free
:: Software Foundation; either version 2 of the License, or (at your option)
:: any later version.
:: 
:: This program is distributed in the hope that it will be useful, but
:: WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
:: or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
:: for more details.
:: 
:: You should have received a copy of the GNU General Public License along
:: with this program; if not, write to the Free Software Foundation, Inc., 51
:: Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
::
:: Script for WDDK compilation.
:: NOTE: Use this script to build the driver

@echo off

set WDDK_INSTALL=install\WDDK\
mkdir %WDDK_INSTALL%

build -cZg


```