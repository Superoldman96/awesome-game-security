Project Path: arc_gmh5225_pubg_internal_lt39bpr7

Source Tree:

```txt
arc_gmh5225_pubg_internal_lt39bpr7
├── FW1FontWrapper
│   ├── FW1FontWrapper.h
│   └── x64
│       ├── FW1FontWrapper.dll
│       └── FW1FontWrapper.lib
├── MinHook
│   ├── include
│   │   └── MinHook.h
│   └── lib
│       ├── libMinHook-x64-v141-md.lib
│       ├── libMinHook-x64-v141-mdd.lib
│       ├── libMinHook-x64-v141-mt.lib
│       └── libMinHook-x64-v141-mtd.lib
├── PUBG_Internal.cpp
├── README.md
├── dllmain.cpp
├── stdafx.cpp
├── stdafx.h
└── targetver.h

```

`FW1FontWrapper/FW1FontWrapper.h`:

```h
// FW1FontWrapper.h

// v1.1, October 2011
// Written by Erik Rufelt

#ifndef IncludeGuard__FW1_FW1FontWrapper_h
#define IncludeGuard__FW1_FW1FontWrapper_h

#include <D3D11.h>
#include <DWrite.h>


/// <summary>The current FW1 version.</summary>
/// <remarks>This constant should be used when calling FW1CreateFactory to make sure the library version matches the headers.</remarks>
#define FW1_VERSION 0x110f

#define FW1_DLL_W L"FW1FontWrapper.dll"
#define FW1_DLL_A "FW1FontWrapper.dll"

#ifdef UNICODE
	#define FW1_DLL FW1_DLL_W
#else
	#define FW1_DLL FW1_DLL_A
#endif

/// <summary>Describes overrides for how an FW1 operation is performed.</summary>
/// <remarks>These flags can be used for any FW1 methods that take a flags parameter. Not all flags have any meaning for all methods however.
/// Consult the documentation page for a particular method for information on what flags are valid.</remarks>
enum FW1_TEXT_FLAG {
	/// <summary>Text is left-aligned. This is the default.</summary>
	FW1_LEFT = 0x0,
	
	/// <summary>Text is centered horizontally.</summary>
	FW1_CENTER = 0x1,
	
	/// <summary>Text is right-aligned.</summary>
	FW1_RIGHT = 0x2,
	
	/// <summary>Text is aligned at the top of the layout-box. This is the default.</summary>
	FW1_TOP = 0x0,
	
	/// <summary>Text is centered vertically.</summary>
	FW1_VCENTER = 0x4,
	
	/// <summary>Text is aligned at the bottom of the layout-box.</summary>
	FW1_BOTTOM = 0x8,
	
	/// <summary>No automatic wrapping when the text overflows the layout-box.</summary>
	FW1_NOWORDWRAP = 0x10,
	
	/// <summary>Text is drawn without anti-aliasing.</summary>
	FW1_ALIASED = 0x20,
	
	/// <summary>If a clip-rect is specified together with this flag, all text is clipped to inside the specified rectangle.</summary>
	FW1_CLIPRECT = 0x40,
	
	/// <summary>No geometry shader is used when drawing glyphs. Indexed quads are constructed on the CPU instead of in the geometry shader.</summary>
	FW1_NOGEOMETRYSHADER = 0x80,
	
	/// <summary>The transform matrix and the clip-rect is not updated in the internal constant-buffer. Can be used as an optimization when a previous call has already set the correct data.</summary>
	FW1_CONSTANTSPREPARED = 0x100,
	
	/// <summary>The internal vertex and index buffer (if used) are assumed to already be bound. Can be used as an optimization when a previous call has already set the buffers.</summary>
	FW1_BUFFERSPREPARED = 0x200,
	
	/// <summary>The correct shaders/constant-buffer etc. are assumed to already be bound. Can be used as an optimization when a previous call has already set the states, or to override the default states.</summary>
	FW1_STATEPREPARED = 0x400,
	
	/// <summary>Can be used as an optimization on subsequent calls, when drawing several strings with the same settings.</summary>
	FW1_IMMEDIATECALL = FW1_CONSTANTSPREPARED | FW1_BUFFERSPREPARED | FW1_STATEPREPARED,
	
	/// <summary>When a draw method returns, the device-context will have been restored to the same state as before the call.</summary>
	FW1_RESTORESTATE = 0x800,
	
	/// <summary>Any new glyphs added during a call are not flushed to the device-resources.
	/// It is a good idea to use this flag for text-operations on deferred contexts, when drawing text on multiple threads simultaneously, in order to guarantee the proper order of operations.</summary>
	FW1_NOFLUSH = 0x1000,
	
	/// <summary>Any new glyphs will be cached in the atlas and glyph-maps, but no geometry is drawn.</summary>
	FW1_CACHEONLY = 0x2000,
	
	/// <summary>No new glyphs will be added to the atlas or glyph-maps. Any glyphs not already present in the atlas will be replaced with a default fall-back glyph (empty box).</summary>
	FW1_NONEWGLYPHS = 0x4000,
	
	/// <summary>A text-layout will be run through DirectWrite and new fonts will be prepared, but no actual drawing will take place, and no additional glyphs will be cached.</summary>
	FW1_ANALYZEONLY = 0x8000,
	
	/// <summary>Don't use.</summary>
	FW1_UNUSED = 0xffffffff
};

/// <summary>Coordinates for a single glyph in the atlas.</summary>
/// <remarks>Each glyph image inserted in a glyph sheet texture gets a unique index in that sheet, and a corresponding FW1_GLYPHCOORDS entry in the sheet's coord buffer, describing its location in the sheet as well as its dimensions.</remarks>
struct FW1_GLYPHCOORDS {
	/// <summary>The left texture coordinate.</summary>
	FLOAT TexCoordLeft;
	
	/// <summary>The top texture coordinate.</summary>
	FLOAT TexCoordTop;
	
	/// <summary>The right texture coordinate.</summary>
	FLOAT TexCoordRight;
	
	/// <summary>The bottom texture coordinate.</summary>
	FLOAT TexCoordBottom;
	
	/// <summary>The offset of the left edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionLeft;
	
	/// <summary>The offset of the top edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionTop;
	
	/// <summary>The offset of the right edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionRight;
	
	/// <summary>The offset of the bottom edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionBottom;
};

/// <summary>Description of a glyph sheet.</summary>
/// <remarks></remarks>
struct FW1_GLYPHSHEETDESC {
	/// <summary>The number of glyphs currently stored in this sheet.</summary>
	UINT GlyphCount;
	
	/// <summary>The width of this sheet's texture, in pixels.</summary>
	UINT Width;
	
	/// <summary>The height of this sheet's texture, in pixels.</summary>
	UINT Height;
	
	/// <summary>The number of mip-levels for this sheet's texture.</summary>
	UINT MipLevels;
};

/// <summary>Metrics for a glyph image.</summary>
/// <remarks>This structure is filled in as part of the FW1_GLYPHIMAGEDATA structure when a glyph-image is rendered by IFW1DWriteRenderTarget::DrawGlyphTemp.</remarks>
struct FW1_GLYPHMETRICS {
	/// <summary>The horizontal offset from a glyph's position in text to the left edge of its image.</summary>
	FLOAT OffsetX;
	
	/// <summary>The vertical offset form a glyph's position in text to the top edge of its image.</summary>
	FLOAT OffsetY;
	
	/// <summary>The width of the glyph image, in pixels.</summary>
	UINT Width;
	
	/// <summary>The height of the glyph image, in pixels.</summary>
	UINT Height;
};

/// <summary>Image data for a glyph.</summary>
/// <remarks>This structure is filled by the IFW1DWriteRenderTarget::DrawGlyphTemp Method.</remarks>
struct FW1_GLYPHIMAGEDATA {
	/// <summary>Metrics for the glyph.</summary>
	FW1_GLYPHMETRICS Metrics;
	
	/// <summary>Pointer to the pixels of the glyph-image.</summary>
	const void *pGlyphPixels;
	
	/// <summary>The number of bytes in a row of the image data.</summary>
	UINT RowPitch;
	
	/// <summary>The number of bytes between the start of one pixel and the next.</summary>
	UINT PixelStride;
};

/// <summary>A vertex corresponding to a single glyph.</summary>
/// <remarks>When an IFW1TextRenderer draws a string, each output glyph is converted to an FW1_GLYPHVERTEX entry in an IFW1TextGeometry object.</remarks>
struct FW1_GLYPHVERTEX {
	/// <summary>The base X position of the glyph.</summary>
	FLOAT PositionX;
	
	/// <summary>The base Y position of the glyph.</summary>
	FLOAT PositionY;
	
	/// <summary>The index of the glyph.</summary>
	UINT32 GlyphIndex;
	
	/// <summary>The color of the glyph, as 0xAaBbGgRr.</summary>
	UINT32 GlyphColor;
};

/// <summary>An array of vertices, sorted by glyph-sheet.</summary>
/// <remarks>This structure is returned by the IFW1TextGeometry::GetGlyphVerticesTemp Method.</remarks>
struct FW1_VERTEXDATA {
	/// <summary>The number of sheets in the glyph-atlas that are used, starting with the first sheet in the atlas.</summary>
	UINT SheetCount;
	
	/// <summary>An array of <i>SheetCount</i> unsigned integers, which specify the number of glyphs using each sheet.
	/// The sum of all counts is <i>TotalVertexCount</i>. Some counts may be zero.</summary>
	const UINT *pVertexCounts;
	
	/// <summary>The total number of vertices.</summary>
	UINT TotalVertexCount;
	
	/// <summary>An array of <i>TotalVertexCount</i> vertices, sorted by sheet.</summary>
	const FW1_GLYPHVERTEX *pVertices;
};

/// <summary>A rectangle.</summary>
/// <remarks></remarks>
struct FW1_RECTF {
	/// <summary>The X coordinate of the left edge of the rectangle.</summary>
	FLOAT Left;
	
	/// <summary>The Y coordinate of the top edge of the rectangle.</summary>
	FLOAT Top;
	
	/// <summary>The X coordinate of the right edge of the rectangle.</summary>
	FLOAT Right;
	
	/// <summary>The Y coordinate of the bottom edge of the rectangle.</summary>
	FLOAT Bottom;
};

/// <summary>Describes a single font. This structure is used in the FW1_FONTWRAPPERCREATEPARAMS structure.</summary>
/// <remarks>If pszFontFamily is NULL when creating an IFW1FontWrapper object, no default font will be set up.
/// This is perfectly valid when drawing text using one of the DrawTextLayout methods.
/// However, the DrawString methods will silently fail if no default font is set up.<br/>
/// If pszFontFamily is not NULL, the FontWeight, FontStyle and FontStretch members must be set to valid values according to the DirectWrite documentation.
/// Zero is not a valid value for these.</remarks>
struct FW1_DWRITEFONTPARAMS {
	/// <summary>The name of the font-family. Valid values include <i>Arial</i>, <i>Courier New</i>, etc. as long as the specified font is installed.
	/// Unavailable fonts will automatically fall back to a different font.
	/// This member can be set to NULL, if no default font is desired when using the structure to create a font-wrapper.</summary>
	LPCWSTR pszFontFamily;
	
	/// <summary>The font weight. See DirectWrite documentation.</summary>
	DWRITE_FONT_WEIGHT FontWeight;
	
	/// <summary>The font style. See DirectWrite documentation.</summary>
	DWRITE_FONT_STYLE FontStyle;
	
	/// <summary>The font stretch. See DirectWrite documentation.</summary>
	DWRITE_FONT_STRETCH FontStretch;
	
	/// <summary>The locale. NULL for default.</summary>
	LPCWSTR pszLocale;
};

/// <summary>The FW1_FONTWRAPPERCREATEPARAMS is used with the IFW1Factory::CreateFontWrapper method, and describes settings for the created IFW1FontWrapper object.</summary>
/// <remarks>If a member has the value zero, the default value will be chosen instead. See FW1_DWRITEFONTPARAMS for requirements for its members.</remarks>
struct FW1_FONTWRAPPERCREATEPARAMS {
	/// <summary>The width of the glyph sheet textures to store glyph images in. 0 defaults to 512.</summary>
	UINT GlyphSheetWidth;
	
	/// <summary>The height of the glyph sheet textures to store glyph images in. 0 defaults to 512.</summary>
	UINT GlyphSheetHeight;
	
	/// <summary>The maximum number of glyphs per texture. A buffer of <i>MaxGlyphCountPerSheet * 32</i> bytes is preallocated for each sheet. 0 defaults to 2048.</summary>
	UINT MaxGlyphCountPerSheet;
	
	/// <summary>The number of mip-levels for the glyph sheet textures. 0 defaults to 1.</summary>
	UINT SheetMipLevels;
	
	/// <summary>If set to TRUE, the sampler-state is created with anisotropic filtering.</summary>
	BOOL AnisotropicFiltering;
	
	/// <summary>The maximum width of a single glyph.
	/// This value is used to decide how large the DirectWrite render target needs to be, which is used when drawing glyph images to put in the atlas.
	/// 0 defaults to 384.</summary>
	UINT MaxGlyphWidth;
	
	/// <summary>The maximum height of a single glyph.
	/// This value is used to decide how large the DirectWrite render target needs to be, which is used when drawing glyph images to put in the atlas.
	/// 0 defaults to 384.</summary>
	UINT MaxGlyphHeight;
	
	/// <summary>If set to TRUE, no geometry shader is used.</summary>
	BOOL DisableGeometryShader;
	
	/// <summary>The size in bytes of the dynamic vertex buffer to upload glyph vertices to when drawing a string. 0 defaults to 4096 * 16.<br/>
	/// Each glyph vertex is either 16 or 20 bytes in size, and each glyph requires either 1 or 4 vertices depending on if the geometry shader is used.</summary>
	UINT VertexBufferSize;
	
	/// <summary>Description of the default font. See FW1_DWRITEFONTPARAMS.</summary>
	FW1_DWRITEFONTPARAMS DefaultFontParams;
};

interface IFW1Factory;
/// <summary>All FW1 interfaces (except for IFW1Factory) inherits from IFW1Object.</summary>
/// <remarks>Since all interfaces inhert from IFW1Object, the factory which created an object can always be queried with its GetFactory method.</remarks>
MIDL_INTERFACE("8D3C3FB1-F2CC-4331-A623-031F74C06617") IFW1Object : public IUnknown {
	public:
		/// <summary>Get the factory that created an object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppFactory">Address of a pointer to an IFW1Factory.</param>
		virtual HRESULT STDMETHODCALLTYPE GetFactory(
			__out IFW1Factory **ppFactory
		) = 0;
};

/// <summary>A sheet contains a texture with glyph images, and a coord-buffer with an FW1_GLYPHCOORDS entry for each glyph.</summary>
MIDL_INTERFACE("60CAB266-C805-461d-82C0-392472EECEFA") IFW1GlyphSheet : public IFW1Object {
	public:
		/// <summary>Get the ID3D11Device the sheet is created on.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
		virtual HRESULT STDMETHODCALLTYPE GetDevice(
			__out ID3D11Device **ppDevice
		) = 0;
		
		/// <summary>Get the properties of a glyph sheet.</summary>
		/// <remarks></remarks>
		/// <returns>Returns nothing.</returns>
		/// <param name="pDesc">Pointer to a sheet description.</param>
		virtual void STDMETHODCALLTYPE GetDesc(
			__out FW1_GLYPHSHEETDESC *pDesc
		) = 0;
		
		/// <summary>Get the ID3D11ShaderResourceView for the sheet's texture.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppSheetTextureSRV">Address of a pointer to an ID3D11ShaderResourceView.</param>
		virtual HRESULT STDMETHODCALLTYPE GetSheetTexture(
			__out ID3D11ShaderResourceView **ppSheetTextureSRV
		) = 0;
		
		/// <summary>Get the ID3D11ShaderResourceView for the sheet's coord buffer.</summary>
		/// <remarks>The coord buffer contains 32 bytes per glyph, stored as two float4, representing the data in an FW1_GLYPHCOORDS structure.<br/>
		/// If the sheet is created without a hardware coord buffer, the method will return success and set the coord buffer to NULL.
		/// See IFW1Factory::CreateGlyphSheet.</remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppCoordBufferSRV">Address of a pointer to an ID3D11ShaderResourceView.</param>
		virtual HRESULT STDMETHODCALLTYPE GetCoordBuffer(
			__out ID3D11ShaderResourceView **ppCoordBufferSRV
		) = 0;
		
		/// <summary>Get a sheet's coord-buffer, as an array of FW1_GLYPHCOORDS.</summary>
		/// <remarks>The returned buffer is valid for the lifetime of the sheet, and may only be read and never altered.
		/// The maximum valid index at any given time is one less than the number of glyphs in the sheet, which can be queried using IFW1GlyphSheet::GetDesc.</remarks>
		/// <returns>Returns a constant pointer to the sheet's coord-buffer.</returns>
		virtual const FW1_GLYPHCOORDS* STDMETHODCALLTYPE GetGlyphCoords(
		) = 0;
		
		/// <summary>Set the sheet shader resources on the provided context.</summary>
		/// <remarks>This method sets the sheet texture as a pixelshader resource for slot 0, and optionally the coord buffer as geometryshader resource for slot 0.</remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pContext">The context to set the sheet shader resources on.</param>
		/// <param name="Flags">This parameter can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
		/// FW1_NOGEOMETRYSHADER: don't bind the coord buffer as a shader-resource for the geometry shader, even if it's available.
		/// </param>
		virtual HRESULT STDMETHODCALLTYPE BindSheet(
			__in ID3D11DeviceContext *pContext,
			__in UINT Flags
		) = 0;
		
		/// <summary>Insert a glyph into the sheet.</summary>
		/// <remarks>The parameters for this method can be obtained as part of the FW1_GLYPHIMAGEDATA structure filled in by the IFW1DWriteRenderTarget::DrawGlyphTemp method.</remarks>
		/// <returns>If the glyph is inserted, the index of the new glyph in the sheet is returned. This index can be used to get the glyph's coordinates from the sheet coord buffer. See IFW1GlyphSheet::GetCoordBuffer and IFW1GlyphSheet::GetGlyphCoords.<br/>
		/// If the method fails to insert the glyph, the returned value is 0xFFFFFFFF.</returns>
		/// <param name="pGlyphMetrics">A pointer to an FW1_GLYPHMETRICS structure, specifying the metrics of the glyph to be inserted.</param>
		/// <param name="pGlyphData">A pointer to image data.</param>
		/// <param name="RowPitch">The number of bytes in a row of image data.</param>
		/// <param name="PixelStride">The number of bytes between successive pixels.</param>
		virtual UINT STDMETHODCALLTYPE InsertGlyph(
			__in const FW1_GLYPHMETRICS *pGlyphMetrics,
			__in const void *pGlyphData,
			__in UINT RowPitch,
			__in UINT PixelStride
		) = 0;
		
		/// <summary>Close the sheet for additional glyphs.</summary>
		/// <remarks>After calling this method any subsequent attempts to insert new glyphs into the sheet will fail.
		/// Calling this method can save some memory as the RAM copy of the texture can be released after the next call to IFW1GlyphSheet::Flush.</remarks>
		/// <returns>No return value.</returns>
		virtual void STDMETHODCALLTYPE CloseSheet(
		) = 0;
		
		/// <summary>Flush any new glyphs to the internal D3D11 buffers.</summary>
		/// <remarks>When glyphs are inserted into the sheet only the CPU-memory resources are updated.
		/// In order for these to be available for use by the GPU, they must be flushed to the device using a device-context.</remarks>
		/// <returns>No return value.</returns>
		/// <param name="pContext">The context to use when updating device resources.</param>
		virtual void STDMETHODCALLTYPE Flush(
			__in ID3D11DeviceContext *pContext
		) = 0;
};

/// <summary>A glyph-atlas is a collection of glyph-sheets.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("A31EB6A2-7458-4e24-82B3-945A95623B1F") IFW1GlyphAtlas : public IFW1Object {
	/// <summary>Get the ID3D11Device the atlas is created on.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Get the total number of glyphs in all the atlas' sheets.</summary>
	/// <remarks></remarks>
	/// <returns>The total number of glyphs in the atlas.</returns>
	virtual UINT STDMETHODCALLTYPE GetTotalGlyphCount(
	) = 0;
	
	/// <summary>Get the number of texture sheets in the atlas.</summary>
	/// <remarks></remarks>
	/// <returns>The number of sheets in the atlas.</returns>
	virtual UINT STDMETHODCALLTYPE GetSheetCount(
	) = 0;
	
	/// <summary>Get a pointer to an IFW1GlyphSheet in the atlas.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="SheetIndex">The index of the sheet to be obtained.</param>
	/// <param name="ppGlyphSheet">Address of a pointer to an IFW1GlyphSheet.</param>
	virtual HRESULT STDMETHODCALLTYPE GetSheet(
		__in UINT SheetIndex,
		__out IFW1GlyphSheet **ppGlyphSheet
	) = 0;
	
	/// <summary>Get a pointer to a sheet's glyph-coord buffer.</summary>
	/// <remarks></remarks>
	/// <returns>If <i>SheetIndex</i> is valid, returns a pointer to a coord buffer. See IFW1GlyphSheet::GetGlyphCoords.</returns>
	/// <param name="SheetIndex">The index of the sheet which coord buffer is to be obtained.</param>
	virtual const FW1_GLYPHCOORDS* STDMETHODCALLTYPE GetGlyphCoords(
		__in UINT SheetIndex
	) = 0;
	
	/// <summary>Bind a sheet's shader resources on a device context.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="pContext">The context to set the shader resources on.</param>
	/// <param name="SheetIndex">The index of the sheet to bind.</param>
	/// <param name="Flags">Flags that specify whether to set the geometry shader coord buffer. See IFW1GlyphSheet::BindSheet.</param>
	virtual HRESULT STDMETHODCALLTYPE BindSheet(
		__in ID3D11DeviceContext *pContext,
		__in UINT SheetIndex,
		__in UINT Flags
	) = 0;
	
	/// <summary>Insert a glyph into the atlas.</summary>
	/// <remarks>The parameters for this method can be obtained as part of the FW1_GLYPHIMAGEDATA structure filled in by the IFW1DWriteRenderTarget::DrawGlyphTemp method.</remarks>
	/// <returns>If the glyph is inserted, the ID of the new glyph in the atlas is returned.
	/// The ID is always <tt>((SheetIndex &lt;&lt; 16) | GlyphIndex)</tt>, where <i>SheetIndex</i> is the index of the sheet texture the glyph is place in, and <i>GlyphIndex</i> is the index of the glyph in that sheet.<br/>
	/// If the method fails to insert the glyph, the returned value is 0xFFFFFFFF.</returns>
	/// <param name="pGlyphMetrics">A pointer to an FW1_GLYPHMETRICS structure, specifying the metrics of the glyph to be inserted.</param>
	/// <param name="pGlyphData">A pointer to image data.</param>
	/// <param name="RowPitch">The number of bytes in a row of image data.</param>
	/// <param name="PixelStride">The number of bytes between successive pixels.</param>
	virtual UINT STDMETHODCALLTYPE InsertGlyph(
		__in const FW1_GLYPHMETRICS *pGlyphMetrics,
		__in const void *pGlyphData,
		__in UINT RowPitch,
		__in UINT PixelStride
	) = 0;
	
	/// <summary>Insert a sheet into the atlas.</summary>
	/// <remarks>This method is used internally whenever new glyphs no longer fits in existing sheets. The atlas will hold a reference to the sheet for the remainder of its lifetime.</remarks>
	/// <returns>On success, eturns the index of the sheet in the atlas after insertion.<br/>If the method fails, 0xFFFFFFFF is returned.</returns>
	/// <param name="pGlyphSheet">A pointer ot the glyph sheet to insert.</param>
	virtual UINT STDMETHODCALLTYPE InsertSheet(
		__in IFW1GlyphSheet *pGlyphSheet
	) = 0;
	
	/// <summary>Flush all new or internally updated sheets.</summary>
	/// <remarks>See IFW1GlyphSheet::Flush.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The context to use when updating device resources.</param>
	virtual void STDMETHODCALLTYPE Flush(
		__in ID3D11DeviceContext *pContext
	) = 0;
};

/// <summary>Collection of glyph-maps, mapping font/size/glyph information to an ID in a glyph atlas.</summary>
/// <remarks>Whenever a glyph or glyphmap is queried from the glyph-provider, it will be dynamically inserted if it does not already exist.</remarks>
MIDL_INTERFACE("F8360043-329D-4EC9-B0F8-ACB00FA77420") IFW1GlyphProvider : public IFW1Object {
	/// <summary>Get the IFW1GlyphAtlas this glyph-provider references.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphAtlas">Address of a pointer to an IFW1GlyphAtlas.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphAtlas(
		__out IFW1GlyphAtlas **ppGlyphAtlas
	) = 0;
	
	/// <summary>Get the DirectWrite factory a glyph-provider references.</summary>
	/// <remarks>The DirectWrite factory is used internally to create render-targets needed to draw glyph-images that are put in the glyph-atlas.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDWriteFactory">Address of a pointer to an IDWriteFactory.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDWriteFactory(
		__out IDWriteFactory **ppDWriteFactory
	) = 0;
	
	/// <summary>Get the DirectWrite font-collection referenced by a glyph-provider.</summary>
	/// <remarks>The DirectWrite font collection is used internally only to match font-faces to unique names.
	/// Since different IDWriteFontFace objects can reference the same font, a reliable method of identifying a font is required.
	/// This is the only function of the font-collection in the scope of the glyph-provider.
	/// A font-face not from the same collection can still be used when requesting glyphs, in which case it will only be identified by its pointer value.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppFontCollection">Address of a pointer to an IDWriteFontCollection.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDWriteFontCollection(
		__out IDWriteFontCollection **ppFontCollection
	) = 0;
	
	/// <summary>Get a pointer identifying a glyph-map matching the specified font.</summary>
	/// <remarks>If the FW1_NONEWGLYPHS flag is not specified, new glyph-maps are created on demand.
	/// The glyph-map returned from this method is not meaningful outside of the glyph provider internals, but is needed for subsequent calls to IFW1GlyphProvider::GetAtlasIdFromGlyphIndex.</remarks>
	/// <returns>A constant pointer identifying a glyph-map.
	/// This pointer should only be used in subsequent calls to IFW1GlyphProvider::GetAtlasIdFromGlyphIndex, and remains valid for the lifetime of the IFW1GlyphProvider.<br/>
	/// A NULL pointer may be returned, if using the FW1_NONEWGLYPHS flag and a matching glyph-map does not exist.</returns>
	/// <param name="pFontFace">A DirectWrite font face.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="FontFlags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_ALIASED - No anti-aliasing is used when drawing the glyphs.<br/>
	/// FW1_NONEWGLYPHS - No new glyph-maps are created.</param>
	virtual const void* STDMETHODCALLTYPE GetGlyphMapFromFont(
		__in IDWriteFontFace *pFontFace,
		__in FLOAT FontSize,
		__in UINT FontFlags
	) = 0;
	
	/// <summary>Get the ID of the specified glyph in the glyph-atlas.</summary>
	/// <remarks>If FW1_NONEWGLYPHS is not specified, any glyph not currently in the atlas will be inserted before the method returns.</remarks>
	/// <returns>The ID of the specified glyph in the glyph-atlas.
	/// The ID is always <tt>((SheetIndex &lt;&lt; 16) | GlyphIndex)</tt>, where <i>SheetIndex</i> is the index of the sheet texture the glyph is placed in, and <i>GlyphIndex</i> is the index of the glyph in that sheet.<br/>
	/// If the specified glyph does not exist and can not be inserted on demand, the ID of a fallback glyph is returned.</returns>
	/// <param name="pGlyphMap">A pointer identifying a glyph-map, previously obtained using IFW1GlyphProvider::GetGlyphMapFromFont.
	/// If this parameter is NULL, the ID of the last-resort fallback glyph is returned, which will be zero.</param>
	/// <param name="GlyphIndex">The index of the glyph in the DirectWrite font face.
	/// Glyph indices can be obtained from DirectWrite using IDWriteFontFace::GetGlyphIndices.</param>
	/// <param name="pFontFace">The DirectWrite font face that contains the glyph referenced by GlyphIndex.</param>
	/// <param name="FontFlags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_NONEWGLYPHS - No new glyphs are inserted.</param>
	virtual UINT STDMETHODCALLTYPE GetAtlasIdFromGlyphIndex(
		__in const void *pGlyphMap,
		__in UINT16 GlyphIndex,
		__in IDWriteFontFace *pFontFace,
		__in UINT FontFlags
	) = 0;
};

/// <summary>Container for a DirectWrite render-target, used to draw glyph images that are to be inserted in a glyph atlas.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("A1EB4141-9A66-4097-A5B0-6FC84F8B162C") IFW1DWriteRenderTarget : public IFW1Object {
	/// <summary>Draw a glyph-image.</summary>
	/// <remarks>The data returned in the FW1_GLYPHIMAGEDATA should only be read, and is valid until the next call to a method in the IFW1DWriteRenderTarget.<br/>
	/// This method is not thread-safe.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="pFontFace">The DirectWrite font face containing the glyph.</param>
	/// <param name="GlyphIndex">The index of the glyph in the font face.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="RenderingMode">The DirectWrite rendering mode. See DirectWrite documentation.</param>
	/// <param name="MeasuringMode">The DirectWrite measuring mode. See DirectWrite documentation..</param>
	/// <param name="pOutData">A pointer to an FW1_GLYPHIMAGEDATA structure that will be filled in with the glyph image data on success.</param>
	virtual HRESULT STDMETHODCALLTYPE DrawGlyphTemp(
		__in IDWriteFontFace *pFontFace,
		__in UINT16 GlyphIndex,
		__in FLOAT FontSize,
		__in DWRITE_RENDERING_MODE RenderingMode,
		__in DWRITE_MEASURING_MODE MeasuringMode,
		__out FW1_GLYPHIMAGEDATA *pOutData
	) = 0;
};

/// <summary>An RGBA color.</summary>
/// <remarks>An IFW1ColorRGBA object can be set as the drawing effect for a range in an IDWriteTextLayout, to override the default color of the text.</remarks>
MIDL_INTERFACE("A0EA03A0-441D-49BE-9D2C-4AE27BB7A327") IFW1ColorRGBA : public IFW1Object {
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="Color">The color to set, as 0xAaBbGgRr.</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in UINT32 Color
	) = 0;
	
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="Red">The red component, in [0, 1].</param>
	/// <param name="Green">The green component, in [0, 1].</param>
	/// <param name="Blue">The blue component, in [0, 1].</param>
	/// <param name="Alpha">The alpha component, in [0, 1].</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in FLOAT Red,
		__in FLOAT Green,
		__in FLOAT Blue,
		__in FLOAT Alpha
	) = 0;
	
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pColor">Pointer to an array of four floats in [0, 1], specifying the red, green, blue and alpha components at indices 0 to 3.</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in const FLOAT *pColor
	) = 0;
	
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pColor">Pointer to an array of four bytes in [0, 255], specifying the red, green, blue and alpha components at indices 0 to 3.</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in const BYTE *pColor
	) = 0;
	
	/// <summary>Get the color.</summary>
	/// <remarks></remarks>
	/// <returns>Returns the color, as 0xAaBbGgRr.</returns>
	virtual UINT32 STDMETHODCALLTYPE GetColor32(
	) = 0;
};

/// <summary>A dynamic list of vertices. Note that this object is a simple array without synchronization and not safe to use simultaneously on more than one thread.</summary>
/// <remarks>When rendering a string, a vertex is inserted into an IFW1TextGeometry object for each glyph.
/// The vertices in an IFW1TextGeometry can be drawn by the IFW1FontWrapper::DrawGeometry method.<br/>
/// A pointer to the actual vertices can be obtained with the IFW1TextGeometry::GetGlyphVerticesTemp method.</remarks>
MIDL_INTERFACE("51E05736-6AFF-44A8-9745-77605C99E8F2") IFW1TextGeometry : public IFW1Object {
	/// <summary>Clear any vertices currently contained in the geometry object.</summary>
	/// <remarks>This method is not thread-safe.</remarks>
	/// <returns>No return value.</returns>
	virtual void STDMETHODCALLTYPE Clear(
	) = 0;
	
	/// <summary>Adds a vertex to the geometry.</summary>
	/// <remarks>The GlyphIndex member of the FW1_GLYPHVERTEX specified when inserting a vertex should be the atlas ID of the desired glyph, as <tt>((SheetIndex &lt;&lt; 16) | GlyphIndex)</tt>.
	/// See IFW1GlyphAtlas::InsertGlyph.<br/>
	/// This method is not thread-safe.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pVertex">Pointer to an FW1_GLYPHVERTEX structure describing the vertex.</param>
	virtual void STDMETHODCALLTYPE AddGlyphVertex(
		__in const FW1_GLYPHVERTEX *pVertex
	) = 0;
	
	/// <summary>Get the vertices in the geometry, sorted by glyph sheet.</summary>
	/// <remarks>When glyphs are inserted into the geometry they contain their glyph atlas ID.
	/// The glyphs are internally sorted by glyph sheet, and glyphs returned by GetGlyphVerticesTemp contain the index of the glyph in its containing sheet, and not the atlas ID.<br/>
	/// This method is not thread-safe.</remarks>
	/// <returns>An FW1_VERTEXDATA structure containing the glyph vertices.
	/// The pointers in this structure are owned by the geometry object and should not be modified.
	/// They are valid until the next call to a method in the IFW1TextGeometry.</returns>
	virtual FW1_VERTEXDATA STDMETHODCALLTYPE GetGlyphVerticesTemp(
	) = 0;
};

/// <summary>A text-renderer converts DirectWrite text layouts into glyph-vertices.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("51E05736-6AFF-44A8-9745-77605C99E8F2") IFW1TextRenderer : public IFW1Object {
	/// <summary>Get the IFW1GlyphProvider used by a text-renderer.</summary>
	/// <remarks>The glyph provider is used internally to get the atlas IDs for any glyphs needed when drawing a text layout.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphProvider">Address of a pointer to an IFW1GlyphProvider.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphProvider(
		__out IFW1GlyphProvider **ppGlyphProvider
	) = 0;
	
	/// <summary>Convert a text layout to vertices.</summary>
	/// <remarks>This method internally calls the IDWriteTextLayout::Draw method, and handles callbacks to convert the formatted text into vertices, which will be stored in the passed IFW1TextGeometry object.
	/// This method is not thread-safe.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="pTextLayout">A DirectWrite text layout. See the DirectWrite documentation.</param>
	/// <param name="OriginX">The X origin of the text.</param>
	/// <param name="OriginY">The Y origin of the text.</param>
	/// <param name="Color">The default text color, as 0xAaGgBbRr.</param>
	/// <param name="Flags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_ALIASED - No anti-aliasing is used when drawing the glyphs.<br/>
	/// FW1_NONEWGLYPHS - No new glyphs are inserted into the atlas. Not previously cached glyphs are replaced with a fallback glyph (usually an empty box).<br/>
	/// FW1_CACHEONLY - All glyphs are queried from the glyph-provider and cached in the glyph-atlas, but no geometry is produced.<br/>
	/// FW1_ANALYZEONLY - The text-layout is analyzed and glyph-maps are prepared, but the glyphs in the string are not cached and no geometry is produced.<br/>
	/// </param>
	/// <param name="pTextGeometry">An IFW1TextGeometry object that the output vertices will be appended to.</param>
	virtual HRESULT STDMETHODCALLTYPE DrawTextLayout(
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in UINT Flags,
		__in IFW1TextGeometry *pTextGeometry
	) = 0;
};

/// <summary>This interface contains all render states and shaders needed to draw glyphs.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("906928B6-79D8-4b42-8CE4-DC7D7046F206") IFW1GlyphRenderStates : public IFW1Object {
	/// <summary>Get the ID3D11Device that all render states are created on.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Set the internal states on a context.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The context to set the states on.</param>
	/// <param name="Flags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_NOGEOMETRYSHADER - States are set up to draw indexed quads instead of constructing quads in the geometry shader.<br/>
	/// FW1_CLIPRECT - Shaders will be set up to clip any drawn glyphs to the clip-rect set in IFW1GlyphRenderStates::UpdateShaderConstants.
	/// </param>
	virtual void STDMETHODCALLTYPE SetStates(
		__in ID3D11DeviceContext *pContext,
		__in UINT Flags
	) = 0;
	
	/// <summary>Update the internal constant buffer.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The context to use to update the constant buffer.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip drawn glyphs to.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which all glyph vertices will be multiplied with, in the geometry or vertex shader.</param>
	virtual void STDMETHODCALLTYPE UpdateShaderConstants(
		__in ID3D11DeviceContext *pContext,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix
	) = 0;
	
	/// <summary>Returns whether a geometry shader is available.</summary>
	/// <remarks>When an IFW1GlyphRenderStates object is created, it may attempt to create a geometry shader, depending on the parameters passed to IFW1Factory::CreateRenderStates.
	/// If a geometry shader is not created, either because of the specified parameters or because the device feature level does not support geometry shaders, this method will return FALSE.</remarks>
	/// <returns>Returns TRUE if a geometry shader is available, and otherwise returns FALSE.</returns>
	virtual BOOL STDMETHODCALLTYPE HasGeometryShader(
	) = 0;
};

/// <summary>A container for a dynamic vertex and index buffer, used to draw glyph vertices.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("E6CD7A32-5B59-463c-9B1B-D44074FF655B") IFW1GlyphVertexDrawer : public IFW1Object {
	/// <summary>Get the ID3D11Device that the buffers are created on.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Upload the specified vertices to the device buffers and draw them.</summary>
	/// <remarks></remarks>
	/// <returns>Returns the index of the sheet in the atlas that was last bound to the device context during the operation.</returns>
	/// <param name="pContext">The context to use to draw.</param>
	/// <param name="pGlyphAtlas">The glyph atlas containg the glyphs referenced by the vertices.</param>
	/// <param name="pVertexData">Pointer to an FW1_VERTEXDATA structure, containing vertices to be drawn, sorted by glyph sheet.
	/// These are easiest obtained from an IFW1TextGeometry object.</param>
	/// <param name="Flags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_NOGEOMETRYSHADER - Vertices are converted to quads on the fly on the CPU, instead of being sent directly to the device for the geometry shader.<br/>
	/// FW1_BUFFERSPREPARED - The internal buffers are assumed to already be set on the device context from a previous call. (Avoids redundant state changes when drawing multiple times).
	/// </param>
	/// <param name="PreboundSheet">If a sheet in the atlas is known to already be correctly set on the device context, specify its index in the atlas with this parameter, to avoid redundant state changes.
	/// If no sheet is known to already be set, specify 0xFFFFFFFF, or another value greater than the number of sheets in the atlas.
	/// </param>
	virtual UINT STDMETHODCALLTYPE DrawVertices(
		__in ID3D11DeviceContext *pContext,
		__in IFW1GlyphAtlas *pGlyphAtlas,
		__in const FW1_VERTEXDATA *pVertexData,
		__in UINT Flags,
		__in UINT PreboundSheet
	) = 0;
};

/// <summary>The IFW1FontWrapper interface is the main interface used to draw text.
/// It holds references to all objects needed to format and convert text to vertices, as well as the D3D11 states and buffers needed to draw them.</summary>
/// <remarks>Create a font-wrapper using IFW1Factory::CreateFontWrapper</remarks>
MIDL_INTERFACE("83347A5C-B0B1-460e-A35C-427E8B85F9F4") IFW1FontWrapper : public IFW1Object {
	/// <summary>Get the ID3D11Device that is used by the font-wrapper.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Get the DirectWrite factory used by the font-wrapper.</summary>
	/// <remarks>The DirectWrite factory is used internally to create text-layouts when drawing strings using any of the DrawString methods.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDWriteFactory">Address of a pointer to an IDWriteFactory.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDWriteFactory(
		__out IDWriteFactory **ppDWriteFactory
	) = 0;
	
	/// <summary>Get the IFW1GlyphAtlas used to cache glyphs.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphAtlas">Address of a pointer to an IFW1GlyphAtlas.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphAtlas(
		__out IFW1GlyphAtlas **ppGlyphAtlas
	) = 0;
	
	/// <summary>Get the IFW1GlyphProvider used to map glyphs to atlas IDs.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphProvider">Address of a pointer to an IFW1GlyphProvider.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphProvider(
		__out IFW1GlyphProvider **ppGlyphProvider
	) = 0;
	
	/// <summary>Get the IFW1GlyphRenderStates containing the render states needed to draw glyphs.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppRenderStates">Address of a pointer to an IFW1GlyphRenderStates.</param>
	virtual HRESULT STDMETHODCALLTYPE GetRenderStates(
		__out IFW1GlyphRenderStates **ppRenderStates
	) = 0;
	
	/// <summary>Get the IFW1GlyphVertexDrawer used to draw glyph vertices.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppVertexDrawer">Address of a pointer to an IFW1GlyphVertexDrawer.</param>
	virtual HRESULT STDMETHODCALLTYPE GetVertexDrawer(
		__out IFW1GlyphVertexDrawer **ppVertexDrawer
	) = 0;
	
	/// <summary>Draw a DirectWrite text layout.</summary>
	/// <remarks>Consult the DirectWrite documentation for details on how to construct a text-layout.<br/>
	/// The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pTextLayout">The text layout to draw.</param>
	/// <param name="OriginX">The X origin of the text in the layout.</param>
	/// <param name="OriginY">The Y origin of the text in the layout.</param>
	/// <param name="Color">The default color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See FW1_TEXT_FLAG. The alignment and word-wrapping flags have no meaning when drawing a preconstructed text layout.</param>
	virtual void STDMETHODCALLTYPE DrawTextLayout(
		__in ID3D11DeviceContext *pContext,
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a DirectWrite text layout.</summary>
	/// <remarks>Consult the DirectWrite documentation for details on how to construct a text-layout.<br/>
	/// The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pTextLayout">The text layout to draw.</param>
	/// <param name="OriginX">The X origin of the text in the layout.</param>
	/// <param name="OriginY">The Y origin of the text in the layout.</param>
	/// <param name="Color">The default color of the text, as 0xAaBbGgRr.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip the text to if also using the FW1_CLIPRECT flag, or NULL to not clip.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which the text will be transformed by.</param>
	/// <param name="Flags">See FW1_TEXT_FLAG. The alignment and word-wrapping flags have no meaning when drawing a preconstructed text layout.</param>
	virtual void STDMETHODCALLTYPE DrawTextLayout(
		__in ID3D11DeviceContext *pContext,
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a string.</summary>
	/// <remarks>The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pszString">The NULL-terminated string to draw.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="X">The X origin of the text.</param>
	/// <param name="Y">The Y origin of the text .</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in FLOAT FontSize,
		__in FLOAT X,
		__in FLOAT Y,
		__in UINT32 Color,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a string.</summary>
	/// <remarks>The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pszString">The NULL-terminated string to draw.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="X">The X origin of the text.</param>
	/// <param name="Y">The Y origin of the text .</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in FLOAT X,
		__in FLOAT Y,
		__in UINT32 Color,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a string.</summary>
	/// <remarks>The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pszString">The NULL-terminated string to draw.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="pLayoutRect">A pointer to a rectangle to format the text in.</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip the text to if also using the FW1_CLIPRECT flag, or NULL to not clip.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which the text will be transformed by, or NULL to draw in screen-space.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in const FW1_RECTF *pLayoutRect,
		__in UINT32 Color,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix,
		__in UINT Flags
	) = 0;
	
	/// <summary>Measure a string.</summary>
	/// <remarks>This function uses the IDWriteTextLayout::GetOverhangMetrics to obtain the size of the string.</remarks>
	/// <returns>The smallest rectangle that completely contains the string if drawn with DrawString and the same parameters as used with MeasureString.</returns>
	/// <param name="pszString">The NULL-terminated string to measure.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="pLayoutRect">A pointer to a rectangle to format the text in.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual FW1_RECTF STDMETHODCALLTYPE MeasureString(
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in const FW1_RECTF *pLayoutRect,
		__in UINT Flags
	) = 0;
	
	/// <summary>Analyze a string and generate geometry to draw it.</summary>
	/// <remarks>pTextGeometry can be NULL if the FW1_ANALYZEONLY or FW1_CACHEONLY flags are specified, as no actual geometry will be generated.
	/// pContext can be NULL if the FW1_NOFLUSH flag is used, as any new glyphs will not be flushed to the device buffers.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">A device context to use to update device buffers when new glyphs are added to the glyph-atlas.</param>
	/// <param name="pszString">The NULL-terminated string to create geometry from.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="pLayoutRect">A pointer to a rectangle to format the text in.</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	/// <param name="pTextGeometry">An IFW1TextGeometry object that the output vertices will be appended to.</param>
	virtual void STDMETHODCALLTYPE AnalyzeString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in const FW1_RECTF *pLayoutRect,
		__in UINT32 Color,
		__in UINT Flags,
		__in IFW1TextGeometry *pTextGeometry
	) = 0;
	
	/// <summary>Analyze a text layout and generate geometry to draw it.</summary>
	/// <remarks>Consult the DirectWrite documentation for details on how to construct a text-layout.
	/// pTextGeometry can be NULL if the FW1_ANALYZEONLY or FW1_CACHEONLY flags are specified, as no actual geometry will be generated.
	/// pContext can be NULL if the FW1_NOFLUSH flag is used, as any new glyphs will not be flushed to the device buffers.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">A device context to use to update device buffers when new glyphs are added to the glyph-atlas.</param>
	/// <param name="pTextLayout">The DirectWrite text layout to create geometry from.</param>
	/// <param name="OriginX">The X origin of the text in the layout.</param>
	/// <param name="OriginY">The Y origin of the text in the layout.</param>
	/// <param name="Color">The default color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See FW1_TEXT_FLAG. The alignment and word-wrapping flags have no meaning when using a preconstructed text layout.</param>
	/// <param name="pTextGeometry">An IFW1TextGeometry object that the output vertices will be appended to.</param>
	virtual void STDMETHODCALLTYPE AnalyzeTextLayout(
		__in ID3D11DeviceContext *pContext,
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in UINT Flags,
		__in IFW1TextGeometry *pTextGeometry
	) = 0;
	
	/// <summary>Draw geometry.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pGeometry">The geometry to draw.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip the text to if also using the FW1_CLIPRECT flag, or NULL to not clip. This rect is in text-space, and clipping is performed prior to any transformation.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which the text will be transformed by, or NULL to draw in screen-space.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawGeometry(
		__in ID3D11DeviceContext *pContext,
		__in IFW1TextGeometry *pGeometry,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix,
		__in UINT Flags
	) = 0;
	
	/// <summary>Flush any new glyphs to GPU resources.</summary>
	/// <remarks>This method calls IFW1GlyphAtlas::Flush to flush any newly cached glyphs.
	/// This method is only needed if drawing text using the FW1_NOFLUSH flag and delaying flushing data to the device, as otherwise it is implicitly called whenever a string is drawn. See IFW1GlyphAtlas::Flush.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to use to update device resources.</param>
	virtual void STDMETHODCALLTYPE Flush(
		__in ID3D11DeviceContext *pContext
	) = 0;
};

/// <summary>
/// Used to create all subsequent FW1 objects.
/// An IFW1Factory can be created using FW1CreateFactory.
/// </summary>
/// <remarks>
/// Any and all FW1 objects are always created through a factory. All FW1 objects inherit from IFW1Object, and holds a reference to the factory that created them.
/// If an object in turn creates new objects, it uses the same factory that created the object itself.
/// For example, a glyph-atlas will ask the factory that created it to create new glyph-sheets as glyphs are added to the atlas.
/// </remarks>
MIDL_INTERFACE("8004DB2B-B5F9-4420-A6A2-E17E15E4C336") IFW1Factory : public IUnknown {
	public:
		/// <summary>Create an IFW1FontWrapper object with default settings.</summary>
		/// <returns>Standard HRESULT error code.</returns>
		/// <remarks></remarks>
		/// <param name="pDevice">The ID3D11Device the font-wrapper will be used with.</param>
		/// <param name="pszFontFamily">The default font-family to use when drawing strings.
		/// Valid values include for example L"Arial" and L"Courier New", provided that the fonts are installed on the system.
		/// Font-fallback will automatically choose a different font if the specified one is not available.</param>
		/// <param name="ppFontWrapper">Address of a pointer to a font-wrapper (See IFW1FontWrapper).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			__in ID3D11Device *pDevice,
			__in LPCWSTR pszFontFamily,
			__out IFW1FontWrapper **ppFontWrapper
		) = 0;
		
		/// <summary>Create an IFW1FontWrapper object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the font-wrapper will be used with.</param>
		/// <param name="pCreateParams">Pointer to an FW1_FONTWRAPPERCREATEPARAMS structure that describes the settings for the new font-wrapper.</param>
		/// <param name="ppFontWrapper">Address of a pointer to a font-wrapper (See IFW1FontWrapper).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			__in ID3D11Device *pDevice,
			__in IDWriteFactory *pDWriteFactory,
			__in const FW1_FONTWRAPPERCREATEPARAMS *pCreateParams,
			__out IFW1FontWrapper **ppFontWrapper
		) = 0;
		
		/// <summary>Create an IFW1FontWrapper object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the font-wrapper will be used with.</param>
		/// <param name="pGlyphAtlas">An IFW1GlyphAtlas that glyph-images will be stored in.</param>
		/// <param name="pGlyphProvider">An IFW1GlyphProvider that handles fonts and glyphmaps.</param>
		/// <param name="pGlyphVertexDrawer">An IFW1GlyphVertexDrawer that handles drawing glyph-vertices.</param>
		/// <param name="pGlyphRenderStates">An IFW1GlyphRenderStates that handles all needed context states when drawing glyphs.</param>
		/// <param name="pDWriteFactory">An IDWriteFactory that is used to create render-targets to draw glyphs with.</param>
		/// <param name="pDefaultFontParams">Pointer to an FW1_DWRITEFONTPARAMS that describes the default font.
		/// Can be NULL if only drawing preconstructed DirectWrite text layouts.</param>
		/// <param name="ppFontWrapper">Address of a pointer to a font-wrapper (See IFW1FontWrapper).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			__in ID3D11Device *pDevice,
			__in IFW1GlyphAtlas *pGlyphAtlas,
			__in IFW1GlyphProvider *pGlyphProvider,
			__in IFW1GlyphVertexDrawer *pGlyphVertexDrawer,
			__in IFW1GlyphRenderStates *pGlyphRenderStates,
			__in IDWriteFactory *pDWriteFactory,
			__in const FW1_DWRITEFONTPARAMS *pDefaultFontParams,
			__out IFW1FontWrapper **ppFontWrapper
		) = 0;
		
		/// <summary>Create an IFW1GlyphVertexDrawer object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the vertex drawer will be used with.</param>
		/// <param name="VertexBufferSize">The size in bytes of the dynamic vertex buffer. An index buffer will be created with a matching size.</param>
		/// <param name="ppGlyphVertexDrawer">Address of a pointer to a glyph-vertex drawer (See IFW1GlyphVertexDrawer).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphVertexDrawer(
			__in ID3D11Device *pDevice,
			__in UINT VertexBufferSize,
			__out IFW1GlyphVertexDrawer **ppGlyphVertexDrawer
		) = 0;
		
		/// <summary>Create an IFW1GlyphRenderStates object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the render-states will be used with.</param>
		/// <param name="DisableGeometryShader">If TRUE, no geometry shader will be created.</param>
		/// <param name="AnisotropicFiltering">If TRUE, a sampler state enabling anisotropic filtering will be created.</param>
		/// <param name="ppGlyphRenderStates">Address of a pointer to a glyph render-states object (See IFW1GlyphRenderStates).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphRenderStates(
			__in ID3D11Device *pDevice,
			__in BOOL DisableGeometryShader,
			__in BOOL AnisotropicFiltering,
			__out IFW1GlyphRenderStates **ppGlyphRenderStates
		) = 0;
		
		/// <summary>Create an IFW1TextRenderer object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pGlyphProvider">The IFW1GlyphProvider that provides glyph-information for the text-renderer.</param>
		/// <param name="ppTextRenderer">Address of a pointer to a IFW1TextRenderer.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateTextRenderer(
			__in IFW1GlyphProvider *pGlyphProvider,
			__out IFW1TextRenderer **ppTextRenderer
		) = 0;
		
		/// <summary>Create an IFW1TextGeometry object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppTextGeometry">Address of a pointer to an IFW1TextGeometry.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateTextGeometry(
			__out IFW1TextGeometry **ppTextGeometry
		) = 0;
		
		/// <summary>Create an IFW1GlyphProvider object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pGlyphAtlas">A glyph atlas to store glyph images in.</param>
		/// <param name="pDWriteFactory">A DirectWrite factory, used to create glyph render targets.</param>
		/// <param name="pFontCollection">A font collection used to identify fonts from DirectWrite font-face objects.</param>
		/// <param name="MaxGlyphWidth">The maximum width of a single glyph.</param>
		/// <param name="MaxGlyphHeight">The maximum height of a single glyph.</param>
		/// <param name="ppGlyphProvider">Address of a pointer to an IFW1GlyphProvider.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphProvider(
			__in IFW1GlyphAtlas *pGlyphAtlas,
			__in IDWriteFactory *pDWriteFactory,
			__in IDWriteFontCollection *pFontCollection,
			__in UINT MaxGlyphWidth,
			__in UINT MaxGlyphHeight,
			__out IFW1GlyphProvider **ppGlyphProvider
		) = 0;
		
		/// <summary>Create an IFW1DWriteRenderTarget object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDWriteFactory">A DirectWrite factory used to create the internal render target.</param>
		/// <param name="RenderTargetWidth">The width of the render target.</param>
		/// <param name="RenderTargetHeight">The height of the render target.</param>
		/// <param name="ppRenderTarget">Address of a pointer to an IFW1DWriteRenderTarget.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateDWriteRenderTarget(
			__in IDWriteFactory *pDWriteFactory,
			__in UINT RenderTargetWidth,
			__in UINT RenderTargetHeight,
			__out IFW1DWriteRenderTarget **ppRenderTarget
		) = 0;
		
		/// <summary>Create an IFW1GlyphAtlas object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">A D3D11 device used to create device resources.</param>
		/// <param name="GlyphSheetWidth">Width of the atlas textures.</param>
		/// <param name="GlyphSheetHeight">Height of the atlas textures.</param>
		/// <param name="HardwareCoordBuffer">If TRUE, create a D3D11 buffer with glyph coordinates for each sheet, for use with the geometry shader.</param>
		/// <param name="AllowOversizedGlyph">If FALSE, glyphs that are larger than the atlas textures will be rejected instead of partially inserted.</param>
		/// <param name="MaxGlyphCountPerSheet">The maximum number of glyphs in a single sheet texture.</param>
		/// <param name="MipLevels">The number of mip levels for the textures.</param>
		/// <param name="MaxGlyphSheetCount">The maximum number of sheet textures.</param>
		/// <param name="ppGlyphAtlas">Address of a pointer to an IFW1GlyphAtlas.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphAtlas(
			__in ID3D11Device *pDevice,
			__in UINT GlyphSheetWidth,
			__in UINT GlyphSheetHeight,
			__in BOOL HardwareCoordBuffer,
			__in BOOL AllowOversizedGlyph,
			__in UINT MaxGlyphCountPerSheet,
			__in UINT MipLevels,
			__in UINT MaxGlyphSheetCount,
			__out IFW1GlyphAtlas **ppGlyphAtlas
		) = 0;
		
		/// <summary>Create an IFW1GlyphSheet object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">A D3D11 device used to create device resources.</param>
		/// <param name="GlyphSheetWidth">Width of the sheet texture.</param>
		/// <param name="GlyphSheetHeight">Height of the sheet texture.</param>
		/// <param name="HardwareCoordBuffer">If TRUE, create a D3D11 buffer with glyph coordinates, for use with the geometry shader.</param>
		/// <param name="AllowOversizedGlyph">If FALSE, glyphs that are larger than the sheet texture will be rejected instead of partially inserted.</param>
		/// <param name="MaxGlyphCount">The maximum number of glyphs in the sheet.</param>
		/// <param name="MipLevels">The number of mip levels for the texture.</param>
		/// <param name="ppGlyphSheet">Address of a pointer to an IFW1GlyphSheet.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphSheet(
			__in ID3D11Device *pDevice,
			__in UINT GlyphSheetWidth,
			__in UINT GlyphSheetHeight,
			__in BOOL HardwareCoordBuffer,
			__in BOOL AllowOversizedGlyph,
			__in UINT MaxGlyphCount,
			__in UINT MipLevels,
			__out IFW1GlyphSheet **ppGlyphSheet
		) = 0;
		
		/// <summary>Create an IFW1ColorRGBA object.</summary>
		/// <remarks>An IFW1ColorRGBA can be set as the drawing effect for a range in a DirectWrite text layout to override the default color.</remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="Color">The initial color, as 0xAaBbGgRr.</param>
		/// <param name="ppColor">Address of a pointer to an IFW1ColorRGBA.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateColor(
			__in UINT32 Color,
			__out IFW1ColorRGBA **ppColor
		) = 0;
};

#ifdef FW1_COMPILETODLL
	extern "C" __declspec(dllexport) HRESULT STDMETHODCALLTYPE FW1CreateFactory(
		__in UINT32 Version,
		__out IFW1Factory **ppFactory
	);
#else
	/// <summary>The FW1CreateFactory method creates an IFWFactory object, that can subsequently be used to create any and all FW1 objects.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="Version">Set to FW1_VERSION. Is used to make sure the header matches the library version.</param>
	/// <param name="ppFactory">Address of a pointer to an IFW1Factory.</param>
	extern "C" HRESULT STDMETHODCALLTYPE FW1CreateFactory(
		__in UINT32 Version,
		__out IFW1Factory **ppFactory
	);
#endif

typedef HRESULT (STDMETHODCALLTYPE * PFN_FW1CREATEFACTORY) (UINT32 Version, IFW1Factory **ppFactory);


#endif// IncludeGuard__FW1_FW1FontWrapper_h

```

`MinHook/include/MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a Hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget    [in]  A pointer to the target function, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    //   ppTarget   [out] A pointer to the target function, which will be used
    //                    with other functions.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif


```

`PUBG_Internal.cpp`:

```cpp
// PUBG_Internal.cpp : Defines the exported functions for the DLL application.
//

#include "stdafx.h"



```

`README.md`:

```md
# PUBG_Internal
Internal cheat for PUBG. Very old but has come useful code in there still.

```

`dllmain.cpp`:

```cpp
#include "stdafx.h"
#include <Windows.h>
#include <stdio.h>
#include <fstream>
#include <stdlib.h>
#include <d3d11.h>
#include <d3d9.h>
#include <d3dx9.h>
#include <D3DX11.h>
#include <dxgi.h>
#include <time.h>
#define _USE_MATH_DEFINES
#include <math.h>
#include <cmath>
#include <vector>
#include <d3dcompiler.h>
#include "MinHook\include\MinHook.h"
#include "FW1FontWrapper\FW1FontWrapper.h"
#include "\Users\Kurt\Downloads\D3D11Renderer_[unknowncheats.me]_\D3D11Renderer.h"

#pragma comment(lib, "libMinHook-x64-v141-mtd.lib")
#pragma comment(lib, "FW1FontWrapper.lib")
#pragma comment(lib, "d3dcompiler.lib")
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "d3dx11.lib")

#define FUNC_FINDER_ADDR		0x836F20

ID3D11DeviceContext *pContext = NULL;
IFW1FontWrapper *pFontWrapper = NULL;

char dlldir[320];
char *GetDirectoryFile(char *filename)
{
	static char path[320];
	strcpy_s(path, dlldir);
	strcat_s(path, filename);
	return path;
}
void Log(const char *fmt, ...)
{
	if (!fmt)	return;

	char		text[4096];
	va_list		ap;
	va_start(ap, fmt);
	vsprintf_s(text, fmt, ap);
	va_end(ap);

	std::ofstream logfile(GetDirectoryFile("log.txt"), std::ios::app);
	if (logfile.is_open() && text)	logfile << text << std::endl;
	logfile.close();
}

DWORD_PTR dwGetBaseAddress()
{
	return (DWORD_PTR)GetModuleHandle(NULL);
}

#pragma region PUBG_Funcs

namespace globals
{
	char *espBoxTypeStr[3] = { "2D Box", "3D Box", "2D Filled Box" };
	char *espEnableStr[3] = { "Off", "On" };
	bool bPlayerESP, bSnapLines, bDrawNames, bDrawDistance, bDrawHealth;
	bool bItemESP;
	bool bDebugESP;
	int g_espBoxStyle = 0;
	float g_espDrawDistance;

	int ActorIDs[4];
	int ErangelMainID;
	int DroppedItemGroupID;
	int DroppedItemInteractionComponentID;
	int DroppedItemID;
}

class ULevel;
class UGameInstance;
class ULocalPlayer;
class UGameViewportClient;
class APlayerController;
class UPlayer;
struct FString;
class AActor;

bool GetGName(int id, char *outname)
{
	DWORD_PTR modBase = (DWORD_PTR)GetModuleHandle(NULL);
	DWORD_PTR GNames = *(DWORD_PTR*)(modBase + 0x36D8590);
	if (!GNames)
		return false;
	DWORD_PTR chunk = *(DWORD_PTR*)(GNames + (id / 0x4000) * 8);
	if (!chunk)
		return false;
	DWORD_PTR nameptr = *(DWORD_PTR*)(chunk + (8 * (id % 0x4000)));
	if (!nameptr)
		return false;

	int str_len = 0;
	while (true)
	{
		char c = *(char*)(nameptr + 0x10 + str_len);
		if (c == 0x0)
			break;
		str_len++;
		if (str_len > 150)
			return false;
	}
	memcpy(outname, (LPVOID)(nameptr + 0x10), str_len);
	//memset(&outname[str_len], 0, 4);
	return true;
}

char *GetGNameAddr(DWORD_PTR addr)
{
	char outname[64] = {};
	GetGName(*(DWORD*)(addr + 0x18), outname);
	return outname;
}

template <class T>
struct TArray
{
public:
	inline TArray()
	{
		Data = nullptr;
	};

	inline T& operator[](int i)
	{
		return Data[i];
	};

	inline int Count()
	{
		return count;
	}

	inline const T& operator[](int i) const
	{
		return Data[i];
	};
private:
	T* Data;
	int count;
	int max;
};

struct FString
{
public:

	inline wchar_t *GetWideString()
	{
		return this->str;
	}

	inline char *GetString()
	{
		char mbs[256] = {};
		wcstombs(mbs, this->str, this->count);
		return mbs;
	}

private:
	wchar_t *str;
	int count;
	int max;
};

class Vector3
{
public:
	float x;
	float y;
	float z;

	Vector3()
	{
		x = y = z = 0;
	}

	Vector3(float x, float y, float z)
	{
		this->x = x;
		this->y = y;
		this->z = z;
	}

	float Dot(const Vector3 &vec)
	{
		return this->x * vec.x + this->y * vec.y + this->z * vec.z;
	}

	float Length()
	{
		return (float)sqrt(this->x * this->x + this->y * this->y + this->z * this->z);
	}

	Vector3 operator-(const Vector3 &vec)
	{
		return Vector3(this->x - vec.x, this->y - vec.y, this->z - vec.z);
	}
	Vector3 operator+(const Vector3 &vec)
	{
		return Vector3(this->x + vec.x, this->y + vec.y, this->z + vec.z);
	}
};

void AngleVectors(Vector3 angles, Vector3 *forward)
{
	float sp, sy, cp, cy;
	float angle;

	angle = angles.y * (M_PI / 180.0f);
	sy = sin(angle);
	cy = cos(angle);
	angle = angles.x * (M_PI / 180.0f);
	sp = sin(angle);
	cp = cos(angle);

	forward->x = cp * cy;
	forward->y = cp * sy;
	forward->z = -sp;
}

class UWorld
{
public:
	char              _0x0000[0x30];
	ULevel*           pLevel; //0x30
	char              _0x0038[0x108];
	UGameInstance*    pOwningGameInstance; //0x140
};

class ULevel
{
public:
	unsigned char				_0x0000[0xA0]; //0x00
	TArray<AActor*>		entityList; //0xA0
};

class UGameInstance
{
public:
	char					_0x0000[0x38];
	TArray<ULocalPlayer*>	LocalPlayers;
};

class ULocalPlayer
{
public:
	char                        _0x0000[0x30];
	APlayerController*    PlayerController; //0x30
	char                          _0x0038[0x20];
	UGameViewportClient*    ViewportClient; //0x58
};

class UGameViewportClient
{
public:
	char                    _0x0000[0x80];
	UWorld*           World; //0x80
	UGameInstance*    GameInstance; //0x88
};

struct FMinimalViewInfo
{
	Vector3                                     Location;                                                 // 0x0000(0x000C) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	Vector3                                     Rotation;                                                 // 0x000C(0x000C) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	float                                              FOV;                                                      // 0x0018(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	float                                              OrthoWidth;                                               // 0x001C(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	float                                              OrthoNearClipPlane;                                       // 0x0020(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	float                                              OrthoFarClipPlane;                                        // 0x0024(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	float                                              AspectRatio;                                              // 0x0028(0x0004) (CPF_Edit, CPF_BlueprintVisible, CPF_ZeroConstructor, CPF_IsPlainOldData)
	unsigned char                                      bConstrainAspectRatio;                               // 0x002C(0x0001) (CPF_Edit, CPF_BlueprintVisible)
	unsigned char                                      bUseFieldOfViewForLOD;
};

struct FCameraCacheEntry
{
	char							_0x0000[0x10];
	FMinimalViewInfo			POV;
};

class APlayerCameraManager
{
public:
	char                        _0x0000[0x3B8];
	float                       DefaultFOV; //0x3B8
	char                        _0x03BC[0x4];
	float                       DefaultOrthoWidth; //0x3C0
	char                        _0x03C4[0x4];
	float                       DefaultAspectRatio; //0x3C8
	char                        _0x03CC[0x44];
	FCameraCacheEntry    CameraCache; //0x410
};

struct FScriptMulticastDelegate
{
	char UnknownData[16];
};

class USceneComponent
{
public:
	char		_0x0000[0x1E0];
	Vector3		RelativeLocation; //0x1E0
	Vector3		RelativeRotation; //0x1EC
	char		_0x01F8[0x60];
	Vector3		ComponentVelocity; //0x258
};

class APawn
{

};
class AMatineeActor
{

};
class FName
{

};
class UActorComponent
{

};

class APlayerState
{
public:
	char       _0x0000[0x3A8];
	FString    PlayerName; //0x3A8
};

struct pADroppedItemArray
{
	DWORD_PTR		pActor; //0x0
	unsigned char	_0x0008[0x8]; //0x8
};

class AActor
{
public:
	char                _0x0000[0x18];
	int                 id; //0x18
	char                _0x001C[0x164];
	USceneComponent*    RootComponent; //0x180
	char                _0x0188[0x150];
	TArray<pADroppedItemArray>           DroppedItemArray; //0x2D8
	char                _0x02E8[0xD8];
	APlayerState*       PlayerState; //0x3C0
	char				_0x03C8[0xCA0];
	float				health; //0x1068
	float				healthMax; //0x106C

	bool IsAlive()
	{
		return this->health > 0 && this->health <= 100.0f;
	}

	bool IsPlayer()
	{
		return this->id == globals::ActorIDs[0] || this->id == globals::ActorIDs[1] || this->id == globals::ActorIDs[2] || this->id == globals::ActorIDs[3];
	}

	bool IsDroppedItem()
	{
		return this->id == globals::DroppedItemID;
	}

	bool IsDroppedItemGroup()
	{
		return this->id == globals::DroppedItemGroupID;
	}

	bool IsDroppedItemInteractionComponent()
	{
		return this->id == globals::DroppedItemInteractionComponentID;
	}

	int K2_TeleportTo(Vector3, Vector3);
	void DisableInput(APlayerController *PlayerController);
	void EnableInput(APlayerController *PlayerController);
};

int AActor::K2_TeleportTo(Vector3 loc, Vector3 rot)
{
	auto result = (*(int(__fastcall**)(AActor*, Vector3*, Vector3*))(*(DWORD64*)this + 0x470))(this, &loc, &rot);
	return result;
}

void AActor::DisableInput(APlayerController * PlayerController)
{
	(*(int(__fastcall**)(AActor*, APlayerController*))(*(DWORD64*)this + 0x270))(this, PlayerController);
}

void AActor::EnableInput(APlayerController * PlayerController)
{
	(*(int(__fastcall**)(AActor*, APlayerController*))(*(DWORD64*)this + 0x268))(this, PlayerController);
}

class APlayerController
{
public:
	char						_0x0000[0x3A8];
	AActor*						Actor; //0x3A8
	char						_0x03B0[0x58];
	ULocalPlayer*				LocalPlayer; //0x408
	char                     _0x0410[0x28];
	APlayerCameraManager*		PlayerCameraManager; //0x438
	char                        _0x0440[0xC];
	Vector3                     TargetViewRotation; //0x44C

	bool IsVisible(AActor *target);
};

bool APlayerController::IsVisible(AActor *target)
{
	Vector3 fillVec = Vector3(0, 0, 0);
	auto result = (*(int(__fastcall**)(APlayerController*, AActor*, Vector3*, bool))(*(DWORD64*)this + 0x620))(this, target, &fillVec, false);
	return result;
}

D3DXMATRIX Matrix(Vector3 rot, Vector3 origin = Vector3(0, 0, 0))
{

	float radPitch = (float)(rot.x * M_PI / 180.f);
	float radYaw = (float)(rot.y  * M_PI / 180.f);
	float radRoll = (float)(rot.z * M_PI / 180.f);

	float SP = (float)sin(radPitch);
	float CP = (float)cos(radPitch);
	float SY = (float)sin(radYaw);
	float CY = (float)cos(radYaw);
	float SR = (float)sin(radRoll);
	float CR = (float)cos(radRoll);
	D3DXMATRIX matrix;
	matrix.m[0][0] = CP * CY;
	matrix.m[0][1] = CP * SY;
	matrix.m[0][2] = SP;
	matrix.m[0][3] = 0.f;
	matrix.m[1][0] = SR * SP * CY - CR * SY;
	matrix.m[1][1] = SR * SP * SY + CR * CY;
	matrix.m[1][2] = -SR * CP;
	matrix.m[1][3] = 0.f;
	matrix.m[2][0] = -(CR * SP * CY + SR * SY);
	matrix.m[2][1] = CY * SR - CR * SP * SY;
	matrix.m[2][2] = CR * CP;
	matrix.m[2][3] = 0.f;
	matrix.m[3][0] = origin.x;
	matrix.m[3][1] = origin.y;
	matrix.m[3][2] = origin.z;
	matrix.m[3][3] = 1.f;
	return matrix;
}

bool WorldToScreen(Vector3 worldLoc, APlayerCameraManager *cameraManager, Vector3 &screenLoc)
{
	screenLoc = Vector3(0, 0, 0);

	auto POV = cameraManager->CameraCache.POV;
	Vector3 rotation = POV.Rotation;

	D3DXMATRIX tempMatrix = Matrix(rotation);
	Vector3 vAxisX, vAxisY, vAxisZ;
	vAxisX = Vector3(tempMatrix.m[0][0], tempMatrix.m[0][1], tempMatrix.m[0][2]);
	vAxisY = Vector3(tempMatrix.m[1][0], tempMatrix.m[1][1], tempMatrix.m[1][2]);
	vAxisZ = Vector3(tempMatrix.m[2][0], tempMatrix.m[2][1], tempMatrix.m[2][2]);

	Vector3 vDelta = worldLoc - POV.Location;
	Vector3 vTransformed = Vector3(vDelta.Dot(vAxisY), vDelta.Dot(vAxisZ), vDelta.Dot(vAxisX));

	if (vTransformed.z < 1.0f)
		vTransformed.z = 1.0f;

	float fovAngle = POV.FOV;
	float screenCenterX = 1920 / 2;
	float screenCenterY = 1080 / 2;

	screenLoc.x = screenCenterX + vTransformed.x * (screenCenterX / (float)tan(fovAngle * M_PI / 360)) / vTransformed.z;
	screenLoc.y = screenCenterY - vTransformed.y * (screenCenterX / (float)tan(fovAngle * M_PI / 360)) / vTransformed.z;

	return true;
}

char *itemEspWeapons[] = { "AKM", "Kar98k", "M16A4", "M416", "SCAR-L", "SKS", "Micro UZI", "12 Gauge", "P1911", "Pan", "P92", "S1897", "Crossbow" };
char *itemEspAttachments[] = { "Extended Mag (AR, S12K)", "Compensator(AR, S12K)", "Ext.QuickDraw Mag(AR, S12K)", "Suppressor(AR, S12K)", "Suppressor (Sniper Rifle)", "Compensator (Sniper Rifle)", "Ext. QuickDraw Mag (M24, AWM, SKS)", "Angled Foregrip (M416, SCAR-L, UMP9)", "Vertical Foregrip (M416, SCAR-L, UMP9, Vector)", "2x Scope", "4x Scope", "8x Scope", "Red Dot Sight", "Cheek Pad (Sniper Rifle)" };
char *itemEspEquipment[] = { "Backpack (Lv. 1)", "Backpack (Lv. 2)", "Backpack (Lv. 3)", "Helmet (Lv. 1)", "Helmet (Lv. 2)", "Helmet (Lv. 3)", "Police Vest (Lv. 1)", "Police Vest (Lv. 2)", "Police Vest (Lv. 3)" };
char *itemEspMedic[] = { "First Aid Kit", "Painkiller", "Energy Drink" };


bool DoesStrArrayContain(char **array, char *str)
{
	int count = sizeof(array) / sizeof(char*);
	for (int i = 0; i < count; i++)
	{
		if (!strcmp(array[i], str))
			return true;
	}
	return false;
}

#define DRAW_STRING_MAX 50
int drawStringCount = 0;
void DrawString(char *text, float size, float x, float y, Color color)
{
	if (drawStringCount < DRAW_STRING_MAX)
	{
		wchar_t wstr[256] = {};
		mbstowcs(wstr, text, 256);
		int abgr = (color.A << 24) | (color.B << 16) | (color.G << 8) | (color.R);
		pFontWrapper->DrawString(pContext, wstr, size, x, y, abgr, FW1_RESTORESTATE);
		drawStringCount++;
	}
}

void DrawString(wchar_t *text, float size, float x, float y, Color color)
{
	if (drawStringCount < DRAW_STRING_MAX)
	{
		int abgr = (color.A << 24) | (color.B << 16) | (color.G << 8) | (color.R);
		pFontWrapper->DrawString(pContext, text, size, x, y, abgr, FW1_RESTORESTATE);
		drawStringCount++;
	}
}

void DrawStringFmt(float size, float x, float y, Color color, char *fmt, ...)
{
	char text[4096] = {};
	va_list ap;
	va_start(ap, fmt);
	vsprintf_s(text, fmt, ap);
	va_end(ap);
	DrawString(text, size, x, y, color);
}

typedef struct _PUBG_ADDR
{
	DWORD_PTR			baseAddr;
	UWorld*				uWorld;
	UGameInstance*		uGameInstance;
	ULocalPlayer*		uLocalPlayer;
	UGameViewportClient* uViewportClient;
	UWorld*				pWorld;
	ULevel*				uLevel;
}PUBG_ADDR, *PPUBG_ADDR;

typedef struct _DEBUG_PRINT
{
	char str[64];
	int timeCreated;
	int timeToDelete;
}DEBUG_PRINT, *PDEBUG_PRINT;

PUBG_ADDR PUBG;
std::vector<DEBUG_PRINT> g_wcDebugPrint;

void DebugPrint(char *fmt, ...)
{
	char text[4096] = {};
	va_list ap;
	va_start(ap, fmt);
	vsprintf_s(text, fmt, ap);
	va_end(ap);
	DEBUG_PRINT debug;
	memcpy(debug.str, text, 64);
	debug.timeCreated = clock();
	debug.timeToDelete = clock() + 4000;
	g_wcDebugPrint.push_back(debug);
}

bool isPUBGThreadRunning = false;
DWORD __stdcall PUBGThread(LPVOID)
{
	isPUBGThreadRunning = true;
	DWORD_PTR base = dwGetBaseAddress();
	while (isPUBGThreadRunning)
	{
		
	}
	return 0;
}

#pragma endregion

#pragma region D3D11_HOOK

typedef HRESULT(__stdcall *D3D11PresentHook) (IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags);
typedef void(__stdcall *D3D11DrawIndexedHook) (ID3D11DeviceContext* pContext, UINT IndexCount, UINT StartIndexLocation, INT BaseVertexLocation);
typedef void(__stdcall *D3D11CreateQueryHook) (ID3D11Device* pDevice, const D3D11_QUERY_DESC *pQueryDesc, ID3D11Query **ppQuery);
#define CUSTOMFVF (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)
D3D11PresentHook phookD3D11Present = NULL;
D3D11DrawIndexedHook phookD3D11DrawIndexed = NULL;
D3D11CreateQueryHook phookD3D11CreateQuery = NULL;
ID3D11Device *pDevice = NULL;
IDXGISwapChain *g_pSwapChain;
DWORD_PTR* pSwapChainVtable = NULL;
DWORD_PTR* pContextVTable = NULL;
DWORD_PTR* pDeviceVTable = NULL;
ID3D11RasterizerState * rwState;
ID3D11RasterizerState * rsState;
ID3D11Texture2D* RenderTargetTexture;
ID3D11RenderTargetView* RenderTargetView = NULL;
ID3D11PixelShader* psRed = NULL;
ID3D11PixelShader* psOrange = NULL;
ID3D11PixelShader* psBlue = NULL;
IFW1Factory *pFW1Factory = NULL;
ID3D11Buffer *veBuffer;
UINT Stride = 0;
UINT veBufferOffset = 0;
D3D11_BUFFER_DESC vedesc;
ID3D11Buffer *inBuffer;
DXGI_FORMAT inFormat;
UINT        inOffset;
D3D11_BUFFER_DESC indesc;

D3D11Renderer *renderer;

enum eDepthState
{
	ENABLED,
	DISABLED,
	READ_NO_WRITE,
	NO_READ_NO_WRITE,
	_DEPTH_COUNT
};

ID3D11DepthStencilState* myDepthStencilStates[static_cast<int>(eDepthState::_DEPTH_COUNT)];

void SetDepthStencilState(eDepthState aState)
{
	pContext->OMSetDepthStencilState(myDepthStencilStates[aState], 1);
}

HRESULT GenerateShader(ID3D11Device* pD3DDevice, ID3D11PixelShader** pShader, float r, float g, float b)
{
	char szCast[] = "struct VS_OUT"
		"{"
		" float4 Position : SV_Position;"
		" float4 Color : COLOR0;"
		"};"

		"float4 main( VS_OUT input ) : SV_Target"
		"{"
		" float4 fake;"
		" fake.a = 0.3f;"
		" fake.r = %f;"
		" fake.g = %f;"
		" fake.b = %f;"
		" return fake;"
		"}";
	ID3D10Blob* pBlob;
	char szPixelShader[1000];
	sprintf_s(szPixelShader, szCast, r, g, b);
	ID3DBlob* d3dErrorMsgBlob;
	HRESULT hr = D3DCompile(szPixelShader, sizeof(szPixelShader), "shader", NULL, NULL, "main", "ps_4_0", NULL, NULL, &pBlob, &d3dErrorMsgBlob);
	if (FAILED(hr))
		return hr;
	hr = pD3DDevice->CreatePixelShader((DWORD*)pBlob->GetBufferPointer(), pBlob->GetBufferSize(), NULL, pShader);
	if (FAILED(hr))
		return hr;
	return S_OK;
}

namespace MenuGUI
{
	const float BUTTON_HEIGHT = 20.0f;

	Color accentColor = Color(255, 92, 145, 188);
	Color background = Color(230, 30, 30, 30);
	Color lightBG = Color(255, 80, 80, 80);

	int g_sliderIndex, g_comboBoxIndex;
	float menuX = 50.0f, menuY = 50.0f, menuW = 0, menuH = 0;
	int clickTimer;
	bool isMovingMenu;
	int moveOffset[2];
	bool isUsingElement;
	bool isAComboBoxInUse;

	void GUISetupMenu(float w, float h)
	{
		g_sliderIndex = 0;
		g_comboBoxIndex = 0;
		menuW = w;
		menuH = h;
	}

	bool isInBounds(POINT point, float x, float y, float w, float h)
	{
		if (point.x > x && point.x < x + w && point.y > y && point.y < y + h)
			return true;
		return false;
	}

	bool leftMouseDown()
	{
		return GetAsyncKeyState(VK_LBUTTON) & 0x8000;
	}

	void GUIBackground()
	{
		POINT point;
		GetCursorPos(&point);
		if (isInBounds(point, menuX, menuY - 20.0f, menuW, 20.0f))
		{
			if (!isMovingMenu)
			{
				moveOffset[0] = point.x - menuX;
				moveOffset[1] = point.y - (menuY - 20.0f);
				isMovingMenu = true;
			}
		}
		if (isMovingMenu)
		{
			if (leftMouseDown())
			{
				menuX = point.x - moveOffset[0];
				menuY = point.y + 20 - moveOffset[1];
			}
			else
			{
				isMovingMenu = false;
			}
		}
		renderer->FillRect(menuX, menuY - 20.0f, menuW, 20.0f, accentColor);
		renderer->FillRect(menuX, menuY - 20.0f, 20.0f, 20.0f, Color(255, 255, 0, 0));
		renderer->FillRect(menuX, menuY, menuW, menuH, background);
	}

	void GUIText(float x, float y, float size, char *text)
	{
		float realX = menuX + x;
		float realY = menuY + y;
		DrawString(text, size, realX, realY, Color(255, 255, 255, 255));
	}

	bool GUIButton(float x, float y, char *text)
	{
		float realX = menuX + x;
		float realY = menuY + y;
		float width = (strlen(text) * 7.45f) + 5.0f;
		POINT point;
		GetCursorPos(&point);
		if (!isAComboBoxInUse)
		{
			if (isInBounds(point, realX, realY, width, BUTTON_HEIGHT))
			{
				Color downColor = accentColor;
				downColor.A = 90;
				renderer->FillRect(realX, realY, width, BUTTON_HEIGHT, downColor);
				DrawString(text, 13, realX + 2.5f, realY + 1, Color(255, 255, 255, 255));
				if (leftMouseDown())
				{
					if (clock() > clickTimer)
					{
						clickTimer = clock() + 200;
						return true;
					}
				}
				return false;
			}
		}
		renderer->FillRect(realX, realY, width, BUTTON_HEIGHT, accentColor);
		DrawString(text, 13, realX + 2.5f, realY + 1, Color(255, 255, 255, 255));
		return false;
	}

	bool GUICheckBox(float x, float y, char *text, bool toggle)
	{
		float realX = menuX + x;
		float realY = menuY + y;
		POINT point;
		GetCursorPos(&point);

		renderer->FillRect(realX, realY, 17, 17, lightBG);
		DrawString(text, 13, realX + 22, realY - 1, Color(255, 255, 255, 255));
		if (toggle)
		{
			Color togOn = accentColor;
			togOn.A = 255;
			renderer->FillRect(realX + 3, realY + 3, 11, 11, togOn);
		}
		if (!isAComboBoxInUse)
		{
			float width = (strlen(text) * 7.45f) + 17;
			if (isInBounds(point, realX, realY, width, 17))
			{
				if (leftMouseDown())
				{
					if (clock() > clickTimer)
					{
						clickTimer = clock() + 200;
						return true;
					}
				}
			}
		}
		return false;
	}

	const float SLIDER_HEIGHT = 20.0f;
	bool movingSlider[10];
	int sliderValue[10];
	int sliderRealValue[10];
	float sliderX[10];
	int GUISlider(float x, float y, float w, int max)
	{
		float realX = menuX + x;
		float realY = menuY + y;
		sliderX[g_sliderIndex] = realX + sliderValue[g_sliderIndex];

		//background
		renderer->FillRect(realX, realY, w, SLIDER_HEIGHT, lightBG);
		//slider
		renderer->FillRect(realX, realY, sliderX[g_sliderIndex] - realX, SLIDER_HEIGHT, Color(255, accentColor.R, accentColor.G, accentColor.B));
		//border
		renderer->DrawBorderBox(realX, realY, w, SLIDER_HEIGHT, Color(255, 255, 255, 255));

		//real value
		char strValue[26] = {};
		sprintf_s(strValue, "%i", sliderRealValue[g_sliderIndex]);
		float strValueWidth = (strlen(strValue) * 7.45f);
		DrawString(strValue, 13, realX + (w / 2) - (strValueWidth / 2) + (7.45f / 2), realY + 1, Color(255, 255, 255, 255));

		if (!isAComboBoxInUse)
		{
			POINT point;
			GetCursorPos(&point);
			if (isInBounds(point, realX, realY, w, SLIDER_HEIGHT))
			{
				if (!movingSlider[g_sliderIndex])
				{
					if (leftMouseDown())
					{
						movingSlider[g_sliderIndex] = true;
					}
				}
			}
			if (movingSlider[g_sliderIndex])
			{
				if (leftMouseDown())
				{
					sliderValue[g_sliderIndex] = point.x - realX;
					if (sliderValue[g_sliderIndex] <= 0)
						sliderValue[g_sliderIndex] = 0;
					if (sliderValue[g_sliderIndex] >= w)
						sliderValue[g_sliderIndex] = w;

					sliderX[g_sliderIndex] = realX + sliderValue[g_sliderIndex];
					float testValue = ((float)sliderValue[g_sliderIndex] * ((float)max / (float)w));
					sliderRealValue[g_sliderIndex] = (int)ceil(testValue);
				}
				else
				{
					movingSlider[g_sliderIndex] = false;
				}
			}
			g_sliderIndex++;
		}
		return sliderRealValue[g_sliderIndex - 1];
	}

	void GUIGroupBox(float x, float y, float w, float h, char *text)
	{
		float realX = menuX + x;
		float realY = menuY + y;
		float barWidth = 1.0f;
		float textWidth = (strlen(text) * 7.44f);
		//left bar
		renderer->FillRect(realX, realY, barWidth, h, Color(255, 255, 255, 255));
		//bottom bar
		renderer->FillRect(realX, realY + h, w, barWidth, Color(255, 255, 255 ,255));
		//right bar
		renderer->FillRect(realX + w, realY, barWidth, h, Color(255, 255, 255, 255));
		//top left bar
		renderer->FillRect(realX, realY, 13.0f, barWidth, Color(255, 255, 255, 255));
		//top right bar
		float gapWidth = 33.0f + textWidth;
		renderer->FillRect(realX + (gapWidth - 8), realY, w - (gapWidth - 8), barWidth, Color(255, 255, 255, 255));
		DrawString(text, 13, realX + 20.0f, realY - 8, Color(255, 255, 255, 255));
	}

	const float COMBOBOX_HEIGHT = 20.0f;
	bool isComboBoxOpen[10];
	int comboBoxSelectedItemIndex[10];
	int activeComboBoxIndex;

	int GUIComboBox(float x, float y, float w, char **items, int itemCount)
	{
		float realX = menuX + x;
		float realY = menuY + y;

		//background
		renderer->FillRect(realX, realY, w, COMBOBOX_HEIGHT, lightBG);
		if (!isComboBoxOpen[g_comboBoxIndex])
		{
			renderer->DrawBorderBox(realX, realY, w, COMBOBOX_HEIGHT, Color(255, 255, 255, 255));
			//item text
			DrawString(items[comboBoxSelectedItemIndex[g_comboBoxIndex]], 13, realX + 4, realY + 1, Color(255, 255, 255, 255));
		}

		POINT point;
		GetCursorPos(&point);
		if (!isAComboBoxInUse)
		{
			if (isInBounds(point, realX, realY, w, COMBOBOX_HEIGHT))
			{
				if (!isComboBoxOpen[g_comboBoxIndex])
				{
					if (leftMouseDown())
					{
						isAComboBoxInUse = true;
						isComboBoxOpen[g_comboBoxIndex] = true;
					}
				}
			}
		}
		if (isComboBoxOpen[g_comboBoxIndex])
		{
			char *currentItem = items[comboBoxSelectedItemIndex[g_comboBoxIndex]];
			for (int i = 0; i < itemCount; i++)
			{
				//if (strcmp(items[i], currentItem))
					renderer->FillRect(realX, realY + COMBOBOX_HEIGHT + (i * COMBOBOX_HEIGHT), w, COMBOBOX_HEIGHT, lightBG);
					//renderer->DrawBorderBox(realX, realY + COMBOBOX_HEIGHT + (i * COMBOBOX_HEIGHT), w, COMBOBOX_HEIGHT, Color(255, 255, 255, 255));
					DrawString(items[i], 13, realX + 4, realY + COMBOBOX_HEIGHT + (i * COMBOBOX_HEIGHT) + 1, Color(255, 255, 255, 255));
			}
			if (!isInBounds(point, realX, realY, w, COMBOBOX_HEIGHT + (COMBOBOX_HEIGHT * itemCount)))
			{
				if (leftMouseDown())
				{
					isAComboBoxInUse = false;
					isComboBoxOpen[g_comboBoxIndex] = false;
				}
			}
			else
			{
				//find what index you selected
				float itemBoxY = realY + COMBOBOX_HEIGHT;

				if (isInBounds(point, realX, itemBoxY, w, COMBOBOX_HEIGHT * itemCount))
				{
					if (leftMouseDown())
					{
						for (int i = 0; i < itemCount; i++)
						{
							float min = i * 20.0f;
							float max = (i + 1) * 20.0f;
							if (point.y > itemBoxY + min && point.y < itemBoxY + max)
							{
								comboBoxSelectedItemIndex[g_comboBoxIndex] = i;
								break;
							}
						}
						isAComboBoxInUse = false;
						isComboBoxOpen[g_comboBoxIndex] = false;
						g_comboBoxIndex++;
						return comboBoxSelectedItemIndex[g_comboBoxIndex - 1];
					}
				}
			}
		}
		g_comboBoxIndex++;
		return -1;
	}

	void GUIEndMenu()
	{

	}
}

void DrawPUBGModMenu()
{
	MenuGUI::GUISetupMenu(800.0f, 400.0f);
	MenuGUI::GUIBackground();

	//ESP OPTIONS
	MenuGUI::GUIGroupBox(20.0f, 20.0f, 300.0f, 350.0f, "ESP Settings");
	//PLAYER ESP
	if (MenuGUI::GUICheckBox(35.0f, 40.0f, "Player ESP", globals::bPlayerESP))
	{
		globals::bPlayerESP = !globals::bPlayerESP;
		DebugPrint("bPlayerESP: %s", globals::bPlayerESP ? "ON" : "OFF");
	}
	if (MenuGUI::GUICheckBox(35.0f, 65.0f, "Draw Names", globals::bDrawNames))
	{
		globals::bDrawNames = !globals::bDrawNames;
		DebugPrint("bDrawNames: %s", globals::bDrawNames ? "ON" : "OFF");
	}
	if (MenuGUI::GUICheckBox(35.0f, 90.0f, "Draw Distance", globals::bDrawDistance))
	{
		globals::bDrawDistance = !globals::bDrawDistance;
		DebugPrint("bDrawDistance: %s", globals::bDrawDistance ? "ON" : "OFF");
	}
	if (MenuGUI::GUICheckBox(35.0f, 115.0f, "Draw Health", globals::bDrawHealth))
	{
		globals::bDrawHealth = !globals::bDrawHealth;
		DebugPrint("bDrawHealth: %s", globals::bDrawHealth ? "ON" : "OFF");
	}
	if (MenuGUI::GUICheckBox(35.0f, 140.0f, "Snap Lines", globals::bSnapLines))
	{
		globals::bSnapLines = !globals::bSnapLines;
		DebugPrint("bSnapLines: %s", globals::bSnapLines ? "ON" : "OFF");
	}
	//ITEM ESP
	if (MenuGUI::GUICheckBox(170.0f, 40.0f, "Item ESP", globals::bItemESP))
	{
		globals::bItemESP = !globals::bItemESP;
		DebugPrint("bItemESP: %s", globals::bItemESP ? "ON" : "OFF");
	}
	if (MenuGUI::GUICheckBox(170.0f, 65.0f, "Debug ESP", globals::bDebugESP))
	{
		globals::bDebugESP = !globals::bDebugESP;
		DebugPrint("bDebugESP: %s", globals::bDebugESP ? "ON" : "OFF");
	}


	MenuGUI::GUIText(35.0f, 210.0f, 13, "Box Style");
	int tmpBoxStyle;
	if ((tmpBoxStyle = MenuGUI::GUIComboBox(35.0f, 230.0f, 150.0f, globals::espBoxTypeStr, 3)) != -1)
	{
		globals::g_espBoxStyle = tmpBoxStyle;
		DebugPrint("espBoxStyle: %i", globals::g_espBoxStyle);
	}
	if (MenuGUI::GUIButton(35.0f, 260.0f, "Test Button"))
	{
		/*AActor *localActor = ->LocalPlayers[0]->PlayerController->Actor;
		if (localActor && localActor->RootComponent)
		{
			std::vector<AActor*> tmpPlayers = g_vPlayerList;
			int size = tmpPlayers.size();
			for (int i = 0; i < size; i++)
			{
				AActor *actor = tmpPlayers[i];
				if (!actor || !actor->PlayerState || !actor->RootComponent || actor == localActor)
					continue;

				actor->K2_TeleportTo(localActor->RootComponent->RelativeLocation, Vector3(0, 0, 0));
			}
		}*/
		APlayerController *controller = PUBG.uLocalPlayer->PlayerController;
		AActor *localActor = controller->Actor;

		localActor->DisableInput(NULL);
	}

	MenuGUI::GUIText(35.0f, 165.0f, 13, "Draw Distance");
	globals::g_espDrawDistance = (float)MenuGUI::GUISlider(35.0f, 185.0f, 200.0f, 1000);
}

bool hasCachedGNames = false;
void CacheGNames()
{
	int actorCount = 0;
	for (int i = 0; i < 100000; i++)
	{
		char gname[256] = {};
		if (GetGName(i, gname))
		{
			if (!strcmp(gname, "PlayerMale_A") || !strcmp(gname, "PlayerMale_A_C") || !strcmp(gname, "PlayerFemale_A") || !strcmp(gname, "PlayerFemale_A_C"))
			{
				DebugPrint("Cached %s", gname);
				globals::ActorIDs[actorCount] = i;
				actorCount++;
			}
			if (!strcmp(gname, "Erangel_Main"))
			{
				DebugPrint("Cached %s", gname);
				globals::ErangelMainID = i;
			}
			if (!strcmp(gname, "DroppedItemInteractionComponent"))
			{
				DebugPrint("Cached %s", gname);
				globals::DroppedItemInteractionComponentID = i;
			}
			if (!strcmp(gname, "DroppedItemGroup"))
			{
				DebugPrint("Cached %s", gname);
				globals::DroppedItemGroupID = i;
			}
			if (!strcmp(gname, "DroppedItem"))
			{
				DebugPrint("Cached %s", gname);
				globals::DroppedItemID = i;
			}
		}
	}
}

bool IsInGame()
{
	DWORD id = *(DWORD*)((DWORD_PTR)PUBG.uWorld + 0x18);
	return id == globals::ErangelMainID;
}

bool present_HadRun = false;
HRESULT __stdcall hookD3D11Present(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)
{
	if (!present_HadRun)
	{
		if (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void **)&pDevice)))
		{
			pSwapChain->GetDevice(__uuidof(pDevice), (void**)&pDevice);
			pDevice->GetImmediateContext(&pContext);
		}

		renderer = new D3D11Renderer(pSwapChain);
		renderer->Initialize();

		D3D11_DEPTH_STENCIL_DESC  stencilDesc;
		stencilDesc.DepthFunc = D3D11_COMPARISON_LESS;
		stencilDesc.StencilEnable = true;
		stencilDesc.StencilReadMask = 0xFF;
		stencilDesc.StencilWriteMask = 0xFF;
		stencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
		stencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
		stencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
		stencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
		stencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
		stencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
		stencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
		stencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

		stencilDesc.DepthEnable = true;
		stencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
		pDevice->CreateDepthStencilState(&stencilDesc, &myDepthStencilStates[static_cast<int>(eDepthState::ENABLED)]);

		stencilDesc.DepthEnable = false;
		stencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
		pDevice->CreateDepthStencilState(&stencilDesc, &myDepthStencilStates[static_cast<int>(eDepthState::DISABLED)]);

		stencilDesc.DepthEnable = false;
		stencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
		stencilDesc.StencilEnable = false;
		stencilDesc.StencilReadMask = UINT8(0xFF);
		stencilDesc.StencilWriteMask = 0x0;
		pDevice->CreateDepthStencilState(&stencilDesc, &myDepthStencilStates[static_cast<int>(eDepthState::NO_READ_NO_WRITE)]);

		stencilDesc.DepthEnable = true;
		stencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL; //
		stencilDesc.DepthFunc = D3D11_COMPARISON_GREATER_EQUAL;
		stencilDesc.StencilEnable = false;
		stencilDesc.StencilReadMask = UINT8(0xFF);
		stencilDesc.StencilWriteMask = 0x0;

		stencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_ZERO;
		stencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_ZERO;
		stencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
		stencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_EQUAL;

		stencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_ZERO;
		stencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_ZERO;
		stencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_ZERO;
		stencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_NEVER;
		pDevice->CreateDepthStencilState(&stencilDesc, &myDepthStencilStates[static_cast<int>(eDepthState::READ_NO_WRITE)]);


		D3D11_RASTERIZER_DESC rwDesc;
		pContext->RSGetState(&rwState); // retrieve the current state
		rwState->GetDesc(&rwDesc);    // get the desc of the state
		rwDesc.FillMode = D3D11_FILL_WIREFRAME;
		rwDesc.CullMode = D3D11_CULL_NONE;
		pDevice->CreateRasterizerState(&rwDesc, &rwState);

		D3D11_RASTERIZER_DESC rsDesc;
		pContext->RSGetState(&rsState); // retrieve the current state
		rsState->GetDesc(&rsDesc);    // get the desc of the state
		rsDesc.FillMode = D3D11_FILL_SOLID;
		rsDesc.CullMode = D3D11_CULL_BACK;
		pDevice->CreateRasterizerState(&rsDesc, &rsState);

		HRESULT hResult = FW1CreateFactory(FW1_VERSION, &pFW1Factory);
		hResult = pFW1Factory->CreateFontWrapper(pDevice, L"Consolas", &pFontWrapper);
		pFW1Factory->Release();

		if (SUCCEEDED(pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&RenderTargetTexture)))
		{
			pDevice->CreateRenderTargetView(RenderTargetTexture, NULL, &RenderTargetView);
			RenderTargetTexture->Release();
		}
		present_HadRun = true;
	}

	if (!psRed)
		GenerateShader(pDevice, &psRed, 1.0f, 0.0f, 0.0f);

	if (!psBlue)
		GenerateShader(pDevice, &psBlue, 0.0f, 0.38f, 1.0f);

	if (!psOrange)
		GenerateShader(pDevice, &psOrange, 1.0f, 0.48f, 0.0f);

	pContext->OMSetRenderTargets(1, &RenderTargetView, NULL);

	if (pFontWrapper)
	{
		drawStringCount = 0;
		for (int i = g_wcDebugPrint.size() - 1; i >= 0; i--)
		{
			DEBUG_PRINT debug = g_wcDebugPrint[i];
			if (debug.timeToDelete > clock())
			{
				DrawString(debug.str, 20, 1500, 50 + (i * 25.0f), Color(255, 255, 255, 255));
			}
			else
			{
				g_wcDebugPrint.erase(g_wcDebugPrint.begin() + i);
			}
		}

		DWORD_PTR base = dwGetBaseAddress();
		UWorld *uWorld = (UWorld*)(*(DWORD_PTR*)(base + 0x37D57A8));
		UGameInstance *uGameInstance = uWorld->pOwningGameInstance;
		ULocalPlayer *uLocalPlayer = uGameInstance->LocalPlayers[0];
		UGameViewportClient *uViewportClient = uLocalPlayer->ViewportClient;
		UWorld *pWorld = uViewportClient->World;
		ULevel *uLevel = pWorld->pLevel;
		PUBG.baseAddr = base;
		PUBG.uWorld = uWorld;
		PUBG.uGameInstance = uGameInstance;
		PUBG.uLocalPlayer = uLocalPlayer;
		PUBG.uViewportClient = uViewportClient;
		PUBG.pWorld = pWorld;
		PUBG.uLevel = uLevel;

		renderer->BeginScene();

		//DrawPUBGModMenu();

		if (hasCachedGNames)
		{
			if (globals::bPlayerESP || globals::bItemESP || globals::bDebugESP)
			{
				APlayerCameraManager *camManager = PUBG.uLocalPlayer->PlayerController->PlayerCameraManager;
				AActor *localActor = PUBG.uLocalPlayer->PlayerController->Actor;
				if (localActor)
				{
					Vector3 localActorPos = localActor->RootComponent->RelativeLocation;
					int entityCount = PUBG.uLevel->entityList.Count();
					for (int i = 0; i < entityCount; i++)
					{
						AActor *actor = PUBG.uLevel->entityList[i];
						if (!actor)
							continue;
						if (actor == localActor)
							continue;
						if (!actor->RootComponent)
							continue;

						if (globals::bDebugESP)
						{
							Vector3 entityScr;
							Vector3 entityLoc = actor->RootComponent->RelativeLocation;
							Vector3 vDelta = localActorPos - entityLoc;
							float fDelta = vDelta.Length() / 100;
							if (fDelta < 500.0f)
							{
								WorldToScreen(entityLoc, camManager, entityScr);

								char itemgname[256] = {};
								if (GetGName(actor->id, itemgname))
								{
									DrawStringFmt(12.0f, entityScr.x, entityScr.y, Color(255, 255, 255, 255), "%s", itemgname);
								}
							}
						}

						if (globals::bPlayerESP)
						{
							if (actor->IsPlayer())
							{
								Vector3 scrFeet, scrHead;
								Vector3 enemyLocation = actor->RootComponent->RelativeLocation;
								Vector3 enemyHead = enemyLocation;
								enemyHead.z += 90.0f;
								Vector3 enemyFeet = enemyLocation;
								enemyFeet.z -= 90.0f;

								Vector3 vDelta = localActorPos - enemyLocation;
								float fDelta = vDelta.Length() / 100;
								if (fDelta < globals::g_espDrawDistance)
								{
									WorldToScreen(enemyHead, camManager, scrHead);
									WorldToScreen(enemyFeet, camManager, scrFeet);

									float height = scrFeet.y - scrHead.y;
									float width = height / 2.0f;

									bool isVisible = PUBG.uGameInstance->LocalPlayers[0]->PlayerController->IsVisible(actor);
									Color espColor;
									if (isVisible)
										espColor = Color(255, 255, 255, 0);
									else
										espColor = Color(255, 255, 0, 0);

									if (globals::bDrawDistance)
									{
										char disStr[100] = {};
										sprintf_s(disStr, "%0.1f M", fDelta);
										DrawString(disStr, 13, scrHead.x - (width / 2), scrHead.y + (height * 1.4f), Color(255, 255, 255, 255));
									}
									if (globals::bDrawNames)
									{
										//wchar_t *playerName = actor->PlayerState->PlayerName.GetWideString();
										//pFontWrapper->DrawString(pContext, playerName, 13, scrHead.x - (width / 2), scrHead.y + height, 0xFFFFFFFF, FW1_RESTORESTATE);
									}
									if (globals::bSnapLines)
									{
										renderer->DrawLine(1920 / 2, 1080, scrFeet.x, scrFeet.y, espColor);
									}
									if (globals::bDrawHealth)
									{
										float health = actor->health;
										Color healthColor = Color(255, 255, 255, 0);
										healthColor.R = 255.0f - (health * 2.55f);
										healthColor.G = health * 2.55f;
										float testValue = health * (height / 100.0f);
										float shit = height - testValue;
										renderer->FillRect(scrHead.x + (width / 1.5f), scrHead.y + shit, 3.0f, testValue, healthColor);
									}
									if (globals::g_espBoxStyle == 0)
									{
										renderer->DrawBorderBox(scrHead.x - (width / 2), scrHead.y, width, height, espColor);
									}
									else if (globals::g_espBoxStyle == 1)
									{

									}
									else if (globals::g_espBoxStyle == 2)
									{
										espColor.A = 90;
										renderer->FillRect(scrHead.x - (width / 2), scrHead.y, width, height, espColor);
										renderer->DrawBorderBox(scrHead.x - (width / 2), scrHead.y, width, height, Color(255, 0, 0, 0));
									}
								}
							}
						}
						if (globals::bItemESP)
						{
							if (actor->IsDroppedItemGroup())
							{
								Vector3 screenLoc;
								Vector3 lootRelLoc = actor->RootComponent->RelativeLocation;

								Vector3 vDelta = localActorPos - lootRelLoc;
								float fDelta = vDelta.Length() / 100;
								if (fDelta < 150.0f)
								{
									if (actor->DroppedItemArray.Count() > 0)
									{
										for (int index = 0; index < actor->DroppedItemArray.Count(); index++)
										{
											AActor *lootItem = (AActor*)actor->DroppedItemArray[index].pActor;
											if (!lootItem)
												continue;

											if (lootItem->IsDroppedItemInteractionComponent())
											{
												Vector3 tmpLoc = *(Vector3*)((DWORD_PTR)lootItem + 0x1E0);
												Vector3 itemLocation = lootRelLoc + tmpLoc;

												WorldToScreen(itemLocation, camManager, screenLoc);

												DWORD_PTR uItem = *(DWORD_PTR*)((DWORD_PTR)lootItem + 0x448);
												if (!uItem)
													continue;
												DWORD_PTR FTextItem = *(DWORD_PTR*)(uItem + 0x40);
												if (!FTextItem)
													continue;
												FString itemName;
												memcpy(&itemName, (LPVOID)(FTextItem + 0x28), sizeof(FString));

												DrawString(itemName.GetWideString(), 12.0f, screenLoc.x, screenLoc.y, Color(255, 255, 255, 255));
											}
										}
									}
								}
							}
							else if (actor->IsDroppedItem())
							{
								Vector3 screenLoc;
								Vector3 lootLoc = actor->RootComponent->RelativeLocation;
								Vector3 vDelta = localActorPos - lootLoc;
								float fDelta = vDelta.Length() / 100;
								if (fDelta < 150.0f)
								{
									WorldToScreen(lootLoc, camManager, screenLoc);
									
									DWORD_PTR uItem = *(DWORD_PTR*)((DWORD_PTR)actor + 0x03A0);
									if (!uItem)
										continue;
									DWORD_PTR FTextItem = *(DWORD_PTR*)(uItem + 0x40);
									if (!FTextItem)
										continue;
									FString itemName;
									memcpy(&itemName, (LPVOID)(FTextItem + 0x28), sizeof(FString));

									DrawString(itemName.GetWideString(), 12.0f, screenLoc.x, screenLoc.y, Color(255, 255, 255, 255));
								}
							}
						}
					}
				}
			}
		}
		renderer->EndScene();
	}

	/*

			AActor *apActor = (AActor*)(pActor);
			if (apActor->IsDroppedItemInteractionComponent())
			{
				Vector3 tmpLoc = *(Vector3*)(pActor + 0x1E0);
				Vector3 itemLoction = lootRelativeLocation + tmpLoc;
				WorldToScreen(itemLoction, cameraManager, screenLoc);

				DWORD_PTR uItem = *(DWORD_PTR*)(pActor + 0x448);
				if (!uItem)
					continue;
				DWORD_PTR FTextItem = *(DWORD_PTR*)(uItem + 0x40);
				if (!FTextItem)
					continue;
				FString itemName;
				memcpy(&itemName, (LPVOID)(FTextItem + 0x28), sizeof(FString));

				if (DoesStrArrayContain(itemEspWeapons, itemName.GetString()) || DoesStrArrayContain(itemEspEquipment, itemName.GetString()))
				{
					pFontWrapper->DrawString(pContext, itemName.GetWideString(), 15, screenLoc.x, screenLoc.y, 0xFF00FF00, FW1_RESTORESTATE);
				}
			}
		}
	}*/

	return phookD3D11Present(pSwapChain, SyncInterval, Flags);
}

int pStride = 36;
void __stdcall hookD3D11DrawIndexed(ID3D11DeviceContext* tpContext, UINT IndexCount, UINT StartIndexLocation, INT BaseVertexLocation)
{
	pContext->IAGetVertexBuffers(0, 1, &veBuffer, &Stride, &veBufferOffset);
	if (veBuffer)
		veBuffer->GetDesc(&vedesc);
	if (veBuffer != NULL) { veBuffer->Release(); veBuffer = NULL; }

	pContext->IAGetIndexBuffer(&inBuffer, &inFormat, &inOffset);
	if (inBuffer)
		inBuffer->GetDesc(&indesc);
	if (inBuffer != NULL) { inBuffer->Release(); inBuffer = NULL; }

	if (Stride == pStride && vedesc.ByteWidth >= 170000 /*Broken Glass*/ && vedesc.ByteWidth != (122766 * pStride) && vedesc.ByteWidth != (21363 * pStride) && vedesc.ByteWidth != (6343 * pStride) /*Buggy*/ \
		&& vedesc.ByteWidth != (30049 * pStride) && vedesc.ByteWidth != (17292 * pStride) && vedesc.ByteWidth != (6481 * pStride) /*Dacia*/ \
		&& vedesc.ByteWidth != (48197 * pStride) && vedesc.ByteWidth != (31616 * pStride) && vedesc.ByteWidth != (10102 * pStride) /*UAZ B*/ \
		&& vedesc.ByteWidth != (46533 * pStride) && vedesc.ByteWidth != (28729 * pStride) && vedesc.ByteWidth != (9815 * pStride) /*UAZ*/ \
		&& vedesc.ByteWidth != (46717 * pStride) && vedesc.ByteWidth != (26879 * pStride) && vedesc.ByteWidth != (9906 * pStride) /*UAZ C*/ \
		&& vedesc.ByteWidth != (42064 * pStride) && vedesc.ByteWidth != (25256 * pStride) && vedesc.ByteWidth != (15867 * pStride)  /*Motorbike Sidecart*/ \
		&& vedesc.ByteWidth != (32281 * pStride) && vedesc.ByteWidth != (19271 * pStride) && vedesc.ByteWidth != (8801 * pStride) /*Motorbike*/ \
		&& vedesc.ByteWidth != (33118 * pStride) && vedesc.ByteWidth != (18738 * pStride) && vedesc.ByteWidth != (5630 * pStride) /*Boat PG117*/ \
		&& vedesc.ByteWidth != (72170 * pStride) /*Destroyed Door A*/ \
		&& vedesc.ByteWidth != (44708 * pStride) /*Destroyed Door F*/ \
		&& vedesc.ByteWidth != (39156 * pStride) /*Destroyed Door A2*/ \
		&& vedesc.ByteWidth != (28286 * pStride) /*Destroyed Wood E11*/ \
		&& vedesc.ByteWidth != (24923 * pStride) /*Destroyed Wood E12*/ \
		&& vedesc.ByteWidth != (23026 * pStride) /*Destroyed Fence Short A*/ \
		&& vedesc.ByteWidth != (19196 * pStride) /*Destroyed Fence Short B*/ \
		&& vedesc.ByteWidth != (15332 * pStride) /*Destroyed Fence Short C*/ \
		&& vedesc.ByteWidth != (23035 * pStride) /*Destroyed Fence A*/ \
		&& vedesc.ByteWidth != (25962 * pStride) /*Destroyed Fence B*/ \
		&& vedesc.ByteWidth != (19931 * pStride) /*Destroyed Fence C*/ \
		&& vedesc.ByteWidth != (19222 * pStride) /*Destroyed Fence D*/ \
		&& vedesc.ByteWidth != (8658 * pStride)  /*M16*/ \
		&& vedesc.ByteWidth != (8351 * pStride)  /*AK*/ \
		&& vedesc.ByteWidth != (9974 * pStride)  /*SCAR-L*/ \
		&& vedesc.ByteWidth != (12166 * pStride)  /*HK416*/ \
		&& vedesc.ByteWidth != (6518 * pStride)  /*UZI*/ \
		&& vedesc.ByteWidth != (12021 * pStride) /*SKS*/ \
		&& vedesc.ByteWidth != (5470 * pStride) /*S686*/ \
		&& vedesc.ByteWidth != (11292 * pStride) /*K89K*/)
	{
		SetDepthStencilState(DISABLED);
		pContext->PSSetShader(psRed, NULL, NULL);
		phookD3D11DrawIndexed(pContext, IndexCount, StartIndexLocation, BaseVertexLocation);
		SetDepthStencilState(READ_NO_WRITE);
		pContext->PSSetShader(psOrange, NULL, NULL);
	}

	return phookD3D11DrawIndexed(pContext, IndexCount, StartIndexLocation, BaseVertexLocation);
}

void __stdcall hookD3D11CreateQuery(ID3D11Device* pDevice, const D3D11_QUERY_DESC *pQueryDesc, ID3D11Query **ppQuery)
{
	if (pQueryDesc->Query == D3D11_QUERY_OCCLUSION)
	{
		D3D11_QUERY_DESC oqueryDesc = CD3D11_QUERY_DESC();
		(&oqueryDesc)->MiscFlags = pQueryDesc->MiscFlags;
		(&oqueryDesc)->Query = D3D11_QUERY_TIMESTAMP;

		return phookD3D11CreateQuery(pDevice, &oqueryDesc, ppQuery);
	}
	return phookD3D11CreateQuery(pDevice, pQueryDesc, ppQuery);
}

LRESULT CALLBACK DXGIMsgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { return DefWindowProc(hwnd, uMsg, wParam, lParam); }
DWORD __stdcall D3D11_Hook(LPVOID)
{
	HMODULE hDXGIDLL = 0;
	do
	{
		hDXGIDLL = GetModuleHandleA("dxgi.dll");
		Sleep(10);
	} while (!hDXGIDLL);
	Sleep(100);
	WNDCLASSEXA wc = { sizeof(WNDCLASSEX), CS_CLASSDC, DXGIMsgProc, 0L, 0L, GetModuleHandleA(NULL), NULL, NULL, NULL, NULL, "DX", NULL };
	RegisterClassExA(&wc);
	HWND hWnd = CreateWindowA("DX", NULL, WS_OVERLAPPEDWINDOW, 100, 100, 300, 300, NULL, NULL, wc.hInstance, NULL);
	D3D_FEATURE_LEVEL requestedLevels[] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_1 };
	D3D_FEATURE_LEVEL obtainedLevel;
	ID3D11Device* d3dDevice = nullptr;
	ID3D11DeviceContext* d3dContext = nullptr;
	DXGI_SWAP_CHAIN_DESC scd;
	ZeroMemory(&scd, sizeof(scd));
	scd.BufferCount = 1;
	scd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	scd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
	scd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	scd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
	scd.OutputWindow = hWnd;
	scd.SampleDesc.Count = 1;
	scd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
	scd.Windowed = ((GetWindowLongPtr(hWnd, GWL_STYLE) & WS_POPUP) != 0) ? false : true;
	scd.BufferDesc.Width = 1;
	scd.BufferDesc.Height = 1;
	scd.BufferDesc.RefreshRate.Numerator = 0;
	scd.BufferDesc.RefreshRate.Denominator = 1;

	UINT createFlags = 0;

	IDXGISwapChain* d3dSwapChain = 0;

	if (FAILED(D3D11CreateDeviceAndSwapChain(
		nullptr,
		D3D_DRIVER_TYPE_HARDWARE,
		nullptr,
		createFlags,
		requestedLevels,
		sizeof(requestedLevels) / sizeof(D3D_FEATURE_LEVEL),
		D3D11_SDK_VERSION,
		&scd,
		&g_pSwapChain,
		&pDevice,
		&obtainedLevel,
		&pContext)))
	{
		MessageBoxA(hWnd, "Failed to create directX device and swapchain!", "Error", MB_ICONERROR);
		return NULL;
	}

	pSwapChainVtable = (DWORD_PTR*)g_pSwapChain;
	pSwapChainVtable = (DWORD_PTR*)pSwapChainVtable[0];
	pContextVTable = (DWORD_PTR*)pContext;
	pContextVTable = (DWORD_PTR*)pContextVTable[0];
	pDeviceVTable = (DWORD_PTR*)pDevice;
	pDeviceVTable = (DWORD_PTR*)pDeviceVTable[0];

	if (MH_Initialize() != MH_OK)
		return 0;

	//MH_CreateHook((DWORD_PTR*)pSwapChainVtable[8], hookD3D11Present, reinterpret_cast<void**>(&phookD3D11Present));
	//MH_EnableHook((DWORD_PTR*)pSwapChainVtable[8]);
	MH_CreateHook((DWORD_PTR*)pContextVTable[12], hookD3D11DrawIndexed, reinterpret_cast<void**>(&phookD3D11DrawIndexed));
	MH_EnableHook((DWORD_PTR*)pContextVTable[12]);
	MH_CreateHook((DWORD_PTR*)pDeviceVTable[24], hookD3D11CreateQuery, reinterpret_cast<void**>(&phookD3D11CreateQuery));
	MH_EnableHook((DWORD_PTR*)pDeviceVTable[24]);

	//CacheGNames();
	//hasCachedGNames = true;

	pDevice->Release();
	pContext->Release();
	g_pSwapChain->Release();

	return 0;
}

#pragma endregion

BOOL APIENTRY DllMain( HMODULE hModule, DWORD  ul_reason_for_call,LPVOID lpReserved )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		CreateThread(0, 0, (LPTHREAD_START_ROUTINE)D3D11_Hook, 0, 0, 0);
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		isPUBGThreadRunning = false;
		MH_Uninitialize();
		MH_DisableHook((DWORD_PTR*)pSwapChainVtable[8]);
		/*MH_DisableHook((DWORD_PTR*)pContextVTable[12]);
		MH_DisableHook((DWORD_PTR*)pDeviceVTable[24]);*/
		break;
	}
	return TRUE;
}


```

`stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// PUBG_Internal.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>



// TODO: reference additional headers your program requires here

```

`targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```