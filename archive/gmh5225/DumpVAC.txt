Project Path: arc_gmh5225_DumpVAC_nrjnz773

Source Tree:

```txt
arc_gmh5225_DumpVAC_nrjnz773
├── Console
│   ├── Console.cpp
│   ├── Console.vcxproj
│   ├── Console.vcxproj.filters
│   ├── ConsoleUtils.cpp
│   └── ConsoleUtils.h
├── DumpVAC
│   ├── Console.cpp
│   ├── Console.h
│   ├── Detours
│   │   ├── Detours.cpp
│   │   └── Detours.h
│   ├── DumpVAC.vcxproj
│   ├── DumpVAC.vcxproj.filters
│   ├── IceKey.cpp
│   ├── IceKey.h
│   ├── LibraryLoader.cpp
│   ├── LibraryLoader.h
│   ├── distorm
│   │   ├── include
│   │   │   ├── distorm.h
│   │   │   └── mnemonics.h
│   │   └── src
│   │       ├── config.h
│   │       ├── decoder.c
│   │       ├── decoder.h
│   │       ├── distorm.c
│   │       ├── instructions.c
│   │       ├── instructions.h
│   │       ├── insts.c
│   │       ├── insts.h
│   │       ├── mnemonics.c
│   │       ├── operands.c
│   │       ├── operands.h
│   │       ├── prefix.c
│   │       ├── prefix.h
│   │       ├── textdefs.c
│   │       ├── textdefs.h
│   │       ├── wstring.h
│   │       └── x86defs.h
│   ├── distormx
│   │   ├── include
│   │   │   └── distormx.h
│   │   └── src
│   │       ├── OS.c
│   │       ├── OS.h
│   │       └── distormx.c
│   ├── dllmain.cpp
│   └── framework.h
├── DumpVAC.sln
├── LICENSE
├── README.md
└── unknown.png

```

`Console/Console.cpp`:

```cpp

// Default
#include <Windows.h>
#include <tchar.h>
#include <TlHelp32.h>
#include <winternl.h>
#include <Psapi.h>

// STL
#include <cctype>

// Custom
#include "ConsoleUtils.h"

// Namespaces
using namespace ConsoleUtils;

// General definitions
typedef LONG(NTAPI* fnNtResumeProcess)(HANDLE hProcess);
typedef LONG(NTAPI* fnNtSuspendProcess)(HANDLE hProcess);

fnNtSuspendProcess NtResumeProcess = nullptr;
fnNtResumeProcess NtSuspendProcess = nullptr;

SC_HANDLE g_hServiceManager = nullptr;
SC_HANDLE g_hService = nullptr;

bool g_bIsValidLaunch = false;
bool g_bStop = false;

typedef LONG(NTAPI* fnNtFlushInstructionCache)(HANDLE ProcessHandle, PVOID BaseAddress, ULONG NumberOfBytesToFlush);
typedef LPVOID(WINAPI* fnVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);
typedef FARPROC(WINAPI* fnGetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
typedef HMODULE(WINAPI* fnLoadLibraryA)(LPCSTR lpLibFileName);

typedef struct _LOADER_DATA {
	// Addresses
	fnNtFlushInstructionCache m_pNtFlushInstructionCache;
	fnVirtualAlloc m_pVirtualAlloc;
	fnGetProcAddress m_pGetProcAddress;
	fnLoadLibraryA m_pLoadLibraryA;
	// Memory
	void* m_pMemoryAddress;
	DWORD m_unMemorySize;
	char m_pLoaderPath[1024];
} LOADER_DATA, *PLOADER_DATA;

typedef struct _CONSOLE_MESSAGE {
	char m_pMessage[1024];
	COLOR_PAIR m_ColorPair;
} CONSOLE_MESSAGE, *PCONSOLE_MESSAGE;

bool StartSteamService(const SC_HANDLE hServiceManager, const SC_HANDLE hService) {
	if (!hServiceManager) {
		return false;
	}

	if (!hService) {
		return false;
	}

	SERVICE_STATUS_PROCESS ssp;
	memset(&ssp, 0, sizeof(ssp));

	DWORD unBytesNeeded = 0;
	if (!QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, reinterpret_cast<LPBYTE>(&ssp), sizeof(SERVICE_STATUS_PROCESS), &unBytesNeeded)) {
		return false;
	}

	if (ssp.dwCurrentState == SERVICE_RUNNING) {
		return true;
	}

	DWORD64 unStartTime = GetTickCount64();
	while (ssp.dwCurrentState == SERVICE_START_PENDING) {

		DWORD unWaitTime = ssp.dwWaitHint / 10;

		if (unWaitTime < 1000) {
			unWaitTime = 1000;
		}
		else if (unWaitTime > 10000) {
			unWaitTime = 10000;
		}

		Sleep(unWaitTime);

		unBytesNeeded = 0;
		if (!QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, reinterpret_cast<LPBYTE>(&ssp), sizeof(SERVICE_STATUS_PROCESS), &unBytesNeeded)) {
			return false;
		}

		if (ssp.dwCurrentState == SERVICE_RUNNING) {
			return true;
		}

		if (GetTickCount64() - unStartTime > 30000) {
			return false;
		}
	}


	if (!StartService(hService, 0, nullptr)) {
		return false;
	}

	unStartTime = GetTickCount64();
	while (true) {
		Sleep(ssp.dwWaitHint);

		unBytesNeeded = 0;
		if (!QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, reinterpret_cast<LPBYTE>(&ssp), sizeof(SERVICE_STATUS_PROCESS), &unBytesNeeded)) {
			return false;
		}

		if (ssp.dwCurrentState == SERVICE_RUNNING) {
			return true;
		}

		if (GetTickCount64() - unStartTime > 30000) {
			return false;
		}
	}

	return false;
}

bool StopSteamService(const SC_HANDLE hServiceManager, const SC_HANDLE hService) {
	if (!hServiceManager) {
		return false;
	}

	if (!hService) {
		return false;
	}

	SERVICE_STATUS_PROCESS ssp;
	memset(&ssp, 0, sizeof(ssp));

	DWORD unBytesNeeded = 0;
	if (!QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, reinterpret_cast<LPBYTE>(&ssp), sizeof(SERVICE_STATUS_PROCESS), &unBytesNeeded)) {
		return false;
	}

	if (ssp.dwCurrentState == SERVICE_STOPPED) {
		return true;
	}

	DWORD64 unStartTime = GetTickCount64();
	while (ssp.dwCurrentState == SERVICE_STOP_PENDING) {

		DWORD unWaitTime = ssp.dwWaitHint / 10;

		if (unWaitTime < 1000) {
			unWaitTime = 1000;
		}
		else if (unWaitTime > 10000) {
			unWaitTime = 10000;
		}

		Sleep(unWaitTime);

		unBytesNeeded = 0;
		if (!QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, reinterpret_cast<LPBYTE>(&ssp), sizeof(SERVICE_STATUS_PROCESS), &unBytesNeeded)) {
			return false;
		}

		if (ssp.dwCurrentState == SERVICE_STOPPED) {
			return true;
		}

		if (GetTickCount64() - unStartTime > 30000) {
			return false;
		}
	}


	if (!ControlService(hService, SERVICE_CONTROL_STOP, reinterpret_cast<LPSERVICE_STATUS>(&ssp))) {
		return false;
	}

	unStartTime = GetTickCount64();
	while (true) {
		Sleep(ssp.dwWaitHint);

		unBytesNeeded = 0;
		if (!QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, reinterpret_cast<LPBYTE>(&ssp), sizeof(SERVICE_STATUS_PROCESS), &unBytesNeeded)) {
			return false;
		}

		if (ssp.dwCurrentState == SERVICE_STOPPED) {
			return true;
		}

		if (GetTickCount64() - unStartTime > 30000) {
			return false;
		}
	}

	return false;
}

typedef struct _RESTART_SERVICE_DATA {
	SC_HANDLE m_hServiceManager;
	SC_HANDLE m_hService;
} RESTART_SERVICE_DATA, *PRESTART_SERVICE_DATA;

DWORD WINAPI StartServiceRoutine(LPVOID lpThreadParameter) {
	PRESTART_SERVICE_DATA pData = reinterpret_cast<PRESTART_SERVICE_DATA>(lpThreadParameter);
	if (!pData) {
		return -1;
	}

	if (!StartSteamService(pData->m_hServiceManager, pData->m_hService)) {
		return -1;
	}

	delete pData;
	return 0;
}

bool Lower(const TCHAR* szInput, const size_t unLength, TCHAR* szOutput) {
	if (!szInput) {
		return false;
	}

	if (!unLength) {
		return false;
	}

	if (!szOutput) {
		return false;
	}

	for (size_t i = 0; i < unLength; ++i) {
		szOutput[i] = std::tolower(szInput[i]);
	}

	return true;
}

DWORD GetPID(const TCHAR* szProcessName) {
	if (!szProcessName) {
		return 0;
	}

	PROCESSENTRY32 pe;
	memset(&pe, 0, sizeof(pe));

	pe.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (!hSnap || (hSnap == INVALID_HANDLE_VALUE)) {
		return 0;
	}

	if (Process32First(hSnap, &pe)) {
		while (Process32Next(hSnap, &pe)) {
			PTCHAR szName = new TCHAR[MAX_PATH + 1];
			if (!szName) {
				CloseHandle(hSnap);
				return 0;
			}
			memset(szName, 0, sizeof(TCHAR[MAX_PATH + 1]));
			if (!Lower(pe.szExeFile, MAX_PATH, szName)) {
				delete[] szName;
				continue;
			}
			if (_tcsncmp(szName, szProcessName, MAX_PATH) == 0) {
				delete[] szName;
				CloseHandle(hSnap);
				return pe.th32ProcessID;
			}
			delete[] szName;
		}
	}

	CloseHandle(hSnap);
	return 0;
}

size_t GetExportOffset(void* pMemory, const size_t unSize, const char* szExportName) {
	if (!pMemory) {
		return 0;
	}

	if (!unSize) {
		return 0;
	}

	if (unSize < sizeof(IMAGE_DOS_HEADER)) {
		return 0;
	}

	const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(pMemory);
	if (pDH->e_magic != IMAGE_DOS_SIGNATURE) {
		return 0;
	}

	if (unSize < pDH->e_lfanew + sizeof(IMAGE_NT_HEADERS)) {
		return 0;
	}

	const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(pMemory) + pDH->e_lfanew);
	if (pNTHs->Signature != IMAGE_NT_SIGNATURE) {
		return 0;
	}

	const PIMAGE_FILE_HEADER pFH = &(pNTHs->FileHeader);
#ifdef _WIN64
	if (pFH->Machine != IMAGE_FILE_MACHINE_AMD64) {
		return 0;
	}

	const PIMAGE_OPTIONAL_HEADER64 pOH = reinterpret_cast<PIMAGE_OPTIONAL_HEADER64>(&(pNTHs->OptionalHeader));
	if (pOH->Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
		return 0;
	}
#elif _WIN32
	if (pFH->Machine != IMAGE_FILE_MACHINE_I386) {
		return 0;
	}

	const PIMAGE_OPTIONAL_HEADER32 pOH = reinterpret_cast<PIMAGE_OPTIONAL_HEADER32>(&(pNTHs->OptionalHeader));
	if (pOH->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
		return 0;
	}
#else
#error Unknown platform
#endif

	const PIMAGE_DATA_DIRECTORY pExportDD = &(pOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
	const PIMAGE_SECTION_HEADER pFirstSection = reinterpret_cast<PIMAGE_SECTION_HEADER>(reinterpret_cast<char*>(&(pNTHs->OptionalHeader)) + pFH->SizeOfOptionalHeader);
	for (DWORD i = 0; i < pFH->NumberOfSections; ++i) {
		if ((pExportDD->VirtualAddress >= pFirstSection[i].VirtualAddress) && (pExportDD->VirtualAddress < (pFirstSection[i].VirtualAddress + pFirstSection[i].Misc.VirtualSize))) {

			const DWORD unDelta = pFirstSection[i].VirtualAddress - pFirstSection[i].PointerToRawData;

			const PIMAGE_EXPORT_DIRECTORY pExportDirectory = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(reinterpret_cast<char*>(pMemory) + pExportDD->VirtualAddress - unDelta);

			const PDWORD pFunctions = reinterpret_cast<PDWORD>(reinterpret_cast<char*>(pMemory) + pExportDirectory->AddressOfFunctions - unDelta);
			const PWORD pOrdinals = reinterpret_cast<PWORD>(reinterpret_cast<char*>(pMemory) + pExportDirectory->AddressOfNameOrdinals - unDelta);
			const PDWORD pNames = reinterpret_cast<PDWORD>(reinterpret_cast<char*>(pMemory) + pExportDirectory->AddressOfNames - unDelta);

			const DWORD unNumberOfFunctions = pExportDirectory->NumberOfFunctions;
			const DWORD unNumberOfNames = pExportDirectory->NumberOfNames;
			for (DWORD j = 0; j < unNumberOfFunctions; ++j) {
				for (DWORD l = 0; l < unNumberOfNames; ++l) {
					if (pOrdinals[l] == j) {
						if (strcmp(szExportName, reinterpret_cast<char*>(pMemory) + pNames[l] - unDelta) == 0) {
							const DWORD unRVA = *reinterpret_cast<PDWORD>(&pFunctions[pOrdinals[l]]);
							for (DWORD k = 0; k < pFH->NumberOfSections; ++k) {
								if ((unRVA >= pFirstSection[k].VirtualAddress) && (unRVA < (pFirstSection[k].VirtualAddress + pFirstSection[k].SizeOfRawData))) {
									return unRVA - pFirstSection[k].VirtualAddress + pFirstSection[k].PointerToRawData;
								}
							}
						}
					}
				}
			}
		}
	}

	return 0;
}

bool InjectLibrary(const HANDLE hProcess, void* pMemory, const size_t unSize, PLOADER_DATA pLoaderData) {
	if (!hProcess) {
		return false;
	}

	if (!pMemory) {
		return false;
	}

	if (!unSize) {
		return false;
	}

	if (unSize < sizeof(IMAGE_DOS_HEADER)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (File is too small)\n"));
		return false;
	}

	const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(pMemory);
	if (pDH->e_magic != IMAGE_DOS_SIGNATURE) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Invalid DOS signature)\n"));
		return false;
	}

	if (unSize < pDH->e_lfanew + sizeof(IMAGE_NT_HEADERS)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (File is too small)\n"));
		return false;
	}

	const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(pMemory) + pDH->e_lfanew);
	if (pNTHs->Signature != IMAGE_NT_SIGNATURE) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Invalid PE signature)\n"));
		return false;
	}

	const PIMAGE_FILE_HEADER pFH = &(pNTHs->FileHeader);
#ifdef _WIN64
	if (pFH->Machine != IMAGE_FILE_MACHINE_AMD64) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Invalid platform)\n"));
		return false;
	}

	const PIMAGE_OPTIONAL_HEADER64 pOH = reinterpret_cast<PIMAGE_OPTIONAL_HEADER64>(&(pNTHs->OptionalHeader));
	if (pOH->Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Invalid optional PE signature)\n"));
		return false;
	}
#elif _WIN32
	if (pFH->Machine != IMAGE_FILE_MACHINE_I386) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Invalid platform)\n"));
		return false;
	}

	const PIMAGE_OPTIONAL_HEADER32 pOH = reinterpret_cast<PIMAGE_OPTIONAL_HEADER32>(&(pNTHs->OptionalHeader));
	if (pOH->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Invalid optional PE signature)\n"));
		return false;
	}
#else
#error Unknown platform
#endif

	const size_t unLoaderOffset = GetExportOffset(pMemory, unSize, "?DumpVAC@@YGKPAX@Z");
	if (!unLoaderOffset) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Loader not found)\n"));
		return false;
	}

	void* pBuffer = VirtualAllocEx(hProcess, nullptr, unSize + sizeof(LOADER_DATA), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!pBuffer) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Unable to allocate memory)\n"));
		return false;
	}

	if (!WriteProcessMemory(hProcess, pBuffer, pMemory, unSize, nullptr)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Unable to write memory)\n"));
		return false;
	}

	pLoaderData->m_pMemoryAddress = pBuffer;
	pLoaderData->m_unMemorySize = unSize;

	char szBuffer[sizeof(LOADER_DATA::m_pLoaderPath)];
	memset(szBuffer, 0, sizeof(szBuffer));
	if (!GetModuleFileNameA(nullptr, szBuffer, sizeof(szBuffer))) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Unknown path)\n"));
		return false;
	}

	char szDriveFile[sizeof(LOADER_DATA::m_pLoaderPath) / 2];
	memset(szDriveFile, 0, sizeof(szDriveFile));
	char szDirFile[sizeof(LOADER_DATA::m_pLoaderPath) / 2];
	memset(szDirFile, 0, sizeof(szDirFile));
	if (_splitpath_s(szBuffer, szDriveFile, sizeof(szDriveFile) - 1, szDirFile, sizeof(szDirFile) - 1, nullptr, 0, nullptr, 0)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Unknown path)\n"));
		return false;
	}

	memset(szBuffer, 0, sizeof(szBuffer));
	sprintf_s(szBuffer, "%s%s", szDriveFile, szDirFile);

	memcpy(pLoaderData->m_pLoaderPath, szBuffer, sizeof(LOADER_DATA::m_pLoaderPath));

	if (!WriteProcessMemory(hProcess, reinterpret_cast<char*>(pBuffer) + unSize, pLoaderData, sizeof(LOADER_DATA), nullptr)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Unable to write memory)\n"));
		return false;
	}

	HANDLE hThread = CreateRemoteThread(hProcess, nullptr, 0x100000 /* 1 MiB */, reinterpret_cast<LPTHREAD_START_ROUTINE>(reinterpret_cast<size_t>(pBuffer) + unLoaderOffset), reinterpret_cast<char*>(pBuffer) + unSize, CREATE_SUSPENDED, nullptr);
	if (!hThread || (hThread == INVALID_HANDLE_VALUE)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to inject library (Invalid thread handle)\n"));
		return false;
	}

	ResumeThread(hThread);

	if (!NT_SUCCESS(NtResumeProcess(hProcess))) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `NtResumeProcess` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	WaitForSingleObject(hThread, INFINITE);
	CloseHandle(hThread);
	return true;
}

bool FileRead(const TCHAR* szPath, PHANDLE phHeap, LPVOID* ppMemory, PDWORD punFileSize) {
	const HANDLE hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (!hFile || (hFile == INVALID_HANDLE_VALUE)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `CreateFile` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	const DWORD unFileSize = GetFileSize(hFile, nullptr);
	if (!unFileSize || (unFileSize == INVALID_FILE_SIZE)) {
		CloseHandle(hFile);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `GetFileSize` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	const HANDLE hHeap = GetProcessHeap();
	if (!hHeap || (hHeap == INVALID_HANDLE_VALUE)) {
		CloseHandle(hFile);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `GetProcessHeap` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	void* pMemory = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, unFileSize);
	if (!pMemory) {
		CloseHandle(hFile);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `HeapAlloc` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	DWORD unNumberOfBytesRead = 0;
	if (!ReadFile(hFile, pMemory, unFileSize, &unNumberOfBytesRead, nullptr) && (unFileSize != unNumberOfBytesRead)) {
		if (!HeapFree(hHeap, NULL, pMemory)) {
			CloseHandle(hFile);
			tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `HeapFree` (LastError = 0x%08X)\n"), GetLastError());
			return false;
		}
		CloseHandle(hFile);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `HeapAlloc` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	CloseHandle(hFile);

	if (phHeap) {
		*phHeap = hHeap;
	}

	if (ppMemory) {
		*ppMemory = pMemory;
	} else {
		if (!HeapFree(hHeap, NULL, pMemory)) {
			tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `HeapFree` (LastError = 0x%08X)\n"), GetLastError());
			return false;
		}
	}

	if (punFileSize) {
		*punFileSize = unFileSize;
	}

	return true;
}

bool HackSteamService(const HANDLE hProcess) {
	if (!hProcess) {
		return false;
	}

	HMODULE hRemoteNTDLL = nullptr;
	HMODULE hRemoteKernel32 = nullptr;

	HMODULE hModules[1024];
	memset(hModules, 0, sizeof(hModules));

	DWORD unNeeded = 0;
	if (EnumProcessModules(hProcess, hModules, sizeof(hModules), &unNeeded)) {
		const DWORD unEnd = unNeeded / sizeof(HMODULE);
		for (unsigned int i = 0; i < unEnd; ++i) {
			TCHAR szModuleName[MAX_PATH];
			memset(szModuleName, 0, sizeof(szModuleName));
			if (GetModuleBaseName(hProcess, hModules[i], szModuleName, MAX_PATH - 1)) {
				if ((_tccmp(szModuleName, _T("ntdll.dll")) == 0) && !hRemoteNTDLL) {
					hRemoteNTDLL = hModules[i];
					continue;
				}

				if ((_tccmp(szModuleName, _T("KERNEL32.DLL")) == 0) && !hRemoteKernel32) {
					hRemoteKernel32 = hModules[i];
					continue;
				}
			}
		}
	}

	if (!hRemoteNTDLL) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `EnumProcessModules` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	if (!hRemoteKernel32) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `EnumProcessModules` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	LOADER_DATA LoaderData;
	memset(&LoaderData, 0, sizeof(LoaderData));

	LoaderData.m_pNtFlushInstructionCache = reinterpret_cast<fnNtFlushInstructionCache>(GetProcAddress(hRemoteNTDLL, "NtFlushInstructionCache"));
	LoaderData.m_pVirtualAlloc = reinterpret_cast<fnVirtualAlloc>(GetProcAddress(hRemoteKernel32, "VirtualAlloc"));
	LoaderData.m_pGetProcAddress = reinterpret_cast<fnGetProcAddress>(GetProcAddress(hRemoteKernel32, "GetProcAddress"));
	LoaderData.m_pLoadLibraryA = reinterpret_cast<fnLoadLibraryA>(GetProcAddress(hRemoteKernel32, "LoadLibraryA"));

	HANDLE hHeap = nullptr;
	LPVOID pMemory = nullptr;
	DWORD unFileSize = 0;

	if (!FileRead(_T("DumpVAC.dll"), &hHeap, &pMemory, &unFileSize)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `FileRead` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	if (!InjectLibrary(hProcess, pMemory, unFileSize, &LoaderData)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `InjectLibrary` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	tclrprintf(COLOR::COLOR_GREEN, _T("[+] Library injected!\n"));
	tclrprintf(COLOR::COLOR_GREEN, _T("[+]  > Base = 0x%08X\n"), reinterpret_cast<unsigned int>(LoaderData.m_pMemoryAddress));
	tclrprintf(COLOR::COLOR_GREEN, _T("[+]  > Size = 0x%08X\n"), LoaderData.m_unMemorySize);

	if (!HeapFree(hHeap, NULL, pMemory)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `HeapFree` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	return true;
}

BOOL WINAPI HandlerRoutine(DWORD dwCtrlType) {
	if (dwCtrlType == CTRL_C_EVENT) {
		g_bStop = true;

		if (g_bIsValidLaunch) {
			StopSteamService(g_hServiceManager, g_hService);
		} else {
			const DWORD unPID = GetPID(_T("steamservice.exe"));
			if (!unPID) {
				return TRUE;
			}

			const HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, unPID);
			if (!hProcess || (hProcess == INVALID_HANDLE_VALUE)) {
				return TRUE;
			}

			TerminateProcess(hProcess, EXIT_FAILURE);

			CloseHandle(hProcess);

			tclrprintf(COLOR::COLOR_YELLOW, _T("[i] Service terminated.\n"));
		}

		return TRUE;
	}
	return FALSE;
}

bool ConnectToSteamService() {

	tclrprintf(COLOR::COLOR_CYAN, _T("[i] Connecting to SteamService... "));

	unsigned char unCount = 0;
	HANDLE hPipe = INVALID_HANDLE_VALUE;
	while (!hPipe || (hPipe == INVALID_HANDLE_VALUE)) {
		if (unCount >= 30) {
			tclrprintf(COLOR::COLOR_RED, _T("[ FAIL ]\n"));
			return false;
		}
		++unCount;
		hPipe = CreateFile(_T("\\\\.\\pipe\\DumpVAC"), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
		Sleep(1000);
	}

	tclrprintf(COLOR::COLOR_GREEN, _T("[  OK  ]\n\n"));

	HANDLE hEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
	if (!hEvent || (hEvent == INVALID_HANDLE_VALUE)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `CreateEvent` (LastError = 0x%08X)\n"), GetLastError());
		return false;
	}

	OVERLAPPED ol;
	memset(&ol, 0, sizeof(ol));

	ol.hEvent = hEvent;

	CONSOLE_MESSAGE Message;

	bool bContinue = true;
	while (bContinue && !g_bStop) {
		bContinue = false;
		memset(&Message, 0, sizeof(Message));
		DWORD unNumberOfBytesRead = 0;
		if (!ReadFile(hPipe, &Message, sizeof(Message), &unNumberOfBytesRead, &ol)) {
			switch (GetLastError()) {
				case ERROR_HANDLE_EOF: {
					break;
				}
				case ERROR_IO_PENDING: {
					bool bPending = true;
					while (bPending && !g_bStop) {
						bPending = false;
						if (!GetOverlappedResult(hPipe, &ol, &unNumberOfBytesRead, FALSE)) {
							switch (GetLastError()) {
								case ERROR_HANDLE_EOF: {
									break;
								}
								case ERROR_IO_INCOMPLETE: {
									bPending = true;
									bContinue = true;
									break;
								}
							}
						} else {
							if (unNumberOfBytesRead == sizeof(CONSOLE_MESSAGE)) {
								Message.m_pMessage[sizeof(Message.m_pMessage) - 1] = '\0';
								if (strnlen_s(Message.m_pMessage, sizeof(Message.m_pMessage)) > 0) {
									clrprintf(Message.m_ColorPair, "%s", Message.m_pMessage);
								}
								ResetEvent(ol.hEvent);
							}
						}
						Sleep(5);
					}
					break;
				}
				default: {
					break;
				}
			}
		} else {
			Message.m_pMessage[sizeof(Message.m_pMessage) - 1] = '\0';
			if (strnlen_s(Message.m_pMessage, sizeof(Message.m_pMessage)) > 0) {
				clrprintf(Message.m_ColorPair, "%s", Message.m_pMessage);
			}
			bContinue = true;
		}
		Sleep(5);
	}

	tclrprintf(COLOR::COLOR_WHITE, _T("\n"));

	CloseHandle(hEvent);
	CloseHandle(hPipe);

	return true;
}

int _tmain() {
	Terminal SCU(true, true);

	if (SCU.Open()) {
		SCU.ChangeColorPalette(COLOR::COLOR_BLACK, 0x1B1B1B);
		SCU.ChangeColorPalette(COLOR::COLOR_DARK_BLUE, 0x2962FF);
		SCU.ChangeColorPalette(COLOR::COLOR_DARK_GREEN, 0x00C853);
		SCU.ChangeColorPalette(COLOR::COLOR_DARK_CYAN, 0x00B8D4);
		SCU.ChangeColorPalette(COLOR::COLOR_DARK_RED, 0xD50000);
		SCU.ChangeColorPalette(COLOR::COLOR_DARK_MAGENTA, 0xAA00FF);
		SCU.ChangeColorPalette(COLOR::COLOR_DARK_YELLOW, 0xFFD600);
		SCU.ChangeColorPalette(COLOR::COLOR_DARK_GRAY, 0x616161);
		SCU.ChangeColorPalette(COLOR::COLOR_GRAY, 0xEEEEEE);
		SCU.ChangeColorPalette(COLOR::COLOR_BLUE, 0x448AFF);
		SCU.ChangeColorPalette(COLOR::COLOR_GREEN, 0x69F0AE);
		SCU.ChangeColorPalette(COLOR::COLOR_CYAN, 0x18FFFF);
		SCU.ChangeColorPalette(COLOR::COLOR_RED, 0xFF5252);
		SCU.ChangeColorPalette(COLOR::COLOR_MAGENTA, 0xE040FB);
		SCU.ChangeColorPalette(COLOR::COLOR_YELLOW, 0xFFFF00);
		SCU.ChangeColorPalette(COLOR::COLOR_WHITE, 0xFAFAFA);

		tclrprintf(COLOR::COLOR_WHITE, _T("Console [Version 1.0.0] (zeze839@gmail.com)\n\n"));
	} else {
		return -1;
	}

	HANDLE hToken = nullptr;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `OpenProcessToken` (LastError = 0x%08X)\n"), GetLastError());
		return -1;
	}

	LUID luid;
	memset(&luid, 0, sizeof(luid));

	if (!LookupPrivilegeValue(nullptr, SE_DEBUG_NAME, &luid)) {
		CloseHandle(hToken);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `LookupPrivilegeValue` (LastError = 0x%08X)\n"), GetLastError());
		return -1;
	}

	TOKEN_PRIVILEGES tp;
	memset(&tp, 0, sizeof(tp));

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), nullptr, nullptr))	{
		CloseHandle(hToken);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `AdjustTokenPrivileges` (LastError = 0x%08X)\n"), GetLastError());
		return -1;
	}

	CloseHandle(hToken);

	const HMODULE hNTDLL = GetModuleHandle(_T("ntdll.dll"));
	if (!hNTDLL) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Not found NTDLL module.\n"));
		return -1;
	}

	NtResumeProcess = reinterpret_cast<fnNtResumeProcess>(GetProcAddress(hNTDLL, "NtResumeProcess"));
	if (!NtResumeProcess) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Not found NtResumeProcess API.\n"));
		return -1;
	}

	NtSuspendProcess = reinterpret_cast<fnNtSuspendProcess>(GetProcAddress(hNTDLL, "NtSuspendProcess"));
	if (!NtSuspendProcess) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Not found NtSuspendProcess API.\n"));
		return -1;
	}

	g_hServiceManager = OpenSCManager(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
	if (!g_hServiceManager) {
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `OpenSCManager` (LastError = 0x%08X)\n"), GetLastError());
		return -1;
	}

	g_hService = OpenService(g_hServiceManager, _T("Steam Client Service"), SERVICE_ALL_ACCESS);
	if (!g_hService) {
		CloseServiceHandle(g_hServiceManager);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `OpenService` (LastError = 0x%08X)\n"), GetLastError());
		return -1;
	}

	SetConsoleCtrlHandler(HandlerRoutine, TRUE);

	if (!StopSteamService(g_hServiceManager, g_hService)) {
		CloseServiceHandle(g_hService);
		CloseServiceHandle(g_hServiceManager);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `StopSteamService` (LastError = 0x%08X)\n"), GetLastError());
		return -1;
	}

	PRESTART_SERVICE_DATA pData = new RESTART_SERVICE_DATA;
	memset(pData, 0, sizeof(RESTART_SERVICE_DATA));

	pData->m_hServiceManager = g_hServiceManager;
	pData->m_hService = g_hService;

	const HANDLE hStartThread = CreateThread(nullptr, 0, StartServiceRoutine, reinterpret_cast<LPVOID>(pData), CREATE_SUSPENDED, nullptr);
	if (!hStartThread || (hStartThread == INVALID_HANDLE_VALUE)) {
		CloseServiceHandle(g_hService);
		CloseServiceHandle(g_hServiceManager);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `CreateThread` (LastError = 0x%08X)\n"), GetLastError());
		return -1;
	}

	ResumeThread(hStartThread);

	const DWORD64 unStartTime = GetTickCount64();
	DWORD unPID = GetPID(_T("steamservice.exe"));
	while (unPID == 0) {
		unPID = GetPID(_T("steamservice.exe"));

		if (GetTickCount64() - unStartTime > 5000) {
			break;
		}

		_mm_pause();
	}

	if (unPID == 0) {
		WaitForSingleObject(hStartThread, INFINITE);
		CloseHandle(hStartThread);
		CloseServiceHandle(g_hService);
		CloseServiceHandle(g_hServiceManager);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed to find service."));
		return -1;
	}

	const HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, unPID);
	if (!hProcess || (hProcess == INVALID_HANDLE_VALUE)) {
		WaitForSingleObject(hStartThread, INFINITE);
		CloseHandle(hStartThread);
		CloseServiceHandle(g_hService);
		CloseServiceHandle(g_hServiceManager);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `OpenProcess` (LastError = 0x%08X)\n"), GetLastError());
		return -1;
	}

	if (!NT_SUCCESS(NtSuspendProcess(hProcess))) {
		WaitForSingleObject(hStartThread, INFINITE);
		CloseHandle(hStartThread);
		CloseHandle(hProcess);
		CloseServiceHandle(g_hService);
		CloseServiceHandle(g_hServiceManager);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `NtSuspendProcess` (LastError = 0x%08X)\n"), GetLastError());
		return -1;
	}

	tclrprintf(COLOR::COLOR_GREEN, _T("[+] Found service!\n"));
	tclrprintf(COLOR::COLOR_GREEN, _T("[+]  > PID  = %lu\n"), unPID);

	if (!HackSteamService(hProcess)) {
		WaitForSingleObject(hStartThread, INFINITE);
		CloseHandle(hStartThread);
		CloseHandle(hProcess);
		CloseServiceHandle(g_hService);
		CloseServiceHandle(g_hServiceManager);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `HackSteamService`.\n"));
		return -1;
	}

	g_bIsValidLaunch = true;

	if (!ConnectToSteamService()) {
		WaitForSingleObject(hStartThread, INFINITE);
		CloseHandle(hStartThread);
		CloseHandle(hProcess);
		CloseServiceHandle(g_hService);
		CloseServiceHandle(g_hServiceManager);
		tclrprintf(COLOR::COLOR_RED, _T("[!] Failed `ConnectToSteamService` (LastError = 0x%08X)\n"), GetLastError());
		return -1;
	}

	WaitForSingleObject(hStartThread, INFINITE);
	CloseHandle(hStartThread);
	CloseHandle(hProcess);
	CloseServiceHandle(g_hService);
	CloseServiceHandle(g_hServiceManager);

	tclrprintf(COLOR::COLOR_WHITE, _T("\nPress ")); tclrprintf(COLOR::COLOR_CYAN, _T("<Enter>")); tclrprintf(COLOR::COLOR_WHITE, _T(" to exit.")); tclrscanf(COLOR::COLOR_WHITE, _T(""));
	return 0;
}

```

`Console/Console.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{dcde0b5e-c150-4d90-b502-67e4113a4ab0}</ProjectGuid>
    <RootNamespace>Console</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>./;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>./;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>./;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>./;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Console.cpp" />
    <ClCompile Include="ConsoleUtils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ConsoleUtils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Console/Console.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Исходные файлы">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Файлы заголовков">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Console.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
    <ClCompile Include="ConsoleUtils.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ConsoleUtils.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Console/ConsoleUtils.cpp`:

```cpp
#include "ConsoleUtils.h"

// ----------------------------------------------------------------
// ConsoleUtils
// ----------------------------------------------------------------
namespace ConsoleUtils {

	// ----------------------------------------------------------------
	// PipeServer
	// ----------------------------------------------------------------

	PipeServer::PipeServer(const DWORD unBufferSize) : m_unBufferSize(unBufferSize) {
		memset(m_szSessionName, 0, sizeof(m_szSessionName));
		m_hPipe = nullptr;

		if (!unBufferSize) {
			return;
		}

		const DWORD unPID = GetCurrentProcessId();
		const DWORD unTID = GetCurrentThreadId();
		const DWORD64 unCycle = __rdtsc();
		_stprintf_s(m_szSessionName, _T("GLOBAL:%08X:%08X:%08X%08X"), 0xFFFFFFFF - unPID, 0xFFFFFFFF - unTID, static_cast<DWORD>(unCycle & 0xFFFFFFFF), static_cast<DWORD>((unCycle >> 32) & 0xFFFFFFFF));

		TCHAR szPipe[64];
		memset(szPipe, 0, sizeof(szPipe));
		_stprintf_s(szPipe, _T("\\\\.\\pipe\\%s"), m_szSessionName);

		m_hPipe = CreateNamedPipe(szPipe, PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, 1, unBufferSize, unBufferSize, NMPWAIT_USE_DEFAULT_WAIT, nullptr);
	}

	PipeServer::~PipeServer() {
		if (m_hPipe && (m_hPipe != INVALID_HANDLE_VALUE)) {
			CloseHandle(m_hPipe);
		}
	}

	bool PipeServer::Listen() {
		if (!m_hPipe || (m_hPipe == INVALID_HANDLE_VALUE)) {
			return false;
		}

		if (!ConnectNamedPipe(m_hPipe, nullptr)) {
			return false;
		}

		return true;
	}

	bool PipeServer::Read(void* const pBuffer) {
		if (!m_hPipe || (m_hPipe == INVALID_HANDLE_VALUE)) {
			return false;
		}

		DWORD unNumberOfBytesRead = 0;
		if (!ReadFile(m_hPipe, pBuffer, m_unBufferSize, &unNumberOfBytesRead, nullptr)) {
			return false;
		}

		if (unNumberOfBytesRead != m_unBufferSize) {
			return false;
		}

		return true;
	}

	bool PipeServer::Write(void* const pBuffer) {
		if (!m_hPipe || (m_hPipe == INVALID_HANDLE_VALUE)) {
			return false;
		}

		DWORD unNumberOfBytesRead = 0;
		if (!WriteFile(m_hPipe, pBuffer, m_unBufferSize, &unNumberOfBytesRead, nullptr)) {
			return false;
		}

		if (unNumberOfBytesRead != m_unBufferSize) {
			return false;
		}

		return true;
	}

	bool PipeServer::GetSessionName(TCHAR szSessionName[64]) {
		if (!m_hPipe || (m_hPipe == INVALID_HANDLE_VALUE)) {
			return false;
		}

		memcpy(szSessionName, m_szSessionName, sizeof(m_szSessionName));

		return true;
	}

	HANDLE PipeServer::GetPipe() {
		if (!m_hPipe || (m_hPipe == INVALID_HANDLE_VALUE)) {
			return nullptr;
		}
		return m_hPipe;
	}

	// ----------------------------------------------------------------
	// PipeClient
	// ----------------------------------------------------------------

	PipeClient::PipeClient(const DWORD unBufferSize, TCHAR szSessionName[64]) : m_unBufferSize(unBufferSize) {
		m_hPipe = nullptr;

		if (!unBufferSize) {
			return;
		}

		if (!szSessionName) {
			return;
		}

		TCHAR szPipe[64];
		memset(szPipe, 0, sizeof(szPipe));
		_stprintf_s(szPipe, _T("\\\\.\\pipe\\%s"), szSessionName);

		m_hPipe = CreateFile(szPipe, GENERIC_READ | GENERIC_WRITE, NULL, nullptr, OPEN_EXISTING, NULL, nullptr);
	}

	PipeClient::~PipeClient() {
		if (m_hPipe && (m_hPipe != INVALID_HANDLE_VALUE)) {
			CloseHandle(m_hPipe);
		}
	}

	bool PipeClient::Read(void* const pBuffer) {
		if (!m_hPipe || (m_hPipe == INVALID_HANDLE_VALUE)) {
			return false;
		}

		DWORD unNumberOfBytesRead = 0;
		if (!ReadFile(m_hPipe, pBuffer, m_unBufferSize, &unNumberOfBytesRead, nullptr)) {
			return false;
		}

		if (unNumberOfBytesRead != m_unBufferSize) {
			return false;
		}

		return true;
	}

	bool PipeClient::Write(void* const pBuffer) {
		if (!m_hPipe || (m_hPipe == INVALID_HANDLE_VALUE)) {
			return false;
		}

		DWORD unNumberOfBytesRead = 0;
		if (!WriteFile(m_hPipe, pBuffer, m_unBufferSize, &unNumberOfBytesRead, nullptr)) {
			return false;
		}

		if (unNumberOfBytesRead != m_unBufferSize) {
			return false;
		}

		return true;
	}

	HANDLE PipeClient::GetPipe() {
		if (!m_hPipe || (m_hPipe == INVALID_HANDLE_VALUE)) {
			return nullptr;
		}
		return m_hPipe;
	}

	// ----------------------------------------------------------------
	// Console
	// ----------------------------------------------------------------

	Console::Console(bool bAutoClose) {
		m_bAutoClose = bAutoClose;
		m_hWindow = GetConsoleWindow();
		m_pIn = nullptr;
		m_pOut = nullptr;
		m_hIn = GetStdHandle(STD_INPUT_HANDLE);
		m_hOut = GetStdHandle(STD_OUTPUT_HANDLE);
		m_unOriginalMode = 0;
		m_nOriginalStyle = 0;
		m_nOriginalStyleEx = 0;
		if (m_hWindow) {
			setlocale(LC_ALL, "");

			if (m_hIn && (m_hIn != INVALID_HANDLE_VALUE)) {
				if (GetConsoleMode(m_hIn, &m_unOriginalMode)) {
					SetConsoleMode(m_hIn, m_unOriginalMode | ENABLE_INSERT_MODE);
				}
			}

			LONG nStyle = GetWindowLong(m_hWindow, GWL_STYLE);
			if (nStyle != 0) {
				m_nOriginalStyle = nStyle;
				SetWindowLong(m_hWindow, GWL_STYLE, nStyle & ~(WS_MAXIMIZEBOX | WS_MINIMIZEBOX));
			}

			LONG nStyleEx = GetWindowLong(m_hWindow, GWL_EXSTYLE);
			if (nStyleEx != 0) {
				m_nOriginalStyleEx = nStyleEx;
				SetWindowLong(m_hWindow, GWL_EXSTYLE, nStyleEx | WS_EX_LAYERED);
			}

			SetWindowPos(m_hWindow, nullptr, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOOWNERZORDER);
		}
	}

	Console::~Console() {
		if (m_bAutoClose) {
			Close();
		} else {
			if (m_nOriginalStyle != 0) {
				SetWindowLong(m_hWindow, GWL_STYLE, m_nOriginalStyle);
			}

			if (m_nOriginalStyleEx != 0) {
				SetWindowLong(m_hWindow, GWL_EXSTYLE, m_nOriginalStyleEx);
			}

			if (m_hIn && (m_hIn != INVALID_HANDLE_VALUE) && m_unOriginalMode) {
				SetConsoleMode(m_hIn, m_unOriginalMode);
			}
		}
	}

	bool Console::Open(bool bUpdateIO) {
		if (m_hWindow) {
			return true;
		}

		if (m_pIn) {
			if (_tfreopen_s(&m_pIn, _T("nul"), _T("r"), stdin)) {
				return false;
			}
			if (m_pIn) {
				fclose(m_pIn);
			}
			m_pIn = nullptr;
		}

		if (m_pOut) {
			if (_tfreopen_s(&m_pOut, _T("nul"), _T("w"), stdout)) {
				return false;
			}
			if (m_pOut) {
				fclose(m_pOut);
			}
			m_pOut = nullptr;
		}

		if (!AllocConsole()) {
			return false;
		}

		m_hWindow = GetConsoleWindow();
		if (!m_hWindow) {
			return false;
		}

		if (bUpdateIO) {
			if (_tfreopen_s(&m_pIn, _T("nul"), _T("r"), stdin)) {
				return false;
			}

			if (_tfreopen_s(&m_pOut, _T("nul"), _T("w"), stdout)) {
				return false;
			}
		}

		HANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);
		if (!hIn || (hIn == INVALID_HANDLE_VALUE)) {
			return false;
		}

		m_hIn = hIn;

		if (bUpdateIO) {
			int nInDescriptor = _open_osfhandle(reinterpret_cast<intptr_t>(hIn), _O_TEXT);
			if (nInDescriptor == -1) {
				return false;
			}

			FILE* pIn = _tfdopen(nInDescriptor, _T("r"));
			if (!pIn) {
				return false;
			}

			m_pIn = pIn;

			if (_dup2(_fileno(pIn), _fileno(stdin)) != 0) {
				return false;
			}

			if (setvbuf(stdin, nullptr, _IONBF, 0) != 0) {
				return false;
			}
		}

		HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
		if (!hOut || (hOut == INVALID_HANDLE_VALUE)) {
			return false;
		}

		m_hOut = hOut;

		if (bUpdateIO) {
			int nOutDescriptor = _open_osfhandle(reinterpret_cast<intptr_t>(hOut), _O_TEXT);
			if (nOutDescriptor == -1) {
				return false;
			}

			FILE* pOut = _tfdopen(nOutDescriptor, _T("w"));
			if (!pOut) {
				return false;
			}

			m_pOut = pOut;

			if (_dup2(_fileno(pOut), _fileno(stdout)) != 0) {
				return false;
			}

			if (setvbuf(stdout, nullptr, _IONBF, 0) != 0) {
				return false;
			}
		}

		setlocale(LC_ALL, "");

		if (GetConsoleMode(hIn, &m_unOriginalMode)) {
			SetConsoleMode(hIn, m_unOriginalMode | ENABLE_INSERT_MODE);
		}

		LONG nStyle = GetWindowLong(m_hWindow, GWL_STYLE);
		if (nStyle != 0) {
			m_nOriginalStyle = nStyle;
			nStyle &= ~WS_MAXIMIZEBOX;
			nStyle &= ~WS_MINIMIZEBOX;
			SetWindowLong(m_hWindow, GWL_STYLE, nStyle);
		}

		LONG nStyleEx = GetWindowLong(m_hWindow, GWL_EXSTYLE);
		if (nStyleEx != 0) {
			m_nOriginalStyleEx = nStyleEx;
			nStyleEx |= WS_EX_LAYERED;
			SetWindowLong(m_hWindow, GWL_EXSTYLE, nStyleEx);
		}

		SetWindowPos(m_hWindow, nullptr, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOOWNERZORDER);

		return true;
	}

	bool Console::Close() {
		if (!m_hWindow) {
			return false;
		}

		if (m_nOriginalStyle != 0) {
			SetWindowLong(m_hWindow, GWL_STYLE, m_nOriginalStyle);
		}

		if (m_nOriginalStyleEx != 0) {
			SetWindowLong(m_hWindow, GWL_EXSTYLE, m_nOriginalStyleEx);
		}

		if (m_hIn && (m_hIn != INVALID_HANDLE_VALUE) && m_unOriginalMode) {
			SetConsoleMode(m_hIn, m_unOriginalMode);
		}

		if (m_pIn) {
			if (_tfreopen_s(&m_pIn, _T("nul"), _T("r"), stdin)) {
				return false;
			}
			if (m_pIn) {
				fclose(m_pIn);
			}
			m_pIn = nullptr;
		}

		if (m_pOut) {
			if (_tfreopen_s(&m_pOut, _T("nul"), _T("w"), stdout)) {
				return false;
			}
			if (m_pOut) {
				fclose(m_pOut);
			}
			m_pOut = nullptr;
		}

		if (!FreeConsole()) {
			return false;
		}

		if (!DestroyWindow(m_hWindow)) {
			return false;
		}

		m_hWindow = nullptr;

		return true;
	}

	bool Console::Show() {
		if (!m_hWindow) {
			return false;
		}

		if (!ShowWindow(m_hWindow, SW_SHOW)) {
			return false;
		}

		return true;
	}

	bool Console::Hide() {
		if (!m_hWindow) {
			return false;
		}

		if (!ShowWindow(m_hWindow, SW_HIDE)) {
			return false;
		}

		return true;
	}

	bool Console::ReadA(char* const szBuffer, unsigned int unCount) {
		if (!m_hWindow) {
			return false;
		}

		if (!fgets(szBuffer, unCount, stdin)) {
			return false;
		}

		return true;
	}

	bool Console::ReadW(wchar_t* const szBuffer, unsigned int unCount) {
		if (!m_hWindow) {
			return false;
		}

		if (!fgetws(szBuffer, unCount, stdin)) {
			return false;
		}

		return true;
	}

#ifdef UNICODE
	bool Console::Read(wchar_t* const szBuffer, unsigned int unCount) {
		return ReadW(szBuffer, unCount);
	}
#else
	bool Console::Read(char* const szBuffer, unsigned int unCount) {
		return ReadA(szBuffer, unCount);
	}
#endif

	bool Console::WriteA(char const* const szBuffer) {
		if (!m_hWindow) {
			return false;
		}

		if (fputs(szBuffer, stdout) == EOF) {
			return false;
		}

		return true;
	}

	bool Console::WriteW(wchar_t const* const szBuffer) {
		if (!m_hWindow) {
			return false;
		}

		if (fputws(szBuffer, stdout) == EOF) {
			return false;
		}

		return true;
	}

#ifdef UNICODE
	bool Console::Write(wchar_t const* const szBuffer) {
		return WriteW(szBuffer);
	}
#else
	bool Console::Write(char const* const szBuffer) {
		return WriteA(szBuffer);
	}
#endif

	HWND Console::GetWindow() {
		return m_hWindow;
	}

	HANDLE Console::GetIn() {
		if (m_hIn == INVALID_HANDLE_VALUE) {
			return nullptr;
		}
		return m_hIn;
	}

	HANDLE Console::GetOut() {
		if (m_hOut == INVALID_HANDLE_VALUE) {
			return nullptr;
		}
		return m_hOut;
	}

	// ----------------------------------------------------------------
	// Terminal
	// ----------------------------------------------------------------

	Terminal::Terminal(bool bAutoClose, bool bAutoRestoreColors) : Console(bAutoClose) {
		HWND hWindow = GetWindow();
		HANDLE hOut = GetOut();

		m_bAutoRestoreColors = bAutoRestoreColors;

		for (unsigned char i = 0; i < 16; ++i) {
			m_OriginalColorTable[i] = 0x00000000;
		}

		if (bAutoRestoreColors && hWindow && hOut) {
			GetColor(&m_OriginalColorPair);
			GetCursorColor(&m_OriginalCursorColorPair);

			CONSOLE_SCREEN_BUFFER_INFOEX csbi;
			if (GetBufferInfo(&csbi)) {
				for (unsigned char i = 0; i < 16; ++i) {
					m_OriginalColorTable[i] = csbi.ColorTable[i];
				}
			}
		}
	}

	Terminal::~Terminal() {
		if (m_bAutoRestoreColors && GetWindow() && GetOut()) {
			CONSOLE_SCREEN_BUFFER_INFOEX csbi;
			if (GetBufferInfo(&csbi)) {
				for (unsigned char i = 0; i < 16; ++i) {
					csbi.ColorTable[i] = m_OriginalColorTable[i];
				}
				SetBufferInfo(csbi);
			}
			SetColor(m_OriginalColorPair);
			SetCursorColor(m_OriginalCursorColorPair);
		}
	}

	bool Terminal::Open(bool bUpdateIO) {
		if (!Console::Open(bUpdateIO)) {
			return false;
		}

		HWND hWindow = GetWindow();
		HANDLE hOut = GetOut();

		m_OriginalColorPair = COLOR_PAIR();
		if (m_bAutoRestoreColors && hWindow && hOut) {
			GetColor(&m_OriginalColorPair);
		}

		m_OriginalCursorColorPair = COLOR_PAIR();
		if (m_bAutoRestoreColors && hWindow && hOut) {
			GetCursorColor(&m_OriginalCursorColorPair);
		}

		m_PreviousColorPair = COLOR_PAIR();
		m_PreviousCursorColorPair = COLOR_PAIR();

		for (unsigned char i = 0; i < 16; ++i) {
			m_OriginalColorTable[i] = 0x00000000;
		}

		if (m_bAutoRestoreColors && hWindow && hOut) {
			CONSOLE_SCREEN_BUFFER_INFOEX csbi;
			if (GetBufferInfo(&csbi)) {
				for (unsigned char i = 0; i < 16; ++i) {
					m_OriginalColorTable[i] = csbi.ColorTable[i];
				}
			}
		}

		return true;
	}

	bool Terminal::Close() {
		if (m_bAutoRestoreColors && GetWindow() && GetOut()) {
			CONSOLE_SCREEN_BUFFER_INFOEX csbi;
			if (GetBufferInfo(&csbi)) {
				for (unsigned char i = 0; i < 16; ++i) {
					csbi.ColorTable[i] = m_OriginalColorTable[i];
				}
				SetBufferInfo(csbi);
			}
			SetColor(m_OriginalColorPair);
			SetCursorColor(m_OriginalCursorColorPair);
		}

		return Console::Close();
	}

	bool Terminal::GetBufferInfo(PCONSOLE_SCREEN_BUFFER_INFOEX pBufferInfo) {
		if (!pBufferInfo) {
			return false;
		}

		if (!GetWindow()) {
			return false;
		}

		HANDLE hOut = GetOut();
		if (!hOut) {
			return false;
		}

		memset(pBufferInfo, 0, sizeof(CONSOLE_SCREEN_BUFFER_INFOEX));
		pBufferInfo->cbSize = sizeof(CONSOLE_SCREEN_BUFFER_INFOEX);

		if (!GetConsoleScreenBufferInfoEx(hOut, pBufferInfo)) {
			return false;
		}

		return true;
	}

	bool Terminal::SetBufferInfo(CONSOLE_SCREEN_BUFFER_INFOEX BufferInfo) {
		if (!GetWindow()) {
			return false;
		}

		HANDLE hOut = GetOut();
		if (!hOut) {
			return false;
		}

		++BufferInfo.srWindow.Bottom;
		++BufferInfo.srWindow.Right;

		if (!SetConsoleScreenBufferInfoEx(hOut, &BufferInfo)) {
			return false;
		}

		--BufferInfo.srWindow.Bottom;
		--BufferInfo.srWindow.Right;

		return true;
	}

	bool Terminal::GetAttributes(PWORD pAttributes) {
		if (!pAttributes) {
			return false;
		}

		CONSOLE_SCREEN_BUFFER_INFOEX csbi;
		if (!GetBufferInfo(&csbi)) {
			return false;
		}

		*pAttributes = csbi.wAttributes;

		return true;
	}

	bool Terminal::SetAttributes(WORD unAttributes) {
		if (!GetWindow()) {
			return false;
		}

		HANDLE hOut = GetOut();
		if (!hOut) {
			return false;
		}

		if (!SetConsoleTextAttribute(hOut, unAttributes)) {
			return false;
		}

		return true;
	}

	bool Terminal::ChangeColorPalette(COLOR Color, unsigned int unRGB) {
		if (static_cast<unsigned char>(Color) > 15) {
			return false;
		}

		CONSOLE_SCREEN_BUFFER_INFOEX csbi;
		if (!GetBufferInfo(&csbi)) {
			return false;
		}

		unsigned char unR = (unRGB >> 16) & 0xFF;
		unsigned char unG = (unRGB >> 8) & 0xFF;
		unsigned char unB = unRGB & 0xFF;

		csbi.ColorTable[static_cast<unsigned char>(Color)] = RGB(unR, unG, unB);

		if (!SetBufferInfo(csbi)) {
			return false;
		}

		return true;
	}

	bool Terminal::ChangeColorPalette(COLOR Color, unsigned char unR, unsigned char unG, unsigned char unB) {
		if (static_cast<unsigned char>(Color) > 15) {
			return false;
		}

		CONSOLE_SCREEN_BUFFER_INFOEX csbi;
		if (!GetBufferInfo(&csbi)) {
			return false;
		}

		csbi.ColorTable[static_cast<unsigned char>(Color)] = RGB(unR, unG, unB);

		if (!SetBufferInfo(csbi)) {
			return false;
		}

		return true;
	}

	bool Terminal::Flush(bool bClear, bool bUpdateOriginalColorPair, bool bResetPreviousColorPair) {
		if (!GetWindow()) {
			return false;
		}

		HANDLE hOut = GetOut();
		if (!hOut) {
			return false;
		}

		CONSOLE_SCREEN_BUFFER_INFOEX csbi;
		if (!GetBufferInfo(&csbi)) {
			return false;
		}

		if (bClear) {
			SMALL_RECT Scroll;
			Scroll.Left = 0;
			Scroll.Top = 0;
			Scroll.Right = csbi.dwSize.X;
			Scroll.Bottom = csbi.dwSize.Y;

			COORD ScrollTarget;
			memset(&ScrollTarget, 0, sizeof(ScrollTarget));

			ScrollTarget.X = 0;
			ScrollTarget.Y = -csbi.dwSize.Y;

			CHAR_INFO Fill;
			memset(&Fill, 0, sizeof(Fill));
#ifdef UNICODE
			Fill.Char.UnicodeChar = L' ';
#else
			Fill.Char.AsciiChar = ' ';
#endif
			Fill.Attributes = csbi.wAttributes;

			if (!ScrollConsoleScreenBuffer(hOut, &Scroll, nullptr, ScrollTarget, &Fill)) {
				return false;
			}

			csbi.dwCursorPosition.X = 0;
			csbi.dwCursorPosition.Y = 0;

			if (!SetConsoleCursorPosition(hOut, csbi.dwCursorPosition)) {
				return false;
			}
		}

		COORD Coord;
		Coord.X = 0;
		Coord.Y = 0;
		DWORD unWrittenAttributes = 0;
		if (!FillConsoleOutputAttribute(hOut, csbi.wAttributes, csbi.dwSize.Y * csbi.dwSize.X, Coord, &unWrittenAttributes)) {
			return false;
		}

		if (bUpdateOriginalColorPair) {
			COLOR_PAIR CurrentColorPair;
			if (!GetColor(&CurrentColorPair)) {
				m_OriginalColorPair = CurrentColorPair;
			}
		}

		if (bResetPreviousColorPair) {
			m_PreviousColorPair = COLOR_PAIR();
		}

		return true;
	}

	bool Terminal::GetColor(PCOLOR_PAIR pColorPair) {
		if (!pColorPair) {
			return false;
		}

		WORD unAttributes = 0;
		if (!GetAttributes(&unAttributes)) {
			return false;
		}

		*pColorPair = COLOR_PAIR(static_cast<COLOR>((unAttributes & 0xF0) >> 4), static_cast<COLOR>(unAttributes & 0x0F));

		return true;
	}

	bool Terminal::SetColor(COLOR_PAIR ColorPair) {
		if (!GetWindow()) {
			return false;
		}

		HANDLE hOut = GetOut();
		if (!hOut) {
			return false;
		}

		WORD unAttributes = 0;
		if (!GetAttributes(&unAttributes)) {
			return false;
		}

		COLOR_PAIR CurrentColorPair(static_cast<COLOR>((unAttributes & 0xF0) >> 4), static_cast<COLOR>(unAttributes & 0x0F));

		if (ColorPair.m_unColorBackground != COLOR::COLOR_UNKNOWN) {
			unAttributes = static_cast<unsigned char>((static_cast<unsigned char>(ColorPair.m_unColorBackground) & 0x0F) << 4);
		} else {
			unAttributes = static_cast<unsigned char>(CurrentColorPair.m_unColorBackground);
		}

		if (ColorPair.m_unColorForeground != COLOR::COLOR_UNKNOWN) {
			unAttributes |= static_cast<unsigned char>((static_cast<unsigned char>(ColorPair.m_unColorForeground) & 0x0F));
		} else {
			unAttributes |= static_cast<unsigned char>(CurrentColorPair.m_unColorForeground);
		}

		m_PreviousColorPair = CurrentColorPair;

		CONSOLE_SCREEN_BUFFER_INFOEX csbi;
		if (!GetBufferInfo(&csbi)) {
			return false;
		}

		COORD Coord;
		Coord.X = 0;
		Coord.Y = 0;
		DWORD unWrittenAttributes = 0;
		if (!FillConsoleOutputAttribute(hOut, unAttributes, csbi.dwSize.Y * csbi.dwSize.X, Coord, &unWrittenAttributes)) {
			return false;
		}

		return true;
	}

	bool Terminal::RestoreColor(bool bRestorePrevious) {
		if (bRestorePrevious) {
			return SetColor(m_PreviousColorPair);
		}
		return SetColor(m_OriginalColorPair);
	}

	bool Terminal::GetCursorInfo(PCONSOLE_CURSOR_INFO pCursorInfo) {
		if (!pCursorInfo) {
			return false;
		}

		if (!GetWindow()) {
			return false;
		}

		HANDLE hOut = GetOut();
		if (!hOut) {
			return false;
		}

		memset(pCursorInfo, 0, sizeof(CONSOLE_CURSOR_INFO));

		if (!GetConsoleCursorInfo(hOut, pCursorInfo)) {
			return false;
		}

		return true;
	}

	bool Terminal::SetCursorInfo(CONSOLE_CURSOR_INFO CursorInfo) {
		if (!GetWindow()) {
			return false;
		}

		HANDLE hOut = GetOut();
		if (!hOut) {
			return false;
		}

		if (!SetConsoleCursorInfo(hOut, &CursorInfo)) {
			return false;
		}

		return true;
	}

	bool Terminal::GetCursorPosition(PCOORD pCursorPosition) {
		if (!pCursorPosition) {
			return false;
		}

		CONSOLE_SCREEN_BUFFER_INFOEX csbi;
		if (!GetBufferInfo(&csbi)) {
			return false;
		}

		pCursorPosition->X = csbi.dwCursorPosition.X;
		pCursorPosition->Y = csbi.dwCursorPosition.Y;

		return true;
	}

	bool Terminal::SetCursorPosition(COORD CursorPosition) {
		if (!GetWindow()) {
			return false;
		}

		HANDLE hOut = GetOut();
		if (!hOut) {
			return false;
		}

		if (!SetConsoleCursorPosition(hOut, CursorPosition)) {
			return false;
		}

		return true;
	}

	bool Terminal::ShowCursor() {
		CONSOLE_CURSOR_INFO cci;
		if (!GetCursorInfo(&cci)) {
			return false;
		}

		cci.bVisible = TRUE;

		if (!SetCursorInfo(cci)) {
			return false;
		}

		return true;
	}

	bool Terminal::HideCursor() {
		CONSOLE_CURSOR_INFO cci;
		if (!GetCursorInfo(&cci)) {
			return false;
		}

		cci.bVisible = FALSE;

		if (!SetCursorInfo(cci)) {
			return false;
		}

		return true;
	}

	bool Terminal::ToggleCursor() {
		CONSOLE_CURSOR_INFO cci;
		if (!GetCursorInfo(&cci)) {
			return false;
		}

		cci.bVisible = (cci.bVisible & 1) == 0;

		if (!SetCursorInfo(cci)) {
			return false;
		}

		return true;
	}

	bool Terminal::GetCursorColor(PCOLOR_PAIR pColorPair) {
		return GetColor(pColorPair);
	}

	bool Terminal::SetCursorColor(COLOR_PAIR ColorPair) {
		WORD unAttributes = 0;
		if (!GetAttributes(&unAttributes)) {
			return false;
		}

		COLOR_PAIR CurrentColorPair(static_cast<COLOR>((unAttributes & 0xF0) >> 4), static_cast<COLOR>(unAttributes & 0x0F));

		if (ColorPair.m_unColorBackground != COLOR::COLOR_UNKNOWN) {
			unAttributes = static_cast<unsigned char>((static_cast<unsigned char>(ColorPair.m_unColorBackground) & 0x0F) << 4);
		} else {
			unAttributes = static_cast<unsigned char>(CurrentColorPair.m_unColorBackground);
		}

		if (ColorPair.m_unColorForeground != COLOR::COLOR_UNKNOWN) {
			unAttributes |= static_cast<unsigned char>((static_cast<unsigned char>(ColorPair.m_unColorForeground) & 0x0F));
		} else {
			unAttributes |= static_cast<unsigned char>(CurrentColorPair.m_unColorForeground);
		}

		m_PreviousCursorColorPair = CurrentColorPair;

		if (!SetAttributes(unAttributes)) {
			return false;
		}

		return true;
	}

	bool Terminal::RestoreCursorColor(bool bRestorePrevious) {
		if (bRestorePrevious) {
			return SetCursorColor(m_PreviousCursorColorPair);
		}
		return SetCursorColor(m_OriginalCursorColorPair);
	}

	bool Terminal::Erase(COORD CursorPosition, unsigned int unLength) {
		if (!GetWindow()) {
			return false;
		}

		HANDLE hOut = GetOut();
		if (!hOut) {
			return false;
		}

		DWORD unWrittenAttributes = 0;
		if (!FillConsoleOutputCharacter(hOut, _T(' '), unLength, CursorPosition, &unWrittenAttributes)) {
			return false;
		}

		WORD unAttributes = 0;
		if (!GetAttributes(&unAttributes)) {
			return false;
		}

		unWrittenAttributes = 0;
		if (!FillConsoleOutputAttribute(hOut, unAttributes, unLength, CursorPosition, &unWrittenAttributes)) {
			return false;
		}

		return true;
	}

	// ----------------------------------------------------------------
	// print/scan with format and color support
	// ----------------------------------------------------------------

	int clrvprintf(COLOR_PAIR ColorPair, char const* const _Format, va_list vargs) {
		HANDLE hHeap = GetProcessHeap();
		if (!hHeap) {
			return -1;
		}

		char* pBuffer = reinterpret_cast<char*>(HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(char) * 8192));
		if (!pBuffer) {
			return -1;
		}

		Terminal SCU;

		if (!SCU.SetCursorColor(ColorPair)) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		int nLength = vsprintf_s(pBuffer, 8192, _Format, vargs);
		if (nLength == -1) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		pBuffer[8191] = 0;
		if (!SCU.WriteA(pBuffer)) {
			SCU.RestoreCursorColor(true);
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		if (!SCU.RestoreCursorColor(true)) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		HeapFree(hHeap, NULL, pBuffer);
		return nLength;
	}

	int clrvprintf(COLOR unForegroundColor, char const* const _Format, va_list vargs) {
		return clrvprintf(COLOR_PAIR(unForegroundColor), _Format, vargs);
	}

	int clrprintf(COLOR_PAIR ColorPair, char const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = clrvprintf(ColorPair, _Format, vargs);
		va_end(vargs);
		return nLength;
	}

	int clrprintf(COLOR unForegroundColor, char const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = clrvprintf(unForegroundColor, _Format, vargs);
		va_end(vargs);
		return nLength;
	}

	int clrvwprintf(COLOR_PAIR ColorPair, wchar_t const* const _Format, va_list vargs) {
		HANDLE hHeap = GetProcessHeap();
		if (!hHeap) {
			return -1;
		}

		wchar_t* pBuffer = reinterpret_cast<wchar_t*>(HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(wchar_t) * 8192));
		if (!pBuffer) {
			return -1;
		}

		Terminal SCU;

		if (!SCU.SetCursorColor(ColorPair)) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		int nLength = vswprintf_s(pBuffer, 8192, _Format, vargs);
		if (nLength == -1) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		pBuffer[8191] = 0;
		if (!SCU.WriteW(pBuffer)) {
			SCU.RestoreCursorColor(true);
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		if (!SCU.RestoreCursorColor(true)) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		HeapFree(hHeap, NULL, pBuffer);
		return nLength;
	}

	int clrvwprintf(COLOR unForegroundColor, wchar_t const* const _Format, va_list vargs) {
		return clrvwprintf(COLOR_PAIR(unForegroundColor), _Format, vargs);
	}

	int clrwprintf(COLOR_PAIR ColorPair, wchar_t const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = clrvwprintf(ColorPair, _Format, vargs);
		va_end(vargs);
		return nLength;
	}

	int clrwprintf(COLOR unForegroundColor, wchar_t const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = clrvwprintf(unForegroundColor, _Format, vargs);
		va_end(vargs);
		return nLength;
	}

#ifdef UNICODE
	int tclrvprintf(COLOR_PAIR ColorPair, wchar_t const* const _Format, va_list vargs) {
		return clrvwprintf(ColorPair, _Format, vargs);
	}

	int tclrvprintf(COLOR unForegroundColor, wchar_t const* const _Format, va_list vargs) {
		return clrvwprintf(unForegroundColor, _Format, vargs);
	}

	int tclrprintf(COLOR_PAIR ColorPair, wchar_t const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = tclrvprintf(ColorPair, _Format, vargs);
		va_end(vargs);
		return nLength;
	}

	int tclrprintf(COLOR unForegroundColor, wchar_t const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = tclrvprintf(unForegroundColor, _Format, vargs);
		va_end(vargs);
		return nLength;
	}
#else
	int tclrvprintf(COLOR_PAIR ColorPair, char const* const _Format, va_list vargs) {
		return clrvprintf(ColorPair, _Format, vargs);
	}

	int tclrvprintf(COLOR unForegroundColor, char const* const _Format, va_list vargs) {
		return clrvprintf(unForegroundColor, _Format, vargs);
	}

	int tclrprintf(COLOR_PAIR ColorPair, char const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = tclrvprintf(ColorPair, _Format, vargs);
		va_end(vargs);
		return nLength;
	}

	int tclrprintf(COLOR unForegroundColor, char const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = tclrvprintf(unForegroundColor, _Format, vargs);
		va_end(vargs);
		return nLength;
	}
#endif

	int clrvscanf(COLOR_PAIR ColorPair, char const* const _Format, va_list vargs) {
		HANDLE hHeap = GetProcessHeap();
		if (!hHeap) {
			return -1;
		}

		char* pBuffer = reinterpret_cast<char*>(HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(char) * 8192));
		if (!pBuffer) {
			return -1;
		}

		Terminal SCU;

		if (!SCU.SetCursorColor(ColorPair)) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		if (!SCU.ReadA(pBuffer, 8191)) {
			SCU.RestoreCursorColor(true);
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		int nLength = vsscanf_s(pBuffer, _Format, vargs);
		if (nLength == -1) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		if (!SCU.RestoreCursorColor(true)) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		HeapFree(hHeap, NULL, pBuffer);
		return nLength;
	}

	int clrvscanf(COLOR unForegroundColor, char const* const _Format, va_list vargs) {
		return clrvscanf(COLOR_PAIR(unForegroundColor), _Format, vargs);
	}

	int clrscanf(COLOR_PAIR ColorPair, char const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = clrvscanf(ColorPair, _Format, vargs);
		va_end(vargs);
		return nLength;
	}

	int clrscanf(COLOR unForegroundColor, char const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = clrvscanf(COLOR_PAIR(unForegroundColor), _Format, vargs);
		va_end(vargs);
		return nLength;
	}

	int clrvwscanf(COLOR_PAIR ColorPair, wchar_t const* const _Format, va_list vargs) {
		HANDLE hHeap = GetProcessHeap();
		if (!hHeap) {
			return -1;
		}

		wchar_t* pBuffer = reinterpret_cast<wchar_t*>(HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(wchar_t) * 8192));
		if (!pBuffer) {
			return -1;
		}

		Terminal SCU;

		if (!SCU.SetCursorColor(ColorPair)) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		if (!SCU.ReadW(pBuffer, 8191)) {
			SCU.RestoreCursorColor(true);
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		int nLength = vswscanf_s(pBuffer, _Format, vargs);
		if (nLength == -1) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		if (!SCU.RestoreCursorColor(true)) {
			HeapFree(hHeap, NULL, pBuffer);
			return -1;
		}

		HeapFree(hHeap, NULL, pBuffer);
		return nLength;
	}

	int clrvwscanf(COLOR unForegroundColor, wchar_t const* const _Format, va_list vargs) {
		return clrvwscanf(COLOR_PAIR(unForegroundColor), _Format, vargs);
	}

	int clrwscanf(COLOR_PAIR ColorPair, wchar_t const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = clrvwscanf(ColorPair, _Format, vargs);
		va_end(vargs);
		return nLength;
	}

	int clrwscanf(COLOR unForegroundColor, wchar_t const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = clrvwscanf(COLOR_PAIR(unForegroundColor), _Format, vargs);
		va_end(vargs);
		return nLength;
	}

#ifdef UNICODE
	int tclrvscanf(COLOR_PAIR ColorPair, wchar_t const* const _Format, va_list vargs) {
		return clrvwscanf(ColorPair, _Format, vargs);
	}

	int tclrvscanf(COLOR unForegroundColor, wchar_t const* const _Format, va_list vargs) {
		return clrvwscanf(unForegroundColor, _Format, vargs);
	}

	int tclrscanf(COLOR_PAIR ColorPair, wchar_t const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = tclrvscanf(ColorPair, _Format, vargs);
		va_end(vargs);
		return nLength;
	}

	int tclrscanf(COLOR unForegroundColor, wchar_t const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = tclrvscanf(unForegroundColor, _Format, vargs);
		va_end(vargs);
		return nLength;
	}
#else
	int tclrvscanf(COLOR_PAIR ColorPair, char const* const _Format, va_list vargs) {
		return clrvscanf(ColorPair, _Format, vargs);
	}

	int tclrvscanf(COLOR unForegroundColor, char const* const _Format, va_list vargs) {
		return clrvscanf(unForegroundColor, _Format, vargs);
	}

	int tclrscanf(COLOR_PAIR ColorPair, char const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = tclrvscanf(ColorPair, _Format, vargs);
		va_end(vargs);
		return nLength;
	}

	int tclrscanf(COLOR unForegroundColor, char const* const _Format, ...) {
		va_list vargs;
		va_start(vargs, _Format);
		int nLength = tclrvscanf(unForegroundColor, _Format, vargs);
		va_end(vargs);
		return nLength;
	}
#endif
}

```

`Console/ConsoleUtils.h`:

```h
#pragma once

#ifndef _CONSOLEUTILS_H_
#define _CONSOLEUTILS_H_

// Default
#include <Windows.h>
#include <tchar.h>

// C
#include <io.h>
#include <fcntl.h>

// C++
#include <clocale>
#include <cstdio>
#include <cmath>

// STL
#include <vector>

// ----------------------------------------------------------------
// ConsoleUtils
// ----------------------------------------------------------------
namespace ConsoleUtils {
	// ----------------------------------------------------------------
	// PipeServer
	// ----------------------------------------------------------------

	class PipeServer {
	public:
		PipeServer(const DWORD unBufferSize);
		~PipeServer();

	public:
		bool Listen();
		bool Read(void* const pBuffer);
		bool Write(void* const pBuffer);

	public:
		bool GetSessionName(TCHAR szSessionName[64]);
		HANDLE GetPipe();

	private:
		const DWORD m_unBufferSize;
		TCHAR m_szSessionName[64];
		HANDLE m_hPipe;
	};

	// ----------------------------------------------------------------
	// PipeClient
	// ----------------------------------------------------------------

	class PipeClient {
	public:
		PipeClient(const DWORD unBufferSize, TCHAR szSessionName[64]);
		~PipeClient();

	public:
		bool Read(void* const pBuffer);
		bool Write(void* const pBuffer);

	public:
		HANDLE GetPipe();

	private:
		const DWORD m_unBufferSize;
		HANDLE m_hPipe;
	};

	// ----------------------------------------------------------------
	// Console
	// ----------------------------------------------------------------

	class Console {
	public:
		Console(bool bAutoClose = false);
		~Console();
	public:
		// Control
		bool Open(bool bUpdateIO = false);
		bool Close();
		bool Show();
		bool Hide();
	public:
		// IO
		bool ReadA(char* const szBuffer, unsigned int unCount);
		bool ReadW(wchar_t* const szBuffer, unsigned int unCount);
#ifdef UNICODE
		bool Read(wchar_t* const szBuffer, unsigned int unCount);
#else
		bool Read(char* const szBuffer, unsigned int unCount);
#endif
		bool WriteA(char const* const szBuffer);
		bool WriteW(wchar_t const* const szBuffer);
#ifdef UNICODE
		bool Write(wchar_t const* const szBuffer);
#else
		bool Write(char const* const szBuffer);
#endif
	public:
		// Properties
		HWND GetWindow();
		HANDLE GetIn();
		HANDLE GetOut();
	private:
		bool m_bAutoClose;
		HWND m_hWindow;
		FILE* m_pIn;
		FILE* m_pOut;
		HANDLE m_hIn;
		HANDLE m_hOut;
		DWORD m_unOriginalMode;
		LONG m_nOriginalStyle;
		LONG m_nOriginalStyleEx;
	};

	// ----------------------------------------------------------------
	// Colors
	// ----------------------------------------------------------------

	typedef enum class _COLOR : unsigned char {
		COLOR_BLACK = 0,
		COLOR_DARK_BLUE = FOREGROUND_BLUE,
		COLOR_DARK_GREEN = FOREGROUND_GREEN,
		COLOR_DARK_CYAN = FOREGROUND_GREEN | FOREGROUND_BLUE,
		COLOR_DARK_RED = FOREGROUND_RED,
		COLOR_DARK_MAGENTA = FOREGROUND_RED | FOREGROUND_BLUE,
		COLOR_DARK_YELLOW = FOREGROUND_RED | FOREGROUND_GREEN,
		COLOR_DARK_GRAY = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
		COLOR_GRAY = FOREGROUND_INTENSITY,
		COLOR_BLUE = FOREGROUND_INTENSITY | FOREGROUND_BLUE,
		COLOR_GREEN = FOREGROUND_INTENSITY | FOREGROUND_GREEN,
		COLOR_CYAN = FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_BLUE,
		COLOR_RED = FOREGROUND_INTENSITY | FOREGROUND_RED,
		COLOR_MAGENTA = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_BLUE,
		COLOR_YELLOW = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN,
		COLOR_WHITE = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
		COLOR_UNKNOWN = 0xFF
	} COLOR, *PCOLOR;

	typedef struct _COLOR_PAIR {
	public:
		_COLOR_PAIR() {
			m_unColorBackground = COLOR::COLOR_UNKNOWN;
			m_unColorForeground = COLOR::COLOR_UNKNOWN;
		}

		_COLOR_PAIR(COLOR unColorBackground, COLOR unColorForeground) {
			m_unColorBackground = unColorBackground;
			m_unColorForeground = unColorForeground;
		}

		_COLOR_PAIR(COLOR unColorForeground) {
			m_unColorBackground = COLOR::COLOR_UNKNOWN;
			m_unColorForeground = unColorForeground;
		}

	public:
		COLOR m_unColorBackground;
		COLOR m_unColorForeground;
	} COLOR_PAIR, *PCOLOR_PAIR;

	// ----------------------------------------------------------------
	// Terminal
	// ----------------------------------------------------------------

	class Terminal : public Console {
	public:
		Terminal(bool bAutoClose = false, bool bAutoRestoreColors = false);
		~Terminal();
	public:
		// Control
		bool Open(bool bUpdateIO = false);
		bool Close();
	public:
		// Buffer
		bool GetBufferInfo(PCONSOLE_SCREEN_BUFFER_INFOEX pBufferInfoEx);
		bool SetBufferInfo(CONSOLE_SCREEN_BUFFER_INFOEX BufferInfoEx);
		bool GetAttributes(PWORD pAttributes);
		bool SetAttributes(WORD unAttributes);
		bool ChangeColorPalette(COLOR Color, unsigned int unRGB);
		bool ChangeColorPalette(COLOR Color, unsigned char unR, unsigned char unG, unsigned char unB);
		// Screen
		bool Flush(bool bClear = false, bool bUpdateOriginalColorPair = false, bool bResetPreviousColorPair = false);
		bool GetColor(PCOLOR_PAIR pColorPair);
		bool SetColor(COLOR_PAIR ColorPair);
		bool RestoreColor(bool bRestorePrevious = false);
		// Cursor
		bool GetCursorInfo(PCONSOLE_CURSOR_INFO pCursorInfo);
		bool SetCursorInfo(CONSOLE_CURSOR_INFO CursorInfo);
		bool GetCursorPosition(PCOORD pCursorPosition);
		bool SetCursorPosition(COORD CursorPosition);
		bool ShowCursor();
		bool HideCursor();
		bool ToggleCursor();
		bool GetCursorColor(PCOLOR_PAIR pColorPair);
		bool SetCursorColor(COLOR_PAIR ColorPair);
		bool RestoreCursorColor(bool bRestorePrevious = false);
		// Advanced
		bool Erase(COORD CursorPosition, unsigned int unLength);
	private:
		bool m_bAutoRestoreColors;
		COLOR_PAIR m_OriginalColorPair;
		COLOR_PAIR m_OriginalCursorColorPair;
		COLOR_PAIR m_PreviousColorPair;
		COLOR_PAIR m_PreviousCursorColorPair;
		COLORREF m_OriginalColorTable[16];
	};

	// ----------------------------------------------------------------
	// print/scan with format and color support
	// ----------------------------------------------------------------

	int clrvprintf(COLOR_PAIR ColorPair, char const* const _Format, va_list vargs);
	int clrvprintf(COLOR unForegroundColor, char const* const _Format, va_list vargs);
	int clrprintf(COLOR_PAIR ColorPair, char const* const _Format, ...);
	int clrprintf(COLOR unForegroundColor, char const* const _Format, ...);

	int clrvwprintf(COLOR_PAIR ColorPair, wchar_t const* const _Format, va_list vargs);
	int clrvwprintf(COLOR unForegroundColor, wchar_t const* const _Format, va_list vargs);
	int clrwprintf(COLOR_PAIR ColorPair, wchar_t const* const _Format, ...);
	int clrwprintf(COLOR unForegroundColor, wchar_t const* const _Format, ...);

#ifdef UNICODE
	int tclrvprintf(COLOR_PAIR ColorPair, wchar_t const* const _Format, va_list vargs);
	int tclrvprintf(COLOR unForegroundColor, wchar_t const* const _Format, va_list vargs);
	int tclrprintf(COLOR_PAIR ColorPair, wchar_t const* const _Format, ...);
	int tclrprintf(COLOR unForegroundColor, wchar_t const* const _Format, ...);
#else
	int tclrvprintf(COLOR_PAIR ColorPair, char const* const _Format, va_list vargs);
	int tclrvprintf(COLOR unForegroundColor, char const* const _Format, va_list vargs);
	int tclrprintf(COLOR_PAIR ColorPair, char const* const _Format, ...);
	int tclrprintf(COLOR unForegroundColor, char const* const _Format, ...);
#endif

	int clrvscanf(COLOR_PAIR ColorPair, char const* const _Format, va_list vargs);
	int clrvscanf(COLOR unForegroundColor, char const* const _Format, va_list vargs);
	int clrscanf(COLOR_PAIR ColorPair, char const* const _Format, ...);
	int clrscanf(COLOR unForegroundColor, char const* const _Format, ...);

	int clrvwscanf(COLOR_PAIR ColorPair, wchar_t const* const _Format, va_list vargs);
	int clrvwscanf(COLOR unForegroundColor, wchar_t const* const _Format, va_list vargs);
	int clrwscanf(COLOR_PAIR ColorPair, wchar_t const* const _Format, ...);
	int clrwscanf(COLOR unForegroundColor, wchar_t const* const _Format, ...);

#ifdef UNICODE
	int tclrvscanf(COLOR_PAIR ColorPair, wchar_t const* const _Format, va_list vargs);
	int tclrvscanf(COLOR unForegroundColor, wchar_t const* const _Format, va_list vargs);
	int tclrscanf(COLOR_PAIR ColorPair, wchar_t const* const _Format, ...);
	int tclrscanf(COLOR unForegroundColor, wchar_t const* const _Format, ...);
#else
	int tclrvscanf(COLOR_PAIR ColorPair, char const* const _Format, va_list vargs);
	int tclrvscanf(COLOR unForegroundColor, char const* const _Format, va_list vargs);
	int tclrscanf(COLOR_PAIR ColorPair, char const* const _Format, ...);
	int tclrscanf(COLOR unForegroundColor, char const* const _Format, ...);
#endif
}

#endif // !_CONSOLEUTILS_H_

```

`DumpVAC.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32630.192
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Console", "Console\Console.vcxproj", "{DCDE0B5E-C150-4D90-B502-67E4113A4AB0}"
	ProjectSection(ProjectDependencies) = postProject
		{ECB99175-0301-48DF-B91B-17A0574D93A9} = {ECB99175-0301-48DF-B91B-17A0574D93A9}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DumpVAC", "DumpVAC\DumpVAC.vcxproj", "{ECB99175-0301-48DF-B91B-17A0574D93A9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DCDE0B5E-C150-4D90-B502-67E4113A4AB0}.Debug|x64.ActiveCfg = Debug|x64
		{DCDE0B5E-C150-4D90-B502-67E4113A4AB0}.Debug|x64.Build.0 = Debug|x64
		{DCDE0B5E-C150-4D90-B502-67E4113A4AB0}.Debug|x86.ActiveCfg = Debug|Win32
		{DCDE0B5E-C150-4D90-B502-67E4113A4AB0}.Debug|x86.Build.0 = Debug|Win32
		{DCDE0B5E-C150-4D90-B502-67E4113A4AB0}.Release|x64.ActiveCfg = Release|x64
		{DCDE0B5E-C150-4D90-B502-67E4113A4AB0}.Release|x64.Build.0 = Release|x64
		{DCDE0B5E-C150-4D90-B502-67E4113A4AB0}.Release|x86.ActiveCfg = Release|Win32
		{DCDE0B5E-C150-4D90-B502-67E4113A4AB0}.Release|x86.Build.0 = Release|Win32
		{ECB99175-0301-48DF-B91B-17A0574D93A9}.Debug|x64.ActiveCfg = Debug|x64
		{ECB99175-0301-48DF-B91B-17A0574D93A9}.Debug|x64.Build.0 = Debug|x64
		{ECB99175-0301-48DF-B91B-17A0574D93A9}.Debug|x86.ActiveCfg = Debug|Win32
		{ECB99175-0301-48DF-B91B-17A0574D93A9}.Debug|x86.Build.0 = Debug|Win32
		{ECB99175-0301-48DF-B91B-17A0574D93A9}.Release|x64.ActiveCfg = Release|x64
		{ECB99175-0301-48DF-B91B-17A0574D93A9}.Release|x64.Build.0 = Release|x64
		{ECB99175-0301-48DF-B91B-17A0574D93A9}.Release|x86.ActiveCfg = Release|Win32
		{ECB99175-0301-48DF-B91B-17A0574D93A9}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {DDCC88B0-B345-4737-A300-07859A2C1C4E}
	EndGlobalSection
EndGlobal

```

`DumpVAC/Console.cpp`:

```cpp
#include "Console.h"

// Framework
#include "framework.h"

static HANDLE g_hPipe = nullptr;
static bool g_bReadyPipe = false;

typedef struct _CONSOLE_MESSAGE {
	char m_pMessage[1024];
	COLOR_PAIR m_ColorPair;
} CONSOLE_MESSAGE, *PCONSOLE_MESSAGE;

bool ConnectToConsole() {
	g_hPipe = CreateNamedPipe(_T("\\\\.\\pipe\\DumpVAC"), PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, 1, sizeof(CONSOLE_MESSAGE), sizeof(CONSOLE_MESSAGE), NMPWAIT_USE_DEFAULT_WAIT, NULL);
	if (!g_hPipe || (g_hPipe == INVALID_HANDLE_VALUE)) {
		return false;
	}

	if (!ConnectNamedPipe(g_hPipe, nullptr)) {
		return false;
	}

	g_bReadyPipe = true;

	return true;
}

int clrvprintf(COLOR_PAIR ColorPair, char const* const _Format, va_list vargs) {
	if (!g_bReadyPipe || !g_hPipe || (g_hPipe == INVALID_HANDLE_VALUE)) {
		return -1;
	}

	PCONSOLE_MESSAGE pMessage = new CONSOLE_MESSAGE;
	if (!pMessage) {
		return -1;
	}

	memset(pMessage, 0, sizeof(CONSOLE_MESSAGE));

	pMessage->m_ColorPair = ColorPair;

	int nLength = vsprintf_s(pMessage->m_pMessage, sizeof(CONSOLE_MESSAGE::m_pMessage), _Format, vargs);
	if (nLength == -1) {
		delete pMessage;
		return -1;
	}

	pMessage->m_pMessage[sizeof(CONSOLE_MESSAGE::m_pMessage) - 1] = 0;

	DWORD unNumberOfBytesWritten = 0;
	if (!WriteFile(g_hPipe, pMessage, sizeof(CONSOLE_MESSAGE), &unNumberOfBytesWritten, nullptr)) {
		delete pMessage;
		return -1;
	}

	delete pMessage;
	return nLength;
}

int clrvprintf(COLOR unForegroundColor, char const* const _Format, va_list vargs) {
	return clrvprintf(COLOR_PAIR(unForegroundColor), _Format, vargs);
}

int clrprintf(COLOR_PAIR ColorPair, char const* const _Format, ...) {
	va_list vargs;
	va_start(vargs, _Format);
	int nLength = clrvprintf(ColorPair, _Format, vargs);
	va_end(vargs);
	return nLength;
}

int clrprintf(COLOR unForegroundColor, char const* const _Format, ...) {
	va_list vargs;
	va_start(vargs, _Format);
	int nLength = clrvprintf(unForegroundColor, _Format, vargs);
	va_end(vargs);
	return nLength;
}

```

`DumpVAC/Console.h`:

```h
#pragma once

#ifndef _CONSOLE_H_
#define _CONSOLE_H_

// Default
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

// General definitions

typedef enum class _COLOR : unsigned char {
	COLOR_BLACK = 0,
	COLOR_DARK_BLUE = FOREGROUND_BLUE,
	COLOR_DARK_GREEN = FOREGROUND_GREEN,
	COLOR_DARK_CYAN = FOREGROUND_GREEN | FOREGROUND_BLUE,
	COLOR_DARK_RED = FOREGROUND_RED,
	COLOR_DARK_MAGENTA = FOREGROUND_RED | FOREGROUND_BLUE,
	COLOR_DARK_YELLOW = FOREGROUND_RED | FOREGROUND_GREEN,
	COLOR_DARK_GRAY = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
	COLOR_GRAY = FOREGROUND_INTENSITY,
	COLOR_BLUE = FOREGROUND_INTENSITY | FOREGROUND_BLUE,
	COLOR_GREEN = FOREGROUND_INTENSITY | FOREGROUND_GREEN,
	COLOR_CYAN = FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_BLUE,
	COLOR_RED = FOREGROUND_INTENSITY | FOREGROUND_RED,
	COLOR_MAGENTA = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_BLUE,
	COLOR_YELLOW = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN,
	COLOR_WHITE = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
	COLOR_UNKNOWN = 0xFF
} COLOR, *PCOLOR;

typedef struct _COLOR_PAIR {
public:
	_COLOR_PAIR() {
		m_unColorBackground = COLOR::COLOR_UNKNOWN;
		m_unColorForeground = COLOR::COLOR_UNKNOWN;
	}

	_COLOR_PAIR(COLOR unColorBackground, COLOR unColorForeground) {
		m_unColorBackground = unColorBackground;
		m_unColorForeground = unColorForeground;
	}

	_COLOR_PAIR(COLOR unColorForeground) {
		m_unColorBackground = COLOR::COLOR_UNKNOWN;
		m_unColorForeground = unColorForeground;
	}

public:
	COLOR m_unColorBackground;
	COLOR m_unColorForeground;
} COLOR_PAIR, *PCOLOR_PAIR;

bool ConnectToConsole();

int clrvprintf(COLOR_PAIR ColorPair, char const* const _Format, va_list vargs);
int clrvprintf(COLOR unForegroundColor, char const* const _Format, va_list vargs);
int clrprintf(COLOR_PAIR ColorPair, char const* const _Format, ...);
int clrprintf(COLOR unForegroundColor, char const* const _Format, ...);

#endif // !_CONSOLE_H_

```

`DumpVAC/Detours/Detours.cpp`:

```cpp
#include "Detours.h"

// Default
#include <tchar.h>

// Advanced
#include <intrin.h>

// STL
#include <memory>
#include <unordered_map>
#include <vector>

// ----------------------------------------------------------------
// Detours
// ----------------------------------------------------------------

namespace Detours {

	// ----------------------------------------------------------------
	// Namespaces
	// ----------------------------------------------------------------

	using namespace Scan;
	using namespace Memory;
	using namespace Exception;
	using namespace Hook;

	// ----------------------------------------------------------------
	// Storage
	// ----------------------------------------------------------------

	static std::unordered_map<void*, std::unique_ptr<Protection>> g_Protections;
	static std::vector<fnExceptionCallBack> g_ExceptionCallBacks;
	static std::unordered_map<void*, std::unique_ptr<ImportHook>> g_ImportHooks;
	static std::unordered_map<void*, std::unique_ptr<ExportHook>> g_ExportHooks;
	static std::unordered_map<void*, std::unique_ptr<MemoryHook>> g_MemoryHooks;

	// ----------------------------------------------------------------
	// KUSER_SHARED_DATA
	// ----------------------------------------------------------------

	const KUSER_SHARED_DATA& KUserSharedData = *reinterpret_cast<PKUSER_SHARED_DATA>(0x7FFE0000);

	// ----------------------------------------------------------------
	// PEB
	// ----------------------------------------------------------------

	const PPEB GetPEB() {
#ifdef _M_X64
		return reinterpret_cast<PPEB>(__readgsqword(0x60));
#elif _M_IX86
		return reinterpret_cast<PPEB>(__readfsdword(0x30));
#endif
	}

	// ----------------------------------------------------------------
	// TEB
	// ----------------------------------------------------------------

	const PTEB GetTEB() {
#ifdef _M_X64
		return reinterpret_cast<PTEB>(__readgsqword(0x30));
#elif _M_IX86
		return reinterpret_cast<PTEB>(__readfsdword(0x18));
#endif
	}

	// ----------------------------------------------------------------
	// Scan
	// ----------------------------------------------------------------

	namespace Scan {

		// ----------------------------------------------------------------
		// P2ALIGNUP
		// ----------------------------------------------------------------

		template <typename T>
		static const T inline P2ALIGNUP(T unSize, T unAlignment) {
			if ((unSize % unAlignment) == 0) {
				return unSize;
			} else {
				return (unSize / unAlignment + 1) * unAlignment;
			}
		};

		// ----------------------------------------------------------------
		// Bit scan
		// ----------------------------------------------------------------

		template <typename T>
		static const T inline __bsf(const T unValue) {
			for (unsigned char i = 0; i < (sizeof(T) * 8); ++i) {
				if (((unValue >> i) & 1) != 0) {
					return i;
				}
			}
			return sizeof(T) * 8;
		}

		// ----------------------------------------------------------------
		// FindSection
		// ----------------------------------------------------------------

		bool FindSection(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, void** pAddress, size_t* pSize) {
			if (!hModule) {
				return false;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_FILE_HEADER pFH = &(pNTHs->FileHeader);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			const PIMAGE_SECTION_HEADER pFirstSection = reinterpret_cast<PIMAGE_SECTION_HEADER>(reinterpret_cast<char*>(pOH) + pFH->SizeOfOptionalHeader);
			const WORD unNumberOfSections = pFH->NumberOfSections;
			const size_t unSectionAlignment = static_cast<size_t>(pOH->SectionAlignment);
			size_t unValidSections = 0;
			for (WORD i = 0; i < unNumberOfSections; ++i) {
				if (memcmp(SectionName.data(), pFirstSection[i].Name, 8) == 0) {
					if (pAddress) {
						*pAddress = reinterpret_cast<void*>(reinterpret_cast<char*>(hModule) + pFirstSection[i].VirtualAddress);
					}

					if (pSize) {
						*pSize = P2ALIGNUP(static_cast<size_t>(pFirstSection[i].SizeOfRawData), unSectionAlignment);;
					}

					return true;
				}
			}

			return false;
		}

		// ----------------------------------------------------------------
		// FindSectionPOGO
		// ----------------------------------------------------------------

		bool FindSectionPOGO(const HMODULE hModule, const char* const szSectionName, void** pAddress, size_t* pSize) {
			if (!hModule) {
				return false;
			}

			if (!szSectionName) {
				return false;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			const IMAGE_DATA_DIRECTORY DebugDD = pOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
			if (!DebugDD.Size) {
				return false;
			}

			const DWORD unCount = DebugDD.Size / sizeof(IMAGE_DEBUG_DIRECTORY);
			const PIMAGE_DEBUG_DIRECTORY pDebugDirectory = reinterpret_cast<PIMAGE_DEBUG_DIRECTORY>(reinterpret_cast<char*>(hModule) + DebugDD.VirtualAddress);
			for (DWORD k = 0; k < unCount; ++k) {
				if (pDebugDirectory[k].Type != IMAGE_DEBUG_TYPE_POGO) {
					continue;
				}

				typedef struct _IMAGE_POGO_BLOCK {
					DWORD unRVA;
					DWORD unSize;
					char Name[1];
				} IMAGE_POGO_BLOCK, *PIMAGE_POGO_BLOCK;

				typedef struct _IMAGE_POGO_INFO {
					DWORD Signature; // 0x4C544347 = 'LTCG'
					IMAGE_POGO_BLOCK Blocks[1];
				} IMAGE_POGO_INFO, *PIMAGE_POGO_INFO;

				const PIMAGE_POGO_INFO pPI = reinterpret_cast<PIMAGE_POGO_INFO>(reinterpret_cast<char*>(hModule) + pDebugDirectory[k].AddressOfRawData);
				if (pPI->Signature != 0x4C544347) {
					continue;
				}

				PIMAGE_POGO_BLOCK pBlock = pPI->Blocks;
				size_t unValidSections = 0;
				while (pBlock->unRVA != 0) {
					const size_t unNameLength = strlen(pBlock->Name) + 1;
					size_t unBlockSize = sizeof(DWORD) * 2 + unNameLength;
					if (unBlockSize & 3) {
						unBlockSize += (4 - (unBlockSize & 3));
					}

					if (strcmp(szSectionName, pBlock->Name) == 0) {
						if (pAddress) {
							*pAddress = reinterpret_cast<void*>(reinterpret_cast<char*>(hModule) + pBlock->unRVA);
						}

						if (pSize) {
							*pSize = static_cast<size_t>(pBlock->unSize);
						}

						return true;
					}

					pBlock = reinterpret_cast<PIMAGE_POGO_BLOCK>(reinterpret_cast<char*>(pBlock) + unBlockSize);
				}
			}

			return false;
		}

		// ----------------------------------------------------------------
		// FindSignature (Native)
		// ----------------------------------------------------------------

		const void* const FindSignatureNative(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!pAddress) {
				return nullptr;
			}

			if (!unSize) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const size_t unSignatureLength = strnlen_s(szSignature, DETOURS_MAX_STRSIZE);
			if (!unSignatureLength) {
				return nullptr;
			}

			if (unSize <= unSignatureLength) {
				return nullptr;
			}

			const unsigned char* const pData = reinterpret_cast<const unsigned char* const>(pAddress);
			const unsigned char* const pSignature = reinterpret_cast<const unsigned char* const>(szSignature);

			for (size_t unIndex = 0; unIndex < unSize; ++unIndex) {
				size_t unSignatureIndex = 0;
				for (; unSignatureIndex < unSignatureLength; ++unSignatureIndex) {
					const unsigned char unSignatureByte = pSignature[unSignatureIndex];
					if (unSignatureByte == unIgnoredByte) {
						continue;
					} else if (pData[unIndex + unSignatureIndex] != unSignatureByte) {
						break;
					}
				}
				if (unSignatureIndex == unSignatureLength) {
					return pData + unIndex;
				}
			}

			return nullptr;
		}

		const void* const FindSignatureNative(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindSignatureNative(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNative(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignatureNative(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNative(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignatureNative(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNativeA(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureNative(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNativeA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureNative(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNativeA(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureNative(hMod, szSectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNativeW(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureNative(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNativeW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureNative(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNativeW(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureNative(hMod, szSectionName, szSignature, unIgnoredByte);
		}

#ifdef UNICODE
		const void* const FindSignatureNative(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureNativeW(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNative(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureNativeW(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNative(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureNativeW(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#else
		const void* const FindSignatureNative(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureNativeA(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNative(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureNativeA(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureNative(const char* const szModuleName, const char* const szSectionName,  const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureNativeA(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#endif

		// ----------------------------------------------------------------
		// FindSignature (SSE2)
		// ----------------------------------------------------------------

		const void* const FindSignatureSSE2(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!pAddress) {
				return nullptr;
			}

			if (!unSize) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const size_t unSignatureLength = strnlen_s(szSignature, DETOURS_MAX_STRSIZE);
			if (!unSignatureLength) {
				return nullptr;
			}

			if (unSize < unSignatureLength) {
				return nullptr;
			}

			const unsigned char* const pData = reinterpret_cast<const unsigned char* const>(pAddress);
			const unsigned char* const pSignature = reinterpret_cast<const unsigned char* const>(szSignature);

			const size_t unDataBytesCycles = static_cast<size_t>(floor(static_cast<double>(unSize) / 16.0));
			for (size_t unCycle = 0; unCycle < unDataBytesCycles; ++unCycle) {
				unsigned __int16 unFound = 0xFFFFui16;
				for (size_t unSignatureIndex = 0; (unSignatureIndex < unSignatureLength) && (unFound != 0); ++unSignatureIndex) {
					const unsigned char unSignatureByte = pSignature[unSignatureIndex];
					if (unSignatureByte == unIgnoredByte) {
						continue;
					} else {
						const __m128i xmm1 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(pData + unCycle * 16 + unSignatureIndex));
						const __m128i xmm2 = _mm_set1_epi8(static_cast<char>(unSignatureByte));

						const __m128i xmm3 = _mm_cmpeq_epi8(xmm1, xmm2);

						unFound &= _mm_movemask_epi8(xmm3);
					}
				}
				if (unFound != 0) {
					return pData + unCycle * 16 + __bsf(unFound);
				}
			}

			const size_t unDataBytesLeft = unSize - unDataBytesCycles * 16;
			if (unDataBytesLeft) {
				if (unDataBytesLeft < unSignatureLength) {
					return FindSignatureNative(pData + unSize - unDataBytesLeft - unSignatureLength, unDataBytesLeft + unSignatureLength, szSignature);
				}
				return FindSignatureNative(pData + unSize - unDataBytesLeft, unDataBytesLeft, szSignature);
			}

			return nullptr;
		}

		const void* const FindSignatureSSE2(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindSignatureSSE2(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignatureSSE2(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignatureSSE2(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2A(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureSSE2(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureSSE2(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2A(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureSSE2(hMod, szSectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2W(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureSSE2(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureSSE2(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2W(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureSSE2(hMod, szSectionName, szSignature, unIgnoredByte);
		}

#ifdef UNICODE
		const void* const FindSignatureSSE2(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureSSE2W(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureSSE2W(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureSSE2W(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#else
		const void* const FindSignatureSSE2(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureSSE2A(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureSSE2A(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureSSE2(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureSSE2A(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#endif

		// ----------------------------------------------------------------
		// FindSignature (AVX)
		// ----------------------------------------------------------------

		const void* const FindSignatureAVX(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!pAddress) {
				return nullptr;
			}

			if (!unSize) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const size_t unSignatureLength = strnlen_s(szSignature, DETOURS_MAX_STRSIZE);
			if (!unSignatureLength) {
				return nullptr;
			}

			if (unSize < unSignatureLength) {
				return nullptr;
			}

			const unsigned char* const pData = reinterpret_cast<const unsigned char* const>(pAddress);
			const unsigned char* const pSignature = reinterpret_cast<const unsigned char* const>(szSignature);

			const size_t unDataBytesCycles = static_cast<size_t>(floor(static_cast<double>(unSize) / 32.0));
			for (size_t unCycle = 0; unCycle < unDataBytesCycles; ++unCycle) {
				unsigned __int32 unFound = 0xFFFFFFFFui32;
				for (size_t unSignatureIndex = 0; (unSignatureIndex < unSignatureLength) && (unFound != 0); ++unSignatureIndex) {
					const unsigned char unSignatureByte = pSignature[unSignatureIndex];
					if (unSignatureByte == unIgnoredByte) {
						continue;
					} else {
						const __m256i ymm0 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(pData + unCycle * 32 + unSignatureIndex));
						const __m256i ymm1 = _mm256_set1_epi8(static_cast<char>(unSignatureByte));

						const __m128i xmm0 = _mm_cmpeq_epi8(reinterpret_cast<const __m128i*>(&ymm0)[0], reinterpret_cast<const __m128i*>(&ymm1)[0]);
						const __m128i xmm1 = _mm_cmpeq_epi8(reinterpret_cast<const __m128i*>(&ymm0)[1], reinterpret_cast<const __m128i*>(&ymm1)[1]);

						const __m256i ymm2 = _mm256_loadu2_m128i(&xmm1, &xmm0);
						reinterpret_cast<__int16*>(&unFound)[0] &= _mm_movemask_epi8(reinterpret_cast<const __m128i*>(&ymm2)[0]);
						reinterpret_cast<__int16*>(&unFound)[1] &= _mm_movemask_epi8(reinterpret_cast<const __m128i*>(&ymm2)[1]);
					}
				}
				if (unFound != 0) {
					return pData + unCycle * 32 + __bsf(unFound);
				}
			}

			const size_t unDataBytesLeft = unSize - unDataBytesCycles * 32;
			if (unDataBytesLeft) {
				if (unDataBytesLeft < unSignatureLength) {
					return FindSignatureSSE2(pData + unSize - unDataBytesLeft - unSignatureLength, unDataBytesLeft + unSignatureLength, szSignature);
				}
				return FindSignatureSSE2(pData + unSize - unDataBytesLeft, unDataBytesLeft, szSignature);
			}

			return nullptr;
		}

		const void* const FindSignatureAVX(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindSignatureAVX(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignatureAVX(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignatureAVX(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVXA(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVXA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVXA(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX(hMod, szSectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVXW(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVXW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVXW(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX(hMod, szSectionName, szSignature, unIgnoredByte);
		}

#ifdef UNICODE
		const void* const FindSignatureAVX(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVXW(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVXW(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVXW(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#else
		const void* const FindSignatureAVX(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVXA(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVXA(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVXA(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#endif

		// ----------------------------------------------------------------
		// FindSignature (AVX2)
		// ----------------------------------------------------------------

		const void* const FindSignatureAVX2(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!pAddress) {
				return nullptr;
			}

			if (!unSize) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const size_t unSignatureLength = strnlen_s(szSignature, DETOURS_MAX_STRSIZE);
			if (!unSignatureLength) {
				return nullptr;
			}

			if (unSize < unSignatureLength) {
				return nullptr;
			}

			const unsigned char* const pData = reinterpret_cast<const unsigned char* const>(pAddress);
			const unsigned char* const pSignature = reinterpret_cast<const unsigned char* const>(szSignature);

			const size_t unDataBytesCycles = static_cast<size_t>(floor(static_cast<double>(unSize) / 32.0));
			for (size_t unCycle = 0; unCycle < unDataBytesCycles; ++unCycle) {
				unsigned __int32 unFound = 0xFFFFFFFFui32;
				for (size_t unSignatureIndex = 0; (unSignatureIndex < unSignatureLength) && (unFound != 0); ++unSignatureIndex) {
					const unsigned char unSignatureByte = pSignature[unSignatureIndex];
					if (unSignatureByte == unIgnoredByte) {
						continue;
					} else {
						const __m256i ymm0 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(pData + unCycle * 32 + unSignatureIndex));
						const __m256i ymm1 = _mm256_set1_epi8(static_cast<char>(unSignatureByte));

						const __m256i ymm3 = _mm256_cmpeq_epi8(ymm0, ymm1);

						unFound &= _mm256_movemask_epi8(ymm3);
					}
				}
				if (unFound != 0) {
					return pData + unCycle * 32 + __bsf(unFound);
				}
			}

			const size_t unDataBytesLeft = unSize - unDataBytesCycles * 32;
			if (unDataBytesLeft) {
				if (unDataBytesLeft < unSignatureLength) {
					return FindSignatureAVX(pData + unSize - unDataBytesLeft - unSignatureLength, unDataBytesLeft + unSignatureLength, szSignature);
				}
				return FindSignatureAVX(pData + unSize - unDataBytesLeft, unDataBytesLeft, szSignature);
			}

			return nullptr;
		}

		const void* const FindSignatureAVX2(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindSignatureAVX2(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignatureAVX2(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignatureAVX2(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2A(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX2(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX2(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2A(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX2(hMod, szSectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2W(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX2(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX2(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2W(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX2(hMod, szSectionName, szSignature, unIgnoredByte);
		}

#ifdef UNICODE
		const void* const FindSignatureAVX2(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX2W(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX2W(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX2W(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#else
		const void* const FindSignatureAVX2(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX2A(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX2A(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX2(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX2A(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#endif

		// ----------------------------------------------------------------
		// FindSignature (AVX-512) [AVX512BW]
		// ----------------------------------------------------------------

		const void* const FindSignatureAVX512(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!pAddress) {
				return nullptr;
			}

			if (!unSize) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const size_t unSignatureLength = strnlen_s(szSignature, DETOURS_MAX_STRSIZE);
			if (!unSignatureLength) {
				return nullptr;
			}

			if (unSize < unSignatureLength) {
				return nullptr;
			}

			const unsigned char* const pData = reinterpret_cast<const unsigned char* const>(pAddress);
			const unsigned char* const pSignature = reinterpret_cast<const unsigned char* const>(szSignature);

			const size_t unDataBytesCycles = static_cast<size_t>(floor(static_cast<double>(unSize) / 64.0));
			for (size_t unCycle = 0; unCycle < unDataBytesCycles; ++unCycle) {
				unsigned __int64 unFound = 0xFFFFFFFFFFFFFFFFui64;
				for (size_t unSignatureIndex = 0; (unSignatureIndex < unSignatureLength) && (unFound != 0); ++unSignatureIndex) {
					const unsigned char unSignatureByte = pSignature[unSignatureIndex];
					if (unSignatureByte == unIgnoredByte) {
						continue;
					} else {
						const __m512i zmm0 = _mm512_loadu_si512(reinterpret_cast<const __m256i*>(pData + unCycle * 64 + unSignatureIndex));
						const __m512i zmm1 = _mm512_set1_epi8(static_cast<char>(unSignatureByte));

						unFound &= _mm512_cmpeq_epi8_mask(zmm0, zmm1);
					}
				}
				if (unFound != 0) {
					return pData + unCycle * 64 + __bsf(unFound);
				}
			}

			const size_t unDataBytesLeft = unSize - unDataBytesCycles * 64;
			if (unDataBytesLeft) {
				if (unDataBytesLeft < unSignatureLength) {
					return FindSignatureAVX2(pData + unSize - unDataBytesLeft - unSignatureLength, unDataBytesLeft + unSignatureLength, szSignature);
				}
				return FindSignatureAVX2(pData + unSize - unDataBytesLeft, unDataBytesLeft, szSignature);
			}

			return nullptr;
		}

		const void* const FindSignatureAVX512(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindSignatureAVX512(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignatureAVX512(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignatureAVX512(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512A(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX512(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX512(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512A(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX512(hMod, szSectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512W(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX512(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX512(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512W(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignatureAVX512(hMod, szSectionName, szSignature, unIgnoredByte);
		}

#ifdef UNICODE
		const void* const FindSignatureAVX512(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX512W(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX512W(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX512W(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#else
		const void* const FindSignatureAVX512(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX512A(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX512A(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureAVX512(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureAVX512A(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#endif

		// ----------------------------------------------------------------
		// FindSignature (Auto)
		// ----------------------------------------------------------------

		static bool bOnceInitialization = false;
		static bool bProcessorFeatureSSE2 = false;
		static bool bProcessorFeatureAVX = false;
		static bool bProcessorFeatureAVX2 = false;
		static bool bProcessorFeatureAVX512BW = false;

		const void* const FindSignature(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte) {

			if (!bOnceInitialization) {
				bOnceInitialization = true;
				int nProcessorIDs[4];
				__cpuid(nProcessorIDs, 0x00000000);
				const int nIDs = nProcessorIDs[0];
				if (nIDs >= 1) {
					__cpuid(nProcessorIDs, 0x00000001);
					bProcessorFeatureSSE2 = (nProcessorIDs[3] & (1 << 26)) != 0;
					bProcessorFeatureAVX = (nProcessorIDs[2] & (1 << 28)) != 0;
					if (nIDs >= 7) {
						__cpuid(nProcessorIDs, 0x00000007);
						bProcessorFeatureAVX2 = (nProcessorIDs[1] & (1 << 5)) != 0;
						bProcessorFeatureAVX512BW = (nProcessorIDs[1] & (1 << 30)) != 0;
					}
				}
			}

			if (bProcessorFeatureAVX512BW) {
				return FindSignatureAVX512(pAddress, unSize, szSignature, unIgnoredByte);
			} else if (bProcessorFeatureAVX2) {
				return FindSignatureAVX2(pAddress, unSize, szSignature, unIgnoredByte);
			} else if (bProcessorFeatureAVX) {
				return FindSignatureAVX(pAddress, unSize, szSignature, unIgnoredByte);
			} else if (bProcessorFeatureSSE2) {
				return FindSignatureSSE2(pAddress, unSize, szSignature, unIgnoredByte);
			} else {
				return FindSignatureNative(pAddress, unSize, szSignature, unIgnoredByte);
			}
		}

		const void* const FindSignature(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindSignature(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, szSignature, unIgnoredByte);
		}

		const void* const FindSignature(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignature(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignature(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindSignature(pAddress, unSize, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureA(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignature(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignature(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureA(const char* const szModuleName, const char* const szSectionName,  const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignature(hMod, szSectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureW(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignature(hMod, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignature(hMod, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignatureW(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!szSignature) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindSignature(hMod, szSectionName, szSignature, unIgnoredByte);
		}

#ifdef UNICODE
		const void* const FindSignature(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureW(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignature(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureW(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignature(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureW(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#else
		const void* const FindSignature(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureA(szModuleName, szSignature, unIgnoredByte);
		}

		const void* const FindSignature(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureA(szModuleName, SectionName, szSignature, unIgnoredByte);
		}

		const void* const FindSignature(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte) {
			return FindSignatureA(szModuleName, szSectionName, szSignature, unIgnoredByte);
		}
#endif

		// ----------------------------------------------------------------
		// FindData (Native)
		// ----------------------------------------------------------------

		const void* const FindDataNative(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize) {
			if (!pAddress) {
				return nullptr;
			}

			if (!unSize) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			if (unSize < unDataSize) {
				return nullptr;
			}

			const unsigned char* const pSourceData = reinterpret_cast<const unsigned char* const>(pAddress);

			for (size_t unIndex = 0; unIndex < unSize; ++unIndex) {
				size_t unDataIndex = 0;
				for (; unDataIndex < unDataSize; ++unDataIndex) {
					if (pSourceData[unIndex + unDataIndex] != pData[unDataIndex]) {
						break;
					}
				}
				if (unDataIndex == unDataSize) {
					return pSourceData + unIndex;
				}
			}

			return nullptr;
		}

		const void* const FindDataNative(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindDataNative(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, pData, unDataSize);
		}

		const void* const FindDataNative(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindDataNative(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindDataNative(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindDataNative(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindDataNativeA(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataNative(hMod, pData, unDataSize);
		}

		const void* const FindDataNativeA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataNative(hMod, SectionName, pData, unDataSize);
		}
		
		const void* const FindDataNativeA(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataNative(hMod, szSectionName, pData, unDataSize);
		}

		const void* const FindDataNativeW(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataNative(hMod, pData, unDataSize);
		}

		const void* const FindDataNativeW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataNative(hMod, SectionName, pData, unDataSize);
		}

		const void* const FindDataNativeW(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataNative(hMod, szSectionName, pData, unDataSize);
		}

#ifdef UNICODE
		const void* const FindDataNative(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataNativeW(szModuleName, pData, unDataSize);
		}

		const void* const FindDataNative(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataNativeW(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindDataNative(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataNativeW(szModuleName, szSectionName, pData, unDataSize);
		}
#else
		const void* const FindDataNative(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataNativeA(szModuleName, pData, unDataSize);
		}

		const void* const FindDataNative(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataNativeA(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindDataNative(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataNativeA(szModuleName, szSectionName, pData, unDataSize);
		}
#endif

		// ----------------------------------------------------------------
		// FindData (SSE2)
		// ----------------------------------------------------------------

		const void* const FindDataSSE2(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize) {
			if (!pAddress) {
				return nullptr;
			}

			if (!unSize) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			if (unSize < unDataSize) {
				return nullptr;
			}

			const unsigned char* const pSourceData = reinterpret_cast<const unsigned char* const>(pAddress);

			const size_t unDataBytesCycles = static_cast<size_t>(floor(static_cast<double>(unSize) / 16.0));
			for (size_t unCycle = 0; unCycle < unDataBytesCycles; ++unCycle) {
				unsigned __int16 unFound = 0xFFFFui16;
				for (size_t unDataIndex = 0; (unDataIndex < unDataSize) && (unFound != 0); ++unDataIndex) {
					const __m128i xmm1 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(pSourceData + unCycle * 16 + unDataIndex));
					const __m128i xmm2 = _mm_set1_epi8(static_cast<char>(pData[unDataIndex]));

					const __m128i xmm3 = _mm_cmpeq_epi8(xmm1, xmm2);

					unFound &= _mm_movemask_epi8(xmm3);
				}
				if (unFound != 0) {
					return pSourceData + unCycle * 16 + __bsf(unFound);
				}
			}

			const size_t unDataBytesLeft = unSize - unDataBytesCycles * 16;
			if (unDataBytesLeft) {
				if (unDataBytesLeft < unDataSize) {
					return FindDataNative(pSourceData + unSize - unDataBytesLeft - unDataSize, unDataBytesLeft + unDataSize, pData, unDataSize);
				}
				return FindDataNative(pSourceData + unSize - unDataBytesLeft, unDataBytesLeft, pData, unDataSize);
			}

			return nullptr;
		}

		const void* const FindDataSSE2(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindDataSSE2(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, pData, unDataSize);
		}

		const void* const FindDataSSE2(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindDataSSE2(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindDataSSE2(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindDataSSE2(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindDataSSE2A(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataSSE2(hMod, pData, unDataSize);
		}

		const void* const FindDataSSE2A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataSSE2(hMod, SectionName, pData, unDataSize);
		}

		const void* const FindDataSSE2A(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataSSE2(hMod, szSectionName, pData, unDataSize);
		}

		const void* const FindDataSSE2W(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataSSE2(hMod, pData, unDataSize);
		}

		const void* const FindDataSSE2W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataSSE2(hMod, SectionName, pData, unDataSize);
		}

		const void* const FindDataSSE2W(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataSSE2(hMod, szSectionName, pData, unDataSize);
		}

#ifdef UNICODE
		const void* const FindDataSSE2(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataSSE2W(szModuleName, pData, unDataSize);
		}

		const void* const FindDataSSE2(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataSSE2W(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindDataSSE2(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataSSE2W(szModuleName, szSectionName, pData, unDataSize);
		}
#else
		const void* const FindDataSSE2(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataSSE2A(szModuleName, pData, unDataSize);
		}

		const void* const FindDataSSE2(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataSSE2A(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindDataSSE2(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataSSE2A(szModuleName, szSectionName, pData, unDataSize);
		}
#endif

		// ----------------------------------------------------------------
		// FindData (AVX)
		// ----------------------------------------------------------------

		const void* const FindDataAVX(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize) {
			if (!pAddress) {
				return nullptr;
			}

			if (!unSize) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			if (unSize < unDataSize) {
				return nullptr;
			}

			const unsigned char* const pSourceData = reinterpret_cast<const unsigned char* const>(pAddress);

			const size_t unDataBytesCycles = static_cast<size_t>(floor(static_cast<double>(unSize) / 32.0));
			for (size_t unCycle = 0; unCycle < unDataBytesCycles; ++unCycle) {
				unsigned __int32 unFound = 0xFFFFFFFFui32;
				for (size_t unDataIndex = 0; (unDataIndex < unDataSize) && (unFound != 0); ++unDataIndex) {
					const __m256i ymm0 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(pSourceData + unCycle * 32 + unDataIndex));
					const __m256i ymm1 = _mm256_set1_epi8(static_cast<char>(pData[unDataIndex]));

					const __m128i xmm0 = _mm_cmpeq_epi8(reinterpret_cast<const __m128i*>(&ymm0)[0], reinterpret_cast<const __m128i*>(&ymm1)[0]);
					const __m128i xmm1 = _mm_cmpeq_epi8(reinterpret_cast<const __m128i*>(&ymm0)[1], reinterpret_cast<const __m128i*>(&ymm1)[1]);

					const __m256i ymm2 = _mm256_loadu2_m128i(&xmm1, &xmm0);
					reinterpret_cast<__int16*>(&unFound)[0] &= _mm_movemask_epi8(reinterpret_cast<const __m128i*>(&ymm2)[0]);
					reinterpret_cast<__int16*>(&unFound)[1] &= _mm_movemask_epi8(reinterpret_cast<const __m128i*>(&ymm2)[1]);
				}
				if (unFound != 0) {
					return pSourceData + unCycle * 32 + __bsf(unFound);
				}
			}

			const size_t unDataBytesLeft = unSize - unDataBytesCycles * 32;
			if (unDataBytesLeft) {
				if (unDataBytesLeft < unDataSize) {
					return FindDataSSE2(pSourceData + unSize - unDataBytesLeft - unDataSize, unDataBytesLeft + unDataSize, pData, unDataSize);
				}
				return FindDataSSE2(pSourceData + unSize - unDataBytesLeft, unDataBytesLeft, pData, unDataSize);
			}

			return nullptr;
		}

		const void* const FindDataAVX(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindDataAVX(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, pData, unDataSize);
		}

		const void* const FindDataAVX(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindDataAVX(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindDataAVX(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindDataAVX(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindDataAVXA(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX(hMod, pData, unDataSize);
		}

		const void* const FindDataAVXA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX(hMod, SectionName, pData, unDataSize);
		}

		const void* const FindDataAVXA(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX(hMod, szSectionName, pData, unDataSize);
		}

		const void* const FindDataAVXW(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX(hMod, pData, unDataSize);
		}

		const void* const FindDataAVXW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX(hMod, SectionName, pData, unDataSize);
		}

		const void* const FindDataAVXW(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX(hMod, szSectionName, pData, unDataSize);
		}

#ifdef UNICODE
		const void* const FindDataAVX(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVXW(szModuleName, pData, unDataSize);
		}

		const void* const FindDataAVX(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVXW(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindDataAVX(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVXW(szModuleName, szSectionName, pData, unDataSize);
		}
#else
		const void* const FindDataAVX(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVXA(szModuleName, pData, unDataSize);
		}

		const void* const FindDataAVX(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVXA(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindDataAVX(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVXA(szModuleName, szSectionName, pData, unDataSize);
		}
#endif

		// ----------------------------------------------------------------
		// FindData (AVX2)
		// ----------------------------------------------------------------

		const void* const FindDataAVX2(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize) {
			if (!pAddress) {
				return nullptr;
			}

			if (!unSize) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			if (unSize < unDataSize) {
				return nullptr;
			}

			const unsigned char* const pSourceData = reinterpret_cast<const unsigned char* const>(pAddress);

			const size_t unDataBytesCycles = static_cast<size_t>(floor(static_cast<double>(unSize) / 32.0));
			for (size_t unCycle = 0; unCycle < unDataBytesCycles; ++unCycle) {
				unsigned __int32 unFound = 0xFFFFFFFFui32;
				for (size_t unDataIndex = 0; (unDataIndex < unDataSize) && (unFound != 0); ++unDataIndex) {
					const __m256i ymm0 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(pSourceData + unCycle * 32 + unDataIndex));
					const __m256i ymm1 = _mm256_set1_epi8(static_cast<char>(pData[unDataIndex]));

					const __m256i ymm3 = _mm256_cmpeq_epi8(ymm0, ymm1);

					unFound &= _mm256_movemask_epi8(ymm3);
				}
				if (unFound != 0) {
					return pSourceData + unCycle * 32 + __bsf(unFound);
				}
			}

			const size_t unDataBytesLeft = unSize - unDataBytesCycles * 32;
			if (unDataBytesLeft) {
				if (unDataBytesLeft < unDataSize) {
					return FindDataAVX(pSourceData + unSize - unDataBytesLeft - unDataSize, unDataBytesLeft + unDataSize, pData, unDataSize);
				}
				return FindDataAVX(pSourceData + unSize - unDataBytesLeft, unDataBytesLeft, pData, unDataSize);
			}

			return nullptr;
		}

		const void* const FindDataAVX2(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindDataAVX2(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, pData, unDataSize);
		}

		const void* const FindDataAVX2(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindDataAVX2(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindDataAVX2(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindDataAVX2(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindDataAVX2A(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX2(hMod, pData, unDataSize);
		}

		const void* const FindDataAVX2A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX2(hMod, SectionName, pData, unDataSize);
		}

		const void* const FindDataAVX2A(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX2(hMod, szSectionName, pData, unDataSize);
		}

		const void* const FindDataAVX2W(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX2(hMod, pData, unDataSize);
		}

		const void* const FindDataAVX2W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX2(hMod, SectionName, pData, unDataSize);
		}

		const void* const FindDataAVX2W(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX2(hMod, szSectionName, pData, unDataSize);
		}

#ifdef UNICODE
		const void* const FindDataAVX2(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX2W(szModuleName, pData, unDataSize);
		}

		const void* const FindDataAVX2(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX2W(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindDataAVX2(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX2W(szModuleName, szSectionName, pData, unDataSize);
		}
#else
		const void* const FindDataAVX2(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX2A(szModuleName, pData, unDataSize);
		}

		const void* const FindDataAVX2(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX2A(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindDataAVX2(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX2A(szModuleName, szSectionName, pData, unDataSize);
		}
#endif

		// ----------------------------------------------------------------
		// FindData (AVX-512) [AVX512BW]
		// ----------------------------------------------------------------

		const void* const FindDataAVX512(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize) {
			if (!pAddress) {
				return nullptr;
			}

			if (!unSize) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			if (unSize < unDataSize) {
				return nullptr;
			}

			const unsigned char* const pSourceData = reinterpret_cast<const unsigned char* const>(pAddress);

			const size_t unDataBytesCycles = static_cast<size_t>(floor(static_cast<double>(unSize) / 64.0));
			for (size_t unCycle = 0; unCycle < unDataBytesCycles; ++unCycle) {
				unsigned __int64 unFound = 0xFFFFFFFFFFFFFFFFui64;
				for (size_t unDataIndex = 0; (unDataIndex < unDataSize) && (unFound != 0); ++unDataIndex) {
					const __m512i zmm0 = _mm512_loadu_si512(reinterpret_cast<const __m256i*>(pSourceData + unCycle * 64 + unDataIndex));
					const __m512i zmm1 = _mm512_set1_epi8(static_cast<char>(pData[unDataIndex]));

					unFound &= _mm512_cmpeq_epi8_mask(zmm0, zmm1);
				}
				if (unFound != 0) {
					return pSourceData + unCycle * 64 + __bsf(unFound);
				}
			}

			const size_t unDataBytesLeft = unSize - unDataBytesCycles * 64;
			if (unDataBytesLeft) {
				if (unDataBytesLeft < unDataSize) {
					return FindDataAVX2(pSourceData + unSize - unDataBytesLeft - unDataSize, unDataBytesLeft + unDataSize, pData, unDataSize);
				}
				return FindDataAVX2(pSourceData + unSize - unDataBytesLeft, unDataBytesLeft, pData, unDataSize);
			}

			return nullptr;
		}

		const void* const FindDataAVX512(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindDataAVX512(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, pData, unDataSize);
		}

		const void* const FindDataAVX512(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindDataAVX512(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindDataAVX512(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindDataAVX512(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindDataAVX512A(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX512(hMod, pData, unDataSize);
		}

		const void* const FindDataAVX512A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX512(hMod, pData, unDataSize);
		}

		const void* const FindDataAVX512A(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX512(hMod, pData, unDataSize);
		}

		const void* const FindDataAVX512W(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX512(hMod, pData, unDataSize);
		}

		const void* const FindDataAVX512W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX512(hMod, SectionName, pData, unDataSize);
		}

		const void* const FindDataAVX512W(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindDataAVX512(hMod, szSectionName, pData, unDataSize);
		}

#ifdef UNICODE
		const void* const FindDataAVX512(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX512W(szModuleName, pData, unDataSize);
		}

		const void* const FindDataAVX512(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX512W(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindDataAVX512(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX512W(szModuleName, szSectionName, pData, unDataSize);
		}
#else
		const void* const FindDataAVX512(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX512A(szModuleName, pData, unDataSize);
		}

		const void* const FindDataAVX512(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX512A(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindDataAVX512(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataAVX512A(szModuleName, szSectionName, pData, unDataSize);
		}
#endif

		// ----------------------------------------------------------------
		// FindData (Auto)
		// ----------------------------------------------------------------

		const void* const FindData(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize) {

			if (!bOnceInitialization) {
				bOnceInitialization = true;
				int nProcessorIDs[4];
				__cpuid(nProcessorIDs, 0x00000000);
				const int nIDs = nProcessorIDs[0];
				if (nIDs >= 1) {
					__cpuid(nProcessorIDs, 0x00000001);
					bProcessorFeatureSSE2 = (nProcessorIDs[3] & (1 << 26)) != 0;
					bProcessorFeatureAVX = (nProcessorIDs[2] & (1 << 28)) != 0;
					if (nIDs >= 7) {
						__cpuid(nProcessorIDs, 0x00000007);
						bProcessorFeatureAVX2 = (nProcessorIDs[1] & (1 << 5)) != 0;
						bProcessorFeatureAVX512BW = (nProcessorIDs[1] & (1 << 30)) != 0;
					}
				}
			}

			if (bProcessorFeatureAVX512BW) {
				return FindDataAVX512(pAddress, unSize, pData, unDataSize);
			} else if (bProcessorFeatureAVX2) {
				return FindDataAVX2(pAddress, unSize, pData, unDataSize);
			} else if (bProcessorFeatureAVX) {
				return FindDataAVX(pAddress, unSize, pData, unDataSize);
			} else if (bProcessorFeatureSSE2) {
				return FindDataSSE2(pAddress, unSize, pData, unDataSize);
			} else {
				return FindDataNative(pAddress, unSize, pData, unDataSize);
			}
		}

		const void* const FindData(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindData(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, pData, unDataSize);
		}

		const void* const FindData(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSection(hModule, SectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindData(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindData(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!hModule) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			void* pAddress = nullptr;
			size_t unSize = 0;
			if (!FindSectionPOGO(hModule, szSectionName, &pAddress, &unSize)) {
				return nullptr;
			}

			return FindData(pAddress, unSize, pData, unDataSize);
		}

		const void* const FindDataA(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindData(hMod, pData, unDataSize);
		}

		const void* const FindDataA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindData(hMod, SectionName, pData, unDataSize);
		}

		const void* const FindDataA(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindData(hMod, szSectionName, pData, unDataSize);
		}

		const void* const FindDataW(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindData(hMod, pData, unDataSize);
		}

		const void* const FindDataW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindData(hMod, SectionName, pData, unDataSize);
		}

		const void* const FindDataW(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szSectionName) {
				return nullptr;
			}

			if (!pData) {
				return nullptr;
			}

			if (!unDataSize) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindData(hMod, szSectionName, pData, unDataSize);
		}

#ifdef UNICODE
		const void* const FindData(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataW(szModuleName, pData, unDataSize);
		}

		const void* const FindData(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataW(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindData(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataW(szModuleName, szSectionName, pData, unDataSize);
		}
#else
		const void* const FindData(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataA(szModuleName, pData, unDataSize);
		}

		const void* const FindData(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataA(szModuleName, SectionName, pData, unDataSize);
		}

		const void* const FindData(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize) {
			return FindDataA(szModuleName, szSectionName, pData, unDataSize);
		}
#endif

		// ----------------------------------------------------------------
		// RTTI
		// ----------------------------------------------------------------

#pragma pack(push, 1)
		typedef struct _PMD {
			int m_nMDisp;
			int m_nPDisp;
			int m_nVDisp;
		} PMD, *PPMD;

		typedef struct _TYPE_DESCRIPTOR {
			void* m_pVFTable;
			void* m_pSpare;
			char m_szName[1];
		} TYPE_DESCRIPTOR, *PTYPE_DESCRIPTOR;

		typedef struct _RTTI_BASE_CLASS_DESCRIPTOR {
#ifdef _M_X64
			unsigned int m_unTypeDescriptor;
#elif _M_IX86
			PTYPE_DESCRIPTOR m_pTypeDescriptor;
#endif
			unsigned int m_unNumberOfContainedBases;
			PMD m_Where;
			unsigned int m_unAttributes;
		} RTTI_BASE_CLASS_DESCRIPTOR, *PRTTI_BASE_CLASS_DESCRIPTOR;

		typedef struct _RTTI_BASE_CLASS_ARRAY {
#ifdef _M_X64
			unsigned int m_unBaseClassDescriptors;
#elif _M_IX86
			PRTTI_BASE_CLASS_DESCRIPTOR m_pBaseClassDescriptors[1];
#endif
		} RTTI_BASE_CLASS_ARRAY, *PRTTI_BASE_CLASS_ARRAY;

		typedef struct _RTTI_CLASS_HIERARCHY_DESCRIPTOR {
			unsigned int m_unSignature;
			unsigned int m_unAttributes;
			unsigned int m_unNumberOfBaseClasses;
#ifdef _M_X64
			unsigned int m_unBaseClassArray;
#elif _M_IX86
			PRTTI_BASE_CLASS_ARRAY m_pBaseClassArray;
#endif
		} RTTI_CLASS_HIERARCHY_DESCRIPTOR, *PRTTI_CLASS_HIERARCHY_DESCRIPTOR;

		typedef struct _RTTI_COMPLETE_OBJECT_LOCATOR {
			unsigned int m_unSignature;
			unsigned int m_unOffset;
			unsigned int m_unConstructorOffset;
#ifdef _M_X64
			unsigned int m_unTypeDescriptor;
			unsigned int m_unClassHierarchyDescriptor;
#elif _M_IX86
			PTYPE_DESCRIPTOR m_pTypeDescriptor;
			PRTTI_CLASS_HIERARCHY_DESCRIPTOR m_pClassHierarchyDescriptor;
#endif
		} RTTI_COMPLETE_OBJECT_LOCATOR, *PRTTI_COMPLETE_OBJECT_LOCATOR;
#pragma pack(pop)

		// ----------------------------------------------------------------
		// FindRTTI
		// ----------------------------------------------------------------

		static const void* const _FindRTTI(const void* const pBaseAddress, const size_t unSize, const char* const szRTTI) {
			if (!pBaseAddress) {
				return nullptr;
			}

			if (!unSize) {
				return nullptr;
			}

			if (!szRTTI) {
				return nullptr;
			}

			const size_t unRTTILength = strnlen_s(szRTTI, DETOURS_MAX_STRSIZE);
			if (!unRTTILength) {
				return nullptr;
			}

			if (unSize <= unRTTILength) {
				return nullptr;
			}

			void* pReference = const_cast<void*>(pBaseAddress);
			void* pEndAddress = reinterpret_cast<char*>(const_cast<void*>(pBaseAddress)) + unSize;
			while (pReference && (pReference < pEndAddress)) {
				pReference = const_cast<void*>(FindData(pReference, reinterpret_cast<size_t>(pEndAddress) - reinterpret_cast<size_t>(pReference), reinterpret_cast<const unsigned char* const>(szRTTI), unRTTILength));
				if (!pReference) {
					break;
				}

				const PTYPE_DESCRIPTOR pTypeDescriptor = reinterpret_cast<PTYPE_DESCRIPTOR>(reinterpret_cast<char*>(pReference) - sizeof(void*) * 2);
				if ((pTypeDescriptor->m_pVFTable < pBaseAddress) || (pTypeDescriptor->m_pVFTable >= pEndAddress)) {
					pReference = reinterpret_cast<void*>(reinterpret_cast<char*>(pReference) + 1);
					continue;
				}
				if (pTypeDescriptor->m_pSpare) {
					pReference = reinterpret_cast<void*>(reinterpret_cast<char*>(pReference) + 1);
					continue;
				}

				void* pTypeDescriptorReference = const_cast<void*>(pBaseAddress);
				while (pTypeDescriptorReference && (pTypeDescriptorReference < pEndAddress)) {
#ifdef _M_X64
					const size_t unTypeDescriptorOffsetTemp = reinterpret_cast<size_t>(pTypeDescriptor) - reinterpret_cast<size_t>(pBaseAddress);
					const unsigned int unTypeDescriptorOffset = (*(reinterpret_cast<const unsigned int*>(&unTypeDescriptorOffsetTemp)));
					pTypeDescriptorReference = const_cast<void*>(FindData(pTypeDescriptorReference, reinterpret_cast<size_t>(pEndAddress) - reinterpret_cast<size_t>(pTypeDescriptorReference), reinterpret_cast<const unsigned char* const>(&unTypeDescriptorOffset), sizeof(int)));
					if (!pTypeDescriptorReference) {
						break;
					}
#elif _M_IX86
					pTypeDescriptorReference = const_cast<void*>(FindData(pTypeDescriptorReference, reinterpret_cast<size_t>(pEndAddress) - reinterpret_cast<size_t>(pTypeDescriptorReference), reinterpret_cast<const unsigned char* const>(&pTypeDescriptor), sizeof(int)));
					if (!pTypeDescriptorReference) {
						break;
					}
#endif

					const PRTTI_COMPLETE_OBJECT_LOCATOR pCompleteObjectLocation = reinterpret_cast<PRTTI_COMPLETE_OBJECT_LOCATOR>(reinterpret_cast<char*>(pTypeDescriptorReference) - sizeof(int) * 3);
#ifdef _M_X64
					const PRTTI_CLASS_HIERARCHY_DESCRIPTOR pClassHierarchyDescriptor = reinterpret_cast<PRTTI_CLASS_HIERARCHY_DESCRIPTOR>(reinterpret_cast<size_t>(pBaseAddress) + pCompleteObjectLocation->m_unClassHierarchyDescriptor);
#elif _M_IX86
					const PRTTI_CLASS_HIERARCHY_DESCRIPTOR pClassHierarchyDescriptor = pCompleteObjectLocation->m_pClassHierarchyDescriptor;
#endif
					if ((pClassHierarchyDescriptor < pBaseAddress) || (pClassHierarchyDescriptor >= pEndAddress)) {
						pTypeDescriptorReference = reinterpret_cast<void*>(reinterpret_cast<char*>(pTypeDescriptorReference) + 1);
						continue;
					}

#ifdef _M_X64
					const PRTTI_BASE_CLASS_ARRAY pBaseClassArray = reinterpret_cast<PRTTI_BASE_CLASS_ARRAY>(reinterpret_cast<size_t>(pBaseAddress) + pClassHierarchyDescriptor->m_unBaseClassArray);
#elif _M_IX86
					const PRTTI_BASE_CLASS_ARRAY pBaseClassArray = pClassHierarchyDescriptor->m_pBaseClassArray;
#endif
					if ((pBaseClassArray < pBaseAddress) || (pBaseClassArray >= pEndAddress)) {
						pTypeDescriptorReference = reinterpret_cast<void*>(reinterpret_cast<char*>(pTypeDescriptorReference) + 1);
						continue;
					}

#ifdef _M_X64
					const PRTTI_BASE_CLASS_DESCRIPTOR pBaseClassDescriptors = reinterpret_cast<PRTTI_BASE_CLASS_DESCRIPTOR>(reinterpret_cast<size_t>(pBaseAddress) + pBaseClassArray->m_unBaseClassDescriptors);
#elif _M_IX86
					const PRTTI_BASE_CLASS_DESCRIPTOR pBaseClassDescriptors = pBaseClassArray->m_pBaseClassDescriptors[0];
#endif
					if ((pBaseClassDescriptors < pBaseAddress) || (pBaseClassDescriptors >= pEndAddress)) {
						pTypeDescriptorReference = reinterpret_cast<void*>(reinterpret_cast<char*>(pTypeDescriptorReference) + 1);
						continue;
					}

					for (size_t i = 0; i < pClassHierarchyDescriptor->m_unNumberOfBaseClasses; ++i) {
						const PRTTI_BASE_CLASS_DESCRIPTOR pBaseClassDescriptor = (&pBaseClassDescriptors)[i];
						if (!pBaseClassDescriptor) {
							continue;
						}
#ifdef _M_X64
						if (reinterpret_cast<void*>(reinterpret_cast<size_t>(pBaseAddress) + pBaseClassDescriptor->m_unTypeDescriptor) == pTypeDescriptor) {
#elif _M_IX86
						if (pBaseClassDescriptor->m_pTypeDescriptor == pTypeDescriptor) {
#endif
							const void* const pCompleteObject = FindData(pBaseAddress, unSize, reinterpret_cast<const unsigned char* const>(&pCompleteObjectLocation), sizeof(void*));
							if (!pCompleteObject) {
								return nullptr;
							}
							return reinterpret_cast<const void* const>(reinterpret_cast<const unsigned char* const>(pCompleteObject) + sizeof(void*));
						}
					}

					pTypeDescriptorReference = reinterpret_cast<void*>(reinterpret_cast<char*>(pTypeDescriptorReference) + 1);
				}

				pReference = reinterpret_cast<void*>(reinterpret_cast<char*>(pReference) + 1);
			}

			return nullptr;
		}

		// Ren: Fixes bug with Visual Studio static code analyzer...
		const void* const FindRTTI(const void* const pBaseAddress, const size_t unSize, const char* const szRTTI) {
			return _FindRTTI(pBaseAddress, unSize, szRTTI);
		}

		const void* const FindRTTI(const HMODULE hModule, const char* const szRTTI) {
			if (!hModule) {
				return nullptr;
			}

			if (!szRTTI) {
				return nullptr;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			return FindRTTI(reinterpret_cast<void*>(hModule), static_cast<size_t>(pOH->SizeOfImage) - 1, szRTTI);
		}

		const void* const FindRTTIA(const char* const szModuleName, const char* const szRTTI) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szRTTI) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleA(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindRTTI(hMod, szRTTI);
		}

		const void* const FindRTTIW(const wchar_t* const szModuleName, const char* const szRTTI) {
			if (!szModuleName) {
				return nullptr;
			}

			if (!szRTTI) {
				return nullptr;
			}

			const HMODULE hMod = GetModuleHandleW(szModuleName);
			if (!hMod) {
				return nullptr;
			}

			return FindRTTI(hMod, szRTTI);
		}

#ifdef UNICODE
		const void* const FindRTTI(const wchar_t* const szModuleName, const char* const szRTTI) {
			return FindRTTIW(szModuleName, szRTTI);
		}
#else
		const void* const FindRTTI(const char* const szModuleName, const char* const szRTTI) {
			return FindRTTIA(szModuleName, szRTTI);
		}
#endif
	}

	// ----------------------------------------------------------------
	// Memory
	// ----------------------------------------------------------------

	namespace Memory {

		// ----------------------------------------------------------------
		// Server
		// ----------------------------------------------------------------

		Server::Server(const size_t unMemorySize, bool bIsGlobal) : m_unMemorySize(unMemorySize) {
			memset(m_szSessionName, 0, sizeof(m_szSessionName));
			m_hMap = nullptr;
			m_pAddress = nullptr;

			if (!unMemorySize) {
				return;
			}

			const DWORD unPID = GetCurrentProcessId();
			const DWORD unTID = GetCurrentThreadId();
			const DWORD64 unCycle = __rdtsc();
			_stprintf_s(m_szSessionName, _T("GLOBAL:%08X:%08X:%08X%08X"), 0xFFFFFFFF - unPID, 0xFFFFFFFF - unTID, static_cast<DWORD>(unCycle & 0xFFFFFFFF), static_cast<DWORD>((unCycle >> 32) & 0xFFFFFFFF));

			TCHAR szMap[64];
			memset(szMap, 0, sizeof(szMap));
			if (bIsGlobal) {
				_stprintf_s(szMap, _T("Global\\%s"), m_szSessionName);
			} else {
				_stprintf_s(szMap, _T("Local\\%s"), m_szSessionName);
			}

			m_hMap = CreateFileMapping(INVALID_HANDLE_VALUE, nullptr, PAGE_READWRITE, 0, unMemorySize & 0xFFFFFFFF, szMap);
			if (m_hMap && (m_hMap != INVALID_HANDLE_VALUE)) {
				m_pAddress = MapViewOfFile(m_hMap, FILE_MAP_ALL_ACCESS, 0, 0, unMemorySize);
			}
		}

		Server::~Server() {
			if (m_pAddress) {
				UnmapViewOfFile(m_pAddress);
			}

			if (m_hMap && (m_hMap != INVALID_HANDLE_VALUE)) {
				CloseHandle(m_hMap);
			}
		}

		bool Server::GetSessionName(TCHAR szSessionName[64]) {
			if (!m_hMap || (m_hMap == INVALID_HANDLE_VALUE)) {
				return false;
			}

			memcpy(szSessionName, m_szSessionName, sizeof(m_szSessionName));

			return true;
		}

		void* Server::GetAddress() {
			return m_pAddress;
		}

		// ----------------------------------------------------------------
		// Client
		// ----------------------------------------------------------------

		Client::Client(const size_t unMemorySize, TCHAR szSessionName[64], bool bIsGlobal) : m_unMemorySize(unMemorySize) {
			m_hMap = nullptr;
			m_pAddress = nullptr;

			if (!unMemorySize) {
				return;
			}

			if (!szSessionName) {
				return;
			}

			TCHAR szMap[64];
			memset(szMap, 0, sizeof(szMap));
			if (bIsGlobal) {
				_stprintf_s(szMap, _T("Global\\%s"), szSessionName);
			} else {
				_stprintf_s(szMap, _T("Local\\%s"), szSessionName);
			}

			m_hMap = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, szMap);
			if (m_hMap && (m_hMap != INVALID_HANDLE_VALUE)) {
				m_pAddress = MapViewOfFile(m_hMap, FILE_MAP_ALL_ACCESS, 0, 0, unMemorySize);
			}
		}

		Client::~Client() {
			if (m_pAddress) {
				UnmapViewOfFile(m_pAddress);
			}

			if (m_hMap && (m_hMap != INVALID_HANDLE_VALUE)) {
				CloseHandle(m_hMap);
			}
		}

		void* Client::GetAddress() {
			return m_pAddress;
		}

		// ----------------------------------------------------------------
		// Protection
		// ----------------------------------------------------------------

		Protection::Protection(const void* const pAddress, const size_t unSize) : m_pAddress(pAddress), m_unSize(unSize) {
			m_unOriginalProtection = 0;

			if (!pAddress) {
				return;
			}

			if (!unSize) {
				return;
			}

			MEMORY_BASIC_INFORMATION mbi;
			memset(&mbi, 0, sizeof(MEMORY_BASIC_INFORMATION));

			if (!VirtualQuery(pAddress, &mbi, sizeof(MEMORY_BASIC_INFORMATION))) {
				return;
			}

			m_unOriginalProtection = mbi.Protect;
		}

		Protection::~Protection() {
			if (!m_pAddress) {
				return;
			}

			if (!m_unSize) {
				return;
			}

			DWORD unProtection = 0;
			VirtualProtect(const_cast<void* const>(m_pAddress), m_unSize, m_unOriginalProtection, &unProtection);
		}

		bool Protection::GetProtection(const PDWORD pProtection) {
			if (!m_pAddress) {
				return false;
			}

			if (!m_unSize) {
				return false;
			}

			MEMORY_BASIC_INFORMATION mbi;
			memset(&mbi, 0, sizeof(MEMORY_BASIC_INFORMATION));

			if (!VirtualQuery(m_pAddress, &mbi, sizeof(MEMORY_BASIC_INFORMATION))) {
				return false;
			}

			if (pProtection) {
				*pProtection = mbi.Protect;
			}

			return true;
		}

		bool Protection::ChangeProtection(const DWORD unNewProtection) {
			if (!m_pAddress) {
				return false;
			}

			if (!m_unSize) {
				return false;
			}

			DWORD unProtection = 0;
			if (!VirtualProtect(const_cast<void* const>(m_pAddress), m_unSize, unNewProtection, &unProtection)) {
				return false;
			}

			return true;
		}

		bool Protection::RestoreProtection() {
			if (!m_pAddress) {
				return false;
			}

			if (!m_unSize) {
				return false;
			}

			DWORD unProtection = 0;
			if (!VirtualProtect(const_cast<void* const>(m_pAddress), m_unSize, m_unOriginalProtection, &unProtection)) {
				return false;
			}

			return true;
		}

		const void* const Protection::GetAddress() {
			return m_pAddress;
		}

		const size_t Protection::GetSize() {
			return m_unSize;
		}

		DWORD Protection::GetOriginalProtection() {
			return m_unOriginalProtection;
		}

		// ----------------------------------------------------------------
		// Simple Protection
		// ----------------------------------------------------------------

		bool ChangeProtection(const void* const pAddress, const size_t unSize, const DWORD unNewProtection) {
			if (!pAddress) {
				return false;
			}

			if (!unSize) {
				return false;
			}

			auto pMemory = std::make_unique<Protection>(pAddress, unSize);
			if (!pMemory) {
				return false;
			}

			const void* const pMemoryAddress = pMemory->GetAddress();
			if (!pMemoryAddress) {
				return false;
			}

			auto pProtection = g_Protections.find(const_cast<void*>(pMemoryAddress));
			if (pProtection != g_Protections.end()) {
				return false;
			}

			if (!pMemory->ChangeProtection(unNewProtection)) {
				return false;
			}

			g_Protections.insert(std::pair<void*, std::unique_ptr<Protection>>(const_cast<void*>(pMemoryAddress), std::move(pMemory)));
			return true;
		}

		bool RestoreProtection(const void* const pAddress) {
			if (!pAddress) {
				return false;
			}

			auto Protection = g_Protections.find(const_cast<void*>(pAddress));
			if (Protection == g_Protections.end()) {
				return false;
			}

			g_Protections.erase(Protection);
			return true;
		}
	}

	// ----------------------------------------------------------------
	// Exception
	// ----------------------------------------------------------------

	namespace Exception {

		// ----------------------------------------------------------------
		// ExceptionHandler
		// ----------------------------------------------------------------

		static LONG NTAPI ExceptionHandler(PEXCEPTION_POINTERS pExceptionInfo) noexcept {
			if (!pExceptionInfo) {
				return EXCEPTION_ACCESS_VIOLATION;
			}

			const PEXCEPTION_RECORD pException = pExceptionInfo->ExceptionRecord;
			if (!pException) {
				return EXCEPTION_ACCESS_VIOLATION;
			}

			const PCONTEXT pCTX = pExceptionInfo->ContextRecord;
			if (!pCTX) {
				return EXCEPTION_ACCESS_VIOLATION;
			}

			// MemoryHook
			auto Hook = g_MemoryHooks.find(pException->ExceptionAddress);
			if (Hook != g_MemoryHooks.end()) {
				auto& pMemoryHook = Hook->second;
				if (pMemoryHook) {
					Hook::MemoryHook* pHook = pMemoryHook.get();
					if (pHook) {
						if (pHook->IsAutoDisable()) {
							pHook->Disable();
						}

						const Hook::fnMemoryHookCallBack pCallBack = pHook->GetCallBack();
						if (pCallBack) {
							if (pCallBack(pHook, pCTX)) {
								return EXCEPTION_CONTINUE_EXECUTION;
							}
						}
					}
				}
			}

			const EXCEPTION_RECORD Exception = *pException;
			for (auto it = g_ExceptionCallBacks.begin(); it != g_ExceptionCallBacks.end(); ++it) {
				const fnExceptionCallBack pCallBack = *it;
				if (!pCallBack) {
					continue;
				}

				if (pCallBack(Exception, pCTX)) {
					return EXCEPTION_CONTINUE_EXECUTION;
				}
			}

			return EXCEPTION_CONTINUE_SEARCH;
		}

		// ----------------------------------------------------------------
		// Exception
		// ----------------------------------------------------------------

		class Exception {
		public:
			Exception();
			~Exception();

		public:
			PVOID m_pVEH;
		};

		Exception::Exception() {
			m_pVEH = AddVectoredExceptionHandler(TRUE, ExceptionHandler);
		}

		Exception::~Exception() {
			if (m_pVEH) {
				RemoveVectoredExceptionHandler(m_pVEH);
			}
		}

		static Exception g_Exception;

		bool AddCallBack(const fnExceptionCallBack pCallBack) {
			if (!pCallBack) {
				return false;
			}

			if (!g_Exception.m_pVEH) {
				return false;
			}

			for (auto it = g_ExceptionCallBacks.begin(); it != g_ExceptionCallBacks.end(); ++it) {
				if (pCallBack == *it) {
					return false;
				}
			}

			g_ExceptionCallBacks.push_back(pCallBack);
			return true;
		}

		bool RemoveCallBack(const fnExceptionCallBack pCallBack) {
			if (!pCallBack) {
				return false;
			}

			if (!g_Exception.m_pVEH) {
				return false;
			}

			for (auto it = g_ExceptionCallBacks.begin(); it != g_ExceptionCallBacks.end(); ++it) {
				if (pCallBack == *it) {
					g_ExceptionCallBacks.erase(it);
					return true;
				}
			}

			return false;
		}
	}

	// ----------------------------------------------------------------
	// Hook
	// ----------------------------------------------------------------

	namespace Hook {

		// ----------------------------------------------------------------
		// Import Hook
		// ----------------------------------------------------------------

		ImportHook::ImportHook(const HMODULE hModule, const char* const szImportName, const char* const szImportModuleName) {
			m_pAddress = nullptr;
			m_pOriginalAddress = nullptr;
			m_pHookAddress = nullptr;

			if (!hModule) {
				return;
			}

			if (!szImportName) {
				return;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			const PIMAGE_DATA_DIRECTORY pImportDD = &(pOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
			const PIMAGE_IMPORT_DESCRIPTOR pImportDesc = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(reinterpret_cast<char*>(hModule) + pImportDD->VirtualAddress);
			for (size_t i = 0; pImportDesc[i].Name != 0; ++i) {
				if (szImportModuleName) {
					if (strncmp(reinterpret_cast<char*>(hModule) + pImportDesc[i].Name, szImportModuleName, 0x100) != 0) {
						continue;
					}
				}

				const PIMAGE_THUNK_DATA pThunkDataImportNameTable = reinterpret_cast<PIMAGE_THUNK_DATA>(reinterpret_cast<char*>(hModule) + pImportDesc[i].OriginalFirstThunk);
				const PIMAGE_THUNK_DATA pThunkDataImportAddressTable = reinterpret_cast<PIMAGE_THUNK_DATA>(reinterpret_cast<char*>(hModule) + pImportDesc[i].FirstThunk);
				for (size_t j = 0; pThunkDataImportNameTable[j].u1.AddressOfData != 0; ++j) {
					if (pThunkDataImportNameTable[j].u1.Ordinal & IMAGE_ORDINAL_FLAG) {
						continue; // TODO: Hook with ordinals
					} else {
						const PIMAGE_IMPORT_BY_NAME pImportByName = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(reinterpret_cast<char*>(hModule) + pThunkDataImportNameTable[j].u1.AddressOfData);
						if (strncmp(pImportByName->Name, szImportName, 0x7FFu) == 0) {
							m_pAddress = reinterpret_cast<const void**>(&(pThunkDataImportAddressTable[j].u1.Function));
							m_pOriginalAddress = *m_pAddress;
						}
					}
				}
			}
		}

		ImportHook::~ImportHook() {
			UnHook();
		}

		bool ImportHook::Hook(const void* const pHookAddress) {
			if (!m_pAddress) {
				return false;
			}

			if (*m_pAddress != m_pOriginalAddress) {
				return false;
			}

			Protection Memory(m_pAddress, sizeof(void*));
			if (Memory.ChangeProtection(PAGE_READWRITE)) {
				*m_pAddress = pHookAddress;
				m_pHookAddress = pHookAddress;
				return true;
			}

			return false;
		}

		bool ImportHook::UnHook() {
			if (!m_pAddress) {
				return false;
			}

			if (*m_pAddress == m_pOriginalAddress) {
				return false;
			}

			Protection Memory(m_pAddress, sizeof(void*));
			if (Memory.ChangeProtection(PAGE_READWRITE)) {
				*m_pAddress = m_pOriginalAddress;
				m_pHookAddress = nullptr;
				return true;
			}

			return false;
		}

		const void* ImportHook::GetOriginalAddress() {
			return m_pOriginalAddress;
		}

		const void* ImportHook::GetHookAddress() {
			return m_pHookAddress;
		}

		// ----------------------------------------------------------------
		// Simple Import Hook
		// ----------------------------------------------------------------

		bool HookImport(const HMODULE hModule, const char* const szImportName, const void* const pHookAddress) {
			if (!hModule) {
				return false;
			}

			if (!szImportName) {
				return false;
			}

			if (!pHookAddress) {
				return false;
			}

			auto pHook = std::make_unique<ImportHook>(hModule, szImportName);
			if (!pHook) {
				return false;
			}

			const void* const pOriginalAddress = pHook->GetOriginalAddress();
			auto pImportHook = g_ImportHooks.find(const_cast<void*>(pOriginalAddress));
			if (pImportHook != g_ImportHooks.end()) {
				return false;
			}

			if (!pHook->Hook(pHookAddress)) {
				return false;
			}

			g_ImportHooks.insert(std::pair<void*, std::unique_ptr<ImportHook>>(const_cast<void*>(pOriginalAddress), std::move(pHook)));
			return true;
		}

		bool UnHookImport(const void* const pHookAddress) {
			if (!pHookAddress) {
				return false;
			}

			for (auto it = g_ImportHooks.begin(); it != g_ImportHooks.end(); ++it) {
				auto& pImportHook = it->second;
				if (!pImportHook) {
					continue;
				}

				if (pHookAddress == pImportHook->GetHookAddress()) {
					g_ImportHooks.erase(it);
					return true;
				}
			}

			return false;
		}

		// ----------------------------------------------------------------
		// Export Hook
		// ----------------------------------------------------------------

		ExportHook::ExportHook(const HMODULE hModule, const char* const szExportName) {
			m_hModule = nullptr;
			m_pAddress = nullptr;
			m_unOriginalAddress = 0;
			m_pHookAddress = nullptr;

			if (!hModule) {
				return;
			}

			m_hModule = hModule;

			if (!szExportName) {
				return;
			}

			const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
			const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pDH->e_lfanew);
			const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

			const PIMAGE_DATA_DIRECTORY pExportDD = &(pOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
			const PIMAGE_EXPORT_DIRECTORY pExportDirectory = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(reinterpret_cast<char*>(hModule) + pExportDD->VirtualAddress);

			const PDWORD pExportAddresses = reinterpret_cast<PDWORD>(reinterpret_cast<char*>(hModule) + pExportDirectory->AddressOfFunctions);
			const PWORD pExportOrdinals = reinterpret_cast<PWORD>(reinterpret_cast<char*>(hModule) + pExportDirectory->AddressOfNameOrdinals);
			const PDWORD pExportNames = reinterpret_cast<PDWORD>(reinterpret_cast<char*>(hModule) + pExportDirectory->AddressOfNames);

			const size_t unAddressOfFunctions = pExportDirectory->NumberOfFunctions;
			for (size_t i = 0; i < unAddressOfFunctions; ++i) {
				if (strncmp(szExportName, reinterpret_cast<char*>(hModule) + pExportNames[i], 0x7FF) == 0) {
					m_pAddress = reinterpret_cast<PDWORD>(&(pExportAddresses[pExportOrdinals[i]]));
					m_unOriginalAddress = *m_pAddress;
				}
			}

		}

		ExportHook::~ExportHook() {
			UnHook();
		}

		bool ExportHook::Hook(const void* const pHookAddress) {
			if (!m_hModule) {
				return false;
			}

			if (!m_pAddress) {
				return false;
			}

			if (*m_pAddress != m_unOriginalAddress) {
				return false;
			}

			const size_t unNewAddress = reinterpret_cast<size_t>(pHookAddress) - reinterpret_cast<size_t>(m_hModule);
#ifdef _M_X64
			if (unNewAddress >= 0xFFFFFFFFui32) {
				return false;
			}
#endif

			Protection Memory(m_pAddress, sizeof(DWORD));
			if (Memory.ChangeProtection(PAGE_READWRITE)) {
				*m_pAddress = static_cast<DWORD>(unNewAddress);
				m_pHookAddress = pHookAddress;
				return true;
			}

			return false;
		}

		bool ExportHook::UnHook() {
			if (!m_hModule) {
				return false;
			}

			if (!m_pAddress) {
				return false;
			}

			if (*m_pAddress == m_unOriginalAddress) {
				return false;
			}

			Protection Memory(m_pAddress, sizeof(DWORD));
			if (Memory.ChangeProtection(PAGE_READWRITE)) {
				*m_pAddress = m_unOriginalAddress;
				m_pHookAddress = nullptr;
				return true;
			}

			return false;
		}

		const void* ExportHook::GetOriginalAddress() {
			if (!m_hModule) {
				return nullptr;
			}
			return reinterpret_cast<const void*>(reinterpret_cast<char*>(m_hModule) + m_unOriginalAddress);
		}

		const void* ExportHook::GetHookAddress() {
			return m_pHookAddress;
		}

		// ----------------------------------------------------------------
		// Simple Export Hook
		// ----------------------------------------------------------------

		bool HookExport(const HMODULE hModule, const char* const szExportName, const void* const pHookAddress) {
			if (!hModule) {
				return false;
			}

			if (!szExportName) {
				return false;
			}

			if (!pHookAddress) {
				return false;
			}

			auto pHook = std::make_unique<ExportHook>(hModule, szExportName);
			if (!pHook) {
				return false;
			}

			const void* const pOriginalAddress = pHook->GetOriginalAddress();
			auto pExportHook = g_ExportHooks.find(const_cast<void*>(pOriginalAddress));
			if (pExportHook != g_ExportHooks.end()) {
				return false;
			}

			if (!pHook->Hook(pHookAddress)) {
				return false;
			}

			g_ExportHooks.insert(std::pair<void*, std::unique_ptr<ExportHook>>(const_cast<void*>(pOriginalAddress), std::move(pHook)));
			return true;
		}

		bool UnHookExport(const void* const pHookAddress) {
			if (!pHookAddress) {
				return false;
			}

			for (auto it = g_ExportHooks.begin(); it != g_ExportHooks.end(); ++it) {
				auto& pExportHook = it->second;
				if (!pExportHook) {
					continue;
				}

				if (pHookAddress == pExportHook->GetHookAddress()) {
					g_ExportHooks.erase(it);
					return true;
				}
			}

			return false;
		}

		// ----------------------------------------------------------------
		// Memory Hook
		// ----------------------------------------------------------------

		static bool __fastcall MemoryExceptionCallBack(const EXCEPTION_RECORD Exception, const PCONTEXT pCTX) noexcept {
			if (Exception.ExceptionCode != EXCEPTION_ACCESS_VIOLATION) {
				return false;
			}

			const void* const pAddress = Exception.ExceptionAddress;
			if (!pAddress) {
				return false;
			}

			auto pHook = g_MemoryHooks.find(const_cast<void*>(pAddress));
			if (pHook == g_MemoryHooks.end()) {
				return false;
			}

			auto& pMemoryHook = pHook->second;
			if (!pMemoryHook) {
				return false;
			}

			if (pMemoryHook->IsAutoDisable()) {
				pMemoryHook->Disable();
			}

			const fnMemoryHookCallBack pCallBack = pMemoryHook->GetCallBack();
			if (!pCallBack) {
				return false;
			}

			if (!pCallBack(pMemoryHook.get(), pCTX)) {
				return false;
			}

			return true;
		}

		MemoryHook::MemoryHook(const void* const pAddress, const size_t unSize, bool bAutoDisable) : m_pAddress(pAddress), m_unSize(unSize) {
			m_bAutoDisable = bAutoDisable;
			m_pCallBack = nullptr;
		}

		MemoryHook::~MemoryHook() {
			UnHook();
		}

		bool MemoryHook::Hook(const fnMemoryHookCallBack pCallBack) {
			if (!m_pAddress) {
				return false;
			}

			if (!m_unSize) {
				return false;
			}

			if (m_pCallBack) {
				return false;
			}

			m_pCallBack = pCallBack;

			auto pMemory = std::make_unique<Protection>(m_pAddress, m_unSize);
			if (!pMemory) {
				return false;
			}

			const void* const pMemoryAddress = pMemory->GetAddress();
			if (!pMemoryAddress) {
				return false;
			}

			auto pProtection = g_Protections.find(const_cast<void*>(pMemoryAddress));
			if (pProtection != g_Protections.end()) {
				return false;
			}

			DWORD unProtection = 0;
			if (!pMemory->GetProtection(&unProtection)) {
				return false;
			}

			if (unProtection & PAGE_EXECUTE) {
				unProtection &= ~(PAGE_EXECUTE);
			}

			if (unProtection & PAGE_EXECUTE_READ) {
				unProtection &= ~(PAGE_EXECUTE_READ);
			}

			if (unProtection & PAGE_EXECUTE_READWRITE) {
				unProtection &= ~(PAGE_EXECUTE_READWRITE);
			}

			if (!unProtection) {
				unProtection |= PAGE_READONLY;
			}

			if (!pMemory->ChangeProtection(unProtection)) {
				return false;
			}

			g_Protections.insert(std::pair<void*, std::unique_ptr<Protection>>(const_cast<void*>(pMemoryAddress), std::move(pMemory)));
			return true;
		}

		bool MemoryHook::UnHook() {
			if (!m_pAddress) {
				return false;
			}

			if (!m_unSize) {
				return false;
			}

			if (!m_pCallBack) {
				return false;
			}

			return RestoreProtection(m_pAddress);
		}

		bool MemoryHook::Enable() {
			if (!m_pAddress) {
				return false;
			}

			if (!m_unSize) {
				return false;
			}

			if (!m_pCallBack) {
				return false;
			}

			auto pProtection = g_Protections.find(const_cast<void*>(m_pAddress));
			if (pProtection == g_Protections.end()) {
				return false;
			}

			auto& pMemoryProtection = pProtection->second;
			if (!pMemoryProtection) {
				return false;
			}

			DWORD unProtection = 0;
			if (!pMemoryProtection->GetProtection(&unProtection)) {
				return false;
			}

			if (unProtection & PAGE_EXECUTE) {
				unProtection &= ~(PAGE_EXECUTE);
			}

			if (unProtection & PAGE_EXECUTE_READ) {
				unProtection &= ~(PAGE_EXECUTE_READ);
			}

			if (unProtection & PAGE_EXECUTE_READWRITE) {
				unProtection &= ~(PAGE_EXECUTE_READWRITE);
			}

			if (!unProtection) {
				unProtection |= PAGE_READONLY;
			}

			if (!pMemoryProtection->ChangeProtection(unProtection)) {
				return false;
			}

			return true;
		}

		bool MemoryHook::Disable() {
			if (!m_pAddress) {
				return false;
			}

			if (!m_unSize) {
				return false;
			}

			if (!m_pCallBack) {
				return false;
			}

			auto pProtection = g_Protections.find(const_cast<void*>(m_pAddress));
			if (pProtection == g_Protections.end()) {
				return false;
			}

			auto& pMemoryProtection = pProtection->second;
			if (!pMemoryProtection) {
				return false;
			}

			return pMemoryProtection->RestoreProtection();
		}

		const void* const MemoryHook::GetAddress() {
			return m_pAddress;
		}

		const size_t MemoryHook::GetSize() {
			return m_unSize;
		}

		bool MemoryHook::IsAutoDisable() {
			return m_bAutoDisable;
		}

		fnMemoryHookCallBack MemoryHook::GetCallBack() {
			return m_pCallBack;
		}

		// ----------------------------------------------------------------
		// Simple Memory Hook
		// ----------------------------------------------------------------

		bool HookMemory(const void* const pAddress, const fnMemoryHookCallBack pCallBack, bool bAutoDisable) {
			if (!pAddress) {
				return false;
			}

			if (!pCallBack) {
				return false;
			}

			auto pHook = std::make_unique<MemoryHook>(pAddress, 1, bAutoDisable);
			if (!pHook) {
				return false;
			}

			if (!pHook->Hook(pCallBack)) {
				return false;
			}

			g_MemoryHooks.insert(std::pair<void*, std::unique_ptr<MemoryHook>>(const_cast<void*>(pAddress), std::move(pHook)));
			return true;
		}

		bool UnHookMemory(const fnMemoryHookCallBack pCallBack) {
			if (!pCallBack) {
				return false;
			}

			for (auto it = g_MemoryHooks.begin(); it != g_MemoryHooks.end(); ++it) {
				auto& pMemoryHook = it->second;
				if (!pMemoryHook) {
					continue;
				}

				if (pCallBack == pMemoryHook->GetCallBack()) {
					g_MemoryHooks.erase(it);
					return true;
				}
			}

			return false;
		}

		bool EnableHookMemory(const fnMemoryHookCallBack pCallBack) {
			if (!pCallBack) {
				return false;
			}

			for (auto it = g_MemoryHooks.begin(); it != g_MemoryHooks.end(); ++it) {
				auto& pMemoryHook = it->second;
				if (!pMemoryHook) {
					continue;
				}

				if (pCallBack == pMemoryHook->GetCallBack()) {
					pMemoryHook->Enable();
					return true;
				}
			}

			return false;
		}

		bool DisableHookMemory(const fnMemoryHookCallBack pCallBack) {
			if (!pCallBack) {
				return false;
			}

			for (auto it = g_MemoryHooks.begin(); it != g_MemoryHooks.end(); ++it) {
				auto& pMemoryHook = it->second;
				if (!pMemoryHook) {
					continue;
				}

				if (pCallBack == pMemoryHook->GetCallBack()) {
					pMemoryHook->Disable();
					return true;
				}
			}

			return false;
		}
	}
}

```

`DumpVAC/Detours/Detours.h`:

```h
#pragma once

#ifndef _DETOURS_H_
#define _DETOURS_H_

// Default
#include <Windows.h>

// C++
#include <cstdlib>

// STL
#include <array>

// ----------------------------------------------------------------
// General definitions
// ----------------------------------------------------------------

#ifndef DETOURS_MAX_STRSIZE
#define DETOURS_MAX_STRSIZE 0x1000 // 4 KiB
#endif // !DETOURS_MAX_SIZE

// Macro to declare a const 8-byte array.
#define DECLARE_SECTOR_NAME(...) std::array<const unsigned char, 8>({ __VA_ARGS__ })

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

// ----------------------------------------------------------------
// Checking platform
// ----------------------------------------------------------------

#if !defined(_M_IX86) && !defined(_M_X64)
#error Only x86 and x86_64 platforms are supported.
#endif // !_M_IX86 && !_M_X64

#if !defined(_WIN32) && !defined(_WIN64)
#error Only Windows platform are supported.
#endif // !_WIN32 && !_WIN64

// ----------------------------------------------------------------
// Detours
// ----------------------------------------------------------------

namespace Detours {

	// ----------------------------------------------------------------
	// KUSER_SHARED_DATA
	// ----------------------------------------------------------------

#pragma pack(push, 4)
	typedef struct _KSYSTEM_TIME {
		ULONG LowPart;
		LONG High1Time;
		LONG High2Time;
	} KSYSTEM_TIME, *PKSYSTEM_TIME;

	typedef enum _NT_PRODUCT_TYPE : unsigned int {
		NtProductWinNt = 1,
		NtProductLanManNt = 2,
		NtProductServer = 3
	} NT_PRODUCT_TYPE;

	typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE : unsigned int {
		StandardDesign = 0,
		NEC98x86 = 1,
		EndAlternatives = 2
	} ALTERNATIVE_ARCHITECTURE_TYPE;

	typedef struct _KUSER_SHARED_DATA {
		ULONG TickCountLowDeprecated;
		ULONG TickCountMultiplier;
		volatile KSYSTEM_TIME InterruptTime;
		volatile KSYSTEM_TIME SystemTime;
		volatile KSYSTEM_TIME TimeZoneBias;
		USHORT ImageNumberLow;
		USHORT ImageNumberHigh;
		WCHAR NtSystemRoot[260];
		ULONG MaxStackTraceDepth;
		ULONG CryptoExponent;
		ULONG TimeZoneId;
		ULONG LargePageMinimum;
		ULONG AitSamplingValue;
		ULONG AppCompatFlag;
		ULONGLONG RNGSeedVersion;
		ULONG GlobalValidationRunlevel;
		LONG TimeZoneBiasStamp;
		ULONG NtBuildNumber;
		NT_PRODUCT_TYPE NtProductType;
		BOOLEAN ProductTypeIsValid;
		UCHAR Reserved0[1];
		USHORT NativeProcessorArchitecture;
		ULONG NtMajorVersion;
		ULONG NtMinorVersion;
		BOOLEAN ProcessorFeatures[64];
		ULONG Reserved1;
		ULONG Reserved3;
		volatile ULONG TimeSlip;
		ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
		ULONG BootId;
		LARGE_INTEGER SystemExpirationDate;
		ULONG SuiteMask;
		BOOLEAN KdDebuggerEnabled;
		union {
			UCHAR MitigationPolicies;
			struct {
				UCHAR NXSupportPolicy : 2;
				UCHAR SEHValidationPolicy : 2;
				UCHAR CurDirDevicesSkippedForDlls : 2;
				UCHAR Reserved : 2;
			};
		};
		USHORT CyclesPerYield;
		volatile ULONG ActiveConsoleId;
		volatile ULONG DismountCount;
		ULONG ComPlusPackage;
		ULONG LastSystemRITEventTickCount;
		ULONG NumberOfPhysicalPages;
		BOOLEAN SafeBootMode;
		UCHAR VirtualizationFlags;
		UCHAR Reserved12[2];
		union {
			ULONG SharedDataFlags;
			struct {
				ULONG DbgErrorPortPresent : 1;
				ULONG DbgElevationEnabled : 1;
				ULONG DbgVirtEnabled : 1;
				ULONG DbgInstallerDetectEnabled : 1;
				ULONG DbgLkgEnabled : 1;
				ULONG DbgDynProcessorEnabled : 1;
				ULONG DbgConsoleBrokerEnabled : 1;
				ULONG DbgSecureBootEnabled : 1;
				ULONG DbgMultiSessionSku : 1;
				ULONG DbgMultiUsersInSessionSku : 1;
				ULONG DbgStateSeparationEnabled : 1;
				ULONG SpareBits : 21;
			};
		};
		ULONG DataFlagsPad[1];
		ULONGLONG TestRetInstruction;
		LONGLONG QpcFrequency;
		ULONG SystemCall;
		union {
			ULONG AllFlags;
			struct {
				ULONG Win32Process : 1;
				ULONG Sgx2Enclave : 1;
				ULONG VbsBasicEnclave : 1;
				ULONG SpareBits : 29;
			};
		} UserCetAvailableEnvironments;
		ULONGLONG SystemCallPad[2];
		union {
			volatile KSYSTEM_TIME TickCount;
			volatile ULONG64 TickCountQuad;
			struct {
				ULONG ReservedTickCountOverlay[3];
				ULONG TickCountPad[1];
			};
		};
		ULONG Cookie;
		ULONG CookiePad[1];
		LONGLONG ConsoleSessionForegroundProcessId;
		ULONGLONG TimeUpdateLock;
		ULONGLONG BaselineSystemTimeQpc;
		ULONGLONG BaselineInterruptTimeQpc;
		ULONGLONG QpcSystemTimeIncrement;
		ULONGLONG QpcInterruptTimeIncrement;
		UCHAR QpcSystemTimeIncrementShift;
		UCHAR QpcInterruptTimeIncrementShift;
		USHORT UnparkedProcessorCount;
		ULONG EnclaveFeatureMask[4];
		ULONG TelemetryCoverageRound;
		USHORT UserModeGlobalLogger[16];
		ULONG ImageFileExecutionOptions;
		ULONG LangGenerationCount;
		ULONGLONG Reserved4;
		volatile ULONGLONG InterruptTimeBias;
		volatile ULONGLONG QpcBias;
		ULONG ActiveProcessorCount;
		volatile UCHAR ActiveGroupCount;
		UCHAR Reserved9;
		union {
			USHORT QpcData;
			struct {
				volatile UCHAR QpcBypassEnabled : 1;
				UCHAR QpcShift : 1;
			};
		};
		LARGE_INTEGER TimeZoneBiasEffectiveStart;
		LARGE_INTEGER TimeZoneBiasEffectiveEnd;
		XSTATE_CONFIGURATION XState;
		KSYSTEM_TIME FeatureConfigurationChangeStamp;
		ULONG Spare;
	} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
#pragma pack(pop)

	extern const KUSER_SHARED_DATA& KUserSharedData;

	// ----------------------------------------------------------------
	// PEB
	// ----------------------------------------------------------------

#pragma pack(push, 8)
	typedef struct _PEB_LDR_DATA {
		ULONG Length;
		BOOLEAN Initialized;
		HANDLE SsHandle;
		LIST_ENTRY InLoadOrderModuleList;
		LIST_ENTRY InMemoryOrderModuleList;
		LIST_ENTRY InInitializationOrderModuleList;
		PVOID EntryInProgress;
		BOOLEAN ShutdownInProgress;
		HANDLE ShutdownThreadId;
	} PEB_LDR_DATA, *PPEB_LDR_DATA;

	typedef struct _UNICODE_STRING {
		USHORT Length;
		USHORT MaximumLength;
		PWCHAR Buffer;
	} UNICODE_STRING, *PUNICODE_STRING;

	typedef struct _CURDIR {
		UNICODE_STRING DosPath;
		HANDLE Handle;
	} CURDIR, *PCURDIR;

	typedef struct _STRING {
		USHORT Length;
		USHORT MaximumLength;
		PCHAR Buffer;
	} STRING, *PSTRING;

	typedef struct _RTL_DRIVE_LETTER_CURDIR {
		USHORT Flags;
		USHORT Length;
		ULONG TimeStamp;
		STRING DosPath;
	} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

	typedef struct _RTL_USER_PROCESS_PARAMETERS {
		ULONG MaximumLength;
		ULONG Length;
		ULONG Flags;
		ULONG DebugFlags;
		HANDLE ConsoleHandle;
		ULONG ConsoleFlags;
		HANDLE StandardInput;
		HANDLE StandardOutput;
		HANDLE StandardError;
		CURDIR CurrentDirectory;
		UNICODE_STRING DllPath;
		UNICODE_STRING ImagePathName;
		UNICODE_STRING CommandLine;
		PVOID Environment;
		ULONG StartingX;
		ULONG StartingY;
		ULONG CountX;
		ULONG CountY;
		ULONG CountCharsX;
		ULONG CountCharsY;
		ULONG FillAttribute;
		ULONG WindowFlags;
		ULONG ShowWindowFlags;
		UNICODE_STRING WindowTitle;
		UNICODE_STRING DesktopInfo;
		UNICODE_STRING ShellInfo;
		UNICODE_STRING RuntimeData;
		RTL_DRIVE_LETTER_CURDIR CurrentDirectories[32];
		ULONG_PTR EnvironmentSize;
		ULONG_PTR EnvironmentVersion;
		PVOID PackageDependencyData;
		ULONG ProcessGroupId;
		ULONG LoaderThreads;
		UNICODE_STRING RedirectionDllName;
		UNICODE_STRING HeapPartitionName;
		ULONG_PTR DefaultThreadpoolCpuSetMasks;
		ULONG DefaultThreadpoolCpuSetMaskCount;
	} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

	typedef struct _API_SET_NAMESPACE {
		ULONG Version;
		ULONG Size;
		ULONG Flags;
		ULONG Count;
		ULONG EntryOffset;
		ULONG HashOffset;
		ULONG HashFactor;
	} API_SET_NAMESPACE, *PAPI_SET_NAMESPACE;

	typedef struct _LEAP_SECOND_DATA {
		UCHAR Enabled;
		ULONG Count;
		LARGE_INTEGER Data[1];
	} LEAP_SECOND_DATA, *PLEAP_SECOND_DATA;

	typedef struct _PEB {
		BOOLEAN InheritedAddressSpace;
		BOOLEAN ReadImageFileExecOptions;
		BOOLEAN BeingDebugged;
		union {
			BOOLEAN BitField;
			struct {
				BOOLEAN ImageUsesLargePages : 1;
				BOOLEAN IsProtectedProcess : 1;
				BOOLEAN IsImageDynamicallyRelocated : 1;
				BOOLEAN SkipPatchingUser32Forwarders : 1;
				BOOLEAN IsPackagedProcess : 1;
				BOOLEAN IsAppContainer : 1;
				BOOLEAN IsProtectedProcessLight : 1;
				BOOLEAN IsLongPathAwareProcess : 1;
			};
		};
		HANDLE Mutant;
		PVOID ImageBaseAddress;
		PPEB_LDR_DATA Ldr;
		PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
		PVOID SubSystemData;
		PVOID ProcessHeap;
		PRTL_CRITICAL_SECTION FastPebLock;
		PSLIST_HEADER AtlThunkSListPtr;
		PVOID IFEOKey;
		union {
			ULONG CrossProcessFlags;
			struct {
				ULONG ProcessInJob : 1;
				ULONG ProcessInitializing : 1;
				ULONG ProcessUsingVEH : 1;
				ULONG ProcessUsingVCH : 1;
				ULONG ProcessUsingFTH : 1;
				ULONG ProcessPreviouslyThrottled : 1;
				ULONG ProcessCurrentlyThrottled : 1;
				ULONG ProcessImagesHotPatched : 1;
				ULONG ReservedBits0 : 24;
			};
		};
		union {
			PVOID KernelCallbackTable;
			PVOID UserSharedInfoPtr;
		};
		ULONG SystemReserved;
		ULONG AtlThunkSListPtr32;
		PAPI_SET_NAMESPACE ApiSetMap;
		ULONG TlsExpansionCounter;
		PVOID TlsBitmap;
		ULONG TlsBitmapBits[2];
		PVOID ReadOnlySharedMemoryBase;
		PVOID SharedData;
		PVOID* ReadOnlyStaticServerData;
		PVOID AnsiCodePageData;
		PVOID OemCodePageData;
		PVOID UnicodeCaseTableData;
		ULONG NumberOfProcessors;
		ULONG NtGlobalFlag;
		ULARGE_INTEGER CriticalSectionTimeout;
		SIZE_T HeapSegmentReserve;
		SIZE_T HeapSegmentCommit;
		SIZE_T HeapDeCommitTotalFreeThreshold;
		SIZE_T HeapDeCommitFreeBlockThreshold;
		ULONG NumberOfHeaps;
		ULONG MaximumNumberOfHeaps;
		PVOID* ProcessHeaps;
		PVOID GdiSharedHandleTable;
		PVOID ProcessStarterHelper;
		ULONG GdiDCAttributeList;
		PRTL_CRITICAL_SECTION LoaderLock;
		ULONG OSMajorVersion;
		ULONG OSMinorVersion;
		USHORT OSBuildNumber;
		USHORT OSCSDVersion;
		ULONG OSPlatformId;
		ULONG ImageSubsystem;
		ULONG ImageSubsystemMajorVersion;
		ULONG ImageSubsystemMinorVersion;
		KAFFINITY ActiveProcessAffinityMask;
#ifdef _M_X64
		ULONG GdiHandleBuffer[60];
#elif _M_IX86
		ULONG GdiHandleBuffer[34];
#endif
		PVOID PostProcessInitRoutine;
		PVOID TlsExpansionBitmap;
		ULONG TlsExpansionBitmapBits[32];
		ULONG SessionId;
		ULARGE_INTEGER AppCompatFlags;
		ULARGE_INTEGER AppCompatFlagsUser;
		PVOID pShimData;
		PVOID AppCompatInfo;
		UNICODE_STRING CSDVersion;
		PVOID ActivationContextData;
		PVOID ProcessAssemblyStorageMap;
		PVOID SystemDefaultActivationContextData;
		PVOID SystemAssemblyStorageMap;
		SIZE_T MinimumStackCommit;
		PVOID SparePointers[2];
		PVOID PatchLoaderData;
		PVOID ChpeV2ProcessInfo;
		ULONG AppModelFeatureState;
		ULONG SpareUlongs[2];
		USHORT ActiveCodePage;
		USHORT OemCodePage;
		USHORT UseCaseMapping;
		USHORT UnusedNlsField;
		PVOID WerRegistrationData;
		PVOID WerShipAssertPtr;
		PVOID EcCodeBitMap;
		PVOID pImageHeaderHash;
		union {
			ULONG TracingFlags;
			struct {
				ULONG HeapTracingEnabled : 1;
				ULONG CritSecTracingEnabled : 1;
				ULONG LibLoaderTracingEnabled : 1;
				ULONG SpareTracingBits : 29;
			};
		};
		ULONGLONG CsrServerReadOnlySharedMemoryBase;
		PRTL_CRITICAL_SECTION TppWorkerpListLock;
		LIST_ENTRY TppWorkerpList;
		PVOID WaitOnAddressHashTable[128];
		PVOID TelemetryCoverageHeader;
		ULONG CloudFileFlags;
		ULONG CloudFileDiagFlags;
		CHAR PlaceholderCompatibilityMode;
		CHAR PlaceholderCompatibilityModeReserved[7];
		PLEAP_SECOND_DATA LeapSecondData;
		union {
			ULONG LeapSecondFlags;
			struct {
				ULONG SixtySecondEnabled : 1;
				ULONG Reserved : 31;
			};
		};
		ULONG NtGlobalFlag2;
		ULONGLONG ExtendedFeatureDisableMask;
	} PEB, *PPEB;
#pragma pack(pop)

	const PPEB GetPEB();

	// ----------------------------------------------------------------
	// TEB
	// ----------------------------------------------------------------

#pragma pack(push, 8)
#ifdef _M_X64
	typedef struct _CLIENT_ID {
		ULONGLONG UniqueProcess;
		ULONGLONG UniqueThread;
	} CLIENT_ID, *PCLIENT_ID;
#elif _M_IX86
	typedef struct _CLIENT_ID {
		ULONG UniqueProcess;
		ULONG UniqueThread;
	} CLIENT_ID, *PCLIENT_ID;
#endif

	typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
		struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* Previous;
		struct _ACTIVATION_CONTEXT* ActivationContext;
		ULONG Flags;
	} RTL_ACTIVATION_CONTEXT_STACK_FRAME, *PRTL_ACTIVATION_CONTEXT_STACK_FRAME;

	typedef struct _ACTIVATION_CONTEXT_STACK {
		PRTL_ACTIVATION_CONTEXT_STACK_FRAME ActiveFrame;
		LIST_ENTRY FrameListCache;
		ULONG Flags;
		ULONG NextCookieSequenceNumber;
		ULONG StackId;
	} ACTIVATION_CONTEXT_STACK, *PACTIVATION_CONTEXT_STACK;

	typedef struct _GDI_TEB_BATCH {
		ULONG Offset;
		ULONG_PTR HDC;
		ULONG Buffer[310];
	} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

	typedef struct _TEB_ACTIVE_FRAME_CONTEXT {
		ULONG Flags;
		PSTR FrameName;
	} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

	typedef struct _TEB_ACTIVE_FRAME {
		ULONG Flags;
		struct _TEB_ACTIVE_FRAME* Previous;
		PTEB_ACTIVE_FRAME_CONTEXT Context;
	} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

	typedef struct _TEB {
		NT_TIB NtTib;
		PVOID EnvironmentPointer;
		CLIENT_ID ClientId;
		PVOID ActiveRpcHandle;
		PVOID ThreadLocalStoragePointer;
		PPEB ProcessEnvironmentBlock;
		ULONG LastErrorValue;
		ULONG CountOfOwnedCriticalSections;
		PVOID CsrClientThread;
		PVOID Win32ThreadInfo;
		ULONG User32Reserved[26];
		ULONG UserReserved[5];
		PVOID WOW32Reserved;
		LCID CurrentLocale;
		ULONG FpSoftwareStatusRegister;
		PVOID ReservedForDebuggerInstrumentation[16];
#ifdef _M_X64
		PVOID SystemReserved1[30];
#elif _M_IX86
		PVOID SystemReserved1[26];
#endif
		CHAR PlaceholderCompatibilityMode;
		BOOLEAN PlaceholderHydrationAlwaysExplicit;
		CHAR PlaceholderReserved[10];
		ULONG ProxiedProcessId;
		ACTIVATION_CONTEXT_STACK ActivationStack;
		UCHAR WorkingOnBehalfTicket[8];
		NTSTATUS ExceptionCode;
		PACTIVATION_CONTEXT_STACK ActivationContextStackPointer;
		ULONG_PTR InstrumentationCallbackSp;
		ULONG_PTR InstrumentationCallbackPreviousPc;
		ULONG_PTR InstrumentationCallbackPreviousSp;
#ifdef _M_X64
		ULONG TxFsContext;
#endif
		BOOLEAN InstrumentationCallbackDisabled;
#ifdef _M_X64
		BOOLEAN UnalignedLoadStoreExceptions;
#endif
#ifdef _M_IX86
		UCHAR SpareBytes[23];
		ULONG TxFsContext;
#endif
		GDI_TEB_BATCH GdiTebBatch;
		CLIENT_ID RealClientId;
		HANDLE GdiCachedProcessHandle;
		ULONG GdiClientPID;
		ULONG GdiClientTID;
		PVOID GdiThreadLocalInfo;
		ULONG_PTR Win32ClientInfo[62];
		PVOID glDispatchTable[233];
		ULONG_PTR glReserved1[29];
		PVOID glReserved2;
		PVOID glSectionInfo;
		PVOID glSection;
		PVOID glTable;
		PVOID glCurrentRC;
		PVOID glContext;
		NTSTATUS LastStatusValue;
		UNICODE_STRING StaticUnicodeString;
		WCHAR StaticUnicodeBuffer[261];
		PVOID DeallocationStack;
		PVOID TlsSlots[64];
		LIST_ENTRY TlsLinks;
		PVOID Vdm;
		PVOID ReservedForNtRpc;
		PVOID DbgSsReserved[2];
		ULONG HardErrorMode;
#ifdef _M_X64
		PVOID Instrumentation[11];
#elif _M_IX86
		PVOID Instrumentation[9];
#endif
		GUID ActivityId;
		PVOID SubProcessTag;
		PVOID PerflibData;
		PVOID EtwTraceData;
		PVOID WinSockData;
		ULONG GdiBatchCount;
		union {
			PROCESSOR_NUMBER CurrentIdealProcessor;
			ULONG IdealProcessorValue;
			struct {
				UCHAR ReservedPad0;
				UCHAR ReservedPad1;
				UCHAR ReservedPad2;
				UCHAR IdealProcessor;
			};
		};
		ULONG GuaranteedStackBytes;
		PVOID ReservedForPerf;
		PVOID ReservedForOle;
		ULONG WaitingOnLoaderLock;
		PVOID SavedPriorityState;
		ULONG_PTR ReservedForCodeCoverage;
		PVOID ThreadPoolData;
		PVOID* TlsExpansionSlots;
#ifdef _M_X64
		PVOID DeallocationBStore;
		PVOID BStoreLimit;
#endif
		ULONG MuiGeneration;
		ULONG IsImpersonating;
		PVOID NlsCache;
		PVOID pShimData;
		ULONG HeapData;
		HANDLE CurrentTransactionHandle;
		PTEB_ACTIVE_FRAME ActiveFrame;
		PVOID FlsData;
		PVOID PreferredLanguages;
		PVOID UserPrefLanguages;
		PVOID MergedPrefLanguages;
		ULONG MuiImpersonation;
		union {
			USHORT CrossTebFlags;
			USHORT SpareCrossTebBits : 16;
		};
		union {
			USHORT SameTebFlags;
			struct {
				USHORT SafeThunkCall : 1;
				USHORT InDebugPrint : 1;
				USHORT HasFiberData : 1;
				USHORT SkipThreadAttach : 1;
				USHORT WerInShipAssertCode : 1;
				USHORT RanProcessInit : 1;
				USHORT ClonedThread : 1;
				USHORT SuppressDebugMsg : 1;
				USHORT DisableUserStackWalk : 1;
				USHORT RtlExceptionAttached : 1;
				USHORT InitialThread : 1;
				USHORT SessionAware : 1;
				USHORT LoadOwner : 1;
				USHORT LoaderWorker : 1;
				USHORT SkipLoaderInit : 1;
				USHORT SkipFileAPIBrokering : 1;
			};
		};
		PVOID TxnScopeEnterCallback;
		PVOID TxnScopeExitCallback;
		PVOID TxnScopeContext;
		ULONG LockCount;
		LONG WowTebOffset;
		PVOID ResourceRetValue;
		PVOID ReservedForWdf;
		ULONGLONG ReservedForCrt;
		GUID EffectiveContainerId;
		ULONGLONG LastSleepCounter;
		ULONG SpinCallCount;
		ULONGLONG ExtendedFeatureDisableMask;
	} TEB, *PTEB;
#pragma pack(pop)

	const PTEB GetTEB();

	// ----------------------------------------------------------------
	// Scan
	// ----------------------------------------------------------------
	// TODO: Add multiple finding.

	namespace Scan {

		// ----------------------------------------------------------------
		// FindSection
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding section in module.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pAddress'>Section address.</param>
		/// <param name='pSize'>Section size.</param>
		/// <returns>Returns True on success, False otherwise.</returns>
		bool FindSection(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, void** pAddress, size_t* pSize);

		// ----------------------------------------------------------------
		// FindSectionPOGO
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding section in module.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pAddress'>Section address.</param>
		/// <param name='pSize'>Section size.</param>
		/// <returns>Returns True on success, False otherwise.</returns>
		bool FindSectionPOGO(const HMODULE hModule, const char* const szSectionName, void** pAddress, const size_t* pSize);

		// ----------------------------------------------------------------
		// FindSignature (Native)
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding signature in data without SIMD by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNative(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNative(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNative(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNative(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNativeA(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNativeA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNativeA(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNativeW(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNativeW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNativeW(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

#ifdef UNICODE
		/// <summary>
		/// Finding signature in data without SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNative(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNative(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNative(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#else
		/// <summary>
		/// Finding signature in data without SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNative(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNative(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureNative(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#endif

		// ----------------------------------------------------------------
		// FindSignature (SSE2)
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2A(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2A(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2W(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2W(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

#ifdef UNICODE
		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>

		const void* const FindSignatureSSE2(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#else
		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (SSE2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureSSE2(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#endif

		// ----------------------------------------------------------------
		// FindSignature (AVX)
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVXA(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVXA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVXA(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVXW(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVXW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVXW(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

#ifdef UNICODE
		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#else
		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#endif

		// ----------------------------------------------------------------
		// FindSignature (AVX2)
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
		
		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
		
		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2A(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2A(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2W(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2W(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

#ifdef UNICODE
		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#else
		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX2(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#endif

		// ----------------------------------------------------------------
		// FindSignature (AVX512) [AVX512BW]
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512A(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512A(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512W(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512W(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

#ifdef UNICODE
		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#else
		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data with SIMD (AVX512) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureAVX512(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#endif

		// ----------------------------------------------------------------
		// FindSignature (Auto)
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding signature in data without/with SIMD by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignature(const void* const pAddress, const size_t unSize, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without/with SIMD by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignature(const HMODULE hModule, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
		
		/// <summary>
		/// Finding signature in data without/with SIMD by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignature(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
		
		/// <summary>
		/// Finding signature in data without/with SIMD by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignature(const HMODULE hModule, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureA(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without/with SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without/with SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureA(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureW(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without/with SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without/with SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignatureW(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

#ifdef UNICODE
		/// <summary>
		/// Finding signature in data without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignature(const wchar_t* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without/with SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignature(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without/with SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignature(const wchar_t* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#else
		/// <summary>
		/// Finding signature in data without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignature(const char* const szModuleName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without/with SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignature(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);

		/// <summary>
		/// Finding signature in data without/with SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='szSignature'>Desired data signature.</param>
		/// <param name='unIgnoredByte'>Byte to ignore in signature.</param>
		/// <returns>Returns address of data from signature on success, null otherwise.</returns>
		const void* const FindSignature(const char* const szModuleName, const char* const szSectionName, const char* const szSignature, const unsigned char unIgnoredByte = 0x2A);
#endif

		// ----------------------------------------------------------------
		// FindData (Native)
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding data-in-data without SIMD by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNative(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNative(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNative(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNative(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNativeA(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNativeA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNativeA(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNativeW(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNativeW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module name POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNativeW(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

#ifdef UNICODE
		/// <summary>
		/// Finding data-in-data without SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNative(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNative(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNative(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#else
		/// <summary>
		/// Finding data-in-data without SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNative(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNative(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataNative(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#endif

		// ----------------------------------------------------------------
		// FindData (SSE2)
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2A(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2A(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2W(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2W(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

#ifdef UNICODE
		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#else
		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (SSE2) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataSSE2(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#endif

		// ----------------------------------------------------------------
		// FindData (AVX)
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVXA(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVXA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVXA(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVXW(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVXW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVXW(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

#ifdef UNICODE
		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#else
		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#endif

		// ----------------------------------------------------------------
		// FindData (AVX2)
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2A(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2A(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2W(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2W(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

#ifdef UNICODE
		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#else
		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX2) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX2(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#endif

		// ----------------------------------------------------------------
		// FindData (AVX512) [AVX512BW]
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512A(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512A(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512A(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512W(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512W(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512W(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

#ifdef UNICODE
		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#else
		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data with SIMD (AVX512) by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataAVX512(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#endif

		// ----------------------------------------------------------------
		// FindData (Auto)
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding data-in-data without/with SIMD by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindData(const void* const pAddress, const size_t unSize, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without/with SIMD by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindData(const HMODULE hModule, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data without/with SIMD by module handle and section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindData(const HMODULE hModule, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data without/with SIMD by module handle and POGO section name.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindData(const HMODULE hModule, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataA(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data without/with SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataA(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data without/with SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataA(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataW(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data without/with SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataW(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);
		
		/// <summary>
		/// Finding data-in-data without/with SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindDataW(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);

#ifdef UNICODE
		/// <summary>
		/// Finding data-in-data without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindData(const wchar_t* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without/with SIMD by module name and seciton name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindData(const wchar_t* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without/with SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindData(const wchar_t* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#else
		/// <summary>
		/// Finding data-in-data without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindData(const char* const szModuleName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without/with SIMD by module name and section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='SectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindData(const char* const szModuleName, const std::array<const unsigned char, 8>& SectionName, const unsigned char* const pData, const size_t unDataSize);

		/// <summary>
		/// Finding data-in-data without/with SIMD by module name and POGO section name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szSectionName'>Section name.</param>
		/// <param name='pData'>Desired data.</param>
		/// <param name='unDataSize'>Size of desired data in bytes</param>
		/// <returns>Returns address of data from data on success, null otherwise.</returns>
		const void* const FindData(const char* const szModuleName, const char* const szSectionName, const unsigned char* const pData, const size_t unDataSize);
#endif

		// ----------------------------------------------------------------
		// FindRTTI
		// ----------------------------------------------------------------

		/// <summary>
		/// Finding for a virtual table in run-time type information without/with SIMD by address and size.
		/// </summary>
		/// <param name='pAddress'>Data address.</param>
		/// <param name='unSize'>The size of the data in bytes.</param>
		/// <param name='szRTTI'>Desired virtual table from run-time type information.</param>
		/// <returns>Returns address of virtual table from run-time type information on success, null otherwise.</returns>
		const void* const FindRTTI(const void* const pBaseAddress, const size_t unSize, const char* const szRTTI);

		/// <summary>
		/// Finding for a virtual table in run-time type information without/with SIMD by module handle.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szRTTI'>Desired virtual table from run-time type information.</param>
		/// <returns>Returns address of virtual table from run-time type information on success, null otherwise.</returns>
		const void* const FindRTTI(const HMODULE hModule, const char* const szRTTI);

		/// <summary>
		/// Finding for a virtual table in run-time type information without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szRTTI'>Desired virtual table from run-time type information.</param>
		/// <returns>Returns address of virtual table from run-time type information on success, null otherwise.</returns>
		const void* const FindRTTIA(const char* const szModuleName, const char* const szRTTI);

		/// <summary>
		/// Finding for a virtual table in run-time type information without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szRTTI'>Desired virtual table from run-time type information.</param>
		/// <returns>Returns address of virtual table from run-time type information on success, null otherwise.</returns>
		const void* const FindRTTIW(const wchar_t* const szModuleName, const char* const szRTTI);

#ifdef UNICODE
		/// <summary>
		/// Finding for a virtual table in run-time type information without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szRTTI'>Desired virtual table from run-time type information.</param>
		/// <returns>Returns address of virtual table from run-time type information on success, null otherwise.</returns>
		const void* const FindRTTI(const wchar_t* const szModuleName, const char* const szRTTI);
#else
		/// <summary>
		/// Finding for a virtual table in run-time type information without/with SIMD by module name.
		/// </summary>
		/// <param name='szModuleName'>Module name.</param>
		/// <param name='szRTTI'>Desired virtual table from run-time type information.</param>
		/// <returns>Returns address of virtual table from run-time type information on success, null otherwise.</returns>
		const void* const FindRTTI(const char* const szModuleName, const char* const szRTTI);
#endif
	}

	// ----------------------------------------------------------------
	// Memory
	// ----------------------------------------------------------------

	namespace Memory {

		// ----------------------------------------------------------------
		// Server
		// ----------------------------------------------------------------

		class Server {
		public:
			Server(const size_t unMemorySize, bool bIsGlobal = false);
			~Server();

		public:
			bool GetSessionName(TCHAR szSessionName[64]);
			void* GetAddress();

		private:
			const size_t m_unMemorySize;
			TCHAR m_szSessionName[64];
			HANDLE m_hMap;
			void* m_pAddress;
		};

		// ----------------------------------------------------------------
		// Client
		// ----------------------------------------------------------------

		class Client {
		public:
			Client(const size_t unMemorySize, TCHAR szSessionName[64], bool bIsGlobal = false);
			~Client();

		public:
			void* GetAddress();

		private:
			const size_t m_unMemorySize;
			HANDLE m_hMap;
			void* m_pAddress;
		};

		// ----------------------------------------------------------------
		// Protection
		// ----------------------------------------------------------------

		/// <summary>
		/// Memory protection that automatically restores protection.
		/// </summary>
		class Protection {
		public:
			/// <summary>
			/// Memory protection that automatically restores protection.
			/// </summary>
			/// <param name='pAddress'>Memory address.</param>
			/// <param name='unSize'>Memory size.</param>
			Protection(const void* const pAddress, const size_t unSize);
			~Protection();

		public:
			/// <summary>
			/// Get current memory protection.</returns>
			/// </summary>
			/// <param name='pProtection'>Recording address.</param>
			/// <returns>Returns True on success, False otherwise.</returns>
			bool GetProtection(const PDWORD pProtection);

			/// <summary>
			/// Change memory protection.
			/// </summary>
			/// <param name='unFlag'>Memory protection flag.</param>
			/// <returns>Returns True on success, False otherwise.</returns>
			bool ChangeProtection(const DWORD unNewProtection);

			/// <summary>
			/// Restore memory protection.
			/// </summary>
			/// <returns>Returns True on success, False otherwise.</returns>
			bool RestoreProtection();

		public:
			/// <returns>Returns memory address.</returns>
			const void* const GetAddress();

			/// <returns>Returns memory size.</returns>
			const size_t GetSize();

			/// <returns>Returns original memory protection.</returns>
			DWORD GetOriginalProtection();

		private:
			const void* const m_pAddress;
			const size_t m_unSize;
			DWORD m_unOriginalProtection;
		};

		// ----------------------------------------------------------------
		// Simple Protection
		// ----------------------------------------------------------------

		/// <summary>
		/// Change memory protection.
		/// </summary>
		/// <param name='pAddress'>Memory address.</param>
		/// <param name='unSize'>Memory size.</param>
		/// <param name='unFlag'>Memory protection flag.</param>
		/// <returns>Returns True on success, False otherwise.</returns>
		bool ChangeProtection(const void* const pAddress, const size_t unSize, const DWORD unNewProtection);

		/// <summary>
		/// Restore memory protection.
		/// </summary>
		/// <param name='pAddress'>Memory address.</param>
		bool RestoreProtection(const void* const pAddress);
	}

	// ----------------------------------------------------------------
	// Exception
	// ----------------------------------------------------------------

	namespace Exception {

		// ----------------------------------------------------------------
		// ExceptionCallBack
		// ----------------------------------------------------------------

		typedef bool(__fastcall* fnExceptionCallBack)(const EXCEPTION_RECORD Exception, const PCONTEXT pCTX);

		// ----------------------------------------------------------------
		// Exception
		// ----------------------------------------------------------------

		bool AddCallBack(const fnExceptionCallBack pCallBack);
		bool RemoveCallBack(const fnExceptionCallBack pCallBack);
	}

	// ----------------------------------------------------------------
	// Hook
	// ----------------------------------------------------------------

	namespace Hook {

		// ----------------------------------------------------------------
		// Import Hook
		// ----------------------------------------------------------------

		/// <summary>
		/// Hook that automatically unhooking.
		/// </summary>
		class ImportHook {
		public:
			/// <summary>
			/// Hook that automatically unhooking.
			/// </summary>
			/// <param name='szModuleName'>Module name.</param>
			/// <param name='szExportName'>Importing name.</param>
			/// <param name='szImportModuleName'>Importing module name.</param>
			ImportHook(const HMODULE hModule, const char* const szImportName, const char* const szImportModuleName = nullptr);
			~ImportHook();

		public:
			/// <summary>
			/// Hook with a specific address.
			/// </summary>
			/// <param name='pHookAddress'>Hook address.</param>
			bool Hook(const void* const pHookAddress);

			/// <summary>
			/// UnHook.
			/// </summary>
			bool UnHook();

		public:
			/// <returns>Returns original address.</returns>
			const void* GetOriginalAddress();

			/// <returns>Returns hook address.</returns>
			const void* GetHookAddress();

		private:
			const void** m_pAddress;
			const void* m_pOriginalAddress;
			const void* m_pHookAddress;
		};

		// ----------------------------------------------------------------
		// Simple Import Hook
		// ----------------------------------------------------------------

		/// <summary>
		/// Hook with a specific address.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szImportName'>Importing name.</param>
		/// <param name='pHookAddress'>Hook address.</param>
		/// <returns>Returns True on success, False otherwise.</returns>
		bool HookImport(const HMODULE hModule, const char* const szImportName, const void* const pHookAddress);

		/// <summary>
		/// UnHook.
		/// </summary>
		/// <param name='pHookAddress'>Hook address.</param>
		bool UnHookImport(const void* const pHookAddress);

		// ----------------------------------------------------------------
		// Export Hook
		// ----------------------------------------------------------------

		/// <summary>
		/// Hook that automatically unhooking.
		/// </summary>
		class ExportHook {
		public:
			/// <summary>
			/// Hook that automatically unhooking.
			/// </summary>
			/// <param name='szModuleName'>Module name.</param>
			/// <param name='szExportName'>Exporting name.</param>
			ExportHook(const HMODULE hModule, const char* const szExportName);
			~ExportHook();

		public:
			/// <summary>
			/// Hook with a specific address.
			/// </summary>
			/// <param name='pHookAddress'>Hook address.</param>
			bool Hook(const void* const pHookAddress);

			/// <summary>
			/// UnHook.
			/// </summary>
			bool UnHook();

		public:
			/// <returns>Returns original address.</returns>
			const void* GetOriginalAddress();

			/// <returns>Returns hook address.</returns>
			const void* GetHookAddress();

		private:
			HMODULE m_hModule;
			PDWORD m_pAddress;
			DWORD m_unOriginalAddress;
			const void* m_pHookAddress;
		};

		// ----------------------------------------------------------------
		// Simple Export Hook
		// ----------------------------------------------------------------

		/// <summary>
		/// Hook with a specific address.
		/// </summary>
		/// <param name='hModule'>Module handle.</param>
		/// <param name='szExportName'>Exporting name.</param>
		/// <param name='pHookAddress'>Hook address.</param>
		/// <returns>Returns True on success, False otherwise.</returns>
		bool HookExport(const HMODULE hModule, const char* const szExportName, const void* const pHookAddress);

		/// <summary>
		/// UnHook.
		/// </summary>
		/// <param name='pHookAddress'>Hook address.</param>
		bool UnHookExport(const void* const pHookAddress);

		// ----------------------------------------------------------------
		// Memory Hook CallBack
		// ----------------------------------------------------------------

		typedef bool(__fastcall* fnMemoryHookCallBack)(class MemoryHook* pHook, PCONTEXT pCTX);

		// ----------------------------------------------------------------
		// Memory Hook
		// ----------------------------------------------------------------

		/// <summary>
		/// Hook that automatically unhooking.
		/// </summary>
		class MemoryHook {
		public:
			/// <summary>
			/// Hook that automatically unhooking.
			/// </summary>
			/// <param name='pAddress'>Memory address.</param>
			/// <param name='unSize'>Memory size.</param>
			MemoryHook(const void* const pAddress, const size_t unSize = 1, bool bAutoDisable = false);
			~MemoryHook();

		public:
			/// <summary>
			/// Hook with a specific address.
			/// </summary>
			/// <param name='pCallBack'>Callback address.</param>
			bool Hook(const fnMemoryHookCallBack pCallBack);

			/// <summary>
			/// UnHook.
			/// </summary>
			bool UnHook();

		public:
			/// <summary>
			/// Enable hook.
			/// </summary>
			/// <returns>Returns True on success, False otherwise.</returns>
			bool Enable();

			/// <summary>
			/// Disable hook.
			/// </summary>
			/// <returns>Returns True on success, False otherwise.</returns>
			bool Disable();

		public:
			/// <returns>Returns memory address.</returns>
			const void* const GetAddress();

			/// <returns>Returns memory size.</returns>
			const size_t GetSize();

			/// <returns>Returns auto disable param.</returns>
			bool IsAutoDisable();

			/// <returns>Returns callback address.</returns>
			fnMemoryHookCallBack GetCallBack();

		private:
			const void* const m_pAddress;
			const size_t m_unSize;
			bool m_bAutoDisable;
			fnMemoryHookCallBack m_pCallBack;
		};

		// ----------------------------------------------------------------
		// Simple Memory Hook
		// ----------------------------------------------------------------

		/// <summary>
		/// Hook with a specific address.
		/// </summary>
		/// <param name='pAddress'>Memory address.</param>
		/// <param name='pCallBack'>Callback address.</param>
		/// <returns>Returns True on success, False otherwise.</returns>
		bool HookMemory(const void* const pAddress, const fnMemoryHookCallBack pCallBack, bool bAutoDisable = false);

		/// <summary>
		/// UnHook.
		/// </summary>
		/// <param name='pCallBack'>Callback address.</param>
		bool UnHookMemory(const fnMemoryHookCallBack pCallBack);

		/// <summary>
		/// Enable hook.
		/// </summary>
		/// <param name='pCallBack'>Callback address.</param>
		/// <returns>Returns True on success, False otherwise.</returns>
		bool EnableHookMemory(const fnMemoryHookCallBack pCallBack);

		/// <summary>
		/// Disable hook.
		/// </summary>
		/// <param name='pCallBack'>Callback address.</param>
		/// <returns>Returns True on success, False otherwise.</returns>
		bool DisableHookMemory(const fnMemoryHookCallBack pCallBack);
	}
}

#endif // !_DETOURS_H_

```

`DumpVAC/DumpVAC.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ecb99175-0301-48df-b91b-17a0574d93a9}</ProjectGuid>
    <RootNamespace>DumpVAC</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;DUMPVAC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions);_CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>./;./Detours;./distorm;./distorm/include;./distorm/src;./distormx;./distormx/include;./distormx/src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
    <MASM>
      <UseSafeExceptionHandlers>true</UseSafeExceptionHandlers>
      <MakeAllSymbolsPublic>true</MakeAllSymbolsPublic>
      <WarningLevel>2</WarningLevel>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;DUMPVAC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions);_CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>./;./Detours;./distorm;./distorm/include;./distorm/src;./distormx;./distormx/include;./distormx/src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
    <MASM>
      <UseSafeExceptionHandlers>true</UseSafeExceptionHandlers>
      <MakeAllSymbolsPublic>true</MakeAllSymbolsPublic>
      <WarningLevel>2</WarningLevel>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;DUMPVAC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions);_CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>./;./Detours;./distorm;./distorm/include;./distorm/src;./distormx;./distormx/include;./distormx/src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
    <MASM>
      <UseSafeExceptionHandlers>true</UseSafeExceptionHandlers>
      <MakeAllSymbolsPublic>true</MakeAllSymbolsPublic>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;DUMPVAC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions);_CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>./;./Detours;./distorm;./distorm/include;./distorm/src;./distormx;./distormx/include;./distormx/src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
    <MASM>
      <UseSafeExceptionHandlers>true</UseSafeExceptionHandlers>
      <MakeAllSymbolsPublic>true</MakeAllSymbolsPublic>
    </MASM>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Console.h" />
    <ClInclude Include="Detours\Detours.h" />
    <ClInclude Include="distormx\include\distormx.h" />
    <ClInclude Include="distormx\src\OS.h" />
    <ClInclude Include="distorm\include\distorm.h" />
    <ClInclude Include="distorm\include\mnemonics.h" />
    <ClInclude Include="distorm\src\config.h" />
    <ClInclude Include="distorm\src\decoder.h" />
    <ClInclude Include="distorm\src\instructions.h" />
    <ClInclude Include="distorm\src\insts.h" />
    <ClInclude Include="distorm\src\operands.h" />
    <ClInclude Include="distorm\src\prefix.h" />
    <ClInclude Include="distorm\src\textdefs.h" />
    <ClInclude Include="distorm\src\wstring.h" />
    <ClInclude Include="distorm\src\x86defs.h" />
    <ClInclude Include="framework.h" />
    <ClInclude Include="IceKey.h" />
    <ClInclude Include="LibraryLoader.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Console.cpp" />
    <ClCompile Include="Detours\Detours.cpp" />
    <ClCompile Include="distormx\src\distormx.c" />
    <ClCompile Include="distormx\src\OS.c" />
    <ClCompile Include="distorm\src\decoder.c" />
    <ClCompile Include="distorm\src\distorm.c" />
    <ClCompile Include="distorm\src\instructions.c" />
    <ClCompile Include="distorm\src\insts.c" />
    <ClCompile Include="distorm\src\mnemonics.c" />
    <ClCompile Include="distorm\src\operands.c" />
    <ClCompile Include="distorm\src\prefix.c" />
    <ClCompile Include="distorm\src\textdefs.c" />
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="IceKey.cpp" />
    <ClCompile Include="LibraryLoader.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`DumpVAC/DumpVAC.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Исходные файлы">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Файлы заголовков">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="distorm">
      <UniqueIdentifier>{96fadd27-0c21-49a6-b87c-d60d86870dc5}</UniqueIdentifier>
    </Filter>
    <Filter Include="distorm\include">
      <UniqueIdentifier>{d753d539-6333-4d6f-88eb-f624d1c6f240}</UniqueIdentifier>
    </Filter>
    <Filter Include="distorm\src">
      <UniqueIdentifier>{e53a683d-0d28-4111-bbbb-e5e7b92381e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="distormx">
      <UniqueIdentifier>{2396406a-5ddf-47ef-a39e-4ede23c3f664}</UniqueIdentifier>
    </Filter>
    <Filter Include="distormx\src">
      <UniqueIdentifier>{05eef973-ac09-4dd9-a5bb-9f79e14401ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="distormx\include">
      <UniqueIdentifier>{678fcbba-d247-4713-af2b-0675dce1690b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Detours">
      <UniqueIdentifier>{2b044748-d6a3-4d36-80f2-bea14deb2997}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="framework.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
    <ClInclude Include="LibraryLoader.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
    <ClInclude Include="distorm\include\distorm.h">
      <Filter>distorm\include</Filter>
    </ClInclude>
    <ClInclude Include="distorm\include\mnemonics.h">
      <Filter>distorm\include</Filter>
    </ClInclude>
    <ClInclude Include="distorm\src\config.h">
      <Filter>distorm\src</Filter>
    </ClInclude>
    <ClInclude Include="distorm\src\decoder.h">
      <Filter>distorm\src</Filter>
    </ClInclude>
    <ClInclude Include="distorm\src\instructions.h">
      <Filter>distorm\src</Filter>
    </ClInclude>
    <ClInclude Include="distorm\src\insts.h">
      <Filter>distorm\src</Filter>
    </ClInclude>
    <ClInclude Include="distorm\src\operands.h">
      <Filter>distorm\src</Filter>
    </ClInclude>
    <ClInclude Include="distorm\src\prefix.h">
      <Filter>distorm\src</Filter>
    </ClInclude>
    <ClInclude Include="distorm\src\textdefs.h">
      <Filter>distorm\src</Filter>
    </ClInclude>
    <ClInclude Include="distorm\src\wstring.h">
      <Filter>distorm\src</Filter>
    </ClInclude>
    <ClInclude Include="distorm\src\x86defs.h">
      <Filter>distorm\src</Filter>
    </ClInclude>
    <ClInclude Include="distormx\src\OS.h">
      <Filter>distormx\src</Filter>
    </ClInclude>
    <ClInclude Include="distormx\include\distormx.h">
      <Filter>distormx\include</Filter>
    </ClInclude>
    <ClInclude Include="Console.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
    <ClInclude Include="Detours\Detours.h">
      <Filter>Detours</Filter>
    </ClInclude>
    <ClInclude Include="IceKey.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
    <ClCompile Include="LibraryLoader.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
    <ClCompile Include="distorm\src\decoder.c">
      <Filter>distorm\src</Filter>
    </ClCompile>
    <ClCompile Include="distorm\src\distorm.c">
      <Filter>distorm\src</Filter>
    </ClCompile>
    <ClCompile Include="distorm\src\instructions.c">
      <Filter>distorm\src</Filter>
    </ClCompile>
    <ClCompile Include="distorm\src\insts.c">
      <Filter>distorm\src</Filter>
    </ClCompile>
    <ClCompile Include="distorm\src\mnemonics.c">
      <Filter>distorm\src</Filter>
    </ClCompile>
    <ClCompile Include="distorm\src\operands.c">
      <Filter>distorm\src</Filter>
    </ClCompile>
    <ClCompile Include="distorm\src\prefix.c">
      <Filter>distorm\src</Filter>
    </ClCompile>
    <ClCompile Include="distorm\src\textdefs.c">
      <Filter>distorm\src</Filter>
    </ClCompile>
    <ClCompile Include="distormx\src\distormx.c">
      <Filter>distormx\src</Filter>
    </ClCompile>
    <ClCompile Include="distormx\src\OS.c">
      <Filter>distormx\src</Filter>
    </ClCompile>
    <ClCompile Include="Console.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
    <ClCompile Include="Detours\Detours.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="IceKey.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`DumpVAC/IceKey.cpp`:

```cpp

#include "IceKey.h"

/* Structure of a single round subkey */
class IceSubkey {
public:
	unsigned long	val[3];
};


/* The S-boxes */
static unsigned long	ice_sbox[4][1024];
static int		ice_sboxes_initialised = 0;


/* Modulo values for the S-boxes */
static const int	ice_smod[4][4] = {
				{333, 313, 505, 369},
				{379, 375, 319, 391},
				{361, 445, 451, 397},
				{397, 425, 395, 505} };

/* XOR values for the S-boxes */
static const int	ice_sxor[4][4] = {
				{0x83, 0x85, 0x9b, 0xcd},
				{0xcc, 0xa7, 0xad, 0x41},
				{0x4b, 0x2e, 0xd4, 0x33},
				{0xea, 0xcb, 0x2e, 0x04} };

/* Permutation values for the P-box */
static const unsigned long	ice_pbox[32] = {
		0x00000001, 0x00000080, 0x00000400, 0x00002000,
		0x00080000, 0x00200000, 0x01000000, 0x40000000,
		0x00000008, 0x00000020, 0x00000100, 0x00004000,
		0x00010000, 0x00800000, 0x04000000, 0x20000000,
		0x00000004, 0x00000010, 0x00000200, 0x00008000,
		0x00020000, 0x00400000, 0x08000000, 0x10000000,
		0x00000002, 0x00000040, 0x00000800, 0x00001000,
		0x00040000, 0x00100000, 0x02000000, 0x80000000 };

/* The key rotation schedule */
static const int	ice_keyrot[16] = {
				0, 1, 2, 3, 2, 1, 3, 0,
				1, 3, 2, 0, 3, 1, 0, 2 };


/*
 * 8-bit Galois Field multiplication of a by b, modulo m.
 * Just like arithmetic multiplication, except that additions and
 * subtractions are replaced by XOR.
 */

static unsigned int
gf_mult(
	unsigned int	a,
	unsigned int	b,
	unsigned int	m
) {
	unsigned int	res = 0;

	while (b) {
		if (b & 1)
			res ^= a;

		a <<= 1;
		b >>= 1;

		if (a >= 256)
			a ^= m;
	}

	return (res);
}


/*
 * Galois Field exponentiation.
 * Raise the base to the power of 7, modulo m.
 */

static unsigned long
gf_exp7(
	unsigned int	b,
	unsigned int		m
) {
	unsigned int	x;

	if (b == 0)
		return (0);

	x = gf_mult(b, b, m);
	x = gf_mult(b, x, m);
	x = gf_mult(x, x, m);
	return (gf_mult(b, x, m));
}


/*
 * Carry out the ICE 32-bit P-box permutation.
 */

static unsigned long
ice_perm32(
	unsigned long	x
) {
	unsigned long		res = 0;
	const unsigned long	*pbox = ice_pbox;

	while (x) {
		if (x & 1)
			res |= *pbox;
		pbox++;
		x >>= 1;
	}

	return (res);
}


/*
 * Initialise the ICE S-boxes.
 * This only has to be done once.
 */

static void
ice_sboxes_init(void)
{
	int	i;

	for (i = 0; i < 1024; i++) {
		int			col = (i >> 1) & 0xff;
		int			row = (i & 0x1) | ((i & 0x200) >> 8);
		unsigned long	x;

		x = gf_exp7(col ^ ice_sxor[0][row], ice_smod[0][row]) << 24;
		ice_sbox[0][i] = ice_perm32(x);

		x = gf_exp7(col ^ ice_sxor[1][row], ice_smod[1][row]) << 16;
		ice_sbox[1][i] = ice_perm32(x);

		x = gf_exp7(col ^ ice_sxor[2][row], ice_smod[2][row]) << 8;
		ice_sbox[2][i] = ice_perm32(x);

		x = gf_exp7(col ^ ice_sxor[3][row], ice_smod[3][row]);
		ice_sbox[3][i] = ice_perm32(x);
	}
}


/*
 * Create a new ICE key.
 */

IceKey::IceKey(int n)
{
	if (!ice_sboxes_initialised) {
		ice_sboxes_init();
		ice_sboxes_initialised = 1;
	}

	if (n < 1) {
		_size = 1;
		_rounds = 8;
	}
	else {
		_size = n;
		_rounds = n * 16;
	}

	_keysched = new IceSubkey[_rounds];
}


/*
 * Destroy an ICE key.
 */

IceKey::~IceKey()
{
	int	i, j;

	for (i = 0; i < _rounds; i++)
		for (j = 0; j < 3; j++)
			_keysched[i].val[j] = 0;

	_rounds = _size = 0;

	delete[] _keysched;
}


/*
 * The single round ICE f function.
 */

static unsigned long
ice_f(
	unsigned long	p,
	const IceSubkey		*sk
) {
	unsigned long	tl, tr;		/* Expanded 40-bit values */
	unsigned long	al, ar;		/* Salted expanded 40-bit values */

					/* Left half expansion */
	tl = ((p >> 16) & 0x3ff) | (((p >> 14) | (p << 18)) & 0xffc00);

	/* Right half expansion */
	tr = (p & 0x3ff) | ((p << 2) & 0xffc00);

	/* Perform the salt permutation */
// al = (tr & sk->val[2]) | (tl & ~sk->val[2]);
// ar = (tl & sk->val[2]) | (tr & ~sk->val[2]);
	al = sk->val[2] & (tl ^ tr);
	ar = al ^ tr;
	al ^= tl;

	al ^= sk->val[0];		/* XOR with the subkey */
	ar ^= sk->val[1];

	/* S-box lookup and permutation */
	return (ice_sbox[0][al >> 10] | ice_sbox[1][al & 0x3ff]
		| ice_sbox[2][ar >> 10] | ice_sbox[3][ar & 0x3ff]);
}


/*
 * Encrypt a block of 8 bytes of data with the given ICE key.
 */

void
IceKey::encrypt(
	const unsigned char	*ptext,
	unsigned char		*ctext
) const
{
	int		i;
	unsigned long	l, r;

	l = (((unsigned long)ptext[0]) << 24)
		| (((unsigned long)ptext[1]) << 16)
		| (((unsigned long)ptext[2]) << 8) | ptext[3];
	r = (((unsigned long)ptext[4]) << 24)
		| (((unsigned long)ptext[5]) << 16)
		| (((unsigned long)ptext[6]) << 8) | ptext[7];

	for (i = 0; i < _rounds; i += 2) {
		l ^= ice_f(r, &_keysched[i]);
		r ^= ice_f(l, &_keysched[i + 1]);
	}

	for (i = 0; i < 4; i++) {
		ctext[3 - i] = r & 0xff;
		ctext[7 - i] = l & 0xff;

		r >>= 8;
		l >>= 8;
	}
}


/*
 * Decrypt a block of 8 bytes of data with the given ICE key.
 */

void
IceKey::decrypt(
	const unsigned char	*ctext,
	unsigned char		*ptext
) const
{
	int		i;
	unsigned long	l, r;

	l = (((unsigned long)ctext[0]) << 24)
		| (((unsigned long)ctext[1]) << 16)
		| (((unsigned long)ctext[2]) << 8) | ctext[3];
	r = (((unsigned long)ctext[4]) << 24)
		| (((unsigned long)ctext[5]) << 16)
		| (((unsigned long)ctext[6]) << 8) | ctext[7];

	for (i = _rounds - 1; i > 0; i -= 2) {
		l ^= ice_f(r, &_keysched[i]);
		r ^= ice_f(l, &_keysched[i - 1]);
	}

	for (i = 0; i < 4; i++) {
		ptext[3 - i] = r & 0xff;
		ptext[7 - i] = l & 0xff;

		r >>= 8;
		l >>= 8;
	}
}


/*
 * Set 8 rounds [n, n+7] of the key schedule of an ICE key.
 */

void
IceKey::scheduleBuild(
	unsigned short	*kb,
	int		n,
	const int	*keyrot
) {
	int		i;

	for (i = 0; i < 8; i++) {
		int	j;
		int	kr = keyrot[i];
		IceSubkey		*isk = &_keysched[n + i];

		for (j = 0; j < 3; j++)
			isk->val[j] = 0;

		for (j = 0; j < 15; j++) {
			int	k;
			unsigned long	*curr_sk = &isk->val[j % 3];

			for (k = 0; k < 4; k++) {
				unsigned short	*curr_kb = &kb[(kr + k) & 3];
				int	bit = *curr_kb & 1;

				*curr_sk = (*curr_sk << 1) | bit;
				*curr_kb = (*curr_kb >> 1) | ((bit ^ 1) << 15);
			}
		}
	}
}


/*
 * Set the key schedule of an ICE key.
 */

void
IceKey::set(
	const unsigned char	*key
) {
	int		i;

	if (_rounds == 8) {
		unsigned short	kb[4];

		for (i = 0; i < 4; i++)
			kb[3 - i] = (key[i * 2] << 8) | key[i * 2 + 1];

		scheduleBuild(kb, 0, ice_keyrot);
		return;
	}

	for (i = 0; i < _size; i++) {
		int			j;
		unsigned short	kb[4];

		for (j = 0; j < 4; j++)
			kb[3 - j] = (key[i * 8 + j * 2] << 8) | key[i * 8 + j * 2 + 1];

		scheduleBuild(kb, i * 8, ice_keyrot);
		scheduleBuild(kb, _rounds - 8 - i * 8, &ice_keyrot[8]);
	}
}


/*
 * Return the key size, in bytes.
 */

int
IceKey::keySize() const
{
	return (_size * 8);
}


/*
 * Return the block size, in bytes.
 */

int
IceKey::blockSize() const
{
	return (8);
}

```

`DumpVAC/IceKey.h`:

```h

#ifndef _IceKey_H
#define _IceKey_H

class IceSubkey;

class IceKey {
public:
	IceKey(int n);
	~IceKey();

	void		set(const unsigned char *key);

	void		encrypt(const unsigned char *plaintext,
		unsigned char *ciphertext) const;

	void		decrypt(const unsigned char *ciphertext,
		unsigned char *plaintext) const;

	int		keySize() const;

	int		blockSize() const;

private:
	void		scheduleBuild(unsigned short *k, int n,
		const int *keyrot);

	int		_size;
	int		_rounds;
	IceSubkey	*_keysched;
};

#endif

```

`DumpVAC/LibraryLoader.cpp`:

```cpp
#include "LibraryLoader.h"

__forceinline void MemoryCopy(void* const pDst, void* const pSrc, size_t unSize) {
	for (size_t i = 0; i < unSize; ++i) {
		reinterpret_cast<unsigned char* const>(pDst)[i] = reinterpret_cast<unsigned char* const>(pSrc)[i];
	}
}

DLL_EXPORT DWORD WINAPI DumpVAC(LPVOID lpParameter) {
	PLOADER_DATA pData = reinterpret_cast<PLOADER_DATA>(lpParameter);
	if (!pData) {
		return -1;
	}

	void* pBaseAddress = pData->m_pMemoryAddress;

	const PIMAGE_DOS_HEADER pDH = reinterpret_cast<PIMAGE_DOS_HEADER>(pBaseAddress);
	const PIMAGE_NT_HEADERS pNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(pBaseAddress) + pDH->e_lfanew);
	const PIMAGE_FILE_HEADER pFH = &(pNTHs->FileHeader);
	const PIMAGE_OPTIONAL_HEADER pOH = &(pNTHs->OptionalHeader);

	void* pMemory = pData->m_pVirtualAlloc(nullptr, ((PIMAGE_NT_HEADERS)pNTHs)->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!pMemory) {
		return -1;
	}

	pData->m_pMemoryAddress = pMemory;

	MemoryCopy(pMemory, pBaseAddress, pOH->SizeOfHeaders);

	const PIMAGE_SECTION_HEADER pFirstSection = reinterpret_cast<PIMAGE_SECTION_HEADER>(reinterpret_cast<char*>(pOH) + pFH->SizeOfOptionalHeader);
	const WORD unNumberOfSections = pFH->NumberOfSections;
	for (WORD i = 0; i < unNumberOfSections; ++i) {
		MemoryCopy(reinterpret_cast<char*>(pMemory) + pFirstSection[i].VirtualAddress, reinterpret_cast<char*>(pBaseAddress) + pFirstSection[i].PointerToRawData, pFirstSection[i].SizeOfRawData);
	}

	const PIMAGE_DATA_DIRECTORY pImportDD = &(pOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
	const PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(reinterpret_cast<char*>(pMemory) + pImportDD->VirtualAddress);

	for (size_t i = 0; pImportDescriptor[i].Name != 0; ++i) {
		const HMODULE hModule = pData->m_pLoadLibraryA(reinterpret_cast<char*>(pMemory) + pImportDescriptor[i].Name);
		if (!hModule) {
			return -1;
		}

		PIMAGE_THUNK_DATA pThunkDataImportNameTable = reinterpret_cast<PIMAGE_THUNK_DATA>(reinterpret_cast<char*>(pMemory) + pImportDescriptor[i].OriginalFirstThunk);
		PIMAGE_THUNK_DATA pThunkDataImportAddressTable = reinterpret_cast<PIMAGE_THUNK_DATA>(reinterpret_cast<char*>(pMemory) + pImportDescriptor[i].FirstThunk);

		while (pThunkDataImportAddressTable->u1.AddressOfData) {
			if (pThunkDataImportNameTable->u1.Ordinal & IMAGE_ORDINAL_FLAG) {
				const PIMAGE_DOS_HEADER pModuleDH = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
				const PIMAGE_NT_HEADERS pModuleNTHs = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<char*>(hModule) + pModuleDH->e_lfanew);
				const PIMAGE_OPTIONAL_HEADER pModuleOH = &(pModuleNTHs->OptionalHeader);

				const PIMAGE_DATA_DIRECTORY pExportDD = reinterpret_cast<PIMAGE_DATA_DIRECTORY>(&(pModuleOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]));
				const PIMAGE_EXPORT_DIRECTORY pExportDirectory = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(reinterpret_cast<char*>(hModule) + pExportDD->VirtualAddress);

				const PDWORD pAddressesOfFunctions = reinterpret_cast<PDWORD>(reinterpret_cast<char*>(hModule) + pExportDirectory->AddressOfFunctions);

				pThunkDataImportAddressTable->u1.Ordinal = ((ULONG_PTR)hModule + pAddressesOfFunctions[IMAGE_ORDINAL(pThunkDataImportNameTable->u1.Ordinal - pExportDirectory->Base)]);
			} else {
				const PIMAGE_IMPORT_BY_NAME pImportByName = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(reinterpret_cast<char*>(pMemory) + pThunkDataImportAddressTable->u1.AddressOfData);

				pThunkDataImportAddressTable->u1.Function = reinterpret_cast<DWORD_PTR>(pData->m_pGetProcAddress(hModule, pImportByName->Name));
			}

			++pThunkDataImportAddressTable;
			++pThunkDataImportNameTable;
		}
	}

	const PIMAGE_DATA_DIRECTORY pBaseRelocationDD = &(pOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]);
	if (pBaseRelocationDD->Size) {
		ULONG_PTR unDelta = reinterpret_cast<ULONG_PTR>(reinterpret_cast<char*>(pMemory) - pOH->ImageBase);
		PIMAGE_BASE_RELOCATION pBaseRelocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<char*>(pMemory) + pBaseRelocationDD->VirtualAddress);
		while (pBaseRelocation->SizeOfBlock) {

			unsigned char* pBlock = reinterpret_cast<unsigned char*>(pMemory) + pBaseRelocation->VirtualAddress;

			PIMAGE_RELOC pReloc = reinterpret_cast<PIMAGE_RELOC>(reinterpret_cast<char*>(pBaseRelocation) + sizeof(IMAGE_BASE_RELOCATION));

			size_t unSizeOfBlock = pBaseRelocation->SizeOfBlock;
			size_t unCount = (unSizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(IMAGE_RELOC);
			while (unCount--) {
				if (pReloc->unType == IMAGE_REL_BASED_DIR64) {
					*reinterpret_cast<PULONG_PTR>(pBlock + pReloc->unOffset) += unDelta;
				} else if (pReloc->unType == IMAGE_REL_BASED_HIGHLOW) {
					*reinterpret_cast<PDWORD>(pBlock + pReloc->unOffset) += static_cast<DWORD>(unDelta);
				} else if (pReloc->unType == IMAGE_REL_BASED_HIGH) {
					*reinterpret_cast<PWORD>(pBlock + pReloc->unOffset) += HIWORD(unDelta);
				} else if (pReloc->unType == IMAGE_REL_BASED_LOW) {
					*reinterpret_cast<PWORD>(pBlock + pReloc->unOffset) += LOWORD(unDelta);
				}

				pReloc = reinterpret_cast<PIMAGE_RELOC>(reinterpret_cast<char*>(pReloc) + sizeof(IMAGE_RELOC));
			}

			pBaseRelocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<char*>(pBaseRelocation) + unSizeOfBlock);
		}
	}

	fnDllMain DllMain = nullptr;
	const DWORD unAddressOfEntryPoint = pOH->AddressOfEntryPoint;
	if (unAddressOfEntryPoint) {
		DllMain = reinterpret_cast<fnDllMain>(reinterpret_cast<char*>(pMemory) + unAddressOfEntryPoint);
	}

	pData->m_pNtFlushInstructionCache(HANDLE(-1), nullptr, 0);

	if (DllMain) {
		return DllMain(reinterpret_cast<HINSTANCE>(pMemory), DLL_PROCESS_ATTACH, lpParameter);
	}

	return 0;
}

```

`DumpVAC/LibraryLoader.h`:

```h
#pragma once

#ifndef _LOADER_H_
#define _LOADER_H_

// Framework
#include "framework.h"

// General definitions

typedef LONG(NTAPI* fnNtFlushInstructionCache)(HANDLE ProcessHandle, PVOID BaseAddress, ULONG NumberOfBytesToFlush);
typedef LPVOID(WINAPI* fnVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);
typedef FARPROC(WINAPI* fnGetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
typedef HMODULE(WINAPI* fnLoadLibraryA)(LPCSTR lpLibFileName);

typedef BOOL(APIENTRY* fnDllMain)(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved);

typedef struct {
	WORD unOffset : 12;
	WORD unType : 4;
} IMAGE_RELOC, *PIMAGE_RELOC;

typedef struct _LOADER_DATA {
	// Addresses
	fnNtFlushInstructionCache m_pNtFlushInstructionCache;
	fnVirtualAlloc m_pVirtualAlloc;
	fnGetProcAddress m_pGetProcAddress;
	fnLoadLibraryA m_pLoadLibraryA;
	// Memory
	void* m_pMemoryAddress;
	DWORD m_unMemorySize;
	char m_pLoaderPath[1024];
} LOADER_DATA, *PLOADER_DATA;

#endif // !_LOADER_H_

```

`DumpVAC/distorm/include/distorm.h`:

```h
/* diStorm 3.5.3 */

/*
distorm.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef DISTORM_H
#define DISTORM_H

/*
 * 64 bit offsets support:
 * If the diStorm library you use was compiled with 64 bits offsets,
 * make sure you compile your own code with the following macro set:
 * SUPPORT_64BIT_OFFSET
 * Otherwise comment it out, or you will get a linker error of an unresolved symbol...
 * Turned on by default!
 */

#if !(defined(DISTORM_STATIC) || defined(DISTORM_DYNAMIC))
	/* Define this macro for outer projects by default. */
	#define SUPPORT_64BIT_OFFSET
#endif

/* TINYC has a problem with some 64bits library functions, so ignore 64 bit offsets. */
#ifdef __TINYC__
	#undef SUPPORT_64BIT_OFFSET
#endif

#ifndef _MSC_VER
#include <stdint.h>
#else
/* Since MSVC < 2010 isn't shipped with stdint.h,
 * here are those from MSVC 2017, which also match
 * those in tinycc/libc. */
typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;
#endif

#ifdef SUPPORT_64BIT_OFFSET
#define OFFSET_INTEGER uint64_t
#else
/* 32 bit offsets are used. */
#define OFFSET_INTEGER uint32_t
#endif

/* Support C++ compilers */
#ifdef __cplusplus
 extern "C" {
#endif


/* ***  Helper Macros  *** */

/* Get the ISC of the instruction, used with the definitions below. */
#define META_GET_ISC(meta) (((meta) >> 8) & 0x1f)
#define META_SET_ISC(di, isc) (((di)->meta) |= ((isc) << 8))
/* Get the flow control flags of the instruction, see 'features for decompose' below. */
#define META_GET_FC(meta) ((meta) & 0xf)

/* Get the target address of a branching instruction. O_PC operand type. */
#define INSTRUCTION_GET_TARGET(di) ((_OffsetType)(((di)->addr + (di)->imm.addr + (di)->size)))
/* Get the target address of a RIP-relative memory indirection. */
#define INSTRUCTION_GET_RIP_TARGET(di) ((_OffsetType)(((di)->addr + (di)->disp + (di)->size)))

/*
 * Operand Size or Adderss size are stored inside the flags:
 * 00 - 16 bits
 * 01 - 32 bits
 * 10 - 64 bits
 * 11 - reserved
 *
 * If you call these set-macros more than once, you will have to clean the bits before doing so.
 */
#define FLAG_SET_OPSIZE(di, size) ((di->flags) |= (((size) & 3) << 8))
#define FLAG_SET_ADDRSIZE(di, size) ((di->flags) |= (((size) & 3) << 10))
#define FLAG_GET_OPSIZE(flags) (((flags) >> 8) & 3)
#define FLAG_GET_ADDRSIZE(flags) (((flags) >> 10) & 3)
/* To get the LOCK/REPNZ/REP prefixes. */
#define FLAG_GET_PREFIX(flags) (((unsigned int)((int16_t)flags)) & 7)
/* Indicates whether the instruction is privileged. */
#define FLAG_GET_PRIVILEGED(flags) (((flags) & FLAG_PRIVILEGED_INSTRUCTION) != 0)

/*
 * Macros to extract segment registers from 'segment':
 */
#define SEGMENT_DEFAULT 0x80
#define SEGMENT_GET(segment) (((segment) == R_NONE) ? R_NONE : ((segment) & 0x7f))
#define SEGMENT_GET_UNSAFE(segment) ((segment) & 0x7f)
#define SEGMENT_IS_DEFAULT(segment) (((int8_t)segment) < -1) /* Quick check it's a negative number that isn't -1, so it's (0x80 | SEGREG). */
#define SEGMENT_IS_DEFAULT_OR_NONE(segment) (((uint8_t)(segment)) > 0x80)

/* Decodes modes of the disassembler, 16 bits or 32 bits or 64 bits for AMD64, x86-64. */
typedef enum { Decode16Bits = 0, Decode32Bits = 1, Decode64Bits = 2 } _DecodeType;

typedef OFFSET_INTEGER _OffsetType;

typedef struct {
	_OffsetType codeOffset, addrMask;
	_OffsetType nextOffset; /* nextOffset is OUT only. */
	const uint8_t* code;
	int codeLen; /* Using signed integer makes it easier to detect an underflow. */
	_DecodeType dt;
	unsigned int features;
} _CodeInfo;

typedef enum { O_NONE, O_REG, O_IMM, O_IMM1, O_IMM2, O_DISP, O_SMEM, O_MEM, O_PC, O_PTR } _OperandType;

typedef union {
	/* Used by O_IMM: */
	int8_t sbyte;
	uint8_t byte;
	int16_t sword;
	uint16_t word;
	int32_t sdword;
	uint32_t dword;
	int64_t sqword; /* All immediates are SIGN-EXTENDED to 64 bits! */
	uint64_t qword;

	/* Used by O_PC: (Use GET_TARGET_ADDR).*/
	_OffsetType addr; /* It's a relative offset as for now. */

	/* Used by O_PTR: */
	struct {
		uint16_t seg;
		/* Can be 16 or 32 bits, size is in ops[n].size. */
		uint32_t off;
	} ptr;

	/* Used by O_IMM1 (i1) and O_IMM2 (i2). ENTER instruction only. */
	struct {
		uint32_t i1;
		uint32_t i2;
	} ex;
} _Value;

typedef struct {
	/* Type of operand:
		O_NONE: operand is to be ignored.
		O_REG: index holds global register index.
		O_IMM: instruction.imm.
		O_IMM1: instruction.imm.ex.i1.
		O_IMM2: instruction.imm.ex.i2.
		O_DISP: memory dereference with displacement only, instruction.disp.
		O_SMEM: simple memory dereference with optional displacement (a single register memory dereference).
		O_MEM: complex memory dereference (optional fields: s/i/b/disp).
		O_PC: the relative address of a branch instruction (instruction.imm.addr).
		O_PTR: the absolute target address of a far branch instruction (instruction.imm.ptr.seg/off).
	*/
	uint8_t type; /* _OperandType */

	/* Index of:
		O_REG: holds global register index
		O_SMEM: holds the 'base' register. E.G: [ECX], [EBX+0x1234] are both in operand.index.
		O_MEM: holds the 'index' register. E.G: [EAX*4] is in operand.index.
	*/
	uint8_t index;

	/* Size in bits of:
		O_REG: register
		O_IMM: instruction.imm
		O_IMM1: instruction.imm.ex.i1
		O_IMM2: instruction.imm.ex.i2
		O_DISP: instruction.disp
		O_SMEM: size of indirection.
		O_MEM: size of indirection.
		O_PC: size of the relative offset
		O_PTR: size of instruction.imm.ptr.off (16 or 32)
	*/
	uint16_t size;
} _Operand;

#define OPCODE_ID_NONE 0
/* Instruction could not be disassembled. */
#define FLAG_NOT_DECODABLE ((uint16_t)-1)
/* The instruction locks memory access. */
#define FLAG_LOCK (1 << 0)
/* The instruction is prefixed with a REPNZ. */
#define FLAG_REPNZ (1 << 1)
/* The instruction is prefixed with a REP, this can be a REPZ, it depends on the specific instruction. */
#define FLAG_REP (1 << 2)
/* Indicates there is a hint taken for Jcc instructions only. */
#define FLAG_HINT_TAKEN (1 << 3)
/* Indicates there is a hint non-taken for Jcc instructions only. */
#define FLAG_HINT_NOT_TAKEN (1 << 4)
/* The Imm value is signed extended (E.G in 64 bit decoding mode, a 32 bit imm is usually sign extended into 64 bit imm). */
#define FLAG_IMM_SIGNED (1 << 5)
/* The destination operand is writable. */
#define FLAG_DST_WR (1 << 6)
/* The instruction uses RIP-relative indirection. */
#define FLAG_RIP_RELATIVE (1 << 7)

/* See flag FLAG_GET_XXX macros above. */

/* The instruction is privileged and can only be used from Ring0. */
#define FLAG_PRIVILEGED_INSTRUCTION (1 << 15)

/* No register was defined. */
#define R_NONE ((uint8_t)-1)

#define REGS64_BASE 0
#define REGS32_BASE 16
#define REGS16_BASE 32
#define REGS8_BASE 48
#define REGS8_REX_BASE 64
#define SREGS_BASE 68
#define FPUREGS_BASE 75
#define MMXREGS_BASE 83
#define SSEREGS_BASE 91
#define AVXREGS_BASE 107
#define CREGS_BASE 123
#define DREGS_BASE 132

#define OPERANDS_NO (4)

typedef struct {
	/* Used by ops[n].type == O_IMM/O_IMM1&O_IMM2/O_PTR/O_PC. Its size is ops[n].size. */
	_Value imm;
	/* Used by ops[n].type == O_SMEM/O_MEM/O_DISP. Its size is dispSize. */
	uint64_t disp;
	/* Virtual address of first byte of instruction. */
	_OffsetType addr;
	/* General flags of instruction, holds prefixes and more, if FLAG_NOT_DECODABLE, instruction is invalid. */
	uint16_t flags;
	/* Unused prefixes mask, for each bit that is set that prefix is not used (LSB is byte [addr + 0]). */
	uint16_t unusedPrefixesMask;
	/* Mask of registers that were used in the operands, only used for quick look up, in order to know *some* operand uses that register class. */
	uint32_t usedRegistersMask;
	/* ID of opcode in the global opcode table. Use for mnemonic look up. */
	uint16_t opcode;
	/* Up to four operands per instruction, ignored if ops[n].type == O_NONE. */
	_Operand ops[OPERANDS_NO];
	/* Number of valid ops entries. */
	uint8_t opsNo;
	/* Size of the whole instruction in bytes. */
	uint8_t size;
	/* Segment information of memory indirection, default segment, or overriden one, can be -1. Use SEGMENT macros. */
	uint8_t segment;
	/* Used by ops[n].type == O_MEM. Base global register index (might be R_NONE), scale size (2/4/8), ignored for 0 or 1. */
	uint8_t base, scale;
	uint8_t dispSize;
	/* Meta defines the instruction set class, and the flow control flags. Use META macros. */
	uint16_t meta;
	/* The CPU flags that the instruction operates upon, set only with DF_FILL_EFLAGS enabled, otherwise 0. */
	uint16_t modifiedFlagsMask, testedFlagsMask, undefinedFlagsMask;
} _DInst;

#ifndef DISTORM_LIGHT

/* Static size of strings. Do not change this value. Keep Python wrapper in sync. */
#define MAX_TEXT_SIZE (48)
typedef struct {
	unsigned int length;
	unsigned char p[MAX_TEXT_SIZE]; /* p is a null terminated string. */
} _WString;

/*
 * Old decoded instruction structure in text format.
 * Used only for backward compatibility with diStorm64.
 * This structure holds all information the disassembler generates per instruction.
 */
typedef struct {
	_OffsetType offset; /* Start offset of the decoded instruction. */
	unsigned int size; /* Size of decoded instruction in bytes. */
	_WString mnemonic; /* Mnemonic of decoded instruction, prefixed if required by REP, LOCK etc. */
	_WString operands; /* Operands of the decoded instruction, up to 3 operands, comma-seperated. */
	_WString instructionHex; /* Hex dump - little endian, including prefixes. */
} _DecodedInst;

#endif /* DISTORM_LIGHT */

/* Register masks for quick look up, each mask indicates one of a register-class that is being used in some operand. */
#define RM_AX 1     /* AL, AH, AX, EAX, RAX */
#define RM_CX 2     /* CL, CH, CX, ECX, RCX */
#define RM_DX 4     /* DL, DH, DX, EDX, RDX */
#define RM_BX 8     /* BL, BH, BX, EBX, RBX */
#define RM_SP 0x10  /* SPL, SP, ESP, RSP */
#define RM_BP 0x20  /* BPL, BP, EBP, RBP */
#define RM_SI 0x40  /* SIL, SI, ESI, RSI */
#define RM_DI 0x80  /* DIL, DI, EDI, RDI */
#define RM_FPU 0x100 /* ST(0) - ST(7) */
#define RM_MMX 0x200 /* MM0 - MM7 */
#define RM_SSE 0x400 /* XMM0 - XMM15 */
#define RM_AVX 0x800 /* YMM0 - YMM15 */
#define RM_CR 0x1000 /* CR0, CR2, CR3, CR4, CR8 */
#define RM_DR 0x2000 /* DR0, DR1, DR2, DR3, DR6, DR7 */
#define RM_R8 0x4000 /* R8B, R8W, R8D, R8 */
#define RM_R9 0x8000 /* R9B, R9W, R9D, R9 */
#define RM_R10 0x10000 /* R10B, R10W, R10D, R10 */
#define RM_R11 0x20000 /* R11B, R11W, R11D, R11 */
#define RM_R12 0x40000 /* R12B, R12W, R12D, R12 */
#define RM_R13 0x80000 /* R13B, R13W, R13D, R13 */
#define RM_R14 0x100000 /* R14B, R14W, R14D, R14 */
#define RM_R15 0x200000 /* R15B, R15W, R15D, R15 */
#define RM_SEG 0x400000 /* CS, SS, DS, ES, FS, GS */

/* RIP should be checked using the 'flags' field and FLAG_RIP_RELATIVE.
 * Segments should be checked using the segment macros.
 * For now R8 - R15 are not supported and non general purpose registers map into same RM.
 */

/* CPU flags that instructions modify, test or undefine (are EFLAGS compatible!). */
#define D_CF 1		/* Carry */
#define D_PF 4		/* Parity */
#define D_AF 0x10	/* Auxiliary */
#define D_ZF 0x40	/* Zero */
#define D_SF 0x80	/* Sign */
#define D_IF 0x200	/* Interrupt */
#define D_DF 0x400	/* Direction */
#define D_OF 0x800	/* Overflow */

/*
 * Instructions Set classes:
 * if you want a better understanding of the available classes, look at disOps project, file: x86sets.py.
 */
/* Indicates the instruction belongs to the General Integer set. */
#define ISC_INTEGER 1
/* Indicates the instruction belongs to the 387 FPU set. */
#define ISC_FPU 2
/* Indicates the instruction belongs to the P6 set. */
#define ISC_P6 3
/* Indicates the instruction belongs to the MMX set. */
#define ISC_MMX 4
/* Indicates the instruction belongs to the SSE set. */
#define ISC_SSE 5
/* Indicates the instruction belongs to the SSE2 set. */
#define ISC_SSE2 6
/* Indicates the instruction belongs to the SSE3 set. */
#define ISC_SSE3 7
/* Indicates the instruction belongs to the SSSE3 set. */
#define ISC_SSSE3 8
/* Indicates the instruction belongs to the SSE4.1 set. */
#define ISC_SSE4_1 9
/* Indicates the instruction belongs to the SSE4.2 set. */
#define ISC_SSE4_2 10
/* Indicates the instruction belongs to the AMD's SSE4.A set. */
#define ISC_SSE4_A 11
/* Indicates the instruction belongs to the 3DNow! set. */
#define ISC_3DNOW 12
/* Indicates the instruction belongs to the 3DNow! Extensions set. */
#define ISC_3DNOWEXT 13
/* Indicates the instruction belongs to the VMX (Intel) set. */
#define ISC_VMX 14
/* Indicates the instruction belongs to the SVM (AMD) set. */
#define ISC_SVM 15
/* Indicates the instruction belongs to the AVX (Intel) set. */
#define ISC_AVX 16
/* Indicates the instruction belongs to the FMA (Intel) set. */
#define ISC_FMA 17
/* Indicates the instruction belongs to the AES/AVX (Intel) set. */
#define ISC_AES 18
/* Indicates the instruction belongs to the CLMUL (Intel) set. */
#define ISC_CLMUL 19

/* Features for decompose: */
#define DF_NONE 0
/* The decoder will limit addresses to a maximum of 16 bits. */
#define DF_MAXIMUM_ADDR16 1
/* The decoder will limit addresses to a maximum of 32 bits. */
#define DF_MAXIMUM_ADDR32 2
/* The decoder will return only flow control instructions (and filter the others internally). */
#define DF_RETURN_FC_ONLY 4
/* The decoder will stop and return to the caller when the instruction 'CALL' (near and far) was decoded. */
#define DF_STOP_ON_CALL 8
/* The decoder will stop and return to the caller when the instruction 'RET' (near and far) was decoded. */
#define DF_STOP_ON_RET 0x10
/* The decoder will stop and return to the caller when the instruction system-call/ret was decoded. */
#define DF_STOP_ON_SYS 0x20
/* The decoder will stop and return to the caller when any of the branch 'JMP', (near and far) instructions were decoded. */
#define DF_STOP_ON_UNC_BRANCH 0x40
/* The decoder will stop and return to the caller when any of the conditional branch instruction were decoded. */
#define DF_STOP_ON_CND_BRANCH 0x80
/* The decoder will stop and return to the caller when the instruction 'INT' (INT, INT1, INTO, INT 3) was decoded. */
#define DF_STOP_ON_INT 0x100
/* The decoder will stop and return to the caller when any of the 'CMOVxx' instruction was decoded. */
#define DF_STOP_ON_CMOV 0x200
/* The decoder will stop and return to the caller when it encounters the HLT instruction. */
#define DF_STOP_ON_HLT 0x400
/* The decoder will stop and return to the caller when it encounters a privileged instruction. */
#define DF_STOP_ON_PRIVILEGED 0x800
/* The decoder will stop and return to the caller when an instruction couldn't be decoded. */
#define DF_STOP_ON_UNDECODEABLE 0x1000
/* The decoder will not synchronize to the next byte after the previosuly decoded instruction, instead it will start decoding at the next byte. */
#define DF_SINGLE_BYTE_STEP 0x2000
/* The decoder will fill in the eflags fields for the decoded instruction. */
#define DF_FILL_EFLAGS 0x4000
/* The decoder will use the addrMask in CodeInfo structure instead of DF_MAXIMUM_ADDR16/32. */
#define DF_USE_ADDR_MASK 0x8000

/* The decoder will stop and return to the caller when any flow control instruction was decoded. */
#define DF_STOP_ON_FLOW_CONTROL (DF_STOP_ON_CALL | DF_STOP_ON_RET | DF_STOP_ON_SYS | DF_STOP_ON_UNC_BRANCH | DF_STOP_ON_CND_BRANCH | DF_STOP_ON_INT | DF_STOP_ON_CMOV | DF_STOP_ON_HLT)

/* Indicates the instruction is not a flow-control instruction. */
#define FC_NONE 0
/* Indicates the instruction is one of: CALL, CALL FAR. */
#define FC_CALL 1
/* Indicates the instruction is one of: RET, IRET, RETF. */
#define FC_RET 2
/* Indicates the instruction is one of: SYSCALL, SYSRET, SYSENTER, SYSEXIT. */
#define FC_SYS 3
/* Indicates the instruction is one of: JMP, JMP FAR. */
#define FC_UNC_BRANCH 4
/*
 * Indicates the instruction is one of:
 * JCXZ, JO, JNO, JB, JAE, JZ, JNZ, JBE, JA, JS, JNS, JP, JNP, JL, JGE, JLE, JG, LOOP, LOOPZ, LOOPNZ.
 */
#define FC_CND_BRANCH 5
/* Indiciates the instruction is one of: INT, INT1, INT 3, INTO, UD2. */
#define FC_INT 6
/* Indicates the instruction is one of: CMOVxx. */
#define FC_CMOV 7
/* Indicates the instruction is HLT. */
#define FC_HLT 8

/* Return code of the decoding function. */
typedef enum { DECRES_NONE, DECRES_SUCCESS, DECRES_MEMORYERR, DECRES_INPUTERR } _DecodeResult;

/* Define the following interface functions only for outer projects. */
#if !(defined(DISTORM_STATIC) || defined(DISTORM_DYNAMIC))

/* distorm_decode
 * Input:
 *         offset - Origin of the given code (virtual address that is), NOT an offset in code.
 *         code - Pointer to the code buffer to be disassembled.
 *         length - Amount of bytes that should be decoded from the code buffer.
 *         dt - Decoding mode, 16 bits (Decode16Bits), 32 bits (Decode32Bits) or AMD64 (Decode64Bits).
 *         result - Array of type _DecodeInst which will be used by this function in order to return the disassembled instructions.
 *         maxInstructions - The maximum number of entries in the result array that you pass to this function, so it won't exceed its bound.
 *         usedInstructionsCount - Number of the instruction that successfully were disassembled and written to the result array.
 * Output: usedInstructionsCount will hold the number of entries used in the result array
 *         and the result array itself will be filled with the disassembled instructions.
 * Return: DECRES_SUCCESS on success (no more to disassemble), DECRES_INPUTERR on input error (null code buffer, invalid decoding mode, etc...),
 *         DECRES_MEMORYERR when there are not enough entries to use in the result array, BUT YOU STILL have to check for usedInstructionsCount!
 * Side-Effects: Even if the return code is DECRES_MEMORYERR, there might STILL be data in the
 *               array you passed, this function will try to use as much entries as possible!
 * Notes:  1)The minimal size of maxInstructions is 15.
 *         2)You will have to synchronize the offset,code and length by yourself if you pass code fragments and not a complete code block!
 */

/* distorm_decompose
 * See more documentation online at the GitHub project's wiki.
 *
 */
#ifdef SUPPORT_64BIT_OFFSET

	_DecodeResult distorm_decompose64(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	#define distorm_decompose distorm_decompose64

#ifndef DISTORM_LIGHT
	/* If distorm-light is defined, we won't export these text-formatting functionality. */
	_DecodeResult distorm_decode64(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	void distorm_format64(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result);
	#define distorm_decode distorm_decode64
	#define distorm_format distorm_format64
#endif /*DISTORM_LIGHT*/

#else /*SUPPORT_64BIT_OFFSET*/

	_DecodeResult distorm_decompose32(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	#define distorm_decompose distorm_decompose32

#ifndef DISTORM_LIGHT
	/* If distorm-light is defined, we won't export these text-formatting functionality. */
	_DecodeResult distorm_decode32(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	void distorm_format32(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result);
	#define distorm_decode distorm_decode32
	#define distorm_format distorm_format32
#endif /*DISTORM_LIGHT*/

#endif

/*
 * distorm_version
 * Input:
 *        none
 *
 * Output: unsigned int - version of compiled library.
 */
unsigned int distorm_version(void);

#endif /* DISTORM_STATIC */

#ifdef __cplusplus
} /* End Of Extern */
#endif

#endif /* DISTORM_H */

```

`DumpVAC/distorm/include/mnemonics.h`:

```h
/*
mnemonics.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef MNEMONICS_H
#define MNEMONICS_H

#ifdef __cplusplus
 extern "C" {
#endif

#ifndef DISTORM_LIGHT

typedef struct WMnemonic {
	unsigned char length;
	unsigned char p[1]; /* p is a null terminated string, which contains 'length' characters. */
} _WMnemonic;

typedef struct WRegister {
	unsigned int length;
	unsigned char p[6]; /* p is a null terminated string. */
} _WRegister;

extern const unsigned char _MNEMONICS[];
extern const _WRegister _REGISTERS[];

#endif /* DISTORM_LIGHT */

#ifdef __cplusplus
} /* End Of Extern */
#endif

#define GET_REGISTER_NAME(r) (unsigned char*)_REGISTERS[(r)].p
#define GET_MNEMONIC_NAME(m) ((_WMnemonic*)&_MNEMONICS[(m)])->p

 typedef enum {
	I_UNDEFINED = 0, I_AAA = 66, I_AAD = 388, I_AAM = 383, I_AAS = 76, I_ADC = 31, I_ADD = 11, I_ADDPD = 3143,
	I_ADDPS = 3136, I_ADDSD = 3157, I_ADDSS = 3150, I_ADDSUBPD = 6427, I_ADDSUBPS = 6437,
	I_AESDEC = 9242, I_AESDECLAST = 9259, I_AESENC = 9200, I_AESENCLAST = 9217,
	I_AESIMC = 9183, I_AESKEYGENASSIST = 9828, I_AND = 41, I_ANDNPD = 3054, I_ANDNPS = 3046,
	I_ANDPD = 3023, I_ANDPS = 3016, I_ARPL = 111, I_BLENDPD = 9405, I_BLENDPS = 9386,
	I_BLENDVPD = 7652, I_BLENDVPS = 7642, I_BOUND = 104, I_BSF = 4379, I_BSR = 4391,
	I_BSWAP = 959, I_BT = 871, I_BTC = 933, I_BTR = 911, I_BTS = 886, I_CALL = 455,
	I_CALL_FAR = 260, I_CBW = 228, I_CDQ = 250, I_CDQE = 239, I_CLAC = 1786, I_CLC = 491,
	I_CLD = 511, I_CLFLUSH = 4362, I_CLGI = 1866, I_CLI = 501, I_CLTS = 540, I_CMC = 486,
	I_CMOVA = 693, I_CMOVAE = 662, I_CMOVB = 655, I_CMOVBE = 685, I_CMOVG = 753,
	I_CMOVGE = 737, I_CMOVL = 730, I_CMOVLE = 745, I_CMOVNO = 647, I_CMOVNP = 722,
	I_CMOVNS = 707, I_CMOVNZ = 677, I_CMOVO = 640, I_CMOVP = 715, I_CMOVS = 700,
	I_CMOVZ = 670, I_CMP = 71, I_CMPEQPD = 4482, I_CMPEQPS = 4403, I_CMPEQSD = 4640,
	I_CMPEQSS = 4561, I_CMPLEPD = 4500, I_CMPLEPS = 4421, I_CMPLESD = 4658, I_CMPLESS = 4579,
	I_CMPLTPD = 4491, I_CMPLTPS = 4412, I_CMPLTSD = 4649, I_CMPLTSS = 4570, I_CMPNEQPD = 4521,
	I_CMPNEQPS = 4442, I_CMPNEQSD = 4679, I_CMPNEQSS = 4600, I_CMPNLEPD = 4541,
	I_CMPNLEPS = 4462, I_CMPNLESD = 4699, I_CMPNLESS = 4620, I_CMPNLTPD = 4531,
	I_CMPNLTPS = 4452, I_CMPNLTSD = 4689, I_CMPNLTSS = 4610, I_CMPORDPD = 4551,
	I_CMPORDPS = 4472, I_CMPORDSD = 4709, I_CMPORDSS = 4630, I_CMPS = 301, I_CMPUNORDPD = 4509,
	I_CMPUNORDPS = 4430, I_CMPUNORDSD = 4667, I_CMPUNORDSS = 4588, I_CMPXCHG = 897,
	I_CMPXCHG16B = 6406, I_CMPXCHG8B = 6395, I_COMISD = 2812, I_COMISS = 2804,
	I_CPUID = 864, I_CQO = 255, I_CRC32 = 9291, I_CVTDQ2PD = 6820, I_CVTDQ2PS = 3340,
	I_CVTPD2DQ = 6830, I_CVTPD2PI = 2714, I_CVTPD2PS = 3266, I_CVTPH2PS = 4194,
	I_CVTPI2PD = 2528, I_CVTPI2PS = 2518, I_CVTPS2DQ = 3350, I_CVTPS2PD = 3256,
	I_CVTPS2PH = 4204, I_CVTPS2PI = 2704, I_CVTSD2SI = 2734, I_CVTSD2SS = 3286,
	I_CVTSI2SD = 2548, I_CVTSI2SS = 2538, I_CVTSS2SD = 3276, I_CVTSS2SI = 2724,
	I_CVTTPD2DQ = 6809, I_CVTTPD2PI = 2647, I_CVTTPS2DQ = 3360, I_CVTTPS2PI = 2636,
	I_CVTTSD2SI = 2669, I_CVTTSS2SI = 2658, I_CWD = 245, I_CWDE = 233, I_DAA = 46,
	I_DAS = 56, I_DEC = 86, I_DIV = 1645, I_DIVPD = 3532, I_DIVPS = 3525, I_DIVSD = 3546,
	I_DIVSS = 3539, I_DPPD = 9648, I_DPPS = 9635, I_EMMS = 4133, I_ENTER = 340,
	I_EXTRACTPS = 9513, I_EXTRQ = 4169, I_F2XM1 = 1191, I_FABS = 1122, I_FADD = 1022,
	I_FADDP = 1548, I_FBLD = 1600, I_FBSTP = 1606, I_FCHS = 1116, I_FCLEX = 7322,
	I_FCMOVB = 1375, I_FCMOVBE = 1391, I_FCMOVE = 1383, I_FCMOVNB = 1444, I_FCMOVNBE = 1462,
	I_FCMOVNE = 1453, I_FCMOVNU = 1472, I_FCMOVU = 1400, I_FCOM = 1034, I_FCOMI = 1511,
	I_FCOMIP = 1622, I_FCOMP = 1040, I_FCOMPP = 1562, I_FCOS = 1310, I_FDECSTP = 1237,
	I_FDIV = 1060, I_FDIVP = 1593, I_FDIVR = 1066, I_FDIVRP = 1585, I_FEDISI = 1487,
	I_FEMMS = 573, I_FENI = 1481, I_FFREE = 1526, I_FIADD = 1316, I_FICOM = 1330,
	I_FICOMP = 1337, I_FIDIV = 1360, I_FIDIVR = 1367, I_FILD = 1417, I_FIMUL = 1323,
	I_FINCSTP = 1246, I_FINIT = 7337, I_FIST = 1431, I_FISTP = 1437, I_FISTTP = 1423,
	I_FISUB = 1345, I_FISUBR = 1352, I_FLD = 1073, I_FLD1 = 1140, I_FLDCW = 1097,
	I_FLDENV = 1089, I_FLDL2E = 1154, I_FLDL2T = 1146, I_FLDLG2 = 1169, I_FLDLN2 = 1177,
	I_FLDPI = 1162, I_FLDZ = 1185, I_FMUL = 1028, I_FMULP = 1555, I_FNCLEX = 7314,
	I_FNINIT = 7329, I_FNOP = 1110, I_FNSAVE = 7344, I_FNSTCW = 7299, I_FNSTENV = 7282,
	I_FNSTSW = 7359, I_FPATAN = 1212, I_FPREM = 1255, I_FPREM1 = 1229, I_FPTAN = 1205,
	I_FRNDINT = 1287, I_FRSTOR = 1518, I_FSAVE = 7352, I_FSCALE = 1296, I_FSETPM = 1495,
	I_FSIN = 1304, I_FSINCOS = 1278, I_FSQRT = 1271, I_FST = 1078, I_FSTCW = 7307,
	I_FSTENV = 7291, I_FSTP = 1083, I_FSTSW = 7367, I_FSUB = 1047, I_FSUBP = 1578,
	I_FSUBR = 1053, I_FSUBRP = 1570, I_FTST = 1128, I_FUCOM = 1533, I_FUCOMI = 1503,
	I_FUCOMIP = 1613, I_FUCOMP = 1540, I_FUCOMPP = 1408, I_FXAM = 1134, I_FXCH = 1104,
	I_FXRSTOR = 9925, I_FXRSTOR64 = 9934, I_FXSAVE = 9897, I_FXSAVE64 = 9905,
	I_FXTRACT = 1220, I_FYL2X = 1198, I_FYL2XP1 = 1262, I_GETSEC = 632, I_HADDPD = 4214,
	I_HADDPS = 4222, I_HLT = 481, I_HSUBPD = 4248, I_HSUBPS = 4256, I_IDIV = 1650,
	I_IMUL = 117, I_IN = 446, I_INC = 81, I_INS = 123, I_INSERTPS = 9580, I_INSERTQ = 4176,
	I_INT = 366, I_INT1 = 475, I_INT3 = 360, I_INTO = 371, I_INVD = 554, I_INVEPT = 8317,
	I_INVLPG = 1726, I_INVLPGA = 1880, I_INVPCID = 8334, I_INVVPID = 8325, I_IRET = 377,
	I_JA = 166, I_JAE = 147, I_JB = 143, I_JBE = 161, I_JCXZ = 426, I_JECXZ = 432,
	I_JG = 202, I_JGE = 192, I_JL = 188, I_JLE = 197, I_JMP = 461, I_JMP_FAR = 466,
	I_JNO = 138, I_JNP = 183, I_JNS = 174, I_JNZ = 156, I_JO = 134, I_JP = 179,
	I_JRCXZ = 439, I_JS = 170, I_JZ = 152, I_LAHF = 289, I_LAR = 521, I_LDDQU = 7027,
	I_LDMXCSR = 9955, I_LDS = 335, I_LEA = 223, I_LEAVE = 347, I_LES = 330, I_LFENCE = 4298,
	I_LFS = 916, I_LGDT = 1702, I_LGS = 921, I_LIDT = 1708, I_LLDT = 1667, I_LMSW = 1720,
	I_LODS = 313, I_LOOP = 420, I_LOOPNZ = 405, I_LOOPZ = 413, I_LSL = 526, I_LSS = 906,
	I_LTR = 1673, I_LZCNT = 4396, I_MASKMOVDQU = 7152, I_MASKMOVQ = 7142, I_MAXPD = 3592,
	I_MAXPS = 3585, I_MAXSD = 3606, I_MAXSS = 3599, I_MFENCE = 4324, I_MINPD = 3472,
	I_MINPS = 3465, I_MINSD = 3486, I_MINSS = 3479, I_MONITOR = 1770, I_MOV = 218,
	I_MOVAPD = 2492, I_MOVAPS = 2484, I_MOVBE = 9284, I_MOVD = 3953, I_MOVDDUP = 2219,
	I_MOVDQ2Q = 6555, I_MOVDQA = 3979, I_MOVDQU = 3987, I_MOVHLPS = 2184, I_MOVHPD = 2378,
	I_MOVHPS = 2370, I_MOVLHPS = 2361, I_MOVLPD = 2201, I_MOVLPS = 2193, I_MOVMSKPD = 2848,
	I_MOVMSKPS = 2838, I_MOVNTDQ = 6882, I_MOVNTDQA = 7928, I_MOVNTI = 951, I_MOVNTPD = 2589,
	I_MOVNTPS = 2580, I_MOVNTQ = 6874, I_MOVNTSD = 2607, I_MOVNTSS = 2598, I_MOVQ = 3959,
	I_MOVQ2DQ = 6546, I_MOVS = 295, I_MOVSD = 2143, I_MOVSHDUP = 2386, I_MOVSLDUP = 2209,
	I_MOVSS = 2136, I_MOVSX = 938, I_MOVSXD = 10038, I_MOVUPD = 2128, I_MOVUPS = 2120,
	I_MOVZX = 926, I_MPSADBW = 9661, I_MUL = 1640, I_MULPD = 3203, I_MULPS = 3196,
	I_MULSD = 3217, I_MULSS = 3210, I_MWAIT = 1779, I_NEG = 1635, I_NOP = 580,
	I_NOT = 1630, I_OR = 27, I_ORPD = 3086, I_ORPS = 3080, I_OUT = 450, I_OUTS = 128,
	I_PABSB = 7721, I_PABSD = 7751, I_PABSW = 7736, I_PACKSSDW = 3882, I_PACKSSWB = 3714,
	I_PACKUSDW = 7949, I_PACKUSWB = 3792, I_PADDB = 7237, I_PADDD = 7267, I_PADDQ = 6514,
	I_PADDSB = 6963, I_PADDSW = 6980, I_PADDUSB = 6653, I_PADDUSW = 6672, I_PADDW = 7252,
	I_PALIGNR = 9443, I_PAND = 6640, I_PANDN = 6698, I_PAUSE = 10046, I_PAVGB = 6713,
	I_PAVGUSB = 2111, I_PAVGW = 6758, I_PBLENDVB = 7632, I_PBLENDW = 9424, I_PCLMULQDQ = 9680,
	I_PCMPEQB = 4076, I_PCMPEQD = 4114, I_PCMPEQQ = 7909, I_PCMPEQW = 4095, I_PCMPESTRI = 9759,
	I_PCMPESTRM = 9736, I_PCMPGTB = 3735, I_PCMPGTD = 3773, I_PCMPGTQ = 8120,
	I_PCMPGTW = 3754, I_PCMPISTRI = 9805, I_PCMPISTRM = 9782, I_PEXTRB = 9462,
	I_PEXTRD = 9479, I_PEXTRQ = 9487, I_PEXTRW = 6344, I_PF2ID = 1947, I_PF2IW = 1940,
	I_PFACC = 2061, I_PFADD = 2010, I_PFCMPEQ = 2068, I_PFCMPGE = 1971, I_PFCMPGT = 2017,
	I_PFMAX = 2026, I_PFMIN = 1980, I_PFMUL = 2077, I_PFNACC = 1954, I_PFPNACC = 1962,
	I_PFRCP = 1987, I_PFRCPIT1 = 2033, I_PFRCPIT2 = 2084, I_PFRSQIT1 = 2043, I_PFRSQRT = 1994,
	I_PFSUB = 2003, I_PFSUBR = 2053, I_PHADDD = 7408, I_PHADDSW = 7425, I_PHADDW = 7391,
	I_PHMINPOSUW = 8292, I_PHSUBD = 7484, I_PHSUBSW = 7501, I_PHSUBW = 7467, I_PI2FD = 1933,
	I_PI2FW = 1926, I_PINSRB = 9563, I_PINSRD = 9601, I_PINSRQ = 9609, I_PINSRW = 6327,
	I_PMADDUBSW = 7444, I_PMADDWD = 7106, I_PMAXSB = 8207, I_PMAXSD = 8224, I_PMAXSW = 6997,
	I_PMAXUB = 6681, I_PMAXUD = 8258, I_PMAXUW = 8241, I_PMINSB = 8139, I_PMINSD = 8156,
	I_PMINSW = 6935, I_PMINUB = 6623, I_PMINUD = 8190, I_PMINUW = 8173, I_PMOVMSKB = 6564,
	I_PMOVSXBD = 7787, I_PMOVSXBQ = 7808, I_PMOVSXBW = 7766, I_PMOVSXDQ = 7871,
	I_PMOVSXWD = 7829, I_PMOVSXWQ = 7850, I_PMOVZXBD = 8015, I_PMOVZXBQ = 8036,
	I_PMOVZXBW = 7994, I_PMOVZXDQ = 8099, I_PMOVZXWD = 8057, I_PMOVZXWQ = 8078,
	I_PMULDQ = 7892, I_PMULHRSW = 7571, I_PMULHRW = 2094, I_PMULHUW = 6773, I_PMULHW = 6792,
	I_PMULLD = 8275, I_PMULLW = 6529, I_PMULUDQ = 7087, I_POP = 22, I_POPA = 98,
	I_POPCNT = 4371, I_POPF = 277, I_POR = 6952, I_PREFETCH = 1905, I_PREFETCHNTA = 2435,
	I_PREFETCHT0 = 2448, I_PREFETCHT1 = 2460, I_PREFETCHT2 = 2472, I_PREFETCHW = 1915,
	I_PSADBW = 7125, I_PSHUFB = 7374, I_PSHUFD = 4021, I_PSHUFHW = 4029, I_PSHUFLW = 4038,
	I_PSHUFW = 4013, I_PSIGNB = 7520, I_PSIGND = 7554, I_PSIGNW = 7537, I_PSLLD = 7057,
	I_PSLLDQ = 9880, I_PSLLQ = 7072, I_PSLLW = 7042, I_PSRAD = 6743, I_PSRAW = 6728,
	I_PSRLD = 6484, I_PSRLDQ = 9863, I_PSRLQ = 6499, I_PSRLW = 6469, I_PSUBB = 7177,
	I_PSUBD = 7207, I_PSUBQ = 7222, I_PSUBSB = 6901, I_PSUBSW = 6918, I_PSUBUSB = 6585,
	I_PSUBUSW = 6604, I_PSUBW = 7192, I_PSWAPD = 2103, I_PTEST = 7662, I_PUNPCKHBW = 3813,
	I_PUNPCKHDQ = 3859, I_PUNPCKHQDQ = 3928, I_PUNPCKHWD = 3836, I_PUNPCKLBW = 3645,
	I_PUNPCKLDQ = 3691, I_PUNPCKLQDQ = 3903, I_PUNPCKLWD = 3668, I_PUSH = 16,
	I_PUSHA = 91, I_PUSHF = 270, I_PXOR = 7014, I_RCL = 976, I_RCPPS = 2986, I_RCPSS = 2993,
	I_RCR = 981, I_RDFSBASE = 9915, I_RDGSBASE = 9945, I_RDMSR = 599, I_RDPMC = 606,
	I_RDRAND = 10059, I_RDTSC = 592, I_RDTSCP = 1897, I_RET = 325, I_RETF = 354,
	I_ROL = 966, I_ROR = 971, I_ROUNDPD = 9329, I_ROUNDPS = 9310, I_ROUNDSD = 9367,
	I_ROUNDSS = 9348, I_RSM = 881, I_RSQRTPS = 2948, I_RSQRTSS = 2957, I_SAHF = 283,
	I_SAL = 996, I_SALC = 393, I_SAR = 1001, I_SBB = 36, I_SCAS = 319, I_SETA = 806,
	I_SETAE = 779, I_SETB = 773, I_SETBE = 799, I_SETG = 858, I_SETGE = 844, I_SETL = 838,
	I_SETLE = 851, I_SETNO = 766, I_SETNP = 831, I_SETNS = 818, I_SETNZ = 792,
	I_SETO = 760, I_SETP = 825, I_SETS = 812, I_SETZ = 786, I_SFENCE = 4354, I_SGDT = 1690,
	I_SHL = 986, I_SHLD = 875, I_SHR = 991, I_SHRD = 891, I_SHUFPD = 6369, I_SHUFPS = 6361,
	I_SIDT = 1696, I_SKINIT = 1872, I_SLDT = 1656, I_SMSW = 1714, I_SQRTPD = 2888,
	I_SQRTPS = 2880, I_SQRTSD = 2904, I_SQRTSS = 2896, I_STAC = 1792, I_STC = 496,
	I_STD = 516, I_STGI = 1860, I_STI = 506, I_STMXCSR = 9984, I_STOS = 307, I_STR = 1662,
	I_SUB = 51, I_SUBPD = 3412, I_SUBPS = 3405, I_SUBSD = 3426, I_SUBSS = 3419,
	I_SWAPGS = 1889, I_SYSCALL = 531, I_SYSENTER = 613, I_SYSEXIT = 623, I_SYSRET = 546,
	I_TEST = 206, I_TZCNT = 4384, I_UCOMISD = 2775, I_UCOMISS = 2766, I_UD2 = 568,
	I_UNPCKHPD = 2329, I_UNPCKHPS = 2319, I_UNPCKLPD = 2287, I_UNPCKLPS = 2277,
	I_VADDPD = 3172, I_VADDPS = 3164, I_VADDSD = 3188, I_VADDSS = 3180, I_VADDSUBPD = 6447,
	I_VADDSUBPS = 6458, I_VAESDEC = 9250, I_VAESDECLAST = 9271, I_VAESENC = 9208,
	I_VAESENCLAST = 9229, I_VAESIMC = 9191, I_VAESKEYGENASSIST = 9845, I_VANDNPD = 3071,
	I_VANDNPS = 3062, I_VANDPD = 3038, I_VANDPS = 3030, I_VBLENDPD = 9414, I_VBLENDPS = 9395,
	I_VBLENDVPD = 9714, I_VBLENDVPS = 9703, I_VBROADCASTF128 = 7705, I_VBROADCASTSD = 7691,
	I_VBROADCASTSS = 7677, I_VCMPEQPD = 5121, I_VCMPEQPS = 4719, I_VCMPEQSD = 5925,
	I_VCMPEQSS = 5523, I_VCMPEQ_OSPD = 5302, I_VCMPEQ_OSPS = 4900, I_VCMPEQ_OSSD = 6106,
	I_VCMPEQ_OSSS = 5704, I_VCMPEQ_UQPD = 5208, I_VCMPEQ_UQPS = 4806, I_VCMPEQ_UQSD = 6012,
	I_VCMPEQ_UQSS = 5610, I_VCMPEQ_USPD = 5411, I_VCMPEQ_USPS = 5009, I_VCMPEQ_USSD = 6215,
	I_VCMPEQ_USSS = 5813, I_VCMPFALSEPD = 5243, I_VCMPFALSEPS = 4841, I_VCMPFALSESD = 6047,
	I_VCMPFALSESS = 5645, I_VCMPFALSE_OSPD = 5452, I_VCMPFALSE_OSPS = 5050, I_VCMPFALSE_OSSD = 6256,
	I_VCMPFALSE_OSSS = 5854, I_VCMPGEPD = 5270, I_VCMPGEPS = 4868, I_VCMPGESD = 6074,
	I_VCMPGESS = 5672, I_VCMPGE_OQPD = 5482, I_VCMPGE_OQPS = 5080, I_VCMPGE_OQSD = 6286,
	I_VCMPGE_OQSS = 5884, I_VCMPGTPD = 5280, I_VCMPGTPS = 4878, I_VCMPGTSD = 6084,
	I_VCMPGTSS = 5682, I_VCMPGT_OQPD = 5495, I_VCMPGT_OQPS = 5093, I_VCMPGT_OQSD = 6299,
	I_VCMPGT_OQSS = 5897, I_VCMPLEPD = 5141, I_VCMPLEPS = 4739, I_VCMPLESD = 5945,
	I_VCMPLESS = 5543, I_VCMPLE_OQPD = 5328, I_VCMPLE_OQPS = 4926, I_VCMPLE_OQSD = 6132,
	I_VCMPLE_OQSS = 5730, I_VCMPLTPD = 5131, I_VCMPLTPS = 4729, I_VCMPLTSD = 5935,
	I_VCMPLTSS = 5533, I_VCMPLT_OQPD = 5315, I_VCMPLT_OQPS = 4913, I_VCMPLT_OQSD = 6119,
	I_VCMPLT_OQSS = 5717, I_VCMPNEQPD = 5164, I_VCMPNEQPS = 4762, I_VCMPNEQSD = 5968,
	I_VCMPNEQSS = 5566, I_VCMPNEQ_OQPD = 5256, I_VCMPNEQ_OQPS = 4854, I_VCMPNEQ_OQSD = 6060,
	I_VCMPNEQ_OQSS = 5658, I_VCMPNEQ_OSPD = 5468, I_VCMPNEQ_OSPS = 5066, I_VCMPNEQ_OSSD = 6272,
	I_VCMPNEQ_OSSS = 5870, I_VCMPNEQ_USPD = 5356, I_VCMPNEQ_USPS = 4954, I_VCMPNEQ_USSD = 6160,
	I_VCMPNEQ_USSS = 5758, I_VCMPNGEPD = 5221, I_VCMPNGEPS = 4819, I_VCMPNGESD = 6025,
	I_VCMPNGESS = 5623, I_VCMPNGE_UQPD = 5424, I_VCMPNGE_UQPS = 5022, I_VCMPNGE_UQSD = 6228,
	I_VCMPNGE_UQSS = 5826, I_VCMPNGTPD = 5232, I_VCMPNGTPS = 4830, I_VCMPNGTSD = 6036,
	I_VCMPNGTSS = 5634, I_VCMPNGT_UQPD = 5438, I_VCMPNGT_UQPS = 5036, I_VCMPNGT_UQSD = 6242,
	I_VCMPNGT_UQSS = 5840, I_VCMPNLEPD = 5186, I_VCMPNLEPS = 4784, I_VCMPNLESD = 5990,
	I_VCMPNLESS = 5588, I_VCMPNLE_UQPD = 5384, I_VCMPNLE_UQPS = 4982, I_VCMPNLE_UQSD = 6188,
	I_VCMPNLE_UQSS = 5786, I_VCMPNLTPD = 5175, I_VCMPNLTPS = 4773, I_VCMPNLTSD = 5979,
	I_VCMPNLTSS = 5577, I_VCMPNLT_UQPD = 5370, I_VCMPNLT_UQPS = 4968, I_VCMPNLT_UQSD = 6174,
	I_VCMPNLT_UQSS = 5772, I_VCMPORDPD = 5197, I_VCMPORDPS = 4795, I_VCMPORDSD = 6001,
	I_VCMPORDSS = 5599, I_VCMPORD_SPD = 5398, I_VCMPORD_SPS = 4996, I_VCMPORD_SSD = 6202,
	I_VCMPORD_SSS = 5800, I_VCMPTRUEPD = 5290, I_VCMPTRUEPS = 4888, I_VCMPTRUESD = 6094,
	I_VCMPTRUESS = 5692, I_VCMPTRUE_USPD = 5508, I_VCMPTRUE_USPS = 5106, I_VCMPTRUE_USSD = 6312,
	I_VCMPTRUE_USSS = 5910, I_VCMPUNORDPD = 5151, I_VCMPUNORDPS = 4749, I_VCMPUNORDSD = 5955,
	I_VCMPUNORDSS = 5553, I_VCMPUNORD_SPD = 5341, I_VCMPUNORD_SPS = 4939, I_VCMPUNORD_SSD = 6145,
	I_VCMPUNORD_SSS = 5743, I_VCOMISD = 2829, I_VCOMISS = 2820, I_VCVTDQ2PD = 6852,
	I_VCVTDQ2PS = 3371, I_VCVTPD2DQ = 6863, I_VCVTPD2PS = 3307, I_VCVTPS2DQ = 3382,
	I_VCVTPS2PD = 3296, I_VCVTSD2SI = 2755, I_VCVTSD2SS = 3329, I_VCVTSI2SD = 2569,
	I_VCVTSI2SS = 2558, I_VCVTSS2SD = 3318, I_VCVTSS2SI = 2744, I_VCVTTPD2DQ = 6840,
	I_VCVTTPS2DQ = 3393, I_VCVTTSD2SI = 2692, I_VCVTTSS2SI = 2680, I_VDIVPD = 3561,
	I_VDIVPS = 3553, I_VDIVSD = 3577, I_VDIVSS = 3569, I_VDPPD = 9654, I_VDPPS = 9641,
	I_VERR = 1678, I_VERW = 1684, I_VEXTRACTF128 = 9549, I_VEXTRACTPS = 9524,
	I_VFMADD132PD = 8420, I_VFMADD132PS = 8407, I_VFMADD132SD = 8446, I_VFMADD132SS = 8433,
	I_VFMADD213PD = 8700, I_VFMADD213PS = 8687, I_VFMADD213SD = 8726, I_VFMADD213SS = 8713,
	I_VFMADD231PD = 8980, I_VFMADD231PS = 8967, I_VFMADD231SD = 9006, I_VFMADD231SS = 8993,
	I_VFMADDSUB132PD = 8359, I_VFMADDSUB132PS = 8343, I_VFMADDSUB213PD = 8639,
	I_VFMADDSUB213PS = 8623, I_VFMADDSUB231PD = 8919, I_VFMADDSUB231PS = 8903,
	I_VFMSUB132PD = 8472, I_VFMSUB132PS = 8459, I_VFMSUB132SD = 8498, I_VFMSUB132SS = 8485,
	I_VFMSUB213PD = 8752, I_VFMSUB213PS = 8739, I_VFMSUB213SD = 8778, I_VFMSUB213SS = 8765,
	I_VFMSUB231PD = 9032, I_VFMSUB231PS = 9019, I_VFMSUB231SD = 9058, I_VFMSUB231SS = 9045,
	I_VFMSUBADD132PD = 8391, I_VFMSUBADD132PS = 8375, I_VFMSUBADD213PD = 8671,
	I_VFMSUBADD213PS = 8655, I_VFMSUBADD231PD = 8951, I_VFMSUBADD231PS = 8935,
	I_VFNMADD132PD = 8525, I_VFNMADD132PS = 8511, I_VFNMADD132SD = 8553, I_VFNMADD132SS = 8539,
	I_VFNMADD213PD = 8805, I_VFNMADD213PS = 8791, I_VFNMADD213SD = 8833, I_VFNMADD213SS = 8819,
	I_VFNMADD231PD = 9085, I_VFNMADD231PS = 9071, I_VFNMADD231SD = 9113, I_VFNMADD231SS = 9099,
	I_VFNMSUB132PD = 8581, I_VFNMSUB132PS = 8567, I_VFNMSUB132SD = 8609, I_VFNMSUB132SS = 8595,
	I_VFNMSUB213PD = 8861, I_VFNMSUB213PS = 8847, I_VFNMSUB213SD = 8889, I_VFNMSUB213SS = 8875,
	I_VFNMSUB231PD = 9141, I_VFNMSUB231PS = 9127, I_VFNMSUB231SD = 9169, I_VFNMSUB231SS = 9155,
	I_VHADDPD = 4230, I_VHADDPS = 4239, I_VHSUBPD = 4264, I_VHSUBPS = 4273, I_VINSERTF128 = 9536,
	I_VINSERTPS = 9590, I_VLDDQU = 7034, I_VLDMXCSR = 9974, I_VMASKMOVDQU = 7164,
	I_VMASKMOVPD = 7982, I_VMASKMOVPS = 7970, I_VMAXPD = 3621, I_VMAXPS = 3613,
	I_VMAXSD = 3637, I_VMAXSS = 3629, I_VMCALL = 1734, I_VMCLEAR = 10022, I_VMFUNC = 1814,
	I_VMINPD = 3501, I_VMINPS = 3493, I_VMINSD = 3517, I_VMINSS = 3509, I_VMLAUNCH = 1742,
	I_VMLOAD = 1844, I_VMMCALL = 1835, I_VMOVAPD = 2509, I_VMOVAPS = 2500, I_VMOVD = 3965,
	I_VMOVDDUP = 2267, I_VMOVDQA = 3995, I_VMOVDQU = 4004, I_VMOVHLPS = 2228,
	I_VMOVHPD = 2415, I_VMOVHPS = 2406, I_VMOVLHPS = 2396, I_VMOVLPD = 2247, I_VMOVLPS = 2238,
	I_VMOVMSKPD = 2869, I_VMOVMSKPS = 2858, I_VMOVNTDQ = 6891, I_VMOVNTDQA = 7938,
	I_VMOVNTPD = 2626, I_VMOVNTPS = 2616, I_VMOVQ = 3972, I_VMOVSD = 2176, I_VMOVSHDUP = 2424,
	I_VMOVSLDUP = 2256, I_VMOVSS = 2168, I_VMOVUPD = 2159, I_VMOVUPS = 2150, I_VMPSADBW = 9670,
	I_VMPTRLD = 10013, I_VMPTRST = 6418, I_VMREAD = 4161, I_VMRESUME = 1752, I_VMRUN = 1828,
	I_VMSAVE = 1852, I_VMULPD = 3232, I_VMULPS = 3224, I_VMULSD = 3248, I_VMULSS = 3240,
	I_VMWRITE = 4185, I_VMXOFF = 1762, I_VMXON = 10031, I_VORPD = 3099, I_VORPS = 3092,
	I_VPABSB = 7728, I_VPABSD = 7758, I_VPABSW = 7743, I_VPACKSSDW = 3892, I_VPACKSSWB = 3724,
	I_VPACKUSDW = 7959, I_VPACKUSWB = 3802, I_VPADDB = 7244, I_VPADDD = 7274,
	I_VPADDQ = 6521, I_VPADDSB = 6971, I_VPADDSW = 6988, I_VPADDUSW = 6662, I_VPADDW = 7259,
	I_VPALIGNR = 9452, I_VPAND = 6646, I_VPANDN = 6705, I_VPAVGB = 6720, I_VPAVGW = 6765,
	I_VPBLENDVB = 9725, I_VPBLENDW = 9433, I_VPCLMULQDQ = 9691, I_VPCMPEQB = 4085,
	I_VPCMPEQD = 4123, I_VPCMPEQQ = 7918, I_VPCMPEQW = 4104, I_VPCMPESTRI = 9770,
	I_VPCMPESTRM = 9747, I_VPCMPGTB = 3744, I_VPCMPGTD = 3782, I_VPCMPGTQ = 8129,
	I_VPCMPGTW = 3763, I_VPCMPISTRI = 9816, I_VPCMPISTRM = 9793, I_VPERM2F128 = 9298,
	I_VPERMILPD = 7603, I_VPERMILPS = 7592, I_VPEXTRB = 9470, I_VPEXTRD = 9495,
	I_VPEXTRQ = 9504, I_VPEXTRW = 6352, I_VPHADDD = 7416, I_VPHADDSW = 7434, I_VPHADDW = 7399,
	I_VPHMINPOSUW = 8304, I_VPHSUBD = 7492, I_VPHSUBSW = 7510, I_VPHSUBW = 7475,
	I_VPINSRB = 9571, I_VPINSRD = 9617, I_VPINSRQ = 9626, I_VPINSRW = 6335, I_VPMADDUBSW = 7455,
	I_VPMADDWD = 7115, I_VPMAXSB = 8215, I_VPMAXSD = 8232, I_VPMAXSW = 7005, I_VPMAXUB = 6689,
	I_VPMAXUD = 8266, I_VPMAXUW = 8249, I_VPMINSB = 8147, I_VPMINSD = 8164, I_VPMINSW = 6943,
	I_VPMINUB = 6631, I_VPMINUD = 8198, I_VPMINUW = 8181, I_VPMOVMSKB = 6574,
	I_VPMOVSXBD = 7797, I_VPMOVSXBQ = 7818, I_VPMOVSXBW = 7776, I_VPMOVSXDQ = 7881,
	I_VPMOVSXWD = 7839, I_VPMOVSXWQ = 7860, I_VPMOVZXBD = 8025, I_VPMOVZXBQ = 8046,
	I_VPMOVZXBW = 8004, I_VPMOVZXDQ = 8109, I_VPMOVZXWD = 8067, I_VPMOVZXWQ = 8088,
	I_VPMULDQ = 7900, I_VPMULHRSW = 7581, I_VPMULHUW = 6782, I_VPMULHW = 6800,
	I_VPMULLD = 8283, I_VPMULLW = 6537, I_VPMULUDQ = 7096, I_VPOR = 6957, I_VPSADBW = 7133,
	I_VPSHUFB = 7382, I_VPSHUFD = 4047, I_VPSHUFHW = 4056, I_VPSHUFLW = 4066,
	I_VPSIGNB = 7528, I_VPSIGND = 7562, I_VPSIGNW = 7545, I_VPSLLD = 7064, I_VPSLLDQ = 9888,
	I_VPSLLQ = 7079, I_VPSLLW = 7049, I_VPSRAD = 6750, I_VPSRAW = 6735, I_VPSRLD = 6491,
	I_VPSRLDQ = 9871, I_VPSRLQ = 6506, I_VPSRLW = 6476, I_VPSUBB = 7184, I_VPSUBD = 7214,
	I_VPSUBQ = 7229, I_VPSUBSB = 6909, I_VPSUBSW = 6926, I_VPSUBUSB = 6594, I_VPSUBUSW = 6613,
	I_VPSUBW = 7199, I_VPTEST = 7669, I_VPUNPCKHBW = 3824, I_VPUNPCKHDQ = 3870,
	I_VPUNPCKHQDQ = 3940, I_VPUNPCKHWD = 3847, I_VPUNPCKLBW = 3656, I_VPUNPCKLDQ = 3702,
	I_VPUNPCKLQDQ = 3915, I_VPUNPCKLWD = 3679, I_VPXOR = 7020, I_VRCPPS = 3000,
	I_VRCPSS = 3008, I_VROUNDPD = 9338, I_VROUNDPS = 9319, I_VROUNDSD = 9376,
	I_VROUNDSS = 9357, I_VRSQRTPS = 2966, I_VRSQRTSS = 2976, I_VSHUFPD = 6386,
	I_VSHUFPS = 6377, I_VSQRTPD = 2921, I_VSQRTPS = 2912, I_VSQRTSD = 2939, I_VSQRTSS = 2930,
	I_VSTMXCSR = 10003, I_VSUBPD = 3441, I_VSUBPS = 3433, I_VSUBSD = 3457, I_VSUBSS = 3449,
	I_VTESTPD = 7623, I_VTESTPS = 7614, I_VUCOMISD = 2794, I_VUCOMISS = 2784,
	I_VUNPCKHPD = 2350, I_VUNPCKHPS = 2339, I_VUNPCKLPD = 2308, I_VUNPCKLPS = 2297,
	I_VXORPD = 3128, I_VXORPS = 3120, I_VZEROALL = 4151, I_VZEROUPPER = 4139,
	I_WAIT = 10053, I_WBINVD = 560, I_WRFSBASE = 9964, I_WRGSBASE = 9993, I_WRMSR = 585,
	I_XABORT = 1006, I_XADD = 945, I_XBEGIN = 1014, I_XCHG = 212, I_XEND = 1822,
	I_XGETBV = 1798, I_XLAT = 399, I_XOR = 61, I_XORPD = 3113, I_XORPS = 3106,
	I_XRSTOR = 4306, I_XRSTOR64 = 4314, I_XSAVE = 4282, I_XSAVE64 = 4289, I_XSAVEOPT = 4332,
	I_XSAVEOPT64 = 4342, I_XSETBV = 1806, I__3DNOW = 10067
} _InstructionType;

typedef enum {
	R_RAX, R_RCX, R_RDX, R_RBX, R_RSP, R_RBP, R_RSI, R_RDI, R_R8, R_R9, R_R10, R_R11, R_R12, R_R13, R_R14, R_R15,
	R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI, R_R8D, R_R9D, R_R10D, R_R11D, R_R12D, R_R13D, R_R14D, R_R15D,
	R_AX, R_CX, R_DX, R_BX, R_SP, R_BP, R_SI, R_DI, R_R8W, R_R9W, R_R10W, R_R11W, R_R12W, R_R13W, R_R14W, R_R15W,
	R_AL, R_CL, R_DL, R_BL, R_AH, R_CH, R_DH, R_BH, R_R8B, R_R9B, R_R10B, R_R11B, R_R12B, R_R13B, R_R14B, R_R15B,
	R_SPL, R_BPL, R_SIL, R_DIL,
	R_ES, R_CS, R_SS, R_DS, R_FS, R_GS,
	R_RIP,
	R_ST0, R_ST1, R_ST2, R_ST3, R_ST4, R_ST5, R_ST6, R_ST7,
	R_MM0, R_MM1, R_MM2, R_MM3, R_MM4, R_MM5, R_MM6, R_MM7,
	R_XMM0, R_XMM1, R_XMM2, R_XMM3, R_XMM4, R_XMM5, R_XMM6, R_XMM7, R_XMM8, R_XMM9, R_XMM10, R_XMM11, R_XMM12, R_XMM13, R_XMM14, R_XMM15,
	R_YMM0, R_YMM1, R_YMM2, R_YMM3, R_YMM4, R_YMM5, R_YMM6, R_YMM7, R_YMM8, R_YMM9, R_YMM10, R_YMM11, R_YMM12, R_YMM13, R_YMM14, R_YMM15,
	R_CR0, R_UNUSED0, R_CR2, R_CR3, R_CR4, R_UNUSED1, R_UNUSED2, R_UNUSED3, R_CR8,
	R_DR0, R_DR1, R_DR2, R_DR3, R_UNUSED4, R_UNUSED5, R_DR6, R_DR7
} _RegisterType;

#endif /* MNEMONICS_H */

```

`DumpVAC/distorm/src/config.h`:

```h
/*
config.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef CONFIG_H
#define CONFIG_H

/* diStorm version number. */
#define __DISTORMV__ 0x030503

#include <string.h> /* memset, memcpy - can be easily self implemented for libc independency. */

#include "../include/distorm.h"


/*
 * 64 bit offsets support:
 * This macro should be defined from compiler command line flags, e.g: -DSUPPORT_64BIT_OFFSET
 * Note: make sure that the caller (library user) defines it too!
 */
/* #define SUPPORT_64BIT_OFFSET */

/*
 * If you compile diStorm as a dynamic library (.dll or .so) file, make sure you uncomment the next line.
 * So the interface functions will be exported, otherwise they are useable only for static library.
 * For example, this macro is being set for compiling diStorm as a .dll for Python with CTypes.
 */
/* #define DISTORM_DYNAMIC */

/*
 * If DISTORM_LIGHT is defined, everything involved in formatting the instructions
 * as text will be excluded from compilation.
 * distorm_decode(..) and distorm_format(..) will not be available.
 * This will decrease the size of the executable and leave you with decomposition functionality only.
 *
 * Note: it should be either set in the preprocessor definitions manually or in command line -D switch.
 * #define DISTORM_LIGHT
 */

/*
 * diStorm now supports little/big endian CPU's.
 * It should detect the endianness according to predefined macro's of the compiler.
 * If you don't use GCC/MSVC you will have to define it on your own.
 */

/* These macros are used in order to make the code portable. */
#ifdef __GNUC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
/* Keep inline as static (arrrrg) as it would break linux on some flavors otherwise. */
#define _INLINE_ static
/* GCC ignores this directive... */
/*#define _FASTCALL_ __attribute__((__fastcall__))*/

/* Set endianity (supposed to be LE though): */
#ifdef __BIG_ENDIAN__
	#define BE_SYSTEM
#endif

/* End of __GCC__ */

#elif __WATCOMC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ __inline

/* End of __WATCOMC__ */

#elif __DMC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ __inline

/* End of __DMC__ */

#elif __TINYC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ static

/* End of __TINYC__ */

#elif _MSC_VER

/* stdint alternative is defined in distorm.h */

#define _DLLEXPORT_ __declspec(dllexport)
#define _FASTCALL_ __fastcall
#define _INLINE_ __inline

/* Set endianity (supposed to be LE though): */
#if !defined(_M_IX86) && !defined(_M_X64)
	#define BE_SYSTEM
#endif

#endif /* #elif _MSC_VER */

/* If the library isn't compiled as a dynamic library don't export any functions. */
#ifndef DISTORM_DYNAMIC
#undef _DLLEXPORT_
#define _DLLEXPORT_
#endif

#ifndef FALSE
#define FALSE 0
#endif
#ifndef TRUE
#define TRUE 1
#endif

/* Define stream read functions for big endian systems. */
#ifdef BE_SYSTEM

/* Avoid defining 'static static' for GCC. */
#ifndef __GNUC__
#define STATIC_INLINE static _INLINE_
#else
#define STATIC_INLINE static
#endif

/*
 * Assumption: These functions can read from the stream safely!
 * Swap endianity of input to little endian.
 */
STATIC_INLINE int16_t RSHORT(const uint8_t *s)
{
	return s[0] | (s[1] << 8);
}
STATIC_INLINE uint16_t RUSHORT(const uint8_t *s)
{
	return s[0] | (s[1] << 8);
}
STATIC_INLINE int32_t RLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24);
}
STATIC_INLINE uint32_t RULONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24);
}
STATIC_INLINE int64_t RLLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24) | ((uint64_t)s[4] << 32) | ((uint64_t)s[5] << 40) | ((uint64_t)s[6] << 48) | ((uint64_t)s[7] << 56);
}
STATIC_INLINE uint64_t RULLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24) | ((uint64_t)s[4] << 32) | ((uint64_t)s[5] << 40) | ((uint64_t)s[6] << 48) | ((uint64_t)s[7] << 56);
}

#undef STATIC_INLINE

#else
/* Little endian macro's will just make the cast. */
#define RSHORT(x) *(int16_t *)x
#define RUSHORT(x) *(uint16_t *)x
#define RLONG(x) *(int32_t *)x
#define RULONG(x) *(uint32_t *)x
#define RLLONG(x) *(int64_t *)x
#define RULLONG(x) *(uint64_t *)x
#endif

#endif /* CONFIG_H */

```

`DumpVAC/distorm/src/decoder.c`:

```c
/*
decoder.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "decoder.h"
#include "instructions.h"
#include "insts.h"
#include "prefix.h"
#include "x86defs.h"
#include "operands.h"
#include "insts.h"
#include "../include/mnemonics.h"


/* Instruction Prefixes - Opcode - ModR/M - SIB - Displacement - Immediate */

static _DecodeType decode_get_effective_addr_size(_DecodeType dt, _iflags decodedPrefixes)
{
	/*
	 * Map from the current decoding mode to an effective address size:
	 * Decode16 -> Decode32
	 * Decode32 -> Decode16
	 * Decode64 -> Decode32
	 */

	/* Switch to non default mode if prefix exists, only for ADDRESS SIZE. */
	if (decodedPrefixes & INST_PRE_ADDR_SIZE) {
		if (dt == Decode32Bits) return Decode16Bits;
		return Decode32Bits;
	}
	return dt;
}

static _DecodeType decode_get_effective_op_size(_DecodeType dt, _iflags decodedPrefixes, unsigned int rex, _iflags instFlags)
{
	/*
	 * Map from the current decoding mode to an effective operand size:
	 * Decode16 -> Decode32
	 * Decode32 -> Decode16
	 * Decode64 -> Decode16
	 * Not that in 64bits it's a bit more complicated, because of REX and promoted instructions.
	 */

	if (decodedPrefixes & INST_PRE_OP_SIZE) {
		if (dt == Decode16Bits) return Decode32Bits;
		return Decode16Bits;
	}

	if (dt == Decode64Bits) {
		/*
		 * REX Prefix toggles data size to 64 bits.
		 * Operand size prefix toggles data size to 16.
		 * Default data size is 32 bits.
		 * Promoted instructions are 64 bits if they don't require a REX perfix.
		 * Non promoted instructions are 64 bits if the REX prefix exists.
		 */
		/* Automatically promoted instructions have only INST_64BITS SET! */
		if (((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS) ||
		/* Other instructions in 64 bits can be promoted only with a REX prefix. */
			((decodedPrefixes & INST_PRE_REX) && (rex & PREFIX_EX_W))) return Decode64Bits;
		return Decode32Bits; /* Default. */
	}

	return dt;
}

/*
 * A helper macro to convert from diStorm's CPU flags to EFLAGS.
 * Copy eflags from compact version (8 bits) to eflags compatible (16 bits).
 * From D_COMPACT_IF to D_IF, bit index 1 to 9.
 * From D_COMPACT_DF to D_DF, bit index 3 to 10.
 * From D_COMPACT_OF to D_OF, bit index 5 to 11.
 */
#define CONVERT_FLAGS_TO_EFLAGS(dst, src, field) dst->field = ((src->field & D_COMPACT_SAME_FLAGS) | \
	((src->field & D_COMPACT_IF) << (9 - 1)) | \
	((src->field & D_COMPACT_DF) << (10 - 3)) | \
	((src->field & D_COMPACT_OF) << (11 - 5)));

/* If DECRES_SUCCESS is returned, CI is in sync, otherwise it loses sync. */
/* Important note: CI is keeping track only for code and codeLen, in case of a failure caller has to restart on their own. */
static _DecodeResult decode_inst(_CodeInfo* ci, _PrefixState* ps, const uint8_t* startCode, _DInst* di)
{
	/* Holds the info about the current found instruction. */
	_InstInfo* ii;
	_InstSharedInfo* isi;

	/* Calculate (and cache) effective-operand-size and effective-address-size only once. */
	_DecodeType effOpSz, effAdrSz;
	_iflags instFlags;

	/* The ModR/M byte of the current instruction. */
	unsigned int modrm = 0;
	int isPrefixed = 0;

	ii = inst_lookup(ci, ps, &isPrefixed);
	if (ii == NULL) goto _Undecodable;

	isi = &InstSharedInfoTable[ii->sharedIndex];
	instFlags = FlagsTable[isi->flagsIndex];

	/* Cache the effective operand-size and address-size. */
	if (isPrefixed) {

		/*
		* If both REX and OpSize are available we will have to disable the OpSize, because REX has precedence.
		* However, only if REX.W is set!
		* We had to wait with this test, since the operand size may be a mandatory prefix,
		* and we know it only after fetching opcode.
		*/
		if ((ps->decodedPrefixes & INST_PRE_OP_SIZE) &&
			(ps->prefixExtType == PET_REX) &&
			(ps->vrex & PREFIX_EX_W) &&
			(!ps->isOpSizeMandatory)) {
			ps->decodedPrefixes &= ~INST_PRE_OP_SIZE;
			prefixes_ignore(ps, PFXIDX_OP_SIZE);
		}

		effAdrSz = decode_get_effective_addr_size(ci->dt, ps->decodedPrefixes);
		effOpSz = decode_get_effective_op_size(ci->dt, ps->decodedPrefixes, ps->vrex, instFlags);
	}
	else
	{
		effAdrSz = ci->dt; /* Default is current decoding type since there's no prefix. */
		effOpSz = decode_get_effective_op_size(ci->dt, 0, 0, instFlags);
	}

	/*
	 * In this point we know the instruction we are about to decode and its operands (unless, it's an invalid one!),
	 * so it makes it the right time for decoding-type suitability testing.
	 * Which practically means, don't allow 32 bits instructions in 16 bits decoding mode, but do allow
	 * 16 bits instructions in 32 bits decoding mode, of course...

	 * NOTE: Make sure the instruction set for 32 bits has explicitly this specific flag set.
	 * NOTE2: Make sure the instruction set for 64 bits has explicitly this specific flag set.

	 * If this is the case, drop what we've got and restart all over after DB'ing that byte.

	 * Though, don't drop an instruction which is also supported in 16 and 32 bits.
	 */

	 /* ! ! ! DISABLED UNTIL FURTHER NOTICE ! ! ! Decode16Bits CAN NOW DECODE 32 BITS INSTRUCTIONS ! ! !*/
	 /* if (ii && (dt == Decode16Bits) && (instFlags & INST_32BITS) && (~instFlags & INST_16BITS)) ii = NULL; */

	memset(di, 0, sizeof(_DInst));

	if (instFlags & INST_MODRM_REQUIRED) {
		/* If the ModRM byte is not part of the opcode, skip the last byte code, so code points now to ModRM. */
		if (!(instFlags & INST_MODRM_INCLUDED)) {
			ci->code++;
			if (--ci->codeLen < 0) goto _Undecodable;
		}
		modrm = *ci->code;
	}

	ci->code++; /* Skip the last byte we just read (either last opcode's byte code or a ModRM). */

	di->addr = ci->codeOffset & ci->addrMask;
	di->opcode = ii->opcodeId;
	di->flags = isi->meta & META_INST_PRIVILEGED;

	/*
	 * Store the address size inside the flags.
	 * This is necessary for the caller to know the size of rSP when using PUSHA for example.
	 */
	di->base = R_NONE;
	di->segment = R_NONE;

	FLAG_SET_ADDRSIZE(di, effAdrSz);

	/* Try to extract the next operand only if the latter exists. */
	if (isi->d != OT_NONE) {
		unsigned int opsNo = 1;
		_Operand* op = &di->ops[0];
		if (instFlags & (INST_MODRR_REQUIRED | INST_FORCE_REG0)) {
			/* Some instructions enforce that mod=11, so validate that. */
			if ((modrm < INST_DIVIDED_MODRM) && (instFlags & INST_MODRR_REQUIRED)) goto _Undecodable;
			/* Some instructions enforce that reg=000, so validate that. (Specifically EXTRQ). */
			if ((instFlags & INST_FORCE_REG0) && (((modrm >> 3) & 7) != 0)) goto _Undecodable;
		}
		if (!operands_extract(ci, di, ii, instFlags, (_OpType)isi->d, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;

		if (isi->s != OT_NONE) {
			if (!operands_extract(ci, di, ii, instFlags, (_OpType)isi->s, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;
			opsNo++;
			/* Use third operand, only if the flags says this InstInfo requires it. */
			if (instFlags & INST_USE_OP3) {
				if (!operands_extract(ci, di, ii, instFlags, (_OpType)((_InstInfoEx*)ii)->op3, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;
				opsNo++;
				/* Support for a fourth operand is added for (e.g:) INSERTQ instruction. */
				if (instFlags & INST_USE_OP4) {
					if (!operands_extract(ci, di, ii, instFlags, (_OpType)((_InstInfoEx*)ii)->op4, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;
					opsNo++;
				}
			}
		}

		/* Copy DST_WR flag. */
		di->flags |= (instFlags & INST_DST_WR) >> (31 - 6); /* Copy bit from INST_DST_WR (bit 31) to FLAG_DST_WR (bit 6). */
		/* operands_extract may touched it for FPU operands, so add on top. */
		di->opsNo += (uint8_t)opsNo;
	}

	if (instFlags & (INST_3DNOW_FETCH |
		INST_PSEUDO_OPCODE |
		INST_NATIVE |
		INST_PRE_REPNZ |
		INST_PRE_REP |
		INST_PRE_ADDR_SIZE |
		INST_INVALID_64BITS |
		INST_64BITS_FETCH)) { /* 8 for 1! */

		/* If it's a native instruction copy OpSize Prefix. */
		if (ps && instFlags & INST_NATIVE) ps->usedPrefixes |= (ps->decodedPrefixes & INST_PRE_OP_SIZE);

		if (ci->dt != Decode64Bits) {
			/* If it's only a 64 bits instruction drop it in other decoding modes. */
			if (instFlags & INST_64BITS_FETCH) goto _Undecodable;
		}
		else {
			/* Drop instructions which are invalid in 64 bits. */
			if (instFlags & INST_INVALID_64BITS) goto _Undecodable;
		}

		/* If it were a 3DNow! instruction, we will have to find the instruction itself now that we got its operands extracted. */
		if (instFlags & INST_3DNOW_FETCH) {
			ii = inst_lookup_3dnow(ci);
			if (ii == NULL) goto _Undecodable;
			isi = &InstSharedInfoTable[ii->sharedIndex];
			instFlags = FlagsTable[isi->flagsIndex];
			di->opcode = ii->opcodeId;
		}

		/* Check whether pseudo opcode is needed, only for CMP instructions: */
		if (instFlags & INST_PSEUDO_OPCODE) {
			/* Used only for special CMP instructions which have pseudo opcodes suffix. */
			unsigned int cmpType;

			if (--ci->codeLen < 0) goto _Undecodable;
			cmpType = *ci->code;
			ci->code++;

			/*
			 * The opcodeId is the offset to the FIRST pseudo compare mnemonic,
			 * we will have to fix it so it offsets into the corrected mnemonic.
			 * Therefore, we use another table to fix the offset.
			 */
			if (instFlags & INST_PRE_VEX) {
				/* AVX Comparison type must be between 0 to 32, otherwise Reserved. */
				if (cmpType >= INST_VCMP_MAX_RANGE) goto _Undecodable;

				/* Use the AVX pseudo compare mnemonics table. */
				di->opcode = ii->opcodeId + VCmpMnemonicOffsets[cmpType];
			}
			else {
				/* SSE Comparison type must be between 0 to 8, otherwise Reserved. */
				if (cmpType >= INST_CMP_MAX_RANGE) goto _Undecodable;
				di->opcode = ii->opcodeId + CmpMnemonicOffsets[cmpType];
			}

			goto _SkipOpcoding;
		}

		/* Start with prefix REP/N/Z. */
		if (isPrefixed && (instFlags & (INST_PRE_REPNZ | INST_PRE_REP))) {
			if ((instFlags & INST_PRE_REPNZ) && (ps->decodedPrefixes & INST_PRE_REPNZ)) {
				ps->usedPrefixes |= INST_PRE_REPNZ;
				di->flags |= FLAG_REPNZ;
			}
			else if ((instFlags & INST_PRE_REP) && (ps->decodedPrefixes & INST_PRE_REP)) {
				ps->usedPrefixes |= INST_PRE_REP;
				di->flags |= FLAG_REP;
			}
		}

		if (instFlags & INST_PRE_ADDR_SIZE) {
			/* If it's JeCXZ the ADDR_SIZE prefix affects them. */
			if (instFlags & INST_USE_EXMNEMONIC) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
				if (effAdrSz == Decode16Bits) di->opcode = ii->opcodeId;
				else if (effAdrSz == Decode32Bits) di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
				/* Ignore REX.W in 64bits, JECXZ is promoted. */
				else /* Decode64Bits */ di->opcode = ((_InstInfoEx*)ii)->opcodeId3;
			}

			/* LOOPxx instructions are also native instruction, but they are special case ones, ADDR_SIZE prefix affects them. */
			else if (instFlags & INST_NATIVE) {
				di->opcode = ii->opcodeId;

				/* If LOOPxx gets here from 64bits, it must be Decode32Bits because Address Size prefix is set. */
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
			}

			goto _SkipOpcoding;
		}
	}

	/*
	 * If we reached here the instruction was fully decoded, we located the instruction in the DB and extracted operands.
	 * Use the correct mnemonic according to the DT.
	 * If we are in 32 bits decoding mode it doesn't necessarily mean we will choose mnemonic2, alas,
	 * it means that if there is a mnemonic2, it will be used.
	 * Note:
	 * If the instruction is prefixed by operand size we will format it in the non-default decoding mode!
	 * So there might be a situation that an instruction of 32 bit gets formatted in 16 bits decoding mode.
	 * Both ways should end up with a correct and expected formatting of the text.
	 */
	if (effOpSz == Decode32Bits) { /* Decode32Bits */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode32Bits);

		/* Give a chance for special mnemonic instruction in 32 bits decoding. */
		if (instFlags & INST_USE_EXMNEMONIC) {
			/* Is it a special instruction which has another mnemonic for mod=11 ? */
			if (instFlags & INST_MNEMONIC_MODRM_BASED) {
				if (modrm < INST_DIVIDED_MODRM) di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
			}
			else di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
		}
	}
	else if (effOpSz == Decode64Bits) { /* Decode64Bits, note that some instructions might be decoded in Decode32Bits above. */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode64Bits);

		if (instFlags & (INST_USE_EXMNEMONIC | INST_USE_EXMNEMONIC2)) {
			/*
			 * We shouldn't be here for MODRM based mnemonics with a MOD=11,
			 * because they must not use REX (otherwise it will get to the wrong instruction which share same opcode).
			 * See XRSTOR and XSAVEOPT.
			 */
			if ((modrm >= INST_DIVIDED_MODRM) && (instFlags & INST_MNEMONIC_MODRM_BASED)) goto _Undecodable;

			/* Use third mnemonic, for 64 bits. */
			if ((instFlags & INST_USE_EXMNEMONIC2) && (ps->vrex & PREFIX_EX_W)) {
				ps->usedPrefixes |= INST_PRE_REX;
				di->opcode = ((_InstInfoEx*)ii)->opcodeId3;
			}
			else di->opcode = ((_InstInfoEx*)ii)->opcodeId2; /* Use second mnemonic. */
		}
	}
	else { /* Decode16Bits */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode16Bits);

		/*
		 * If it's a special instruction which has two mnemonics, then use the 16 bits one + update usedPrefixes.
		 * Note: use 16 bits mnemonic if that instruction supports 32 bit or 64 bit explicitly.
		 */
		if ((instFlags & (INST_USE_EXMNEMONIC | INST_32BITS | INST_64BITS)) == INST_USE_EXMNEMONIC) ps->usedPrefixes |= INST_PRE_OP_SIZE;
	}

_SkipOpcoding:

	/* Check VEX mnemonics: */
	if (isPrefixed && (instFlags & INST_PRE_VEX) &&
		(((((_InstInfoEx*)ii)->flagsEx & INST_MNEMONIC_VEXW_BASED) && (ps->vrex & PREFIX_EX_W)) ||
			((((_InstInfoEx*)ii)->flagsEx & INST_MNEMONIC_VEXL_BASED) && (ps->vrex & PREFIX_EX_L)))) {
		di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
	}

	/* Instruction's size should include prefixes too if exist. */
	di->size = (uint8_t)(ci->code - startCode);
	/*
	 * There's a limit of 15 bytes on instruction length. The only way to violate
	 * this limit is by putting redundant prefixes before an instruction.
	 * start points to first prefix if any, otherwise it points to instruction first byte.
	 */
	if (di->size > INST_MAXIMUM_SIZE) goto _Undecodable;

	/* Set the unused prefixes mask, if any prefixes (not) used at all. */
	if (isPrefixed) di->unusedPrefixesMask = prefixes_set_unused_mask(ps);

	/* Copy instruction meta. */
	di->meta = isi->meta;

	if (ci->features & DF_FILL_EFLAGS) {
		/* Copy CPU affected flags. */
		if (isi->testedFlagsMask) CONVERT_FLAGS_TO_EFLAGS(di, isi, testedFlagsMask);
		if (isi->modifiedFlagsMask) CONVERT_FLAGS_TO_EFLAGS(di, isi, modifiedFlagsMask);
		if (isi->undefinedFlagsMask) CONVERT_FLAGS_TO_EFLAGS(di, isi, undefinedFlagsMask);
	}

	/*
	 * Instruction can still be invalid if it's total length is over 15 bytes with prefixes.
	 * Up to the caller to check that.
	 */
	return DECRES_SUCCESS;

_Undecodable: /* If the instruction couldn't be decoded for some reason, fail. */
	/* Special case for WAIT instruction: If it's dropped as a prefix, we have to return a valid instruction! */
	if (*startCode == INST_WAIT_INDEX) {
		int delta;
		memset(di, 0, sizeof(_DInst));
		di->addr = ci->codeOffset & ci->addrMask;
		di->imm.byte = INST_WAIT_INDEX;
		di->segment = R_NONE;
		di->base = R_NONE;
		di->size = 1;
		di->opcode = I_WAIT;
		META_SET_ISC(di, ISC_INTEGER);

		/* Fix ci because WAIT could be a prefix that failed, and ci->code is now out of sync. */
		delta = (int)(ci->code - startCode); /* How many bytes we read so far. */
		ci->codeLen += delta - 1;
		ci->code = startCode + 1;
		/* codeOffset is fixed outside. */

		return DECRES_SUCCESS;
	}

	/* Mark that we didn't manage to decode the instruction well, caller will drop it. */
	return DECRES_INPUTERR;
}

/*
 * decode_internal
 *
 * supportOldIntr - Since now we work with new structure instead of the old _DecodedInst, we are still interested in backward compatibility.
 *                  So although, the array is now of type _DInst, we want to read it in jumps of the old array element's size.
 *                  This is in order to save memory allocation for conversion between the new and the old structures.
 *                  It really means we can do the conversion in-place now.
 */
_DecodeResult decode_internal(_CodeInfo* _ci, int supportOldIntr, _DInst result[], unsigned int maxResultCount, unsigned int* usedInstructionsCount)
{
	_CodeInfo ci = *_ci; /* A working copy, we don't touch user's _ci except OUT params. */
	_PrefixState ps;
	/* Bookkeep these from ci below, as it makes things way simpler. */
	const uint8_t* code;
	int codeLen;
	_OffsetType codeOffset;

	_DecodeResult ret = DECRES_SUCCESS;

	/* Current working decoded instruction in results. */
	_DInst* pdi = (_DInst*)&result[0]; /* There's always a room for at least one slot, checked earlier. */
	_DInst* maxResultAddr;

	unsigned int features = ci.features;

	unsigned int diStructSize;
	/* Use next entry. */
#ifndef DISTORM_LIGHT
	if (supportOldIntr) {
		diStructSize = sizeof(_DecodedInst);
		maxResultAddr = (_DInst*)((size_t)&result[0] + (maxResultCount * sizeof(_DecodedInst)));
	}
	else
#endif /* DISTORM_LIGHT */
	{
		diStructSize = sizeof(_DInst);
		maxResultAddr = &result[maxResultCount];
	}

	ci.addrMask = (_OffsetType)-1;

#ifdef DISTORM_LIGHT
	supportOldIntr; /* Unreferenced. */

	/*
	 * Only truncate address if we are using the decompose interface.
	 * Otherwise, we use the textual interface which needs full addresses for formatting bytes output.
	 * So distorm_format will truncate later.
	 */
	if (features & DF_MAXIMUM_ADDR32) ci.addrMask = 0xffffffff;
	else if (features & DF_MAXIMUM_ADDR16) ci.addrMask = 0xffff;
#endif

	ps.count = 1; /* Force zero'ing ps below. */

	/* Decode instructions as long as we have what to decode/enough room in entries. */
	while (ci.codeLen > 0) {
		code = ci.code;
		codeLen = ci.codeLen;
		codeOffset = ci.codeOffset;

		if (ps.count) memset(&ps, 0, sizeof(ps));

		/**** INSTRUCTION DECODING NEXT: ****/

		/* Make sure we didn't run out of output entries. */
		if (pdi >= maxResultAddr) {
			ret = DECRES_MEMORYERR;
			break;
		}

		ret = decode_inst(&ci, &ps, code, pdi);
		/* decode_inst keeps track (only if successful!) for code and codeLen but ignores codeOffset, fix it here. */
		ci.codeOffset += pdi->size;

		if (ret == DECRES_SUCCESS) {

			if (features & (DF_SINGLE_BYTE_STEP | DF_RETURN_FC_ONLY | DF_STOP_ON_PRIVILEGED | DF_STOP_ON_FLOW_CONTROL)) {

				/* Sync codeinfo, remember that currently it points to beginning of the instruction and prefixes if any. */
				if (features & DF_SINGLE_BYTE_STEP) {
					ci.code = code + 1;
					ci.codeLen = codeLen - 1;
					ci.codeOffset = codeOffset + 1;
				}

				/* See if we need to filter this instruction. */
				if ((features & DF_RETURN_FC_ONLY) && (META_GET_FC(pdi->meta) == FC_NONE)) {
					continue;
				}

				/* Check whether we need to stop on any feature. */
				if ((features & DF_STOP_ON_PRIVILEGED) && (FLAG_GET_PRIVILEGED(pdi->flags))) {
					pdi = (_DInst*)((char*)pdi + diStructSize);
					break; /* ret = DECRES_SUCCESS; */
				}

				if (features & DF_STOP_ON_FLOW_CONTROL) {
					unsigned int mfc = META_GET_FC(pdi->meta);
					if (mfc && (((features & DF_STOP_ON_CALL) && (mfc == FC_CALL)) ||
						((features & DF_STOP_ON_RET) && (mfc == FC_RET)) ||
						((features & DF_STOP_ON_SYS) && (mfc == FC_SYS)) ||
						((features & DF_STOP_ON_UNC_BRANCH) && (mfc == FC_UNC_BRANCH)) ||
						((features & DF_STOP_ON_CND_BRANCH) && (mfc == FC_CND_BRANCH)) ||
						((features & DF_STOP_ON_INT) && (mfc == FC_INT)) ||
						((features & DF_STOP_ON_CMOV) && (mfc == FC_CMOV)) ||
						((features & DF_STOP_ON_HLT) && (mfc == FC_HLT)))) {
						pdi = (_DInst*)((char*)pdi + diStructSize);
						break; /* ret = DECRES_SUCCESS; */
					}
				}
			}

			/* Allocate at least one more entry to use, for the next instruction. */
			pdi = (_DInst*)((char*)pdi + diStructSize);
		}
		else { /* ret == DECRES_INPUTERR */

			/* Handle failure of decoding last instruction. */
			if ((!(features & DF_RETURN_FC_ONLY))) {
				memset(pdi, 0, sizeof(_DInst));
				pdi->flags = FLAG_NOT_DECODABLE;
				pdi->imm.byte = *code;
				pdi->size = 1;
				pdi->addr = codeOffset & ci.addrMask;
				pdi = (_DInst*)((char*)pdi + diStructSize);

				/* If an instruction wasn't decoded then stop on undecodeable if set. */
				if (features & DF_STOP_ON_UNDECODEABLE) {
					ret = DECRES_SUCCESS;
					break;
				}
			}

			/* Skip a single byte in case of a failure and retry instruction. */
			ci.code = code + 1;
			ci.codeLen = codeLen - 1;
			ci.codeOffset = codeOffset + 1;

			/* Reset return value. */
			ret = DECRES_SUCCESS;
		}
	}

	/* Set OUT params. */
	*usedInstructionsCount = (unsigned int)(((size_t)pdi - (size_t)result) / (size_t)diStructSize);
	_ci->nextOffset = ci.codeOffset;

	return ret;
}

```

`DumpVAC/distorm/src/decoder.h`:

```h
/*
decoder.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef DECODER_H
#define DECODER_H

#include "config.h"

typedef unsigned int _iflags;

_DecodeResult decode_internal(_CodeInfo* _ci, int supportOldIntr, _DInst result[], unsigned int maxResultCount, unsigned int* usedInstructionsCount);

#endif /* DECODER_H */

```

`DumpVAC/distorm/src/distorm.c`:

```c
/*
distorm.c

diStorm3 C Library Interface
diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "../include/distorm.h"
#include "config.h"
#include "decoder.h"
#include "x86defs.h"
#include "textdefs.h"
#include "wstring.h"
#include "../include/mnemonics.h"

/* C DLL EXPORTS */
#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ _DecodeResult distorm_decompose64(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#else
	_DLLEXPORT_ _DecodeResult distorm_decompose32(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#endif
{
	if (usedInstructionsCount == NULL) {
		return DECRES_SUCCESS;
	}

	if ((ci == NULL) ||
		(ci->codeLen < 0) ||
		((unsigned)ci->dt > (unsigned)Decode64Bits) ||
		(ci->code == NULL) ||
		(result == NULL) ||
		(maxInstructions == 0) ||
		((ci->features & (DF_MAXIMUM_ADDR16 | DF_MAXIMUM_ADDR32)) == (DF_MAXIMUM_ADDR16 | DF_MAXIMUM_ADDR32)))
	{
		return DECRES_INPUTERR;
	}

	return decode_internal(ci, FALSE, result, maxInstructions, usedInstructionsCount);
}

#ifndef DISTORM_LIGHT

/* Helper function to concatenate an explicit size when it's unknown from the operands. */
static void distorm_format_size(unsigned char** str, const _DInst* di, int opNum)
{
	int isSizingRequired = 0;
	/*
	 * We only have to output the size explicitly if it's not clear from the operands.
	 * For example:
	 * mov al, [0x1234] -> The size is 8, we know it from the AL register operand.
	 * mov [0x1234], 0x11 -> Now we don't know the size. Pam pam pam
	 *
	 * If given operand number is higher than 2, then output the size anyways.
	 */
	isSizingRequired = ((opNum >= 2) || ((opNum == 0) && (di->ops[0].type != O_REG) && (di->ops[1].type != O_REG)));

	/* Still not sure? Try some special instructions. */
	if (!isSizingRequired) {
		/*
		 * INS/OUTS are exception, because DX is a port specifier and not a real src/dst register.
		 * A few exceptions that always requires sizing:
		 * MOVZX, MOVSX, MOVSXD.
		 * ROL, ROR, RCL, RCR, SHL, SHR, SAL, SAR.
		 * SHLD, SHRD.
		 * CVTSI2SS is also an exception.
		 */
		switch (di->opcode)
		{
			case I_INS:
			case I_OUTS:
			case I_MOVZX:
			case I_MOVSX:
			case I_MOVSXD:
			case I_ROL:
			case I_ROR:
			case I_RCL:
			case I_RCR:
			case I_SHL:
			case I_SHR:
			case I_SAL:
			case I_SAR:
			case I_SHLD:
			case I_SHRD:
			case I_CVTSI2SS:
				isSizingRequired = 1;
			break;
			default: /* Instruction doesn't require sizing. */ break;
		}
	}

	if (isSizingRequired)
	{
		/*case 0: break; OT_MEM's unknown size. */
		switch (di->ops[opNum].size / 8)
		{
			case 1: strcat_WS(*str,  "BYTE    ", 8, 5); break;
			case 2: strcat_WS(*str,  "WORD    ", 8, 5); break;
			case 4: strcat_WS(*str,  "DWORD   ", 8, 6); break;
			case 8: strcat_WS(*str,  "QWORD   ", 8, 6); break;
			case 10: strcat_WS(*str, "TBYTE   ", 8, 6); break;
			case 16: strcat_WS(*str, "DQWORD  ", 8, 7); break;
			case 32: strcat_WS(*str, "YWORD   ", 8, 6); break;
		}
	}
}

static void distorm_format_signed_disp(unsigned char** str, const _DInst* di, uint64_t addrMask)
{
	int64_t tmpDisp64;

	if (di->dispSize) {
		if (((int64_t)di->disp < 0)) {
			chrcat_WS(*str, MINUS_DISP_CHR);
			tmpDisp64 = -(int64_t)di->disp;
			tmpDisp64 &= addrMask; /* Verify only for neg numbers. */
		}
		else {
			chrcat_WS(*str, PLUS_DISP_CHR);
			tmpDisp64 = di->disp;
		}
		str_int(str, tmpDisp64);
	}
}

static uint8_t prefixTable[6][8] = { "", "LOCK ", "REPNZ ", "REPNZ ", "REP ", "REPZ " };
static unsigned int prefixSizesTable[6] = { 0, 5, 6, 6, 4, 5 };
static uint8_t suffixTable[10] = { 0, 'B', 'W', 0, 'D', 0, 0, 0, 'Q' };

/* WARNING: This function is written carefully to be able to work with same input and output buffer in-place! */
#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ void distorm_format64(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result)
#else
	_DLLEXPORT_ void distorm_format32(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result)
#endif
{
	unsigned char* str;
	int64_t tmpDisp64;
	uint64_t addrMask = (uint64_t)-1;
	const _WMnemonic* mnemonic;
	int suffixSize = -1;
	unsigned int i;

	/* Set address mask, when default is for 64bits addresses. */
	if (ci->features & DF_USE_ADDR_MASK) addrMask = ci->addrMask;
	else {
		if (ci->features & DF_MAXIMUM_ADDR32) addrMask = 0xffffffff;
		else if (ci->features & DF_MAXIMUM_ADDR16) addrMask = 0xffff;
	}

	/* Gotta have full address for (di->addr - ci->codeOffset) to work in all modes. */
	str_hex(&result->instructionHex, (const uint8_t*)&ci->code[(unsigned int)(di->addr - ci->codeOffset)], di->size);

	if ((int)((int16_t)di->flags) == -1) {
		/* In-place considerations: DI is RESULT. Deref fields first. */
		unsigned int size = di->size;
		unsigned int byte = di->imm.byte;
		_OffsetType offset = di->addr & addrMask;

		result->offset = offset;
		result->size = size;
		str = (unsigned char*)&result->mnemonic.p;
		strcat_WS(str, "DB  ", 4, 3);
		str_int(&str, byte);
		strfinalize_WS(result->mnemonic, str);
		*(uint64_t*)&result->operands = 0; /* Clears length and the string at once. */
		return; /* Skip to next instruction. */
	}

	str = (unsigned char*)&result->operands.p;

	/* Special treatment for String (movs, cmps, stos, lods, scas) instructions. */
	if ((di->opcode >= I_MOVS) && (di->opcode <= I_SCAS)) {
		/*
		 * No operands are needed if the address size is the default one,
		 * and no segment is overridden, so add the suffix letter,
		 * to indicate size of operation and continue to next instruction.
		 */
		if ((SEGMENT_IS_DEFAULT_OR_NONE(di->segment)) && (FLAG_GET_ADDRSIZE(di->flags) == ci->dt)) {
			suffixSize = di->ops[0].size / 8;
			goto skipOperands;
		}
		suffixSize = 0; /* Marks it's a string instruction. */
	}

	for (i = 0; i < di->opsNo; i++) {
		unsigned int type = di->ops[i].type;
		if (i > 0) strcat_WS(str, ", ", 2, 2);
		if (type == O_REG) {
			strcat_WSR(&str, &_REGISTERS[di->ops[i].index]);
		}
		else if (type == O_IMM) {
			/* If the instruction is 'push', show explicit size (except byte imm). */
			if ((di->opcode == I_PUSH) && (di->ops[i].size != 8)) distorm_format_size(&str, di, i);
			/* Special fix for negative sign extended immediates. */
			if ((di->flags & FLAG_IMM_SIGNED) && (di->ops[i].size == 8) && (di->imm.sbyte < 0)) {
				chrcat_WS(str, MINUS_DISP_CHR);
				tmpDisp64 = -di->imm.sbyte;
				str_int(&str, tmpDisp64);
			}
			else {
				/* Notice signedness and size of the immediate. */
				if (di->ops[i].size == 0x20) str_int(&str, di->imm.dword);
				else str_int(&str, di->imm.qword);
			}
		}
		else if (type == O_PC) {
#ifdef SUPPORT_64BIT_OFFSET
			str_int(&str, (di->size + di->imm.sqword + di->addr) & addrMask);
#else
			tmpDisp64 = ((_OffsetType)di->imm.sdword + di->addr + di->size) & (uint32_t)addrMask;
			str_int(&str, tmpDisp64);
#endif
		}
		else if (type == O_DISP) {
			distorm_format_size(&str, di, i);
			chrcat_WS(str, OPEN_CHR);
			if (!SEGMENT_IS_DEFAULT_OR_NONE(di->segment)) {
				strcat_WSR(&str, &_REGISTERS[SEGMENT_GET_UNSAFE(di->segment)]);
				chrcat_WS(str, SEG_OFF_CHR);
			}
			tmpDisp64 = di->disp & addrMask;
			str_int(&str, tmpDisp64);
			chrcat_WS(str, CLOSE_CHR);
		}
		else if (type == O_SMEM) {
			int isDefault;
			int segment;
			distorm_format_size(&str, di, i);
			chrcat_WS(str, OPEN_CHR);

			segment = SEGMENT_GET(di->segment);
			isDefault = SEGMENT_IS_DEFAULT(di->segment);

			/*
			 * This is where we need to take special care for String instructions.
			 * If we got here, it means we need to explicitly show their operands.
			 * The problem with CMPS and MOVS is that they have two(!) memory operands.
			 * So we have to complement(!) them ourselves, since the isntruction structure supplies only the segment that can be overridden.
			 * And make the rest of the String operations explicit.
			 * We ignore default ES/DS in 64 bits.
			 * ["MOVS"], [OPT.REGI_EDI, OPT.REGI_ESI] -- DS can be overridden.
			 * ["CMPS"], [OPT.REGI_ESI, OPT.REGI_EDI] -- DS can be overriden.
			 *
			 * suffixSize == 0 was set above for string opcode already.
			 */
			if (suffixSize == 0) {
				if (((di->opcode == I_MOVS) && (i == 0)) || ((di->opcode == I_CMPS) && (i == 1))) {
					if (ci->dt != Decode64Bits) {
						segment = R_ES;
						isDefault = FALSE;
					}
					else isDefault = TRUE;
				}
				else if (isDefault && ((di->opcode == I_MOVS) || (di->opcode == I_CMPS))) {
					if (ci->dt != Decode64Bits) {
						segment = R_DS;
						isDefault = FALSE;
					}
				}
			}
			if (!isDefault && (segment != R_NONE)) {
				strcat_WSR(&str, &_REGISTERS[segment]);
				chrcat_WS(str, SEG_OFF_CHR);
			}

			strcat_WSR(&str, &_REGISTERS[di->ops[i].index]);

			distorm_format_signed_disp(&str, di, addrMask);
			chrcat_WS(str, CLOSE_CHR);
		}
		else if (type == O_MEM) {
			distorm_format_size(&str, di, i);
			chrcat_WS(str, OPEN_CHR);
			if (!SEGMENT_IS_DEFAULT_OR_NONE(di->segment)) {
				strcat_WSR(&str, &_REGISTERS[SEGMENT_GET_UNSAFE(di->segment)]);
				chrcat_WS(str, SEG_OFF_CHR);
			}
			if (di->base != R_NONE) {
				strcat_WSR(&str, &_REGISTERS[di->base]);
				chrcat_WS(str, PLUS_DISP_CHR);
			}
			strcat_WSR(&str, &_REGISTERS[di->ops[i].index]);
			if (di->scale != 0) {
				switch (di->scale)
				{
					case 2: strcat_WS(str, "*2", 2, 2); break;
					case 4: strcat_WS(str, "*4", 2, 2); break;
					case 8: strcat_WS(str, "*8", 2, 2); break;
				}
			}
			distorm_format_signed_disp(&str, di, addrMask);
			chrcat_WS(str, CLOSE_CHR);
		}
		else if (type == O_PTR) {
			str_int(&str, di->imm.ptr.seg);
			chrcat_WS(str, SEG_OFF_CHR);
			str_int(&str, di->imm.ptr.off);
		}
		else if (type == O_IMM1) {
			str_int(&str, di->imm.ex.i1);
		}
		else if (type == O_IMM2) {
			str_int(&str, di->imm.ex.i2);
		}
	}

skipOperands:

	/* Finalize the operands string. */
	strfinalize_WS(result->operands, str);

	/* Not used anymore.
	if (di->flags & FLAG_HINT_TAKEN) strcat_WSN(str, " ;TAKEN");
	else if (di->flags & FLAG_HINT_NOT_TAKEN) strcat_WSN(str, " ;NOT TAKEN");
	*/
	{
		/* In-place considerations: DI is RESULT. Deref fields first. */
		unsigned int opcode = di->opcode;
		unsigned int prefix = FLAG_GET_PREFIX(di->flags);
		unsigned int size = di->size;
		_OffsetType offset = di->addr & addrMask;
		str = (unsigned char*)&result->mnemonic.p;
		mnemonic = (const _WMnemonic*)&_MNEMONICS[opcode];

		if (prefix) {
			/* REP prefix for CMPS and SCAS is really a REPZ. */
			prefix += (opcode == I_CMPS);
			prefix += (opcode == I_SCAS);
			memcpy(str, &prefixTable[prefix][0], 8);
			str += prefixSizesTable[prefix];
		}

		/*
		 * Always copy 16 bytes from the mnemonic, we have a sentinel padding so we can read past.
		 * This helps the compiler to remove the call to memcpy and therefore makes this copying much faster.
		 * The longest instruction is exactly 16 chars long, so we null terminate the string below.
		 */
		memcpy((int8_t*)str, mnemonic->p, 16);
		str += mnemonic->length;

		if (suffixSize > 0) {
			*str++ = suffixTable[suffixSize];
		}
		strfinalize_WS(result->mnemonic, str);

		result->offset = offset;
		result->size = size;
	}
}

#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ _DecodeResult distorm_decode64(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#else
	_DLLEXPORT_ _DecodeResult distorm_decode32(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#endif
{
	_DecodeResult res;
	_CodeInfo ci;
	unsigned int i, instsCount;

	*usedInstructionsCount = 0;

	/* I use codeLen as a signed variable in order to ease detection of underflow... and besides - */
	if (codeLen < 0) {
		return DECRES_INPUTERR;
	}

	if ((unsigned)dt > (unsigned)Decode64Bits) {
		return DECRES_INPUTERR;
	}

	/* Make sure there's at least one instruction in the result buffer. */
	if ((code == NULL) || (result == NULL) || (maxInstructions == 0)) {
		return DECRES_INPUTERR;
	}

	/*
	 * We have to format the result into text. But the interal decoder works with the new structure of _DInst.
	 * Therefore, we will pass the result array(!) from the caller and the interal decoder will fill it in with _DInst's.
	 * Then we will copy each result to a temporary structure, and use it to reformat that specific result.
	 *
	 * This is all done to save memory allocation and to work on the same result array in-place!!!
	 * It's a bit ugly, I have to admit, but worth it.
	 */

	ci.codeOffset = codeOffset;
	ci.code = code;
	ci.codeLen = codeLen;
	ci.dt = dt;
	ci.features = DF_USE_ADDR_MASK;
	if (dt == Decode16Bits) ci.addrMask = 0xffff;
	else if (dt == Decode32Bits) ci.addrMask = 0xffffffff;
	else ci.addrMask = (_OffsetType)-1;

	res = decode_internal(&ci, TRUE, (_DInst*)result, maxInstructions, usedInstructionsCount);
	instsCount = *usedInstructionsCount;
	for (i = 0; i < instsCount; i++) {
		/* distorm_format is optimized and can work with same input/output buffer in-place. */
#ifdef SUPPORT_64BIT_OFFSET
		distorm_format64(&ci, (_DInst*)&result[i], &result[i]);
#else
		distorm_format32(&ci, (_DInst*)&result[i], &result[i]);
#endif
	}

	return res;
}

#endif /* DISTORM_LIGHT */

_DLLEXPORT_ unsigned int distorm_version(void)
{
	return __DISTORMV__;
}

```

`DumpVAC/distorm/src/instructions.c`:

```c
/*
instructions.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "instructions.h"

#include "insts.h"
#include "prefix.h"
#include "x86defs.h"
#include "../include/mnemonics.h"


/* Helper macros to extract the type or index from an inst-node value. */
#define INST_NODE_INDEX(n) ((n) & 0x1fff)
#define INST_NODE_TYPE(n) ((n) >> 13)

/* Helper macro to read the actual flags that are associated with an inst-info. */
#define INST_INFO_FLAGS(ii) (FlagsTable[InstSharedInfoTable[(ii)->sharedIndex].flagsIndex])

/*
I use the trie data structure as I found it most fitting to a disassembler mechanism.
When you read a byte and have to decide if it's enough or you should read more bytes, 'till you get to the instruction information.
It's really fast because you POP the instruction info in top 3 iterates on the DB, because an instruction can be formed from two bytes + 3 bits reg from the ModR/M byte.
For a simple explanation, check this out:
http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Trie/
Further reading: http://en.wikipedia.org/wiki/Trie

The first GATE (array you read off a trie data structure), as I call them, is statically allocated by the compiler.
The second and third gates if used are being allocated dynamically by the instructions-insertion functionality.

How would such a thing look in memory, say we support 4 instructions with 3 bytes top (means 2 dynamically allocated gates).

->
|-------|                                0,
|0|     -------------------------------> |-------|
|1|RET  |      1,                        |0|AND  |
|2|     -----> |-------|                 |1|XOR  |
|3|INT3 |      |0|PUSH |                 |2|OR   |         0,3,
|-------|      |1|POP  |                 |3|     --------->|-------|
               |2|PUSHF|                 |-------|         |0|ROR  |
               |3|POPF |                                   |1|ROL  |
               |-------|                                   |2|SHR  |
                                                           |3|SHL  |
                                                           |-------|

Of course, this is NOT how Intel instructions set looks!!!
but I just wanted to give a small demonstration.
Now the instructions you get from such a trie DB goes like this:

0, 0 - AND
0, 1 - XOR
0, 2 - OR
0, 3, 0, ROR
0, 3, 1, ROL
0, 3, 2, SHR
0, 3, 3, SHL
1 - RET
2, 0 - PUSH
2, 1 - POP
2, 2 - PUSHF
2, 3 - POPF
3 - INT3

I guess it's clear by now.
So now, if you read 0, you know that you have to enter the second gate(list) with the second byte specifying the index.
But if you read 1, you know that you go to an instruction (in this case, a RET).
That's why there's an Instruction-Node structure, it tells you whether you got to an instruction or another list
so you should keep on reading byte).

In Intel, you could go through 4 gates at top, because there are instructions which are built from 2 bytes and another smaller list
for the REG part, or newest SSE4 instructions which use 4 bytes for opcode.
Therefore, Intel's first gate is 256 long, and other gates are 256 (/72) or 8 long, yes, it costs pretty much a lot of memory
for non-used defined instructions, but I think that it still rocks.
*/

/*
 * A helper function to look up the correct inst-info structure.
 * It does one fetch from the index-table, and then another to get the inst-info.
 * Note that it takes care about basic inst-info or inst-info-ex.
 * The caller should worry about boundary checks and whether it accesses a last-level table.
 */
static _InstInfo* inst_get_info(_InstNode in, int index)
{
	int instIndex = 0;

	in = InstructionsTree[INST_NODE_INDEX(in) + index];
	if (in == INT_NOTEXISTS) return NULL;

	instIndex = INST_NODE_INDEX(in);
	return INST_NODE_TYPE(in) == INT_INFO ? &InstInfos[instIndex] : (_InstInfo*)&InstInfosEx[instIndex];
}

/*
 * This function is responsible to return the instruction information of the first found in code.
 * It returns the _InstInfo of the found instruction, otherwise NULL.
 * code should point to the ModR/M byte upon exit (if used), or after the instruction binary code itself.
 * This function is NOT decoding-type dependant, it is up to the caller to see whether the instruction is valid.
 * Get the instruction info, using a Trie data structure.
 *
 * Sometimes normal prefixes become mandatory prefixes, which means they are now part of the instruction opcode bytes.

 * This is a bit tricky now,
 * if the first byte is a REP (F3) prefix, we will have to give a chance to an SSE instruction.
 * If an instruction doesn't exist, we will make it as a prefix and re-locateinst.
 * A case such that a REP prefix is being changed into an instruction byte and also an SSE instruction will not be found can't happen,
 * simply because there are no collisions between string instruction and SSE instructions (they are escaped).

 * As for S/SSE2/3, check for F2 and 66 as well.

 * In 64 bits, we have to make sure that we will skip the REX prefix, if it exists.
 * There's a specific case, where a 66 is mandatory but it was dropped because REG.W was used,
 * but it doesn't behave as an operand size prefix but as a mandatory, so we will have to take it into account.

 * For example (64 bits decoding mode):
 * 66 98 CBW
 * 48 98 CDQE
 * 66 48 98: db 0x66; CDQE
 * Shows that operand size is dropped.

 * Now, it's a mandatory prefix and NOT an operand size one.
 * 66480f2dc0 db 0x48; CVTPD2PI XMM0, XMM0
 * Although this instruction doesn't require a REX.W, it just shows, that even if it did - it doesn't matter.
 * REX.W is dropped because it's not required, but the decode function disabled the operand size even so.
 */
static _InstInfo* inst_lookup_prefixed(_InstNode in, _PrefixState* ps)
{
	int checkOpSize = FALSE;
	int index = 0;
	_InstInfo* ii = NULL;

	/* Check prefixes of current decoded instruction (None, 0x66, 0xf3, 0xf2). */
	switch (ps->decodedPrefixes & (INST_PRE_OP_SIZE | INST_PRE_REPS))
	{
		case 0:
			/* Non-prefixed, index = 0. */
			index = 0;
		break;
		case INST_PRE_OP_SIZE:
			/* 0x66, index = 1. */
			index = 1;
			/* Mark that we used it as a mandatory prefix. */
			ps->isOpSizeMandatory = TRUE;
			ps->decodedPrefixes &= ~INST_PRE_OP_SIZE;
		break;
		case INST_PRE_REP:
			/* 0xf3, index = 2. */
			index = 2;
			ps->decodedPrefixes &= ~INST_PRE_REP;
		break;
		case INST_PRE_REPNZ:
			/* 0xf2, index = 3. */
			index = 3;
			ps->decodedPrefixes &= ~INST_PRE_REPNZ;
		break;
		default:
			/*
			 * Now we got a problem, since there are a few mandatory prefixes at once.
			 * There is only one case when it's ok, when the operand size prefix is for real (not mandatory).
			 * Otherwise we will have to return NULL, since the instruction is illegal.
			 * Therefore we will start with REPNZ and REP prefixes,
			 * try to get the instruction and only then check for the operand size prefix.
			 */

			 /* If both REPNZ and REP are together, it's illegal for sure. */
			if ((ps->decodedPrefixes & INST_PRE_REPS) == INST_PRE_REPS) return NULL;

			/* Now we know it's either REPNZ+OPSIZE or REP+OPSIZE, so examine the instruction. */
			if (ps->decodedPrefixes & INST_PRE_REPNZ) {
				index = 3;
				ps->decodedPrefixes &= ~INST_PRE_REPNZ;
			}
			else if (ps->decodedPrefixes & INST_PRE_REP) {
				index = 2;
				ps->decodedPrefixes &= ~INST_PRE_REP;
			}
			/* Mark to verify the operand-size prefix of the fetched instruction below. */
			checkOpSize = TRUE;
		break;
	}

	/* Fetch the inst-info from the index. */
	ii = inst_get_info(in, index);

	if (checkOpSize) {
		/* If the instruction doesn't support operand size prefix, then it's illegal. */
		if ((ii == NULL) || (~INST_INFO_FLAGS(ii) & INST_PRE_OP_SIZE)) return NULL;
	}

	/* If there was a prefix, but the instruction wasn't found. Try to fall back to use the normal instruction. */
	if (ii == NULL) ii = inst_get_info(in, 0);
	return ii;
}

/* A helper function to look up special VEX instructions.
 * See if it's a MOD based instruction and fix index if required.
 * Only after a first lookup (that was done by caller), we can tell if we need to fix the index.
 * Because these are coupled instructions
 * (which means that the base instruction hints about the other instruction).
 * Note that caller should check if it's a MOD dependent instruction before getting in here.
 */
static _InstInfo* inst_vex_mod_lookup(_CodeInfo* ci, _InstNode in, _InstInfo* ii, unsigned int index)
{
	/* Advance to read the MOD from ModRM byte. */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	if (*ci->code < INST_DIVIDED_MODRM) {
		/* MOD is not 11, therefore change the index to 8 - 12 range in the prefixed table. */
		index += 4;
		/* Make a second lookup for this special instruction. */
		return inst_get_info(in, index);
	}
	/* Return the original one, in case we didn't find a suited instruction. */
	return ii;
}

static _InstInfo* inst_vex_lookup(_CodeInfo* ci, _PrefixState* ps)
{
	_InstNode in = 0;
	unsigned int pp = 0, start = 0;
	unsigned int index = 4; /* VEX instructions start at index 4 in the Prefixed table. */
	uint8_t vex = *ps->vexPos, vex2 = 0, v = 0;
	int instType = 0, instIndex = 0;

	/* The VEX instruction will #ud if any of 66, f0, f2, f3, REX prefixes precede. */
	_iflags illegal = (INST_PRE_OP_SIZE | INST_PRE_LOCK | INST_PRE_REP | INST_PRE_REPNZ | INST_PRE_REX);
	if ((ps->decodedPrefixes & illegal) != 0) return NULL;

	/* Read the some fields from the VEX prefix we need to extract the instruction. */
	if (ps->prefixExtType == PET_VEX2BYTES) {
		ps->vexV = v = (~vex >> 3) & 0xf;
		pp = vex & 3;
		/* Implied leading 0x0f byte by default for 2 bytes VEX prefix. */
		start = 1;
	}
	else { /* PET_VEX3BYTES */
		start = vex & 0x1f;
		vex2 = *(ps->vexPos + 1);
		ps->vexV = v = (~vex2 >> 3) & 0xf;
		pp = vex2 & 3;
	}

	/* start can be either 1 (0x0f), 2 (0x0f, 0x038) or 3 (0x0f, 0x3a), otherwise it's illegal. */
	switch (start)
	{
		case 1: in = Table_0F; break;
		case 2: in = Table_0F_38; break;
		case 3: in = Table_0F_3A; break;
		default: return NULL;
	}

	/* pp is actually the implied mandatory prefix, apply it to the index. */
	index += pp; /* (None, 0x66, 0xf3, 0xf2) */

	/* Read a byte from the stream. */
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;

	in = InstructionsTree[INST_NODE_INDEX(in) + *ci->code];
	if (in == INT_NOTEXISTS) return NULL;

	instType = INST_NODE_TYPE(in);
	instIndex = INST_NODE_INDEX(in);

	/*
	 * If we started with 0f38 or 0f3a so it's a prefixed table,
	 * therefore it's surely a VEXed instruction (because of a high index).
	 * However, starting with 0f, could also lead immediately to a prefixed table for some bytes.
	 * it might return NULL, if the index is invalid.
	 */
	if (instType == INT_LIST_PREFIXED) {
		_InstInfo* ii = inst_get_info(in, index);
		/* See if the instruction is dependent on MOD. */
		if ((ii != NULL) && (((_InstInfoEx*)ii)->flagsEx & INST_MODRR_BASED)) {
			ii = inst_vex_mod_lookup(ci, in, ii, index);
		}
		return ii;
	}

	/*
	 * If we reached here, obviously we started with 0f. VEXed instructions must be nodes of a prefixed table.
	 * But since we found an instruction (or divided one), just return NULL.
	 * They cannot lead to a VEXed instruction.
	 */
	if ((instType == INT_INFO) || (instType == INT_INFOEX) || (instType == INT_LIST_DIVIDED)) return NULL;

	/* Now we are left with handling either GROUP or FULL tables, therefore we will read another byte from the stream. */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;

	if (instType == INT_LIST_GROUP) {
		in = InstructionsTree[instIndex + ((*ci->code >> 3) & 7)];
		/* Continue below to check prefixed table. */
	}
	else if (instType == INT_LIST_FULL) {
		in = InstructionsTree[instIndex + *ci->code];
		/* Continue below to check prefixed table. */
	}

	/* Now that we got to the last table in the trie, check for a prefixed table. */
	if (INST_NODE_TYPE(in) == INT_LIST_PREFIXED) {
		_InstInfo* ii = inst_get_info(in, index);
		/* See if the instruction is dependent on MOD. */
		if ((ii != NULL) && (((_InstInfoEx*)ii)->flagsEx & INST_MODRR_BASED)) {
			ii = inst_vex_mod_lookup(ci, in, ii, index);
		}
		return ii;
	}

	/* No VEXed instruction was found. */
	return NULL;
}

_InstInfo* inst_lookup(_CodeInfo* ci, _PrefixState* ps, int* isPrefixed)
{
	unsigned int tmpIndex0, tmpIndex1, tmpIndex2;
	int instType;
	_InstNode in;
	_InstInfo* ii = NULL;
	int isWaitIncluded = FALSE;

	/* Always safe to read first byte codeLen > 0. */
	tmpIndex0 = *ci->code;

	if (prefixes_is_valid((unsigned char)tmpIndex0, ci->dt)) {
		*isPrefixed = TRUE;
		prefixes_decode(ci, ps);
		if (ci->codeLen < 1) return NULL; /* No more bytes for opcode, halt. */
		tmpIndex0 = *ci->code; /* Reload. */

		/* If there are too many prefixes, it will be checked later in decode_inst. */

		/* See whether we have to handle a VEX prefixed instruction. */
		if (ps->decodedPrefixes & INST_PRE_VEX) {
			ii = inst_vex_lookup(ci, ps);
			if (ii != NULL) {
				/* Make sure that VEX.L exists when forced. */
				if ((((_InstInfoEx*)ii)->flagsEx & INST_FORCE_VEXL) && (~ps->vrex & PREFIX_EX_L)) return NULL;
				/* If the instruction doesn't use VEX.vvvv it must be zero. */
				if ((((_InstInfoEx*)ii)->flagsEx & INST_VEX_V_UNUSED) && ps->vexV) return NULL;
			}
			return ii;
		}
	}

	/* Account first byte, we know it's safe to read. */
	ci->codeLen -= 1;

	/* Check for special 0x9b, WAIT instruction, which can be part of some instructions(x87). */
	if (tmpIndex0 == INST_WAIT_INDEX) {
		/* Only OCST_1dBYTES get a chance to include this byte as part of the opcode. */
		isWaitIncluded = TRUE;

		/* Ignore all prefixes, since they are useless and operate on the WAIT instruction itself. */
		prefixes_ignore_all(ps);

		/* Move to next code byte as a new whole instruction. */
		ci->code += 1;
		ci->codeLen -= 1;
		if (ci->codeLen < 0) return NULL; /* Faster to return NULL, it will be detected as WAIT later anyway. */
		/* Since we got a WAIT prefix, we re-read the first byte. */
		tmpIndex0 = *ci->code;
	}

	/* Walk first byte in InstructionsTree root. */
	in = InstructionsTree[tmpIndex0];
	if ((uint32_t)in == INT_NOTEXISTS) return NULL;
	instType = INST_NODE_TYPE(in);

	/* Single byte instruction (OCST_1BYTE). */
	if ((instType < INT_INFOS) && (!isWaitIncluded)) {
		/* Some single byte instructions need extra treatment. */
		if (instType == INT_INFO_TREAT) {
			if (tmpIndex0 == INST_NOP_INDEX) { /* Nopnopnop */
				/* Check for Pause, since it's prefixed with 0xf3, which is not a real mandatory prefix. */
				if (ps->decodedPrefixes & INST_PRE_REP) {
					/* Flag this prefix as used. */
					ps->usedPrefixes |= INST_PRE_REP;
					return &II_PAUSE;
				}

				/*
				 * Treat NOP/XCHG specially.
				 * If we're not in 64bits restore XCHG to NOP, since in the DB it's XCHG.
				 * Else if we're in 64bits examine REX, if exists, and decide which instruction should go to output.
				 * 48 90 XCHG RAX, RAX is a true NOP (eat REX in this case because it's valid).
				 * 90 XCHG EAX, EAX is a true NOP (and not high dword of RAX = 0 although it should be a 32 bits operation).
				 * Note that if the REX.B is used, then the register is not RAX anymore but R8, which means it's not a NOP.
				 */
				if (ps->vrex & PREFIX_EX_W) ps->usedPrefixes |= INST_PRE_REX;
				if ((ci->dt != Decode64Bits) || (~ps->vrex & PREFIX_EX_B)) return &II_NOP;
			}
			else if (tmpIndex0 == INST_LEA_INDEX) {
				/* Ignore segment override prefixes for LEA instruction. */
				ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
				/* Update unused mask for ignoring segment prefix. */
				prefixes_ignore(ps, PFXIDX_SEG);
			}
			else if (tmpIndex0 == INST_ARPL_INDEX) {
					/*
					 * ARPL/MOVSXD share the same opcode, and both have different operands and mnemonics, of course.
					 * Practically, I couldn't come up with a comfortable way to merge the operands' types of ARPL/MOVSXD.
					 * And since the DB can't be patched dynamically, because the DB has to be multi-threaded compliant,
					 * I have no choice but to check for ARPL/MOVSXD right here - "right about now, the funk soul brother, check it out now, the funk soul brother...", fatboy slim
					 */
					if (ci->dt == Decode64Bits) {
						return &II_MOVSXD;
					} /* else ARPL will be returned because its defined in the DB already. */
			}
		}
		/*
		 * Return the 1 byte instruction we found.
		 * We can have three node types here: infoex, info_treat and info.
		 * The latter two are really the same basic structure.
		 */
		return instType == INT_INFOEX ? (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)] : &InstInfos[INST_NODE_INDEX(in)];
	}

	/* Read second byte, still doesn't mean all of its bits are used (I.E: ModRM). */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	tmpIndex1 = *ci->code;

	/* Try single byte instruction + reg bits (OCST_13BYTES). */
	if ((instType == INT_LIST_GROUP) && (!isWaitIncluded)) return inst_get_info(in, (tmpIndex1 >> 3) & 7);

	/* Try single byte instruction + reg byte OR one whole byte (OCST_1dBYTES). */
	if (instType == INT_LIST_DIVIDED) {

		/* Checking for inst by REG bits is higher priority if it's found not to be divided instruction. */
		{
			_InstNode in2 = InstructionsTree[INST_NODE_INDEX(in) + ((tmpIndex1 >> 3) & 7)];
			/*
			 * Do NOT check for NULL here, since we do a bit of a guess work,
			 * hence we don't override 'in', cause we might still need it.
			 */
			instType = INST_NODE_TYPE(in2);

			if (instType == INT_INFO) ii = &InstInfos[INST_NODE_INDEX(in2)];
			else if (instType == INT_INFOEX) ii = (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in2)];
			if ((ii != NULL) && (INST_INFO_FLAGS(ii) & INST_NOT_DIVIDED)) return ii;
			/* ii is reset below. */
		}

		/* Continue normally because of wait prefix. */
		if (tmpIndex1 < INST_DIVIDED_MODRM) {
			/* An instruction which requires a ModR/M byte. Thus it's 1.3 bytes long instruction. */
			tmpIndex1 = (tmpIndex1 >> 3) & 7; /* Isolate the 3 REG/OPCODE bits. */
		}
		else { /* Normal 2 bytes instruction. */
		 /*
		  * Divided instructions can't be in the range of 0x8-0xc0.
		  * That's because 0-8 are used for 3 bits group.
		  * And 0xc0-0xff are used for not-divided instruction.
		  * So the in between range is omitted, thus saving some more place in the tables.
		  */
			tmpIndex1 -= INST_DIVIDED_MODRM - 8;
		}

		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex1];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS) {
			/* If the instruction doesn't support the wait (marked as opsize) as part of the opcode, it's illegal. */
			ii = instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];
			if ((~INST_INFO_FLAGS(ii) & INST_PRE_OP_SIZE) && (isWaitIncluded)) return NULL;
			return ii;
		}
		/*
		 * If we got here the instruction can support the wait prefix, so see if it was part of the stream.
		 * Examine prefixed table, specially used for 0x9b, since it's optional.
		 * No Wait: index = 0.
		 * Wait Exists, index = 1.
		 */
		return inst_get_info(in, isWaitIncluded);
	}

	/* Don't allow to continue if WAIT is part of the opcode, because there are no instructions that include it. */
	if (isWaitIncluded) return NULL;

	/* Try 2 bytes long instruction (doesn't include ModRM byte). */
	if (instType == INT_LIST_FULL) {
		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex1];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		/* This is where we check if we just read two escape bytes in a row, which means it is a 3DNow! instruction. */
		if ((tmpIndex0 == _3DNOW_ESCAPE_BYTE) && (tmpIndex1 == _3DNOW_ESCAPE_BYTE)) return &II_3DNOW;

		/* 2 bytes instruction (OCST_2BYTES). */
		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		/*
		 * 2 bytes + mandatory prefix.
		 * Mandatory prefixes can be anywhere in the prefixes.
		 * There cannot be more than one mandatory prefix, unless it's a normal operand size prefix.
		 */
		if (instType == INT_LIST_PREFIXED) return inst_lookup_prefixed(in, ps);
	}

	/* Read third byte, still doesn't mean all of its bits are used (I.E: ModRM). */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	tmpIndex2 = *ci->code;

	/* Try 2 bytes + reg instruction (OCST_23BYTES). */
	if (instType == INT_LIST_GROUP) {
		in = InstructionsTree[INST_NODE_INDEX(in) + ((tmpIndex2 >> 3) & 7)];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		/* It has to be a prefixed table then. */
		ii = inst_lookup_prefixed(in, ps);
		/* RDRAND and VMPTRLD share same 2.3 bytes opcode, and alternate on the MOD bits. See insts.h for more info. */
		if ((ii != NULL) && (ii->opcodeId == I_VMPTRLD) && (tmpIndex1 >= INST_DIVIDED_MODRM)) return &II_RDRAND;
		return ii;
	}

	/* Try 2 bytes + divided range (OCST_2dBYTES). */
	if (instType == INT_LIST_DIVIDED) {
		_InstNode in2 = InstructionsTree[INST_NODE_INDEX(in) + ((tmpIndex2 >> 3) & 7)];
		/*
		 * Do NOT check for NULL here, since we do a bit of a guess work,
		 * hence we don't override 'in', cause we might still need it.
		 */
		instType = INST_NODE_TYPE(in2);

		if (instType == INT_INFO) ii = &InstInfos[INST_NODE_INDEX(in2)];
		else if (instType == INT_INFOEX) ii = (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in2)];

		/*
		 * OCST_2dBYTES is complex, because there are a few instructions which are not divided in some special cases.
		 * If the instruction wasn't divided (but still it must be a 2.3 because we are in divided category)
		 * or it was an official 2.3 (because its index was less than 0xc0) -
		 * Then it means the instruction should be using the REG bits, otherwise give a chance to range 0xc0-0xff.
		 */
		 /* If we found an instruction only by its REG bits, AND it is not divided, then return it. */
		if ((ii != NULL) && (INST_INFO_FLAGS(ii) & INST_NOT_DIVIDED)) return ii;
		/* Otherwise, if the range is above 0xc0, try the special divided range (range 0x8-0xc0 is omitted). */
		if (tmpIndex2 >= INST_DIVIDED_MODRM) return inst_get_info(in, tmpIndex2 - INST_DIVIDED_MODRM + 8);

		/* It might be that we got here without touching ii in the above if statements, then it becomes an invalid instruction prolly. */
		return ii;
	}

	/* Try 3 full bytes (OCST_3BYTES - no ModRM byte). */
	if (instType == INT_LIST_FULL) {
		/* OCST_3BYTES. */
		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex2];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		if (instType == INT_LIST_PREFIXED) return inst_lookup_prefixed(in, ps);
	}

	/* Kahtchinggg, damn. */
	return NULL;
}

/*
* 3DNow! instruction handling:

* This is used when we encounter a 3DNow! instruction.
* We can't really locate a 3DNow! instruction before we see two escaped bytes,
* 0x0f, 0x0f. Then we have to extract operands which are, dest=mmx register, src=mmx register or quadword indirection.
* When we are finished with the extraction of operands we can resume to locate the instruction by reading another byte
* which tells us which 3DNow instruction we really tracked down...
* So in order to tell the extract operands function which operands the 3DNow! instruction require, we need to set up some
* generic instruction info for 3DNow! instructions.

* In the inst_lookup itself, when we read an OCST_3BYTES which the two first bytes are 0x0f and 0x0f.
* we will return this special generic II for the specific operands we are interested in (MM, MM64).
* Then after extracting the operand, we'll call a completion routine for locating the instruction
* which will be called only for 3DNow! instructions, distinguished by a flag, and it will read the last byte of the 3 bytes.
*
* The id of this opcode should not be used, the following function should change it anyway.
*/
_InstInfo* inst_lookup_3dnow(_CodeInfo* ci)
{
	/* Start off from the two escape bytes gates... which is 3DNow! table.*/
	_InstNode in = Table_0F_0F;

	int index;

	/* Make sure we can read a byte off the stream. */
	if (ci->codeLen < 1) return NULL;

	index = *ci->code;

	ci->codeLen -= 1;
	ci->code += 1;
	return inst_get_info(in, index);
}

```

`DumpVAC/distorm/src/instructions.h`:

```h
/*
instructions.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef INSTRUCTIONS_H
#define INSTRUCTIONS_H

#include "config.h"
#include "prefix.h"


/*
 * Operand type possibilities:
 * Note "_FULL" suffix indicates to decode the operand as 16 bits or 32 bits depends on DecodeType -
 * actually, it depends on the decoding mode, unless there's an operand/address size prefix.
 * For example, the code: 33 c0 could be decoded/executed as XOR AX, AX or XOR EAX, EAX.
 */

typedef enum OpType {
	/* No operand is set */
	OT_NONE = 0,

	/* Read a byte(8 bits) immediate */
	OT_IMM8,
	/* Force a read of a word(16 bits) immediate, used by ret only */
	OT_IMM16,
	/* Read a word/dword immediate */
	OT_IMM_FULL,
	/* Read a double-word(32 bits) immediate */
	OT_IMM32,

	/* Read a signed extended byte(8 bits) immediate */
	OT_SEIMM8,

	/* Use a 8bit register */
	OT_REG8,
	/* Use a 16bit register */
	OT_REG16,
	/* Use a 16/32/64bit register */
	OT_REG_FULL,
	/* Use a 32bit register */
	OT_REG32,
	/*
	 * If used with REX the reg operand size becomes 64 bits, otherwise 32 bits.
	 * VMX instructions are promoted automatically without a REX prefix.
	 */
	OT_REG32_64,

	/* Use AL */
	OT_ACC8,
	/* Use AX (FSTSW) */
	OT_ACC16,
	/* Use AX/EAX/RAX */
	OT_ACC_FULL,
	/* Use AX/EAX, no REX is possible for RAX, used only with IN/OUT which don't support 64 bit registers */
	OT_ACC_FULL_NOT64,

	/* Read a byte(8 bits) immediate and calculate it relatively to the current offset of the instruction being decoded */
	OT_RELCB,
	/* Read a word/dword immediate and calculate it relatively to the current offset of the instruction being decoded */
	OT_RELC_FULL,

	/*
	 * Instruction-Block for one byte long instructions, used by INC/DEC/PUSH/POP/XCHG,
	 * REG is extracted from the value of opcode
	 * Use a 8bit register
	 */
	OT_IB_RB,
	/* Use a 16/32/64bit register */
	OT_IB_R_FULL,

	/* Read an immediate as an absolute address, size is known by instruction, used by MOV (memory offset) only */
	OT_MOFFS8,
	OT_MOFFS_FULL,
	/* Use [(r)SI] as INDIRECTION, for repeatable instructions */
	OT_REGI_ESI,
	/* Use [(r)DI] as INDIRECTION, for repeatable instructions */
	OT_REGI_EDI,
	/* Use [(r)BX + AL] as INDIRECTIOM, used by XLAT only */
	OT_REGI_EBXAL,
	/* Use [(r)AX] as INDIRECTION, used by AMD's SVM instructions */
	OT_REGI_EAX,
	/* Use DX, as for OUTS DX, BYTE [SI] */
	OT_REGDX,
	/* Use ECX in INVLPGA instruction */
	OT_REGECX,

	/* FPU registers: */
	OT_FPU_SI, /* ST(i) */
	OT_FPU_SSI, /* ST(0), ST(i) */
	OT_FPU_SIS, /* ST(i), ST(0) */

	/* SSE registers: */
	OT_XMM,
	/* Extract the SSE register from the RM bits this time (used when the REG bits are used for opcode extension) */
	OT_XMM_RM,
	/* Implied XMM0 register as operand, used in SSE4. */
	OT_REGXMM0,
	/* Reg32/Reg 64 depends on prefix width only. */
	OT_WREG32_64,

	/* XMM is encoded in VEX.VVVV. */
	OT_VXMM,
	/* XMM is encoded in the high nibble of an immediate byte. */
	OT_XMM_IMM,
	/* YMM/XMM is dependent on VEX.L. */
	OT_YXMM,
	/* YMM/XMM (depends on prefix length) is encoded in the high nibble of an immediate byte. */
	OT_YXMM_IMM,
	/* YMM is encoded in reg. */
	OT_YMM,
	/* YMM is encoded in VEX.VVVV. */
	OT_VYMM,
	/* YMM/XMM is dependent on VEX.L, and encoded in VEX.VVVV. */
	OT_VYXMM,

	/* Use an immediate of 1, as for SHR R/M, 1 */
	OT_CONST1,
	/* Use CL, as for SHR R/M, CL */
	OT_REGCL,

	/* Use a control register */
	OT_CREG,
	/* Use a debug register */
	OT_DREG,
	/* Use a segment register */
	OT_SREG,
	/*
	 * SEG is encoded in the flags of the opcode itself!
	 * This is used for specific "push SS" where SS is a segment where
	 * each "push SS" has an absolutely different opcode byte.
	 * We need this to detect whether an operand size prefix is used.
	 */
	OT_SEG,

	/*
	 * Special immediates for instructions which have more than one immediate,
	 * which is an exception from standard instruction format.
	 * As to version v1.0: ENTER, INSERTQ, EXTRQ are the only problematic ones.
	 */
	 /* 16 bits immediate using the first imm-slot */
	OT_IMM16_1,
	/* 8 bits immediate using the first imm-slot */
	OT_IMM8_1,
	/* 8 bits immediate using the second imm-slot */
	OT_IMM8_2,

	/* Read one word (seg) and a word/dword/qword (depends on operand size), usually SEG:OFF, JMP 1234:1234 */
	OT_PTR16_FULL,

	/* Used only by MOV CR/DR(n). Promoted with REX onlly. */
	OT_FREG32_64_RM,

	/* MMX registers: */
	OT_MM,
	/* Extract the MMX register from the RM bits this time (used when the REG bits are used for opcode extension) */
	OT_MM_RM,


	/**** MEMORY only operands: ****/

	/* Use general memory indirection, with varying sizes: */
	OT_MEM,
	OT_MEM32,
	/* Memory dereference for MOVNTI, either 32 or 64 bits (with REX). */
	OT_MEM32_64,
	OT_MEM64,
	/* Used for cmpxchg8b/16b. */
	OT_MEM64_128,
	OT_MEM128,
	/*
	 * Read one word (seg), and a word/dword/qword (depends on operand size) from memory.
	 * JMP FAR [EBX] means EBX point to 16:32 ptr.
	 */
	OT_MEM16_FULL,
	/* Read one word (limit) and a dword/qword (limit) (depends on operand size), used by SGDT, SIDT, LGDT, LIDT. */
	OT_MEM16_3264,
	/* Used when a memory indirection is required, but if the mod field is 11, this operand will be ignored. */
	OT_MEM_OPT,

	/* Same as OT_RMXX but POINTS to 16 bits [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM16,
	/* Same as OT_RMXX but POINTS to 32 bits (single precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM32,
	/* Same as OT_RMXX but POINTS to 64 bits (double precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM64,
	/* Same as OT_RMXX but POINTS to 80 bits (extended precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM80,

	/* Mem128/Mem256 is dependent on VEX.L. */
	OT_LMEM128_256,


	/**** MEMORY & REGISTER only operands: ****/

	/* Use or read (indirection) a 8bit register or immediate byte */
	OT_RM8,
	/* Some instructions force 16 bits (mov sreg, rm16) */
	OT_RM16,
	/* ModR/M for 32 bits. */
	OT_RM32,
	/*
	 * Special operand type for MOV reg16/32/64/mem16, segReg 8C /r. and SMSW.
	 * It supports all decoding modes, but if used as a memory indirection it's a 16 bit ModR/M indirection.
	 */
	OT_RFULL_M16,
	/* Use or read a 16/32/64bit register or immediate word/dword/qword */
	OT_RM_FULL,

	/* RM32/RM64 depends on prefix width only. */
	OT_WRM32_64,
	/*
	 * Special type for SSE4, ModR/M might be a 32 bits or 64 bits (with REX) register or
	 * a 8 bits memory indirection operand.
	 */
	OT_R32_64_M8,
	/*
	 * Special type for SSE4, ModR/M might be a 32 bits or 64 bits (with REX) register or
	 * a 16 bits memory indirection operand.
	 */
	OT_R32_64_M16,

	/*
	 * 32 or 64 bits (with REX) operand size indirection memory operand.
	 * Some instructions are promoted automatically without a REX prefix.
	 */
	OT_RM32_64,
	/* 16 or 32 bits RM. This is used only with MOVZXD instruction in 64bits. */
	OT_RM16_32,

	/*
	 * Special operand type for SSE4 where the ModR/M might
	 * be a 32 bits register or 8 bits memory indirection operand.
	 */
	OT_R32_M8,
	/*
	 * Special ModR/M for PINSRW, which need a 16 bits memory operand or 32 bits register.
	 * In 16 bits decoding mode R32 becomes R16, operand size cannot affect this.
	 */
	OT_R32_M16,
	/* Reg32/Reg64 (prefix width) or Mem8. */
	OT_REG32_64_M8,
	/* Reg32/Reg64 (prefix width) or Mem16. */
	OT_REG32_64_M16,

	/* ModR/M points to 32 bits MMX variable */
	OT_MM32,
	/* ModR/M points to 32 bits MMX variable */
	OT_MM64,

	/* ModR/M points to 16 bits SSE variable */
	OT_XMM16,
	/* ModR/M points to 32 bits SSE variable */
	OT_XMM32,
	/* ModR/M points to 64 bits SSE variable */
	OT_XMM64,
	/* ModR/M points to 128 bits SSE variable */
	OT_XMM128,

	/* AVX operands: */
	/* XMM or Mem32/Mem64 depends on perfix width only. */
	OT_WXMM32_64,
	/* YMM or Mem256. */
	OT_YMM256,
	/* YMM/XMM or Mem64/Mem256 is dependent on VEX.L. */
	OT_YXMM64_256,
	/* YMM/XMM or Mem128/Mem256 is dependent on VEX.L. */
	OT_YXMM128_256,
	/* XMM or Mem64/Mem256 is dependent on VEX.L. */
	OT_LXMM64_128
} _OpType;

/* Flags for instruction: */

/* Empty flags indicator: */
#define INST_FLAGS_NONE (0)
/* The instruction we are going to decode requires ModR/M encoding. */
#define INST_MODRM_REQUIRED (1)
/* Special treatment for instructions which are in the divided-category but still needs the whole byte for ModR/M... */
#define INST_NOT_DIVIDED (1 << 1)
/*
 * Used explicitly in repeatable instructions,
 * which needs a suffix letter in their mnemonic to specify operation-size (depend on operands).
 */
#define INST_16BITS (1 << 2)
/* If the opcode is supported by 80286 and upper models (16/32 bits). */
#define INST_32BITS (1 << 3)
/*
 * Prefix flags (6 types: lock/rep, seg override, addr-size, oper-size, REX, VEX)
 * There are several specific instructions that can follow LOCK prefix,
 * note that they must be using a memory operand form, otherwise they generate an exception.
 */
#define INST_PRE_LOCK (1 << 4)
/* REPNZ prefix for string instructions only - means an instruction can follow it. */
#define INST_PRE_REPNZ (1 << 5)
/* REP prefix for string instructions only - means an instruction can follow it. */
#define INST_PRE_REP (1 << 6)
/* CS override prefix. */
#define INST_PRE_CS (1 << 7)
/* SS override prefix. */
#define INST_PRE_SS (1 << 8)
/* DS override prefix. */
#define INST_PRE_DS (1 << 9)
/* ES override prefix. */
#define INST_PRE_ES (1 << 10)
/* FS override prefix. Funky Segment :) */
#define INST_PRE_FS (1 << 11)
/* GS override prefix. Groovy Segment, of course not, duh ! */
#define INST_PRE_GS (1 << 12)
/* Switch operand size from 32 to 16 and vice versa. */
#define INST_PRE_OP_SIZE (1 << 13)
/* Switch address size from 32 to 16 and vice versa. */
#define INST_PRE_ADDR_SIZE (1 << 14)
/* Native instructions which needs suffix letter to indicate their operation-size (and don't depend on operands). */
#define INST_NATIVE (1 << 15)
/* Use extended mnemonic, means it's an _InstInfoEx structure, which contains another mnemonic for 32 bits specifically. */
#define INST_USE_EXMNEMONIC (1 << 16)
/* Use third operand, means it's an _InstInfoEx structure, which contains another operand for special instructions. */
#define INST_USE_OP3 (1 << 17)
/* Use fourth operand, means it's an _InstInfoEx structure, which contains another operand for special instructions. */
#define INST_USE_OP4 (1 << 18)
/* The instruction's mnemonic depends on the mod value of the ModR/M byte (mod=11, mod!=11). */
#define INST_MNEMONIC_MODRM_BASED (1 << 19)
/* The instruction uses a ModR/M byte which the MOD must be 11 (for registers operands only). */
#define INST_MODRR_REQUIRED (1 << 20)
/* The way of 3DNow! instructions are built, we have to handle their locating specially. Suffix imm8 tells which instruction it is. */
#define INST_3DNOW_FETCH (1 << 21)
/* The instruction needs two suffixes, one for the comparison type (imm8) and the second for its operation size indication (second mnemonic). */
#define INST_PSEUDO_OPCODE (1 << 22)
/* Invalid instruction at 64 bits decoding mode. */
#define INST_INVALID_64BITS (1 << 23)
/* Specific instruction can be promoted to 64 bits (without REX, it is promoted automatically). */
#define INST_64BITS (1 << 24)
/* Indicates the instruction must be REX prefixed in order to use 64 bits operands. */
#define INST_PRE_REX (1 << 25)
/* Third mnemonic is set. */
#define INST_USE_EXMNEMONIC2 (1 << 26)
/* Instruction is only valid in 64 bits decoding mode. */
#define INST_64BITS_FETCH (1 << 27)
/* Forces that the ModRM-REG/Opcode field will be 0. (For EXTRQ). */
#define INST_FORCE_REG0 (1 << 28)
/* Indicates that instruction is encoded with a VEX prefix. */
#define INST_PRE_VEX (1 << 29)
/* Indicates that the instruction is encoded with a ModRM byte (REG field specifically). */
#define INST_MODRM_INCLUDED (1 << 30)
/* Indicates that the first (/destination) operand of the instruction is writable. */
#define INST_DST_WR (1 << 31)

#define INST_PRE_REPS (INST_PRE_REPNZ | INST_PRE_REP)
#define INST_PRE_LOKREP_MASK (INST_PRE_LOCK | INST_PRE_REPNZ | INST_PRE_REP)
#define INST_PRE_SEGOVRD_MASK32 (INST_PRE_CS | INST_PRE_SS | INST_PRE_DS | INST_PRE_ES)
#define INST_PRE_SEGOVRD_MASK64 (INST_PRE_FS | INST_PRE_GS)
#define INST_PRE_SEGOVRD_MASK (INST_PRE_SEGOVRD_MASK32 | INST_PRE_SEGOVRD_MASK64)

/* Extended flags for VEX: */
/* Indicates that the instruction might have VEX.L encoded. */
#define INST_VEX_L (1)
/* Indicates that the instruction might have VEX.W encoded. */
#define INST_VEX_W (1 << 1)
/* Indicates that the mnemonic of the instruction is based on the VEX.W bit. */
#define INST_MNEMONIC_VEXW_BASED (1 << 2)
/* Indicates that the mnemonic of the instruction is based on the VEX.L bit. */
#define INST_MNEMONIC_VEXL_BASED (1 << 3)
/* Forces the instruction to be encoded with VEX.L, otherwise it's undefined. */
#define INST_FORCE_VEXL (1 << 4)
/*
 * Indicates that the instruction is based on the MOD field of the ModRM byte.
 * (MOD==11: got the right instruction, else skip +4 in prefixed table for the correct instruction).
 */
#define INST_MODRR_BASED (1 << 5)
/* Indicates that the instruction doesn't use the VVVV field of the VEX prefix, if it does then it's undecodable. */
#define INST_VEX_V_UNUSED (1 << 6)

/* Indication that the instruction is privileged (Ring 0), this should be checked on the opcodeId field. */
#define META_INST_PRIVILEGED ((uint16_t)0x8000)

/*
 * Indicates which operand is being decoded.
 * Destination (1st), Source (2nd), op3 (3rd), op4 (4th).
 * Used to set the operands' fields in the _DInst structure!
 */
typedef enum {ONT_NONE = -1, ONT_1 = 0, ONT_2 = 1, ONT_3 = 2, ONT_4 = 3} _OperandNumberType;

/* CPU Flags that instructions modify, test or undefine, in compacted form (CF,PF,AF,ZF,SF are 1:1 map to EFLAGS). */
#define D_COMPACT_CF 1		/* Carry */
#define D_COMPACT_PF 4		/* Parity */
#define D_COMPACT_AF 0x10	/* Auxiliary */
#define D_COMPACT_ZF 0x40	/* Zero */
#define D_COMPACT_SF 0x80	/* Sign */
/* The following flags have to be translated to EFLAGS. */
#define D_COMPACT_IF 2		/* Interrupt */
#define D_COMPACT_DF 8		/* Direction */
#define D_COMPACT_OF 0x20	/* Overflow */

/* The mask of flags that are already compatible with EFLAGS. */
#define D_COMPACT_SAME_FLAGS (D_COMPACT_CF | D_COMPACT_PF | D_COMPACT_AF | D_COMPACT_ZF | D_COMPACT_SF)

/*
 * In order to save more space for storing the DB statically,
 * I came up with another level of shared info.
 * Because I saw that most of the information that instructions use repeats itself.
 *
 * Info about the instruction, source/dest types, meta and flags.
 * _InstInfo points to a table of _InstSharedInfo.
 */
typedef struct {
	uint8_t flagsIndex; /* An index into FlagsTables */
	uint8_t s, d; /* OpType. */
	/*
	 * The following are CPU flag masks that the instruction changes.
	 * The flags are compacted so 8 bits representation is enough.
	 * They will be expanded in runtime to be compatible to EFLAGS.
	 */
	uint8_t modifiedFlagsMask;
	uint8_t testedFlagsMask;
	uint8_t undefinedFlagsMask;
	uint16_t meta; /* High byte = Instruction set class | Low byte = flow control flags. */
} _InstSharedInfo;

/*
 * This structure is used for the instructions DB and NOT for the disassembled result code!
 * This is the BASE structure, there are extensions to this structure below.
 */
typedef struct {
	uint16_t sharedIndex; /* An index into the SharedInfoTable. */
	uint16_t opcodeId; /* The opcodeId is really a byte-offset into the mnemonics table. MSB is a privileged indication. */
} _InstInfo;

/*
 * There are merely few instructions which need a second mnemonic for 32 bits.
 * Or a third for 64 bits. Therefore sometimes the second mnemonic is empty but not the third.
 * In all decoding modes the first mnemonic is the default.
 * A flag will indicate it uses another mnemonic.
 *
 * There are a couple of (SSE4) instructions in the whole DB which need both op3 and 3rd mnemonic for 64bits,
 * therefore, I decided to make the extended structure contain all extra info in the same structure.
 * There are a few instructions (SHLD/SHRD/IMUL and SSE too) which use third operand (or a fourth).
 * A flag will indicate it uses a third/fourth operand.
 */
typedef struct {
	/* Base structure (doesn't get accessed directly from code). */
	_InstInfo BASE;

	/* Extended starts here. */
	uint8_t flagsEx; /* 8 bits are enough, in the future we might make it a bigger integer. */
	uint8_t op3, op4; /* OpType. */
	uint16_t opcodeId2, opcodeId3;
} _InstInfoEx;

/* Trie data structure node type: */
typedef enum {
	INT_NOTEXISTS = 0, /* Not exists. */
	INT_INFO = 1, /* It's an instruction info. */
	INT_INFOEX,
	INT_INFO_TREAT, /* Extra intervention is required by inst_lookup. */
	INT_LIST_GROUP,
	INT_LIST_FULL,
	INT_LIST_DIVIDED,
	INT_LIST_PREFIXED
} _InstNodeType;

/* Used to check instType < INT_INFOS, means we got an inst-info. Cause it has to be only one of them. */
#define INT_INFOS (INT_LIST_GROUP)

/* Instruction node is treated as { int index:13;  int type:3; } */
typedef uint16_t _InstNode;

_InstInfo* inst_lookup(_CodeInfo* ci, _PrefixState* ps, int* isPrefixed);
_InstInfo* inst_lookup_3dnow(_CodeInfo* ci);

#endif /* INSTRUCTIONS_H */


```

`DumpVAC/distorm/src/insts.c`:

```c
/*
insts.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "config.h"
#include "insts.h"
#include "instructions.h"


/*
 * GENERATED BY disOps at Fri Dec 17 10:22:38 2021
 */

_InstInfo II_MOVSXD =	/*II*/ {0x1d7, 10038};
_InstInfo II_NOP =	/*II*/ {0x53, 580};
_InstInfo II_PAUSE =	/*II*/ {0x91, 10046};
_InstInfo II_WAIT =	/*II*/ {0x53, 10053};
_InstInfo II_RDRAND =	/*II*/ {0x1d8, 10059};
_InstInfo II_3DNOW =	/*II*/ {0x1d9, 10067};

_iflags FlagsTable[101] = {
0x80000011,
0x80000000,
0x800400,
0x80800400,
0x800080,
0x800100,
0x80800100,
0x800200,
0x80800200,
0x800000,
0x1,
0x0,
0x80800000,
0x1000000,
0x81000000,
0x808000,
0x800001,
0x80020001,
0x1002000,
0x60,
0x64,
0x80000001,
0x4010000,
0x1008000,
0x80000060,
0x83000064,
0x3000064,
0x83000000,
0x3008000,
0x200,
0xc000,
0x4014000,
0x8,
0x81000009,
0x80000009,
0x1000808,
0x81000808,
0x80020009,
0x1001008,
0x81001008,
0x80000019,
0x3000009,
0x83000009,
0x83000008,
0xc0000011,
0x40000001,
0xc0800011,
0x40800001,
0xc0000019,
0xc1000001,
0xc0000001,
0xc0000003,
0x41000000,
0x40000000,
0x40000008,
0x40000009,
0x41000001,
0x43000001,
0x40000003,
0x48000000,
0x200009,
0x20000009,
0x60020009,
0x60000009,
0x80090009,
0x200b0009,
0x20020009,
0x9,
0x80100009,
0x21100009,
0x87000009,
0x20009,
0x20000008,
0x1000009,
0x10020009,
0x160009,
0x100009,
0x47000009,
0x47090009,
0x40090009,
0x80002009,
0xc0000009,
0x2001,
0x80002001,
0x410009,
0x20420009,
0x20060009,
0x120009,
0x21020009,
0xc7000019,
0x20100009,
0xc0002009,
0x40002008,
0xc0000000,
0xc0002008,
0x4020009,
0x40100009,
0x60120009,
0x41000009,
0x83000001,
0x200001
};

_InstNode Table_0F = 256;
_InstNode Table_0F_0F = 1440;
_InstNode Table_0F_38 = 1896;
_InstNode Table_0F_3A = 2152;

_InstInfo InstInfos[1248] = {
	/*II_00*/ {0x0, 11},
	/*II_01*/ {0x1, 11},
	/*II_02*/ {0x2, 11},
	/*II_03*/ {0x3, 11},
	/*II_04*/ {0x4, 11},
	/*II_05*/ {0x5, 11},
	/*II_06*/ {0x6, 16},
	/*II_07*/ {0x7, 22},
	/*II_08*/ {0x8, 27},
	/*II_09*/ {0x9, 27},
	/*II_0A*/ {0xa, 27},
	/*II_0B*/ {0xb, 27},
	/*II_0C*/ {0xc, 27},
	/*II_0D*/ {0xd, 27},
	/*II_0E*/ {0xe, 16},
	/*II_10*/ {0xf, 31},
	/*II_11*/ {0x10, 31},
	/*II_12*/ {0x11, 31},
	/*II_13*/ {0x12, 31},
	/*II_14*/ {0x13, 31},
	/*II_15*/ {0x14, 31},
	/*II_16*/ {0x15, 16},
	/*II_17*/ {0x16, 22},
	/*II_18*/ {0xf, 36},
	/*II_19*/ {0x10, 36},
	/*II_1A*/ {0x11, 36},
	/*II_1B*/ {0x12, 36},
	/*II_1C*/ {0x13, 36},
	/*II_1D*/ {0x14, 36},
	/*II_1E*/ {0x17, 16},
	/*II_1F*/ {0x18, 22},
	/*II_20*/ {0x19, 41},
	/*II_21*/ {0x1a, 41},
	/*II_22*/ {0x1b, 41},
	/*II_23*/ {0x1c, 41},
	/*II_24*/ {0x1d, 41},
	/*II_25*/ {0x1e, 41},
	/*II_27*/ {0x1f, 46},
	/*II_28*/ {0x0, 51},
	/*II_29*/ {0x1, 51},
	/*II_2A*/ {0x2, 51},
	/*II_2B*/ {0x3, 51},
	/*II_2C*/ {0x4, 51},
	/*II_2D*/ {0x5, 51},
	/*II_2F*/ {0x1f, 56},
	/*II_30*/ {0x20, 61},
	/*II_31*/ {0x21, 61},
	/*II_32*/ {0x22, 61},
	/*II_33*/ {0x23, 61},
	/*II_34*/ {0x24, 61},
	/*II_35*/ {0x25, 61},
	/*II_37*/ {0x26, 66},
	/*II_38*/ {0x27, 71},
	/*II_39*/ {0x28, 71},
	/*II_3A*/ {0x29, 71},
	/*II_3B*/ {0x2a, 71},
	/*II_3C*/ {0x2b, 71},
	/*II_3D*/ {0x2c, 71},
	/*II_3F*/ {0x26, 76},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_60*/ {0x30, 91},
	/*II_61*/ {0x30, 98},
	/*II_62*/ {0x31, 104},
	/*II_63*/ {0x32, 111},
	/*II_68*/ {0x33, 16},
	/*II_6A*/ {0x35, 16},
	/*II_6C*/ {0x36, 123},
	/*II_6D*/ {0x37, 123},
	/*II_6E*/ {0x38, 128},
	/*II_6F*/ {0x39, 128},
	/*II_70*/ {0x3a, 134},
	/*II_71*/ {0x3a, 138},
	/*II_72*/ {0x3b, 143},
	/*II_73*/ {0x3b, 147},
	/*II_74*/ {0x3c, 152},
	/*II_75*/ {0x3c, 156},
	/*II_76*/ {0x3d, 161},
	/*II_77*/ {0x3d, 166},
	/*II_78*/ {0x3e, 170},
	/*II_79*/ {0x3e, 174},
	/*II_7A*/ {0x3f, 179},
	/*II_7B*/ {0x3f, 183},
	/*II_7C*/ {0x40, 188},
	/*II_7D*/ {0x40, 192},
	/*II_7E*/ {0x41, 197},
	/*II_7F*/ {0x41, 202},
	/*II_84*/ {0x42, 206},
	/*II_85*/ {0x43, 206},
	/*II_86*/ {0x44, 212},
	/*II_87*/ {0x45, 212},
	/*II_88*/ {0x46, 218},
	/*II_89*/ {0x47, 218},
	/*II_8A*/ {0x48, 218},
	/*II_8B*/ {0x49, 218},
	/*II_8C*/ {0x4a, 218},
	/*II_8D*/ {0x4b, 223},
	/*II_8E*/ {0x4c, 218},
	/*II_90*/ {0x4d, 212},
	/*II_91*/ {0x4d, 212},
	/*II_92*/ {0x4d, 212},
	/*II_93*/ {0x4d, 212},
	/*II_94*/ {0x4d, 212},
	/*II_95*/ {0x4d, 212},
	/*II_96*/ {0x4d, 212},
	/*II_97*/ {0x4d, 212},
	/*II_9A*/ {0x4f, 260},
	/*II_9C*/ {0x50, 270},
	/*II_9D*/ {0x51, 277},
	/*II_9E*/ {0x52, 283},
	/*II_9F*/ {0x53, 289},
	/*II_A0*/ {0x54, 218},
	/*II_A1*/ {0x55, 218},
	/*II_A2*/ {0x56, 218},
	/*II_A3*/ {0x57, 218},
	/*II_A4*/ {0x58, 295},
	/*II_A5*/ {0x59, 295},
	/*II_A6*/ {0x5a, 301},
	/*II_A7*/ {0x5b, 301},
	/*II_A8*/ {0x5c, 206},
	/*II_A9*/ {0x5d, 206},
	/*II_AA*/ {0x5e, 307},
	/*II_AB*/ {0x5f, 307},
	/*II_AC*/ {0x60, 313},
	/*II_AD*/ {0x61, 313},
	/*II_AE*/ {0x62, 319},
	/*II_AF*/ {0x63, 319},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_C2*/ {0x66, 325},
	/*II_C3*/ {0x67, 325},
	/*II_C4*/ {0x68, 330},
	/*II_C5*/ {0x68, 335},
	/*II_C8*/ {0x69, 340},
	/*II_C9*/ {0x6a, 347},
	/*II_CA*/ {0x6b, 354},
	/*II_CB*/ {0x6c, 354},
	/*II_CC*/ {0x53, 360},
	/*II_CD*/ {0x6d, 366},
	/*II_CE*/ {0x6e, 371},
	/*II_CF*/ {0x6f, 377},
	/*II_D4*/ {0x70, 383},
	/*II_D5*/ {0x70, 388},
	/*II_D6*/ {0x71, 393},
	/*II_D7*/ {0x72, 399},
	/*II_E0*/ {0x73, 405},
	/*II_E1*/ {0x73, 413},
	/*II_E2*/ {0x74, 420},
	/*II_E4*/ {0x76, 446},
	/*II_E5*/ {0x77, 446},
	/*II_E6*/ {0x78, 450},
	/*II_E7*/ {0x79, 450},
	/*II_E8*/ {0x7a, 455},
	/*II_E9*/ {0x7b, 461},
	/*II_EA*/ {0x7c, 466},
	/*II_EB*/ {0x7d, 461},
	/*II_EC*/ {0x7e, 446},
	/*II_ED*/ {0x7f, 446},
	/*II_EE*/ {0x80, 450},
	/*II_EF*/ {0x81, 450},
	/*II_F1*/ {0x82, 475},
	/*II_F4*/ {0x83, 481},
	/*II_F5*/ {0x84, 486},
	/*II_F8*/ {0x84, 491},
	/*II_F9*/ {0x84, 496},
	/*II_FA*/ {0x85, 501},
	/*II_FB*/ {0x85, 506},
	/*II_FC*/ {0x86, 511},
	/*II_FD*/ {0x86, 516},
	/*II_0F_02*/ {0x87, 521},
	/*II_0F_03*/ {0x87, 526},
	/*II_0F_05*/ {0x88, 531},
	/*II_0F_06*/ {0x89, 540},
	/*II_0F_07*/ {0x88, 546},
	/*II_0F_08*/ {0x89, 554},
	/*II_0F_09*/ {0x89, 560},
	/*II_0F_0B*/ {0x8a, 568},
	/*II_0F_0E*/ {0x8b, 573},
	/*II_0F_1F*/ {0x8c, 580},
	/*II_0F_20*/ {0x8d, 218},
	/*II_0F_21*/ {0x8e, 218},
	/*II_0F_22*/ {0x8f, 218},
	/*II_0F_23*/ {0x90, 218},
	/*II_0F_30*/ {0x89, 585},
	/*II_0F_31*/ {0x89, 592},
	/*II_0F_32*/ {0x89, 599},
	/*II_0F_33*/ {0x89, 606},
	/*II_0F_34*/ {0x88, 613},
	/*II_0F_35*/ {0x88, 623},
	/*II_0F_37*/ {0x91, 632},
	/*II_0F_40*/ {0x92, 640},
	/*II_0F_41*/ {0x92, 647},
	/*II_0F_42*/ {0x93, 655},
	/*II_0F_43*/ {0x93, 662},
	/*II_0F_44*/ {0x94, 670},
	/*II_0F_45*/ {0x94, 677},
	/*II_0F_46*/ {0x95, 685},
	/*II_0F_47*/ {0x95, 693},
	/*II_0F_48*/ {0x96, 700},
	/*II_0F_49*/ {0x96, 707},
	/*II_0F_4A*/ {0x97, 715},
	/*II_0F_4B*/ {0x97, 722},
	/*II_0F_4C*/ {0x98, 730},
	/*II_0F_4D*/ {0x98, 737},
	/*II_0F_4E*/ {0x99, 745},
	/*II_0F_4F*/ {0x99, 753},
	/*II_0F_80*/ {0x9a, 134},
	/*II_0F_81*/ {0x9a, 138},
	/*II_0F_82*/ {0x9b, 143},
	/*II_0F_83*/ {0x9b, 147},
	/*II_0F_84*/ {0x9c, 152},
	/*II_0F_85*/ {0x9c, 156},
	/*II_0F_86*/ {0x9d, 161},
	/*II_0F_87*/ {0x9d, 166},
	/*II_0F_88*/ {0x9e, 170},
	/*II_0F_89*/ {0x9e, 174},
	/*II_0F_8A*/ {0x9f, 179},
	/*II_0F_8B*/ {0x9f, 183},
	/*II_0F_8C*/ {0xa0, 188},
	/*II_0F_8D*/ {0xa0, 192},
	/*II_0F_8E*/ {0xa1, 197},
	/*II_0F_8F*/ {0xa1, 202},
	/*II_0F_90*/ {0xa2, 760},
	/*II_0F_91*/ {0xa2, 766},
	/*II_0F_92*/ {0xa3, 773},
	/*II_0F_93*/ {0xa3, 779},
	/*II_0F_94*/ {0xa4, 786},
	/*II_0F_95*/ {0xa4, 792},
	/*II_0F_96*/ {0xa5, 799},
	/*II_0F_97*/ {0xa5, 806},
	/*II_0F_98*/ {0xa6, 812},
	/*II_0F_99*/ {0xa6, 818},
	/*II_0F_9A*/ {0xa7, 825},
	/*II_0F_9B*/ {0xa7, 831},
	/*II_0F_9C*/ {0xa8, 838},
	/*II_0F_9D*/ {0xa8, 844},
	/*II_0F_9E*/ {0xa9, 851},
	/*II_0F_9F*/ {0xa9, 858},
	/*II_0F_A0*/ {0xaa, 16},
	/*II_0F_A1*/ {0xab, 22},
	/*II_0F_A2*/ {0x91, 864},
	/*II_0F_A3*/ {0xac, 871},
	/*II_0F_A8*/ {0xae, 16},
	/*II_0F_A9*/ {0xaf, 22},
	/*II_0F_AA*/ {0xb0, 881},
	/*II_0F_AB*/ {0xb1, 886},
	/*II_0F_AF*/ {0xb2, 117},
	/*II_0F_B0*/ {0xb3, 897},
	/*II_0F_B1*/ {0xb4, 897},
	/*II_0F_B2*/ {0xb5, 906},
	/*II_0F_B3*/ {0xb1, 911},
	/*II_0F_B4*/ {0xb5, 916},
	/*II_0F_B5*/ {0xb5, 921},
	/*II_0F_B6*/ {0xb6, 926},
	/*II_0F_B7*/ {0xb7, 926},
	/*II_0F_B9*/ {0x8a, 568},
	/*II_0F_BB*/ {0xb1, 933},
	/*II_0F_BE*/ {0xb6, 938},
	/*II_0F_BF*/ {0xb7, 938},
	/*II_0F_C0*/ {0xb3, 945},
	/*II_0F_C1*/ {0xb4, 945},
	/*II_0F_C3*/ {0xb8, 951},
	/*II_0F_C8*/ {0xb9, 959},
	/*II_0F_C8*/ {0xb9, 959},
	/*II_0F_C8*/ {0xb9, 959},
	/*II_0F_C8*/ {0xb9, 959},
	/*II_0F_C8*/ {0xb9, 959},
	/*II_0F_C8*/ {0xb9, 959},
	/*II_0F_C8*/ {0xb9, 959},
	/*II_0F_C8*/ {0xb9, 959},
	/*II_80_00*/ {0xba, 11},
	/*II_80_01*/ {0xbb, 27},
	/*II_80_02*/ {0xbc, 31},
	/*II_80_03*/ {0xbc, 36},
	/*II_80_04*/ {0xbd, 41},
	/*II_80_05*/ {0xba, 51},
	/*II_80_06*/ {0xbe, 61},
	/*II_80_07*/ {0xbf, 71},
	/*II_81_00*/ {0xc0, 11},
	/*II_81_01*/ {0xc1, 27},
	/*II_81_02*/ {0xc2, 31},
	/*II_81_03*/ {0xc2, 36},
	/*II_81_04*/ {0xc3, 41},
	/*II_81_05*/ {0xc0, 51},
	/*II_81_06*/ {0xc4, 61},
	/*II_81_07*/ {0xc5, 71},
	/*II_82_00*/ {0xc6, 11},
	/*II_82_01*/ {0xc7, 27},
	/*II_82_02*/ {0xc8, 31},
	/*II_82_03*/ {0xc8, 36},
	/*II_82_04*/ {0xc9, 41},
	/*II_82_05*/ {0xc6, 51},
	/*II_82_06*/ {0xca, 61},
	/*II_82_07*/ {0xcb, 71},
	/*II_83_00*/ {0xcc, 11},
	/*II_83_01*/ {0xcd, 27},
	/*II_83_02*/ {0xce, 31},
	/*II_83_03*/ {0xce, 36},
	/*II_83_04*/ {0xcf, 41},
	/*II_83_05*/ {0xcc, 51},
	/*II_83_06*/ {0xd0, 61},
	/*II_83_07*/ {0xd1, 71},
	/*II_8F_00*/ {0xd2, 22},
	/*II_C0_00*/ {0xd3, 966},
	/*II_C0_01*/ {0xd3, 971},
	/*II_C0_02*/ {0xd4, 976},
	/*II_C0_03*/ {0xd4, 981},
	/*II_C0_04*/ {0xd5, 986},
	/*II_C0_05*/ {0xd5, 991},
	/*II_C0_06*/ {0xd5, 996},
	/*II_C0_07*/ {0xd5, 1001},
	/*II_C1_00*/ {0xd6, 966},
	/*II_C1_01*/ {0xd6, 971},
	/*II_C1_02*/ {0xd7, 976},
	/*II_C1_03*/ {0xd7, 981},
	/*II_C1_04*/ {0xd8, 986},
	/*II_C1_05*/ {0xd8, 991},
	/*II_C1_06*/ {0xd8, 996},
	/*II_C1_07*/ {0xd8, 1001},
	/*II_C6_00*/ {0xd9, 218},
	/*II_C6_F8*/ {0xda, 1006},
	/*II_C7_00*/ {0xdb, 218},
	/*II_C7_F8*/ {0xdc, 1014},
	/*II_D0_00*/ {0xdd, 966},
	/*II_D0_01*/ {0xdd, 971},
	/*II_D0_02*/ {0xde, 976},
	/*II_D0_03*/ {0xde, 981},
	/*II_D0_04*/ {0xdf, 986},
	/*II_D0_05*/ {0xdf, 991},
	/*II_D0_06*/ {0xdf, 996},
	/*II_D0_07*/ {0xdf, 1001},
	/*II_D1_00*/ {0xe0, 966},
	/*II_D1_01*/ {0xe0, 971},
	/*II_D1_02*/ {0xe1, 976},
	/*II_D1_03*/ {0xe1, 981},
	/*II_D1_04*/ {0xe2, 986},
	/*II_D1_05*/ {0xe2, 991},
	/*II_D1_06*/ {0xe2, 996},
	/*II_D1_07*/ {0xe2, 1001},
	/*II_D2_00*/ {0xe3, 966},
	/*II_D2_01*/ {0xe3, 971},
	/*II_D2_02*/ {0xe4, 976},
	/*II_D2_03*/ {0xe4, 981},
	/*II_D2_04*/ {0xe5, 986},
	/*II_D2_05*/ {0xe5, 991},
	/*II_D2_06*/ {0xe5, 996},
	/*II_D2_07*/ {0xe5, 1001},
	/*II_D3_00*/ {0xe6, 966},
	/*II_D3_01*/ {0xe6, 971},
	/*II_D3_02*/ {0xe7, 976},
	/*II_D3_03*/ {0xe7, 981},
	/*II_D3_04*/ {0xe8, 986},
	/*II_D3_05*/ {0xe8, 991},
	/*II_D3_06*/ {0xe8, 996},
	/*II_D3_07*/ {0xe8, 1001},
	/*II_D8_00*/ {0xe9, 1022},
	/*II_D8_01*/ {0xe9, 1028},
	/*II_D8_02*/ {0xe9, 1034},
	/*II_D8_03*/ {0xe9, 1040},
	/*II_D8_04*/ {0xe9, 1047},
	/*II_D8_05*/ {0xe9, 1053},
	/*II_D8_06*/ {0xe9, 1060},
	/*II_D8_07*/ {0xe9, 1066},
	/*II_D8_C0*/ {0xea, 1022},
	/*II_D8_C0*/ {0xea, 1022},
	/*II_D8_C0*/ {0xea, 1022},
	/*II_D8_C0*/ {0xea, 1022},
	/*II_D8_C0*/ {0xea, 1022},
	/*II_D8_C0*/ {0xea, 1022},
	/*II_D8_C0*/ {0xea, 1022},
	/*II_D8_C0*/ {0xea, 1022},
	/*II_D8_C8*/ {0xea, 1028},
	/*II_D8_C8*/ {0xea, 1028},
	/*II_D8_C8*/ {0xea, 1028},
	/*II_D8_C8*/ {0xea, 1028},
	/*II_D8_C8*/ {0xea, 1028},
	/*II_D8_C8*/ {0xea, 1028},
	/*II_D8_C8*/ {0xea, 1028},
	/*II_D8_C8*/ {0xea, 1028},
	/*II_D8_D0*/ {0xeb, 1034},
	/*II_D8_D0*/ {0xeb, 1034},
	/*II_D8_D0*/ {0xeb, 1034},
	/*II_D8_D0*/ {0xeb, 1034},
	/*II_D8_D0*/ {0xeb, 1034},
	/*II_D8_D0*/ {0xeb, 1034},
	/*II_D8_D0*/ {0xeb, 1034},
	/*II_D8_D0*/ {0xeb, 1034},
	/*II_D8_D8*/ {0xeb, 1040},
	/*II_D8_D9*/ {0xec, 1040},
	/*II_D8_D8*/ {0xeb, 1040},
	/*II_D8_D8*/ {0xeb, 1040},
	/*II_D8_D8*/ {0xeb, 1040},
	/*II_D8_D8*/ {0xeb, 1040},
	/*II_D8_D8*/ {0xeb, 1040},
	/*II_D8_D8*/ {0xeb, 1040},
	/*II_D8_E0*/ {0xea, 1047},
	/*II_D8_E0*/ {0xea, 1047},
	/*II_D8_E0*/ {0xea, 1047},
	/*II_D8_E0*/ {0xea, 1047},
	/*II_D8_E0*/ {0xea, 1047},
	/*II_D8_E0*/ {0xea, 1047},
	/*II_D8_E0*/ {0xea, 1047},
	/*II_D8_E0*/ {0xea, 1047},
	/*II_D8_E8*/ {0xea, 1053},
	/*II_D8_E8*/ {0xea, 1053},
	/*II_D8_E8*/ {0xea, 1053},
	/*II_D8_E8*/ {0xea, 1053},
	/*II_D8_E8*/ {0xea, 1053},
	/*II_D8_E8*/ {0xea, 1053},
	/*II_D8_E8*/ {0xea, 1053},
	/*II_D8_E8*/ {0xea, 1053},
	/*II_D8_F0*/ {0xea, 1060},
	/*II_D8_F0*/ {0xea, 1060},
	/*II_D8_F0*/ {0xea, 1060},
	/*II_D8_F0*/ {0xea, 1060},
	/*II_D8_F0*/ {0xea, 1060},
	/*II_D8_F0*/ {0xea, 1060},
	/*II_D8_F0*/ {0xea, 1060},
	/*II_D8_F0*/ {0xea, 1060},
	/*II_D8_F8*/ {0xea, 1066},
	/*II_D8_F8*/ {0xea, 1066},
	/*II_D8_F8*/ {0xea, 1066},
	/*II_D8_F8*/ {0xea, 1066},
	/*II_D8_F8*/ {0xea, 1066},
	/*II_D8_F8*/ {0xea, 1066},
	/*II_D8_F8*/ {0xea, 1066},
	/*II_D8_F8*/ {0xea, 1066},
	/*II_D9_00*/ {0xe9, 1073},
	/*II_D9_02*/ {0xed, 1078},
	/*II_D9_03*/ {0xed, 1083},
	/*II_D9_04*/ {0xee, 1089},
	/*II_D9_05*/ {0xef, 1097},
	/*II_D9_C0*/ {0xeb, 1073},
	/*II_D9_C0*/ {0xeb, 1073},
	/*II_D9_C0*/ {0xeb, 1073},
	/*II_D9_C0*/ {0xeb, 1073},
	/*II_D9_C0*/ {0xeb, 1073},
	/*II_D9_C0*/ {0xeb, 1073},
	/*II_D9_C0*/ {0xeb, 1073},
	/*II_D9_C0*/ {0xeb, 1073},
	/*II_D9_C8*/ {0xeb, 1104},
	/*II_D9_C9*/ {0xec, 1104},
	/*II_D9_C8*/ {0xeb, 1104},
	/*II_D9_C8*/ {0xeb, 1104},
	/*II_D9_C8*/ {0xeb, 1104},
	/*II_D9_C8*/ {0xeb, 1104},
	/*II_D9_C8*/ {0xeb, 1104},
	/*II_D9_C8*/ {0xeb, 1104},
	/*II_D9_D0*/ {0xec, 1110},
	/*II_D9_E0*/ {0xec, 1116},
	/*II_D9_E1*/ {0xec, 1122},
	/*II_D9_E4*/ {0xec, 1128},
	/*II_D9_E5*/ {0xec, 1134},
	/*II_D9_E8*/ {0xec, 1140},
	/*II_D9_E9*/ {0xec, 1146},
	/*II_D9_EA*/ {0xec, 1154},
	/*II_D9_EB*/ {0xec, 1162},
	/*II_D9_EC*/ {0xec, 1169},
	/*II_D9_ED*/ {0xec, 1177},
	/*II_D9_EE*/ {0xec, 1185},
	/*II_D9_F0*/ {0xec, 1191},
	/*II_D9_F1*/ {0xec, 1198},
	/*II_D9_F2*/ {0xec, 1205},
	/*II_D9_F3*/ {0xec, 1212},
	/*II_D9_F4*/ {0xec, 1220},
	/*II_D9_F5*/ {0xec, 1229},
	/*II_D9_F6*/ {0xec, 1237},
	/*II_D9_F7*/ {0xec, 1246},
	/*II_D9_F8*/ {0xec, 1255},
	/*II_D9_F9*/ {0xec, 1262},
	/*II_D9_FA*/ {0xec, 1271},
	/*II_D9_FB*/ {0xec, 1278},
	/*II_D9_FC*/ {0xec, 1287},
	/*II_D9_FD*/ {0xec, 1296},
	/*II_D9_FE*/ {0xec, 1304},
	/*II_D9_FF*/ {0xec, 1310},
	/*II_DA_00*/ {0xe9, 1316},
	/*II_DA_01*/ {0xe9, 1323},
	/*II_DA_02*/ {0xe9, 1330},
	/*II_DA_03*/ {0xe9, 1337},
	/*II_DA_04*/ {0xe9, 1345},
	/*II_DA_05*/ {0xe9, 1352},
	/*II_DA_06*/ {0xe9, 1360},
	/*II_DA_07*/ {0xe9, 1367},
	/*II_DA_C0*/ {0xf0, 1375},
	/*II_DA_C0*/ {0xf0, 1375},
	/*II_DA_C0*/ {0xf0, 1375},
	/*II_DA_C0*/ {0xf0, 1375},
	/*II_DA_C0*/ {0xf0, 1375},
	/*II_DA_C0*/ {0xf0, 1375},
	/*II_DA_C0*/ {0xf0, 1375},
	/*II_DA_C0*/ {0xf0, 1375},
	/*II_DA_C8*/ {0xf1, 1383},
	/*II_DA_C8*/ {0xf1, 1383},
	/*II_DA_C8*/ {0xf1, 1383},
	/*II_DA_C8*/ {0xf1, 1383},
	/*II_DA_C8*/ {0xf1, 1383},
	/*II_DA_C8*/ {0xf1, 1383},
	/*II_DA_C8*/ {0xf1, 1383},
	/*II_DA_C8*/ {0xf1, 1383},
	/*II_DA_D0*/ {0xf2, 1391},
	/*II_DA_D0*/ {0xf2, 1391},
	/*II_DA_D0*/ {0xf2, 1391},
	/*II_DA_D0*/ {0xf2, 1391},
	/*II_DA_D0*/ {0xf2, 1391},
	/*II_DA_D0*/ {0xf2, 1391},
	/*II_DA_D0*/ {0xf2, 1391},
	/*II_DA_D0*/ {0xf2, 1391},
	/*II_DA_D8*/ {0xf3, 1400},
	/*II_DA_D8*/ {0xf3, 1400},
	/*II_DA_D8*/ {0xf3, 1400},
	/*II_DA_D8*/ {0xf3, 1400},
	/*II_DA_D8*/ {0xf3, 1400},
	/*II_DA_D8*/ {0xf3, 1400},
	/*II_DA_D8*/ {0xf3, 1400},
	/*II_DA_D8*/ {0xf3, 1400},
	/*II_DA_E9*/ {0xec, 1408},
	/*II_DB_00*/ {0xe9, 1417},
	/*II_DB_01*/ {0xf4, 1423},
	/*II_DB_02*/ {0xed, 1431},
	/*II_DB_03*/ {0xed, 1437},
	/*II_DB_05*/ {0xf5, 1073},
	/*II_DB_07*/ {0xf6, 1083},
	/*II_DB_C0*/ {0xf0, 1444},
	/*II_DB_C0*/ {0xf0, 1444},
	/*II_DB_C0*/ {0xf0, 1444},
	/*II_DB_C0*/ {0xf0, 1444},
	/*II_DB_C0*/ {0xf0, 1444},
	/*II_DB_C0*/ {0xf0, 1444},
	/*II_DB_C0*/ {0xf0, 1444},
	/*II_DB_C0*/ {0xf0, 1444},
	/*II_DB_C8*/ {0xf1, 1453},
	/*II_DB_C8*/ {0xf1, 1453},
	/*II_DB_C8*/ {0xf1, 1453},
	/*II_DB_C8*/ {0xf1, 1453},
	/*II_DB_C8*/ {0xf1, 1453},
	/*II_DB_C8*/ {0xf1, 1453},
	/*II_DB_C8*/ {0xf1, 1453},
	/*II_DB_C8*/ {0xf1, 1453},
	/*II_DB_D0*/ {0xf2, 1462},
	/*II_DB_D0*/ {0xf2, 1462},
	/*II_DB_D0*/ {0xf2, 1462},
	/*II_DB_D0*/ {0xf2, 1462},
	/*II_DB_D0*/ {0xf2, 1462},
	/*II_DB_D0*/ {0xf2, 1462},
	/*II_DB_D0*/ {0xf2, 1462},
	/*II_DB_D0*/ {0xf2, 1462},
	/*II_DB_D8*/ {0xf3, 1472},
	/*II_DB_D8*/ {0xf3, 1472},
	/*II_DB_D8*/ {0xf3, 1472},
	/*II_DB_D8*/ {0xf3, 1472},
	/*II_DB_D8*/ {0xf3, 1472},
	/*II_DB_D8*/ {0xf3, 1472},
	/*II_DB_D8*/ {0xf3, 1472},
	/*II_DB_D8*/ {0xf3, 1472},
	/*II_DB_E0*/ {0xec, 1481},
	/*II_DB_E1*/ {0xec, 1487},
	/*II_DB_E4*/ {0xec, 1495},
	/*II_DB_E8*/ {0xf7, 1503},
	/*II_DB_E8*/ {0xf7, 1503},
	/*II_DB_E8*/ {0xf7, 1503},
	/*II_DB_E8*/ {0xf7, 1503},
	/*II_DB_E8*/ {0xf7, 1503},
	/*II_DB_E8*/ {0xf7, 1503},
	/*II_DB_E8*/ {0xf7, 1503},
	/*II_DB_E8*/ {0xf7, 1503},
	/*II_DB_F0*/ {0xf8, 1511},
	/*II_DB_F0*/ {0xf8, 1511},
	/*II_DB_F0*/ {0xf8, 1511},
	/*II_DB_F0*/ {0xf8, 1511},
	/*II_DB_F0*/ {0xf8, 1511},
	/*II_DB_F0*/ {0xf8, 1511},
	/*II_DB_F0*/ {0xf8, 1511},
	/*II_DB_F0*/ {0xf8, 1511},
	/*II_DC_00*/ {0xf9, 1022},
	/*II_DC_01*/ {0xf9, 1028},
	/*II_DC_02*/ {0xf9, 1034},
	/*II_DC_03*/ {0xf9, 1040},
	/*II_DC_04*/ {0xf9, 1047},
	/*II_DC_05*/ {0xf9, 1053},
	/*II_DC_06*/ {0xf9, 1060},
	/*II_DC_07*/ {0xf9, 1066},
	/*II_DC_C0*/ {0xfa, 1022},
	/*II_DC_C0*/ {0xfa, 1022},
	/*II_DC_C0*/ {0xfa, 1022},
	/*II_DC_C0*/ {0xfa, 1022},
	/*II_DC_C0*/ {0xfa, 1022},
	/*II_DC_C0*/ {0xfa, 1022},
	/*II_DC_C0*/ {0xfa, 1022},
	/*II_DC_C0*/ {0xfa, 1022},
	/*II_DC_C8*/ {0xfa, 1028},
	/*II_DC_C8*/ {0xfa, 1028},
	/*II_DC_C8*/ {0xfa, 1028},
	/*II_DC_C8*/ {0xfa, 1028},
	/*II_DC_C8*/ {0xfa, 1028},
	/*II_DC_C8*/ {0xfa, 1028},
	/*II_DC_C8*/ {0xfa, 1028},
	/*II_DC_C8*/ {0xfa, 1028},
	/*II_DC_E0*/ {0xfa, 1053},
	/*II_DC_E0*/ {0xfa, 1053},
	/*II_DC_E0*/ {0xfa, 1053},
	/*II_DC_E0*/ {0xfa, 1053},
	/*II_DC_E0*/ {0xfa, 1053},
	/*II_DC_E0*/ {0xfa, 1053},
	/*II_DC_E0*/ {0xfa, 1053},
	/*II_DC_E0*/ {0xfa, 1053},
	/*II_DC_E8*/ {0xfa, 1047},
	/*II_DC_E8*/ {0xfa, 1047},
	/*II_DC_E8*/ {0xfa, 1047},
	/*II_DC_E8*/ {0xfa, 1047},
	/*II_DC_E8*/ {0xfa, 1047},
	/*II_DC_E8*/ {0xfa, 1047},
	/*II_DC_E8*/ {0xfa, 1047},
	/*II_DC_E8*/ {0xfa, 1047},
	/*II_DC_F0*/ {0xfa, 1066},
	/*II_DC_F0*/ {0xfa, 1066},
	/*II_DC_F0*/ {0xfa, 1066},
	/*II_DC_F0*/ {0xfa, 1066},
	/*II_DC_F0*/ {0xfa, 1066},
	/*II_DC_F0*/ {0xfa, 1066},
	/*II_DC_F0*/ {0xfa, 1066},
	/*II_DC_F0*/ {0xfa, 1066},
	/*II_DC_F8*/ {0xfa, 1060},
	/*II_DC_F8*/ {0xfa, 1060},
	/*II_DC_F8*/ {0xfa, 1060},
	/*II_DC_F8*/ {0xfa, 1060},
	/*II_DC_F8*/ {0xfa, 1060},
	/*II_DC_F8*/ {0xfa, 1060},
	/*II_DC_F8*/ {0xfa, 1060},
	/*II_DC_F8*/ {0xfa, 1060},
	/*II_DD_00*/ {0xf9, 1073},
	/*II_DD_01*/ {0xfb, 1423},
	/*II_DD_02*/ {0xfc, 1078},
	/*II_DD_03*/ {0xfc, 1083},
	/*II_DD_04*/ {0xee, 1518},
	/*II_DD_C0*/ {0xeb, 1526},
	/*II_DD_C0*/ {0xeb, 1526},
	/*II_DD_C0*/ {0xeb, 1526},
	/*II_DD_C0*/ {0xeb, 1526},
	/*II_DD_C0*/ {0xeb, 1526},
	/*II_DD_C0*/ {0xeb, 1526},
	/*II_DD_C0*/ {0xeb, 1526},
	/*II_DD_C0*/ {0xeb, 1526},
	/*II_DD_D0*/ {0xeb, 1078},
	/*II_DD_D0*/ {0xeb, 1078},
	/*II_DD_D0*/ {0xeb, 1078},
	/*II_DD_D0*/ {0xeb, 1078},
	/*II_DD_D0*/ {0xeb, 1078},
	/*II_DD_D0*/ {0xeb, 1078},
	/*II_DD_D0*/ {0xeb, 1078},
	/*II_DD_D0*/ {0xeb, 1078},
	/*II_DD_D8*/ {0xeb, 1083},
	/*II_DD_D8*/ {0xeb, 1083},
	/*II_DD_D8*/ {0xeb, 1083},
	/*II_DD_D8*/ {0xeb, 1083},
	/*II_DD_D8*/ {0xeb, 1083},
	/*II_DD_D8*/ {0xeb, 1083},
	/*II_DD_D8*/ {0xeb, 1083},
	/*II_DD_D8*/ {0xeb, 1083},
	/*II_DD_E0*/ {0xfa, 1533},
	/*II_DD_E1*/ {0xec, 1533},
	/*II_DD_E0*/ {0xfa, 1533},
	/*II_DD_E0*/ {0xfa, 1533},
	/*II_DD_E0*/ {0xfa, 1533},
	/*II_DD_E0*/ {0xfa, 1533},
	/*II_DD_E0*/ {0xfa, 1533},
	/*II_DD_E0*/ {0xfa, 1533},
	/*II_DD_E8*/ {0xeb, 1540},
	/*II_DD_E9*/ {0xec, 1540},
	/*II_DD_E8*/ {0xeb, 1540},
	/*II_DD_E8*/ {0xeb, 1540},
	/*II_DD_E8*/ {0xeb, 1540},
	/*II_DD_E8*/ {0xeb, 1540},
	/*II_DD_E8*/ {0xeb, 1540},
	/*II_DD_E8*/ {0xeb, 1540},
	/*II_DE_00*/ {0xef, 1316},
	/*II_DE_01*/ {0xef, 1323},
	/*II_DE_02*/ {0xef, 1330},
	/*II_DE_03*/ {0xef, 1337},
	/*II_DE_04*/ {0xef, 1345},
	/*II_DE_05*/ {0xef, 1352},
	/*II_DE_06*/ {0xef, 1360},
	/*II_DE_07*/ {0xef, 1367},
	/*II_DE_C0*/ {0xfa, 1548},
	/*II_DE_C1*/ {0xec, 1548},
	/*II_DE_C0*/ {0xfa, 1548},
	/*II_DE_C0*/ {0xfa, 1548},
	/*II_DE_C0*/ {0xfa, 1548},
	/*II_DE_C0*/ {0xfa, 1548},
	/*II_DE_C0*/ {0xfa, 1548},
	/*II_DE_C0*/ {0xfa, 1548},
	/*II_DE_C8*/ {0xfa, 1555},
	/*II_DE_C9*/ {0xec, 1555},
	/*II_DE_C8*/ {0xfa, 1555},
	/*II_DE_C8*/ {0xfa, 1555},
	/*II_DE_C8*/ {0xfa, 1555},
	/*II_DE_C8*/ {0xfa, 1555},
	/*II_DE_C8*/ {0xfa, 1555},
	/*II_DE_C8*/ {0xfa, 1555},
	/*II_DE_D9*/ {0xec, 1562},
	/*II_DE_E0*/ {0xfa, 1570},
	/*II_DE_E1*/ {0xec, 1570},
	/*II_DE_E0*/ {0xfa, 1570},
	/*II_DE_E0*/ {0xfa, 1570},
	/*II_DE_E0*/ {0xfa, 1570},
	/*II_DE_E0*/ {0xfa, 1570},
	/*II_DE_E0*/ {0xfa, 1570},
	/*II_DE_E0*/ {0xfa, 1570},
	/*II_DE_E8*/ {0xfa, 1578},
	/*II_DE_E9*/ {0xec, 1578},
	/*II_DE_E8*/ {0xfa, 1578},
	/*II_DE_E8*/ {0xfa, 1578},
	/*II_DE_E8*/ {0xfa, 1578},
	/*II_DE_E8*/ {0xfa, 1578},
	/*II_DE_E8*/ {0xfa, 1578},
	/*II_DE_E8*/ {0xfa, 1578},
	/*II_DE_F0*/ {0xfa, 1585},
	/*II_DE_F1*/ {0xec, 1585},
	/*II_DE_F0*/ {0xfa, 1585},
	/*II_DE_F0*/ {0xfa, 1585},
	/*II_DE_F0*/ {0xfa, 1585},
	/*II_DE_F0*/ {0xfa, 1585},
	/*II_DE_F0*/ {0xfa, 1585},
	/*II_DE_F0*/ {0xfa, 1585},
	/*II_DE_F8*/ {0xfa, 1593},
	/*II_DE_F9*/ {0xec, 1593},
	/*II_DE_F8*/ {0xfa, 1593},
	/*II_DE_F8*/ {0xfa, 1593},
	/*II_DE_F8*/ {0xfa, 1593},
	/*II_DE_F8*/ {0xfa, 1593},
	/*II_DE_F8*/ {0xfa, 1593},
	/*II_DE_F8*/ {0xfa, 1593},
	/*II_DF_00*/ {0xef, 1417},
	/*II_DF_01*/ {0xfd, 1423},
	/*II_DF_02*/ {0xfe, 1431},
	/*II_DF_03*/ {0xfe, 1437},
	/*II_DF_04*/ {0xf5, 1600},
	/*II_DF_05*/ {0xf9, 1417},
	/*II_DF_06*/ {0xf6, 1606},
	/*II_DF_07*/ {0xfc, 1437},
	/*II_DF_E8*/ {0xf7, 1613},
	/*II_DF_E8*/ {0xf7, 1613},
	/*II_DF_E8*/ {0xf7, 1613},
	/*II_DF_E8*/ {0xf7, 1613},
	/*II_DF_E8*/ {0xf7, 1613},
	/*II_DF_E8*/ {0xf7, 1613},
	/*II_DF_E8*/ {0xf7, 1613},
	/*II_DF_E8*/ {0xf7, 1613},
	/*II_DF_F0*/ {0xf7, 1622},
	/*II_DF_F0*/ {0xf7, 1622},
	/*II_DF_F0*/ {0xf7, 1622},
	/*II_DF_F0*/ {0xf7, 1622},
	/*II_DF_F0*/ {0xf7, 1622},
	/*II_DF_F0*/ {0xf7, 1622},
	/*II_DF_F0*/ {0xf7, 1622},
	/*II_DF_F0*/ {0xf7, 1622},
	/*II_F6_00*/ {0xff, 206},
	/*II_F6_02*/ {0x100, 1630},
	/*II_F6_03*/ {0x101, 1635},
	/*II_F6_04*/ {0x102, 1640},
	/*II_F6_05*/ {0x102, 117},
	/*II_F6_06*/ {0x103, 1645},
	/*II_F6_07*/ {0x103, 1650},
	/*II_F7_00*/ {0x104, 206},
	/*II_F7_02*/ {0x105, 1630},
	/*II_F7_03*/ {0x106, 1635},
	/*II_F7_04*/ {0x107, 1640},
	/*II_F7_05*/ {0x107, 117},
	/*II_F7_06*/ {0x108, 1645},
	/*II_F7_07*/ {0x108, 1650},
	/*II_FE_00*/ {0x109, 81},
	/*II_FE_01*/ {0x109, 86},
	/*II_FF_00*/ {0x10a, 81},
	/*II_FF_01*/ {0x10a, 86},
	/*II_FF_02*/ {0x10b, 455},
	/*II_FF_03*/ {0x10c, 260},
	/*II_FF_04*/ {0x10d, 461},
	/*II_FF_05*/ {0x10e, 466},
	/*II_FF_06*/ {0x10f, 16},
	/*II_0F_00_00*/ {0x110, 1656},
	/*II_0F_00_01*/ {0x111, 1662},
	/*II_0F_00_02*/ {0x112, 1667},
	/*II_0F_00_03*/ {0x113, 1673},
	/*II_0F_00_04*/ {0x114, 1678},
	/*II_0F_00_05*/ {0x114, 1684},
	/*II_0F_01_00*/ {0x115, 1690},
	/*II_0F_01_01*/ {0x115, 1696},
	/*II_0F_01_02*/ {0x116, 1702},
	/*II_0F_01_03*/ {0x116, 1708},
	/*II_0F_01_04*/ {0x117, 1714},
	/*II_0F_01_06*/ {0x118, 1720},
	/*II_0F_01_07*/ {0x119, 1726},
	/*II_0F_01_C1*/ {0x11a, 1734},
	/*II_0F_01_C2*/ {0x11a, 1742},
	/*II_0F_01_C3*/ {0x11a, 1752},
	/*II_0F_01_C4*/ {0x11a, 1762},
	/*II_0F_01_C8*/ {0x11b, 1770},
	/*II_0F_01_C9*/ {0x11b, 1779},
	/*II_0F_01_CA*/ {0x11b, 1786},
	/*II_0F_01_CB*/ {0x11b, 1792},
	/*II_0F_01_D0*/ {0x91, 1798},
	/*II_0F_01_D1*/ {0x91, 1806},
	/*II_0F_01_D4*/ {0x11a, 1814},
	/*II_0F_01_D5*/ {0x11c, 1822},
	/*II_0F_01_D8*/ {0x11d, 1828},
	/*II_0F_01_D9*/ {0x11e, 1835},
	/*II_0F_01_DA*/ {0x11f, 1844},
	/*II_0F_01_DB*/ {0x11f, 1852},
	/*II_0F_01_DC*/ {0x11e, 1860},
	/*II_0F_01_DD*/ {0x11e, 1866},
	/*II_0F_01_DE*/ {0x11f, 1872},
	/*II_0F_01_DF*/ {0x120, 1880},
	/*II_0F_01_F8*/ {0x121, 1889},
	/*II_0F_01_F9*/ {0x121, 1897},
	/*II_0F_0D_00*/ {0x122, 1905},
	/*II_0F_0D_01*/ {0x122, 1915},
	/*II_0F_0F_0C*/ {0x123, 1926},
	/*II_0F_0F_0D*/ {0x124, 1933},
	/*II_0F_0F_1C*/ {0x123, 1940},
	/*II_0F_0F_1D*/ {0x124, 1947},
	/*II_0F_0F_8A*/ {0x123, 1954},
	/*II_0F_0F_8E*/ {0x123, 1962},
	/*II_0F_0F_90*/ {0x124, 1971},
	/*II_0F_0F_94*/ {0x124, 1980},
	/*II_0F_0F_96*/ {0x124, 1987},
	/*II_0F_0F_97*/ {0x124, 1994},
	/*II_0F_0F_9A*/ {0x124, 2003},
	/*II_0F_0F_9E*/ {0x124, 2010},
	/*II_0F_0F_A0*/ {0x124, 2017},
	/*II_0F_0F_A4*/ {0x124, 2026},
	/*II_0F_0F_A6*/ {0x124, 2033},
	/*II_0F_0F_A7*/ {0x124, 2043},
	/*II_0F_0F_AA*/ {0x124, 2053},
	/*II_0F_0F_AE*/ {0x124, 2061},
	/*II_0F_0F_B0*/ {0x124, 2068},
	/*II_0F_0F_B4*/ {0x124, 2077},
	/*II_0F_0F_B6*/ {0x124, 2084},
	/*II_0F_0F_B7*/ {0x124, 2094},
	/*II_0F_0F_BB*/ {0x123, 2103},
	/*II_0F_0F_BF*/ {0x124, 2111},
	/*II_0F_10*/ {0x125, 2120},
	/*II_66_0F_10*/ {0x126, 2128},
	/*II_F3_0F_10*/ {0x127, 2136},
	/*II_F2_0F_10*/ {0x128, 2143},
	/*II_0F_11*/ {0x12d, 2120},
	/*II_66_0F_11*/ {0x12e, 2128},
	/*II_F3_0F_11*/ {0x12f, 2136},
	/*II_F2_0F_11*/ {0x130, 2143},
	/*II_66_0F_12*/ {0x135, 2201},
	/*II_F3_0F_12*/ {0x136, 2209},
	/*II_F2_0F_12*/ {0x136, 2219},
	/*II_0F_13*/ {0x13a, 2193},
	/*II_66_0F_13*/ {0x13b, 2201},
	/*II_0F_14*/ {0x13d, 2277},
	/*II_66_0F_14*/ {0x13e, 2287},
	/*II_0F_15*/ {0x13d, 2319},
	/*II_66_0F_15*/ {0x13e, 2329},
	/*II_66_0F_16*/ {0x135, 2378},
	/*II_F3_0F_16*/ {0x140, 2386},
	/*II_0F_17*/ {0x13a, 2370},
	/*II_66_0F_17*/ {0x13b, 2378},
	/*II_0F_18_00*/ {0x141, 2435},
	/*II_0F_18_01*/ {0x141, 2448},
	/*II_0F_18_02*/ {0x141, 2460},
	/*II_0F_18_03*/ {0x141, 2472},
	/*II_0F_28*/ {0x125, 2484},
	/*II_66_0F_28*/ {0x126, 2492},
	/*II_0F_29*/ {0x12d, 2484},
	/*II_66_0F_29*/ {0x12e, 2492},
	/*II_0F_2A*/ {0x142, 2518},
	/*II_66_0F_2A*/ {0x143, 2528},
	/*II_F3_0F_2A*/ {0x144, 2538},
	/*II_F2_0F_2A*/ {0x145, 2548},
	/*II_0F_2B*/ {0x146, 2580},
	/*II_66_0F_2B*/ {0x147, 2589},
	/*II_F3_0F_2B*/ {0x148, 2598},
	/*II_F2_0F_2B*/ {0x149, 2607},
	/*II_0F_2C*/ {0x14b, 2636},
	/*II_66_0F_2C*/ {0x14c, 2647},
	/*II_F3_0F_2C*/ {0x14d, 2658},
	/*II_F2_0F_2C*/ {0x14e, 2669},
	/*II_0F_2D*/ {0x14b, 2704},
	/*II_66_0F_2D*/ {0x13e, 2714},
	/*II_F3_0F_2D*/ {0x14d, 2724},
	/*II_F2_0F_2D*/ {0x14e, 2734},
	/*II_0F_2E*/ {0x150, 2766},
	/*II_66_0F_2E*/ {0x151, 2775},
	/*II_0F_2F*/ {0x150, 2804},
	/*II_66_0F_2F*/ {0x151, 2812},
	/*II_0F_50*/ {0x154, 2838},
	/*II_66_0F_50*/ {0x155, 2848},
	/*II_0F_51*/ {0x13d, 2880},
	/*II_66_0F_51*/ {0x13e, 2888},
	/*II_F3_0F_51*/ {0x157, 2896},
	/*II_F2_0F_51*/ {0x151, 2904},
	/*II_0F_52*/ {0x13d, 2948},
	/*II_F3_0F_52*/ {0x157, 2957},
	/*II_0F_53*/ {0x13d, 2986},
	/*II_F3_0F_53*/ {0x157, 2993},
	/*II_0F_54*/ {0x13d, 3016},
	/*II_66_0F_54*/ {0x13e, 3023},
	/*II_0F_55*/ {0x13d, 3046},
	/*II_66_0F_55*/ {0x13e, 3054},
	/*II_0F_56*/ {0x13d, 3080},
	/*II_66_0F_56*/ {0x13e, 3086},
	/*II_0F_57*/ {0x13d, 3106},
	/*II_66_0F_57*/ {0x13e, 3113},
	/*II_0F_58*/ {0x13d, 3136},
	/*II_66_0F_58*/ {0x13e, 3143},
	/*II_F3_0F_58*/ {0x157, 3150},
	/*II_F2_0F_58*/ {0x151, 3157},
	/*II_0F_59*/ {0x13d, 3196},
	/*II_66_0F_59*/ {0x13e, 3203},
	/*II_F3_0F_59*/ {0x157, 3210},
	/*II_F2_0F_59*/ {0x151, 3217},
	/*II_0F_5A*/ {0x151, 3256},
	/*II_66_0F_5A*/ {0x13e, 3266},
	/*II_F3_0F_5A*/ {0x158, 3276},
	/*II_F2_0F_5A*/ {0x151, 3286},
	/*II_0F_5B*/ {0x13e, 3340},
	/*II_66_0F_5B*/ {0x13e, 3350},
	/*II_F3_0F_5B*/ {0x13e, 3360},
	/*II_0F_5C*/ {0x13d, 3405},
	/*II_66_0F_5C*/ {0x13e, 3412},
	/*II_F3_0F_5C*/ {0x157, 3419},
	/*II_F2_0F_5C*/ {0x151, 3426},
	/*II_0F_5D*/ {0x13d, 3465},
	/*II_66_0F_5D*/ {0x13e, 3472},
	/*II_F3_0F_5D*/ {0x157, 3479},
	/*II_F2_0F_5D*/ {0x151, 3486},
	/*II_0F_5E*/ {0x13d, 3525},
	/*II_66_0F_5E*/ {0x13e, 3532},
	/*II_F3_0F_5E*/ {0x157, 3539},
	/*II_F2_0F_5E*/ {0x151, 3546},
	/*II_0F_5F*/ {0x13d, 3585},
	/*II_66_0F_5F*/ {0x13e, 3592},
	/*II_F3_0F_5F*/ {0x157, 3599},
	/*II_F2_0F_5F*/ {0x151, 3606},
	/*II_0F_60*/ {0x15b, 3645},
	/*II_66_0F_60*/ {0x13e, 3645},
	/*II_0F_61*/ {0x15b, 3668},
	/*II_66_0F_61*/ {0x13e, 3668},
	/*II_0F_62*/ {0x15b, 3691},
	/*II_66_0F_62*/ {0x13e, 3691},
	/*II_0F_63*/ {0x15c, 3714},
	/*II_66_0F_63*/ {0x13e, 3714},
	/*II_0F_64*/ {0x15c, 3735},
	/*II_66_0F_64*/ {0x13e, 3735},
	/*II_0F_65*/ {0x15c, 3754},
	/*II_66_0F_65*/ {0x13e, 3754},
	/*II_0F_66*/ {0x15c, 3773},
	/*II_66_0F_66*/ {0x13e, 3773},
	/*II_0F_67*/ {0x15c, 3792},
	/*II_66_0F_67*/ {0x13e, 3792},
	/*II_0F_68*/ {0x15c, 3813},
	/*II_66_0F_68*/ {0x13e, 3813},
	/*II_0F_69*/ {0x15c, 3836},
	/*II_66_0F_69*/ {0x13e, 3836},
	/*II_0F_6A*/ {0x15c, 3859},
	/*II_66_0F_6A*/ {0x13e, 3859},
	/*II_0F_6B*/ {0x15c, 3882},
	/*II_66_0F_6B*/ {0x13e, 3882},
	/*II_66_0F_6C*/ {0x13e, 3903},
	/*II_66_0F_6D*/ {0x13e, 3928},
	/*II_0F_6F*/ {0x160, 3959},
	/*II_66_0F_6F*/ {0x126, 3979},
	/*II_F3_0F_6F*/ {0x126, 3987},
	/*II_0F_74*/ {0x15c, 4076},
	/*II_66_0F_74*/ {0x13e, 4076},
	/*II_0F_75*/ {0x15c, 4095},
	/*II_66_0F_75*/ {0x13e, 4095},
	/*II_0F_76*/ {0x15c, 4114},
	/*II_66_0F_76*/ {0x13e, 4114},
	/*II_0F_77*/ {0x164, 4133},
	/*II_0F_78*/ {0x166, 4161},
	/*II_0F_79*/ {0x169, 4185},
	/*II_66_0F_79*/ {0x16a, 4169},
	/*II_F2_0F_79*/ {0x16b, 4176},
	/*II_0F_7A_30*/ {0x16c, 4194},
	/*II_0F_7A_31*/ {0x16d, 4204},
	/*II_66_0F_7C*/ {0x16e, 4214},
	/*II_F2_0F_7C*/ {0x16e, 4222},
	/*II_66_0F_7D*/ {0x16e, 4248},
	/*II_F2_0F_7D*/ {0x16e, 4256},
	/*II_F3_0F_7E*/ {0x128, 3959},
	/*II_0F_7F*/ {0x172, 3959},
	/*II_66_0F_7F*/ {0x12e, 3979},
	/*II_F3_0F_7F*/ {0x12e, 3987},
	/*II_F3_0F_B8*/ {0x176, 4371},
	/*II_0F_BA_04*/ {0x177, 871},
	/*II_0F_BA_05*/ {0x178, 886},
	/*II_0F_BA_06*/ {0x178, 911},
	/*II_0F_BA_07*/ {0x178, 933},
	/*II_0F_BC*/ {0x179, 4379},
	/*II_F3_0F_BC*/ {0x17a, 4384},
	/*II_0F_BD*/ {0x179, 4391},
	/*II_F3_0F_BD*/ {0x17b, 4396},
	/*II_0F_C7_07*/ {0x18b, 6418},
	/*II_66_0F_D0*/ {0x16e, 6427},
	/*II_F2_0F_D0*/ {0x16e, 6437},
	/*II_0F_D1*/ {0x15c, 6469},
	/*II_66_0F_D1*/ {0x13e, 6469},
	/*II_0F_D2*/ {0x15c, 6484},
	/*II_66_0F_D2*/ {0x13e, 6484},
	/*II_0F_D3*/ {0x15c, 6499},
	/*II_66_0F_D3*/ {0x13e, 6499},
	/*II_0F_D4*/ {0x151, 6514},
	/*II_66_0F_D4*/ {0x13e, 6514},
	/*II_0F_D5*/ {0x15c, 6529},
	/*II_66_0F_D5*/ {0x13e, 6529},
	/*II_66_0F_D6*/ {0x130, 3959},
	/*II_F3_0F_D6*/ {0x18c, 6546},
	/*II_F2_0F_D6*/ {0x18d, 6555},
	/*II_0F_D7*/ {0x18f, 6564},
	/*II_66_0F_D7*/ {0x190, 6564},
	/*II_0F_D8*/ {0x15c, 6585},
	/*II_66_0F_D8*/ {0x13e, 6585},
	/*II_0F_D9*/ {0x15c, 6604},
	/*II_66_0F_D9*/ {0x13e, 6604},
	/*II_0F_DA*/ {0x192, 6623},
	/*II_66_0F_DA*/ {0x13e, 6623},
	/*II_0F_DB*/ {0x15c, 6640},
	/*II_66_0F_DB*/ {0x13e, 6640},
	/*II_0F_DC*/ {0x15c, 6653},
	/*II_66_0F_DC*/ {0x13e, 6653},
	/*II_0F_DD*/ {0x15c, 6672},
	/*II_66_0F_DD*/ {0x13e, 6672},
	/*II_0F_DE*/ {0x192, 6681},
	/*II_66_0F_DE*/ {0x13e, 6681},
	/*II_0F_DF*/ {0x15c, 6698},
	/*II_66_0F_DF*/ {0x13e, 6698},
	/*II_0F_E0*/ {0x192, 6713},
	/*II_66_0F_E0*/ {0x13e, 6713},
	/*II_0F_E1*/ {0x15c, 6728},
	/*II_66_0F_E1*/ {0x13e, 6728},
	/*II_0F_E2*/ {0x15c, 6743},
	/*II_66_0F_E2*/ {0x13e, 6743},
	/*II_0F_E3*/ {0x192, 6758},
	/*II_66_0F_E3*/ {0x13e, 6758},
	/*II_0F_E4*/ {0x192, 6773},
	/*II_66_0F_E4*/ {0x13e, 6773},
	/*II_0F_E5*/ {0x15c, 6792},
	/*II_66_0F_E5*/ {0x13e, 6792},
	/*II_66_0F_E6*/ {0x13e, 6809},
	/*II_F3_0F_E6*/ {0x151, 6820},
	/*II_F2_0F_E6*/ {0x13e, 6830},
	/*II_0F_E7*/ {0x193, 6874},
	/*II_66_0F_E7*/ {0x147, 6882},
	/*II_0F_E8*/ {0x15c, 6901},
	/*II_66_0F_E8*/ {0x13e, 6901},
	/*II_0F_E9*/ {0x15c, 6918},
	/*II_66_0F_E9*/ {0x13e, 6918},
	/*II_0F_EA*/ {0x192, 6935},
	/*II_66_0F_EA*/ {0x13e, 6935},
	/*II_0F_EB*/ {0x15c, 6952},
	/*II_66_0F_EB*/ {0x13e, 6952},
	/*II_0F_EC*/ {0x15c, 6963},
	/*II_66_0F_EC*/ {0x13e, 6963},
	/*II_0F_ED*/ {0x15c, 6980},
	/*II_66_0F_ED*/ {0x13e, 6980},
	/*II_0F_EE*/ {0x192, 6997},
	/*II_66_0F_EE*/ {0x13e, 6997},
	/*II_0F_EF*/ {0x15c, 7014},
	/*II_66_0F_EF*/ {0x13e, 7014},
	/*II_F2_0F_F0*/ {0x194, 7027},
	/*II_0F_F1*/ {0x15c, 7042},
	/*II_66_0F_F1*/ {0x13e, 7042},
	/*II_0F_F2*/ {0x15c, 7057},
	/*II_66_0F_F2*/ {0x13e, 7057},
	/*II_0F_F3*/ {0x15c, 7072},
	/*II_66_0F_F3*/ {0x13e, 7072},
	/*II_0F_F4*/ {0x196, 7087},
	/*II_66_0F_F4*/ {0x13e, 7087},
	/*II_0F_F5*/ {0x15c, 7106},
	/*II_66_0F_F5*/ {0x13e, 7106},
	/*II_0F_F6*/ {0x192, 7125},
	/*II_66_0F_F6*/ {0x13e, 7125},
	/*II_0F_F7*/ {0x197, 7142},
	/*II_66_0F_F7*/ {0x198, 7152},
	/*II_0F_F8*/ {0x15c, 7177},
	/*II_66_0F_F8*/ {0x13e, 7177},
	/*II_0F_F9*/ {0x15c, 7192},
	/*II_66_0F_F9*/ {0x13e, 7192},
	/*II_0F_FA*/ {0x15c, 7207},
	/*II_66_0F_FA*/ {0x13e, 7207},
	/*II_0F_FB*/ {0x196, 7222},
	/*II_66_0F_FB*/ {0x13e, 7222},
	/*II_0F_FC*/ {0x15c, 7237},
	/*II_66_0F_FC*/ {0x13e, 7237},
	/*II_0F_FD*/ {0x15c, 7252},
	/*II_66_0F_FD*/ {0x13e, 7252},
	/*II_0F_FE*/ {0x15c, 7267},
	/*II_66_0F_FE*/ {0x13e, 7267},
	/*II_D9_06*/ {0x19a, 7282},
	/*II_9B_D9_06*/ {0x19b, 7291},
	/*II_D9_07*/ {0xfe, 7299},
	/*II_9B_D9_07*/ {0x19c, 7307},
	/*II_DB_E2*/ {0xec, 7314},
	/*II_9B_DB_E2*/ {0x19d, 7322},
	/*II_DB_E3*/ {0xec, 7329},
	/*II_9B_DB_E3*/ {0x19d, 7337},
	/*II_DD_06*/ {0x19a, 7344},
	/*II_9B_DD_06*/ {0x19b, 7352},
	/*II_DD_07*/ {0xfe, 7359},
	/*II_9B_DD_07*/ {0x19c, 7367},
	/*II_DF_E0*/ {0x19e, 7359},
	/*II_9B_DF_E0*/ {0x19f, 7367},
	/*II_0F_38_00*/ {0x1a0, 7374},
	/*II_66_0F_38_00*/ {0x1a1, 7374},
	/*II_0F_38_01*/ {0x1a0, 7391},
	/*II_66_0F_38_01*/ {0x1a1, 7391},
	/*II_0F_38_02*/ {0x1a0, 7408},
	/*II_66_0F_38_02*/ {0x1a1, 7408},
	/*II_0F_38_03*/ {0x1a0, 7425},
	/*II_66_0F_38_03*/ {0x1a1, 7425},
	/*II_0F_38_04*/ {0x1a0, 7444},
	/*II_66_0F_38_04*/ {0x1a1, 7444},
	/*II_0F_38_05*/ {0x1a0, 7467},
	/*II_66_0F_38_05*/ {0x1a1, 7467},
	/*II_0F_38_06*/ {0x1a0, 7484},
	/*II_66_0F_38_06*/ {0x1a1, 7484},
	/*II_0F_38_07*/ {0x1a0, 7501},
	/*II_66_0F_38_07*/ {0x1a1, 7501},
	/*II_0F_38_08*/ {0x1a0, 7520},
	/*II_66_0F_38_08*/ {0x1a1, 7520},
	/*II_0F_38_09*/ {0x1a0, 7537},
	/*II_66_0F_38_09*/ {0x1a1, 7537},
	/*II_0F_38_0A*/ {0x1a0, 7554},
	/*II_66_0F_38_0A*/ {0x1a1, 7554},
	/*II_0F_38_0B*/ {0x1a0, 7571},
	/*II_66_0F_38_0B*/ {0x1a1, 7571},
	/*II_66_0F_38_17*/ {0x1a3, 7662},
	/*II_0F_38_1C*/ {0x1a0, 7721},
	/*II_66_0F_38_1C*/ {0x1a1, 7721},
	/*II_0F_38_1D*/ {0x1a0, 7736},
	/*II_66_0F_38_1D*/ {0x1a1, 7736},
	/*II_0F_38_1E*/ {0x1a0, 7751},
	/*II_66_0F_38_1E*/ {0x1a1, 7751},
	/*II_66_0F_38_20*/ {0x1a8, 7766},
	/*II_66_0F_38_21*/ {0x1a9, 7787},
	/*II_66_0F_38_22*/ {0x1aa, 7808},
	/*II_66_0F_38_23*/ {0x1a8, 7829},
	/*II_66_0F_38_24*/ {0x1a9, 7850},
	/*II_66_0F_38_25*/ {0x1a8, 7871},
	/*II_66_0F_38_28*/ {0x1ac, 7892},
	/*II_66_0F_38_29*/ {0x1ac, 7909},
	/*II_66_0F_38_2A*/ {0x1ad, 7928},
	/*II_66_0F_38_2B*/ {0x1ac, 7949},
	/*II_66_0F_38_30*/ {0x1a8, 7994},
	/*II_66_0F_38_31*/ {0x1a9, 8015},
	/*II_66_0F_38_32*/ {0x1aa, 8036},
	/*II_66_0F_38_33*/ {0x1a8, 8057},
	/*II_66_0F_38_34*/ {0x1a9, 8078},
	/*II_66_0F_38_35*/ {0x1a8, 8099},
	/*II_66_0F_38_37*/ {0x1a3, 8120},
	/*II_66_0F_38_38*/ {0x1ac, 8139},
	/*II_66_0F_38_39*/ {0x1ac, 8156},
	/*II_66_0F_38_3A*/ {0x1ac, 8173},
	/*II_66_0F_38_3B*/ {0x1ac, 8190},
	/*II_66_0F_38_3C*/ {0x1ac, 8207},
	/*II_66_0F_38_3D*/ {0x1ac, 8224},
	/*II_66_0F_38_3E*/ {0x1ac, 8241},
	/*II_66_0F_38_3F*/ {0x1ac, 8258},
	/*II_66_0F_38_40*/ {0x1ac, 8275},
	/*II_66_0F_38_41*/ {0x1ac, 8292},
	/*II_66_0F_38_80*/ {0x1b0, 8317},
	/*II_66_0F_38_81*/ {0x1b0, 8325},
	/*II_66_0F_38_82*/ {0x1b0, 8334},
	/*II_66_0F_38_DB*/ {0x1b3, 9183},
	/*II_66_0F_38_DC*/ {0x1b3, 9200},
	/*II_66_0F_38_DD*/ {0x1b3, 9217},
	/*II_66_0F_38_DE*/ {0x1b3, 9242},
	/*II_66_0F_38_DF*/ {0x1b3, 9259},
	/*II_0F_38_F0*/ {0x1b6, 9284},
	/*II_F2_0F_38_F0*/ {0x1b7, 9291},
	/*II_0F_38_F1*/ {0x1b8, 9284},
	/*II_F2_0F_38_F1*/ {0x1b9, 9291},
	/*II_0F_71_02*/ {0x1d0, 6469},
	/*II_66_0F_71_02*/ {0x1d1, 6469},
	/*II_0F_71_04*/ {0x1d0, 6728},
	/*II_66_0F_71_04*/ {0x1d1, 6728},
	/*II_0F_71_06*/ {0x1d0, 7042},
	/*II_66_0F_71_06*/ {0x1d1, 7042},
	/*II_0F_72_02*/ {0x1d0, 6484},
	/*II_66_0F_72_02*/ {0x1d1, 6484},
	/*II_0F_72_04*/ {0x1d0, 6743},
	/*II_66_0F_72_04*/ {0x1d1, 6743},
	/*II_0F_72_06*/ {0x1d0, 7057},
	/*II_66_0F_72_06*/ {0x1d1, 7057},
	/*II_0F_73_02*/ {0x1d0, 6499},
	/*II_66_0F_73_02*/ {0x1d1, 6499},
	/*II_66_0F_73_03*/ {0x1d1, 9863},
	/*II_0F_73_06*/ {0x1d0, 7072},
	/*II_66_0F_73_06*/ {0x1d1, 7072},
	/*II_66_0F_73_07*/ {0x1d1, 9880},
	/*II_F3_0F_AE_00*/ {0x1d3, 9915},
	/*II_F3_0F_AE_01*/ {0x1d3, 9945},
	/*II_0F_AE_02*/ {0x1d4, 9955},
	/*II_F3_0F_AE_02*/ {0x1d3, 9964},
	/*II_0F_AE_03*/ {0x1d4, 9984},
	/*II_F3_0F_AE_03*/ {0x1d3, 9993},
	/*II_0F_C7_06*/ {0x1d6, 10013},
	/*II_66_0F_C7_06*/ {0x18b, 10022},
	/*II_F3_0F_C7_06*/ {0x18b, 10031}
};

_InstInfoEx InstInfosEx[381] = {
	/*II_69*/ {{0x34, 117}, 0x0, 3, 0, 0, 0},
	/*II_6B*/ {{0x34, 117}, 0x0, 5, 0, 0, 0},
	/*II_98*/ {{0x4e, 228}, 0x0, 0, 0, 233, 239},
	/*II_99*/ {{0x4e, 245}, 0x0, 0, 0, 250, 255},
	/*II_E3*/ {{0x75, 426}, 0x0, 0, 0, 432, 439},
	/*II_0F_A4*/ {{0xad, 875}, 0x0, 1, 0, 0, 0},
	/*II_0F_A5*/ {{0xad, 875}, 0x0, 42, 0, 0, 0},
	/*II_0F_AC*/ {{0xad, 891}, 0x0, 1, 0, 0, 0},
	/*II_0F_AD*/ {{0xad, 891}, 0x0, 42, 0, 0, 0},
	/*II_V_0F_10*/ {{0x129, 2150}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_10*/ {{0x129, 2159}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_10*/ {{0x12a, 2168}, 0x20, 31, 0, 0, 0},
	/*II_V_F2_0F_10*/ {{0x12a, 2176}, 0x20, 31, 0, 0, 0},
	/*II_VRR_F3_0F_10*/ {{0x12b, 2168}, 0x60, 0, 0, 0, 0},
	/*II_VRR_F2_0F_10*/ {{0x12c, 2176}, 0x60, 0, 0, 0, 0},
	/*II_V_0F_11*/ {{0x131, 2150}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_11*/ {{0x131, 2159}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_11*/ {{0x12a, 2168}, 0x20, 31, 0, 0, 0},
	/*II_V_F2_0F_11*/ {{0x12a, 2176}, 0x20, 31, 0, 0, 0},
	/*II_VRR_F3_0F_11*/ {{0x132, 2168}, 0x60, 0, 0, 0, 0},
	/*II_VRR_F2_0F_11*/ {{0x133, 2176}, 0x60, 0, 0, 0, 0},
	/*II_0F_12*/ {{0x134, 2184}, 0x0, 0, 0, 2193, 0},
	/*II_V_0F_12*/ {{0x137, 2228}, 0x0, 86, 0, 2238, 0},
	/*II_V_66_0F_12*/ {{0x138, 2247}, 0x0, 57, 0, 0, 0},
	/*II_V_F3_0F_12*/ {{0x129, 2256}, 0x41, 0, 0, 0, 0},
	/*II_V_F2_0F_12*/ {{0x139, 2267}, 0x41, 0, 0, 0, 0},
	/*II_V_0F_13*/ {{0x13c, 2238}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_13*/ {{0x13c, 2247}, 0x40, 0, 0, 0, 0},
	/*II_V_0F_14*/ {{0x13f, 2297}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_14*/ {{0x13f, 2308}, 0x1, 91, 0, 0, 0},
	/*II_V_0F_15*/ {{0x13f, 2339}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_15*/ {{0x13f, 2350}, 0x1, 91, 0, 0, 0},
	/*II_0F_16*/ {{0x134, 2361}, 0x0, 0, 0, 2370, 0},
	/*II_V_0F_16*/ {{0x137, 2396}, 0x0, 86, 0, 2406, 0},
	/*II_V_66_0F_16*/ {{0x138, 2415}, 0x0, 57, 0, 0, 0},
	/*II_V_F3_0F_16*/ {{0x129, 2424}, 0x41, 0, 0, 0, 0},
	/*II_V_0F_17*/ {{0x13c, 2406}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_17*/ {{0x13c, 2415}, 0x40, 0, 0, 0, 0},
	/*II_V_0F_28*/ {{0x129, 2500}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_28*/ {{0x129, 2509}, 0x41, 0, 0, 0, 0},
	/*II_V_0F_29*/ {{0x131, 2500}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_29*/ {{0x131, 2509}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_2A*/ {{0x138, 2558}, 0x2, 73, 0, 0, 0},
	/*II_V_F2_0F_2A*/ {{0x138, 2569}, 0x2, 73, 0, 0, 0},
	/*II_V_0F_2B*/ {{0x14a, 2616}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_2B*/ {{0x14a, 2626}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_2C*/ {{0x14f, 2680}, 0x42, 0, 0, 0, 0},
	/*II_V_F2_0F_2C*/ {{0x14f, 2692}, 0x42, 0, 0, 0, 0},
	/*II_V_F3_0F_2D*/ {{0x14f, 2744}, 0x42, 0, 0, 0, 0},
	/*II_V_F2_0F_2D*/ {{0x14f, 2755}, 0x42, 0, 0, 0, 0},
	/*II_V_0F_2E*/ {{0x152, 2784}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_2E*/ {{0x153, 2794}, 0x40, 0, 0, 0, 0},
	/*II_V_0F_2F*/ {{0x152, 2820}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_2F*/ {{0x153, 2829}, 0x40, 0, 0, 0, 0},
	/*II_V_0F_50*/ {{0x156, 2858}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_50*/ {{0x156, 2869}, 0x41, 0, 0, 0, 0},
	/*II_V_0F_51*/ {{0x129, 2912}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_51*/ {{0x129, 2921}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_51*/ {{0x138, 2930}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_51*/ {{0x138, 2939}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_52*/ {{0x129, 2966}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_52*/ {{0x138, 2976}, 0x0, 85, 0, 0, 0},
	/*II_V_0F_53*/ {{0x129, 3000}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_53*/ {{0x138, 3008}, 0x0, 85, 0, 0, 0},
	/*II_V_0F_54*/ {{0x13f, 3030}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_54*/ {{0x13f, 3038}, 0x1, 91, 0, 0, 0},
	/*II_V_0F_55*/ {{0x13f, 3062}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_55*/ {{0x13f, 3071}, 0x1, 91, 0, 0, 0},
	/*II_V_0F_56*/ {{0x13f, 3092}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_56*/ {{0x13f, 3099}, 0x1, 91, 0, 0, 0},
	/*II_V_0F_57*/ {{0x13f, 3120}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_57*/ {{0x13f, 3128}, 0x1, 91, 0, 0, 0},
	/*II_V_0F_58*/ {{0x13f, 3164}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_58*/ {{0x13f, 3172}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_58*/ {{0x138, 3180}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_58*/ {{0x138, 3188}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_59*/ {{0x13f, 3224}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_59*/ {{0x13f, 3232}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_59*/ {{0x138, 3240}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_59*/ {{0x138, 3248}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_5A*/ {{0x159, 3296}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_5A*/ {{0x15a, 3307}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_5A*/ {{0x138, 3318}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_5A*/ {{0x138, 3329}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_5B*/ {{0x129, 3371}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_5B*/ {{0x129, 3382}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_5B*/ {{0x129, 3393}, 0x41, 0, 0, 0, 0},
	/*II_V_0F_5C*/ {{0x13f, 3433}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_5C*/ {{0x13f, 3441}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_5C*/ {{0x138, 3449}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_5C*/ {{0x138, 3457}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_5D*/ {{0x13f, 3493}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_5D*/ {{0x13f, 3501}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_5D*/ {{0x138, 3509}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_5D*/ {{0x138, 3517}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_5E*/ {{0x13f, 3553}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_5E*/ {{0x13f, 3561}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_5E*/ {{0x138, 3569}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_5E*/ {{0x138, 3577}, 0x0, 86, 0, 0, 0},
	/*II_V_0F_5F*/ {{0x13f, 3613}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_5F*/ {{0x13f, 3621}, 0x1, 91, 0, 0, 0},
	/*II_V_F3_0F_5F*/ {{0x138, 3629}, 0x0, 85, 0, 0, 0},
	/*II_V_F2_0F_5F*/ {{0x138, 3637}, 0x0, 86, 0, 0, 0},
	/*II_V_66_0F_60*/ {{0x138, 3656}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_61*/ {{0x138, 3679}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_62*/ {{0x138, 3702}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_63*/ {{0x138, 3724}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_64*/ {{0x138, 3744}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_65*/ {{0x138, 3763}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_66*/ {{0x138, 3782}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_67*/ {{0x138, 3802}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_68*/ {{0x138, 3824}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_69*/ {{0x138, 3847}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_6A*/ {{0x138, 3870}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_6B*/ {{0x138, 3892}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_6C*/ {{0x138, 3915}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_6D*/ {{0x138, 3940}, 0x0, 87, 0, 0, 0},
	/*II_0F_6E*/ {{0x15d, 3953}, 0x0, 0, 0, 0, 3959},
	/*II_66_0F_6E*/ {{0x15e, 3953}, 0x0, 0, 0, 0, 3959},
	/*II_V_66_0F_6E*/ {{0x15f, 3965}, 0x46, 0, 0, 3972, 0},
	/*II_V_66_0F_6F*/ {{0x129, 3995}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_6F*/ {{0x129, 4004}, 0x41, 0, 0, 0, 0},
	/*II_0F_70*/ {{0x161, 4013}, 0x0, 1, 0, 0, 0},
	/*II_66_0F_70*/ {{0x162, 4021}, 0x0, 1, 0, 0, 0},
	/*II_F3_0F_70*/ {{0x162, 4029}, 0x0, 1, 0, 0, 0},
	/*II_F2_0F_70*/ {{0x162, 4038}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_70*/ {{0x163, 4047}, 0x40, 1, 0, 0, 0},
	/*II_V_F3_0F_70*/ {{0x163, 4056}, 0x40, 1, 0, 0, 0},
	/*II_V_F2_0F_70*/ {{0x163, 4066}, 0x40, 1, 0, 0, 0},
	/*II_V_66_0F_74*/ {{0x138, 4085}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_75*/ {{0x138, 4104}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_76*/ {{0x138, 4123}, 0x0, 87, 0, 0, 0},
	/*II_V_0F_77*/ {{0x165, 4139}, 0x49, 0, 0, 4151, 0},
	/*II_66_0F_78*/ {{0x167, 4169}, 0x0, 49, 0, 0, 0},
	/*II_F2_0F_78*/ {{0x168, 4176}, 0x0, 48, 49, 0, 0},
	/*II_V_66_0F_7C*/ {{0x13f, 4230}, 0x1, 91, 0, 0, 0},
	/*II_V_F2_0F_7C*/ {{0x13f, 4239}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_7D*/ {{0x13f, 4264}, 0x1, 91, 0, 0, 0},
	/*II_V_F2_0F_7D*/ {{0x13f, 4273}, 0x1, 91, 0, 0, 0},
	/*II_0F_7E*/ {{0x16f, 3953}, 0x0, 0, 0, 0, 3959},
	/*II_66_0F_7E*/ {{0x170, 3953}, 0x0, 0, 0, 0, 3959},
	/*II_V_66_0F_7E*/ {{0x171, 3965}, 0x46, 0, 0, 3972, 0},
	/*II_V_F3_0F_7E*/ {{0x153, 3972}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_7F*/ {{0x131, 3995}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_7F*/ {{0x131, 4004}, 0x41, 0, 0, 0, 0},
	/*II_0F_AE_04*/ {{0x173, 4282}, 0x0, 0, 0, 0, 4289},
	/*II_0F_AE_05*/ {{0x174, 4298}, 0x0, 0, 0, 4306, 4314},
	/*II_0F_AE_06*/ {{0x174, 4324}, 0x0, 0, 0, 4332, 4342},
	/*II_0F_AE_07*/ {{0x175, 4354}, 0x0, 0, 0, 4362, 0},
	/*II_0F_C2*/ {{0x17c, 4403}, 0x0, 0, 0, 4412, 4421},
	/*II_66_0F_C2*/ {{0x17d, 4482}, 0x0, 0, 0, 4491, 4500},
	/*II_F3_0F_C2*/ {{0x17e, 4561}, 0x0, 0, 0, 4570, 4579},
	/*II_F2_0F_C2*/ {{0x17f, 4640}, 0x0, 0, 0, 4649, 4658},
	/*II_V_0F_C2*/ {{0x180, 4719}, 0x1, 91, 0, 4729, 4739},
	/*II_V_66_0F_C2*/ {{0x180, 5121}, 0x1, 91, 0, 5131, 5141},
	/*II_V_F3_0F_C2*/ {{0x181, 5523}, 0x0, 85, 0, 5533, 5543},
	/*II_V_F2_0F_C2*/ {{0x181, 5925}, 0x0, 86, 0, 5935, 5945},
	/*II_0F_C4*/ {{0x182, 6327}, 0x0, 1, 0, 0, 0},
	/*II_66_0F_C4*/ {{0x183, 6327}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_C4*/ {{0x184, 6335}, 0x0, 79, 1, 0, 0},
	/*II_0F_C5*/ {{0x185, 6344}, 0x0, 1, 0, 0, 0},
	/*II_66_0F_C5*/ {{0x186, 6344}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_C5*/ {{0x187, 6352}, 0x40, 1, 0, 0, 0},
	/*II_0F_C6*/ {{0x188, 6361}, 0x0, 1, 0, 0, 0},
	/*II_66_0F_C6*/ {{0x162, 6369}, 0x0, 1, 0, 0, 0},
	/*II_V_0F_C6*/ {{0x189, 6377}, 0x1, 91, 1, 0, 0},
	/*II_V_66_0F_C6*/ {{0x189, 6386}, 0x1, 91, 1, 0, 0},
	/*II_0F_C7_01*/ {{0x18a, 6395}, 0x0, 0, 0, 0, 6406},
	/*II_V_66_0F_D0*/ {{0x13f, 6447}, 0x1, 91, 0, 0, 0},
	/*II_V_F2_0F_D0*/ {{0x13f, 6458}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_D1*/ {{0x138, 6476}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D2*/ {{0x138, 6491}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D3*/ {{0x138, 6506}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D4*/ {{0x138, 6521}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D5*/ {{0x138, 6537}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D6*/ {{0x18e, 3972}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_D7*/ {{0x191, 6574}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_D8*/ {{0x138, 6594}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_D9*/ {{0x138, 6613}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DA*/ {{0x138, 6631}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DB*/ {{0x138, 6646}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DC*/ {{0x138, 6662}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DD*/ {{0x138, 6662}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DE*/ {{0x138, 6689}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_DF*/ {{0x138, 6705}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E0*/ {{0x138, 6720}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E1*/ {{0x138, 6735}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E2*/ {{0x138, 6750}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E3*/ {{0x138, 6765}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E4*/ {{0x138, 6782}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E5*/ {{0x138, 6800}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E6*/ {{0x15a, 6840}, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_E6*/ {{0x159, 6852}, 0x41, 0, 0, 0, 0},
	/*II_V_F2_0F_E6*/ {{0x15a, 6863}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_E7*/ {{0x14a, 6891}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_E8*/ {{0x138, 6909}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_E9*/ {{0x138, 6926}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_EA*/ {{0x138, 6943}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_EB*/ {{0x138, 6957}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_EC*/ {{0x138, 6971}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_ED*/ {{0x138, 6988}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_EE*/ {{0x138, 7005}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_EF*/ {{0x138, 7020}, 0x0, 87, 0, 0, 0},
	/*II_V_F2_0F_F0*/ {{0x195, 7034}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_F1*/ {{0x138, 7049}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F2*/ {{0x138, 7064}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F3*/ {{0x138, 7079}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F4*/ {{0x138, 7096}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F5*/ {{0x138, 7115}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F6*/ {{0x138, 7133}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F7*/ {{0x199, 7164}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_F8*/ {{0x138, 7184}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_F9*/ {{0x138, 7199}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_FA*/ {{0x138, 7214}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_FB*/ {{0x138, 7229}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_FC*/ {{0x138, 7244}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_FD*/ {{0x138, 7259}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_FE*/ {{0x138, 7274}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_00*/ {{0x138, 7382}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_01*/ {{0x138, 7399}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_02*/ {{0x138, 7416}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_03*/ {{0x138, 7434}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_04*/ {{0x138, 7455}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_05*/ {{0x138, 7475}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_06*/ {{0x138, 7492}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_07*/ {{0x138, 7510}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_08*/ {{0x138, 7528}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_09*/ {{0x138, 7545}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_0A*/ {{0x138, 7562}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_0B*/ {{0x138, 7581}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_0C*/ {{0x13f, 7592}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_38_0D*/ {{0x13f, 7603}, 0x1, 91, 0, 0, 0},
	/*II_V_66_0F_38_0E*/ {{0x129, 7614}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_38_0F*/ {{0x129, 7623}, 0x41, 0, 0, 0, 0},
	/*II_66_0F_38_10*/ {{0x1a2, 7632}, 0x0, 32, 0, 0, 0},
	/*II_66_0F_38_14*/ {{0x1a2, 7642}, 0x0, 32, 0, 0, 0},
	/*II_66_0F_38_15*/ {{0x1a2, 7652}, 0x0, 32, 0, 0, 0},
	/*II_V_66_0F_38_17*/ {{0x129, 7669}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_38_18*/ {{0x1a4, 7677}, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_38_19*/ {{0x1a5, 7691}, 0x50, 0, 0, 0, 0},
	/*II_V_66_0F_38_1A*/ {{0x1a6, 7705}, 0x50, 0, 0, 0, 0},
	/*II_V_66_0F_38_1C*/ {{0x1a7, 7728}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_1D*/ {{0x1a7, 7743}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_1E*/ {{0x1a7, 7758}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_20*/ {{0x153, 7776}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_21*/ {{0x152, 7797}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_22*/ {{0x1ab, 7818}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_23*/ {{0x153, 7839}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_24*/ {{0x152, 7860}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_25*/ {{0x153, 7881}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_28*/ {{0x138, 7900}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_29*/ {{0x138, 7918}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_2A*/ {{0x1ae, 7938}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_2B*/ {{0x138, 7959}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_2C*/ {{0x13f, 7970}, 0x1, 67, 0, 0, 0},
	/*II_V_66_0F_38_2D*/ {{0x13f, 7982}, 0x1, 67, 0, 0, 0},
	/*II_V_66_0F_38_2E*/ {{0x1af, 7970}, 0x1, 36, 0, 0, 0},
	/*II_V_66_0F_38_2F*/ {{0x1af, 7982}, 0x1, 36, 0, 0, 0},
	/*II_V_66_0F_38_30*/ {{0x153, 8004}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_31*/ {{0x152, 8025}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_32*/ {{0x1ab, 8046}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_33*/ {{0x153, 8067}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_34*/ {{0x152, 8088}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_35*/ {{0x153, 8109}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_37*/ {{0x138, 8129}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_38*/ {{0x138, 8147}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_39*/ {{0x138, 8164}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3A*/ {{0x138, 8181}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3B*/ {{0x138, 8198}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3C*/ {{0x138, 8215}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3D*/ {{0x138, 8232}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3E*/ {{0x138, 8249}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_3F*/ {{0x138, 8266}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_40*/ {{0x138, 8283}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_41*/ {{0x1a7, 8304}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_96*/ {{0x1b1, 8343}, 0x7, 91, 0, 8359, 0},
	/*II_V_66_0F_38_97*/ {{0x1b1, 8375}, 0x7, 91, 0, 8391, 0},
	/*II_V_66_0F_38_98*/ {{0x1b1, 8407}, 0x7, 91, 0, 8420, 0},
	/*II_V_66_0F_38_99*/ {{0x1b2, 8433}, 0x6, 88, 0, 8446, 0},
	/*II_V_66_0F_38_9A*/ {{0x1b1, 8459}, 0x7, 91, 0, 8472, 0},
	/*II_V_66_0F_38_9B*/ {{0x1b2, 8485}, 0x6, 88, 0, 8498, 0},
	/*II_V_66_0F_38_9C*/ {{0x1b1, 8511}, 0x7, 91, 0, 8525, 0},
	/*II_V_66_0F_38_9D*/ {{0x1b2, 8539}, 0x6, 88, 0, 8553, 0},
	/*II_V_66_0F_38_9E*/ {{0x1b1, 8567}, 0x7, 91, 0, 8581, 0},
	/*II_V_66_0F_38_9F*/ {{0x1b2, 8595}, 0x6, 88, 0, 8609, 0},
	/*II_V_66_0F_38_A6*/ {{0x1b1, 8623}, 0x7, 91, 0, 8639, 0},
	/*II_V_66_0F_38_A7*/ {{0x1b1, 8655}, 0x7, 91, 0, 8671, 0},
	/*II_V_66_0F_38_A8*/ {{0x1b1, 8687}, 0x7, 91, 0, 8700, 0},
	/*II_V_66_0F_38_A9*/ {{0x1b2, 8713}, 0x6, 88, 0, 8726, 0},
	/*II_V_66_0F_38_AA*/ {{0x1b1, 8739}, 0x7, 91, 0, 8752, 0},
	/*II_V_66_0F_38_AB*/ {{0x1b2, 8765}, 0x6, 88, 0, 8778, 0},
	/*II_V_66_0F_38_AC*/ {{0x1b1, 8791}, 0x7, 91, 0, 8805, 0},
	/*II_V_66_0F_38_AD*/ {{0x1b2, 8819}, 0x6, 88, 0, 8833, 0},
	/*II_V_66_0F_38_AE*/ {{0x1b1, 8847}, 0x7, 91, 0, 8861, 0},
	/*II_V_66_0F_38_AF*/ {{0x1b2, 8875}, 0x6, 88, 0, 8889, 0},
	/*II_V_66_0F_38_B6*/ {{0x1b1, 8903}, 0x7, 91, 0, 8919, 0},
	/*II_V_66_0F_38_B7*/ {{0x1b1, 8935}, 0x7, 91, 0, 8951, 0},
	/*II_V_66_0F_38_B8*/ {{0x1b1, 8967}, 0x7, 91, 0, 8980, 0},
	/*II_V_66_0F_38_B9*/ {{0x1b2, 8993}, 0x6, 88, 0, 9006, 0},
	/*II_V_66_0F_38_BA*/ {{0x1b1, 9019}, 0x7, 91, 0, 9032, 0},
	/*II_V_66_0F_38_BB*/ {{0x1b2, 9045}, 0x6, 88, 0, 9058, 0},
	/*II_V_66_0F_38_BC*/ {{0x1b1, 9071}, 0x7, 91, 0, 9085, 0},
	/*II_V_66_0F_38_BD*/ {{0x1b2, 9099}, 0x6, 88, 0, 9113, 0},
	/*II_V_66_0F_38_BE*/ {{0x1b1, 9127}, 0x7, 91, 0, 9141, 0},
	/*II_V_66_0F_38_BF*/ {{0x1b2, 9155}, 0x6, 88, 0, 9169, 0},
	/*II_V_66_0F_38_DB*/ {{0x1b4, 9191}, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_DC*/ {{0x1b5, 9208}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_DD*/ {{0x1b5, 9229}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_DE*/ {{0x1b5, 9250}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_38_DF*/ {{0x1b5, 9271}, 0x0, 87, 0, 0, 0},
	/*II_V_66_0F_3A_04*/ {{0x1ba, 7592}, 0x41, 1, 0, 0, 0},
	/*II_V_66_0F_3A_05*/ {{0x1ba, 7603}, 0x41, 1, 0, 0, 0},
	/*II_V_66_0F_3A_06*/ {{0x1bb, 9298}, 0x10, 89, 1, 0, 0},
	/*II_66_0F_3A_08*/ {{0x1a2, 9310}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_08*/ {{0x1ba, 9319}, 0x41, 1, 0, 0, 0},
	/*II_66_0F_3A_09*/ {{0x1a2, 9329}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_09*/ {{0x1ba, 9338}, 0x41, 1, 0, 0, 0},
	/*II_66_0F_3A_0A*/ {{0x1bc, 9348}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0A*/ {{0x184, 9357}, 0x0, 85, 1, 0, 0},
	/*II_66_0F_3A_0B*/ {{0x1bd, 9367}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0B*/ {{0x184, 9376}, 0x0, 86, 1, 0, 0},
	/*II_66_0F_3A_0C*/ {{0x1a2, 9386}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0C*/ {{0x189, 9395}, 0x1, 91, 1, 0, 0},
	/*II_66_0F_3A_0D*/ {{0x1a2, 9405}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0D*/ {{0x189, 9414}, 0x1, 91, 1, 0, 0},
	/*II_66_0F_3A_0E*/ {{0x1a2, 9424}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0E*/ {{0x184, 9433}, 0x0, 87, 1, 0, 0},
	/*II_0F_3A_0F*/ {{0x1be, 9443}, 0x0, 1, 0, 0, 0},
	/*II_66_0F_3A_0F*/ {{0x1bf, 9443}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0F*/ {{0x184, 9452}, 0x0, 87, 1, 0, 0},
	/*II_66_0F_3A_14*/ {{0x1c0, 9462}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_14*/ {{0x1c1, 9470}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_15*/ {{0x1c2, 6344}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_15*/ {{0x1c3, 6352}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_16*/ {{0x1c4, 9479}, 0x0, 1, 0, 0, 9487},
	/*II_V_66_0F_3A_16*/ {{0x1c5, 9495}, 0x46, 1, 0, 9504, 0},
	/*II_66_0F_3A_17*/ {{0x1c6, 9513}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_17*/ {{0x1c7, 9524}, 0x40, 1, 0, 0, 0},
	/*II_V_66_0F_3A_18*/ {{0x1bb, 9536}, 0x10, 87, 1, 0, 0},
	/*II_V_66_0F_3A_19*/ {{0x1c8, 9549}, 0x50, 1, 0, 0, 0},
	/*II_66_0F_3A_20*/ {{0x1c9, 9563}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_20*/ {{0x184, 9571}, 0x0, 80, 1, 0, 0},
	/*II_66_0F_3A_21*/ {{0x1bc, 9580}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_21*/ {{0x184, 9590}, 0x0, 85, 1, 0, 0},
	/*II_66_0F_3A_22*/ {{0x1ca, 9601}, 0x0, 1, 0, 0, 9609},
	/*II_V_66_0F_3A_22*/ {{0x184, 9617}, 0x6, 73, 1, 9626, 0},
	/*II_66_0F_3A_40*/ {{0x1a2, 9635}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_40*/ {{0x189, 9641}, 0x1, 91, 1, 0, 0},
	/*II_66_0F_3A_41*/ {{0x1a2, 9648}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_41*/ {{0x184, 9654}, 0x0, 87, 1, 0, 0},
	/*II_66_0F_3A_42*/ {{0x1a2, 9661}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_42*/ {{0x184, 9670}, 0x0, 87, 1, 0, 0},
	/*II_66_0F_3A_44*/ {{0x1cb, 9680}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_44*/ {{0x1cc, 9691}, 0x0, 87, 1, 0, 0},
	/*II_V_66_0F_3A_4A*/ {{0x189, 9703}, 0x1, 91, 37, 0, 0},
	/*II_V_66_0F_3A_4B*/ {{0x189, 9714}, 0x1, 91, 37, 0, 0},
	/*II_V_66_0F_3A_4C*/ {{0x184, 9725}, 0x0, 87, 35, 0, 0},
	/*II_66_0F_3A_60*/ {{0x1cd, 9736}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_60*/ {{0x163, 9747}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_61*/ {{0x1cd, 9759}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_61*/ {{0x163, 9770}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_62*/ {{0x1cd, 9782}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_62*/ {{0x163, 9793}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_63*/ {{0x1cd, 9805}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_63*/ {{0x163, 9816}, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_DF*/ {{0x1ce, 9828}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_DF*/ {{0x1cf, 9845}, 0x40, 1, 0, 0, 0},
	/*II_V_66_0F_71_02*/ {{0x1d2, 6476}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_71_04*/ {{0x1d2, 6735}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_71_06*/ {{0x1d2, 7049}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_72_02*/ {{0x1d2, 6491}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_72_04*/ {{0x1d2, 6750}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_72_06*/ {{0x1d2, 7064}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_02*/ {{0x1d2, 6506}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_03*/ {{0x1d2, 9871}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_06*/ {{0x1d2, 7079}, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_07*/ {{0x1d2, 9888}, 0x0, 1, 0, 0, 0},
	/*II_0F_AE_00*/ {{0x173, 9897}, 0x0, 0, 0, 0, 9905},
	/*II_0F_AE_01*/ {{0x173, 9925}, 0x0, 0, 0, 0, 9934},
	/*II_V_0F_AE_02*/ {{0x1d5, 9974}, 0x40, 0, 0, 0, 0},
	/*II_V_0F_AE_03*/ {{0x1d5, 10003}, 0x40, 0, 0, 0, 0}
};

_InstNode InstructionsTree[5688] = {
/* 0 - _00 */  0x2000,
/* 1 - _01 */  0x2001,
/* 2 - _02 */  0x2002,
/* 3 - _03 */  0x2003,
/* 4 - _04 */  0x2004,
/* 5 - _05 */  0x2005,
/* 6 - _06 */  0x2006,
/* 7 - _07 */  0x2007,
/* 8 - _08 */  0x2008,
/* 9 - _09 */  0x2009,
/* a - _0A */  0x200a,
/* b - _0B */  0x200b,
/* c - _0C */  0x200c,
/* d - _0D */  0x200d,
/* e - _0E */  0x200e,
/* f - _0F */  0xa100,
/* 10 - _10 */  0x200f,
/* 11 - _11 */  0x2010,
/* 12 - _12 */  0x2011,
/* 13 - _13 */  0x2012,
/* 14 - _14 */  0x2013,
/* 15 - _15 */  0x2014,
/* 16 - _16 */  0x2015,
/* 17 - _17 */  0x2016,
/* 18 - _18 */  0x2017,
/* 19 - _19 */  0x2018,
/* 1a - _1A */  0x2019,
/* 1b - _1B */  0x201a,
/* 1c - _1C */  0x201b,
/* 1d - _1D */  0x201c,
/* 1e - _1E */  0x201d,
/* 1f - _1F */  0x201e,
/* 20 - _20 */  0x201f,
/* 21 - _21 */  0x2020,
/* 22 - _22 */  0x2021,
/* 23 - _23 */  0x2022,
/* 24 - _24 */  0x2023,
/* 25 - _25 */  0x2024,
/* 26 -  */  0,
/* 27 - _27 */  0x2025,
/* 28 - _28 */  0x2026,
/* 29 - _29 */  0x2027,
/* 2a - _2A */  0x2028,
/* 2b - _2B */  0x2029,
/* 2c - _2C */  0x202a,
/* 2d - _2D */  0x202b,
/* 2e -  */  0,
/* 2f - _2F */  0x202c,
/* 30 - _30 */  0x202d,
/* 31 - _31 */  0x202e,
/* 32 - _32 */  0x202f,
/* 33 - _33 */  0x2030,
/* 34 - _34 */  0x2031,
/* 35 - _35 */  0x2032,
/* 36 -  */  0,
/* 37 - _37 */  0x2033,
/* 38 - _38 */  0x2034,
/* 39 - _39 */  0x2035,
/* 3a - _3A */  0x2036,
/* 3b - _3B */  0x2037,
/* 3c - _3C */  0x2038,
/* 3d - _3D */  0x2039,
/* 3e -  */  0,
/* 3f - _3F */  0x203a,
/* 40 - _40 */  0x203b,
/* 41 - _40 */  0x203c,
/* 42 - _40 */  0x203d,
/* 43 - _40 */  0x203e,
/* 44 - _40 */  0x203f,
/* 45 - _40 */  0x2040,
/* 46 - _40 */  0x2041,
/* 47 - _40 */  0x2042,
/* 48 - _48 */  0x2043,
/* 49 - _48 */  0x2044,
/* 4a - _48 */  0x2045,
/* 4b - _48 */  0x2046,
/* 4c - _48 */  0x2047,
/* 4d - _48 */  0x2048,
/* 4e - _48 */  0x2049,
/* 4f - _48 */  0x204a,
/* 50 - _50 */  0x204b,
/* 51 - _50 */  0x204c,
/* 52 - _50 */  0x204d,
/* 53 - _50 */  0x204e,
/* 54 - _50 */  0x204f,
/* 55 - _50 */  0x2050,
/* 56 - _50 */  0x2051,
/* 57 - _50 */  0x2052,
/* 58 - _58 */  0x2053,
/* 59 - _58 */  0x2054,
/* 5a - _58 */  0x2055,
/* 5b - _58 */  0x2056,
/* 5c - _58 */  0x2057,
/* 5d - _58 */  0x2058,
/* 5e - _58 */  0x2059,
/* 5f - _58 */  0x205a,
/* 60 - _60 */  0x205b,
/* 61 - _61 */  0x205c,
/* 62 - _62 */  0x205d,
/* 63 - _63 */  0x605e,
/* 64 -  */  0,
/* 65 -  */  0,
/* 66 -  */  0,
/* 67 -  */  0,
/* 68 - _68 */  0x205f,
/* 69 - _69 */  0x4000,
/* 6a - _6A */  0x2060,
/* 6b - _6B */  0x4001,
/* 6c - _6C */  0x2061,
/* 6d - _6D */  0x2062,
/* 6e - _6E */  0x2063,
/* 6f - _6F */  0x2064,
/* 70 - _70 */  0x2065,
/* 71 - _71 */  0x2066,
/* 72 - _72 */  0x2067,
/* 73 - _73 */  0x2068,
/* 74 - _74 */  0x2069,
/* 75 - _75 */  0x206a,
/* 76 - _76 */  0x206b,
/* 77 - _77 */  0x206c,
/* 78 - _78 */  0x206d,
/* 79 - _79 */  0x206e,
/* 7a - _7A */  0x206f,
/* 7b - _7B */  0x2070,
/* 7c - _7C */  0x2071,
/* 7d - _7D */  0x2072,
/* 7e - _7E */  0x2073,
/* 7f - _7F */  0x2074,
/* 80 - _80 */  0x8200,
/* 81 - _81 */  0x8208,
/* 82 - _82 */  0x8210,
/* 83 - _83 */  0x8218,
/* 84 - _84 */  0x2075,
/* 85 - _85 */  0x2076,
/* 86 - _86 */  0x2077,
/* 87 - _87 */  0x2078,
/* 88 - _88 */  0x2079,
/* 89 - _89 */  0x207a,
/* 8a - _8A */  0x207b,
/* 8b - _8B */  0x207c,
/* 8c - _8C */  0x207d,
/* 8d - _8D */  0x607e,
/* 8e - _8E */  0x207f,
/* 8f - _8F */  0x8220,
/* 90 - _90 */  0x6080,
/* 91 - _91 */  0x2081,
/* 92 - _92 */  0x2082,
/* 93 - _93 */  0x2083,
/* 94 - _94 */  0x2084,
/* 95 - _95 */  0x2085,
/* 96 - _96 */  0x2086,
/* 97 - _97 */  0x2087,
/* 98 - _98 */  0x4002,
/* 99 - _99 */  0x4003,
/* 9a - _9A */  0x2088,
/* 9b -  */  0,
/* 9c - _9C */  0x2089,
/* 9d - _9D */  0x208a,
/* 9e - _9E */  0x208b,
/* 9f - _9F */  0x208c,
/* a0 - _A0 */  0x208d,
/* a1 - _A1 */  0x208e,
/* a2 - _A2 */  0x208f,
/* a3 - _A3 */  0x2090,
/* a4 - _A4 */  0x2091,
/* a5 - _A5 */  0x2092,
/* a6 - _A6 */  0x2093,
/* a7 - _A7 */  0x2094,
/* a8 - _A8 */  0x2095,
/* a9 - _A9 */  0x2096,
/* aa - _AA */  0x2097,
/* ab - _AB */  0x2098,
/* ac - _AC */  0x2099,
/* ad - _AD */  0x209a,
/* ae - _AE */  0x209b,
/* af - _AF */  0x209c,
/* b0 - _B0 */  0x209d,
/* b1 - _B0 */  0x209e,
/* b2 - _B0 */  0x209f,
/* b3 - _B0 */  0x20a0,
/* b4 - _B0 */  0x20a1,
/* b5 - _B0 */  0x20a2,
/* b6 - _B0 */  0x20a3,
/* b7 - _B0 */  0x20a4,
/* b8 - _B8 */  0x20a5,
/* b9 - _B8 */  0x20a6,
/* ba - _B8 */  0x20a7,
/* bb - _B8 */  0x20a8,
/* bc - _B8 */  0x20a9,
/* bd - _B8 */  0x20aa,
/* be - _B8 */  0x20ab,
/* bf - _B8 */  0x20ac,
/* c0 - _C0 */  0x8228,
/* c1 - _C1 */  0x8230,
/* c2 - _C2 */  0x20ad,
/* c3 - _C3 */  0x20ae,
/* c4 - _C4 */  0x20af,
/* c5 - _C5 */  0x20b0,
/* c6 - _C6 */  0xc238,
/* c7 - _C7 */  0xc280,
/* c8 - _C8 */  0x20b1,
/* c9 - _C9 */  0x20b2,
/* ca - _CA */  0x20b3,
/* cb - _CB */  0x20b4,
/* cc - _CC */  0x20b5,
/* cd - _CD */  0x20b6,
/* ce - _CE */  0x20b7,
/* cf - _CF */  0x20b8,
/* d0 - _D0 */  0x82c8,
/* d1 - _D1 */  0x82d0,
/* d2 - _D2 */  0x82d8,
/* d3 - _D3 */  0x82e0,
/* d4 - _D4 */  0x20b9,
/* d5 - _D5 */  0x20ba,
/* d6 - _D6 */  0x20bb,
/* d7 - _D7 */  0x20bc,
/* d8 - _D8 */  0xc2e8,
/* d9 - _D9 */  0xc330,
/* da - _DA */  0xc378,
/* db - _DB */  0xc3c0,
/* dc - _DC */  0xc408,
/* dd - _DD */  0xc450,
/* de - _DE */  0xc498,
/* df - _DF */  0xc4e0,
/* e0 - _E0 */  0x20bd,
/* e1 - _E1 */  0x20be,
/* e2 - _E2 */  0x20bf,
/* e3 - _E3 */  0x4004,
/* e4 - _E4 */  0x20c0,
/* e5 - _E5 */  0x20c1,
/* e6 - _E6 */  0x20c2,
/* e7 - _E7 */  0x20c3,
/* e8 - _E8 */  0x20c4,
/* e9 - _E9 */  0x20c5,
/* ea - _EA */  0x20c6,
/* eb - _EB */  0x20c7,
/* ec - _EC */  0x20c8,
/* ed - _ED */  0x20c9,
/* ee - _EE */  0x20ca,
/* ef - _EF */  0x20cb,
/* f0 -  */  0,
/* f1 - _F1 */  0x20cc,
/* f2 -  */  0,
/* f3 -  */  0,
/* f4 - _F4 */  0x20cd,
/* f5 - _F5 */  0x20ce,
/* f6 - _F6 */  0x8528,
/* f7 - _F7 */  0x8530,
/* f8 - _F8 */  0x20cf,
/* f9 - _F9 */  0x20d0,
/* fa - _FA */  0x20d1,
/* fb - _FB */  0x20d2,
/* fc - _FC */  0x20d3,
/* fd - _FD */  0x20d4,
/* fe - _FE */  0x8538,
/* ff - _FF */  0x8540,
/* 100 - _0F_00 */  0x8548,
/* 101 - _0F_01 */  0xc550,
/* 102 - _0F_02 */  0x20d5,
/* 103 - _0F_03 */  0x20d6,
/* 104 -  */  0,
/* 105 - _0F_05 */  0x20d7,
/* 106 - _0F_06 */  0x20d8,
/* 107 - _0F_07 */  0x20d9,
/* 108 - _0F_08 */  0x20da,
/* 109 - _0F_09 */  0x20db,
/* 10a -  */  0,
/* 10b - _0F_0B */  0x20dc,
/* 10c -  */  0,
/* 10d - _0F_0D */  0x8598,
/* 10e - _0F_0E */  0x20dd,
/* 10f - _0F_0F */  0xa5a0,
/* 110 - _0F_10 */  0xe6a0,
/* 111 - _0F_11 */  0xe6ac,
/* 112 - _0F_12 */  0xe6b8,
/* 113 - _0F_13 */  0xe6c4,
/* 114 - _0F_14 */  0xe6d0,
/* 115 - _0F_15 */  0xe6dc,
/* 116 - _0F_16 */  0xe6e8,
/* 117 - _0F_17 */  0xe6f4,
/* 118 - _0F_18 */  0x8700,
/* 119 -  */  0,
/* 11a -  */  0,
/* 11b -  */  0,
/* 11c -  */  0,
/* 11d -  */  0,
/* 11e -  */  0,
/* 11f - _0F_1F */  0x20de,
/* 120 - _0F_20 */  0x20df,
/* 121 - _0F_21 */  0x20e0,
/* 122 - _0F_22 */  0x20e1,
/* 123 - _0F_23 */  0x20e2,
/* 124 -  */  0,
/* 125 -  */  0,
/* 126 -  */  0,
/* 127 -  */  0,
/* 128 - _0F_28 */  0xe708,
/* 129 - _0F_29 */  0xe714,
/* 12a - _0F_2A */  0xe720,
/* 12b - _0F_2B */  0xe72c,
/* 12c - _0F_2C */  0xe738,
/* 12d - _0F_2D */  0xe744,
/* 12e - _0F_2E */  0xe750,
/* 12f - _0F_2F */  0xe75c,
/* 130 - _0F_30 */  0x20e3,
/* 131 - _0F_31 */  0x20e4,
/* 132 - _0F_32 */  0x20e5,
/* 133 - _0F_33 */  0x20e6,
/* 134 - _0F_34 */  0x20e7,
/* 135 - _0F_35 */  0x20e8,
/* 136 -  */  0,
/* 137 - _0F_37 */  0x20e9,
/* 138 - _0F_38 */  0xa768,
/* 139 -  */  0,
/* 13a - _0F_3A */  0xa868,
/* 13b -  */  0,
/* 13c -  */  0,
/* 13d -  */  0,
/* 13e -  */  0,
/* 13f -  */  0,
/* 140 - _0F_40 */  0x20ea,
/* 141 - _0F_41 */  0x20eb,
/* 142 - _0F_42 */  0x20ec,
/* 143 - _0F_43 */  0x20ed,
/* 144 - _0F_44 */  0x20ee,
/* 145 - _0F_45 */  0x20ef,
/* 146 - _0F_46 */  0x20f0,
/* 147 - _0F_47 */  0x20f1,
/* 148 - _0F_48 */  0x20f2,
/* 149 - _0F_49 */  0x20f3,
/* 14a - _0F_4A */  0x20f4,
/* 14b - _0F_4B */  0x20f5,
/* 14c - _0F_4C */  0x20f6,
/* 14d - _0F_4D */  0x20f7,
/* 14e - _0F_4E */  0x20f8,
/* 14f - _0F_4F */  0x20f9,
/* 150 - _0F_50 */  0xe968,
/* 151 - _0F_51 */  0xe974,
/* 152 - _0F_52 */  0xe980,
/* 153 - _0F_53 */  0xe98c,
/* 154 - _0F_54 */  0xe998,
/* 155 - _0F_55 */  0xe9a4,
/* 156 - _0F_56 */  0xe9b0,
/* 157 - _0F_57 */  0xe9bc,
/* 158 - _0F_58 */  0xe9c8,
/* 159 - _0F_59 */  0xe9d4,
/* 15a - _0F_5A */  0xe9e0,
/* 15b - _0F_5B */  0xe9ec,
/* 15c - _0F_5C */  0xe9f8,
/* 15d - _0F_5D */  0xea04,
/* 15e - _0F_5E */  0xea10,
/* 15f - _0F_5F */  0xea1c,
/* 160 - _0F_60 */  0xea28,
/* 161 - _0F_61 */  0xea34,
/* 162 - _0F_62 */  0xea40,
/* 163 - _0F_63 */  0xea4c,
/* 164 - _0F_64 */  0xea58,
/* 165 - _0F_65 */  0xea64,
/* 166 - _0F_66 */  0xea70,
/* 167 - _0F_67 */  0xea7c,
/* 168 - _0F_68 */  0xea88,
/* 169 - _0F_69 */  0xea94,
/* 16a - _0F_6A */  0xeaa0,
/* 16b - _0F_6B */  0xeaac,
/* 16c - _0F_6C */  0xeab8,
/* 16d - _0F_6D */  0xeac4,
/* 16e - _0F_6E */  0xead0,
/* 16f - _0F_6F */  0xeadc,
/* 170 - _0F_70 */  0xeae8,
/* 171 - _0F_71 */  0x8af4,
/* 172 - _0F_72 */  0x8afc,
/* 173 - _0F_73 */  0x8b04,
/* 174 - _0F_74 */  0xeb0c,
/* 175 - _0F_75 */  0xeb18,
/* 176 - _0F_76 */  0xeb24,
/* 177 - _0F_77 */  0xeb30,
/* 178 - _0F_78 */  0xeb3c,
/* 179 - _0F_79 */  0xeb48,
/* 17a - _0F_7A */  0xab54,
/* 17b -  */  0,
/* 17c - _0F_7C */  0xec54,
/* 17d - _0F_7D */  0xec60,
/* 17e - _0F_7E */  0xec6c,
/* 17f - _0F_7F */  0xec78,
/* 180 - _0F_80 */  0x20fa,
/* 181 - _0F_81 */  0x20fb,
/* 182 - _0F_82 */  0x20fc,
/* 183 - _0F_83 */  0x20fd,
/* 184 - _0F_84 */  0x20fe,
/* 185 - _0F_85 */  0x20ff,
/* 186 - _0F_86 */  0x2100,
/* 187 - _0F_87 */  0x2101,
/* 188 - _0F_88 */  0x2102,
/* 189 - _0F_89 */  0x2103,
/* 18a - _0F_8A */  0x2104,
/* 18b - _0F_8B */  0x2105,
/* 18c - _0F_8C */  0x2106,
/* 18d - _0F_8D */  0x2107,
/* 18e - _0F_8E */  0x2108,
/* 18f - _0F_8F */  0x2109,
/* 190 - _0F_90 */  0x210a,
/* 191 - _0F_91 */  0x210b,
/* 192 - _0F_92 */  0x210c,
/* 193 - _0F_93 */  0x210d,
/* 194 - _0F_94 */  0x210e,
/* 195 - _0F_95 */  0x210f,
/* 196 - _0F_96 */  0x2110,
/* 197 - _0F_97 */  0x2111,
/* 198 - _0F_98 */  0x2112,
/* 199 - _0F_99 */  0x2113,
/* 19a - _0F_9A */  0x2114,
/* 19b - _0F_9B */  0x2115,
/* 19c - _0F_9C */  0x2116,
/* 19d - _0F_9D */  0x2117,
/* 19e - _0F_9E */  0x2118,
/* 19f - _0F_9F */  0x2119,
/* 1a0 - _0F_A0 */  0x211a,
/* 1a1 - _0F_A1 */  0x211b,
/* 1a2 - _0F_A2 */  0x211c,
/* 1a3 - _0F_A3 */  0x211d,
/* 1a4 - _0F_A4 */  0x4005,
/* 1a5 - _0F_A5 */  0x4006,
/* 1a6 -  */  0,
/* 1a7 -  */  0,
/* 1a8 - _0F_A8 */  0x211e,
/* 1a9 - _0F_A9 */  0x211f,
/* 1aa - _0F_AA */  0x2120,
/* 1ab - _0F_AB */  0x2121,
/* 1ac - _0F_AC */  0x4007,
/* 1ad - _0F_AD */  0x4008,
/* 1ae - _0F_AE */  0x8c84,
/* 1af - _0F_AF */  0x2122,
/* 1b0 - _0F_B0 */  0x2123,
/* 1b1 - _0F_B1 */  0x2124,
/* 1b2 - _0F_B2 */  0x2125,
/* 1b3 - _0F_B3 */  0x2126,
/* 1b4 - _0F_B4 */  0x2127,
/* 1b5 - _0F_B5 */  0x2128,
/* 1b6 - _0F_B6 */  0x2129,
/* 1b7 - _0F_B7 */  0x212a,
/* 1b8 - _0F_B8 */  0xec8c,
/* 1b9 - _0F_B9 */  0x212b,
/* 1ba - _0F_BA */  0x8c98,
/* 1bb - _0F_BB */  0x212c,
/* 1bc - _0F_BC */  0xeca0,
/* 1bd - _0F_BD */  0xecac,
/* 1be - _0F_BE */  0x212d,
/* 1bf - _0F_BF */  0x212e,
/* 1c0 - _0F_C0 */  0x212f,
/* 1c1 - _0F_C1 */  0x2130,
/* 1c2 - _0F_C2 */  0xecb8,
/* 1c3 - _0F_C3 */  0x2131,
/* 1c4 - _0F_C4 */  0xecc4,
/* 1c5 - _0F_C5 */  0xecd0,
/* 1c6 - _0F_C6 */  0xecdc,
/* 1c7 - _0F_C7 */  0x8ce8,
/* 1c8 - _0F_C8 */  0x2132,
/* 1c9 - _0F_C8 */  0x2133,
/* 1ca - _0F_C8 */  0x2134,
/* 1cb - _0F_C8 */  0x2135,
/* 1cc - _0F_C8 */  0x2136,
/* 1cd - _0F_C8 */  0x2137,
/* 1ce - _0F_C8 */  0x2138,
/* 1cf - _0F_C8 */  0x2139,
/* 1d0 - _0F_D0 */  0xecf0,
/* 1d1 - _0F_D1 */  0xecfc,
/* 1d2 - _0F_D2 */  0xed08,
/* 1d3 - _0F_D3 */  0xed14,
/* 1d4 - _0F_D4 */  0xed20,
/* 1d5 - _0F_D5 */  0xed2c,
/* 1d6 - _0F_D6 */  0xed38,
/* 1d7 - _0F_D7 */  0xed44,
/* 1d8 - _0F_D8 */  0xed50,
/* 1d9 - _0F_D9 */  0xed5c,
/* 1da - _0F_DA */  0xed68,
/* 1db - _0F_DB */  0xed74,
/* 1dc - _0F_DC */  0xed80,
/* 1dd - _0F_DD */  0xed8c,
/* 1de - _0F_DE */  0xed98,
/* 1df - _0F_DF */  0xeda4,
/* 1e0 - _0F_E0 */  0xedb0,
/* 1e1 - _0F_E1 */  0xedbc,
/* 1e2 - _0F_E2 */  0xedc8,
/* 1e3 - _0F_E3 */  0xedd4,
/* 1e4 - _0F_E4 */  0xede0,
/* 1e5 - _0F_E5 */  0xedec,
/* 1e6 - _0F_E6 */  0xedf8,
/* 1e7 - _0F_E7 */  0xee04,
/* 1e8 - _0F_E8 */  0xee10,
/* 1e9 - _0F_E9 */  0xee1c,
/* 1ea - _0F_EA */  0xee28,
/* 1eb - _0F_EB */  0xee34,
/* 1ec - _0F_EC */  0xee40,
/* 1ed - _0F_ED */  0xee4c,
/* 1ee - _0F_EE */  0xee58,
/* 1ef - _0F_EF */  0xee64,
/* 1f0 - _0F_F0 */  0xee70,
/* 1f1 - _0F_F1 */  0xee7c,
/* 1f2 - _0F_F2 */  0xee88,
/* 1f3 - _0F_F3 */  0xee94,
/* 1f4 - _0F_F4 */  0xeea0,
/* 1f5 - _0F_F5 */  0xeeac,
/* 1f6 - _0F_F6 */  0xeeb8,
/* 1f7 - _0F_F7 */  0xeec4,
/* 1f8 - _0F_F8 */  0xeed0,
/* 1f9 - _0F_F9 */  0xeedc,
/* 1fa - _0F_FA */  0xeee8,
/* 1fb - _0F_FB */  0xeef4,
/* 1fc - _0F_FC */  0xef00,
/* 1fd - _0F_FD */  0xef0c,
/* 1fe - _0F_FE */  0xef18,
/* 1ff -  */  0,
/* 200 - _80_00 */  0x213a,
/* 201 - _80_01 */  0x213b,
/* 202 - _80_02 */  0x213c,
/* 203 - _80_03 */  0x213d,
/* 204 - _80_04 */  0x213e,
/* 205 - _80_05 */  0x213f,
/* 206 - _80_06 */  0x2140,
/* 207 - _80_07 */  0x2141,
/* 208 - _81_00 */  0x2142,
/* 209 - _81_01 */  0x2143,
/* 20a - _81_02 */  0x2144,
/* 20b - _81_03 */  0x2145,
/* 20c - _81_04 */  0x2146,
/* 20d - _81_05 */  0x2147,
/* 20e - _81_06 */  0x2148,
/* 20f - _81_07 */  0x2149,
/* 210 - _82_00 */  0x214a,
/* 211 - _82_01 */  0x214b,
/* 212 - _82_02 */  0x214c,
/* 213 - _82_03 */  0x214d,
/* 214 - _82_04 */  0x214e,
/* 215 - _82_05 */  0x214f,
/* 216 - _82_06 */  0x2150,
/* 217 - _82_07 */  0x2151,
/* 218 - _83_00 */  0x2152,
/* 219 - _83_01 */  0x2153,
/* 21a - _83_02 */  0x2154,
/* 21b - _83_03 */  0x2155,
/* 21c - _83_04 */  0x2156,
/* 21d - _83_05 */  0x2157,
/* 21e - _83_06 */  0x2158,
/* 21f - _83_07 */  0x2159,
/* 220 - _8F_00 */  0x215a,
/* 221 -  */  0,
/* 222 -  */  0,
/* 223 -  */  0,
/* 224 -  */  0,
/* 225 -  */  0,
/* 226 -  */  0,
/* 227 -  */  0,
/* 228 - _C0_00 */  0x215b,
/* 229 - _C0_01 */  0x215c,
/* 22a - _C0_02 */  0x215d,
/* 22b - _C0_03 */  0x215e,
/* 22c - _C0_04 */  0x215f,
/* 22d - _C0_05 */  0x2160,
/* 22e - _C0_06 */  0x2161,
/* 22f - _C0_07 */  0x2162,
/* 230 - _C1_00 */  0x2163,
/* 231 - _C1_01 */  0x2164,
/* 232 - _C1_02 */  0x2165,
/* 233 - _C1_03 */  0x2166,
/* 234 - _C1_04 */  0x2167,
/* 235 - _C1_05 */  0x2168,
/* 236 - _C1_06 */  0x2169,
/* 237 - _C1_07 */  0x216a,
/* 238 - _C6_00 */  0x216b,
/* 239 -  */  0,
/* 23a -  */  0,
/* 23b -  */  0,
/* 23c -  */  0,
/* 23d -  */  0,
/* 23e -  */  0,
/* 23f -  */  0,
/* 240 -  */  0,
/* 241 -  */  0,
/* 242 -  */  0,
/* 243 -  */  0,
/* 244 -  */  0,
/* 245 -  */  0,
/* 246 -  */  0,
/* 247 -  */  0,
/* 248 -  */  0,
/* 249 -  */  0,
/* 24a -  */  0,
/* 24b -  */  0,
/* 24c -  */  0,
/* 24d -  */  0,
/* 24e -  */  0,
/* 24f -  */  0,
/* 250 -  */  0,
/* 251 -  */  0,
/* 252 -  */  0,
/* 253 -  */  0,
/* 254 -  */  0,
/* 255 -  */  0,
/* 256 -  */  0,
/* 257 -  */  0,
/* 258 -  */  0,
/* 259 -  */  0,
/* 25a -  */  0,
/* 25b -  */  0,
/* 25c -  */  0,
/* 25d -  */  0,
/* 25e -  */  0,
/* 25f -  */  0,
/* 260 -  */  0,
/* 261 -  */  0,
/* 262 -  */  0,
/* 263 -  */  0,
/* 264 -  */  0,
/* 265 -  */  0,
/* 266 -  */  0,
/* 267 -  */  0,
/* 268 -  */  0,
/* 269 -  */  0,
/* 26a -  */  0,
/* 26b -  */  0,
/* 26c -  */  0,
/* 26d -  */  0,
/* 26e -  */  0,
/* 26f -  */  0,
/* 270 -  */  0,
/* 271 -  */  0,
/* 272 -  */  0,
/* 273 -  */  0,
/* 274 -  */  0,
/* 275 -  */  0,
/* 276 -  */  0,
/* 277 -  */  0,
/* 278 - _C6_F8 */  0x216c,
/* 279 -  */  0,
/* 27a -  */  0,
/* 27b -  */  0,
/* 27c -  */  0,
/* 27d -  */  0,
/* 27e -  */  0,
/* 27f -  */  0,
/* 280 - _C7_00 */  0x216d,
/* 281 -  */  0,
/* 282 -  */  0,
/* 283 -  */  0,
/* 284 -  */  0,
/* 285 -  */  0,
/* 286 -  */  0,
/* 287 -  */  0,
/* 288 -  */  0,
/* 289 -  */  0,
/* 28a -  */  0,
/* 28b -  */  0,
/* 28c -  */  0,
/* 28d -  */  0,
/* 28e -  */  0,
/* 28f -  */  0,
/* 290 -  */  0,
/* 291 -  */  0,
/* 292 -  */  0,
/* 293 -  */  0,
/* 294 -  */  0,
/* 295 -  */  0,
/* 296 -  */  0,
/* 297 -  */  0,
/* 298 -  */  0,
/* 299 -  */  0,
/* 29a -  */  0,
/* 29b -  */  0,
/* 29c -  */  0,
/* 29d -  */  0,
/* 29e -  */  0,
/* 29f -  */  0,
/* 2a0 -  */  0,
/* 2a1 -  */  0,
/* 2a2 -  */  0,
/* 2a3 -  */  0,
/* 2a4 -  */  0,
/* 2a5 -  */  0,
/* 2a6 -  */  0,
/* 2a7 -  */  0,
/* 2a8 -  */  0,
/* 2a9 -  */  0,
/* 2aa -  */  0,
/* 2ab -  */  0,
/* 2ac -  */  0,
/* 2ad -  */  0,
/* 2ae -  */  0,
/* 2af -  */  0,
/* 2b0 -  */  0,
/* 2b1 -  */  0,
/* 2b2 -  */  0,
/* 2b3 -  */  0,
/* 2b4 -  */  0,
/* 2b5 -  */  0,
/* 2b6 -  */  0,
/* 2b7 -  */  0,
/* 2b8 -  */  0,
/* 2b9 -  */  0,
/* 2ba -  */  0,
/* 2bb -  */  0,
/* 2bc -  */  0,
/* 2bd -  */  0,
/* 2be -  */  0,
/* 2bf -  */  0,
/* 2c0 - _C7_F8 */  0x216e,
/* 2c1 -  */  0,
/* 2c2 -  */  0,
/* 2c3 -  */  0,
/* 2c4 -  */  0,
/* 2c5 -  */  0,
/* 2c6 -  */  0,
/* 2c7 -  */  0,
/* 2c8 - _D0_00 */  0x216f,
/* 2c9 - _D0_01 */  0x2170,
/* 2ca - _D0_02 */  0x2171,
/* 2cb - _D0_03 */  0x2172,
/* 2cc - _D0_04 */  0x2173,
/* 2cd - _D0_05 */  0x2174,
/* 2ce - _D0_06 */  0x2175,
/* 2cf - _D0_07 */  0x2176,
/* 2d0 - _D1_00 */  0x2177,
/* 2d1 - _D1_01 */  0x2178,
/* 2d2 - _D1_02 */  0x2179,
/* 2d3 - _D1_03 */  0x217a,
/* 2d4 - _D1_04 */  0x217b,
/* 2d5 - _D1_05 */  0x217c,
/* 2d6 - _D1_06 */  0x217d,
/* 2d7 - _D1_07 */  0x217e,
/* 2d8 - _D2_00 */  0x217f,
/* 2d9 - _D2_01 */  0x2180,
/* 2da - _D2_02 */  0x2181,
/* 2db - _D2_03 */  0x2182,
/* 2dc - _D2_04 */  0x2183,
/* 2dd - _D2_05 */  0x2184,
/* 2de - _D2_06 */  0x2185,
/* 2df - _D2_07 */  0x2186,
/* 2e0 - _D3_00 */  0x2187,
/* 2e1 - _D3_01 */  0x2188,
/* 2e2 - _D3_02 */  0x2189,
/* 2e3 - _D3_03 */  0x218a,
/* 2e4 - _D3_04 */  0x218b,
/* 2e5 - _D3_05 */  0x218c,
/* 2e6 - _D3_06 */  0x218d,
/* 2e7 - _D3_07 */  0x218e,
/* 2e8 - _D8_00 */  0x218f,
/* 2e9 - _D8_01 */  0x2190,
/* 2ea - _D8_02 */  0x2191,
/* 2eb - _D8_03 */  0x2192,
/* 2ec - _D8_04 */  0x2193,
/* 2ed - _D8_05 */  0x2194,
/* 2ee - _D8_06 */  0x2195,
/* 2ef - _D8_07 */  0x2196,
/* 2f0 - _D8_C0 */  0x2197,
/* 2f1 - _D8_C0 */  0x2198,
/* 2f2 - _D8_C0 */  0x2199,
/* 2f3 - _D8_C0 */  0x219a,
/* 2f4 - _D8_C0 */  0x219b,
/* 2f5 - _D8_C0 */  0x219c,
/* 2f6 - _D8_C0 */  0x219d,
/* 2f7 - _D8_C0 */  0x219e,
/* 2f8 - _D8_C8 */  0x219f,
/* 2f9 - _D8_C8 */  0x21a0,
/* 2fa - _D8_C8 */  0x21a1,
/* 2fb - _D8_C8 */  0x21a2,
/* 2fc - _D8_C8 */  0x21a3,
/* 2fd - _D8_C8 */  0x21a4,
/* 2fe - _D8_C8 */  0x21a5,
/* 2ff - _D8_C8 */  0x21a6,
/* 300 - _D8_D0 */  0x21a7,
/* 301 - _D8_D0 */  0x21a8,
/* 302 - _D8_D0 */  0x21a9,
/* 303 - _D8_D0 */  0x21aa,
/* 304 - _D8_D0 */  0x21ab,
/* 305 - _D8_D0 */  0x21ac,
/* 306 - _D8_D0 */  0x21ad,
/* 307 - _D8_D0 */  0x21ae,
/* 308 - _D8_D8 */  0x21af,
/* 309 - _D8_D9 */  0x21b0,
/* 30a - _D8_D8 */  0x21b1,
/* 30b - _D8_D8 */  0x21b2,
/* 30c - _D8_D8 */  0x21b3,
/* 30d - _D8_D8 */  0x21b4,
/* 30e - _D8_D8 */  0x21b5,
/* 30f - _D8_D8 */  0x21b6,
/* 310 - _D8_E0 */  0x21b7,
/* 311 - _D8_E0 */  0x21b8,
/* 312 - _D8_E0 */  0x21b9,
/* 313 - _D8_E0 */  0x21ba,
/* 314 - _D8_E0 */  0x21bb,
/* 315 - _D8_E0 */  0x21bc,
/* 316 - _D8_E0 */  0x21bd,
/* 317 - _D8_E0 */  0x21be,
/* 318 - _D8_E8 */  0x21bf,
/* 319 - _D8_E8 */  0x21c0,
/* 31a - _D8_E8 */  0x21c1,
/* 31b - _D8_E8 */  0x21c2,
/* 31c - _D8_E8 */  0x21c3,
/* 31d - _D8_E8 */  0x21c4,
/* 31e - _D8_E8 */  0x21c5,
/* 31f - _D8_E8 */  0x21c6,
/* 320 - _D8_F0 */  0x21c7,
/* 321 - _D8_F0 */  0x21c8,
/* 322 - _D8_F0 */  0x21c9,
/* 323 - _D8_F0 */  0x21ca,
/* 324 - _D8_F0 */  0x21cb,
/* 325 - _D8_F0 */  0x21cc,
/* 326 - _D8_F0 */  0x21cd,
/* 327 - _D8_F0 */  0x21ce,
/* 328 - _D8_F8 */  0x21cf,
/* 329 - _D8_F8 */  0x21d0,
/* 32a - _D8_F8 */  0x21d1,
/* 32b - _D8_F8 */  0x21d2,
/* 32c - _D8_F8 */  0x21d3,
/* 32d - _D8_F8 */  0x21d4,
/* 32e - _D8_F8 */  0x21d5,
/* 32f - _D8_F8 */  0x21d6,
/* 330 - _D9_00 */  0x21d7,
/* 331 -  */  0,
/* 332 - _D9_02 */  0x21d8,
/* 333 - _D9_03 */  0x21d9,
/* 334 - _D9_04 */  0x21da,
/* 335 - _D9_05 */  0x21db,
/* 336 - _D9_06 */  0xef24,
/* 337 - _D9_07 */  0xef30,
/* 338 - _D9_C0 */  0x21dc,
/* 339 - _D9_C0 */  0x21dd,
/* 33a - _D9_C0 */  0x21de,
/* 33b - _D9_C0 */  0x21df,
/* 33c - _D9_C0 */  0x21e0,
/* 33d - _D9_C0 */  0x21e1,
/* 33e - _D9_C0 */  0x21e2,
/* 33f - _D9_C0 */  0x21e3,
/* 340 - _D9_C8 */  0x21e4,
/* 341 - _D9_C9 */  0x21e5,
/* 342 - _D9_C8 */  0x21e6,
/* 343 - _D9_C8 */  0x21e7,
/* 344 - _D9_C8 */  0x21e8,
/* 345 - _D9_C8 */  0x21e9,
/* 346 - _D9_C8 */  0x21ea,
/* 347 - _D9_C8 */  0x21eb,
/* 348 - _D9_D0 */  0x21ec,
/* 349 -  */  0,
/* 34a -  */  0,
/* 34b -  */  0,
/* 34c -  */  0,
/* 34d -  */  0,
/* 34e -  */  0,
/* 34f -  */  0,
/* 350 -  */  0,
/* 351 -  */  0,
/* 352 -  */  0,
/* 353 -  */  0,
/* 354 -  */  0,
/* 355 -  */  0,
/* 356 -  */  0,
/* 357 -  */  0,
/* 358 - _D9_E0 */  0x21ed,
/* 359 - _D9_E1 */  0x21ee,
/* 35a -  */  0,
/* 35b -  */  0,
/* 35c - _D9_E4 */  0x21ef,
/* 35d - _D9_E5 */  0x21f0,
/* 35e -  */  0,
/* 35f -  */  0,
/* 360 - _D9_E8 */  0x21f1,
/* 361 - _D9_E9 */  0x21f2,
/* 362 - _D9_EA */  0x21f3,
/* 363 - _D9_EB */  0x21f4,
/* 364 - _D9_EC */  0x21f5,
/* 365 - _D9_ED */  0x21f6,
/* 366 - _D9_EE */  0x21f7,
/* 367 -  */  0,
/* 368 - _D9_F0 */  0x21f8,
/* 369 - _D9_F1 */  0x21f9,
/* 36a - _D9_F2 */  0x21fa,
/* 36b - _D9_F3 */  0x21fb,
/* 36c - _D9_F4 */  0x21fc,
/* 36d - _D9_F5 */  0x21fd,
/* 36e - _D9_F6 */  0x21fe,
/* 36f - _D9_F7 */  0x21ff,
/* 370 - _D9_F8 */  0x2200,
/* 371 - _D9_F9 */  0x2201,
/* 372 - _D9_FA */  0x2202,
/* 373 - _D9_FB */  0x2203,
/* 374 - _D9_FC */  0x2204,
/* 375 - _D9_FD */  0x2205,
/* 376 - _D9_FE */  0x2206,
/* 377 - _D9_FF */  0x2207,
/* 378 - _DA_00 */  0x2208,
/* 379 - _DA_01 */  0x2209,
/* 37a - _DA_02 */  0x220a,
/* 37b - _DA_03 */  0x220b,
/* 37c - _DA_04 */  0x220c,
/* 37d - _DA_05 */  0x220d,
/* 37e - _DA_06 */  0x220e,
/* 37f - _DA_07 */  0x220f,
/* 380 - _DA_C0 */  0x2210,
/* 381 - _DA_C0 */  0x2211,
/* 382 - _DA_C0 */  0x2212,
/* 383 - _DA_C0 */  0x2213,
/* 384 - _DA_C0 */  0x2214,
/* 385 - _DA_C0 */  0x2215,
/* 386 - _DA_C0 */  0x2216,
/* 387 - _DA_C0 */  0x2217,
/* 388 - _DA_C8 */  0x2218,
/* 389 - _DA_C8 */  0x2219,
/* 38a - _DA_C8 */  0x221a,
/* 38b - _DA_C8 */  0x221b,
/* 38c - _DA_C8 */  0x221c,
/* 38d - _DA_C8 */  0x221d,
/* 38e - _DA_C8 */  0x221e,
/* 38f - _DA_C8 */  0x221f,
/* 390 - _DA_D0 */  0x2220,
/* 391 - _DA_D0 */  0x2221,
/* 392 - _DA_D0 */  0x2222,
/* 393 - _DA_D0 */  0x2223,
/* 394 - _DA_D0 */  0x2224,
/* 395 - _DA_D0 */  0x2225,
/* 396 - _DA_D0 */  0x2226,
/* 397 - _DA_D0 */  0x2227,
/* 398 - _DA_D8 */  0x2228,
/* 399 - _DA_D8 */  0x2229,
/* 39a - _DA_D8 */  0x222a,
/* 39b - _DA_D8 */  0x222b,
/* 39c - _DA_D8 */  0x222c,
/* 39d - _DA_D8 */  0x222d,
/* 39e - _DA_D8 */  0x222e,
/* 39f - _DA_D8 */  0x222f,
/* 3a0 -  */  0,
/* 3a1 -  */  0,
/* 3a2 -  */  0,
/* 3a3 -  */  0,
/* 3a4 -  */  0,
/* 3a5 -  */  0,
/* 3a6 -  */  0,
/* 3a7 -  */  0,
/* 3a8 -  */  0,
/* 3a9 - _DA_E9 */  0x2230,
/* 3aa -  */  0,
/* 3ab -  */  0,
/* 3ac -  */  0,
/* 3ad -  */  0,
/* 3ae -  */  0,
/* 3af -  */  0,
/* 3b0 -  */  0,
/* 3b1 -  */  0,
/* 3b2 -  */  0,
/* 3b3 -  */  0,
/* 3b4 -  */  0,
/* 3b5 -  */  0,
/* 3b6 -  */  0,
/* 3b7 -  */  0,
/* 3b8 -  */  0,
/* 3b9 -  */  0,
/* 3ba -  */  0,
/* 3bb -  */  0,
/* 3bc -  */  0,
/* 3bd -  */  0,
/* 3be -  */  0,
/* 3bf -  */  0,
/* 3c0 - _DB_00 */  0x2231,
/* 3c1 - _DB_01 */  0x2232,
/* 3c2 - _DB_02 */  0x2233,
/* 3c3 - _DB_03 */  0x2234,
/* 3c4 -  */  0,
/* 3c5 - _DB_05 */  0x2235,
/* 3c6 -  */  0,
/* 3c7 - _DB_07 */  0x2236,
/* 3c8 - _DB_C0 */  0x2237,
/* 3c9 - _DB_C0 */  0x2238,
/* 3ca - _DB_C0 */  0x2239,
/* 3cb - _DB_C0 */  0x223a,
/* 3cc - _DB_C0 */  0x223b,
/* 3cd - _DB_C0 */  0x223c,
/* 3ce - _DB_C0 */  0x223d,
/* 3cf - _DB_C0 */  0x223e,
/* 3d0 - _DB_C8 */  0x223f,
/* 3d1 - _DB_C8 */  0x2240,
/* 3d2 - _DB_C8 */  0x2241,
/* 3d3 - _DB_C8 */  0x2242,
/* 3d4 - _DB_C8 */  0x2243,
/* 3d5 - _DB_C8 */  0x2244,
/* 3d6 - _DB_C8 */  0x2245,
/* 3d7 - _DB_C8 */  0x2246,
/* 3d8 - _DB_D0 */  0x2247,
/* 3d9 - _DB_D0 */  0x2248,
/* 3da - _DB_D0 */  0x2249,
/* 3db - _DB_D0 */  0x224a,
/* 3dc - _DB_D0 */  0x224b,
/* 3dd - _DB_D0 */  0x224c,
/* 3de - _DB_D0 */  0x224d,
/* 3df - _DB_D0 */  0x224e,
/* 3e0 - _DB_D8 */  0x224f,
/* 3e1 - _DB_D8 */  0x2250,
/* 3e2 - _DB_D8 */  0x2251,
/* 3e3 - _DB_D8 */  0x2252,
/* 3e4 - _DB_D8 */  0x2253,
/* 3e5 - _DB_D8 */  0x2254,
/* 3e6 - _DB_D8 */  0x2255,
/* 3e7 - _DB_D8 */  0x2256,
/* 3e8 - _DB_E0 */  0x2257,
/* 3e9 - _DB_E1 */  0x2258,
/* 3ea - _DB_E2 */  0xef3c,
/* 3eb - _DB_E3 */  0xef48,
/* 3ec - _DB_E4 */  0x2259,
/* 3ed -  */  0,
/* 3ee -  */  0,
/* 3ef -  */  0,
/* 3f0 - _DB_E8 */  0x225a,
/* 3f1 - _DB_E8 */  0x225b,
/* 3f2 - _DB_E8 */  0x225c,
/* 3f3 - _DB_E8 */  0x225d,
/* 3f4 - _DB_E8 */  0x225e,
/* 3f5 - _DB_E8 */  0x225f,
/* 3f6 - _DB_E8 */  0x2260,
/* 3f7 - _DB_E8 */  0x2261,
/* 3f8 - _DB_F0 */  0x2262,
/* 3f9 - _DB_F0 */  0x2263,
/* 3fa - _DB_F0 */  0x2264,
/* 3fb - _DB_F0 */  0x2265,
/* 3fc - _DB_F0 */  0x2266,
/* 3fd - _DB_F0 */  0x2267,
/* 3fe - _DB_F0 */  0x2268,
/* 3ff - _DB_F0 */  0x2269,
/* 400 -  */  0,
/* 401 -  */  0,
/* 402 -  */  0,
/* 403 -  */  0,
/* 404 -  */  0,
/* 405 -  */  0,
/* 406 -  */  0,
/* 407 -  */  0,
/* 408 - _DC_00 */  0x226a,
/* 409 - _DC_01 */  0x226b,
/* 40a - _DC_02 */  0x226c,
/* 40b - _DC_03 */  0x226d,
/* 40c - _DC_04 */  0x226e,
/* 40d - _DC_05 */  0x226f,
/* 40e - _DC_06 */  0x2270,
/* 40f - _DC_07 */  0x2271,
/* 410 - _DC_C0 */  0x2272,
/* 411 - _DC_C0 */  0x2273,
/* 412 - _DC_C0 */  0x2274,
/* 413 - _DC_C0 */  0x2275,
/* 414 - _DC_C0 */  0x2276,
/* 415 - _DC_C0 */  0x2277,
/* 416 - _DC_C0 */  0x2278,
/* 417 - _DC_C0 */  0x2279,
/* 418 - _DC_C8 */  0x227a,
/* 419 - _DC_C8 */  0x227b,
/* 41a - _DC_C8 */  0x227c,
/* 41b - _DC_C8 */  0x227d,
/* 41c - _DC_C8 */  0x227e,
/* 41d - _DC_C8 */  0x227f,
/* 41e - _DC_C8 */  0x2280,
/* 41f - _DC_C8 */  0x2281,
/* 420 -  */  0,
/* 421 -  */  0,
/* 422 -  */  0,
/* 423 -  */  0,
/* 424 -  */  0,
/* 425 -  */  0,
/* 426 -  */  0,
/* 427 -  */  0,
/* 428 -  */  0,
/* 429 -  */  0,
/* 42a -  */  0,
/* 42b -  */  0,
/* 42c -  */  0,
/* 42d -  */  0,
/* 42e -  */  0,
/* 42f -  */  0,
/* 430 - _DC_E0 */  0x2282,
/* 431 - _DC_E0 */  0x2283,
/* 432 - _DC_E0 */  0x2284,
/* 433 - _DC_E0 */  0x2285,
/* 434 - _DC_E0 */  0x2286,
/* 435 - _DC_E0 */  0x2287,
/* 436 - _DC_E0 */  0x2288,
/* 437 - _DC_E0 */  0x2289,
/* 438 - _DC_E8 */  0x228a,
/* 439 - _DC_E8 */  0x228b,
/* 43a - _DC_E8 */  0x228c,
/* 43b - _DC_E8 */  0x228d,
/* 43c - _DC_E8 */  0x228e,
/* 43d - _DC_E8 */  0x228f,
/* 43e - _DC_E8 */  0x2290,
/* 43f - _DC_E8 */  0x2291,
/* 440 - _DC_F0 */  0x2292,
/* 441 - _DC_F0 */  0x2293,
/* 442 - _DC_F0 */  0x2294,
/* 443 - _DC_F0 */  0x2295,
/* 444 - _DC_F0 */  0x2296,
/* 445 - _DC_F0 */  0x2297,
/* 446 - _DC_F0 */  0x2298,
/* 447 - _DC_F0 */  0x2299,
/* 448 - _DC_F8 */  0x229a,
/* 449 - _DC_F8 */  0x229b,
/* 44a - _DC_F8 */  0x229c,
/* 44b - _DC_F8 */  0x229d,
/* 44c - _DC_F8 */  0x229e,
/* 44d - _DC_F8 */  0x229f,
/* 44e - _DC_F8 */  0x22a0,
/* 44f - _DC_F8 */  0x22a1,
/* 450 - _DD_00 */  0x22a2,
/* 451 - _DD_01 */  0x22a3,
/* 452 - _DD_02 */  0x22a4,
/* 453 - _DD_03 */  0x22a5,
/* 454 - _DD_04 */  0x22a6,
/* 455 -  */  0,
/* 456 - _DD_06 */  0xef54,
/* 457 - _DD_07 */  0xef60,
/* 458 - _DD_C0 */  0x22a7,
/* 459 - _DD_C0 */  0x22a8,
/* 45a - _DD_C0 */  0x22a9,
/* 45b - _DD_C0 */  0x22aa,
/* 45c - _DD_C0 */  0x22ab,
/* 45d - _DD_C0 */  0x22ac,
/* 45e - _DD_C0 */  0x22ad,
/* 45f - _DD_C0 */  0x22ae,
/* 460 -  */  0,
/* 461 -  */  0,
/* 462 -  */  0,
/* 463 -  */  0,
/* 464 -  */  0,
/* 465 -  */  0,
/* 466 -  */  0,
/* 467 -  */  0,
/* 468 - _DD_D0 */  0x22af,
/* 469 - _DD_D0 */  0x22b0,
/* 46a - _DD_D0 */  0x22b1,
/* 46b - _DD_D0 */  0x22b2,
/* 46c - _DD_D0 */  0x22b3,
/* 46d - _DD_D0 */  0x22b4,
/* 46e - _DD_D0 */  0x22b5,
/* 46f - _DD_D0 */  0x22b6,
/* 470 - _DD_D8 */  0x22b7,
/* 471 - _DD_D8 */  0x22b8,
/* 472 - _DD_D8 */  0x22b9,
/* 473 - _DD_D8 */  0x22ba,
/* 474 - _DD_D8 */  0x22bb,
/* 475 - _DD_D8 */  0x22bc,
/* 476 - _DD_D8 */  0x22bd,
/* 477 - _DD_D8 */  0x22be,
/* 478 - _DD_E0 */  0x22bf,
/* 479 - _DD_E1 */  0x22c0,
/* 47a - _DD_E0 */  0x22c1,
/* 47b - _DD_E0 */  0x22c2,
/* 47c - _DD_E0 */  0x22c3,
/* 47d - _DD_E0 */  0x22c4,
/* 47e - _DD_E0 */  0x22c5,
/* 47f - _DD_E0 */  0x22c6,
/* 480 - _DD_E8 */  0x22c7,
/* 481 - _DD_E9 */  0x22c8,
/* 482 - _DD_E8 */  0x22c9,
/* 483 - _DD_E8 */  0x22ca,
/* 484 - _DD_E8 */  0x22cb,
/* 485 - _DD_E8 */  0x22cc,
/* 486 - _DD_E8 */  0x22cd,
/* 487 - _DD_E8 */  0x22ce,
/* 488 -  */  0,
/* 489 -  */  0,
/* 48a -  */  0,
/* 48b -  */  0,
/* 48c -  */  0,
/* 48d -  */  0,
/* 48e -  */  0,
/* 48f -  */  0,
/* 490 -  */  0,
/* 491 -  */  0,
/* 492 -  */  0,
/* 493 -  */  0,
/* 494 -  */  0,
/* 495 -  */  0,
/* 496 -  */  0,
/* 497 -  */  0,
/* 498 - _DE_00 */  0x22cf,
/* 499 - _DE_01 */  0x22d0,
/* 49a - _DE_02 */  0x22d1,
/* 49b - _DE_03 */  0x22d2,
/* 49c - _DE_04 */  0x22d3,
/* 49d - _DE_05 */  0x22d4,
/* 49e - _DE_06 */  0x22d5,
/* 49f - _DE_07 */  0x22d6,
/* 4a0 - _DE_C0 */  0x22d7,
/* 4a1 - _DE_C1 */  0x22d8,
/* 4a2 - _DE_C0 */  0x22d9,
/* 4a3 - _DE_C0 */  0x22da,
/* 4a4 - _DE_C0 */  0x22db,
/* 4a5 - _DE_C0 */  0x22dc,
/* 4a6 - _DE_C0 */  0x22dd,
/* 4a7 - _DE_C0 */  0x22de,
/* 4a8 - _DE_C8 */  0x22df,
/* 4a9 - _DE_C9 */  0x22e0,
/* 4aa - _DE_C8 */  0x22e1,
/* 4ab - _DE_C8 */  0x22e2,
/* 4ac - _DE_C8 */  0x22e3,
/* 4ad - _DE_C8 */  0x22e4,
/* 4ae - _DE_C8 */  0x22e5,
/* 4af - _DE_C8 */  0x22e6,
/* 4b0 -  */  0,
/* 4b1 -  */  0,
/* 4b2 -  */  0,
/* 4b3 -  */  0,
/* 4b4 -  */  0,
/* 4b5 -  */  0,
/* 4b6 -  */  0,
/* 4b7 -  */  0,
/* 4b8 -  */  0,
/* 4b9 - _DE_D9 */  0x22e7,
/* 4ba -  */  0,
/* 4bb -  */  0,
/* 4bc -  */  0,
/* 4bd -  */  0,
/* 4be -  */  0,
/* 4bf -  */  0,
/* 4c0 - _DE_E0 */  0x22e8,
/* 4c1 - _DE_E1 */  0x22e9,
/* 4c2 - _DE_E0 */  0x22ea,
/* 4c3 - _DE_E0 */  0x22eb,
/* 4c4 - _DE_E0 */  0x22ec,
/* 4c5 - _DE_E0 */  0x22ed,
/* 4c6 - _DE_E0 */  0x22ee,
/* 4c7 - _DE_E0 */  0x22ef,
/* 4c8 - _DE_E8 */  0x22f0,
/* 4c9 - _DE_E9 */  0x22f1,
/* 4ca - _DE_E8 */  0x22f2,
/* 4cb - _DE_E8 */  0x22f3,
/* 4cc - _DE_E8 */  0x22f4,
/* 4cd - _DE_E8 */  0x22f5,
/* 4ce - _DE_E8 */  0x22f6,
/* 4cf - _DE_E8 */  0x22f7,
/* 4d0 - _DE_F0 */  0x22f8,
/* 4d1 - _DE_F1 */  0x22f9,
/* 4d2 - _DE_F0 */  0x22fa,
/* 4d3 - _DE_F0 */  0x22fb,
/* 4d4 - _DE_F0 */  0x22fc,
/* 4d5 - _DE_F0 */  0x22fd,
/* 4d6 - _DE_F0 */  0x22fe,
/* 4d7 - _DE_F0 */  0x22ff,
/* 4d8 - _DE_F8 */  0x2300,
/* 4d9 - _DE_F9 */  0x2301,
/* 4da - _DE_F8 */  0x2302,
/* 4db - _DE_F8 */  0x2303,
/* 4dc - _DE_F8 */  0x2304,
/* 4dd - _DE_F8 */  0x2305,
/* 4de - _DE_F8 */  0x2306,
/* 4df - _DE_F8 */  0x2307,
/* 4e0 - _DF_00 */  0x2308,
/* 4e1 - _DF_01 */  0x2309,
/* 4e2 - _DF_02 */  0x230a,
/* 4e3 - _DF_03 */  0x230b,
/* 4e4 - _DF_04 */  0x230c,
/* 4e5 - _DF_05 */  0x230d,
/* 4e6 - _DF_06 */  0x230e,
/* 4e7 - _DF_07 */  0x230f,
/* 4e8 -  */  0,
/* 4e9 -  */  0,
/* 4ea -  */  0,
/* 4eb -  */  0,
/* 4ec -  */  0,
/* 4ed -  */  0,
/* 4ee -  */  0,
/* 4ef -  */  0,
/* 4f0 -  */  0,
/* 4f1 -  */  0,
/* 4f2 -  */  0,
/* 4f3 -  */  0,
/* 4f4 -  */  0,
/* 4f5 -  */  0,
/* 4f6 -  */  0,
/* 4f7 -  */  0,
/* 4f8 -  */  0,
/* 4f9 -  */  0,
/* 4fa -  */  0,
/* 4fb -  */  0,
/* 4fc -  */  0,
/* 4fd -  */  0,
/* 4fe -  */  0,
/* 4ff -  */  0,
/* 500 -  */  0,
/* 501 -  */  0,
/* 502 -  */  0,
/* 503 -  */  0,
/* 504 -  */  0,
/* 505 -  */  0,
/* 506 -  */  0,
/* 507 -  */  0,
/* 508 - _DF_E0 */  0xef6c,
/* 509 -  */  0,
/* 50a -  */  0,
/* 50b -  */  0,
/* 50c -  */  0,
/* 50d -  */  0,
/* 50e -  */  0,
/* 50f -  */  0,
/* 510 - _DF_E8 */  0x2310,
/* 511 - _DF_E8 */  0x2311,
/* 512 - _DF_E8 */  0x2312,
/* 513 - _DF_E8 */  0x2313,
/* 514 - _DF_E8 */  0x2314,
/* 515 - _DF_E8 */  0x2315,
/* 516 - _DF_E8 */  0x2316,
/* 517 - _DF_E8 */  0x2317,
/* 518 - _DF_F0 */  0x2318,
/* 519 - _DF_F0 */  0x2319,
/* 51a - _DF_F0 */  0x231a,
/* 51b - _DF_F0 */  0x231b,
/* 51c - _DF_F0 */  0x231c,
/* 51d - _DF_F0 */  0x231d,
/* 51e - _DF_F0 */  0x231e,
/* 51f - _DF_F0 */  0x231f,
/* 520 -  */  0,
/* 521 -  */  0,
/* 522 -  */  0,
/* 523 -  */  0,
/* 524 -  */  0,
/* 525 -  */  0,
/* 526 -  */  0,
/* 527 -  */  0,
/* 528 - _F6_00 */  0x2320,
/* 529 -  */  0,
/* 52a - _F6_02 */  0x2321,
/* 52b - _F6_03 */  0x2322,
/* 52c - _F6_04 */  0x2323,
/* 52d - _F6_05 */  0x2324,
/* 52e - _F6_06 */  0x2325,
/* 52f - _F6_07 */  0x2326,
/* 530 - _F7_00 */  0x2327,
/* 531 -  */  0,
/* 532 - _F7_02 */  0x2328,
/* 533 - _F7_03 */  0x2329,
/* 534 - _F7_04 */  0x232a,
/* 535 - _F7_05 */  0x232b,
/* 536 - _F7_06 */  0x232c,
/* 537 - _F7_07 */  0x232d,
/* 538 - _FE_00 */  0x232e,
/* 539 - _FE_01 */  0x232f,
/* 53a -  */  0,
/* 53b -  */  0,
/* 53c -  */  0,
/* 53d -  */  0,
/* 53e -  */  0,
/* 53f -  */  0,
/* 540 - _FF_00 */  0x2330,
/* 541 - _FF_01 */  0x2331,
/* 542 - _FF_02 */  0x2332,
/* 543 - _FF_03 */  0x2333,
/* 544 - _FF_04 */  0x2334,
/* 545 - _FF_05 */  0x2335,
/* 546 - _FF_06 */  0x2336,
/* 547 -  */  0,
/* 548 - _0F_00_00 */  0x2337,
/* 549 - _0F_00_01 */  0x2338,
/* 54a - _0F_00_02 */  0x2339,
/* 54b - _0F_00_03 */  0x233a,
/* 54c - _0F_00_04 */  0x233b,
/* 54d - _0F_00_05 */  0x233c,
/* 54e -  */  0,
/* 54f -  */  0,
/* 550 - _0F_01_00 */  0x233d,
/* 551 - _0F_01_01 */  0x233e,
/* 552 - _0F_01_02 */  0x233f,
/* 553 - _0F_01_03 */  0x2340,
/* 554 - _0F_01_04 */  0x2341,
/* 555 -  */  0,
/* 556 - _0F_01_06 */  0x2342,
/* 557 - _0F_01_07 */  0x2343,
/* 558 -  */  0,
/* 559 - _0F_01_C1 */  0x2344,
/* 55a - _0F_01_C2 */  0x2345,
/* 55b - _0F_01_C3 */  0x2346,
/* 55c - _0F_01_C4 */  0x2347,
/* 55d -  */  0,
/* 55e -  */  0,
/* 55f -  */  0,
/* 560 - _0F_01_C8 */  0x2348,
/* 561 - _0F_01_C9 */  0x2349,
/* 562 - _0F_01_CA */  0x234a,
/* 563 - _0F_01_CB */  0x234b,
/* 564 -  */  0,
/* 565 -  */  0,
/* 566 -  */  0,
/* 567 -  */  0,
/* 568 - _0F_01_D0 */  0x234c,
/* 569 - _0F_01_D1 */  0x234d,
/* 56a -  */  0,
/* 56b -  */  0,
/* 56c - _0F_01_D4 */  0x234e,
/* 56d - _0F_01_D5 */  0x234f,
/* 56e -  */  0,
/* 56f -  */  0,
/* 570 - _0F_01_D8 */  0x2350,
/* 571 - _0F_01_D9 */  0x2351,
/* 572 - _0F_01_DA */  0x2352,
/* 573 - _0F_01_DB */  0x2353,
/* 574 - _0F_01_DC */  0x2354,
/* 575 - _0F_01_DD */  0x2355,
/* 576 - _0F_01_DE */  0x2356,
/* 577 - _0F_01_DF */  0x2357,
/* 578 -  */  0,
/* 579 -  */  0,
/* 57a -  */  0,
/* 57b -  */  0,
/* 57c -  */  0,
/* 57d -  */  0,
/* 57e -  */  0,
/* 57f -  */  0,
/* 580 -  */  0,
/* 581 -  */  0,
/* 582 -  */  0,
/* 583 -  */  0,
/* 584 -  */  0,
/* 585 -  */  0,
/* 586 -  */  0,
/* 587 -  */  0,
/* 588 -  */  0,
/* 589 -  */  0,
/* 58a -  */  0,
/* 58b -  */  0,
/* 58c -  */  0,
/* 58d -  */  0,
/* 58e -  */  0,
/* 58f -  */  0,
/* 590 - _0F_01_F8 */  0x2358,
/* 591 - _0F_01_F9 */  0x2359,
/* 592 -  */  0,
/* 593 -  */  0,
/* 594 -  */  0,
/* 595 -  */  0,
/* 596 -  */  0,
/* 597 -  */  0,
/* 598 - _0F_0D_00 */  0x235a,
/* 599 - _0F_0D_01 */  0x235b,
/* 59a -  */  0,
/* 59b -  */  0,
/* 59c -  */  0,
/* 59d -  */  0,
/* 59e -  */  0,
/* 59f -  */  0,
/* 5a0 -  */  0,
/* 5a1 -  */  0,
/* 5a2 -  */  0,
/* 5a3 -  */  0,
/* 5a4 -  */  0,
/* 5a5 -  */  0,
/* 5a6 -  */  0,
/* 5a7 -  */  0,
/* 5a8 -  */  0,
/* 5a9 -  */  0,
/* 5aa -  */  0,
/* 5ab -  */  0,
/* 5ac - _0F_0F_0C */  0x235c,
/* 5ad - _0F_0F_0D */  0x235d,
/* 5ae -  */  0,
/* 5af -  */  0,
/* 5b0 -  */  0,
/* 5b1 -  */  0,
/* 5b2 -  */  0,
/* 5b3 -  */  0,
/* 5b4 -  */  0,
/* 5b5 -  */  0,
/* 5b6 -  */  0,
/* 5b7 -  */  0,
/* 5b8 -  */  0,
/* 5b9 -  */  0,
/* 5ba -  */  0,
/* 5bb -  */  0,
/* 5bc - _0F_0F_1C */  0x235e,
/* 5bd - _0F_0F_1D */  0x235f,
/* 5be -  */  0,
/* 5bf -  */  0,
/* 5c0 -  */  0,
/* 5c1 -  */  0,
/* 5c2 -  */  0,
/* 5c3 -  */  0,
/* 5c4 -  */  0,
/* 5c5 -  */  0,
/* 5c6 -  */  0,
/* 5c7 -  */  0,
/* 5c8 -  */  0,
/* 5c9 -  */  0,
/* 5ca -  */  0,
/* 5cb -  */  0,
/* 5cc -  */  0,
/* 5cd -  */  0,
/* 5ce -  */  0,
/* 5cf -  */  0,
/* 5d0 -  */  0,
/* 5d1 -  */  0,
/* 5d2 -  */  0,
/* 5d3 -  */  0,
/* 5d4 -  */  0,
/* 5d5 -  */  0,
/* 5d6 -  */  0,
/* 5d7 -  */  0,
/* 5d8 -  */  0,
/* 5d9 -  */  0,
/* 5da -  */  0,
/* 5db -  */  0,
/* 5dc -  */  0,
/* 5dd -  */  0,
/* 5de -  */  0,
/* 5df -  */  0,
/* 5e0 -  */  0,
/* 5e1 -  */  0,
/* 5e2 -  */  0,
/* 5e3 -  */  0,
/* 5e4 -  */  0,
/* 5e5 -  */  0,
/* 5e6 -  */  0,
/* 5e7 -  */  0,
/* 5e8 -  */  0,
/* 5e9 -  */  0,
/* 5ea -  */  0,
/* 5eb -  */  0,
/* 5ec -  */  0,
/* 5ed -  */  0,
/* 5ee -  */  0,
/* 5ef -  */  0,
/* 5f0 -  */  0,
/* 5f1 -  */  0,
/* 5f2 -  */  0,
/* 5f3 -  */  0,
/* 5f4 -  */  0,
/* 5f5 -  */  0,
/* 5f6 -  */  0,
/* 5f7 -  */  0,
/* 5f8 -  */  0,
/* 5f9 -  */  0,
/* 5fa -  */  0,
/* 5fb -  */  0,
/* 5fc -  */  0,
/* 5fd -  */  0,
/* 5fe -  */  0,
/* 5ff -  */  0,
/* 600 -  */  0,
/* 601 -  */  0,
/* 602 -  */  0,
/* 603 -  */  0,
/* 604 -  */  0,
/* 605 -  */  0,
/* 606 -  */  0,
/* 607 -  */  0,
/* 608 -  */  0,
/* 609 -  */  0,
/* 60a -  */  0,
/* 60b -  */  0,
/* 60c -  */  0,
/* 60d -  */  0,
/* 60e -  */  0,
/* 60f -  */  0,
/* 610 -  */  0,
/* 611 -  */  0,
/* 612 -  */  0,
/* 613 -  */  0,
/* 614 -  */  0,
/* 615 -  */  0,
/* 616 -  */  0,
/* 617 -  */  0,
/* 618 -  */  0,
/* 619 -  */  0,
/* 61a -  */  0,
/* 61b -  */  0,
/* 61c -  */  0,
/* 61d -  */  0,
/* 61e -  */  0,
/* 61f -  */  0,
/* 620 -  */  0,
/* 621 -  */  0,
/* 622 -  */  0,
/* 623 -  */  0,
/* 624 -  */  0,
/* 625 -  */  0,
/* 626 -  */  0,
/* 627 -  */  0,
/* 628 -  */  0,
/* 629 -  */  0,
/* 62a - _0F_0F_8A */  0x2360,
/* 62b -  */  0,
/* 62c -  */  0,
/* 62d -  */  0,
/* 62e - _0F_0F_8E */  0x2361,
/* 62f -  */  0,
/* 630 - _0F_0F_90 */  0x2362,
/* 631 -  */  0,
/* 632 -  */  0,
/* 633 -  */  0,
/* 634 - _0F_0F_94 */  0x2363,
/* 635 -  */  0,
/* 636 - _0F_0F_96 */  0x2364,
/* 637 - _0F_0F_97 */  0x2365,
/* 638 -  */  0,
/* 639 -  */  0,
/* 63a - _0F_0F_9A */  0x2366,
/* 63b -  */  0,
/* 63c -  */  0,
/* 63d -  */  0,
/* 63e - _0F_0F_9E */  0x2367,
/* 63f -  */  0,
/* 640 - _0F_0F_A0 */  0x2368,
/* 641 -  */  0,
/* 642 -  */  0,
/* 643 -  */  0,
/* 644 - _0F_0F_A4 */  0x2369,
/* 645 -  */  0,
/* 646 - _0F_0F_A6 */  0x236a,
/* 647 - _0F_0F_A7 */  0x236b,
/* 648 -  */  0,
/* 649 -  */  0,
/* 64a - _0F_0F_AA */  0x236c,
/* 64b -  */  0,
/* 64c -  */  0,
/* 64d -  */  0,
/* 64e - _0F_0F_AE */  0x236d,
/* 64f -  */  0,
/* 650 - _0F_0F_B0 */  0x236e,
/* 651 -  */  0,
/* 652 -  */  0,
/* 653 -  */  0,
/* 654 - _0F_0F_B4 */  0x236f,
/* 655 -  */  0,
/* 656 - _0F_0F_B6 */  0x2370,
/* 657 - _0F_0F_B7 */  0x2371,
/* 658 -  */  0,
/* 659 -  */  0,
/* 65a -  */  0,
/* 65b - _0F_0F_BB */  0x2372,
/* 65c -  */  0,
/* 65d -  */  0,
/* 65e -  */  0,
/* 65f - _0F_0F_BF */  0x2373,
/* 660 -  */  0,
/* 661 -  */  0,
/* 662 -  */  0,
/* 663 -  */  0,
/* 664 -  */  0,
/* 665 -  */  0,
/* 666 -  */  0,
/* 667 -  */  0,
/* 668 -  */  0,
/* 669 -  */  0,
/* 66a -  */  0,
/* 66b -  */  0,
/* 66c -  */  0,
/* 66d -  */  0,
/* 66e -  */  0,
/* 66f -  */  0,
/* 670 -  */  0,
/* 671 -  */  0,
/* 672 -  */  0,
/* 673 -  */  0,
/* 674 -  */  0,
/* 675 -  */  0,
/* 676 -  */  0,
/* 677 -  */  0,
/* 678 -  */  0,
/* 679 -  */  0,
/* 67a -  */  0,
/* 67b -  */  0,
/* 67c -  */  0,
/* 67d -  */  0,
/* 67e -  */  0,
/* 67f -  */  0,
/* 680 -  */  0,
/* 681 -  */  0,
/* 682 -  */  0,
/* 683 -  */  0,
/* 684 -  */  0,
/* 685 -  */  0,
/* 686 -  */  0,
/* 687 -  */  0,
/* 688 -  */  0,
/* 689 -  */  0,
/* 68a -  */  0,
/* 68b -  */  0,
/* 68c -  */  0,
/* 68d -  */  0,
/* 68e -  */  0,
/* 68f -  */  0,
/* 690 -  */  0,
/* 691 -  */  0,
/* 692 -  */  0,
/* 693 -  */  0,
/* 694 -  */  0,
/* 695 -  */  0,
/* 696 -  */  0,
/* 697 -  */  0,
/* 698 -  */  0,
/* 699 -  */  0,
/* 69a -  */  0,
/* 69b -  */  0,
/* 69c -  */  0,
/* 69d -  */  0,
/* 69e -  */  0,
/* 69f -  */  0,
/* 6a0 - _0F_10 */  0x2374,
/* 6a1 - _66_0F_10 */  0x2375,
/* 6a2 - _F3_0F_10 */  0x2376,
/* 6a3 - _F2_0F_10 */  0x2377,
/* 6a4 - _V_0F_10 */  0x4009,
/* 6a5 - _V_66_0F_10 */  0x400a,
/* 6a6 - _V_F3_0F_10 */  0x400b,
/* 6a7 - _V_F2_0F_10 */  0x400c,
/* 6a8 -  */  0,
/* 6a9 -  */  0,
/* 6aa - _VRR_F3_0F_10 */  0x400d,
/* 6ab - _VRR_F2_0F_10 */  0x400e,
/* 6ac - _0F_11 */  0x2378,
/* 6ad - _66_0F_11 */  0x2379,
/* 6ae - _F3_0F_11 */  0x237a,
/* 6af - _F2_0F_11 */  0x237b,
/* 6b0 - _V_0F_11 */  0x400f,
/* 6b1 - _V_66_0F_11 */  0x4010,
/* 6b2 - _V_F3_0F_11 */  0x4011,
/* 6b3 - _V_F2_0F_11 */  0x4012,
/* 6b4 -  */  0,
/* 6b5 -  */  0,
/* 6b6 - _VRR_F3_0F_11 */  0x4013,
/* 6b7 - _VRR_F2_0F_11 */  0x4014,
/* 6b8 - _0F_12 */  0x4015,
/* 6b9 - _66_0F_12 */  0x237c,
/* 6ba - _F3_0F_12 */  0x237d,
/* 6bb - _F2_0F_12 */  0x237e,
/* 6bc - _V_0F_12 */  0x4016,
/* 6bd - _V_66_0F_12 */  0x4017,
/* 6be - _V_F3_0F_12 */  0x4018,
/* 6bf - _V_F2_0F_12 */  0x4019,
/* 6c0 -  */  0,
/* 6c1 -  */  0,
/* 6c2 -  */  0,
/* 6c3 -  */  0,
/* 6c4 - _0F_13 */  0x237f,
/* 6c5 - _66_0F_13 */  0x2380,
/* 6c6 -  */  0,
/* 6c7 -  */  0,
/* 6c8 - _V_0F_13 */  0x401a,
/* 6c9 - _V_66_0F_13 */  0x401b,
/* 6ca -  */  0,
/* 6cb -  */  0,
/* 6cc -  */  0,
/* 6cd -  */  0,
/* 6ce -  */  0,
/* 6cf -  */  0,
/* 6d0 - _0F_14 */  0x2381,
/* 6d1 - _66_0F_14 */  0x2382,
/* 6d2 -  */  0,
/* 6d3 -  */  0,
/* 6d4 - _V_0F_14 */  0x401c,
/* 6d5 - _V_66_0F_14 */  0x401d,
/* 6d6 -  */  0,
/* 6d7 -  */  0,
/* 6d8 -  */  0,
/* 6d9 -  */  0,
/* 6da -  */  0,
/* 6db -  */  0,
/* 6dc - _0F_15 */  0x2383,
/* 6dd - _66_0F_15 */  0x2384,
/* 6de -  */  0,
/* 6df -  */  0,
/* 6e0 - _V_0F_15 */  0x401e,
/* 6e1 - _V_66_0F_15 */  0x401f,
/* 6e2 -  */  0,
/* 6e3 -  */  0,
/* 6e4 -  */  0,
/* 6e5 -  */  0,
/* 6e6 -  */  0,
/* 6e7 -  */  0,
/* 6e8 - _0F_16 */  0x4020,
/* 6e9 - _66_0F_16 */  0x2385,
/* 6ea - _F3_0F_16 */  0x2386,
/* 6eb -  */  0,
/* 6ec - _V_0F_16 */  0x4021,
/* 6ed - _V_66_0F_16 */  0x4022,
/* 6ee - _V_F3_0F_16 */  0x4023,
/* 6ef -  */  0,
/* 6f0 -  */  0,
/* 6f1 -  */  0,
/* 6f2 -  */  0,
/* 6f3 -  */  0,
/* 6f4 - _0F_17 */  0x2387,
/* 6f5 - _66_0F_17 */  0x2388,
/* 6f6 -  */  0,
/* 6f7 -  */  0,
/* 6f8 - _V_0F_17 */  0x4024,
/* 6f9 - _V_66_0F_17 */  0x4025,
/* 6fa -  */  0,
/* 6fb -  */  0,
/* 6fc -  */  0,
/* 6fd -  */  0,
/* 6fe -  */  0,
/* 6ff -  */  0,
/* 700 - _0F_18_00 */  0x2389,
/* 701 - _0F_18_01 */  0x238a,
/* 702 - _0F_18_02 */  0x238b,
/* 703 - _0F_18_03 */  0x238c,
/* 704 -  */  0,
/* 705 -  */  0,
/* 706 -  */  0,
/* 707 -  */  0,
/* 708 - _0F_28 */  0x238d,
/* 709 - _66_0F_28 */  0x238e,
/* 70a -  */  0,
/* 70b -  */  0,
/* 70c - _V_0F_28 */  0x4026,
/* 70d - _V_66_0F_28 */  0x4027,
/* 70e -  */  0,
/* 70f -  */  0,
/* 710 -  */  0,
/* 711 -  */  0,
/* 712 -  */  0,
/* 713 -  */  0,
/* 714 - _0F_29 */  0x238f,
/* 715 - _66_0F_29 */  0x2390,
/* 716 -  */  0,
/* 717 -  */  0,
/* 718 - _V_0F_29 */  0x4028,
/* 719 - _V_66_0F_29 */  0x4029,
/* 71a -  */  0,
/* 71b -  */  0,
/* 71c -  */  0,
/* 71d -  */  0,
/* 71e -  */  0,
/* 71f -  */  0,
/* 720 - _0F_2A */  0x2391,
/* 721 - _66_0F_2A */  0x2392,
/* 722 - _F3_0F_2A */  0x2393,
/* 723 - _F2_0F_2A */  0x2394,
/* 724 -  */  0,
/* 725 -  */  0,
/* 726 - _V_F3_0F_2A */  0x402a,
/* 727 - _V_F2_0F_2A */  0x402b,
/* 728 -  */  0,
/* 729 -  */  0,
/* 72a -  */  0,
/* 72b -  */  0,
/* 72c - _0F_2B */  0x2395,
/* 72d - _66_0F_2B */  0x2396,
/* 72e - _F3_0F_2B */  0x2397,
/* 72f - _F2_0F_2B */  0x2398,
/* 730 - _V_0F_2B */  0x402c,
/* 731 - _V_66_0F_2B */  0x402d,
/* 732 -  */  0,
/* 733 -  */  0,
/* 734 -  */  0,
/* 735 -  */  0,
/* 736 -  */  0,
/* 737 -  */  0,
/* 738 - _0F_2C */  0x2399,
/* 739 - _66_0F_2C */  0x239a,
/* 73a - _F3_0F_2C */  0x239b,
/* 73b - _F2_0F_2C */  0x239c,
/* 73c -  */  0,
/* 73d -  */  0,
/* 73e - _V_F3_0F_2C */  0x402e,
/* 73f - _V_F2_0F_2C */  0x402f,
/* 740 -  */  0,
/* 741 -  */  0,
/* 742 -  */  0,
/* 743 -  */  0,
/* 744 - _0F_2D */  0x239d,
/* 745 - _66_0F_2D */  0x239e,
/* 746 - _F3_0F_2D */  0x239f,
/* 747 - _F2_0F_2D */  0x23a0,
/* 748 -  */  0,
/* 749 -  */  0,
/* 74a - _V_F3_0F_2D */  0x4030,
/* 74b - _V_F2_0F_2D */  0x4031,
/* 74c -  */  0,
/* 74d -  */  0,
/* 74e -  */  0,
/* 74f -  */  0,
/* 750 - _0F_2E */  0x23a1,
/* 751 - _66_0F_2E */  0x23a2,
/* 752 -  */  0,
/* 753 -  */  0,
/* 754 - _V_0F_2E */  0x4032,
/* 755 - _V_66_0F_2E */  0x4033,
/* 756 -  */  0,
/* 757 -  */  0,
/* 758 -  */  0,
/* 759 -  */  0,
/* 75a -  */  0,
/* 75b -  */  0,
/* 75c - _0F_2F */  0x23a3,
/* 75d - _66_0F_2F */  0x23a4,
/* 75e -  */  0,
/* 75f -  */  0,
/* 760 - _V_0F_2F */  0x4034,
/* 761 - _V_66_0F_2F */  0x4035,
/* 762 -  */  0,
/* 763 -  */  0,
/* 764 -  */  0,
/* 765 -  */  0,
/* 766 -  */  0,
/* 767 -  */  0,
/* 768 - _0F_38_00 */  0xef78,
/* 769 - _0F_38_01 */  0xef84,
/* 76a - _0F_38_02 */  0xef90,
/* 76b - _0F_38_03 */  0xef9c,
/* 76c - _0F_38_04 */  0xefa8,
/* 76d - _0F_38_05 */  0xefb4,
/* 76e - _0F_38_06 */  0xefc0,
/* 76f - _0F_38_07 */  0xefcc,
/* 770 - _0F_38_08 */  0xefd8,
/* 771 - _0F_38_09 */  0xefe4,
/* 772 - _0F_38_0A */  0xeff0,
/* 773 - _0F_38_0B */  0xeffc,
/* 774 - _0F_38_0C */  0xf008,
/* 775 - _0F_38_0D */  0xf014,
/* 776 - _0F_38_0E */  0xf020,
/* 777 - _0F_38_0F */  0xf02c,
/* 778 - _0F_38_10 */  0xf038,
/* 779 -  */  0,
/* 77a -  */  0,
/* 77b -  */  0,
/* 77c - _0F_38_14 */  0xf044,
/* 77d - _0F_38_15 */  0xf050,
/* 77e -  */  0,
/* 77f - _0F_38_17 */  0xf05c,
/* 780 - _0F_38_18 */  0xf068,
/* 781 - _0F_38_19 */  0xf074,
/* 782 - _0F_38_1A */  0xf080,
/* 783 -  */  0,
/* 784 - _0F_38_1C */  0xf08c,
/* 785 - _0F_38_1D */  0xf098,
/* 786 - _0F_38_1E */  0xf0a4,
/* 787 -  */  0,
/* 788 - _0F_38_20 */  0xf0b0,
/* 789 - _0F_38_21 */  0xf0bc,
/* 78a - _0F_38_22 */  0xf0c8,
/* 78b - _0F_38_23 */  0xf0d4,
/* 78c - _0F_38_24 */  0xf0e0,
/* 78d - _0F_38_25 */  0xf0ec,
/* 78e -  */  0,
/* 78f -  */  0,
/* 790 - _0F_38_28 */  0xf0f8,
/* 791 - _0F_38_29 */  0xf104,
/* 792 - _0F_38_2A */  0xf110,
/* 793 - _0F_38_2B */  0xf11c,
/* 794 - _0F_38_2C */  0xf128,
/* 795 - _0F_38_2D */  0xf134,
/* 796 - _0F_38_2E */  0xf140,
/* 797 - _0F_38_2F */  0xf14c,
/* 798 - _0F_38_30 */  0xf158,
/* 799 - _0F_38_31 */  0xf164,
/* 79a - _0F_38_32 */  0xf170,
/* 79b - _0F_38_33 */  0xf17c,
/* 79c - _0F_38_34 */  0xf188,
/* 79d - _0F_38_35 */  0xf194,
/* 79e -  */  0,
/* 79f - _0F_38_37 */  0xf1a0,
/* 7a0 - _0F_38_38 */  0xf1ac,
/* 7a1 - _0F_38_39 */  0xf1b8,
/* 7a2 - _0F_38_3A */  0xf1c4,
/* 7a3 - _0F_38_3B */  0xf1d0,
/* 7a4 - _0F_38_3C */  0xf1dc,
/* 7a5 - _0F_38_3D */  0xf1e8,
/* 7a6 - _0F_38_3E */  0xf1f4,
/* 7a7 - _0F_38_3F */  0xf200,
/* 7a8 - _0F_38_40 */  0xf20c,
/* 7a9 - _0F_38_41 */  0xf218,
/* 7aa -  */  0,
/* 7ab -  */  0,
/* 7ac -  */  0,
/* 7ad -  */  0,
/* 7ae -  */  0,
/* 7af -  */  0,
/* 7b0 -  */  0,
/* 7b1 -  */  0,
/* 7b2 -  */  0,
/* 7b3 -  */  0,
/* 7b4 -  */  0,
/* 7b5 -  */  0,
/* 7b6 -  */  0,
/* 7b7 -  */  0,
/* 7b8 -  */  0,
/* 7b9 -  */  0,
/* 7ba -  */  0,
/* 7bb -  */  0,
/* 7bc -  */  0,
/* 7bd -  */  0,
/* 7be -  */  0,
/* 7bf -  */  0,
/* 7c0 -  */  0,
/* 7c1 -  */  0,
/* 7c2 -  */  0,
/* 7c3 -  */  0,
/* 7c4 -  */  0,
/* 7c5 -  */  0,
/* 7c6 -  */  0,
/* 7c7 -  */  0,
/* 7c8 -  */  0,
/* 7c9 -  */  0,
/* 7ca -  */  0,
/* 7cb -  */  0,
/* 7cc -  */  0,
/* 7cd -  */  0,
/* 7ce -  */  0,
/* 7cf -  */  0,
/* 7d0 -  */  0,
/* 7d1 -  */  0,
/* 7d2 -  */  0,
/* 7d3 -  */  0,
/* 7d4 -  */  0,
/* 7d5 -  */  0,
/* 7d6 -  */  0,
/* 7d7 -  */  0,
/* 7d8 -  */  0,
/* 7d9 -  */  0,
/* 7da -  */  0,
/* 7db -  */  0,
/* 7dc -  */  0,
/* 7dd -  */  0,
/* 7de -  */  0,
/* 7df -  */  0,
/* 7e0 -  */  0,
/* 7e1 -  */  0,
/* 7e2 -  */  0,
/* 7e3 -  */  0,
/* 7e4 -  */  0,
/* 7e5 -  */  0,
/* 7e6 -  */  0,
/* 7e7 -  */  0,
/* 7e8 - _0F_38_80 */  0xf224,
/* 7e9 - _0F_38_81 */  0xf230,
/* 7ea - _0F_38_82 */  0xf23c,
/* 7eb -  */  0,
/* 7ec -  */  0,
/* 7ed -  */  0,
/* 7ee -  */  0,
/* 7ef -  */  0,
/* 7f0 -  */  0,
/* 7f1 -  */  0,
/* 7f2 -  */  0,
/* 7f3 -  */  0,
/* 7f4 -  */  0,
/* 7f5 -  */  0,
/* 7f6 -  */  0,
/* 7f7 -  */  0,
/* 7f8 -  */  0,
/* 7f9 -  */  0,
/* 7fa -  */  0,
/* 7fb -  */  0,
/* 7fc -  */  0,
/* 7fd -  */  0,
/* 7fe - _0F_38_96 */  0xf248,
/* 7ff - _0F_38_97 */  0xf254,
/* 800 - _0F_38_98 */  0xf260,
/* 801 - _0F_38_99 */  0xf26c,
/* 802 - _0F_38_9A */  0xf278,
/* 803 - _0F_38_9B */  0xf284,
/* 804 - _0F_38_9C */  0xf290,
/* 805 - _0F_38_9D */  0xf29c,
/* 806 - _0F_38_9E */  0xf2a8,
/* 807 - _0F_38_9F */  0xf2b4,
/* 808 -  */  0,
/* 809 -  */  0,
/* 80a -  */  0,
/* 80b -  */  0,
/* 80c -  */  0,
/* 80d -  */  0,
/* 80e - _0F_38_A6 */  0xf2c0,
/* 80f - _0F_38_A7 */  0xf2cc,
/* 810 - _0F_38_A8 */  0xf2d8,
/* 811 - _0F_38_A9 */  0xf2e4,
/* 812 - _0F_38_AA */  0xf2f0,
/* 813 - _0F_38_AB */  0xf2fc,
/* 814 - _0F_38_AC */  0xf308,
/* 815 - _0F_38_AD */  0xf314,
/* 816 - _0F_38_AE */  0xf320,
/* 817 - _0F_38_AF */  0xf32c,
/* 818 -  */  0,
/* 819 -  */  0,
/* 81a -  */  0,
/* 81b -  */  0,
/* 81c -  */  0,
/* 81d -  */  0,
/* 81e - _0F_38_B6 */  0xf338,
/* 81f - _0F_38_B7 */  0xf344,
/* 820 - _0F_38_B8 */  0xf350,
/* 821 - _0F_38_B9 */  0xf35c,
/* 822 - _0F_38_BA */  0xf368,
/* 823 - _0F_38_BB */  0xf374,
/* 824 - _0F_38_BC */  0xf380,
/* 825 - _0F_38_BD */  0xf38c,
/* 826 - _0F_38_BE */  0xf398,
/* 827 - _0F_38_BF */  0xf3a4,
/* 828 -  */  0,
/* 829 -  */  0,
/* 82a -  */  0,
/* 82b -  */  0,
/* 82c -  */  0,
/* 82d -  */  0,
/* 82e -  */  0,
/* 82f -  */  0,
/* 830 -  */  0,
/* 831 -  */  0,
/* 832 -  */  0,
/* 833 -  */  0,
/* 834 -  */  0,
/* 835 -  */  0,
/* 836 -  */  0,
/* 837 -  */  0,
/* 838 -  */  0,
/* 839 -  */  0,
/* 83a -  */  0,
/* 83b -  */  0,
/* 83c -  */  0,
/* 83d -  */  0,
/* 83e -  */  0,
/* 83f -  */  0,
/* 840 -  */  0,
/* 841 -  */  0,
/* 842 -  */  0,
/* 843 - _0F_38_DB */  0xf3b0,
/* 844 - _0F_38_DC */  0xf3bc,
/* 845 - _0F_38_DD */  0xf3c8,
/* 846 - _0F_38_DE */  0xf3d4,
/* 847 - _0F_38_DF */  0xf3e0,
/* 848 -  */  0,
/* 849 -  */  0,
/* 84a -  */  0,
/* 84b -  */  0,
/* 84c -  */  0,
/* 84d -  */  0,
/* 84e -  */  0,
/* 84f -  */  0,
/* 850 -  */  0,
/* 851 -  */  0,
/* 852 -  */  0,
/* 853 -  */  0,
/* 854 -  */  0,
/* 855 -  */  0,
/* 856 -  */  0,
/* 857 -  */  0,
/* 858 - _0F_38_F0 */  0xf3ec,
/* 859 - _0F_38_F1 */  0xf3f8,
/* 85a -  */  0,
/* 85b -  */  0,
/* 85c -  */  0,
/* 85d -  */  0,
/* 85e -  */  0,
/* 85f -  */  0,
/* 860 -  */  0,
/* 861 -  */  0,
/* 862 -  */  0,
/* 863 -  */  0,
/* 864 -  */  0,
/* 865 -  */  0,
/* 866 -  */  0,
/* 867 -  */  0,
/* 868 -  */  0,
/* 869 -  */  0,
/* 86a -  */  0,
/* 86b -  */  0,
/* 86c - _0F_3A_04 */  0xf404,
/* 86d - _0F_3A_05 */  0xf410,
/* 86e - _0F_3A_06 */  0xf41c,
/* 86f -  */  0,
/* 870 - _0F_3A_08 */  0xf428,
/* 871 - _0F_3A_09 */  0xf434,
/* 872 - _0F_3A_0A */  0xf440,
/* 873 - _0F_3A_0B */  0xf44c,
/* 874 - _0F_3A_0C */  0xf458,
/* 875 - _0F_3A_0D */  0xf464,
/* 876 - _0F_3A_0E */  0xf470,
/* 877 - _0F_3A_0F */  0xf47c,
/* 878 -  */  0,
/* 879 -  */  0,
/* 87a -  */  0,
/* 87b -  */  0,
/* 87c - _0F_3A_14 */  0xf488,
/* 87d - _0F_3A_15 */  0xf494,
/* 87e - _0F_3A_16 */  0xf4a0,
/* 87f - _0F_3A_17 */  0xf4ac,
/* 880 - _0F_3A_18 */  0xf4b8,
/* 881 - _0F_3A_19 */  0xf4c4,
/* 882 -  */  0,
/* 883 -  */  0,
/* 884 -  */  0,
/* 885 -  */  0,
/* 886 -  */  0,
/* 887 -  */  0,
/* 888 - _0F_3A_20 */  0xf4d0,
/* 889 - _0F_3A_21 */  0xf4dc,
/* 88a - _0F_3A_22 */  0xf4e8,
/* 88b -  */  0,
/* 88c -  */  0,
/* 88d -  */  0,
/* 88e -  */  0,
/* 88f -  */  0,
/* 890 -  */  0,
/* 891 -  */  0,
/* 892 -  */  0,
/* 893 -  */  0,
/* 894 -  */  0,
/* 895 -  */  0,
/* 896 -  */  0,
/* 897 -  */  0,
/* 898 -  */  0,
/* 899 -  */  0,
/* 89a -  */  0,
/* 89b -  */  0,
/* 89c -  */  0,
/* 89d -  */  0,
/* 89e -  */  0,
/* 89f -  */  0,
/* 8a0 -  */  0,
/* 8a1 -  */  0,
/* 8a2 -  */  0,
/* 8a3 -  */  0,
/* 8a4 -  */  0,
/* 8a5 -  */  0,
/* 8a6 -  */  0,
/* 8a7 -  */  0,
/* 8a8 - _0F_3A_40 */  0xf4f4,
/* 8a9 - _0F_3A_41 */  0xf500,
/* 8aa - _0F_3A_42 */  0xf50c,
/* 8ab -  */  0,
/* 8ac - _0F_3A_44 */  0xf518,
/* 8ad -  */  0,
/* 8ae -  */  0,
/* 8af -  */  0,
/* 8b0 -  */  0,
/* 8b1 -  */  0,
/* 8b2 - _0F_3A_4A */  0xf524,
/* 8b3 - _0F_3A_4B */  0xf530,
/* 8b4 - _0F_3A_4C */  0xf53c,
/* 8b5 -  */  0,
/* 8b6 -  */  0,
/* 8b7 -  */  0,
/* 8b8 -  */  0,
/* 8b9 -  */  0,
/* 8ba -  */  0,
/* 8bb -  */  0,
/* 8bc -  */  0,
/* 8bd -  */  0,
/* 8be -  */  0,
/* 8bf -  */  0,
/* 8c0 -  */  0,
/* 8c1 -  */  0,
/* 8c2 -  */  0,
/* 8c3 -  */  0,
/* 8c4 -  */  0,
/* 8c5 -  */  0,
/* 8c6 -  */  0,
/* 8c7 -  */  0,
/* 8c8 - _0F_3A_60 */  0xf548,
/* 8c9 - _0F_3A_61 */  0xf554,
/* 8ca - _0F_3A_62 */  0xf560,
/* 8cb - _0F_3A_63 */  0xf56c,
/* 8cc -  */  0,
/* 8cd -  */  0,
/* 8ce -  */  0,
/* 8cf -  */  0,
/* 8d0 -  */  0,
/* 8d1 -  */  0,
/* 8d2 -  */  0,
/* 8d3 -  */  0,
/* 8d4 -  */  0,
/* 8d5 -  */  0,
/* 8d6 -  */  0,
/* 8d7 -  */  0,
/* 8d8 -  */  0,
/* 8d9 -  */  0,
/* 8da -  */  0,
/* 8db -  */  0,
/* 8dc -  */  0,
/* 8dd -  */  0,
/* 8de -  */  0,
/* 8df -  */  0,
/* 8e0 -  */  0,
/* 8e1 -  */  0,
/* 8e2 -  */  0,
/* 8e3 -  */  0,
/* 8e4 -  */  0,
/* 8e5 -  */  0,
/* 8e6 -  */  0,
/* 8e7 -  */  0,
/* 8e8 -  */  0,
/* 8e9 -  */  0,
/* 8ea -  */  0,
/* 8eb -  */  0,
/* 8ec -  */  0,
/* 8ed -  */  0,
/* 8ee -  */  0,
/* 8ef -  */  0,
/* 8f0 -  */  0,
/* 8f1 -  */  0,
/* 8f2 -  */  0,
/* 8f3 -  */  0,
/* 8f4 -  */  0,
/* 8f5 -  */  0,
/* 8f6 -  */  0,
/* 8f7 -  */  0,
/* 8f8 -  */  0,
/* 8f9 -  */  0,
/* 8fa -  */  0,
/* 8fb -  */  0,
/* 8fc -  */  0,
/* 8fd -  */  0,
/* 8fe -  */  0,
/* 8ff -  */  0,
/* 900 -  */  0,
/* 901 -  */  0,
/* 902 -  */  0,
/* 903 -  */  0,
/* 904 -  */  0,
/* 905 -  */  0,
/* 906 -  */  0,
/* 907 -  */  0,
/* 908 -  */  0,
/* 909 -  */  0,
/* 90a -  */  0,
/* 90b -  */  0,
/* 90c -  */  0,
/* 90d -  */  0,
/* 90e -  */  0,
/* 90f -  */  0,
/* 910 -  */  0,
/* 911 -  */  0,
/* 912 -  */  0,
/* 913 -  */  0,
/* 914 -  */  0,
/* 915 -  */  0,
/* 916 -  */  0,
/* 917 -  */  0,
/* 918 -  */  0,
/* 919 -  */  0,
/* 91a -  */  0,
/* 91b -  */  0,
/* 91c -  */  0,
/* 91d -  */  0,
/* 91e -  */  0,
/* 91f -  */  0,
/* 920 -  */  0,
/* 921 -  */  0,
/* 922 -  */  0,
/* 923 -  */  0,
/* 924 -  */  0,
/* 925 -  */  0,
/* 926 -  */  0,
/* 927 -  */  0,
/* 928 -  */  0,
/* 929 -  */  0,
/* 92a -  */  0,
/* 92b -  */  0,
/* 92c -  */  0,
/* 92d -  */  0,
/* 92e -  */  0,
/* 92f -  */  0,
/* 930 -  */  0,
/* 931 -  */  0,
/* 932 -  */  0,
/* 933 -  */  0,
/* 934 -  */  0,
/* 935 -  */  0,
/* 936 -  */  0,
/* 937 -  */  0,
/* 938 -  */  0,
/* 939 -  */  0,
/* 93a -  */  0,
/* 93b -  */  0,
/* 93c -  */  0,
/* 93d -  */  0,
/* 93e -  */  0,
/* 93f -  */  0,
/* 940 -  */  0,
/* 941 -  */  0,
/* 942 -  */  0,
/* 943 -  */  0,
/* 944 -  */  0,
/* 945 -  */  0,
/* 946 -  */  0,
/* 947 - _0F_3A_DF */  0xf578,
/* 948 -  */  0,
/* 949 -  */  0,
/* 94a -  */  0,
/* 94b -  */  0,
/* 94c -  */  0,
/* 94d -  */  0,
/* 94e -  */  0,
/* 94f -  */  0,
/* 950 -  */  0,
/* 951 -  */  0,
/* 952 -  */  0,
/* 953 -  */  0,
/* 954 -  */  0,
/* 955 -  */  0,
/* 956 -  */  0,
/* 957 -  */  0,
/* 958 -  */  0,
/* 959 -  */  0,
/* 95a -  */  0,
/* 95b -  */  0,
/* 95c -  */  0,
/* 95d -  */  0,
/* 95e -  */  0,
/* 95f -  */  0,
/* 960 -  */  0,
/* 961 -  */  0,
/* 962 -  */  0,
/* 963 -  */  0,
/* 964 -  */  0,
/* 965 -  */  0,
/* 966 -  */  0,
/* 967 -  */  0,
/* 968 - _0F_50 */  0x23a5,
/* 969 - _66_0F_50 */  0x23a6,
/* 96a -  */  0,
/* 96b -  */  0,
/* 96c - _V_0F_50 */  0x4036,
/* 96d - _V_66_0F_50 */  0x4037,
/* 96e -  */  0,
/* 96f -  */  0,
/* 970 -  */  0,
/* 971 -  */  0,
/* 972 -  */  0,
/* 973 -  */  0,
/* 974 - _0F_51 */  0x23a7,
/* 975 - _66_0F_51 */  0x23a8,
/* 976 - _F3_0F_51 */  0x23a9,
/* 977 - _F2_0F_51 */  0x23aa,
/* 978 - _V_0F_51 */  0x4038,
/* 979 - _V_66_0F_51 */  0x4039,
/* 97a - _V_F3_0F_51 */  0x403a,
/* 97b - _V_F2_0F_51 */  0x403b,
/* 97c -  */  0,
/* 97d -  */  0,
/* 97e -  */  0,
/* 97f -  */  0,
/* 980 - _0F_52 */  0x23ab,
/* 981 -  */  0,
/* 982 - _F3_0F_52 */  0x23ac,
/* 983 -  */  0,
/* 984 - _V_0F_52 */  0x403c,
/* 985 -  */  0,
/* 986 - _V_F3_0F_52 */  0x403d,
/* 987 -  */  0,
/* 988 -  */  0,
/* 989 -  */  0,
/* 98a -  */  0,
/* 98b -  */  0,
/* 98c - _0F_53 */  0x23ad,
/* 98d -  */  0,
/* 98e - _F3_0F_53 */  0x23ae,
/* 98f -  */  0,
/* 990 - _V_0F_53 */  0x403e,
/* 991 -  */  0,
/* 992 - _V_F3_0F_53 */  0x403f,
/* 993 -  */  0,
/* 994 -  */  0,
/* 995 -  */  0,
/* 996 -  */  0,
/* 997 -  */  0,
/* 998 - _0F_54 */  0x23af,
/* 999 - _66_0F_54 */  0x23b0,
/* 99a -  */  0,
/* 99b -  */  0,
/* 99c - _V_0F_54 */  0x4040,
/* 99d - _V_66_0F_54 */  0x4041,
/* 99e -  */  0,
/* 99f -  */  0,
/* 9a0 -  */  0,
/* 9a1 -  */  0,
/* 9a2 -  */  0,
/* 9a3 -  */  0,
/* 9a4 - _0F_55 */  0x23b1,
/* 9a5 - _66_0F_55 */  0x23b2,
/* 9a6 -  */  0,
/* 9a7 -  */  0,
/* 9a8 - _V_0F_55 */  0x4042,
/* 9a9 - _V_66_0F_55 */  0x4043,
/* 9aa -  */  0,
/* 9ab -  */  0,
/* 9ac -  */  0,
/* 9ad -  */  0,
/* 9ae -  */  0,
/* 9af -  */  0,
/* 9b0 - _0F_56 */  0x23b3,
/* 9b1 - _66_0F_56 */  0x23b4,
/* 9b2 -  */  0,
/* 9b3 -  */  0,
/* 9b4 - _V_0F_56 */  0x4044,
/* 9b5 - _V_66_0F_56 */  0x4045,
/* 9b6 -  */  0,
/* 9b7 -  */  0,
/* 9b8 -  */  0,
/* 9b9 -  */  0,
/* 9ba -  */  0,
/* 9bb -  */  0,
/* 9bc - _0F_57 */  0x23b5,
/* 9bd - _66_0F_57 */  0x23b6,
/* 9be -  */  0,
/* 9bf -  */  0,
/* 9c0 - _V_0F_57 */  0x4046,
/* 9c1 - _V_66_0F_57 */  0x4047,
/* 9c2 -  */  0,
/* 9c3 -  */  0,
/* 9c4 -  */  0,
/* 9c5 -  */  0,
/* 9c6 -  */  0,
/* 9c7 -  */  0,
/* 9c8 - _0F_58 */  0x23b7,
/* 9c9 - _66_0F_58 */  0x23b8,
/* 9ca - _F3_0F_58 */  0x23b9,
/* 9cb - _F2_0F_58 */  0x23ba,
/* 9cc - _V_0F_58 */  0x4048,
/* 9cd - _V_66_0F_58 */  0x4049,
/* 9ce - _V_F3_0F_58 */  0x404a,
/* 9cf - _V_F2_0F_58 */  0x404b,
/* 9d0 -  */  0,
/* 9d1 -  */  0,
/* 9d2 -  */  0,
/* 9d3 -  */  0,
/* 9d4 - _0F_59 */  0x23bb,
/* 9d5 - _66_0F_59 */  0x23bc,
/* 9d6 - _F3_0F_59 */  0x23bd,
/* 9d7 - _F2_0F_59 */  0x23be,
/* 9d8 - _V_0F_59 */  0x404c,
/* 9d9 - _V_66_0F_59 */  0x404d,
/* 9da - _V_F3_0F_59 */  0x404e,
/* 9db - _V_F2_0F_59 */  0x404f,
/* 9dc -  */  0,
/* 9dd -  */  0,
/* 9de -  */  0,
/* 9df -  */  0,
/* 9e0 - _0F_5A */  0x23bf,
/* 9e1 - _66_0F_5A */  0x23c0,
/* 9e2 - _F3_0F_5A */  0x23c1,
/* 9e3 - _F2_0F_5A */  0x23c2,
/* 9e4 - _V_0F_5A */  0x4050,
/* 9e5 - _V_66_0F_5A */  0x4051,
/* 9e6 - _V_F3_0F_5A */  0x4052,
/* 9e7 - _V_F2_0F_5A */  0x4053,
/* 9e8 -  */  0,
/* 9e9 -  */  0,
/* 9ea -  */  0,
/* 9eb -  */  0,
/* 9ec - _0F_5B */  0x23c3,
/* 9ed - _66_0F_5B */  0x23c4,
/* 9ee - _F3_0F_5B */  0x23c5,
/* 9ef -  */  0,
/* 9f0 - _V_0F_5B */  0x4054,
/* 9f1 - _V_66_0F_5B */  0x4055,
/* 9f2 - _V_F3_0F_5B */  0x4056,
/* 9f3 -  */  0,
/* 9f4 -  */  0,
/* 9f5 -  */  0,
/* 9f6 -  */  0,
/* 9f7 -  */  0,
/* 9f8 - _0F_5C */  0x23c6,
/* 9f9 - _66_0F_5C */  0x23c7,
/* 9fa - _F3_0F_5C */  0x23c8,
/* 9fb - _F2_0F_5C */  0x23c9,
/* 9fc - _V_0F_5C */  0x4057,
/* 9fd - _V_66_0F_5C */  0x4058,
/* 9fe - _V_F3_0F_5C */  0x4059,
/* 9ff - _V_F2_0F_5C */  0x405a,
/* a00 -  */  0,
/* a01 -  */  0,
/* a02 -  */  0,
/* a03 -  */  0,
/* a04 - _0F_5D */  0x23ca,
/* a05 - _66_0F_5D */  0x23cb,
/* a06 - _F3_0F_5D */  0x23cc,
/* a07 - _F2_0F_5D */  0x23cd,
/* a08 - _V_0F_5D */  0x405b,
/* a09 - _V_66_0F_5D */  0x405c,
/* a0a - _V_F3_0F_5D */  0x405d,
/* a0b - _V_F2_0F_5D */  0x405e,
/* a0c -  */  0,
/* a0d -  */  0,
/* a0e -  */  0,
/* a0f -  */  0,
/* a10 - _0F_5E */  0x23ce,
/* a11 - _66_0F_5E */  0x23cf,
/* a12 - _F3_0F_5E */  0x23d0,
/* a13 - _F2_0F_5E */  0x23d1,
/* a14 - _V_0F_5E */  0x405f,
/* a15 - _V_66_0F_5E */  0x4060,
/* a16 - _V_F3_0F_5E */  0x4061,
/* a17 - _V_F2_0F_5E */  0x4062,
/* a18 -  */  0,
/* a19 -  */  0,
/* a1a -  */  0,
/* a1b -  */  0,
/* a1c - _0F_5F */  0x23d2,
/* a1d - _66_0F_5F */  0x23d3,
/* a1e - _F3_0F_5F */  0x23d4,
/* a1f - _F2_0F_5F */  0x23d5,
/* a20 - _V_0F_5F */  0x4063,
/* a21 - _V_66_0F_5F */  0x4064,
/* a22 - _V_F3_0F_5F */  0x4065,
/* a23 - _V_F2_0F_5F */  0x4066,
/* a24 -  */  0,
/* a25 -  */  0,
/* a26 -  */  0,
/* a27 -  */  0,
/* a28 - _0F_60 */  0x23d6,
/* a29 - _66_0F_60 */  0x23d7,
/* a2a -  */  0,
/* a2b -  */  0,
/* a2c -  */  0,
/* a2d - _V_66_0F_60 */  0x4067,
/* a2e -  */  0,
/* a2f -  */  0,
/* a30 -  */  0,
/* a31 -  */  0,
/* a32 -  */  0,
/* a33 -  */  0,
/* a34 - _0F_61 */  0x23d8,
/* a35 - _66_0F_61 */  0x23d9,
/* a36 -  */  0,
/* a37 -  */  0,
/* a38 -  */  0,
/* a39 - _V_66_0F_61 */  0x4068,
/* a3a -  */  0,
/* a3b -  */  0,
/* a3c -  */  0,
/* a3d -  */  0,
/* a3e -  */  0,
/* a3f -  */  0,
/* a40 - _0F_62 */  0x23da,
/* a41 - _66_0F_62 */  0x23db,
/* a42 -  */  0,
/* a43 -  */  0,
/* a44 -  */  0,
/* a45 - _V_66_0F_62 */  0x4069,
/* a46 -  */  0,
/* a47 -  */  0,
/* a48 -  */  0,
/* a49 -  */  0,
/* a4a -  */  0,
/* a4b -  */  0,
/* a4c - _0F_63 */  0x23dc,
/* a4d - _66_0F_63 */  0x23dd,
/* a4e -  */  0,
/* a4f -  */  0,
/* a50 -  */  0,
/* a51 - _V_66_0F_63 */  0x406a,
/* a52 -  */  0,
/* a53 -  */  0,
/* a54 -  */  0,
/* a55 -  */  0,
/* a56 -  */  0,
/* a57 -  */  0,
/* a58 - _0F_64 */  0x23de,
/* a59 - _66_0F_64 */  0x23df,
/* a5a -  */  0,
/* a5b -  */  0,
/* a5c -  */  0,
/* a5d - _V_66_0F_64 */  0x406b,
/* a5e -  */  0,
/* a5f -  */  0,
/* a60 -  */  0,
/* a61 -  */  0,
/* a62 -  */  0,
/* a63 -  */  0,
/* a64 - _0F_65 */  0x23e0,
/* a65 - _66_0F_65 */  0x23e1,
/* a66 -  */  0,
/* a67 -  */  0,
/* a68 -  */  0,
/* a69 - _V_66_0F_65 */  0x406c,
/* a6a -  */  0,
/* a6b -  */  0,
/* a6c -  */  0,
/* a6d -  */  0,
/* a6e -  */  0,
/* a6f -  */  0,
/* a70 - _0F_66 */  0x23e2,
/* a71 - _66_0F_66 */  0x23e3,
/* a72 -  */  0,
/* a73 -  */  0,
/* a74 -  */  0,
/* a75 - _V_66_0F_66 */  0x406d,
/* a76 -  */  0,
/* a77 -  */  0,
/* a78 -  */  0,
/* a79 -  */  0,
/* a7a -  */  0,
/* a7b -  */  0,
/* a7c - _0F_67 */  0x23e4,
/* a7d - _66_0F_67 */  0x23e5,
/* a7e -  */  0,
/* a7f -  */  0,
/* a80 -  */  0,
/* a81 - _V_66_0F_67 */  0x406e,
/* a82 -  */  0,
/* a83 -  */  0,
/* a84 -  */  0,
/* a85 -  */  0,
/* a86 -  */  0,
/* a87 -  */  0,
/* a88 - _0F_68 */  0x23e6,
/* a89 - _66_0F_68 */  0x23e7,
/* a8a -  */  0,
/* a8b -  */  0,
/* a8c -  */  0,
/* a8d - _V_66_0F_68 */  0x406f,
/* a8e -  */  0,
/* a8f -  */  0,
/* a90 -  */  0,
/* a91 -  */  0,
/* a92 -  */  0,
/* a93 -  */  0,
/* a94 - _0F_69 */  0x23e8,
/* a95 - _66_0F_69 */  0x23e9,
/* a96 -  */  0,
/* a97 -  */  0,
/* a98 -  */  0,
/* a99 - _V_66_0F_69 */  0x4070,
/* a9a -  */  0,
/* a9b -  */  0,
/* a9c -  */  0,
/* a9d -  */  0,
/* a9e -  */  0,
/* a9f -  */  0,
/* aa0 - _0F_6A */  0x23ea,
/* aa1 - _66_0F_6A */  0x23eb,
/* aa2 -  */  0,
/* aa3 -  */  0,
/* aa4 -  */  0,
/* aa5 - _V_66_0F_6A */  0x4071,
/* aa6 -  */  0,
/* aa7 -  */  0,
/* aa8 -  */  0,
/* aa9 -  */  0,
/* aaa -  */  0,
/* aab -  */  0,
/* aac - _0F_6B */  0x23ec,
/* aad - _66_0F_6B */  0x23ed,
/* aae -  */  0,
/* aaf -  */  0,
/* ab0 -  */  0,
/* ab1 - _V_66_0F_6B */  0x4072,
/* ab2 -  */  0,
/* ab3 -  */  0,
/* ab4 -  */  0,
/* ab5 -  */  0,
/* ab6 -  */  0,
/* ab7 -  */  0,
/* ab8 -  */  0,
/* ab9 - _66_0F_6C */  0x23ee,
/* aba -  */  0,
/* abb -  */  0,
/* abc -  */  0,
/* abd - _V_66_0F_6C */  0x4073,
/* abe -  */  0,
/* abf -  */  0,
/* ac0 -  */  0,
/* ac1 -  */  0,
/* ac2 -  */  0,
/* ac3 -  */  0,
/* ac4 -  */  0,
/* ac5 - _66_0F_6D */  0x23ef,
/* ac6 -  */  0,
/* ac7 -  */  0,
/* ac8 -  */  0,
/* ac9 - _V_66_0F_6D */  0x4074,
/* aca -  */  0,
/* acb -  */  0,
/* acc -  */  0,
/* acd -  */  0,
/* ace -  */  0,
/* acf -  */  0,
/* ad0 - _0F_6E */  0x4075,
/* ad1 - _66_0F_6E */  0x4076,
/* ad2 -  */  0,
/* ad3 -  */  0,
/* ad4 -  */  0,
/* ad5 - _V_66_0F_6E */  0x4077,
/* ad6 -  */  0,
/* ad7 -  */  0,
/* ad8 -  */  0,
/* ad9 -  */  0,
/* ada -  */  0,
/* adb -  */  0,
/* adc - _0F_6F */  0x23f0,
/* add - _66_0F_6F */  0x23f1,
/* ade - _F3_0F_6F */  0x23f2,
/* adf -  */  0,
/* ae0 -  */  0,
/* ae1 - _V_66_0F_6F */  0x4078,
/* ae2 - _V_F3_0F_6F */  0x4079,
/* ae3 -  */  0,
/* ae4 -  */  0,
/* ae5 -  */  0,
/* ae6 -  */  0,
/* ae7 -  */  0,
/* ae8 - _0F_70 */  0x407a,
/* ae9 - _66_0F_70 */  0x407b,
/* aea - _F3_0F_70 */  0x407c,
/* aeb - _F2_0F_70 */  0x407d,
/* aec -  */  0,
/* aed - _V_66_0F_70 */  0x407e,
/* aee - _V_F3_0F_70 */  0x407f,
/* aef - _V_F2_0F_70 */  0x4080,
/* af0 -  */  0,
/* af1 -  */  0,
/* af2 -  */  0,
/* af3 -  */  0,
/* af4 -  */  0,
/* af5 -  */  0,
/* af6 - _0F_71_02 */  0xf584,
/* af7 -  */  0,
/* af8 - _0F_71_04 */  0xf590,
/* af9 -  */  0,
/* afa - _0F_71_06 */  0xf59c,
/* afb -  */  0,
/* afc -  */  0,
/* afd -  */  0,
/* afe - _0F_72_02 */  0xf5a8,
/* aff -  */  0,
/* b00 - _0F_72_04 */  0xf5b4,
/* b01 -  */  0,
/* b02 - _0F_72_06 */  0xf5c0,
/* b03 -  */  0,
/* b04 -  */  0,
/* b05 -  */  0,
/* b06 - _0F_73_02 */  0xf5cc,
/* b07 - _0F_73_03 */  0xf5d8,
/* b08 -  */  0,
/* b09 -  */  0,
/* b0a - _0F_73_06 */  0xf5e4,
/* b0b - _0F_73_07 */  0xf5f0,
/* b0c - _0F_74 */  0x23f3,
/* b0d - _66_0F_74 */  0x23f4,
/* b0e -  */  0,
/* b0f -  */  0,
/* b10 -  */  0,
/* b11 - _V_66_0F_74 */  0x4081,
/* b12 -  */  0,
/* b13 -  */  0,
/* b14 -  */  0,
/* b15 -  */  0,
/* b16 -  */  0,
/* b17 -  */  0,
/* b18 - _0F_75 */  0x23f5,
/* b19 - _66_0F_75 */  0x23f6,
/* b1a -  */  0,
/* b1b -  */  0,
/* b1c -  */  0,
/* b1d - _V_66_0F_75 */  0x4082,
/* b1e -  */  0,
/* b1f -  */  0,
/* b20 -  */  0,
/* b21 -  */  0,
/* b22 -  */  0,
/* b23 -  */  0,
/* b24 - _0F_76 */  0x23f7,
/* b25 - _66_0F_76 */  0x23f8,
/* b26 -  */  0,
/* b27 -  */  0,
/* b28 -  */  0,
/* b29 - _V_66_0F_76 */  0x4083,
/* b2a -  */  0,
/* b2b -  */  0,
/* b2c -  */  0,
/* b2d -  */  0,
/* b2e -  */  0,
/* b2f -  */  0,
/* b30 - _0F_77 */  0x23f9,
/* b31 -  */  0,
/* b32 -  */  0,
/* b33 -  */  0,
/* b34 - _V_0F_77 */  0x4084,
/* b35 -  */  0,
/* b36 -  */  0,
/* b37 -  */  0,
/* b38 -  */  0,
/* b39 -  */  0,
/* b3a -  */  0,
/* b3b -  */  0,
/* b3c - _0F_78 */  0x23fa,
/* b3d - _66_0F_78 */  0x4085,
/* b3e -  */  0,
/* b3f - _F2_0F_78 */  0x4086,
/* b40 -  */  0,
/* b41 -  */  0,
/* b42 -  */  0,
/* b43 -  */  0,
/* b44 -  */  0,
/* b45 -  */  0,
/* b46 -  */  0,
/* b47 -  */  0,
/* b48 - _0F_79 */  0x23fb,
/* b49 - _66_0F_79 */  0x23fc,
/* b4a -  */  0,
/* b4b - _F2_0F_79 */  0x23fd,
/* b4c -  */  0,
/* b4d -  */  0,
/* b4e -  */  0,
/* b4f -  */  0,
/* b50 -  */  0,
/* b51 -  */  0,
/* b52 -  */  0,
/* b53 -  */  0,
/* b54 -  */  0,
/* b55 -  */  0,
/* b56 -  */  0,
/* b57 -  */  0,
/* b58 -  */  0,
/* b59 -  */  0,
/* b5a -  */  0,
/* b5b -  */  0,
/* b5c -  */  0,
/* b5d -  */  0,
/* b5e -  */  0,
/* b5f -  */  0,
/* b60 -  */  0,
/* b61 -  */  0,
/* b62 -  */  0,
/* b63 -  */  0,
/* b64 -  */  0,
/* b65 -  */  0,
/* b66 -  */  0,
/* b67 -  */  0,
/* b68 -  */  0,
/* b69 -  */  0,
/* b6a -  */  0,
/* b6b -  */  0,
/* b6c -  */  0,
/* b6d -  */  0,
/* b6e -  */  0,
/* b6f -  */  0,
/* b70 -  */  0,
/* b71 -  */  0,
/* b72 -  */  0,
/* b73 -  */  0,
/* b74 -  */  0,
/* b75 -  */  0,
/* b76 -  */  0,
/* b77 -  */  0,
/* b78 -  */  0,
/* b79 -  */  0,
/* b7a -  */  0,
/* b7b -  */  0,
/* b7c -  */  0,
/* b7d -  */  0,
/* b7e -  */  0,
/* b7f -  */  0,
/* b80 -  */  0,
/* b81 -  */  0,
/* b82 -  */  0,
/* b83 -  */  0,
/* b84 - _0F_7A_30 */  0x23fe,
/* b85 - _0F_7A_31 */  0x23ff,
/* b86 -  */  0,
/* b87 -  */  0,
/* b88 -  */  0,
/* b89 -  */  0,
/* b8a -  */  0,
/* b8b -  */  0,
/* b8c -  */  0,
/* b8d -  */  0,
/* b8e -  */  0,
/* b8f -  */  0,
/* b90 -  */  0,
/* b91 -  */  0,
/* b92 -  */  0,
/* b93 -  */  0,
/* b94 -  */  0,
/* b95 -  */  0,
/* b96 -  */  0,
/* b97 -  */  0,
/* b98 -  */  0,
/* b99 -  */  0,
/* b9a -  */  0,
/* b9b -  */  0,
/* b9c -  */  0,
/* b9d -  */  0,
/* b9e -  */  0,
/* b9f -  */  0,
/* ba0 -  */  0,
/* ba1 -  */  0,
/* ba2 -  */  0,
/* ba3 -  */  0,
/* ba4 -  */  0,
/* ba5 -  */  0,
/* ba6 -  */  0,
/* ba7 -  */  0,
/* ba8 -  */  0,
/* ba9 -  */  0,
/* baa -  */  0,
/* bab -  */  0,
/* bac -  */  0,
/* bad -  */  0,
/* bae -  */  0,
/* baf -  */  0,
/* bb0 -  */  0,
/* bb1 -  */  0,
/* bb2 -  */  0,
/* bb3 -  */  0,
/* bb4 -  */  0,
/* bb5 -  */  0,
/* bb6 -  */  0,
/* bb7 -  */  0,
/* bb8 -  */  0,
/* bb9 -  */  0,
/* bba -  */  0,
/* bbb -  */  0,
/* bbc -  */  0,
/* bbd -  */  0,
/* bbe -  */  0,
/* bbf -  */  0,
/* bc0 -  */  0,
/* bc1 -  */  0,
/* bc2 -  */  0,
/* bc3 -  */  0,
/* bc4 -  */  0,
/* bc5 -  */  0,
/* bc6 -  */  0,
/* bc7 -  */  0,
/* bc8 -  */  0,
/* bc9 -  */  0,
/* bca -  */  0,
/* bcb -  */  0,
/* bcc -  */  0,
/* bcd -  */  0,
/* bce -  */  0,
/* bcf -  */  0,
/* bd0 -  */  0,
/* bd1 -  */  0,
/* bd2 -  */  0,
/* bd3 -  */  0,
/* bd4 -  */  0,
/* bd5 -  */  0,
/* bd6 -  */  0,
/* bd7 -  */  0,
/* bd8 -  */  0,
/* bd9 -  */  0,
/* bda -  */  0,
/* bdb -  */  0,
/* bdc -  */  0,
/* bdd -  */  0,
/* bde -  */  0,
/* bdf -  */  0,
/* be0 -  */  0,
/* be1 -  */  0,
/* be2 -  */  0,
/* be3 -  */  0,
/* be4 -  */  0,
/* be5 -  */  0,
/* be6 -  */  0,
/* be7 -  */  0,
/* be8 -  */  0,
/* be9 -  */  0,
/* bea -  */  0,
/* beb -  */  0,
/* bec -  */  0,
/* bed -  */  0,
/* bee -  */  0,
/* bef -  */  0,
/* bf0 -  */  0,
/* bf1 -  */  0,
/* bf2 -  */  0,
/* bf3 -  */  0,
/* bf4 -  */  0,
/* bf5 -  */  0,
/* bf6 -  */  0,
/* bf7 -  */  0,
/* bf8 -  */  0,
/* bf9 -  */  0,
/* bfa -  */  0,
/* bfb -  */  0,
/* bfc -  */  0,
/* bfd -  */  0,
/* bfe -  */  0,
/* bff -  */  0,
/* c00 -  */  0,
/* c01 -  */  0,
/* c02 -  */  0,
/* c03 -  */  0,
/* c04 -  */  0,
/* c05 -  */  0,
/* c06 -  */  0,
/* c07 -  */  0,
/* c08 -  */  0,
/* c09 -  */  0,
/* c0a -  */  0,
/* c0b -  */  0,
/* c0c -  */  0,
/* c0d -  */  0,
/* c0e -  */  0,
/* c0f -  */  0,
/* c10 -  */  0,
/* c11 -  */  0,
/* c12 -  */  0,
/* c13 -  */  0,
/* c14 -  */  0,
/* c15 -  */  0,
/* c16 -  */  0,
/* c17 -  */  0,
/* c18 -  */  0,
/* c19 -  */  0,
/* c1a -  */  0,
/* c1b -  */  0,
/* c1c -  */  0,
/* c1d -  */  0,
/* c1e -  */  0,
/* c1f -  */  0,
/* c20 -  */  0,
/* c21 -  */  0,
/* c22 -  */  0,
/* c23 -  */  0,
/* c24 -  */  0,
/* c25 -  */  0,
/* c26 -  */  0,
/* c27 -  */  0,
/* c28 -  */  0,
/* c29 -  */  0,
/* c2a -  */  0,
/* c2b -  */  0,
/* c2c -  */  0,
/* c2d -  */  0,
/* c2e -  */  0,
/* c2f -  */  0,
/* c30 -  */  0,
/* c31 -  */  0,
/* c32 -  */  0,
/* c33 -  */  0,
/* c34 -  */  0,
/* c35 -  */  0,
/* c36 -  */  0,
/* c37 -  */  0,
/* c38 -  */  0,
/* c39 -  */  0,
/* c3a -  */  0,
/* c3b -  */  0,
/* c3c -  */  0,
/* c3d -  */  0,
/* c3e -  */  0,
/* c3f -  */  0,
/* c40 -  */  0,
/* c41 -  */  0,
/* c42 -  */  0,
/* c43 -  */  0,
/* c44 -  */  0,
/* c45 -  */  0,
/* c46 -  */  0,
/* c47 -  */  0,
/* c48 -  */  0,
/* c49 -  */  0,
/* c4a -  */  0,
/* c4b -  */  0,
/* c4c -  */  0,
/* c4d -  */  0,
/* c4e -  */  0,
/* c4f -  */  0,
/* c50 -  */  0,
/* c51 -  */  0,
/* c52 -  */  0,
/* c53 -  */  0,
/* c54 -  */  0,
/* c55 - _66_0F_7C */  0x2400,
/* c56 -  */  0,
/* c57 - _F2_0F_7C */  0x2401,
/* c58 -  */  0,
/* c59 - _V_66_0F_7C */  0x4087,
/* c5a -  */  0,
/* c5b - _V_F2_0F_7C */  0x4088,
/* c5c -  */  0,
/* c5d -  */  0,
/* c5e -  */  0,
/* c5f -  */  0,
/* c60 -  */  0,
/* c61 - _66_0F_7D */  0x2402,
/* c62 -  */  0,
/* c63 - _F2_0F_7D */  0x2403,
/* c64 -  */  0,
/* c65 - _V_66_0F_7D */  0x4089,
/* c66 -  */  0,
/* c67 - _V_F2_0F_7D */  0x408a,
/* c68 -  */  0,
/* c69 -  */  0,
/* c6a -  */  0,
/* c6b -  */  0,
/* c6c - _0F_7E */  0x408b,
/* c6d - _66_0F_7E */  0x408c,
/* c6e - _F3_0F_7E */  0x2404,
/* c6f -  */  0,
/* c70 -  */  0,
/* c71 - _V_66_0F_7E */  0x408d,
/* c72 - _V_F3_0F_7E */  0x408e,
/* c73 -  */  0,
/* c74 -  */  0,
/* c75 -  */  0,
/* c76 -  */  0,
/* c77 -  */  0,
/* c78 - _0F_7F */  0x2405,
/* c79 - _66_0F_7F */  0x2406,
/* c7a - _F3_0F_7F */  0x2407,
/* c7b -  */  0,
/* c7c -  */  0,
/* c7d - _V_66_0F_7F */  0x408f,
/* c7e - _V_F3_0F_7F */  0x4090,
/* c7f -  */  0,
/* c80 -  */  0,
/* c81 -  */  0,
/* c82 -  */  0,
/* c83 -  */  0,
/* c84 - _0F_AE_00 */  0xf5fc,
/* c85 - _0F_AE_01 */  0xf608,
/* c86 - _0F_AE_02 */  0xf614,
/* c87 - _0F_AE_03 */  0xf620,
/* c88 - _0F_AE_04 */  0x4091,
/* c89 - _0F_AE_05 */  0x4092,
/* c8a - _0F_AE_06 */  0x4093,
/* c8b - _0F_AE_07 */  0x4094,
/* c8c -  */  0,
/* c8d -  */  0,
/* c8e - _F3_0F_B8 */  0x2408,
/* c8f -  */  0,
/* c90 -  */  0,
/* c91 -  */  0,
/* c92 -  */  0,
/* c93 -  */  0,
/* c94 -  */  0,
/* c95 -  */  0,
/* c96 -  */  0,
/* c97 -  */  0,
/* c98 -  */  0,
/* c99 -  */  0,
/* c9a -  */  0,
/* c9b -  */  0,
/* c9c - _0F_BA_04 */  0x2409,
/* c9d - _0F_BA_05 */  0x240a,
/* c9e - _0F_BA_06 */  0x240b,
/* c9f - _0F_BA_07 */  0x240c,
/* ca0 - _0F_BC */  0x240d,
/* ca1 -  */  0,
/* ca2 - _F3_0F_BC */  0x240e,
/* ca3 -  */  0,
/* ca4 -  */  0,
/* ca5 -  */  0,
/* ca6 -  */  0,
/* ca7 -  */  0,
/* ca8 -  */  0,
/* ca9 -  */  0,
/* caa -  */  0,
/* cab -  */  0,
/* cac - _0F_BD */  0x240f,
/* cad -  */  0,
/* cae - _F3_0F_BD */  0x2410,
/* caf -  */  0,
/* cb0 -  */  0,
/* cb1 -  */  0,
/* cb2 -  */  0,
/* cb3 -  */  0,
/* cb4 -  */  0,
/* cb5 -  */  0,
/* cb6 -  */  0,
/* cb7 -  */  0,
/* cb8 - _0F_C2 */  0x4095,
/* cb9 - _66_0F_C2 */  0x4096,
/* cba - _F3_0F_C2 */  0x4097,
/* cbb - _F2_0F_C2 */  0x4098,
/* cbc - _V_0F_C2 */  0x4099,
/* cbd - _V_66_0F_C2 */  0x409a,
/* cbe - _V_F3_0F_C2 */  0x409b,
/* cbf - _V_F2_0F_C2 */  0x409c,
/* cc0 -  */  0,
/* cc1 -  */  0,
/* cc2 -  */  0,
/* cc3 -  */  0,
/* cc4 - _0F_C4 */  0x409d,
/* cc5 - _66_0F_C4 */  0x409e,
/* cc6 -  */  0,
/* cc7 -  */  0,
/* cc8 -  */  0,
/* cc9 - _V_66_0F_C4 */  0x409f,
/* cca -  */  0,
/* ccb -  */  0,
/* ccc -  */  0,
/* ccd -  */  0,
/* cce -  */  0,
/* ccf -  */  0,
/* cd0 - _0F_C5 */  0x40a0,
/* cd1 - _66_0F_C5 */  0x40a1,
/* cd2 -  */  0,
/* cd3 -  */  0,
/* cd4 -  */  0,
/* cd5 - _V_66_0F_C5 */  0x40a2,
/* cd6 -  */  0,
/* cd7 -  */  0,
/* cd8 -  */  0,
/* cd9 -  */  0,
/* cda -  */  0,
/* cdb -  */  0,
/* cdc - _0F_C6 */  0x40a3,
/* cdd - _66_0F_C6 */  0x40a4,
/* cde -  */  0,
/* cdf -  */  0,
/* ce0 - _V_0F_C6 */  0x40a5,
/* ce1 - _V_66_0F_C6 */  0x40a6,
/* ce2 -  */  0,
/* ce3 -  */  0,
/* ce4 -  */  0,
/* ce5 -  */  0,
/* ce6 -  */  0,
/* ce7 -  */  0,
/* ce8 -  */  0,
/* ce9 - _0F_C7_01 */  0x40a7,
/* cea -  */  0,
/* ceb -  */  0,
/* cec -  */  0,
/* ced -  */  0,
/* cee - _0F_C7_06 */  0xf62c,
/* cef - _0F_C7_07 */  0x2411,
/* cf0 -  */  0,
/* cf1 - _66_0F_D0 */  0x2412,
/* cf2 -  */  0,
/* cf3 - _F2_0F_D0 */  0x2413,
/* cf4 -  */  0,
/* cf5 - _V_66_0F_D0 */  0x40a8,
/* cf6 -  */  0,
/* cf7 - _V_F2_0F_D0 */  0x40a9,
/* cf8 -  */  0,
/* cf9 -  */  0,
/* cfa -  */  0,
/* cfb -  */  0,
/* cfc - _0F_D1 */  0x2414,
/* cfd - _66_0F_D1 */  0x2415,
/* cfe -  */  0,
/* cff -  */  0,
/* d00 -  */  0,
/* d01 - _V_66_0F_D1 */  0x40aa,
/* d02 -  */  0,
/* d03 -  */  0,
/* d04 -  */  0,
/* d05 -  */  0,
/* d06 -  */  0,
/* d07 -  */  0,
/* d08 - _0F_D2 */  0x2416,
/* d09 - _66_0F_D2 */  0x2417,
/* d0a -  */  0,
/* d0b -  */  0,
/* d0c -  */  0,
/* d0d - _V_66_0F_D2 */  0x40ab,
/* d0e -  */  0,
/* d0f -  */  0,
/* d10 -  */  0,
/* d11 -  */  0,
/* d12 -  */  0,
/* d13 -  */  0,
/* d14 - _0F_D3 */  0x2418,
/* d15 - _66_0F_D3 */  0x2419,
/* d16 -  */  0,
/* d17 -  */  0,
/* d18 -  */  0,
/* d19 - _V_66_0F_D3 */  0x40ac,
/* d1a -  */  0,
/* d1b -  */  0,
/* d1c -  */  0,
/* d1d -  */  0,
/* d1e -  */  0,
/* d1f -  */  0,
/* d20 - _0F_D4 */  0x241a,
/* d21 - _66_0F_D4 */  0x241b,
/* d22 -  */  0,
/* d23 -  */  0,
/* d24 -  */  0,
/* d25 - _V_66_0F_D4 */  0x40ad,
/* d26 -  */  0,
/* d27 -  */  0,
/* d28 -  */  0,
/* d29 -  */  0,
/* d2a -  */  0,
/* d2b -  */  0,
/* d2c - _0F_D5 */  0x241c,
/* d2d - _66_0F_D5 */  0x241d,
/* d2e -  */  0,
/* d2f -  */  0,
/* d30 -  */  0,
/* d31 - _V_66_0F_D5 */  0x40ae,
/* d32 -  */  0,
/* d33 -  */  0,
/* d34 -  */  0,
/* d35 -  */  0,
/* d36 -  */  0,
/* d37 -  */  0,
/* d38 -  */  0,
/* d39 - _66_0F_D6 */  0x241e,
/* d3a - _F3_0F_D6 */  0x241f,
/* d3b - _F2_0F_D6 */  0x2420,
/* d3c -  */  0,
/* d3d - _V_66_0F_D6 */  0x40af,
/* d3e -  */  0,
/* d3f -  */  0,
/* d40 -  */  0,
/* d41 -  */  0,
/* d42 -  */  0,
/* d43 -  */  0,
/* d44 - _0F_D7 */  0x2421,
/* d45 - _66_0F_D7 */  0x2422,
/* d46 -  */  0,
/* d47 -  */  0,
/* d48 -  */  0,
/* d49 - _V_66_0F_D7 */  0x40b0,
/* d4a -  */  0,
/* d4b -  */  0,
/* d4c -  */  0,
/* d4d -  */  0,
/* d4e -  */  0,
/* d4f -  */  0,
/* d50 - _0F_D8 */  0x2423,
/* d51 - _66_0F_D8 */  0x2424,
/* d52 -  */  0,
/* d53 -  */  0,
/* d54 -  */  0,
/* d55 - _V_66_0F_D8 */  0x40b1,
/* d56 -  */  0,
/* d57 -  */  0,
/* d58 -  */  0,
/* d59 -  */  0,
/* d5a -  */  0,
/* d5b -  */  0,
/* d5c - _0F_D9 */  0x2425,
/* d5d - _66_0F_D9 */  0x2426,
/* d5e -  */  0,
/* d5f -  */  0,
/* d60 -  */  0,
/* d61 - _V_66_0F_D9 */  0x40b2,
/* d62 -  */  0,
/* d63 -  */  0,
/* d64 -  */  0,
/* d65 -  */  0,
/* d66 -  */  0,
/* d67 -  */  0,
/* d68 - _0F_DA */  0x2427,
/* d69 - _66_0F_DA */  0x2428,
/* d6a -  */  0,
/* d6b -  */  0,
/* d6c -  */  0,
/* d6d - _V_66_0F_DA */  0x40b3,
/* d6e -  */  0,
/* d6f -  */  0,
/* d70 -  */  0,
/* d71 -  */  0,
/* d72 -  */  0,
/* d73 -  */  0,
/* d74 - _0F_DB */  0x2429,
/* d75 - _66_0F_DB */  0x242a,
/* d76 -  */  0,
/* d77 -  */  0,
/* d78 -  */  0,
/* d79 - _V_66_0F_DB */  0x40b4,
/* d7a -  */  0,
/* d7b -  */  0,
/* d7c -  */  0,
/* d7d -  */  0,
/* d7e -  */  0,
/* d7f -  */  0,
/* d80 - _0F_DC */  0x242b,
/* d81 - _66_0F_DC */  0x242c,
/* d82 -  */  0,
/* d83 -  */  0,
/* d84 -  */  0,
/* d85 - _V_66_0F_DC */  0x40b5,
/* d86 -  */  0,
/* d87 -  */  0,
/* d88 -  */  0,
/* d89 -  */  0,
/* d8a -  */  0,
/* d8b -  */  0,
/* d8c - _0F_DD */  0x242d,
/* d8d - _66_0F_DD */  0x242e,
/* d8e -  */  0,
/* d8f -  */  0,
/* d90 -  */  0,
/* d91 - _V_66_0F_DD */  0x40b6,
/* d92 -  */  0,
/* d93 -  */  0,
/* d94 -  */  0,
/* d95 -  */  0,
/* d96 -  */  0,
/* d97 -  */  0,
/* d98 - _0F_DE */  0x242f,
/* d99 - _66_0F_DE */  0x2430,
/* d9a -  */  0,
/* d9b -  */  0,
/* d9c -  */  0,
/* d9d - _V_66_0F_DE */  0x40b7,
/* d9e -  */  0,
/* d9f -  */  0,
/* da0 -  */  0,
/* da1 -  */  0,
/* da2 -  */  0,
/* da3 -  */  0,
/* da4 - _0F_DF */  0x2431,
/* da5 - _66_0F_DF */  0x2432,
/* da6 -  */  0,
/* da7 -  */  0,
/* da8 -  */  0,
/* da9 - _V_66_0F_DF */  0x40b8,
/* daa -  */  0,
/* dab -  */  0,
/* dac -  */  0,
/* dad -  */  0,
/* dae -  */  0,
/* daf -  */  0,
/* db0 - _0F_E0 */  0x2433,
/* db1 - _66_0F_E0 */  0x2434,
/* db2 -  */  0,
/* db3 -  */  0,
/* db4 -  */  0,
/* db5 - _V_66_0F_E0 */  0x40b9,
/* db6 -  */  0,
/* db7 -  */  0,
/* db8 -  */  0,
/* db9 -  */  0,
/* dba -  */  0,
/* dbb -  */  0,
/* dbc - _0F_E1 */  0x2435,
/* dbd - _66_0F_E1 */  0x2436,
/* dbe -  */  0,
/* dbf -  */  0,
/* dc0 -  */  0,
/* dc1 - _V_66_0F_E1 */  0x40ba,
/* dc2 -  */  0,
/* dc3 -  */  0,
/* dc4 -  */  0,
/* dc5 -  */  0,
/* dc6 -  */  0,
/* dc7 -  */  0,
/* dc8 - _0F_E2 */  0x2437,
/* dc9 - _66_0F_E2 */  0x2438,
/* dca -  */  0,
/* dcb -  */  0,
/* dcc -  */  0,
/* dcd - _V_66_0F_E2 */  0x40bb,
/* dce -  */  0,
/* dcf -  */  0,
/* dd0 -  */  0,
/* dd1 -  */  0,
/* dd2 -  */  0,
/* dd3 -  */  0,
/* dd4 - _0F_E3 */  0x2439,
/* dd5 - _66_0F_E3 */  0x243a,
/* dd6 -  */  0,
/* dd7 -  */  0,
/* dd8 -  */  0,
/* dd9 - _V_66_0F_E3 */  0x40bc,
/* dda -  */  0,
/* ddb -  */  0,
/* ddc -  */  0,
/* ddd -  */  0,
/* dde -  */  0,
/* ddf -  */  0,
/* de0 - _0F_E4 */  0x243b,
/* de1 - _66_0F_E4 */  0x243c,
/* de2 -  */  0,
/* de3 -  */  0,
/* de4 -  */  0,
/* de5 - _V_66_0F_E4 */  0x40bd,
/* de6 -  */  0,
/* de7 -  */  0,
/* de8 -  */  0,
/* de9 -  */  0,
/* dea -  */  0,
/* deb -  */  0,
/* dec - _0F_E5 */  0x243d,
/* ded - _66_0F_E5 */  0x243e,
/* dee -  */  0,
/* def -  */  0,
/* df0 -  */  0,
/* df1 - _V_66_0F_E5 */  0x40be,
/* df2 -  */  0,
/* df3 -  */  0,
/* df4 -  */  0,
/* df5 -  */  0,
/* df6 -  */  0,
/* df7 -  */  0,
/* df8 -  */  0,
/* df9 - _66_0F_E6 */  0x243f,
/* dfa - _F3_0F_E6 */  0x2440,
/* dfb - _F2_0F_E6 */  0x2441,
/* dfc -  */  0,
/* dfd - _V_66_0F_E6 */  0x40bf,
/* dfe - _V_F3_0F_E6 */  0x40c0,
/* dff - _V_F2_0F_E6 */  0x40c1,
/* e00 -  */  0,
/* e01 -  */  0,
/* e02 -  */  0,
/* e03 -  */  0,
/* e04 - _0F_E7 */  0x2442,
/* e05 - _66_0F_E7 */  0x2443,
/* e06 -  */  0,
/* e07 -  */  0,
/* e08 -  */  0,
/* e09 - _V_66_0F_E7 */  0x40c2,
/* e0a -  */  0,
/* e0b -  */  0,
/* e0c -  */  0,
/* e0d -  */  0,
/* e0e -  */  0,
/* e0f -  */  0,
/* e10 - _0F_E8 */  0x2444,
/* e11 - _66_0F_E8 */  0x2445,
/* e12 -  */  0,
/* e13 -  */  0,
/* e14 -  */  0,
/* e15 - _V_66_0F_E8 */  0x40c3,
/* e16 -  */  0,
/* e17 -  */  0,
/* e18 -  */  0,
/* e19 -  */  0,
/* e1a -  */  0,
/* e1b -  */  0,
/* e1c - _0F_E9 */  0x2446,
/* e1d - _66_0F_E9 */  0x2447,
/* e1e -  */  0,
/* e1f -  */  0,
/* e20 -  */  0,
/* e21 - _V_66_0F_E9 */  0x40c4,
/* e22 -  */  0,
/* e23 -  */  0,
/* e24 -  */  0,
/* e25 -  */  0,
/* e26 -  */  0,
/* e27 -  */  0,
/* e28 - _0F_EA */  0x2448,
/* e29 - _66_0F_EA */  0x2449,
/* e2a -  */  0,
/* e2b -  */  0,
/* e2c -  */  0,
/* e2d - _V_66_0F_EA */  0x40c5,
/* e2e -  */  0,
/* e2f -  */  0,
/* e30 -  */  0,
/* e31 -  */  0,
/* e32 -  */  0,
/* e33 -  */  0,
/* e34 - _0F_EB */  0x244a,
/* e35 - _66_0F_EB */  0x244b,
/* e36 -  */  0,
/* e37 -  */  0,
/* e38 -  */  0,
/* e39 - _V_66_0F_EB */  0x40c6,
/* e3a -  */  0,
/* e3b -  */  0,
/* e3c -  */  0,
/* e3d -  */  0,
/* e3e -  */  0,
/* e3f -  */  0,
/* e40 - _0F_EC */  0x244c,
/* e41 - _66_0F_EC */  0x244d,
/* e42 -  */  0,
/* e43 -  */  0,
/* e44 -  */  0,
/* e45 - _V_66_0F_EC */  0x40c7,
/* e46 -  */  0,
/* e47 -  */  0,
/* e48 -  */  0,
/* e49 -  */  0,
/* e4a -  */  0,
/* e4b -  */  0,
/* e4c - _0F_ED */  0x244e,
/* e4d - _66_0F_ED */  0x244f,
/* e4e -  */  0,
/* e4f -  */  0,
/* e50 -  */  0,
/* e51 - _V_66_0F_ED */  0x40c8,
/* e52 -  */  0,
/* e53 -  */  0,
/* e54 -  */  0,
/* e55 -  */  0,
/* e56 -  */  0,
/* e57 -  */  0,
/* e58 - _0F_EE */  0x2450,
/* e59 - _66_0F_EE */  0x2451,
/* e5a -  */  0,
/* e5b -  */  0,
/* e5c -  */  0,
/* e5d - _V_66_0F_EE */  0x40c9,
/* e5e -  */  0,
/* e5f -  */  0,
/* e60 -  */  0,
/* e61 -  */  0,
/* e62 -  */  0,
/* e63 -  */  0,
/* e64 - _0F_EF */  0x2452,
/* e65 - _66_0F_EF */  0x2453,
/* e66 -  */  0,
/* e67 -  */  0,
/* e68 -  */  0,
/* e69 - _V_66_0F_EF */  0x40ca,
/* e6a -  */  0,
/* e6b -  */  0,
/* e6c -  */  0,
/* e6d -  */  0,
/* e6e -  */  0,
/* e6f -  */  0,
/* e70 -  */  0,
/* e71 -  */  0,
/* e72 -  */  0,
/* e73 - _F2_0F_F0 */  0x2454,
/* e74 -  */  0,
/* e75 -  */  0,
/* e76 -  */  0,
/* e77 - _V_F2_0F_F0 */  0x40cb,
/* e78 -  */  0,
/* e79 -  */  0,
/* e7a -  */  0,
/* e7b -  */  0,
/* e7c - _0F_F1 */  0x2455,
/* e7d - _66_0F_F1 */  0x2456,
/* e7e -  */  0,
/* e7f -  */  0,
/* e80 -  */  0,
/* e81 - _V_66_0F_F1 */  0x40cc,
/* e82 -  */  0,
/* e83 -  */  0,
/* e84 -  */  0,
/* e85 -  */  0,
/* e86 -  */  0,
/* e87 -  */  0,
/* e88 - _0F_F2 */  0x2457,
/* e89 - _66_0F_F2 */  0x2458,
/* e8a -  */  0,
/* e8b -  */  0,
/* e8c -  */  0,
/* e8d - _V_66_0F_F2 */  0x40cd,
/* e8e -  */  0,
/* e8f -  */  0,
/* e90 -  */  0,
/* e91 -  */  0,
/* e92 -  */  0,
/* e93 -  */  0,
/* e94 - _0F_F3 */  0x2459,
/* e95 - _66_0F_F3 */  0x245a,
/* e96 -  */  0,
/* e97 -  */  0,
/* e98 -  */  0,
/* e99 - _V_66_0F_F3 */  0x40ce,
/* e9a -  */  0,
/* e9b -  */  0,
/* e9c -  */  0,
/* e9d -  */  0,
/* e9e -  */  0,
/* e9f -  */  0,
/* ea0 - _0F_F4 */  0x245b,
/* ea1 - _66_0F_F4 */  0x245c,
/* ea2 -  */  0,
/* ea3 -  */  0,
/* ea4 -  */  0,
/* ea5 - _V_66_0F_F4 */  0x40cf,
/* ea6 -  */  0,
/* ea7 -  */  0,
/* ea8 -  */  0,
/* ea9 -  */  0,
/* eaa -  */  0,
/* eab -  */  0,
/* eac - _0F_F5 */  0x245d,
/* ead - _66_0F_F5 */  0x245e,
/* eae -  */  0,
/* eaf -  */  0,
/* eb0 -  */  0,
/* eb1 - _V_66_0F_F5 */  0x40d0,
/* eb2 -  */  0,
/* eb3 -  */  0,
/* eb4 -  */  0,
/* eb5 -  */  0,
/* eb6 -  */  0,
/* eb7 -  */  0,
/* eb8 - _0F_F6 */  0x245f,
/* eb9 - _66_0F_F6 */  0x2460,
/* eba -  */  0,
/* ebb -  */  0,
/* ebc -  */  0,
/* ebd - _V_66_0F_F6 */  0x40d1,
/* ebe -  */  0,
/* ebf -  */  0,
/* ec0 -  */  0,
/* ec1 -  */  0,
/* ec2 -  */  0,
/* ec3 -  */  0,
/* ec4 - _0F_F7 */  0x2461,
/* ec5 - _66_0F_F7 */  0x2462,
/* ec6 -  */  0,
/* ec7 -  */  0,
/* ec8 -  */  0,
/* ec9 - _V_66_0F_F7 */  0x40d2,
/* eca -  */  0,
/* ecb -  */  0,
/* ecc -  */  0,
/* ecd -  */  0,
/* ece -  */  0,
/* ecf -  */  0,
/* ed0 - _0F_F8 */  0x2463,
/* ed1 - _66_0F_F8 */  0x2464,
/* ed2 -  */  0,
/* ed3 -  */  0,
/* ed4 -  */  0,
/* ed5 - _V_66_0F_F8 */  0x40d3,
/* ed6 -  */  0,
/* ed7 -  */  0,
/* ed8 -  */  0,
/* ed9 -  */  0,
/* eda -  */  0,
/* edb -  */  0,
/* edc - _0F_F9 */  0x2465,
/* edd - _66_0F_F9 */  0x2466,
/* ede -  */  0,
/* edf -  */  0,
/* ee0 -  */  0,
/* ee1 - _V_66_0F_F9 */  0x40d4,
/* ee2 -  */  0,
/* ee3 -  */  0,
/* ee4 -  */  0,
/* ee5 -  */  0,
/* ee6 -  */  0,
/* ee7 -  */  0,
/* ee8 - _0F_FA */  0x2467,
/* ee9 - _66_0F_FA */  0x2468,
/* eea -  */  0,
/* eeb -  */  0,
/* eec -  */  0,
/* eed - _V_66_0F_FA */  0x40d5,
/* eee -  */  0,
/* eef -  */  0,
/* ef0 -  */  0,
/* ef1 -  */  0,
/* ef2 -  */  0,
/* ef3 -  */  0,
/* ef4 - _0F_FB */  0x2469,
/* ef5 - _66_0F_FB */  0x246a,
/* ef6 -  */  0,
/* ef7 -  */  0,
/* ef8 -  */  0,
/* ef9 - _V_66_0F_FB */  0x40d6,
/* efa -  */  0,
/* efb -  */  0,
/* efc -  */  0,
/* efd -  */  0,
/* efe -  */  0,
/* eff -  */  0,
/* f00 - _0F_FC */  0x246b,
/* f01 - _66_0F_FC */  0x246c,
/* f02 -  */  0,
/* f03 -  */  0,
/* f04 -  */  0,
/* f05 - _V_66_0F_FC */  0x40d7,
/* f06 -  */  0,
/* f07 -  */  0,
/* f08 -  */  0,
/* f09 -  */  0,
/* f0a -  */  0,
/* f0b -  */  0,
/* f0c - _0F_FD */  0x246d,
/* f0d - _66_0F_FD */  0x246e,
/* f0e -  */  0,
/* f0f -  */  0,
/* f10 -  */  0,
/* f11 - _V_66_0F_FD */  0x40d8,
/* f12 -  */  0,
/* f13 -  */  0,
/* f14 -  */  0,
/* f15 -  */  0,
/* f16 -  */  0,
/* f17 -  */  0,
/* f18 - _0F_FE */  0x246f,
/* f19 - _66_0F_FE */  0x2470,
/* f1a -  */  0,
/* f1b -  */  0,
/* f1c -  */  0,
/* f1d - _V_66_0F_FE */  0x40d9,
/* f1e -  */  0,
/* f1f -  */  0,
/* f20 -  */  0,
/* f21 -  */  0,
/* f22 -  */  0,
/* f23 -  */  0,
/* f24 - _D9_06 */  0x2471,
/* f25 - _9B_D9_06 */  0x2472,
/* f26 -  */  0,
/* f27 -  */  0,
/* f28 -  */  0,
/* f29 -  */  0,
/* f2a -  */  0,
/* f2b -  */  0,
/* f2c -  */  0,
/* f2d -  */  0,
/* f2e -  */  0,
/* f2f -  */  0,
/* f30 - _D9_07 */  0x2473,
/* f31 - _9B_D9_07 */  0x2474,
/* f32 -  */  0,
/* f33 -  */  0,
/* f34 -  */  0,
/* f35 -  */  0,
/* f36 -  */  0,
/* f37 -  */  0,
/* f38 -  */  0,
/* f39 -  */  0,
/* f3a -  */  0,
/* f3b -  */  0,
/* f3c - _DB_E2 */  0x2475,
/* f3d - _9B_DB_E2 */  0x2476,
/* f3e -  */  0,
/* f3f -  */  0,
/* f40 -  */  0,
/* f41 -  */  0,
/* f42 -  */  0,
/* f43 -  */  0,
/* f44 -  */  0,
/* f45 -  */  0,
/* f46 -  */  0,
/* f47 -  */  0,
/* f48 - _DB_E3 */  0x2477,
/* f49 - _9B_DB_E3 */  0x2478,
/* f4a -  */  0,
/* f4b -  */  0,
/* f4c -  */  0,
/* f4d -  */  0,
/* f4e -  */  0,
/* f4f -  */  0,
/* f50 -  */  0,
/* f51 -  */  0,
/* f52 -  */  0,
/* f53 -  */  0,
/* f54 - _DD_06 */  0x2479,
/* f55 - _9B_DD_06 */  0x247a,
/* f56 -  */  0,
/* f57 -  */  0,
/* f58 -  */  0,
/* f59 -  */  0,
/* f5a -  */  0,
/* f5b -  */  0,
/* f5c -  */  0,
/* f5d -  */  0,
/* f5e -  */  0,
/* f5f -  */  0,
/* f60 - _DD_07 */  0x247b,
/* f61 - _9B_DD_07 */  0x247c,
/* f62 -  */  0,
/* f63 -  */  0,
/* f64 -  */  0,
/* f65 -  */  0,
/* f66 -  */  0,
/* f67 -  */  0,
/* f68 -  */  0,
/* f69 -  */  0,
/* f6a -  */  0,
/* f6b -  */  0,
/* f6c - _DF_E0 */  0x247d,
/* f6d - _9B_DF_E0 */  0x247e,
/* f6e -  */  0,
/* f6f -  */  0,
/* f70 -  */  0,
/* f71 -  */  0,
/* f72 -  */  0,
/* f73 -  */  0,
/* f74 -  */  0,
/* f75 -  */  0,
/* f76 -  */  0,
/* f77 -  */  0,
/* f78 - _0F_38_00 */  0x247f,
/* f79 - _66_0F_38_00 */  0x2480,
/* f7a -  */  0,
/* f7b -  */  0,
/* f7c -  */  0,
/* f7d - _V_66_0F_38_00 */  0x40da,
/* f7e -  */  0,
/* f7f -  */  0,
/* f80 -  */  0,
/* f81 -  */  0,
/* f82 -  */  0,
/* f83 -  */  0,
/* f84 - _0F_38_01 */  0x2481,
/* f85 - _66_0F_38_01 */  0x2482,
/* f86 -  */  0,
/* f87 -  */  0,
/* f88 -  */  0,
/* f89 - _V_66_0F_38_01 */  0x40db,
/* f8a -  */  0,
/* f8b -  */  0,
/* f8c -  */  0,
/* f8d -  */  0,
/* f8e -  */  0,
/* f8f -  */  0,
/* f90 - _0F_38_02 */  0x2483,
/* f91 - _66_0F_38_02 */  0x2484,
/* f92 -  */  0,
/* f93 -  */  0,
/* f94 -  */  0,
/* f95 - _V_66_0F_38_02 */  0x40dc,
/* f96 -  */  0,
/* f97 -  */  0,
/* f98 -  */  0,
/* f99 -  */  0,
/* f9a -  */  0,
/* f9b -  */  0,
/* f9c - _0F_38_03 */  0x2485,
/* f9d - _66_0F_38_03 */  0x2486,
/* f9e -  */  0,
/* f9f -  */  0,
/* fa0 -  */  0,
/* fa1 - _V_66_0F_38_03 */  0x40dd,
/* fa2 -  */  0,
/* fa3 -  */  0,
/* fa4 -  */  0,
/* fa5 -  */  0,
/* fa6 -  */  0,
/* fa7 -  */  0,
/* fa8 - _0F_38_04 */  0x2487,
/* fa9 - _66_0F_38_04 */  0x2488,
/* faa -  */  0,
/* fab -  */  0,
/* fac -  */  0,
/* fad - _V_66_0F_38_04 */  0x40de,
/* fae -  */  0,
/* faf -  */  0,
/* fb0 -  */  0,
/* fb1 -  */  0,
/* fb2 -  */  0,
/* fb3 -  */  0,
/* fb4 - _0F_38_05 */  0x2489,
/* fb5 - _66_0F_38_05 */  0x248a,
/* fb6 -  */  0,
/* fb7 -  */  0,
/* fb8 -  */  0,
/* fb9 - _V_66_0F_38_05 */  0x40df,
/* fba -  */  0,
/* fbb -  */  0,
/* fbc -  */  0,
/* fbd -  */  0,
/* fbe -  */  0,
/* fbf -  */  0,
/* fc0 - _0F_38_06 */  0x248b,
/* fc1 - _66_0F_38_06 */  0x248c,
/* fc2 -  */  0,
/* fc3 -  */  0,
/* fc4 -  */  0,
/* fc5 - _V_66_0F_38_06 */  0x40e0,
/* fc6 -  */  0,
/* fc7 -  */  0,
/* fc8 -  */  0,
/* fc9 -  */  0,
/* fca -  */  0,
/* fcb -  */  0,
/* fcc - _0F_38_07 */  0x248d,
/* fcd - _66_0F_38_07 */  0x248e,
/* fce -  */  0,
/* fcf -  */  0,
/* fd0 -  */  0,
/* fd1 - _V_66_0F_38_07 */  0x40e1,
/* fd2 -  */  0,
/* fd3 -  */  0,
/* fd4 -  */  0,
/* fd5 -  */  0,
/* fd6 -  */  0,
/* fd7 -  */  0,
/* fd8 - _0F_38_08 */  0x248f,
/* fd9 - _66_0F_38_08 */  0x2490,
/* fda -  */  0,
/* fdb -  */  0,
/* fdc -  */  0,
/* fdd - _V_66_0F_38_08 */  0x40e2,
/* fde -  */  0,
/* fdf -  */  0,
/* fe0 -  */  0,
/* fe1 -  */  0,
/* fe2 -  */  0,
/* fe3 -  */  0,
/* fe4 - _0F_38_09 */  0x2491,
/* fe5 - _66_0F_38_09 */  0x2492,
/* fe6 -  */  0,
/* fe7 -  */  0,
/* fe8 -  */  0,
/* fe9 - _V_66_0F_38_09 */  0x40e3,
/* fea -  */  0,
/* feb -  */  0,
/* fec -  */  0,
/* fed -  */  0,
/* fee -  */  0,
/* fef -  */  0,
/* ff0 - _0F_38_0A */  0x2493,
/* ff1 - _66_0F_38_0A */  0x2494,
/* ff2 -  */  0,
/* ff3 -  */  0,
/* ff4 -  */  0,
/* ff5 - _V_66_0F_38_0A */  0x40e4,
/* ff6 -  */  0,
/* ff7 -  */  0,
/* ff8 -  */  0,
/* ff9 -  */  0,
/* ffa -  */  0,
/* ffb -  */  0,
/* ffc - _0F_38_0B */  0x2495,
/* ffd - _66_0F_38_0B */  0x2496,
/* ffe -  */  0,
/* fff -  */  0,
/* 1000 -  */  0,
/* 1001 - _V_66_0F_38_0B */  0x40e5,
/* 1002 -  */  0,
/* 1003 -  */  0,
/* 1004 -  */  0,
/* 1005 -  */  0,
/* 1006 -  */  0,
/* 1007 -  */  0,
/* 1008 -  */  0,
/* 1009 -  */  0,
/* 100a -  */  0,
/* 100b -  */  0,
/* 100c -  */  0,
/* 100d - _V_66_0F_38_0C */  0x40e6,
/* 100e -  */  0,
/* 100f -  */  0,
/* 1010 -  */  0,
/* 1011 -  */  0,
/* 1012 -  */  0,
/* 1013 -  */  0,
/* 1014 -  */  0,
/* 1015 -  */  0,
/* 1016 -  */  0,
/* 1017 -  */  0,
/* 1018 -  */  0,
/* 1019 - _V_66_0F_38_0D */  0x40e7,
/* 101a -  */  0,
/* 101b -  */  0,
/* 101c -  */  0,
/* 101d -  */  0,
/* 101e -  */  0,
/* 101f -  */  0,
/* 1020 -  */  0,
/* 1021 -  */  0,
/* 1022 -  */  0,
/* 1023 -  */  0,
/* 1024 -  */  0,
/* 1025 - _V_66_0F_38_0E */  0x40e8,
/* 1026 -  */  0,
/* 1027 -  */  0,
/* 1028 -  */  0,
/* 1029 -  */  0,
/* 102a -  */  0,
/* 102b -  */  0,
/* 102c -  */  0,
/* 102d -  */  0,
/* 102e -  */  0,
/* 102f -  */  0,
/* 1030 -  */  0,
/* 1031 - _V_66_0F_38_0F */  0x40e9,
/* 1032 -  */  0,
/* 1033 -  */  0,
/* 1034 -  */  0,
/* 1035 -  */  0,
/* 1036 -  */  0,
/* 1037 -  */  0,
/* 1038 -  */  0,
/* 1039 - _66_0F_38_10 */  0x40ea,
/* 103a -  */  0,
/* 103b -  */  0,
/* 103c -  */  0,
/* 103d -  */  0,
/* 103e -  */  0,
/* 103f -  */  0,
/* 1040 -  */  0,
/* 1041 -  */  0,
/* 1042 -  */  0,
/* 1043 -  */  0,
/* 1044 -  */  0,
/* 1045 - _66_0F_38_14 */  0x40eb,
/* 1046 -  */  0,
/* 1047 -  */  0,
/* 1048 -  */  0,
/* 1049 -  */  0,
/* 104a -  */  0,
/* 104b -  */  0,
/* 104c -  */  0,
/* 104d -  */  0,
/* 104e -  */  0,
/* 104f -  */  0,
/* 1050 -  */  0,
/* 1051 - _66_0F_38_15 */  0x40ec,
/* 1052 -  */  0,
/* 1053 -  */  0,
/* 1054 -  */  0,
/* 1055 -  */  0,
/* 1056 -  */  0,
/* 1057 -  */  0,
/* 1058 -  */  0,
/* 1059 -  */  0,
/* 105a -  */  0,
/* 105b -  */  0,
/* 105c -  */  0,
/* 105d - _66_0F_38_17 */  0x2497,
/* 105e -  */  0,
/* 105f -  */  0,
/* 1060 -  */  0,
/* 1061 - _V_66_0F_38_17 */  0x40ed,
/* 1062 -  */  0,
/* 1063 -  */  0,
/* 1064 -  */  0,
/* 1065 -  */  0,
/* 1066 -  */  0,
/* 1067 -  */  0,
/* 1068 -  */  0,
/* 1069 -  */  0,
/* 106a -  */  0,
/* 106b -  */  0,
/* 106c -  */  0,
/* 106d - _V_66_0F_38_18 */  0x40ee,
/* 106e -  */  0,
/* 106f -  */  0,
/* 1070 -  */  0,
/* 1071 -  */  0,
/* 1072 -  */  0,
/* 1073 -  */  0,
/* 1074 -  */  0,
/* 1075 -  */  0,
/* 1076 -  */  0,
/* 1077 -  */  0,
/* 1078 -  */  0,
/* 1079 - _V_66_0F_38_19 */  0x40ef,
/* 107a -  */  0,
/* 107b -  */  0,
/* 107c -  */  0,
/* 107d -  */  0,
/* 107e -  */  0,
/* 107f -  */  0,
/* 1080 -  */  0,
/* 1081 -  */  0,
/* 1082 -  */  0,
/* 1083 -  */  0,
/* 1084 -  */  0,
/* 1085 - _V_66_0F_38_1A */  0x40f0,
/* 1086 -  */  0,
/* 1087 -  */  0,
/* 1088 -  */  0,
/* 1089 -  */  0,
/* 108a -  */  0,
/* 108b -  */  0,
/* 108c - _0F_38_1C */  0x2498,
/* 108d - _66_0F_38_1C */  0x2499,
/* 108e -  */  0,
/* 108f -  */  0,
/* 1090 -  */  0,
/* 1091 - _V_66_0F_38_1C */  0x40f1,
/* 1092 -  */  0,
/* 1093 -  */  0,
/* 1094 -  */  0,
/* 1095 -  */  0,
/* 1096 -  */  0,
/* 1097 -  */  0,
/* 1098 - _0F_38_1D */  0x249a,
/* 1099 - _66_0F_38_1D */  0x249b,
/* 109a -  */  0,
/* 109b -  */  0,
/* 109c -  */  0,
/* 109d - _V_66_0F_38_1D */  0x40f2,
/* 109e -  */  0,
/* 109f -  */  0,
/* 10a0 -  */  0,
/* 10a1 -  */  0,
/* 10a2 -  */  0,
/* 10a3 -  */  0,
/* 10a4 - _0F_38_1E */  0x249c,
/* 10a5 - _66_0F_38_1E */  0x249d,
/* 10a6 -  */  0,
/* 10a7 -  */  0,
/* 10a8 -  */  0,
/* 10a9 - _V_66_0F_38_1E */  0x40f3,
/* 10aa -  */  0,
/* 10ab -  */  0,
/* 10ac -  */  0,
/* 10ad -  */  0,
/* 10ae -  */  0,
/* 10af -  */  0,
/* 10b0 -  */  0,
/* 10b1 - _66_0F_38_20 */  0x249e,
/* 10b2 -  */  0,
/* 10b3 -  */  0,
/* 10b4 -  */  0,
/* 10b5 - _V_66_0F_38_20 */  0x40f4,
/* 10b6 -  */  0,
/* 10b7 -  */  0,
/* 10b8 -  */  0,
/* 10b9 -  */  0,
/* 10ba -  */  0,
/* 10bb -  */  0,
/* 10bc -  */  0,
/* 10bd - _66_0F_38_21 */  0x249f,
/* 10be -  */  0,
/* 10bf -  */  0,
/* 10c0 -  */  0,
/* 10c1 - _V_66_0F_38_21 */  0x40f5,
/* 10c2 -  */  0,
/* 10c3 -  */  0,
/* 10c4 -  */  0,
/* 10c5 -  */  0,
/* 10c6 -  */  0,
/* 10c7 -  */  0,
/* 10c8 -  */  0,
/* 10c9 - _66_0F_38_22 */  0x24a0,
/* 10ca -  */  0,
/* 10cb -  */  0,
/* 10cc -  */  0,
/* 10cd - _V_66_0F_38_22 */  0x40f6,
/* 10ce -  */  0,
/* 10cf -  */  0,
/* 10d0 -  */  0,
/* 10d1 -  */  0,
/* 10d2 -  */  0,
/* 10d3 -  */  0,
/* 10d4 -  */  0,
/* 10d5 - _66_0F_38_23 */  0x24a1,
/* 10d6 -  */  0,
/* 10d7 -  */  0,
/* 10d8 -  */  0,
/* 10d9 - _V_66_0F_38_23 */  0x40f7,
/* 10da -  */  0,
/* 10db -  */  0,
/* 10dc -  */  0,
/* 10dd -  */  0,
/* 10de -  */  0,
/* 10df -  */  0,
/* 10e0 -  */  0,
/* 10e1 - _66_0F_38_24 */  0x24a2,
/* 10e2 -  */  0,
/* 10e3 -  */  0,
/* 10e4 -  */  0,
/* 10e5 - _V_66_0F_38_24 */  0x40f8,
/* 10e6 -  */  0,
/* 10e7 -  */  0,
/* 10e8 -  */  0,
/* 10e9 -  */  0,
/* 10ea -  */  0,
/* 10eb -  */  0,
/* 10ec -  */  0,
/* 10ed - _66_0F_38_25 */  0x24a3,
/* 10ee -  */  0,
/* 10ef -  */  0,
/* 10f0 -  */  0,
/* 10f1 - _V_66_0F_38_25 */  0x40f9,
/* 10f2 -  */  0,
/* 10f3 -  */  0,
/* 10f4 -  */  0,
/* 10f5 -  */  0,
/* 10f6 -  */  0,
/* 10f7 -  */  0,
/* 10f8 -  */  0,
/* 10f9 - _66_0F_38_28 */  0x24a4,
/* 10fa -  */  0,
/* 10fb -  */  0,
/* 10fc -  */  0,
/* 10fd - _V_66_0F_38_28 */  0x40fa,
/* 10fe -  */  0,
/* 10ff -  */  0,
/* 1100 -  */  0,
/* 1101 -  */  0,
/* 1102 -  */  0,
/* 1103 -  */  0,
/* 1104 -  */  0,
/* 1105 - _66_0F_38_29 */  0x24a5,
/* 1106 -  */  0,
/* 1107 -  */  0,
/* 1108 -  */  0,
/* 1109 - _V_66_0F_38_29 */  0x40fb,
/* 110a -  */  0,
/* 110b -  */  0,
/* 110c -  */  0,
/* 110d -  */  0,
/* 110e -  */  0,
/* 110f -  */  0,
/* 1110 -  */  0,
/* 1111 - _66_0F_38_2A */  0x24a6,
/* 1112 -  */  0,
/* 1113 -  */  0,
/* 1114 -  */  0,
/* 1115 - _V_66_0F_38_2A */  0x40fc,
/* 1116 -  */  0,
/* 1117 -  */  0,
/* 1118 -  */  0,
/* 1119 -  */  0,
/* 111a -  */  0,
/* 111b -  */  0,
/* 111c -  */  0,
/* 111d - _66_0F_38_2B */  0x24a7,
/* 111e -  */  0,
/* 111f -  */  0,
/* 1120 -  */  0,
/* 1121 - _V_66_0F_38_2B */  0x40fd,
/* 1122 -  */  0,
/* 1123 -  */  0,
/* 1124 -  */  0,
/* 1125 -  */  0,
/* 1126 -  */  0,
/* 1127 -  */  0,
/* 1128 -  */  0,
/* 1129 -  */  0,
/* 112a -  */  0,
/* 112b -  */  0,
/* 112c -  */  0,
/* 112d - _V_66_0F_38_2C */  0x40fe,
/* 112e -  */  0,
/* 112f -  */  0,
/* 1130 -  */  0,
/* 1131 -  */  0,
/* 1132 -  */  0,
/* 1133 -  */  0,
/* 1134 -  */  0,
/* 1135 -  */  0,
/* 1136 -  */  0,
/* 1137 -  */  0,
/* 1138 -  */  0,
/* 1139 - _V_66_0F_38_2D */  0x40ff,
/* 113a -  */  0,
/* 113b -  */  0,
/* 113c -  */  0,
/* 113d -  */  0,
/* 113e -  */  0,
/* 113f -  */  0,
/* 1140 -  */  0,
/* 1141 -  */  0,
/* 1142 -  */  0,
/* 1143 -  */  0,
/* 1144 -  */  0,
/* 1145 - _V_66_0F_38_2E */  0x4100,
/* 1146 -  */  0,
/* 1147 -  */  0,
/* 1148 -  */  0,
/* 1149 -  */  0,
/* 114a -  */  0,
/* 114b -  */  0,
/* 114c -  */  0,
/* 114d -  */  0,
/* 114e -  */  0,
/* 114f -  */  0,
/* 1150 -  */  0,
/* 1151 - _V_66_0F_38_2F */  0x4101,
/* 1152 -  */  0,
/* 1153 -  */  0,
/* 1154 -  */  0,
/* 1155 -  */  0,
/* 1156 -  */  0,
/* 1157 -  */  0,
/* 1158 -  */  0,
/* 1159 - _66_0F_38_30 */  0x24a8,
/* 115a -  */  0,
/* 115b -  */  0,
/* 115c -  */  0,
/* 115d - _V_66_0F_38_30 */  0x4102,
/* 115e -  */  0,
/* 115f -  */  0,
/* 1160 -  */  0,
/* 1161 -  */  0,
/* 1162 -  */  0,
/* 1163 -  */  0,
/* 1164 -  */  0,
/* 1165 - _66_0F_38_31 */  0x24a9,
/* 1166 -  */  0,
/* 1167 -  */  0,
/* 1168 -  */  0,
/* 1169 - _V_66_0F_38_31 */  0x4103,
/* 116a -  */  0,
/* 116b -  */  0,
/* 116c -  */  0,
/* 116d -  */  0,
/* 116e -  */  0,
/* 116f -  */  0,
/* 1170 -  */  0,
/* 1171 - _66_0F_38_32 */  0x24aa,
/* 1172 -  */  0,
/* 1173 -  */  0,
/* 1174 -  */  0,
/* 1175 - _V_66_0F_38_32 */  0x4104,
/* 1176 -  */  0,
/* 1177 -  */  0,
/* 1178 -  */  0,
/* 1179 -  */  0,
/* 117a -  */  0,
/* 117b -  */  0,
/* 117c -  */  0,
/* 117d - _66_0F_38_33 */  0x24ab,
/* 117e -  */  0,
/* 117f -  */  0,
/* 1180 -  */  0,
/* 1181 - _V_66_0F_38_33 */  0x4105,
/* 1182 -  */  0,
/* 1183 -  */  0,
/* 1184 -  */  0,
/* 1185 -  */  0,
/* 1186 -  */  0,
/* 1187 -  */  0,
/* 1188 -  */  0,
/* 1189 - _66_0F_38_34 */  0x24ac,
/* 118a -  */  0,
/* 118b -  */  0,
/* 118c -  */  0,
/* 118d - _V_66_0F_38_34 */  0x4106,
/* 118e -  */  0,
/* 118f -  */  0,
/* 1190 -  */  0,
/* 1191 -  */  0,
/* 1192 -  */  0,
/* 1193 -  */  0,
/* 1194 -  */  0,
/* 1195 - _66_0F_38_35 */  0x24ad,
/* 1196 -  */  0,
/* 1197 -  */  0,
/* 1198 -  */  0,
/* 1199 - _V_66_0F_38_35 */  0x4107,
/* 119a -  */  0,
/* 119b -  */  0,
/* 119c -  */  0,
/* 119d -  */  0,
/* 119e -  */  0,
/* 119f -  */  0,
/* 11a0 -  */  0,
/* 11a1 - _66_0F_38_37 */  0x24ae,
/* 11a2 -  */  0,
/* 11a3 -  */  0,
/* 11a4 -  */  0,
/* 11a5 - _V_66_0F_38_37 */  0x4108,
/* 11a6 -  */  0,
/* 11a7 -  */  0,
/* 11a8 -  */  0,
/* 11a9 -  */  0,
/* 11aa -  */  0,
/* 11ab -  */  0,
/* 11ac -  */  0,
/* 11ad - _66_0F_38_38 */  0x24af,
/* 11ae -  */  0,
/* 11af -  */  0,
/* 11b0 -  */  0,
/* 11b1 - _V_66_0F_38_38 */  0x4109,
/* 11b2 -  */  0,
/* 11b3 -  */  0,
/* 11b4 -  */  0,
/* 11b5 -  */  0,
/* 11b6 -  */  0,
/* 11b7 -  */  0,
/* 11b8 -  */  0,
/* 11b9 - _66_0F_38_39 */  0x24b0,
/* 11ba -  */  0,
/* 11bb -  */  0,
/* 11bc -  */  0,
/* 11bd - _V_66_0F_38_39 */  0x410a,
/* 11be -  */  0,
/* 11bf -  */  0,
/* 11c0 -  */  0,
/* 11c1 -  */  0,
/* 11c2 -  */  0,
/* 11c3 -  */  0,
/* 11c4 -  */  0,
/* 11c5 - _66_0F_38_3A */  0x24b1,
/* 11c6 -  */  0,
/* 11c7 -  */  0,
/* 11c8 -  */  0,
/* 11c9 - _V_66_0F_38_3A */  0x410b,
/* 11ca -  */  0,
/* 11cb -  */  0,
/* 11cc -  */  0,
/* 11cd -  */  0,
/* 11ce -  */  0,
/* 11cf -  */  0,
/* 11d0 -  */  0,
/* 11d1 - _66_0F_38_3B */  0x24b2,
/* 11d2 -  */  0,
/* 11d3 -  */  0,
/* 11d4 -  */  0,
/* 11d5 - _V_66_0F_38_3B */  0x410c,
/* 11d6 -  */  0,
/* 11d7 -  */  0,
/* 11d8 -  */  0,
/* 11d9 -  */  0,
/* 11da -  */  0,
/* 11db -  */  0,
/* 11dc -  */  0,
/* 11dd - _66_0F_38_3C */  0x24b3,
/* 11de -  */  0,
/* 11df -  */  0,
/* 11e0 -  */  0,
/* 11e1 - _V_66_0F_38_3C */  0x410d,
/* 11e2 -  */  0,
/* 11e3 -  */  0,
/* 11e4 -  */  0,
/* 11e5 -  */  0,
/* 11e6 -  */  0,
/* 11e7 -  */  0,
/* 11e8 -  */  0,
/* 11e9 - _66_0F_38_3D */  0x24b4,
/* 11ea -  */  0,
/* 11eb -  */  0,
/* 11ec -  */  0,
/* 11ed - _V_66_0F_38_3D */  0x410e,
/* 11ee -  */  0,
/* 11ef -  */  0,
/* 11f0 -  */  0,
/* 11f1 -  */  0,
/* 11f2 -  */  0,
/* 11f3 -  */  0,
/* 11f4 -  */  0,
/* 11f5 - _66_0F_38_3E */  0x24b5,
/* 11f6 -  */  0,
/* 11f7 -  */  0,
/* 11f8 -  */  0,
/* 11f9 - _V_66_0F_38_3E */  0x410f,
/* 11fa -  */  0,
/* 11fb -  */  0,
/* 11fc -  */  0,
/* 11fd -  */  0,
/* 11fe -  */  0,
/* 11ff -  */  0,
/* 1200 -  */  0,
/* 1201 - _66_0F_38_3F */  0x24b6,
/* 1202 -  */  0,
/* 1203 -  */  0,
/* 1204 -  */  0,
/* 1205 - _V_66_0F_38_3F */  0x4110,
/* 1206 -  */  0,
/* 1207 -  */  0,
/* 1208 -  */  0,
/* 1209 -  */  0,
/* 120a -  */  0,
/* 120b -  */  0,
/* 120c -  */  0,
/* 120d - _66_0F_38_40 */  0x24b7,
/* 120e -  */  0,
/* 120f -  */  0,
/* 1210 -  */  0,
/* 1211 - _V_66_0F_38_40 */  0x4111,
/* 1212 -  */  0,
/* 1213 -  */  0,
/* 1214 -  */  0,
/* 1215 -  */  0,
/* 1216 -  */  0,
/* 1217 -  */  0,
/* 1218 -  */  0,
/* 1219 - _66_0F_38_41 */  0x24b8,
/* 121a -  */  0,
/* 121b -  */  0,
/* 121c -  */  0,
/* 121d - _V_66_0F_38_41 */  0x4112,
/* 121e -  */  0,
/* 121f -  */  0,
/* 1220 -  */  0,
/* 1221 -  */  0,
/* 1222 -  */  0,
/* 1223 -  */  0,
/* 1224 -  */  0,
/* 1225 - _66_0F_38_80 */  0x24b9,
/* 1226 -  */  0,
/* 1227 -  */  0,
/* 1228 -  */  0,
/* 1229 -  */  0,
/* 122a -  */  0,
/* 122b -  */  0,
/* 122c -  */  0,
/* 122d -  */  0,
/* 122e -  */  0,
/* 122f -  */  0,
/* 1230 -  */  0,
/* 1231 - _66_0F_38_81 */  0x24ba,
/* 1232 -  */  0,
/* 1233 -  */  0,
/* 1234 -  */  0,
/* 1235 -  */  0,
/* 1236 -  */  0,
/* 1237 -  */  0,
/* 1238 -  */  0,
/* 1239 -  */  0,
/* 123a -  */  0,
/* 123b -  */  0,
/* 123c -  */  0,
/* 123d - _66_0F_38_82 */  0x24bb,
/* 123e -  */  0,
/* 123f -  */  0,
/* 1240 -  */  0,
/* 1241 -  */  0,
/* 1242 -  */  0,
/* 1243 -  */  0,
/* 1244 -  */  0,
/* 1245 -  */  0,
/* 1246 -  */  0,
/* 1247 -  */  0,
/* 1248 -  */  0,
/* 1249 -  */  0,
/* 124a -  */  0,
/* 124b -  */  0,
/* 124c -  */  0,
/* 124d - _V_66_0F_38_96 */  0x4113,
/* 124e -  */  0,
/* 124f -  */  0,
/* 1250 -  */  0,
/* 1251 -  */  0,
/* 1252 -  */  0,
/* 1253 -  */  0,
/* 1254 -  */  0,
/* 1255 -  */  0,
/* 1256 -  */  0,
/* 1257 -  */  0,
/* 1258 -  */  0,
/* 1259 - _V_66_0F_38_97 */  0x4114,
/* 125a -  */  0,
/* 125b -  */  0,
/* 125c -  */  0,
/* 125d -  */  0,
/* 125e -  */  0,
/* 125f -  */  0,
/* 1260 -  */  0,
/* 1261 -  */  0,
/* 1262 -  */  0,
/* 1263 -  */  0,
/* 1264 -  */  0,
/* 1265 - _V_66_0F_38_98 */  0x4115,
/* 1266 -  */  0,
/* 1267 -  */  0,
/* 1268 -  */  0,
/* 1269 -  */  0,
/* 126a -  */  0,
/* 126b -  */  0,
/* 126c -  */  0,
/* 126d -  */  0,
/* 126e -  */  0,
/* 126f -  */  0,
/* 1270 -  */  0,
/* 1271 - _V_66_0F_38_99 */  0x4116,
/* 1272 -  */  0,
/* 1273 -  */  0,
/* 1274 -  */  0,
/* 1275 -  */  0,
/* 1276 -  */  0,
/* 1277 -  */  0,
/* 1278 -  */  0,
/* 1279 -  */  0,
/* 127a -  */  0,
/* 127b -  */  0,
/* 127c -  */  0,
/* 127d - _V_66_0F_38_9A */  0x4117,
/* 127e -  */  0,
/* 127f -  */  0,
/* 1280 -  */  0,
/* 1281 -  */  0,
/* 1282 -  */  0,
/* 1283 -  */  0,
/* 1284 -  */  0,
/* 1285 -  */  0,
/* 1286 -  */  0,
/* 1287 -  */  0,
/* 1288 -  */  0,
/* 1289 - _V_66_0F_38_9B */  0x4118,
/* 128a -  */  0,
/* 128b -  */  0,
/* 128c -  */  0,
/* 128d -  */  0,
/* 128e -  */  0,
/* 128f -  */  0,
/* 1290 -  */  0,
/* 1291 -  */  0,
/* 1292 -  */  0,
/* 1293 -  */  0,
/* 1294 -  */  0,
/* 1295 - _V_66_0F_38_9C */  0x4119,
/* 1296 -  */  0,
/* 1297 -  */  0,
/* 1298 -  */  0,
/* 1299 -  */  0,
/* 129a -  */  0,
/* 129b -  */  0,
/* 129c -  */  0,
/* 129d -  */  0,
/* 129e -  */  0,
/* 129f -  */  0,
/* 12a0 -  */  0,
/* 12a1 - _V_66_0F_38_9D */  0x411a,
/* 12a2 -  */  0,
/* 12a3 -  */  0,
/* 12a4 -  */  0,
/* 12a5 -  */  0,
/* 12a6 -  */  0,
/* 12a7 -  */  0,
/* 12a8 -  */  0,
/* 12a9 -  */  0,
/* 12aa -  */  0,
/* 12ab -  */  0,
/* 12ac -  */  0,
/* 12ad - _V_66_0F_38_9E */  0x411b,
/* 12ae -  */  0,
/* 12af -  */  0,
/* 12b0 -  */  0,
/* 12b1 -  */  0,
/* 12b2 -  */  0,
/* 12b3 -  */  0,
/* 12b4 -  */  0,
/* 12b5 -  */  0,
/* 12b6 -  */  0,
/* 12b7 -  */  0,
/* 12b8 -  */  0,
/* 12b9 - _V_66_0F_38_9F */  0x411c,
/* 12ba -  */  0,
/* 12bb -  */  0,
/* 12bc -  */  0,
/* 12bd -  */  0,
/* 12be -  */  0,
/* 12bf -  */  0,
/* 12c0 -  */  0,
/* 12c1 -  */  0,
/* 12c2 -  */  0,
/* 12c3 -  */  0,
/* 12c4 -  */  0,
/* 12c5 - _V_66_0F_38_A6 */  0x411d,
/* 12c6 -  */  0,
/* 12c7 -  */  0,
/* 12c8 -  */  0,
/* 12c9 -  */  0,
/* 12ca -  */  0,
/* 12cb -  */  0,
/* 12cc -  */  0,
/* 12cd -  */  0,
/* 12ce -  */  0,
/* 12cf -  */  0,
/* 12d0 -  */  0,
/* 12d1 - _V_66_0F_38_A7 */  0x411e,
/* 12d2 -  */  0,
/* 12d3 -  */  0,
/* 12d4 -  */  0,
/* 12d5 -  */  0,
/* 12d6 -  */  0,
/* 12d7 -  */  0,
/* 12d8 -  */  0,
/* 12d9 -  */  0,
/* 12da -  */  0,
/* 12db -  */  0,
/* 12dc -  */  0,
/* 12dd - _V_66_0F_38_A8 */  0x411f,
/* 12de -  */  0,
/* 12df -  */  0,
/* 12e0 -  */  0,
/* 12e1 -  */  0,
/* 12e2 -  */  0,
/* 12e3 -  */  0,
/* 12e4 -  */  0,
/* 12e5 -  */  0,
/* 12e6 -  */  0,
/* 12e7 -  */  0,
/* 12e8 -  */  0,
/* 12e9 - _V_66_0F_38_A9 */  0x4120,
/* 12ea -  */  0,
/* 12eb -  */  0,
/* 12ec -  */  0,
/* 12ed -  */  0,
/* 12ee -  */  0,
/* 12ef -  */  0,
/* 12f0 -  */  0,
/* 12f1 -  */  0,
/* 12f2 -  */  0,
/* 12f3 -  */  0,
/* 12f4 -  */  0,
/* 12f5 - _V_66_0F_38_AA */  0x4121,
/* 12f6 -  */  0,
/* 12f7 -  */  0,
/* 12f8 -  */  0,
/* 12f9 -  */  0,
/* 12fa -  */  0,
/* 12fb -  */  0,
/* 12fc -  */  0,
/* 12fd -  */  0,
/* 12fe -  */  0,
/* 12ff -  */  0,
/* 1300 -  */  0,
/* 1301 - _V_66_0F_38_AB */  0x4122,
/* 1302 -  */  0,
/* 1303 -  */  0,
/* 1304 -  */  0,
/* 1305 -  */  0,
/* 1306 -  */  0,
/* 1307 -  */  0,
/* 1308 -  */  0,
/* 1309 -  */  0,
/* 130a -  */  0,
/* 130b -  */  0,
/* 130c -  */  0,
/* 130d - _V_66_0F_38_AC */  0x4123,
/* 130e -  */  0,
/* 130f -  */  0,
/* 1310 -  */  0,
/* 1311 -  */  0,
/* 1312 -  */  0,
/* 1313 -  */  0,
/* 1314 -  */  0,
/* 1315 -  */  0,
/* 1316 -  */  0,
/* 1317 -  */  0,
/* 1318 -  */  0,
/* 1319 - _V_66_0F_38_AD */  0x4124,
/* 131a -  */  0,
/* 131b -  */  0,
/* 131c -  */  0,
/* 131d -  */  0,
/* 131e -  */  0,
/* 131f -  */  0,
/* 1320 -  */  0,
/* 1321 -  */  0,
/* 1322 -  */  0,
/* 1323 -  */  0,
/* 1324 -  */  0,
/* 1325 - _V_66_0F_38_AE */  0x4125,
/* 1326 -  */  0,
/* 1327 -  */  0,
/* 1328 -  */  0,
/* 1329 -  */  0,
/* 132a -  */  0,
/* 132b -  */  0,
/* 132c -  */  0,
/* 132d -  */  0,
/* 132e -  */  0,
/* 132f -  */  0,
/* 1330 -  */  0,
/* 1331 - _V_66_0F_38_AF */  0x4126,
/* 1332 -  */  0,
/* 1333 -  */  0,
/* 1334 -  */  0,
/* 1335 -  */  0,
/* 1336 -  */  0,
/* 1337 -  */  0,
/* 1338 -  */  0,
/* 1339 -  */  0,
/* 133a -  */  0,
/* 133b -  */  0,
/* 133c -  */  0,
/* 133d - _V_66_0F_38_B6 */  0x4127,
/* 133e -  */  0,
/* 133f -  */  0,
/* 1340 -  */  0,
/* 1341 -  */  0,
/* 1342 -  */  0,
/* 1343 -  */  0,
/* 1344 -  */  0,
/* 1345 -  */  0,
/* 1346 -  */  0,
/* 1347 -  */  0,
/* 1348 -  */  0,
/* 1349 - _V_66_0F_38_B7 */  0x4128,
/* 134a -  */  0,
/* 134b -  */  0,
/* 134c -  */  0,
/* 134d -  */  0,
/* 134e -  */  0,
/* 134f -  */  0,
/* 1350 -  */  0,
/* 1351 -  */  0,
/* 1352 -  */  0,
/* 1353 -  */  0,
/* 1354 -  */  0,
/* 1355 - _V_66_0F_38_B8 */  0x4129,
/* 1356 -  */  0,
/* 1357 -  */  0,
/* 1358 -  */  0,
/* 1359 -  */  0,
/* 135a -  */  0,
/* 135b -  */  0,
/* 135c -  */  0,
/* 135d -  */  0,
/* 135e -  */  0,
/* 135f -  */  0,
/* 1360 -  */  0,
/* 1361 - _V_66_0F_38_B9 */  0x412a,
/* 1362 -  */  0,
/* 1363 -  */  0,
/* 1364 -  */  0,
/* 1365 -  */  0,
/* 1366 -  */  0,
/* 1367 -  */  0,
/* 1368 -  */  0,
/* 1369 -  */  0,
/* 136a -  */  0,
/* 136b -  */  0,
/* 136c -  */  0,
/* 136d - _V_66_0F_38_BA */  0x412b,
/* 136e -  */  0,
/* 136f -  */  0,
/* 1370 -  */  0,
/* 1371 -  */  0,
/* 1372 -  */  0,
/* 1373 -  */  0,
/* 1374 -  */  0,
/* 1375 -  */  0,
/* 1376 -  */  0,
/* 1377 -  */  0,
/* 1378 -  */  0,
/* 1379 - _V_66_0F_38_BB */  0x412c,
/* 137a -  */  0,
/* 137b -  */  0,
/* 137c -  */  0,
/* 137d -  */  0,
/* 137e -  */  0,
/* 137f -  */  0,
/* 1380 -  */  0,
/* 1381 -  */  0,
/* 1382 -  */  0,
/* 1383 -  */  0,
/* 1384 -  */  0,
/* 1385 - _V_66_0F_38_BC */  0x412d,
/* 1386 -  */  0,
/* 1387 -  */  0,
/* 1388 -  */  0,
/* 1389 -  */  0,
/* 138a -  */  0,
/* 138b -  */  0,
/* 138c -  */  0,
/* 138d -  */  0,
/* 138e -  */  0,
/* 138f -  */  0,
/* 1390 -  */  0,
/* 1391 - _V_66_0F_38_BD */  0x412e,
/* 1392 -  */  0,
/* 1393 -  */  0,
/* 1394 -  */  0,
/* 1395 -  */  0,
/* 1396 -  */  0,
/* 1397 -  */  0,
/* 1398 -  */  0,
/* 1399 -  */  0,
/* 139a -  */  0,
/* 139b -  */  0,
/* 139c -  */  0,
/* 139d - _V_66_0F_38_BE */  0x412f,
/* 139e -  */  0,
/* 139f -  */  0,
/* 13a0 -  */  0,
/* 13a1 -  */  0,
/* 13a2 -  */  0,
/* 13a3 -  */  0,
/* 13a4 -  */  0,
/* 13a5 -  */  0,
/* 13a6 -  */  0,
/* 13a7 -  */  0,
/* 13a8 -  */  0,
/* 13a9 - _V_66_0F_38_BF */  0x4130,
/* 13aa -  */  0,
/* 13ab -  */  0,
/* 13ac -  */  0,
/* 13ad -  */  0,
/* 13ae -  */  0,
/* 13af -  */  0,
/* 13b0 -  */  0,
/* 13b1 - _66_0F_38_DB */  0x24bc,
/* 13b2 -  */  0,
/* 13b3 -  */  0,
/* 13b4 -  */  0,
/* 13b5 - _V_66_0F_38_DB */  0x4131,
/* 13b6 -  */  0,
/* 13b7 -  */  0,
/* 13b8 -  */  0,
/* 13b9 -  */  0,
/* 13ba -  */  0,
/* 13bb -  */  0,
/* 13bc -  */  0,
/* 13bd - _66_0F_38_DC */  0x24bd,
/* 13be -  */  0,
/* 13bf -  */  0,
/* 13c0 -  */  0,
/* 13c1 - _V_66_0F_38_DC */  0x4132,
/* 13c2 -  */  0,
/* 13c3 -  */  0,
/* 13c4 -  */  0,
/* 13c5 -  */  0,
/* 13c6 -  */  0,
/* 13c7 -  */  0,
/* 13c8 -  */  0,
/* 13c9 - _66_0F_38_DD */  0x24be,
/* 13ca -  */  0,
/* 13cb -  */  0,
/* 13cc -  */  0,
/* 13cd - _V_66_0F_38_DD */  0x4133,
/* 13ce -  */  0,
/* 13cf -  */  0,
/* 13d0 -  */  0,
/* 13d1 -  */  0,
/* 13d2 -  */  0,
/* 13d3 -  */  0,
/* 13d4 -  */  0,
/* 13d5 - _66_0F_38_DE */  0x24bf,
/* 13d6 -  */  0,
/* 13d7 -  */  0,
/* 13d8 -  */  0,
/* 13d9 - _V_66_0F_38_DE */  0x4134,
/* 13da -  */  0,
/* 13db -  */  0,
/* 13dc -  */  0,
/* 13dd -  */  0,
/* 13de -  */  0,
/* 13df -  */  0,
/* 13e0 -  */  0,
/* 13e1 - _66_0F_38_DF */  0x24c0,
/* 13e2 -  */  0,
/* 13e3 -  */  0,
/* 13e4 -  */  0,
/* 13e5 - _V_66_0F_38_DF */  0x4135,
/* 13e6 -  */  0,
/* 13e7 -  */  0,
/* 13e8 -  */  0,
/* 13e9 -  */  0,
/* 13ea -  */  0,
/* 13eb -  */  0,
/* 13ec - _0F_38_F0 */  0x24c1,
/* 13ed -  */  0,
/* 13ee -  */  0,
/* 13ef - _F2_0F_38_F0 */  0x24c2,
/* 13f0 -  */  0,
/* 13f1 -  */  0,
/* 13f2 -  */  0,
/* 13f3 -  */  0,
/* 13f4 -  */  0,
/* 13f5 -  */  0,
/* 13f6 -  */  0,
/* 13f7 -  */  0,
/* 13f8 - _0F_38_F1 */  0x24c3,
/* 13f9 -  */  0,
/* 13fa -  */  0,
/* 13fb - _F2_0F_38_F1 */  0x24c4,
/* 13fc -  */  0,
/* 13fd -  */  0,
/* 13fe -  */  0,
/* 13ff -  */  0,
/* 1400 -  */  0,
/* 1401 -  */  0,
/* 1402 -  */  0,
/* 1403 -  */  0,
/* 1404 -  */  0,
/* 1405 -  */  0,
/* 1406 -  */  0,
/* 1407 -  */  0,
/* 1408 -  */  0,
/* 1409 - _V_66_0F_3A_04 */  0x4136,
/* 140a -  */  0,
/* 140b -  */  0,
/* 140c -  */  0,
/* 140d -  */  0,
/* 140e -  */  0,
/* 140f -  */  0,
/* 1410 -  */  0,
/* 1411 -  */  0,
/* 1412 -  */  0,
/* 1413 -  */  0,
/* 1414 -  */  0,
/* 1415 - _V_66_0F_3A_05 */  0x4137,
/* 1416 -  */  0,
/* 1417 -  */  0,
/* 1418 -  */  0,
/* 1419 -  */  0,
/* 141a -  */  0,
/* 141b -  */  0,
/* 141c -  */  0,
/* 141d -  */  0,
/* 141e -  */  0,
/* 141f -  */  0,
/* 1420 -  */  0,
/* 1421 - _V_66_0F_3A_06 */  0x4138,
/* 1422 -  */  0,
/* 1423 -  */  0,
/* 1424 -  */  0,
/* 1425 -  */  0,
/* 1426 -  */  0,
/* 1427 -  */  0,
/* 1428 -  */  0,
/* 1429 - _66_0F_3A_08 */  0x4139,
/* 142a -  */  0,
/* 142b -  */  0,
/* 142c -  */  0,
/* 142d - _V_66_0F_3A_08 */  0x413a,
/* 142e -  */  0,
/* 142f -  */  0,
/* 1430 -  */  0,
/* 1431 -  */  0,
/* 1432 -  */  0,
/* 1433 -  */  0,
/* 1434 -  */  0,
/* 1435 - _66_0F_3A_09 */  0x413b,
/* 1436 -  */  0,
/* 1437 -  */  0,
/* 1438 -  */  0,
/* 1439 - _V_66_0F_3A_09 */  0x413c,
/* 143a -  */  0,
/* 143b -  */  0,
/* 143c -  */  0,
/* 143d -  */  0,
/* 143e -  */  0,
/* 143f -  */  0,
/* 1440 -  */  0,
/* 1441 - _66_0F_3A_0A */  0x413d,
/* 1442 -  */  0,
/* 1443 -  */  0,
/* 1444 -  */  0,
/* 1445 - _V_66_0F_3A_0A */  0x413e,
/* 1446 -  */  0,
/* 1447 -  */  0,
/* 1448 -  */  0,
/* 1449 -  */  0,
/* 144a -  */  0,
/* 144b -  */  0,
/* 144c -  */  0,
/* 144d - _66_0F_3A_0B */  0x413f,
/* 144e -  */  0,
/* 144f -  */  0,
/* 1450 -  */  0,
/* 1451 - _V_66_0F_3A_0B */  0x4140,
/* 1452 -  */  0,
/* 1453 -  */  0,
/* 1454 -  */  0,
/* 1455 -  */  0,
/* 1456 -  */  0,
/* 1457 -  */  0,
/* 1458 -  */  0,
/* 1459 - _66_0F_3A_0C */  0x4141,
/* 145a -  */  0,
/* 145b -  */  0,
/* 145c -  */  0,
/* 145d - _V_66_0F_3A_0C */  0x4142,
/* 145e -  */  0,
/* 145f -  */  0,
/* 1460 -  */  0,
/* 1461 -  */  0,
/* 1462 -  */  0,
/* 1463 -  */  0,
/* 1464 -  */  0,
/* 1465 - _66_0F_3A_0D */  0x4143,
/* 1466 -  */  0,
/* 1467 -  */  0,
/* 1468 -  */  0,
/* 1469 - _V_66_0F_3A_0D */  0x4144,
/* 146a -  */  0,
/* 146b -  */  0,
/* 146c -  */  0,
/* 146d -  */  0,
/* 146e -  */  0,
/* 146f -  */  0,
/* 1470 -  */  0,
/* 1471 - _66_0F_3A_0E */  0x4145,
/* 1472 -  */  0,
/* 1473 -  */  0,
/* 1474 -  */  0,
/* 1475 - _V_66_0F_3A_0E */  0x4146,
/* 1476 -  */  0,
/* 1477 -  */  0,
/* 1478 -  */  0,
/* 1479 -  */  0,
/* 147a -  */  0,
/* 147b -  */  0,
/* 147c - _0F_3A_0F */  0x4147,
/* 147d - _66_0F_3A_0F */  0x4148,
/* 147e -  */  0,
/* 147f -  */  0,
/* 1480 -  */  0,
/* 1481 - _V_66_0F_3A_0F */  0x4149,
/* 1482 -  */  0,
/* 1483 -  */  0,
/* 1484 -  */  0,
/* 1485 -  */  0,
/* 1486 -  */  0,
/* 1487 -  */  0,
/* 1488 -  */  0,
/* 1489 - _66_0F_3A_14 */  0x414a,
/* 148a -  */  0,
/* 148b -  */  0,
/* 148c -  */  0,
/* 148d - _V_66_0F_3A_14 */  0x414b,
/* 148e -  */  0,
/* 148f -  */  0,
/* 1490 -  */  0,
/* 1491 -  */  0,
/* 1492 -  */  0,
/* 1493 -  */  0,
/* 1494 -  */  0,
/* 1495 - _66_0F_3A_15 */  0x414c,
/* 1496 -  */  0,
/* 1497 -  */  0,
/* 1498 -  */  0,
/* 1499 - _V_66_0F_3A_15 */  0x414d,
/* 149a -  */  0,
/* 149b -  */  0,
/* 149c -  */  0,
/* 149d -  */  0,
/* 149e -  */  0,
/* 149f -  */  0,
/* 14a0 -  */  0,
/* 14a1 - _66_0F_3A_16 */  0x414e,
/* 14a2 -  */  0,
/* 14a3 -  */  0,
/* 14a4 -  */  0,
/* 14a5 - _V_66_0F_3A_16 */  0x414f,
/* 14a6 -  */  0,
/* 14a7 -  */  0,
/* 14a8 -  */  0,
/* 14a9 -  */  0,
/* 14aa -  */  0,
/* 14ab -  */  0,
/* 14ac -  */  0,
/* 14ad - _66_0F_3A_17 */  0x4150,
/* 14ae -  */  0,
/* 14af -  */  0,
/* 14b0 -  */  0,
/* 14b1 - _V_66_0F_3A_17 */  0x4151,
/* 14b2 -  */  0,
/* 14b3 -  */  0,
/* 14b4 -  */  0,
/* 14b5 -  */  0,
/* 14b6 -  */  0,
/* 14b7 -  */  0,
/* 14b8 -  */  0,
/* 14b9 -  */  0,
/* 14ba -  */  0,
/* 14bb -  */  0,
/* 14bc -  */  0,
/* 14bd - _V_66_0F_3A_18 */  0x4152,
/* 14be -  */  0,
/* 14bf -  */  0,
/* 14c0 -  */  0,
/* 14c1 -  */  0,
/* 14c2 -  */  0,
/* 14c3 -  */  0,
/* 14c4 -  */  0,
/* 14c5 -  */  0,
/* 14c6 -  */  0,
/* 14c7 -  */  0,
/* 14c8 -  */  0,
/* 14c9 - _V_66_0F_3A_19 */  0x4153,
/* 14ca -  */  0,
/* 14cb -  */  0,
/* 14cc -  */  0,
/* 14cd -  */  0,
/* 14ce -  */  0,
/* 14cf -  */  0,
/* 14d0 -  */  0,
/* 14d1 - _66_0F_3A_20 */  0x4154,
/* 14d2 -  */  0,
/* 14d3 -  */  0,
/* 14d4 -  */  0,
/* 14d5 - _V_66_0F_3A_20 */  0x4155,
/* 14d6 -  */  0,
/* 14d7 -  */  0,
/* 14d8 -  */  0,
/* 14d9 -  */  0,
/* 14da -  */  0,
/* 14db -  */  0,
/* 14dc -  */  0,
/* 14dd - _66_0F_3A_21 */  0x4156,
/* 14de -  */  0,
/* 14df -  */  0,
/* 14e0 -  */  0,
/* 14e1 - _V_66_0F_3A_21 */  0x4157,
/* 14e2 -  */  0,
/* 14e3 -  */  0,
/* 14e4 -  */  0,
/* 14e5 -  */  0,
/* 14e6 -  */  0,
/* 14e7 -  */  0,
/* 14e8 -  */  0,
/* 14e9 - _66_0F_3A_22 */  0x4158,
/* 14ea -  */  0,
/* 14eb -  */  0,
/* 14ec -  */  0,
/* 14ed - _V_66_0F_3A_22 */  0x4159,
/* 14ee -  */  0,
/* 14ef -  */  0,
/* 14f0 -  */  0,
/* 14f1 -  */  0,
/* 14f2 -  */  0,
/* 14f3 -  */  0,
/* 14f4 -  */  0,
/* 14f5 - _66_0F_3A_40 */  0x415a,
/* 14f6 -  */  0,
/* 14f7 -  */  0,
/* 14f8 -  */  0,
/* 14f9 - _V_66_0F_3A_40 */  0x415b,
/* 14fa -  */  0,
/* 14fb -  */  0,
/* 14fc -  */  0,
/* 14fd -  */  0,
/* 14fe -  */  0,
/* 14ff -  */  0,
/* 1500 -  */  0,
/* 1501 - _66_0F_3A_41 */  0x415c,
/* 1502 -  */  0,
/* 1503 -  */  0,
/* 1504 -  */  0,
/* 1505 - _V_66_0F_3A_41 */  0x415d,
/* 1506 -  */  0,
/* 1507 -  */  0,
/* 1508 -  */  0,
/* 1509 -  */  0,
/* 150a -  */  0,
/* 150b -  */  0,
/* 150c -  */  0,
/* 150d - _66_0F_3A_42 */  0x415e,
/* 150e -  */  0,
/* 150f -  */  0,
/* 1510 -  */  0,
/* 1511 - _V_66_0F_3A_42 */  0x415f,
/* 1512 -  */  0,
/* 1513 -  */  0,
/* 1514 -  */  0,
/* 1515 -  */  0,
/* 1516 -  */  0,
/* 1517 -  */  0,
/* 1518 -  */  0,
/* 1519 - _66_0F_3A_44 */  0x4160,
/* 151a -  */  0,
/* 151b -  */  0,
/* 151c -  */  0,
/* 151d - _V_66_0F_3A_44 */  0x4161,
/* 151e -  */  0,
/* 151f -  */  0,
/* 1520 -  */  0,
/* 1521 -  */  0,
/* 1522 -  */  0,
/* 1523 -  */  0,
/* 1524 -  */  0,
/* 1525 -  */  0,
/* 1526 -  */  0,
/* 1527 -  */  0,
/* 1528 -  */  0,
/* 1529 - _V_66_0F_3A_4A */  0x4162,
/* 152a -  */  0,
/* 152b -  */  0,
/* 152c -  */  0,
/* 152d -  */  0,
/* 152e -  */  0,
/* 152f -  */  0,
/* 1530 -  */  0,
/* 1531 -  */  0,
/* 1532 -  */  0,
/* 1533 -  */  0,
/* 1534 -  */  0,
/* 1535 - _V_66_0F_3A_4B */  0x4163,
/* 1536 -  */  0,
/* 1537 -  */  0,
/* 1538 -  */  0,
/* 1539 -  */  0,
/* 153a -  */  0,
/* 153b -  */  0,
/* 153c -  */  0,
/* 153d -  */  0,
/* 153e -  */  0,
/* 153f -  */  0,
/* 1540 -  */  0,
/* 1541 - _V_66_0F_3A_4C */  0x4164,
/* 1542 -  */  0,
/* 1543 -  */  0,
/* 1544 -  */  0,
/* 1545 -  */  0,
/* 1546 -  */  0,
/* 1547 -  */  0,
/* 1548 -  */  0,
/* 1549 - _66_0F_3A_60 */  0x4165,
/* 154a -  */  0,
/* 154b -  */  0,
/* 154c -  */  0,
/* 154d - _V_66_0F_3A_60 */  0x4166,
/* 154e -  */  0,
/* 154f -  */  0,
/* 1550 -  */  0,
/* 1551 -  */  0,
/* 1552 -  */  0,
/* 1553 -  */  0,
/* 1554 -  */  0,
/* 1555 - _66_0F_3A_61 */  0x4167,
/* 1556 -  */  0,
/* 1557 -  */  0,
/* 1558 -  */  0,
/* 1559 - _V_66_0F_3A_61 */  0x4168,
/* 155a -  */  0,
/* 155b -  */  0,
/* 155c -  */  0,
/* 155d -  */  0,
/* 155e -  */  0,
/* 155f -  */  0,
/* 1560 -  */  0,
/* 1561 - _66_0F_3A_62 */  0x4169,
/* 1562 -  */  0,
/* 1563 -  */  0,
/* 1564 -  */  0,
/* 1565 - _V_66_0F_3A_62 */  0x416a,
/* 1566 -  */  0,
/* 1567 -  */  0,
/* 1568 -  */  0,
/* 1569 -  */  0,
/* 156a -  */  0,
/* 156b -  */  0,
/* 156c -  */  0,
/* 156d - _66_0F_3A_63 */  0x416b,
/* 156e -  */  0,
/* 156f -  */  0,
/* 1570 -  */  0,
/* 1571 - _V_66_0F_3A_63 */  0x416c,
/* 1572 -  */  0,
/* 1573 -  */  0,
/* 1574 -  */  0,
/* 1575 -  */  0,
/* 1576 -  */  0,
/* 1577 -  */  0,
/* 1578 -  */  0,
/* 1579 - _66_0F_3A_DF */  0x416d,
/* 157a -  */  0,
/* 157b -  */  0,
/* 157c -  */  0,
/* 157d - _V_66_0F_3A_DF */  0x416e,
/* 157e -  */  0,
/* 157f -  */  0,
/* 1580 -  */  0,
/* 1581 -  */  0,
/* 1582 -  */  0,
/* 1583 -  */  0,
/* 1584 - _0F_71_02 */  0x24c5,
/* 1585 - _66_0F_71_02 */  0x24c6,
/* 1586 -  */  0,
/* 1587 -  */  0,
/* 1588 -  */  0,
/* 1589 - _V_66_0F_71_02 */  0x416f,
/* 158a -  */  0,
/* 158b -  */  0,
/* 158c -  */  0,
/* 158d -  */  0,
/* 158e -  */  0,
/* 158f -  */  0,
/* 1590 - _0F_71_04 */  0x24c7,
/* 1591 - _66_0F_71_04 */  0x24c8,
/* 1592 -  */  0,
/* 1593 -  */  0,
/* 1594 -  */  0,
/* 1595 - _V_66_0F_71_04 */  0x4170,
/* 1596 -  */  0,
/* 1597 -  */  0,
/* 1598 -  */  0,
/* 1599 -  */  0,
/* 159a -  */  0,
/* 159b -  */  0,
/* 159c - _0F_71_06 */  0x24c9,
/* 159d - _66_0F_71_06 */  0x24ca,
/* 159e -  */  0,
/* 159f -  */  0,
/* 15a0 -  */  0,
/* 15a1 - _V_66_0F_71_06 */  0x4171,
/* 15a2 -  */  0,
/* 15a3 -  */  0,
/* 15a4 -  */  0,
/* 15a5 -  */  0,
/* 15a6 -  */  0,
/* 15a7 -  */  0,
/* 15a8 - _0F_72_02 */  0x24cb,
/* 15a9 - _66_0F_72_02 */  0x24cc,
/* 15aa -  */  0,
/* 15ab -  */  0,
/* 15ac -  */  0,
/* 15ad - _V_66_0F_72_02 */  0x4172,
/* 15ae -  */  0,
/* 15af -  */  0,
/* 15b0 -  */  0,
/* 15b1 -  */  0,
/* 15b2 -  */  0,
/* 15b3 -  */  0,
/* 15b4 - _0F_72_04 */  0x24cd,
/* 15b5 - _66_0F_72_04 */  0x24ce,
/* 15b6 -  */  0,
/* 15b7 -  */  0,
/* 15b8 -  */  0,
/* 15b9 - _V_66_0F_72_04 */  0x4173,
/* 15ba -  */  0,
/* 15bb -  */  0,
/* 15bc -  */  0,
/* 15bd -  */  0,
/* 15be -  */  0,
/* 15bf -  */  0,
/* 15c0 - _0F_72_06 */  0x24cf,
/* 15c1 - _66_0F_72_06 */  0x24d0,
/* 15c2 -  */  0,
/* 15c3 -  */  0,
/* 15c4 -  */  0,
/* 15c5 - _V_66_0F_72_06 */  0x4174,
/* 15c6 -  */  0,
/* 15c7 -  */  0,
/* 15c8 -  */  0,
/* 15c9 -  */  0,
/* 15ca -  */  0,
/* 15cb -  */  0,
/* 15cc - _0F_73_02 */  0x24d1,
/* 15cd - _66_0F_73_02 */  0x24d2,
/* 15ce -  */  0,
/* 15cf -  */  0,
/* 15d0 -  */  0,
/* 15d1 - _V_66_0F_73_02 */  0x4175,
/* 15d2 -  */  0,
/* 15d3 -  */  0,
/* 15d4 -  */  0,
/* 15d5 -  */  0,
/* 15d6 -  */  0,
/* 15d7 -  */  0,
/* 15d8 -  */  0,
/* 15d9 - _66_0F_73_03 */  0x24d3,
/* 15da -  */  0,
/* 15db -  */  0,
/* 15dc -  */  0,
/* 15dd - _V_66_0F_73_03 */  0x4176,
/* 15de -  */  0,
/* 15df -  */  0,
/* 15e0 -  */  0,
/* 15e1 -  */  0,
/* 15e2 -  */  0,
/* 15e3 -  */  0,
/* 15e4 - _0F_73_06 */  0x24d4,
/* 15e5 - _66_0F_73_06 */  0x24d5,
/* 15e6 -  */  0,
/* 15e7 -  */  0,
/* 15e8 -  */  0,
/* 15e9 - _V_66_0F_73_06 */  0x4177,
/* 15ea -  */  0,
/* 15eb -  */  0,
/* 15ec -  */  0,
/* 15ed -  */  0,
/* 15ee -  */  0,
/* 15ef -  */  0,
/* 15f0 -  */  0,
/* 15f1 - _66_0F_73_07 */  0x24d6,
/* 15f2 -  */  0,
/* 15f3 -  */  0,
/* 15f4 -  */  0,
/* 15f5 - _V_66_0F_73_07 */  0x4178,
/* 15f6 -  */  0,
/* 15f7 -  */  0,
/* 15f8 -  */  0,
/* 15f9 -  */  0,
/* 15fa -  */  0,
/* 15fb -  */  0,
/* 15fc - _0F_AE_00 */  0x4179,
/* 15fd -  */  0,
/* 15fe - _F3_0F_AE_00 */  0x24d7,
/* 15ff -  */  0,
/* 1600 -  */  0,
/* 1601 -  */  0,
/* 1602 -  */  0,
/* 1603 -  */  0,
/* 1604 -  */  0,
/* 1605 -  */  0,
/* 1606 -  */  0,
/* 1607 -  */  0,
/* 1608 - _0F_AE_01 */  0x417a,
/* 1609 -  */  0,
/* 160a - _F3_0F_AE_01 */  0x24d8,
/* 160b -  */  0,
/* 160c -  */  0,
/* 160d -  */  0,
/* 160e -  */  0,
/* 160f -  */  0,
/* 1610 -  */  0,
/* 1611 -  */  0,
/* 1612 -  */  0,
/* 1613 -  */  0,
/* 1614 - _0F_AE_02 */  0x24d9,
/* 1615 -  */  0,
/* 1616 - _F3_0F_AE_02 */  0x24da,
/* 1617 -  */  0,
/* 1618 - _V_0F_AE_02 */  0x417b,
/* 1619 -  */  0,
/* 161a -  */  0,
/* 161b -  */  0,
/* 161c -  */  0,
/* 161d -  */  0,
/* 161e -  */  0,
/* 161f -  */  0,
/* 1620 - _0F_AE_03 */  0x24db,
/* 1621 -  */  0,
/* 1622 - _F3_0F_AE_03 */  0x24dc,
/* 1623 -  */  0,
/* 1624 - _V_0F_AE_03 */  0x417c,
/* 1625 -  */  0,
/* 1626 -  */  0,
/* 1627 -  */  0,
/* 1628 -  */  0,
/* 1629 -  */  0,
/* 162a -  */  0,
/* 162b -  */  0,
/* 162c - _0F_C7_06 */  0x24dd,
/* 162d - _66_0F_C7_06 */  0x24de,
/* 162e - _F3_0F_C7_06 */  0x24df,
/* 162f -  */  0,
/* 1630 -  */  0,
/* 1631 -  */  0,
/* 1632 -  */  0,
/* 1633 -  */  0,
/* 1634 -  */  0,
/* 1635 -  */  0,
/* 1636 -  */  0,
/* 1637 -  */  0
};

_InstSharedInfo InstSharedInfoTable[474] = {
{0, 6, 68, 245, 0, 0, 256},
{0, 8, 72, 245, 0, 0, 256},
{0, 68, 6, 245, 0, 0, 256},
{0, 72, 8, 245, 0, 0, 256},
{1, 1, 11, 245, 0, 0, 256},
{1, 3, 13, 245, 0, 0, 256},
{2, 0, 46, 0, 0, 0, 256},
{3, 0, 46, 0, 0, 0, 256},
{0, 6, 68, 196, 16, 0, 256},
{0, 8, 72, 196, 16, 0, 256},
{0, 68, 6, 196, 16, 0, 256},
{0, 72, 8, 196, 16, 0, 256},
{1, 1, 11, 196, 16, 0, 256},
{1, 3, 13, 196, 16, 0, 256},
{4, 0, 46, 0, 0, 0, 256},
{0, 6, 68, 245, 1, 0, 256},
{0, 8, 72, 245, 1, 0, 256},
{0, 68, 6, 245, 1, 0, 256},
{0, 72, 8, 245, 1, 0, 256},
{1, 1, 11, 245, 1, 0, 256},
{1, 3, 13, 245, 1, 0, 256},
{5, 0, 46, 0, 0, 0, 256},
{6, 0, 46, 0, 0, 0, 256},
{7, 0, 46, 0, 0, 0, 256},
{8, 0, 46, 0, 0, 0, 256},
{0, 6, 68, 229, 0, 16, 256},
{0, 8, 72, 229, 0, 16, 256},
{0, 68, 6, 229, 0, 16, 256},
{0, 72, 8, 229, 0, 16, 256},
{1, 1, 11, 229, 0, 16, 256},
{1, 3, 13, 229, 0, 16, 256},
{9, 0, 0, 213, 17, 32, 256},
{0, 6, 68, 196, 0, 16, 256},
{0, 8, 72, 196, 0, 16, 256},
{0, 68, 6, 196, 0, 16, 256},
{0, 72, 8, 196, 0, 16, 256},
{1, 1, 11, 196, 0, 16, 256},
{1, 3, 13, 196, 0, 16, 256},
{9, 0, 0, 17, 16, 228, 256},
{10, 6, 68, 245, 0, 0, 256},
{10, 8, 72, 245, 0, 0, 256},
{10, 68, 6, 245, 0, 0, 256},
{10, 72, 8, 245, 0, 0, 256},
{11, 1, 11, 245, 0, 0, 256},
{11, 3, 13, 245, 0, 0, 256},
{12, 0, 18, 244, 0, 0, 256},
{13, 0, 18, 0, 0, 0, 256},
{14, 0, 18, 0, 0, 0, 256},
{15, 0, 0, 0, 0, 0, 256},
{16, 54, 8, 0, 0, 0, 256},
{10, 7, 69, 64, 0, 0, 256},
{13, 0, 3, 0, 0, 0, 256},
{17, 72, 8, 33, 0, 212, 256},
{18, 0, 5, 0, 0, 0, 256},
{19, 25, 22, 0, 8, 0, 33024},
{20, 25, 22, 0, 8, 0, 33024},
{19, 21, 25, 0, 8, 0, 33024},
{20, 21, 25, 0, 8, 0, 33024},
{13, 0, 15, 0, 32, 0, 261},
{13, 0, 15, 0, 1, 0, 261},
{13, 0, 15, 0, 64, 0, 261},
{13, 0, 15, 0, 65, 0, 261},
{13, 0, 15, 0, 128, 0, 261},
{13, 0, 15, 0, 4, 0, 261},
{13, 0, 15, 0, 160, 0, 261},
{13, 0, 15, 0, 224, 0, 261},
{10, 6, 68, 196, 0, 16, 256},
{10, 8, 72, 196, 0, 16, 256},
{0, 6, 68, 0, 0, 0, 256},
{0, 8, 72, 0, 0, 0, 256},
{21, 6, 68, 0, 0, 0, 256},
{21, 8, 72, 0, 0, 0, 256},
{21, 68, 6, 0, 0, 0, 256},
{21, 72, 8, 0, 0, 0, 256},
{21, 45, 71, 0, 0, 0, 256},
{21, 54, 8, 0, 0, 0, 256},
{21, 71, 45, 0, 0, 0, 256},
{1, 13, 18, 0, 0, 0, 256},
{22, 0, 0, 0, 0, 0, 256},
{9, 0, 50, 0, 0, 0, 257},
{23, 0, 0, 0, 0, 0, 256},
{23, 0, 0, 255, 0, 0, 256},
{11, 0, 0, 213, 0, 0, 256},
{11, 0, 0, 0, 0, 0, 256},
{1, 19, 11, 0, 0, 0, 256},
{1, 20, 13, 0, 0, 0, 256},
{1, 11, 19, 0, 0, 0, 256},
{1, 13, 20, 0, 0, 0, 256},
{24, 21, 22, 0, 8, 0, 256},
{25, 21, 22, 0, 8, 0, 256},
{19, 22, 21, 245, 8, 0, 256},
{26, 22, 21, 245, 8, 0, 256},
{11, 1, 11, 196, 0, 16, 256},
{11, 3, 13, 196, 0, 16, 256},
{19, 11, 22, 0, 8, 0, 256},
{26, 13, 22, 0, 8, 0, 256},
{19, 21, 11, 0, 8, 0, 256},
{26, 21, 13, 0, 8, 0, 256},
{19, 11, 22, 245, 8, 0, 256},
{26, 13, 22, 245, 8, 0, 256},
{1, 1, 17, 0, 0, 0, 256},
{27, 3, 18, 0, 0, 0, 256},
{13, 0, 2, 0, 0, 0, 258},
{13, 0, 0, 0, 0, 0, 258},
{16, 60, 8, 0, 0, 0, 256},
{13, 49, 47, 0, 0, 0, 256},
{13, 0, 0, 0, 0, 0, 256},
{28, 0, 2, 0, 0, 0, 258},
{28, 0, 0, 0, 0, 0, 258},
{11, 0, 1, 0, 0, 0, 262},
{9, 0, 0, 0, 0, 0, 262},
{28, 0, 0, 255, 0, 0, 33026},
{9, 0, 1, 196, 0, 49, 256},
{9, 0, 0, 0, 0, 0, 256},
{29, 0, 23, 0, 0, 0, 256},
{30, 0, 15, 0, 64, 0, 261},
{30, 0, 15, 0, 0, 0, 261},
{31, 0, 15, 0, 0, 0, 261},
{1, 1, 11, 0, 0, 0, 33024},
{1, 1, 14, 0, 0, 0, 33024},
{11, 11, 1, 0, 0, 0, 33024},
{11, 14, 1, 0, 0, 0, 33024},
{13, 0, 16, 0, 0, 0, 257},
{13, 0, 16, 0, 0, 0, 260},
{9, 0, 50, 0, 0, 0, 260},
{13, 0, 15, 0, 0, 0, 260},
{1, 25, 11, 0, 0, 0, 33024},
{1, 25, 14, 0, 0, 0, 33024},
{11, 11, 25, 0, 0, 0, 33024},
{11, 14, 25, 0, 0, 0, 33024},
{11, 0, 0, 0, 0, 0, 262},
{11, 0, 0, 0, 0, 0, 33032},
{11, 0, 0, 1, 0, 0, 256},
{11, 0, 0, 2, 0, 0, 33024},
{11, 0, 0, 8, 0, 0, 256},
{10, 69, 8, 64, 0, 0, 256},
{32, 0, 0, 0, 0, 0, 771},
{32, 0, 0, 0, 0, 0, 33024},
{32, 0, 0, 0, 0, 0, 262},
{11, 0, 0, 0, 0, 0, 3072},
{10, 0, 72, 0, 0, 0, 256},
{33, 43, 51, 0, 0, 0, 33024},
{33, 44, 51, 0, 0, 0, 33024},
{33, 51, 43, 0, 0, 0, 33024},
{33, 51, 44, 0, 0, 0, 33024},
{32, 0, 0, 0, 0, 0, 256},
{34, 72, 8, 0, 32, 0, 775},
{34, 72, 8, 0, 1, 0, 775},
{34, 72, 8, 0, 64, 0, 775},
{34, 72, 8, 0, 65, 0, 775},
{34, 72, 8, 0, 128, 0, 775},
{34, 72, 8, 0, 4, 0, 775},
{34, 72, 8, 0, 160, 0, 775},
{34, 72, 8, 0, 224, 0, 775},
{32, 0, 16, 0, 32, 0, 261},
{32, 0, 16, 0, 1, 0, 261},
{32, 0, 16, 0, 64, 0, 261},
{32, 0, 16, 0, 65, 0, 261},
{32, 0, 16, 0, 128, 0, 261},
{32, 0, 16, 0, 4, 0, 261},
{32, 0, 16, 0, 160, 0, 261},
{32, 0, 16, 0, 224, 0, 261},
{34, 0, 68, 0, 32, 0, 256},
{34, 0, 68, 0, 1, 0, 256},
{34, 0, 68, 0, 64, 0, 256},
{34, 0, 68, 0, 65, 0, 256},
{34, 0, 68, 0, 128, 0, 256},
{34, 0, 68, 0, 4, 0, 256},
{34, 0, 68, 0, 160, 0, 256},
{34, 0, 68, 0, 224, 0, 256},
{35, 0, 46, 0, 0, 0, 256},
{36, 0, 46, 0, 0, 0, 256},
{34, 8, 72, 1, 0, 244, 256},
{37, 8, 72, 197, 0, 48, 256},
{38, 0, 46, 0, 0, 0, 256},
{39, 0, 46, 0, 0, 0, 256},
{32, 0, 0, 255, 0, 0, 256},
{40, 8, 72, 1, 0, 244, 256},
{34, 72, 8, 33, 0, 212, 256},
{40, 6, 68, 245, 0, 0, 256},
{40, 8, 72, 245, 0, 0, 256},
{41, 60, 8, 0, 0, 0, 256},
{34, 68, 8, 0, 0, 0, 256},
{42, 69, 8, 0, 0, 0, 256},
{42, 10, 56, 0, 0, 0, 1536},
{43, 0, 18, 0, 0, 0, 256},
{44, 1, 68, 245, 0, 0, 256},
{44, 1, 68, 196, 16, 0, 256},
{44, 1, 68, 245, 1, 0, 256},
{44, 1, 68, 229, 0, 16, 256},
{44, 1, 68, 196, 0, 16, 256},
{45, 1, 68, 245, 0, 0, 256},
{44, 3, 72, 245, 0, 0, 256},
{44, 3, 72, 196, 16, 0, 256},
{44, 3, 72, 245, 1, 0, 256},
{44, 3, 72, 229, 0, 16, 256},
{44, 3, 72, 196, 0, 16, 256},
{45, 3, 72, 245, 0, 0, 256},
{46, 1, 68, 245, 0, 0, 256},
{46, 1, 68, 196, 16, 0, 256},
{46, 1, 68, 245, 1, 0, 256},
{46, 1, 68, 229, 0, 16, 256},
{46, 1, 68, 196, 0, 16, 256},
{47, 1, 68, 245, 0, 0, 256},
{44, 5, 72, 245, 0, 0, 256},
{48, 5, 72, 196, 16, 0, 256},
{44, 5, 72, 245, 1, 0, 256},
{48, 5, 72, 229, 0, 16, 256},
{48, 5, 72, 196, 0, 16, 256},
{45, 5, 72, 245, 0, 0, 256},
{49, 0, 72, 0, 0, 0, 256},
{50, 1, 68, 1, 0, 32, 256},
{50, 1, 68, 1, 1, 32, 256},
{50, 1, 68, 197, 0, 48, 256},
{50, 1, 72, 1, 0, 32, 256},
{50, 1, 72, 1, 1, 32, 256},
{50, 1, 72, 197, 0, 48, 256},
{51, 1, 68, 0, 0, 0, 256},
{52, 0, 1, 0, 0, 0, 768},
{51, 3, 72, 0, 0, 0, 256},
{52, 0, 16, 0, 0, 0, 768},
{50, 41, 68, 33, 0, 0, 256},
{50, 41, 68, 33, 1, 0, 256},
{50, 41, 68, 229, 0, 16, 256},
{50, 41, 72, 33, 0, 0, 256},
{50, 41, 72, 33, 1, 0, 256},
{50, 41, 72, 229, 0, 16, 256},
{50, 42, 68, 1, 0, 32, 256},
{50, 42, 68, 1, 1, 32, 256},
{50, 42, 68, 197, 0, 48, 256},
{50, 42, 72, 1, 0, 32, 256},
{50, 42, 72, 1, 1, 32, 256},
{50, 42, 72, 197, 0, 48, 256},
{45, 0, 64, 0, 0, 0, 512},
{53, 0, 28, 0, 0, 0, 512},
{53, 0, 27, 0, 0, 0, 512},
{53, 0, 0, 0, 0, 0, 512},
{50, 0, 64, 0, 0, 0, 512},
{45, 0, 54, 0, 0, 0, 512},
{45, 0, 63, 0, 0, 0, 512},
{54, 0, 28, 0, 1, 0, 768},
{54, 0, 28, 0, 64, 0, 768},
{54, 0, 28, 0, 65, 0, 768},
{54, 0, 28, 0, 4, 0, 768},
{55, 0, 64, 0, 0, 0, 1792},
{45, 0, 66, 0, 0, 0, 512},
{50, 0, 66, 0, 0, 0, 512},
{54, 0, 28, 69, 0, 0, 512},
{54, 0, 28, 69, 0, 0, 768},
{45, 0, 65, 0, 0, 0, 512},
{53, 0, 29, 0, 0, 0, 512},
{55, 0, 65, 0, 0, 0, 1792},
{50, 0, 65, 0, 0, 0, 512},
{55, 0, 63, 0, 0, 0, 1792},
{50, 0, 63, 0, 0, 0, 512},
{45, 1, 68, 196, 0, 16, 256},
{44, 0, 68, 0, 0, 0, 256},
{44, 0, 68, 245, 0, 0, 256},
{50, 0, 68, 33, 0, 212, 256},
{50, 0, 68, 0, 0, 245, 256},
{45, 3, 72, 196, 0, 16, 256},
{44, 0, 72, 0, 0, 0, 256},
{44, 0, 72, 245, 0, 0, 256},
{50, 0, 72, 33, 0, 212, 256},
{50, 0, 72, 0, 0, 245, 256},
{44, 0, 68, 244, 0, 0, 256},
{44, 0, 72, 244, 0, 0, 256},
{56, 0, 72, 0, 0, 0, 257},
{57, 0, 60, 0, 0, 0, 257},
{56, 0, 72, 0, 0, 0, 260},
{57, 0, 60, 0, 0, 0, 260},
{56, 0, 72, 0, 0, 0, 256},
{45, 0, 72, 0, 0, 0, 256},
{45, 0, 69, 0, 0, 0, 256},
{45, 0, 69, 0, 0, 0, 33024},
{55, 0, 69, 0, 0, 0, 33024},
{45, 0, 69, 64, 0, 0, 256},
{56, 0, 61, 0, 0, 0, 256},
{56, 0, 61, 0, 0, 0, 33024},
{51, 0, 71, 0, 0, 0, 256},
{58, 0, 69, 0, 0, 0, 33024},
{55, 0, 54, 0, 0, 0, 33024},
{54, 0, 0, 0, 0, 0, 3584},
{54, 0, 0, 0, 0, 0, 256},
{13, 0, 0, 0, 0, 0, 768},
{55, 0, 24, 0, 0, 0, 3840},
{54, 0, 0, 0, 0, 0, 3840},
{54, 0, 24, 0, 0, 0, 3840},
{54, 26, 24, 0, 0, 0, 3840},
{59, 0, 0, 0, 0, 0, 256},
{55, 0, 54, 0, 0, 0, 3072},
{60, 83, 52, 0, 0, 0, 3328},
{60, 83, 52, 0, 0, 0, 3072},
{34, 87, 30, 0, 0, 0, 1280},
{34, 87, 30, 0, 0, 0, 1536},
{34, 85, 30, 0, 0, 0, 1280},
{34, 86, 30, 0, 0, 0, 1536},
{61, 91, 36, 0, 0, 0, 4096},
{62, 34, 30, 0, 0, 0, 4096},
{63, 55, 30, 0, 0, 0, 4096},
{63, 57, 30, 0, 0, 0, 4096},
{34, 30, 87, 0, 0, 0, 1280},
{34, 30, 87, 0, 0, 0, 1536},
{34, 30, 85, 0, 0, 0, 1280},
{34, 30, 86, 0, 0, 0, 1536},
{61, 36, 91, 0, 0, 0, 4096},
{63, 30, 55, 0, 0, 0, 4096},
{63, 30, 57, 0, 0, 0, 4096},
{64, 86, 30, 0, 0, 0, 1280},
{34, 57, 30, 0, 0, 0, 1536},
{34, 86, 30, 0, 0, 0, 1792},
{65, 34, 30, 0, 0, 0, 4096},
{66, 34, 30, 0, 0, 0, 4096},
{61, 90, 36, 0, 0, 0, 4096},
{34, 30, 57, 0, 0, 0, 1280},
{34, 30, 57, 0, 0, 0, 1536},
{61, 30, 57, 0, 0, 0, 4096},
{67, 87, 30, 0, 0, 0, 1280},
{67, 87, 30, 0, 0, 0, 1536},
{66, 40, 36, 0, 0, 0, 4096},
{34, 87, 30, 0, 0, 0, 1792},
{55, 0, 54, 0, 0, 0, 1280},
{67, 83, 30, 0, 0, 0, 1280},
{67, 83, 30, 0, 0, 0, 1536},
{41, 76, 30, 0, 0, 0, 1280},
{41, 76, 30, 0, 0, 0, 1536},
{34, 30, 59, 0, 0, 0, 1280},
{34, 30, 59, 0, 0, 0, 1536},
{34, 30, 55, 0, 0, 0, 2816},
{34, 30, 57, 0, 0, 0, 2816},
{61, 36, 67, 0, 0, 0, 4096},
{67, 86, 52, 0, 0, 0, 1280},
{67, 87, 52, 0, 0, 0, 1536},
{41, 85, 10, 0, 0, 0, 1280},
{41, 86, 10, 0, 0, 0, 1536},
{61, 88, 33, 0, 0, 0, 4096},
{67, 85, 30, 69, 0, 0, 1280},
{67, 86, 30, 0, 0, 0, 1536},
{61, 85, 30, 0, 0, 0, 4096},
{61, 86, 30, 0, 0, 0, 4096},
{68, 31, 9, 0, 0, 0, 1280},
{68, 31, 9, 0, 0, 0, 1536},
{69, 36, 10, 0, 0, 0, 4096},
{67, 85, 30, 0, 0, 0, 1280},
{67, 85, 30, 0, 0, 0, 1536},
{61, 92, 36, 0, 0, 0, 4096},
{61, 91, 30, 0, 0, 0, 4096},
{67, 82, 52, 0, 0, 0, 1024},
{67, 83, 52, 0, 0, 0, 1024},
{70, 76, 52, 0, 0, 0, 1024},
{70, 76, 30, 0, 0, 0, 1536},
{61, 73, 30, 0, 0, 0, 4096},
{34, 83, 52, 0, 0, 0, 1024},
{71, 83, 52, 0, 0, 0, 1280},
{71, 87, 30, 0, 0, 0, 1536},
{66, 87, 30, 0, 0, 0, 4096},
{32, 0, 0, 0, 0, 0, 1024},
{72, 0, 0, 0, 0, 0, 4096},
{73, 10, 76, 0, 0, 0, 3584},
{74, 48, 31, 0, 0, 0, 2816},
{75, 31, 30, 0, 0, 0, 2816},
{73, 76, 10, 0, 0, 0, 3584},
{67, 31, 30, 0, 0, 0, 2816},
{76, 31, 30, 0, 0, 0, 2816},
{32, 86, 30, 0, 0, 0, 3584},
{32, 30, 86, 0, 0, 0, 3584},
{67, 87, 30, 0, 0, 0, 1792},
{70, 52, 76, 0, 0, 0, 1024},
{70, 30, 76, 0, 0, 0, 1536},
{61, 30, 73, 0, 0, 0, 4096},
{34, 52, 83, 0, 0, 0, 1024},
{77, 0, 54, 0, 0, 0, 256},
{78, 0, 62, 0, 0, 0, 256},
{79, 0, 62, 0, 0, 0, 256},
{80, 72, 8, 64, 0, 0, 2560},
{81, 1, 72, 1, 0, 244, 256},
{48, 1, 72, 1, 0, 244, 256},
{67, 72, 8, 64, 0, 245, 256},
{82, 72, 8, 0, 0, 0, 3584},
{83, 72, 8, 65, 0, 180, 256},
{84, 87, 30, 0, 0, 0, 1280},
{84, 87, 30, 0, 0, 0, 1536},
{84, 85, 30, 0, 0, 0, 1280},
{84, 86, 30, 0, 0, 0, 1536},
{85, 40, 36, 0, 0, 0, 4096},
{85, 34, 30, 0, 0, 0, 4096},
{71, 79, 52, 0, 0, 0, 1280},
{71, 79, 30, 0, 0, 0, 1536},
{86, 34, 30, 0, 0, 0, 4096},
{87, 53, 9, 0, 0, 0, 1280},
{71, 31, 9, 0, 0, 0, 1536},
{88, 30, 10, 0, 0, 0, 4096},
{71, 87, 30, 0, 0, 0, 1280},
{86, 40, 36, 0, 0, 0, 4096},
{89, 0, 58, 64, 0, 0, 256},
{55, 0, 57, 0, 0, 0, 3584},
{68, 53, 30, 0, 0, 0, 1536},
{68, 31, 52, 0, 0, 0, 1536},
{61, 30, 86, 0, 0, 0, 4096},
{76, 53, 9, 0, 0, 0, 1280},
{76, 31, 9, 0, 0, 0, 1536},
{69, 30, 10, 0, 0, 0, 4096},
{67, 83, 52, 0, 0, 0, 1280},
{34, 52, 57, 0, 0, 0, 1280},
{67, 54, 30, 0, 0, 0, 1792},
{61, 67, 36, 0, 0, 0, 4096},
{67, 83, 52, 0, 0, 0, 1536},
{76, 53, 52, 0, 0, 0, 1280},
{76, 31, 30, 0, 0, 0, 1536},
{90, 31, 30, 0, 0, 0, 4096},
{50, 0, 54, 0, 0, 0, 512},
{91, 0, 54, 0, 0, 0, 512},
{91, 0, 63, 0, 0, 0, 512},
{92, 0, 0, 0, 0, 0, 512},
{93, 0, 12, 0, 0, 0, 512},
{94, 0, 12, 0, 0, 0, 512},
{67, 83, 52, 0, 0, 0, 2048},
{67, 87, 30, 0, 0, 0, 2048},
{71, 87, 30, 0, 0, 0, 2304},
{67, 87, 30, 0, 0, 0, 2560},
{61, 55, 36, 0, 0, 0, 4096},
{61, 57, 38, 0, 0, 0, 4096},
{61, 59, 38, 0, 0, 0, 4096},
{61, 87, 30, 0, 0, 0, 4096},
{67, 86, 30, 0, 0, 0, 2304},
{67, 85, 30, 0, 0, 0, 2304},
{67, 84, 30, 0, 0, 0, 2304},
{61, 84, 30, 0, 0, 0, 4096},
{67, 87, 30, 0, 0, 0, 2304},
{34, 59, 30, 0, 0, 0, 2304},
{61, 59, 30, 0, 0, 0, 4096},
{66, 40, 67, 0, 0, 0, 4096},
{73, 59, 10, 0, 0, 0, 3584},
{66, 40, 36, 0, 0, 0, 4352},
{66, 34, 30, 0, 0, 0, 4352},
{67, 87, 30, 0, 0, 0, 4864},
{61, 87, 30, 0, 0, 0, 4864},
{66, 34, 30, 0, 0, 0, 4864},
{34, 72, 8, 0, 0, 0, 256},
{34, 68, 10, 0, 0, 0, 2560},
{34, 8, 72, 0, 0, 0, 256},
{34, 72, 10, 0, 0, 0, 2560},
{66, 91, 36, 0, 0, 0, 4096},
{86, 39, 38, 0, 0, 0, 4096},
{71, 85, 30, 0, 0, 0, 2304},
{71, 86, 30, 0, 0, 0, 2304},
{71, 83, 52, 0, 0, 0, 2048},
{71, 87, 30, 0, 0, 0, 2048},
{71, 30, 74, 0, 0, 0, 2304},
{88, 30, 80, 0, 0, 0, 4096},
{71, 30, 75, 0, 0, 0, 2304},
{88, 30, 81, 0, 0, 0, 4096},
{95, 30, 76, 0, 0, 0, 2304},
{66, 30, 73, 0, 0, 0, 4096},
{71, 30, 76, 0, 0, 0, 2304},
{66, 30, 70, 0, 0, 0, 4096},
{66, 38, 87, 0, 0, 0, 4096},
{71, 78, 30, 0, 0, 0, 2304},
{95, 76, 30, 0, 0, 0, 2304},
{71, 87, 30, 0, 0, 0, 4608},
{86, 34, 30, 0, 0, 0, 4608},
{71, 87, 30, 0, 0, 0, 2560},
{71, 87, 30, 0, 0, 0, 4864},
{66, 87, 30, 0, 0, 0, 4864},
{96, 1, 53, 0, 0, 0, 1024},
{55, 1, 31, 0, 0, 0, 1536},
{97, 31, 34, 0, 0, 0, 4096},
{98, 0, 10, 0, 0, 0, 3584},
{55, 0, 55, 0, 0, 0, 256},
{63, 0, 55, 0, 0, 0, 4096},
{55, 0, 54, 0, 0, 0, 3584},
{99, 70, 10, 0, 0, 0, 256},
{98, 0, 72, 0, 0, 0, 256},
{100, 83, 52, 0, 0, 0, 3072}
};

uint16_t CmpMnemonicOffsets[8] = {
0, 9, 18, 27, 39, 49, 59, 69
};
uint16_t VCmpMnemonicOffsets[32] = {
0, 10, 20, 30, 43, 54, 65, 76, 87, 100, 111, 122, 135, 149, 159, 169, 181, 194, 207, 220, 235, 249, 263, 277, 290, 303, 317, 331, 347, 361, 374, 387
};
```

`DumpVAC/distorm/src/insts.h`:

```h
/*
insts.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef INSTS_H
#define INSTS_H

#include "instructions.h"


/* Flags Table */
extern _iflags FlagsTable[];

/* Root Trie DB */
extern _InstSharedInfo InstSharedInfoTable[];
extern _InstInfo InstInfos[];
extern _InstInfoEx InstInfosEx[];
extern _InstNode InstructionsTree[];

/* 3DNow! Trie DB */
extern _InstNode Table_0F_0F;
/* AVX related: */
extern _InstNode Table_0F, Table_0F_38, Table_0F_3A;

/*
 * The inst_lookup will return on of these two instructions according to the specified decoding mode.
 * ARPL or MOVSXD on 64 bits is one byte instruction at index 0x63.
 */
extern _InstInfo II_MOVSXD;

/*
 * The NOP instruction can be prefixed by REX in 64bits, therefore we have to decide in runtime whether it's an XCHG or NOP instruction.
 * If 0x90 is prefixed by a usable REX it will become XCHG, otherwise it will become a NOP.
 * Also note that if it's prefixed by 0xf3, it becomes a Pause.
 */
extern _InstInfo II_NOP;
extern _InstInfo II_PAUSE;

/*
 * RDRAND and VMPTRLD share same 2.3 bytes opcode, and then alternates on the MOD bits,
 * RDRAND is OT_FULL_REG while VMPTRLD is OT_MEM, and there's no such mixed type.
 * So a hack into the inst_lookup was added for this decision, the DB isn't flexible enough. :(
 */
extern _InstInfo II_RDRAND;

/*
 * Used for letting the extract operand know the type of operands without knowing the
 * instruction itself yet, because of the way those instructions work.
 * See function instructions.c!inst_lookup_3dnow.
 */
extern _InstInfo II_3DNOW;

/* Helper tables for pseudo compare mnemonics. */
extern uint16_t CmpMnemonicOffsets[8]; /* SSE */
extern uint16_t VCmpMnemonicOffsets[32]; /* AVX */

#endif /* INSTS_H */

```

`DumpVAC/distorm/src/mnemonics.c`:

```c
/*
mnemonics.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "../include/mnemonics.h"

#ifndef DISTORM_LIGHT

const unsigned char _MNEMONICS[] =
"\x09" "UNDEFINED\0" "\x03" "ADD\0" "\x04" "PUSH\0" "\x03" "POP\0" \
"\x02" "OR\0" "\x03" "ADC\0" "\x03" "SBB\0" "\x03" "AND\0" "\x03" "DAA\0" \
"\x03" "SUB\0" "\x03" "DAS\0" "\x03" "XOR\0" "\x03" "AAA\0" "\x03" "CMP\0" \
"\x03" "AAS\0" "\x03" "INC\0" "\x03" "DEC\0" "\x05" "PUSHA\0" "\x04" "POPA\0" \
"\x05" "BOUND\0" "\x04" "ARPL\0" "\x04" "IMUL\0" "\x03" "INS\0" "\x04" "OUTS\0" \
"\x02" "JO\0" "\x03" "JNO\0" "\x02" "JB\0" "\x03" "JAE\0" "\x02" "JZ\0" \
"\x03" "JNZ\0" "\x03" "JBE\0" "\x02" "JA\0" "\x02" "JS\0" "\x03" "JNS\0" \
"\x02" "JP\0" "\x03" "JNP\0" "\x02" "JL\0" "\x03" "JGE\0" "\x03" "JLE\0" \
"\x02" "JG\0" "\x04" "TEST\0" "\x04" "XCHG\0" "\x03" "MOV\0" "\x03" "LEA\0" \
"\x03" "CBW\0" "\x04" "CWDE\0" "\x04" "CDQE\0" "\x03" "CWD\0" "\x03" "CDQ\0" \
"\x03" "CQO\0" "\x08" "CALL FAR\0" "\x05" "PUSHF\0" "\x04" "POPF\0" \
"\x04" "SAHF\0" "\x04" "LAHF\0" "\x04" "MOVS\0" "\x04" "CMPS\0" "\x04" "STOS\0" \
"\x04" "LODS\0" "\x04" "SCAS\0" "\x03" "RET\0" "\x03" "LES\0" "\x03" "LDS\0" \
"\x05" "ENTER\0" "\x05" "LEAVE\0" "\x04" "RETF\0" "\x04" "INT3\0" "\x03" "INT\0" \
"\x04" "INTO\0" "\x04" "IRET\0" "\x03" "AAM\0" "\x03" "AAD\0" "\x04" "SALC\0" \
"\x04" "XLAT\0" "\x06" "LOOPNZ\0" "\x05" "LOOPZ\0" "\x04" "LOOP\0" \
"\x04" "JCXZ\0" "\x05" "JECXZ\0" "\x05" "JRCXZ\0" "\x02" "IN\0" "\x03" "OUT\0" \
"\x04" "CALL\0" "\x03" "JMP\0" "\x07" "JMP FAR\0" "\x04" "INT1\0" "\x03" "HLT\0" \
"\x03" "CMC\0" "\x03" "CLC\0" "\x03" "STC\0" "\x03" "CLI\0" "\x03" "STI\0" \
"\x03" "CLD\0" "\x03" "STD\0" "\x03" "LAR\0" "\x03" "LSL\0" "\x07" "SYSCALL\0" \
"\x04" "CLTS\0" "\x06" "SYSRET\0" "\x04" "INVD\0" "\x06" "WBINVD\0" \
"\x03" "UD2\0" "\x05" "FEMMS\0" "\x03" "NOP\0" "\x05" "WRMSR\0" "\x05" "RDTSC\0" \
"\x05" "RDMSR\0" "\x05" "RDPMC\0" "\x08" "SYSENTER\0" "\x07" "SYSEXIT\0" \
"\x06" "GETSEC\0" "\x05" "CMOVO\0" "\x06" "CMOVNO\0" "\x05" "CMOVB\0" \
"\x06" "CMOVAE\0" "\x05" "CMOVZ\0" "\x06" "CMOVNZ\0" "\x06" "CMOVBE\0" \
"\x05" "CMOVA\0" "\x05" "CMOVS\0" "\x06" "CMOVNS\0" "\x05" "CMOVP\0" \
"\x06" "CMOVNP\0" "\x05" "CMOVL\0" "\x06" "CMOVGE\0" "\x06" "CMOVLE\0" \
"\x05" "CMOVG\0" "\x04" "SETO\0" "\x05" "SETNO\0" "\x04" "SETB\0" "\x05" "SETAE\0" \
"\x04" "SETZ\0" "\x05" "SETNZ\0" "\x05" "SETBE\0" "\x04" "SETA\0" "\x04" "SETS\0" \
"\x05" "SETNS\0" "\x04" "SETP\0" "\x05" "SETNP\0" "\x04" "SETL\0" "\x05" "SETGE\0" \
"\x05" "SETLE\0" "\x04" "SETG\0" "\x05" "CPUID\0" "\x02" "BT\0" "\x04" "SHLD\0" \
"\x03" "RSM\0" "\x03" "BTS\0" "\x04" "SHRD\0" "\x07" "CMPXCHG\0" "\x03" "LSS\0" \
"\x03" "BTR\0" "\x03" "LFS\0" "\x03" "LGS\0" "\x05" "MOVZX\0" "\x03" "BTC\0" \
"\x05" "MOVSX\0" "\x04" "XADD\0" "\x06" "MOVNTI\0" "\x05" "BSWAP\0" \
"\x03" "ROL\0" "\x03" "ROR\0" "\x03" "RCL\0" "\x03" "RCR\0" "\x03" "SHL\0" \
"\x03" "SHR\0" "\x03" "SAL\0" "\x03" "SAR\0" "\x06" "XABORT\0" "\x06" "XBEGIN\0" \
"\x04" "FADD\0" "\x04" "FMUL\0" "\x04" "FCOM\0" "\x05" "FCOMP\0" "\x04" "FSUB\0" \
"\x05" "FSUBR\0" "\x04" "FDIV\0" "\x05" "FDIVR\0" "\x03" "FLD\0" "\x03" "FST\0" \
"\x04" "FSTP\0" "\x06" "FLDENV\0" "\x05" "FLDCW\0" "\x04" "FXCH\0" \
"\x04" "FNOP\0" "\x04" "FCHS\0" "\x04" "FABS\0" "\x04" "FTST\0" "\x04" "FXAM\0" \
"\x04" "FLD1\0" "\x06" "FLDL2T\0" "\x06" "FLDL2E\0" "\x05" "FLDPI\0" \
"\x06" "FLDLG2\0" "\x06" "FLDLN2\0" "\x04" "FLDZ\0" "\x05" "F2XM1\0" \
"\x05" "FYL2X\0" "\x05" "FPTAN\0" "\x06" "FPATAN\0" "\x07" "FXTRACT\0" \
"\x06" "FPREM1\0" "\x07" "FDECSTP\0" "\x07" "FINCSTP\0" "\x05" "FPREM\0" \
"\x07" "FYL2XP1\0" "\x05" "FSQRT\0" "\x07" "FSINCOS\0" "\x07" "FRNDINT\0" \
"\x06" "FSCALE\0" "\x04" "FSIN\0" "\x04" "FCOS\0" "\x05" "FIADD\0" \
"\x05" "FIMUL\0" "\x05" "FICOM\0" "\x06" "FICOMP\0" "\x05" "FISUB\0" \
"\x06" "FISUBR\0" "\x05" "FIDIV\0" "\x06" "FIDIVR\0" "\x06" "FCMOVB\0" \
"\x06" "FCMOVE\0" "\x07" "FCMOVBE\0" "\x06" "FCMOVU\0" "\x07" "FUCOMPP\0" \
"\x04" "FILD\0" "\x06" "FISTTP\0" "\x04" "FIST\0" "\x05" "FISTP\0" \
"\x07" "FCMOVNB\0" "\x07" "FCMOVNE\0" "\x08" "FCMOVNBE\0" "\x07" "FCMOVNU\0" \
"\x04" "FENI\0" "\x06" "FEDISI\0" "\x06" "FSETPM\0" "\x06" "FUCOMI\0" \
"\x05" "FCOMI\0" "\x06" "FRSTOR\0" "\x05" "FFREE\0" "\x05" "FUCOM\0" \
"\x06" "FUCOMP\0" "\x05" "FADDP\0" "\x05" "FMULP\0" "\x06" "FCOMPP\0" \
"\x06" "FSUBRP\0" "\x05" "FSUBP\0" "\x06" "FDIVRP\0" "\x05" "FDIVP\0" \
"\x04" "FBLD\0" "\x05" "FBSTP\0" "\x07" "FUCOMIP\0" "\x06" "FCOMIP\0" \
"\x03" "NOT\0" "\x03" "NEG\0" "\x03" "MUL\0" "\x03" "DIV\0" "\x04" "IDIV\0" \
"\x04" "SLDT\0" "\x03" "STR\0" "\x04" "LLDT\0" "\x03" "LTR\0" "\x04" "VERR\0" \
"\x04" "VERW\0" "\x04" "SGDT\0" "\x04" "SIDT\0" "\x04" "LGDT\0" "\x04" "LIDT\0" \
"\x04" "SMSW\0" "\x04" "LMSW\0" "\x06" "INVLPG\0" "\x06" "VMCALL\0" \
"\x08" "VMLAUNCH\0" "\x08" "VMRESUME\0" "\x06" "VMXOFF\0" "\x07" "MONITOR\0" \
"\x05" "MWAIT\0" "\x04" "CLAC\0" "\x04" "STAC\0" "\x06" "XGETBV\0" \
"\x06" "XSETBV\0" "\x06" "VMFUNC\0" "\x04" "XEND\0" "\x05" "VMRUN\0" \
"\x07" "VMMCALL\0" "\x06" "VMLOAD\0" "\x06" "VMSAVE\0" "\x04" "STGI\0" \
"\x04" "CLGI\0" "\x06" "SKINIT\0" "\x07" "INVLPGA\0" "\x06" "SWAPGS\0" \
"\x06" "RDTSCP\0" "\x08" "PREFETCH\0" "\x09" "PREFETCHW\0" "\x05" "PI2FW\0" \
"\x05" "PI2FD\0" "\x05" "PF2IW\0" "\x05" "PF2ID\0" "\x06" "PFNACC\0" \
"\x07" "PFPNACC\0" "\x07" "PFCMPGE\0" "\x05" "PFMIN\0" "\x05" "PFRCP\0" \
"\x07" "PFRSQRT\0" "\x05" "PFSUB\0" "\x05" "PFADD\0" "\x07" "PFCMPGT\0" \
"\x05" "PFMAX\0" "\x08" "PFRCPIT1\0" "\x08" "PFRSQIT1\0" "\x06" "PFSUBR\0" \
"\x05" "PFACC\0" "\x07" "PFCMPEQ\0" "\x05" "PFMUL\0" "\x08" "PFRCPIT2\0" \
"\x07" "PMULHRW\0" "\x06" "PSWAPD\0" "\x07" "PAVGUSB\0" "\x06" "MOVUPS\0" \
"\x06" "MOVUPD\0" "\x05" "MOVSS\0" "\x05" "MOVSD\0" "\x07" "VMOVUPS\0" \
"\x07" "VMOVUPD\0" "\x06" "VMOVSS\0" "\x06" "VMOVSD\0" "\x07" "MOVHLPS\0" \
"\x06" "MOVLPS\0" "\x06" "MOVLPD\0" "\x08" "MOVSLDUP\0" "\x07" "MOVDDUP\0" \
"\x08" "VMOVHLPS\0" "\x07" "VMOVLPS\0" "\x07" "VMOVLPD\0" "\x09" "VMOVSLDUP\0" \
"\x08" "VMOVDDUP\0" "\x08" "UNPCKLPS\0" "\x08" "UNPCKLPD\0" "\x09" "VUNPCKLPS\0" \
"\x09" "VUNPCKLPD\0" "\x08" "UNPCKHPS\0" "\x08" "UNPCKHPD\0" "\x09" "VUNPCKHPS\0" \
"\x09" "VUNPCKHPD\0" "\x07" "MOVLHPS\0" "\x06" "MOVHPS\0" "\x06" "MOVHPD\0" \
"\x08" "MOVSHDUP\0" "\x08" "VMOVLHPS\0" "\x07" "VMOVHPS\0" "\x07" "VMOVHPD\0" \
"\x09" "VMOVSHDUP\0" "\x0b" "PREFETCHNTA\0" "\x0a" "PREFETCHT0\0" "\x0a" "PREFETCHT1\0" \
"\x0a" "PREFETCHT2\0" "\x06" "MOVAPS\0" "\x06" "MOVAPD\0" "\x07" "VMOVAPS\0" \
"\x07" "VMOVAPD\0" "\x08" "CVTPI2PS\0" "\x08" "CVTPI2PD\0" "\x08" "CVTSI2SS\0" \
"\x08" "CVTSI2SD\0" "\x09" "VCVTSI2SS\0" "\x09" "VCVTSI2SD\0" "\x07" "MOVNTPS\0" \
"\x07" "MOVNTPD\0" "\x07" "MOVNTSS\0" "\x07" "MOVNTSD\0" "\x08" "VMOVNTPS\0" \
"\x08" "VMOVNTPD\0" "\x09" "CVTTPS2PI\0" "\x09" "CVTTPD2PI\0" "\x09" "CVTTSS2SI\0" \
"\x09" "CVTTSD2SI\0" "\x0a" "VCVTTSS2SI\0" "\x0a" "VCVTTSD2SI\0" "\x08" "CVTPS2PI\0" \
"\x08" "CVTPD2PI\0" "\x08" "CVTSS2SI\0" "\x08" "CVTSD2SI\0" "\x09" "VCVTSS2SI\0" \
"\x09" "VCVTSD2SI\0" "\x07" "UCOMISS\0" "\x07" "UCOMISD\0" "\x08" "VUCOMISS\0" \
"\x08" "VUCOMISD\0" "\x06" "COMISS\0" "\x06" "COMISD\0" "\x07" "VCOMISS\0" \
"\x07" "VCOMISD\0" "\x08" "MOVMSKPS\0" "\x08" "MOVMSKPD\0" "\x09" "VMOVMSKPS\0" \
"\x09" "VMOVMSKPD\0" "\x06" "SQRTPS\0" "\x06" "SQRTPD\0" "\x06" "SQRTSS\0" \
"\x06" "SQRTSD\0" "\x07" "VSQRTPS\0" "\x07" "VSQRTPD\0" "\x07" "VSQRTSS\0" \
"\x07" "VSQRTSD\0" "\x07" "RSQRTPS\0" "\x07" "RSQRTSS\0" "\x08" "VRSQRTPS\0" \
"\x08" "VRSQRTSS\0" "\x05" "RCPPS\0" "\x05" "RCPSS\0" "\x06" "VRCPPS\0" \
"\x06" "VRCPSS\0" "\x05" "ANDPS\0" "\x05" "ANDPD\0" "\x06" "VANDPS\0" \
"\x06" "VANDPD\0" "\x06" "ANDNPS\0" "\x06" "ANDNPD\0" "\x07" "VANDNPS\0" \
"\x07" "VANDNPD\0" "\x04" "ORPS\0" "\x04" "ORPD\0" "\x05" "VORPS\0" \
"\x05" "VORPD\0" "\x05" "XORPS\0" "\x05" "XORPD\0" "\x06" "VXORPS\0" \
"\x06" "VXORPD\0" "\x05" "ADDPS\0" "\x05" "ADDPD\0" "\x05" "ADDSS\0" \
"\x05" "ADDSD\0" "\x06" "VADDPS\0" "\x06" "VADDPD\0" "\x06" "VADDSS\0" \
"\x06" "VADDSD\0" "\x05" "MULPS\0" "\x05" "MULPD\0" "\x05" "MULSS\0" \
"\x05" "MULSD\0" "\x06" "VMULPS\0" "\x06" "VMULPD\0" "\x06" "VMULSS\0" \
"\x06" "VMULSD\0" "\x08" "CVTPS2PD\0" "\x08" "CVTPD2PS\0" "\x08" "CVTSS2SD\0" \
"\x08" "CVTSD2SS\0" "\x09" "VCVTPS2PD\0" "\x09" "VCVTPD2PS\0" "\x09" "VCVTSS2SD\0" \
"\x09" "VCVTSD2SS\0" "\x08" "CVTDQ2PS\0" "\x08" "CVTPS2DQ\0" "\x09" "CVTTPS2DQ\0" \
"\x09" "VCVTDQ2PS\0" "\x09" "VCVTPS2DQ\0" "\x0a" "VCVTTPS2DQ\0" "\x05" "SUBPS\0" \
"\x05" "SUBPD\0" "\x05" "SUBSS\0" "\x05" "SUBSD\0" "\x06" "VSUBPS\0" \
"\x06" "VSUBPD\0" "\x06" "VSUBSS\0" "\x06" "VSUBSD\0" "\x05" "MINPS\0" \
"\x05" "MINPD\0" "\x05" "MINSS\0" "\x05" "MINSD\0" "\x06" "VMINPS\0" \
"\x06" "VMINPD\0" "\x06" "VMINSS\0" "\x06" "VMINSD\0" "\x05" "DIVPS\0" \
"\x05" "DIVPD\0" "\x05" "DIVSS\0" "\x05" "DIVSD\0" "\x06" "VDIVPS\0" \
"\x06" "VDIVPD\0" "\x06" "VDIVSS\0" "\x06" "VDIVSD\0" "\x05" "MAXPS\0" \
"\x05" "MAXPD\0" "\x05" "MAXSS\0" "\x05" "MAXSD\0" "\x06" "VMAXPS\0" \
"\x06" "VMAXPD\0" "\x06" "VMAXSS\0" "\x06" "VMAXSD\0" "\x09" "PUNPCKLBW\0" \
"\x0a" "VPUNPCKLBW\0" "\x09" "PUNPCKLWD\0" "\x0a" "VPUNPCKLWD\0" "\x09" "PUNPCKLDQ\0" \
"\x0a" "VPUNPCKLDQ\0" "\x08" "PACKSSWB\0" "\x09" "VPACKSSWB\0" "\x07" "PCMPGTB\0" \
"\x08" "VPCMPGTB\0" "\x07" "PCMPGTW\0" "\x08" "VPCMPGTW\0" "\x07" "PCMPGTD\0" \
"\x08" "VPCMPGTD\0" "\x08" "PACKUSWB\0" "\x09" "VPACKUSWB\0" "\x09" "PUNPCKHBW\0" \
"\x0a" "VPUNPCKHBW\0" "\x09" "PUNPCKHWD\0" "\x0a" "VPUNPCKHWD\0" "\x09" "PUNPCKHDQ\0" \
"\x0a" "VPUNPCKHDQ\0" "\x08" "PACKSSDW\0" "\x09" "VPACKSSDW\0" "\x0a" "PUNPCKLQDQ\0" \
"\x0b" "VPUNPCKLQDQ\0" "\x0a" "PUNPCKHQDQ\0" "\x0b" "VPUNPCKHQDQ\0" "\x04" "MOVD\0" \
"\x04" "MOVQ\0" "\x05" "VMOVD\0" "\x05" "VMOVQ\0" "\x06" "MOVDQA\0" \
"\x06" "MOVDQU\0" "\x07" "VMOVDQA\0" "\x07" "VMOVDQU\0" "\x06" "PSHUFW\0" \
"\x06" "PSHUFD\0" "\x07" "PSHUFHW\0" "\x07" "PSHUFLW\0" "\x07" "VPSHUFD\0" \
"\x08" "VPSHUFHW\0" "\x08" "VPSHUFLW\0" "\x07" "PCMPEQB\0" "\x08" "VPCMPEQB\0" \
"\x07" "PCMPEQW\0" "\x08" "VPCMPEQW\0" "\x07" "PCMPEQD\0" "\x08" "VPCMPEQD\0" \
"\x04" "EMMS\0" "\x0a" "VZEROUPPER\0" "\x08" "VZEROALL\0" "\x06" "VMREAD\0" \
"\x05" "EXTRQ\0" "\x07" "INSERTQ\0" "\x07" "VMWRITE\0" "\x08" "CVTPH2PS\0" \
"\x08" "CVTPS2PH\0" "\x06" "HADDPD\0" "\x06" "HADDPS\0" "\x07" "VHADDPD\0" \
"\x07" "VHADDPS\0" "\x06" "HSUBPD\0" "\x06" "HSUBPS\0" "\x07" "VHSUBPD\0" \
"\x07" "VHSUBPS\0" "\x05" "XSAVE\0" "\x07" "XSAVE64\0" "\x06" "LFENCE\0" \
"\x06" "XRSTOR\0" "\x08" "XRSTOR64\0" "\x06" "MFENCE\0" "\x08" "XSAVEOPT\0" \
"\x0a" "XSAVEOPT64\0" "\x06" "SFENCE\0" "\x07" "CLFLUSH\0" "\x06" "POPCNT\0" \
"\x03" "BSF\0" "\x05" "TZCNT\0" "\x03" "BSR\0" "\x05" "LZCNT\0" "\x07" "CMPEQPS\0" \
"\x07" "CMPLTPS\0" "\x07" "CMPLEPS\0" "\x0a" "CMPUNORDPS\0" "\x08" "CMPNEQPS\0" \
"\x08" "CMPNLTPS\0" "\x08" "CMPNLEPS\0" "\x08" "CMPORDPS\0" "\x07" "CMPEQPD\0" \
"\x07" "CMPLTPD\0" "\x07" "CMPLEPD\0" "\x0a" "CMPUNORDPD\0" "\x08" "CMPNEQPD\0" \
"\x08" "CMPNLTPD\0" "\x08" "CMPNLEPD\0" "\x08" "CMPORDPD\0" "\x07" "CMPEQSS\0" \
"\x07" "CMPLTSS\0" "\x07" "CMPLESS\0" "\x0a" "CMPUNORDSS\0" "\x08" "CMPNEQSS\0" \
"\x08" "CMPNLTSS\0" "\x08" "CMPNLESS\0" "\x08" "CMPORDSS\0" "\x07" "CMPEQSD\0" \
"\x07" "CMPLTSD\0" "\x07" "CMPLESD\0" "\x0a" "CMPUNORDSD\0" "\x08" "CMPNEQSD\0" \
"\x08" "CMPNLTSD\0" "\x08" "CMPNLESD\0" "\x08" "CMPORDSD\0" "\x08" "VCMPEQPS\0" \
"\x08" "VCMPLTPS\0" "\x08" "VCMPLEPS\0" "\x0b" "VCMPUNORDPS\0" "\x09" "VCMPNEQPS\0" \
"\x09" "VCMPNLTPS\0" "\x09" "VCMPNLEPS\0" "\x09" "VCMPORDPS\0" "\x0b" "VCMPEQ_UQPS\0" \
"\x09" "VCMPNGEPS\0" "\x09" "VCMPNGTPS\0" "\x0b" "VCMPFALSEPS\0" "\x0c" "VCMPNEQ_OQPS\0" \
"\x08" "VCMPGEPS\0" "\x08" "VCMPGTPS\0" "\x0a" "VCMPTRUEPS\0" "\x0b" "VCMPEQ_OSPS\0" \
"\x0b" "VCMPLT_OQPS\0" "\x0b" "VCMPLE_OQPS\0" "\x0d" "VCMPUNORD_SPS\0" \
"\x0c" "VCMPNEQ_USPS\0" "\x0c" "VCMPNLT_UQPS\0" "\x0c" "VCMPNLE_UQPS\0" \
"\x0b" "VCMPORD_SPS\0" "\x0b" "VCMPEQ_USPS\0" "\x0c" "VCMPNGE_UQPS\0" \
"\x0c" "VCMPNGT_UQPS\0" "\x0e" "VCMPFALSE_OSPS\0" "\x0c" "VCMPNEQ_OSPS\0" \
"\x0b" "VCMPGE_OQPS\0" "\x0b" "VCMPGT_OQPS\0" "\x0d" "VCMPTRUE_USPS\0" \
"\x08" "VCMPEQPD\0" "\x08" "VCMPLTPD\0" "\x08" "VCMPLEPD\0" "\x0b" "VCMPUNORDPD\0" \
"\x09" "VCMPNEQPD\0" "\x09" "VCMPNLTPD\0" "\x09" "VCMPNLEPD\0" "\x09" "VCMPORDPD\0" \
"\x0b" "VCMPEQ_UQPD\0" "\x09" "VCMPNGEPD\0" "\x09" "VCMPNGTPD\0" "\x0b" "VCMPFALSEPD\0" \
"\x0c" "VCMPNEQ_OQPD\0" "\x08" "VCMPGEPD\0" "\x08" "VCMPGTPD\0" "\x0a" "VCMPTRUEPD\0" \
"\x0b" "VCMPEQ_OSPD\0" "\x0b" "VCMPLT_OQPD\0" "\x0b" "VCMPLE_OQPD\0" \
"\x0d" "VCMPUNORD_SPD\0" "\x0c" "VCMPNEQ_USPD\0" "\x0c" "VCMPNLT_UQPD\0" \
"\x0c" "VCMPNLE_UQPD\0" "\x0b" "VCMPORD_SPD\0" "\x0b" "VCMPEQ_USPD\0" \
"\x0c" "VCMPNGE_UQPD\0" "\x0c" "VCMPNGT_UQPD\0" "\x0e" "VCMPFALSE_OSPD\0" \
"\x0c" "VCMPNEQ_OSPD\0" "\x0b" "VCMPGE_OQPD\0" "\x0b" "VCMPGT_OQPD\0" \
"\x0d" "VCMPTRUE_USPD\0" "\x08" "VCMPEQSS\0" "\x08" "VCMPLTSS\0" "\x08" "VCMPLESS\0" \
"\x0b" "VCMPUNORDSS\0" "\x09" "VCMPNEQSS\0" "\x09" "VCMPNLTSS\0" "\x09" "VCMPNLESS\0" \
"\x09" "VCMPORDSS\0" "\x0b" "VCMPEQ_UQSS\0" "\x09" "VCMPNGESS\0" "\x09" "VCMPNGTSS\0" \
"\x0b" "VCMPFALSESS\0" "\x0c" "VCMPNEQ_OQSS\0" "\x08" "VCMPGESS\0" "\x08" "VCMPGTSS\0" \
"\x0a" "VCMPTRUESS\0" "\x0b" "VCMPEQ_OSSS\0" "\x0b" "VCMPLT_OQSS\0" "\x0b" "VCMPLE_OQSS\0" \
"\x0d" "VCMPUNORD_SSS\0" "\x0c" "VCMPNEQ_USSS\0" "\x0c" "VCMPNLT_UQSS\0" \
"\x0c" "VCMPNLE_UQSS\0" "\x0b" "VCMPORD_SSS\0" "\x0b" "VCMPEQ_USSS\0" \
"\x0c" "VCMPNGE_UQSS\0" "\x0c" "VCMPNGT_UQSS\0" "\x0e" "VCMPFALSE_OSSS\0" \
"\x0c" "VCMPNEQ_OSSS\0" "\x0b" "VCMPGE_OQSS\0" "\x0b" "VCMPGT_OQSS\0" \
"\x0d" "VCMPTRUE_USSS\0" "\x08" "VCMPEQSD\0" "\x08" "VCMPLTSD\0" "\x08" "VCMPLESD\0" \
"\x0b" "VCMPUNORDSD\0" "\x09" "VCMPNEQSD\0" "\x09" "VCMPNLTSD\0" "\x09" "VCMPNLESD\0" \
"\x09" "VCMPORDSD\0" "\x0b" "VCMPEQ_UQSD\0" "\x09" "VCMPNGESD\0" "\x09" "VCMPNGTSD\0" \
"\x0b" "VCMPFALSESD\0" "\x0c" "VCMPNEQ_OQSD\0" "\x08" "VCMPGESD\0" "\x08" "VCMPGTSD\0" \
"\x0a" "VCMPTRUESD\0" "\x0b" "VCMPEQ_OSSD\0" "\x0b" "VCMPLT_OQSD\0" "\x0b" "VCMPLE_OQSD\0" \
"\x0d" "VCMPUNORD_SSD\0" "\x0c" "VCMPNEQ_USSD\0" "\x0c" "VCMPNLT_UQSD\0" \
"\x0c" "VCMPNLE_UQSD\0" "\x0b" "VCMPORD_SSD\0" "\x0b" "VCMPEQ_USSD\0" \
"\x0c" "VCMPNGE_UQSD\0" "\x0c" "VCMPNGT_UQSD\0" "\x0e" "VCMPFALSE_OSSD\0" \
"\x0c" "VCMPNEQ_OSSD\0" "\x0b" "VCMPGE_OQSD\0" "\x0b" "VCMPGT_OQSD\0" \
"\x0d" "VCMPTRUE_USSD\0" "\x06" "PINSRW\0" "\x07" "VPINSRW\0" "\x06" "PEXTRW\0" \
"\x07" "VPEXTRW\0" "\x06" "SHUFPS\0" "\x06" "SHUFPD\0" "\x07" "VSHUFPS\0" \
"\x07" "VSHUFPD\0" "\x09" "CMPXCHG8B\0" "\x0a" "CMPXCHG16B\0" "\x07" "VMPTRST\0" \
"\x08" "ADDSUBPD\0" "\x08" "ADDSUBPS\0" "\x09" "VADDSUBPD\0" "\x09" "VADDSUBPS\0" \
"\x05" "PSRLW\0" "\x06" "VPSRLW\0" "\x05" "PSRLD\0" "\x06" "VPSRLD\0" \
"\x05" "PSRLQ\0" "\x06" "VPSRLQ\0" "\x05" "PADDQ\0" "\x06" "VPADDQ\0" \
"\x06" "PMULLW\0" "\x07" "VPMULLW\0" "\x07" "MOVQ2DQ\0" "\x07" "MOVDQ2Q\0" \
"\x08" "PMOVMSKB\0" "\x09" "VPMOVMSKB\0" "\x07" "PSUBUSB\0" "\x08" "VPSUBUSB\0" \
"\x07" "PSUBUSW\0" "\x08" "VPSUBUSW\0" "\x06" "PMINUB\0" "\x07" "VPMINUB\0" \
"\x04" "PAND\0" "\x05" "VPAND\0" "\x07" "PADDUSB\0" "\x08" "VPADDUSW\0" \
"\x07" "PADDUSW\0" "\x06" "PMAXUB\0" "\x07" "VPMAXUB\0" "\x05" "PANDN\0" \
"\x06" "VPANDN\0" "\x05" "PAVGB\0" "\x06" "VPAVGB\0" "\x05" "PSRAW\0" \
"\x06" "VPSRAW\0" "\x05" "PSRAD\0" "\x06" "VPSRAD\0" "\x05" "PAVGW\0" \
"\x06" "VPAVGW\0" "\x07" "PMULHUW\0" "\x08" "VPMULHUW\0" "\x06" "PMULHW\0" \
"\x07" "VPMULHW\0" "\x09" "CVTTPD2DQ\0" "\x08" "CVTDQ2PD\0" "\x08" "CVTPD2DQ\0" \
"\x0a" "VCVTTPD2DQ\0" "\x09" "VCVTDQ2PD\0" "\x09" "VCVTPD2DQ\0" "\x06" "MOVNTQ\0" \
"\x07" "MOVNTDQ\0" "\x08" "VMOVNTDQ\0" "\x06" "PSUBSB\0" "\x07" "VPSUBSB\0" \
"\x06" "PSUBSW\0" "\x07" "VPSUBSW\0" "\x06" "PMINSW\0" "\x07" "VPMINSW\0" \
"\x03" "POR\0" "\x04" "VPOR\0" "\x06" "PADDSB\0" "\x07" "VPADDSB\0" \
"\x06" "PADDSW\0" "\x07" "VPADDSW\0" "\x06" "PMAXSW\0" "\x07" "VPMAXSW\0" \
"\x04" "PXOR\0" "\x05" "VPXOR\0" "\x05" "LDDQU\0" "\x06" "VLDDQU\0" \
"\x05" "PSLLW\0" "\x06" "VPSLLW\0" "\x05" "PSLLD\0" "\x06" "VPSLLD\0" \
"\x05" "PSLLQ\0" "\x06" "VPSLLQ\0" "\x07" "PMULUDQ\0" "\x08" "VPMULUDQ\0" \
"\x07" "PMADDWD\0" "\x08" "VPMADDWD\0" "\x06" "PSADBW\0" "\x07" "VPSADBW\0" \
"\x08" "MASKMOVQ\0" "\x0a" "MASKMOVDQU\0" "\x0b" "VMASKMOVDQU\0" "\x05" "PSUBB\0" \
"\x06" "VPSUBB\0" "\x05" "PSUBW\0" "\x06" "VPSUBW\0" "\x05" "PSUBD\0" \
"\x06" "VPSUBD\0" "\x05" "PSUBQ\0" "\x06" "VPSUBQ\0" "\x05" "PADDB\0" \
"\x06" "VPADDB\0" "\x05" "PADDW\0" "\x06" "VPADDW\0" "\x05" "PADDD\0" \
"\x06" "VPADDD\0" "\x07" "FNSTENV\0" "\x06" "FSTENV\0" "\x06" "FNSTCW\0" \
"\x05" "FSTCW\0" "\x06" "FNCLEX\0" "\x05" "FCLEX\0" "\x06" "FNINIT\0" \
"\x05" "FINIT\0" "\x06" "FNSAVE\0" "\x05" "FSAVE\0" "\x06" "FNSTSW\0" \
"\x05" "FSTSW\0" "\x06" "PSHUFB\0" "\x07" "VPSHUFB\0" "\x06" "PHADDW\0" \
"\x07" "VPHADDW\0" "\x06" "PHADDD\0" "\x07" "VPHADDD\0" "\x07" "PHADDSW\0" \
"\x08" "VPHADDSW\0" "\x09" "PMADDUBSW\0" "\x0a" "VPMADDUBSW\0" "\x06" "PHSUBW\0" \
"\x07" "VPHSUBW\0" "\x06" "PHSUBD\0" "\x07" "VPHSUBD\0" "\x07" "PHSUBSW\0" \
"\x08" "VPHSUBSW\0" "\x06" "PSIGNB\0" "\x07" "VPSIGNB\0" "\x06" "PSIGNW\0" \
"\x07" "VPSIGNW\0" "\x06" "PSIGND\0" "\x07" "VPSIGND\0" "\x08" "PMULHRSW\0" \
"\x09" "VPMULHRSW\0" "\x09" "VPERMILPS\0" "\x09" "VPERMILPD\0" "\x07" "VTESTPS\0" \
"\x07" "VTESTPD\0" "\x08" "PBLENDVB\0" "\x08" "BLENDVPS\0" "\x08" "BLENDVPD\0" \
"\x05" "PTEST\0" "\x06" "VPTEST\0" "\x0c" "VBROADCASTSS\0" "\x0c" "VBROADCASTSD\0" \
"\x0e" "VBROADCASTF128\0" "\x05" "PABSB\0" "\x06" "VPABSB\0" "\x05" "PABSW\0" \
"\x06" "VPABSW\0" "\x05" "PABSD\0" "\x06" "VPABSD\0" "\x08" "PMOVSXBW\0" \
"\x09" "VPMOVSXBW\0" "\x08" "PMOVSXBD\0" "\x09" "VPMOVSXBD\0" "\x08" "PMOVSXBQ\0" \
"\x09" "VPMOVSXBQ\0" "\x08" "PMOVSXWD\0" "\x09" "VPMOVSXWD\0" "\x08" "PMOVSXWQ\0" \
"\x09" "VPMOVSXWQ\0" "\x08" "PMOVSXDQ\0" "\x09" "VPMOVSXDQ\0" "\x06" "PMULDQ\0" \
"\x07" "VPMULDQ\0" "\x07" "PCMPEQQ\0" "\x08" "VPCMPEQQ\0" "\x08" "MOVNTDQA\0" \
"\x09" "VMOVNTDQA\0" "\x08" "PACKUSDW\0" "\x09" "VPACKUSDW\0" "\x0a" "VMASKMOVPS\0" \
"\x0a" "VMASKMOVPD\0" "\x08" "PMOVZXBW\0" "\x09" "VPMOVZXBW\0" "\x08" "PMOVZXBD\0" \
"\x09" "VPMOVZXBD\0" "\x08" "PMOVZXBQ\0" "\x09" "VPMOVZXBQ\0" "\x08" "PMOVZXWD\0" \
"\x09" "VPMOVZXWD\0" "\x08" "PMOVZXWQ\0" "\x09" "VPMOVZXWQ\0" "\x08" "PMOVZXDQ\0" \
"\x09" "VPMOVZXDQ\0" "\x07" "PCMPGTQ\0" "\x08" "VPCMPGTQ\0" "\x06" "PMINSB\0" \
"\x07" "VPMINSB\0" "\x06" "PMINSD\0" "\x07" "VPMINSD\0" "\x06" "PMINUW\0" \
"\x07" "VPMINUW\0" "\x06" "PMINUD\0" "\x07" "VPMINUD\0" "\x06" "PMAXSB\0" \
"\x07" "VPMAXSB\0" "\x06" "PMAXSD\0" "\x07" "VPMAXSD\0" "\x06" "PMAXUW\0" \
"\x07" "VPMAXUW\0" "\x06" "PMAXUD\0" "\x07" "VPMAXUD\0" "\x06" "PMULLD\0" \
"\x07" "VPMULLD\0" "\x0a" "PHMINPOSUW\0" "\x0b" "VPHMINPOSUW\0" "\x06" "INVEPT\0" \
"\x07" "INVVPID\0" "\x07" "INVPCID\0" "\x0e" "VFMADDSUB132PS\0" "\x0e" "VFMADDSUB132PD\0" \
"\x0e" "VFMSUBADD132PS\0" "\x0e" "VFMSUBADD132PD\0" "\x0b" "VFMADD132PS\0" \
"\x0b" "VFMADD132PD\0" "\x0b" "VFMADD132SS\0" "\x0b" "VFMADD132SD\0" \
"\x0b" "VFMSUB132PS\0" "\x0b" "VFMSUB132PD\0" "\x0b" "VFMSUB132SS\0" \
"\x0b" "VFMSUB132SD\0" "\x0c" "VFNMADD132PS\0" "\x0c" "VFNMADD132PD\0" \
"\x0c" "VFNMADD132SS\0" "\x0c" "VFNMADD132SD\0" "\x0c" "VFNMSUB132PS\0" \
"\x0c" "VFNMSUB132PD\0" "\x0c" "VFNMSUB132SS\0" "\x0c" "VFNMSUB132SD\0" \
"\x0e" "VFMADDSUB213PS\0" "\x0e" "VFMADDSUB213PD\0" "\x0e" "VFMSUBADD213PS\0" \
"\x0e" "VFMSUBADD213PD\0" "\x0b" "VFMADD213PS\0" "\x0b" "VFMADD213PD\0" \
"\x0b" "VFMADD213SS\0" "\x0b" "VFMADD213SD\0" "\x0b" "VFMSUB213PS\0" \
"\x0b" "VFMSUB213PD\0" "\x0b" "VFMSUB213SS\0" "\x0b" "VFMSUB213SD\0" \
"\x0c" "VFNMADD213PS\0" "\x0c" "VFNMADD213PD\0" "\x0c" "VFNMADD213SS\0" \
"\x0c" "VFNMADD213SD\0" "\x0c" "VFNMSUB213PS\0" "\x0c" "VFNMSUB213PD\0" \
"\x0c" "VFNMSUB213SS\0" "\x0c" "VFNMSUB213SD\0" "\x0e" "VFMADDSUB231PS\0" \
"\x0e" "VFMADDSUB231PD\0" "\x0e" "VFMSUBADD231PS\0" "\x0e" "VFMSUBADD231PD\0" \
"\x0b" "VFMADD231PS\0" "\x0b" "VFMADD231PD\0" "\x0b" "VFMADD231SS\0" \
"\x0b" "VFMADD231SD\0" "\x0b" "VFMSUB231PS\0" "\x0b" "VFMSUB231PD\0" \
"\x0b" "VFMSUB231SS\0" "\x0b" "VFMSUB231SD\0" "\x0c" "VFNMADD231PS\0" \
"\x0c" "VFNMADD231PD\0" "\x0c" "VFNMADD231SS\0" "\x0c" "VFNMADD231SD\0" \
"\x0c" "VFNMSUB231PS\0" "\x0c" "VFNMSUB231PD\0" "\x0c" "VFNMSUB231SS\0" \
"\x0c" "VFNMSUB231SD\0" "\x06" "AESIMC\0" "\x07" "VAESIMC\0" "\x06" "AESENC\0" \
"\x07" "VAESENC\0" "\x0a" "AESENCLAST\0" "\x0b" "VAESENCLAST\0" "\x06" "AESDEC\0" \
"\x07" "VAESDEC\0" "\x0a" "AESDECLAST\0" "\x0b" "VAESDECLAST\0" "\x05" "MOVBE\0" \
"\x05" "CRC32\0" "\x0a" "VPERM2F128\0" "\x07" "ROUNDPS\0" "\x08" "VROUNDPS\0" \
"\x07" "ROUNDPD\0" "\x08" "VROUNDPD\0" "\x07" "ROUNDSS\0" "\x08" "VROUNDSS\0" \
"\x07" "ROUNDSD\0" "\x08" "VROUNDSD\0" "\x07" "BLENDPS\0" "\x08" "VBLENDPS\0" \
"\x07" "BLENDPD\0" "\x08" "VBLENDPD\0" "\x07" "PBLENDW\0" "\x08" "VPBLENDW\0" \
"\x07" "PALIGNR\0" "\x08" "VPALIGNR\0" "\x06" "PEXTRB\0" "\x07" "VPEXTRB\0" \
"\x06" "PEXTRD\0" "\x06" "PEXTRQ\0" "\x07" "VPEXTRD\0" "\x07" "VPEXTRQ\0" \
"\x09" "EXTRACTPS\0" "\x0a" "VEXTRACTPS\0" "\x0b" "VINSERTF128\0" "\x0c" "VEXTRACTF128\0" \
"\x06" "PINSRB\0" "\x07" "VPINSRB\0" "\x08" "INSERTPS\0" "\x09" "VINSERTPS\0" \
"\x06" "PINSRD\0" "\x06" "PINSRQ\0" "\x07" "VPINSRD\0" "\x07" "VPINSRQ\0" \
"\x04" "DPPS\0" "\x05" "VDPPS\0" "\x04" "DPPD\0" "\x05" "VDPPD\0" "\x07" "MPSADBW\0" \
"\x08" "VMPSADBW\0" "\x09" "PCLMULQDQ\0" "\x0a" "VPCLMULQDQ\0" "\x09" "VBLENDVPS\0" \
"\x09" "VBLENDVPD\0" "\x09" "VPBLENDVB\0" "\x09" "PCMPESTRM\0" "\x0a" "VPCMPESTRM\0" \
"\x09" "PCMPESTRI\0" "\x0a" "VPCMPESTRI\0" "\x09" "PCMPISTRM\0" "\x0a" "VPCMPISTRM\0" \
"\x09" "PCMPISTRI\0" "\x0a" "VPCMPISTRI\0" "\x0f" "AESKEYGENASSIST\0" \
"\x10" "VAESKEYGENASSIST\0" "\x06" "PSRLDQ\0" "\x07" "VPSRLDQ\0" "\x06" "PSLLDQ\0" \
"\x07" "VPSLLDQ\0" "\x06" "FXSAVE\0" "\x08" "FXSAVE64\0" "\x08" "RDFSBASE\0" \
"\x07" "FXRSTOR\0" "\x09" "FXRSTOR64\0" "\x08" "RDGSBASE\0" "\x07" "LDMXCSR\0" \
"\x08" "WRFSBASE\0" "\x08" "VLDMXCSR\0" "\x07" "STMXCSR\0" "\x08" "WRGSBASE\0" \
"\x08" "VSTMXCSR\0" "\x07" "VMPTRLD\0" "\x07" "VMCLEAR\0" "\x05" "VMXON\0" \
"\x06" "MOVSXD\0" "\x05" "PAUSE\0" "\x04" "WAIT\0" "\x06" "RDRAND\0" \
"\x06" "_3DNOW\0" \
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"; /* Sentinel mnemonic. */

const _WRegister _REGISTERS[] = {
	{3, "RAX"}, {3, "RCX"}, {3, "RDX"}, {3, "RBX"}, {3, "RSP"}, {3, "RBP"}, {3, "RSI"}, {3, "RDI"}, {2, "R8"}, {2, "R9"}, {3, "R10"}, {3, "R11"}, {3, "R12"}, {3, "R13"}, {3, "R14"}, {3, "R15"},
	{3, "EAX"}, {3, "ECX"}, {3, "EDX"}, {3, "EBX"}, {3, "ESP"}, {3, "EBP"}, {3, "ESI"}, {3, "EDI"}, {3, "R8D"}, {3, "R9D"}, {4, "R10D"}, {4, "R11D"}, {4, "R12D"}, {4, "R13D"}, {4, "R14D"}, {4, "R15D"},
	{2, "AX"}, {2, "CX"}, {2, "DX"}, {2, "BX"}, {2, "SP"}, {2, "BP"}, {2, "SI"}, {2, "DI"}, {3, "R8W"}, {3, "R9W"}, {4, "R10W"}, {4, "R11W"}, {4, "R12W"}, {4, "R13W"}, {4, "R14W"}, {4, "R15W"},
	{2, "AL"}, {2, "CL"}, {2, "DL"}, {2, "BL"}, {2, "AH"}, {2, "CH"}, {2, "DH"}, {2, "BH"}, {3, "R8B"}, {3, "R9B"}, {4, "R10B"}, {4, "R11B"}, {4, "R12B"}, {4, "R13B"}, {4, "R14B"}, {4, "R15B"},
	{3, "SPL"}, {3, "BPL"}, {3, "SIL"}, {3, "DIL"},
	{2, "ES"}, {2, "CS"}, {2, "SS"}, {2, "DS"}, {2, "FS"}, {2, "GS"},
	{3, "RIP"},
	{3, "ST0"}, {3, "ST1"}, {3, "ST2"}, {3, "ST3"}, {3, "ST4"}, {3, "ST5"}, {3, "ST6"}, {3, "ST7"},
	{3, "MM0"}, {3, "MM1"}, {3, "MM2"}, {3, "MM3"}, {3, "MM4"}, {3, "MM5"}, {3, "MM6"}, {3, "MM7"},
	{4, "XMM0"}, {4, "XMM1"}, {4, "XMM2"}, {4, "XMM3"}, {4, "XMM4"}, {4, "XMM5"}, {4, "XMM6"}, {4, "XMM7"}, {4, "XMM8"}, {4, "XMM9"}, {5, "XMM10"}, {5, "XMM11"}, {5, "XMM12"}, {5, "XMM13"}, {5, "XMM14"}, {5, "XMM15"},
	{4, "YMM0"}, {4, "YMM1"}, {4, "YMM2"}, {4, "YMM3"}, {4, "YMM4"}, {4, "YMM5"}, {4, "YMM6"}, {4, "YMM7"}, {4, "YMM8"}, {4, "YMM9"}, {5, "YMM10"}, {5, "YMM11"}, {5, "YMM12"}, {5, "YMM13"}, {5, "YMM14"}, {5, "YMM15"},
	{3, "CR0"}, {0, ""}, {3, "CR2"}, {3, "CR3"}, {3, "CR4"}, {0, ""}, {0, ""}, {0, ""}, {3, "CR8"},
	{3, "DR0"}, {3, "DR1"}, {3, "DR2"}, {3, "DR3"}, {0, ""}, {0, ""}, {3, "DR6"}, {3, "DR7"},
	{0, ""} /* There must be an empty last reg, see strcat_WSR. */
};

#endif /* DISTORM_LIGHT */

```

`DumpVAC/distorm/src/operands.c`:

```c
/*
operands.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "config.h"
#include "operands.h"
#include "x86defs.h"
#include "insts.h"
#include "../include/mnemonics.h"


/* Maps a register to its register-class mask. */
uint32_t _REGISTERTORCLASS[] = /* Based on _RegisterType enumeration! */
{RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_AX, RM_CX, RM_DX, RM_BX, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_SP, RM_BP, RM_SI, RM_DI,
 RM_SEG, RM_SEG, RM_SEG, RM_SEG, RM_SEG, RM_SEG,
 0,
 RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU,
 RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX,
 RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE,
 RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX,
 RM_CR, 0, RM_CR, RM_CR, RM_CR, 0, 0, 0, RM_CR,
 RM_DR, RM_DR, RM_DR, RM_DR, 0, 0, RM_DR, RM_DR
};

/* A helper function to fix the 8 bits register if REX is used (to support SIL, DIL, etc). */
_INLINE_ unsigned int _FASTCALL_ operands_fix_8bit_rex_base(unsigned int reg)
{
	if ((reg >= 4) && (reg < 8)) return reg + REGS8_REX_BASE - 4;
	return reg + REGS8_BASE;
}

/* A helper function to set operand's type and size. */
_INLINE_ void operands_set_ts(_Operand* op, _OperandType type, uint16_t size)
{
	op->type = type;
	op->size = size;
}

/* A helper function to set operand's type, size and index. */
_INLINE_ void operands_set_tsi(_DInst* di, _Operand* op, _OperandType type, uint16_t size, unsigned int index)
{
	op->type = type;
	op->index = (uint8_t)index;
	op->size = size;
	di->usedRegistersMask |= _REGISTERTORCLASS[index];
}

/* A helper function to read an unsigned integer from the stream safely. */
_INLINE_ int read_stream_safe_uint8(_CodeInfo* ci, void* result)
{
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return FALSE;
	*(uint8_t*)result = *(uint8_t*)ci->code;
	ci->code += 1;
	return TRUE;
}

/* A helper function to read an unsigned integer from the stream safely. */
_INLINE_ int read_stream_safe_uint16(_CodeInfo* ci, void* result)
{
	ci->codeLen -= 2;
	if (ci->codeLen < 0) return FALSE;
	*(uint16_t*)result = RUSHORT(ci->code);
	ci->code += 2;
	return TRUE;
}

/* A helper function to read an unsigned integer from the stream safely. */
_INLINE_ int read_stream_safe_uint32(_CodeInfo* ci, void* result)
{
	ci->codeLen -= 4;
	if (ci->codeLen < 0) return FALSE;
	*(uint32_t*)result = RULONG(ci->code);
	ci->code += 4;
	return TRUE;
}

/* A helper function to read an unsigned integer from the stream safely. */
_INLINE_ int read_stream_safe_uint64(_CodeInfo* ci, void* result)
{
	ci->codeLen -= 8;
	if (ci->codeLen < 0) return FALSE;
	*(uint64_t*)result = RULLONG(ci->code);
	ci->code += 8;
	return TRUE;
}

/* A helper function to read a signed integer from the stream safely. */
_INLINE_ int read_stream_safe_sint8(_CodeInfo* ci, int64_t* result)
{
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return FALSE;
	*result = *(int8_t*)ci->code;
	ci->code += 1;
	return TRUE;
}

/* A helper function to read a signed integer from the stream safely. */
_INLINE_ int read_stream_safe_sint16(_CodeInfo* ci, int64_t* result)
{
	ci->codeLen -= 2;
	if (ci->codeLen < 0) return FALSE;
	*result = RSHORT(ci->code);
	ci->code += 2;
	return TRUE;
}

/* A helper function to read a signed integer from the stream safely. */
_INLINE_ int read_stream_safe_sint32(_CodeInfo* ci, int64_t* result)
{
	ci->codeLen -= 4;
	if (ci->codeLen < 0) return FALSE;
	*result = RLONG(ci->code);
	ci->code += 4;
	return TRUE;
}

/*
 * SIB decoding is the most confusing part when decoding IA-32 instructions.
 * This explanation should clear up some stuff.
 *
 * ! When base == 5, use EBP as the base register !
 * if (rm == 4) {
 *	if mod == 01, decode SIB byte and ALSO read a 8 bits displacement.
 *	if mod == 10, decode SIB byte and ALSO read a 32 bits displacement.
 *	if mod == 11 <-- EXCEPTION, this is a general-purpose register and mustn't lead to SIB decoding!
 *	; So far so good, now the confusing part comes in with mod == 0 and base=5, but no worry.
 *	if (mod == 00) {
 *	 decode SIB byte WITHOUT any displacement.
 *	 EXCEPTION!!! when base == 5, read a 32 bits displacement, but this time DO NOT use (EBP) BASE at all!
 *	}
 *
 *	NOTE: base could specify None (no base register) if base==5 and mod==0, but then you also need DISP32.
 * }
 */
static void operands_extract_sib(_DInst* di,
                                 _PrefixState* ps, _DecodeType effAdrSz,
                                 unsigned int sib, unsigned int mod, _Operand* op)
{
	unsigned char scale, index, base;
	unsigned int vrex = ps->vrex;
	uint8_t* pIndex = NULL;

	/*
	 * SIB bits:
	 * |7---6-5----3-2---0|
	 * |SCALE| INDEX| BASE|
	 * |------------------|
	 */
	index = (sib >> 3) & 7;
	base = sib & 7;

	/*
	 * The following fields: base/index/scale/disp8/32 are ALL optional by specific rules!
	 * The idea here is to keep the indirection as a simple-memory type.
	 * Because the base is optional, and we might be left with only one index.
	 * So even if there's a base but no index, or vice versa, we end up with one index register.
	 */

	/* In 64 bits the REX prefix might affect the index of the SIB byte. */
	if (vrex & PREFIX_EX_X) {
		ps->usedPrefixes |= INST_PRE_REX;
		index += EX_GPR_BASE;
	}

	if (index == 4) { /* No index is used. Use SMEM. */
		op->type = O_SMEM;
		pIndex = &op->index;
	} else {
		op->type = O_MEM;
		pIndex = &di->base;
		/* No base, unless it is updated below. E.G: [EAX*4] has no base reg. */
	}

	if (base != 5) {
		if (vrex & PREFIX_EX_B) ps->usedPrefixes |= INST_PRE_REX;
		*pIndex = effAdrSz == Decode64Bits ? REGS64_BASE : REGS32_BASE;
		*pIndex += (uint8_t)(base + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0));

		if (di->base != R_NONE) di->usedRegistersMask |= _REGISTERTORCLASS[di->base];
	} else if (mod != 0) {
		/*
		 * if base == 5 then you have to decode according to MOD.
		 * mod(00) - disp32.
		 * mod(01) - disp8 + rBP
		 * mod(10) - disp32 + rBP
		 * mod(11) - not possible, it's a general-purpose register.
		 */

		if (vrex & PREFIX_EX_B) ps->usedPrefixes |= INST_PRE_REX;
		if (effAdrSz == Decode64Bits) *pIndex = REGS64_BASE + 5 + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0);
		else *pIndex = REGS32_BASE + 5 + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0);

		if (di->base != R_NONE) di->usedRegistersMask |= _REGISTERTORCLASS[di->base];
	} else if (index == 4) {
		 /* 32bits displacement only. */
		op->type = O_DISP;
		return;
	}

	if (index != 4) { /* In 64 bits decoding mode, if index == R12, it's valid! */
		scale = (sib >> 6) & 3;
		if (effAdrSz == Decode64Bits) op->index = (uint8_t)(REGS64_BASE + index);
		else op->index = (uint8_t)(REGS32_BASE + index);
		di->scale = scale != 0 ? (1 << scale) : 0;
	}
}

/*
 * This seems to be the hardest part in decoding the operands.
 * If you take a look carefully at Table 2-2. 32-Bit Addressing Forms with the ModR/M Byte,
 * you will understand it's easy to decode the operands.

 * First we check the DT, so we can decide according to which Table in the documentation we are supposed to decode.
 * Then we follow the specific table whether it's 16 bits or 32/64 bits.

 * Don't forget that Operand Size AND Address Size prefixes may change the decoding!

 * Some instructions force the use of RM16 or other specific types, so take it into account.
 */
static int operands_extract_modrm(_CodeInfo* ci, _PrefixState* ps, _DInst* di,
                                  _DecodeType effAdrSz, unsigned int mod, unsigned int rm,
                                  _iflags instFlags, _Operand* op)
{
	unsigned char sib = 0, base = 0;

	/* Memory indirection decoding ahead:) */

	ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
	if ((instFlags & INST_PRE_LOCK) && (ps->decodedPrefixes & INST_PRE_LOCK)) {
		ps->usedPrefixes |= INST_PRE_LOCK;
		di->flags |= FLAG_LOCK;
	}

	if (effAdrSz != Decode16Bits) { /* Decode32Bits or Decode64Bits! */
		/* Remember that from a 32/64 bits ModR/M byte a SIB byte could follow! */
		if ((rm == 5) && (mod == 0)) {
			/* 5 is a special case - only 32 bits displacement, or RIP relative. */
			di->dispSize = 32;
			if (!read_stream_safe_sint32(ci, (int64_t*)&di->disp)) return FALSE;

			/* Absolute address: */
			op->type = O_DISP;

			if (ci->dt == Decode64Bits) {
				/* In 64 bits decoding mode depsite of the address size, a RIP-relative address it is. */
				op->type = O_SMEM;
				op->index = R_RIP;
				di->flags |= FLAG_RIP_RELATIVE;
			}

			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);
		}
		else {
			if (rm == 4) {
				/* 4 is a special case - SIB byte + disp8/32 follows! */
				/* Read SIB byte. */
				if (!read_stream_safe_uint8(ci, &sib)) return FALSE;
				operands_extract_sib(di, ps, effAdrSz, sib, mod, op);
			}
			else {
				op->type = O_SMEM;
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}

				if (effAdrSz == Decode64Bits) op->index = (uint8_t)(REGS64_BASE + rm);
				else op->index = (uint8_t)(REGS32_BASE + rm);
			}

			if (mod == 1) {
				di->dispSize = 8;
				if (!read_stream_safe_sint8(ci, (int64_t*)&di->disp)) return FALSE;
			}
			else if ((mod == 2) || ((sib & 7) == 5)) { /* If there is no BASE, read DISP32! */
				di->dispSize = 32;
				if (!read_stream_safe_sint32(ci, (int64_t*)&di->disp)) return FALSE;
			}

			/* Get the base register. */
			base = op->index;
			if (di->base != R_NONE) base = di->base;
			else if (di->scale >= 2) base = 0; /* If it's only an index but got scale, it's still DS. */
			/* Default for EBP/ESP is SS segment. 64 bits mode ignores DS anyway. */
			if ((base == R_EBP) || (base == R_ESP)) prefixes_use_segment(INST_PRE_SS, ps, ci->dt, di);
			else prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);
		}
	}
	else { /* Decode16Bits */
		/* Decoding according to Table 2-1. (16 bits) */
		if ((mod == 0) && (rm == 6)) {
			/* 6 is a special case - only 16 bits displacement. */
			op->type = O_DISP;
			di->dispSize = 16;
			if (!read_stream_safe_sint16(ci, (int64_t*)&di->disp)) return FALSE;
		}
		else {
			/*
			 * Create the O_MEM for 16 bits indirection that requires 2 registers, E.G: [BS+SI].
			 * or create O_SMEM for a single register indirection, E.G: [BP].
			 */
			static uint8_t MODS[] = { R_BX, R_BX, R_BP, R_BP, R_SI, R_DI, R_BP, R_BX };
			static uint8_t MODS2[] = { R_SI, R_DI, R_SI, R_DI };
			if (rm < 4) {
				op->type = O_MEM;
				di->base = MODS[rm];
				di->usedRegistersMask |= _REGISTERTORCLASS[MODS[rm]];
				op->index = MODS2[rm];
			}
			else {
				op->type = O_SMEM;
				op->index = MODS[rm];
			}

			if (mod == 1) { /* 8 bits displacement + indirection */
				di->dispSize = 8;
				if (!read_stream_safe_sint8(ci, (int64_t*)&di->disp)) return FALSE;
			}
			else if (mod == 2) { /* 16 bits displacement + indirection */
				di->dispSize = 16;
				if (!read_stream_safe_sint16(ci, (int64_t*)&di->disp)) return FALSE;
			}
		}

		if ((rm == 2) || (rm == 3) || ((rm == 6) && (mod != 0))) {
			/* BP's default segment is SS, so ignore it. */
			prefixes_use_segment(INST_PRE_SS, ps, ci->dt, di);
		}
		else {
			/* Ignore default DS segment. */
			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);
		}
	}

	return TRUE;
}


/*
 * This function is reponsible to textually format a required operand according to its type.
 * It is vital to understand that there are other operands than what the ModR/M byte specifies.

 * Only by decoding the operands of an instruction which got a LOCK prefix, we could tell whether it may use the LOCK prefix.
 * According to Intel, LOCK prefix must precede some specific instructions AND in their memory destination operand form (which means first operand).
 * LOCK INC EAX, would generate an exception, but LOCK INC [EAX] is alright.
 * Also LOCK ADD BX, [BP] would generate an exception.

 * Return code:
 * TRUE - continue parsing the instruction and its operands, everything went right 'till now.
 * FALSE - not enough bytes, or invalid operands.
 */

int operands_extract(_CodeInfo* ci, _DInst* di, _InstInfo* ii,
                     _iflags instFlags, _OpType type,
                     unsigned int modrm, _PrefixState* ps, _DecodeType effOpSz,
                     _DecodeType effAdrSz, _Operand* op)
{
	int ret = 0;
	unsigned int mod, reg, rm;
	unsigned int size = 0;

	/*
	 * ModRM bits:
	 * |7-6-5--------3-2-0|
	 * |MOD|REG/OPCODE|RM |
	 * |------------------|
	 */
	/* mod = (modrm >> 6) & 3; */ /* Mode(register-indirection, disp8+reg+indirection, disp16+reg+indirection, general-purpose register) */
	/* reg = (modrm >> 3) & 7; */ /* Register(could be part of the opcode itself or general-purpose register) */
	/* rm = modrm & 7; */ /* Specifies which general-purpose register or disp+reg to use. */

	/* -- Memory Indirection Operands (that cannot be a general purpose register) -- */
	if ((type >= OT_MEM) && (type <= OT_LMEM128_256)) {
		/* All of the above types can't use a general-purpose register (a MOD of 3)!. */
		mod = (modrm >> 6) & 3;

		if (mod == 3) {
			if (type == OT_MEM_OPT) {
				/* Since the MEM is optional, only when mod != 3, then return true as if the operand was alright. */
				return TRUE;
			}
			return FALSE;
		}

		switch (type)
		{
			case OT_MEM64_128: /* Used only by CMPXCHG8/16B. */
				if (effOpSz == Decode64Bits) {
					ps->usedPrefixes |= INST_PRE_REX;
					size = 128;
				}
				else size = 64;
			break;
			case OT_MEM32: size = 32; break;
			case OT_MEM32_64:
				/* Used by MOVNTI. Default size is 32bits, 64bits with REX. */
				if (effOpSz == Decode64Bits) {
					ps->usedPrefixes |= INST_PRE_REX;
					size = 64;
				}
				else size = 32;
			break;
			case OT_MEM64: size = 64; break;
			case OT_MEM128: size = 128; break;
			case OT_MEM16_FULL: /* The size indicates about the second item of the pair. */
				switch (effOpSz)
				{
					case Decode16Bits:
						ps->usedPrefixes |= INST_PRE_OP_SIZE;
						size = 16;
					break;
					case Decode32Bits:
						ps->usedPrefixes |= INST_PRE_OP_SIZE;
						size = 32;
					break;
					case Decode64Bits:
						/* Mark usage of REX only if it was required. */
						if ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX)) ps->usedPrefixes |= INST_PRE_REX;
						size = 64;
					break;
				}
			break;
			case OT_MEM16_3264: /* The size indicates about the second item of the pair. */
				if (ci->dt == Decode64Bits) size = 64;
				else size = 32;
			break;
			case OT_FPUM16: size = 16; break;
			case OT_FPUM32: size = 32; break;
			case OT_FPUM64: size = 64; break;
			case OT_FPUM80: size = 80; break;
			case OT_LMEM128_256:
				if (ps->vrex & PREFIX_EX_L) size = 256;
				else size = 128;
			break;
			case OT_MEM_OPT: /* Here we know it's not optional. */
			case OT_MEM: size = 0; /* Size is unknown, but still handled. */ break;
			default: return FALSE;
		}
		rm = modrm & 7;
		ret = operands_extract_modrm(ci, ps, di, effAdrSz, mod, rm, instFlags, op);
		op->size = (uint16_t)size;
		if ((op->type == O_SMEM) || (op->type == O_MEM)) {
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		}
		return ret;
	}

	/* -- Memory Indirection Operands (that can be a register) -- */
	if ((type >= OT_RM8) && (type <= OT_LXMM64_128)) {
		mod = (modrm >> 6) & 3;
		if (mod != 3) {
			switch (type)
			{
				case OT_RM_FULL:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					/* PUSH/JMP/CALL are automatically promoted to 64 bits! */
					if (effOpSz == Decode32Bits) {
						size = 32;
						break;
					}
					else if (effOpSz == Decode64Bits) {
						/* Mark usage of REX only if it was required. */
						if ((instFlags & INST_64BITS) == 0) ps->usedPrefixes |= INST_PRE_REX;
						size = 64;
						break;
					}
					/* FALL THROUGH BECAUSE dt==Decoded16Bits @-<----*/
				case OT_RM16:
					/* If we got here not from OT_RM16, then the prefix was used. */
					if (type != OT_RM16) ps->usedPrefixes |= INST_PRE_OP_SIZE;
					size = 16;
				break;
				case OT_RM32_64:
					/* The default size is 32, which can be 64 with a REX only. */
					if (effOpSz == Decode64Bits) {
						size = 64;
						/* Mark REX prefix as used if non-promoted instruction. */
						if ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX)) {
							ps->usedPrefixes |= INST_PRE_REX;
						}
					}
					else size = 32;
				break;
				case OT_RM16_32:
					/* Ignore REX, it's either 32 or 16 bits RM. */
					if (ps->decodedPrefixes & INST_PRE_OP_SIZE) {
						ps->usedPrefixes |= INST_PRE_OP_SIZE;
						/* Assume: We are in 64bits when we have this operand used. */
						size = 16;
					}
					else size = 32;
				break;
				case OT_WXMM32_64:
				case OT_WRM32_64:
					if (ps->vrex & PREFIX_EX_W) size = 64;
					else size = 32;
				break;
				case OT_YXMM64_256:
					if (ps->vrex & PREFIX_EX_L) size = 256;
					else size = 64;
				break;
				case OT_YXMM128_256:
					if (ps->vrex & PREFIX_EX_L) size = 256;
					else size = 128;
				break;
				case OT_LXMM64_128:
					if (ps->vrex & PREFIX_EX_L) size = 128;
					else size = 64;
				break;
				case OT_RFULL_M16:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					size = 16;
				break;

				case OT_RM8:
				case OT_R32_M8:
				case OT_R32_64_M8:
				case OT_REG32_64_M8:
					size = 8;
				break;

				case OT_XMM16:
				case OT_R32_M16:
				case OT_R32_64_M16:
				case OT_REG32_64_M16:
					size = 16;
				break;

				case OT_RM32:
				case OT_MM32:
				case OT_XMM32:
					size = 32;
				break;

				case OT_MM64:
				case OT_XMM64:
					size = 64;
				break;

				case OT_XMM128: size = 128; break;
				case OT_YMM256: size = 256; break;
				default: return FALSE;
			}
			/* Fill size of memory dereference for operand. */
			rm = modrm & 7;
			ret = operands_extract_modrm(ci, ps, di, effAdrSz, mod, rm, instFlags, op);
			op->size = (uint16_t)size;
			if ((op->type == O_SMEM) || (op->type == O_MEM)) {
				di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
			}
			return ret;
		}
		else {
			/*
			 * General-purpose register is handled the same way in 16/32/64 bits decoding modes.
			 * NOTE!! that we have to override the size of the register, since it was set earlier as Memory and not Register!
			 */
			rm = modrm & 7;
			size = 0;
			switch (type)
			{
			case OT_RFULL_M16:
			case OT_RM_FULL:
				switch (effOpSz)
				{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (ps->vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						rm += EX_GPR_BASE;
					}
					size = 16;
					rm += REGS16_BASE;
					break;
				case Decode32Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (ps->vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						rm += EX_GPR_BASE;
					}
					size = 32;
					rm += REGS32_BASE;
					break;
				case Decode64Bits:
					/* A fix for SMSW RAX which use the REX prefix. */
					if (type == OT_RFULL_M16) ps->usedPrefixes |= INST_PRE_REX;
					/* CALL NEAR/PUSH/POP defaults to 64 bits. --> INST_64BITS, REX isn't required, thus ignored anyways. */
					if (instFlags & INST_PRE_REX) ps->usedPrefixes |= INST_PRE_REX;
					/* Mark usage of REX only if it was required. */
					if ((instFlags & INST_64BITS) == 0) ps->usedPrefixes |= INST_PRE_REX;
					/* Include REX if used for REX.B. */
					if (ps->vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						rm += EX_GPR_BASE;
					}
					size = 64;
					rm += REGS64_BASE;
					break;
				}
				break;
			case OT_R32_64_M8:
				/* FALL THROUGH, decode 32 or 64 bits register. */
			case OT_R32_64_M16:
				/* FALL THROUGH, decode 32 or 64 bits register. */
			case OT_RM32_64: /* Take care specifically in MOVNTI/MOVD/CVT's instructions, making it _REG64 with REX or if they are promoted. */
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				/* Is it a promoted instruction? (only INST_64BITS is set and REX isn't required.) */
				if ((ci->dt == Decode64Bits) && ((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS)) {
					size = 64;
					rm += REGS64_BASE;
					break;
				}
				/* Give a chance to REX.W. Because if it was a promoted instruction we don't care about REX.W anyways. */
				if (ps->vrex & PREFIX_EX_W) {
					ps->usedPrefixes |= INST_PRE_REX;
					size = 64;
					rm += REGS64_BASE;
				}
				else {
					size = 32;
					rm += REGS32_BASE;
				}
				break;
			case OT_RM16_32: /* Used only with MOVZXD instruction to support 16 bits operand. */
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				/* Is it 16 bits operand size? */
				if (ps->decodedPrefixes & INST_PRE_OP_SIZE) {
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					size = 16;
					rm += REGS16_BASE;
				}
				else {
					size = 32;
					rm += REGS32_BASE;
				}
				break;
			case OT_RM16:
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				rm += REGS16_BASE;
				size = 16;
				break;
			case OT_RM8:
				if (ps->prefixExtType == PET_REX) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm = operands_fix_8bit_rex_base(rm + ((ps->vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0));
				}
				else rm += REGS8_BASE;
				size = 8;
				break;
			case OT_MM32:
			case OT_MM64:
				/* MMX doesn't support extended registers. */
				size = 64;
				rm += MMXREGS_BASE;
				break;

			case OT_XMM16:
			case OT_XMM32:
			case OT_XMM64:
			case OT_XMM128:
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				size = 128;
				rm += SSEREGS_BASE;
				break;

			case OT_RM32:
			case OT_R32_M8:
			case OT_R32_M16:
				if (ps->vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				size = 32;
				rm += REGS32_BASE;
				break;

			case OT_YMM256:
				if (ps->vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				rm += AVXREGS_BASE;
				size = 256;
				break;
			case OT_YXMM64_256:
			case OT_YXMM128_256:
				if (ps->vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				if (ps->vrex & PREFIX_EX_L) {
					size = 256;
					rm += AVXREGS_BASE;
				}
				else {
					size = 128;
					rm += SSEREGS_BASE;
				}
				break;
			case OT_WXMM32_64:
			case OT_LXMM64_128:
				if (ps->vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				size = 128;
				rm += SSEREGS_BASE;
				break;

			case OT_WRM32_64:
			case OT_REG32_64_M8:
			case OT_REG32_64_M16:
				if (ps->vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				if (ps->vrex & PREFIX_EX_W) {
					size = 64;
					rm += REGS64_BASE;
				}
				else {
					size = 32;
					rm += REGS32_BASE;
				}
				break;

			default: return FALSE;
			}
			op->size = (uint16_t)size;
			op->index = (uint8_t)rm;
			op->type = O_REG;
			di->usedRegistersMask |= _REGISTERTORCLASS[rm];
			return TRUE;
		}
	}

	/* Simple operand type (ModRM reg). */
	reg = (modrm >> 3) & 7;
	switch (type)
	{
		case OT_IMM8:
			operands_set_ts(op, O_IMM, 8);
			if (!read_stream_safe_uint8(ci, &di->imm.byte)) return FALSE;
		break;
		case OT_IMM_FULL: /* 16, 32 or 64, depends on prefixes. */
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				/* FALL THROUGH */
		case OT_IMM16: /* Force 16 bits imm. */
			operands_set_ts(op, O_IMM, 16);
			if (!read_stream_safe_uint16(ci, &di->imm.word)) return FALSE;
		break;
			/*
			 * Extension: MOV imm64, requires REX.
			 * Make sure it needs the REX.
			 * REX must be present because op size function takes it into consideration.
			 */
			} else if ((effOpSz == Decode64Bits) &&
				        ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX))) {
				ps->usedPrefixes |= INST_PRE_REX;

				operands_set_ts(op, O_IMM, 64);
				if (!read_stream_safe_uint64(ci, &di->imm.qword)) return FALSE;
				break;
			} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/* FALL THROUGH BECAUSE dt==Decoded32Bits @-<----*/
		case OT_IMM32:
			op->type = O_IMM;
			if (ci->dt == Decode64Bits) {
				/*
				 * Imm32 is sign extended to 64 bits!
				 * Originally the op size was 64, but later was changed to reflect real size of imm.
				 */
				op->size = 32;
				/* Use this as an indicator that it should be signed extended. */
				di->flags |= FLAG_IMM_SIGNED;
				if (!read_stream_safe_sint32(ci, &di->imm.sqword)) return FALSE;
			} else {
				op->size = 32;
				if (!read_stream_safe_uint32(ci, &di->imm.dword)) return FALSE;
			}
		break;
		case OT_SEIMM8: /* Sign extended immediate. */
			/*
			 * PUSH SEIMM8 can be prefixed by operand size:
			 * Input stream: 66, 6a, 55
			 * 64bits DT: push small 55
			 * 32bits DT: push small 55
			 * 16bits DT: push large 55
			 * small/large indicates the size of the eSP pointer advancement.
			 * Check the instFlags (ii->flags) if it can be operand-size-prefixed and if the prefix exists.
			 */
			op->type = O_IMM;
			if ((instFlags & INST_PRE_OP_SIZE) && (ps->decodedPrefixes & INST_PRE_OP_SIZE)) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				switch (ci->dt)
				{
					case Decode16Bits: op->size = 32; break;
					case Decode32Bits:
					case Decode64Bits:
						op->size = 16;
					break;
				}
			} else op->size = 8;
			di->flags |= FLAG_IMM_SIGNED;
			if (!read_stream_safe_sint8(ci, &di->imm.sqword)) return FALSE;
		break;
		case OT_IMM16_1:
			operands_set_ts(op, O_IMM1, 16);
			if (!read_stream_safe_uint16(ci, &di->imm.ex.i1)) return FALSE;
		break;
		case OT_IMM8_1:
			operands_set_ts(op, O_IMM1, 8);
			if (!read_stream_safe_uint8(ci, &di->imm.ex.i1)) return FALSE;
		break;
		case OT_IMM8_2:
			operands_set_ts(op, O_IMM2, 8);
			if (!read_stream_safe_uint8(ci, &di->imm.ex.i2)) return FALSE;
		break;
		case OT_REG8:
			operands_set_ts(op, O_REG, 8);
			if (ps->prefixExtType) {
				/*
				 * If REX prefix is valid then we will have to use low bytes.
				 * This is a PASSIVE behavior changer of REX prefix, it affects operands even if its value is 0x40 !
				 */
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg + ((ps->vrex & PREFIX_EX_R) ? EX_GPR_BASE : 0));
			} else op->index = (uint8_t)(REGS8_BASE + reg);
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		break;
		case OT_REG16:
			operands_set_tsi(di, op, O_REG, 16, REGS16_BASE + reg);
		break;
		case OT_REG_FULL:
			switch (effOpSz)
			{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (ps->vrex & PREFIX_EX_R) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					}
					operands_set_tsi(di, op, O_REG, 16, REGS16_BASE + reg);
				break;
				case Decode32Bits:
					if (ps->vrex & PREFIX_EX_R) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
					operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + reg);
				break;
				case Decode64Bits: /* rex must be presented. */
					ps->usedPrefixes |= INST_PRE_REX;
					operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + reg + ((ps->vrex & PREFIX_EX_R) ? EX_GPR_BASE : 0));
				break;
			}
		break;
		case OT_REG32:
			if (ps->vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}
			operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + reg);
		break;
		case OT_REG32_64: /* Handle CVT's, MOVxX and MOVNTI instructions which could be extended to 64 bits registers with REX. */
			if (ps->vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}

			/* Is it a promoted instruction? (only INST_64BITS is set and REX isn't required.) */
			if ((ci->dt == Decode64Bits) && ((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS)) {
				operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + reg);
				break;
			}
			/* Give a chance to REX.W. Because if it was a promoted instruction we don't care about REX.W anyways. */
			if (ps->vrex & PREFIX_EX_W) {
				ps->usedPrefixes |= INST_PRE_REX;
				operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + reg);
			} else operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + reg);
		break;
		case OT_FREG32_64_RM: /* Force decoding mode. Used for MOV CR(n)/DR(n) which defaults to 64 bits operand size in 64 bits. */
			rm = modrm & 7;
			if (ps->vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				rm += EX_GPR_BASE;
			}

			if (ci->dt == Decode64Bits) operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + rm);
			else operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + rm);
		break;
		case OT_MM: /* MMX register */
			operands_set_tsi(di, op, O_REG, 64, MMXREGS_BASE + reg);
		break;
		case OT_MM_RM: /* MMX register, this time from the RM field */
			rm = modrm & 7;
			operands_set_tsi(di, op, O_REG, 64, MMXREGS_BASE + rm);
		break;
		case OT_REGXMM0: /* Implicit XMM0 operand. */
			operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + 0);
			break;
		case OT_XMM: /* SSE register */
			if (ps->vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}
			operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + reg);
		break;
		case OT_XMM_RM: /* SSE register, this time from the RM field */
			rm = modrm & 7;
			if (ps->vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				rm += EX_GPR_BASE;
			}
			operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + rm);
		break;
		case OT_CREG:
			/*
			 * Don't parse if the reg exceeds the bounds of the array.
			 * Most of the CR's are not implemented, so if there's no matching string, the operand is invalid.
			 */
			if (ps->vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			} else if ((ci->dt == Decode32Bits) && (ps->decodedPrefixes & INST_PRE_LOCK)) {
				/*
				 * NOTE: In 32 bits decoding mode,
				 * if the lock prefix is set before MOV CR(n) it will become the 4th bit of the REG field like REX.R in 64 bits.
				 */
				reg += EX_GPR_BASE;
				ps->usedPrefixes |= INST_PRE_LOCK;
			}
			/* Ignore some registers which do not exist. */
			if ((reg >= CREGS_MAX) || (reg == 1) || ((reg >= 5) && (reg <= 7))) return FALSE;

			op->type = O_REG;
			if (ci->dt == Decode64Bits) op->size = 64;
			else op->size = 32;
			op->index = (uint8_t)(CREGS_BASE + reg);
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		break;
		case OT_DREG:
			/*
			 * In 64 bits there are 16 debug registers.
			 * but accessing any of dr8-15 which aren't implemented will cause an #ud.
			 */
			if ((reg == 4) || (reg == 5) || (ps->vrex & PREFIX_EX_R)) return FALSE;

			op->type = O_REG;
			if (ci->dt == Decode64Bits) op->size = 64;
			else op->size = 32;
			op->index = (uint8_t)(DREGS_BASE + reg);
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		break;
		case OT_SREG: /* Works with REG16 only! */
			if ((&di->ops[0] == op) && (reg == 1)) return FALSE; /* Can't MOV CS, <REG>. */
			/*Don't parse if the reg exceeds the bounds of the array. */
			if (reg <= SEG_REGS_MAX - 1) operands_set_tsi(di, op, O_REG, 16, SREGS_BASE + reg);
			else return FALSE;
		break;
		case OT_SEG:
			op->type = O_REG;
			/* Size of reg is always 16, it's up to caller to zero extend it to operand size. */
			op->size = 16;
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/*
			 * Extract the SEG from ii->flags this time!!!
			 * Check whether an operand size prefix is used.
			 */
			switch (instFlags & INST_PRE_SEGOVRD_MASK)
			{
				case INST_PRE_ES: op->index = R_ES; break;
				case INST_PRE_CS: op->index = R_CS; break;
				case INST_PRE_SS: op->index = R_SS; break;
				case INST_PRE_DS: op->index = R_DS; break;
				case INST_PRE_FS: op->index = R_FS; break;
				case INST_PRE_GS: op->index = R_GS; break;
			}
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		break;
		case OT_ACC8:
			operands_set_tsi(di, op, O_REG, 8, R_AL);
		break;
		case OT_ACC16:
			operands_set_tsi(di, op, O_REG, 16, R_AX);
		break;
		case OT_ACC_FULL_NOT64:
			/* No REX.W support for IN/OUT. */
			/* FALL THROUGH */
		case OT_ACC_FULL:
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				operands_set_tsi(di, op, O_REG, 16, R_AX);
			} else if ((effOpSz == Decode32Bits) || (type == OT_ACC_FULL_NOT64)) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				operands_set_tsi(di, op, O_REG, 32, R_EAX);
			} else { /* Decode64Bits */
				/* Only non-promoted instructions need REX in order to decode in 64 bits. */
				/* MEM-OFFSET MOV's are NOT automatically promoted to 64 bits. */
				if (!(instFlags & INST_64BITS)) {
					ps->usedPrefixes |= INST_PRE_REX;
				}
				operands_set_tsi(di, op, O_REG, 64, R_RAX);
			}
		break;
		case OT_PTR16_FULL:
			/* ptr16:full - full is size of operand size to read, therefore Operand Size Prefix affects this. So we need to handle it. */
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				ci->codeLen -= sizeof(int16_t)*2;
				if (ci->codeLen < 0) return FALSE;

				operands_set_ts(op, O_PTR, 16);
				di->imm.ptr.off = RUSHORT(ci->code); /* Read offset first. */
				di->imm.ptr.seg = RUSHORT((ci->code + sizeof(int16_t))); /* And read segment. */

				ci->code += sizeof(int16_t)*2;
			} else { /* Decode32Bits, for Decode64Bits this instruction is invalid. */
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				ci->codeLen -= sizeof(int32_t) + sizeof(int16_t);
				if (ci->codeLen < 0) return FALSE;

				operands_set_ts(op, O_PTR, 32);
				di->imm.ptr.off = RULONG(ci->code); /* Read 32bits offset this time. */
				di->imm.ptr.seg = RUSHORT((ci->code + sizeof(int32_t))); /* And read segment, 16 bits. */
				
				ci->code += sizeof(int32_t) + sizeof(int16_t);
			}
		break;
		case OT_RELCB:
		case OT_RELC_FULL:

			if (type == OT_RELCB) {
				operands_set_ts(op, O_PC, 8);
				if (!read_stream_safe_sint8(ci, &di->imm.sqword)) return FALSE;
			} else { /* OT_RELC_FULL */

				/* Yep, operand size prefix affects relc also.  */
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				if (effOpSz == Decode16Bits) {
					operands_set_ts(op, O_PC, 16);
					if (!read_stream_safe_sint16(ci, &di->imm.sqword)) return FALSE;
				} else { /* Decode32Bits or Decode64Bits = for now they are the same */
					operands_set_ts(op, O_PC, 32);
					if (!read_stream_safe_sint32(ci, &di->imm.sqword)) return FALSE;
				}
			}

			/* Support for hint, see if there's a segment override. */
			if ((ii->opcodeId >= I_JO) && (ii->opcodeId <= I_JG)) {
				if (ps->decodedPrefixes & INST_PRE_CS) {
					ps->usedPrefixes |= INST_PRE_CS;
					di->flags |= FLAG_HINT_NOT_TAKEN;
				} else if (ps->decodedPrefixes & INST_PRE_DS) {
					ps->usedPrefixes |= INST_PRE_DS;
					di->flags |= FLAG_HINT_TAKEN;
				}
			}
		break;
		case OT_MOFFS8:
			op->size = 8;
			/* FALL THROUGH, size won't be changed. */
		case OT_MOFFS_FULL:
			op->type = O_DISP;
			if (op->size == 0) {
				/* Calculate size of operand (same as ACC size). */
				switch (effOpSz)
				{
					case Decode16Bits: op->size = 16; break;
					case Decode32Bits: op->size = 32; break;
					case Decode64Bits: op->size = 64; break;
				}
			}

			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			/*
			 * Just a pointer to a BYTE, WORD, DWORD, QWORD. Works only with ACC8/16/32/64 respectively. 
			 * MOV [0x1234], AL ; MOV AX, [0x1234] ; MOV EAX, [0x1234], note that R/E/AX will be chosen by OT_ACC_FULL.
			 */
			if (effAdrSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

				di->dispSize = 16;
				if (!read_stream_safe_uint16(ci, &di->disp)) return FALSE;
			} else if (effAdrSz == Decode32Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

				di->dispSize = 32;
				if (!read_stream_safe_uint32(ci, &di->disp)) return FALSE;
			} else { /* Decode64Bits */
				di->dispSize = 64;
				if (!read_stream_safe_uint64(ci, &di->disp)) return FALSE;
			}
		break;
		case OT_CONST1:
			operands_set_ts(op, O_IMM, 8);
			di->imm.byte = 1;
		break;
		case OT_REGCL:
			operands_set_tsi(di, op, O_REG, 8, R_CL);
		break;

		case OT_FPU_SI:
			/* Low 3 bits specify the REG, similar to the MODR/M byte reg. */
			operands_set_tsi(di, op, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
		break;
		case OT_FPU_SSI:
			operands_set_tsi(di, op, O_REG, 32, R_ST0);
			operands_set_tsi(di, op + 1, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
			di->opsNo++;
		break;
		case OT_FPU_SIS:
			operands_set_tsi(di, op, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
			operands_set_tsi(di, op + 1, O_REG, 32, R_ST0);
			di->opsNo++;
		break;

		/*
		 * Special treatment for Instructions-Block:
		 * INC/DEC (only 16/32 bits) /PUSH/POP/XCHG instructions, which get their REG from their own binary code.

		 * Notice these instructions are 1 or 2 byte long,
		 * code points after the byte which represents the instruction itself,
		 * thus, even if the instructions are 2 bytes long it will read its last byte which contains the REG info.
		 */
		case OT_IB_RB:
			/* Low 3 bits specify the REG, similar to the MODR/M byte reg. */
			operands_set_ts(op, O_REG, 8);
			reg = *(ci->code-1) & 7;
			if (ps->vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg + EX_GPR_BASE);
			} else if (ps->prefixExtType == PET_REX) {
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg);
			} else op->index = (uint8_t)(REGS8_BASE + reg);

			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		break;
		case OT_IB_R_FULL:
			reg = *(ci->code-1) & 7;
			switch (effOpSz)
			{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (ps->vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					}
					operands_set_tsi(di, op, O_REG, 16, REGS16_BASE + reg);
				break;
				case Decode32Bits:
					if (ps->vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
					operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + reg);
				break;
				case Decode64Bits:
					/*
					 * Automatically promoted instruction can drop REX prefix if not required.
					 * PUSH/POP defaults to 64 bits. --> INST_64BITS
					 * MOV imm64 / BSWAP requires REX.W to be 64 bits --> INST_64BITS | INST_PRE_REX
					 */
					if ((instFlags & INST_64BITS) && ((instFlags & INST_PRE_REX) == 0)) {
						if (ps->vrex & PREFIX_EX_B) {
							ps->usedPrefixes |= INST_PRE_REX;
							reg += EX_GPR_BASE;
						}
					} else {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += (ps->vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0;
					}
					operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + reg);
				break;
			}
		break;

		/*
		 * Special treatment for repeatable instructions.

		 * We want the following output:
		 * If there's only the REP/NZ prefix, we won't output anything (All operands are implicit).
		 * If there's an operand size prefix, we will change the suffix letter of the mnemonic, which specifies the size of operand to the required one.
		 * If there's a segment override prefix, we will output the segment and the used index register (EDI/ESI).
		 * If there's an address size prefix, we will output the (segment if needed and) the used and inverted index register (DI/SI).

		 * Example:
		 * :: Decoding in 16 bits mode! ::
		 * AD ~ LODSW
		 * 66 AD ~ LODSD
		 * F3 AC ~ REP LODSB
		 * F3 66 AD ~ REP LODSD
		 * F3 3E AC ~ REP LODS BYTE DS:[SI]
		 * F3 67 AD ~ REP LODS WORD [ESI]

		 * The basic form of a repeatable instruction has its operands hidden and has a suffix letter
		 * which implies on the size of operation being done.
		 * Therefore, we cannot change the mnemonic here when we encounter another prefix and its not the decoder's responsibility to do so.
		 * That's why the caller is responsible to add the suffix letter if no other prefixes are used.
		 * And all we are doing here is formatting the operand correctly.
		 */
		case OT_REGI_ESI:
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			op->type = O_SMEM;

			/* This might be a 16, 32 or 64 bits instruction, depends on the decoding mode. */
			if (instFlags & INST_16BITS) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;

				if (effOpSz == Decode16Bits) op->size = 16;
				else if ((effOpSz == Decode64Bits) && (instFlags & INST_64BITS)) {
					ps->usedPrefixes |= INST_PRE_REX;
					op->size = 64;
				} else op->size = 32;
			} else op->size = 8;

			/*
			 * Clear segment in case OT_REGI_EDI was parsed earlier,
			 * DS can be overridden and therefore has precedence.
			 */
			di->segment = R_NONE;
			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			if (effAdrSz == Decode16Bits) op->index = R_SI;
			else if (effAdrSz == Decode32Bits) op->index = R_ESI;
			else op->index = R_RSI;
			
			di->usedRegistersMask |= _REGISTERTORCLASS[R_RSI]; /* Maps to RM_SI. */
		break;
		case OT_REGI_EDI:
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			op->type = O_SMEM;

			/* This might be a 16 or 32 bits instruction, depends on the decoding mode. */
			if (instFlags & INST_16BITS) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;

				if (effOpSz == Decode16Bits) op->size = 16;
				else if ((effOpSz == Decode64Bits) && (instFlags & INST_64BITS)) {
					ps->usedPrefixes |= INST_PRE_REX;
					op->size = 64;
				} else op->size = 32;
			} else op->size = 8;

			/* Note: The [rDI] operand can't be prefixed by a segment override, therefore we don't set usedPrefixes. */
			if ((di->segment == R_NONE) && (ci->dt != Decode64Bits)) di->segment = R_ES | SEGMENT_DEFAULT; /* No ES in 64 bits mode. */

			if (effAdrSz == Decode16Bits) op->index = R_DI;
			else if (effAdrSz == Decode32Bits) op->index = R_EDI;
			else op->index = R_RDI;

			di->usedRegistersMask |= _REGISTERTORCLASS[R_RDI]; /* Maps to RM_DI. */
		break;

		/* Used for In/Out instructions varying forms. */
		case OT_REGDX:
			/* Simple single IN/OUT instruction. */
			operands_set_tsi(di, op, O_REG, 16, R_DX);
		break;

			/* Used for INVLPGA instruction. */
		case OT_REGECX:
			operands_set_tsi(di, op, O_REG, 32, R_ECX);
		break;
		case OT_REGI_EBXAL:
			/* XLAT BYTE [rBX + AL] */
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			/* Size of deref is always 8 for xlat. */
			operands_set_tsi(di, op, O_MEM, 8, R_AL);

			if (effAdrSz == Decode16Bits) di->base = R_BX;
			else if (effAdrSz == Decode32Bits) di->base = R_EBX;
			else {
				ps->usedPrefixes |= INST_PRE_REX;
				di->base = R_RBX;
			}

			di->usedRegistersMask |= _REGISTERTORCLASS[di->base];
		break;
		case OT_REGI_EAX:
			/*
			 * Implicit rAX as memory indirection operand. Used by AMD's SVM instructions.
			 * Since this is a memory indirection, the default address size in 64bits decoding mode is 64.
			 */

			if (effAdrSz == Decode64Bits) operands_set_tsi(di, op, O_SMEM, 64, R_RAX);
			else if (effAdrSz == Decode32Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
				operands_set_tsi(di, op, O_SMEM, 32, R_EAX);
			}
			else {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
				operands_set_tsi(di, op, O_SMEM, 16, R_AX);
			}
		break;
		case OT_VXMM:
			operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + ps->vexV);
		break;
		case OT_XMM_IMM:
			ci->codeLen -= sizeof(int8_t);
			if (ci->codeLen < 0) return FALSE;

			if (ci->dt == Decode32Bits) reg = (*ci->code >> 4) & 0x7;
			else reg = (*ci->code >> 4) & 0xf;
			operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + reg);

			ci->code += sizeof(int8_t);
		break;
		case OT_YXMM:
			if (ps->vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(di, op, O_REG, 256, AVXREGS_BASE + reg);
			else operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + reg);
		break;
		case OT_YXMM_IMM:
			ci->codeLen -= sizeof(int8_t);
			if (ci->codeLen < 0) return FALSE;

			if (ci->dt == Decode32Bits) reg = (*ci->code >> 4) & 0x7;
			else reg = (*ci->code >> 4) & 0xf;

			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(di, op, O_REG, 256, AVXREGS_BASE + reg);
			else operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + reg);

			ci->code += sizeof(int8_t);
		break;
		case OT_YMM:
			if (ps->vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			operands_set_tsi(di, op, O_REG, 256, AVXREGS_BASE + reg);
		break;
		case OT_VYMM:
			operands_set_tsi(di, op, O_REG, 256, AVXREGS_BASE + ps->vexV);
		break;
		case OT_VYXMM:
			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(di, op, O_REG, 256, AVXREGS_BASE + ps->vexV);
			else operands_set_tsi(di, op, O_REG, 128, SSEREGS_BASE + ps->vexV);
		break;
		case OT_WREG32_64:
			if (ps->vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			if (ps->vrex & PREFIX_EX_W) operands_set_tsi(di, op, O_REG, 64, REGS64_BASE + reg);
			else operands_set_tsi(di, op, O_REG, 32, REGS32_BASE + reg);
		break;
		default: return FALSE;
	}
	return TRUE;
}

```

`DumpVAC/distorm/src/operands.h`:

```h
/*
operands.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef OPERANDS_H
#define OPERANDS_H

#include "config.h"
#include "decoder.h"
#include "prefix.h"
#include "instructions.h"

int operands_extract(_CodeInfo* ci, _DInst* di, _InstInfo* ii,
                     _iflags instFlags, _OpType type,
                     unsigned int modrm, _PrefixState* ps, _DecodeType effOpSz,
                     _DecodeType effAdrSz, _Operand* op);

#endif /* OPERANDS_H */

```

`DumpVAC/distorm/src/prefix.c`:

```c
/*
prefix.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "prefix.h"

#include "x86defs.h"
#include "instructions.h"
#include "../include/mnemonics.h"


/*
 * The main purpose of this module is to keep track of all kind of prefixes a single instruction may have.
 * The problem is that a single instruction may have up to six different prefix-types.
 * That's why I have to detect such cases and drop those excess prefixes.
 */


int PrefixTables[256 * 2] = {
	/* Decode 16/32 Bits */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, /* ES (0x26) CS (0x2e) */
	0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, /* DS (0x3e) SS (0x36) */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, /* FS(0x64) GS(0x65) OP_SIZE(0x66) ADDR_SIZE(0x67) */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* VEX2b (0xc5) VEX3b (0xc4) */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* LOCK (0xf0) REPNZ (0xf2) REP (0xf3) */
	/* Decode64Bits */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
	0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* REX: 0x40 - 0x4f */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* Ignore all prefix. */
void prefixes_ignore_all(_PrefixState* ps)
{
	int i;
	for (i = 0; i < PFXIDX_MAX; i++)
		prefixes_ignore(ps, i);
}

/* Calculates which prefixes weren't used and accordingly sets the bits in the unusedPrefixesMask. */
uint16_t prefixes_set_unused_mask(_PrefixState* ps)
{
	/*
	 * The decodedPrefixes represents the prefixes that were *read* from the binary stream for the instruction.
	 * The usedPrefixes represents the prefixes that were actually used by the instruction in the *decode* phase.
	 * Xoring between the two will result in a 'diff' which returns the prefixes that were read
	 * from the stream *and* that were never used in the actual decoding.
	 *
	 * Only one prefix per type can be set in decodedPrefixes from the stream.
	 * Therefore it's enough to check each type once and set the flag accordingly.
	 * That's why we had to book-keep each prefix type and its position.
	 * So now we know which bits we need to set exactly in the mask.
	 */
	_iflags unusedPrefixesDiff = ps->decodedPrefixes ^ ps->usedPrefixes;
	uint16_t unusedPrefixesMask = ps->unusedPrefixesMask;

	/* Examine unused prefixes by type: */
	/*
	 * About REX: it might be set in the diff although it was never in the stream itself.
	 * This is because the vrex is shared between VEX and REX and some places flag it as REX usage, while
	 * we were really decoding an AVX instruction.
	 * It's not a big problem, because the prefixes_ignore func will ignore it anyway,
	 * since it wasn't seen earlier. But it's important to know this.
	 */
	if (unusedPrefixesDiff) {
		if (unusedPrefixesDiff & INST_PRE_REX) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_REX];
		if (unusedPrefixesDiff & INST_PRE_SEGOVRD_MASK) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_SEG];
		if (unusedPrefixesDiff & INST_PRE_LOKREP_MASK) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_LOREP];
		if (unusedPrefixesDiff & INST_PRE_OP_SIZE) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_OP_SIZE];
		if (unusedPrefixesDiff & INST_PRE_ADDR_SIZE) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_ADRS];
		/* If a VEX instruction was found, its prefix is considered as used, therefore no point for checking for it. */
	}

	return unusedPrefixesMask;
}

/*
 * Mark a prefix as unused, and bookkeep where we last saw this same type,
 * because in the future we might want to disable it too.
 */
_INLINE_ void prefixes_track_unused(_PrefixState* ps, int index, _PrefixIndexer pi)
{
	/* Mark the previously used prefix (if exists) in the unused mask. */
	prefixes_ignore(ps, pi);
	/* Book-keep the current index for this type. */
	ps->pfxIndexer[pi] = 1 << index;
}

/*
 * Read as many prefixes as possible, up to 15 bytes, and halt when we encounter non-prefix byte.
 * This algorithm tries to imitate a real processor, where the same prefix can appear a few times, etc.
 * The tiny complexity is that we want to know when a prefix was superfluous and mark any copy of it as unused.
 * Note that the last prefix of its type will be considered as used, and all the others (of same type) before it as unused.
 */
void prefixes_decode(_CodeInfo* ci, _PrefixState* ps)
{
	const uint8_t* rexPos = NULL;
	const uint8_t* start = ci->code;
	uint8_t byte, vex;
	unsigned int index;
	/*
	 * First thing to do, scan for prefixes, there are six types of prefixes.
	 * There may be up to six prefixes before a single instruction, not the same type, no special order,
	 * except REX/VEX must precede immediately the first opcode byte.
	 * BTW - This is the reason why I didn't make the REP prefixes part of the instructions (STOS/SCAS/etc).
	 *
	 * Another thing, the instruction maximum size is 15 bytes, thus if we read more than 15 bytes, we will halt.
	 *
	 * We attach all prefixes to the next instruction, there might be two or more occurrences from the same prefix.
	 * Also, since VEX can be allowed only once we will test it separately.
	 */
	for (index = 0;
		(ci->codeLen > 0) && (index < INST_MAXIMUM_SIZE);
		ci->code++, ci->codeLen--, index++) {
		/*
		NOTE: AMD treat lock/rep as two different groups... But I am based on Intel.

			- Lock and Repeat:
				- 0xF0 — LOCK
				- 0xF2 — REPNE/REPNZ
				- 0xF3 - REP/REPE/REPZ
			- Segment Override:
				- 0x2E - CS
				- 0x36 - SS
				- 0x3E - DS
				- 0x26 - ES
				- 0x64 - FS
				- 0x65 - GS
			- Operand-Size Override: 0x66, switching default size.
			- Address-Size Override: 0x67, switching default size.

		64 Bits:
			- REX: 0x40 - 0x4f, extends register access.
			- 2 Bytes VEX: 0xc4
			- 3 Bytes VEX: 0xc5
		32 Bits:
			- 2 Bytes VEX: 0xc4 11xx-xxxx
			- 3 Bytes VEX: 0xc5 11xx-xxxx
		*/

		/* Examine what type of prefix we got. */
		byte = *ci->code;
		switch (byte)
		{
		case PREFIX_OP_SIZE: {/* Op Size type: */
			ps->decodedPrefixes |= INST_PRE_OP_SIZE;
			prefixes_track_unused(ps, index, PFXIDX_OP_SIZE);
		} break;
			/* Look for both common arch prefixes. */
		case PREFIX_LOCK: {
			/* LOCK and REPx type: */
			ps->decodedPrefixes |= INST_PRE_LOCK;
			prefixes_track_unused(ps, index, PFXIDX_LOREP);
		} break;
		case PREFIX_REPNZ: {
			ps->decodedPrefixes |= INST_PRE_REPNZ;
			prefixes_track_unused(ps, index, PFXIDX_LOREP);
		} break;
		case PREFIX_REP: {
			ps->decodedPrefixes |= INST_PRE_REP;
			prefixes_track_unused(ps, index, PFXIDX_LOREP);
		} break;
		case PREFIX_CS: {
			/* Seg Overide type: */
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_CS;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_SS: {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_SS;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_DS: {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_DS;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_ES: {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_ES;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_FS: {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_FS;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_GS: {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
			ps->decodedPrefixes |= INST_PRE_GS;
			prefixes_track_unused(ps, index, PFXIDX_SEG);
		} break;
		case PREFIX_ADDR_SIZE: {
			/* Addr Size type: */
			ps->decodedPrefixes |= INST_PRE_ADDR_SIZE;
			prefixes_track_unused(ps, index, PFXIDX_ADRS);
		} break;
		default:
			if (ci->dt == Decode64Bits) {
				/* REX type, 64 bits decoding mode only: */
				if ((byte & 0xf0) == 0x40) {
					ps->decodedPrefixes |= INST_PRE_REX;
					rexPos = ci->code;
					ps->vrex = byte & 0xf; /* Keep only BXRW. */
					ps->prefixExtType = PET_REX;
					prefixes_track_unused(ps, index, PFXIDX_REX);
					continue;
				}
			}
			goto _Break2;
		}
	}
_Break2:

	/* 2 Bytes VEX: */
	if ((ci->codeLen >= 2) &&
		(*ci->code == PREFIX_VEX2b) &&
		((ci->code - start) <= INST_MAXIMUM_SIZE - 2)) {
		/*
		 * In 32 bits the second byte has to be in the special range of Mod=11.
		 * Otherwise it might be a normal LDS instruction.
		 */
		if ((ci->dt == Decode64Bits) || (*(ci->code + 1) >= INST_DIVIDED_MODRM)) {
			ps->vexPos = ci->code + 1;
			ps->decodedPrefixes |= INST_PRE_VEX;
			ps->prefixExtType = PET_VEX2BYTES;

			/*
			 * VEX 1 byte bits:
			 * |7-6--3-2-10|
			 * |R|vvvv|L|pp|
			 * |-----------|
			 */

			/* -- Convert from VEX prefix to VREX flags -- */
			vex = *ps->vexPos;
			if (!(vex & 0x80) && (ci->dt == Decode64Bits)) ps->vrex |= PREFIX_EX_R; /* Convert VEX.R. */
			if (vex & 4) ps->vrex |= PREFIX_EX_L; /* Convert VEX.L. */

			ci->code += 2;
			ci->codeLen -= 2;
		}
	}

	/* 3 Bytes VEX: */
	if ((ci->codeLen >= 3) &&
		(*ci->code == PREFIX_VEX3b) &&
		((ci->code - start) <= INST_MAXIMUM_SIZE - 3) &&
		(!(ps->decodedPrefixes & INST_PRE_VEX))) {
		/*
		 * In 32 bits the second byte has to be in the special range of Mod=11.
		 * Otherwise it might be a normal LES instruction.
		 * And we don't care now about the 3rd byte.
		 */
		if ((ci->dt == Decode64Bits) || (*(ci->code + 1) >= INST_DIVIDED_MODRM)) {
			ps->vexPos = ci->code + 1;
			ps->decodedPrefixes |= INST_PRE_VEX;
			ps->prefixExtType = PET_VEX3BYTES;

			/*
			 * VEX first and second bytes:
			 * |7-6-5-4----0|  |7-6--3-2-10|
			 * |R|X|B|m-mmmm|  |W|vvvv|L|pp|
			 * |------------|  |-----------|
			 */

			/* -- Convert from VEX prefix to VREX flags -- */
			vex = *ps->vexPos;
			ps->vrex |= ((~vex >> 5) & 0x7); /* Shift and invert VEX.R/X/B to their place */
			vex = *(ps->vexPos + 1);
			if (vex & 4) ps->vrex |= PREFIX_EX_L; /* Convert VEX.L. */
			if (vex & 0x80) ps->vrex |= PREFIX_EX_W; /* Convert VEX.W. */

			/* Clear some flags if the mode isn't 64 bits. */
			if (ci->dt != Decode64Bits) ps->vrex &= ~(PREFIX_EX_B | PREFIX_EX_X | PREFIX_EX_R | PREFIX_EX_W);

			ci->code += 3;
			ci->codeLen -= 3;
		}
	}

	if (ci->dt == Decode64Bits) {
		if (ps->decodedPrefixes & INST_PRE_REX) {
			/* REX prefix must precede first byte of instruction. */
			if (rexPos != (ci->code - 1)) {
				ps->decodedPrefixes &= ~INST_PRE_REX;
				if (ps->prefixExtType == PET_REX) ps->prefixExtType = PET_NONE; /* It might be a VEX by now, keep it that way. */
				prefixes_ignore(ps, PFXIDX_REX);
			}
			/*
			 * We will disable operand size prefix,
			 * if it exists only after decoding the instruction, since it might be a mandatory prefix.
			 * This will be done after calling inst_lookup in decode_inst.
			 */
		}
		/* In 64 bits, segment overrides of CS, DS, ES and SS are ignored. So don't take'em into account. */
		if (ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK32) {
			ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK32;
			prefixes_ignore(ps, PFXIDX_SEG);
		}
	}

	/* Store number of prefixes scanned. */
	ps->count = (uint8_t)(ci->code - start);
}

/*
 * For every memory-indirection operand we want to set a used segment.
 * If the segment is being overrided with a prefix, we will need to check if it's a default.
 * Defaults don't use their prefix, e.g "mov [rsp]" can ignore a given SS: prefix,
 * but still set the used segment as SS.
 * This function is called only with SS and DS as defaults.
 * If there's a segment prefix used, it will override the default one.
 * And If the prefix is a default seg in 64 bits, it will be ignored.
 */
void prefixes_use_segment(_iflags defaultSeg, _PrefixState* ps, _DecodeType dt, _DInst* di)
{
	/* Extract given segment prefix from the decoded prefixes. */
	_iflags flags;

	if (dt == Decode64Bits) {
		if (ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK64) { /* Either GS or FS. */
			di->segment = ps->decodedPrefixes & INST_PRE_GS ? R_GS : R_FS;
		}

		return;
	}

	flags = ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK;

	/* Use the given prefix only if it's not the default. */
	if (flags && (flags != defaultSeg)) {
		ps->usedPrefixes |= flags;

		switch (flags >> 7) /* INST_PRE_CS is 1 << 7. And the rest of the prefixes follow as bit fields. */
		{
			case 1: di->segment = R_CS; break;
			case 2: di->segment = R_SS; break;
			case 4: di->segment = R_DS; break;
			case 8: di->segment = R_ES; break;
			case 0x10: di->segment = R_FS; break;
			case 0x20: di->segment = R_GS; break;
		}
	}
	else {
		if (defaultSeg == INST_PRE_SS) di->segment = SEGMENT_DEFAULT | R_SS;
		else di->segment = SEGMENT_DEFAULT | R_DS;
	}
}

```

`DumpVAC/distorm/src/prefix.h`:

```h
/*
prefix.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef PREFIX_H
#define PREFIX_H

#include "config.h"
#include "decoder.h"


/* Specifies the type of the extension prefix, such as: REX, 2 bytes VEX, 3 bytes VEX. */
typedef enum {PET_NONE = 0, PET_REX, PET_VEX2BYTES, PET_VEX3BYTES} _PrefixExtType;

/* Specifies an index into a table of prefixes by their type. */
typedef enum {PFXIDX_NONE = -1, PFXIDX_REX, PFXIDX_LOREP, PFXIDX_SEG, PFXIDX_OP_SIZE, PFXIDX_ADRS, PFXIDX_MAX} _PrefixIndexer;

/*
* This holds the prefixes state for the current instruction we decode.
* decodedPrefixes includes all specific prefixes that the instruction got.
* start is a pointer to the first prefix to take into account.
* last is a pointer to the last byte we scanned.
* Other pointers are used to keep track of prefixes positions and help us know if they appeared already and where.
*/
typedef struct {
	_iflags decodedPrefixes, usedPrefixes;
	/* Number of prefixes scanned for current instruction, including VEX! */
	unsigned int count;
	uint16_t unusedPrefixesMask;
	/* Holds the offset to the prefix byte by its type. */
	uint16_t pfxIndexer[PFXIDX_MAX];
	_PrefixExtType prefixExtType;
	/* Indicates whether the operand size prefix (0x66) was used as a mandatory prefix. */
	int isOpSizeMandatory;
	/* If VEX prefix is used, store the VEX.vvvv field. */
	unsigned int vexV;
	/* The fields B/X/R/W/L of REX and VEX are stored together in this byte. */
	unsigned int vrex;
	const uint8_t* vexPos;
} _PrefixState;

/*
* Intel supports 6 types of prefixes, whereas AMD supports 5 types (lock is seperated from rep/nz).
* REX is the fifth prefix type, this time I'm based on AMD64.
* VEX is the 6th, though it can't be repeated.
*/
#define MAX_PREFIXES (5)

extern int PrefixTables[256 * 2];

_INLINE_ int prefixes_is_valid(unsigned char ch, _DecodeType dt)
{
	/* The predicate selects (branchlessly) second half table for 64 bits otherwise selects first half. */
	return PrefixTables[ch + ((dt >> 1) << 8)];
}

/* Ignore a specific prefix type. */
_INLINE_ void prefixes_ignore(_PrefixState* ps, _PrefixIndexer pi)
{
	/*
	 * If that type of prefix appeared already, set the bit of that *former* prefix.
	 * Anyway, set the new index of that prefix type to the current index, so next time we know its position.
	 */
	ps->unusedPrefixesMask |= ps->pfxIndexer[pi];
}

void prefixes_ignore_all(_PrefixState* ps);
uint16_t prefixes_set_unused_mask(_PrefixState* ps);
void prefixes_decode(_CodeInfo* ci, _PrefixState* ps);
void prefixes_use_segment(_iflags defaultSeg, _PrefixState* ps, _DecodeType dt, _DInst* di);

#endif /* PREFIX_H */

```

`DumpVAC/distorm/src/textdefs.c`:

```c
/*
textdefs.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "textdefs.h"

#ifndef DISTORM_LIGHT

static uint8_t Nibble2ChrTable[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
#define NIBBLE_TO_CHR Nibble2ChrTable[t]

void str_hex(_WString* s, const uint8_t* buf, unsigned int len)
{
	/* 256 * 2 : 2 chars per byte value. */
	static const char* TextBTable =
		"000102030405060708090a0b0c0d0e0f" \
		"101112131415161718191a1b1c1d1e1f" \
		"202122232425262728292a2b2c2d2e2f" \
		"303132333435363738393a3b3c3d3e3f" \
		"404142434445464748494a4b4c4d4e4f" \
		"505152535455565758595a5b5c5d5e5f" \
		"606162636465666768696a6b6c6d6e6f" \
		"707172737475767778797a7b7c7d7e7f" \
		"808182838485868788898a8b8c8d8e8f" \
		"909192939495969798999a9b9c9d9e9f" \
		"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf" \
		"b0b1b2b3b4b5b6b7b8b9babbbcbdbebf" \
		"c0c1c2c3c4c5c6c7c8c9cacbcccdcecf" \
		"d0d1d2d3d4d5d6d7d8d9dadbdcdddedf" \
		"e0e1e2e3e4e5e6e7e8e9eaebecedeeef" \
		"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";
	
	unsigned int i = 0;
	/* Length is at least 1, enter loop. */
	s->length = len * 2;
	s->p[len * 2] = 0;
	do {
		RSHORT(&s->p[i]) = RSHORT(&TextBTable[(*buf) * 2]);
		buf++;
		i += 2;
	} while (i < len * 2);
}

#ifdef SUPPORT_64BIT_OFFSET

void str_int_impl(unsigned char** s, uint64_t x)
{
	int8_t* buf;
	int shift = 0;
	OFFSET_INTEGER t = x;

	buf = (int8_t*)*s;

	*buf++ = '0';
	*buf++ = 'x';

	if (x == 0) {
		*buf = '0';
		*s += 3;
		return;
	}

	do {
		t >>= 4;
		shift += 4;
	} while (t);

	do {
		shift -= 4;
		t = (x >> shift) & 0xf;
		*buf++ = NIBBLE_TO_CHR;
	} while (shift > 0);

	*s = (unsigned char*)buf;
}

#else

void str_int_impl(unsigned char** s, uint8_t src[8])
{
	int8_t* buf;
	int i = 0, shift = 0;
	uint32_t x = RULONG(&src[sizeof(int32_t)]);
	int t;

	buf = (int8_t*)*s;
	buf[0] = '0';
	buf[1] = 'x';
	buf += 2;

	for (shift = 28; shift != -4; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}

	x = RULONG(src);
	for (shift = 28; shift != 0; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}
	t = x & 0xf;
	buf[i++] = NIBBLE_TO_CHR;

	*s += (size_t)(i + 2);
}

#endif /* SUPPORT_64BIT_OFFSET */

#endif /* DISTORM_LIGHT */

```

`DumpVAC/distorm/src/textdefs.h`:

```h
/*
textdefs.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef TEXTDEFS_H
#define TEXTDEFS_H

#include "config.h"
#include "wstring.h"

#ifndef DISTORM_LIGHT

#define PLUS_DISP_CHR '+'
#define MINUS_DISP_CHR '-'
#define OPEN_CHR '['
#define CLOSE_CHR ']'
#define SP_CHR ' '
#define SEG_OFF_CHR ':'

/*
Naming Convention:

* get - returns a pointer to a string.
* str - concatenates to string.

* hex - means the function is used for hex dump (number is padded to required size) - Little Endian output.
* code - means the function is used for disassembled instruction - Big Endian output.
* off - means the function is used for 64bit offset - Big Endian output.

* h - '0x' in front of the string.

* b - byte
* dw - double word (can be used for word also)
* qw - quad word

* all numbers are in HEX.
*/

void str_hex(_WString* s, const uint8_t* buf, unsigned int len);

#ifdef SUPPORT_64BIT_OFFSET
#define str_int(s, x) str_int_impl((s), (x))
void str_int_impl(unsigned char** s, uint64_t x);
#else
#define str_int(s, x) str_int_impl((s), (uint8_t*)&(x))
void str_int_impl(unsigned char** s, uint8_t src[8]);
#endif

#endif /* DISTORM_LIGHT */

#endif /* TEXTDEFS_H */

```

`DumpVAC/distorm/src/wstring.h`:

```h
/*
wstring.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef WSTRING_H
#define WSTRING_H

#include "config.h"
#include "../include/mnemonics.h"

#ifndef DISTORM_LIGHT

_INLINE_ void strcat_WSR(unsigned char** str, const _WRegister* reg)
{
	/*
	 * Longest register name is YMM15 - 5 characters,
	 * Copy 8 so compiler can do a QWORD move.
	 * We copy nul termination and fix the length, so it's okay to copy more to the output buffer.
	 * There's a sentinel register to make sure we don't read past the end of the registers table.
	 */
	memcpy((int8_t*)*str, (const int8_t*)reg->p, 8);
	*str += reg->length;
}

#define strfinalize_WS(s, end) do { *end = 0; s.length = (unsigned int)((size_t)end - (size_t)s.p); } while (0)
#define chrcat_WS(s, ch) do { *s = ch; s += 1; } while (0)
#define strcat_WS(s, buf, copylen, advancelen) do { memcpy((int8_t*)s, buf, copylen); s += advancelen; } while(0)

#endif /* DISTORM_LIGHT */

#endif /* WSTRING_H */

```

`DumpVAC/distorm/src/x86defs.h`:

```h
/*
x86defs.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef X86DEFS_H
#define X86DEFS_H


#define SEG_REGS_MAX (6)
#define CREGS_MAX (9)
#define DREGS_MAX (8)

/* Maximum instruction size, including prefixes */
#define INST_MAXIMUM_SIZE (15)

/* Maximum range of imm8 (comparison type) of special SSE CMP instructions. */
#define INST_CMP_MAX_RANGE (8)

/* Maximum range of imm8 (comparison type) of special AVX VCMP instructions. */
#define INST_VCMP_MAX_RANGE (32)

/* Wait instruction byte code. */
#define INST_WAIT_INDEX (0x9b)

/* Lea instruction byte code. */
#define INST_LEA_INDEX (0x8d)

/* NOP/XCHG instruction byte code. */
#define INST_NOP_INDEX (0x90)

/* ARPL/MOVSXD instruction byte code. */
#define INST_ARPL_INDEX (0x63)

/*
 * Minimal MODR/M value of divided instructions.
 * It's 0xc0, two MSBs set, which indicates a general purpose register is used too.
 */
#define INST_DIVIDED_MODRM (0xc0)

/* This is the escape byte value used for 3DNow! instructions. */
#define _3DNOW_ESCAPE_BYTE (0x0f)

#define PREFIX_LOCK (0xf0)
#define PREFIX_REPNZ (0xf2)
#define PREFIX_REP (0xf3)
#define PREFIX_CS (0x2e)
#define PREFIX_SS (0x36)
#define PREFIX_DS (0x3e)
#define PREFIX_ES (0x26)
#define PREFIX_FS (0x64)
#define PREFIX_GS (0x65)
#define PREFIX_OP_SIZE (0x66)
#define PREFIX_ADDR_SIZE (0x67)
#define PREFIX_VEX2b (0xc5)
#define PREFIX_VEX3b (0xc4)

/* REX prefix value range, 64 bits mode decoding only. */
#define PREFIX_REX_LOW (0x40)
#define PREFIX_REX_HI (0x4f)
/* In order to use the extended GPR's we have to add 8 to the Modr/M info values. */
#define EX_GPR_BASE (8)

/* Mask for REX and VEX features: */
/* Base */
#define PREFIX_EX_B (1)
/* Index */
#define PREFIX_EX_X (2)
/* Register */
#define PREFIX_EX_R (4)
/* Operand Width */
#define PREFIX_EX_W (8)
/* Vector Lengh */
#define PREFIX_EX_L (0x10)

#endif /* X86DEFS_H */

```

`DumpVAC/distormx/include/distormx.h`:

```h
/*
diStormX 1.0 - The ultimate hooking library
https://github.com/gdabah/distormx
distorm at gmail dot com
Copyright (C) 2015-2021 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef DISTORMX_H
#define DISTORMX_H

/* Support C++ compilers */
#ifdef __cplusplus
extern "C" {
#endif

/*
 * distormx_hook
 *
 * target - In/Out pointer that contains the function to hook.
 *          Returns a pointer to the trampoline of the original function.
 * stub   - In pointer of the function to call instead.
 * return value - int as bool, TRUE if succeeded.
 *
 * NOTES a. Hooking is deferred if distormx_begin_defer was previously called, until distormx_commit is called.
 *       b. If distormx_abort_defer was called all previous un/hooks in the batch will be removed.
 */
int distormx_hook(void ** target, void * stub);

/*
 * distormx_unhook
 *
 * prevTarget - In/Out pointer that was first passed to distormx_hook.
 *              If prevTarget is unknown it will ignore it silently.
 *              If function succeeded, prevTarget will contain NULL.
 * return value - none.
 *
 * NOTES a. Unhooking is deferred if distormx_begin_defer was previously called, until distormx_commit is called.
 *       b. If distormx_abort_defer was called all previous un/hooks in the batch will be removed.
 */
void distormx_unhook(void * prevTarget);

/*
 * distormx_begin_defer
 *
 * Instructs the hooking engine to begin a batch of multi hooks,
 * therefore all next calls to both distormx_hook and distormx_unhook will be deferred until committed.
 *
 * Once distormx_commit is called, all hooks/unhooks will be applied.
 * To cancel the batch, call distormx_abort_defer, which will remove all pending hooks.
 */
void distormx_begin_defer();

/*
 * distormx_abort_defer
 *
 * Removes all pending un/hook operations from the queue.
 * Resets status so next operation happens immediately.
 */
void distormx_abort_defer();

/*
 * distormx_commit
 *
 * Commits both pending hooks and unhooks in the current batch.
 *
 * Hooks all the queued functions at once.
 * The following steps are done:
 * 1) Preflight hooks to organize memory.
 * 2) Suspend all threads.
 * 3) Do actual hooks.
 * 4) Do actual unhooks, if any.
 * 5) Resume all threads.
 *
 * NOTE that the parameters to distormx_hook must still be valid at the time of committing.
 *
 * return value - int as bool, TRUE if everything succeeded.
 *
 * Side effects: defer is disabled.
 */
int distormx_commit();

/*
* allocator_callback_t
* A callback to allocate zero'd RX memory near target.
*
* targetVA - Pointer to target function that is going to be hooked.
*
* return value - Pointer to a newly allocated RX page.
*                         !!IMPORTANT NOTES!!:
*                a. The returned page must be zero'd initially.
*                b. It must be set as Read-Executable protection.
*                c. It must be maximum +-2GB away from target virtual address.
*                d. Must be using a correspondant APIs to the original implementation in os.c
*                   (e.g in Windows - VirtualAlloc/VirtualFree).
*                e. The page returned will be exhausted as much as possible.
*                f. NULL on failure, will cause failures on attempting the following hooking.
*/
typedef void * (*allocator_callback_t)(void * targetVA);

/*
* distormx_set_code_allocator
* Lets the user sets a proprietary read-exec page allocator near target address.
* Overrides default behavior, see OS.c!OS_alloc_code_page as an example.
* Will be called every time a new trampoline needs memory.
*
* callback - Callback of allocator_callback_t, see above expected behavior.
*            Pass NULL to go back to default behavior.
*
* return value - Previous callback (or NULL if wasn't set before).
*/
allocator_callback_t distormx_set_code_allocator(allocator_callback_t callback);

/*
 * distormx_destroy
 *
 * Tears down all hooks, structures and used memory.
 *
 * forceRemoval - Set to TRUE to remove ALL memory including trampolines.
 *                This is dangerous as some hooks might still be in use.
 *                By default it's set to FALSE.
 */
int distormx_destroy();
int distormx_destroy_ex(int forceRemoval);

#ifdef __cplusplus
} /* End Of Extern */
#endif

#endif /* DISTORMX_H */

```

`DumpVAC/distormx/src/OS.c`:

```c
/*
OS.c - Cross paltform OS APIs
diStormX - The ultimate hooking library
https://github.com/gdabah/distormx
distorm at gmail dot com
Copyright (C) 2015-2020 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/

/*
 Heap isolation for hooks.
 OS module shouldn't use malloc/free but its own heap through OS_alloc/OS_free.
*/

#include <windows.h>
#include <TlHelp32.h>
#include "OS.h"


typedef struct {
	HANDLE hHeap;
} os_info_t;

static os_info_t g_osInfo;

typedef void * thread_t;

typedef struct {
	/* First round it's the TID (inside suspend function) and then an opened thread handle! */
	thread_t handle;
	/* IP of the thread to resume from. */
	void * ip;
} _ThreadInfo;

/* Structure to hold the state of suspended threads. */
typedef struct {
	/* Number of suspended threads. */
	unsigned int threadsCount;
	/* Maximum number of threads in the threads array. */
	unsigned int maxThreadsCount;
	/* Old priority of the calling thread, so we revert it later. */
	unsigned int oldThreadPriority;
	/* Array of thread infos. */
	_ThreadInfo threads[1];
} _ThreadsInfo;

/* Minimum start count of threads in the process, this grows by multiples of 2. */
#define START_THREADS_COUNT 64

int OS_init()
{
	g_osInfo.hHeap = HeapCreate(0, 0, 0);
	if (NULL == g_osInfo.hHeap) return FALSE;

	return TRUE;
}

void OS_destroy()
{
	if (NULL != g_osInfo.hHeap) {
		HeapDestroy(g_osInfo.hHeap);
		g_osInfo.hHeap = NULL;
	}
}

void * OS_alloc_code_page(void * target)
{
	int i;
	void * page;
	MEMORY_BASIC_INFORMATION mbi;
	SecureZeroMemory(&mbi, sizeof(mbi));

	/* Get current address' base allocation (it should be mapped). */
	if ((NULL != target) && !VirtualQuery((LPCVOID)target, &mbi, sizeof(mbi))) return FALSE;

	/* Try to allocate a page just next to it. */
	for (i = 1; i < MAXINT32; i *= 2) {
		/* Try lower address first. */
		page = VirtualAlloc((LPVOID)((size_t)mbi.AllocationBase - (i * OS_PAGE_SIZE)), OS_PAGE_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READ);
		if (NULL != page) {
			return page; /* Assume page is zero'd. */
		}
		/* Try higher address next. */
		page = VirtualAlloc((LPVOID)((size_t)mbi.AllocationBase + mbi.RegionSize + (i * OS_PAGE_SIZE)), OS_PAGE_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READ);
		if (NULL != page) {
			return page; /* Assume page is zero'd. */
		}
	}

	return NULL;
}

void OS_free_page(void * address)
{
	VirtualFree(address, 0, MEM_RELEASE);
}

int OS_protect_page(void * address, unsigned int size, os_prot_t newProt, os_prot_t * oldProt)
{
	return VirtualProtect(address, size, newProt,  (PDWORD)oldProt) != FALSE;
	/* No need to translate oldProt, should be opaque to caller. */
}

int OS_is_page_committed(void * address)
{
	MEMORY_BASIC_INFORMATION mbi;
	SecureZeroMemory(&mbi, sizeof(mbi));

	if (NULL == address) return TRUE;

	/* Get current address' info. */
	if (!VirtualQuery((LPCVOID)address, &mbi, sizeof(mbi))) return FALSE;

	return mbi.State == MEM_COMMIT;
}

int OS_suspend_threads(void ** threadsOpaque, unsigned int * threadsCount)
{
	int ret = FALSE;
	CONTEXT context;
	int suspendIndex = 0; /* Must be signed for cleanup code. */
	HANDLE hSnap = INVALID_HANDLE_VALUE;
	_ThreadsInfo * threadsInfo = NULL;
	THREADENTRY32 te32;
	te32.dwSize = sizeof(te32);

	if (NULL == threadsOpaque) return FALSE;

	*threadsOpaque = NULL;
	*threadsCount = 0;

	/*
	 * Allocate threads info with some array size to begin with
	 * (64 threads should be ok inside a process, we will grow if necessary).
	 */
	threadsInfo = (_ThreadsInfo *)OS_realloc(NULL, sizeof(_ThreadsInfo) + START_THREADS_COUNT * sizeof(_ThreadInfo));
	if (NULL == threadsInfo) return FALSE;
	OS_memset(threadsInfo, 0, sizeof(_ThreadsInfo) + START_THREADS_COUNT * sizeof(_ThreadInfo));
	threadsInfo->maxThreadsCount = START_THREADS_COUNT;

	hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (INVALID_HANDLE_VALUE == hSnap) goto cleanup;

	/* Boost priority so we're super fast and only then scan for other threads. */
	threadsInfo->oldThreadPriority = GetThreadPriority(GetCurrentThread());
	if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL)) goto cleanup;

	ret = Thread32First(hSnap, &te32);
	while (ret) {
		/* Gotta filter threads by their process id and not our own thread. */
		if ((te32.th32OwnerProcessID == GetCurrentProcessId()) && (te32.th32ThreadID != GetCurrentThreadId()))  {
			/* If no room to add the thread, then double the array. */
			if (threadsInfo->threadsCount + 1 == threadsInfo->maxThreadsCount) {
				threadsInfo = (_ThreadsInfo *)OS_realloc(threadsInfo, sizeof(_ThreadsInfo) + threadsInfo->maxThreadsCount * 2 * sizeof(_ThreadInfo));
				if (NULL == threadsInfo) goto cleanup;
				/* Update new max. */
				threadsInfo->maxThreadsCount *= 2;
			}
			/* Add the thread ID to the array. */
			threadsInfo->threads[threadsInfo->threadsCount++].handle = (thread_t)(size_t)te32.th32ThreadID;
		}
		ret = Thread32Next(hSnap, &te32);
	}
	CloseHandle(hSnap);
	hSnap = INVALID_HANDLE_VALUE;

	/* Gotta do another pass, so we don't deadlock with a suspended thread that has malloc's lock... */
	for (suspendIndex = 0; (unsigned int)suspendIndex < threadsInfo->threadsCount; suspendIndex++) {
		HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, (DWORD)(size_t)threadsInfo->threads[suspendIndex].handle);

		/*
		* Change the thread id to the handle of the thread.
		* Leave handle to the thread opened.
		*/
		threadsInfo->threads[suspendIndex].handle = hThread;
		if (NULL == hThread) {
			if (ERROR_INVALID_PARAMETER == GetLastError()) continue; /* Skip this thread, probably it died on us. */
			goto cleanup;
		}

		/* Suspend the thread! */
		if (-1 == SuspendThread(hThread)) {
			threadsInfo->threads[suspendIndex].handle = NULL;
			continue;
		}

		/* Get the IP address of the suspended thread. */
		context.ContextFlags = CONTEXT_CONTROL;
		if (!GetThreadContext(hThread, &context)) {
			threadsInfo->threads[suspendIndex].handle = NULL;
			continue;
		}

#if _M_IX86
		threadsInfo->threads[suspendIndex].ip = (void *)context.Eip;
#else
		threadsInfo->threads[suspendIndex].ip = (void *)context.Rip;
#endif
	}

	/* Success, we suspended all other threads. */
	*threadsOpaque = (void *)threadsInfo;
	if (NULL != threadsCount) *threadsCount = threadsInfo->threadsCount;

	ret = TRUE;

cleanup:
	if (INVALID_HANDLE_VALUE != hSnap) CloseHandle(hSnap);
	if (!ret) {
		/* Resume any suspended threads in case we failed. */
		while (suspendIndex >= 0) {
			HANDLE hThread = (HANDLE)threadsInfo->threads[suspendIndex].handle;
			if (NULL != hThread) {
				(void)ResumeThread(hThread);
				CloseHandle(hThread);
			}
			suspendIndex--;
		}

		/* Revert priority. */
		(void)SetThreadPriority(GetCurrentThread(), threadsInfo->oldThreadPriority);

		if (NULL != threadsInfo) OS_free(threadsInfo);
	}
	return ret;
}

void OS_resume_threads(void ** threadsOpaque)
{
	unsigned int i;
	CONTEXT context;
	_ThreadsInfo * threadsInfo;

	if ((NULL == threadsOpaque) || (NULL == *threadsOpaque)) return;

	threadsInfo = (_ThreadsInfo *)*threadsOpaque;
	for (i = 0; i < threadsInfo->threadsCount; i++) {
		HANDLE hThread = (HANDLE)threadsInfo->threads[i].handle;
		if (NULL == hThread) continue; /* Skip dead threads. */

		/* Try best effort to change IP. */
		context.ContextFlags = CONTEXT_CONTROL;
		if (GetThreadContext(hThread, &context)) {
#if _M_IX86
			context.Eip = (DWORD)threadsInfo->threads[i].ip;
#else
			context.Rip = (DWORD64)threadsInfo->threads[i].ip;
#endif
			(void)SetThreadContext(hThread, &context);
		}
		(void)ResumeThread(hThread);
		CloseHandle(hThread);
	}

	/* Revert priority. */
	(void)SetThreadPriority(GetCurrentThread(), threadsInfo->oldThreadPriority);

	OS_free(threadsInfo);
	*threadsOpaque = NULL;
}

void * OS_get_thread_IP(void * threadsOpaque, unsigned int threadIndex)
{
	_ThreadsInfo * threadsInfo;
	if (NULL == threadsOpaque) return NULL;
	threadsInfo = (_ThreadsInfo *)threadsOpaque;
	if ((threadIndex >= 0) && (threadIndex < threadsInfo->threadsCount)) return threadsInfo->threads[threadIndex].ip;
	return NULL;
}

void OS_set_thread_IP(void * threadsOpaque, unsigned int threadIndex, void * ip)
{
	_ThreadsInfo * threadsInfo;
	if (NULL == threadsOpaque) return;
	threadsInfo = (_ThreadsInfo *)threadsOpaque;
	if ((threadIndex >= 0) && (threadIndex < threadsInfo->threadsCount)) threadsInfo->threads[threadIndex].ip = ip;
}

int OS_init_crit(OS_CRIT_SEC_OPAQUE * csOpaque)
{
	InitializeCriticalSection(csOpaque);
	return TRUE;
}

void OS_enter_crit(OS_CRIT_SEC_OPAQUE * csOpaque)
{
	EnterCriticalSection(csOpaque);
}

void OS_leave_crit(OS_CRIT_SEC_OPAQUE * csOpaque)
{
	LeaveCriticalSection(csOpaque);
}

void OS_delete_crit(OS_CRIT_SEC_OPAQUE * csOpaque)
{
	DeleteCriticalSection(csOpaque);
	SecureZeroMemory(csOpaque, sizeof(OS_CRIT_SEC_OPAQUE));
}

void * OS_malloc(size_t size)
{
	return HeapAlloc(g_osInfo.hHeap, 0, size);
}

void * OS_realloc(void * old, size_t size)
{
	if (NULL == old) { /* First time callers. */
		return OS_malloc(size);
	}

	return HeapReAlloc(g_osInfo.hHeap, HEAP_ZERO_MEMORY, old, size);
}

void OS_free(void * ptr)
{
	HeapFree(g_osInfo.hHeap, 0, ptr);
}

void * OS_memset(void * ptr, int c, size_t count)
{
	return memset(ptr, c, count);
}

void * OS_memcpy(void * dst, const void * src, size_t count)
{
	return memcpy(dst, src, count);
}

int OS_memcmp(const void * dst, const void * src, size_t count)
{
	return memcmp(dst, src, count);
}

```

`DumpVAC/distormx/src/OS.h`:

```h
/*
diStormX - The ultimate hooking library
https://github.com/gdabah/distormx
distorm at gmail dot com
Copyright (C) 2015-2020 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef OS_H
#define OS_H

/* Currently this module supports only Windows. */
#include <windows.h>

/* In case someone doesn't have these definitions. */
#ifndef FALSE
#define FALSE 0
#endif
#ifndef TRUE
#define TRUE 1
#endif


/* // Typedefs that are OS dependent // */

#define OS_PAGE_SIZE	0x1000
#define OS_PAGE_RWX		PAGE_EXECUTE_READWRITE
#define OS_PAGE_RX		PAGE_EXECUTE_READ
typedef CRITICAL_SECTION OS_CRIT_SEC_OPAQUE;
typedef unsigned int os_prot_t;

/* // Values that must be in sync with page_alloc_type_e!distormx.h // */
#define OS_PAGEALLOCSTRATEGY_UP   0
#define OS_PAGEALLOCSTRATEGY_DOWN 1
#define OS_PAGEALLOCSTRATEGY_IMPL 2

/* // General OS // */
int OS_init();
void OS_destroy();

/* // Virtual Memory // */

/* Allocate a page as near as possible to target's address. Useful in x64. */
void * OS_alloc_code_page(void * target);
/* Free a page that was allocated previously with OS_alloc_page. */
void OS_free_page(void * address);
/* Change the protection of a page, returns the oldProt, use OS_PAGE_XXX flags. Returns TRUE if succeeded. */
int OS_protect_page(void * address, unsigned int size, os_prot_t newProt, os_prot_t * oldProt);
/* Returns TRUE if page exists. */
int OS_is_page_committed(void * address);

/* // Threading // */

/*
 * Boost priority of current thread and suspend the rest of the threads in the process.
 * A matching call to OS_resume_threads must occur ASAP.
 * threadsOpaque holds an allocated memory.
 * threadsCount will contain the number of suspended threads.
 * Returns TRUE if succeeded.
 * If fails, it exits clean (so no thread is suspended).
 */
int OS_suspend_threads(void ** threadsOpaque, unsigned int * threadsCount);

/*
 * Resumes all threads that OS_suspend_threads suspended in the first place.
 * Releases threadsOpaque's memory.
 * Reverts calling thread's priority.
 * The caller thread must be the same one that called OS_suspend_threads.
 */
void OS_resume_threads(void ** threadsOpaque);

/* Gets the IP register value of a given suspended thread. */
void * OS_get_thread_IP(void * threadsOpaque, unsigned int threadIndex);

/* Sets the IP register value of a given suspended thread. */
void OS_set_thread_IP(void * threadsOpaque, unsigned int threadIndex, void * ip);


/* // Critical Section // */

/* Initialize an OS dependent opaque crit-sect structure. */
int OS_init_crit(OS_CRIT_SEC_OPAQUE * csOpaque);
/* Enter given (initialized) crit-sect. */
void OS_enter_crit(OS_CRIT_SEC_OPAQUE * csOpaque);
/* Leave given (initialized) crit-sect. */
void OS_leave_crit(OS_CRIT_SEC_OPAQUE * csOpaque);
/* Delete given (initialized) crit-sect. */
void OS_delete_crit(OS_CRIT_SEC_OPAQUE * csOpaque);


/* // Generic CRT functions // */
void * OS_malloc(size_t size);
void * OS_realloc(void * old, size_t size);
void OS_free(void * ptr);
void * OS_memset(void * ptr, int c, size_t count);
void * OS_memcpy(void * dst, const void * src, size_t count);
int OS_memcmp(const void * dst, const void * src, size_t count);

#endif /* OS_H */

```

`DumpVAC/distormx/src/distormx.c`:

```c
/*
diStormX 1.0 - The ultimate hooking library for x86/x64
https://github.com/gdabah/distormx
distorm at gmail dot com
Copyright (C) 2015-2020 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.

Features:
 1) Support for both x86/x64
 2) Simple APIs and batch hook commit
 3) Low memory foot print, will re-use trampoline pages as much as possible
 4) RWX sensitive, will temporarily enable RWX and then revert to RX when writing trampolines
 5) Uses a private heap
*/
 

#include "distormx.h"
#include "OS.h"
#include "distorm.h"
#include "mnemonics.h"

#define X86_BRANCH_SIZE 5
#define X64_ABS_BRANCH_SIZE 14
#define MAX_TRAMPOLINE_SIZE 20 /* Max instruction sizes: 4 + 15 */
#define TRAMPOLINE_MAGIC 0xffffaa66
#define TRAMPOLINE_MAGIC_UNHOOKED 0xffffaa99

#define X86_CALL_OPCODE	0xe8
#define X86_JMP_OPCODE	0xe9

/* Structure that holds the actual jmp instruction (trampoline code should be application life time). */
typedef struct {
	/*
	 * Copied instructions from the target function we hook + a JMP to continue execution.
	 */
	unsigned char trampoline[MAX_TRAMPOLINE_SIZE];

#if _M_X64
	/*
	* In x64 if the target and the stub are too far from each other (>-/+2GB),
	* then a bridge is an absolute JMP instruction to the stub.
	* Note that the trampoline is allocated as close as possible to the target's page.
	*/
	unsigned char bridge[X64_ABS_BRANCH_SIZE];
#endif

	/* Magic value to validate trampoline. */
	unsigned int magic;

	/* Point back to the hook info. */
	void * hookInfo;
} trampoline_t;

#define MAX_TRAMPOLINES_PER_PAGE (OS_PAGE_SIZE / sizeof(trampoline_t))

/* Structure that describes a single hook info & state. */
typedef struct {
	/* Original bytes we patched, needed for unhooking. */
	unsigned char origBytes[X86_BRANCH_SIZE];

	/* Trampoline RX code.*/
	trampoline_t * code;

	/* Address of the target itself. */
	void * target;
} hook_info_t;

/* Structure that holds information for installing a hook, temporary only (should be on the stack). */
typedef struct {
	hook_info_t * info;
	_DInst insts[X86_BRANCH_SIZE];
	/* The next instruction the trampoline should go to after executing the copied instructions. */
	void * nextAddress;
	unsigned int trampolineSize;
	unsigned int instsCount;
} hook_info_ex_t;

/* An array of trampolines in the same virtual page. */
typedef struct {
	trampoline_t * trampolines;
	/* Number of trampolines in that page. */
	unsigned int trampolinesCount;
} page_info_t;

/* Type of deferred operation either hook or unhook. */
typedef enum { DX_DEFERRED_HOOK, DX_DEFERRED_UNHOOK } defer_type_e;

/* If the hooks are to be deferred, store minimum information to apply them later. */
typedef struct {
	void ** ppTarget;
	void * stub;
	void * preflightTarget;
	hook_info_t * hookInfo;
	defer_type_e deferType;
} defer_info_t;

/* Structure to hold all hooks related globals and the array of pages of trampolines. */
typedef struct {
	/* Array of trampolines pages. */
	page_info_t * pages;
	/* Number of pages allocated. */
	unsigned int pagesCount;

	/* Information of to-be-hooked. */
	defer_info_t * defers;
	unsigned int defersCount;
	int isDeferred;

	/* Information of to-be-unhooked. */
	hook_info_t ** unhookAddrs;
	unsigned int unhookAddrsCount;

	OS_CRIT_SEC_OPAQUE critSect;
	int initialized;

	/* allocator override for user's proprietary implementation, if NULL will call default implementation. */
	allocator_callback_t allocatorCallback;

	void * threadsOpaque;
	unsigned int threadsCount;
} hooks_globals_t;

static hooks_globals_t * distormx_globals()
{
	static hooks_globals_t globals; /* Zero'd. */
	return (hooks_globals_t *)&globals;
}

static page_info_t * distormx_alloc_page(void * target)
{
	page_info_t * pages;
	hooks_globals_t * globals = distormx_globals();
	if (NULL == globals) return NULL;
	unsigned int pagesCount = globals->pagesCount;
	pages = (page_info_t *)OS_realloc(globals->pages, (pagesCount + 1) * sizeof(page_info_t));
	if (NULL == pages) return NULL;
	globals->pages = pages;

	/* Give a chance to user's callback for allocating the page. */
	if (NULL == globals->allocatorCallback) {
		globals->pages[pagesCount].trampolines = (trampoline_t *)OS_alloc_code_page(target);
	} else {
		globals->pages[pagesCount].trampolines = (trampoline_t *)globals->allocatorCallback(target);
	}
	if (NULL == globals->pages[pagesCount].trampolines) return NULL;
	globals->pages[pagesCount].trampolinesCount = 0;
	globals->pagesCount += 1;

	return &globals->pages[pagesCount];
}

static hook_info_t * distormx_alloc(void * target)
{
	trampoline_t * trampoline = NULL;
	hook_info_t * hookInfo = NULL;
	page_info_t * pageInfo = NULL;
	unsigned int i;

	ptrdiff_t wideTarget = (ptrdiff_t)target;
	ptrdiff_t diff;

	hooks_globals_t * globals = distormx_globals();
	if (NULL == globals) return NULL;

	/* Find the nearest page we can use, basically required only for 64 bits. */
	for (i = 0; i < globals->pagesCount; i++) {
		diff = wideTarget - (ptrdiff_t)globals->pages[i].trampolines;
		if ((diff <= MAXINT32) && (diff > MININT32)) {
			pageInfo = &globals->pages[i];
		}
	}

	/*
	 * If we didn't find a relevant page, allocate a new one then.
	 * In case we found a page, make sure it's not full.
	 */
	if ((NULL == pageInfo) || (pageInfo->trampolinesCount >= MAX_TRAMPOLINES_PER_PAGE)) {
		pageInfo = distormx_alloc_page(target);
		if (NULL == pageInfo) return NULL;
	}

	hookInfo = OS_malloc(sizeof(hook_info_t));
	if (NULL == hookInfo) {
		/* Note: if distorm_alloc_page was called, it will be freed in destroy eventually. */
		return NULL;
	}

	trampoline = (trampoline_t*)((unsigned char *)pageInfo->trampolines + (pageInfo->trampolinesCount * sizeof(trampoline_t)));
	pageInfo->trampolinesCount += 1;

	hookInfo->code = trampoline;

	return hookInfo;
}

static void * distormx_follow_target(void * target)
{
	unsigned char * p = (unsigned char *)target;
	if (*p == 0xe9) {
		return distormx_follow_target((void *)((ptrdiff_t)target + 5 + *(int*)(p + 1)));
	} if (*p == 0xeb) {
		return distormx_follow_target((void *)((ptrdiff_t)target + 2 + *(char*)(p + 1)));
	}
#if _M_IX86
	else if ((*p == 0xff) && (*(p + 1) == 0x25)) {
		return distormx_follow_target(**(void ***)(p + 2));
	}
#else /* _M_X64 */
	else if ((*p == 0xff) && (*(p + 1) == 0x25)) {
		/* JMP QWORD [RIP + offset] */
		int off = *(int*)(p + 2);
		return distormx_follow_target(*(void **)((ptrdiff_t)target + off + 6));
	}
	else if ((*p == 0x48) && (*(p + 1) == 0xff) && (*(p + 2) == 0x25)) {
		int off = *(int*)(p + 3);
		return distormx_follow_target(*(void **)((ptrdiff_t)target + off + 7));
	}
#endif
	return target;
}

static void distormx_connect_stub(void * source, void * target, unsigned char * bridgeCode, hook_info_t * hookInfo)
{
	ptrdiff_t iSource = (ptrdiff_t)source;
	ptrdiff_t iTarget = (ptrdiff_t)target;
	ptrdiff_t diff = iTarget - iSource - 5;

	bridgeCode[0] = X86_JMP_OPCODE;

#if _M_IX86
	*(unsigned int*)&bridgeCode[1] = (unsigned int)diff;
	hookInfo; /* Unreferenced. */
#elif _M_X64
	/* See if we could use a single branch from the hooked function to the stub. */
	if ((diff > MAXINT32) || (diff <= MININT32)) {
		/*
		 * We are going to need a bridge through hookInfo->bridge.
		 * Bridge is required because the target address and the stub are too far from each (more than 31 bits).
		 *
		 * Emit:
		 * JMP QWORD [RIP+0]
		 * DQ <ABS_ADDR>
		 */
		hookInfo->code->bridge[0] = 0xff;
		hookInfo->code->bridge[1] = 0x25;
		*(unsigned int*)&hookInfo->code->bridge[2] = 0;
		*(void **)&hookInfo->code->bridge[6] = target;

		/* Update the relative offset to point to the bridge instead. */
		diff = (ptrdiff_t)hookInfo->code->bridge - iSource - 5;
	}

	*(unsigned int*)&bridgeCode[1] = (unsigned int)diff;
#endif
}

static int distormx_disasm(void * address, hook_info_ex_t * hookInfoEx)
{
	_CodeInfo ci;
	ci.code = (uint8_t *)address;
	ci.codeLen = 64;
	ci.codeOffset = (_OffsetType)address;
#if _M_IX86
	ci.dt = Decode32Bits;
#else
	ci.dt = Decode64Bits;
#endif
	ci.features = DF_NONE;
	distorm_decompose(&ci, hookInfoEx->insts, X86_BRANCH_SIZE, &hookInfoEx->instsCount);
	return hookInfoEx->instsCount > 0;
}

static int distormx_copy_and_relocate_instruction(_DInst * inst, hook_info_ex_t * hookInfoEx)
{
	_OffsetType target = 0;
	unsigned char * code;

	/* Make sure we got enough room to copy the instruction. */
	if (hookInfoEx->trampolineSize + inst->size > MAX_TRAMPOLINE_SIZE) return FALSE;
	/*
	 * Since we might create new instruction because of relocations,
	 * we will have to keep track of the real address we have to continue from.
	 */
	hookInfoEx->nextAddress = (void *)((size_t)hookInfoEx->nextAddress + inst->size);

	/* See if some instructions need special relocation treatment. */
	if ((inst->opcode == I_CALL) && (inst->ops[0].type == O_PC)) {
		ptrdiff_t diff;
		/* Is it a relative call? Any other call instruction should be copied as is (E.G. CALL EAX). */
		/* Calculate target. */
		target = INSTRUCTION_GET_TARGET(inst);
		/* Emit a new instruction with the corrected relative target address. */
		code = &hookInfoEx->info->code->trampoline[hookInfoEx->trampolineSize];

#if _M_X64
		/* Validate range in x64 or die. */
		diff = (ptrdiff_t)target - (ptrdiff_t)code - 5;
		if ((diff > MAXINT32) || (diff <= MININT32)) return FALSE;
#else
		diff; /* Unreferenced. */
#endif

		*code = X86_CALL_OPCODE;
		*(unsigned int *)(code + 1) = (unsigned int)((ptrdiff_t)target - (ptrdiff_t)code - 5);
		hookInfoEx->trampolineSize += 5;
	} else {
		/* Copy instruction as is. */
		OS_memcpy(&hookInfoEx->info->code->trampoline[hookInfoEx->trampolineSize], (const void *)((size_t)inst->addr), inst->size);
		hookInfoEx->trampolineSize += inst->size;

#if _M_X64
		/*
		 * In x64 an instruction can be RIP relative.
		 * So it only means we will have to copy it and fix the relativity.
		 * The problem is that the it might happen that the copied instruction
		 * will get too far away from the RIP relative target address.
		 * However, it should be really rare since we allocated a page close to the hooked address.
		 * In case it ever happens we could always build better instruction chains to overcome this.
		 *
		 * The nice thing about RIP relative is that the offset is always signed 32 bits displacement.
		 * Thanks Intel for putting displacements just before immediates thus we can find it and patch it easily.
		 * And that's why we don't care which instruction we patch, nothing needs a special treatment.
		 */
		if (inst->flags & FLAG_RIP_RELATIVE) {
			ptrdiff_t diff;
			unsigned int i;
			unsigned int immSize = 0;
			target = INSTRUCTION_GET_RIP_TARGET(inst);
			/* Validate range or die. */
			diff = ((ptrdiff_t)target - (ptrdiff_t)(hookInfoEx->info->code->trampoline + hookInfoEx->trampolineSize));
			if ((diff > MAXINT32) || (diff <= MININT32)) return FALSE;
			/* Skip the immediate, if one exists, so we reach to the displacement. */
			for (i = 0; i < OPERANDS_NO; i++) {
				if (inst->ops[i].type == O_IMM) {
					immSize = inst->ops[i].size / 8;
					break;
				}
			}
			/* Fix the relative offset (start from end of instruction, 4 = size of disp plus immSize). */
			*(unsigned int*)&hookInfoEx->info->code->trampoline[hookInfoEx->trampolineSize - immSize - 4] = (unsigned int)diff;
		}
#endif
	}
	return TRUE;
}

static int distormx_copy_instructions(hook_info_ex_t * hookInfoEx)
{
	unsigned int i;
	unsigned int instsSize = 0;
	unsigned int meta;

	/*
	 * We keep track of the real address to continue trampoline from.
	 * This might become necessary if we don't copy the instructions 1 to 1.
	 */
	hookInfoEx->nextAddress = (void *)((size_t)hookInfoEx->insts[0].addr);

	/* Scan all instructions and see if we could patch them. */
	for (i = 0; ((i < X86_BRANCH_SIZE) && (i < hookInfoEx->instsCount)); i++) {
		if (hookInfoEx->insts[i].flags == FLAG_NOT_DECODABLE) return FALSE;

		meta = META_GET_FC(hookInfoEx->insts[i].meta);

		/* If it's any INTxx or JMP instruction, just fail. */
		/* TODO: handle branches smarter. */
		/* BUGBUGBUG: In some cases there's false positive on 55 instruction (push ebp). Disabled for now */
		//if ((meta == FC_INT) || (meta == FC_UNC_BRANCH) || (meta == FC_CND_BRANCH)) return FALSE;

		if (!distormx_copy_and_relocate_instruction(&hookInfoEx->insts[i], hookInfoEx)) return FALSE;

		instsSize += hookInfoEx->insts[i].size;
		/* Check if we're done copying instructions. */
		if (instsSize >= X86_BRANCH_SIZE) {
			/* Emit the JMP instruction at the end of the copied instructions to continue at the next instruction. */
			ptrdiff_t iSource = (ptrdiff_t)&hookInfoEx->info->code->trampoline[hookInfoEx->trampolineSize];
			ptrdiff_t iTarget = (ptrdiff_t)hookInfoEx->nextAddress;
			hookInfoEx->info->code->trampoline[hookInfoEx->trampolineSize] = X86_JMP_OPCODE;
			*(unsigned int*)&hookInfoEx->info->code->trampoline[hookInfoEx->trampolineSize + 1] = (unsigned int)(iTarget - iSource - 5);
			return TRUE;
		}
		/* If instruction is RET family, then fail. BTW - it's ok to patch RET too if we have sufficient room. */
		if (meta == FC_RET) break;
	}

	/* If we reached here it means we didn't have enough bytes to write our patch. */
	return FALSE;
}

static defer_info_t * distormx_alloc_defer_info()
{
	defer_info_t * currDefer, *defers;
	hooks_globals_t * globals = distormx_globals();
	if (NULL == globals) return NULL;
	defers = (defer_info_t *)OS_realloc(globals->defers, (globals->defersCount + 1) * sizeof(defer_info_t));
	if (NULL == defers) return NULL;
	globals->defers = defers;

	currDefer = (defer_info_t *)((size_t)globals->defers + globals->defersCount * sizeof(defer_info_t));
	OS_memset(currDefer, 0, sizeof(defer_info_t));
	globals->defersCount += 1;

	return currDefer;
}

static int distormx_patch(void * target, void * code, unsigned int codeLength, hook_info_ex_t * hookInfoEx, int shouldSuspend, int isHooking)
{
	unsigned int oldProt;
	unsigned int i;
	void * threadsOpaque;
	unsigned int threadsCount;
	int retVal = FALSE;
	/*
	 * If we are not going to suspend here, since everything is suspended already in deferring mode,
	 * then we have to use the global threads state of the distormx_commit function.
	 */
	if (NULL == distormx_globals()) return FALSE;

	threadsOpaque = distormx_globals()->threadsOpaque;
	threadsCount = distormx_globals()->threadsCount;

	/* Only suspend other threads if we have to. */
	if (!shouldSuspend || OS_suspend_threads(&threadsOpaque, &threadsCount)) {
		/* Change protection to page so we could patch it. */
		if (!OS_protect_page(target, codeLength, OS_PAGE_RWX, &oldProt)) {
			if (shouldSuspend) {
				OS_resume_threads(&threadsOpaque);
			}
			return FALSE;
		}
		/* See if any thread's IP is inside the patched range, only possible during hooking. */
		if (isHooking) {
			for (i = 0; i < threadsCount; i++) {
				size_t ip = (size_t)OS_get_thread_IP(threadsOpaque, i);

				/* See if the IP is in the range. */
				if ((ip >= (size_t)target) && (ip < (size_t)target + X86_BRANCH_SIZE)) {
					/*
					* Now move it to the trampoline.
					* It's ok to move it relatively because we copy 1 to 1 so far.
					* In the future we might need to check the mapping...
					* Rebase it:
					*/
					ip -= (size_t)target;
					ip += (size_t)hookInfoEx->info->code->trampoline;
					OS_set_thread_IP(threadsOpaque, i, (void *)ip);
				}
			}
		}

		/* Patch the function's code at last. */
		OS_memcpy(target, code, codeLength);

		/* Return page to original protection. */
		retVal = OS_protect_page(target, codeLength, oldProt, &oldProt) != FALSE;
		/* Resume threads. */
		if (shouldSuspend) (void)OS_resume_threads(&threadsOpaque);
	}

	return retVal;
}

static int distormx_init()
{
	hooks_globals_t * globals = distormx_globals();
	if (NULL == globals) return FALSE;

	if (!OS_init()) return FALSE;

	if (!OS_init_crit(&globals->critSect)) {
		OS_destroy();
		return FALSE;
	}

	/* Note isDeferred could be 1 already here since distormx_begin_defer could've been called. */

	globals->initialized = TRUE;
	return TRUE;
}

static int distormx_hook_internal(void ** ppTarget, void * stub, defer_info_t * deferredInfo)
{
	int shouldSuspend = TRUE;
	int ret = FALSE;
	void * target;
	hook_info_t * hookInfo;
	/* Extra information needed to create the trampoline but not for hook's life time. */
	hook_info_ex_t hookInfoEx;
	SecureZeroMemory(&hookInfoEx, sizeof(hookInfoEx));

	/* Follow in target address to skip branches. */
	target = distormx_follow_target(*ppTarget);

	/* In deferring mode we must not allocate memory, so we have to use existing hookInfo. */
	if (NULL != deferredInfo) {
		/* Use the preflight hook info! */
		hookInfo = deferredInfo->hookInfo;
		/*
		 * We gotta make sure targets haven't changed.
		 * If they did then it means another thread hooked the function or something happened with it.
		 * Technically, if the target got changed, and points to a far away page, we might need to allocate a new page.
		 * In deferred mode we must not allocate memory.
		 * Therefore, we rather fail miserably in both x86/x64!
		 */
		if (deferredInfo->preflightTarget != target) return FALSE;

		/* Mark that we shouldn't suspend other threads as they are already suspended. */
		shouldSuspend = FALSE;
	} else {
		/* Allocate a new trampoline for this hook. */
		hookInfo = distormx_alloc(target);
		if (NULL == hookInfo) return FALSE;
	}

	hookInfoEx.info = hookInfo;
	/* Disassemble the first few instructions. */
	if (distormx_disasm(target, &hookInfoEx)) {

		os_prot_t oldProt;
		/* Make trampoline's page temporarily RWX. */
		if (OS_protect_page(&hookInfo->code->trampoline, MAX_TRAMPOLINE_SIZE, OS_PAGE_RWX, &oldProt)) {

			/* Copy enough instructions to the trampoline and relocate (fix) offsets too. */
			if (distormx_copy_instructions(&hookInfoEx)) {

				unsigned char bridgeCode[X86_BRANCH_SIZE];

				/*
				 * Build the JMP instruction from the hooked function to the stub,
				 * might need a bridge in x64 if target/stub are more than -/+2GB.
				 */
				distormx_connect_stub(target, stub, bridgeCode, hookInfo);

				/* Some unhooking book keeping. */
				OS_memcpy(hookInfo->origBytes, target, X86_BRANCH_SIZE);
				hookInfo->target = target;
				hookInfo->code->magic = TRAMPOLINE_MAGIC;
				hookInfo->code->hookInfo = (void *)hookInfo;

				/* FIRST! Set output argument to contain trampoline address, so hook stub can work immediately. */
				*ppTarget = (void *)hookInfo->code->trampoline;

				ret = distormx_patch(target, bridgeCode, X86_BRANCH_SIZE, &hookInfoEx, shouldSuspend, TRUE) != FALSE;
				/* Did we fail installing the hook? */
				if (!ret) {
					*ppTarget = NULL;
					/* To keep things simple, we will just mark this hook as dud. Can't release memory in case we're in deferring mode. */
					hookInfo->code->magic = TRAMPOLINE_MAGIC_UNHOOKED;
				}
			}
			OS_protect_page(&hookInfo->code->trampoline, MAX_TRAMPOLINE_SIZE, oldProt, &oldProt);
		}
	}

	return ret;
}

int distormx_hook(void ** ppTarget, void * stub)
{
	int ret;
	hooks_globals_t * globals = distormx_globals();
	if (NULL == globals) return FALSE;

	/* Input validation. */
	if ((NULL == ppTarget) || (NULL == *ppTarget) || (NULL == stub)) return FALSE;

	if (!globals->initialized)
		if (!distormx_init()) return FALSE;

	OS_enter_crit(&globals->critSect);

	/* See if the hook should be deferred, so we keep it for later. */
	if (globals->isDeferred) {
		defer_info_t * deferInfo;
		deferInfo = distormx_alloc_defer_info();
		if (NULL == deferInfo) {
			OS_leave_crit(&globals->critSect);
			return FALSE;
		}

		deferInfo->ppTarget = ppTarget;
		deferInfo->stub = stub;
		deferInfo->deferType = DX_DEFERRED_HOOK;

		OS_leave_crit(&globals->critSect);
		return TRUE;
	}

	/* Do the hook now. */
	ret = distormx_hook_internal(ppTarget, stub, NULL);
	OS_leave_crit(&globals->critSect);
	return ret;
}

static void distormx_unhook_internal(hook_info_t * hookInfo, int shouldSuspend)
{
	/* Validate again now that we got the crit. */
	if (hookInfo->code->magic == TRAMPOLINE_MAGIC) {
		/* Validate hook is still going to our stub, so we can unhook. Otherwise we gotta fail. */
		// BUGBUG fix bridgecode comparison && (OS_memcmp(hookInfo->target, hookInfo->bridgeCode, X86_BRANCH_SIZE) == 0)
		if (OS_is_page_committed(hookInfo->target)) {
			/* Other threads are suspended inside the patching function. */
			(VOID)distormx_patch(hookInfo->target, hookInfo->origBytes, sizeof(hookInfo->origBytes), NULL, shouldSuspend, FALSE);
		}

		os_prot_t oldProt;
		/* Make trampoline's page temporarily RWX. */
		if (OS_protect_page(&hookInfo->code->magic, sizeof(unsigned int), OS_PAGE_RWX, &oldProt)) {
			/* Mark it's unhooked. */
			hookInfo->code->magic = TRAMPOLINE_MAGIC_UNHOOKED;
			hookInfo->code->hookInfo = NULL;
			OS_protect_page(&hookInfo->code->trampoline, MAX_TRAMPOLINE_SIZE, oldProt, &oldProt);
		}

		OS_free(hookInfo);
	}
}

void distormx_unhook(void * prevTarget)
{
	trampoline_t * trampoline;
	hook_info_t * info;
	hooks_globals_t * globals = distormx_globals();
	if (NULL == globals) return;

	if (!globals->initialized) return;

	if ((NULL == prevTarget) || (NULL == *(void**)prevTarget)) return;
	trampoline = *(trampoline_t **)prevTarget;

	/*
	 * It might happen that distormx_commit failed, and then later unhook is called anyways.
	 * So next thing is that info points to the supposed-to-be-hooked function (instead of a trampoline).
	 * In addition, usually it's in unloading code, and thus if they tried to hook a DLL, and it's unloaded,
	 * the following magic test will segfault too.
	 * Therefore, extra precaution must be done.
	 */
	if (!OS_is_page_committed(trampoline)) return;

	/* Hold it first, so no double unhooking somehow. */
	OS_enter_crit(&globals->critSect);

	/* Validate given prevTarget is ours. */
	if (trampoline->magic != TRAMPOLINE_MAGIC) {
		OS_leave_crit(&globals->critSect);
		return;
	}

	info = trampoline->hookInfo;

	if (globals->isDeferred) {
		/* Allocate extra room for the pointer to the trampoline, so we can unhook it later. */
		hook_info_t ** unhookAddrs = (hook_info_t **)OS_realloc(globals->unhookAddrs, (globals->unhookAddrsCount + 1) * sizeof(hook_info_t *));
		if (NULL == unhookAddrs) {
			OS_leave_crit(&globals->critSect);
			return;
		}
		globals->unhookAddrs = unhookAddrs;
		globals->unhookAddrs[globals->unhookAddrsCount] = info;
		globals->unhookAddrsCount += 1;
	} else {
		distormx_unhook_internal(info, TRUE); /* Suspend threads. */
	}

	/* NOTE! When unhooking we must keep trampoline in case somebody may still return to it. */

	OS_leave_crit(&globals->critSect);
}

void distormx_begin_defer()
{
	hooks_globals_t * globals = distormx_globals();
	if (NULL == globals) return;

	/* It's ok if distormx_init wasn't called yet. */

	globals->isDeferred = TRUE;
}

void distormx_abort_defer()
{
	hooks_globals_t * globals = distormx_globals();
	if (NULL == globals) return;

	/* Remove all deferred hooks that weren't installed. Their hookInfo's will be freed later. */
	globals->isDeferred = FALSE;
	if (globals->defersCount) {
		OS_free(globals->defers);
		globals->defers = NULL;
		globals->defersCount = 0;
	}

	/* Removed all deferred unhooks. Going to unhook everything soon anyway. */
	if (globals->unhookAddrsCount) {
		OS_free(globals->unhookAddrs);
		globals->unhookAddrs = NULL;
		globals->unhookAddrsCount = 0;
	}
}

int distormx_commit()
{
	unsigned int i;
	int ret = FALSE;

	hooks_globals_t * globals = distormx_globals();
	if (NULL == globals) return FALSE;
	if (!globals->initialized) return FALSE;
	if (!globals->isDeferred) return FALSE;

	/* Disable deferred anyway. */
	globals->isDeferred = FALSE;

	if (!globals->defersCount && !globals->unhookAddrsCount) return FALSE;

	OS_enter_crit(&globals->critSect);
	
	/* Preflight, make one pass to allocate trampolines for all deferred hooks first. */
	for (i = 0; i < globals->defersCount; i++) {
		/* Follow in target address to skip branches. */
		void * target = distormx_follow_target(*globals->defers[i].ppTarget);

		/* Allocate a new trampoline for this hook. */
		hook_info_t * hookInfo = distormx_alloc(target);
		if (NULL == hookInfo) goto cleanup;

		/*
		 * Store some info.
		 * Since we do preflight, we want to make sure nobody touches the
		 * target address between the time we did the preflight and the time we suspended other threads.
		 */
		globals->defers[i].preflightTarget = target;
		globals->defers[i].hookInfo = hookInfo;
	}

	/* Now suspend all other threads only once. */
	if (!OS_suspend_threads(&globals->threadsOpaque, &globals->threadsCount)) goto cleanup;

	/* Walk over the deferred hooks and apply them with the previously allocated hookInfo. */
	for (i = 0 ; i < globals->defersCount; i++)
		if ((ret = distormx_hook_internal(globals->defers[i].ppTarget, globals->defers[i].stub, &globals->defers[i])) == FALSE) break;

	/* Do all deferred unhooks now. */
	for (i = 0; i < globals->unhookAddrsCount; i++)
		distormx_unhook_internal(globals->unhookAddrs[i], FALSE); /* Don't suspend. */

	/* Resume threads. */
	(void)OS_resume_threads(&globals->threadsOpaque);

cleanup:
	if (NULL != globals->defers) OS_free(globals->defers);
	globals->defers = NULL;
	globals->defersCount = 0;

	if (NULL != globals->unhookAddrs) OS_free(globals->unhookAddrs);
	globals->unhookAddrs = NULL;
	globals->unhookAddrsCount = 0;

	OS_leave_crit(&globals->critSect);
	return ret;
}

allocator_callback_t distormx_set_code_allocator(allocator_callback_t callback)
{
	allocator_callback_t prev;
	hooks_globals_t * globals = distormx_globals();
	if (NULL == globals) return NULL;

	prev = globals->allocatorCallback;
	globals->allocatorCallback = callback;
	return prev;
}

int distormx_destroy()
{
	/* By default we leave trampolines in memory, this is much safer. */
	return distormx_destroy_ex(FALSE);
}

int distormx_destroy_ex(int forceRemoval)
{
	unsigned int i, j;
	hooks_globals_t * globals = distormx_globals();
	if (NULL == globals) return FALSE;
	if (!globals->initialized) return FALSE;

	OS_enter_crit(&globals->critSect);
	globals->initialized = FALSE;

	distormx_abort_defer();

	/*
	 * Unhook all.
	 * Now suspend all other threads only once (instead of per un/hook). Try to do our best, hopefully we manage to suspend.
	 */
	if (globals->pagesCount && OS_suspend_threads(&globals->threadsOpaque, &globals->threadsCount)) {
		for (i = 0; i < globals->pagesCount; i++) {
			if (globals->pages[i].trampolinesCount) {
				for (j = 0;
					((j < MAX_TRAMPOLINES_PER_PAGE) && (globals->pages[i].trampolines[j].magic != 0));
					j++)
				{
					hook_info_t * hookInfo = globals->pages[i].trampolines[j].hookInfo;
					if (NULL != hookInfo) {
						distormx_unhook_internal(hookInfo, FALSE); /* Don't suspend threads as we did already. */
					}
				}

				if (forceRemoval) {
					/* Remove actual pages of trampolines, this is dangerous in case some hooks are still used! */
					OS_free_page(globals->pages[i].trampolines);
				}
				globals->pages[i].trampolines = NULL;
				globals->pages[i].trampolinesCount = 0;
			}
		}

		/* Resume threads. */
		(void)OS_resume_threads(&globals->threadsOpaque);
	}

	/* Free globals. */
	OS_free(globals->pages);
	globals->pages = NULL;
	globals->pagesCount = 0;

	OS_leave_crit(&globals->critSect);
	OS_delete_crit(&globals->critSect);

	OS_destroy();

	return TRUE;
}

```

`DumpVAC/dllmain.cpp`:

```cpp

// Framework
#include "framework.h"

// IceKey
#include "IceKey.h"

// ConsoleAPI
#include "Console.h"

// LibraryLoader
#include "LibraryLoader.h"

// Detours
#include "Detours.h"

// Distorm(X)
#include "distorm.h"
#include "distormx.h"

// STL
#include <unordered_map>
#include <memory>
#include <vector>
#include <array>

// Namespaces
using namespace Detours;

// General definitions

#define MAGIC_VALVE_SIGNATURE 0x00564C56 // VLV

typedef HMODULE(WINAPI* fnLoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);

enum MODULE_RESULT : unsigned int {
	NOT_SET = 0x0,
	SUCCESS = 0x1,
	ALREADY_LOADED = 0x2,
	FAIL_INITIALIZE = 0x3,
	UKN1 = 0x4,
	UKN2 = 0x5,
	FAIL_TO_DECRYPT_MODULE = 0xB,
	FAIL_MODULE_SIZE_NULL = 0xC,
	UKN3 = 0xF,
	FAIL_GET_MODULE_TEMP_PATH = 0x13,
	FAIL_WRITE_MODULE = 0x15,
	FAIL_LOAD_MODULE = 0x16,
	FAIL_GET_EXPORT_RUNFUNC = 0x17,
	FAIL_GET_EXPORT_RUNFUNC_2 = 0x19
};

typedef void(__fastcall* fnEncrypt)(void* pBase, void* pData, unsigned int unDataSize, unsigned char* pIceKey);
typedef MODULE_RESULT(__stdcall* fnRunFunc)(unsigned int unID, void* pInData, unsigned int unInDataSize, void* pOutData, unsigned int* pOutDataSize);

typedef struct _MODULE {
	unsigned short m_unRunFuncExportFunctionOrdinal;
	unsigned short m_unRunFuncExportModuleOrdinal;
	void* m_pModuleBase;
	PIMAGE_NT_HEADERS m_pNTHs;
	unsigned int m_unImportedLibraryCount;
	void* m_pIAT;
} MODULE, *PMODULE;

typedef struct _MODULE_HEADER {
	IMAGE_DOS_HEADER m_DH;
	unsigned int m_unMagic;
	unsigned int m_unCrypt;
	unsigned int m_unFileSize;
	unsigned int m_unTimeStamp;
	unsigned char m_pCryptRSASignature[0x80];
} MODULE_HEADER, *PMODULE_HEADER;

typedef struct _MODULE_INFO {
	unsigned int m_unHash; // CRC32
	HMODULE m_hModule;
	PMODULE m_pModule;
	fnRunFunc m_pRunFunc;
	MODULE_RESULT m_unLastResult;
	unsigned int m_unModuleSize;
	PMODULE_HEADER m_pRawModule;
} MODULE_INFO, *PMODULE_INFO;

typedef bool(__stdcall* fnLoadModuleStandard)(PMODULE_INFO pModuleInfo, unsigned char unFlags);
typedef MODULE_RESULT(__fastcall* fnCallFunctionAsyncInternal)(void* pThis, void* pEDX, unsigned int unHash, unsigned char unFlags, int nA, int nB, unsigned int unID, int nC, void* pInData, unsigned int unInDataSize, void* pOutData, unsigned int* pOutDataSize);

PLOADER_DATA g_pLoaderData = nullptr;

std::unordered_map<HMODULE, std::pair<HANDLE, std::unique_ptr<wchar_t[]>>> g_ImportingModules;
std::unordered_map<unsigned int, std::array<unsigned char, 16>> g_IceKeys;
std::vector<unsigned int> g_DumpedHashes;

fnLoadLibraryExW LoadLibraryExW_Original = nullptr;
HMODULE WINAPI LoadLibraryExW_Hook(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags) {
	HMODULE hModule = LoadLibraryExW_Original(lpLibFileName, hFile, dwFlags);
	if (!lpLibFileName) {
		return hModule;
	}

	const size_t unLength = wcsnlen_s(lpLibFileName, MAX_PATH);
	const size_t unSize = unLength * sizeof(wchar_t);

	auto Import = g_ImportingModules.find(hModule);
	if (Import == g_ImportingModules.end()) {
		std::unique_ptr<wchar_t[]> pMem(new wchar_t[unLength + 1]);
		wchar_t* pBuffer = pMem.get();
		memset(pBuffer, 0, unSize + sizeof(wchar_t));
		memcpy(pBuffer, lpLibFileName, unSize);
		pBuffer[unLength] = 0;

		g_ImportingModules.insert(std::pair<HMODULE, std::pair<HANDLE, std::unique_ptr<wchar_t[]>>>(hModule, std::pair<HANDLE, std::unique_ptr<wchar_t[]>>(hFile, std::move(pMem))));
	} else {
		std::unique_ptr<wchar_t[]> pMem(new wchar_t[unLength + 1]);
		wchar_t* pBuffer = pMem.get();
		memset(pBuffer, 0, unSize + sizeof(wchar_t));
		memcpy(pBuffer, lpLibFileName, unSize);
		pBuffer[unLength] = 0;

		Import->second = std::pair<HANDLE, std::unique_ptr<wchar_t[]>>(hFile, std::move(pMem));
	}

	return hModule;
}

void DumpOutData(void* pOutData, unsigned int* pOutDataSize) {

	char szBuffer[2048];
	memset(szBuffer, 0, sizeof(szBuffer));
	sprintf_s(szBuffer, "%sVAC_OUT_%08X.dat", g_pLoaderData->m_pLoaderPath, reinterpret_cast<unsigned int>(pOutData));
	FILE* pFile = nullptr;
	fopen_s(&pFile, szBuffer, "wb+");
	if (!pFile) {
		return;
	}

	if (fwrite(pOutData, 1, 4232, pFile) != 4232) {
		fclose(pFile);
		return;
	}

	fclose(pFile);

	clrprintf(COLOR::COLOR_RED, "[DumpVAC] RunFunc (OUT) dumped to `%s`.\n", szBuffer);
}

void EncryptICE(unsigned char* pAddress, void* pAllocation, int a3, unsigned char* pIceKey) {
	IceKey ICE(1);
	ICE.set(pIceKey);

	unsigned char* pData = reinterpret_cast<unsigned char*>(reinterpret_cast<unsigned int>(pAllocation) - reinterpret_cast<unsigned int>(pAddress));
	unsigned short unCount = 512;
	do {
		ICE.encrypt((unsigned __int8*)(pData + reinterpret_cast<unsigned int>(pAddress)), pAddress);
		pAddress += 8;
		--unCount;
	} while (unCount);
}

unsigned int* g_pOutDataSize = nullptr;

unsigned int unKey = 0;
unsigned char g_pIceKey[8];

unsigned int unECX = 0;
unsigned int unEDX = 0;

fnEncrypt Encrypt = nullptr;
__declspec(naked) void Encrypt_Hook() {
	__asm {
		mov [unECX], ecx
		mov [unEDX], edx

		push ebp
		mov ebp, esp

		push ecx
		mov ecx, [ebp + 0Ch]
		mov [unKey], ecx
		pop ecx

		mov esp, ebp
		pop ebp
	}
	//for (i = 0; i < 4096; i += 8) {
	//	clrprintf(COLOR::COLOR_RED, "[%08X] ", unESP + i);
	//	for (k = 0; (k < 8) && ((i + k) < 4096); ++k) {
	//		clrprintf(COLOR::COLOR_RED, "%08X ", reinterpret_cast<unsigned int*>(unESP)[i + k]);
	//	}
	//	clrprintf(COLOR::COLOR_RED, "\n");
	//}
	clrprintf(COLOR::COLOR_RED, "[DumpVAC] Encryption Key: %02X %02X %02X %02X %02X %02X %02X %02X\n", reinterpret_cast<unsigned char*>(unKey)[0], reinterpret_cast<unsigned char*>(unKey)[1], reinterpret_cast<unsigned char*>(unKey)[2], reinterpret_cast<unsigned char*>(unKey)[3], reinterpret_cast<unsigned char*>(unKey)[4], reinterpret_cast<unsigned char*>(unKey)[5], reinterpret_cast<unsigned char*>(unKey)[6], reinterpret_cast<unsigned char*>(unKey)[7], unKey);
	//__asm {
	//	ret
	//}
	g_pIceKey[0] = reinterpret_cast<unsigned char*>(unKey)[0];
	g_pIceKey[1] = reinterpret_cast<unsigned char*>(unKey)[1];
	g_pIceKey[2] = reinterpret_cast<unsigned char*>(unKey)[2];
	g_pIceKey[3] = reinterpret_cast<unsigned char*>(unKey)[3];
	g_pIceKey[4] = reinterpret_cast<unsigned char*>(unKey)[4];
	g_pIceKey[5] = reinterpret_cast<unsigned char*>(unKey)[5];
	g_pIceKey[6] = reinterpret_cast<unsigned char*>(unKey)[6];
	g_pIceKey[7] = reinterpret_cast<unsigned char*>(unKey)[7];

	//((unsigned int*)unEDX)[0] = 0x00000000; // ICE Key address
	//((unsigned int*)unEDX)[1] = 0x00000000; // Loader Status
	//((unsigned int*)unEDX)[2] = 0xFFFFFFFF; // ??

	/*
	((unsigned int*)unEDX)[1026] = 0x46221D9E;
	((unsigned int*)unEDX)[1027] = 0x67746882;
	((unsigned int*)unEDX)[1028] = 0xE3287DC7;
	((unsigned int*)unEDX)[1029] = 0xA4993577;
	((unsigned int*)unEDX)[1030] = 0x93523D76;
	((unsigned int*)unEDX)[1031] = 0xF2D2A55E;
	((unsigned int*)unEDX)[1032] = 0x429C7F5F;
	((unsigned int*)unEDX)[1033] = 0x2137159A;
	((unsigned int*)unEDX)[1034] = 0xB842B5E0;
	((unsigned int*)unEDX)[1035] = 0x535C9CE6;
	((unsigned int*)unEDX)[1036] = 0xA3BAC349;
	((unsigned int*)unEDX)[1037] = 0x2DAB997A;
	((unsigned int*)unEDX)[1038] = 0x56BAB25F;
	((unsigned int*)unEDX)[1039] = 0x925CB300;
	((unsigned int*)unEDX)[1040] = 0x68881140;
	((unsigned int*)unEDX)[1041] = 0xB3C7F37A;
	((unsigned int*)unEDX)[1042] = 0xE3287DC7;
	*/

	//((unsigned int*)unEDX)[1024] = 0x00000040;
	//((unsigned int*)unEDX)[1025] = 0x00000000;

	DumpOutData((void*)unEDX, g_pOutDataSize);
	//DumpOutData((void*)(unECX - 4 * unSize), unSize);
	EncryptICE((unsigned char*)unEDX, (unsigned char*)unECX, 0, g_pIceKey);
	//VirtualFree(reinterpret_cast<LPVOID>(unECX), 0, MEM_RELEASE);
	__asm {
		ret
	}
}

bool bCallOriginal = false;
bool bSessionCheck = false;

unsigned char pIceKey1[8];
unsigned char pIceKey2[8];

fnRunFunc RunFunc = nullptr;
MODULE_RESULT __stdcall RunFunc_Hook(unsigned int unID, void* pInData, unsigned int unInDataSize, void* pOutData, unsigned int* pOutDataSize) {
	if (!bCallOriginal) {
		bCallOriginal = true;
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] RunFunc ID=%08X\n", unID);

		char szBuffer[2048];
		memset(szBuffer, 0, sizeof(szBuffer));
		sprintf_s(szBuffer, "%sVAC_IN_%08X.dat", g_pLoaderData->m_pLoaderPath, reinterpret_cast<unsigned int>(pInData));
		FILE* pFile = nullptr;
		fopen_s(&pFile, szBuffer, "wb+");
		if (!pFile) {
			return RunFunc(unID, pInData, unInDataSize, pOutData, pOutDataSize);
		}

		unsigned char* pMemory = new unsigned char [unInDataSize];
		if (!pMemory) {
			fclose(pFile);
			return RunFunc(unID, pInData, unInDataSize, pOutData, pOutDataSize);
		}

		memcpy(pMemory, pInData, unInDataSize);

		IceKey ICE(1);
		ICE.set(pIceKey1);
		for (size_t i = 0; i < unInDataSize; i += 8) {
			ICE.decrypt(&pMemory[i], &pMemory[i]);
		}

		if (fwrite(pMemory, 1, unInDataSize, pFile) != unInDataSize) {
			fclose(pFile);
			return RunFunc(unID, pInData, unInDataSize, pOutData, pOutDataSize);
		}

		delete[] pMemory;

		fclose(pFile);

		clrprintf(COLOR::COLOR_RED, "[DumpVAC] RunFunc (IN) dumped to `%s`.\n", szBuffer);

		//clrprintf(COLOR::COLOR_RED, "OUT = %08X\n", reinterpret_cast<unsigned int>(pOutData));

		//DebugBreak();

		g_pOutDataSize = pOutDataSize;

		MODULE_RESULT unResult = RunFunc(unID, pInData, unInDataSize, pOutData, pOutDataSize);

		clrprintf(COLOR::COLOR_RED, "[DumpVAC] OK.\n");

		//unsigned int unLESP = 0;
		//__asm { mov unLESP, esp };

		//clrprintf(COLOR::COLOR_RED, "[DumpVAC] ESP = %08X\n", unLESP);

		//unsigned char* pIceKey = reinterpret_cast<unsigned char*>(unLESP + 0x29C);
		//clrprintf(COLOR::COLOR_RED, "[DumpVAC] Encrypt called with %02X %02X %02X %02X %02X %02X %02X %02X key.\n", pIceKey[0], pIceKey[1], pIceKey[2], pIceKey[3], pIceKey[4], pIceKey[5], pIceKey[6], pIceKey[7]);

		return unResult;
	}

	if (bSessionCheck) {
		bSessionCheck = false;
		clrprintf(COLOR::COLOR_GREEN, "[DumpVAC] RunFunc allowed. (Session check)\n");
		return RunFunc(unID, pInData, unInDataSize, pOutData, pOutDataSize);
	}

	clrprintf(COLOR::COLOR_RED, "[DumpVAC] RunFunc ID=%08X\n", unID);
	clrprintf(COLOR::COLOR_RED, "[DumpVAC] RunFunc blocked.\n");

	if (unID == 4) {
		return MODULE_RESULT::SUCCESS;
	}

	return MODULE_RESULT::FAIL_INITIALIZE;
}

unsigned int unSessionModuleHash = 0;

fnLoadModuleStandard LoadModuleStandard = nullptr;
bool __stdcall LoadModuleStandard_Hook(PMODULE_INFO pModuleInfo, unsigned char unFlags) {

	clrprintf(COLOR::COLOR_WHITE, "[DumpVAC] ");
	clrprintf(COLOR::COLOR_CYAN, "PreLoadModuleStandard\n");
	clrprintf(COLOR::COLOR_GREEN, " -> ModuleInfo = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo));
	if (pModuleInfo) {
		clrprintf(COLOR::COLOR_GREEN, "    -> m_unHash       = 0x%08X\n", pModuleInfo->m_unHash);
		clrprintf(COLOR::COLOR_GREEN, "    -> m_hModule      = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_hModule));
		clrprintf(COLOR::COLOR_GREEN, "    -> m_pModule      = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pModule));
		if (pModuleInfo->m_pModule) {
			clrprintf(COLOR::COLOR_GREEN, "       -> m_unRunFuncExportFunctionOrdinal = 0x%04X\n", pModuleInfo->m_pModule->m_unRunFuncExportFunctionOrdinal);
			clrprintf(COLOR::COLOR_GREEN, "       -> m_unRunFuncExportModuleOrdinal   = 0x%04X\n", pModuleInfo->m_pModule->m_unRunFuncExportModuleOrdinal);
			clrprintf(COLOR::COLOR_GREEN, "       -> m_pModuleBase                    = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pModule->m_pModuleBase));
			clrprintf(COLOR::COLOR_GREEN, "       -> m_pNTHs                          = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pModule->m_pNTHs));
			clrprintf(COLOR::COLOR_GREEN, "       -> m_unImportedLibraryCount         = 0x%08X\n", pModuleInfo->m_pModule->m_unImportedLibraryCount);
			clrprintf(COLOR::COLOR_GREEN, "       -> m_pIAT                           = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pModule->m_pIAT));
		}
		clrprintf(COLOR::COLOR_GREEN, "    -> m_pRunFunc     = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pRunFunc));
		clrprintf(COLOR::COLOR_GREEN, "    -> m_unLastResult = 0x%08X\n", pModuleInfo->m_unLastResult);
		clrprintf(COLOR::COLOR_GREEN, "    -> m_unModuleSize = 0x%08X\n", pModuleInfo->m_unModuleSize);
		clrprintf(COLOR::COLOR_GREEN, "    -> m_pRawModule   = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pRawModule));
	}
	clrprintf(COLOR::COLOR_GREEN, " -> unFlags    = 0x%02X\n", unFlags);

	bool bResult = LoadModuleStandard(pModuleInfo, unFlags);
	if (!pModuleInfo) {
		return bResult;
	}

	clrprintf(COLOR::COLOR_WHITE, "[DumpVAC] ");
	clrprintf(COLOR::COLOR_CYAN, "PostLoadModuleStandard\n");
	clrprintf(COLOR::COLOR_GREEN, " -> ModuleInfo = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo));
	if (pModuleInfo) {
		clrprintf(COLOR::COLOR_GREEN, "    -> m_unHash       = 0x%08X\n", pModuleInfo->m_unHash);
		clrprintf(COLOR::COLOR_GREEN, "    -> m_hModule      = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_hModule));
		clrprintf(COLOR::COLOR_GREEN, "    -> m_pModule      = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pModule));
		if (pModuleInfo->m_pModule) {
			clrprintf(COLOR::COLOR_GREEN, "       -> m_unRunFuncExportFunctionOrdinal = 0x%04X\n", pModuleInfo->m_pModule->m_unRunFuncExportFunctionOrdinal);
			clrprintf(COLOR::COLOR_GREEN, "       -> m_unRunFuncExportModuleOrdinal   = 0x%04X\n", pModuleInfo->m_pModule->m_unRunFuncExportModuleOrdinal);
			clrprintf(COLOR::COLOR_GREEN, "       -> m_pModuleBase                    = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pModule->m_pModuleBase));
			clrprintf(COLOR::COLOR_GREEN, "       -> m_pNTHs                          = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pModule->m_pNTHs));
			clrprintf(COLOR::COLOR_GREEN, "       -> m_unImportedLibraryCount         = 0x%08X\n", pModuleInfo->m_pModule->m_unImportedLibraryCount);
			clrprintf(COLOR::COLOR_GREEN, "       -> m_pIAT                           = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pModule->m_pIAT));
		}
		clrprintf(COLOR::COLOR_GREEN, "    -> m_pRunFunc     = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pRunFunc));
		clrprintf(COLOR::COLOR_GREEN, "    -> m_unLastResult = 0x%08X\n", pModuleInfo->m_unLastResult);
		clrprintf(COLOR::COLOR_GREEN, "    -> m_unModuleSize = 0x%08X\n", pModuleInfo->m_unModuleSize);
		clrprintf(COLOR::COLOR_GREEN, "    -> m_pRawModule   = 0x%08X\n", reinterpret_cast<unsigned int>(pModuleInfo->m_pRawModule));
	}
	clrprintf(COLOR::COLOR_GREEN, " -> unFlags    = 0x%02X\n", unFlags);
	clrprintf(COLOR::COLOR_GREEN, " -> Result     = 0x%02X\n", bResult);

	if (pModuleInfo->m_pRunFunc) {
		if (!bCallOriginal) {
			RunFunc = pModuleInfo->m_pRunFunc;
			unSessionModuleHash = pModuleInfo->m_unHash;
		}

		if (unSessionModuleHash == pModuleInfo->m_unHash) {
			bSessionCheck = true;
		}

		pModuleInfo->m_pRunFunc = RunFunc_Hook;
	}

	HMODULE hModule = pModuleInfo->m_hModule;
	if (!hModule) {
		return bResult;
	}

	const PMODULE_HEADER pMH = reinterpret_cast<PMODULE_HEADER>(hModule);
	if (pMH->m_unMagic != MAGIC_VALVE_SIGNATURE) {
		return bResult;
	}

	unsigned int unHash = pModuleInfo->m_unHash;

	for (auto it = g_DumpedHashes.begin(); it != g_DumpedHashes.end(); ++it) {
		if (*it == unHash) {
			return bResult;
		}
	}

	g_DumpedHashes.push_back(unHash);

	auto Import = g_ImportingModules.find(hModule);
	if (Import != g_ImportingModules.end()) {
		auto Keys = g_IceKeys.find(unHash);
		if (Keys != g_IceKeys.end()) {

			const size_t unModuleSize = pModuleInfo->m_unModuleSize;

			memcpy(pIceKey1, Keys->second.data(), 8);
			memcpy(pIceKey2, Keys->second.data() + 8, 8);

			clrprintf(COLOR::COLOR_RED, "[DumpVAC] Found VAC module\n");
			clrprintf(COLOR::COLOR_RED, "[DumpVAC]  -> Base = 0x%08X\n", hModule);
			clrprintf(COLOR::COLOR_RED, "[DumpVAC]  -> Size = 0x%08X\n", unModuleSize);
			clrprintf(COLOR::COLOR_RED, "[DumpVAC]  -> Path = `%ws`\n", Import->second.second.get());
			clrprintf(COLOR::COLOR_RED, "[DumpVAC]  -> FKey = %02X %02X %02X %02X %02X %02X %02X %02X\n", pIceKey1[0], pIceKey1[1], pIceKey1[2], pIceKey1[3], pIceKey1[4], pIceKey1[5], pIceKey1[6], pIceKey1[7]);
			clrprintf(COLOR::COLOR_RED, "[DumpVAC]  -> SKey = %02X %02X %02X %02X %02X %02X %02X %02X\n", pIceKey2[0], pIceKey2[1], pIceKey2[2], pIceKey2[3], pIceKey2[4], pIceKey2[5], pIceKey2[6], pIceKey2[7]);

			unsigned char* pMemory = new unsigned char [unModuleSize];
			if (!pMemory) {
				return bResult;
			}

			memcpy(pMemory, pModuleInfo->m_pRawModule, unModuleSize);

			Encrypt = reinterpret_cast<fnEncrypt>(Scan::FindSignature(hModule, "\x55\x8B\xEC\x83\xEC\x0C\x53\x56\x57\x8B\xF9"));
			if (Encrypt) {
				if (distormx_hook(reinterpret_cast<void**>(&Encrypt), Encrypt_Hook)) {
					clrprintf(COLOR::COLOR_RED, "[DumpVAC] Encrypt hooked.\n");
				}
			}

			// Removing loader
			unsigned char* pLoader = reinterpret_cast<unsigned char*>(const_cast<void*>(Scan::FindSignature(hModule, "\x55\x8B\xEC\xB8\xF0\x43\x00\x00")));
			if (!pLoader) {
				delete[] pMemory;
				return bResult;
			}

			if (!Memory::ChangeProtection(pLoader, 1, PAGE_READWRITE)) {
				delete[] pMemory;
				return bResult;
			}

			pLoader[0] = 0xC3;

			Memory::RestoreProtection(pLoader);

			clrprintf(COLOR::COLOR_RED, "[DumpVAC] Loader patched.\n");

			// Removing all junks/trash.
			unsigned char* pMagic = reinterpret_cast<unsigned char*>(const_cast<void*>(Scan::FindSignature(hModule, "\x51\x53\x56\x57\x8B")));
			if (!pMagic) {
				delete[] pMemory;
				return bResult;
			}

			if (!Memory::ChangeProtection(pMagic, 6, PAGE_READWRITE)) {
				delete[] pMemory;
				return bResult;
			}

			pMagic[0] = 0xB8;
			pMagic[1] = 0x00;
			pMagic[2] = 0x00;
			pMagic[3] = 0x00;
			pMagic[4] = 0x00;
			pMagic[5] = 0xC3;

			Memory::RestoreProtection(pMagic);

			clrprintf(COLOR::COLOR_RED, "[DumpVAC] Magic patched.\n");

			unsigned char* pRDTSC = reinterpret_cast<unsigned char*>(const_cast<void*>(Scan::FindSignature(hModule, "\x0F\x31\x83\xA4\x24\xCC")));
			if (!pRDTSC) {
				delete[] pMemory;
				return bResult;
			}

			if (!Memory::ChangeProtection(pRDTSC, 21, PAGE_READWRITE)) {
				delete[] pMemory;
				return bResult;
			}

			//unsigned long long rdtsc = __rdtsc();
			//unsigned int edx = (rdtsc >> 32) & 0xFFFFFFFF;
			//unsigned int eax = rdtsc & 0xFFFFFFFF;

			unsigned int edx = 0x0009E9EC; // High
			unsigned int eax = 0xA8423856; // Low

			// and dword ptr ss:[esp+0xCC], 0x0
			pRDTSC[0 ] = 0x83;
			pRDTSC[1 ] = 0xA4;
			pRDTSC[2 ] = 0x24;
			pRDTSC[3 ] = 0xCC;
			pRDTSC[4 ] = 0x00;
			pRDTSC[5 ] = 0x00;
			pRDTSC[6 ] = 0x00;
			pRDTSC[7 ] = 0x00;

			// mov dword ptr ss:[esp+0x1C], 0x0009E9EC
			pRDTSC[8 ] = 0xC7;
			pRDTSC[9 ] = 0x44;
			pRDTSC[10] = 0x24;
			pRDTSC[11] = 0x1C;
			memcpy(&pRDTSC[12], &edx, 4);

			// mov eax, 0xA8423856
			pRDTSC[16] = 0xB8;
			memcpy(&pRDTSC[17], &eax, 4);

			Memory::RestoreProtection(pRDTSC);

			clrprintf(COLOR::COLOR_RED, "[DumpVAC] RDTSC fixed.\n");

			unsigned char* pEncryptedSize = reinterpret_cast<unsigned char*>(const_cast<void*>(Scan::FindSignature(hModule, "\x68\x2A\x2A\x2A\x2A\x8B\xD1")));
			if (!pEncryptedSize) {
				delete[] pMemory;
				return bResult;
			}

			const unsigned int unEncryptedSize = *reinterpret_cast<unsigned int*>(pEncryptedSize + 1);
			if (!unEncryptedSize) {
				delete[] pMemory;
				return bResult;
			}

			unsigned char* pEncryptedPayload = reinterpret_cast<unsigned char*>(const_cast<void*>(Scan::FindSignature(hModule, "\xB9\x2A\x2A\x2A\x2A\x68")));
			if (!pEncryptedPayload) {
				delete[] pMemory;
				return bResult;
			}

			pEncryptedPayload = reinterpret_cast<unsigned char*>(*reinterpret_cast<unsigned int*>(pEncryptedPayload + 1));
			if (!pEncryptedPayload) {
				delete[] pMemory;
				return bResult;
			}

			unsigned char* pFirstIceKey = reinterpret_cast<unsigned char*>(const_cast<void*>(Scan::FindSignature(hModule, "\xA3\x2A\x2A\x2A\x2A\xC7")));
			if (!pFirstIceKey) {
				delete[] pMemory;
				return bResult;
			}

			unsigned char* pSecondIceKey = reinterpret_cast<unsigned char*>(const_cast<void*>(Scan::FindSignature(pFirstIceKey + 6, reinterpret_cast<size_t>(pFirstIceKey) - reinterpret_cast<size_t>(hModule) - 6,  "\xA3\x2A\x2A\x2A\x2A\xC7")));
			if (!pSecondIceKey) {
				delete[] pMemory;
				return bResult;
			}

			pFirstIceKey = reinterpret_cast<unsigned char*>(*reinterpret_cast<unsigned int*>(pFirstIceKey + 1) + 0x10);
			pSecondIceKey = reinterpret_cast<unsigned char*>(*reinterpret_cast<unsigned int*>(pSecondIceKey + 1) + 0x10);

			clrprintf(COLOR::COLOR_RED, "[DumpVAC] VAC FKey: %02X %02X %02X %02X %02X %02X %02X %02X\n", pFirstIceKey[0], pFirstIceKey[1], pFirstIceKey[2], pFirstIceKey[3], pFirstIceKey[4], pFirstIceKey[5], pFirstIceKey[6], pFirstIceKey[7]);

			IceKey ICE(1);
			ICE.set(pFirstIceKey);
			ICE.decrypt(&pIceKey1[0], &pIceKey1[0]);
			ICE.set(pIceKey1);

			clrprintf(COLOR::COLOR_RED, "[DumpVAC] VAC  DKey: %02X %02X %02X %02X %02X %02X %02X %02X\n", pIceKey1[0], pIceKey1[1], pIceKey1[2], pIceKey1[3], pIceKey1[4], pIceKey1[5], pIceKey1[6], pIceKey1[7]);

			unsigned char* pPayload = reinterpret_cast<unsigned char*>(const_cast<void*>(Scan::FindData(pMemory, unModuleSize, pEncryptedPayload, unEncryptedSize)));
			if (!pPayload) {
				delete[] pMemory;
				return bResult;
			}

			for (unsigned int i = 0; i < unEncryptedSize; i += 8) {
				ICE.decrypt(&pPayload[i], &pPayload[i]);
			}

			clrprintf(COLOR::COLOR_RED, "[DumpVAC] VAC SKey: %02X %02X %02X %02X %02X %02X %02X %02X\n", pSecondIceKey[0], pSecondIceKey[1], pSecondIceKey[2], pSecondIceKey[3], pSecondIceKey[4], pSecondIceKey[5], pSecondIceKey[6], pSecondIceKey[7]);

			char szBuffer[2048];
			memset(szBuffer, 0, sizeof(szBuffer));
			sprintf_s(szBuffer, "%sVAC_%08X.dll", g_pLoaderData->m_pLoaderPath, unHash);
			FILE* pFile = nullptr;
			fopen_s(&pFile, szBuffer, "wb+");
			if (!pFile) {
				delete[] pMemory;
				return bResult;
			}

			reinterpret_cast<PMODULE_HEADER>(pMemory)->m_unCrypt = 0;

			if (fwrite(pMemory, 1, unModuleSize, pFile) != unModuleSize) {
				fclose(pFile);
				delete[] pMemory;
				return bResult;
			}

			fclose(pFile);
			delete[] pMemory;

			clrprintf(COLOR::COLOR_RED, "[DumpVAC] Dumped to `%s`.\n", szBuffer);
		}
	}

	return bResult;
}

fnCallFunctionAsyncInternal CallFunctionAsyncInternal = nullptr;
MODULE_RESULT __fastcall CallFunctionAsyncInternal_Hook(void* pThis, void* pEDX, unsigned int unHash, unsigned char unFlags, int nA, int nB, unsigned int unActionID, int nC, void* pInData, unsigned int unInDataSize, void* pOutData, unsigned int* pOutDataSize) {

	clrprintf(COLOR::COLOR_WHITE, "[DumpVAC] ");
	clrprintf(COLOR::COLOR_CYAN, "PreCallFunctionAsyncInternal\n");
	clrprintf(COLOR::COLOR_GREEN, " -> (this)      = 0x%08X\n", reinterpret_cast<unsigned int>(pThis));
	clrprintf(COLOR::COLOR_GREEN, " -> Hash        = 0x%08X\n", unHash);
	clrprintf(COLOR::COLOR_GREEN, " -> Flags       = 0x%02X\n", unFlags);
	clrprintf(COLOR::COLOR_GREEN, " -> ActionID     = 0x%08X\n", unActionID);
	clrprintf(COLOR::COLOR_GREEN, " -> InData      = 0x%08X\n", reinterpret_cast<unsigned int>(pInData));
	clrprintf(COLOR::COLOR_GREEN, " -> InDataSize  = 0x%08X\n", unInDataSize);
	clrprintf(COLOR::COLOR_GREEN, " -> OutData     = 0x%08X\n", reinterpret_cast<unsigned int>(pOutData));
	clrprintf(COLOR::COLOR_GREEN, " -> OutDataSize = 0x%08X\n", pOutDataSize ? *pOutDataSize : 0x00000000ui32);

	unsigned char* pIn = reinterpret_cast<unsigned char*>(pInData);
	if (pIn) {
		auto Keys = g_IceKeys.find(unHash);
		if (Keys == g_IceKeys.end()) {
			auto vKeys = std::array<unsigned char, 16>();
			memcpy(vKeys.data(), pIn + 0x10, 16);
			clrprintf(COLOR::COLOR_GREEN, " -> FKey        = %02X %02X %02X %02X %02X %02X %02X %02X\n", vKeys[0], vKeys[1], vKeys[2], vKeys[3], vKeys[4], vKeys[5], vKeys[6], vKeys[7]);
			clrprintf(COLOR::COLOR_GREEN, " -> SKey        = %02X %02X %02X %02X %02X %02X %02X %02X\n", vKeys[8], vKeys[9], vKeys[10], vKeys[11], vKeys[12], vKeys[13], vKeys[14], vKeys[15]);
			g_IceKeys.insert(std::pair<unsigned int, std::array<unsigned char, 16>>(unHash, std::move(vKeys)));
		} else {
			memcpy(Keys->second.data(), pIn + 0x10, 16);
		}
	}

	MODULE_RESULT unResult = CallFunctionAsyncInternal(pThis, pEDX, unHash, unFlags, nA, nB, unActionID, nC, pInData, unInDataSize, pOutData, pOutDataSize);

	clrprintf(COLOR::COLOR_WHITE, "[DumpVAC] ");
	clrprintf(COLOR::COLOR_CYAN, "PostCallFunctionAsyncInternal\n");
	clrprintf(COLOR::COLOR_GREEN, " -> (this)      = 0x%08X\n", reinterpret_cast<unsigned int>(pThis));
	clrprintf(COLOR::COLOR_GREEN, " -> Hash        = 0x%08X\n", unHash);
	clrprintf(COLOR::COLOR_GREEN, " -> Flags       = 0x%02X\n", unFlags);
	clrprintf(COLOR::COLOR_GREEN, " -> ActionID    = 0x%08X\n", unActionID);
	clrprintf(COLOR::COLOR_GREEN, " -> InData      = 0x%08X\n", reinterpret_cast<unsigned int>(pInData));
	clrprintf(COLOR::COLOR_GREEN, " -> InDataSize  = 0x%08X\n", unInDataSize);
	clrprintf(COLOR::COLOR_GREEN, " -> OutData     = 0x%08X\n", reinterpret_cast<unsigned int>(pOutData));
	clrprintf(COLOR::COLOR_GREEN, " -> OutDataSize = 0x%08X\n", pOutDataSize ? *pOutDataSize : 0x00000000ui32);
	clrprintf(COLOR::COLOR_GREEN, " -> Result      = 0x%08X\n", unResult);

	return unResult;
}

DWORD WINAPI MainRoutine(LPVOID lpThreadParameter) {
	if (!ConnectToConsole()) {
		return 0;
	}

	clrprintf(COLOR::COLOR_WHITE, "DumpVAC [Version 1.0.0] (zeze839@gmail.com)\n\n");
	clrprintf(COLOR::COLOR_WHITE, "[DumpVAC] Loading... ");

	if (!g_pLoaderData) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Loader data not available.\n");
		return 0;
	}

	HMODULE hKernel32 = GetModuleHandle(_T("kernel32.dll"));
	if (!hKernel32) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Unable to find `kernel32.dll` module.\n");
		return 0;
	}

	LoadLibraryExW_Original = reinterpret_cast<fnLoadLibraryExW>(GetProcAddress(hKernel32, "LoadLibraryExW"));
	if (!LoadLibraryExW_Original) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Unable to find `LoadLibraryExW` function.\n");
		return 0;
	}

	if (!distormx_hook(reinterpret_cast<void**>(&LoadLibraryExW_Original), LoadLibraryExW_Hook)) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Failed to hook `LoadLibraryExW` function.\n");
		return 0;
	}

	HMODULE hSteamService = GetModuleHandle(_T("SteamService.dll"));
	if (!hSteamService) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Unable to find `SteamService.dll` module.\n");
		return 0;
	}

	unsigned char* pJZ = const_cast<unsigned char*>(reinterpret_cast<const unsigned char* const>(Scan::FindData(hSteamService, reinterpret_cast<const unsigned char*>("\x74\x47\x6A\x01\x6A\x00"), 6)));
	if (!pJZ) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Unable to find `74 47 6A 01 6A 00` signature.\n");
		return 0;
	}

	if (!Memory::ChangeProtection(pJZ, 1, PAGE_EXECUTE_READWRITE)) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Failed to change memory protection for `74 47 6A 01 6A 00` signature.\n");
		return 0;
	}

	// Forces to use LoadModuleStandard. (Potential File Spam)
	pJZ[0] = 0xEB; // jz -> jmp

	if (!Memory::RestoreProtection(pJZ)) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Failed to change memory protection for `74 47 6A 01 6A 00` signature.\n");
		return 0;
	}

	pJZ = const_cast<unsigned char*>(reinterpret_cast<const unsigned char* const>(Scan::FindSignature(hSteamService, "\x74\x18\xE8\x2A\x2A\x2A\x2A\x6A\x2A\xFF\x76\x18\x8B\xC8\x8B\x10\xFF\x52\x2A\xC7\x46\x18\x2A\x2A\x2A\x2A\x5E")));
	if (!pJZ) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Unable to find `74 18 E8 ?? ?? ?? ?? 6A ?? FF 76 18 8B C8 8B 10 FF 52 ?? C7 46 18 ?? ?? ?? ?? 5E` signature.\n");
		return 0;
	}

	if (!Memory::ChangeProtection(pJZ, 1, PAGE_EXECUTE_READWRITE)) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Failed to patch `74 18 E8 ?? ?? ?? ?? 6A ?? FF 76 18 8B C8 8B 10 FF 52 ?? C7 46 18 ?? ?? ?? ?? 5E` signature.\n");

		return 0;
	}

	// Forces to save RAW module in `MODULE_INFO`. (Potential Memory Leak?)
	pJZ[0] = 0xEB; // jz -> jmp

	if (!Memory::RestoreProtection(pJZ)) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Failed to change memory protection for `74 18 E8 ?? ?? ?? ?? 6A ?? FF 76 18 8B C8 8B 10 FF 52 ?? C7 46 18 ?? ?? ?? ?? 5E` signature.\n");
		return 0;
	}

	LoadModuleStandard = reinterpret_cast<fnLoadModuleStandard>(Scan::FindSignature(hSteamService, "\x55\x8B\xEC\x83\xEC\x28\x53\x56\x8B\x75"));
	if (!LoadModuleStandard) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Unable to find `55 8B EC 83 EC 28 53 56 8B 75` signature.\n");
		return 0;
	}

	CallFunctionAsyncInternal = reinterpret_cast<fnCallFunctionAsyncInternal>(Scan::FindSignature(hSteamService, "\x55\x8B\xEC\x6A\xFF\x68\x2A\x2A\x2A\x2A\x68\x2A\x2A\x2A\x2A\x64\xA1\x2A\x2A\x2A\x2A\x50\x64\x89\x25\x2A\x2A\x2A\x2A\x83\xEC\x6C"));
	if (!CallFunctionAsyncInternal) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Unable to find `55 8B EC 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64 A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 6C` signature.\n");
		return 0;
	}

	if (!distormx_hook(reinterpret_cast<void**>(&LoadModuleStandard), LoadModuleStandard_Hook)) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Failed to hook function with `55 8B EC 83 EC 28 53 56 8B 75` signature.\n");
		return 0;
	}

	if (!distormx_hook(reinterpret_cast<void**>(&CallFunctionAsyncInternal), CallFunctionAsyncInternal_Hook)) {
		clrprintf(COLOR::COLOR_RED, "[ FAIL ]\n");
		clrprintf(COLOR::COLOR_RED, "[DumpVAC] Error: ");
		clrprintf(COLOR::COLOR_WHITE, "Failed to hook function with `55 8B EC 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64 A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 6C` signature.\n");
		return 0;
	}

	clrprintf(COLOR::COLOR_GREEN, "[  OK  ]\n");
	return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
	g_pLoaderData = reinterpret_cast<PLOADER_DATA>(lpReserved);
	switch (ul_reason_for_call) {
		case DLL_PROCESS_ATTACH: {
			CreateThread(nullptr, 0x100000 /* 1 MiB */, MainRoutine, lpReserved, NULL, nullptr);
		}
		case DLL_THREAD_ATTACH: {
			break;
		}
		case DLL_THREAD_DETACH: {
			break;
		}
		case DLL_PROCESS_DETACH: {
			break;
		}
	}
	return TRUE;
}

```

`DumpVAC/framework.h`:

```h
#pragma once

#ifndef _FRAMEWORK_H_
#define _FRAMEWORK_H_

// Default
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <tchar.h>
#include <Psapi.h>

// C++
#include <cstdlib>
#include <cstdio>
#include <ctime>

// General definitions
#define DLL_EXPORT __declspec(dllexport)

#endif // !_FRAMEWORK_H_

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Ren

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# DumpVAC
PoC to disable VAC and dump modules with automatic decryption.

# Some info (Possibly outdated, this screenshot was taken about a year ago)
![Picture](https://github.com/RenardDev/DumpVAC/blob/main/unknown.png)

* The first module always responds to session initialization.
* Modules can be different (for example, a scanner for illegal controllers that emulate a player but in reality are hardware cheats; a scanner for processes and its modules)
* All modules have their own purpose.
* Modules are received from Steam servers and the server does not care if it has not received a response with the results of module execution. (DumpVAC blocks the execution of modules and the response remains filled with zeros)
* Modules can be specially created for specific tasks. (There are general modules that always work and there are modules that are created to search for specific cheats)

# Short manual
1. Run `Console.exe`.
2. Run any game with VAC.
3. Done.
4. (To restore VAC - Press CTRL+C / To restart DumpVAC for reuse - Close and Open again)

```