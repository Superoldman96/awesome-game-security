Project Path: arc_gmh5225_kLLDB_ud0oucg5

Source Tree:

```txt
arc_gmh5225_kLLDB_ud0oucg5
├── CMakeLists.txt
├── LICENSE
├── README.md
├── kLLDB.py
├── kLLDB.sh
├── plugins
│   ├── CMakeLists.txt
│   ├── kLLDBLive.cpp
│   └── kLLDBOffline.cpp
└── scripts
    └── report-linux-bug.py

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.13.4)
project(kLLDB)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(LLVM REQUIRED CONFIG)
message(STATUS "Using LLVMConfig.cmake in: ${LLVM_DIR}")
include(AddLLVM)

include_directories(${LLVM_INCLUDE_DIRS})
separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS})
add_definitions(${LLVM_DEFINITIONS_LIST})

add_subdirectory(plugins)

add_custom_target(copy_kLLDB_scripts ALL
  COMMAND ${CMAKE_COMMAND} -E make_directory "${CMAKE_BINARY_DIR}/bin"
  COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "${CMAKE_SOURCE_DIR}/kLLDB.sh" "${CMAKE_BINARY_DIR}/bin/kLLDB"
  COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "${CMAKE_SOURCE_DIR}/kLLDB.py" "${CMAKE_BINARY_DIR}/bin/kLLDB.py"
  COMMENT "Copying kLLDB.sh and kLLDB.py into build/bin"
)

add_dependencies(copy_kLLDB_scripts kLLDBLive)

install(TARGETS kLLDBLive
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION bin
)

install(PROGRAMS
  "${CMAKE_SOURCE_DIR}/kLLDB.sh"
  DESTINATION bin
  RENAME kLLDB
)

install(FILES
  "${CMAKE_SOURCE_DIR}/kLLDB.py"
  DESTINATION bin
)

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# kLLDB
LLDB based debugger for Linux Kernel

## Install deps

```
echo "deb http://apt.llvm.org/$(lsb_release -cs)/ llvm-toolchain-$(lsb_release -cs)-19 main" | sudo tee /etc/apt/sources.list.d/llvm.list
wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -
sudo apt-get update
sudo apt-get install -y llvm-19-dev clang-19 libclang-19-dev lld-19 pkg-config libgc-dev libssl-dev zlib1g-dev libcjson-dev libsqlite3-dev libunwind-dev
sudo apt-get install -y python3.12-dev
```

Create symlink to `lldb-19`:

```
cd /usr/bin
sudo ln -S ./lldb ../lib/llvm-19/bin/lldb
```

## Build it

```
mkdir build && cd build
cmake ../kLLDB/ -DCMAKE_BUILD_TYPE=Relase -DLLVM_DIR=/usr/lib/llvm-19/lib/cmake/llvm -GNinja
```

## Examples

`kLLDB` supports both live and offline debugging by parsing `kdump` coredump files.

### Offline debugging - kdump

For the purpose of debugging a `kdump` file, we added an LLDB plugin, that is a wrapper around [libkdumpfile](https://github.com/ptesarik/libkdumpfile).
Lets analyze a crash file from Linux kernel 5.15 and see some `kdump` specific options:

```
$ lldb
(lldb) target create vmlinux
Current executable set to '/path/to/KoviD/kovid/vmlinux' (x86_64).
(lldb) plugin load /path/to/NewKLLDB/build/lib/libkLLDBOffline.so
kLLDBOffline plugin loaded.
kLLDB> kdump open ./crash.file
Opened ./crash.file
kLLDB> kdump info
  Crash File: ./crash.file
  Release: 5.15.0
  Arch: x86_64
  Crash Time: 2025-03-26 08:15:11
  BUILD-ID: 5854168ecc422202ede0880ac960351c37b57faa
  PAGESIZE: 4096
  Crash PID: 260 CPU0
kLLDB> kdump load-lkm kovid.ko
kovid.ko loaded at 0xffffffffc0000000
kLLDB> kdump bugpoint
Instructon pointer at rip=0xffffffffc0003dd5
Blame function: kv_reset_tainted+5
kLLDB> kdump source-dir-map /kovid/ /path/to/KoviD/kovid
Mapped source directory '/kovid/' -> '/path/to/KoviD/kovid'
kLLDB> list kv_reset_tainted
File: /kovid/src/sys.c
   1226 
   1227     if (!within_module(parent_ip, THIS_MODULE))
   1228         regs->ip = (unsigned long)hook->function;
   1229 }
   1230 
   1231 int kv_reset_tainted(unsigned long *tainted_ptr)
   1232 {
   1233     return test_and_clear_bit(TAINT_UNSIGNED_MODULE, tainted_ptr);
   1234 }
   1235 
   1236 #ifdef __x86_64__
   1237 #define _sys_arch(s) "__x64_" s
   1238 #else
   1239 #define _sys_arch(s) s
kLLDB> kdump registers
 CPU: 0, PID: 260
  RAX=0x0000000000000000  RBX=0xFFFFFFFFC000C020  RCX=0x0000000000000000  RDX=0x0000000000000000
  RSI=0xFFFF88807FC17470  RDI=0x0000000000000000  RBP=0xFFFFFFFFC000EB60  RSP=0xFFFFC900000B3DC0
   R8=0xFFFFFFFF82741968   R9=0x00000000FFFFDFFF  R10=0xFFFFFFFF82661980  R11=0xFFFFFFFF82661980
  R12=0xFFFF888005A98100  R13=0x000055C63C7FD45C  R14=0x0000000000000003  R15=0x0000000000000000
  RIP=0xFFFFFFFFC0003DD5  CS=0x0010  EFLAGS=0x00000246  SS=0x0018
  ORIG_RAX=0xFFFFFFFFFFFFFFFF
kLLDB> q
```

### Live debugging

In one terminal, run qemu as:

```
$ qemu-system-x86_64   -kernel "arch/x86/boot/bzImage" -append "root=/dev/sda rw console=ttyS0,115200 nokaslr init=/sbin/init" -drive format=raw,file=/path/to/rootfs.ext2  -device e1000,netdev=net0 -netdev user,id=net0,hostfwd=tcp::5555-:22,hostfwd=tcp::9999-:9999 -nographic -s -S
```

In second terminal, run the tool:

```
$ ./bin/kLLDB 
(lldb) command script import ./bin/kLLDB.py
kLLDB plugin initialized successfully.
kLLDB: Plugin loaded from /path/to/build/lib/libkLLDBLive.so
kLLDB: Ready
kLLDB> linux config /path/to/inux-5.15.15/vmlinux
kLLDB: vmlinux path set to: /path/to/linux-5.15.15/vmlinux
kLLDB> linux connect
Failed to connect to GDB stub at 127.0.0.1:1234
Process 1 stopped
* thread #1, stop reason = signal SIGTRAP
    frame #0: 0x000000000000fff0 vmlinux`exception_stacks + 16368
vmlinux`exception_stacks:
->  0xfff0 <+16368>: addb   %al, (%rax)
    0xfff2 <+16370>: addb   %al, (%rax)
    0xfff4 <+16372>: addb   %al, (%rax)
    0xfff6 <+16374>: addb   %al, (%rax)
kLLDB> linux continue
Failed to continue the process.
kLLDB> linux status
Process 1 is running.
kLLDB> linux stop
Process interrupted (like 'process interrupt').
Process 1 stopped
* thread #1, stop reason = signal SIGINT
    frame #0: 0xffffffff8102c57a vmlinux`amd_e400_idle [inlined] amd_e400_idle at process.c:780:3
   777 		 */
   778 		if (!boot_cpu_has_bug(X86_BUG_AMD_APIC_C1E)) {
   779 			default_idle();
-> 780 			return;
   781 		}
   782 	
   783 		tick_broadcast_enter();
kLLDB> bt
* thread #1, stop reason = signal SIGINT
  * frame #0: 0xffffffff8102c57a vmlinux`amd_e400_idle [inlined] amd_e400_idle at process.c:780:3
    frame #1: 0xffffffff8102c56f vmlinux`amd_e400_idle at process.c:771:13
    frame #2: 0xffffffff81c221af vmlinux`default_idle_call at idle.c:112:3
    frame #3: 0xffffffff810a0f44 vmlinux`do_idle [inlined] cpuidle_idle_call at idle.c:194:3
    frame #4: 0xffffffff810a0eec vmlinux`do_idle at idle.c:306:4
    frame #5: 0xffffffff810a1149 vmlinux`cpu_startup_entry(state=CPUHP_ONLINE) at idle.c:403:3
    frame #6: 0xffffffff82d991d7 vmlinux`start_kernel at main.c:1144:2
    frame #7: 0xffffffff81000107 vmlinux`secondary_startup_64 at head_64.S:283
kLLDB> q
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] n
kLLDB> list
   784 	
   785 		default_idle();
   786 	
   787 		/*
   788 		 * The switch back from broadcast mode needs to be called with
   789 		 * interrupts disabled.
   790 		 */
kLLDB> q
```

### Using LLM for bug report

Download LLM:

```
$ wget https://huggingface.co/lmstudio-community/DeepSeek-R1-Distill-Llama-8B-GGUF/resolve/main/DeepSeek-R1-Distill-Llama-8B-Q8_0.gguf
```

Download packages:

```
$ python3 -m venv kdump-venv
$ source kdump-venv/bin/activate
$ pip3 install pexpect llama-cpp-python
```

There is a Python script that uses local LLM that parses `kLLDB` analysis for bug reporting.
You can use it this way:

```

(kdump-venv) $ kLLDB/scripts/report-linux-bug.py --llm-path  /path/to/DeepSeek-R1-Distill-Llama-8B-Q8_0.gguf --lldb-path /usr/bin/lldb --kdump-plugin-path /path/to/libkLLDBOffline.so --vmlinux-path vmlinux --crash-file-path ./crash.file --lkm-path /path/to/lkm.ko --source-dir-old /remote-dir/ --source-dir-new /path-to-local-dir/ --report-file=bug-report-32.txt
$ cat bug-report-32.txt 
kLLDB sesion:
(lldb) target create vmlinux
Current executable set to '/path/to/KoviD/kovid/vmlinux' (x86_64).
(lldb) plugin load /path/to/NewKLLDB/build/lib/libkLLDBOffline.so
kLLDBOffline plugin loaded.
kLLDB> kdump open ./crash.file
Opened ./crash.file
kLLDB> kdump info
  Crash File: ./crash.file
  Release: 5.15.0
  Arch: x86_64
  Crash Time: 2025-03-26 08:15:11
  BUILD-ID: 5854168ecc422202ede0880ac960351c37b57faa
  PAGESIZE: 4096
  Crash PID: 260 CPU0
kLLDB> kdump load-lkm kovid.ko
kovid.ko loaded at 0xffffffffc0000000
kLLDB> kdump bugpoint
Instructon pointer at rip=0xffffffffc0003dd5
Blame function: kv_reset_tainted+5
kLLDB> kdump source-dir-map /kovid/ /path/to/KoviD/kovid
Mapped source directory '/kovid/' -> '/path/to/KoviD/kovid'
kLLDB> list kv_reset_tainted
File: /kovid/src/sys.c
   1226 
   1227     if (!within_module(parent_ip, THIS_MODULE))
   1228         regs->ip = (unsigned long)hook->function;
   1229 }
   1230 
   1231 int kv_reset_tainted(unsigned long *tainted_ptr)
   1232 {
   1233     return test_and_clear_bit(TAINT_UNSIGNED_MODULE, tainted_ptr);
   1234 }
   1235 
   1236 #ifdef __x86_64__
   1237 #define _sys_arch(s) "__x64_" s
   1238 #else
   1239 #define _sys_arch(s) s
kLLDB> kdump registers
 CPU: 0, PID: 260
  RAX=0x0000000000000000  RBX=0xFFFFFFFFC000C020  RCX=0x0000000000000000  RDX=0x0000000000000000
  RSI=0xFFFF88807FC17470  RDI=0x0000000000000000  RBP=0xFFFFFFFFC000EB60  RSP=0xFFFFC900000B3DC0
   R8=0xFFFFFFFF82741968   R9=0x00000000FFFFDFFF  R10=0xFFFFFFFF82661980  R11=0xFFFFFFFF82661980
  R12=0xFFFF888005A98100  R13=0x000055C63C7FD45C  R14=0x0000000000000003  R15=0x0000000000000000
  RIP=0xFFFFFFFFC0003DD5  CS=0x0010  EFLAGS=0x00000246  SS=0x0018
  ORIG_RAX=0xFFFFFFFFFFFFFFFF
kLLDB> q
Blame module: kovid.ko

=====

LLM report:
Alright, I'm trying to figure out why the Linux kernel is crashing with the given details. Let's start by looking at the information provided.

The crash is happening in the `kv_reset_tainted` function, specifically at an instruction pointer `0xffffffffc0003dd5`. The function is part of the `kovid.ko` module. The register dump shows that `RIP` is pointing to this function, so the crash is definitely happening inside `kv_reset_tainted`.

Looking at the function definition in `sys.c`, `kv_reset_tainted` takes a single argument `tainted_ptr`, which is a pointer to an unsigned long. The function uses `test_and_clear_bit` with `TAINT_UNSIGNED_MODULE` and `tainted_ptr` as arguments. 

In the register dump, the registers are in a state that might indicate an error. The `RAX` is zero, which might mean that the function isn't returning properly or there's an issue with the return value. The `RBX` has a value of `0xFFFFFFFFC000C020`, which is a 64-bit address, but I'm not sure if that's relevant here.

I notice that the function is called with a pointer, but in the register dump, `RDI` (the first argument) is zero. That's odd because `RDI` is the destination for the first argument of a function. If `tainted_ptr` is being passed as zero, that could cause issues because the function expects a valid pointer.

So, the likely cause is that `kv_reset_tainted` is being called with a null or invalid `tainted_ptr` argument. This might be due to a bug in the calling code that's not passing the correct pointer, or perhaps a null pointer dereference within the function itself.

To debug this, I should check how `kv_reset_tainted` is being called. If it's being called with a null pointer, that's a problem. Also, I should look into the context where `tainted_ptr` is being set to ensure it's not null before calling the function.

Another angle is to examine the `test_and_clear_bit` function to see if it's handling the `tainted_ptr` correctly, especially if it's not a valid pointer. Maybe there's a missing bounds check or a null pointer check that's causing the crash.

In summary, the crash is due to a null or invalid pointer being passed to `kv_reset_tainted`, leading to an issue
=====
```

```

`kLLDB.py`:

```py
# kLLDB by djolertrk

import lldb
import os

def __lldb_init_module(debugger, internal_dict):
    # Set the custom prompt for kLLDB
    debugger.HandleCommand("settings set prompt 'kLLDB> '")

    # Get the directory of this script (should be in bin/)
    script_dir = os.path.dirname(__file__)

    # Construct the path to the plugin in ../lib/
    plugin_path = os.path.join(script_dir, "..", "lib", "libkLLDBLive.so")
    plugin_path = os.path.abspath(plugin_path)

    # Load the plugin
    load_command = f"plugin load {plugin_path}"
    debugger.HandleCommand(load_command)

    print(f"kLLDB: Plugin loaded from {plugin_path}")
    print("kLLDB: Ready")

```

`kLLDB.sh`:

```sh
#!/bin/bash
SCRIPT_DIR="$(dirname "$0")"
PYTHON_SCRIPT="$SCRIPT_DIR/kLLDB.py"

# Launch LLDB and import the initialization script
lldb -o "command script import $PYTHON_SCRIPT" "$@"


```

`plugins/CMakeLists.txt`:

```txt
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

find_library(LLDB_LIBRARY
    NAMES lldb LLDB
    HINTS /usr/lib/llvm-19/lib/
)

include_directories(/usr/lib/llvm-19/include/)

add_library(kLLDBLive SHARED kLLDBLive.cpp)

set_target_properties(kLLDBLive PROPERTIES
  ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib"
  LIBRARY_OUTPUT_DIRECTORY  "${CMAKE_BINARY_DIR}/lib"
  RUNTIME_OUTPUT_DIRECTORY  "${CMAKE_BINARY_DIR}/bin"
)

find_library(KDUMPFILE_LIBRARY
    NAMES libkdumpfile.a
    HINTS /usr/local/lib /usr/lib
)
if(NOT KDUMPFILE_LIBRARY)
    message(FATAL_ERROR "Could not find libkdumpfile! Provide a HINTS or PATHS.")
endif()

find_library(ADDRXLAT_LIBRARY
    NAMES libaddrxlat.a
    HINTS /usr/local/lib /usr/lib
)
if(NOT ADDRXLAT_LIBRARY)
    message(FATAL_ERROR "Could not find libaddrxlat! Provide a HINTS or PATHS.")
endif()

message(STATUS "Found libkdumpfile at: ${KDUMPFILE_LIBRARY}")
message(STATUS "Found libaddrxlat at: ${ADDRXLAT_LIBRARY}")

add_library(kLLDBOffline SHARED kLLDBOffline.cpp)

target_link_libraries(kLLDBOffline PRIVATE
    ${LLDB_LIBRARY}
    ${KDUMPFILE_LIBRARY}
    ${ADDRXLAT_LIBRARY}
    z
)

set_target_properties(kLLDBOffline PROPERTIES
  ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib"
  LIBRARY_OUTPUT_DIRECTORY  "${CMAKE_BINARY_DIR}/lib"
  RUNTIME_OUTPUT_DIRECTORY  "${CMAKE_BINARY_DIR}/bin"
)

install(TARGETS kLLDBLive
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION bin
)

install(TARGETS kLLDBOffline
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION bin
)

```

`plugins/kLLDBLive.cpp`:

```cpp
//
// kLLDBLive.cpp by djolertrk
//

#include <lldb/API/SBAddress.h>
#include <lldb/API/SBCommandInterpreter.h>
#include <lldb/API/SBCommandReturnObject.h>
#include <lldb/API/SBDebugger.h>
#include <lldb/API/SBFrame.h>
#include <lldb/API/SBTarget.h>
#include <lldb/API/SBThread.h>
#include <lldb/API/SBValue.h>

#include <limits.h>
#include <sstream>
#include <sys/stat.h>
#include <unistd.h>

// Convenient macro to ensure the symbol remains in the plugin.
#define API __attribute__((used))

using namespace lldb;

static std::string g_vmlinux_path = "vmlinux";

static std::vector<std::string> g_module_search_paths;

static bool FileExists(const std::string &path) {
  struct stat st;
  return (stat(path.c_str(), &st) == 0);
}

// Utility to make path absolute via realpath() if possible
static std::string MakeAbsolutePath(const std::string &path) {
  char resolved[PATH_MAX];
  if (realpath(path.c_str(), resolved)) {
    return std::string(resolved);
  }
  // If realpath fails (e.g. file doesn't exist yet), fallback:
  return path;
}

class LxSymbolsCommand : public SBCommandPluginInterface {
public:
  bool DoExecute(SBDebugger debugger, char **command,
                 SBCommandReturnObject &result) override {

    // 1) Collect all arguments as .ko file paths
    std::vector<std::string> ko_paths;
    while (command && command[0]) {
      std::string arg = command[0];
      command++;
      ko_paths.push_back(arg);
    }

    if (ko_paths.empty()) {
      result.AppendMessage("Usage: linux symbols /path/to/module.ko [...]\n");
      result.SetStatus(eReturnStatusFailed);
      return false;
    }

    // 2) Create or re-create the main kernel target from g_vmlinux_path
    SBTarget target = debugger.GetSelectedTarget();
    if (target.IsValid()) {
      // If already valid, remove it to get a clean slate
      debugger.DeleteTarget(target);
    }

    SBError error;
    target = debugger.CreateTarget(g_vmlinux_path.c_str(), nullptr, nullptr,
                                   false, error);
    if (!target.IsValid() || error.Fail()) {
      std::stringstream msg;
      msg << "Failed to create target from '" << g_vmlinux_path << "'\n"
          << "LLDB error: " << error.GetCString() << "\n";
      result.AppendMessage(msg.str().c_str());
      result.SetStatus(eReturnStatusFailed);
      return false;
    }

    // 3) For each .ko path, convert to absolute, then run "target modules add
    // <path>"
    //    This is the simplest approach to have LLDB parse the .ko as a module.
    for (auto &rel_path : ko_paths) {
      std::string abs_path = MakeAbsolutePath(rel_path);

      // Also check existence before passing to LLDB
      if (!FileExists(abs_path)) {
        std::stringstream msg;
        msg << "Skipping '" << rel_path << "': file not found.\n";
        result.AppendMessage(msg.str().c_str());
        continue;
      }

      std::string cmd = "target modules add \"" + abs_path + "\"";
      SBCommandReturnObject cmd_result;
      debugger.GetCommandInterpreter().HandleCommand(cmd.c_str(), cmd_result);

      if (cmd_result.GetStatus() != eReturnStatusSuccessFinishResult) {
        std::stringstream msg;
        msg << "Failed to add module '" << abs_path
            << "': " << cmd_result.GetError() << "\n";
        result.AppendMessage(msg.str().c_str());
      } else {
        std::stringstream msg;
        msg << "Added module: " << abs_path << "\n";
        result.AppendMessage(msg.str().c_str());
      }
    }

    // 4) Done
    result.AppendMessage("linux-symbols: All requested modules processed.\n");
    result.SetStatus(eReturnStatusSuccessFinishResult);
    return true;
  }
};

class LxConfigCommand : public SBCommandPluginInterface {
public:
  bool DoExecute(SBDebugger debugger, char **command,
                 SBCommandReturnObject &result) override {
    if (!command || !command[0]) {
      std::stringstream msg;
      msg << "Current vmlinux path: " << g_vmlinux_path << "\n";
      msg << "Usage: linux config /path/to/vmlinux\n";
      result.AppendMessage(msg.str().c_str());
      result.SetStatus(eReturnStatusFailed);
      return false;
    }

    g_vmlinux_path = command[0];

    std::stringstream msg;
    msg << "kLLDB: vmlinux path set to: " << g_vmlinux_path << "\n";
    result.AppendMessage(msg.str().c_str());
    result.SetStatus(eReturnStatusSuccessFinishResult);
    return true;
  }
};

class LxConnectCommand : public SBCommandPluginInterface {
public:
  bool DoExecute(SBDebugger debugger, char **command,
                 SBCommandReturnObject &result) override {
    // Figure out the port spec
    // If user typed "linux connect :1234", prepend "127.0.0.1"
    // Default is "127.0.0.1:1234"
    std::string host_port = "127.0.0.1:1234";
    if (command && command[0]) {
      host_port = command[0];
      if (!host_port.empty() && host_port.front() == ':') {
        host_port = "127.0.0.1" + host_port; // => "127.0.0.1:1234"
      }
    }

    // Create an LLDB target object directly via the API
    SBError error;
    SBTarget target = debugger.CreateTarget(g_vmlinux_path.c_str(), // file
                                            nullptr,                // triple
                                            nullptr,                // platform
                                            false, // add_dependent_modules
                                            error);
    if (error.Fail() || !target.IsValid()) {
      std::stringstream msg;
      msg << "Failed to create target with '" << g_vmlinux_path << "'\n"
          << "LLDB error: " << error.GetCString();
      result.AppendMessage(msg.str().c_str());
      result.SetStatus(eReturnStatusFailed);
      return false;
    }

    // Connect to QEMU’s GDB stub via the process connect command
    std::string connect_cmd = "gdb-remote " + host_port;

    SBCommandReturnObject connect_result;
    debugger.GetCommandInterpreter().HandleCommand(connect_cmd.c_str(),
                                                   connect_result);

    if (connect_result.GetStatus() != eReturnStatusSuccessFinishResult) {
      std::stringstream msg;
      msg << "Failed to connect to GDB stub at " << host_port << "\n"
          << connect_result.GetError();
      result.AppendMessage(msg.str().c_str());
      result.SetStatus(eReturnStatusFailed);
      return false;
    }

    // If all is well
    std::stringstream msg;
    msg << "kLLDB: Connected to GDB stub at " << host_port << "\n"
        << "Using vmlinux path: " << g_vmlinux_path << "\n";
    result.AppendMessage(msg.str().c_str());
    result.SetStatus(eReturnStatusSuccessFinishResult);
    return true;
  }
};

// Command: linux linux stop
class LxLinuxStopCommand : public lldb::SBCommandPluginInterface {
public:
  bool DoExecute(lldb::SBDebugger debugger, char **command,
                 lldb::SBCommandReturnObject &result) override {
    lldb::SBCommandReturnObject interrupt_result;
    debugger.GetCommandInterpreter().HandleCommand("process interrupt",
                                                   interrupt_result);

    if (interrupt_result.GetStatus() ==
        lldb::eReturnStatusSuccessFinishResult) {
      result.AppendMessage("Process interrupted (like 'process interrupt').\n");
      result.SetStatus(lldb::eReturnStatusSuccessFinishResult);
    } else {
      result.AppendMessage("Failed to interrupt the process.\n");
      result.SetStatus(lldb::eReturnStatusFailed);
    }
    return true;
  }
};

// Command: linux linux status
class LxLinuxStatusCommand : public lldb::SBCommandPluginInterface {
public:
  bool DoExecute(lldb::SBDebugger debugger, char **command,
                 lldb::SBCommandReturnObject &result) override {
    lldb::SBCommandReturnObject status_result;
    debugger.GetCommandInterpreter().HandleCommand("process status",
                                                   status_result);

    // Pass the status output to our caller
    result.AppendMessage(status_result.GetOutput());
    // The sub-command's status is success if the underlying command succeeded
    if (status_result.GetStatus() == lldb::eReturnStatusSuccessFinishResult) {
      result.SetStatus(lldb::eReturnStatusSuccessFinishResult);
    } else {
      result.SetStatus(lldb::eReturnStatusFailed);
    }
    return true;
  }
};

class LxLinuxContinueCommand : public lldb::SBCommandPluginInterface {
public:
  bool DoExecute(lldb::SBDebugger debugger, char **command,
                 lldb::SBCommandReturnObject &result) override {
    // 1) Make sure we have a valid target
    SBTarget target = debugger.GetSelectedTarget();
    if (!target.IsValid()) {
      result.AppendMessage("No valid target selected.\n");
      result.SetStatus(lldb::eReturnStatusFailed);
      return false;
    }

    // 2) Make sure we have a valid process
    SBProcess process = target.GetProcess();
    if (!process.IsValid()) {
      result.AppendMessage("No valid process. Must be connected.\n");
      result.SetStatus(lldb::eReturnStatusFailed);
      return false;
    }

    // 3) Force synchronous mode if you want GDB-like blocking
    //    Telling LLDB "run in sync mode"
    debugger.SetAsync(false);

    // 4) Actually continue via the SB API
    SBError err = process.Continue();
    if (err.Fail()) {
      // 'Continue()' can fail if the process is not in a "stopped" state or if
      // there's an internal LLDB error.
      std::stringstream msg;
      msg << "Failed to continue the process: " << err.GetCString();
      result.AppendMessage(msg.str().c_str());
      result.SetStatus(lldb::eReturnStatusFailed);
      return false;
    }

    // If we get here, LLDB is blocking until the target stops again (breakpoint
    // or manual interrupt).
    // Once the target is stopped, we resume control in the plugin code:
    result.AppendMessage("Process continued synchronously.\n");
    result.SetStatus(lldb::eReturnStatusSuccessFinishResult);
    return true;
  }
};

//
// Plugin initialization entry point for LLDB 10+
//
namespace lldb {
bool PluginInitialize(SBDebugger debugger) {
  SBCommandInterpreter interpreter = debugger.GetCommandInterpreter();
  debugger.SetPrompt("kLLDB> ");

  // Create a multiword command group named "linux" for Linux kernel helper
  // commands
  SBCommand linuxGroup =
      interpreter.AddMultiwordCommand("linux", "Linux kernel helper commands");
  if (linuxGroup.IsValid()) {
    linuxGroup.AddCommand("symbols", new LxSymbolsCommand(),
                          "Load Linux kernel and module symbols", nullptr);

    linuxGroup.AddCommand(
        "config", new LxConfigCommand(),
        "Set or show the path to vmlinux. Usage: linux config /path/to/vmlinux",
        nullptr);

    // Add subcommand: connect
    linuxGroup.AddCommand(
        "connect", new LxConnectCommand(),
        "Connect to a remote GDB server. Usage: linux connect :1234", nullptr);

    linuxGroup.AddCommand("stop", new LxLinuxStopCommand(),
                          "Interrupt linux kernel process.", nullptr);

    linuxGroup.AddCommand("status", new LxLinuxStatusCommand(),
                          "Show linux kernel process status).", nullptr);

    linuxGroup.AddCommand("continue", new LxLinuxContinueCommand(),
                          "Continue linux kernel process execution.", nullptr);
  }

  // Inform the user that the plugin loaded successfully
  printf("kLLDB plugin initialized successfully.\n");
  return true;
}
} // namespace lldb

```

`plugins/kLLDBOffline.cpp`:

```cpp
//
// kLLDB - offline deubg of kdump crash files
// by djolertrk
//

#include <lldb/API/LLDB.h>
#include <lldb/API/SBAddress.h>
#include <lldb/API/SBBlock.h>
#include <lldb/API/SBCommandInterpreter.h>
#include <lldb/API/SBCommandReturnObject.h>
#include <lldb/API/SBDebugger.h>
#include <lldb/API/SBError.h>
#include <lldb/API/SBFileSpec.h>
#include <lldb/API/SBModule.h>
#include <lldb/API/SBSection.h>
#include <lldb/API/SBSymbol.h>
#include <lldb/API/SBSymbolContext.h>
#include <lldb/API/SBTarget.h>

#include <llvm/Object/Binary.h>
#include <llvm/Object/ELF.h>
#include <llvm/Object/ObjectFile.h>
#include <llvm/Object/SymbolSize.h>
#include <llvm/Support/Error.h>
#include <llvm/Support/MemoryBuffer.h>
#include <llvm/Support/raw_ostream.h>

#include <libkdumpfile/kdumpfile.h>

#include <algorithm>
#include <cinttypes>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fcntl.h>
#include <iomanip>
#include <map>
#include <sstream>
#include <string>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>
#include <vector>

struct X86_64_Regs {
  uint64_t r15, r14, r13, r12;
  uint64_t rbp, rbx, r11, r10;
  uint64_t r9, r8, rax, rcx;
  uint64_t rdx, rsi, rdi, orig_rax;
  uint64_t rip, cs, eflags, rsp, ss;

  X86_64_Regs() { ::memset(this, 0, sizeof(*this)); }
};

struct ThreadInfo {
  uint64_t tid; // from "cpu.#.pid"
  X86_64_Regs regs;

  std::string comm;     // from "cpu.#.comm" (if available)
  uint64_t task;        // from "cpu.#.task" (if available)
  uint64_t thread_info; // from "cpu.#.thread_info" (if available)
  uint64_t cpu_index;   // to keep track of CPU # (optional)
};

// TODO: For targets other than x86_64, this needs to be fixed.
#define ELF_NGREG 27
struct timeval_64 {
  int64_t tv_sec;
  int64_t tv_usec;
} __attribute__((packed));

struct elf_prstatus {
  struct {
    int32_t si_signo;
    int32_t si_code;
    int32_t si_errno;
  } __attribute__((packed)) pr_info;
  int16_t pr_cursig;
  char _pad1[2];
  uint64_t pr_sigpend;
  uint64_t pr_sighold;
  int32_t pr_pid;
  int32_t pr_ppid;
  int32_t pr_pgrp;
  int32_t pr_sid;
  struct timeval_64 pr_utime;
  struct timeval_64 pr_stime;
  struct timeval_64 pr_cutime;
  struct timeval_64 pr_cstime;
  uint64_t pr_reg[ELF_NGREG];
} __attribute__((packed));

struct _kdump_blob {
  /** Reference counter. */
  unsigned long refcnt;

  /** Pin counter. */
  unsigned long pincnt;

  void *data;  /**< Binary data. */
  size_t size; /**< Size of binary data. */
};

//--------------------------------------------------------------------------------------
// KdumpBackend: uses libkdumpfile for reading a kdump
//--------------------------------------------------------------------------------------

class KdumpBackend {
public:
  KdumpBackend() : m_ctx(nullptr), m_is_open(false) {}

  ~KdumpBackend() { Close(); }

  bool Open(const std::string &path) {
    Close();

    m_ctx = kdump_new();
    if (!m_ctx) {
      m_err = "kdump_new() failed";
      return false;
    }

    int fd = ::open(path.c_str(), O_RDONLY);
    if (fd < 0) {
      m_err = "Cannot open file: " + path;
      kdump_free(m_ctx);
      m_ctx = nullptr;
      return false;
    }

    kdump_status st = kdump_open_fd(m_ctx, fd);
    ::close(fd);
    if (st != KDUMP_OK) {
      m_err = std::string("kdump_open_fd() failed: ") + kdump_get_err(m_ctx);
      kdump_free(m_ctx);
      m_ctx = nullptr;
      return false;
    }

    ParseCpus();
    m_is_open = true;
    return true;
  }

  void Close() {
    if (m_ctx) {
      kdump_free(m_ctx);
      m_ctx = nullptr;
    }
    m_threads.clear();
    m_is_open = false;
  }

  bool IsOpen() const { return m_is_open; }

  std::string GetError() const { return m_err; }

  const std::vector<ThreadInfo> &GetThreads() const { return m_threads; }

  // A minimal read from kernel VA
  bool ReadMemory(uint64_t va, void *buf, size_t size) {
    if (!m_ctx) {
      return false;
    }

    uint8_t *dst = static_cast<uint8_t *>(buf);
    size_t done = 0;
    while (done < size) {
      size_t chunk = size - done;
      size_t got = chunk;
      kdump_status s = kdump_read(m_ctx, KDUMP_KVADDR,
                                  (kdump_addr_t)(va + done), dst + done, &got);
      if (s != KDUMP_OK || got == 0) {
        // zero fill remainder
        ::memset(dst + done, 0, chunk);
        return false;
      }
      done += got;
    }
    return true;
  }

  // read a top-level attribute
  std::string GetAttrString(const std::string &path) {
    if (!m_ctx)
      return "";
    kdump_attr_ref_t ref;
    if (kdump_attr_ref(m_ctx, path.c_str(), &ref) != KDUMP_OK)
      return "";

    kdump_attr_t a;
    if (kdump_attr_ref_get(m_ctx, &ref, &a) != KDUMP_OK) {
      kdump_attr_unref(m_ctx, &ref);
      return "";
    }

    std::string result;
    if (a.type == KDUMP_STRING && a.val.string) {
      result = a.val.string;
    } else if (a.type == KDUMP_NUMBER) {
      char tmp[64];
      ::snprintf(tmp, sizeof(tmp), "%" PRIu64, a.val.number);
      result = tmp;
    }

    kdump_attr_discard(m_ctx, &a);
    kdump_attr_unref(m_ctx, &ref);
    return result;
  }

private:
  // Read process/thread data from "cpu".
  void ParseCpus() {
    if (!m_ctx)
      return;

    // Get a reference to the "cpu" attribute
    kdump_attr_ref_t cpuRef;
    if (kdump_attr_ref(m_ctx, "cpu", &cpuRef) != KDUMP_OK)
      return;

    // Start iteration over all cpu.<N> subkeys
    kdump_attr_iter_t it;
    if (kdump_attr_ref_iter_start(m_ctx, &cpuRef, &it) != KDUMP_OK) {
      kdump_attr_unref(m_ctx, &cpuRef);
      return;
    }

    while (it.key) {
      ThreadInfo thr;
      std::memset(&thr, 0, sizeof(thr));

      // (1) CPU index from "cpu.<key>"
      thr.cpu_index = strtoull(it.key, nullptr, 10); // e.g. "0"

      // (2) TID from "cpu.#.pid"
      {
        std::string ppath = std::string("cpu.") + it.key + ".pid";
        kdump_attr_ref_t pRef;
        if (kdump_attr_ref(m_ctx, ppath.c_str(), &pRef) == KDUMP_OK) {
          kdump_attr_t a;
          if (kdump_attr_ref_get(m_ctx, &pRef, &a) == KDUMP_OK) {
            if (a.type == KDUMP_NUMBER) {
              thr.tid = a.val.number;
            }
            kdump_attr_discard(m_ctx, &a);
          }
          kdump_attr_unref(m_ctx, &pRef);
        }
      }

      // We can do:
      // thr.regs.rip = ReadReg(it.key, "rip");
      // thr.regs.rbp = ReadReg(it.key, "rbp");
      // etc. but will do prstatus parse.

      // Now parse PRSTATUS for the *full* register set, if present
      {
        std::string prPath = std::string("cpu.") + it.key + ".PRSTATUS";
        kdump_attr_ref_t prRef;
        if (kdump_attr_ref(m_ctx, prPath.c_str(), &prRef) == KDUMP_OK) {
          kdump_attr_t prAtt;
          if (kdump_attr_ref_get(m_ctx, &prRef, &prAtt) == KDUMP_OK) {
            // Check for KDUMP_BLOB type, then the size
            if (prAtt.type == KDUMP_BLOB && prAtt.val.blob) {
              size_t sz = prAtt.val.blob->size;
              if (sz >= sizeof(elf_prstatus)) {
                elf_prstatus prs;
                std::memcpy(&prs, prAtt.val.blob->data, sizeof(prs));

                // Overwrite tid from pr_pid
                thr.tid = prs.pr_pid;

                // x86_64 pr_reg[]: 0=R15,1=R14,2=R13,3=R12,4=RBP,5=RBX,...
                thr.regs.r15 = prs.pr_reg[0];
                thr.regs.r14 = prs.pr_reg[1];
                thr.regs.r13 = prs.pr_reg[2];
                thr.regs.r12 = prs.pr_reg[3];
                thr.regs.rbp = prs.pr_reg[4];
                thr.regs.rbx = prs.pr_reg[5];
                thr.regs.r11 = prs.pr_reg[6];
                thr.regs.r10 = prs.pr_reg[7];
                thr.regs.r9 = prs.pr_reg[8];
                thr.regs.r8 = prs.pr_reg[9];
                thr.regs.rax = prs.pr_reg[10];
                thr.regs.rcx = prs.pr_reg[11];
                thr.regs.rdx = prs.pr_reg[12];
                thr.regs.rsi = prs.pr_reg[13];
                thr.regs.rdi = prs.pr_reg[14];
                thr.regs.orig_rax = prs.pr_reg[15];
                thr.regs.rip = prs.pr_reg[16];
                thr.regs.cs = prs.pr_reg[17];
                thr.regs.eflags = prs.pr_reg[18];
                thr.regs.rsp = prs.pr_reg[19];
                thr.regs.ss = prs.pr_reg[20];
                // TODO: parse fs_base, gs_base, ds, es, fs, gs etc.
              }
            }
            kdump_attr_discard(m_ctx, &prAtt);
          }
          kdump_attr_unref(m_ctx, &prRef);
        }
      }

      // push the thread in the vector
      m_threads.push_back(thr);

      // iterate next CPU
      if (kdump_attr_iter_next(m_ctx, &it) != KDUMP_OK) {
        break;
      }
    }

    kdump_attr_iter_end(m_ctx, &it);
    kdump_attr_unref(m_ctx, &cpuRef);
  }

  uint64_t ReadReg(const std::string &cpuKey, const std::string &regName) {
    std::string path = "cpu." + cpuKey + ".reg." + regName;
    kdump_attr_ref_t ref;
    if (kdump_attr_ref(m_ctx, path.c_str(), &ref) != KDUMP_OK) {
      return 0;
    }
    kdump_attr_t a;
    if (kdump_attr_ref_get(m_ctx, &ref, &a) != KDUMP_OK) {
      kdump_attr_unref(m_ctx, &ref);
      return 0;
    }
    uint64_t val = 0;
    if (a.type == KDUMP_NUMBER) {
      val = a.val.number;
    }
    kdump_attr_discard(m_ctx, &a);
    kdump_attr_unref(m_ctx, &ref);
    return val;
  }

private:
  kdump_ctx_t *m_ctx;
  bool m_is_open;
  std::string m_err;
  std::vector<ThreadInfo> m_threads;
};

static KdumpBackend g_kdump;
static std::string g_coreFilePath;

static bool SafeReadU64(uint64_t va, uint64_t &val) {
  val = 0;
  uint8_t tmp[8];
  if (!g_kdump.ReadMemory(va, tmp, sizeof(tmp))) {
    return false;
  }
  val = *(const uint64_t *)(tmp);
  return true;
}

struct Frame {
  uint64_t rip;
  uint64_t rbp;
};

static std::vector<Frame> WalkStack_RBP(uint64_t rip, uint64_t rbp) {
  std::vector<Frame> frames;
  frames.reserve(64);

  frames.push_back({rip, rbp});

  for (int i = 0; i < 63; i++) {
    uint64_t nrip = 0, nrbp = 0;
    if (!SafeReadU64(rbp, nrbp))
      break;
    if (!SafeReadU64(rbp + 8, nrip))
      break;
    if (nrbp <= rbp)
      break;
    if (nrip < 0xffffffff80000000ULL)
      break;

    frames.push_back({nrip, nrbp});
    rbp = nrbp;
  }
  return frames;
}

//--------------------------------------------------------------------------------------
// Commands
//--------------------------------------------------------------------------------------

// TODO: Check Linux 6.x
class CoreLoadLKMCommand : public lldb::SBCommandPluginInterface {
public:
  bool DoExecute(lldb::SBDebugger dbg, char **cmd,
                 lldb::SBCommandReturnObject &res) override {
    // Check if we have a valid dump file loaded
    if (!g_kdump.IsOpen()) {
      res.AppendMessage("No open kdump. 'kdump open <crash file>' first.");
      return false;
    }

    // Ensure the user has provided the .ko path
    if (!cmd || !cmd[0]) {
      res.AppendMessage("Usage: kdump load-lkm <module-path.ko>");
      return false;
    }

    // Retrieve the kernel release from the kdump. (e.g.
    // "5.15.0-051500-generic")
    std::string release = g_kdump.GetAttrString("linux.uts.release");
    if (release.empty()) {
      res.AppendMessage(
          "Warning: kernel version (linux.uts.release) not found. "
          "The default LKM load address may be incorrect!");
    } else {
      // Simple check: if "5.15." is not present, warn the user
      if (release.find("5.15.") == std::string::npos) {
        std::ostringstream warn;
        warn << "Warning: kernel version is '" << release
             << "', which is NOT 5.15.x. The default LKM load address "
                "(0xffffffffc0000000) may be incorrect!";
        res.AppendMessage(warn.str().c_str());
      }
    }

    static bool lkm_loaded = false;
    if (lkm_loaded) {
      // Already loaded once this session
      res.AppendMessage("LKM already loaded, ignoring.");
      return true;
    }

    std::string lkmPath = cmd[0];

    // Ensure we have a valid target (the user presumably has done "target
    // create vmlinux")
    lldb::SBTarget target = dbg.GetSelectedTarget();
    if (!target.IsValid()) {
      res.AppendMessage(
          "No valid target. Use 'target create vmlinux' or 'kdump open'.");
      return false;
    }

    // Actually load the module at slide 0xffffffffc0000000
    // 1) Add the image
    {
      std::ostringstream oss;
      oss << "image add " << lkmPath;
      dbg.HandleCommand(oss.str().c_str());
    }

    // 2) Then load with --slide
    {
      std::ostringstream oss;
      oss << "image load --file " << lkmPath << " --slide 0xffffffffc0000000";
      dbg.HandleCommand(oss.str().c_str());
    }

    // Mark as loaded
    lkm_loaded = true;

    // Success message
    std::ostringstream msg;
    msg << lkmPath << " loaded at 0xffffffffc0000000";
    res.AppendMessage(msg.str().c_str());

    return true;
  }
};

class CoreSourceDirMapCommand : public lldb::SBCommandPluginInterface {
public:
  bool DoExecute(lldb::SBDebugger dbg, char **cmd,
                 lldb::SBCommandReturnObject &res) override {
    // Basic usage check
    if (!cmd || !cmd[0] || !cmd[1]) {
      res.AppendMessage("Usage: kdump source-dir-map <fromDir> <toDir>");
      return false;
    }

    std::string fromDir = cmd[0];
    std::string toDir = cmd[1];

    // We assume a valid target is open, but it's not strictly required to do
    // source mapping.
    lldb::SBTarget target = dbg.GetSelectedTarget();
    if (!target.IsValid()) {
      res.AppendMessage("Warning: No valid target. Mapping anyway.");
    }

    // Build and execute the actual LLDB command:
    //  settings set target.source-map <fromDir> <toDir>
    std::ostringstream oss;
    oss << "settings set target.source-map " << fromDir << " " << toDir;

    dbg.HandleCommand(oss.str().c_str());

    // Confirm success
    std::ostringstream msg;
    msg << "Mapped source directory '" << fromDir << "' -> '" << toDir << "'";
    res.AppendMessage(msg.str().c_str());

    return true;
  }
};

// TODO: Fix this for other kernels e.g. 6.x
static constexpr uint64_t MODULE_BASE = 0xffffffffc0000000;

// Helper to find the "best" symbol for an offset.
// Returns (symbolName, offsetInSymbol).
static std::pair<std::string, uint64_t>
FindSymbolInModule(llvm::StringRef koPath, uint64_t moduleOffset) {
  namespace obj = llvm::object;

  // Prepare return values (if fail, return something plausible)
  std::string bestName = "<unknown>";
  uint64_t offsetIntoSym = moduleOffset;

  // Load the .ko file into memory
  auto binOrErr = obj::createBinary(koPath);
  if (!binOrErr) {
    // In real code, you should log or print
    // llvm::toString(binOrErr.takeError())
    return {bestName, offsetIntoSym};
  }

  // We expect a valid object file
  obj::Binary &bin = *binOrErr.get().getBinary();
  auto *objFile = llvm::dyn_cast<obj::ObjectFile>(&bin);
  if (!objFile) {
    return {bestName, offsetIntoSym};
  }

  // We will find the symbol whose "Value" is <= moduleOffset,
  // and is the largest such Value (i.e. the nearest preceding symbol).
  // E.g. if offset is 0x3dd5, we want the symbol that starts at or before
  // 0x3dd5.
  uint64_t bestSymAddr = 0;
  for (auto sym : objFile->symbols()) {
    // Symbol must be in the .text or other relevant section (STT_FUNC).
    // We can check type or flags if desired:
    auto symType = sym.getType();
    if (!symType) // if error
      continue;
    if (*symType != obj::SymbolRef::ST_Function &&
        *symType != obj::SymbolRef::ST_Data &&
        *symType != obj::SymbolRef::ST_Unknown) {
      // For kernel modules, sometimes STT_NOTYPE is used; we can relax checks
      continue;
    }

    // Get symbol address (Value)
    llvm::Expected<uint64_t> addrOrErr = sym.getValue();
    if (!addrOrErr)
      continue;
    uint64_t symAddr = *addrOrErr; // offset within the module file

    // If symbol name is not available, skip
    llvm::Expected<llvm::StringRef> nameOrErr = sym.getName();
    if (!nameOrErr)
      continue;
    llvm::StringRef symName = *nameOrErr;
    if (symName.empty())
      continue;

    // We want the symbol that starts <= moduleOffset, but is closest
    if (symAddr <= moduleOffset && symAddr >= bestSymAddr) {
      bestSymAddr = symAddr;
      bestName = symName.str();
    }
  }

  // The offset within that symbol is (moduleOffset - bestSymAddr)
  offsetIntoSym = moduleOffset - bestSymAddr;
  return {bestName, offsetIntoSym};
}

/// A helper to get the path from an SBFileSpec in a portable way
static std::string GetFileSpecPath(const lldb::SBFileSpec &fspec) {
  if (!fspec.IsValid())
    return std::string();
  char path_buf[1024];
  uint32_t len = fspec.GetPath(path_buf, sizeof(path_buf));
  if (len == 0)
    return std::string();
  return std::string(path_buf);
}

static bool FindModuleForAddress(lldb::SBTarget &target, uint64_t rip,
                                 std::string &outModulePath) {
  uint32_t numMods = target.GetNumModules();
  for (uint32_t i = 0; i < numMods; ++i) {
    lldb::SBModule mod = target.GetModuleAtIndex(i);
    if (!mod.IsValid())
      continue;

    uint32_t numSecs = mod.GetNumSections();
    for (uint32_t s = 0; s < numSecs; ++s) {
      lldb::SBSection sec = mod.GetSectionAtIndex(s);
      if (!sec.IsValid())
        continue;

      // The load address is fetched from the section object, not from the
      // target
      uint64_t secLoadAddr = sec.GetLoadAddress(target);
      uint64_t secSize = sec.GetByteSize();
      if (secLoadAddr == LLDB_INVALID_ADDRESS)
        continue;

      // Check if rip lies within [secLoadAddr, secLoadAddr+secSize)
      if (rip >= secLoadAddr && rip < (secLoadAddr + secSize)) {
        lldb::SBFileSpec fspec = mod.GetFileSpec();
        std::string dir(fspec.GetDirectory());
        std::string fname(fspec.GetFilename());
        if (!dir.empty()) {
          outModulePath = dir + "/" + fname;
        } else {
          outModulePath = fname;
        }
        return true;
      }
    }
  }
  return false; // not found
}

class CoreBugpointCommand : public lldb::SBCommandPluginInterface {
public:
  bool DoExecute(lldb::SBDebugger dbg, char **cmd,
                 lldb::SBCommandReturnObject &res) override {
    // Ensure we have a valid kdump
    if (!g_kdump.IsOpen()) {
      res.AppendMessage("No open kdump. 'kdump open <crash file>' first.");
      return false;
    }

    lldb::SBTarget target = dbg.GetSelectedTarget();
    if (!target.IsValid()) {
      res.AppendMessage("No valid target - 'target create vmlinux' maybe?");
      return false;
    }

    // Pick CPU #0 / first thread
    auto &threads = g_kdump.GetThreads();
    if (threads.empty()) {
      res.AppendMessage("No threads in dump!");
      return false;
    }

    const auto &r = threads[0].regs;
    uint64_t rip = r.rip;
    uint64_t rbp = r.rbp;

    // Perform naive RBP-based backtrace
    auto frames = WalkStack_RBP(rip, rbp);

    // Now for each frame, we compute offset from module base
    // and parse the .ko to find the function symbol
    for (size_t i = 0; i < frames.size(); i++) {
      // Print the raw RIP/RBP
      char line[256];
      // ::snprintf(line, sizeof(line),
      //            "#%zu  rip=0x%016" PRIx64 "  rbp=0x%016" PRIx64,
      //            i, frames[i].rip, frames[i].rbp);
      ::snprintf(line, sizeof(line),
                 "Instructon pointer at rip=0x%016" PRIx64 "", frames[i].rip);
      res.AppendMessage(line);

      std::string blameModulePath;
      uint64_t offset = frames[i].rip;
      if (!FindModuleForAddress(target, offset, blameModulePath)) {
        char err_line[128];
        ::snprintf(err_line, sizeof(err_line),
                   "Unable to find loaded module with address 0x%016" PRIx64 "",
                   frames[i].rip);
        res.AppendMessage(err_line);
        return false;
      }

      std::ostringstream oss;
      if (!blameModulePath.empty()) {
        llvm::outs() << "Blame module: " << blameModulePath << "\n";
        res.AppendMessage(oss.str().c_str());
      }

      // If the RIP is in range for our lkm ko, let's parse that .ko file
      // This is just a check if rip >= MODULE_BASE, < MODULE_BASE +
      // (size?) Let's do a simple check if it's >= base (and < base+someMax).
      // For a real check, you might parse sections to see actual .text size.
      // Otherwise we assume the address is good - from vmlinux.
      if (frames[i].rip >= MODULE_BASE &&
          frames[i].rip < (MODULE_BASE + 0x100000)) {
        offset = frames[i].rip - MODULE_BASE;
      }

      // Manually parse the .ko symbol table
      auto sym = FindSymbolInModule(blameModulePath, offset);
      if (!sym.first.empty()) {
        // If we found a symbol, print it
        oss << "Blame function: " << sym.first;
        if (sym.second) {
          oss << "+" << sym.second;
        }
        res.AppendMessage(oss.str().c_str());
      }
    }

    return true;
  }
};

class CoreInfoCommand : public lldb::SBCommandPluginInterface {
public:
  bool DoExecute(lldb::SBDebugger dbg, char **cmd,
                 lldb::SBCommandReturnObject &res) override {
    if (!g_kdump.IsOpen()) {
      res.AppendMessage("No open kdump for 'info'");
      return false;
    }
    // example: read some stuff
    std::string release = g_kdump.GetAttrString("linux.uts.release");
    std::string arch = g_kdump.GetAttrString("arch.name");
    std::string ctime =
        g_kdump.GetAttrString("linux.vmcoreinfo.lines.CRASHTIME");
    std::string buildid =
        g_kdump.GetAttrString("linux.vmcoreinfo.lines.BUILD-ID");
    std::string pagesize =
        g_kdump.GetAttrString("linux.vmcoreinfo.lines.PAGESIZE");

    std::string timestr = "(none)";
    if (!ctime.empty()) {
      unsigned long long epoch = 0ULL;
      ::sscanf(ctime.c_str(), "%llu", &epoch);
      if (epoch != 0ULL) {
        time_t rawt = (time_t)epoch;
        struct tm tmpbuf;
        if (localtime_r(&rawt, &tmpbuf)) {
          char tbuf[64];
          ::strftime(tbuf, sizeof(tbuf), "%Y-%m-%d %H:%M:%S", &tmpbuf);
          timestr = tbuf;
        }
      }
    }

    std::ostringstream oss;
    oss << "  Crash File: " << g_coreFilePath << "\n"
        << "  Release: " << release << "\n"
        << "  Arch: " << arch << "\n"
        << "  Crash Time: " << timestr << "\n"
        << "  BUILD-ID: " << buildid << "\n"
        << "  PAGESIZE: " << pagesize << "\n";

    auto &threads = g_kdump.GetThreads();
    for (size_t i = 0; i < threads.size(); i++) {
      const ThreadInfo &th = threads[i];
      // skip PID == 0.
      if (th.tid == 0)
        continue;

      oss << "  Crash PID: " << th.tid << " CPU" << th.cpu_index << '\n';
    }

    res.AppendMessage(oss.str().c_str());
    return true;
  }
};

class CoreRegistersCommand : public lldb::SBCommandPluginInterface {
public:
  bool DoExecute(lldb::SBDebugger dbg, char **cmd,
                 lldb::SBCommandReturnObject &res) override {
    if (!g_kdump.IsOpen()) {
      res.AppendMessage("No open kdump for 'info'");
      return false;
    }

    std::ostringstream oss;
    auto &threads = g_kdump.GetThreads();
    for (size_t i = 0; i < threads.size(); i++) {
      const ThreadInfo &th = threads[i];
      // skip PID == 0.
      if (th.tid == 0)
        continue;
      // Print a header line about the thread/cpu
      oss << " CPU: " << th.cpu_index << ", PID: " << th.tid << "\n";

      // Switch to hex, uppercase, with zero padding if desired
      oss << std::uppercase << std::hex << std::setfill('0');

      // First line: RAX, RBX, RCX, RDX
      oss << "  RAX=0x" << std::setw(16) << th.regs.rax << "  RBX=0x"
          << std::setw(16) << th.regs.rbx << "  RCX=0x" << std::setw(16)
          << th.regs.rcx << "  RDX=0x" << std::setw(16) << th.regs.rdx << "\n";

      // Second line: RSI, RDI, RBP, RSP
      oss << "  RSI=0x" << std::setw(16) << th.regs.rsi << "  RDI=0x"
          << std::setw(16) << th.regs.rdi << "  RBP=0x" << std::setw(16)
          << th.regs.rbp << "  RSP=0x" << std::setw(16) << th.regs.rsp << "\n";

      // Third line: R8, R9, R10, R11
      oss << "   R8=0x" << std::setw(16) << th.regs.r8 << "   R9=0x"
          << std::setw(16) << th.regs.r9 << "  R10=0x" << std::setw(16)
          << th.regs.r10 << "  R11=0x" << std::setw(16) << th.regs.r11 << "\n";

      // Fourth line: R12, R13, R14, R15
      oss << "  R12=0x" << std::setw(16) << th.regs.r12 << "  R13=0x"
          << std::setw(16) << th.regs.r13 << "  R14=0x" << std::setw(16)
          << th.regs.r14 << "  R15=0x" << std::setw(16) << th.regs.r15 << "\n";

      // Next line: RIP, CS, EFLAGS, SS, ORIG_RAX
      // (cs and ss are 16-bit, eflags might be 32 bits, but we can show them in
      // hex)
      oss << "  RIP=0x" << std::setw(16) << th.regs.rip << "  CS=0x"
          << std::setw(4) << (uint16_t)th.regs.cs << "  EFLAGS=0x"
          << std::setw(8) << (uint32_t)th.regs.eflags << "  SS=0x"
          << std::setw(4) << (uint16_t)th.regs.ss << "\n";

      oss << "  ORIG_RAX=0x" << std::setw(16) << th.regs.orig_rax << "\n\n";

      // restore default formatting
      oss << std::dec << std::nouppercase;
    }

    res.AppendMessage(oss.str().c_str());
    return true;
  }
};

class CoreOpenCommand : public lldb::SBCommandPluginInterface {
public:
  bool DoExecute(lldb::SBDebugger dbg, char **cmd,
                 lldb::SBCommandReturnObject &res) override {
    if (!cmd || !cmd[0]) {
      res.AppendMessage("Usage: kdump open <crash file>");
      return false;
    }

    std::string vmcorePath = cmd[0];
    std::string vmlinuxPath;
    if (cmd[1]) {
      vmlinuxPath = cmd[1];
    }

    // close old
    g_kdump.Close();
    g_coreFilePath = vmcorePath;

    if (!g_kdump.Open(vmcorePath)) {
      std::string e = "Failed to open: ";
      e += vmcorePath + " => " + g_kdump.GetError();
      res.AppendMessage(e.c_str());
      return false;
    }

    lldb::SBTarget target = dbg.GetSelectedTarget();
    if (!vmlinuxPath.empty()) {
      lldb::SBError err;
      target = dbg.CreateTarget(vmlinuxPath.c_str(), "", "", true, err);
      if (err.Fail()) {
        std::string e = "Failed to load vmlinux: ";
        e += err.GetCString();
        res.AppendMessage(e.c_str());
      } else {
        // optional: read "phys_base" from kdump attr
        auto physb_str =
            g_kdump.GetAttrString("linux.vmcoreinfo.NUMBER.phys_base");
        if (!physb_str.empty()) {
          uint64_t pb = strtoull(physb_str.c_str(), nullptr, 0);
          if (pb) {
            // set section load address, etc.
            lldb::SBModule mod = target.GetModuleAtIndex(0);
            if (mod.IsValid()) {
              lldb::SBSection s_text = mod.FindSection("__text");
              if (s_text.IsValid()) {
                lldb::SBError e2 = target.SetSectionLoadAddress(s_text, pb);
                if (e2.Fail()) {
                  std::string w = "Could not set load address: ";
                  w += e2.GetCString();
                  res.AppendMessage(w.c_str());
                }
              }
            }
          }
        }
      }
    }

    char msg[256];
    ::snprintf(msg, sizeof(msg), "Opened %s", vmcorePath.c_str());
    res.AppendMessage(msg);
    return true;
  }
};

//--------------------------------------------------------------------------------------
// Plugin entry
//--------------------------------------------------------------------------------------

namespace lldb {

bool PluginInitialize(lldb::SBDebugger debugger) {
  auto interp = debugger.GetCommandInterpreter();
  debugger.SetPrompt("kLLDB> ");

  lldb::SBCommand cmdGroup = interp.AddMultiwordCommand(
      "kdump", "Commands for Linux vmcore/kdump analysis");
  if (!cmdGroup.IsValid()) {
    ::fprintf(stderr, "Failed to create 'linux kdump' cmd group.\n");
    return false;
  }

  cmdGroup.AddCommand("open", new CoreOpenCommand(),
                      "Open a kdump file: kdump open <crash file>");
  cmdGroup.AddCommand("bugpoint", new CoreBugpointCommand(),
                      "Show bugpoint based on rbp and rip");
  cmdGroup.AddCommand("info", new CoreInfoCommand(),
                      "Show top-level info from the dump");
  cmdGroup.AddCommand("registers", new CoreRegistersCommand(),
                      "Show registers content from dump file");
  cmdGroup.AddCommand("load-lkm", new CoreLoadLKMCommand(),
                      "Load a kernel module");
  cmdGroup.AddCommand("source-dir-map", new CoreSourceDirMapCommand(),
                      "Map remote source directories to local paths");

  ::printf("kLLDBOffline plugin loaded.\n");
  return true;
}

} // namespace lldb

```

`scripts/report-linux-bug.py`:

```py
#!/usr/bin/env python3
import subprocess
import re
import os
import argparse
import contextlib
import sys

try:
    from llama_cpp import Llama
except ImportError:
    print("llama_cpp not installed. Please install with: pip install llama-cpp-python")
    raise

ANSI_RE = re.compile(r"\x1b\[[0-9;]*m")

def generate_bug_report_locally(analysis_data, llm_path):
    prompt_text = f"""You are Linux Kernel expert. You are analyzing a Linux kernel crash and here are some inputs about crash:

Details:
Blame Module: {analysis_data['module']}
Instruction Pointer (RIP): {analysis_data['rip']}
Function: {analysis_data['function']}

Register Dump:
{analysis_data['registers']}

Additional Info:
{analysis_data['info']}

Source Snippet (kv_reset_tainted):
{analysis_data['source_code']}

===

Provide a short and concise bug report describing:
- The likely cause of the crash.
- Which module and function are implicated.
- Check function arguments and registers (e.g. arg one is RDI, second is RDI, etc.).
- Potential next steps or debugging strategies.
- Be short.
- Should be in up to 2 sentences.
- Print summary only.
- Do not print <think> process!
===
"""
    print("== Prompt used:")
    print(prompt_text)

    # Hide llama-cpp logs by redirecting stdout/stderr
    with open(os.devnull, 'w') as devnull:
        with contextlib.redirect_stdout(devnull), contextlib.redirect_stderr(devnull):
            llm = Llama(
                model_path=llm_path,
                n_ctx=2048,
                n_gpu_layers=0,
                n_threads=4,
                f16_kv=False,
                use_mlock=False
            )
            output = llm(
                prompt=prompt_text,
                max_tokens=512,
                temperature=0.2,
                stop=["</s>"]
            )

    if "choices" in output and output["choices"]:
        return output["choices"][0]["text"].strip()
    return output.get("data", "").strip()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--llm-path", required=True)
    parser.add_argument("--lldb-path", default="/usr/bin/lldb")
    parser.add_argument("--kdump-plugin-path", default="/path/to/libkLLDBLinux.so")
    parser.add_argument("--vmlinux-path", default="/path/to/vmlinux")
    parser.add_argument("--crash-file-path", default="./crash.file")
    parser.add_argument("--lkm-path", default="kovid.ko")
    parser.add_argument("--source-dir-old", default="/kovid/",
                        help="Old source dir path inside the kernel debug info.")
    parser.add_argument("--source-dir-new", default="/path/to/KoviD/kovid",
                        help="New source dir path on your filesystem.")
    parser.add_argument("--report-file", default=None,
                        help="Path to save the generated bug report (if provided). Otherwise prints to stdout.")

    args = parser.parse_args()

    lldb_cmd = [
        args.lldb_path,
        "-o", f"target create {args.vmlinux_path}",
        "-o", f"plugin load {args.kdump_plugin_path}",
        "-o", f"kdump open {args.crash_file_path}",
        "-o", "kdump info",
        "-o", f"kdump load-lkm {args.lkm_path}",
        "-o", "kdump bugpoint",
        "-o", f"kdump source-dir-map {args.source_dir_old} {args.source_dir_new}",
        "-o", "list kv_reset_tainted",
        "-o", "kdump registers",
        "-o", "q"
    ]

    print("Running LLDB with one-shot commands...")
    print(" ".join(lldb_cmd))

    # Run the command, capture output
    result = subprocess.run(lldb_cmd, capture_output=True, text=True)
    full_output = result.stdout

    if result.returncode != 0:
        print("WARNING: LLDB returned a non-zero status!", result.returncode)

    # Strip ANSI color codes
    clean_output = ANSI_RE.sub("", full_output)

    # --- PARSE BUGPOINT ---
    blame_module = re.search(r"Blame module:\s*(.*)", clean_output)
    rip_address  = re.search(r"Instructon pointer at rip=(0x[0-9A-Fa-f]+)", clean_output)
    blame_func   = re.search(r"Blame function:\s*(.*)", clean_output)

    # --- PARSE REGISTERS ---
    registers = {}
    for line in clean_output.splitlines():
        line_strip = line.strip()
        # Example: "  RAX=0x0000..."
        if "=" in line_strip and re.match(r"^[A-Z]+=", line_strip, re.IGNORECASE):
            parts = line_strip.split()
            for part in parts:
                if "=" in part:
                    reg, val = part.split("=")
                    registers[reg] = val

    # --- PARSE "kdump info" ---
    info_regex = re.compile(r"kdump info\s+(.*?)\s+kLLDB>", re.DOTALL)
    info_match = info_regex.search(clean_output)
    info_text = info_match.group(1).strip() if info_match else ""

    # --- PARSE "list kv_reset_tainted" ---
    snippet_regex = re.compile(r"list kv_reset_tainted\s+(.*?)\s+kLLDB>", re.DOTALL)
    snippet_match = snippet_regex.search(clean_output)
    source_snippet = snippet_match.group(1).strip() if snippet_match else ""

    # Debug prints
    print("\n=== PARSED RESULTS ===")
    mod_parsed = blame_module.group(1).strip() if blame_module else ""
    rip_parsed = rip_address.group(1).strip() if rip_address else ""
    func_parsed = blame_func.group(1).strip() if blame_func else ""
    print("Blame module:", mod_parsed)
    print("RIP address:", rip_parsed)
    print("Blame function:", func_parsed)
    print("Registers found:", registers)
    print("Info text:\n", info_text)
    print("Source snippet:\n", source_snippet)
    print("=====================")

    # Build analysis data
    analysis_data = {
        "module":     mod_parsed,
        "rip":        rip_parsed,
        "function":   func_parsed,
        "registers":  registers,
        "info":       info_text,
        "source_code": source_snippet,
    }

    print("\nGenerating bug report with local LLM...")
    bug_report = generate_bug_report_locally(analysis_data, args.llm_path)

    final_report = "kLLDB sesion:\n"
    final_report += full_output
    final_report += "\n=====\n\n"
    final_report += "LLM report:\n"
    final_report += bug_report
    final_report += "\n=====\n\n"

    # Print or write to file, depending on --report-file
    if args.report_file:
        print(f"\nWriting bug report to {args.report_file} ...")
        with open(args.report_file, "w", encoding="utf-8") as rf:
            rf.write(final_report + "\n")
        print("Done.")
    else:
        print("\n=== Bug Report ===")
        print(final_report)
        print("==================")

if __name__ == "__main__":
    main()

```