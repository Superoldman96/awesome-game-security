Project Path: arc_gmh5225_USecurity_ap1wham5

Source Tree:

```txt
arc_gmh5225_USecurity_ap1wham5
├── AntiCheat
│   ├── Script
│   │   ├── AntiCheatExtension.cs
│   │   ├── AntiCheatExtension.cs.meta
│   │   ├── DataType
│   │   │   ├── Base
│   │   │   │   ├── IAntiCheatValue.cs
│   │   │   │   ├── IAntiCheatValue.cs.meta
│   │   │   │   ├── cGlobal.cs
│   │   │   │   └── cGlobal.cs.meta
│   │   │   ├── Base.meta
│   │   │   ├── CSharp
│   │   │   │   ├── cBool.cs
│   │   │   │   ├── cBool.cs.meta
│   │   │   │   ├── cByte.cs
│   │   │   │   ├── cByte.cs.meta
│   │   │   │   ├── cChar.cs
│   │   │   │   ├── cChar.cs.meta
│   │   │   │   ├── cDecimal.cs
│   │   │   │   ├── cDecimal.cs.meta
│   │   │   │   ├── cDouble.cs
│   │   │   │   ├── cDouble.cs.meta
│   │   │   │   ├── cFloat.cs
│   │   │   │   ├── cFloat.cs.meta
│   │   │   │   ├── cInt.cs
│   │   │   │   ├── cInt.cs.meta
│   │   │   │   ├── cLong.cs
│   │   │   │   ├── cLong.cs.meta
│   │   │   │   ├── cShort.cs
│   │   │   │   ├── cShort.cs.meta
│   │   │   │   ├── cString.cs
│   │   │   │   └── cString.cs.meta
│   │   │   ├── CSharp.meta
│   │   │   ├── Unity
│   │   │   │   ├── cColor.cs
│   │   │   │   ├── cColor.cs.meta
│   │   │   │   ├── cQuaternion.cs
│   │   │   │   ├── cQuaternion.cs.meta
│   │   │   │   ├── cVector2.cs
│   │   │   │   ├── cVector2.cs.meta
│   │   │   │   ├── cVector3.cs
│   │   │   │   ├── cVector3.cs.meta
│   │   │   │   ├── cVector4.cs
│   │   │   │   └── cVector4.cs.meta
│   │   │   └── Unity.meta
│   │   ├── DataType.meta
│   │   ├── PlayerPrefsAES.cs
│   │   └── PlayerPrefsAES.cs.meta
│   └── Script.meta
├── AntiCheat.meta
├── DFA
│   ├── Script
│   │   ├── DFANode.cs
│   │   ├── DFANode.cs.meta
│   │   ├── DFAUtil.cs
│   │   └── DFAUtil.cs.meta
│   └── Script.meta
├── DFA.meta
├── EncDec
│   ├── AES
│   │   ├── Resources
│   │   │   ├── AESKey.asset
│   │   │   └── AESKey.asset.meta
│   │   ├── Resources.meta
│   │   ├── Script
│   │   │   ├── AESFileUtil.cs
│   │   │   ├── AESFileUtil.cs.meta
│   │   │   ├── AESKey.cs
│   │   │   ├── AESKey.cs.meta
│   │   │   ├── AESUtil.cs
│   │   │   └── AESUtil.cs.meta
│   │   └── Script.meta
│   ├── AES.meta
│   ├── Base64
│   │   ├── Script
│   │   │   ├── Base64Util.cs
│   │   │   └── Base64Util.cs.meta
│   │   └── Script.meta
│   ├── Base64.meta
│   ├── DES
│   │   ├── Resources
│   │   │   ├── DESKey.asset
│   │   │   └── DESKey.asset.meta
│   │   ├── Resources.meta
│   │   ├── Script
│   │   │   ├── DESFileUtil.cs
│   │   │   ├── DESFileUtil.cs.meta
│   │   │   ├── DESKey.cs
│   │   │   ├── DESKey.cs.meta
│   │   │   ├── DESUtil.cs
│   │   │   └── DESUtil.cs.meta
│   │   └── Script.meta
│   ├── DES.meta
│   ├── Extension
│   │   ├── Script
│   │   │   ├── SecurityExtension.cs
│   │   │   └── SecurityExtension.cs.meta
│   │   └── Script.meta
│   ├── Extension.meta
│   ├── RC4
│   │   ├── Resources
│   │   │   ├── RC4kEY.asset
│   │   │   └── RC4kEY.asset.meta
│   │   ├── Resources.meta
│   │   ├── Script
│   │   │   ├── RC4Key.cs
│   │   │   ├── RC4Key.cs.meta
│   │   │   ├── RC4Util.cs
│   │   │   └── RC4Util.cs.meta
│   │   └── Script.meta
│   ├── RC4.meta
│   ├── RSA
│   │   ├── Resources
│   │   │   ├── RSAKey.asset
│   │   │   └── RSAKey.asset.meta
│   │   ├── Resources.meta
│   │   ├── Script
│   │   │   ├── RSAKey.cs
│   │   │   ├── RSAKey.cs.meta
│   │   │   ├── RSAUtil.cs
│   │   │   └── RSAUtil.cs.meta
│   │   └── Script.meta
│   └── RSA.meta
├── EncDec.meta
├── LICENSE.md
├── LICENSE.md.meta
├── MD5
│   ├── Script
│   │   ├── MD5Util.cs
│   │   └── MD5Util.cs.meta
│   └── Script.meta
├── MD5.meta
├── README.md
├── README_CN.md
├── Util
│   ├── Script
│   │   ├── USecurityInterface.cs
│   │   ├── USecurityInterface.cs.meta
│   │   ├── USecurityUtil.cs
│   │   └── USecurityUtil.cs.meta
│   └── Script.meta
└── Util.meta

```

`AntiCheat.meta`:

```meta
fileFormatVersion: 2
guid: ba77d25c44d5ae845a5096985274839a
folderAsset: yes
timeCreated: 1478003570
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script.meta`:

```meta
fileFormatVersion: 2
guid: 965956cb6d022304d967040a25795480
folderAsset: yes
timeCreated: 1510291733
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/AntiCheatExtension.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : AntiCheatExtension.cs
//  Info     : 反作弊 扩展方法
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

namespace Aya.Security
{
    public static class AntiCheatExtension
    {
        #region Cache

        internal static readonly Dictionary<Type, Type> AntiCheatTypeDic = new Dictionary<Type, Type>()
        {
            {typeof(bool), typeof(cBool)},
            {typeof(byte), typeof(cByte)},
            {typeof(char), typeof(cChar)},
            {typeof(decimal), typeof(cDecimal)},
            {typeof(double), typeof(cDouble)},
            {typeof(float), typeof(cFloat)},
            {typeof(int), typeof(cInt)},
            {typeof(long), typeof(cLong)},
            {typeof(short), typeof(cShort)},
            {typeof(string), typeof(cString)},
            {typeof(Color), typeof(cColor)},
            {typeof(Quaternion), typeof(cQuaternion)},
            {typeof(Vector2), typeof(cVector2)},
            {typeof(Vector3), typeof(cVector3)},
            {typeof(Vector4), typeof(cVector4)},
        };

        internal static readonly Dictionary<Type, Type> SourceTypeDic = new Dictionary<Type, Type>()
        {
            {typeof(cBool), typeof(bool)},
            {typeof(cByte), typeof(byte)},
            {typeof(cChar), typeof(char)},
            {typeof(cDecimal), typeof(decimal)},
            {typeof(cDouble), typeof(double)},
            {typeof(cFloat), typeof(float)},
            {typeof(cInt), typeof(int)},
            {typeof(cLong), typeof(long)},
            {typeof(cShort), typeof(short)},
            {typeof(cString), typeof(string)},
            {typeof(cColor), typeof(Color)},
            {typeof(cQuaternion), typeof(Quaternion)},
            {typeof(cVector2), typeof(Vector2)},
            {typeof(Vector3), typeof(cVector3)},
            {typeof(cVector4), typeof(Vector4)},
        };

        static AntiCheatExtension()
        {

        }

        #endregion

        /// <summary>
        /// 是否是反作弊数据类型
        /// </summary>
        /// <param name="type">类型</param>
        /// <returns>结果</returns>
        public static bool IsAntiCheatValue(this Type type)
        {
            var result = typeof(IAntiCheatValue).IsAssignableFrom(type);
            return result;
        }

        /// <summary>
        /// 获取反作弊类型的原始默认值，需提前判定是否为反作弊类型
        /// </summary>
        /// <param name="type">类型</param>
        /// <returns>结果</returns>
        public static object DefaultSourceValue(this Type type)
        {
            if (SourceTypeDic.TryGetValue(type, out var sourceType))
            {
                return Activator.CreateInstance(sourceType);
            }

            return null;
        }

        /// <summary>
        /// 获取反作弊类型的默认值，需提前判定是否为反作弊类型
        /// </summary>
        /// <param name="type">类型</param>
        /// <returns>结果</returns>
        public static object DefaultAntiCheatValue(this Type type)
        {
            if (SourceTypeDic.TryGetValue(type, out var sourceType))
            {
                var instance = Activator.CreateInstance(type);
                var property = type.GetProperty("Value");
                property?.SetValue(instance, Activator.CreateInstance(sourceType));
                return instance;
            }

            return null;
        }

        /// <summary>
        /// 获取反作弊类型的默认值类型，需提前判定是否为反作弊类型
        /// </summary>
        /// <param name="type">类型</param>
        /// <returns>结果</returns>
        public static Type SourceType(this Type type)
        {
            if (SourceTypeDic.TryGetValue(type, out var sourceType))
            {
                return sourceType;
            }

            return null;
        }

        /// <summary>
        /// 获取原生数据类型对应的反作弊类型
        /// </summary>
        /// <param name="type">类型</param>
        /// <returns>结果</returns>
        public static Type AntiCheatType(this Type type)
        {
            if (AntiCheatTypeDic.TryGetValue(type, out var antiCheatType))
            {
                return antiCheatType;
            }

            return null;
        }

        /// <summary>
        /// 获取反作弊类型的默认值类型，需提前判定是否为反作弊类型
        /// </summary>
        /// <param name="value">数值</param>
        /// <returns>结果</returns>
        public static Type SourceType(this IAntiCheatValue value)
        {
            if (SourceTypeDic.TryGetValue(value.GetType(), out var sourceType))
            {
                return sourceType;
            }

            return null;
        }

        /// <summary>
        /// 获取原生数据类型对应的反作弊类型
        /// </summary>
        /// <param name="value">数值</param>
        /// <returns>结果</returns>
        public static Type AntiCheatType(this object value)
        {
            if (AntiCheatTypeDic.TryGetValue(value.GetType(), out var antiCheatType))
            {
                return antiCheatType;
            }

            return null;
        }

        /// <summary>
        /// 尝试转换为非反作弊类型，需要确定是反作弊类型
        /// </summary>
        /// <param name="obj">值</param>
        /// <returns>值</returns>
        public static object TryParseSourceValue(this object obj)
        {
            var type = obj.GetType();
            if (!type.IsAntiCheatValue()) return obj;
            var defaultType = type.SourceType();
            var defaultValue = Convert.ChangeType(obj, defaultType, CultureInfo.InvariantCulture);
            var ins = Activator.CreateInstance(type);
            var method = ins.GetType().GetMethod("TryParseSource");
            var result = method?.Invoke(ins, new object[] {defaultValue});
            return result;
        }

        /// <summary>
        /// 尝试转换为反作弊类型，需要确定是普通类型
        /// </summary>
        /// <param name="obj">值</param>
        /// <param name="targetType">目标类型</param>
        /// <returns>值</returns>
        public static object TryParseAntiCheatValue(this object obj, Type targetType)
        {
            if (!SourceTypeDic.TryGetValue(targetType, out var sourceType))
            {
                return obj;
            }

            var sourceValue = Convert.ChangeType(obj, sourceType, CultureInfo.InvariantCulture);
            var result = sourceValue.TryParseAntiCheatValue();
            return result;
        }

        /// <summary>
        /// 尝试转换为反作弊类型，需要确定是普通类型
        /// </summary>
        /// <param name="obj">值</param>
        /// <returns>值</returns>
        public static object TryParseAntiCheatValue(this object obj)
        {
            var type = obj.GetType();
            if (!AntiCheatTypeDic.TryGetValue(type, out var antiCheatType))
            {
                return obj;
            }

            var ins = Activator.CreateInstance(antiCheatType);
            var method = ins.GetType().GetMethod("TryParseAntiCheat");
            var result = method?.Invoke(ins, new object[] {obj});
            return result;
        }
    }
}
```

`AntiCheat/Script/AntiCheatExtension.cs.meta`:

```meta
fileFormatVersion: 2
guid: db05acc69c8456f48a4bb30102657842
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType.meta`:

```meta
fileFormatVersion: 2
guid: 5398e7414a4e33346a28e108626e6d61
folderAsset: yes
timeCreated: 1496744220
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/Base.meta`:

```meta
fileFormatVersion: 2
guid: 4dc9197ba218dfa4b8fccbd31bdd37b8
folderAsset: yes
timeCreated: 1510292568
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/Base/IAntiCheatValue.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : IAntiCheatValue.cs
//  Info     : 反作弊数值类型接口
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System.Runtime.Serialization;

namespace Aya.Security
{
    public interface IAntiCheatValue : ISerializable
    {

    }

    public interface IAntiCheatValue<out TSource> : IAntiCheatValue
    {
        TSource Value { get; }
    }
}
```

`AntiCheat/Script/DataType/Base/IAntiCheatValue.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4ffb0061ec305bb47b52b1696f837719
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/Base/cGlobal.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cGlobal.cs
//  Info     : 反作弊 - 全局配置类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;

namespace Aya.Security
{
    internal class cGlobal
    {
        /// <summary>
        /// 随机数字密钥
        /// </summary>
        public static int Key { get; } = USecurityUtil.Rand.Next(100000, 999999);

        /// <summary>
        /// 随机字符串密钥
        /// </summary>
        public static readonly string KeyStr = Guid.NewGuid().ToString().Substring(0, 16);
    }
}
```

`AntiCheat/Script/DataType/Base/cGlobal.cs.meta`:

```meta
fileFormatVersion: 2
guid: 9752d4ffc9def5f43a91263c29400f4a
timeCreated: 1496830850
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/CSharp.meta`:

```meta
fileFormatVersion: 2
guid: 83e5140341ea6aa4aa33ae5fc10523d3
folderAsset: yes
timeCreated: 1496744241
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/CSharp/cBool.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cBool.cs
//  Info     : 反作弊 - bool 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Runtime.Serialization;

namespace Aya.Security
{
    public struct cBool : IAntiCheatValue<bool>, IComparable, IConvertible, IComparable<bool>, IEquatable<bool>
    {
        #region Value

        public bool Value
        {
            get => _value == (9642 ^ cGlobal.Key);
            set => _value = value ? (9642 ^ cGlobal.Key) : (3571 ^ cGlobal.Key);
        }

        private int _value;

        #endregion

        #region Parse

        public static cBool TryParseAntiCheat(bool value)
        {
            return (cBool) value;
        }

        public static bool TryParseSource(cBool value)
        {
            return (bool) value;
        }

        #endregion

        #region Override operator

        public static implicit operator cBool(bool value)
        {
            var ret = new cBool {Value = value};
            return ret;
        }

        public static implicit operator bool(cBool obj)
        {
            return obj.Value;
        }

        public static bool operator ==(cBool lhs, cBool rhs)
        {
            return lhs._value == rhs._value;
        }

        public static bool operator !=(cBool lhs, cBool rhs)
        {
            return lhs._value != rhs._value;
        }

        #endregion

        #region Override object

        public bool Equals(cBool obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cBool))
            {
                return false;
            }

            return this == (cBool) obj;
        }

        public override string ToString()
        {
            return Value.ToString();
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cBool(SerializationInfo info, StreamingContext context)
        {
            _value = 0;
            Value = info.GetBoolean("Value");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Value", Value);
        }

        #endregion

        #region IEquatable<T>

        public bool Equals(bool obj)
        {
            return Value.Equals(obj);
        }

        #endregion

        #region IComparable<T>

        public int CompareTo(bool other)
        {
            return Value.CompareTo(other);
        }

        #endregion

        #region IComparable

        public int CompareTo(object obj)
        {
            return Value.CompareTo(obj);
        }

        #endregion

        #region IConvertible

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        public bool ToBoolean(IFormatProvider provider)
        {
            return Value;
        }

        public byte ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(Value);
        }

        public char ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(Value);
        }

        public decimal ToDecimal(IFormatProvider provider)
        {
            return Convert.ToDecimal(Value);
        }

        public double ToDouble(IFormatProvider provider)
        {
            return Convert.ToDouble(Value);
        }

        public short ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(Value);
        }

        public int ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32(Value);
        }

        public long ToInt64(IFormatProvider provider)
        {
            return Convert.ToInt64(Value);
        }

        public sbyte ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte(Value);
        }

        public float ToSingle(IFormatProvider provider)
        {
            return Convert.ToSingle(Value);
        }

        public string ToString(IFormatProvider provider)
        {
            return Convert.ToString(Value);
        }

        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(Value);
        }

        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(Value);
        }

        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(Value);
        }

        public DateTime ToDateTime(IFormatProvider provider)
        {
            throw new InvalidCastException();
        }

        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return Convert.ChangeType(Value, conversionType);
        }

        #endregion
    }
}

```

`AntiCheat/Script/DataType/CSharp/cBool.cs.meta`:

```meta
fileFormatVersion: 2
guid: 11e6714ce5f0e7a4394b2107e7c0e087
timeCreated: 1478006600
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/CSharp/cByte.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cByte.cs
//  Info     : 反作弊 - byte 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Runtime.Serialization;

namespace Aya.Security
{
    public struct cByte : IAntiCheatValue<byte>, IComparable, IFormattable, IConvertible, IComparable<byte>, IEquatable<byte>
    {
        #region Value

        public byte Value
        {
            get => this;
            set => this = value;
        }

        private byte _value;

        #endregion

        #region Parse

        public static cByte TryParseAntiCheat(byte value)
        {
            return (cByte) value;
        }

        public static byte TryParseSource(cByte value)
        {
            return (byte) value;
        }

        #endregion

        #region Enc & Dec

        public static cByte Encode(byte value)
        {
            cByte i;
            i._value = (byte) (~value ^ cGlobal.Key);
            return i;
        }

        public static byte Decode(cByte value)
        {
            return (byte) (~value._value ^ cGlobal.Key);
        }

        #endregion

        #region Override operator

        public static implicit operator cByte(byte value)
        {
            return Encode(value);
        }

        public static implicit operator byte(cByte obj)
        {
            return Decode(obj);
        }


        public static bool operator ==(cByte lhs, cByte rhs)
        {
            return lhs._value == rhs._value;
        }

        public static bool operator !=(cByte lhs, cByte rhs)
        {
            return lhs._value != rhs._value;
        }

        #endregion

        #region Override object

        public bool Equals(cByte obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cByte))
            {
                return false;
            }

            return this == (cByte) obj;
        }

        public override string ToString()
        {
            return Decode(this).ToString();
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cByte(SerializationInfo info, StreamingContext context)
        {
            _value = Encode(info.GetByte("Value"));
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Value", Value);
        }

        #endregion

        #region IEquatable<T>

        public bool Equals(byte obj)
        {
            return Value.Equals(obj);
        }

        #endregion

        #region IComparable<T>

        public int CompareTo(byte other)
        {
            return Value.CompareTo(other);
        }

        #endregion

        #region IComparable

        public int CompareTo(object obj)
        {
            return Value.CompareTo(obj);
        }

        #endregion

        #region IFormattable

        public string ToString(string format, IFormatProvider formatProvider)
        {
            return Value.ToString(format, formatProvider);
        }

        #endregion

        #region IConvertible

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        public bool ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(Value);
        }

        public byte ToByte(IFormatProvider provider)
        {
            return Value;
        }

        public char ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(Value);
        }

        public decimal ToDecimal(IFormatProvider provider)
        {
            return Convert.ToDecimal(Value);
        }

        public double ToDouble(IFormatProvider provider)
        {
            return Convert.ToDouble(Value);
        }

        public short ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(Value);
        }

        public int ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32(Value);
        }

        public long ToInt64(IFormatProvider provider)
        {
            return Convert.ToInt64(Value);
        }

        public sbyte ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte(Value);
        }

        public float ToSingle(IFormatProvider provider)
        {
            return Convert.ToSingle(Value);
        }

        public string ToString(IFormatProvider provider)
        {
            return Convert.ToString(Value);
        }

        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(Value);
        }

        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(Value);
        }

        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(Value);
        }

        public DateTime ToDateTime(IFormatProvider provider)
        {
            throw new InvalidCastException();
        }

        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return Convert.ChangeType(Value, conversionType);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/CSharp/cByte.cs.meta`:

```meta
fileFormatVersion: 2
guid: 83fea23215cc23f4d8b91a8b067e5f1d
timeCreated: 1491311024
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/CSharp/cChar.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cChar.cs
//  Info     : 反作弊 - char 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Runtime.Serialization;

namespace Aya.Security
{
    public struct cChar : IAntiCheatValue<char>, IComparable, IConvertible, IComparable<char>, IEquatable<char>
    {
        #region Value

        public char Value
        {
            get => this;
            set => this = value;
        }

        private char _value;

        #endregion

        #region Parse

        public static cChar TryParseAntiCheat(char value)
        {
            return (cChar) value;
        }

        public static char TryParseSource(cChar value)
        {
            return (char) value;
        }

        #endregion

        #region Enc & Dec

        public static cChar Encode(char value)
        {
            cChar i;
            i._value = (char) (~value ^ cGlobal.Key);
            return i;
        }

        public static char Decode(cChar value)
        {
            return (char) (~value._value ^ cGlobal.Key);
        }

        #endregion

        #region Override operator

        public static implicit operator cChar(char value)
        {
            return Encode(value);
        }

        public static implicit operator char(cChar obj)
        {
            return Decode(obj);
        }

        public static bool operator ==(cChar lhs, cChar rhs)
        {
            return lhs._value == rhs._value;
        }

        public static bool operator !=(cChar lhs, cChar rhs)
        {
            return lhs._value != rhs._value;
        }

        #endregion

        #region Override object

        public bool Equals(cChar obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cChar))
            {
                return false;
            }

            return this == (cChar) obj;
        }

        public override string ToString()
        {
            return Decode(this).ToString();
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cChar(SerializationInfo info, StreamingContext context)
        {
            _value = Encode(info.GetChar("Value"));
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Value", Value);
        }

        #endregion

        #region IEquatable<T>

        public bool Equals(char obj)
        {
            return Value.Equals(obj);
        }

        #endregion

        #region IComparable<T>

        public int CompareTo(char other)
        {
            return Value.CompareTo(other);
        }

        #endregion

        #region IComparable

        public int CompareTo(object obj)
        {
            return Value.CompareTo(obj);
        }

        #endregion

        #region IConvertible

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        public bool ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(Value);
        }

        public byte ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(Value);
        }

        public char ToChar(IFormatProvider provider)
        {
            return Value;
        }

        public decimal ToDecimal(IFormatProvider provider)
        {
            return Convert.ToDecimal(Value);
        }

        public double ToDouble(IFormatProvider provider)
        {
            return Convert.ToDouble(Value);
        }

        public short ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(Value);
        }

        public int ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32(Value);
        }

        public long ToInt64(IFormatProvider provider)
        {
            return Convert.ToInt64(Value);
        }

        public sbyte ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte(Value);
        }

        public float ToSingle(IFormatProvider provider)
        {
            return Convert.ToSingle(Value);
        }

        public string ToString(IFormatProvider provider)
        {
            return Convert.ToString(Value);
        }

        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(Value);
        }

        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(Value);
        }

        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(Value);
        }

        public DateTime ToDateTime(IFormatProvider provider)
        {
            throw new InvalidCastException();
        }

        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return Convert.ChangeType(Value, conversionType);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/CSharp/cChar.cs.meta`:

```meta
fileFormatVersion: 2
guid: 1f528766e0d537d47b79169f3ce947a5
timeCreated: 1478006600
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/CSharp/cDecimal.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cDecimal.cs
//  Info     : 反作弊 - decimal 等效加密类型，非必要情况下，尽可能使用cFloat
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

namespace Aya.Security
{
    public struct cDecimal : IAntiCheatValue<decimal>, IFormattable, IComparable, IConvertible, IComparable<Decimal>, IEquatable<Decimal>
    {
        #region Value

        public decimal Value
        {
            get
            {
                var v = new DecimalIntBytesUnion
                {
                    a = ~_value.a ^ cGlobal.Key,
                    b = ~_value.b ^ cGlobal.Key
                };
                return v.d;
            }
            set
            {
                var v = new DecimalIntBytesUnion {d = value};
                _value.a = ~v.a ^ cGlobal.Key;
                _value.b = ~v.b ^ cGlobal.Key;
            }
        }

        #endregion

        #region Parse

        public static cDecimal TryParseAntiCheat(decimal value)
        {
            return (cDecimal) value;
        }

        public static decimal TryParseSource(cDecimal value)
        {
            return (decimal) value;
        }

        #endregion

        #region Enc & Dec

        [StructLayout(LayoutKind.Explicit)]
        private struct DecimalIntBytesUnion
        {
            [FieldOffset(0)] public decimal d;
            [FieldOffset(0)] public long a;
            [FieldOffset(0)] public byte b1;
            [FieldOffset(1)] public byte b2;
            [FieldOffset(2)] public byte b3;
            [FieldOffset(3)] public byte b4;
            [FieldOffset(4)] public byte b5;
            [FieldOffset(5)] public byte b6;
            [FieldOffset(6)] public byte b7;
            [FieldOffset(7)] public byte b8;
            [FieldOffset(8)] public long b;
            [FieldOffset(8)] public byte b9;
            [FieldOffset(9)] public byte b10;
            [FieldOffset(10)] public byte b11;
            [FieldOffset(11)] public byte b12;
            [FieldOffset(12)] public byte b13;
            [FieldOffset(13)] public byte b14;
            [FieldOffset(14)] public byte b15;
            [FieldOffset(15)] public byte b16;
        }

        private DecimalIntBytesUnion _value;

        #endregion

        #region Override operator

        public static implicit operator cDecimal(decimal value)
        {
            var ret = new cDecimal {Value = value};
            return ret;
        }

        public static implicit operator decimal(cDecimal obj)
        {
            return obj.Value;
        }

        public static cDecimal operator ++(cDecimal lhs)
        {
            return lhs.Value + 1;
        }

        public static cDecimal operator --(cDecimal lhs)
        {
            return lhs.Value - 1;
        }

        public static bool operator ==(cDecimal lhs, cDecimal rhs)
        {
            return Math.Abs(lhs.Value - rhs.Value) < 1e-6m;
        }

        public static bool operator !=(cDecimal lhs, cDecimal rhs)
        {
            return Math.Abs(lhs.Value - rhs.Value) > 1e-6m;
        }

        #endregion

        #region Override object

        public bool Equals(cDecimal obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cDecimal))
            {
                return false;
            }

            return this == (cDecimal) obj;
        }

        public override string ToString()
        {
            return Value.ToString(CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return Value.ToString(format);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cDecimal(SerializationInfo info, StreamingContext context)
        {
            _value = new DecimalIntBytesUnion();
            Value = info.GetDecimal("Value");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Value", Value);
        }

        #endregion

        #region IEquatable<T>

        public bool Equals(decimal obj)
        {
            return Value.Equals(obj);
        }

        #endregion

        #region IComparable<T>

        public int CompareTo(decimal other)
        {
            return Value.CompareTo(other);
        }

        #endregion

        #region IComparable

        public int CompareTo(object obj)
        {
            return Value.CompareTo(obj);
        }

        #endregion

        #region IFormattable

        public string ToString(string format, IFormatProvider formatProvider)
        {
            return Value.ToString(format, formatProvider);
        }

        #endregion

        #region IConvertible

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        public bool ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(Value);
        }

        public byte ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(Value);
        }

        public char ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(Value);
        }

        public decimal ToDecimal(IFormatProvider provider)
        {
            return Value;
        }

        public double ToDouble(IFormatProvider provider)
        {
            return Convert.ToDouble(Value);
        }

        public short ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(Value);
        }

        public int ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32(Value);
        }

        public long ToInt64(IFormatProvider provider)
        {
            return Convert.ToInt64(Value);
        }

        public sbyte ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte(Value);
        }

        public float ToSingle(IFormatProvider provider)
        {
            return Convert.ToSingle(Value);
        }

        public string ToString(IFormatProvider provider)
        {
            return Convert.ToString(Value, CultureInfo.InvariantCulture);
        }

        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(Value);
        }

        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(Value);
        }

        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(Value);
        }

        public DateTime ToDateTime(IFormatProvider provider)
        {
            throw new InvalidCastException();
        }

        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return Convert.ChangeType(Value, conversionType);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/CSharp/cDecimal.cs.meta`:

```meta
fileFormatVersion: 2
guid: 73df2bdffe571324c8fa2e298fa8399c
timeCreated: 1491300122
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/CSharp/cDouble.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cDouble.cs
//  Info     : 反作弊 - double 等效加密类型，非必要情况下，尽可能使用cFloat
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

namespace Aya.Security
{
    public struct cDouble : IAntiCheatValue<double>, IComparable, IFormattable, IConvertible, IComparable<double>, IEquatable<double>
    {
        #region Value

        public double Value
        {
            get
            {
                var v = new DoubleIntBytesUnion {i = ~_value.i ^ cGlobal.Key};
                return v.d;
            }
            set
            {
                var v = new DoubleIntBytesUnion {d = value};
                _value.i = ~v.i ^ cGlobal.Key;
            }
        }

        #endregion

        #region Parse

        public static cDouble TryParseAntiCheat(double value)
        {
            return (cDouble) value;
        }

        public static double TryParseSource(cDouble value)
        {
            return (double) value;
        }

        #endregion

        #region Enc & Dec

        [StructLayout(LayoutKind.Explicit)]
        private struct DoubleIntBytesUnion
        {
            [FieldOffset(0)] public double d;
            [FieldOffset(0)] public long i;
            [FieldOffset(0)] public byte b1;
            [FieldOffset(1)] public byte b2;
            [FieldOffset(2)] public byte b3;
            [FieldOffset(3)] public byte b4;
            [FieldOffset(4)] public byte b5;
            [FieldOffset(5)] public byte b6;
            [FieldOffset(6)] public byte b7;
            [FieldOffset(7)] public byte b8;
        }

        private DoubleIntBytesUnion _value;

        #endregion

        #region Override operator

        public static implicit operator cDouble(double value)
        {
            var ret = new cDouble {Value = value};
            return ret;
        }

        public static implicit operator double(cDouble obj)
        {
            return obj.Value;
        }

        public static cDouble operator ++(cDouble lhs)
        {
            return lhs.Value + 1;
        }

        public static cDouble operator --(cDouble lhs)
        {
            return lhs.Value - 1;
        }

        public static bool operator ==(cDouble lhs, cDouble rhs)
        {
            return Math.Abs(lhs.Value - rhs.Value) < 1e-8;
        }

        public static bool operator !=(cDouble lhs, cDouble rhs)
        {
            return Math.Abs(lhs.Value - rhs.Value) > 1e-8;
        }

        #endregion

        #region Override object

        public bool Equals(cDouble obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cDouble))
            {
                return false;
            }

            return this == (cDouble) obj;
        }

        public override string ToString()
        {
            return Value.ToString(CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return Value.ToString(format);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cDouble(SerializationInfo info, StreamingContext context)
        {
            _value = new DoubleIntBytesUnion();
            Value = info.GetDouble("Value");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Value", Value);
        }

        #endregion

        #region IEquatable<T>

        public bool Equals(double obj)
        {
            return Value.Equals(obj);
        }

        #endregion

        #region IComparable<T>

        public int CompareTo(double other)
        {
            return Value.CompareTo(other);
        }

        #endregion

        #region IComparable

        public int CompareTo(object obj)
        {
            return Value.CompareTo(obj);
        }

        #endregion

        #region IFormattable

        public string ToString(string format, IFormatProvider formatProvider)
        {
            return Value.ToString(format, formatProvider);
        }

        #endregion

        #region IConvertible

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        public bool ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(Value);
        }

        public byte ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(Value);
        }

        public char ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(Value);
        }

        public decimal ToDecimal(IFormatProvider provider)
        {
            return Convert.ToDecimal(Value);
        }

        public double ToDouble(IFormatProvider provider)
        {
            return Value;
        }

        public short ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(Value);
        }

        public int ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32(Value);
        }

        public long ToInt64(IFormatProvider provider)
        {
            return Convert.ToInt64(Value);
        }

        public sbyte ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte(Value);
        }

        public float ToSingle(IFormatProvider provider)
        {
            return Convert.ToSingle(Value);
        }

        public string ToString(IFormatProvider provider)
        {
            return Convert.ToString(Value, CultureInfo.InvariantCulture);
        }

        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(Value);
        }

        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(Value);
        }

        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(Value);
        }

        public DateTime ToDateTime(IFormatProvider provider)
        {
            throw new InvalidCastException();
        }

        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return Convert.ChangeType(Value, conversionType);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/CSharp/cDouble.cs.meta`:

```meta
fileFormatVersion: 2
guid: 3c4e179a10d37ed4692f871c40ff77fa
timeCreated: 1491300122
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/CSharp/cFloat.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cFloat.cs
//  Info     : 反作弊 - float 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

namespace Aya.Security
{
    public struct cFloat : IAntiCheatValue<float>, IComparable, IFormattable, IConvertible, IComparable<float>, IEquatable<float>
    {
        #region Value

        public float Value
        {
            get
            {
                var v = new FloatIntBytesUnion {i = ~_value.i ^ cGlobal.Key};
                return v.f;
            }
            set
            {
                var v = new FloatIntBytesUnion {f = value};
                _value.i = ~v.i ^ cGlobal.Key;
            }
        }

        #endregion

        #region Parse

        public static cFloat TryParseAntiCheat(float value)
        {
            return (cFloat) value;
        }

        public static float TryParseSource(cFloat value)
        {
            return (float) value;
        }

        #endregion

        #region Enc & Dec

        [StructLayout(LayoutKind.Explicit)]
        private struct FloatIntBytesUnion
        {
            [FieldOffset(0)] public float f;
            [FieldOffset(0)] public int i;
            [FieldOffset(0)] public byte b1;
            [FieldOffset(1)] public byte b2;
            [FieldOffset(2)] public byte b3;
            [FieldOffset(3)] public byte b4;
        }

        private FloatIntBytesUnion _value;

        #endregion

        #region Override operator

        public static implicit operator cFloat(float value)
        {
            var ret = new cFloat {Value = value};
            return ret;
        }

        public static implicit operator float(cFloat obj)
        {
            return obj.Value;
        }

        public static cFloat operator ++(cFloat lhs)
        {
            return lhs.Value + 1;
        }

        public static cFloat operator --(cFloat lhs)
        {
            return lhs.Value - 1;
        }

        public static bool operator ==(cFloat lhs, cFloat rhs)
        {
            return Math.Abs(lhs.Value - rhs.Value) < 1e-6;
        }

        public static bool operator !=(cFloat lhs, cFloat rhs)
        {
            return Math.Abs(lhs.Value - rhs.Value) > 1e-6;
        }

        #endregion

        #region Override object

        public bool Equals(cFloat obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cFloat))
            {
                return false;
            }

            return this == (cFloat) obj;
        }

        public override string ToString()
        {
            return Value.ToString(CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return Value.ToString(format);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cFloat(SerializationInfo info, StreamingContext context)
        {
            _value = new FloatIntBytesUnion();
            Value = info.GetSingle("Value");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Value", Value);
        }

        #endregion

        #region IEquatable<T>

        public bool Equals(float obj)
        {
            return Value.Equals(obj);
        }

        #endregion

        #region IComparable<T>

        public int CompareTo(float other)
        {
            return Value.CompareTo(other);
        }

        #endregion

        #region IComparable

        public int CompareTo(object obj)
        {
            return Value.CompareTo(obj);
        }

        #endregion

        #region IFormattable

        public string ToString(string format, IFormatProvider formatProvider)
        {
            return Value.ToString(format, formatProvider);
        }

        #endregion

        #region IConvertible

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        public bool ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(Value);
        }

        public byte ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(Value);
        }

        public char ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(Value);
        }

        public decimal ToDecimal(IFormatProvider provider)
        {
            return Convert.ToDecimal(Value);
        }

        public double ToDouble(IFormatProvider provider)
        {
            return Convert.ToDouble(Value);
        }

        public short ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(Value);
        }

        public int ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32(Value);
        }

        public long ToInt64(IFormatProvider provider)
        {
            return Convert.ToInt64(Value);
        }

        public sbyte ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte(Value);
        }

        public float ToSingle(IFormatProvider provider)
        {
            return Value;
        }

        public string ToString(IFormatProvider provider)
        {
            return Convert.ToString(Value, CultureInfo.InvariantCulture);
        }

        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(Value);
        }

        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(Value);
        }

        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(Value);
        }

        public DateTime ToDateTime(IFormatProvider provider)
        {
            throw new InvalidCastException();
        }

        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return Convert.ChangeType(Value, conversionType);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/CSharp/cFloat.cs.meta`:

```meta
fileFormatVersion: 2
guid: fe1137e4b721e354182c0e106e681ee8
timeCreated: 1478006600
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/CSharp/cInt.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cInt.cs
//  Info     : 反作弊 - int 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Runtime.Serialization;

namespace Aya.Security
{
    public struct cInt : IAntiCheatValue<int>, IComparable, IFormattable, IConvertible, IComparable<int>, IEquatable<int>
    {
        #region Value

        public int Value
        {
            get => this;
            set => this = value;
        }

        private int _value;

        #endregion

        #region Parse

        public static cInt TryParseAntiCheat(int value)
        {
            return (cInt) value;
        }

        public static int TryParseSource(cInt value)
        {
            return (int) value;
        }

        #endregion

        #region Enc & Dec

        public static cInt Encode(int value)
        {
            cInt i;
            i._value = InternalEncode(value);
            return i;
        }

        public static int Decode(cInt value)
        {
            return InternalDecode(value._value);
        }

        internal static int InternalEncode(int value)
        {
            return ~value ^ cGlobal.Key;
        }

        internal static int InternalDecode(int value)
        {
            return ~value ^ cGlobal.Key;
        }

        #endregion

        #region Override operator

        public static implicit operator cInt(int value)
        {
            return Encode(value);
        }

        public static implicit operator int(cInt obj)
        {
            return Decode(obj);
        }

        public static cInt operator ++(cInt lhs)
        {
            return Decode(lhs) + 1;
        }

        public static cInt operator --(cInt lhs)
        {
            return Decode(lhs) - 1;
        }

        public static bool operator ==(cInt lhs, cInt rhs)
        {
            return lhs._value == rhs._value;
        }

        public static bool operator !=(cInt lhs, cInt rhs)
        {
            return lhs._value != rhs._value;
        }

        #endregion

        #region Override object

        public bool Equals(cInt obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cInt))
            {
                return false;
            }

            return this == (cInt) obj;
        }

        public override string ToString()
        {
            return Value.ToString();
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cInt(SerializationInfo info, StreamingContext context)
        {
            _value = 0;
            Value = info.GetInt32("Value");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Value", Value);
        }

        #endregion

        #region IEquatable<T>

        public bool Equals(int obj)
        {
            return Value.Equals(obj);
        }

        #endregion

        #region IComparable<T>

        public int CompareTo(int other)
        {
            return Value.CompareTo(other);
        }

        #endregion

        #region IComparable

        public int CompareTo(object obj)
        {
            return Value.CompareTo(obj);
        }

        #endregion

        #region IFormattable

        public string ToString(string format, IFormatProvider formatProvider)
        {
            return Value.ToString(format, formatProvider);
        }

        #endregion

        #region IConvertible

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        public bool ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(Value);
        }

        public byte ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(Value);
        }

        public char ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(Value);
        }

        public decimal ToDecimal(IFormatProvider provider)
        {
            return Convert.ToDecimal(Value);
        }

        public double ToDouble(IFormatProvider provider)
        {
            return Convert.ToDouble(Value);
        }

        public short ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(Value);
        }

        public int ToInt32(IFormatProvider provider)
        {
            return Value;
        }

        public long ToInt64(IFormatProvider provider)
        {
            return Convert.ToInt64(Value);
        }

        public sbyte ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte(Value);
        }

        public float ToSingle(IFormatProvider provider)
        {
            return Convert.ToSingle(Value);
        }

        public string ToString(IFormatProvider provider)
        {
            return Convert.ToString(Value);
        }

        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(Value);
        }

        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(Value);
        }

        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(Value);
        }

        public DateTime ToDateTime(IFormatProvider provider)
        {
            throw new InvalidCastException();
        }

        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return Convert.ChangeType(Value, conversionType);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/CSharp/cInt.cs.meta`:

```meta
fileFormatVersion: 2
guid: 20250f77a3a267f4eac90957c4e1a436
timeCreated: 1478006600
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/CSharp/cLong.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cLong.cs
//  Info     : 反作弊 - long 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Runtime.Serialization;

namespace Aya.Security
{
    public struct cLong : IAntiCheatValue<long>, IComparable, IFormattable, IConvertible, IComparable<long>, IEquatable<long>
    {
        #region Value

        public long Value
        {
            get => this;
            set => this = value;
        }

        private long _value;

        #endregion

        #region Parse

        public static cLong TryParseAntiCheat(long value)
        {
            return (cLong) value;
        }

        public static long TryParseSource(cLong value)
        {
            return (long) value;
        }

        #endregion

        #region Enc & Dec

        public static cLong Encode(long value)
        {
            cLong i;
            i._value = ~value ^ cGlobal.Key;
            return i;
        }

        public static long Decode(cLong value)
        {
            return ~value._value ^ cGlobal.Key;
        }

        #endregion

        #region Override operator

        public static implicit operator cLong(long value)
        {
            return Encode(value);
        }

        public static implicit operator long(cLong obj)
        {
            return Decode(obj);
        }

        public static cLong operator ++(cLong lhs)
        {
            return Decode(lhs) + 1;
        }

        public static cLong operator --(cLong lhs)
        {
            return Decode(lhs) - 1;
        }

        public static bool operator ==(cLong lhs, cLong rhs)
        {
            return lhs._value == rhs._value;
        }

        public static bool operator !=(cLong lhs, cLong rhs)
        {
            return lhs._value != rhs._value;
        }

        #endregion

        #region Override object

        public bool Equals(cLong obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cLong))
            {
                return false;
            }

            return this == (cLong) obj;
        }

        public override string ToString()
        {
            return Decode(this).ToString();
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cLong(SerializationInfo info, StreamingContext context)
        {
            _value = 0;
            Value = info.GetInt64("Value");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Value", Value);
        }

        #endregion

        #region IEquatable<T>

        public bool Equals(long obj)
        {
            return Value.Equals(obj);
        }

        #endregion

        #region IComparable<T>

        public int CompareTo(long other)
        {
            return Value.CompareTo(other);
        }

        #endregion

        #region IComparable

        public int CompareTo(object obj)
        {
            return Value.CompareTo(obj);
        }

        #endregion

        #region IFormattable

        public string ToString(string format, IFormatProvider formatProvider)
        {
            return Value.ToString(format, formatProvider);
        }

        #endregion

        #region IConvertible

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        public bool ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(Value);
        }

        public byte ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(Value);
        }

        public char ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(Value);
        }

        public decimal ToDecimal(IFormatProvider provider)
        {
            return Convert.ToDecimal(Value);
        }

        public double ToDouble(IFormatProvider provider)
        {
            return Convert.ToDouble(Value);
        }

        public short ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(Value);
        }

        public int ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32(Value);
        }

        public long ToInt64(IFormatProvider provider)
        {
            return Value;
        }

        public sbyte ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte(Value);
        }

        public float ToSingle(IFormatProvider provider)
        {
            return Convert.ToSingle(Value);
        }

        public string ToString(IFormatProvider provider)
        {
            return Convert.ToString(Value);
        }

        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(Value);
        }

        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(Value);
        }

        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(Value);
        }

        public DateTime ToDateTime(IFormatProvider provider)
        {
            throw new InvalidCastException();
        }

        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return Convert.ChangeType(Value, conversionType);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/CSharp/cLong.cs.meta`:

```meta
fileFormatVersion: 2
guid: 27225895b5e01304a8690f0641155ba2
timeCreated: 1478006600
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/CSharp/cShort.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cShort.cs
//  Info     : 反作弊 - short 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Runtime.Serialization;

namespace Aya.Security
{
    public struct cShort : IAntiCheatValue<short>, IComparable, IFormattable, IConvertible, IComparable<short>, IEquatable<short>
    {
        #region Value

        public short Value
        {
            get => this;
            set => this = value;
        }

        private short _value;

        #endregion

        #region Parse

        public static cShort TryParseAntiCheat(short value)
        {
            return (cShort) value;
        }

        public static short TryParseSource(cShort value)
        {
            return (short) value;
        }

        #endregion

        #region Enc & Dec

        public static cShort Encode(short value)
        {
            cShort i;
            i._value = (short) (~value ^ cGlobal.Key);
            return i;
        }

        public static short Decode(cShort value)
        {
            return (short) (~value._value ^ cGlobal.Key);
        }

        #endregion

        #region Override operator

        public static implicit operator cShort(short value)
        {
            return Encode(value);
        }

        public static implicit operator short(cShort obj)
        {
            return Decode(obj);
        }

        public static cShort operator ++(cShort lhs)
        {
            return (cShort) (Decode(lhs) + 1);
        }

        public static cShort operator --(cShort lhs)
        {
            return (cShort) (Decode(lhs) - 1);
        }

        public static bool operator ==(cShort lhs, cShort rhs)
        {
            return lhs._value == rhs._value;
        }

        public static bool operator !=(cShort lhs, cShort rhs)
        {
            return lhs._value != rhs._value;
        }

        #endregion

        #region Override object

        public bool Equals(cShort obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cShort))
            {
                return false;
            }

            return this == (cShort) obj;
        }

        public override string ToString()
        {
            return Decode(this).ToString();
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cShort(SerializationInfo info, StreamingContext context)
        {
            _value = 0;
            Value = info.GetInt16("Value");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Value", Value);
        }

        #endregion

        #region IEquatable<T>

        public bool Equals(short obj)
        {
            return Value.Equals(obj);
        }

        #endregion

        #region IComparable<T>

        public int CompareTo(short other)
        {
            return Value.CompareTo(other);
        }

        #endregion

        #region IComparable

        public int CompareTo(object obj)
        {
            return Value.CompareTo(obj);
        }

        #endregion

        #region IFormattable

        public string ToString(string format, IFormatProvider formatProvider)
        {
            return Value.ToString(format, formatProvider);
        }

        #endregion

        #region IConvertible

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        public bool ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(Value);
        }

        public byte ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(Value);
        }

        public char ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(Value);
        }

        public decimal ToDecimal(IFormatProvider provider)
        {
            return Convert.ToDecimal(Value);
        }

        public double ToDouble(IFormatProvider provider)
        {
            return Convert.ToDouble(Value);
        }

        public short ToInt16(IFormatProvider provider)
        {
            return Value;
        }

        public int ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32(Value);
        }

        public long ToInt64(IFormatProvider provider)
        {
            return Convert.ToInt64(Value);
        }

        public sbyte ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte(Value);
        }

        public float ToSingle(IFormatProvider provider)
        {
            return Convert.ToSingle(Value);
        }

        public string ToString(IFormatProvider provider)
        {
            return Convert.ToString(Value);
        }

        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(Value);
        }

        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(Value);
        }

        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(Value);
        }

        public DateTime ToDateTime(IFormatProvider provider)
        {
            throw new InvalidCastException();
        }

        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return Convert.ChangeType(Value, conversionType);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/CSharp/cShort.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5fe2ced500f0fc1499e1324124a77e04
timeCreated: 1491310429
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/CSharp/cString.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cString.cs
//  Info     : 反作弊 - string 等效加密类型，string 类型实时加密解密效率较低，仅限很重要的部分使用
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace Aya.Security
{
    public struct cString : IAntiCheatValue<string>, IComparable, ICloneable, IConvertible, IEnumerable, IComparable<string>, IEnumerable<char>, IEquatable<string>
    {
        #region Value

        public string Value
        {
            get => this;
            set => this = value;
        }

        private string _value;

        #endregion

        #region Parse

        public static cString TryParseAntiCheat(string value)
        {
            return (cString) value;
        }

        public static string TryParseSource(cString value)
        {
            return (string) value;
        }

        #endregion

        #region Enc & Dec

        public static cString Encode(string value)
        {
            cString s;
            s._value = AESUtil.Encrypt(value, cGlobal.KeyStr, cGlobal.KeyStr);
            return s;
        }

        public static string Decode(cString value)
        {
            return AESUtil.Decrypt(value._value, cGlobal.KeyStr, cGlobal.KeyStr);
        }

        #endregion

        #region Override operator

        public static implicit operator cString(string value)
        {
            return Encode(value);
        }

        public static implicit operator string(cString obj)
        {
            return Decode(obj);
        }

        public static bool operator ==(cString lhs, cString rhs)
        {
            return lhs._value == rhs._value;
        }

        public static bool operator !=(cString lhs, cString rhs)
        {
            return lhs._value != rhs._value;
        }

        #endregion

        #region Override object

        public bool Equals(cString obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cString))
            {
                return false;
            }

            return this == (cString) obj;
        }

        public override string ToString()
        {
            return Value;
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cString(SerializationInfo info, StreamingContext context)
        {
            _value = Encode(info.GetString("Value"));
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Value", Decode(_value));
        }

        #endregion

        #region IEquatable<T>

        public bool Equals(string obj)
        {
            return Value.Equals(obj);
        }

        #endregion

        #region IComparable<T>

        public int CompareTo(string other)
        {
            return string.Compare(Value, other, StringComparison.Ordinal);
        }

        #endregion

        #region IComparable

        public int CompareTo(object obj)
        {
            return Value.CompareTo(obj);
        }

        #endregion

        #region IConvertible

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        public bool ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(Value);
        }

        public byte ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(Value);
        }

        public char ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(Value);
        }

        public decimal ToDecimal(IFormatProvider provider)
        {
            return Convert.ToDecimal(Value);
        }

        public double ToDouble(IFormatProvider provider)
        {
            return Convert.ToDouble(Value);
        }

        public short ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(Value);
        }

        public int ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32(Value);
        }

        public long ToInt64(IFormatProvider provider)
        {
            return Convert.ToInt64(Value);
        }

        public sbyte ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte(Value);
        }

        public float ToSingle(IFormatProvider provider)
        {
            return Convert.ToSingle(Value);
        }

        public string ToString(IFormatProvider provider)
        {
            return Value;
        }

        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(Value);
        }

        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(Value);
        }

        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(Value);
        }

        public DateTime ToDateTime(IFormatProvider provider)
        {
            return Convert.ToDateTime(Value, provider);
        }

        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return Convert.ChangeType(Value, conversionType);
        }

        #endregion

        #region IEnumerator<T>

        public CharEnumerator GetEnumerator()
        {
            return Value.GetEnumerator();
        }

        IEnumerator<char> IEnumerable<char>.GetEnumerator()
        {
            return (IEnumerator<char>)GetEnumerator();
        }

        #endregion

        #region IEnumerator

        IEnumerator IEnumerable.GetEnumerator()
        {
            return (IEnumerator)GetEnumerator();
        }

        #endregion

        #region ICloneable

        public object Clone()
        {
            return (object)this;
        } 

        #endregion
    }
}
```

`AntiCheat/Script/DataType/CSharp/cString.cs.meta`:

```meta
fileFormatVersion: 2
guid: 926730ed9ac40744eab31335048bf094
timeCreated: 1491297411
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/Unity.meta`:

```meta
fileFormatVersion: 2
guid: 913ed688e4df8844fa2e250aa578a851
folderAsset: yes
timeCreated: 1496744259
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/Unity/cColor.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cColor.cs
//  Info     : 反作弊 - Color 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Runtime.Serialization;
using UnityEngine;

namespace Aya.Security
{
    public struct cColor : IAntiCheatValue<Color>, IEquatable<Color>
    {
        #region Value

        public Color Value
        {
            get => new Color(_r, _g, _b, _a);
            set
            {
                _r = value.r;
                _g = value.g;
                _b = value.b;
                _a = value.a;
            }
        }

        private cFloat _r;
        private cFloat _g;
        private cFloat _b;
        private cFloat _a;

        #endregion

        #region Parse

        public static cColor TryParseAntiCheat(Color value)
        {
            return (cColor)value;
        }

        public static Color TryParseSource(cColor value)
        {
            return (Color)value;
        }

        #endregion

        #region Override operator

        public static implicit operator cColor(Color value)
        {
            var ret = new cColor {Value = value};
            return ret;
        }

        public static implicit operator Color(cColor obj)
        {
            return obj.Value;
        }

        public static bool operator ==(cColor lhs, cColor rhs)
        {
            return lhs._r.Equals(rhs._r) && lhs._g.Equals(rhs._g) && lhs._b.Equals(rhs._b) && lhs._a.Equals(rhs._a);
        }

        public static bool operator !=(cColor lhs, cColor rhs)
        {
            return !lhs._r.Equals(rhs._r) || !lhs._g.Equals(rhs._g) || !lhs._b.Equals(rhs._b) || !lhs._a.Equals(rhs._a);

        }

        #endregion

        #region Override object

        public bool Equals(Color obj)
        {
            return obj.r.Equals(_r) && obj.g.Equals(_g) && obj.b.Equals(_b) && obj.a.Equals(_a);
        }

        public bool Equals(cColor obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cColor))
            {
                return false;
            }

            return this == (cColor) obj;
        }

        public override string ToString()
        {
            return Value.ToString();
        }

        public string ToString(string format)
        {
            return Value.ToString(format);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cColor(SerializationInfo info, StreamingContext context)
        {
            _r = info.GetSingle("R");
            _g = info.GetSingle("G");
            _b = info.GetSingle("B");
            _a = info.GetSingle("A");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("R", (float) _r);
            info.AddValue("G", (float) _g);
            info.AddValue("B", (float) _b);
            info.AddValue("A", (float) _a);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/Unity/cColor.cs.meta`:

```meta
fileFormatVersion: 2
guid: a0902862fb9dc9f408ce59b3eb1d4d96
timeCreated: 1496744275
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/Unity/cQuaternion.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cQuaternion.cs
//  Info     : 反作弊 - cQuaternion 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Runtime.Serialization;
using UnityEngine;

namespace Aya.Security
{
    public struct cQuaternion : IAntiCheatValue<Quaternion>, IEquatable<Quaternion>
    {
        #region Value

        public Quaternion Value
        {
            get => new Quaternion(_x, _y, _z, _w);
            set
            {
                _x = value.x;
                _y = value.y;
                _z = value.z;
                _w = value.w;
            }
        }

        private cFloat _x;
        private cFloat _y;
        private cFloat _z;
        private cFloat _w;

        #endregion

        #region Parse

        public static cQuaternion TryParseAntiCheat(Quaternion value)
        {
            return (cQuaternion) value;
        }

        public static Quaternion TryParseSource(cQuaternion value)
        {
            return (Quaternion) value;
        }

        #endregion

        #region Override operator

        public static implicit operator cQuaternion(Quaternion value)
        {
            var ret = new cQuaternion {Value = value};
            return ret;
        }

        public static implicit operator Quaternion(cQuaternion obj)
        {
            return obj.Value;
        }

        public static bool operator ==(cQuaternion lhs, cQuaternion rhs)
        {
            return Math.Abs(lhs._x - rhs._x) < 1e-6 && Math.Abs(lhs._y - rhs._y) < 1e-6 && Math.Abs(lhs._z - rhs._z) < 1e-6 && Math.Abs(lhs._w - rhs._w) < 1e-6;
        }

        public static bool operator !=(cQuaternion lhs, cQuaternion rhs)
        {
            return Math.Abs(lhs._x - rhs._x) >= 1e-6 && Math.Abs(lhs._y - rhs._y) >= 1e-6 && Math.Abs(lhs._z - rhs._z) >= 1e-6 && Math.Abs(lhs._w - rhs._w) >= 1e-6;

        }

        #endregion

        #region Override object

        public bool Equals(Quaternion obj)
        {
            return Math.Abs(Value.x - obj.x) < 1e-6 && Math.Abs(Value.y - obj.y) < 1e-6 && Math.Abs(Value.z - obj.z) < 1e-6 && Math.Abs(Value.w - obj.w) < 1e-6;
        }

        public bool Equals(cQuaternion obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cQuaternion))
            {
                return false;
            }

            return this == (cQuaternion) obj;
        }

        public override string ToString()
        {
            return Value.ToString();
        }

        public string ToString(string format)
        {
            return Value.ToString(format);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cQuaternion(SerializationInfo info, StreamingContext context)
        {
            _x = info.GetSingle("X");
            _y = info.GetSingle("Y");
            _z = info.GetSingle("Z");
            _w = info.GetSingle("W");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("X", (float) _x);
            info.AddValue("Y", (float) _y);
            info.AddValue("Z", (float) _z);
            info.AddValue("W", (float) _w);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/Unity/cQuaternion.cs.meta`:

```meta
fileFormatVersion: 2
guid: 757745621d4c98d458f9ad2f2784acfc
timeCreated: 1496744275
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/Unity/cVector2.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cVector2.cs
//  Info     : 反作弊 - Vector2 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Runtime.Serialization;
using UnityEngine;

namespace Aya.Security
{
    public struct cVector2 : IAntiCheatValue<Vector2>, IEquatable<Vector2>
    {
        #region Value

        public Vector2 Value
        {
            get => new Vector2(_x, _y);
            set
            {
                _x = value.x;
                _y = value.y;
            }
        }

        private cFloat _x;
        private cFloat _y;

        #endregion

        #region Parse

        public static cVector2 TryParseAntiCheat(Vector2 value)
        {
            return (cVector2) value;
        }

        public static Vector2 TryParseSource(cVector2 value)
        {
            return (Vector2) value;
        }

        #endregion

        #region Override operator

        public static implicit operator cVector2(Vector2 value)
        {
            var ret = new cVector2 {Value = value};
            return ret;
        }

        public static implicit operator Vector2(cVector2 obj)
        {
            return obj.Value;
        }

        public static bool operator ==(cVector2 lhs, cVector2 rhs)
        {
            return Math.Abs(lhs._x - rhs._x) < 1e-6 && Math.Abs(lhs._y - rhs._y) < 1e-6;
        }

        public static bool operator !=(cVector2 lhs, cVector2 rhs)
        {
            return Math.Abs(lhs._x - rhs._x) >= 1e-6 && Math.Abs(lhs._y - rhs._y) >= 1e-6;

        }

        #endregion

        #region Override object

        public bool Equals(Vector2 obj)
        {
            return Math.Abs(Value.x - obj.x) < 1e-6 && Math.Abs(Value.y - obj.y) < 1e-6;
        }

        public bool Equals(cVector2 obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cVector2))
            {
                return false;
            }

            return this == (cVector2) obj;
        }

        public override string ToString()
        {
            return Value.ToString();
        }

        public string ToString(string format)
        {
            return Value.ToString(format);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cVector2(SerializationInfo info, StreamingContext context)
        {
            _x = info.GetSingle("X");
            _y = info.GetSingle("Y");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("X", (float) _x);
            info.AddValue("Y", (float) _y);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/Unity/cVector2.cs.meta`:

```meta
fileFormatVersion: 2
guid: 88559685ed24376438e0f7b57193d032
timeCreated: 1496744275
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/Unity/cVector3.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cVector3.cs
//  Info     : 反作弊 - Vector3 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Runtime.Serialization;
using UnityEngine;

namespace Aya.Security
{
    public struct cVector3 : IAntiCheatValue<Vector3>, IEquatable<Vector3>
    {
        #region Value

        public Vector3 Value
        {
            get => new Vector3(_x, _y, _z);
            set
            {
                _x = value.x;
                _y = value.y;
                _z = value.z;
            }
        }

        private cFloat _x;
        private cFloat _y;
        private cFloat _z;

        #endregion

        #region Parse

        public static cVector3 TryParseAntiCheat(Vector3 value)
        {
            return (cVector3) value;
        }

        public static Vector3 TryParseSource(cVector3 value)
        {
            return (Vector3) value;
        }

        #endregion

        #region Override operator

        public static implicit operator cVector3(Vector3 value)
        {
            var ret = new cVector3 {Value = value};
            return ret;
        }

        public static implicit operator Vector3(cVector3 obj)
        {
            return obj.Value;
        }

        public static bool operator ==(cVector3 lhs, cVector3 rhs)
        {
            return Math.Abs(lhs._x - rhs._x) < 1e-6 && Math.Abs(lhs._y - rhs._y) < 1e-6 && Math.Abs(lhs._z - rhs._z) < 1e-6;
        }

        public static bool operator !=(cVector3 lhs, cVector3 rhs)
        {
            return Math.Abs(lhs._x - rhs._x) >= 1e-6 && Math.Abs(lhs._y - rhs._y) >= 1e-6 && Math.Abs(lhs._z - rhs._z) >= 1e-6;

        }

        #endregion

        #region Override object

        public bool Equals(Vector3 obj)
        {
            return Math.Abs(Value.x - obj.x) < 1e-6 && Math.Abs(Value.y - obj.y) < 1e-6 && Math.Abs(Value.z - obj.z) < 1e-6;
        }

        public bool Equals(cVector3 obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cVector3))
            {
                return false;
            }

            return this == (cVector3) obj;
        }

        public override string ToString()
        {
            return Value.ToString();
        }

        public string ToString(string format)
        {
            return Value.ToString(format);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cVector3(SerializationInfo info, StreamingContext context)
        {
            _x = info.GetSingle("X");
            _y = info.GetSingle("Y");
            _z = info.GetSingle("Z");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("X", (float) _x);
            info.AddValue("Y", (float) _y);
            info.AddValue("Z", (float) _z);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/Unity/cVector3.cs.meta`:

```meta
fileFormatVersion: 2
guid: d0ef48cef09164c4ab3ccae77ca35668
timeCreated: 1496744275
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/DataType/Unity/cVector4.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : cVector4.cs
//  Info     : 反作弊 - Vector4 等效加密类型
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Runtime.Serialization;
using UnityEngine;

namespace Aya.Security
{
    public struct cVector4 : IAntiCheatValue<Vector4>, IEquatable<Vector4>
    {
        #region Value

        public Vector4 Value
        {
            get => new Vector4(_x, _y, _z, _w);
            set
            {
                _x = value.x;
                _y = value.y;
                _z = value.z;
                _w = value.w;
            }
        }

        private cFloat _x;
        private cFloat _y;
        private cFloat _z;
        private cFloat _w;

        #endregion

        #region Parse

        public static cVector4 TryParseAntiCheat(Vector4 value)
        {
            return (cVector4) value;
        }

        public static Vector4 TryParseSource(cVector4 value)
        {
            return (Vector4) value;
        }

        #endregion

        #region Override operator

        public static implicit operator cVector4(Vector4 value)
        {
            var ret = new cVector4 {Value = value};
            return ret;
        }

        public static implicit operator Vector4(cVector4 obj)
        {
            return obj.Value;
        }

        public static bool operator ==(cVector4 lhs, cVector4 rhs)
        {
            return Math.Abs(lhs._x - rhs._x) < 1e-6 && Math.Abs(lhs._y - rhs._y) < 1e-6 && Math.Abs(lhs._z - rhs._z) < 1e-6 && Math.Abs(lhs._w - rhs._w) < 1e-6;
        }

        public static bool operator !=(cVector4 lhs, cVector4 rhs)
        {
            return Math.Abs(lhs._x - rhs._x) >= 1e-6 && Math.Abs(lhs._y - rhs._y) >= 1e-6 && Math.Abs(lhs._z - rhs._z) >= 1e-6 && Math.Abs(lhs._w - rhs._w) >= 1e-6;
        }

        #endregion

        #region Override object

        public bool Equals(Vector4 obj)
        {
            return Math.Abs(Value.x - obj.x) < 1e-6 && Math.Abs(Value.y - obj.y) < 1e-6 && Math.Abs(Value.z - obj.z) < 1e-6 && Math.Abs(Value.w - obj.w) < 1e-6;
        }

        public bool Equals(cVector4 obj)
        {
            return this == obj;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is cVector4))
            {
                return false;
            }

            return this == (cVector4) obj;
        }

        public override string ToString()
        {
            return Value.ToString();
        }

        public string ToString(string format)
        {
            return Value.ToString(format);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region ISerializable

        public cVector4(SerializationInfo info, StreamingContext context)
        {
            _x = info.GetSingle("X");
            _y = info.GetSingle("Y");
            _z = info.GetSingle("Z");
            _w = info.GetSingle("W");
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("X", (float) _x);
            info.AddValue("Y", (float) _y);
            info.AddValue("Z", (float) _z);
            info.AddValue("W", (float) _w);
        }

        #endregion
    }
}
```

`AntiCheat/Script/DataType/Unity/cVector4.cs.meta`:

```meta
fileFormatVersion: 2
guid: c8013a90a46a9444897dc114f4249bbe
timeCreated: 1496744275
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`AntiCheat/Script/PlayerPrefsAES.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : PlayerPrefsAES.cs
//  Info     : PlayerPrefs加密存储辅助类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System.Globalization;
using UnityEngine;

namespace Aya.Security
{
	public static class PlayerPrefsAES
	{
		#region string

		public static void SetString(string key, string value)
		{
			PlayerPrefs.SetString(MD5Util.GetMd5(key), AESUtil.Encrypt(value, AESKey.DefaultKey, AESKey.DefaultIV));
		}

		public static string GetString(string key, string defaultValue = default(string))
		{
			var result = PlayerPrefs.GetString(MD5Util.GetMd5(key));
			return string.IsNullOrEmpty(result) ? defaultValue : AESUtil.Decrypt(result, AESKey.DefaultKey, AESKey.DefaultIV);
		}

		#endregion

		#region int

		public static void SetInt(string key, int value)
		{
			SetString(key, value.ToString());
		}

		public static int GetInt(string key, int defaultValue = default(int))
		{
			var s = GetString(key);
		    return int.TryParse(s, out var ret) ? ret : defaultValue;
		}

		#endregion

		#region long

		public static void SetLong(string key, long value)
		{
			SetString(key, value.ToString());
		}

		public static long GetLong(string key, long defaultValue = default(long))
		{
			var s = GetString(key);
            return long.TryParse(s, out var ret) ? ret : defaultValue;
		}

		#endregion

		#region float

		public static void SetFloat(string key, float value)
		{
			SetString(key, value.ToString(CultureInfo.InvariantCulture));
		}

		public static float GetFloat(string key, float defaultValue = default(float))
		{
			var s = GetString(key);
            return float.TryParse(s, out var ret) ? ret : defaultValue;
		}

		#endregion

		#region double

		public static void SetDouble(string key, double value)
		{
			SetString(key, value.ToString(CultureInfo.InvariantCulture));
		}

		public static double GetDouble(string key, double defaultValue = default(int))
		{
			var s = GetString(key);
            return double.TryParse(s, out var ret) ? ret : defaultValue;
		}

		#endregion

		#region bool

		public static void SetBool(string key, bool value)
		{
			SetString(key, value.ToString());
		}

		public static bool GetBool(string key, bool defaultValue = default(bool))
		{
			var s = GetString(key);
            return bool.TryParse(s, out var ret) ? ret : defaultValue;
		}

        #endregion

        #region Has

        public static bool HasKey(string key)
        {
            return PlayerPrefs.HasKey(MD5Util.GetMd5(key));
        }

        #endregion

        #region Delete

        public static void DeleteKey(string key)
		{
			PlayerPrefs.DeleteKey(MD5Util.GetMd5(key));
		}

		public static void DeleteAll()
		{
			PlayerPrefs.DeleteAll();
		}

        #endregion

        #region Save

        public static void Save()
        {
            PlayerPrefs.Save();
        }

        #endregion
    }
}

```

`AntiCheat/Script/PlayerPrefsAES.cs.meta`:

```meta
fileFormatVersion: 2
guid: 1e8bc459fffa2cb4fa0be1d5e727f425
timeCreated: 1478007872
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`DFA.meta`:

```meta
fileFormatVersion: 2
guid: b0556953b24f8f444a541e73e2394a73
folderAsset: yes
timeCreated: 1495112082
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`DFA/Script.meta`:

```meta
fileFormatVersion: 2
guid: 6dbfddd8547ab754e8dbd36e1c49088e
folderAsset: yes
timeCreated: 1495112557
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`DFA/Script/DFANode.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : DFANode.cs
//  Info     : 敏感词过滤 -- 查找树节点
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System.Collections.Generic;

namespace Aya.Security
{
	internal class DFANode
	{
		public char Char;
		public int Flag;
		public List<DFANode> Nodes;

		public DFANode(char c)
		{
			Nodes = new List<DFANode>();
			Char = c;
			Flag = 0;
		}

		public DFANode(char c, int flag)
		{
			Nodes = new List<DFANode>();
			Char = c;
			Flag = flag;
		}
	}
}
```

`DFA/Script/DFANode.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8d44215b352ddc14b80804cc24ca9ee6
timeCreated: 1495113370
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`DFA/Script/DFAUtil.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : DFAUtil.cs
//  Info     : 敏感词过滤辅助类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Text;

namespace Aya.Security
{
    public class DFAUtil
    {
        public static bool IsInit { get; private set; }
        public static string ReplaceSymbol = "*";
        public static string[] Separator = new[] { ",", "\n", "\r" };

        private static readonly DFANode RootDfaNode = new DFANode('R');
        private static readonly List<string> Word = new List<string>();

        /// <summary>
        /// 初始化敏感字过滤
        /// </summary>
        /// <param name="dfaText">敏感词数据文件</param>
        public static void Init(string dfaText)
        {
            if (IsInit) return;
            CreateTree(dfaText.Split(Separator, StringSplitOptions.RemoveEmptyEntries));
            IsInit = true;
        }

        /// <summary>
        /// 过滤词汇
        /// </summary>
        /// <param name="input">输入</param>
        /// <param name="isLimit">是否被过滤</param>
        /// <returns>输出</returns>
        public static string FilterWords(string input, out bool isLimit)
        {
            isLimit = false;
            if (!IsInit)
            {
                return input;
            }

            var index = 0;
            Word.Clear();
            var chArray = input.ToCharArray();
            var rootNode = RootDfaNode;
            var builder = new StringBuilder();
            while (index < chArray.Length)
            {
                var c = chArray[index];
                if (char.IsUpper(c))
                {
                    c = c.ToString().ToLower()[0];
                }

                rootNode = FindNode(rootNode, c);
                if (rootNode == null)
                {
                    rootNode = RootDfaNode;
                    Word.Clear();
                    rootNode = FindNode(rootNode, c);
                    if (rootNode == null)
                    {
                        builder.Append(chArray[index]);
                        rootNode = RootDfaNode;
                    }
                    else
                    {
                        Word.Add(chArray[0].ToString());
                        builder.Append(chArray[index]);
                    }
                }
                else if (rootNode.Flag == 1)
                {
                    Word.Add(chArray[index].ToString());
                    builder.Append(chArray[index]);
                    var builder2 = new StringBuilder();
                    builder2.Append(ReplaceSymbol);
                    builder.Remove(builder.Length - Word.Count, Word.Count);
                    builder.Append(builder2);
                    Word.Clear();
                    rootNode = RootDfaNode;
                    isLimit = true;
                }
                else
                {
                    Word.Add(chArray[index].ToString());
                    builder.Append(chArray[index]);
                }

                index++;
            }

            return builder.ToString();
        }

        #region Private

        /// <summary>
        /// 创建查找树
        /// </summary>
        /// <param name="arr">字符串数组</param>
        private static void CreateTree(string[] arr)
        {
            for (var i = 0; i < arr.Length; i++)
            {
                var str = arr[i];
                var cs = str.Trim().ToLower().ToCharArray();
                if (cs.Length > 0)
                {
                    InsertNode(RootDfaNode, cs, 0);
                }
            }
        }

        /// <summary>
        /// 查找节点
        /// </summary>
        /// <param name="dfaNode">父节点</param>
        /// <param name="c">字符</param>
        /// <returns>结果</returns>
        private static DFANode FindNode(DFANode dfaNode, char c)
        {
            var nodes = dfaNode.Nodes;
            for (var i = 0; i < nodes.Count; i++)
            {
                var n = nodes[i];
                if (n.Char == c)
                {
                    return n;
                }
            }

            return null;
        }

        /// <summary>
        /// 插入节点
        /// </summary>
        /// <param name="dfaNode">父节点</param>
        /// <param name="cs">字符数组</param>
        /// <param name="index">索引</param>
        private static void InsertNode(DFANode dfaNode, char[] cs, int index)
        {
            var item = FindNode(dfaNode, cs[index]);
            if (item == null)
            {
                item = new DFANode(cs[index]);
                dfaNode.Nodes.Add(item);
            }

            if (index == (cs.Length - 1))
            {
                item.Flag = 1;
            }

            index++;
            if (index < cs.Length)
            {
                InsertNode(item, cs, index);
            }
        }

        #endregion
    }
}
```

`DFA/Script/DFAUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: ddb6c7a66e54080478ae7d8dbdd7a8ae
timeCreated: 1495112591
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec.meta`:

```meta
fileFormatVersion: 2
guid: 0f283de94accd10499e712b75794fd41
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/AES.meta`:

```meta
fileFormatVersion: 2
guid: 7ddc4aa91b225124ca56145411e342b1
folderAsset: yes
timeCreated: 1478003570
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/AES/Resources.meta`:

```meta
fileFormatVersion: 2
guid: 2e6d92dafe0fac7418f4f8d953c85028
folderAsset: yes
timeCreated: 1510291700
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/AES/Resources/AESKey.asset`:

```asset
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c3422a09c785d7f41ba179ed05a8c82e, type: 3}
  m_Name: AESKey
  m_EditorClassIdentifier: 
  key: 6fae8dece809ded1
  iv: 22f16ccfe67d787b

```

`EncDec/AES/Resources/AESKey.asset.meta`:

```meta
fileFormatVersion: 2
guid: 68fe750f411fbee469f498539250180e
timeCreated: 1442401803
licenseType: Pro
NativeFormatImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/AES/Script.meta`:

```meta
fileFormatVersion: 2
guid: 4927c02a4b39c8046a9804604e01762a
folderAsset: yes
timeCreated: 1510291688
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/AES/Script/AESFileUtil.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : AESFileUtil.cs
//  Info     : AES文件加密辅助类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System.IO;

    namespace Aya.Security
    {
        public static class AESFileUtil
        {
            #region Read & Write string

            public static string ReadAllText(string path, string key, string iv)
            {
                var text = File.ReadAllText(path);
                return AESUtil.Decrypt(text, key, iv);
            }

            public static void WriteAllText(string path, string text, string key, string iv)
            {
                var bs = AESUtil.Encrypt(text, key, iv);
                File.WriteAllText(path, bs);
            }

            #endregion

            #region Read & Write byte[]

            public static byte[] ReadAllBytes(string path, string key, string iv)
            {
                var text = File.ReadAllBytes(path);
                return AESUtil.Decrypt(text, key, iv);
            }

            public static void WriteAllBytes(string path, byte[] bytes, string key, string iv)
            {
                var bs = AESUtil.Encrypt(bytes, key, iv);
                File.WriteAllBytes(path, bs);
            }

            #endregion
        }
    }
```

`EncDec/AES/Script/AESFileUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: 423385183cbe7f545aec73b675957467
timeCreated: 1442396666
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/AES/Script/AESKey.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : AESKey.cs
//  Info     : AES密钥
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using UnityEngine;

namespace Aya.Security
{
    [CreateAssetMenu(menuName = "USecurity/AESKey")]
    public class AESKey : ScriptableObject
    {
        private const string DEFAULT_KEY = "AESKey";

        public string key;
        public string iv;

        public void Reset()
        {
            CreateKey();
        }

        [ContextMenu("Create Key")]
        public void CreateKey()
        {
            key = USecurityUtil.RandHexString(16);
            iv = USecurityUtil.RandHexString(16);
        }

        public static string DefaultKey
        {
            get
            {
                if (string.IsNullOrEmpty(_defaultKey))
                {
                    _defaultKey = Key(DEFAULT_KEY);
                }

                return _defaultKey;
            }
        }

        private static string _defaultKey;

        public static string DefaultIV
        {
            get
            {
                if (string.IsNullOrEmpty(_defaultIv))
                {
                    _defaultIv = IV(DEFAULT_KEY);
                }

                return IV(DEFAULT_KEY);
            }
        }

        private static string _defaultIv;

        public static string Key(string keyName)
        {
            var asset = USecurityInterface.Load(keyName) as AESKey;
            if (asset == null)
            {
                throw new NullReferenceException();
            }

            return asset.key;
        }

        public static string IV(string keyName)
        {
            var asset = USecurityInterface.Load(keyName) as AESKey;
            if (asset == null)
            {
                throw new NullReferenceException();
            }

            return asset.iv;
        }
    }
}
```

`EncDec/AES/Script/AESKey.cs.meta`:

```meta
fileFormatVersion: 2
guid: c3422a09c785d7f41ba179ed05a8c82e
timeCreated: 1442396666
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/AES/Script/AESUtil.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : AESUtil.cs
//  Info     : AES加密辅助类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Security.Cryptography;
using System.Text;

namespace Aya.Security
{
    public static class AESUtil
    {
        #region Enc & Dec string

        public static string Encrypt(string str)
        {
            return Encrypt(str, AESKey.DefaultKey, AESKey.DefaultIV);
        }

        public static string Decrypt(string str)
        {
            return Decrypt(str, AESKey.DefaultKey, AESKey.DefaultIV);
        }

        public static string Encrypt(string data, string key, string iv)
        {
            var bytes = Encoding.UTF8.GetBytes(data);
            var result = Encrypt(bytes, key, iv);
            return Encoding.UTF8.GetString(result);
        }

        public static string Decrypt(string data, string key, string iv)
        {
            var result = DecryptInternal(data, key, iv);
            return Encoding.UTF8.GetString(result);
        }

        #endregion

        #region Enc & Dec byte[]

        public static byte[] Encrypt(byte[] bytes)
        {
            return Encrypt(bytes, AESKey.DefaultKey, AESKey.DefaultIV);
        }

        public static byte[] Decrypt(byte[] bytes)
        {
            return Decrypt(bytes, AESKey.DefaultKey, AESKey.DefaultIV);
        }

        public static byte[] Encrypt(byte[] data, string key, string iv)
        {
            var bKey = Encoding.UTF8.GetBytes(key);
            var ivArray = Encoding.UTF8.GetBytes(iv);

            var rDel = new RijndaelManaged
            {
                Key = bKey,
                IV = ivArray,
                Mode = CipherMode.CBC,
                Padding = PaddingMode.Zeros
            };
            var cTransform = rDel.CreateEncryptor();
            var result = cTransform.TransformFinalBlock(data, 0, data.Length);
            return Encoding.UTF8.GetBytes(Convert.ToBase64String(result, 0, result.Length));
        }

        public static byte[] Decrypt(byte[] data, string key, string iv)
        {
            return DecryptInternal(Encoding.UTF8.GetString(data), key, iv);
        }

        #endregion

        #region Private

        private static byte[] DecryptInternal(string data, string key, string iv)
        {
            var toDecrypt = Convert.FromBase64String(data);
            var keyArray = Encoding.UTF8.GetBytes(key);
            var ivArray = Encoding.UTF8.GetBytes(iv);

            var rDel = new RijndaelManaged
            {
                Key = keyArray,
                IV = ivArray,
                Mode = CipherMode.CBC,
                Padding = PaddingMode.Zeros
            };

            var cTransform = rDel.CreateDecryptor();
            var result = cTransform.TransformFinalBlock(toDecrypt, 0, toDecrypt.Length);
            // 移除解码后的尾部的空字节
            var i = result.Length - 1;
            while (i >= 0 && result[i] == 0)
            {
                --i;
            }

            var trimed = new byte[i + 1];
            Array.Copy(result, trimed, i + 1);
            return trimed;
        }

        #endregion
    }
}
```

`EncDec/AES/Script/AESUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: 245b51864cb72a8489081d0aea7ea436
timeCreated: 1442395346
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/Base64.meta`:

```meta
fileFormatVersion: 2
guid: b83083d0807ff904f8b6c3ee214780a9
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/Base64/Script.meta`:

```meta
fileFormatVersion: 2
guid: a538d664967d2ed4ba30041d2f5470a5
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/Base64/Script/Base64Util.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : Base64Util.cs
//  Info     : Base64 加密辅助类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Text;

namespace Aya.Security
{
    public static class Base64Util
    {
        public static string Encode(string str)
        {
            var mod4 = str.Length % 4;
            if (mod4 > 0)
            {
                str += new string('=', 4 - mod4);
            }
            var plainTextBytes = Encoding.UTF8.GetBytes(str);
            return Convert.ToBase64String(plainTextBytes);
        }

        public static string Decode(string str)
        {
            var base64EncodedBytes = Convert.FromBase64String(str);
            return Encoding.UTF8.GetString(base64EncodedBytes);
        }
    }
}
```

`EncDec/Base64/Script/Base64Util.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5b11c5f646d163742a76d8f3ba321e09
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/DES.meta`:

```meta
fileFormatVersion: 2
guid: d3b83b49c6724444db86f50c81267162
folderAsset: yes
timeCreated: 1478003570
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/DES/Resources.meta`:

```meta
fileFormatVersion: 2
guid: 044c61c56e552844f8639321cd58bbda
folderAsset: yes
timeCreated: 1510291722
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/DES/Resources/DESKey.asset`:

```asset
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 83f0480e4399494478466037346d413c, type: 3}
  m_Name: DESKey
  m_EditorClassIdentifier: 
  key: d20955a4
  iv: 758e015e

```

`EncDec/DES/Resources/DESKey.asset.meta`:

```meta
fileFormatVersion: 2
guid: febe87a103b5dea49ba76c5bc4100d57
NativeFormatImporter:
  userData: 

```

`EncDec/DES/Script.meta`:

```meta
fileFormatVersion: 2
guid: cedaa8b2fa8020845adeb0f317bf246d
folderAsset: yes
timeCreated: 1510291712
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/DES/Script/DESFileUtil.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : DESFileUtil.cs
//  Info     : DES文件加密辅助类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System.IO;

namespace Aya.Security
{
	public static class DESFileUtil
	{
		#region Read & Write string

		public static string ReadAllText(string path, string key, string iv)
		{
			var text = File.ReadAllText(path);
			return DESUtil.Decrypt(text, key, iv);
		}

		public static void WriteAllText(string path, string text, string key, string iv)
		{
			var bs = DESUtil.Encrypt(text, key, iv);
			File.WriteAllText(path, bs);
		}

		#endregion

		#region Read & Write byte[]

		public static byte[] ReadAllBytes(string path, string key, string iv)
		{
			var text = File.ReadAllBytes(path);
			return DESUtil.Decrypt(text, key, iv);
		}

		public static void WriteAllBytes(string path, byte[] bytes, string key, string iv)
		{
			var bs = DESUtil.Encrypt(bytes, key, iv);
			File.WriteAllBytes(path, bs);
		}

		#endregion
	}
}

```

`EncDec/DES/Script/DESFileUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: d728468cd8e67994bb4ab40628b311ab
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 

```

`EncDec/DES/Script/DESKey.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : DESKey.cs
//  Info     : DES密钥
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using UnityEngine;

namespace Aya.Security
{
    [CreateAssetMenu(menuName = "USecurity/DESKey")]
    public class DESKey : ScriptableObject
    {
        public const string DEFAULT_KEY = "DESKey";

        public string key;
        public string iv;

        public void Reset()
        {
            CreateKey();
        }

        [ContextMenu("Create Key")]
        public void CreateKey()
        {
            key = USecurityUtil.RandHexString(8);
            iv = USecurityUtil.RandHexString(8);
        }

        public static string DefaultKey
        {
            get
            {
                if (string.IsNullOrEmpty(_defaultKey))
                {
                    _defaultKey = Key(DEFAULT_KEY);
                }

                return _defaultKey;
            }
        }

        private static string _defaultKey;

        public static string DefaultIV
        {
            get
            {
                if (string.IsNullOrEmpty(_defaultIv))
                {
                    _defaultIv = IV(DEFAULT_KEY);
                }

                return IV(DEFAULT_KEY);
            }
        }

        private static string _defaultIv;

        public static string Key(string keyName)
        {
            var asset = USecurityInterface.Load(keyName) as DESKey;
            if (asset == null)
            {
                throw new NullReferenceException();
            }

            return asset.key;
        }

        public static string IV(string keyName)
        {
            var asset = USecurityInterface.Load(keyName) as DESKey;
            if (asset == null)
            {
                throw new NullReferenceException();
            }

            return asset.iv;
        }
    }
}
```

`EncDec/DES/Script/DESKey.cs.meta`:

```meta
fileFormatVersion: 2
guid: 83f0480e4399494478466037346d413c
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 

```

`EncDec/DES/Script/DESUtil.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : DESUtil.cs
//  Info     : DES加密辅助类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Aya.Security
{
    public static class DESUtil
    {
        #region Enc & Dec string

        public static string Encrypt(string str)
        {
            return Encrypt(str, DESKey.DefaultKey, DESKey.DefaultIV);
        }

        public static string Decrypt(string str)
        {
            return Decrypt(str, DESKey.DefaultKey, DESKey.DefaultIV);
        }

        public static string Encrypt(string text, string key, string iv)
        {
            using (var provider = new DESCryptoServiceProvider())
            {
                var bytes = Encoding.UTF8.GetBytes(text);
                provider.Key = Encoding.ASCII.GetBytes(key);
                provider.IV = Encoding.ASCII.GetBytes(iv);
                var stream = new MemoryStream();
                using (var stream2 = new CryptoStream(stream, provider.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    stream2.Write(bytes, 0, bytes.Length);
                    stream2.FlushFinalBlock();
                    stream2.Close();
                }

                var str = Convert.ToBase64String(stream.ToArray());
                stream.Close();
                return str;
            }
        }

        public static string Decrypt(string text, string key, string iv)
        {
            using (var provider = new DESCryptoServiceProvider
            {
                Key = Encoding.ASCII.GetBytes(key),
                IV = Encoding.ASCII.GetBytes(iv)
            })
            {
                var stream = new MemoryStream();
                using (var stream2 = new CryptoStream(stream, provider.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    var buffer = Convert.FromBase64String(text);
                    stream2.Write(buffer, 0, buffer.Length);
                    stream2.FlushFinalBlock();
                    stream2.Close();
                }

                var str = Encoding.UTF8.GetString(stream.ToArray());
                stream.Close();
                return str;
            }
        }

        #endregion

        #region Enc & Dec byte[]

        public static byte[] Encrypt(byte[] bytes)
        {
            return Encrypt(bytes, DESKey.DefaultKey, DESKey.DefaultIV);
        }

        public static byte[] Decrypt(byte[] bytes)
        {
            return Decrypt(bytes, DESKey.DefaultKey, DESKey.DefaultIV);
        }

        public static byte[] Encrypt(byte[] bytes, string key, string iv)
        {
            using (var provider = new DESCryptoServiceProvider
            {
                Key = Encoding.ASCII.GetBytes(key),
                IV = Encoding.ASCII.GetBytes(iv)
            })
            {
                var stream = new MemoryStream();
                using (var stream2 = new CryptoStream(stream, provider.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    stream2.Write(bytes, 0, bytes.Length);
                    stream2.FlushFinalBlock();
                    stream2.Close();
                }

                var convertByte = new byte[stream.ToArray().Length];
                Array.Copy(stream.ToArray(), convertByte, stream.ToArray().Length);
                stream.Close();
                return convertByte;
            }
        }

        public static byte[] Decrypt(byte[] bytes, string key, string iv)
        {
            using (var provider = new DESCryptoServiceProvider
            {
                Key = Encoding.ASCII.GetBytes(key),
                IV = Encoding.ASCII.GetBytes(iv)
            })
            {
                var stream = new MemoryStream();
                using (var stream2 = new CryptoStream(stream, provider.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    stream2.Write(bytes, 0, bytes.Length);
                    stream2.FlushFinalBlock();
                    stream2.Close();
                }

                var convertByte = new byte[stream.ToArray().Length];
                Array.Copy(stream.ToArray(), convertByte, stream.ToArray().Length);
                stream.Close();
                return convertByte;
            }
        }

        #endregion
    }
}
```

`EncDec/DES/Script/DESUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0f50c374e805a7342badf056f6b31a3b
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 

```

`EncDec/Extension.meta`:

```meta
fileFormatVersion: 2
guid: 41279c33ab6403d429b7b1c01f443879
folderAsset: yes
timeCreated: 1514190731
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/Extension/Script.meta`:

```meta
fileFormatVersion: 2
guid: f8eda626784566841ab9d44ac94667cd
folderAsset: yes
timeCreated: 1514190741
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/Extension/Script/SecurityExtension.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : SecurityExtension.cs
//  Info     : 加密操作扩展类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
//  Example  : string str = "Test";
//			   str = str.Compress().EncryptAES();
//			   str = str.DecryptAES().Decompress();
//
/////////////////////////////////////////////////////////////////////////////
using Aya.Security;

public static class SecurityExtension
{
    #region AES

    public static string EncryptAES(this string str)
    {
        return AESUtil.Encrypt(str);
    }

    public static string DecryptAES(this string str)
    {
        return AESUtil.Decrypt(str);
    }

    #endregion

    #region DES

    public static string EncryptDES(this string str)
    {
        return DESUtil.Encrypt(str);
    }

    public static string DecryptDES(this string str)
    {
        return DESUtil.Decrypt(str);
    }

    #endregion

    #region RC4

    public static string EncryptRC4(this string str)
    {
        return RC4Util.Encrypt(str);
    }

    public static string DecryptRC4(this string str)
    {
        return RC4Util.Decrypt(str);
    }

    #endregion

    #region RSA

    public static string EncryptRSA(this string str)
    {
        return RSAUtil.Encrypt(str);
    }

    public static string DecryptRSA(this string str)
    {
        return RSAUtil.Decrypt(str);
    }

    #endregion
}
```

`EncDec/Extension/Script/SecurityExtension.cs.meta`:

```meta
fileFormatVersion: 2
guid: 319fd423f026d804d95e7097cd6dd48d
timeCreated: 1514190753
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/RC4.meta`:

```meta
fileFormatVersion: 2
guid: 9df384bfc76e593489819803652a1715
folderAsset: yes
timeCreated: 1514193623
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/RC4/Resources.meta`:

```meta
fileFormatVersion: 2
guid: 33daa25505c518c40ba3275e2dc45a0b
folderAsset: yes
timeCreated: 1514197153
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/RC4/Resources/RC4kEY.asset`:

```asset
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: d8d7835e492b0ff4eb96794b73a40f32, type: 3}
  m_Name: RC4kEY
  m_EditorClassIdentifier: 
  key: e839af38b080b304

```

`EncDec/RC4/Resources/RC4kEY.asset.meta`:

```meta
fileFormatVersion: 2
guid: fe0b8fe6ebb550d4aa1c47513b76fe43
timeCreated: 1514197164
licenseType: Pro
NativeFormatImporter:
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/RC4/Script.meta`:

```meta
fileFormatVersion: 2
guid: 48807cd392c67e941984cac7d962f42f
folderAsset: yes
timeCreated: 1514193634
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/RC4/Script/RC4Key.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : RC4Key.cs
//  Info     : RC4密钥
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using UnityEngine;

namespace Aya.Security
{
    [CreateAssetMenu(menuName = "USecurity/RC4Key")]
    public class RC4Key : ScriptableObject
	{
		public const string DEFAULT_KEY = "RC4Key";

		public string key;

	    public void Reset()
	    {
	        CreateKey();
	    }

	    [ContextMenu("Create Key")]
	    public void CreateKey()
	    {
	        key = USecurityUtil.RandHexString(16);
	    }

        public static string DefaultKey
		{
			get
			{
				if (string.IsNullOrEmpty(_defaultKey))
				{
					_defaultKey = Key(DEFAULT_KEY);
				}
				return _defaultKey;
			}
		}
		private static string _defaultKey;

		public static string Key(string keyName)
		{
            var asset = USecurityInterface.Load(keyName) as RC4Key;
            if (asset == null)
            {
                throw new NullReferenceException();
            }

            return asset.key;
		}
	}
}
```

`EncDec/RC4/Script/RC4Key.cs.meta`:

```meta
fileFormatVersion: 2
guid: d8d7835e492b0ff4eb96794b73a40f32
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 

```

`EncDec/RC4/Script/RC4Util.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : RC4Util.cs
//  Info     : RC4加密类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System.Text;

namespace Aya.Security
{
    public static class RC4Util
    {
        #region Enc & Dec string

        public static string Encrypt(string str)
        {
            return Encrypt(str, RC4Key.DefaultKey);
        }

        public static string Decrypt(string str)
        {
            return Decrypt(str, RC4Key.DefaultKey);
        }

        public static string Encrypt(string data, string key)
        {
            return RC4Encode(data, key);
        }

        public static string Decrypt(string data, string key)
        {
            return RC4Encode(data, key);
        }

        #endregion

        #region Private

        private static readonly StringBuilder StreamBuilder = new StringBuilder();

        private static string RC4Encode(string input, string key)
        {
            StreamBuilder.Remove(0, StreamBuilder.Length);
            int x, y, j = 0;
            var box = new int[256];
            for (var i = 0; i < 256; i++)
            {
                box[i] = i;
            }

            for (var i = 0; i < 256; i++)
            {
                j = (key[i % key.Length] + box[i] + j) % 256;
                x = box[i];
                box[i] = box[j];
                box[j] = x;
            }

            for (var i = 0; i < input.Length; i++)
            {
                y = i % 256;
                j = (box[y] + j) % 256;
                x = box[y];
                box[y] = box[j];
                box[j] = x;

                StreamBuilder.Append((char) (input[i] ^ box[(box[y] + box[j]) % 256]));
            }

            return StreamBuilder.ToString();
        }

        #endregion
    }
}

```

`EncDec/RC4/Script/RC4Util.cs.meta`:

```meta
fileFormatVersion: 2
guid: 830dcfc571c73f94ca2eb1f940ba5698
timeCreated: 1514194952
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/RSA.meta`:

```meta
fileFormatVersion: 2
guid: c4b8c401cd3716549be325bbba4a9234
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/RSA/Resources.meta`:

```meta
fileFormatVersion: 2
guid: 5bb2c6ba31ea8a749a4a655c20ce9aa3
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/RSA/Resources/RSAKey.asset`:

```asset
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 44f9415840c647741a84ec2b5e76d9af, type: 3}
  m_Name: RSAKey
  m_EditorClassIdentifier: 
  publicKey: <RSAKeyValue><Modulus>xwN2H+JpNsMsPRzYljvK0B9IYrGE1bKhfoHMLuUjE+hjFdVUqPy76vMh4O9F/WLHkJAY1zGbWZgskxTu1+lDF8d+w2bFIAND4LQOllusUxCqrxz8GGNiNYVzTn8NuHWEC89v1QD2bjzFlfwrhlQmd+ni/CvPchkxtNBweWXGs00=</Modulus><Exponent>AQAB</Exponent><P>x2KeS/l7+cgODll9bSQDxrCwN1JBHiTOEnHpBRc80zfbbkhZwLeogiE2KkA7M5lr4XhYWDEyMfE/RT9Y5zLRbw==</P><Q>/4XS1oHbQITqfcNhIwPUbqPGGxhnVS1v5OJJIc0zPSyhRcP0Uazx137J3xay9n1o0VyYolD/nwBP2PaCr2gxAw==</Q><DP>idUx6wF/48+Zb/ALVfyUo7EXUFcLbwQwdO3MEVncEYPGrHlVmnUcB0FgSVr30hbYThi8sdLoiT/l5kABfGpT/w==</DP><DQ>hpMgm8EAjFZ0eY/xFNPrienPaG3N3lpz2AQlqBu+pLVgqrGtd2ayaGBqSYhW8OLT1ZADA1nNhxxO8WHDKkahqQ==</DQ><InverseQ>szQ59R07ntR9uLyGx1Gyf4n2tu3oNxWUqJLtln9h3FSMB34xrbndP+1GlWIk6sHJNMO08rCdYtVyj+vuizr8ng==</InverseQ><D>XhELx3xcIO9VvLkiwrgWYBM5QrUHxX5+iO5PFadm0iUYmJxSPOHg7OfpDonqeh8zlugVZbnj5RBhmU/eqR1vgTnb05zFh2s+EXO39Bj1UKDV+1f8MH22/lsl517gfICXzyux+nhPY2jNPjgeNqJC6/G86JtwGT9NWsQIosjmrN0=</D></RSAKeyValue>
  privateKey: <RSAKeyValue><Modulus>xwN2H+JpNsMsPRzYljvK0B9IYrGE1bKhfoHMLuUjE+hjFdVUqPy76vMh4O9F/WLHkJAY1zGbWZgskxTu1+lDF8d+w2bFIAND4LQOllusUxCqrxz8GGNiNYVzTn8NuHWEC89v1QD2bjzFlfwrhlQmd+ni/CvPchkxtNBweWXGs00=</Modulus><Exponent>AQAB</Exponent></RSAKeyValue>

```

`EncDec/RSA/Resources/RSAKey.asset.meta`:

```meta
fileFormatVersion: 2
guid: c25c968ba8f574840872fa3b82c1b26d
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/RSA/Script.meta`:

```meta
fileFormatVersion: 2
guid: a330918825322344699982b87f17fabe
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/RSA/Script/RSAKey.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : RSAKey.cs
//  Info     : RSA密钥
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Security.Cryptography;
using UnityEngine;

namespace Aya.Security
{
    [CreateAssetMenu(menuName = "USecurity/RSAKey")]
    public class RSAKey : ScriptableObject
    {
        private const string DEFAULT_KEY = "RSAKey";

        [TextArea] public string publicKey;
        [TextArea] public string privateKey;

        public void Reset()
        {
            CreateKey();
        }

        [ContextMenu("Create Key")]
        public void CreateKey()
        {
            var rsa = new RSACryptoServiceProvider();
            var rsaPublic = rsa.ToXmlString(false);
            var rsaPrivate = rsa.ToXmlString(true);

            publicKey = rsaPrivate;
            privateKey = rsaPublic;
        }

        public static string DefaultPublicKey
        {
            get
            {
                if (string.IsNullOrEmpty(_defaultPublicKey))
                {
                    _defaultPublicKey = PublicKey(DEFAULT_KEY);
                }

                return _defaultPublicKey;
            }
        }

        private static string _defaultPublicKey;

        public static string DefaultPrivateKey
        {
            get
            {
                if (string.IsNullOrEmpty(_defaultPrivateKey))
                {
                    _defaultPrivateKey = PrivateKey(DEFAULT_KEY);
                }

                return PrivateKey(DEFAULT_KEY);
            }
        }

        private static string _defaultPrivateKey;

        public static string PublicKey(string keyName)
        {
            var asset = USecurityInterface.Load(keyName) as RSAKey;
            if (asset == null)
            {
                throw new NullReferenceException();
            }

            return asset.publicKey;
        }

        public static string PrivateKey(string keyName)
        {
            var asset = USecurityInterface.Load(keyName) as RSAKey;
            if (asset == null)
            {
                throw new NullReferenceException();
            }

            return asset.privateKey;
        }
    }
}

```

`EncDec/RSA/Script/RSAKey.cs.meta`:

```meta
fileFormatVersion: 2
guid: 44f9415840c647741a84ec2b5e76d9af
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`EncDec/RSA/Script/RSAUtil.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : RSAUtil.cs
//  Info     : RSA加密辅助类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Security.Cryptography;
using System.Text;

namespace Aya.Security
{
    public static class RSAUtil
    {
        #region Sign & Check String

        public static string Sign(string str)
        {
            return Sign(str, RSAKey.DefaultPrivateKey);
        }

        public static bool SignCheck(string str, string sign)
        {
            return SignCheck(str, sign, RSAKey.DefaultPublicKey);
        }

        public static string Sign(string str, string privateKey)
        {
            var bytes = Encoding.UTF8.GetBytes(str);
            var sha256 = new SHA256CryptoServiceProvider();
            var rgbHash = sha256.ComputeHash(bytes);
            var rsa = new RSACryptoServiceProvider();
            rsa.FromXmlString(privateKey);
            var formatter = new RSAPKCS1SignatureFormatter(rsa);
            formatter.SetHashAlgorithm("SHA256");
            var inArray = formatter.CreateSignature(rgbHash);
            return Convert.ToBase64String(inArray);
        }

        public static bool SignCheck(string str, string sign, string publicKey)
        {
            try
            {
                var bytes = Encoding.UTF8.GetBytes(str);
                var sha256 = new SHA256CryptoServiceProvider();
                var rgbHash = sha256.ComputeHash(bytes);
                var rsa = new RSACryptoServiceProvider();
                rsa.FromXmlString(publicKey);
                var deformatter = new RSAPKCS1SignatureDeformatter(rsa);
                deformatter.SetHashAlgorithm("SHA256");
                var rgbSignature = Convert.FromBase64String(sign);
                return deformatter.VerifySignature(rgbHash, rgbSignature);
            }
            catch
            {
                return false;
            }
        }

        #endregion

        #region Sign & Check Bytes

        public static string Sign(byte[] bytes)
        {
            return Sign(bytes, RSAKey.DefaultPrivateKey);
        }

        public static bool SignCheck(byte[] bytes, string sign)
        {
            return SignCheck(bytes, sign, RSAKey.DefaultPublicKey);
        }

        public static string Sign(byte[] bytes, string privateKey)
        {
            var sha256 = new SHA256CryptoServiceProvider();
            var rgbHash = sha256.ComputeHash(bytes);
            var rsa = new RSACryptoServiceProvider();
            rsa.FromXmlString(privateKey);
            var formatter = new RSAPKCS1SignatureFormatter(rsa);
            formatter.SetHashAlgorithm("SHA256");
            var inArray = formatter.CreateSignature(rgbHash);
            return Convert.ToBase64String(inArray);
        }

        public static bool SignCheck(byte[] bytes, string sign, string publicKey)
        {
            try
            {
                var sha256 = new SHA256CryptoServiceProvider();
                var rgbHash = sha256.ComputeHash(bytes);
                var rsa = new RSACryptoServiceProvider();
                rsa.FromXmlString(publicKey);
                var deformatter = new RSAPKCS1SignatureDeformatter(rsa);
                deformatter.SetHashAlgorithm("SHA256");
                var rgbSignature = Convert.FromBase64String(sign);
                return deformatter.VerifySignature(rgbHash, rgbSignature);
            }
            catch
            {
                return false;
            }
        }

        #endregion

        #region Enc & Dec String

        public static string Encrypt(string data)
        {
            return Encrypt(data, RSAKey.DefaultPublicKey);
        }

        public static string Decrypt(string data)
        {
            return Decrypt(data, RSAKey.DefaultPrivateKey);
        }

        public static string Encrypt(string data, string publicKey)
        {
            using (var rsa = new RSACryptoServiceProvider())
            {
                var bytes = Encoding.UTF8.GetBytes(data);
                rsa.FromXmlString(publicKey);
                var retBytes = rsa.Encrypt(bytes, false);
                var retStr = Convert.ToBase64String(retBytes);
                return retStr;
            }
        }

        public static string Decrypt(string data, string privateKey)
        {
            using (var rsa = new RSACryptoServiceProvider())
            {
                var bytes = Convert.FromBase64String(data);
                rsa.FromXmlString(privateKey);
                var retBytes = rsa.Decrypt(bytes, false);
                var retStr = Encoding.UTF8.GetString(retBytes);
                return retStr;
            }
        }

        #endregion

        #region Enc & Dec Bytes

        public static byte[] Encrypt(byte[] bytes)
        {
            return Encrypt(bytes, RSAKey.DefaultPublicKey);
        }

        public static byte[] Decrypt(byte[] bytes)
        {
            return Decrypt(bytes, RSAKey.DefaultPrivateKey);
        }

        public static byte[] Encrypt(byte[] bytes, string publicKey)
        {
            using (var rsa = new RSACryptoServiceProvider())
            {
                rsa.FromXmlString(publicKey);
                var retBytes = rsa.EncryptValue(bytes);
                return retBytes;
            }
        }

        public static byte[] Decrypt(byte[] bytes, string privateKey)
        {
            using (var rsa = new RSACryptoServiceProvider())
            {
                rsa.FromXmlString(privateKey);
                var retBytes = rsa.DecryptValue(bytes);
                return retBytes;
            }
        }

        #endregion
    }
}
```

`EncDec/RSA/Script/RSAUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: c1491fff5c1e88b44958f1a60930b94a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`LICENSE.md`:

```md
MIT License

Copyright (c) 2020 ls9512

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`LICENSE.md.meta`:

```meta
fileFormatVersion: 2
guid: a760b27c360d05f4f9b7d399ccb4f55e
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`MD5.meta`:

```meta
fileFormatVersion: 2
guid: 96cfdacc656a18e4386c2885f59f5e88
folderAsset: yes
timeCreated: 1478003570
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`MD5/Script.meta`:

```meta
fileFormatVersion: 2
guid: 05a1077d2ba62f043acfa5f987473ac6
folderAsset: yes
timeCreated: 1510291754
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`MD5/Script/MD5Util.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : MD5Util.cs
//  Info     : MD5验证计算辅助类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.IO;
using System.Text;
using System.Security.Cryptography;

namespace Aya.Security
{
    public static class MD5Util
    {
        public static string GetMd5FormFile(string filePath)
        {
            var file = new FileStream(filePath, FileMode.Open);
            var md5 = new MD5CryptoServiceProvider();
            var retVal = md5.ComputeHash(file);
            file.Close();
            var sb = new StringBuilder();
            for (var i = 0; i < retVal.Length; i++)
            {
                sb.Append(retVal[i].ToString("x2"));
            }

            return sb.ToString();
        }

        public static string GetMd5(byte[] bytes)
        {
            var md5 = new MD5CryptoServiceProvider();
            var retVal = md5.ComputeHash(bytes);
            var sb = new StringBuilder();
            for (var i = 0; i < retVal.Length; i++)
            {
                sb.Append(retVal[i].ToString("x2"));
            }

            return sb.ToString();
        }

        public static string GetMd5(string str)
        {
            return GetMd5(Encoding.UTF8.GetBytes(str));
        }

        /// <summary>
        /// 获取精简MD5 / 短链接<para/>
        /// 取MD5摘要的部分特征，有概率重复
        /// </summary>
        /// <param name="str">原文</param>
        /// <returns>摘要密文</returns>
        public static string GetShortMd5(string str)
        {
            // 将长内容 md5 生成 32 位签名串,分为 4 段, 每段 8 个字节
            // 对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与 0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理
            // 这 30 位分成 6 段, 每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串
            // 总的 md5 串可以获得 4 个 6 位串,取里面的任意一个就可作为这个长 url 的短 url 地址
            var md5 = GetMd5(str);
            var codes = new char[]
            {
                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
                'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
                'u', 'v'
            };
            var hexNumbers = new uint[4];
            var hexValues = new uint[4];
            var chars = new char[6];
            var shortMd5Result = new string[4];
            var index = 0;
            for (var i = 0; i <= 24; i += 8)
            {
                hexNumbers[index] = (uint) Math.Abs(int.Parse(md5.Substring(i, 8), System.Globalization.NumberStyles.HexNumber));
                hexValues[index] = 0x3fffffff & hexNumbers[index];
                var value = hexValues[index];
                chars[0] = codes[value << 0 >> 25];
                chars[1] = codes[value << 7 >> 27];
                chars[2] = codes[value << 12 >> 27];
                chars[3] = codes[value << 17 >> 27];
                chars[4] = codes[value << 22 >> 27];
                chars[5] = codes[value << 27 >> 27];
                var shortMd5 = new string(chars);
                shortMd5Result[index] = shortMd5;
                index++;
            }

            return shortMd5Result[0];
        }
    }
}
```

`MD5/Script/MD5Util.cs.meta`:

```meta
fileFormatVersion: 2
guid: cfbed78b40bedde42b618e8da654091c
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 

```

`README.md`:

```md
# USecurity

**USecurity** is a security component used in the **Unity** project. It provides encryption of commonly used data types at runtime, **PlayerPrefs** storage encryption, and a quick call interface for encryption and decryption of common encryption algorithms.

![topLanguage](https://img.shields.io/github/languages/top/ls9512/USecurity)
![size](https://img.shields.io/github/languages/code-size/ls9512/USecurity)
![issue](https://img.shields.io/github/issues/ls9512/USecurity)
![license](https://img.shields.io/github/license/ls9512/USecurity)
![last](https://img.shields.io/github/last-commit/ls9512/USecurity)
[![996.icu](https://img.shields.io/badge/link-996.icu-red.svg)](https://996.icu)

[[中文文档]](README_CN.md)

<!-- vscode-markdown-toc -->
* 1. [Quick Start](#QuickStart)
* 2. [Anti Cheat](#AntiCheat)
	* 2.1. [Anti Cheat Value - Runtime Data Encryption](#AntiCheatValue-RuntimeDataEncryption)
		* 2.1.1. [Introduction](#Introduction)
		* 2.1.2. [C# Type](#CType)
		* 2.1.3. [Unity Type](#UnityType)
		* 2.1.4. [Working Principle](#WorkingPrinciple)
		* 2.1.5. [How To Use](#HowToUse)
		* 2.1.6. [Attention](#Attention)
	* 2.2. [PlayerPrefsAES](#PlayerPrefsAES)
		* 2.2.1. [Introduction](#Introduction-1)
		* 2.2.2. [How To Use](#HowToUse-1)
* 3. [DFA - Sensitive Word Filtering](#DFA-SensitiveWordFiltering)
	* 3.1. [Introduction](#Introduction-1)
	* 3.2. [How To Use](#HowToUse-1)
* 4. [Encrypt / Decrypt](#EncryptDecrypt)
	* 4.1. [AES](#AES)
	* 4.2. [DES](#DES)
	* 4.3. [RC4](#RC4)
	* 4.4. [RSA](#RSA)
	* 4.5. [Base64](#Base64)
* 5. [MD5](#MD5)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name='QuickStart'></a>Quick Start
1. Copy the folder to the `UnityProject/Assets/Plugins/` directory.
2. Set the key file in the `Resources/` subdirectory of each type of encryption needed under the `EncDec/` directory, and set the encryption key you want, or click `Create Key` in the component menu to generate a random key.
3. If the project does not use the `Resources.Load` method to load resources, you can adjust the storage path of the key configuration file by yourself and replace the interface implementation of `USecurityInterface.Load`, or you can do secondary encryption on the key resource file.

##  2. <a name='AntiCheat'></a>Anti Cheat

###  2.1. <a name='AntiCheatValue-RuntimeDataEncryption'></a>Anti Cheat Value - Runtime Data Encryption

####  2.1.1. <a name='Introduction'></a>Introduction
**AntiCheatValue** is the core function of the **USecurity** component. It provides runtime encrypted data types corresponding to the native data types of C# and Unity. In most cases, these data types can directly replace the original native data in the project. Type, and use the same style and method as the original type, which can be efficiently accessed so that existing projects can quickly obtain runtime anti-cheating capabilities.

####  2.1.2. <a name='CType'></a>C# Type
|Anti Cheat Type|Source Tyoe|
|-|-|
|cBool|bool|
|cByte|byte|
|cChar|char|
|cDecimal|decimal|
|cFloat|float|
|cInt|int|
|cLong|long|
|cShort|short|
|cString|string|

Provides most commonly used C# data types, and all implement the interfaces of `IComparable`, `IFormattable`, `IConvertible`, `IEquatable`, `IFormattable`, `IEnumerable`, `ICloneable`, etc. contained in the native type, and implement `ISerializable` `Interface to support serialized storage. All types implement **implicit conversion** and common **operator overloading** with corresponding primitive types.

####  2.1.3. <a name='UnityType'></a>Unity Type
|Anti Cheat Type|Source Tyoe|
|-|-|
|cColor|Color|
|cQuaternion|Quaternion|
|cVector2|Vector2|
|cVector3|Vector3|
|cVector4|Vector4|

The Unity encrypted data type is a secondary encapsulation based on the C# encryption type. For example, **cVector3** essentially encapsulates 3 **cFloat**, so it can be combined with actual needs to expand other complex encrypted data types.

####  2.1.4. <a name='WorkingPrinciple'></a>Working Principle
By encapsulating the native type, the upper-level business logic accesses and manipulates the encapsulated type without directly operating the actual internal value. When the encapsulation type is operated, the real value passed in will be processed through encryption algorithms, memory offset, etc., and the processing methods for different data types are different. It can effectively avoid conventional cheating methods for searching and locating memory data.

####  2.1.5. <a name='HowToUse'></a>How To Use
```cs
// Directly replace the native type
public cInt num = 1;

// Mutual assignment operations with native types
public int a = 1;
public cInt b = a;
a = b;

// Perform regular mathematical operations directly with native types
public int left = 1;
public cInt right = 1;
right++;
public int add = left + right;

// Routine mathematical operations between different encryption types
public cInt num1 = 1;
public cFloat num2 = 1f;
float result = num1 * num2;

// Compare with native type value
public cInt i1 = 1;
public int i2 = 1;
public cInt i3 = 1;
public Debug.Log(i1 == i2);
public Debug.Log(i1 == i3);

// Support using the Convert interface for type conversion
public cInt srcValue = 1;
public int dstValue = Convert.ToInt32(srcValue);
```

####  2.1.6. <a name='Attention'></a>Attention
* Since the dynamic encryption key is regenerated every time it runs, the same actual value will be different every time it runs, so the internal value should not be used for storage.
* Encryption operations have a certain performance overhead. Use simple numeric encryption types as much as possible and apply only to important data as much as possible.

###  2.2. <a name='PlayerPrefsAES'></a>PlayerPrefsAES

####  2.2.1. <a name='Introduction-1'></a>Introduction
Provides **AES** encryption and decryption package for **PlayerPrefs** archive function, the style is consistent with the native interface, and some additional access interfaces for commonly used data types are added, and **PlayerPrefs** can be used as the main storage Directly replace in the project of the method to quickly obtain storage encryption capabilities.

####  2.2.2. <a name='HowToUse-1'></a>How To Use
```cs
// Save value
PlayerPrefsAES.SetInt("Key", 100);

// Load value
var value = PlayerPrefsAES.GetInt("Key");

// Delete value
PlayerPrefsAES.DeleteKey("Key");

// Delete all data
PlayerPrefsAES.DeleteAll();

// Save & Write data
PlayerPrefsAES.Save();
```

***

##  3. <a name='DFA-SensitiveWordFiltering'></a>DFA - Sensitive Word Filtering

###  3.1. <a name='Introduction-1'></a>Introduction
**DFA** is the full name **Deterministic Finite Automaton**, which is a more commonly used sensitive word filtering algorithm. This component compares and filters the user text input in the project with the sensitive word dictionary.

###  3.2. <a name='HowToUse-1'></a>How To Use
```cs
// Set to replace sensitive characters
DFAUtil.ReplaceSymbol = "*";

// Set the thesaurus file separator
DFAUtil.Separator = new[] { ",", "\n", "\r" };

// Initialize with pre-prepared thesaurus text
var text = Resources.Load<TextAsset>("DFA").text;
DFAUtil.Init(text);

// Filter input content
var content = ".....";
var result = DFAUtil.FilterWords(content, out var isLimit);
Debug.Log(isLimit);
Debug.Log(result);
```

***

##  4. <a name='EncryptDecrypt'></a>Encrypt / Decrypt

###  4.1. <a name='AES'></a>AES
Provides AES encryption and decryption of strings and files, with faster speed and higher security.

###  4.2. <a name='DES'></a>DES
Provides DES encryption and decryption of strings and files, which is slower and less secure.

###  4.3. <a name='RC4'></a>RC4
Provide RC4 encryption and decryption of strings, the fastest speed, security is not guaranteed, and the password can be variable length.

###  4.4. <a name='RSA'></a>RSA
It provides RSA signature and verification, encryption and decryption of strings and files, which is slower and has the highest security. The password is generated by the program.

###  4.5. <a name='Base64'></a>Base64
Provide base64 encoding and decoding of text.

***

##  5. <a name='MD5'></a>MD5
Provides standard MD5 value and short MD5 value calculation for text and files.
```

`README_CN.md`:

```md
# USecurity

**USecurity** 是一个用于 **Unity** 项目的安全组件，提供运行时常用数据类型加密，**PlayerPrefs** 存储加密，以及常见加密算法的加密解密快调用接口。

![topLanguage](https://img.shields.io/github/languages/top/ls9512/USecurity)
![size](https://img.shields.io/github/languages/code-size/ls9512/USecurity)
![issue](https://img.shields.io/github/issues/ls9512/USecurity)
![license](https://img.shields.io/github/license/ls9512/USecurity)
![last](https://img.shields.io/github/last-commit/ls9512/USecurity)
[![996.icu](https://img.shields.io/badge/link-996.icu-red.svg)](https://996.icu)

[[English Documents Available]](README.md)

<!-- vscode-markdown-toc -->
* 1. [接入](#)
* 2. [Anti Cheat](#AntiCheat)
	* 2.1. [Anti Cheat Value 运行时数据加密](#AntiCheatValue)
		* 2.1.1. [简介](#-1)
		* 2.1.2. [C# Type](#CType)
		* 2.1.3. [Unity Type](#UnityType)
		* 2.1.4. [工作机制](#-1)
		* 2.1.5. [使用示例](#-1)
		* 2.1.6. [注意事项](#-1)
	* 2.2. [PlayerPrefsAES](#PlayerPrefsAES)
		* 2.2.1. [简介](#-1)
		* 2.2.2. [使用示例](#-1)
* 3. [DFA 敏感词过滤](#DFA)
	* 3.1. [简介](#-1)
	* 3.2. [使用示例](#-1)
* 4. [Encrypt / Decrypt](#EncryptDecrypt)
	* 4.1. [AES](#AES)
	* 4.2. [DES](#DES)
	* 4.3. [RC4](#RC4)
	* 4.4. [RSA](#RSA)
	* 4.5. [Base64](#Base64)
* 5. [MD5](#MD5)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name=''></a>接入
1. 将整个文件夹复制到 `UnityProject/Assets/Plugins/` 目录下
2. 将 `EncDec/` 目录下，需要用到的每种加密类型的 `Resources/` 子目录下的 Key 文件，设置自己想要的加密密钥，或者点击组件菜单中的 `Create Key` 生成随机密钥。
3. 如果项目不使用 `Resources.Load` 方式加载资源，可以自行调整密钥配置文件的存储路径，并替换 `USecurityInterface.Load` 的接口实现，也可以对密钥资源文件做二次加密。

##  2. <a name='AntiCheat'></a>Anti Cheat

###  2.1. <a name='AntiCheatValue'></a>Anti Cheat Value 运行时数据加密

####  2.1.1. <a name='-1'></a>简介
**AntiCheatValue** 是 **USecurity** 组件的核心功能，提供大量鱼C#和Unity原生数据类型对应的运行时加密数据类型，在大多数情况下，这些数据类型可以直接替换项目中原有的原生类型，并保持与原生类型相同的风格和方法进行使用，可以高效接入使得现有项目快速获得反作弊能力。

####  2.1.2. <a name='CType'></a>C# Type
|Anti Cheat Type|Source Tyoe|
|-|-|
|cBool|bool|
|cByte|byte|
|cChar|char|
|cDecimal|decimal|
|cFloat|float|
|cInt|int|
|cLong|long|
|cShort|short|
|cString|string|

提供大多数常用C#数据类型，并且全部实现原生类型所包含的`IComparable`, `IFormattable`, `IConvertible`, `IEquatable`, `IFormattable`, `IEnumerable`, `ICloneable` 等接口，并且实现 `ISerializable` 接口以支持序列化存储。所有类型都实现了与对应原生类型的 **隐式转换** 和常用 **运算符重载** 。

####  2.1.3. <a name='UnityType'></a>Unity Type
|Anti Cheat Type|Source Tyoe|
|-|-|
|cColor|Color|
|cQuaternion|Quaternion|
|cVector2|Vector2|
|cVector3|Vector3|
|cVector4|Vector4|

Unity加密数据类型是基于C#加密类型的二次封装，例如 **cVector3** 本质上是封装了3个 **cFloat** ，因此可以结合实际需求，扩展出其他复杂加密数据类型。

####  2.1.4. <a name='-1'></a>工作机制
通过对原生类型进行封装，上层业务逻辑访问和操作封装后的类型而不直接操作内部真实的数值。在封装类型被操作时，传入的真实数值，会经过加密算法、内存偏移等方式进行处理，不同数据类型处理方式有所不同。可以有效规避常规的内存数据搜索定位作弊方式。

####  2.1.5. <a name='-1'></a>使用示例
```cs
// 直接替换原数据类型进行定义
public cInt num = 1;

// 与对应原生类型互相赋值操作
public int a = 1;
public cInt b = a;
a = b;

// 与原生类型直接进行常规数学运算
public int left = 1;
public cInt right = 1;
right++;
public int add = left + right;

// 不同加密类型之间进行常规数学运算
public cInt num1 = 1;
public cFloat num2 = 1f;
float result = num1 * num2;

// 与原生类型数值进行比较
public cInt i1 = 1;
public int i2 = 1;
public cInt i3 = 1;
public Debug.Log(i1 == i2);
public Debug.Log(i1 == i3);

// 支持被 Convert 做类型转换处理
public cInt srcValue = 1;
public int dstValue = Convert.ToInt32(srcValue);
```

####  2.1.6. <a name='-1'></a>注意事项
* 由于动态加密密钥每次运行都会重新生成，所以同样的实际数值每次运行内部数值都会不同，因此内部数值不应用于存储。
* 加密运算有一定性能开销，尽可能使用简单数值加密类型，尽可能只应用于重要数据。

###  2.2. <a name='PlayerPrefsAES'></a>PlayerPrefsAES

####  2.2.1. <a name='-1'></a>简介
提供对 **PlayerPrefs** 存档功能的 **AES** 加解密封装，风格与原生接口保持一致，并额外增加了一些常用数据类型的存取接口，可以在使用 **PlayerPrefs** 作为主要存储方式的项目中进行直接替换以快速获得存储加密能力。

####  2.2.2. <a name='-1'></a>使用示例
```cs
// 保存数值
PlayerPrefsAES.SetInt("Key", 100);

// 读取数值
var value = PlayerPrefsAES.GetInt("Key");

// 删除数值
PlayerPrefsAES.DeleteKey("Key");

// 删除所有数据
PlayerPrefsAES.DeleteAll();

// 保存数据
PlayerPrefsAES.Save();
```

***

##  3. <a name='DFA'></a>DFA 敏感词过滤

###  3.1. <a name='-1'></a>简介
**DFA** 全称 **Deterministic Finite Automaton** 确定有穷自动机，是比较常用的敏感词过滤算法。该组件对项目中的用户文字输入内容与敏感词词库进行比对并进行过滤。

###  3.2. <a name='-1'></a>使用示例
```cs
// 设置替换敏感字符
DFAUtil.ReplaceSymbol = "*";

// 设置词库文件分隔符
DFAUtil.Separator = new[] { ",", "\n", "\r" };

// 使用预先准备好的词库文本进行初始化
var text = Resources.Load<TextAsset>("DFA").text;
DFAUtil.Init(text);

// 过滤内容
var content = ".....";
var result = DFAUtil.FilterWords(content, out var isLimit);
Debug.Log(isLimit);
Debug.Log(result);
```

***

##  4. <a name='EncryptDecrypt'></a>Encrypt / Decrypt

###  4.1. <a name='AES'></a>AES
提供对字符串和文件的AES加密解密，速度较快，安全性较高。

###  4.2. <a name='DES'></a>DES
提供对字符串和文件的DES加密解密，速度较慢，安全性较低。

###  4.3. <a name='RC4'></a>RC4
提供对字符串的RC4加密解密，速度最快，安全性不做保证，密码可变长。

###  4.4. <a name='RSA'></a>RSA
提供对字符串和文件的RSA签名和验签、加密和解密，速度较慢，安全性最高，密码由程序生成。

###  4.5. <a name='Base64'></a>Base64
提供对文本的 base64 编码、解码。

***

##  5. <a name='MD5'></a>MD5
提供对文本、文件的标准MD5值和短MD5值计算。
```

`Util.meta`:

```meta
fileFormatVersion: 2
guid: 4b79db501c7552b4295815c59bf1603a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Util/Script.meta`:

```meta
fileFormatVersion: 2
guid: 46f7c56eb4521d342921fb140e8f4d58
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Util/Script/USecurityInterface.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : USecurityInterface.cs
//  Info     : USecurity 外部定义接口
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using UnityEngine;

namespace Aya.Security
{
    public static class USecurityInterface
    {
        public static Func<string, UnityEngine.Object> Load { get; set; } = Resources.Load;
    }
}

```

`Util/Script/USecurityInterface.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8a38c8c2335c94c44ac6270aeaa297dc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Util/Script/USecurityUtil.cs`:

```cs
/////////////////////////////////////////////////////////////////////////////
//
//  Script   : USecurityUtil.cs
//  Info     : USecurity 工具类
//  Author   : ls9512
//  E-mail   : ls9512@vip.qq.com
//
/////////////////////////////////////////////////////////////////////////////
using System;
using System.Text;

namespace Aya.Security
{
    public static class USecurityUtil
    {
        internal static readonly Random Rand = new Random(DateTime.Now.Year * DateTime.Now.Month * DateTime.Now.Day * DateTime.Now.Millisecond);

        internal static string RandHexString(int length)
        {
            var str = new StringBuilder();
            var chars = new[]
            {
                "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e","f",
                "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"
            };

            for (var i = 0; i < length; i++)
            {
                var index = Rand.Next(0, 16);
                var strTemp = chars[index];
                str.Append(strTemp);
            }

            return str.ToString();
        }
    }
}

```

`Util/Script/USecurityUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: ff32979bfa187ed47b36f2e85b849592
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```