Project Path: arc_gmh5225_input-overlay_pm3kz6ma

Source Tree:

```txt
arc_gmh5225_input-overlay_pm3kz6ma
├── CMakeLists.txt
├── COPYING.txt
├── README.md
├── cmake
│   └── FindLibObs.cmake
├── deps
│   ├── CMakeLists.txt
│   ├── common
│   │   ├── buffer.hpp
│   │   ├── keycodes.h
│   │   ├── layout_constants.h
│   │   ├── messages.hpp
│   │   └── util.hpp
│   ├── libgamepad
│   ├── libuiohook
│   ├── mongoose
│   │   ├── mongoose.c
│   │   └── mongoose.h
│   └── netlib
├── docs
│   └── cct
│       ├── css
│       │   ├── colors.css
│       │   ├── dialog.css
│       │   ├── file.css
│       │   └── select.css
│       ├── favicon.ico
│       ├── index.html
│       ├── js
│       │   ├── config.js
│       │   ├── cs.js
│       │   ├── dl.js
│       │   ├── draw.js
│       │   ├── editor.js
│       │   ├── elements.js
│       │   ├── file.js
│       │   ├── gamepad.js
│       │   ├── gui.js
│       │   ├── jquery-3.5.1.min.js
│       │   ├── main.js
│       │   ├── math.js
│       │   ├── select.js
│       │   └── vc.js
│       └── layout-projects.zip
├── format.sh
├── package
│   └── installer.iss.in
└── projects
    ├── client
    │   ├── CMakeLists.txt
    │   ├── README.md
    │   └── src
    │       ├── client_util.cpp
    │       ├── client_util.hpp
    │       ├── gamepad_helper.cpp
    │       ├── gamepad_helper.hpp
    │       ├── io_client.cpp
    │       ├── network.cpp
    │       ├── network.hpp
    │       ├── uiohook_helper.cpp
    │       └── uiohook_helper.hpp
    ├── plugin
    │   ├── CMakeLists.txt
    │   ├── README.md
    │   ├── data
    │   │   ├── example.html
    │   │   ├── locale
    │   │   │   ├── de-DE.ini
    │   │   │   ├── en-US.ini
    │   │   │   ├── ko-KR.ini
    │   │   │   ├── ru-RU.ini
    │   │   │   └── zh-CN.ini
    │   │   ├── mouse_highlight.html
    │   │   └── overlay_render
    │   │       ├── js
    │   │       │   ├── config.js
    │   │       │   ├── draw.js
    │   │       │   ├── elements.js
    │   │       │   ├── gamepad.js
    │   │       │   ├── jquery-3.5.1.min.js
    │   │       │   ├── main.js
    │   │       │   └── vc.js
    │   │       ├── renderer.html
    │   │       └── texture.png
    │   └── src
    │       ├── gui
    │       │   ├── io_settings_dialog.cpp
    │       │   ├── io_settings_dialog.hpp
    │       │   └── io_settings_dialog.ui
    │       ├── hook
    │       │   ├── gamepad_hook_helper.cpp
    │       │   ├── gamepad_hook_helper.hpp
    │       │   ├── uiohook_helper.hpp
    │       │   ├── uiohook_helper_linux.cpp
    │       │   └── uiohook_helper_win.cpp
    │       ├── input_overlay.cpp
    │       ├── network
    │       │   ├── io_client.cpp
    │       │   ├── io_client.hpp
    │       │   ├── io_server.cpp
    │       │   ├── io_server.hpp
    │       │   ├── mg.cpp
    │       │   ├── mg.hpp
    │       │   ├── remote_connection.cpp
    │       │   ├── remote_connection.hpp
    │       │   ├── websocket_server.cpp
    │       │   └── websocket_server.hpp
    │       ├── sources
    │       │   ├── input_source.cpp
    │       │   └── input_source.hpp
    │       └── util
    │           ├── config.cpp
    │           ├── config.hpp
    │           ├── element
    │           │   ├── element.cpp
    │           │   ├── element.hpp
    │           │   ├── element_analog_stick.cpp
    │           │   ├── element_analog_stick.hpp
    │           │   ├── element_button.cpp
    │           │   ├── element_button.hpp
    │           │   ├── element_dpad.cpp
    │           │   ├── element_dpad.hpp
    │           │   ├── element_gamepad_id.cpp
    │           │   ├── element_gamepad_id.hpp
    │           │   ├── element_mouse_movement.cpp
    │           │   ├── element_mouse_movement.hpp
    │           │   ├── element_mouse_wheel.cpp
    │           │   ├── element_mouse_wheel.hpp
    │           │   ├── element_texture.cpp
    │           │   ├── element_texture.hpp
    │           │   ├── element_trigger.cpp
    │           │   └── element_trigger.hpp
    │           ├── input_data.cpp
    │           ├── input_data.hpp
    │           ├── input_filter.cpp
    │           ├── input_filter.hpp
    │           ├── lang.h
    │           ├── log.h
    │           ├── obs_util.cpp
    │           ├── obs_util.hpp
    │           ├── overlay.cpp
    │           ├── overlay.hpp
    │           ├── settings.h
    │           ├── window_helper.hpp
    │           ├── window_helper_nix.cpp
    │           └── window_helper_win.cpp
    └── presets
        ├── README.md
        ├── arcade-stick
        │   ├── arcade-stick-preview.png
        │   ├── arcade-stick.json
        │   └── arcade-stick.png
        ├── dualsense
        │   ├── CREDITS.md
        │   ├── dualsense.json
        │   ├── dualsense.png
        │   ├── dualsenseblack.png
        │   └── dualsensewhite.png
        ├── gamecube
        │   ├── CREDITS.md
        │   ├── gamecube.json
        │   ├── gamecube.png
        │   └── gamecube.xcf
        ├── gamepad
        │   ├── game-pad-preview.png
        │   ├── game-pad.json
        │   └── game-pad.png
        ├── input-history-windows
        │   ├── README.md
        │   ├── img
        │   │   ├── custom-css.png
        │   │   └── websocket-forwarding.png
        │   └── input-history-windows.html
        ├── mouse
        │   ├── alternative
        │   │   └── FAT9L
        │   │       ├── mouse_FAT9L.pdn
        │   │       ├── mouse_FAT9L.png
        │   │       ├── mouse_pink_no_movement_FAT9L.json
        │   │       ├── mousepink_FAT9L.png
        │   │       ├── mousepink_no_movement_FAT9L.pdn
        │   │       ├── wasd_pink_FAT9L.json
        │   │       ├── wasdwithblankpink.pdn
        │   │       └── wasdwithblankpink.png
        │   ├── mouse-arrow.json
        │   ├── mouse-dot.json
        │   ├── mouse-no-movement.json
        │   ├── mouse-no-movment-preview.png
        │   └── mouse.png
        ├── qwerty
        │   ├── qwerty-preview.png
        │   ├── qwerty.json
        │   └── qwerty.png
        ├── wasd
        │   ├── wasd-full-preview.png
        │   ├── wasd-full.json
        │   ├── wasd-minimal-preview.png
        │   ├── wasd-minimal.json
        │   └── wasd.png
        └── yghj
            ├── yghj-minimal-preview.png
            ├── yghj-minimal.json
            └── yghj-minimal.png

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.5)
project(io-base VERSION 5.0.0)
set(INPUT_OVERLAY_VERSION "5.0.0" CACHE STRING "" FORCE)

option(ENABLE_CLIENT "Whether to build the client (default: ON)" ON)
option(ENABLE_PLUGIN "Whether to build the obs plugin (default: ON)" ON)

set(PLUGIN_AUTHOR "univrsal")
set(PLUGIN_GIT input-overlay)
set(LINUX_MAINTAINER_EMAIL "uni@vrsal.de")
set(MACOS_BUNDLEID "de.vrsal.inputoverlay")

set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -D_DEBUG")

add_subdirectory(deps)

if (ENABLE_CLIENT)
    add_subdirectory(projects/client)
endif()

if (ENABLE_PLUGIN)
    add_subdirectory(projects/plugin)
endif()

# Don't install the license when building the deb installer
if (ENABLE_CLIENT)
    install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/COPYING.txt DESTINATION ./)
endif()

```

`COPYING.txt`:

```txt
            GNU GENERAL PUBLIC LICENSE
               Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

            GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

             END OF TERMS AND CONDITIONS

        How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year  name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
```

`README.md`:

```md
![logo](https://i.imgur.com/nPgpsRx.png)

![CI](https://github.com/univrsal/input-overlay/workflows/CI/badge.svg)

Show keyboard, mouse and gamepad input on stream.\
Available for OBS Studio 19.0.3+ on windows (32bit/64bit) and linux (64bit).
Head over to [releases](https://github.com/univrsal/input-overlay/releases) for binaries.
## [Wiki](https://github.com/univrsal/input-overlay/wiki)
## [Installation](https://github.com/univrsal/input-overlay/wiki/Installation)
## Credits
input-overlay depends on [libuiohook](https://github.com/kwhat/libuiohook) by [kwhat](https://github.com/kwhat) licensed under the [GNU General Public License v3.0](https://www.gnu.org/licenses/gpl-3.0.txt), [mongoose](https://github.com/cesanta/mongoose) licensed under the [GNU General Public License v2.0](https://www.gnu.org/licenses/gpl-2.0.txt), my SDL_net fork [netlib](https://github.com/univrsal/netlib) licensed under the [zlib license](https://www.zlib.net/zlib_license.html) and my gamepad hook [libgamepad](https://github.com/univrsal/libgamepad) licensed under the [GNU LESSER GENERAL PUBLIC LICENSE
](https://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt).

## More Information:
- [OBS resource page](https://obsproject.com/forum/resources/input-overlay.552/)
- [*.psd and fonts used](https://github.com/univrsal/input-overlay/raw/master/docs/cct/layout-projects.zip)
- [Config creation tool](https://univrsal.github.io/input-overlay/cct/)

```

`cmake/FindLibObs.cmake`:

```cmake
# This module can be copied and used by external plugins for OBS
#
# Once done these will be defined:
#
#  LIBOBS_FOUND
#  LIBOBS_INCLUDE_DIRS
#  LIBOBS_LIBRARIES

find_package(PkgConfig QUIET)
if (PKG_CONFIG_FOUND)
	pkg_check_modules(_OBS QUIET obs libobs)
endif()

if(CMAKE_SIZEOF_VOID_P EQUAL 8)
	set(_lib_suffix 64)
else()
	set(_lib_suffix 32)
endif()

if(DEFINED CMAKE_BUILD_TYPE)
	if(CMAKE_BUILD_TYPE STREQUAL "Debug")
		set(_build_type_base "debug")
	else()
		set(_build_type_base "release")
	endif()
endif()

find_path(LIBOBS_INCLUDE_DIR
	NAMES obs.h
	HINTS
		ENV obsPath${_lib_suffix}
		ENV obsPath
		${obsPath}
	PATHS
		/usr/include /usr/local/include /opt/local/include /sw/include
	PATH_SUFFIXES
		libobs
	)

function(find_obs_lib base_name repo_build_path lib_name)
	string(TOUPPER "${base_name}" base_name_u)

	if(DEFINED _build_type_base)
		set(_build_type_${repo_build_path} "${_build_type_base}/${repo_build_path}")
		set(_build_type_${repo_build_path}${_lib_suffix} "${_build_type_base}${_lib_suffix}/${repo_build_path}")
	endif()

	find_library(${base_name_u}_LIB
		NAMES ${_${base_name_u}_LIBRARIES} ${lib_name} lib${lib_name}
		HINTS
			ENV obsPath${_lib_suffix}
			ENV obsPath
			${obsPath}
			${_${base_name_u}_LIBRARY_DIRS}
		PATHS
			/usr/lib /usr/local/lib /opt/local/lib /sw/lib
		PATH_SUFFIXES
			lib${_lib_suffix} lib
			libs${_lib_suffix} libs
			bin${_lib_suffix} bin
			../lib${_lib_suffix} ../lib
			../libs${_lib_suffix} ../libs
			../bin${_lib_suffix} ../bin
			# base repo non-msvc-specific search paths
			${_build_type_${repo_build_path}}
			${_build_type_${repo_build_path}${_lib_suffix}}
			build/${repo_build_path}
			build${_lib_suffix}/${repo_build_path}
			# base repo msvc-specific search paths on windows
			build${_lib_suffix}/${repo_build_path}/Debug
			build${_lib_suffix}/${repo_build_path}/RelWithDebInfo
			build/${repo_build_path}/Debug
			build/${repo_build_path}/RelWithDebInfo
		)
endfunction()

find_obs_lib(LIBOBS libobs obs)

if(MSVC)
	find_obs_lib(W32_PTHREADS deps/w32-pthreads w32-pthreads)
endif()

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(Libobs DEFAULT_MSG LIBOBS_LIB LIBOBS_INCLUDE_DIR)
mark_as_advanced(LIBOBS_INCLUDE_DIR LIBOBS_LIB)

if(LIBOBS_FOUND)
	if(MSVC)
		if (NOT DEFINED W32_PTHREADS_LIB)
			message(FATAL_ERROR "Could not find the w32-pthreads library" )
		endif()

		set(W32_PTHREADS_INCLUDE_DIR ${LIBOBS_INCLUDE_DIR}/../deps/w32-pthreads)
	endif()

	set(LIBOBS_INCLUDE_DIRS ${LIBOBS_INCLUDE_DIR} ${W32_PTHREADS_INCLUDE_DIR})
	set(LIBOBS_LIBRARIES ${LIBOBS_LIB} ${W32_PTHREADS_LIB})
	include(${LIBOBS_INCLUDE_DIR}/../cmake/external/ObsPluginHelpers.cmake)

	# allows external plugins to easily use/share common dependencies that are often included with libobs (such as FFmpeg)
	if(NOT DEFINED INCLUDED_LIBOBS_CMAKE_MODULES)
		set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${LIBOBS_INCLUDE_DIR}/../cmake/Modules/")
		set(INCLUDED_LIBOBS_CMAKE_MODULES true)
	endif()
else()
	message(FATAL_ERROR "Could not find the libobs library" )
endif()

```

`deps/CMakeLists.txt`:

```txt
set(COMMON_HEADERS "${CMAKE_CURRENT_SOURCE_DIR}/common" CACHE STRING "" FORCE)
set(JSON_11_HEADER "${CMAKE_CURRENT_SOURCE_DIR}/libgamepad/include" CACHE STRING "" FORCE)
set(JSON_11_SOURCE "${CMAKE_CURRENT_SOURCE_DIR}/libgamepad/src/json11.cpp" CACHE STRING "" FORCE)
set(MONGOOSE_SOURCE "${CMAKE_CURRENT_SOURCE_DIR}/mongoose/mongoose.c" CACHE STRING "" FORCE)

set(UIOHOOK_INCLUDE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/libuiohook/include" CACHE STRING "" FORCE)
set(GAMEPAD_INCLUDE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/libgamepad/include" CACHE STRING "" FORCE)
set(NETLIB_INCLUDE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/netlib/include" CACHE STRING "" FORCE)
set(MONGOOSE_INCLUDE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/mongoose" CACHE STRING "" FORCE)

mark_as_advanced(COMMON_HEADERS)
mark_as_advanced(JSON_11_HEADER)
mark_as_advanced(JSON_11_SOURCE)

set(NETLIB_ENABLE_TESTS OFF CACHE INTERNAL "Internal var")
set(NETLIB_ENABLE_SHARED OFF CACHE INTERNAL "Internal var")
set(NETLIB_ENABLE_STATIC ON CACHE INTERNAL "Internal var")
set(NETLIB_ENABLE_INSTALL OFF CACHE INTERNAL "Internal var")

set(GAMEPAD_ENABLE_TESTS OFF CACHE INTERNAL "Internal var")
set(GAMEPAD_ENABLE_SHARED OFF CACHE INTERNAL "Internal var")
set(GAMEPAD_ENABLE_STATIC ON CACHE INTERNAL "Internal var")
set(GAMEPAD_ENABLE_INSTALL OFF CACHE INTERNAL "Internal var")

set(UIOHOOK_ENABLE_TEST OFF CACHE INTERNAL "Internal var")
set(UIOHOOK_ENABLE_SHARED OFF CACHE INTERNAL "Internal var")
set(UIOHOOK_ENABLE_STATIC ON CACHE INTERNAL "Internal var")
set(UIOHOOK_ENABLE_INSTALL OFF CACHE INTERNAL "Internal var")

add_subdirectory(netlib)
add_subdirectory(libgamepad)

# Create static version of libuiohook here
if (WIN32 OR WIN64)
    set(UIOHOOK_SOURCE_DIR "windows")
elseif (APPLE)
    set(UIOHOOK_SOURCE_DIR "darwin")
else()
    set(UIOHOOK_SOURCE_DIR "x11")
endif()

add_library(uiohook_static STATIC
    "${CMAKE_CURRENT_SOURCE_DIR}/libuiohook/src/logger.c"
    "${CMAKE_CURRENT_SOURCE_DIR}/libuiohook/src/${UIOHOOK_SOURCE_DIR}/input_helper.c"
    "${CMAKE_CURRENT_SOURCE_DIR}/libuiohook/src/${UIOHOOK_SOURCE_DIR}/input_hook.c"
    "${CMAKE_CURRENT_SOURCE_DIR}/libuiohook/src/${UIOHOOK_SOURCE_DIR}/post_event.c"
    "${CMAKE_CURRENT_SOURCE_DIR}/libuiohook/src/${UIOHOOK_SOURCE_DIR}/system_properties.c"
)

set_target_properties(uiohook_static PROPERTIES
    C_STANDARD 99
    C_STANDARD_REQUIRED ON
    POSITION_INDEPENDENT_CODE 1
    VERSION "1.3.0"
    SOVERSION "1"
)

target_include_directories(uiohook_static PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/libuiohook/include")
target_include_directories(uiohook_static PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/libuiohook/src")

if(UNIX AND NOT APPLE)
    find_package(PkgConfig REQUIRED)

    pkg_check_modules(X11 REQUIRED x11)
    target_include_directories(uiohook_static PRIVATE "${X11_INCLUDE_DIRS}")
    target_link_libraries(uiohook_static "${X11_LDFLAGS}")

    pkg_check_modules(XTST REQUIRED xtst)
    target_include_directories(uiohook_static PRIVATE "${XTST_INCLUDE_DIRS}")
    target_link_libraries(uiohook_static "${XTST_LDFLAGS}")

    include(CheckLibraryExists)
    check_library_exists(Xtst XRecordQueryVersion "" HAVE_XRECORD)

    include(CheckIncludeFile)
    check_include_file(X11/extensions/record.h HAVE_RECORD_H "-include X11/Xlib.h")

    option(USE_XKB_COMMON "X Keyboard Common Extension (default: ON)" ON)
    if(USE_XKB_COMMON)
        pkg_check_modules(XKB_COMMON REQUIRED xkbcommon-x11)
        add_compile_definitions(uiohook_static PRIVATE USE_XKB_COMMON)
        target_include_directories(uiohook_static PRIVATE "${XKB_COMMON_INCLUDE_DIRS}")
        target_link_libraries(uiohook_static "${XKB_COMMON_LDFLAGS}")

        pkg_check_modules(X11_XCB REQUIRED x11-xcb)
        target_include_directories(uiohook_static PRIVATE "${X11_XCB_INCLUDE_DIRS}")
        target_link_libraries(uiohook_static "${X11_XCB_LDFLAGS}")
    endif()

    option(USE_XKB_FILE "X Keyboard File Extension (default: ON)" ON)
    if(USE_XKB_FILE)
        pkg_check_modules(XKB_FILE REQUIRED xkbfile)
        add_compile_definitions(uiohook_static PRIVATE USE_XKB_FILE)
        target_include_directories(uiohook_static PRIVATE "${XKB_FILE_INCLUDE_DIRS}")
        target_link_libraries(uiohook_static "${XKB_FILE_LDFLAGS}")
    endif()

    option(USE_XT "X Toolkit Extension (default: ON)" ON)
    if(USE_XT)
        pkg_check_modules(XT REQUIRED xt)
        add_compile_definitions(uiohook_static PRIVATE USE_XT)
        target_include_directories(uiohook_static PRIVATE "${XT_INCLUDE_DIRS}")
        target_link_libraries(uiohook_static "${XT_LDFLAGS}")
    endif()


    option(USE_XF86MISC "XFree86-Misc X Extension (default: OFF)" OFF)
    if(USE_XF86MISC)
        pkg_check_modules(XF86MISC REQUIRED Xxf86misc)
        add_compile_definitions(uiohook_static PRIVATE USE_XF86MISC)
        target_include_directories(uiohook_static PRIVATE "${XF86MISC_INCLUDE_DIRS}")
        target_link_libraries(uiohook_static "${XF86MISC_LDFLAGS}")
    endif()

    option(USE_XRANDR "XRandR Extension (default: OFF)" OFF)
    if(USE_XRANDR)
        pkg_check_modules(XRANDR REQUIRED xrandr)
        add_compile_definitions(uiohook_static PRIVATE USE_XRANDR)
        target_include_directories(uiohook_static PRIVATE "${XRANDR_INCLUDE_DIRS}")
        target_link_libraries(uiohook_static "${XRANDR_LDFLAGS}")
    endif()

    option(USE_XINERAMA "Xinerama Extension (default: ON)" ON)
    if(USE_XINERAMA)
        pkg_check_modules(XINERAMA REQUIRED xinerama)
        add_compile_definitions(uiohook_static PRIVATE USE_XINERAMA)
        target_include_directories(uiohook_static PRIVATE "${XINERAMA_INCLUDE_DIRS}")
        target_link_libraries(uiohook_static "${XINERAMA_LDFLAGS}")
    endif()

    option(USE_XRECORD_ASYNC "XRecord Asynchronous API (default: OFF)" OFF)
    if(USE_XRECORD_ASYNC)
        add_compile_definitions(uiohook_static PRIVATE USE_XRECORD_ASYNC)
    endif()

    if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
        option(USE_EVDEV "Generic Linux input driver (default: ON)" ON)
        if(USE_EVDEV)
            add_compile_definitions(uiohook_static PRIVATE USE_EVDEV)
        endif()
    endif()
elseif(APPLE)
    set(CMAKE_MACOSX_RPATH 1)
    set(CMAKE_OSX_DEPLOYMENT_TARGET "10.5")

    find_package(Threads REQUIRED)
    target_link_libraries(uiohook_static "${CMAKE_THREAD_LIBS_INIT}")

    find_library(CARBON Carbon REQUIRED)
    target_include_directories(uiohook_static PRIVATE "${CARBON}")
    target_link_libraries(uiohook_static "${CARBON}")

    option(USE_APPLICATION_SERVICES "ApplicationServices framework (default: ON)" ON)
    if(USE_APPLICATION_SERVICES)
        find_library(APPLICATION_SERVICES ApplicationServices REQUIRED)
        add_compile_definitions(USE_APPLICATION_SERVICES)
        target_include_directories(uiohook_static PRIVATE "${APPLICATION_SERVICES}")
        target_link_libraries(uiohook_static "${APPLICATION_SERVICES}")
    endif()

    option(USE_IOKIT "IOKit framework (default: ON)" ON)
    if(USE_IOKIT)
        find_library(IOKIT IOKit REQUIRED)
        add_compile_definitions(USE_IOKIT)
        target_include_directories(uiohook_static PRIVATE "${IOKIT}")
        target_link_libraries(uiohook_static "${IOKIT}")
    endif()

    option(USE_APPKIT "AppKit framework (default: ON)" ON)
    if(USE_APPKIT)
        find_library(APPKIT AppKit REQUIRED)
        add_compile_definitions(USE_APPKIT)
        target_include_directories(uiohook_static PRIVATE "${APPKIT}")
        target_link_libraries(uiohook_static "${APPKIT}")
    endif()
elseif(WIN32)
    target_link_libraries(uiohook_static Advapi32)
endif()

```

`deps/common/buffer.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2020 univrsal <uni@vrsal.cf>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once
#include <malloc.h>
#include <cassert>
#include <cstring>

typedef unsigned char byte;
class buffer {
    byte *m_buf = nullptr;
    size_t m_length = 0, m_write_pos = 0, m_read_pos = 0;

public:
    buffer(size_t len = 0)
    {
        if (len > 0)
            resize(len);
    }

    ~buffer()
    {
        free(m_buf);
        m_buf = nullptr;
        m_length = 0;
        m_write_pos = 0;
    }

    void reset()
    {
        m_read_pos = 0;
        m_write_pos = 0;
    }

    void resize(size_t new_size)
    {
        assert(new_size < 0xffff);
        m_buf = reinterpret_cast<byte *>(realloc(m_buf, new_size));
        if (m_buf)
            m_length = new_size;
    }

    void write(const void *data, size_t size)
    {
        if (m_write_pos + size >= m_length)
            resize(m_write_pos + size * 1.5);
        memcpy(m_buf + m_write_pos, data, size);
        m_write_pos += size;
    }

    void read(void **dest, size_t size)
    {
        if (size + m_read_pos < m_length) {
            *dest = reinterpret_cast<void *>(m_buf + m_read_pos);
        }
    }

    template<class T> T *write(const T &val)
    {
        if (m_write_pos + sizeof(T) >= m_length)
            resize(m_write_pos + sizeof(T) * 1.5);
        memcpy(m_buf + m_write_pos, &val, sizeof(T));
        auto *res = reinterpret_cast<T *>(m_buf + m_write_pos);
        m_write_pos += sizeof(T);
        return res;
    }

    template<class T> T *read()
    {
        if (sizeof(T) + m_read_pos < m_length) {
            auto result = reinterpret_cast<T *>(m_buf + m_read_pos);
            m_read_pos += sizeof(T);
            return result;
        }
        return nullptr;
    }

    byte &operator[](size_t idx) { return m_buf[idx]; }

    const byte &operator[](size_t idx) const { return m_buf[idx]; }

    size_t length() { return m_length; }
    size_t write_pos() { return m_write_pos; }
    size_t read_pos() { return m_read_pos; }
    byte *get() { return m_buf; }
};
```

`deps/common/keycodes.h`:

```h
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2020 univrsal <universailp@web.de>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once
#include <uiohook.h>
/* clang-format off */
#define WHEEL_UP           -1
#define WHEEL_DOWN          1

/* These were free in uiohook.h */
#define VC_NONE             0xFFFFu

#define VC_MOUSE_MASK       0xED00u /* 'u' for unsigned to fix clang tidy warning */
#define VC_MOUSE_WHEEL      (MOUSE_BUTTON3 | VC_MOUSE_MASK)

/* Contains mouse position */
#define VC_MOUSE_DATA       0xED14u

#define VC_MOUSE_BUTTON1    (MOUSE_BUTTON1 | VC_MOUSE_MASK)
#define VC_MOUSE_BUTTON2    (MOUSE_BUTTON2 | VC_MOUSE_MASK)
#define VC_MOUSE_BUTTON3    VC_MOUSE_WHEEL
#define VC_MOUSE_BUTTON4    (MOUSE_BUTTON4 | VC_MOUSE_MASK)
#define VC_MOUSE_BUTTON5    (MOUSE_BUTTON5 | VC_MOUSE_MASK)

/* Gamepad constants */
#define VC_PAD_MASK         0xEC00u /* 'u' for unsigned to fix clang tidy warning */
#define VC_STICK_DATA       0xEC30u
#define VC_TRIGGER_DATA     0xEC31u
#define VC_DPAD_DATA        0xEC32u

/* clang-format on */

```

`deps/common/layout_constants.h`:

```h
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2020 univrsal <universailp@web.de>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

/* Prevent cropped textures from overlapping */
#define CFG_INNER_BORDER 3
#define CFG_OUTER_BORDER 1

#define CFG_DEBUG_FLAG "debug"
#define CFG_DEFAULT_WIDTH "default_width"
#define CFG_DEFAULT_HEIGHT "default_height"
#define CFG_H_SPACE "space_h"
#define CFG_V_SPACE "space_v"

#define CFG_FLAGS "flags"

#define CFG_TOTAL_WIDTH "overlay_width"
#define CFG_TOTAL_HEIGHT "overlay_height"

#define CFG_ID "id"
#define CFG_POS "pos"
#define CFG_MAPPING "mapping"
#define CFG_TYPE "type"
#define CFG_KEY_CODE "code"
#define CFG_WIDTH "width"
#define CFG_HEIGHT "height"
#define CFG_Z_LEVEL "z_level"
#define CFG_ELEMENTS "elements"
#define CFG_SIDE "side"
#define CFG_STICK_RADIUS "stick_radius"
#define CFG_MOUSE_RADIUS "mouse_radius"
#define CFG_MOUSE_TYPE "mouse_type"
#define CFG_DIRECTION "direction"
#define CFG_TRIGGER_MODE "trigger_mode"

/* Misc */
#define PAD_COUNT 4
#define AXIS_MAX_AMPLITUDE 32767
#define STICK_DEAD_ZONE 100

#define TRIGGER_THRESHOLD 0.2f

#undef DT_CENTER /* God dammit microsoft what the fuck */
#undef DT_LEFT
#undef DT_RIGHT
#undef ES_LEFT
#undef ES_RIGHT

enum overlay_flag { OF_LEFT_STICK = 1 << 0, OF_RIGHT_STICK = 1 << 1, OF_GAMEPAD = 1 << 2, OF_MOUSE = 1 << 3 };

enum dpad_texture {
    DT_CENTER,
    DT_LEFT,
    DT_RIGHT,
    DT_UP,
    DT_DOWN,
    DT_TOP_LEFT,
    DT_TOP_RIGHT,
    DT_BOTTOM_LEFT,
    DT_BOTTOM_RIGHT
};

enum dpad_direction {
    DD_CENTER = 1 << 0,
    DD_LEFT = 1 << 1,
    DD_RIGHT = 1 << 2,
    DD_UP = 1 << 3,
    DD_DOWN = 1 << 4,
};

enum mouse_movement { MM_DOT, MM_ARROW };

enum class element_side { INVALID = -1, LEFT, RIGHT };

enum direction { DIR_NONE = 0, DIR_UP, DIR_DOWN, DIR_LEFT, DIR_RIGHT, DIR_MAX };

enum button_state { BS_RELEASED = 0, BS_PRESSED = 1 };

enum element_type {
    ET_INVALID = -1,
    ET_TEXTURE,
    ET_KEYBOARD_KEY,
    ET_GAMEPAD_BUTTON,
    ET_MOUSE_BUTTON,
    ET_WHEEL,
    ET_ANALOG_STICK,
    ET_TRIGGER,
    /* Shows game pad number 1 through 4 */
    ET_GAMEPAD_ID,
    ET_DPAD_STICK,
    ET_MOUSE_MOVEMENT
};

```

`deps/common/messages.hpp`:

```hpp
/**
 * This file is part of input-overlay
 * which is licensed under the GPL v2.0
 * See LICENSE or http://www.gnu.org/licenses
 * github.com/univrsal/input-overlay
 */
#pragma once

namespace network {
enum message : char {
    MSG_READ_ERROR = -2,
    MSG_INVALID,
    MSG_NAME_NOT_UNIQUE,
    MSG_NAME_INVALID,
    MSG_SERVER_SHUTDOWN,
    MSG_PING_CLIENT,
    MSG_UIOHOOK_EVENT,
    MSG_MOUSE_WHEEL_RESET,
    MSG_GAMEPAD_EVENT,
    MSG_GAMEPAD_CONNECTED,
    MSG_GAMEPAD_RECONNECTED,
    MSG_GAMEPAD_DISCONNECTED,
    MSG_CLIENT_DC,
    MSG_REFRESH,
    MSG_END_BUFFER,
    MSG_LAST
};
}

```

`deps/common/util.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2020 univrsal <universailp@web.de>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once
#include "keycodes.h"
#include <gamepad/device.hpp>
#include <stdint.h>
#include <string>
#include <uiohook.h>

/* clang-format off */
#define UTIL_MAX(a, b)                  (((a) > (b)) ? (a) : (b))
#define UTIL_MIN(a, b)                  (((a) < (b)) ? (a) : (b))
#define UTIL_CLAMP(lower, x, upper)     (UTIL_MIN(upper, UTIL_MAX(x, lower)))
#define UTIL_SWAP_BE16(i)               ((i >> 8) | (i << 8))

#define DEAD_ZONE(x, dz)                ((x < dz) && (x > -dz))
/* clang-format on */

namespace common {

inline void util_enable_mask(uint16_t &masks, const uint16_t mask)
{
    masks |= mask;
}

inline void util_disable_mask(uint16_t &masks, const uint16_t mask)
{
    masks &= ~mask;
}

inline void util_set_mask(uint16_t &masks, const uint16_t mask, const bool state)
{
    if (state) {
        util_enable_mask(masks, mask);
    } else {
        util_disable_mask(masks, mask);
    }
}

inline uint16_t util_mouse_to_vc(int m)
{
#ifndef _WIN32 /* Linux mixes right mouse and middle mouse or is windows getting it wrong? */
    if (m == 3)
        m = 2;
    else if (m == 2)
        m = 3;
#endif
    return static_cast<uint16_t>(VC_MOUSE_MASK | m);
}

inline bool ends_with(std::string const &value, std::string const &ending)
{
    if (ending.size() > value.size())
        return false;
    return std::equal(ending.rbegin(), ending.rend(), value.rbegin());
}

}

```

`deps/mongoose/mongoose.c`:

```c
// Copyright (c) 2004-2013 Sergey Lyubka
// Copyright (c) 2013-2021 Cesanta Software Limited
// All rights reserved
//
// This software is dual-licensed: you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation. For the terms of this
// license, see http://www.gnu.org/licenses/
//
// You are free to use this software under the terms of the GNU General
// Public License, but WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// Alternatively, you can license this software under a commercial
// license, as set out in https://www.mongoose.ws/licensing/

#include "mongoose.h"

#ifdef MG_ENABLE_LINES
#line 1 "src/base64.c"
#endif

#include <string.h>

static int mg_b64idx(int c) {
  if (c < 26) {
    return c + 'A';
  } else if (c < 52) {
    return c - 26 + 'a';
  } else if (c < 62) {
    return c - 52 + '0';
  } else {
    return c == 62 ? '+' : '/';
  }
}

static int mg_b64rev(int c) {
  if (c >= 'A' && c <= 'Z') {
    return c - 'A';
  } else if (c >= 'a' && c <= 'z') {
    return c + 26 - 'a';
  } else if (c >= '0' && c <= '9') {
    return c + 52 - '0';
  } else if (c == '+') {
    return 62;
  } else if (c == '/') {
    return 63;
  } else if (c == '=') {
    return 64;
  } else {
    return -1;
  }
}

int mg_base64_update(unsigned char ch, char *to, int n) {
  int rem = (n & 3) % 3;
  if (rem == 0) {
    to[n] = (char) mg_b64idx(ch >> 2);
    to[++n] = (char) ((ch & 3) << 4);
  } else if (rem == 1) {
    to[n] = (char) mg_b64idx(to[n] | (ch >> 4));
    to[++n] = (char) ((ch & 15) << 2);
  } else {
    to[n] = (char) mg_b64idx(to[n] | (ch >> 6));
    to[++n] = (char) mg_b64idx(ch & 63);
    n++;
  }
  return n;
}

int mg_base64_final(char *to, int n) {
  int saved = n;
  // printf("---[%.*s]\n", n, to);
  if (n & 3) n = mg_base64_update(0, to, n);
  if ((saved & 3) == 2) n--;
  // printf("    %d[%.*s]\n", n, n, to);
  while (n & 3) to[n++] = '=';
  to[n] = '\0';
  return n;
}

int mg_base64_encode(const unsigned char *p, int n, char *to) {
  int i, len = 0;
  for (i = 0; i < n; i++) len = mg_base64_update(p[i], to, len);
  len = mg_base64_final(to, len);
  return len;
}

int mg_base64_decode(const char *src, int n, char *dst) {
  const char *end = src + n;
  int len = 0;
  while (src + 3 < end) {
    int a = mg_b64rev(src[0]), b = mg_b64rev(src[1]), c = mg_b64rev(src[2]),
        d = mg_b64rev(src[3]);
    if (a == 64 || a < 0 || b == 64 || b < 0 || c < 0 || d < 0) return 0;
    dst[len++] = (char) ((a << 2) | (b >> 4));
    if (src[2] != '=') {
      dst[len++] = (char) ((b << 4) | (c >> 2));
      if (src[3] != '=') dst[len++] = (char) ((c << 6) | d);
    }
    src += 4;
  }
  dst[len] = '\0';
  return len;
}

#ifdef MG_ENABLE_LINES
#line 1 "src/dns.c"
#endif







struct dns_data {
  struct dns_data *next;
  struct mg_connection *c;
  int64_t expire;
  uint16_t txnid;
};

static struct dns_data *s_reqs;  // Active DNS requests

static void mg_sendnsreq(struct mg_connection *, struct mg_str *, int,
                         struct mg_dns *, bool);

static void mg_dns_free(struct dns_data *d) {
  LIST_DELETE(struct dns_data, &s_reqs, d);
  free(d);
}

void mg_resolve_cancel(struct mg_connection *c) {
  struct dns_data *tmp, *d;
  for (d = s_reqs; d != NULL; d = tmp) {
    tmp = d->next;
    if (d->c == c) mg_dns_free(d);
  }
}

static size_t mg_dns_parse_name_depth(const uint8_t *s, size_t len, size_t ofs,
                                      char *to, size_t tolen, int depth) {
  size_t i = 0, j = 0;
  if (tolen > 0) to[0] = '\0';
  if (depth > 5) return 0;
  while (ofs + i + 1 < len) {
    size_t n = s[ofs + i];
    if (n == 0) {
      i++;
      break;
    }
    if (n & 0xc0) {
      size_t ptr = (((n & 0x3f) << 8) | s[ofs + i + 1]);  // 12 is hdr len
      if (ptr + 1 < len && (s[ptr] & 0xc0) == 0 &&
          mg_dns_parse_name_depth(s, len, ptr, to, tolen, depth + 1) == 0)
        return 0;
      i += 2;
      break;
    }
    if (ofs + i + n + 1 >= len) return 0;
    if (j > 0) {
      if (j < tolen) to[j] = '.';
      j++;
    }
    if (j + n < tolen) memcpy(&to[j], &s[ofs + i + 1], n);
    j += n;
    i += n + 1;
    if (j < tolen) to[j] = '\0';  // Zero-terminate this chunk
  }
  if (tolen > 0) to[tolen - 1] = '\0';  // Make sure make sure it is nul-term
  return i;
}

static size_t mg_dns_parse_name(const uint8_t *s, size_t n, size_t ofs,
                                char *dst, size_t dstlen) {
  return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0);
}

size_t mg_dns_parse_rr(const uint8_t *buf, size_t len, size_t ofs,
                       bool is_question, struct mg_dns_rr *rr) {
  const uint8_t *s = buf + ofs, *e = &buf[len];

  memset(rr, 0, sizeof(*rr));
  if (len < sizeof(struct mg_dns_header)) return 0;  // Too small
  if (len > 512) return 0;  //  Too large, we don't expect that
  if (s >= e) return 0;     //  Overflow

  if ((rr->nlen = (uint16_t) mg_dns_parse_name(buf, len, ofs, NULL, 0)) == 0)
    return 0;
  s += rr->nlen + 4;
  if (s > e) return 0;
  rr->atype = (uint16_t) (((uint16_t) s[-4] << 8) | s[-3]);
  rr->aclass = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);
  if (is_question) return (size_t) (rr->nlen + 4);

  s += 6;
  if (s > e) return 0;
  rr->alen = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);
  if (s + rr->alen > e) return 0;
  return (size_t) (rr->nlen + rr->alen + 10);
}

bool mg_dns_parse(const uint8_t *buf, size_t len, struct mg_dns_message *dm) {
  const struct mg_dns_header *h = (struct mg_dns_header *) buf;
  struct mg_dns_rr rr;
  size_t i, n, ofs = sizeof(*h);
  memset(dm, 0, sizeof(*dm));

  if (len < sizeof(*h)) return 0;                // Too small, headers dont fit
  if (mg_ntohs(h->num_questions) > 1) return 0;  // Sanity
  if (mg_ntohs(h->num_answers) > 10) return 0;   // Sanity
  dm->txnid = mg_ntohs(h->txnid);

  for (i = 0; i < mg_ntohs(h->num_questions); i++) {
    if ((n = mg_dns_parse_rr(buf, len, ofs, true, &rr)) == 0) return false;
    // LOG(LL_INFO, ("Q %zu %zu", ofs, n));
    ofs += n;
  }
  for (i = 0; i < mg_ntohs(h->num_answers); i++) {
    // LOG(LL_INFO, ("A -- %zu %zu %s", ofs, n, dm->name));
    if ((n = mg_dns_parse_rr(buf, len, ofs, false, &rr)) == 0) return false;
    mg_dns_parse_name(buf, len, ofs, dm->name, sizeof(dm->name));
    ofs += n;

    if (rr.alen == 4 && rr.atype == 1 && rr.aclass == 1) {
      dm->addr.is_ip6 = false;
      memcpy(&dm->addr.ip, &buf[ofs - 4], 4);
      dm->resolved = true;
      break;  // Return success
    } else if (rr.alen == 16 && rr.atype == 28 && rr.aclass == 1) {
      dm->addr.is_ip6 = true;
      memcpy(&dm->addr.ip6, &buf[ofs - 16], 16);
      dm->resolved = true;
      break;  // Return success
    }
  }
  return true;
}

static void dns_cb(struct mg_connection *c, int ev, void *ev_data,
                   void *fn_data) {
  struct dns_data *d, *tmp;
  if (ev == MG_EV_POLL) {
    int64_t now = *(int64_t *) ev_data;
    for (d = s_reqs; d != NULL; d = tmp) {
      tmp = d->next;
      // LOG(LL_DEBUG, ("%lu %lu dns poll", d->expire, now));
      if (now > d->expire) mg_error(d->c, "DNS timeout");
    }
  } else if (ev == MG_EV_READ) {
    struct mg_dns_message dm;
    int resolved = 0;
    if (mg_dns_parse(c->recv.buf, c->recv.len, &dm) == false) {
      char *s = mg_hexdump(c->recv.buf, c->recv.len);
      LOG(LL_ERROR, ("Unexpected DNS response:\n%s\n", s));
      free(s);
    } else {
      LOG(LL_VERBOSE_DEBUG, ("%s %d", dm.name, dm.resolved));
      for (d = s_reqs; d != NULL; d = tmp) {
        tmp = d->next;
        // LOG(LL_INFO, ("d %p %hu %hu", d, d->txnid, dm.txnid));
        if (dm.txnid != d->txnid) continue;
        if (d->c->is_resolving) {
          d->c->is_resolving = 0;
          if (dm.resolved) {
#if MG_ENABLE_LOG
            char buf[100];
#endif
            dm.addr.port = d->c->peer.port;  // Save port
            d->c->peer = dm.addr;            // Copy resolved address
            LOG(LL_DEBUG, ("%lu %s resolved to %s", d->c->id, dm.name,
                           mg_ntoa(&d->c->peer, buf, sizeof(buf))));
            mg_connect_resolved(d->c);
#if MG_ENABLE_IPV6
          } else if (dm.addr.is_ip6 == false && dm.name[0] != '\0') {
            struct mg_str x = mg_str(dm.name);
            mg_sendnsreq(d->c, &x, c->mgr->dnstimeout, &c->mgr->dns6, true);
#endif
          } else {
            mg_error(d->c, "%s DNS lookup failed", dm.name);
          }
        } else {
          LOG(LL_ERROR, ("%lu already resolved", d->c->id));
        }
        mg_dns_free(d);
        resolved = 1;
      }
    }
    if (!resolved) LOG(LL_ERROR, ("stray DNS reply"));
    c->recv.len = 0;
  } else if (ev == MG_EV_CLOSE) {
    for (d = s_reqs; d != NULL; d = tmp) {
      tmp = d->next;
      mg_error(d->c, "DNS error");
      mg_dns_free(d);
    }
  }
  (void) fn_data;
}

static void mg_dns_send(struct mg_connection *c, const struct mg_str *name,
                        uint16_t txnid, bool ipv6) {
  struct {
    struct mg_dns_header header;
    uint8_t data[256];
  } pkt;
  size_t i, n;
  memset(&pkt, 0, sizeof(pkt));
  pkt.header.txnid = mg_htons(txnid);
  pkt.header.flags = mg_htons(0x100);
  pkt.header.num_questions = mg_htons(1);
  for (i = n = 0; i < sizeof(pkt.data) - 5; i++) {
    if (name->ptr[i] == '.' || i >= name->len) {
      pkt.data[n] = (uint8_t) (i - n);
      memcpy(&pkt.data[n + 1], name->ptr + n, i - n);
      n = i + 1;
    }
    if (i >= name->len) break;
  }
  memcpy(&pkt.data[n], "\x00\x00\x01\x00\x01", 5);  // A query
  n += 5;
  if (ipv6) pkt.data[n - 3] = 0x1c;  // AAAA query
  // memcpy(&pkt.data[n], "\xc0\x0c\x00\x1c\x00\x01", 6);  // AAAA query
  // n += 6;
  mg_send(c, &pkt, sizeof(pkt.header) + n);
#if 0
  // Immediately after A query, send AAAA query. Whatever reply comes first,
  // we'll use it. Note: we cannot send two queries in a single packet.
  // https://stackoverflow.com/questions/4082081/requesting-a-and-aaaa-records-in-single-dns-query
  pkt.data[n - 3] = 0x1c;  // AAAA query
  mg_send(c, &pkt, sizeof(pkt.header) + n);
#endif
}

static void mg_sendnsreq(struct mg_connection *c, struct mg_str *name, int ms,
                         struct mg_dns *dnsc, bool ipv6) {
  struct dns_data *d = NULL;
  if (dnsc->url == NULL) {
    mg_error(c, "DNS server URL is NULL. Call mg_mgr_init()");
  } else if (dnsc->c == NULL) {
    dnsc->c = mg_connect(c->mgr, dnsc->url, NULL, NULL);
    if (dnsc->c != NULL) {
      dnsc->c->pfn = dns_cb;
      // snprintf(dnsc->c->label, sizeof(dnsc->c->label), "%s", "DNS");
      // dnsc->c->is_hexdumping = 1;
    }
  }
  if (dnsc->c == NULL) {
    mg_error(c, "resolver");
  } else if ((d = (struct dns_data *) calloc(1, sizeof(*d))) == NULL) {
    mg_error(c, "resolve OOM");
  } else {
#if MG_ENABLE_LOG
    char buf[100];
#endif
    d->txnid = s_reqs ? (uint16_t) (s_reqs->txnid + 1) : 1;
    d->next = s_reqs;
    s_reqs = d;
    d->expire = mg_millis() + (int64_t) ms;
    d->c = c;
    c->is_resolving = 1;
    LOG(LL_VERBOSE_DEBUG,
        ("%lu resolving %.*s @ %s, txnid %hu", c->id, (int) name->len,
         name->ptr, mg_ntoa(&dnsc->c->peer, buf, sizeof(buf)), d->txnid));
    mg_dns_send(dnsc->c, name, d->txnid, ipv6);
  }
}

void mg_resolve(struct mg_connection *c, const char *url) {
  struct mg_str host = mg_url_host(url);
  c->peer.port = mg_htons(mg_url_port(url));
  if (mg_aton(host, &c->peer)) {
    // host is an IP address, do not fire name resolution
    mg_connect_resolved(c);
  } else {
    // host is not an IP, send DNS resolution request
    mg_sendnsreq(c, &host, c->mgr->dnstimeout, &c->mgr->dns4, false);
  }
}

#ifdef MG_ENABLE_LINES
#line 1 "src/event.c"
#endif





void mg_call(struct mg_connection *c, int ev, void *ev_data) {
  // Run user-defined handler first, in order to give it an ability
  // to intercept processing (e.g. clean input buffer) before the
  // protocol handler kicks in
  if (c->fn != NULL) c->fn(c, ev, ev_data, c->fn_data);
  if (c->pfn != NULL) c->pfn(c, ev, ev_data, c->pfn_data);
}

void mg_error(struct mg_connection *c, const char *fmt, ...) {
  char mem[256], *buf = mem;
  va_list ap;
  va_start(ap, fmt);
  mg_vasprintf(&buf, sizeof(mem), fmt, ap);
  va_end(ap);
  LOG(LL_ERROR, ("%lu %s", c->id, buf));
  c->is_closing = 1;             // Set is_closing before sending MG_EV_CALL
  mg_call(c, MG_EV_ERROR, buf);  // Let user handler to override it
  if (buf != mem) free(buf);
}

#ifdef MG_ENABLE_LINES
#line 1 "src/fs.c"
#endif



struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags) {
  struct mg_fd *fd = (struct mg_fd *) calloc(1, sizeof(*fd));
  if (fd != NULL) {
    fd->fd = fs->open(path, flags);
    fd->fs = fs;
    if (fd->fd == NULL) {
      free(fd);
      fd = NULL;
    }
  }
  return fd;
}

void mg_fs_close(struct mg_fd *fd) {
  if (fd != NULL) {
    fd->fs->close(fd->fd);
    free(fd);
  }
}

char *mg_file_read(struct mg_fs *fs, const char *path, size_t *sizep) {
  struct mg_fd *fd;
  char *data = NULL;
  size_t size = 0;
  fs->stat(path, &size, NULL);
  if ((fd = mg_fs_open(fs, path, MG_FS_READ)) != NULL) {
    data = (char *) calloc(1, size + 1);
    if (data != NULL) {
      if (fs->read(fd->fd, data, size) != size) {
        free(data);
        data = NULL;
      } else {
        data[size] = '\0';
        if (sizep != NULL) *sizep = size;
      }
    }
    mg_fs_close(fd);
  }
  return data;
}

bool mg_file_write(struct mg_fs *fs, const char *path, const void *buf,
                   size_t len) {
  bool result = false;
  struct mg_fd *fd;
  char tmp[MG_PATH_MAX];
  snprintf(tmp, sizeof(tmp), "%s..%d", path, rand());
  if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {
    result = fs->write(fd->fd, buf, len) == len;
    mg_fs_close(fd);
    if (result) {
      fs->remove(path);
      fs->rename(tmp, path);
    } else {
      fs->remove(tmp);
    }
  }
  return result;
}

bool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...) {
  char tmp[256], *buf = tmp;
  bool result;
  int len;
  va_list ap;
  va_start(ap, fmt);
  len = mg_vasprintf(&buf, sizeof(tmp), fmt, ap);
  va_end(ap);
  result = mg_file_write(fs, path, buf, len > 0 ? (size_t) len : 0);
  if (buf != tmp) free(buf);
  return result;
}

#ifdef MG_ENABLE_LINES
#line 1 "src/fs_fat.c"
#endif


#if MG_ENABLE_FATFS
#include <ff.h>

static int ff_stat(const char *path, size_t *size, time_t *mtime) {
  FILINFO fi;
  if (path[0] == '\0' || strcmp(path, MG_FATFS_ROOT) == 0) {
    if (size) *size = 0;
    if (mtime) *mtime = 0;
    return MG_FS_DIR;
  } else if (f_stat(path, &fi) == 0) {
    if (size) *size = (size_t) fi.fsize;
    if (mtime) *mtime = (fi.fdate << 16) | fi.ftime;
    return MG_FS_READ | MG_FS_WRITE | ((fi.fattrib & AM_DIR) ? MG_FS_DIR : 0);
  } else {
    return 0;
  }
}

static void ff_list(const char *dir, void (*fn)(const char *, void *),
                    void *userdata) {
  DIR d;
  FILINFO fi;
  if (f_opendir(&d, dir) == FR_OK) {
    while (f_readdir(&d, &fi) == FR_OK && fi.fname[0] != '\0') {
      if (!strcmp(fi.fname, ".") || !strcmp(fi.fname, "..")) continue;
      fn(fi.fname, userdata);
    }
    f_closedir(&d);
  }
}

static void *ff_open(const char *path, int flags) {
  FIL f;
  unsigned char mode =
      flags == MG_FS_READ ? FA_READ : FA_READ | FA_WRITE | FA_OPEN_APPEND;
  if (f_open(&f, path, mode) == 0) {
    FIL *fp = calloc(1, sizeof(*fp));
    *fp = f;
    return fp;
  } else {
    return NULL;
  }
}

static void ff_close(void *fp) {
  if (fp != NULL) {
    f_close((FIL *) fp);
    free(fp);
  }
}

static size_t ff_read(void *fp, void *buf, size_t len) {
  unsigned n = 0;
  f_read((FIL *) fp, buf, len, &n);
  return n;
}

static size_t ff_write(void *fp, const void *buf, size_t len) {
  unsigned n, sum = 0, bs = MG_FATFS_BSIZE;
  while ((size_t) sum < len &&
         f_write((FIL *) fp, (char *) buf + sum,
                 sum + bs > len ? len - sum : bs, &n) == FR_OK &&
         n > 0) {
    sum += n;
  }
  return sum;
}

static size_t ff_seek(void *fp, size_t offset) {
  f_lseek((FIL *) fp, offset);
  return offset;
}

static bool ff_rename(const char *from, const char *to) {
  return f_rename(from, to) == FR_OK;
}

static bool ff_remove(const char *path) {
  return f_unlink(path) == FR_OK;
}

static bool ff_mkdir(const char *path) {
  return f_mkdir(path) == FR_OK;
}

struct mg_fs mg_fs_fat = {ff_stat,  ff_list, ff_open,   ff_close,  ff_read,
                          ff_write, ff_seek, ff_rename, ff_remove, ff_mkdir};
#endif

#ifdef MG_ENABLE_LINES
#line 1 "src/fs_packed.c"
#endif


struct packed_file {
  const char *data;
  size_t size;
  size_t pos;
};

const char *mg_unpack(const char *path, size_t *size, time_t *mtime);
const char *mg_unlist(size_t no);
#if MG_ENABLE_PACKED_FS
#else
const char *mg_unpack(const char *path, size_t *size, time_t *mtime) {
  (void) path, (void) size, (void) mtime;
  return NULL;
}
const char *mg_unlist(size_t no) {
  (void) no;
  return NULL;
}
#endif

static int is_dir_prefix(const char *prefix, size_t n, const char *path) {
  return n < strlen(path) && memcmp(prefix, path, n) == 0 && path[n] == '/';
  //(n == 0 || path[n] == MG_DIRSEP);
}

static int packed_stat(const char *path, size_t *size, time_t *mtime) {
  const char *p;
  size_t i, n = strlen(path);
  if (mg_unpack(path, size, mtime)) return MG_FS_READ;  // Regular file
  // Scan all files. If `path` is a dir prefix for any of them, it's a dir
  for (i = 0; (p = mg_unlist(i)) != NULL; i++) {
    if (is_dir_prefix(path, n, p)) return MG_FS_DIR;
  }
  return 0;
}

static void packed_list(const char *dir, void (*fn)(const char *, void *),
                        void *userdata) {
  char buf[256], tmp[sizeof(buf)];
  const char *path, *begin, *end;
  size_t i, n = strlen(dir);
  tmp[0] = '\0';  // Previously listed entry
  for (i = 0; (path = mg_unlist(i)) != NULL; i++) {
    if (!is_dir_prefix(dir, n, path)) continue;
    begin = &path[n + 1];
    end = strchr(begin, '/');
    if (end == NULL) end = begin + strlen(begin);
    snprintf(buf, sizeof(buf), "%.*s", (int) (end - begin), begin);
    buf[sizeof(buf) - 1] = '\0';
    // If this entry has been already listed, skip
    // NOTE: we're assuming that file list is sorted alphabetically
    if (strcmp(buf, tmp) == 0) continue;
    fn(buf, userdata);  // Not yet listed, call user function
    strcpy(tmp, buf);   // And save this entry as listed
  }
}

static void *packed_open(const char *path, int flags) {
  size_t size = 0;
  const char *data = mg_unpack(path, &size, NULL);
  struct packed_file *fp = NULL;
  if (data == NULL) return NULL;
  if (flags & MG_FS_WRITE) return NULL;
  fp = (struct packed_file *) calloc(1, sizeof(*fp));
  fp->size = size;
  fp->data = data;
  return (void *) fp;
}

static void packed_close(void *fp) {
  if (fp != NULL) free(fp);
}

static size_t packed_read(void *fd, void *buf, size_t len) {
  struct packed_file *fp = (struct packed_file *) fd;
  if (fp->pos + len > fp->size) len = fp->size - fp->pos;
  memcpy(buf, &fp->data[fp->pos], len);
  fp->pos += len;
  return len;
}

static size_t packed_write(void *fd, const void *buf, size_t len) {
  (void) fd, (void) buf, (void) len;
  return 0;
}

static size_t packed_seek(void *fd, size_t offset) {
  struct packed_file *fp = (struct packed_file *) fd;
  fp->pos = offset;
  if (fp->pos > fp->size) fp->pos = fp->size;
  return fp->pos;
}

static bool packed_rename(const char *from, const char *to) {
  (void) from, (void) to;
  return false;
}

static bool packed_remove(const char *path) {
  (void) path;
  return false;
}

static bool packed_mkdir(const char *path) {
  (void) path;
  return false;
}

struct mg_fs mg_fs_packed = {
    packed_stat,  packed_list, packed_open,   packed_close,  packed_read,
    packed_write, packed_seek, packed_rename, packed_remove, packed_mkdir};

#ifdef MG_ENABLE_LINES
#line 1 "src/fs_posix.c"
#endif


#if MG_ENABLE_FILE

#ifndef MG_STAT_STRUCT
#define MG_STAT_STRUCT stat
#endif

#ifndef MG_STAT_FUNC
#define MG_STAT_FUNC stat
#endif

static int p_stat(const char *path, size_t *size, time_t *mtime) {
#if !defined(S_ISDIR)
  LOG(LL_ERROR, ("stat() API is not supported. %p %p %p", path, size, mtime));
  return 0;
#else
#if defined(_WIN32)
  struct _stati64 st;
  wchar_t tmp[PATH_MAX];
  MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));
  if (_wstati64(tmp, &st) != 0) return 0;
#else
  struct MG_STAT_STRUCT st;
  if (MG_STAT_FUNC(path, &st) != 0) return 0;
#endif
  if (size) *size = (size_t) st.st_size;
  if (mtime) *mtime = st.st_mtime;
  return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);
#endif
}

#ifdef _WIN32
struct dirent {
  char d_name[MAX_PATH];
};

typedef struct win32_dir {
  HANDLE handle;
  WIN32_FIND_DATAW info;
  struct dirent result;
} DIR;

int gettimeofday(struct timeval *tv, void *tz) {
  FILETIME ft;
  unsigned __int64 tmpres = 0;

  if (tv != NULL) {
    GetSystemTimeAsFileTime(&ft);
    tmpres |= ft.dwHighDateTime;
    tmpres <<= 32;
    tmpres |= ft.dwLowDateTime;
    tmpres /= 10;  // convert into microseconds
    tmpres -= (int64_t) 11644473600000000;
    tv->tv_sec = (long) (tmpres / 1000000UL);
    tv->tv_usec = (long) (tmpres % 1000000UL);
  }
  (void) tz;
  return 0;
}

static int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {
  int ret;
  char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;
  strncpy(buf, path, sizeof(buf));
  buf[sizeof(buf) - 1] = '\0';
  // Trim trailing slashes. Leave backslash for paths like "X:\"
  p = buf + strlen(buf) - 1;
  while (p > buf && p[-1] != ':' && (p[0] == '\\' || p[0] == '/')) *p-- = '\0';
  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));
  ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);
  // Convert back to Unicode. If doubly-converted string does not match the
  // original, something is fishy, reject.
  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),
                      NULL, NULL);
  if (strcmp(buf, buf2) != 0) {
    wbuf[0] = L'\0';
    ret = 0;
  }
  return ret;
}

DIR *opendir(const char *name) {
  DIR *d = NULL;
  wchar_t wpath[MAX_PATH];
  DWORD attrs;

  if (name == NULL) {
    SetLastError(ERROR_BAD_ARGUMENTS);
  } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
  } else {
    to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));
    attrs = GetFileAttributesW(wpath);
    if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {
      (void) wcscat(wpath, L"\\*");
      d->handle = FindFirstFileW(wpath, &d->info);
      d->result.d_name[0] = '\0';
    } else {
      free(d);
      d = NULL;
    }
  }
  return d;
}

int closedir(DIR *d) {
  int result = 0;
  if (d != NULL) {
    if (d->handle != INVALID_HANDLE_VALUE)
      result = FindClose(d->handle) ? 0 : -1;
    free(d);
  } else {
    result = -1;
    SetLastError(ERROR_BAD_ARGUMENTS);
  }
  return result;
}

struct dirent *readdir(DIR *d) {
  struct dirent *result = NULL;
  if (d != NULL) {
    memset(&d->result, 0, sizeof(d->result));
    if (d->handle != INVALID_HANDLE_VALUE) {
      result = &d->result;
      WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,
                          sizeof(result->d_name), NULL, NULL);
      if (!FindNextFileW(d->handle, &d->info)) {
        FindClose(d->handle);
        d->handle = INVALID_HANDLE_VALUE;
      }
    } else {
      SetLastError(ERROR_FILE_NOT_FOUND);
    }
  } else {
    SetLastError(ERROR_BAD_ARGUMENTS);
  }
  return result;
}
#endif

static void p_list(const char *dir, void (*fn)(const char *, void *),
                   void *userdata) {
#if MG_ENABLE_DIRLIST
  struct dirent *dp;
  DIR *dirp;
  if ((dirp = (opendir(dir))) == NULL) return;
  while ((dp = readdir(dirp)) != NULL) {
    if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, "..")) continue;
    fn(dp->d_name, userdata);
  }
  closedir(dirp);
#else
  (void) dir, (void) fn, (void) userdata;
#endif
}

static void *p_open(const char *path, int flags) {
  const char *mode = flags == MG_FS_READ ? "rb" : "a+b";
#ifdef _WIN32
  wchar_t b1[PATH_MAX], b2[10];
  MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));
  MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));
  return (void *) _wfopen(b1, b2);
#else
  return (void *) fopen(path, mode);
#endif
}

static void p_close(void *fp) {
  fclose((FILE *) fp);
}

static size_t p_read(void *fp, void *buf, size_t len) {
  return fread(buf, 1, len, (FILE *) fp);
}

static size_t p_write(void *fp, const void *buf, size_t len) {
  return fwrite(buf, 1, len, (FILE *) fp);
}

static size_t p_seek(void *fp, size_t offset) {
#if (defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64) ||  \
    (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) || \
    (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)
  fseeko((FILE *) fp, (off_t) offset, SEEK_SET);
#else
  fseek((FILE *) fp, (long) offset, SEEK_SET);
#endif
  return (size_t) ftell((FILE *) fp);
}

static bool p_rename(const char *from, const char *to) {
  return rename(from, to) == 0;
}

static bool p_remove(const char *path) {
  return remove(path) == 0;
}

static bool p_mkdir(const char *path) {
  return mkdir(path, 0775) == 0;
}

#else

static int p_stat(const char *path, size_t *size, time_t *mtime) {
  (void) path, (void) size, (void) mtime;
  return 0;
}
static void p_list(const char *path, void (*fn)(const char *, void *),
                   void *userdata) {
  (void) path, (void) fn, (void) userdata;
}
static void *p_open(const char *path, int flags) {
  (void) path, (void) flags;
  return NULL;
}
static void p_close(void *fp) {
  (void) fp;
}
static size_t p_read(void *fd, void *buf, size_t len) {
  (void) fd, (void) buf, (void) len;
  return 0;
}
static size_t p_write(void *fd, const void *buf, size_t len) {
  (void) fd, (void) buf, (void) len;
  return 0;
}
static size_t p_seek(void *fd, size_t offset) {
  (void) fd, (void) offset;
  return (size_t) ~0;
}
static bool p_rename(const char *from, const char *to) {
  (void) from, (void) to;
  return false;
}
static bool p_remove(const char *path) {
  (void) path;
  return false;
}
static bool p_mkdir(const char *path) {
  (void) path;
  return false;
}
#endif

struct mg_fs mg_fs_posix = {p_stat,  p_list, p_open,   p_close,  p_read,
                            p_write, p_seek, p_rename, p_remove, p_mkdir};

#ifdef MG_ENABLE_LINES
#line 1 "src/http.c"
#endif










// Multipart POST example:
// --xyz
// Content-Disposition: form-data; name="val"
//
// abcdef
// --xyz
// Content-Disposition: form-data; name="foo"; filename="a.txt"
// Content-Type: text/plain
//
// hello world
//
// --xyz--
size_t mg_http_next_multipart(struct mg_str body, size_t ofs,
                              struct mg_http_part *part) {
  struct mg_str cd = mg_str_n("Content-Disposition", 19);
  const char *s = body.ptr;
  size_t b = ofs, h1, h2, b1, b2, max = body.len;

  // Init part params
  if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);

  // Skip boundary
  while (b + 2 < max && s[b] != '\r' && s[b + 1] != '\n') b++;
  if (b <= ofs || b + 2 >= max) return 0;
  // LOG(LL_INFO, ("B: %zu %zu [%.*s]", ofs, b - ofs, (int) (b - ofs), s));

  // Skip headers
  h1 = h2 = b + 2;
  for (;;) {
    while (h2 + 2 < max && s[h2] != '\r' && s[h2 + 1] != '\n') h2++;
    if (h2 == h1) break;
    if (h2 + 2 >= max) return 0;
    // LOG(LL_INFO, ("Header: [%.*s]", (int) (h2 - h1), &s[h1]));
    if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&
        mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {
      struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));
      part->name = mg_http_get_header_var(v, mg_str_n("name", 4));
      part->filename = mg_http_get_header_var(v, mg_str_n("filename", 8));
    }
    h1 = h2 = h2 + 2;
  }
  b1 = b2 = h2 + 2;
  while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\r' && s[b2 + 1] == '\n' &&
                                           memcmp(&s[b2 + 2], s, b - ofs) == 0))
    b2++;

  if (b2 + 2 >= max) return 0;
  if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);
  // LOG(LL_INFO, ("Body: [%.*s]", (int) (b2 - b1), &s[b1]));
  return b2 + 2;
}

void mg_http_bauth(struct mg_connection *c, const char *user,
                   const char *pass) {
  struct mg_str u = mg_str(user), p = mg_str(pass);
  size_t need = c->send.len + 36 + (u.len + p.len) * 2;
  if (c->send.size < need) mg_iobuf_resize(&c->send, need);
  if (c->send.size >= need) {
    int i, n = 0;
    char *buf = (char *) &c->send.buf[c->send.len + 21];
    memcpy(&buf[-21], "Authorization: Basic ", 21);  // DON'T use mg_send!
    for (i = 0; i < (int) u.len; i++) {
      n = mg_base64_update(((unsigned char *) u.ptr)[i], buf, n);
    }
    if (p.len > 0) {
      n = mg_base64_update(':', buf, n);
      for (i = 0; i < (int) p.len; i++) {
        n = mg_base64_update(((unsigned char *) p.ptr)[i], buf, n);
      }
    }
    n = mg_base64_final(buf, n);
    c->send.len += 21 + (size_t) n + 2;
    memcpy(&c->send.buf[c->send.len - 2], "\r\n", 2);
  } else {
    LOG(LL_ERROR, ("%lu %s cannot resize iobuf %d->%d ", c->id, c->label,
                   (int) c->send.size, (int) need));
  }
}

int mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,
                    size_t dst_len) {
  const char *p, *e, *s;
  size_t name_len;
  int len;

  if (dst == NULL || dst_len == 0) {
    len = -2;  // Bad destination
  } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {
    len = -1;  // Bad source
    dst[0] = '\0';
  } else {
    name_len = strlen(name);
    e = buf->ptr + buf->len;
    len = -4;  // Name does not exist
    dst[0] = '\0';
    for (p = buf->ptr; p + name_len < e; p++) {
      if ((p == buf->ptr || p[-1] == '&') && p[name_len] == '=' &&
          !mg_ncasecmp(name, p, name_len)) {
        p += name_len + 1;
        s = (const char *) memchr(p, '&', (size_t) (e - p));
        if (s == NULL) s = e;
        len = mg_url_decode(p, (size_t) (s - p), dst, dst_len, 1);
        if (len < 0) len = -3;  // Failed to decode
        break;
      }
    }
  }
  return len;
}

int mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,
                  int is_form_url_encoded) {
  size_t i, j;
  for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {
    if (src[i] == '%') {
      // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len
      if (i + 2 < src_len && isxdigit(*(const unsigned char *) (src + i + 1)) &&
          isxdigit(*(const unsigned char *) (src + i + 2))) {
        mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);
        i += 2;
      } else {
        return -1;
      }
    } else if (is_form_url_encoded && src[i] == '+') {
      dst[j] = ' ';
    } else {
      dst[j] = src[i];
    }
  }
  if (j < dst_len) dst[j] = '\0';  // Null-terminate the destination
  return i >= src_len && j < dst_len ? (int) j : -1;
}

int mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {
  size_t i;
  for (i = 0; i < buf_len; i++) {
    if (!isprint(buf[i]) && buf[i] != '\r' && buf[i] != '\n' && buf[i] < 128)
      return -1;
    if ((i > 0 && buf[i] == '\n' && buf[i - 1] == '\n') ||
        (i > 3 && buf[i] == '\n' && buf[i - 1] == '\r' && buf[i - 2] == '\n'))
      return (int) i + 1;
  }
  return 0;
}

static const char *skip(const char *s, const char *e, const char *d,
                        struct mg_str *v) {
  v->ptr = s;
  while (s < e && *s != '\n' && strchr(d, *s) == NULL) s++;
  v->len = (size_t) (s - v->ptr);
  while (s < e && strchr(d, *s) != NULL) s++;
  return s;
}

struct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {
  size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);
  for (i = 0; i < max && h->headers[i].name.len > 0; i++) {
    struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;
    if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;
  }
  return NULL;
}

static void mg_http_parse_headers(const char *s, const char *end,
                                  struct mg_http_header *h, int max_headers) {
  int i;
  for (i = 0; i < max_headers; i++) {
    struct mg_str k, v, tmp;
    const char *he = skip(s, end, "\n", &tmp);
    s = skip(s, he, ": \r\n", &k);
    s = skip(s, he, "\r\n", &v);
    if (k.len == tmp.len) continue;
    while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces
    if (k.len == 0) break;
    // LOG(LL_INFO, ("--HH [%.*s] [%.*s] [%.*s]", (int) tmp.len - 1, tmp.ptr,
    //(int) k.len, k.ptr, (int) v.len, v.ptr));
    h[i].name = k;
    h[i].value = v;
  }
}

int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {
  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);
  const char *end = s + req_len, *qs;
  struct mg_str *cl;

  memset(hm, 0, sizeof(*hm));
  if (req_len <= 0) return req_len;

  hm->message.ptr = hm->head.ptr = s;
  hm->body.ptr = end;
  hm->head.len = (size_t) req_len;
  hm->chunk.ptr = end;
  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite

  // Parse request line
  s = skip(s, end, " ", &hm->method);
  s = skip(s, end, " ", &hm->uri);
  s = skip(s, end, "\r\n", &hm->proto);

  // Sanity check. Allow protocol/reason to be empty
  if (hm->method.len == 0 || hm->uri.len == 0) return -1;

  // If URI contains '?' character, setup query string
  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {
    hm->query.ptr = qs + 1;
    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));
    hm->uri.len = (size_t) (qs - hm->uri.ptr);
  }

  mg_http_parse_headers(s, end, hm->headers,
                        sizeof(hm->headers) / sizeof(hm->headers[0]));
  if ((cl = mg_http_get_header(hm, "Content-Length")) != NULL) {
    hm->body.len = (size_t) mg_to64(*cl);
    hm->message.len = (size_t) req_len + hm->body.len;
  }

  // mg_http_parse() is used to parse both HTTP requests and HTTP
  // responses. If HTTP response does not have Content-Length set, then
  // body is read until socket is closed, i.e. body.len is infinite (~0).
  //
  // For HTTP requests though, according to
  // http://tools.ietf.org/html/rfc7231#section-8.1.3,
  // only POST and PUT methods have defined body semantics.
  // Therefore, if Content-Length is not specified and methods are
  // not one of PUT or POST, set body length to 0.
  //
  // So, if it is HTTP request, and Content-Length is not set,
  // and method is not (PUT or POST) then reset body length to zero.
  is_response = mg_ncasecmp(hm->method.ptr, "HTTP/", 5) == 0;
  if (hm->body.len == (size_t) ~0 && !is_response &&
      mg_vcasecmp(&hm->method, "PUT") != 0 &&
      mg_vcasecmp(&hm->method, "POST") != 0) {
    hm->body.len = 0;
    hm->message.len = (size_t) req_len;
  }

  // The 204 (No content) responses also have 0 body length
  if (hm->body.len == (size_t) ~0 && is_response &&
      mg_vcasecmp(&hm->uri, "204") == 0) {
    hm->body.len = 0;
    hm->message.len = (size_t) req_len;
  }

  return req_len;
}

static void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,
                                  va_list ap) {
  char mem[256], *buf = mem;
  int len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);
  mg_printf(c, "%X\r\n", len);
  mg_send(c, buf, len > 0 ? (size_t) len : 0);
  mg_send(c, "\r\n", 2);
  if (buf != mem) free(buf);
}

void mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  mg_http_vprintf_chunk(c, fmt, ap);
  va_end(ap);
}

void mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {
  mg_printf(c, "%lX\r\n", (unsigned long) len);
  mg_send(c, buf, len);
  mg_send(c, "\r\n", 2);
}

// clang-format off
static const char *mg_http_status_code_str(int status_code) {
  switch (status_code) {
    case 100: return "Continue";
    case 101: return "Switching Protocols";
    case 102: return "Processing";
    case 200: return "OK";
    case 201: return "Created";
    case 202: return "Accepted";
    case 203: return "Non-authoritative Information";
    case 204: return "No Content";
    case 205: return "Reset Content";
    case 206: return "Partial Content";
    case 207: return "Multi-Status";
    case 208: return "Already Reported";
    case 226: return "IM Used";
    case 300: return "Multiple Choices";
    case 301: return "Moved Permanently";
    case 302: return "Found";
    case 303: return "See Other";
    case 304: return "Not Modified";
    case 305: return "Use Proxy";
    case 307: return "Temporary Redirect";
    case 308: return "Permanent Redirect";
    case 400: return "Bad Request";
    case 401: return "Unauthorized";
    case 402: return "Payment Required";
    case 403: return "Forbidden";
    case 404: return "Not Found";
    case 405: return "Method Not Allowed";
    case 406: return "Not Acceptable";
    case 407: return "Proxy Authentication Required";
    case 408: return "Request Timeout";
    case 409: return "Conflict";
    case 410: return "Gone";
    case 411: return "Length Required";
    case 412: return "Precondition Failed";
    case 413: return "Payload Too Large";
    case 414: return "Request-URI Too Long";
    case 415: return "Unsupported Media Type";
    case 416: return "Requested Range Not Satisfiable";
    case 417: return "Expectation Failed";
    case 418: return "I'm a teapot";
    case 421: return "Misdirected Request";
    case 422: return "Unprocessable Entity";
    case 423: return "Locked";
    case 424: return "Failed Dependency";
    case 426: return "Upgrade Required";
    case 428: return "Precondition Required";
    case 429: return "Too Many Requests";
    case 431: return "Request Header Fields Too Large";
    case 444: return "Connection Closed Without Response";
    case 451: return "Unavailable For Legal Reasons";
    case 499: return "Client Closed Request";
    case 500: return "Internal Server Error";
    case 501: return "Not Implemented";
    case 502: return "Bad Gateway";
    case 503: return "Service Unavailable";
    case 504: return "Gateway Timeout";
    case 505: return "HTTP Version Not Supported";
    case 506: return "Variant Also Negotiates";
    case 507: return "Insufficient Storage";
    case 508: return "Loop Detected";
    case 510: return "Not Extended";
    case 511: return "Network Authentication Required";
    case 599: return "Network Connect Timeout Error";
    default: return "OK";
  }
}
// clang-format on

void mg_http_reply(struct mg_connection *c, int code, const char *headers,
                   const char *fmt, ...) {
  char mem[256], *buf = mem;
  va_list ap;
  int len;
  va_start(ap, fmt);
  len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);
  va_end(ap);
  mg_printf(c, "HTTP/1.1 %d %s\r\n%sContent-Length: %d\r\n\r\n", code,
            mg_http_status_code_str(code), headers == NULL ? "" : headers, len);
  mg_send(c, buf, len > 0 ? (size_t) len : 0);
  if (buf != mem) free(buf);
}

static void http_cb(struct mg_connection *, int, void *, void *);
static void restore_http_cb(struct mg_connection *c) {
  mg_fs_close((struct mg_fd *) c->pfn_data);
  c->pfn_data = NULL;
  c->pfn = http_cb;
}

char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);
char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {
  snprintf(buf, len, "\"%lx." MG_INT64_FMT "\"", (unsigned long) mtime,
           (int64_t) size);
  return buf;
}

static void static_cb(struct mg_connection *c, int ev, void *ev_data,
                      void *fn_data) {
  if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {
    struct mg_fd *fd = (struct mg_fd *) fn_data;
    // Read to send IO buffer directly, avoid extra on-stack buffer
    size_t n, max = 2 * MG_IO_SIZE;
    if (c->send.size < max) mg_iobuf_resize(&c->send, max);
    if (c->send.len >= c->send.size) return;  // Rate limit
    n = fd->fs->read(fd->fd, c->send.buf + c->send.len,
                     c->send.size - c->send.len);
    if (n > 0) c->send.len += n;
    if (c->send.len < c->send.size) restore_http_cb(c);
  } else if (ev == MG_EV_CLOSE) {
    restore_http_cb(c);
  }
  (void) ev_data;
}

static struct mg_str guess_content_type(struct mg_str path, const char *extra) {
  // clang-format off
  struct mimeentry { struct mg_str extension, value; };
  #define MIME_ENTRY(a, b) {{a, sizeof(a) - 1 }, { b, sizeof(b) - 1 }}
  // clang-format on
  const struct mimeentry tab[] = {
      MIME_ENTRY("html", "text/html; charset=utf-8"),
      MIME_ENTRY("htm", "text/html; charset=utf-8"),
      MIME_ENTRY("css", "text/css; charset=utf-8"),
      MIME_ENTRY("js", "text/javascript; charset=utf-8"),
      MIME_ENTRY("gif", "image/gif"),
      MIME_ENTRY("png", "image/png"),
      MIME_ENTRY("jpg", "image/jpeg"),
      MIME_ENTRY("jpeg", "image/jpeg"),
      MIME_ENTRY("woff", "font/woff"),
      MIME_ENTRY("ttf", "font/ttf"),
      MIME_ENTRY("svg", "image/svg+xml"),
      MIME_ENTRY("txt", "text/plain; charset=utf-8"),
      MIME_ENTRY("avi", "video/x-msvideo"),
      MIME_ENTRY("csv", "text/csv"),
      MIME_ENTRY("doc", "application/msword"),
      MIME_ENTRY("exe", "application/octet-stream"),
      MIME_ENTRY("gz", "application/gzip"),
      MIME_ENTRY("ico", "image/x-icon"),
      MIME_ENTRY("json", "application/json"),
      MIME_ENTRY("mov", "video/quicktime"),
      MIME_ENTRY("mp3", "audio/mpeg"),
      MIME_ENTRY("mp4", "video/mp4"),
      MIME_ENTRY("mpeg", "video/mpeg"),
      MIME_ENTRY("pdf", "application/pdf"),
      MIME_ENTRY("shtml", "text/html; charset=utf-8"),
      MIME_ENTRY("tgz", "application/tar-gz"),
      MIME_ENTRY("wav", "audio/wav"),
      MIME_ENTRY("webp", "image/webp"),
      MIME_ENTRY("zip", "application/zip"),
      MIME_ENTRY("3gp", "video/3gpp"),
      {{0, 0}, {0, 0}},
  };
  size_t i = 0;
  struct mg_str k, v, s = mg_str(extra);

  // Shrink path to its extension only
  while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;
  path.ptr += path.len - i;
  path.len = i;

  // Process user-provided mime type overrides, if any
  while (mg_commalist(&s, &k, &v)) {
    if (mg_strcmp(path, k) == 0) return v;
  }

  // Process built-in mime types
  for (i = 0; tab[i].extension.ptr != NULL; i++) {
    if (mg_strcmp(path, tab[i].extension) == 0) return tab[i].value;
  }

  return mg_str("text/plain; charset=utf-8");
}

static int getrange(struct mg_str *s, int64_t *a, int64_t *b) {
  size_t i, numparsed = 0;
  LOG(LL_INFO, ("%.*s", (int) s->len, s->ptr));
  for (i = 0; i + 6 < s->len; i++) {
    if (memcmp(&s->ptr[i], "bytes=", 6) == 0) {
      struct mg_str p = mg_str_n(s->ptr + i + 6, s->len - i - 6);
      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;
      *a = mg_to64(p);
      // LOG(LL_INFO, ("PPP [%.*s] %d", (int) p.len, p.ptr, numparsed));
      while (p.len && p.ptr[0] >= '0' && p.ptr[0] <= '9') p.ptr++, p.len--;
      if (p.len && p.ptr[0] == '-') p.ptr++, p.len--;
      *b = mg_to64(p);
      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;
      // LOG(LL_INFO, ("PPP [%.*s] %d", (int) p.len, p.ptr, numparsed));
      break;
    }
  }
  return (int) numparsed;
}

void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,
                        const char *path, struct mg_http_serve_opts *opts) {
  char etag[64];
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_fd *fd = mg_fs_open(fs, path, MG_FS_READ);
  size_t size = 0;
  time_t mtime = 0;
  struct mg_str *inm = NULL;

  if (fd == NULL || fs->stat(path, &size, &mtime) == 0) {
    LOG(LL_DEBUG, ("404 [%s] %p", path, (void *) fd));
    mg_http_reply(c, 404, "", "%s", "Not found\n");
    mg_fs_close(fd);
    // NOTE: mg_http_etag() call should go first!
  } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&
             (inm = mg_http_get_header(hm, "If-None-Match")) != NULL &&
             mg_vcasecmp(inm, etag) == 0) {
    mg_fs_close(fd);
    mg_printf(c, "HTTP/1.1 304 Not Modified\r\nContent-Length: 0\r\n\r\n");
  } else {
    int n, status = 200;
    char range[100] = "";
    int64_t r1 = 0, r2 = 0, cl = (int64_t) size;
    struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);

    // Handle Range header
    struct mg_str *rh = mg_http_get_header(hm, "Range");
    if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {
      // If range is specified like "400-", set second limit to content len
      if (n == 1) r2 = cl - 1;
      if (r1 > r2 || r2 >= cl) {
        status = 416;
        cl = 0;
        snprintf(range, sizeof(range),
                 "Content-Range: bytes */" MG_INT64_FMT "\r\n", (int64_t) size);
      } else {
        status = 206;
        cl = r2 - r1 + 1;
        snprintf(range, sizeof(range),
                 "Content-Range: bytes " MG_INT64_FMT "-" MG_INT64_FMT
                 "/" MG_INT64_FMT "\r\n",
                 r1, r1 + cl - 1, (int64_t) size);
        fs->seek(fd->fd, (size_t) r1);
      }
    }

    mg_printf(c,
              "HTTP/1.1 %d %s\r\nContent-Type: %.*s\r\n"
              "Etag: %s\r\nContent-Length: " MG_INT64_FMT "\r\n%s%s\r\n",
              status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,
              etag, cl, range, opts->extra_headers ? opts->extra_headers : "");
    if (mg_vcasecmp(&hm->method, "HEAD") == 0) {
      c->is_draining = 1;
      mg_fs_close(fd);
    } else {
      c->pfn = static_cb;
      c->pfn_data = fd;
    }
  }
}

struct printdirentrydata {
  struct mg_connection *c;
  struct mg_http_message *hm;
  struct mg_http_serve_opts *opts;
  const char *dir;
};

static void printdirentry(const char *name, void *userdata) {
  struct printdirentrydata *d = (struct printdirentrydata *) userdata;
  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;
  size_t size = 0;
  time_t t = 0;
  char path[MG_PATH_MAX], sz[64], mod[64];
  int flags, n = 0;

  // LOG(LL_DEBUG, ("[%s] [%s]", d->dir, name));
  if (snprintf(path, sizeof(path), "%s%c%s", d->dir, '/', name) < 0) {
    LOG(LL_ERROR, ("%s truncated", name));
  } else if ((flags = fs->stat(path, &size, &t)) == 0) {
    LOG(LL_ERROR, ("%lu stat(%s): %d", d->c->id, path, errno));
  } else {
    const char *slash = flags & MG_FS_DIR ? "/" : "";
    struct tm tm;
    if (flags & MG_FS_DIR) {
      snprintf(sz, sizeof(sz), "%s", "[DIR]");
    } else if (size < 1024) {
      snprintf(sz, sizeof(sz), "%d", (int) size);
    } else if (size < 0x100000) {
      snprintf(sz, sizeof(sz), "%.1fk", (double) size / 1024.0);
    } else if (size < 0x40000000) {
      snprintf(sz, sizeof(sz), "%.1fM", (double) size / 1048576);
    } else {
      snprintf(sz, sizeof(sz), "%.1fG", (double) size / 1073741824);
    }
    strftime(mod, sizeof(mod), "%d-%b-%Y %H:%M", localtime_r(&t, &tm));
    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));
    mg_printf(d->c,
              "  <tr><td><a href=\"%.*s%s\">%s%s</a></td>"
              "<td name=%lu>%s</td><td name=" MG_INT64_FMT ">%s</td></tr>\n",
              n, path, slash, name, slash, (unsigned long) t, mod,
              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);
  }
}

static void listdir(struct mg_connection *c, struct mg_http_message *hm,
                    struct mg_http_serve_opts *opts, char *dir) {
  static const char *sort_js_code =
      "<script>function srt(tb, sc, so, d) {"
      "var tr = Array.prototype.slice.call(tb.rows, 0),"
      "tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],"
      "n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), "
      "t1 = a.cells[2].getAttribute('name'), "
      "t2 = b.cells[2].getAttribute('name'); "
      "return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : "
      "n1 ? parseInt(n2) - parseInt(n1) : "
      "c1.textContent.trim().localeCompare(c2.textContent.trim())); });";
  static const char *sort_js_code2 =
      "for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); "
      "if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); "
      "};"
      "window.onload = function() {"
      "var tb = document.getElementById('tb');"
      "var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];"
      "var sc = m[1], so = m[2]; document.onclick = function(ev) { "
      "var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); "
      "sc = c; ev.preventDefault();}};"
      "srt(tb, sc, so, true);"
      "}"
      "</script>";
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct printdirentrydata d = {c, hm, opts, dir};
  char tmp[10], buf[MG_PATH_MAX];
  size_t off, n;
  int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);
  struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;

  mg_printf(c,
            "HTTP/1.1 200 OK\r\n"
            "Content-Type: text/html; charset=utf-8\r\n"
            "%s"
            "Content-Length:         \r\n\r\n",
            opts->extra_headers == NULL ? "" : opts->extra_headers);
  off = c->send.len;  // Start of body
  mg_printf(c,
            "<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s"
            "<style>th,td {text-align: left; padding-right: 1em; "
            "font-family: monospace; }</style></head>"
            "<body><h1>Index of %.*s</h1><table cellpadding=\"0\"><thead>"
            "<tr><th><a href=\"#\" rel=\"0\">Name</a></th><th>"
            "<a href=\"#\" rel=\"1\">Modified</a></th>"
            "<th><a href=\"#\" rel=\"2\">Size</a></th></tr>"
            "<tr><td colspan=\"3\"><hr></td></tr>"
            "</thead>"
            "<tbody id=\"tb\">\n",
            (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,
            uri.ptr);

  fs->list(dir, printdirentry, &d);
  mg_printf(c,
            "</tbody><tfoot><tr><td colspan=\"3\"><hr></td></tr></tfoot>"
            "</table><address>Mongoose v.%s</address></body></html>\n",
            MG_VERSION);
  n = (size_t) snprintf(tmp, sizeof(tmp), "%lu",
                        (unsigned long) (c->send.len - off));
  if (n > sizeof(tmp)) n = 0;
  memcpy(c->send.buf + off - 10, tmp, n);  // Set content length
}

static void remove_double_dots(char *s) {
  char *p = s;
  while (*s != '\0') {
    *p++ = *s++;
    if (s[-1] == '/' || s[-1] == '\\') {
      while (s[0] != '\0') {
        if (s[0] == '/' || s[0] == '\\') {
          s++;
        } else if (s[0] == '.' && s[1] == '.' &&
                   (s[2] == '/' || s[2] == '\\')) {
          s += 2;
        } else {
          break;
        }
      }
    }
  }
  *p = '\0';
}

// Resolve requested file into `path` and return its fs->stat() result
static int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,
                        struct mg_fs *fs, struct mg_str url, struct mg_str dir,
                        char *path, size_t path_size) {
  int flags = 0, tmp;
  // Append URI to the root_dir, and sanitize it
  size_t n = (size_t) snprintf(path, path_size, "%.*s", (int) dir.len, dir.ptr);
  if (n > path_size) n = path_size;
  path[path_size - 1] = '\0';
  if ((fs->stat(path, NULL, NULL) & MG_FS_DIR) == 0) {
    mg_http_reply(c, 400, "", "Invalid web root [%.*s]\n", (int) dir.len,
                  dir.ptr);
  } else {
    if (n + 2 < path_size) path[n++] = '/', path[n] = '\0';
    mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,
                  path_size - n, 0);
    path[path_size - 1] = '\0';  // Double-check
    remove_double_dots(path);
    n = strlen(path);
    LOG(LL_VERBOSE_DEBUG,
        ("%lu %.*s -> %s", c->id, (int) hm->uri.len, hm->uri.ptr, path));
    while (n > 0 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes
    flags = fs->stat(path, NULL, NULL);                 // Does it exist?
    if (flags == 0) {
      mg_http_reply(c, 404, "", "Not found\n");  // Does not exist, doh
    } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&
               hm->uri.ptr[hm->uri.len - 1] != '/') {
      mg_printf(c,
                "HTTP/1.1 301 Moved\r\n"
                "Location: %.*s/\r\n"
                "Content-Length: 0\r\n"
                "\r\n",
                (int) hm->uri.len, hm->uri.ptr);
      flags = 0;
    } else if (flags & MG_FS_DIR) {
      if (((snprintf(path + n, path_size - n, "/" MG_HTTP_INDEX) > 0 &&
            (tmp = fs->stat(path, NULL, NULL)) != 0) ||
           (snprintf(path + n, path_size - n, "/index.shtml") > 0 &&
            (tmp = fs->stat(path, NULL, NULL)) != 0))) {
        flags = tmp;
      } else {
        path[n] = '\0';  // Remove appended index file name
      }
    }
  }
  return flags;
}

static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str("/");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}

void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts) {
  char path[MG_PATH_MAX] = "";
  const char *sp = opts->ssi_pattern;
  int flags = uri_to_path(c, hm, opts, path, sizeof(path));
  if (flags == 0) return;
  LOG(LL_VERBOSE_DEBUG,
      ("%.*s %s %d", (int) hm->uri.len, hm->uri.ptr, path, flags));
  if (flags & MG_FS_DIR) {
    listdir(c, hm, opts, path);
  } else if (sp != NULL && mg_globmatch(sp, strlen(sp), path, strlen(path))) {
    mg_http_serve_ssi(c, opts->root_dir, path);
  } else {
    mg_http_serve_file(c, hm, path, opts);
  }
}

static bool mg_is_url_safe(int c) {
  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||
         (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';
}

size_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {
  size_t i, n = 0;
  for (i = 0; i < sl; i++) {
    int c = *(unsigned char *) &s[i];
    if (n + 4 >= len) return 0;
    if (mg_is_url_safe(c)) {
      buf[n++] = s[i];
    } else {
      buf[n++] = '%';
      mg_hex(&s[i], 1, &buf[n]);
      n += 2;
    }
  }
  return n;
}

void mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,
                   char *pass, size_t passlen) {
  struct mg_str *v = mg_http_get_header(hm, "Authorization");
  user[0] = pass[0] = '\0';
  if (v != NULL && v->len > 6 && memcmp(v->ptr, "Basic ", 6) == 0) {
    char buf[256];
    int n = mg_base64_decode(v->ptr + 6, (int) v->len - 6, buf);
    const char *p = (const char *) memchr(buf, ':', n > 0 ? (size_t) n : 0);
    if (p != NULL) {
      snprintf(user, userlen, "%.*s", (int) (p - buf), buf);
      snprintf(pass, passlen, "%.*s", n - (int) (p - buf) - 1, p + 1);
    }
  } else if (v != NULL && v->len > 7 && memcmp(v->ptr, "Bearer ", 7) == 0) {
    snprintf(pass, passlen, "%.*s", (int) v->len - 7, v->ptr + 7);
  } else if ((v = mg_http_get_header(hm, "Cookie")) != NULL) {
    struct mg_str t = mg_http_get_header_var(*v, mg_str_n("access_token", 12));
    if (t.len > 0) snprintf(pass, passlen, "%.*s", (int) t.len, t.ptr);
  } else {
    mg_http_get_var(&hm->query, "access_token", pass, passlen);
  }
}

static struct mg_str stripquotes(struct mg_str s) {
  return s.len > 1 && s.ptr[0] == '"' && s.ptr[s.len - 1] == '"'
             ? mg_str_n(s.ptr + 1, s.len - 2)
             : s;
}

struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {
  size_t i;
  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {
    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {
      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];
      int q = p < x && *p == '"' ? 1 : 0;
      while (p < x &&
             (q ? p == b || *p != '"' : *p != ';' && *p != ' ' && *p != ','))
        p++;
      // LOG(LL_INFO, ("[%.*s] [%.*s] [%.*s]", (int) s.len, s.ptr, (int) v.len,
      // v.ptr, (int) (p - b), b));
      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));
    }
  }
  return mg_str_n(NULL, 0);
}

bool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {
  return mg_globmatch(glob, strlen(glob), hm->uri.ptr, hm->uri.len);
}

static size_t get_chunk_length(const char *buf, size_t len, size_t *ll) {
  size_t i = 0, n;
  while (i < len && buf[i] != '\r' && i != '\n') i++;
  n = mg_unhexn((char *) buf, i);
  while (i < len && (buf[i] == '\r' || i == '\n')) i++;
  // LOG(LL_INFO, ("len %zu i %zu n %zu ", len, i, n));
  if (ll != NULL) *ll = i + 1;
  if (i < len && i + n + 2 < len) return i + n + 3;
  return 0;
}

// Walk through all chunks in the chunked body. For each chunk, fire
// an MG_EV_HTTP_CHUNK event.
static void walkchunks(struct mg_connection *c, struct mg_http_message *hm,
                       size_t reqlen) {
  size_t off = 0, bl, ll;
  while (off + reqlen < c->recv.len) {
    char *buf = (char *) &c->recv.buf[reqlen];
    size_t memo = c->recv.len;
    size_t cl = get_chunk_length(&buf[off], memo - reqlen - off, &ll);
    // LOG(LL_INFO, ("len %zu off %zu cl %zu ll %zu", len, off, cl, ll));
    if (cl == 0) break;
    hm->chunk = mg_str_n(&buf[off + ll], cl < ll + 2 ? 0 : cl - ll - 2);
    mg_call(c, MG_EV_HTTP_CHUNK, hm);
    // Increase offset only if user has not deleted this chunk
    if (memo == c->recv.len) off += cl;
    if (cl <= 5) {
      // Zero chunk - last one. Prepare body - cut off chunk lengths
      off = bl = 0;
      while (off + reqlen < c->recv.len) {
        char *buf2 = (char *) &c->recv.buf[reqlen];
        size_t memo2 = c->recv.len;
        size_t cl2 = get_chunk_length(&buf2[off], memo2 - reqlen - off, &ll);
        size_t n = cl2 < ll + 2 ? 0 : cl2 - ll - 2;
        memmove(buf2 + bl, buf2 + off + ll, n);
        bl += n;
        off += cl2;
        if (cl2 <= 5) break;
      }
      // LOG(LL_INFO, ("BL->%d del %d off %d", (int) bl, (int) del, (int) off));
      c->recv.len -= off - bl;
      // Set message length to indicate we've received
      // everything, to fire MG_EV_HTTP_MSG
      hm->message.len = bl + reqlen;
      hm->body.len = bl;
      break;
    }
  }
}

static bool mg_is_chunked(struct mg_http_message *hm) {
  struct mg_str needle = mg_str_n("chunked", 7);
  struct mg_str *te = mg_http_get_header(hm, "Transfer-Encoding");
  return te != NULL && mg_strstr(*te, needle) != NULL;
}

void mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {
  struct mg_str ch = hm->chunk;
  if (mg_is_chunked(hm)) {
    ch.len += 4;  // \r\n before and after the chunk
    ch.ptr -= 2;
    while (ch.ptr > hm->body.ptr && *ch.ptr != '\n') ch.ptr--, ch.len++;
  }
  {
    const char *end = &ch.ptr[ch.len];
    size_t n = (size_t) (end - (char *) c->recv.buf);
    if (c->recv.len > n) {
      memmove((char *) ch.ptr, end, (size_t) (c->recv.len - n));
    }
    // LOG(LL_INFO, ("DELETING CHUNK: %zu %zu %zu\n%.*s", c->recv.len, n,
    // ch.len, (int) ch.len, ch.ptr));
  }
  c->recv.len -= ch.len;
}

int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,
                   struct mg_fs *fs, const char *dir) {
  char offset[40] = "", name[200] = "", path[256];
  mg_http_get_var(&hm->query, "offset", offset, sizeof(offset));
  mg_http_get_var(&hm->query, "name", name, sizeof(name));
  if (name[0] == '\0') {
    mg_http_reply(c, 400, "", "%s", "name required");
    return -1;
  } else {
    struct mg_fd *fd;
    long oft = strtol(offset, NULL, 0);
    snprintf(path, sizeof(path), "%s%c%s", dir, MG_DIRSEP, name);
    remove_double_dots(path);
    LOG(LL_DEBUG, ("%d bytes @ %ld [%s]", (int) hm->body.len, oft, path));
    if (oft == 0) fs->remove(path);
    if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {
      mg_http_reply(c, 400, "", "open(%s): %d", path, errno);
      return -2;
    } else {
      int written = (int) fs->write(fd->fd, hm->body.ptr, hm->body.len);
      mg_fs_close(fd);
      mg_http_reply(c, 200, "", "%d", written);
      return (int) hm->body.len;
    }
  }
}

static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {
  if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {
    struct mg_http_message hm;
    while (c->recv.buf != NULL && c->recv.len > 0) {
      int n = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);
      bool is_chunked = n > 0 && mg_is_chunked(&hm);
      if (ev == MG_EV_CLOSE) {
        hm.message.len = c->recv.len;
        hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);
      } else if (is_chunked && n > 0) {
        walkchunks(c, &hm, (size_t) n);
      }
      // LOG(LL_INFO,
      //("---->%d %d\n%.*s", n, is_chunked, (int) c->recv.len, c->recv.buf));
      if (n < 0 && ev == MG_EV_READ) {
        mg_error(c, "HTTP parse:\n%.*s", (int) c->recv.len, c->recv.buf);
        break;
      } else if (n > 0 && (size_t) c->recv.len >= hm.message.len) {
        mg_call(c, MG_EV_HTTP_MSG, &hm);
        mg_iobuf_del(&c->recv, 0, hm.message.len);
      } else {
        if (n > 0 && !is_chunked) {
          hm.chunk =
              mg_str_n((char *) &c->recv.buf[n], c->recv.len - (size_t) n);
          mg_call(c, MG_EV_HTTP_CHUNK, &hm);
        }
        break;
      }
    }
  }
  (void) fnd;
  (void) evd;
}

struct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,
                                      mg_event_handler_t fn, void *fn_data) {
  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);
  if (c != NULL) c->pfn = http_cb;
  return c;
}

struct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,
                                     mg_event_handler_t fn, void *fn_data) {
  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);
  if (c != NULL) c->pfn = http_cb;
  return c;
}

#ifdef MG_ENABLE_LINES
#line 1 "src/iobuf.c"
#endif



#include <string.h>

// Not using memset for zeroing memory, cause it can be dropped by compiler
// See https://github.com/cesanta/mongoose/pull/1265
static void zeromem(volatile unsigned char *buf, size_t len) {
  if (buf != NULL) {
    while (len--) *buf++ = 0;
  }
}

int mg_iobuf_resize(struct mg_iobuf *io, size_t new_size) {
  int ok = 1;
  if (new_size == 0) {
    zeromem(io->buf, io->size);
    free(io->buf);
    io->buf = NULL;
    io->len = io->size = 0;
  } else if (new_size != io->size) {
    // NOTE(lsm): do not use realloc here. Use calloc/free only, to ease the
    // porting to some obscure platforms like FreeRTOS
    void *p = calloc(1, new_size);
    if (p != NULL) {
      size_t len = new_size < io->len ? new_size : io->len;
      if (len > 0) memcpy(p, io->buf, len);
      zeromem(io->buf, io->size);
      free(io->buf);
      io->buf = (unsigned char *) p;
      io->size = new_size;
    } else {
      ok = 0;
      LOG(LL_ERROR,
          ("%lu->%lu", (unsigned long) io->size, (unsigned long) new_size));
    }
  }
  return ok;
}

int mg_iobuf_init(struct mg_iobuf *io, size_t size) {
  return mg_iobuf_resize(io, size);
}

size_t mg_iobuf_add(struct mg_iobuf *io, size_t ofs, const void *buf,
                    size_t len, size_t chunk_size) {
  size_t new_size = io->len + len;
  if (new_size > io->size) {
    new_size += chunk_size;             // Make sure that io->size
    new_size -= new_size % chunk_size;  // is aligned by chunk_size boundary
    mg_iobuf_resize(io, new_size);      // Attempt to realloc
    if (new_size != io->size) len = 0;  // Realloc failure, append nothing
  }
  if (ofs < io->len) memmove(io->buf + ofs + len, io->buf + ofs, io->len - ofs);
  if (buf != NULL) memmove(io->buf + ofs, buf, len);
  if (ofs > io->len) io->len += ofs - io->len;
  io->len += len;
  return len;
}

size_t mg_iobuf_del(struct mg_iobuf *io, size_t ofs, size_t len) {
  if (ofs > io->len) ofs = io->len;
  if (ofs + len > io->len) len = io->len - ofs;
  memmove(io->buf + ofs, io->buf + ofs + len, io->len - ofs - len);
  zeromem(io->buf + io->len - len, len);
  io->len -= len;
  return len;
}

void mg_iobuf_free(struct mg_iobuf *io) {
  mg_iobuf_resize(io, 0);
}

#ifdef MG_ENABLE_LINES
#line 1 "src/log.c"
#endif



#if MG_ENABLE_LOG
static void mg_log_stdout(const void *buf, size_t len, void *userdata) {
  (void) userdata;
#if MG_ENABLE_FILE
  fwrite(buf, 1, len, stdout);
#endif
}

static const char *s_spec = "2";
static void (*s_fn)(const void *, size_t, void *) = mg_log_stdout;
static void *s_fn_param = NULL;

void mg_log_set(const char *spec) {
  LOG(LL_DEBUG, ("Setting log level to %s", spec));
  s_spec = spec;
}

bool mg_log_prefix(int level, const char *file, int line, const char *fname) {
  // static unsigned long seq;
  int max = LL_INFO;
  struct mg_str k, v, s = mg_str(s_spec);
  const char *p = strrchr(file, '/');

  if (s_fn == NULL) return false;

  if (p == NULL) p = strrchr(file, '\\');
  p = p == NULL ? file : p + 1;

  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) max = atoi(k.ptr);
    if (v.len > 0 && strncmp(p, k.ptr, k.len) == 0) max = atoi(v.ptr);
  }

  if (level <= max) {
    char timebuf[21], buf[50] = "";
    time_t t = time(NULL);
    struct tm tmp, *tm = gmtime_r(&t, &tmp);
    int n;
    (void) tmp;
    strftime(timebuf, sizeof(timebuf), "%Y-%m-%d %H:%M:%S", tm);
    n = snprintf(buf, sizeof(buf), "%s %d %s:%d:%s", timebuf, level, p, line,
                 fname);
    if (n < 0 || n > (int) sizeof(buf) - 2) n = sizeof(buf) - 2;
    while (n < (int) sizeof(buf) - 1) buf[n++] = ' ';
    s_fn(buf, sizeof(buf) - 1, s_fn_param);
    return true;
  } else {
    return false;
  }
}

void mg_log(const char *fmt, ...) {
  char mem[256], *buf = mem;
  va_list ap;
  int len = 0;
  va_start(ap, fmt);
  len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);
  va_end(ap);
  s_fn(buf, len > 0 ? (size_t) len : 0, s_fn_param);
  s_fn("\n", 1, s_fn_param);
  if (buf != mem) free(buf);
}

void mg_log_set_callback(void (*fn)(const void *, size_t, void *), void *fnd) {
  s_fn = fn;
  s_fn_param = fnd;
}
#endif

#ifdef MG_ENABLE_LINES
#line 1 "src/md5.c"
#endif
#include <string.h>


#if defined(MG_ENABLE_MD5) && MG_ENABLE_MD5
#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)
#define BYTE_ORDER __BYTE_ORDER
#ifndef LITTLE_ENDIAN
#define LITTLE_ENDIAN __LITTLE_ENDIAN
#endif /* LITTLE_ENDIAN */
#ifndef BIG_ENDIAN
#define BIG_ENDIAN __LITTLE_ENDIAN
#endif /* BIG_ENDIAN */
#endif /* BYTE_ORDER */

static void mg_byte_reverse(unsigned char *buf, unsigned longs) {
/* Forrest: MD5 expect LITTLE_ENDIAN, swap if BIG_ENDIAN */
#if BYTE_ORDER == BIG_ENDIAN
  do {
    uint32_t t = (uint32_t)((unsigned) buf[3] << 8 | buf[2]) << 16 |
                 ((unsigned) buf[1] << 8 | buf[0]);
    *(uint32_t *) buf = t;
    buf += 4;
  } while (--longs);
#else
  (void) buf;
  (void) longs;
#endif
}

#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

#define MD5STEP(f, w, x, y, z, data, s) \
  (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)

/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
void mg_md5_init(mg_md5_ctx *ctx) {
  ctx->buf[0] = 0x67452301;
  ctx->buf[1] = 0xefcdab89;
  ctx->buf[2] = 0x98badcfe;
  ctx->buf[3] = 0x10325476;

  ctx->bits[0] = 0;
  ctx->bits[1] = 0;
}

static void mg_md5_transform(uint32_t buf[4], uint32_t const in[16]) {
  uint32_t a, b, c, d;

  a = buf[0];
  b = buf[1];
  c = buf[2];
  d = buf[3];

  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}

void mg_md5_update(mg_md5_ctx *ctx, const unsigned char *buf, size_t len) {
  uint32_t t;

  t = ctx->bits[0];
  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;
  ctx->bits[1] += (uint32_t) len >> 29;

  t = (t >> 3) & 0x3f;

  if (t) {
    unsigned char *p = (unsigned char *) ctx->in + t;

    t = 64 - t;
    if (len < t) {
      memcpy(p, buf, len);
      return;
    }
    memcpy(p, buf, t);
    mg_byte_reverse(ctx->in, 16);
    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);
    buf += t;
    len -= t;
  }

  while (len >= 64) {
    memcpy(ctx->in, buf, 64);
    mg_byte_reverse(ctx->in, 16);
    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);
    buf += 64;
    len -= 64;
  }

  memcpy(ctx->in, buf, len);
}

void mg_md5_final(mg_md5_ctx *ctx, unsigned char digest[16]) {
  unsigned count;
  unsigned char *p;
  uint32_t *a;

  count = (ctx->bits[0] >> 3) & 0x3F;

  p = ctx->in + count;
  *p++ = 0x80;
  count = 64 - 1 - count;
  if (count < 8) {
    memset(p, 0, count);
    mg_byte_reverse(ctx->in, 16);
    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);
    memset(ctx->in, 0, 56);
  } else {
    memset(p, 0, count - 8);
  }
  mg_byte_reverse(ctx->in, 14);

  a = (uint32_t *) ctx->in;
  a[14] = ctx->bits[0];
  a[15] = ctx->bits[1];

  mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);
  mg_byte_reverse((unsigned char *) ctx->buf, 4);
  memcpy(digest, ctx->buf, 16);
  memset((char *) ctx, 0, sizeof(*ctx));
}
#endif

#ifdef MG_ENABLE_LINES
#line 1 "src/mqtt.c"
#endif








#define MQTT_CLEAN_SESSION 0x02
#define MQTT_HAS_WILL 0x04
#define MQTT_WILL_RETAIN 0x20
#define MQTT_HAS_PASSWORD 0x40
#define MQTT_HAS_USER_NAME 0x80

enum { MQTT_OK, MQTT_INCOMPLETE, MQTT_MALFORMED };

void mg_mqtt_send_header(struct mg_connection *c, uint8_t cmd, uint8_t flags,
                         uint32_t len) {
  uint8_t buf[1 + sizeof(len)], *vlen = &buf[1];
  buf[0] = (uint8_t) ((cmd << 4) | flags);
  do {
    *vlen = len % 0x80;
    len /= 0x80;
    if (len > 0) *vlen |= 0x80;
    vlen++;
  } while (len > 0 && vlen < &buf[sizeof(buf)]);
  mg_send(c, buf, (size_t) (vlen - buf));
}

static void mg_send_u16(struct mg_connection *c, uint16_t value) {
  mg_send(c, &value, sizeof(value));
}

void mg_mqtt_login(struct mg_connection *c, struct mg_mqtt_opts *opts) {
  char rnd[9], client_id[16];
  struct mg_str cid = opts->client_id;
  uint32_t total_len = 7 + 1 + 2 + 2;
  uint8_t connflag = (uint8_t) ((opts->will_qos & 3) << 3);

  if (cid.len == 0) {
    mg_random(rnd, sizeof(rnd));
    mg_base64_encode((unsigned char *) rnd, sizeof(rnd), client_id);
    client_id[sizeof(client_id) - 1] = '\0';
    cid = mg_str(client_id);
  }

  if (opts->user.len > 0) {
    total_len += 2 + (uint32_t) opts->user.len;
    connflag |= MQTT_HAS_USER_NAME;
  }
  if (opts->pass.len > 0) {
    total_len += 2 + (uint32_t) opts->pass.len;
    connflag |= MQTT_HAS_PASSWORD;
  }
  if (opts->will_topic.len > 0 && opts->will_message.len > 0) {
    total_len +=
        4 + (uint32_t) opts->will_topic.len + (uint32_t) opts->will_message.len;
    connflag |= MQTT_HAS_WILL;
  }
  if (opts->clean || cid.len == 0) connflag |= MQTT_CLEAN_SESSION;
  if (opts->will_retain) connflag |= MQTT_WILL_RETAIN;
  total_len += (uint32_t) cid.len;

  mg_mqtt_send_header(c, MQTT_CMD_CONNECT, 0, total_len);
  mg_send(c, "\00\04MQTT\04", 7);
  mg_send(c, &connflag, sizeof(connflag));
  // keepalive == 0 means "do not disconnect us!"
  mg_send_u16(c, mg_htons((uint16_t) opts->keepalive));
  mg_send_u16(c, mg_htons((uint16_t) cid.len));
  mg_send(c, cid.ptr, cid.len);
  if (connflag & MQTT_HAS_WILL) {
    mg_send_u16(c, mg_htons((uint16_t) opts->will_topic.len));
    mg_send(c, opts->will_topic.ptr, opts->will_topic.len);
    mg_send_u16(c, mg_htons((uint16_t) opts->will_message.len));
    mg_send(c, opts->will_message.ptr, opts->will_message.len);
  }
  if (opts->user.len > 0) {
    mg_send_u16(c, mg_htons((uint16_t) opts->user.len));
    mg_send(c, opts->user.ptr, opts->user.len);
  }
  if (opts->pass.len > 0) {
    mg_send_u16(c, mg_htons((uint16_t) opts->pass.len));
    mg_send(c, opts->pass.ptr, opts->pass.len);
  }
}

void mg_mqtt_pub(struct mg_connection *c, struct mg_str topic,
                 struct mg_str data, int qos, bool retain) {
  uint8_t flags = (uint8_t) (((qos & 3) << 1) | (retain ? 1 : 0));
  uint32_t total_len = 2 + (uint32_t) topic.len + (uint32_t) data.len;
  LOG(LL_DEBUG, ("%lu [%.*s] -> [%.*s]", c->id, (int) topic.len,
                 (char *) topic.ptr, (int) data.len, (char *) data.ptr));
  if (qos > 0) total_len += 2;
  mg_mqtt_send_header(c, MQTT_CMD_PUBLISH, flags, total_len);
  mg_send_u16(c, mg_htons((uint16_t) topic.len));
  mg_send(c, topic.ptr, topic.len);
  if (qos > 0) {
    static uint16_t s_id;
    if (++s_id == 0) s_id++;
    mg_send_u16(c, mg_htons(s_id));
  }
  mg_send(c, data.ptr, data.len);
}

void mg_mqtt_sub(struct mg_connection *c, struct mg_str topic, int qos) {
  static uint16_t s_id;
  uint8_t qos_ = qos & 3;
  uint32_t total_len = 2 + (uint32_t) topic.len + 2 + 1;
  mg_mqtt_send_header(c, MQTT_CMD_SUBSCRIBE, 2, total_len);
  if (++s_id == 0) ++s_id;
  mg_send_u16(c, mg_htons(s_id));
  mg_send_u16(c, mg_htons((uint16_t) topic.len));
  mg_send(c, topic.ptr, topic.len);
  mg_send(c, &qos_, sizeof(qos_));
}

int mg_mqtt_parse(const uint8_t *buf, size_t len, struct mg_mqtt_message *m) {
  uint8_t lc = 0, *p, *end;
  uint32_t n = 0, len_len = 0;

  memset(m, 0, sizeof(*m));
  m->dgram.ptr = (char *) buf;
  if (len < 2) return MQTT_INCOMPLETE;
  m->cmd = (uint8_t) (buf[0] >> 4);
  m->qos = (buf[0] >> 1) & 3;

  n = len_len = 0;
  p = (uint8_t *) buf + 1;
  while ((size_t) (p - buf) < len) {
    lc = *((uint8_t *) p++);
    n += (uint32_t) ((lc & 0x7f) << 7 * len_len);
    len_len++;
    if (!(lc & 0x80)) break;
    if (len_len >= 4) return MQTT_MALFORMED;
  }
  end = p + n;
  if (lc & 0x80 || end > buf + len) return MQTT_INCOMPLETE;
  m->dgram.len = (size_t) (end - buf);

  switch (m->cmd) {
    case MQTT_CMD_CONNACK:
      if (end - p < 2) return MQTT_MALFORMED;
      m->ack = p[1];
      break;
    case MQTT_CMD_PUBACK:
    case MQTT_CMD_PUBREC:
    case MQTT_CMD_PUBREL:
    case MQTT_CMD_PUBCOMP:
    case MQTT_CMD_SUBACK:
      if (p + 2 > end) return MQTT_MALFORMED;
      m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);
      break;
    case MQTT_CMD_SUBSCRIBE: {
      if (p + 2 > end) return MQTT_MALFORMED;
      m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);
      p += 2;
      break;
    }
    case MQTT_CMD_PUBLISH: {
      if (p + 2 > end) return MQTT_MALFORMED;
      m->topic.len = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);
      m->topic.ptr = (char *) p + 2;
      p += 2 + m->topic.len;
      if (p > end) return MQTT_MALFORMED;
      if (m->qos > 0) {
        if (p + 2 > end) return MQTT_MALFORMED;
        m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);
        p += 2;
      }
      if (p > end) return MQTT_MALFORMED;
      m->data.ptr = (char *) p;
      m->data.len = (size_t) (end - p);
      break;
    }
    default:
      break;
  }
  return MQTT_OK;
}

static size_t mg_mqtt_next_topic(struct mg_mqtt_message *msg,
                                 struct mg_str *topic, uint8_t *qos,
                                 size_t pos) {
  unsigned char *buf = (unsigned char *) msg->dgram.ptr + pos;
  size_t new_pos;
  if (pos >= msg->dgram.len) return 0;

  topic->len = (size_t) (((unsigned) buf[0]) << 8 | buf[1]);
  topic->ptr = (char *) buf + 2;
  new_pos = pos + 2 + topic->len + (qos == NULL ? 0 : 1);
  if ((size_t) new_pos > msg->dgram.len) return 0;
  if (qos != NULL) *qos = buf[2 + topic->len];
  return new_pos;
}

size_t mg_mqtt_next_sub(struct mg_mqtt_message *msg, struct mg_str *topic,
                        uint8_t *qos, size_t pos) {
  uint8_t tmp;
  return mg_mqtt_next_topic(msg, topic, qos == NULL ? &tmp : qos, pos);
}

size_t mg_mqtt_next_unsub(struct mg_mqtt_message *msg, struct mg_str *topic,
                          size_t pos) {
  return mg_mqtt_next_topic(msg, topic, NULL, pos);
}

static void mqtt_cb(struct mg_connection *c, int ev, void *ev_data,
                    void *fn_data) {
  if (ev == MG_EV_READ) {
    for (;;) {
      struct mg_mqtt_message mm;
      int rc = mg_mqtt_parse(c->recv.buf, c->recv.len, &mm);
      if (rc == MQTT_MALFORMED) {
        LOG(LL_ERROR, ("%lu MQTT malformed message", c->id));
        c->is_closing = 1;
        break;
      } else if (rc == MQTT_OK) {
        LOG(LL_VERBOSE_DEBUG,
            ("%p MQTT CMD %d len %d [%.*s]", c->fd, mm.cmd, (int) mm.dgram.len,
             (int) mm.data.len, mm.data.ptr));
        switch (mm.cmd) {
          case MQTT_CMD_CONNACK:
            mg_call(c, MG_EV_MQTT_OPEN, &mm.ack);
            if (mm.ack == 0) {
              LOG(LL_DEBUG, ("%lu Connected", c->id));
            } else {
              LOG(LL_ERROR, ("%lu MQTT auth failed, code %d", c->id, mm.ack));
              c->is_closing = 1;
            }
            break;
          case MQTT_CMD_PUBLISH: {
            LOG(LL_DEBUG, ("%lu [%.*s] -> [%.*s]", c->id, (int) mm.topic.len,
                           mm.topic.ptr, (int) mm.data.len, mm.data.ptr));
            mg_call(c, MG_EV_MQTT_MSG, &mm);
            break;
          }
        }
        mg_call(c, MG_EV_MQTT_CMD, &mm);
        mg_iobuf_del(&c->recv, 0, mm.dgram.len);
      } else {
        break;
      }
    }
  }
  (void) ev_data;
  (void) fn_data;
}

void mg_mqtt_ping(struct mg_connection *nc) {
  mg_mqtt_send_header(nc, MQTT_CMD_PINGREQ, 0, 0);
}

void mg_mqtt_pong(struct mg_connection *nc) {
  mg_mqtt_send_header(nc, MQTT_CMD_PINGRESP, 0, 0);
}

void mg_mqtt_disconnect(struct mg_connection *nc) {
  mg_mqtt_send_header(nc, MQTT_CMD_DISCONNECT, 0, 0);
}

struct mg_connection *mg_mqtt_connect(struct mg_mgr *mgr, const char *url,
                                      struct mg_mqtt_opts *opts,
                                      mg_event_handler_t fn, void *fn_data) {
  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);
  if (c != NULL) {
    struct mg_mqtt_opts empty;
    memset(&empty, 0, sizeof(empty));
    mg_mqtt_login(c, opts == NULL ? &empty : opts);
    c->pfn = mqtt_cb;
  }
  return c;
}

struct mg_connection *mg_mqtt_listen(struct mg_mgr *mgr, const char *url,
                                     mg_event_handler_t fn, void *fn_data) {
  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);
  if (c != NULL) c->pfn = mqtt_cb, c->pfn_data = mgr;
  return c;
}

#ifdef MG_ENABLE_LINES
#line 1 "src/net.c"
#endif




int mg_vprintf(struct mg_connection *c, const char *fmt, va_list ap) {
  char mem[256], *buf = mem;
  int len = mg_vasprintf(&buf, sizeof(mem), fmt, ap);
  len = mg_send(c, buf, len > 0 ? (size_t) len : 0);
  if (buf != mem) free(buf);
  return len;
}

int mg_printf(struct mg_connection *c, const char *fmt, ...) {
  int len = 0;
  va_list ap;
  va_start(ap, fmt);
  len = mg_vprintf(c, fmt, ap);
  va_end(ap);
  return len;
}

char *mg_straddr(struct mg_addr *a, char *buf, size_t len) {
  char tmp[30];
  const char *fmt = a->is_ip6 ? "[%s]:%d" : "%s:%d";
  mg_ntoa(a, tmp, sizeof(tmp));
  snprintf(buf, len, fmt, tmp, (int) mg_ntohs(a->port));
  return buf;
}

char *mg_ntoa(const struct mg_addr *addr, char *buf, size_t len) {
  if (addr->is_ip6) {
    uint16_t *p = (uint16_t *) addr->ip6;
    snprintf(buf, len, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx", mg_htons(p[0]),
             mg_htons(p[1]), mg_htons(p[2]), mg_htons(p[3]), mg_htons(p[4]),
             mg_htons(p[5]), mg_htons(p[6]), mg_htons(p[7]));
  } else {
    uint8_t p[4];
    memcpy(p, &addr->ip, sizeof(p));
    snprintf(buf, len, "%d.%d.%d.%d", (int) p[0], (int) p[1], (int) p[2],
             (int) p[3]);
  }
  return buf;
}

static bool mg_atonl(struct mg_str str, struct mg_addr *addr) {
  if (mg_vcasecmp(&str, "localhost") != 0) return false;
  addr->ip = mg_htonl(0x7f000001);
  addr->is_ip6 = false;
  return true;
}

static bool mg_atone(struct mg_str str, struct mg_addr *addr) {
  if (str.len > 0) return false;
  addr->ip = 0;
  addr->is_ip6 = false;
  return true;
}

static bool mg_aton4(struct mg_str str, struct mg_addr *addr) {
  uint8_t data[4] = {0, 0, 0, 0};
  size_t i, num_dots = 0;
  for (i = 0; i < str.len; i++) {
    if (str.ptr[i] >= '0' && str.ptr[i] <= '9') {
      int octet = data[num_dots] * 10 + (str.ptr[i] - '0');
      if (octet > 255) return false;
      data[num_dots] = (uint8_t) octet;
    } else if (str.ptr[i] == '.') {
      if (num_dots >= 3 || i == 0 || str.ptr[i - 1] == '.') return false;
      num_dots++;
    } else {
      return false;
    }
  }
  if (num_dots != 3 || str.ptr[i - 1] == '.') return false;
  memcpy(&addr->ip, data, sizeof(data));
  addr->is_ip6 = false;
  return true;
}

static bool mg_v4mapped(struct mg_str str, struct mg_addr *addr) {
  int i;
  if (str.len < 14) return false;
  if (str.ptr[0] != ':' || str.ptr[1] != ':' || str.ptr[6] != ':') return false;
  for (i = 2; i < 6; i++) {
    if (str.ptr[i] != 'f' && str.ptr[i] != 'F') return false;
  }
  if (!mg_aton4(mg_str_n(&str.ptr[7], str.len - 7), addr)) return false;
  memset(addr->ip6, 0, sizeof(addr->ip6));
  addr->ip6[10] = addr->ip6[11] = 255;
  memcpy(&addr->ip6[12], &addr->ip, 4);
  addr->is_ip6 = true;
  return true;
}

static bool mg_aton6(struct mg_str str, struct mg_addr *addr) {
  size_t i, j = 0, n = 0, dc = 42;
  if (str.len > 2 && str.ptr[0] == '[') str.ptr++, str.len -= 2;
  if (mg_v4mapped(str, addr)) return true;
  for (i = 0; i < str.len; i++) {
    if ((str.ptr[i] >= '0' && str.ptr[i] <= '9') ||
        (str.ptr[i] >= 'a' && str.ptr[i] <= 'f') ||
        (str.ptr[i] >= 'A' && str.ptr[i] <= 'F')) {
      unsigned long val;
      if (i > j + 3) return false;
      // LOG(LL_DEBUG, ("%zu %zu [%.*s]", i, j, (int) (i - j + 1),
      // &str.ptr[j]));
      val = mg_unhexn(&str.ptr[j], i - j + 1);
      addr->ip6[n] = (uint8_t) ((val >> 8) & 255);
      addr->ip6[n + 1] = (uint8_t) (val & 255);
    } else if (str.ptr[i] == ':') {
      j = i + 1;
      if (i > 0 && str.ptr[i - 1] == ':') {
        dc = n;  // Double colon
        if (i > 1 && str.ptr[i - 2] == ':') return false;
      } else if (i > 0) {
        n += 2;
      }
      if (n > 14) return false;
      addr->ip6[n] = addr->ip6[n + 1] = 0;  // For trailing ::
    } else {
      return false;
    }
  }
  if (n < 14 && dc == 42) return false;
  if (n < 14) {
    memmove(&addr->ip6[dc + (14 - n)], &addr->ip6[dc], n - dc + 2);
    memset(&addr->ip6[dc], 0, 14 - n);
  }
  addr->is_ip6 = true;
  return true;
}

bool mg_aton(struct mg_str str, struct mg_addr *addr) {
  // LOG(LL_INFO, ("[%.*s]", (int) str.len, str.ptr));
  return mg_atone(str, addr) || mg_atonl(str, addr) || mg_aton4(str, addr) ||
         mg_aton6(str, addr);
}

void mg_mgr_free(struct mg_mgr *mgr) {
  struct mg_connection *c;
  for (c = mgr->conns; c != NULL; c = c->next) c->is_closing = 1;
  mg_mgr_poll(mgr, 0);
#if MG_ARCH == MG_ARCH_FREERTOS_TCP
  FreeRTOS_DeleteSocketSet(mgr->ss);
#endif
  LOG(LL_INFO, ("All connections closed"));
}

void mg_mgr_init(struct mg_mgr *mgr) {
  memset(mgr, 0, sizeof(*mgr));
#if defined(_WIN32) && MG_ENABLE_WINSOCK
  // clang-format off
  { WSADATA data; WSAStartup(MAKEWORD(2, 2), &data); }
  // clang-format on
#elif MG_ARCH == MG_ARCH_FREERTOS_TCP
  mgr->ss = FreeRTOS_CreateSocketSet();
#elif defined(__unix) || defined(__unix__) || defined(__APPLE__)
  // Ignore SIGPIPE signal, so if client cancels the request, it
  // won't kill the whole process.
  signal(SIGPIPE, SIG_IGN);
#endif
  mgr->dnstimeout = 3000;
  mgr->dns4.url = "udp://8.8.8.8:53";
  mgr->dns6.url = "udp://[2001:4860:4860::8888]:53";
}

#ifdef MG_ENABLE_LINES
#line 1 "src/sha1.c"
#endif
/* Copyright(c) By Steve Reid <steve@edmweb.com> */
/* 100% Public Domain */

#include <string.h>

/*
 * clang with std=-c99 uses __LITTLE_ENDIAN, by default
 * while for ex, RTOS gcc - LITTLE_ENDIAN, by default
 * it depends on __USE_BSD, but let's have everything
 */
#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)
#define BYTE_ORDER __BYTE_ORDER
#ifndef LITTLE_ENDIAN
#define LITTLE_ENDIAN __LITTLE_ENDIAN
#endif /* LITTLE_ENDIAN */
#ifndef BIG_ENDIAN
#define BIG_ENDIAN __LITTLE_ENDIAN
#endif /* BIG_ENDIAN */
#endif /* BYTE_ORDER */

union char64long16 {
  unsigned char c[64];
  uint32_t l[16];
};

#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))

static uint32_t blk0(union char64long16 *block, int i) {
/* Forrest: SHA expect BIG_ENDIAN, swap if LITTLE_ENDIAN */
#if BYTE_ORDER == LITTLE_ENDIAN
  block->l[i] =
      (rol(block->l[i], 24) & 0xFF00FF00) | (rol(block->l[i], 8) & 0x00FF00FF);
#endif
  return block->l[i];
}

/* Avoid redefine warning (ARM /usr/include/sys/ucontext.h define R0~R4) */
#undef blk
#undef R0
#undef R1
#undef R2
#undef R3
#undef R4

#define blk(i)                                                               \
  (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \
                              block->l[(i + 2) & 15] ^ block->l[i & 15],     \
                          1))
#define R0(v, w, x, y, z, i)                                          \
  z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \
  w = rol(w, 30);
#define R1(v, w, x, y, z, i)                                  \
  z += ((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5); \
  w = rol(w, 30);
#define R2(v, w, x, y, z, i)                          \
  z += (w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5); \
  w = rol(w, 30);
#define R3(v, w, x, y, z, i)                                        \
  z += (((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5); \
  w = rol(w, 30);
#define R4(v, w, x, y, z, i)                          \
  z += (w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5); \
  w = rol(w, 30);

static void mg_sha1_transform(uint32_t state[5], const unsigned char buffer[64]) {
  uint32_t a, b, c, d, e;
  union char64long16 block[1];

  memcpy(block, buffer, 64);
  a = state[0];
  b = state[1];
  c = state[2];
  d = state[3];
  e = state[4];
  R0(a, b, c, d, e, 0);
  R0(e, a, b, c, d, 1);
  R0(d, e, a, b, c, 2);
  R0(c, d, e, a, b, 3);
  R0(b, c, d, e, a, 4);
  R0(a, b, c, d, e, 5);
  R0(e, a, b, c, d, 6);
  R0(d, e, a, b, c, 7);
  R0(c, d, e, a, b, 8);
  R0(b, c, d, e, a, 9);
  R0(a, b, c, d, e, 10);
  R0(e, a, b, c, d, 11);
  R0(d, e, a, b, c, 12);
  R0(c, d, e, a, b, 13);
  R0(b, c, d, e, a, 14);
  R0(a, b, c, d, e, 15);
  R1(e, a, b, c, d, 16);
  R1(d, e, a, b, c, 17);
  R1(c, d, e, a, b, 18);
  R1(b, c, d, e, a, 19);
  R2(a, b, c, d, e, 20);
  R2(e, a, b, c, d, 21);
  R2(d, e, a, b, c, 22);
  R2(c, d, e, a, b, 23);
  R2(b, c, d, e, a, 24);
  R2(a, b, c, d, e, 25);
  R2(e, a, b, c, d, 26);
  R2(d, e, a, b, c, 27);
  R2(c, d, e, a, b, 28);
  R2(b, c, d, e, a, 29);
  R2(a, b, c, d, e, 30);
  R2(e, a, b, c, d, 31);
  R2(d, e, a, b, c, 32);
  R2(c, d, e, a, b, 33);
  R2(b, c, d, e, a, 34);
  R2(a, b, c, d, e, 35);
  R2(e, a, b, c, d, 36);
  R2(d, e, a, b, c, 37);
  R2(c, d, e, a, b, 38);
  R2(b, c, d, e, a, 39);
  R3(a, b, c, d, e, 40);
  R3(e, a, b, c, d, 41);
  R3(d, e, a, b, c, 42);
  R3(c, d, e, a, b, 43);
  R3(b, c, d, e, a, 44);
  R3(a, b, c, d, e, 45);
  R3(e, a, b, c, d, 46);
  R3(d, e, a, b, c, 47);
  R3(c, d, e, a, b, 48);
  R3(b, c, d, e, a, 49);
  R3(a, b, c, d, e, 50);
  R3(e, a, b, c, d, 51);
  R3(d, e, a, b, c, 52);
  R3(c, d, e, a, b, 53);
  R3(b, c, d, e, a, 54);
  R3(a, b, c, d, e, 55);
  R3(e, a, b, c, d, 56);
  R3(d, e, a, b, c, 57);
  R3(c, d, e, a, b, 58);
  R3(b, c, d, e, a, 59);
  R4(a, b, c, d, e, 60);
  R4(e, a, b, c, d, 61);
  R4(d, e, a, b, c, 62);
  R4(c, d, e, a, b, 63);
  R4(b, c, d, e, a, 64);
  R4(a, b, c, d, e, 65);
  R4(e, a, b, c, d, 66);
  R4(d, e, a, b, c, 67);
  R4(c, d, e, a, b, 68);
  R4(b, c, d, e, a, 69);
  R4(a, b, c, d, e, 70);
  R4(e, a, b, c, d, 71);
  R4(d, e, a, b, c, 72);
  R4(c, d, e, a, b, 73);
  R4(b, c, d, e, a, 74);
  R4(a, b, c, d, e, 75);
  R4(e, a, b, c, d, 76);
  R4(d, e, a, b, c, 77);
  R4(c, d, e, a, b, 78);
  R4(b, c, d, e, a, 79);
  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
  state[4] += e;
  /* Erase working structures. The order of operations is important,
   * used to ensure that compiler doesn't optimize those out. */
  memset(block, 0, sizeof(block));
  a = b = c = d = e = 0;
  (void) a;
  (void) b;
  (void) c;
  (void) d;
  (void) e;
}

void mg_sha1_init(mg_sha1_ctx *context) {
  context->state[0] = 0x67452301;
  context->state[1] = 0xEFCDAB89;
  context->state[2] = 0x98BADCFE;
  context->state[3] = 0x10325476;
  context->state[4] = 0xC3D2E1F0;
  context->count[0] = context->count[1] = 0;
}

void mg_sha1_update(mg_sha1_ctx *context, const unsigned char *data,
                    size_t len) {
  size_t i, j;

  j = context->count[0];
  if ((context->count[0] += (uint32_t) len << 3) < j) context->count[1]++;
  context->count[1] += (uint32_t)(len >> 29);
  j = (j >> 3) & 63;
  if ((j + len) > 63) {
    memcpy(&context->buffer[j], data, (i = 64 - j));
    mg_sha1_transform(context->state, context->buffer);
    for (; i + 63 < len; i += 64) {
      mg_sha1_transform(context->state, &data[i]);
    }
    j = 0;
  } else
    i = 0;
  memcpy(&context->buffer[j], &data[i], len - i);
}

void mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *context) {
  unsigned i;
  unsigned char finalcount[8], c;

  for (i = 0; i < 8; i++) {
    finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>
                                      ((3 - (i & 3)) * 8)) &
                                     255);
  }
  c = 0200;
  mg_sha1_update(context, &c, 1);
  while ((context->count[0] & 504) != 448) {
    c = 0000;
    mg_sha1_update(context, &c, 1);
  }
  mg_sha1_update(context, finalcount, 8);
  for (i = 0; i < 20; i++) {
    digest[i] =
        (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
  }
  memset(context, '\0', sizeof(*context));
  memset(&finalcount, '\0', sizeof(finalcount));
}

void mg_hmac_sha1(const unsigned char *key, size_t keylen,
                  const unsigned char *data, size_t datalen,
                  unsigned char out[20]) {
  mg_sha1_ctx ctx;
  unsigned char buf1[64], buf2[64], tmp_key[20], i;

  if (keylen > sizeof(buf1)) {
    mg_sha1_init(&ctx);
    mg_sha1_update(&ctx, key, keylen);
    mg_sha1_final(tmp_key, &ctx);
    key = tmp_key;
    keylen = sizeof(tmp_key);
  }

  memset(buf1, 0, sizeof(buf1));
  memset(buf2, 0, sizeof(buf2));
  memcpy(buf1, key, keylen);
  memcpy(buf2, key, keylen);

  for (i = 0; i < sizeof(buf1); i++) {
    buf1[i] ^= 0x36;
    buf2[i] ^= 0x5c;
  }

  mg_sha1_init(&ctx);
  mg_sha1_update(&ctx, buf1, sizeof(buf1));
  mg_sha1_update(&ctx, data, datalen);
  mg_sha1_final(out, &ctx);

  mg_sha1_init(&ctx);
  mg_sha1_update(&ctx, buf2, sizeof(buf2));
  mg_sha1_update(&ctx, out, 20);
  mg_sha1_final(out, &ctx);
}

#ifdef MG_ENABLE_LINES
#line 1 "src/sntp.c"
#endif






#define SNTP_INTERVAL_SEC 3600
#define SNTP_TIME_OFFSET 2208988800UL

static unsigned long s_sntmp_next;

int64_t mg_sntp_parse(const unsigned char *buf, size_t len) {
  int64_t res = -1;
  int mode = len > 0 ? buf[0] & 7 : 0;
  if (len < 48) {
    LOG(LL_ERROR, ("%s", "corrupt packet"));
  } else if ((buf[0] & 0x38) >> 3 != 4) {
    LOG(LL_ERROR, ("%s", "wrong version"));
  } else if (mode != 4 && mode != 5) {
    LOG(LL_ERROR, ("%s", "not a server reply"));
  } else if (buf[1] == 0) {
    LOG(LL_ERROR, ("%s", "server sent a kiss of death"));
  } else {
    uint32_t *data = (uint32_t *) &buf[40];
    unsigned long seconds = mg_ntohl(data[0]) - SNTP_TIME_OFFSET;
    unsigned long useconds = mg_ntohl(data[1]);
    // LOG(LL_DEBUG, ("%lu %lu %lu", time(0), seconds, useconds));
    res = ((int64_t) seconds) * 1000 + (int64_t) ((useconds / 1000) % 1000);
    s_sntmp_next = seconds + SNTP_INTERVAL_SEC;
  }
  return res;
}

static void sntp_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {
  if (ev == MG_EV_READ) {
    int64_t milliseconds = mg_sntp_parse(c->recv.buf, c->recv.len);
    if (milliseconds > 0) {
      mg_call(c, MG_EV_SNTP_TIME, &milliseconds);
      LOG(LL_DEBUG, ("%u.%u, next at %lu", (unsigned) (milliseconds / 1000),
                     (unsigned) (milliseconds % 1000), s_sntmp_next));
    }
    c->recv.len = 0;  // Clear receive buffer
  } else if (ev == MG_EV_CONNECT) {
    mg_sntp_send(c, (unsigned long) time(NULL));
  } else if (ev == MG_EV_CLOSE) {
  }
  (void) fnd;
  (void) evd;
}

void mg_sntp_send(struct mg_connection *c, unsigned long utc) {
  if (c->is_resolving) {
    LOG(LL_ERROR, ("%lu wait until resolved", c->id));
  } else if (utc > s_sntmp_next) {
    uint8_t buf[48] = {0};
    s_sntmp_next = utc + SNTP_INTERVAL_SEC;
    buf[0] = (0 << 6) | (4 << 3) | 3;
    mg_send(c, buf, sizeof(buf));
    LOG(LL_DEBUG, ("%lu ct %lu, next at %lu", c->id, utc, s_sntmp_next));
  }
}

struct mg_connection *mg_sntp_connect(struct mg_mgr *mgr, const char *url,
                                      mg_event_handler_t fn, void *fnd) {
  struct mg_connection *c = NULL;
  if (url == NULL) url = "udp://time.google.com:123";
  if ((c = mg_connect(mgr, url, fn, fnd)) != NULL) c->pfn = sntp_cb;
  return c;
}

#ifdef MG_ENABLE_LINES
#line 1 "src/sock.c"
#endif










#if MG_ENABLE_SOCKET
#if defined(_WIN32) && MG_ENABLE_WINSOCK
#define MG_SOCK_ERRNO WSAGetLastError()
#ifndef SO_EXCLUSIVEADDRUSE
#define SO_EXCLUSIVEADDRUSE ((int) (~SO_REUSEADDR))
#endif
#elif MG_ARCH == MG_ARCH_FREERTOS_TCP
#define MG_SOCK_ERRNO errno
typedef Socket_t SOCKET;
#define INVALID_SOCKET FREERTOS_INVALID_SOCKET
#else
#define MG_SOCK_ERRNO errno
#ifndef closesocket
#define closesocket(x) close(x)
#endif
#define INVALID_SOCKET (-1)
typedef int SOCKET;
#endif

#define FD(c_) ((SOCKET) (size_t) (c_)->fd)
#define S2PTR(s_) ((void *) (size_t) (s_))

#ifndef MSG_NONBLOCKING
#define MSG_NONBLOCKING 0
#endif

#ifndef AF_INET6
#define AF_INET6 10
#endif

union usa {
  struct sockaddr sa;
  struct sockaddr_in sin;
#if MG_ENABLE_IPV6
  struct sockaddr_in6 sin6;
#endif
};

static socklen_t tousa(struct mg_addr *a, union usa *usa) {
  socklen_t len = sizeof(usa->sin);
  memset(usa, 0, sizeof(*usa));
  usa->sin.sin_family = AF_INET;
  usa->sin.sin_port = a->port;
  *(uint32_t *) &usa->sin.sin_addr = a->ip;
#if MG_ENABLE_IPV6
  if (a->is_ip6) {
    usa->sin.sin_family = AF_INET6;
    usa->sin6.sin6_port = a->port;
    memcpy(&usa->sin6.sin6_addr, a->ip6, sizeof(a->ip6));
    len = sizeof(usa->sin6);
  }
#endif
  return len;
}

static void tomgaddr(union usa *usa, struct mg_addr *a, bool is_ip6) {
  a->is_ip6 = is_ip6;
  a->port = usa->sin.sin_port;
  memcpy(&a->ip, &usa->sin.sin_addr, sizeof(a->ip));
#if MG_ENABLE_IPV6
  if (is_ip6) {
    memcpy(a->ip6, &usa->sin6.sin6_addr, sizeof(a->ip6));
    a->port = usa->sin6.sin6_port;
  }
#endif
}

static bool mg_sock_would_block(void) {
  int err = MG_SOCK_ERRNO;
  return err == EINPROGRESS || err == EWOULDBLOCK
#ifndef WINCE
         || err == EAGAIN || err == EINTR
#endif
#if defined(_WIN32) && MG_ENABLE_WINSOCK
         || err == WSAEINTR || err == WSAEWOULDBLOCK
#endif
      ;
}

static struct mg_connection *alloc_conn(struct mg_mgr *mgr, bool is_client,
                                        SOCKET fd) {
  struct mg_connection *c = (struct mg_connection *) calloc(1, sizeof(*c));
  if (c != NULL) {
    c->is_client = is_client;
    c->fd = S2PTR(fd);
    c->mgr = mgr;
    c->id = ++mgr->nextid;
  }
  return c;
}

static void iolog(struct mg_connection *c, char *buf, long n, bool r) {
  LOG(n > 0 ? LL_VERBOSE_DEBUG : LL_DEBUG,
      ("%-3lu %d%d%d%d%d%d%d%d%d%d%d%d%d%d %d:%d %ld err %d", c->id,
       c->is_listening, c->is_client, c->is_accepted, c->is_resolving,
       c->is_connecting, c->is_tls, c->is_tls_hs, c->is_udp, c->is_websocket,
       c->is_hexdumping, c->is_draining, c->is_closing, c->is_readable,
       c->is_writable, (int) c->send.len, (int) c->recv.len, n, MG_SOCK_ERRNO));
  if (n == 0) {
    // Do nothing
  } else if (n < 0) {
    c->is_closing = 1;  // Error, or normal termination
  } else if (n > 0) {
    if (c->is_hexdumping) {
      union usa usa;
      char t1[50] = "", t2[50] = "";
      socklen_t slen = sizeof(usa.sin);
      char *s = mg_hexdump(buf, (size_t) n);
      struct mg_addr a;
      memset(&usa, 0, sizeof(usa));
      memset(&a, 0, sizeof(a));
      getsockname(FD(c), &usa.sa, &slen);
      tomgaddr(&usa, &a, c->peer.is_ip6);
      LOG(LL_INFO, ("\n-- %lu %s %s %s %s %ld\n%s", c->id,
                    mg_straddr(&a, t1, sizeof(t1)), r ? "<-" : "->",
                    mg_straddr(&c->peer, t2, sizeof(t2)), c->label, n, s));
      free(s);
      (void) t1, (void) t2;  // Silence warnings for MG_ENABLE_LOG=0
    }
    if (r) {
      struct mg_str evd = mg_str_n(buf, (size_t) n);
      c->recv.len += (size_t) n;
      mg_call(c, MG_EV_READ, &evd);
    } else {
      mg_iobuf_del(&c->send, 0, (size_t) n);
      if (c->send.len == 0) mg_iobuf_resize(&c->send, 0);
      mg_call(c, MG_EV_WRITE, &n);
    }
  }
}

static long mg_sock_send(struct mg_connection *c, const void *buf, size_t len) {
  long n;
  if (c->is_udp) {
    union usa usa;
    socklen_t slen = tousa(&c->peer, &usa);
    n = sendto(FD(c), (char *) buf, len, 0, &usa.sa, slen);
  } else {
    n = send(FD(c), (char *) buf, len, MSG_NONBLOCKING);
  }
  return n == 0 ? -1 : n < 0 && mg_sock_would_block() ? 0 : n;
}

bool mg_send(struct mg_connection *c, const void *buf, size_t len) {
  if (c->is_udp) {
    long n = mg_sock_send(c, buf, len);
    iolog(c, (char *) buf, n, false);
    return n > 0;
  } else {
    return mg_iobuf_add(&c->send, c->send.len, buf, len, MG_IO_SIZE);
  }
}

static void mg_set_non_blocking_mode(SOCKET fd) {
#if defined(_WIN32) && MG_ENABLE_WINSOCK
  unsigned long on = 1;
  ioctlsocket(fd, FIONBIO, &on);
#elif MG_ARCH == MG_ARCH_FREERTOS_TCP
  const BaseType_t off = 0;
  setsockopt(fd, 0, FREERTOS_SO_RCVTIMEO, &off, sizeof(off));
  setsockopt(fd, 0, FREERTOS_SO_SNDTIMEO, &off, sizeof(off));
#elif MG_ARCH == MG_ARCH_FREERTOS_LWIP
  lwip_fcntl(fd, F_SETFL, O_NONBLOCK);
#elif MG_ARCH == MG_ARCH_AZURERTOS
  fcntl(fd, F_SETFL, O_NONBLOCK);
#else
  fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);  // Non-blocking mode
  fcntl(fd, F_SETFD, FD_CLOEXEC);                          // Set close-on-exec
#endif
}

static SOCKET mg_open_listener(const char *url, struct mg_addr *addr) {
  SOCKET fd = INVALID_SOCKET;
  int s_err = 0;  // Memoized socket error, in case closesocket() overrides it
  memset(addr, 0, sizeof(*addr));
  addr->port = mg_htons(mg_url_port(url));
  if (!mg_aton(mg_url_host(url), addr)) {
    LOG(LL_ERROR, ("invalid listening URL: %s", url));
  } else {
    union usa usa;
    socklen_t slen = tousa(addr, &usa);
    int on = 1, af = addr->is_ip6 ? AF_INET6 : AF_INET;
    int type = strncmp(url, "udp:", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;
    int proto = type == SOCK_DGRAM ? IPPROTO_UDP : IPPROTO_TCP;
    (void) on;

    if ((fd = socket(af, type, proto)) != INVALID_SOCKET &&
#if (!defined(_WIN32) || !defined(SO_EXCLUSIVEADDRUSE)) && \
    (!defined(LWIP_SOCKET) || (defined(LWIP_SOCKET) && SO_REUSE == 1))
        // 1. SO_RESUSEADDR is not enabled on Windows because the semantics of
        //    SO_REUSEADDR on UNIX and Windows is different. On Windows,
        //    SO_REUSEADDR allows to bind a socket to a port without error even
        //    if the port is already open by another program. This is not the
        //    behavior SO_REUSEADDR was designed for, and leads to hard-to-track
        //    failure scenarios. Therefore, SO_REUSEADDR was disabled on Windows
        //    unless SO_EXCLUSIVEADDRUSE is supported and set on a socket.
        // 2. In case of LWIP, SO_REUSEADDR should be explicitly enabled, by
        // defining
        //    SO_REUSE (in lwipopts.h), otherwise the code below will compile
        //    but won't work! (setsockopt will return EINVAL)
        !setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on)) &&
#endif
#if defined(_WIN32) && defined(SO_EXCLUSIVEADDRUSE) && !defined(WINCE)
        // "Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE"
        //! setsockopt(fd, SOL_SOCKET, SO_BROADCAST, (char *) &on, sizeof(on))
        //! &&
        !setsockopt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *) &on,
                    sizeof(on)) &&
#endif
        bind(fd, &usa.sa, slen) == 0 &&
        // NOTE(lsm): FreeRTOS uses backlog value as a connection limit
        (type == SOCK_DGRAM || listen(fd, MG_SOCK_LISTEN_BACKLOG_SIZE) == 0)) {
      // In case port was set to 0, get the real port number
      if (getsockname(fd, &usa.sa, &slen) == 0) {
        addr->port = usa.sin.sin_port;
#if MG_ENABLE_IPV6
        if (addr->is_ip6) addr->port = usa.sin6.sin6_port;
#endif
      }
      mg_set_non_blocking_mode(fd);
    } else if (fd != INVALID_SOCKET) {
      s_err = MG_SOCK_ERRNO;
      closesocket(fd);
      fd = INVALID_SOCKET;
    }
  }
  if (fd == INVALID_SOCKET) {
    if (s_err == 0) s_err = MG_SOCK_ERRNO;
    LOG(LL_ERROR, ("Failed to listen on %s, errno %d", url, s_err));
  }

  return fd;
}

static long mg_sock_recv(struct mg_connection *c, void *buf, size_t len) {
  long n = 0;
  if (c->is_udp) {
    union usa usa;
    socklen_t slen = tousa(&c->peer, &usa);
    n = recvfrom(FD(c), (char *) buf, len, 0, &usa.sa, &slen);
    if (n > 0) tomgaddr(&usa, &c->peer, slen != sizeof(usa.sin));
  } else {
    n = recv(FD(c), (char *) buf, len, MSG_NONBLOCKING);
  }
  return n == 0 ? -1 : n < 0 && mg_sock_would_block() ? 0 : n;
}

// NOTE(lsm): do only one iteration of reads, cause some systems
// (e.g. FreeRTOS stack) return 0 instead of -1/EWOULDBLOCK when no data
static long read_conn(struct mg_connection *c) {
  long n = -1;
  if (c->recv.len >= MG_MAX_RECV_BUF_SIZE) {
    mg_error(c, "max_recv_buf_size reached");
  } else if (c->recv.size - c->recv.len < MG_IO_SIZE &&
             !mg_iobuf_resize(&c->recv, c->recv.size + MG_IO_SIZE)) {
    mg_error(c, "oom");
  } else {
    char *buf = (char *) &c->recv.buf[c->recv.len];
    size_t len = c->recv.size - c->recv.len;
    n = c->is_tls ? mg_tls_recv(c, buf, len) : mg_sock_recv(c, buf, len);
    iolog(c, buf, n, true);
  }
  return n;
}

static void write_conn(struct mg_connection *c) {
  char *buf = (char *) c->send.buf;
  size_t len = c->send.len;
  long n = c->is_tls ? mg_tls_send(c, buf, len) : mg_sock_send(c, buf, len);
  iolog(c, buf, n, false);
}

static void close_conn(struct mg_connection *c) {
  mg_resolve_cancel(c);  // Close any pending DNS query
  LIST_DELETE(struct mg_connection, &c->mgr->conns, c);
  if (c == c->mgr->dns4.c) c->mgr->dns4.c = NULL;
  if (c == c->mgr->dns6.c) c->mgr->dns6.c = NULL;
  // Order of operations is important. `MG_EV_CLOSE` event must be fired
  // before we deallocate received data, see #1331
  mg_call(c, MG_EV_CLOSE, NULL);
  LOG(LL_DEBUG, ("%lu closed", c->id));
  if (FD(c) != INVALID_SOCKET) {
    closesocket(FD(c));
#if MG_ARCH == MG_ARCH_FREERTOS_TCP
    FreeRTOS_FD_CLR(c->fd, c->mgr->ss, eSELECT_ALL);
#endif
    c->fd = S2PTR(INVALID_SOCKET);
  }
  mg_tls_free(c);
  mg_iobuf_free(&c->recv);
  mg_iobuf_free(&c->send);
  memset(c, 0, sizeof(*c));
  free(c);
}

static void setsockopts(struct mg_connection *c) {
#if MG_ARCH == MG_ARCH_FREERTOS_TCP || MG_ARCH == MG_ARCH_AZURERTOS
  (void) c;
#else
  int on = 1;
#if !defined(SOL_TCP)
#define SOL_TCP IPPROTO_TCP
#endif
  setsockopt(FD(c), SOL_TCP, TCP_NODELAY, (char *) &on, sizeof(on));
#if defined(TCP_QUICKACK)
  setsockopt(FD(c), SOL_TCP, TCP_QUICKACK, (char *) &on, sizeof(on));
#endif
  setsockopt(FD(c), SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on));
#if (defined(ESP32) && ESP32) || (defined(ESP8266) && ESP8266) || \
    defined(__linux__)
  int idle = 60;
  setsockopt(FD(c), IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(idle));
#endif
#if !defined(_WIN32) && !defined(__QNX__)
  {
    int cnt = 3, intvl = 20;
    setsockopt(FD(c), IPPROTO_TCP, TCP_KEEPCNT, &cnt, sizeof(cnt));
    setsockopt(FD(c), IPPROTO_TCP, TCP_KEEPINTVL, &intvl, sizeof(intvl));
  }
#endif
#endif
}

void mg_connect_resolved(struct mg_connection *c) {
  // char buf[40];
  int type = c->is_udp ? SOCK_DGRAM : SOCK_STREAM;
  int rc, af = c->peer.is_ip6 ? AF_INET6 : AF_INET;
  // mg_straddr(&c->peer, buf, sizeof(buf));
  c->fd = S2PTR(socket(af, type, 0));
  if (FD(c) == INVALID_SOCKET) {
    mg_error(c, "socket(): %d", MG_SOCK_ERRNO);
  } else if (c->is_udp) {
    mg_call(c, MG_EV_RESOLVE, NULL);
    mg_call(c, MG_EV_CONNECT, NULL);
  } else {
    union usa usa;
    socklen_t slen = tousa(&c->peer, &usa);
    mg_set_non_blocking_mode(FD(c));
    setsockopts(c);
    mg_call(c, MG_EV_RESOLVE, NULL);
    if ((rc = connect(FD(c), &usa.sa, slen)) == 0) {
      mg_call(c, MG_EV_CONNECT, NULL);
    } else if (mg_sock_would_block()) {
      c->is_connecting = 1;
    } else {
      mg_error(c, "connect: %d", MG_SOCK_ERRNO);
    }
  }
}

struct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url,
                                 mg_event_handler_t fn, void *fn_data) {
  struct mg_connection *c = NULL;
  if (url == NULL || url[0] == '\0') {
    LOG(LL_ERROR, ("null url"));
  } else if ((c = alloc_conn(mgr, 1, INVALID_SOCKET)) == NULL) {
    LOG(LL_ERROR, ("OOM"));
  } else {
    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);
    c->is_udp = (strncmp(url, "udp:", 4) == 0);
    c->fn = fn;
    c->fn_data = fn_data;
    LOG(LL_DEBUG, ("%lu -> %s", c->id, url));
    mg_call(c, MG_EV_OPEN, NULL);
    mg_resolve(c, url);
  }
  return c;
}

static void accept_conn(struct mg_mgr *mgr, struct mg_connection *lsn) {
  struct mg_connection *c = NULL;
  union usa usa;
  socklen_t sa_len = sizeof(usa);
  SOCKET fd = accept(FD(lsn), &usa.sa, &sa_len);
  if (fd == INVALID_SOCKET) {
#if MG_ARCH == MG_ARCH_AZURERTOS
    // AzureRTOS, in non-block socket mode can mark listening socket readable
    // even it is not. See comment for 'select' func implementation in nx_bsd.c
    // That's not an error, just should try later
    if (MG_SOCK_ERRNO != EAGAIN)
#endif
      LOG(LL_ERROR, ("%lu accept failed, errno %d", lsn->id, MG_SOCK_ERRNO));
#if (!defined(_WIN32) && (MG_ARCH != MG_ARCH_FREERTOS_TCP))
  } else if ((long) fd >= FD_SETSIZE) {
    LOG(LL_ERROR, ("%ld > %ld", (long) fd, (long) FD_SETSIZE));
    closesocket(fd);
#endif
  } else if ((c = alloc_conn(mgr, 0, fd)) == NULL) {
    LOG(LL_ERROR, ("%lu OOM", lsn->id));
    closesocket(fd);
  } else {
    char buf[40];
    tomgaddr(&usa, &c->peer, sa_len != sizeof(usa.sin));
    mg_straddr(&c->peer, buf, sizeof(buf));
    LOG(LL_DEBUG, ("%lu accepted %s", c->id, buf));
    mg_set_non_blocking_mode(FD(c));
    setsockopts(c);
    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);
    c->is_accepted = 1;
    c->is_hexdumping = lsn->is_hexdumping;
    c->pfn = lsn->pfn;
    c->pfn_data = lsn->pfn_data;
    c->fn = lsn->fn;
    c->fn_data = lsn->fn_data;
    mg_call(c, MG_EV_OPEN, NULL);
    mg_call(c, MG_EV_ACCEPT, NULL);
  }
}

static bool mg_socketpair(SOCKET sp[2], union usa usa[2]) {
  socklen_t n = sizeof(usa[0].sin);
  bool result = false;

  (void) memset(&usa[0], 0, sizeof(usa[0]));
  usa[0].sin.sin_family = AF_INET;
  *(uint32_t *) &usa->sin.sin_addr = mg_htonl(0x7f000001);  // 127.0.0.1
  usa[1] = usa[0];

  if ((sp[0] = socket(AF_INET, SOCK_DGRAM, 0)) != INVALID_SOCKET &&
      (sp[1] = socket(AF_INET, SOCK_DGRAM, 0)) != INVALID_SOCKET &&
      bind(sp[0], &usa[0].sa, n) == 0 && bind(sp[1], &usa[1].sa, n) == 0 &&
      getsockname(sp[0], &usa[0].sa, &n) == 0 &&
      getsockname(sp[1], &usa[1].sa, &n) == 0 &&
      connect(sp[0], &usa[1].sa, n) == 0 &&
      connect(sp[1], &usa[0].sa, n) == 0) {
    mg_set_non_blocking_mode(sp[1]);  // Set close-on-exec
    result = true;
  } else {
    if (sp[0] != INVALID_SOCKET) closesocket(sp[0]);
    if (sp[1] != INVALID_SOCKET) closesocket(sp[1]);
    sp[0] = sp[1] = INVALID_SOCKET;
  }

  return result;
}

void mg_mgr_wakeup(struct mg_connection *c, const void *buf, size_t len) {
  if (buf == NULL || len == 0) buf = (void *) "", len = 1;
  send((SOCKET) (size_t) c->pfn_data, (const char *) buf, len, MSG_NONBLOCKING);
}

static void pf1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {
  if (ev == MG_EV_READ) {
    mg_iobuf_free(&c->recv);
  } else if (ev == MG_EV_CLOSE) {
    closesocket((SOCKET) (size_t) c->pfn_data);
  }
  (void) ev_data, (void) fn_data;
}

struct mg_connection *mg_mkpipe(struct mg_mgr *mgr, mg_event_handler_t fn,
                                void *fn_data) {
  union usa usa[2];
  SOCKET sp[2] = {INVALID_SOCKET, INVALID_SOCKET};
  struct mg_connection *c = NULL;
  if (!mg_socketpair(sp, usa)) {
    LOG(LL_ERROR, ("Cannot create socket pair"));
  } else if ((c = alloc_conn(mgr, false, sp[1])) == NULL) {
    closesocket(sp[0]);
    closesocket(sp[1]);
    LOG(LL_ERROR, ("OOM"));
  } else {
    LOG(LL_INFO, ("pipe %lu", (unsigned long) sp[0]));
    tomgaddr(&usa[0], &c->peer, false);
    c->is_udp = 1;
    c->pfn = pf1;
    c->pfn_data = (void *) (size_t) sp[0];
    c->fn = fn;
    c->fn_data = fn_data;
    mg_call(c, MG_EV_OPEN, NULL);
    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);
  }
  return c;
}

struct mg_connection *mg_listen(struct mg_mgr *mgr, const char *url,
                                mg_event_handler_t fn, void *fn_data) {
  struct mg_connection *c = NULL;
  bool is_udp = strncmp(url, "udp:", 4) == 0;
  struct mg_addr addr;
  SOCKET fd = mg_open_listener(url, &addr);
  if (fd == INVALID_SOCKET) {
    LOG(LL_ERROR, ("Failed: %s, errno %d", url, MG_SOCK_ERRNO));
  } else if ((c = alloc_conn(mgr, 0, fd)) == NULL) {
    LOG(LL_ERROR, ("OOM %s", url));
    closesocket(fd);
  } else {
    memcpy(&c->peer, &addr, sizeof(struct mg_addr));
    c->fd = S2PTR(fd);
    c->is_listening = 1;
    c->is_udp = is_udp;
    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);
    c->fn = fn;
    c->fn_data = fn_data;
    mg_call(c, MG_EV_OPEN, NULL);
    LOG(LL_DEBUG,
        ("%lu accepting on %s (port %u)", c->id, url, mg_ntohs(c->peer.port)));
  }
  return c;
}

static void mg_iotest(struct mg_mgr *mgr, int ms) {
#if MG_ARCH == MG_ARCH_FREERTOS_TCP
  struct mg_connection *c;
  for (c = mgr->conns; c != NULL; c = c->next) {
    if (c->is_closing || c->is_resolving || FD(c) == INVALID_SOCKET) continue;
    FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_READ | eSELECT_EXCEPT);
    if (c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0))
      FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_WRITE);
  }
  FreeRTOS_select(mgr->ss, pdMS_TO_TICKS(ms));
  for (c = mgr->conns; c != NULL; c = c->next) {
    EventBits_t bits = FreeRTOS_FD_ISSET(c->fd, mgr->ss);
    c->is_readable = bits & (eSELECT_READ | eSELECT_EXCEPT) ? 1 : 0;
    c->is_writable = bits & eSELECT_WRITE ? 1 : 0;
    FreeRTOS_FD_CLR(c->fd, mgr->ss,
                    eSELECT_READ | eSELECT_EXCEPT | eSELECT_WRITE);
  }
#else
  struct timeval tv = {ms / 1000, (ms % 1000) * 1000};
  struct mg_connection *c;
  fd_set rset, wset;
  SOCKET maxfd = 0;
  int rc;

  FD_ZERO(&rset);
  FD_ZERO(&wset);

  for (c = mgr->conns; c != NULL; c = c->next) {
    if (c->is_closing || c->is_resolving || FD(c) == INVALID_SOCKET) continue;
    FD_SET(FD(c), &rset);
    if (FD(c) > maxfd) maxfd = FD(c);
    if (c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0))
      FD_SET(FD(c), &wset);
  }

  if ((rc = select((int) maxfd + 1, &rset, &wset, NULL, &tv)) < 0) {
    LOG(LL_DEBUG, ("select: %d %d", rc, MG_SOCK_ERRNO));
    FD_ZERO(&rset);
    FD_ZERO(&wset);
  }

  for (c = mgr->conns; c != NULL; c = c->next) {
    // TLS might have stuff buffered, so dig everything
    c->is_readable = FD(c) != INVALID_SOCKET && FD_ISSET(FD(c), &rset);
    c->is_writable = FD(c) != INVALID_SOCKET && FD_ISSET(FD(c), &wset);
  }
#endif
}

static void connect_conn(struct mg_connection *c) {
  int rc = 0;
#if MG_ARCH != MG_ARCH_FREERTOS_TCP
  socklen_t len = sizeof(rc);
  if (getsockopt(FD(c), SOL_SOCKET, SO_ERROR, (char *) &rc, &len)) rc = 1;
#endif
  if (rc == EAGAIN || rc == EWOULDBLOCK) rc = 0;
  c->is_connecting = 0;
  if (rc) {
    char buf[50];
    mg_error(c, "error connecting to %s",
             mg_straddr(&c->peer, buf, sizeof(buf)));
  } else {
    if (c->is_tls_hs) mg_tls_handshake(c);
    mg_call(c, MG_EV_CONNECT, NULL);
  }
}

void mg_mgr_poll(struct mg_mgr *mgr, int ms) {
  struct mg_connection *c, *tmp;
  int64_t now;

  mg_iotest(mgr, ms);
  now = mg_millis();
  mg_timer_poll(now);

  for (c = mgr->conns; c != NULL; c = tmp) {
    tmp = c->next;
    mg_call(c, MG_EV_POLL, &now);
    LOG(LL_VERBOSE_DEBUG,
        ("%lu %c%c %c%c%c%c%c", c->id, c->is_readable ? 'r' : '-',
         c->is_writable ? 'w' : '-', c->is_tls ? 'T' : 't',
         c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',
         c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));
    if (c->is_resolving || c->is_closing) {
      // Do nothing
    } else if (c->is_listening && c->is_udp == 0) {
      if (c->is_readable) accept_conn(mgr, c);
    } else if (c->is_connecting) {
      if (c->is_readable || c->is_writable) connect_conn(c);
    } else if (c->is_tls_hs) {
      if ((c->is_readable || c->is_writable)) mg_tls_handshake(c);
    } else {
      if (c->is_readable) read_conn(c);
      if (c->is_writable) write_conn(c);
      while (c->is_tls && read_conn(c) > 0) (void) 0;  // Read buffered TLS data
    }

    if (c->is_draining && c->send.len == 0) c->is_closing = 1;
    if (c->is_closing) close_conn(c);
  }
}
#endif

#ifdef MG_ENABLE_LINES
#line 1 "src/ssi.c"
#endif




#ifndef MG_MAX_SSI_DEPTH
#define MG_MAX_SSI_DEPTH 5
#endif

#if MG_ENABLE_SSI
static char *mg_ssi(const char *path, const char *root, int depth) {
  struct mg_iobuf b = {NULL, 0, 0};
  FILE *fp = fopen(path, "rb");
  if (fp != NULL) {
    char buf[BUFSIZ], arg[sizeof(buf)];
    int ch, intag = 0;
    size_t len = 0, align = MG_IO_SIZE;
    while ((ch = fgetc(fp)) != EOF) {
      if (intag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {
        buf[len++] = (char) (ch & 0xff);
        if (sscanf(buf, "<!--#include file=\"%[^\"]", arg)) {
          char tmp[MG_PATH_MAX + BUFSIZ + 10],
              *p = (char *) path + strlen(path), *data;
          while (p > path && p[-1] != MG_DIRSEP && p[-1] != '/') p--;
          snprintf(tmp, sizeof(tmp), "%.*s%s", (int) (p - path), path, arg);
          if (depth < MG_MAX_SSI_DEPTH &&
              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {
            mg_iobuf_add(&b, b.len, data, strlen(data), align);
            free(data);
          } else {
            LOG(LL_ERROR, ("%s: file=%s error or too deep", path, arg));
          }
        } else if (sscanf(buf, "<!--#include virtual=\"%[^\"]", arg)) {
          char tmp[MG_PATH_MAX + BUFSIZ + 10], *data;
          snprintf(tmp, sizeof(tmp), "%s%s", root, arg);
          if (depth < MG_MAX_SSI_DEPTH &&
              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {
            mg_iobuf_add(&b, b.len, data, strlen(data), align);
            free(data);
          } else {
            LOG(LL_ERROR, ("%s: virtual=%s error or too deep", path, arg));
          }
        } else {
          // Unknown SSI tag
          LOG(LL_INFO, ("Unknown SSI tag: %.*s", (int) len, buf));
          mg_iobuf_add(&b, b.len, buf, len, align);
        }
        intag = 0;
        len = 0;
      } else if (ch == '<') {
        intag = 1;
        if (len > 0) mg_iobuf_add(&b, b.len, buf, len, align);
        len = 0;
        buf[len++] = (char) (ch & 0xff);
      } else if (intag) {
        if (len == 5 && strncmp(buf, "<!--#", 5) != 0) {
          intag = 0;
        } else if (len >= sizeof(buf) - 2) {
          LOG(LL_ERROR, ("%s: SSI tag is too large", path));
          len = 0;
        }
        buf[len++] = (char) (ch & 0xff);
      } else {
        buf[len++] = (char) (ch & 0xff);
        if (len >= sizeof(buf)) {
          mg_iobuf_add(&b, b.len, buf, len, align);
          len = 0;
        }
      }
    }
    if (len > 0) mg_iobuf_add(&b, b.len, buf, len, align);
    if (b.len > 0) mg_iobuf_add(&b, b.len, "", 1, align);  // nul-terminate
    fclose(fp);
  }
  (void) depth;
  (void) root;
  return (char *) b.buf;
}

void mg_http_serve_ssi(struct mg_connection *c, const char *root,
                       const char *fullpath) {
  const char *headers = "Content-Type: text/html; charset=utf-8\r\n";
  char *data = mg_ssi(fullpath, root, 0);
  mg_http_reply(c, 200, headers, "%s", data == NULL ? "" : data);
  free(data);
}
#else
void mg_http_serve_ssi(struct mg_connection *c, const char *root,
                       const char *fullpath) {
  mg_http_reply(c, 501, NULL, "SSI not enabled");
  (void) root, (void) fullpath;
}
#endif

#ifdef MG_ENABLE_LINES
#line 1 "src/str.c"
#endif

#include <stdlib.h>

struct mg_str mg_str_s(const char *s) {
  struct mg_str str = {s, s == NULL ? 0 : strlen(s)};
  return str;
}

struct mg_str mg_str_n(const char *s, size_t n) {
  struct mg_str str = {s, n};
  return str;
}

int mg_lower(const char *s) {
  return tolower(*(const unsigned char *) s);
}

int mg_ncasecmp(const char *s1, const char *s2, size_t len) {
  int diff = 0;
  if (len > 0) do {
      diff = mg_lower(s1++) - mg_lower(s2++);
    } while (diff == 0 && s1[-1] != '\0' && --len > 0);
  return diff;
}

int mg_casecmp(const char *s1, const char *s2) {
  return mg_ncasecmp(s1, s2, (size_t) ~0);
}

int mg_vcmp(const struct mg_str *s1, const char *s2) {
  size_t n2 = strlen(s2), n1 = s1->len;
  int r = strncmp(s1->ptr, s2, (n1 < n2) ? n1 : n2);
  if (r == 0) return (int) (n1 - n2);
  return r;
}

int mg_vcasecmp(const struct mg_str *str1, const char *str2) {
  size_t n2 = strlen(str2), n1 = str1->len;
  int r = mg_ncasecmp(str1->ptr, str2, (n1 < n2) ? n1 : n2);
  if (r == 0) return (int) (n1 - n2);
  return r;
}

struct mg_str mg_strdup(const struct mg_str s) {
  struct mg_str r = {NULL, 0};
  if (s.len > 0 && s.ptr != NULL) {
    char *sc = (char *) calloc(1, s.len + 1);
    if (sc != NULL) {
      memcpy(sc, s.ptr, s.len);
      sc[s.len] = '\0';
      r.ptr = sc;
      r.len = s.len;
    }
  }
  return r;
}

int mg_strcmp(const struct mg_str str1, const struct mg_str str2) {
  size_t i = 0;
  while (i < str1.len && i < str2.len) {
    int c1 = str1.ptr[i];
    int c2 = str2.ptr[i];
    if (c1 < c2) return -1;
    if (c1 > c2) return 1;
    i++;
  }
  if (i < str1.len) return 1;
  if (i < str2.len) return -1;
  return 0;
}

const char *mg_strstr(const struct mg_str haystack,
                      const struct mg_str needle) {
  size_t i;
  if (needle.len > haystack.len) return NULL;
  for (i = 0; i <= haystack.len - needle.len; i++) {
    if (memcmp(haystack.ptr + i, needle.ptr, needle.len) == 0) {
      return haystack.ptr + i;
    }
  }
  return NULL;
}

struct mg_str mg_strstrip(struct mg_str s) {
  while (s.len > 0 && isspace((int) *s.ptr)) s.ptr++, s.len--;
  while (s.len > 0 && isspace((int) *(s.ptr + s.len - 1))) s.len--;
  return s;
}

#ifdef MG_ENABLE_LINES
#line 1 "src/timer.c"
#endif
// Copyright (c) Cesanta Software Limited
// All rights reserved




struct mg_timer *g_timers;

void mg_timer_init(struct mg_timer *t, int64_t ms, unsigned flags,
                   void (*fn)(void *), void *arg) {
  struct mg_timer tmp = {ms, 0UL, flags, fn, arg, g_timers};
  *t = tmp;
  g_timers = t;
  if (flags & MG_TIMER_RUN_NOW) fn(arg);
}

void mg_timer_free(struct mg_timer *t) {
  struct mg_timer **head = &g_timers;
  while (*head && *head != t) head = &(*head)->next;
  if (*head) *head = t->next;
}

void mg_timer_poll(int64_t now_ms) {
  // If time goes back (wrapped around), reset timers
  struct mg_timer *t, *tmp;
  static int64_t oldnow;  // Timestamp in a previous invocation
  if (oldnow > now_ms) {  // If it is wrapped, reset timers
    for (t = g_timers; t != NULL; t = t->next) t->expire = 0;
  }
  oldnow = now_ms;

  for (t = g_timers; t != NULL; t = tmp) {
    tmp = t->next;
    if (t->expire == 0) t->expire = now_ms + t->period_ms;
    if (t->expire > now_ms) continue;
    t->fn(t->arg);
    // Try to tick timers with the given period as accurate as possible,
    // even if this polling function is called with some random period.
    t->expire = now_ms - t->expire > t->period_ms ? now_ms + t->period_ms
                                                  : t->expire + t->period_ms;
    if (!(t->flags & MG_TIMER_REPEAT)) mg_timer_free(t);
  }
}

#ifdef MG_ENABLE_LINES
#line 1 "src/tls_dummy.c"
#endif


#if !MG_ENABLE_MBEDTLS && !MG_ENABLE_OPENSSL && !MG_ENABLE_CUSTOM_TLS
void mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts) {
  (void) opts;
  mg_error(c, "TLS is not enabled");
}
void mg_tls_handshake(struct mg_connection *c) {
  (void) c;
}
void mg_tls_free(struct mg_connection *c) {
  (void) c;
}
long mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {
  return c == NULL || buf == NULL || len == 0 ? 0 : -1;
}
long mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {
  return c == NULL || buf == NULL || len == 0 ? 0 : -1;
}
#endif

#ifdef MG_ENABLE_LINES
#line 1 "src/tls_mbed.c"
#endif



#if MG_ENABLE_MBEDTLS

#if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000
#define MGRNG , rng_get, NULL
#else
#define MGRNG
#endif

void mg_tls_free(struct mg_connection *c) {
  struct mg_tls *tls = (struct mg_tls *) c->tls;
  if (tls != NULL) {
    free(tls->cafile);
    mbedtls_ssl_free(&tls->ssl);
    mbedtls_pk_free(&tls->pk);
    mbedtls_x509_crt_free(&tls->ca);
    mbedtls_x509_crl_free(&tls->crl);
    mbedtls_x509_crt_free(&tls->cert);
    mbedtls_ssl_config_free(&tls->conf);
    free(tls);
    c->tls = NULL;
  }
}

static bool mg_wouldblock(int n) {
  return n < 0 &&
         (errno == EINPROGRESS || errno == EAGAIN || errno == EWOULDBLOCK);
}

static int mg_net_send(void *ctx, const unsigned char *buf, size_t len) {
  int fd = *(int *) ctx;
  int n = (int) send(fd, buf, len, 0);
  if (n > 0) return n;
  if (mg_wouldblock(n)) return MBEDTLS_ERR_SSL_WANT_WRITE;
  return MBEDTLS_ERR_NET_SEND_FAILED;
}

static int mg_net_recv(void *ctx, unsigned char *buf, size_t len) {
  int fd = *(int *) ctx;
  int n = (int) recv(fd, buf, len, 0);
  if (n > 0) return n;
  if (mg_wouldblock(n)) return MBEDTLS_ERR_SSL_WANT_READ;
  return MBEDTLS_ERR_NET_RECV_FAILED;
}

void mg_tls_handshake(struct mg_connection *c) {
  struct mg_tls *tls = (struct mg_tls *) c->tls;
  int rc;
  mbedtls_ssl_set_bio(&tls->ssl, &c->fd, mg_net_send, mg_net_recv, 0);
  rc = mbedtls_ssl_handshake(&tls->ssl);
  if (rc == 0) {  // Success
    LOG(LL_DEBUG, ("%lu success", c->id));
    c->is_tls_hs = 0;
  } else if (rc == MBEDTLS_ERR_SSL_WANT_READ ||
             rc == MBEDTLS_ERR_SSL_WANT_WRITE) {  // Still pending
    LOG(LL_VERBOSE_DEBUG, ("%lu pending, %d%d %d (-%#x)", c->id,
                           c->is_connecting, c->is_tls_hs, rc, -rc));
  } else {
    mg_error(c, "TLS handshake: -%#x", -rc);  // Error
  }
}

static int mbed_rng(void *ctx, unsigned char *buf, size_t len) {
  mg_random(buf, len);
  (void) ctx;
  return 0;
}

static void debug_cb(void *c, int lev, const char *s, int n, const char *s2) {
  n = (int) strlen(s2) - 1;
  LOG(LL_VERBOSE_DEBUG, ("%p %.*s", ((struct mg_connection *) c)->fd, n, s2));
  (void) s;
  (void) c;
  (void) lev;
}

#if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000
static int rng_get(void *p_rng, unsigned char *buf, size_t len) {
  (void) p_rng;
  mg_random(buf, len);
  return 0;
}
#endif

static struct mg_str mg_loadfile(struct mg_fs *fs, const char *path) {
  size_t n = 0;
  if (path[0] == '-') return mg_str(path);
  char *p = mg_file_read(fs, path, &n);
  return mg_str_n(p, n);
}

void mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));
  int rc = 0;
  c->tls = tls;
  if (c->tls == NULL) {
    mg_error(c, "TLS OOM");
    goto fail;
  }
  LOG(LL_DEBUG, ("%lu Setting TLS", c->id));
  mbedtls_ssl_init(&tls->ssl);
  mbedtls_ssl_config_init(&tls->conf);
  mbedtls_x509_crt_init(&tls->ca);
  mbedtls_x509_crl_init(&tls->crl);
  mbedtls_x509_crt_init(&tls->cert);
  mbedtls_pk_init(&tls->pk);
  mbedtls_ssl_conf_dbg(&tls->conf, debug_cb, c);
  if ((rc = mbedtls_ssl_config_defaults(
           &tls->conf,
           c->is_client ? MBEDTLS_SSL_IS_CLIENT : MBEDTLS_SSL_IS_SERVER,
           MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT)) != 0) {
    mg_error(c, "tls defaults %#x", -rc);
    goto fail;
  }
  mbedtls_ssl_conf_rng(&tls->conf, mbed_rng, c);
  if (opts->ca == NULL || strcmp(opts->ca, "*") == 0) {
    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_NONE);
  } else if (opts->ca != NULL && opts->ca[0] != '\0') {
    if (opts->crl != NULL && opts->crl[0] != '\0') {
      struct mg_str s = mg_loadfile(fs, opts->crl);
      rc = mbedtls_x509_crl_parse(&tls->crl, (uint8_t *) s.ptr, s.len + 1);
      if (opts->crl[0] != '-') free((char *) s.ptr);
      if (rc != 0) {
        mg_error(c, "parse(%s) err %#x", opts->crl, -rc);
        goto fail;
      }
    }
#if defined(MBEDTLS_X509_CA_CHAIN_ON_DISK)
    tls->cafile = strdup(opts->ca);
    rc = mbedtls_ssl_conf_ca_chain_file(&tls->conf, tls->cafile, &tls->crl);
    if (rc != 0) {
      mg_error(c, "parse on-disk chain(%s) err %#x", ca, -rc);
      goto fail;
    }
#else
    struct mg_str s = mg_loadfile(fs, opts->ca);
    rc = mbedtls_x509_crt_parse(&tls->ca, (uint8_t *) s.ptr, s.len + 1);
    if (opts->ca[0] != '-') free((char *) s.ptr);
    if (rc != 0) {
      mg_error(c, "parse(%s) err %#x", opts->ca, -rc);
      goto fail;
    }
    mbedtls_ssl_conf_ca_chain(&tls->conf, &tls->ca, &tls->crl);
#endif
    if (opts->srvname.len > 0) {
      char mem[128], *buf = mem;
      mg_asprintf(&buf, sizeof(mem), "%.*s", (int) opts->srvname.len,
                  opts->srvname.ptr);
      mbedtls_ssl_set_hostname(&tls->ssl, buf);
      if (buf != mem) free(buf);
    }
    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_REQUIRED);
  }
  if (opts->cert != NULL && opts->cert[0] != '\0') {
    struct mg_str s = mg_loadfile(fs, opts->cert);
    const char *key = opts->certkey == NULL ? opts->cert : opts->certkey;
    rc = mbedtls_x509_crt_parse(&tls->cert, (uint8_t *) s.ptr, s.len + 1);
    if (opts->cert[0] != '-') free((char *) s.ptr);
    if (rc != 0) {
      mg_error(c, "parse(%s) err %#x", opts->cert, -rc);
      goto fail;
    }
    s = mg_loadfile(fs, key);
    rc = mbedtls_pk_parse_key(&tls->pk, (uint8_t *) s.ptr, s.len + 1, NULL,
                              0 MGRNG);
    if (key[0] != '-') free((char *) s.ptr);
    if (rc != 0) {
      mg_error(c, "tls key(%s) %#x", key, -rc);
      goto fail;
    }
    rc = mbedtls_ssl_conf_own_cert(&tls->conf, &tls->cert, &tls->pk);
    if (rc != 0) {
      mg_error(c, "own cert %#x", -rc);
      goto fail;
    }
  }
  if ((rc = mbedtls_ssl_setup(&tls->ssl, &tls->conf)) != 0) {
    mg_error(c, "setup err %#x", -rc);
    goto fail;
  }
  c->tls = tls;
  c->is_tls = 1;
  c->is_tls_hs = 1;
  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {
    mg_tls_handshake(c);
  }
  return;
fail:
  mg_tls_free(c);
}

long mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {
  struct mg_tls *tls = (struct mg_tls *) c->tls;
  long n = mbedtls_ssl_read(&tls->ssl, (unsigned char *) buf, len);
  return n == 0 ? -1 : n == MBEDTLS_ERR_SSL_WANT_READ ? 0 : n;
}

long mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {
  struct mg_tls *tls = (struct mg_tls *) c->tls;
  long n = mbedtls_ssl_write(&tls->ssl, (unsigned char *) buf, len);
  return n == 0 ? -1 : n == MBEDTLS_ERR_SSL_WANT_WRITE ? 0 : n;
}
#endif

#ifdef MG_ENABLE_LINES
#line 1 "src/tls_openssl.c"
#endif


#if MG_ENABLE_OPENSSL
static int mg_tls_err(struct mg_tls *tls, int res) {
  int err = SSL_get_error(tls->ssl, res);
  // We've just fetched the last error from the queue.
  // Now we need to clear the error queue. If we do not, then the following
  // can happen (actually reported):
  //  - A new connection is accept()-ed with cert error (e.g. self-signed cert)
  //  - Since all accept()-ed connections share listener's context,
  //  - *ALL* SSL accepted connection report read error on the next poll cycle.
  //    Thus a single errored connection can close all the rest, unrelated ones.
  // Clearing the error keeps the shared SSL_CTX in an OK state.

  if (err != 0) ERR_print_errors_fp(stderr);
  ERR_clear_error();
  if (err == SSL_ERROR_WANT_READ) return 0;
  if (err == SSL_ERROR_WANT_WRITE) return 0;
  return err;
}

void mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts) {
  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));
  const char *id = "mongoose";
  static unsigned char s_initialised = 0;
  int rc;

  if (tls == NULL) {
    mg_error(c, "TLS OOM");
    goto fail;
  }

  if (!s_initialised) {
    SSL_library_init();
    s_initialised++;
  }
  LOG(LL_DEBUG, ("%lu Setting TLS, CA: %s, cert: %s, key: %s", c->id,
                 opts->ca == NULL ? "null" : opts->ca,
                 opts->cert == NULL ? "null" : opts->cert,
                 opts->certkey == NULL ? "null" : opts->certkey));
  tls->ctx = c->is_client ? SSL_CTX_new(SSLv23_client_method())
                          : SSL_CTX_new(SSLv23_server_method());
  if ((tls->ssl = SSL_new(tls->ctx)) == NULL) {
    mg_error(c, "SSL_new");
    goto fail;
  }
  SSL_set_session_id_context(tls->ssl, (const uint8_t *) id,
                             (unsigned) strlen(id));
  // Disable deprecated protocols
  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv2);
  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv3);
  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1);
  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1_1);
#ifdef MG_ENABLE_OPENSSL_NO_COMPRESSION
  SSL_set_options(tls->ssl, SSL_OP_NO_COMPRESSION);
#endif
#ifdef MG_ENABLE_OPENSSL_CIPHER_SERVER_PREFERENCE
  SSL_set_options(tls->ssl, SSL_OP_CIPHER_SERVER_PREFERENCE);
#endif

  if (opts->ca != NULL && opts->ca[0] != '\0') {
    SSL_set_verify(tls->ssl, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
                   NULL);
    if ((rc = SSL_CTX_load_verify_locations(tls->ctx, opts->ca, NULL)) != 1) {
      mg_error(c, "parse(%s): err %d", opts->ca, mg_tls_err(tls, rc));
      goto fail;
    }
  }
  if (opts->cert != NULL && opts->cert[0] != '\0') {
    const char *key = opts->certkey;
    if (key == NULL) key = opts->cert;
    if ((rc = SSL_use_certificate_file(tls->ssl, opts->cert, 1)) != 1) {
      mg_error(c, "Invalid SSL cert, err %d", mg_tls_err(tls, rc));
      goto fail;
    } else if ((rc = SSL_use_PrivateKey_file(tls->ssl, key, 1)) != 1) {
      mg_error(c, "Invalid SSL key, err %d", mg_tls_err(tls, rc));
      goto fail;
#if OPENSSL_VERSION_NUMBER > 0x10100000L
    } else if ((rc = SSL_use_certificate_chain_file(tls->ssl, opts->cert)) !=
               1) {
      mg_error(c, "Invalid CA, err %d", mg_tls_err(tls, rc));
      goto fail;
#endif
    } else {
      SSL_set_mode(tls->ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
#if OPENSSL_VERSION_NUMBER > 0x10002000L
      SSL_set_ecdh_auto(tls->ssl, 1);
#endif
    }
  }
  if (opts->ciphers != NULL) SSL_set_cipher_list(tls->ssl, opts->ciphers);
  if (opts->srvname.len > 0) {
    char mem[128], *buf = mem;
    mg_asprintf(&buf, sizeof(mem), "%.*s", (int) opts->srvname.len,
                opts->srvname.ptr);
    SSL_set_tlsext_host_name(tls->ssl, buf);
    if (buf != mem) free(buf);
  }
  c->tls = tls;
  c->is_tls = 1;
  c->is_tls_hs = 1;
  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {
    mg_tls_handshake(c);
  }
  LOG(LL_DEBUG, ("%lu SSL %s OK", c->id, c->is_accepted ? "accept" : "client"));
  return;
fail:
  c->is_closing = 1;
  free(tls);
}

void mg_tls_handshake(struct mg_connection *c) {
  struct mg_tls *tls = (struct mg_tls *) c->tls;
  int rc;
  SSL_set_fd(tls->ssl, (int) (size_t) c->fd);
  rc = c->is_client ? SSL_connect(tls->ssl) : SSL_accept(tls->ssl);
  if (rc == 1) {
    LOG(LL_DEBUG, ("%lu success", c->id));
    c->is_tls_hs = 0;
  } else {
    int code = mg_tls_err(tls, rc);
    if (code != 0) mg_error(c, "tls hs: rc %d, err %d", rc, code);
  }
}

void mg_tls_free(struct mg_connection *c) {
  struct mg_tls *tls = (struct mg_tls *) c->tls;
  if (tls == NULL) return;
  SSL_free(tls->ssl);
  SSL_CTX_free(tls->ctx);
  free(tls);
  c->tls = NULL;
}

long mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {
  struct mg_tls *tls = (struct mg_tls *) c->tls;
  int n = SSL_read(tls->ssl, buf, (int) len);
  return n == 0 ? -1 : n < 0 && mg_tls_err(tls, n) == 0 ? 0 : n;
}

long mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {
  struct mg_tls *tls = (struct mg_tls *) c->tls;
  int n = SSL_write(tls->ssl, buf, (int) len);
  return n == 0 ? -1 : n < 0 && mg_tls_err(tls, n) == 0 ? 0 : n;
}
#endif

#ifdef MG_ENABLE_LINES
#line 1 "src/url.c"
#endif

#include <stdlib.h>

struct url {
  size_t key, user, pass, host, port, uri, end;
};

int mg_url_is_ssl(const char *url) {
  return strncmp(url, "wss:", 4) == 0 || strncmp(url, "https:", 6) == 0 ||
         strncmp(url, "mqtts:", 6) == 0 || strncmp(url, "ssl:", 4) == 0 ||
         strncmp(url, "tls:", 4) == 0;
}

static struct url urlparse(const char *url) {
  size_t i;
  struct url u;
  memset(&u, 0, sizeof(u));
  for (i = 0; url[i] != '\0'; i++) {
    if (i > 0 && u.host == 0 && url[i - 1] == '/' && url[i] == '/') {
      u.host = i + 1;
      u.port = 0;
    } else if (url[i] == ']') {
      u.port = 0;  // IPv6 URLs, like http://[::1]/bar
    } else if (url[i] == ':' && u.port == 0 && u.uri == 0) {
      u.port = i + 1;
    } else if (url[i] == '@' && u.user == 0 && u.pass == 0) {
      u.user = u.host;
      u.pass = u.port;
      u.host = i + 1;
      u.port = 0;
    } else if (u.host && u.uri == 0 && url[i] == '/') {
      u.uri = i;
    }
  }
  u.end = i;
#if 0
  printf("[%s] %d %d %d %d %d\n", url, u.user, u.pass, u.host, u.port, u.uri);
#endif
  return u;
}

struct mg_str mg_url_host(const char *url) {
  struct url u = urlparse(url);
  size_t n = u.port  ? u.port - u.host - 1
             : u.uri ? u.uri - u.host
                     : u.end - u.host;
  struct mg_str s = mg_str_n(url + u.host, n);
  return s;
}

const char *mg_url_uri(const char *url) {
  struct url u = urlparse(url);
  return u.uri ? url + u.uri : "/";
}

unsigned short mg_url_port(const char *url) {
  struct url u = urlparse(url);
  unsigned short port = 0;
  if (strncmp(url, "http:", 5) == 0 || strncmp(url, "ws:", 3) == 0) port = 80;
  if (strncmp(url, "wss:", 4) == 0 || strncmp(url, "https:", 6) == 0)
    port = 443;
  if (strncmp(url, "mqtt:", 5) == 0) port = 1883;
  if (strncmp(url, "mqtts:", 6) == 0) port = 8883;
  if (u.port) port = (unsigned short) atoi(url + u.port);
  return port;
}

struct mg_str mg_url_user(const char *url) {
  struct url u = urlparse(url);
  struct mg_str s = mg_str("");
  if (u.user && (u.pass || u.host)) {
    size_t n = u.pass ? u.pass - u.user - 1 : u.host - u.user - 1;
    s = mg_str_n(url + u.user, n);
  }
  return s;
}

struct mg_str mg_url_pass(const char *url) {
  struct url u = urlparse(url);
  struct mg_str s = mg_str_n("", 0UL);
  if (u.pass && u.host) {
    size_t n = u.host - u.pass - 1;
    s = mg_str_n(url + u.pass, n);
  }
  return s;
}

#ifdef MG_ENABLE_LINES
#line 1 "src/util.c"
#endif


#if MG_ARCH == MG_ARCH_UNIX && defined(__APPLE__)
#include <mach/mach_time.h>
#endif

#if MG_ENABLE_CUSTOM_RANDOM
#else
void mg_random(void *buf, size_t len) {
  bool done = false;
  unsigned char *p = (unsigned char *) buf;
#if MG_ARCH == MG_ARCH_ESP32
  while (len--) *p++ = (unsigned char) (esp_random() & 255);
  done = true;
#elif MG_ARCH == MG_ARCH_WIN32
#elif MG_ARCH == MG_ARCH_UNIX
  FILE *fp = fopen("/dev/urandom", "rb");
  if (fp != NULL) {
    if (fread(buf, 1, len, fp) == len) done = true;
    fclose(fp);
  }
#endif
  // If everything above did not work, fallback to a pseudo random generator
  while (!done && len--) *p++ = (unsigned char) (rand() & 255);
}
#endif

bool mg_globmatch(const char *s1, size_t n1, const char *s2, size_t n2) {
  size_t i = 0, j = 0, ni = 0, nj = 0;
  while (i < n1 || j < n2) {
    if (i < n1 && j < n2 && (s1[i] == '?' || s2[j] == s1[i])) {
      i++, j++;
    } else if (i < n1 && (s1[i] == '*' || s1[i] == '#')) {
      ni = i, nj = j + 1, i++;
    } else if (nj > 0 && nj <= n2 && (s1[ni] == '#' || s2[j] != '/')) {
      i = ni, j = nj;
    } else {
      // printf(">>: [%s] [%s] %d %d %d %d\n", s1, s2, i, j, ni, nj);
      return false;
    }
  }
  return true;
}

static size_t mg_nce(const char *s, size_t n, size_t ofs, size_t *koff,
                     size_t *klen, size_t *voff, size_t *vlen) {
  size_t kvlen, kl;
  for (kvlen = 0; ofs + kvlen < n && s[ofs + kvlen] != ',';) kvlen++;
  for (kl = 0; kl < kvlen && s[ofs + kl] != '=';) kl++;
  if (koff != NULL) *koff = ofs;
  if (klen != NULL) *klen = kl;
  if (voff != NULL) *voff = kl < kvlen ? ofs + kl + 1 : 0;
  if (vlen != NULL) *vlen = kl < kvlen ? kvlen - kl - 1 : 0;
  ofs += kvlen + 1;
  return ofs > n ? n : ofs;
}

bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v) {
  size_t koff = 0, klen = 0, voff = 0, vlen = 0, off = 0;
  if (s->ptr == NULL || s->len == 0) return 0;
  off = mg_nce(s->ptr, s->len, 0, &koff, &klen, &voff, &vlen);
  if (k != NULL) *k = mg_str_n(s->ptr + koff, klen);
  if (v != NULL) *v = mg_str_n(s->ptr + voff, vlen);
  *s = mg_str_n(s->ptr + off, s->len - off);
  return off > 0;
}

uint32_t mg_ntohl(uint32_t net) {
  uint8_t data[4] = {0, 0, 0, 0};
  memcpy(&data, &net, sizeof(data));
  return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |
         (((uint32_t) data[1]) << 16) | (((uint32_t) data[0]) << 24);
}

uint16_t mg_ntohs(uint16_t net) {
  uint8_t data[2] = {0, 0};
  memcpy(&data, &net, sizeof(data));
  return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));
}

char *mg_hexdump(const void *buf, size_t len) {
  const unsigned char *p = (const unsigned char *) buf;
  size_t i, idx, n = 0, ofs = 0, dlen = len * 5 + 100;
  char ascii[17] = "", *dst = (char *) calloc(1, dlen);
  if (dst == NULL) return dst;
  for (i = 0; i < len; i++) {
    idx = i % 16;
    if (idx == 0) {
      if (i > 0 && dlen > n)
        n += (size_t) snprintf(dst + n, dlen - n, "  %s\n", ascii);
      if (dlen > n)
        n += (size_t) snprintf(dst + n, dlen - n, "%04x ", (int) (i + ofs));
    }
    if (dlen < n) break;
    n += (size_t) snprintf(dst + n, dlen - n, " %02x", p[i]);
    ascii[idx] = (char) (p[i] < 0x20 || p[i] > 0x7e ? '.' : p[i]);
    ascii[idx + 1] = '\0';
  }
  while (i++ % 16) {
    if (n < dlen) n += (size_t) snprintf(dst + n, dlen - n, "%s", "   ");
  }
  if (n < dlen) n += (size_t) snprintf(dst + n, dlen - n, "  %s\n", ascii);
  if (n > dlen - 1) n = dlen - 1;
  dst[n] = '\0';
  return dst;
}

char *mg_hex(const void *buf, size_t len, char *to) {
  const unsigned char *p = (const unsigned char *) buf;
  static const char *hex = "0123456789abcdef";
  size_t i = 0;
  for (; len--; p++) {
    to[i++] = hex[p[0] >> 4];
    to[i++] = hex[p[0] & 0x0f];
  }
  to[i] = '\0';
  return to;
}

static unsigned char mg_unhex_nimble(unsigned char c) {
  return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')
         : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')
                                  : (unsigned char) (c - 'W');
}

unsigned long mg_unhexn(const char *s, size_t len) {
  unsigned long i = 0, v = 0;
  for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);
  return v;
}

void mg_unhex(const char *buf, size_t len, unsigned char *to) {
  size_t i;
  for (i = 0; i < len; i += 2) {
    to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);
  }
}

int mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap) {
  va_list ap_copy;
  int len;

  va_copy(ap_copy, ap);
  len = vsnprintf(*buf, size, fmt, ap_copy);
  va_end(ap_copy);

  if (len < 0) {
    // eCos and Windows are not standard-compliant and return -1 when
    // the buffer is too small. Keep allocating larger buffers until we
    // succeed or out of memory.
    // LCOV_EXCL_START
    *buf = NULL;
    while (len < 0) {
      free(*buf);
      if (size == 0) size = 5;
      size *= 2;
      if ((*buf = (char *) calloc(1, size)) == NULL) {
        len = -1;
        break;
      }
      va_copy(ap_copy, ap);
      len = vsnprintf(*buf, size - 1, fmt, ap_copy);
      va_end(ap_copy);
    }
    // Microsoft version of vsnprintf() is not always null-terminated, so put
    // the terminator manually
    if (*buf != NULL) (*buf)[len] = 0;
    // LCOV_EXCL_STOP
  } else if (len >= (int) size) {
    /// Standard-compliant code path. Allocate a buffer that is large enough
    if ((*buf = (char *) calloc(1, (size_t) len + 1)) == NULL) {
      len = -1;  // LCOV_EXCL_LINE
    } else {     // LCOV_EXCL_LINE
      va_copy(ap_copy, ap);
      len = vsnprintf(*buf, (size_t) len + 1, fmt, ap_copy);
      va_end(ap_copy);
    }
  }

  return len;
}

int mg_asprintf(char **buf, size_t size, const char *fmt, ...) {
  int ret;
  va_list ap;
  va_start(ap, fmt);
  ret = mg_vasprintf(buf, size, fmt, ap);
  va_end(ap);
  return ret;
}

int64_t mg_to64(struct mg_str str) {
  int64_t result = 0, neg = 1, max = 922337203685477570 /* INT64_MAX/10-10 */;
  size_t i = 0;
  while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\t')) i++;
  if (i < str.len && str.ptr[i] == '-') neg = -1, i++;
  while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {
    if (result > max) return 0;
    result *= 10;
    result += (str.ptr[i] - '0');
    i++;
  }
  return result * neg;
}

uint32_t mg_crc32(uint32_t crc, const char *buf, size_t len) {
  int i;
  crc = ~crc;
  while (len--) {
    crc ^= *(unsigned char *) buf++;
    for (i = 0; i < 8; i++) crc = crc & 1 ? (crc >> 1) ^ 0xedb88320 : crc >> 1;
  }
  return ~crc;
}

static int isbyte(int n) {
  return n >= 0 && n <= 255;
}

static int parse_net(const char *spec, uint32_t *net, uint32_t *mask) {
  int n, a, b, c, d, slash = 32, len = 0;
  if ((sscanf(spec, "%d.%d.%d.%d/%d%n", &a, &b, &c, &d, &slash, &n) == 5 ||
       sscanf(spec, "%d.%d.%d.%d%n", &a, &b, &c, &d, &n) == 4) &&
      isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && slash >= 0 &&
      slash < 33) {
    len = n;
    *net = ((uint32_t) a << 24) | ((uint32_t) b << 16) | ((uint32_t) c << 8) |
           (uint32_t) d;
    *mask = slash ? (uint32_t) (0xffffffffU << (32 - slash)) : (uint32_t) 0;
  }
  return len;
}

int mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip) {
  struct mg_str k, v;
  int allowed = acl.len == 0 ? '+' : '-';  // If any ACL is set, deny by default
  while (mg_commalist(&acl, &k, &v)) {
    uint32_t net, mask;
    if (k.ptr[0] != '+' && k.ptr[0] != '-') return -1;
    if (parse_net(&k.ptr[1], &net, &mask) == 0) return -2;
    if ((mg_ntohl(remote_ip) & mask) == net) allowed = k.ptr[0];
  }
  return allowed == '+';
}

int64_t mg_millis(void) {
#if MG_ARCH == MG_ARCH_WIN32
  return GetTickCount();
#elif MG_ARCH == MG_ARCH_ESP32
  return esp_timer_get_time() / 1000;
#elif MG_ARCH == MG_ARCH_ESP8266
  return xTaskGetTickCount() * portTICK_PERIOD_MS;
#elif MG_ARCH == MG_ARCH_FREERTOS_TCP || MG_ARCH == MG_ARCH_FREERTOS_LWIP
  return xTaskGetTickCount() * portTICK_PERIOD_MS;
#elif MG_ARCH == MG_ARCH_AZURERTOS
  return tx_time_get() * (1000 /* MS per SEC */ / TX_TIMER_TICKS_PER_SECOND);
#elif MG_ARCH == MG_ARCH_UNIX && defined(__APPLE__)
  uint64_t ticks = mach_absolute_time();
  static mach_timebase_info_data_t timebase;
  mach_timebase_info(&timebase);
  double ticks_to_nanos = (double) timebase.numer / timebase.denom;
  uint64_t uptime_nanos = (uint64_t) (ticks_to_nanos * ticks);
  return (int64_t) (uptime_nanos / 1000000);
#elif MG_ARCH == MG_ARCH_UNIX
  struct timespec ts;
#ifdef _POSIX_MONOTONIC_CLOCK
#ifdef CLOCK_MONOTONIC_RAW
  clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
#else
  clock_gettime(CLOCK_MONOTONIC, &ts);
#endif
#else
  clock_gettime(CLOCK_REALTIME, &ts);
#endif
  return ((int64_t) ts.tv_sec * 1000 + (int64_t) ts.tv_nsec / 1000000);
#else
  return time(NULL) * 1000;
#endif
}

#ifdef MG_ENABLE_LINES
#line 1 "src/ws.c"
#endif









struct ws_msg {
  uint8_t flags;
  size_t header_len;
  size_t data_len;
};

static void ws_handshake(struct mg_connection *c, const struct mg_str *wskey,
                         const struct mg_str *wsproto, const char *fmt,
                         va_list ap) {
  const char *magic = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  unsigned char sha[20], b64_sha[30];
  char mem[128], *buf = mem;

  mg_sha1_ctx sha_ctx;
  mg_sha1_init(&sha_ctx);
  mg_sha1_update(&sha_ctx, (unsigned char *) wskey->ptr, wskey->len);
  mg_sha1_update(&sha_ctx, (unsigned char *) magic, 36);
  mg_sha1_final(sha, &sha_ctx);
  mg_base64_encode(sha, sizeof(sha), (char *) b64_sha);
  buf[0] = '\0';
  if (fmt != NULL) mg_vasprintf(&buf, sizeof(mem), fmt, ap);
  mg_printf(c,
            "HTTP/1.1 101 Switching Protocols\r\n"
            "Upgrade: websocket\r\n"
            "Connection: Upgrade\r\n"
            "Sec-WebSocket-Accept: %s\r\n"
            "%s",
            b64_sha, buf);
  if (buf != mem) free(buf);
  if (wsproto != NULL) {
    mg_printf(c, "Sec-WebSocket-Protocol: %.*s\r\n", (int) wsproto->len,
              wsproto->ptr);
  }
  mg_send(c, "\r\n", 2);
}

static size_t ws_process(uint8_t *buf, size_t len, struct ws_msg *msg) {
  size_t i, n = 0, mask_len = 0;
  memset(msg, 0, sizeof(*msg));
  if (len >= 2) {
    n = buf[1] & 0x7f;                // Frame length
    mask_len = buf[1] & 128 ? 4 : 0;  // last bit is a mask bit
    msg->flags = buf[0];
    if (n < 126 && len >= mask_len) {
      msg->data_len = n;
      msg->header_len = 2 + mask_len;
    } else if (n == 126 && len >= 4 + mask_len) {
      msg->header_len = 4 + mask_len;
      msg->data_len = mg_ntohs(*(uint16_t *) &buf[2]);
    } else if (len >= 10 + mask_len) {
      msg->header_len = 10 + mask_len;
      msg->data_len =
          (size_t) (((uint64_t) mg_ntohl(*(uint32_t *) &buf[2])) << 32) +
          mg_ntohl(*(uint32_t *) &buf[6]);
    }
  }
  // Sanity check, and integer overflow protection for the boundary check below
  // data_len should not be larger than 1 Gb
  if (msg->data_len > 1024 * 1024 * 1024) return 0;
  if (msg->header_len + msg->data_len > len) return 0;
  if (mask_len > 0) {
    uint8_t *p = buf + msg->header_len, *m = p - mask_len;
    for (i = 0; i < msg->data_len; i++) p[i] ^= m[i & 3];
  }
  return msg->header_len + msg->data_len;
}

static size_t mkhdr(size_t len, int op, bool is_client, uint8_t *buf) {
  size_t n = 0;
  buf[0] = (uint8_t) (op | 128);
  if (len < 126) {
    buf[1] = (unsigned char) len;
    n = 2;
  } else if (len < 65536) {
    uint16_t tmp = mg_htons((uint16_t) len);
    buf[1] = 126;
    memcpy(&buf[2], &tmp, sizeof(tmp));
    n = 4;
  } else {
    uint32_t tmp;
    buf[1] = 127;
    tmp = mg_htonl((uint32_t) ((uint64_t) len >> 32));
    memcpy(&buf[2], &tmp, sizeof(tmp));
    tmp = mg_htonl((uint32_t) (len & 0xffffffff));
    memcpy(&buf[6], &tmp, sizeof(tmp));
    n = 10;
  }
  if (is_client) {
    buf[1] |= 1 << 7;  // Set masking flag
    mg_random(&buf[n], 4);
    n += 4;
  }
  return n;
}

static void mg_ws_mask(struct mg_connection *c, size_t len) {
  if (c->is_client && c->send.buf != NULL) {
    size_t i;
    uint8_t *p = c->send.buf + c->send.len - len, *mask = p - 4;
    for (i = 0; i < len; i++) p[i] ^= mask[i & 3];
  }
}

size_t mg_ws_send(struct mg_connection *c, const char *buf, size_t len,
                  int op) {
  uint8_t header[14];
  size_t header_len = mkhdr(len, op, c->is_client, header);
  mg_send(c, header, header_len);
  LOG(LL_VERBOSE_DEBUG, ("WS out: %d [%.*s]", (int) len, (int) len, buf));
  mg_send(c, buf, len);
  mg_ws_mask(c, len);
  return header_len + len;
}

static void mg_ws_cb(struct mg_connection *c, int ev, void *ev_data,
                     void *fn_data) {
  struct ws_msg msg;
  size_t ofs = (size_t) c->pfn_data;

  // assert(ofs < c->recv.len);
  if (ev == MG_EV_READ) {
    if (!c->is_websocket && c->is_client) {
      int n = mg_http_get_request_len(c->recv.buf, c->recv.len);
      if (n < 0) {
        c->is_closing = 1;  // Some just, not an HTTP request
      } else if (n > 0) {
        if (n < 15 || memcmp(c->recv.buf + 9, "101", 3) != 0) {
          LOG(LL_ERROR,
              ("%lu WS handshake error: %.*s", c->id, 15, c->recv.buf));
          c->is_closing = 1;
        } else {
          struct mg_http_message hm;
          mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);
          c->is_websocket = 1;
          mg_call(c, MG_EV_WS_OPEN, &hm);
        }
        mg_iobuf_del(&c->recv, 0, (size_t) n);
      } else {
        return;  // A request is not yet received
      }
    }

    while (ws_process(c->recv.buf + ofs, c->recv.len - ofs, &msg) > 0) {
      char *s = (char *) c->recv.buf + ofs + msg.header_len;
      struct mg_ws_message m = {{s, msg.data_len}, msg.flags};
      size_t len = msg.header_len + msg.data_len;
      uint8_t final = msg.flags & 128, op = msg.flags & 15;
      // LOG(LL_VERBOSE_DEBUG, ("fin %d op %d len %d [%.*s]", final, op,
      //                       (int) m.data.len, (int) m.data.len, m.data.ptr));
      switch (op) {
        case WEBSOCKET_OP_CONTINUE:
          mg_call(c, MG_EV_WS_CTL, &m);
          break;
        case WEBSOCKET_OP_PING:
          LOG(LL_DEBUG, ("%s", "WS PONG"));
          mg_ws_send(c, s, msg.data_len, WEBSOCKET_OP_PONG);
          mg_call(c, MG_EV_WS_CTL, &m);
          break;
        case WEBSOCKET_OP_PONG:
          mg_call(c, MG_EV_WS_CTL, &m);
          break;
        case WEBSOCKET_OP_TEXT:
        case WEBSOCKET_OP_BINARY:
          if (final) mg_call(c, MG_EV_WS_MSG, &m);
          break;
        case WEBSOCKET_OP_CLOSE:
          LOG(LL_DEBUG, ("%lu Got WS CLOSE", c->id));
          mg_call(c, MG_EV_WS_CTL, &m);
          c->is_closing = 1;
          break;
        default:
          // Per RFC6455, close conn when an unknown op is recvd
          mg_error(c, "unknown WS op %d", op);
          break;
      }

      // Handle fragmented frames: strip header, keep in c->recv
      if (final == 0 || op == 0) {
        if (op) ofs++, len--, msg.header_len--;       // First frame
        mg_iobuf_del(&c->recv, ofs, msg.header_len);  // Strip header
        len -= msg.header_len;
        ofs += len;
        c->pfn_data = (void *) ofs;
        // LOG(LL_INFO, ("FRAG %d [%.*s]", (int) ofs, (int) ofs, c->recv.buf));
      }
      // Remove non-fragmented frame
      if (final && op) mg_iobuf_del(&c->recv, ofs, len);
      // Last chunk of the fragmented frame
      if (final && !op) {
        m.flags = c->recv.buf[0];
        m.data = mg_str_n((char *) &c->recv.buf[1], (size_t) (ofs - 1));
        mg_call(c, MG_EV_WS_MSG, &m);
        mg_iobuf_del(&c->recv, 0, ofs);
        ofs = 0;
        c->pfn_data = NULL;
      }
    }
  }
  (void) fn_data;
  (void) ev_data;
}

struct mg_connection *mg_ws_connect(struct mg_mgr *mgr, const char *url,
                                    mg_event_handler_t fn, void *fn_data,
                                    const char *fmt, ...) {
  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);
  if (c != NULL) {
    char nonce[16], key[30], mem1[128], mem2[256], *buf1 = mem1, *buf2 = mem2;
    struct mg_str host = mg_url_host(url);
    int n1 = 0, n2 = 0;
    if (fmt != NULL) {
      va_list ap;
      va_start(ap, fmt);
      n1 = mg_vasprintf(&buf1, sizeof(mem1), fmt, ap);
      va_end(ap);
    }
    // Send handshake request
    // mg_url_host(url, host, sizeof(host));
    mg_random(nonce, sizeof(nonce));
    mg_base64_encode((unsigned char *) nonce, sizeof(nonce), key);
    // LOG(LL_DEBUG, "%p [%s]", uri, uri == NULL ? "???" : uri);
    n2 = mg_asprintf(&buf2, sizeof(mem2),
                     "GET %s HTTP/1.1\r\n"
                     "Upgrade: websocket\r\n"
                     "Host: %.*s\r\n"
                     "Connection: Upgrade\r\n"
                     "%.*s"
                     "Sec-WebSocket-Version: 13\r\n"
                     "Sec-WebSocket-Key: %s\r\n"
                     "\r\n",
                     mg_url_uri(url), (int) host.len, host.ptr, n1, buf1, key);
    mg_send(c, buf2, n2 > 0 ? (size_t) n2 : 0);
    if (buf1 != mem1) free(buf1);
    if (buf2 != mem2) free(buf2);
    c->pfn = mg_ws_cb;
    c->pfn_data = NULL;
  }
  return c;
}

void mg_ws_upgrade(struct mg_connection *c, struct mg_http_message *hm,
                   const char *fmt, ...) {
  struct mg_str *wskey = mg_http_get_header(hm, "Sec-WebSocket-Key");
  c->pfn = mg_ws_cb;
  c->pfn_data = NULL;
  if (wskey == NULL) {
    mg_http_reply(c, 426, "", "WS upgrade expected\n");
    c->is_draining = 1;
  } else {
    struct mg_str *wsproto = mg_http_get_header(hm, "Sec-WebSocket-Protocol");
    va_list ap;
    va_start(ap, fmt);
    ws_handshake(c, wskey, wsproto, fmt, ap);
    va_end(ap);
    c->is_websocket = 1;
    mg_call(c, MG_EV_WS_OPEN, hm);
  }
}

size_t mg_ws_wrap(struct mg_connection *c, size_t len, int op) {
  uint8_t header[14], *p;
  size_t header_len = mkhdr(len, op, c->is_client, header);

  // NOTE: order of operations is important!
  mg_iobuf_add(&c->send, c->send.len, NULL, header_len, MG_IO_SIZE);
  p = &c->send.buf[c->send.len - len];         // p points to data
  memmove(p, p - header_len, len);             // Shift data
  memcpy(p - header_len, header, header_len);  // Prepend header
  mg_ws_mask(c, len);                          // Mask data

  return c->send.len;
}

```

`deps/mongoose/mongoose.h`:

```h
// Copyright (c) 2004-2013 Sergey Lyubka
// Copyright (c) 2013-2021 Cesanta Software Limited
// All rights reserved
//
// This software is dual-licensed: you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation. For the terms of this
// license, see http://www.gnu.org/licenses/
//
// You are free to use this software under the terms of the GNU General
// Public License, but WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// Alternatively, you can license this software under a commercial
// license, as set out in https://www.mongoose.ws/licensing/

#ifndef MONGOOSE_H
#define MONGOOSE_H

#define MG_VERSION "7.6"

#ifdef __cplusplus
extern "C" {
#endif


#define MG_ARCH_CUSTOM 0
#define MG_ARCH_UNIX 1
#define MG_ARCH_WIN32 2
#define MG_ARCH_ESP32 3
#define MG_ARCH_ESP8266 4
#define MG_ARCH_FREERTOS_TCP 5
#define MG_ARCH_FREERTOS_LWIP 6
#define MG_ARCH_AZURERTOS 7

#if !defined(MG_ARCH)
#if defined(__unix__) || defined(__APPLE__)
#define MG_ARCH MG_ARCH_UNIX
#elif defined(_WIN32)
#define MG_ARCH MG_ARCH_WIN32
#elif defined(ICACHE_FLASH) || defined(ICACHE_RAM_ATTR)
#define MG_ARCH MG_ARCH_ESP8266
#elif defined(ESP_PLATFORM)
#define MG_ARCH MG_ARCH_ESP32
#elif defined(FREERTOS_IP_H)
#define MG_ARCH MG_ARCH_FREERTOS_TCP
#elif defined(AZURE_RTOS_THREADX)
#define MG_ARCH MG_ARCH_AZURERTOS
#endif

#if !defined(MG_ARCH)
#error "MG_ARCH is not specified and we couldn't guess it."
#endif
#endif  // !defined(MG_ARCH)

#if !defined(PRINTF_LIKE)
#if defined(__GNUC__) || defined(__clang__) || defined(__TI_COMPILER_VERSION__)
#define PRINTF_LIKE(f, a) __attribute__((format(printf, f, a)))
#else
#define PRINTF_LIKE(f, a)
#endif
#endif

#if MG_ARCH == MG_ARCH_CUSTOM
#include <mongoose_custom.h>
#endif









#if MG_ARCH == MG_ARCH_AZURERTOS

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <time.h>

#include <fx_api.h>
#include <tx_api.h>

#include <nx_api.h>
#include <nx_bsd.h>
#include <nx_port.h>
#include <tx_port.h>

#ifdef __REDLIB__
#define va_copy(d, s) __builtin_va_copy(d, s)
#endif

#define PATH_MAX FX_MAXIMUM_PATH
#define MG_DIRSEP '\\'

#define socklen_t int
#define closesocket(x) soc_close(x)
#define gmtime_r(a, b) gmtime(a)
#define MG_INT64_FMT "%lld"

static __inline struct tm *localtime_r(const time_t *t, struct tm *tm) {
  struct tm *x = localtime(t);
  *tm = *x;
  return tm;
}

#undef FOPEN_MAX

#endif


#if MG_ARCH == MG_ARCH_ESP32

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>

#define MG_PATH_MAX 128
#define MG_ENABLE_DIRLIST 1

#endif


#if MG_ARCH == MG_ARCH_ESP8266

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <time.h>

#include <esp_system.h>

#define MG_PATH_MAX 128
#define MG_ENABLE_DIRLIST 1

#endif


#if MG_ARCH == MG_ARCH_FREERTOS_LWIP

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#if defined(__GNUC__)
#include <sys/stat.h>
#include <sys/time.h>
#else
struct timeval {
  time_t tv_sec;
  long tv_usec;
};
#endif

#include <FreeRTOS.h>
#include <task.h>

#include <lwip/sockets.h>

#if LWIP_SOCKET != 1
// Sockets support disabled in LWIP by default
#error Set LWIP_SOCKET variable to 1 (in lwipopts.h)
#endif

#if LWIP_POSIX_SOCKETS_IO_NAMES != 0
// LWIP_POSIX_SOCKETS_IO_NAMES must be disabled in posix-compatible OS
// enviroment (freertos mimics to one) otherwise names like `read` and `write`
// conflict
#error LWIP_POSIX_SOCKETS_IO_NAMES must be set to 0 (in lwipopts.h) for FreeRTOS
#endif

#define MG_INT64_FMT "%lld"
#define MG_DIRSEP '/'

// Re-route calloc/free to the FreeRTOS's functions, don't use stdlib
static inline void *mg_calloc(int cnt, size_t size) {
  void *p = pvPortMalloc(cnt * size);
  if (p != NULL) memset(p, 0, size);
  return p;
}
#define calloc(a, b) mg_calloc((a), (b))
#define free(a) vPortFree(a)
#define malloc(a) pvPortMalloc(a)
#define gmtime_r(a, b) gmtime(a)
#define mkdir(a, b) (-1)

#endif  // MG_ARCH == MG_ARCH_FREERTOS_LWIP


#if MG_ARCH == MG_ARCH_FREERTOS_TCP

#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>

#include <FreeRTOS.h>
#include <FreeRTOS_IP.h>
#include <FreeRTOS_Sockets.h>
#include <task.h>

// Why FreeRTOS-TCP did not implement a clean BSD API, but its own thing
// with FreeRTOS_ prefix, is beyond me
#define IPPROTO_TCP FREERTOS_IPPROTO_TCP
#define IPPROTO_UDP FREERTOS_IPPROTO_UDP
#define AF_INET FREERTOS_AF_INET
#define SOCK_STREAM FREERTOS_SOCK_STREAM
#define SOCK_DGRAM FREERTOS_SOCK_DGRAM
#define SO_BROADCAST 0
#define SO_ERROR 0
#define SOL_SOCKET 0
#define SO_REUSEADDR 0
#define sockaddr_in freertos_sockaddr
#define sockaddr freertos_sockaddr
#define accept(a, b, c) FreeRTOS_accept((a), (b), (c))
#define connect(a, b, c) FreeRTOS_connect((a), (b), (c))
#define bind(a, b, c) FreeRTOS_bind((a), (b), (c))
#define listen(a, b) FreeRTOS_listen((a), (b))
#define socket(a, b, c) FreeRTOS_socket((a), (b), (c))
#define send(a, b, c, d) FreeRTOS_send((a), (b), (c), (d))
#define recv(a, b, c, d) FreeRTOS_recv((a), (b), (c), (d))
#define setsockopt(a, b, c, d, e) FreeRTOS_setsockopt((a), (b), (c), (d), (e))
#define sendto(a, b, c, d, e, f) FreeRTOS_sendto((a), (b), (c), (d), (e), (f))
#define recvfrom(a, b, c, d, e, f) \
  FreeRTOS_recvfrom((a), (b), (c), (d), (e), (f))
#define closesocket(x) FreeRTOS_closesocket(x)
#define gethostbyname(x) FreeRTOS_gethostbyname(x)
#define getsockname(a, b, c) (-1)

// Re-route calloc/free to the FreeRTOS's functions, don't use stdlib
static inline void *mg_calloc(int cnt, size_t size) {
  void *p = pvPortMalloc(cnt * size);
  if (p != NULL) memset(p, 0, size);
  return p;
}
#define calloc(a, b) mg_calloc((a), (b))
#define free(a) vPortFree(a)
#define malloc(a) pvPortMalloc(a)
#define mkdir(a, b) (-1)

#define gmtime_r(a, b) gmtime(a)

#if !defined(__GNUC__)
// copied from GCC on ARM; for some reason useconds are signed
struct timeval {
  time_t tv_sec;
  long tv_usec;
};
#endif

#ifndef EINPROGRESS
#define EINPROGRESS pdFREERTOS_ERRNO_EINPROGRESS
#endif
#ifndef EWOULDBLOCK
#define EWOULDBLOCK pdFREERTOS_ERRNO_EWOULDBLOCK
#endif
#ifndef EAGAIN
#define EAGAIN pdFREERTOS_ERRNO_EAGAIN
#endif
#ifndef EINTR
#define EINTR pdFREERTOS_ERRNO_EINTR
#endif

#endif  // MG_ARCH == MG_ARCH_FREERTOS_TCP


#if MG_ARCH == MG_ARCH_UNIX

#define _DARWIN_UNLIMITED_SELECT 1  // No limit on file descriptors

#include <arpa/inet.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <limits.h>
#include <netdb.h>
#include <netinet/tcp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

#define MG_INT64_FMT "%" PRId64

#ifndef MG_ENABLE_DIRLIST
#define MG_ENABLE_DIRLIST 1
#endif

#endif


#if MG_ARCH == MG_ARCH_WIN32

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef _WINSOCK_DEPRECATED_NO_WARNINGS
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#endif

#include <ctype.h>
#include <direct.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>

#if defined(_MSC_VER) && _MSC_VER < 1700
#define __func__ ""
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
typedef unsigned char uint8_t;
typedef char int8_t;
typedef unsigned short uint16_t;
typedef short int16_t;
typedef unsigned int uint32_t;
typedef int int32_t;
typedef enum { false = 0, true = 1 } bool;
#else
#include <stdbool.h>
#include <stdint.h>
#include <ws2tcpip.h>
#endif

#include <winsock2.h>

// Protect from calls like std::snprintf in app code
// See https://github.com/cesanta/mongoose/issues/1047
#ifndef __cplusplus
#define snprintf _snprintf
#define vsnprintf _vsnprintf
#ifndef strdup  // For MSVC with _DEBUG, see #1359
#define strdup(x) _strdup(x)
#endif
#endif

typedef int socklen_t;
#define MG_DIRSEP '\\'
#ifndef PATH_MAX
#define PATH_MAX MAX_PATH
#endif
#ifndef EINPROGRESS
#define EINPROGRESS WSAEINPROGRESS
#endif
#ifndef EWOULDBLOCK
#define EWOULDBLOCK WSAEWOULDBLOCK
#endif

#define realpath(a, b) _fullpath((b), (a), MG_PATH_MAX)
#define sleep(x) Sleep(x)
#define mkdir(a, b) _mkdir(a)

#ifndef va_copy
#ifdef __va_copy
#define va_copy __va_copy
#else
#define va_copy(x, y) (x) = (y)
#endif
#endif
#ifndef S_ISDIR
#define S_ISDIR(x) (((x) &_S_IFMT) == _S_IFDIR)
#endif

#define MG_INT64_FMT "%I64d"

#ifndef MG_ENABLE_DIRLIST
#define MG_ENABLE_DIRLIST 1
#endif

// https://lgtm.com/rules/2154840805/ -gmtime, localtime, ctime and asctime
static __inline struct tm *gmtime_r(const time_t *t, struct tm *tm) {
  struct tm *x = gmtime(t);
  *tm = *x;
  return tm;
}

static __inline struct tm *localtime_r(const time_t *t, struct tm *tm) {
  struct tm *x = localtime(t);
  *tm = *x;
  return tm;
}

#endif


#ifndef MG_ENABLE_FATFS
#define MG_ENABLE_FATFS 0
#endif

#ifndef MG_FATFS_ROOT
#define MG_FATFS_ROOT "/"
#endif

#ifndef MG_FATFS_BSIZE
#define MG_FATFS_BSIZE 64
#endif

#ifndef MG_ENABLE_SOCKET
#define MG_ENABLE_SOCKET 1
#endif

#ifndef MG_ENABLE_MBEDTLS
#define MG_ENABLE_MBEDTLS 0
#endif

#ifndef MG_ENABLE_OPENSSL
#define MG_ENABLE_OPENSSL 0
#endif

#ifndef MG_ENABLE_CUSTOM_TLS
#define MG_ENABLE_CUSTOM_TLS 0
#endif

#ifndef MG_ENABLE_SSI
#define MG_ENABLE_SSI 1
#endif

#ifndef MG_ENABLE_IPV6
#define MG_ENABLE_IPV6 0
#endif

#ifndef MG_ENABLE_LOG
#define MG_ENABLE_LOG 1
#endif

#ifndef MG_ENABLE_MD5
#define MG_ENABLE_MD5 0
#endif

// Set MG_ENABLE_WINSOCK=0 for Win32 builds with external IP stack (like LWIP)
#ifndef MG_ENABLE_WINSOCK
#define MG_ENABLE_WINSOCK 1
#endif

#ifndef MG_ENABLE_DIRLIST
#define MG_ENABLE_DIRLIST 0
#endif

#ifndef MG_ENABLE_CUSTOM_RANDOM
#define MG_ENABLE_CUSTOM_RANDOM 0
#endif

#ifndef MG_ENABLE_PACKED_FS
#define MG_ENABLE_PACKED_FS 0
#endif

// Granularity of the send/recv IO buffer growth
#ifndef MG_IO_SIZE
#define MG_IO_SIZE 2048
#endif

// Maximum size of the recv IO buffer
#ifndef MG_MAX_RECV_BUF_SIZE
#define MG_MAX_RECV_BUF_SIZE (3 * 1024 * 1024)
#endif

#ifndef MG_MAX_HTTP_HEADERS
#define MG_MAX_HTTP_HEADERS 40
#endif

#ifndef MG_HTTP_INDEX
#define MG_HTTP_INDEX "index.html"
#endif

#ifndef MG_PATH_MAX
#ifdef PATH_MAX
#define MG_PATH_MAX PATH_MAX
#else
#define MG_PATH_MAX 128
#endif
#endif

#ifndef MG_SOCK_LISTEN_BACKLOG_SIZE
#define MG_SOCK_LISTEN_BACKLOG_SIZE 128
#endif

#ifndef MG_DIRSEP
#define MG_DIRSEP '/'
#endif

#ifndef MG_INT64_FMT
#define MG_INT64_FMT "%lld"
#endif

#ifndef MG_ENABLE_FILE
#if defined(FOPEN_MAX)
#define MG_ENABLE_FILE 1
#else
#define MG_ENABLE_FILE 0
#endif
#endif




struct mg_str {
  const char *ptr;  // Pointer to string data
  size_t len;       // String len
};

#define MG_NULL_STR \
  { NULL, 0 }

// Using macro to avoid shadowing C++ struct constructor, see #1298
#define mg_str(s) mg_str_s(s)

struct mg_str mg_str(const char *s);
struct mg_str mg_str_n(const char *s, size_t n);
int mg_lower(const char *s);
int mg_ncasecmp(const char *s1, const char *s2, size_t len);
int mg_casecmp(const char *s1, const char *s2);
int mg_vcmp(const struct mg_str *s1, const char *s2);
int mg_vcasecmp(const struct mg_str *str1, const char *str2);
int mg_strcmp(const struct mg_str str1, const struct mg_str str2);
struct mg_str mg_strstrip(struct mg_str s);
struct mg_str mg_strdup(const struct mg_str s);
const char *mg_strstr(const struct mg_str haystack, const struct mg_str needle);





#if MG_ENABLE_LOG
#define LOG(level, args)                                                   \
  do {                                                                     \
    if (mg_log_prefix((level), __FILE__, __LINE__, __func__)) mg_log args; \
  } while (0)
enum { LL_NONE, LL_ERROR, LL_INFO, LL_DEBUG, LL_VERBOSE_DEBUG };
bool mg_log_prefix(int ll, const char *file, int line, const char *fname);
void mg_log(const char *fmt, ...) PRINTF_LIKE(1, 2);
void mg_log_set(const char *spec);
void mg_log_set_callback(void (*fn)(const void *, size_t, void *), void *param);
#else
#define LOG(level, args) (void) 0
#define mg_log_set(x) (void) (x)
#endif




struct mg_timer {
  int64_t period_ms;        // Timer period in milliseconds
  int64_t expire;           // Expiration timestamp in milliseconds
  unsigned flags;           // Possible flags values below
#define MG_TIMER_REPEAT 1   // Call function periodically, otherwise run once
#define MG_TIMER_RUN_NOW 2  // Call immediately when timer is set
  void (*fn)(void *);       // Function to call
  void *arg;                // Function argument
  struct mg_timer *next;    // Linkage in g_timers list
};

extern struct mg_timer *g_timers;  // Global list of timers

void mg_timer_init(struct mg_timer *, int64_t, unsigned, void (*)(void *),
                   void *);
void mg_timer_free(struct mg_timer *);
void mg_timer_poll(int64_t current_time_ms);





enum { MG_FS_READ = 1, MG_FS_WRITE = 2, MG_FS_DIR = 4 };

// Filesystem API functions
// stat() returns MG_FS_* flags and populates file size and modification time
// list() calls fn() for every directory entry, allowing to list a directory
struct mg_fs {
  int (*stat)(const char *path, size_t *size, time_t *mtime);
  void (*list)(const char *path, void (*fn)(const char *, void *), void *);
  void *(*open)(const char *path, int flags);              // Open file
  void (*close)(void *fd);                                 // Close file
  size_t (*read)(void *fd, void *buf, size_t len);         // Read file
  size_t (*write)(void *fd, const void *buf, size_t len);  // Write file
  size_t (*seek)(void *fd, size_t offset);                 // Set file position
  bool (*rename)(const char *from, const char *to);        // Rename
  bool (*remove)(const char *path);                        // Delete file
  bool (*mkd)(const char *path);                           // Create directory
};

extern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek
extern struct mg_fs mg_fs_packed;  // Packed FS, see examples/complete
extern struct mg_fs mg_fs_fat;     // FAT FS

// File descriptor
struct mg_fd {
  void *fd;
  struct mg_fs *fs;
};

struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags);
void mg_fs_close(struct mg_fd *fd);
char *mg_file_read(struct mg_fs *fs, const char *path, size_t *size);
bool mg_file_write(struct mg_fs *fs, const char *path, const void *, size_t);
bool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...);






void mg_random(void *buf, size_t len);
bool mg_globmatch(const char *pattern, size_t plen, const char *s, size_t n);
bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v);
uint16_t mg_ntohs(uint16_t net);
uint32_t mg_ntohl(uint32_t net);
uint32_t mg_crc32(uint32_t crc, const char *buf, size_t len);
char *mg_hexdump(const void *buf, size_t len);
char *mg_hex(const void *buf, size_t len, char *dst);
void mg_unhex(const char *buf, size_t len, unsigned char *to);
unsigned long mg_unhexn(const char *s, size_t len);
int mg_asprintf(char **buf, size_t size, const char *fmt, ...);
int mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap);
int mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip);
int64_t mg_to64(struct mg_str str);
int64_t mg_millis(void);

#define mg_htons(x) mg_ntohs(x)
#define mg_htonl(x) mg_ntohl(x)

#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif
#endif

// Expands to a string representation of its argument: e.g.
// MG_STRINGIFY_LITERAL(5) expands to "5"
#if !defined(_MSC_VER) || _MSC_VER >= 1900
#define MG_STRINGIFY_LITERAL(...) #__VA_ARGS__
#else
#define MG_STRINGIFY_LITERAL(x) #x
#endif
// Expands to a string representation of its argument, which can be a macro:
// #define FOO 123
// MG_STRINGIFY_MACRO(FOO)  // Expands to 123
#define MG_STRINGIFY_MACRO(x) MG_STRINGIFY_LITERAL(x)

// Linked list management macros
#define LIST_ADD_HEAD(type_, head_, elem_) \
  do {                                     \
    (elem_)->next = (*head_);              \
    *(head_) = (elem_);                    \
  } while (0)

#define LIST_ADD_TAIL(type_, head_, elem_) \
  do {                                     \
    type_ **h = head_;                     \
    while (*h != NULL) h = &(*h)->next;    \
    *h = (elem_);                          \
  } while (0)

#define LIST_DELETE(type_, head_, elem_)   \
  do {                                     \
    type_ **h = head_;                     \
    while (*h != (elem_)) h = &(*h)->next; \
    *h = (elem_)->next;                    \
  } while (0)



unsigned short mg_url_port(const char *url);
int mg_url_is_ssl(const char *url);
struct mg_str mg_url_host(const char *url);
struct mg_str mg_url_user(const char *url);
struct mg_str mg_url_pass(const char *url);
const char *mg_url_uri(const char *url);


#include <stddef.h>

struct mg_iobuf {
  unsigned char *buf;  // Pointer to stored data
  size_t size;         // Total size available
  size_t len;          // Current number of bytes
};

int mg_iobuf_init(struct mg_iobuf *, size_t);
int mg_iobuf_resize(struct mg_iobuf *, size_t);
void mg_iobuf_free(struct mg_iobuf *);
size_t mg_iobuf_add(struct mg_iobuf *, size_t, const void *, size_t, size_t);
size_t mg_iobuf_del(struct mg_iobuf *, size_t ofs, size_t len);

int mg_base64_update(unsigned char p, char *to, int len);
int mg_base64_final(char *to, int len);
int mg_base64_encode(const unsigned char *p, int n, char *to);
int mg_base64_decode(const char *src, int n, char *dst);




typedef struct {
  uint32_t buf[4];
  uint32_t bits[2];
  unsigned char in[64];
} mg_md5_ctx;

void mg_md5_init(mg_md5_ctx *c);
void mg_md5_update(mg_md5_ctx *c, const unsigned char *data, size_t len);
void mg_md5_final(mg_md5_ctx *c, unsigned char[16]);




typedef struct {
  uint32_t state[5];
  uint32_t count[2];
  unsigned char buffer[64];
} mg_sha1_ctx;

void mg_sha1_init(mg_sha1_ctx *);
void mg_sha1_update(mg_sha1_ctx *, const unsigned char *data, size_t len);
void mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *);
void mg_hmac_sha1(const unsigned char *key, size_t key_len,
                  const unsigned char *text, size_t text_len,
                  unsigned char out[20]);


struct mg_connection;
typedef void (*mg_event_handler_t)(struct mg_connection *, int ev,
                                   void *ev_data, void *fn_data);
void mg_call(struct mg_connection *c, int ev, void *ev_data);
void mg_error(struct mg_connection *c, const char *fmt, ...);

enum {
  MG_EV_ERROR,       // Error                        char *error_message
  MG_EV_OPEN,        // Connection created           NULL
  MG_EV_POLL,        // mg_mgr_poll iteration        int64_t *milliseconds
  MG_EV_RESOLVE,     // Host name is resolved        NULL
  MG_EV_CONNECT,     // Connection established       NULL
  MG_EV_ACCEPT,      // Connection accepted          NULL
  MG_EV_READ,        // Data received from socket    struct mg_str *
  MG_EV_WRITE,       // Data written to socket       long *bytes_written
  MG_EV_CLOSE,       // Connection closed            NULL
  MG_EV_HTTP_MSG,    // HTTP request/response        struct mg_http_message *
  MG_EV_HTTP_CHUNK,  // HTTP chunk (partial msg)     struct mg_http_message *
  MG_EV_WS_OPEN,     // Websocket handshake done     struct mg_http_message *
  MG_EV_WS_MSG,      // Websocket msg, text or bin   struct mg_ws_message *
  MG_EV_WS_CTL,      // Websocket control msg        struct mg_ws_message *
  MG_EV_MQTT_CMD,    // MQTT low-level command       struct mg_mqtt_message *
  MG_EV_MQTT_MSG,    // MQTT PUBLISH received        struct mg_mqtt_message *
  MG_EV_MQTT_OPEN,   // MQTT CONNACK received        int *connack_status_code
  MG_EV_SNTP_TIME,   // SNTP time received           int64_t *milliseconds
  MG_EV_USER,        // Starting ID for user events
};







struct mg_dns {
  const char *url;          // DNS server URL
  struct mg_connection *c;  // DNS server connection
};

struct mg_addr {
  uint16_t port;    // TCP or UDP port in network byte order
  uint32_t ip;      // IP address in network byte order
  uint8_t ip6[16];  // IPv6 address
  bool is_ip6;      // True when address is IPv6 address
};

struct mg_mgr {
  struct mg_connection *conns;  // List of active connections
  struct mg_dns dns4;           // DNS for IPv4
  struct mg_dns dns6;           // DNS for IPv6
  int dnstimeout;               // DNS resolve timeout in milliseconds
  unsigned long nextid;         // Next connection ID
  void *userdata;               // Arbitrary user data pointer
#if MG_ARCH == MG_ARCH_FREERTOS_TCP
  SocketSet_t ss;  // NOTE(lsm): referenced from socket struct
#endif
};

struct mg_connection {
  struct mg_connection *next;  // Linkage in struct mg_mgr :: connections
  struct mg_mgr *mgr;          // Our container
  struct mg_addr peer;         // Remote address. For listeners, local address
  void *fd;                    // Connected socket, or LWIP data
  unsigned long id;            // Auto-incrementing unique connection ID
  struct mg_iobuf recv;        // Incoming data
  struct mg_iobuf send;        // Outgoing data
  mg_event_handler_t fn;       // User-specified event handler function
  void *fn_data;               // User-specified function parameter
  mg_event_handler_t pfn;      // Protocol-specific handler function
  void *pfn_data;              // Protocol-specific function parameter
  char label[50];              // Arbitrary label
  void *tls;                   // TLS specific data
  unsigned is_listening : 1;   // Listening connection
  unsigned is_client : 1;      // Outbound (client) connection
  unsigned is_accepted : 1;    // Accepted (server) connection
  unsigned is_resolving : 1;   // Non-blocking DNS resolution is in progress
  unsigned is_connecting : 1;  // Non-blocking connect is in progress
  unsigned is_tls : 1;         // TLS-enabled connection
  unsigned is_tls_hs : 1;      // TLS handshake is in progress
  unsigned is_udp : 1;         // UDP connection
  unsigned is_websocket : 1;   // WebSocket connection
  unsigned is_hexdumping : 1;  // Hexdump in/out traffic
  unsigned is_draining : 1;    // Send remaining data, then close and free
  unsigned is_closing : 1;     // Close and free the connection immediately
  unsigned is_readable : 1;    // Connection is ready to read
  unsigned is_writable : 1;    // Connection is ready to write
};

void mg_mgr_poll(struct mg_mgr *, int ms);
void mg_mgr_init(struct mg_mgr *);
void mg_mgr_free(struct mg_mgr *);

struct mg_connection *mg_listen(struct mg_mgr *, const char *url,
                                mg_event_handler_t fn, void *fn_data);
struct mg_connection *mg_connect(struct mg_mgr *, const char *url,
                                 mg_event_handler_t fn, void *fn_data);
void mg_connect_resolved(struct mg_connection *);
bool mg_send(struct mg_connection *, const void *, size_t);
int mg_printf(struct mg_connection *, const char *fmt, ...);
int mg_vprintf(struct mg_connection *, const char *fmt, va_list ap);
char *mg_straddr(struct mg_addr *, char *, size_t);
bool mg_aton(struct mg_str str, struct mg_addr *addr);
char *mg_ntoa(const struct mg_addr *addr, char *buf, size_t len);

struct mg_connection *mg_mkpipe(struct mg_mgr *, mg_event_handler_t, void *);
void mg_mgr_wakeup(struct mg_connection *pipe, const void *buf, size_t len);








struct mg_http_header {
  struct mg_str name;   // Header name
  struct mg_str value;  // Header value
};

struct mg_http_message {
  struct mg_str method, uri, query, proto;             // Request/response line
  struct mg_http_header headers[MG_MAX_HTTP_HEADERS];  // Headers
  struct mg_str body;                                  // Body
  struct mg_str head;                                  // Request + headers
  struct mg_str chunk;    // Chunk for chunked encoding,  or partial body
  struct mg_str message;  // Request + headers + body
};

// Parameter for mg_http_serve_dir()
struct mg_http_serve_opts {
  const char *root_dir;       // Web root directory, must be non-NULL
  const char *ssi_pattern;    // SSI file name pattern, e.g. #.shtml
  const char *extra_headers;  // Extra HTTP headers to add in responses
  const char *mime_types;     // Extra mime types, ext1=type1,ext2=type2,..
  struct mg_fs *fs;           // Filesystem implementation. Use NULL for POSIX
};

// Parameter for mg_http_next_multipart
struct mg_http_part {
  struct mg_str name;      // Form field name
  struct mg_str filename;  // Filename for file uploads
  struct mg_str body;      // Part contents
};

int mg_http_parse(const char *s, size_t len, struct mg_http_message *);
int mg_http_get_request_len(const unsigned char *buf, size_t buf_len);
void mg_http_printf_chunk(struct mg_connection *cnn, const char *fmt, ...);
void mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len);
void mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm);
struct mg_connection *mg_http_listen(struct mg_mgr *, const char *url,
                                     mg_event_handler_t fn, void *fn_data);
struct mg_connection *mg_http_connect(struct mg_mgr *, const char *url,
                                      mg_event_handler_t fn, void *fn_data);
void mg_http_serve_dir(struct mg_connection *, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts);
void mg_http_serve_file(struct mg_connection *, struct mg_http_message *hm,
                        const char *path, struct mg_http_serve_opts *opts);
void mg_http_reply(struct mg_connection *, int status_code, const char *headers,
                   const char *body_fmt, ...);
struct mg_str *mg_http_get_header(struct mg_http_message *, const char *name);
int mg_http_get_var(const struct mg_str *, const char *name, char *, size_t);
int mg_url_decode(const char *s, size_t n, char *to, size_t to_len, int form);
size_t mg_url_encode(const char *s, size_t n, char *buf, size_t len);
void mg_http_creds(struct mg_http_message *, char *, size_t, char *, size_t);
bool mg_http_match_uri(const struct mg_http_message *, const char *glob);
int mg_http_upload(struct mg_connection *, struct mg_http_message *hm,
                   struct mg_fs *fs, const char *dir);
void mg_http_bauth(struct mg_connection *, const char *user, const char *pass);
struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v);
size_t mg_http_next_multipart(struct mg_str, size_t, struct mg_http_part *);


void mg_http_serve_ssi(struct mg_connection *c, const char *root,
                       const char *fullpath);






struct mg_tls_opts {
  const char *ca;         // CA certificate file. For both listeners and clients
  const char *crl;        // Certificate Revocation List. For clients
  const char *cert;       // Certificate
  const char *certkey;    // Certificate key
  const char *ciphers;    // Cipher list
  struct mg_str srvname;  // If not empty, enables server name verification
  struct mg_fs *fs;       // FS API for reading certificate files
};

void mg_tls_init(struct mg_connection *, struct mg_tls_opts *);
void mg_tls_free(struct mg_connection *);
long mg_tls_send(struct mg_connection *, const void *buf, size_t len);
long mg_tls_recv(struct mg_connection *, void *buf, size_t len);
void mg_tls_handshake(struct mg_connection *);


#if MG_ENABLE_MBEDTLS




#include <mbedtls/debug.h>
#include <mbedtls/net_sockets.h>
#include <mbedtls/ssl.h>

struct mg_tls {
  char *cafile;             // CA certificate path
  mbedtls_x509_crt ca;      // Parsed CA certificate
  mbedtls_x509_crl crl;     // Parsed Certificate Revocation List
  mbedtls_x509_crt cert;    // Parsed certificate
  mbedtls_ssl_context ssl;  // SSL/TLS context
  mbedtls_ssl_config conf;  // SSL-TLS config
  mbedtls_pk_context pk;    // Private key context
};
#endif


#if MG_ENABLE_OPENSSL

#include <openssl/err.h>
#include <openssl/ssl.h>

struct mg_tls {
  SSL_CTX *ctx;
  SSL *ssl;
};
#endif


#define WEBSOCKET_OP_CONTINUE 0
#define WEBSOCKET_OP_TEXT 1
#define WEBSOCKET_OP_BINARY 2
#define WEBSOCKET_OP_CLOSE 8
#define WEBSOCKET_OP_PING 9
#define WEBSOCKET_OP_PONG 10



struct mg_ws_message {
  struct mg_str data;  // Websocket message data
  uint8_t flags;       // Websocket message flags
};

struct mg_connection *mg_ws_connect(struct mg_mgr *, const char *url,
                                    mg_event_handler_t fn, void *fn_data,
                                    const char *fmt, ...);
void mg_ws_upgrade(struct mg_connection *, struct mg_http_message *,
                   const char *fmt, ...);
size_t mg_ws_send(struct mg_connection *, const char *buf, size_t len, int op);
size_t mg_ws_wrap(struct mg_connection *, size_t len, int op);




struct mg_connection *mg_sntp_connect(struct mg_mgr *mgr, const char *url,
                                      mg_event_handler_t fn, void *fn_data);
void mg_sntp_send(struct mg_connection *c, unsigned long utc);
int64_t mg_sntp_parse(const unsigned char *buf, size_t len);





#define MQTT_CMD_CONNECT 1
#define MQTT_CMD_CONNACK 2
#define MQTT_CMD_PUBLISH 3
#define MQTT_CMD_PUBACK 4
#define MQTT_CMD_PUBREC 5
#define MQTT_CMD_PUBREL 6
#define MQTT_CMD_PUBCOMP 7
#define MQTT_CMD_SUBSCRIBE 8
#define MQTT_CMD_SUBACK 9
#define MQTT_CMD_UNSUBSCRIBE 10
#define MQTT_CMD_UNSUBACK 11
#define MQTT_CMD_PINGREQ 12
#define MQTT_CMD_PINGRESP 13
#define MQTT_CMD_DISCONNECT 14

struct mg_mqtt_opts {
  struct mg_str user;          // Username, can be empty
  struct mg_str pass;          // Password, can be empty
  struct mg_str client_id;     // Client ID
  struct mg_str will_topic;    // Will topic
  struct mg_str will_message;  // Will message
  uint8_t will_qos;            // Will message quality of service
  bool will_retain;            // Retain last will
  bool clean;                  // Use clean session, 0 or 1
  uint16_t keepalive;          // Keep-alive timer in seconds
};

struct mg_mqtt_message {
  struct mg_str topic;  // Parsed topic
  struct mg_str data;   // Parsed message
  struct mg_str dgram;  // Whole MQTT datagram, including headers
  uint16_t id;  // Set for PUBACK, PUBREC, PUBREL, PUBCOMP, SUBACK, PUBLISH
  uint8_t cmd;  // MQTT command, one of MQTT_CMD_*
  uint8_t qos;  // Quality of service
  uint8_t ack;  // Connack return code. 0 - success
};

struct mg_connection *mg_mqtt_connect(struct mg_mgr *, const char *url,
                                      struct mg_mqtt_opts *opts,
                                      mg_event_handler_t fn, void *fn_data);
struct mg_connection *mg_mqtt_listen(struct mg_mgr *mgr, const char *url,
                                     mg_event_handler_t fn, void *fn_data);
void mg_mqtt_login(struct mg_connection *c, struct mg_mqtt_opts *opts);
void mg_mqtt_pub(struct mg_connection *c, struct mg_str topic,
                 struct mg_str data, int qos, bool retain);
void mg_mqtt_sub(struct mg_connection *, struct mg_str topic, int qos);
int mg_mqtt_parse(const uint8_t *buf, size_t len, struct mg_mqtt_message *m);
void mg_mqtt_send_header(struct mg_connection *, uint8_t cmd, uint8_t flags,
                         uint32_t len);
size_t mg_mqtt_next_sub(struct mg_mqtt_message *msg, struct mg_str *topic,
                        uint8_t *qos, size_t pos);
size_t mg_mqtt_next_unsub(struct mg_mqtt_message *msg, struct mg_str *topic,
                          size_t pos);
void mg_mqtt_ping(struct mg_connection *);
void mg_mqtt_pong(struct mg_connection *);
void mg_mqtt_disconnect(struct mg_connection *);





// Mongoose sends DNS queries that contain only one question:
// either A (IPv4) or AAAA (IPv6) address lookup.
// Therefore, we expect zero or one answer.
// If `resolved` is true, then `addr` contains resolved IPv4 or IPV6 address.
struct mg_dns_message {
  uint16_t txnid;       // Transaction ID
  bool resolved;        // Resolve successful, addr is set
  struct mg_addr addr;  // Resolved address
  char name[256];       // Host name
};

struct mg_dns_header {
  uint16_t txnid;  // Transaction ID
  uint16_t flags;
  uint16_t num_questions;
  uint16_t num_answers;
  uint16_t num_authority_prs;
  uint16_t num_other_prs;
};

// DNS resource record
struct mg_dns_rr {
  uint16_t nlen;    // Name or pointer length
  uint16_t atype;   // Address type
  uint16_t aclass;  // Address class
  uint16_t alen;    // Address length
};

void mg_resolve(struct mg_connection *, const char *url);
void mg_resolve_cancel(struct mg_connection *);
bool mg_dns_parse(const uint8_t *buf, size_t len, struct mg_dns_message *);
size_t mg_dns_parse_rr(const uint8_t *buf, size_t len, size_t ofs,
                       bool is_question, struct mg_dns_rr *);
size_t mg_dns_decode_name(const uint8_t *, size_t, size_t, char *, size_t);

#ifdef __cplusplus
}
#endif
#endif  // MONGOOSE_H

```

`docs/cct/css/colors.css`:

```css
/**
 * Copyright (C) 2021 universal
 * 
 * This file is part of input-overlay.
 * 
 * input-overlay is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License.
 * 
 * input-overlay is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with input-overlay.  If not, see <http://www.gnu.org/licenses/>.
 */

 :root {
    /* Both theme colors */
    --theme-red: #fd5754;
    --theme-dark-red: #7f0508;
    --theme-orange: #febb40;
    --theme-dark-orange: #995712;
    --theme-green: #34c848;
    --theme-dark-green: #0b650d;

    --theme-bright-red: #ff8380;
    --theme-bright-orange: #ffcf78;
    --theme-bright-green: #79e488;
    
    --theme-stroke: white;
    --theme-item-selected: gray;

    --theme-accent: #1768e4; 
    --theme-accent-dark: #1d52c1;
    --theme-accent-bright: #3863c0; 
    --theme-accent-hovered: #3d82ea; 
    
    --theme-accept-gradient: linear-gradient(var(--theme-accent-hovered),
        var(--theme-accent) 30%, var(--theme-accent) 100%);
    --theme-accept-gradient-hovered: linear-gradient(var(--theme-accent-bright),
        var(--theme-accent-hovered) 30%, var(--theme-accent-hovered) 100%);
    --theme-spinbox-gradient: linear-gradient(var(--theme-accent-hovered),
        var(--theme-accent));
    --theme-spinbox-gradient-hovered: linear-gradient(var(--theme-accent-hovered),
        var(--theme-accent-bright));

    /* Dark theme colors */
    --dark-window-bg: #393b3d;
    --dark-window-border: #6c6d7188 #6c6d7188 #51515588 #6c6d7188;
    --dark-window-gradient: repeating-linear-gradient(#414446, #393b3d 4%, #393b3d 100%);
    --dark-text: white;
    --dark-shadow: drop-shadow(0px 0px 5px #292828bb);
    --dark-disabled:rgb(53, 53, 53);
    --dark-text-disabled:rgb(78, 78, 78);
    --dark-textbox: white;
    --dark-control: #6c6d71;
    --dark-tab-button: #717274;
    --dark-border: #ffffff3d;
    --dark-tab-left-border: #ffffff3d #3d3d3d44 #0000005b;
    --dark-tab-right-border: #ffffff3d transparent #0000005b;
    --dark-control-border: #ffffff33 transparent rgb(46, 46, 46) transparent;
    --dark-control-hover: #8c8d91;
    --dark-link: #7da6ff;
    /* Check box & Radio buttons */
    --dark-control-gradient-top: #474749;
    --dark-control-gradient-bottom: #606062;
    --dark-control-gradient: linear-gradient(var(--dark-control-gradient-top),
       var(--dark-control-gradient-bottom));
    --dark-control-inset: inset 0 1px 1px rgba(255,255,255,0.15), inset 0 -1px 1px rgba(0,0,0,0.15);

    /* Bright */
    --bright-window-bg: #e4e4e4;
    --bright-window-border: #6c6d7188;
    --bright-window-gradient: repeating-linear-gradient(#efefef, #e4e4e4 4%, #e4e4e4 100%);
    --bright-text: rgb(29, 29, 29);
    --bright-shadow: drop-shadow(0px 0px 5px #aaaaaabb);
    --bright-disabled:rgb(119, 119, 119);
    --bright-text-disabled:rgb(78, 78, 78);
    --bright-textbox: black;
    --bright-control-border: transparent #00000000 rgba(128, 128, 128, 0.616);
    --bright-control: #fcfcfc;
    --bright-control-hover: #d3cdcd;
    /* Check box & Radio buttons */
    --bright-control-gradient-top: white;
    --bright-control-gradient-bottom: #606062;
    --bright-control-gradient: linear-gradient(var(--bright-control),
       var(--bright-control));
    --bright-control-inset: inset 0 2px 2px rgba(255,255,255,0.15), inset 0 -1px 1px rgba(0,0,0,0.15);
}
```

`docs/cct/css/dialog.css`:

```css
/**
 * Copyright (C) 2021 universal
 * 
 * This file is part of input-overlay.
 * 
 * input-overlay is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License.
 * 
 * input-overlay is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with input-overlay.  If not, see <http://www.gnu.org/licenses/>.
 */

@import url("colors.css");

.canvas-container {
    height: 100%;
    width: 100%;
    overflow: hidden;
}

#editor-title {
    grid-column-start: 1;
    grid-column-end: 3;
    grid-row: 1;
}

.editor-properties {
    padding-right: 5px;
}

.edit-grid {
    display: grid; 
    width: 100%;
    height: 100%;
    grid-template-columns: 200px;
    grid-template-rows: 25px auto;
}

.intro-grid > div {
    padding-top: 10px;
}

.intro-grid {
    display: grid; 
    width: 100%;
    grid-template-columns: 50% 50%;
    grid-template-rows: repeat(25px);
    grid-auto-flow: row dense;
}

.setup-wide {
    grid-column-start: 1;
    grid-column-end: 3;
}

.properties {
    display: grid; 
    width: 100%;
    grid-template-columns: 16% 34% 16% 34%; 
}

.blurred {
    filter: blur(4px);
    -webkit-filter: blur(4px);
}

.left-column {
    width: 180pt;
}

.modal-dialog {
    position: fixed;
    background-color: rgba(20, 20, 20, 0.5);
    top: 0;
    right: 0 !important;
    bottom: 0;
    left: 0;
    z-index: 999;
    -webkit-transition: all 0.5s;
    -moz-transition: all 0.5s;
    transition: all 0.5s; 
}

#setup-dialog {
    margin-left: auto;
    margin-right: auto;
    width: fit-content !important;
    height: fit-content !important;
}

#edit-element-dialog {
    opacity: 0;
    display: none;
    height: 80% !important;
    pointer-events: none;
    margin-left: 150px;
    margin-right: 150px;
}

.modal-window>div {
    border-radius: 6px;
    position: relative;
    margin: 10% auto;
    padding: 8px;
    border-style: solid;
    border-width: 1px;
    /* box-shadow: 0px 0px 9px 9px #b6b5b546; */
}

/* The container <div> - needed to position the dropdown content */
.dropdown {
    position: relative;
    display: inline-block;
}

/* Dropdown Content (Hidden by Default) */
.dropdown-content {
    display: none;
    position: absolute;
    z-index: 1;
}

/* Links inside the dropdown */
.dropdown-content a {
    text-decoration: none;
    display: block;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 2px !important;
    padding-bottom: 2px !important;
}

/* Change color of dropdown links on hover */
.dropdown-content a:hover {
    background-color: var(--theme-accent-hovered);

}

/* Show the dropdown menu (use JS to add this class to the .dropdown-content container when the user clicks on the dropdown button) */
.show {
    display: block;
}

#element-dialog {
    width: 130pt;
}

.dropdown-content {
    padding-bottom: 3px;
    padding-top: 3px;
    border-radius: 6px;
    border-style: solid;
    border-width: 1px;
    
    background-color: var(--dark-window-bg);
    background-image: var(--dark-window-gradient);
    border-color: var(--dark-window-border);

}

.dialog, .modal-dialog {
    padding: 7px;
    border-radius: 6px;
    border-style: solid;
    border-width: 1px;
    box-shadow: 0px 0px 5px 5px #29282850;
    top: 50%;
    right: 5px;
    transform: translate3d(0%, -50%, 0);
    position: absolute;
    background-color: var(--dark-window-bg);
    background-image: var(--dark-window-gradient);
    border-color: var(--dark-window-border);
}

.dialog-title {
    text-align: center;
    font-size: 12pt !important;
    padding: 0px 4px 6px 4px;
}

a { 
    color: var(--theme-accent-hovered);
}

a:visited {
    color: var(--theme-accent-bright);
}
.noselect,
p,
label,
.dropdown-content a {
    -webkit-touch-callout: none; /* ios safari */
    -webkit-user-select: none; /* safari */
    -khtml-user-select: none; /* konqueror html */
    -moz-user-select: none; /* old versions of firefox */
    -ms-user-select: none; /* internet explorer/edge */
    user-select: none; /* non-prefixed version, currently
                                  supported by chrome, opera and firefox */
}

.label,
.dropdown-content a,
p,
label,
input[type="button"] {
    font-family: "Arial", Times, serif;
    font-size: 11pt;
    color: var(--dark-text);
    margin-bottom: 0px;
    margin-top: 0px;
}

input[type="text"] {
    height: 18px;
    width: 100%;
}

.textbox-container, .textbox-container-wide, .textbox-container-medium {
    display: flex;
    width:100%;
    padding-top: 2px;
    padding-bottom: 2px;
}

.textbox-container-wide {
    grid-column-start: 2;
    grid-column-end: 5;
}

.label-container-wide {
    grid-column-start: 1;
    grid-column-end: 3;
}

.textbox-container-medium {
    grid-column-start: 4;
    grid-column-end: 5;
}

.full-width { 
    width: 100%;
}

.grid-full-width {
    grid-column-start: 1;
    grid-column-end: 5;
    padding-top: 2px;
    padding-bottom: 2px;
}

input[type="text"],
input[type="button"] {
    border-radius: 3px;
    border-style: solid none none none;
    border-width: 1px;
    background: var(--dark-control);
    border-color: var(--dark-control-border);
    color: var(--dark-textbox);
}

input[type="button"] {
    height: 22px;
    cursor: pointer;
}

input[type="file"] {
    display: none;
}


.value > p,
.value > input {
    display: inline;
}

.properties > div > label {
    padding-left: 9px;
    padding-top: 5px;
    width: 100%;
    display: inline-table;
}

/* Checkbox */
.cbx {
    position: relative;
    display: block;
    float: left;
    width: 15px;
    height: 15px;
    border-radius: 4px;
    transition: all 0.15s ease;
    background-color: var(--bright-control-gradient-bottom);
    background-image: var(--bright-control-gradient);
    box-shadow: var(--bright-control-inset);
}

.cbx svg {
    position: absolute;
    top: 3px;
    left: 3px;
    fill: none;
    stroke-linecap: round;
    stroke-linejoin: round;
    stroke: var(--theme-stroke);
    stroke-width: 2;
    stroke-dasharray: 17;
    stroke-dashoffset: 17;
    transform: translate3d(0, 0, 0);
}

.cbx + span {
    float: left;
    margin-left: 6px;
}

input[type="checkbox"] {
    position: absolute;
    opacity: 0;
    cursor: pointer;
}

input[type="checkbox"]:checked + .cbx {
    background-color: var(--dark-control-gradient-bottom);
    background-image: linear-gradient(var(--theme-accent), var(--theme-accent));
}

input[type="checkbox"]:checked + .cbx svg {
    stroke-dashoffset: 0;
    transition: all 0.25s ease;
}

.cbx-label {
    padding-bottom: 5px;
}

.cbx-label > span {
    cursor: pointer;
}
```

`docs/cct/css/file.css`:

```css
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#drop-area {
  border: 2px dashed #ccc;
  border-radius: 20px;
  width: 480px;
  margin: 50px auto;
  padding: 20px;
}

.highlight > form > label {
  background-color: var(--dark-control-hover);
}

.button {
  font-family: "Arial", Times, serif;
  font-size: 11pt;
  color: var(--dark-text);
  cursor: pointer;
  border-radius: 3px;
  border-style: solid none none none;
  border-width: 1px;
  background: var(--dark-control);
  border-color: var(--dark-control-border);
  color: var(--dark-textbox);
  cursor: pointer;
  padding-top: 2px;
  padding-bottom: 2px;
  padding-left: 5px;
  padding-right: 5px;
  margin-top: 2px;
  margin-bottom: 2px;
  font-size: 11pt !important;
}
```

`docs/cct/css/select.css`:

```css
@import url("colors.css");

.custom-select {
    position: relative;
    font-family: "Arial", Times, serif;
    font-size: 11pt;
}

.custom-select select {
    display: none; /*hide original SELECT element: */
}

.select-selected {
    background-color:  var(--dark-control);
    border-color: var(--dark-control-border);
    color: var(--dark-textbox);
    border-radius: 3px;
    border-style: solid none none none;
    border-width: 1px;
}

/* Style the arrow inside the select element: */
.select-selected:after {
    position: absolute;
    content: "";
    top: 9px;
    right: 5px;
    width: 0;
    height: 0;
    border: 6px solid transparent;
    border-color: #fff transparent transparent transparent;
}

/* Point the arrow upwards when the select box is open (active): */
.select-selected.select-arrow-active:after {
    border-color: transparent transparent #fff transparent;
    top: 2px;
}

.select-selected.select-arrow-active {
    border-radius: 3px 3px 0px 0px !important;
    border-color: rgb(150 150 150);
    border-style: solid solid none solid;
    border-width: 1px;
    padding-left: 5px !important;
}

/* style the items (options), including the selected item: */
.select-items div,
.select-selected {
    padding-top: 2px;
    height: 20px;
    cursor: pointer;
}

.select-items div {
    padding-left: 5px;
}

.select-selected {
    padding-left: 6px;
}

/* Style items (options): */
.select-items {
    position: absolute;
    background: var(--dark-control);
    border-color: rgb(150 150 150);
    color: var(--dark-textbox);
    top: 100%;
    border-radius: 0px 0px 4px 4px;
    border-style: none solid solid;
    border-width: 1px;
    margin-top: -1px;
    left: 0;
    right: 0;
    z-index: 99;
    overflow: hidden;

}

.select-items > div:hover {
    background-color: var(--theme-accent);
}

/* Hide the items when the select box is closed: */
.select-hide {
    display: none;
}


```

`docs/cct/index.html`:

```html
<!--
   This file is part of input-overlay
   github.con/univrsal/input-overlay
   Copyright 2022 univrsal <uni@vrsal.xyz>.
  
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, version 2 of the License.
  
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>

<head>
    <title>io-cct</title>
    <link rel="shortcut icon" href="./favicon.ico" type="image/x-icon">

    <!-- 
            https://www.flaticon.com/free-icon/video-game_4021738
            https://www.flaticon.com/free-icon/wrench_3680814
            both icons by freepik
    -->
    <link rel="icon" href="./favicon.ico" type="image/x-icon">
    <script src="./js/jquery-3.5.1.min.js"></script>
    <script src="./js/math.js"></script>
    <script src="./js/gamepad.js"></script>
    <script src="./js/vc.js"></script>
    <script src="./js/elements.js"></script>
    <script src="./js/config.js"></script>
    <script src="./js/cs.js"></script>
    <script src="./js/draw.js"></script>
    <script src="./js/editor.js"></script>
    <script src="./js/dl.js"></script>
    <script src="./js/main.js"></script>
    <script src="./js/gui.js"></script>
    <script src="./js/select.js"></script>
    <script src="./js/file.js"></script>

    <link rel="stylesheet" href="./css/dialog.css">
    <link rel="stylesheet" href="./css/select.css">
    <link rel="stylesheet" href="./css/file.css">
    <style>
        #editor-canvas,
        #main-canvas {
            /* IE, only works on <img> tags */
            -ms-interpolation-mode: nearest-neighbor;
            /* Firefox */
            image-rendering: crisp-edges;
            /* Chromium + Safari */
            image-rendering: pixelated;
        }

        body,
        html {
            height: 100%;
        }
    </style>
</head>

<body style="margin: 0px; overflow: hidden;">
    <div class="canvas-container" id="main-canvas-container">
        <canvas id="main-canvas"></canvas>
    </div>
    <div id="element-dialog" class="dialog">
        <p class="dialog-title noselect">Element settings</p>

        <div class="properties">
            <!-- Position -->
            <div><label for="selected-element-x">X</label></div>
            <div class="textbox-container"><input type="text" class="numeric" id="selected-element-x" value="0"></div>

            <div><label for="selected-element-y">Y</label></div>
            <div class="textbox-container"><input type="text" class="numeric" id="selected-element-y" value="0"></div>

            <!-- UV -->
            <div><label for="selected-element-u">U</label></div>
            <div class="textbox-container"><input type="text" class="numeric" id="selected-element-u" value="0"></div>

            <div><label for="selected-element-v">V</label></div>
            <div class="textbox-container"><input type="text" class="numeric" id="selected-element-v" value="0"></div>

            <!-- W/H -->
            <div><label for="selected-element-w">W</label></div>
            <div class="textbox-container"><input type="text" class="numeric" id="selected-element-w" value="0"></div>

            <div><label for="selected-element-h">H</label></div>
            <div class="textbox-container"><input type="text" class="numeric" id="selected-element-h" value="0"></div>

            <!-- Z -->
            <div><label for="selected-element-layer">Z</label></div>
            <div class="textbox-container-wide"><input type="text" class="numeric" id="selected-element-layer"
                    value="0">
            </div>

            <div><label for="selected-element-id">ID</label></div>
            <div class="textbox-container-wide"><input type="text" class="coord" id="selected-element-id" value="">
            </div>

            <!-- Buttons -->
            <div class="grid-full-width"><input type="button" class="full-width" id="ok" value="Apply"></div>

            <div class="grid-full-width">
                <input type="button" class="full-width dropbtn" id="new" value="Add new element"
                    onclick="new_type_dropdown()">
                <div id="type-dropdown" class="dropdown-content ">
                    <a onclick="open_editor('texture', false)" href="#">Texture</a>
                    <a onclick="open_editor('keyboard_button', false)" href="#">Keyboard button</a>
                    <a onclick="open_editor('gamepad_button', false)" href="#">Gamepad button</a>
                    <a onclick="open_editor('mouse_button', false)" href="#">Mouse button</a>
                    <a onclick="open_editor('mouse_wheel', false)" href="#">Mouse wheel</a>
                    <a onclick="open_editor('analog_stick', false)" href="#">Analog stick</a>
                    <a onclick="open_editor('trigger', false)" href="#">Gamepad trigger</a>
                    <a onclick="open_editor('player_id', false)" href="#">Gamepad player id</a>
                    <a onclick="open_editor('dpad', false)" href="#">DPad</a>
                    <a onclick="open_editor('mouse_movement', false)" href="#">Mouse movement</a>
                </div>
            </div>

            <div class="grid-full-width"><input type="button" onclick="open_editor(null, true)" class="full-width" id="mod" value="Edit selected element">
            </div>
            <div class="grid-full-width"><input type="button" class="full-width" id="del"
                    value="Delete selected element"></div>

            <div class="grid-full-width"><input type="button" class="full-width" id="export" onclick="download_config()" value="Export to JSON">
            </div>
        </div>
    </div>

    <!-- Load config dialog -->
    <div id="setup-dialog" class="modal-dialog">
        <div class="intro-grid">
            <p class="dialog-title noselect setup-wide">Setup</p>
            <div>
                <label>Texture file</label>
            </div>
            <div>
                <div id="texture-drop-area">
                </div>
            </div>

            <div>
                <label>Config file (when editing an existing config)</label>
            </div>
            <div>
                <div id="config-drop-area">
                </div>
            </div>

            <div>
                <label>Default width</label>
            </div>
            <div>
                <label>Default height</label>
            </div>
            <div style="margin-right: 10px;">
                <input type="text" class="numeric" id="default-width" value="0">
            </div>
            <div>
                <input type="text" class="numeric" id="default-height" value="0">
            </div>

            <div>
                <label>Horizontal offset</label>
            </div>

            <div>
                <label>Vertical offset</label>
            </div>
            <div style="margin-right: 10px;">
                <input type="text" class="numeric" id="horizontal-offset" value="0">
            </div>
            <div>
                <input type="text" class="numeric" id="vertical-offset" value="0">
            </div>

            <div style="margin-right: 5px">
                <input type="button" class="full-width" id="start-button" onclick="setup()" value="Start">
            </div>
        </div>
    </div>

    <!-- Element edit dialog -->
    <div id="edit-element-dialog" class="modal-dialog">
        <div class="edit-grid">
            <p class="dialog-title noselect" id="editor-title">Element editor</p>

            <div class="editor-properties">
                <div class="properties">
                    <div><label for="editor-element-id">ID</label></div>
                    <div class="textbox-container-wide"><input type="text" id="editor-element-id" value="">
                    </div>

                    <!-- UV -->
                    <div><label for="editor-element-u">U</label></div>
                    <div class="textbox-container"><input type="text" class="numeric" id="editor-element-u" value="0">
                    </div>

                    <div><label for="editor-element-v">V</label></div>
                    <div class="textbox-container"><input type="text" class="numeric" id="editor-element-v" value="0">
                    </div>

                    <!-- W/H -->
                    <div><label for="editor-element-w">W</label></div>
                    <div class="textbox-container"><input type="text" class="numeric" id="editor-element-w" value="0">
                    </div>

                    <div><label for="editor-element-h">H</label></div>
                    <div class="textbox-container"><input type="text" class="numeric" id="editor-element-h" value="0">
                    </div>

                    <!-- Z -->
                    <div><label for="editor-element-layer">Z</label></div>
                    <div class="textbox-container-wide"><input type="text" class="numeric" id="editor-element-layer"
                            value="0">
                    </div>

                    <!-- Misc stuff -->

                    <!-- Key code-->
                    <div class="label-container-wide" id="editor-element-keycode-label"><label
                            for="editor-element-keycode">Keycode</label></div>
                    <div class="textbox-container-medium" id="editor-element-keycode-container"><input type="text"
                            class="hex-numeric" id="editor-element-keycode" value="0x0">
                    </div>
                    <div id="editor-element-record-code-container" class="grid-full-width">
                        <label for="editor-element-record-code" class="cbx-label">
                            <input type="checkbox" id="editor-element-record-code" checked>
                            <span class="cbx">
                                <svg width="12px" height="11px" viewBox="0 0 12 11">
                                    <polyline points="0.75 4.721 3.375 7.5 8.25 0.75"></polyline>
                                </svg>
                            </span>
                            <span>Record keycode</span>
                        </label>
                    </div>

                    <!-- Analog stick -->
                    <div id="editor-element-analog-stick-side-label" class="label-container-wide"><label
                            for="editor-element-analog-stick-side">Stick side</label>
                    </div>
                    <div class="textbox-container-medium" id="editor-element-analog-stick-side-container">
                        <div class="custom-select" style="width:100%">
                            <select id="editor-element-analog-stick-side">
                                <option value="0">Left</option>
                                <!-- The w3 code uses the first one as a placeholder, which i don't want -->
                                <option value="0">Left</option>
                                <option value="1">Right</option>
                            </select>
                        </div>
                    </div>

                    <div id="editor-element-analog-stick-radius-label" class="label-container-wide"><label
                            for="editor-element-analog-stick-side">Radius</label>
                    </div>
                    <div class="textbox-container-medium" id="editor-element-analog-stick-radius-container">
                        <input type="text" class="coord" id="editor-element-analog-stick-radius" value="20">
                    </div>

                    <!-- trigger -->
                    <div id="editor-element-trigger-button-container" class="grid-full-width">
                        <label for="editor-element-trigger-button" class="cbx-label">
                            <input type="checkbox" id="editor-element-trigger-button">
                            <span class="cbx">
                                <svg width="12px" height="11px" viewBox="0 0 12 11">
                                    <polyline points="0.75 4.721 3.375 7.5 8.25 0.75"></polyline>
                                </svg>
                            </span>
                            <span>Button</span>
                        </label>
                    </div>

                    <div id="editor-element-trigger-direction-label" class="label-container-wide"><label
                            for="editor-element-analog-stick-side">Fill</label>
                    </div>
                    <div id="editor-element-trigger-direction-container" class="textbox-container-medium">
                        <div class="custom-select" style="width:100%">
                            <select id="editor-element-trigger-direction-side">
                                <option value="3">Left</option>
                                <option value="3">Left</option>
                                <option value="4">Right</option>
                                <option value="1">Up</option>
                                <option value="2">Down</option>
                            </select>
                        </div>
                    </div>

                    <!-- mouse movement type -->
                    <div id="editor-element-movement-type-label" class="label-container-wide"><label
                            for="editor-element-movement-type">Type</label>
                    </div>
                    <div id="editor-element-movement-type-container" class="textbox-container-medium">
                        <div class="custom-select" style="width:100%">
                            <select id="editor-element-movement-type">
                                <option value="1">Point</option>
                                <option value="1">Point</option>
                                <option value="0">Move</option>
                            </select>
                        </div>
                    </div>

                    <div id="editor-element-description-label" class="grid-full-width">
                        <p class="label-container-wide label" id="editor-info-label"></label>
                    </div>
                    <!-- Buttons -->
                    <div class="grid-full-width ">
                        <input type="button" onclick="apply_editor()" id="ok-editor" value="OK">
                        <input type="button" onclick="close_editor()" id="cancel-editor" value="Cancel">
                    </div>

                </div>
            </div>

            <div class="canvas-container" id="editor-canvas-container">
                <canvas id="editor-canvas"></canvas>
            </div>
        </div>
    </div>
</body>

</html>

```

`docs/cct/js/config.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

class config {

    constructor(canvas_id, painter)
    {
        this.data = {};
        this.elements = [];
        this.selected_elements = [];
        this.selecting = false;
        this.dragging = false;
        this.allow_arrow_movement = true;
        this.drag_selection = new r4(); // Mouse dragged selection in screen space
        this.selection_rect = new r4(); // Actual selected element(s) in coordinate space
        this.drag_offset = new vec2();  // MousePos - SelectionRect (unscaled)
        this.painter = painter;
        this.is_ctrl_down = false;
        this.internal_clipboard = null;
        this.grid = new vec2();
        this.enabled = true; // false when a dialog is open
        $(canvas_id).on('mousemove', e => this.move(e, this.painter.cs()));
        $(canvas_id).on('mouseup', e => this.mouseup(e, this.painter.cs()));
        $(canvas_id).on('mousedown', e => this.mousedown(e, this.painter.cs()));
        $(canvas_id).on('wheel', e => this.on_scroll(e));
        $(window).on('copy', () => this.on_copy());
        $(window).on('paste', () => this.on_paste());
        $(window).on('keydown', e => this.on_button(e, true));
        $(window).on('keyup', e => this.on_button(e, false));
        pad.on('input', p => this.gamepad_input(p));
        this.load_callbacks = [];
        setInterval(() => this.tick(), 250);
    }

    tick() { this.elements.forEach(e => e.tick()); }

    on_scroll(e) { this.elements.forEach(element => element.on_scroll_input(e)); }

    on_copy()
    {
        if (!this.enabled)
            return;
        let data = [];
        this.selected_elements.forEach(e => data.push(e.data));
        this.internal_clipboard = data;
        navigator.clipboard.writeText(JSON.stringify(data));
    }

    add_elements(j)
    {
        if (j) {
            if (j.length > 0)
                this.selected_elements = [];
            j.forEach(e => {
                let orig_id = e.id.replace(/\d+$/, "");
                let counter = 0;
                let id = orig_id + counter;
                e.pos[1] += 4; // offset so you can see the pasted elements
                while (!this.is_name_unique(id))
                    id = orig_id + counter++;
                e.id = id;
                let new_element = create_element(e);
                this.elements.push(new_element);
                this.selected_elements.push(new_element);
            });
        }
    }

    on_paste()
    {
        if (!this.enabled)
            return;
        let cfg = this;
        navigator.clipboard.readText().then(text => { cfg.add_elements(JSON.parse(text)); }).catch(err => {
            console.log('Failed to read clipboard text: ' + err);
            // fallback to internal clip board
            this.add_elements(this.internal_clipboard);
        });
    }

    add_load_callback(cb) { this.load_callbacks.push(cb); }

    load_from_json(json)
    {
        this.data = json;
        this.data["elements"].forEach(data => {
            let new_element = create_element(data);
            if (new_element !== null)
                this.elements.push(new_element);
        });
        this.grid.x = this.data.default_width + this.data.space_h;
        this.grid.y = this.data.default_height + this.data.space_v;
        this.sort_elements();
        this.load_callbacks.forEach(cb => cb());
    }

    write_to_json()
    {
        this.data.flags = 0;
        this.data.overlay_width = 0;
        this.data.overlay_height = 0;
        this.data["elements"] = this.elements.map(e => e.data);
        this.elements.forEach(e => {
            switch (e.type()) {
            case element_types.ANALOG_STICK:
                if (e.is_left_stick())
                    this.data.flags |= overlay_flags.LEFT_STICK;
                else
                    this.data.flags |= overlay_flags.RIGHT_STICK;
            case element_types.GAMEPAD_BUTTON:
            case element_types.ANALOG_STICK:
            case element_types.TRIGGER:
            case element_types.DPAD_STICK:
            case element_types.GAMEPAD_ID:
                this.data.flags |= overlay_flags.GAMEPAD;
                break;
            case element_types.WHEEL:
            case element_types.MOUSE_MOVEMENT:
            case element_types.MOUSE_BUTTON:
                this.data.flags |= overlay_flags.MOUSE;
                break;
            }
            this.data.overlay_width = Math.max(this.data.overlay_width, e.x() + e.w());
            this.data.overlay_height = Math.max(this.data.overlay_height, e.y() + e.h());
        });
        return this.data;
    }

    sort_elements()
    {
        this.elements.sort((a, b) => { return a.layer() - b.layer(); });
    }

    draw(painter)
    {
        if (atlas === null) // Don't draw if image hasn't loaded yet
            return;

        let ctx = painter.get_context();
        let cs = painter.cs();
        ctx.save();
        ctx.rect(cs.origin.x, cs.origin.y, cs.dimensions.w, cs.dimensions.h);
        ctx.clip();

        if (this.grid.x > 0) {
            for (var x = cs.origin.x - cs.offset.x; x < cs.dimensions.w + cs.origin.x; x += this.grid.x * cs.scale) {
                painter.line(x - 0.5, cs.origin.y, x - 0.5, cs.origin.y + cs.dimensions.h, 1, brightLineColor);
            }
        }
        if (this.grid.y > 0) {
            for (var y = cs.origin.y - cs.offset.y; y < cs.dimensions.h + cs.origin.y; y += this.grid.y * cs.scale) {
                painter.line(cs.origin.x, y - 0.5, cs.origin.x + cs.dimensions.w, y - 0.5, 1, brightLineColor);
            }
        }

        this.elements.forEach(element => element.draw(painter));
        if (this.selecting && !this.drag_selection.is_empty()) {
            painter.rect_outline(this.drag_selection.x - 0.5, this.drag_selection.y - 0.5, this.drag_selection.w,
                                 this.drag_selection.h);
        }

        if (!this.selection_rect.is_empty()) {
            let r = cs.translate_rect_to_screen(this.selection_rect);
            painter.rect_outline(r.x + 0.5, r.y + 0.5, r.w - 1, r.h - 1, 1, "#ff0000ff");
        }
        ctx.restore();
    }

    delete_selection()
    {
        let new_elements = this.elements.filter(function(to_filter) {
            return this.selected_elements.find(function(to_find) { return to_filter.id() === to_find.id(); }) ===
                   undefined;
        }, this);
        this.elements = new_elements;
        this.deselect();
    }

    is_name_unique(name, editing_element)
    {
        let unique = true;
        this.elements.some(e => {
            if (e.id() === name) {
                if (!editing_element || e !== editing_element) {
                    unique = false;
                    return true;
                }
            }
            return false;
        });
        return unique;
    }

    gamepad_input(pad) { this.elements.forEach(e => e.on_gamepad_input(pad)); }

    on_button(event, state)
    {
        if (!this.enabled)
            return;
        if (event.key == 'Control')
            this.is_ctrl_down = state;

        let vc = key_to_vc(event);
        this.elements.forEach(element => element.on_keyboard_input(vc, state));
        if (this.selected_elements.length > 0 && state) {
            let old_pos = new vec2(this.selection_rect.x, this.selection_rect.y);
            let moved = false;

            switch (event.key) {
            case "ArrowUp":
                moved = true;
                this.selection_rect.y--;
                break;
            case "ArrowDown":
                moved = true;
                this.selection_rect.y++;
                break;
            case "ArrowLeft":
                moved = true;
                this.selection_rect.x--;
                break;
            case "ArrowRight":
                moved = true;
                this.selection_rect.x++;
                break;
            case "Delete":
                if (document.activeElement === document.body) {
                    if (this.selected_elements.length > 1) {
                        // Ask for comfirmation when deleting more than one element
                        if (confirm("You are about to delete " + this.selected_elements.length +
                                    " elements. Are you sure?")) {
                            this.delete_selection();
                        }
                    } else {
                        this.delete_selection();
                    }
                }
                break;
            }

            if (moved) {
                this.selection_rect.max();

                let diff = old_pos.sub(this.selection_rect.x, this.selection_rect.y);
                this.selected_elements.forEach(e => {
                    let d = e.dim();
                    e.set_pos(d.x - diff.x, d.y - diff.y);
                });
                if (this.selected_elements.length < 2)
                    this.select_element(this.selected_elements[0]);
            }
        }
    }

    mouseup(event, cs)
    {
        this.selecting = false;
        this.dragging = false;
        let vc = mouse_to_vc(event);
        this.elements.forEach(element => element.on_mouse_input(vc, false));
    }

    start_dragging(event, cs)
    {
        let tv = cs.translate_point_to_cs(event.clientX, event.clientY);
        this.drag_offset.x = tv.x - this.selection_rect.x;
        this.drag_offset.y = tv.y - this.selection_rect.y;
        this.dragging = true;
        this.selecting = false;
    }

    set_selection(element) { this.selection_rect = element.dim(); }

    mousedown(event, cs)
    {
        let vc = mouse_to_vc(event);
        this.elements.forEach(element => element.on_mouse_input(vc, true));

        if (event.button == 0 && cs.is_mouse_over(event)) {
            let r = cs.translate_rect_to_screen(this.selection_rect);
            let m = new vec2(event.clientX, event.clientY);
            if (r.is_point_inside(m)) {
                this.start_dragging(event, cs);
            } else {
                // Element selection
                if (!this.is_ctrl_down) {
                    this.selected_elements = [];
                    this.selection_rect = new r4();

                    this.deselect();
                }

                // Array is sorted lowest to highest, so the highest layer is drawn
                // last, but for clicking we want the highest layer first
                this.elements.slice().reverse().some(e => {
                    if (e.scaled_dim(cs).is_point_inside(m)) {
                        this.selected_elements.push(e);
                        this.selection_rect.union(e.dim());
                        this.select_element(e);
                        return true;
                    }
                    return false;
                });

                // No element was directly selected -> allow drag selection
                if (this.selection_rect.is_empty()) {
                    this.selecting = true;
                    this.dragging = false;
                    this.drag_selection.x = event.clientX;
                    this.drag_selection.y = event.clientY;
                    this.drag_selection.w = 0;
                    this.drag_selection.h = 0;
                } else {
                    this.start_dragging(event, cs);
                }
            }
        }
    }

    deselect()
    {
        $("#selected-element-x").val(0);
        $("#selected-element-y").val(0);
        $("#selected-element-w").val(0);
        $("#selected-element-h").val(0);
        $("#selected-element-u").val(0);
        $("#selected-element-v").val(0);
        $("#selected-element-id").val("");
        $("#selected-element-layer").val(0);
        this.selected_elements = [];
        this.selection_rect.reset();
    }

    select_element(e)
    {
        $("#selected-element-x").val(e.x());
        $("#selected-element-y").val(e.y());
        $("#selected-element-w").val(e.w());
        $("#selected-element-h").val(e.h());
        $("#selected-element-u").val(e.u());
        $("#selected-element-v").val(e.v());
        $("#selected-element-id").val(e.id());
        $("#selected-element-layer").val(e.layer());
    }

    move(event, cs)
    {
        if (this.selecting) {
            this.drag_selection.w = event.clientX - this.drag_selection.x;
            this.drag_selection.h = event.clientY - this.drag_selection.y;

            let selected_elements = [];
            let rect = new r4();
            let first = true;
            this.elements.forEach(e => {
                if (e.scaled_dim(cs).is_inside(this.drag_selection)) {
                    selected_elements.push(e);
                    if (first) {
                        rect = e.dim();
                        first = false;
                    } else {
                        rect.union(e.dim());
                    }
                }
            });

            this.selected_elements = selected_elements;
            this.selection_rect = rect;
        } else if (this.dragging) {
            let tv = cs.translate_point_to_cs(event.clientX, event.clientY);
            let old_pos = new vec2(this.selection_rect.x, this.selection_rect.y);
            this.selection_rect.x = tv.x - this.drag_offset.x;
            this.selection_rect.y = tv.y - this.drag_offset.y;
            this.selection_rect.max();

            let diff = old_pos.sub(this.selection_rect.x, this.selection_rect.y);
            this.selected_elements.forEach(e => {
                let d = e.dim();
                e.set_pos(d.x - diff.x, d.y - diff.y);
            });
            if (this.selected_elements.length < 2)
                this.select_element(this.selected_elements[0]);
        }
    }
}

```

`docs/cct/js/cs.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

class cs {
    constructor(canvas_id)
    {
        this.origin = new vec2(100, 100);
        this.offset = new vec2();
        this.orig_offset = new vec2();
        this.drag_start = new vec2();
        this.dragging = false;
        this.scale = 1;
        this.dimensions = new r2();
        this.step = 10;
        this.canvas_id = canvas_id;

        $(canvas_id).on('wheel', e => this.scroll(e));
        $(canvas_id).on('click', e => this.click(e));
        $(canvas_id).on('mousemove', e => this.move(e));
        $(canvas_id).on('mouseup', e => this.mouseup());
        $(canvas_id).on('mouseleave', () => this.mouseup());
        $(canvas_id).on('contextmenu', e => {
            this.click(e);
            e.preventDefault();
            return false;
        });
    }

    draw(painter)
    {
        // Axis labels
        painter.text("y in pixels", this.origin.x - 17, this.origin.y - 20, 90, "right", lineColor, 15);
        painter.text("x in pixels", this.origin.x - 22, this.origin.y - 9, 0, "right", lineColor, 15);
        // Draw axis
        painter.line(0, this.origin.y - 0.5, this.dimensions.w + this.origin.x, this.origin.y - 0.5, 1);
        painter.line(this.origin.x - 0.5, 0, this.origin.x - 0.5, this.origin.y + this.dimensions.h, 1);

        let ctx = painter.get_context();

        ctx.save();
        ctx.rect(this.origin.x, 0, this.dimensions.w, this.dimensions.h + this.origin.y);
        ctx.clip();

        // Draw scale
        let counter = 0;

        for (var x = this.origin.x - this.offset.x; x < this.dimensions.w + this.origin.x;
             x += this.step * this.scale) {
            let div = counter % this.step === 0;
            let size = div ? 5.5 : 2.5;

            if (div && counter > 0) {
                painter.text(counter * this.step, x - 5.5, this.origin.y - 9, 90);
                painter.line(x - 0.5, this.origin.y, x - 0.5, this.origin.y + this.dimensions.h, 1, darkLineColor);
            }

            painter.line(x - 0.5, this.origin.y - size, x - 0.5, this.origin.y + size, 1);
            counter++;
        }
        ctx.restore();

        ctx.save();
        ctx.rect(0, this.origin.y, this.dimensions.w + this.origin.x, this.dimensions.h);
        ctx.clip();

        counter = 0;
        for (var y = this.origin.y - this.offset.y; y < this.dimensions.h + this.origin.y;
             y += this.step * this.scale) {
            let div = counter % this.step === 0;
            let size = div ? 5.5 : 2.5;

            if (div && counter > 0) {
                painter.text(counter * this.step, this.origin.x - 9, y + 2.5);
                painter.line(this.origin.x, y - 0.5, this.origin.x + this.dimensions.w, y - 0.5, 1, darkLineColor);
            }

            painter.line(this.origin.x - size, y - 0.5, this.origin.x + size, y - 0.5, 1);
            counter++;
        }
        ctx.restore();
    }

    is_mouse_over(event) { return this.origin.lt(event.clientX, event.clientY); }

    is_mouse_over2(event) { return this.origin.lt(event.offsetX, event.offsetY); }

    /* screen space to coordinate space */
    translate_point_to_cs(x, y)
    {
        return new vec2(Math.round((x - this.origin.x + this.offset.x) / this.scale),
                        Math.round((y - this.origin.y + this.offset.y) / this.scale));
    }

    /* coordinate space to screen space */
    translate_rect_to_screen(r)
    {
        return new r4(r.x * this.scale - this.offset.x + this.origin.x,
                      r.y * this.scale - this.offset.y + this.origin.y, r.w * this.scale, r.h * this.scale);
    }

    translate_point_to_screen(x, y)
    {
        return new vec2(x * this.scale - this.offset.x + this.origin.x, y * this.scale - this.offset.y + this.origin.y);
    }

    click(event)
    {
        if (event.button === 2 && this.is_mouse_over(event)) {
            this.drag_start = new vec2(event.clientX, event.clientY);
            this.orig_offset = this.offset;
            this.dragging = true;
        }
    }

    mouseup() { this.dragging = false; }

    scroll(event)
    {
        let old_mouse = this.translate_point_to_cs(event.clientX, event.clientY);
        let old_scale = this.scale;

        if (event.originalEvent.deltaY < 0) {
            this.scale = Math.min(8, this.scale + 1);
        } else {
            this.scale = Math.max(1, this.scale - 1);
        }

        // Adjust to mouse position
        let new_mouse = this.translate_point_to_cs(event.clientX, event.clientY);
        let offset_factor = this.scale / old_scale;
        this.offset = this.offset.scale(this.scale / old_scale);
        //this.offset = this.offset.sub((new_mouse.x - old_mouse.x) * offset_factor, (new_mouse.x - old_mouse.y) * offset_factor);

        this.offset.limit(0, 0, 3000 * this.scale, 3000 * this.scale);
    }

    move(event)
    {
        if (this.dragging) {
            this.offset = this.orig_offset.addv(this.drag_start.sub(event.clientX, event.clientY));
            this.offset.limit(0, 0, 3000 * this.scale, 3000 * this.scale);
        }
    }

    resize(painter)
    {
        this.dimensions =
            new r2($(this.canvas_id).attr("width") - this.origin.x, $(this.canvas_id).attr("height") - this.origin.y);
    }
}
```

`docs/cct/js/dl.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

function download_json(file_name, content)
{
    var json_data = new Blob([JSON.stringify(content, null, 4)], {type: 'text/json'});
    if (window.navigator && window.navigator.msSaveOrOpenBlob) { // for IE
        window.navigator.msSaveOrOpenBlob(json_data, file_name);
    } else { // for Non-IE (chrome, firefox etc.)
        var a = document.createElement("a");
        document.body.appendChild(a);
        a.style = "display: none";
        var csvUrl = URL.createObjectURL(json_data);
        a.href = csvUrl;
        a.download = file_name;
        a.click();
        URL.revokeObjectURL(a.href)
        a.remove();
    }
}
```

`docs/cct/js/draw.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

var backgroundColor = "#393b3d";
var lineColor = "#ffffffff";
var darkLineColor = "#555555";
var brightLineColor = "#f055559c"

class painter {

    constructor(canvas_id, draw_callback)
    {
        this.enabled = true;
        this.scale = 1; // HiDPI support at some point maybe
        this.canvas_id = '#' + canvas_id;
        this.canvas_container_id = '#' + canvas_id + '-container';
        this.coordinate_system = new cs(this.canvas_id);
        this.draw_callback = draw_callback;
        $(window).on('resize', () => this.resize_canvas());

        requestAnimationFrame(seconds => this.update(seconds)); // start animation
    }

    cs() { return this.coordinate_system; }

    load_image(url)
    {
        return new Promise(r => {
            let i = new Image();
            i.onload = (() => r(i));
            i.src = url;
        });
    }

    get_context() { return $(this.canvas_id)[0].getContext('2d'); }

    fill(w, h, color) { this.rect(0, 0, w, h, color); }

    rect(x, y, w, h, color)
    {
        let context = this.get_context();
        context.beginPath();
        context.rect(x, y, w, h);
        context.fillStyle = color;
        context.fill();
    }

    rect_outline(x, y, w, h, width = 1, color = lineColor)
    {
        let context = this.get_context();
        context.beginPath();
        context.rect(x, y, w, h);
        context.strokeStyle = color;
        context.lineWidth = width;
        context.stroke();
    }

    text(str, x, y, rotate = 0, align = "right", color = lineColor, size = 13, font = "Arial")
    {
        let ctx = this.get_context();
        ctx.save();
        ctx.translate(x, y);
        if (rotate > 0)
            ctx.rotate(rotate * Math.PI / 180);
        ctx.textAlign = align;
        ctx.font = size + "px " + font;
        ctx.fillStyle = color;
        ctx.fillText(str, 0, 0);
        ctx.restore();
    }

    line(x1, y1, x2, y2, width = 2, color = lineColor)
    {
        let ctx = this.get_context();
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
    }

    dashed_line(x1, y1, x2, y2, width = 2, color = lineColor, dash = 5, space = 3)
    {
        let ctx = this.get_context();
        ctx.setLineDash([dash, space]);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
    }

    image(i, x, y)
    {
        let context = this.get_context();
        context.drawImage(i, x, y);
    }

    image_crop(i, x, y, w, h, cx, cy, cw, ch)
    {
        let context = this.get_context();
        context.drawImage(i, cx, cy, cw, ch, x * this.scale, y * this.scale, w * this.scale, h * this.scale);
    }

    resize_canvas()
    {
        let w = $(this.canvas_container_id).innerWidth();
        let h = $(this.canvas_container_id).innerHeight();
        $(this.canvas_id).css({"height": h, "width": w});
        $(this.canvas_id).attr("width", w);
        $(this.canvas_id).attr("height", h);
        this.fill(w, h, backgroundColor);
        this.coordinate_system.resize(this);
        this.get_context().imageSmoothingEnabled = false;
    }

    update(time)
    {
        if (this.enabled) {
            let c = $(this.canvas_id)[0];
            this.fill(c.width, c.height, backgroundColor);
            this.coordinate_system.draw(this);
            if (this.draw_callback !== null)
                this.draw_callback(this, this.coordinate_system);
        }
        requestAnimationFrame(seconds => this.update(seconds)); // get next frame
    }
}

```

`docs/cct/js/editor.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

var leniency = 10;

class editor {
    constructor(canvas_id, painter)
    {
        this.canvas_id = canvas_id;
        this.painter = painter;
        this.move_flags = 0x0;
        this.drag_offset = new vec2();
        this.drag_start = new vec2();
        this.selecting = false;
        this.mouse_pos = new vec2();
        this.mouse_over = false;
        this.shift_pressed = false;
        this.selection_rect = new r4();

        $(canvas_id).on("mousemove", (e) => this.move(e, this.painter.cs()));
        $(canvas_id).on("mouseup", (e) => this.mouseup(e, this.painter.cs()));
        $(canvas_id).on("mousedown", (e) => this.mousedown(e, this.painter.cs()));
        $(window).on("keydown", (e) => this.on_button(e, true));
        $(window).on("keyup", (e) => this.on_button(e, false));
        $("#editor-element-u").on("keyup", (_e) => this.update_selection_from_text());
        $("#editor-element-v").on("keyup", (_e) => this.update_selection_from_text());
        $("#editor-element-w").on("keyup", (_e) => this.update_selection_from_text());
        $("#editor-element-h").on("keyup", (_e) => this.update_selection_from_text());

        let hex_numeric = $(".hex-numeric")[0];
        if (hex_numeric) {
            // jquery doesn't forward the location variable
            hex_numeric.addEventListener("keydown", (e) => {
                if ($("#editor-element-record-code")[0].checked && current_type === element_types.KEYBOARD_KEY) {
                    e.target.value = "0x" + key_to_vc(e).toString(16).toUpperCase();
                    e.preventDefault();
                    return false;
                }
                let text = e.target.value + e.key;
                if (!/^0x[0-9a-fA-F]+$/g.test(text)) {
                    e.target.value = "0x0";
                    e.preventDefault();
                    return false;
                }
            });
            hex_numeric.addEventListener("mouseup", (e) => {
                if ($("#editor-element-record-code")[0].checked && current_type === element_types.MOUSE_BUTTON) {
                    // Scroll wheel pastes text on linux so we delay the action a bit;
                    let val = "0x" + mouse_to_vc(e).toString(16).toUpperCase();
                    setTimeout(() => { e.target.value = val; }, 50);
                }
            });
        }

        pad.on("button", (pad, index, btn) => this.on_gamepad_button(pad, index, btn));
    }

    on_gamepad_button(_pad, index, btn)
    {
        if ($("#editor-element-record-code").val() === "on" && btn.value > 0 &&
            current_type === element_types.GAMEPAD_BUTTON) {
            let vc = "0x" + gamepad_to_vc(index).toString(16).toUpperCase();
            $(".hex-numeric").val(vc);
            console.log($(".hex-numeric").val());
        }
    }

    on_config_load()
    {
        if (cfg.data.default_height !== undefined && cfg.data.default_width !== undefined) {
            this.selection_rect = new r4(1, 1, cfg.data.default_width, cfg.data.default_height);
        } else {
            this.selection_rect = new r4(1, 1, 100, 100);
        }
        this.update_selection_values();
    }

    on_button(event, down) { this.shift_pressed = event.shiftKey; }

    set_cursor(c) { $(this.canvas_id).css({cursor: c}); }

    update_selection_from_text()
    {
        this.selection_rect.x = parseInt($("#editor-element-u").val());
        this.selection_rect.y = parseInt($("#editor-element-v").val());
        this.selection_rect.w = parseInt($("#editor-element-w").val());
        this.selection_rect.h = parseInt($("#editor-element-h").val());
    }

    move(event, cs)
    {
        let tv = cs.translate_point_to_cs(event.offsetX, event.offsetY);
        this.mouse_pos.x = event.offsetX;
        this.mouse_pos.y = event.offsetY;

        if (this.selecting) {
            let new_selection = this.selection_rect.copy();

            if (this.move_flags === 0) {
                // Rubber band selection
                new_selection.from_points(this.drag_start, tv);
            } else {
                if (this.move_flags & 0b0001)
                    new_selection.h = tv.y - new_selection.y;
                if (this.move_flags & 0b0010) {
                    new_selection.h += new_selection.y - tv.y;
                    new_selection.y = tv.y;
                }

                if (this.move_flags & 0b0100)
                    new_selection.w = tv.x - new_selection.x;
                if (this.move_flags & 0b1000) {
                    new_selection.w += new_selection.x - tv.x;
                    new_selection.x = tv.x;
                }

                if (this.move_flags & 0b10000) {
                    new_selection.x = tv.x - this.drag_offset.x;
                    new_selection.y = tv.y - this.drag_offset.y;
                }

                // prevent the selection from getting to small
                if (new_selection.w < leniency + 3 || new_selection.x < 0) {
                    new_selection.w = this.selection_rect.w;
                    new_selection.x = this.selection_rect.x;
                }
                if (new_selection.h < leniency + 3 || new_selection.y < 0) {
                    new_selection.h = this.selection_rect.h;
                    new_selection.y = this.selection_rect.y;
                }
            }

            this.update_selection_values();
            this.selection_rect = new_selection;
            return;
        }

        let flags = 0b0000; // left, right, up, down
        let l = leniency / (cs.scale / 2);
        let cursor_box = this.selection_rect.grow(l);
        this.mouse_over = cs.is_mouse_over2(event);

        if (this.mouse_over) {
            if (cursor_box.is_point_inside(tv)) {
                if (Math.abs(tv.x - this.selection_rect.x) < l)
                    flags |= 0b1000;
                else if (Math.abs(tv.x - (this.selection_rect.w + this.selection_rect.x)) < l)
                    flags |= 0b0100;
                if (Math.abs(tv.y - this.selection_rect.y) < l)
                    flags |= 0b0010;
                else if (Math.abs(tv.y - (this.selection_rect.h + this.selection_rect.y)) < l)
                    flags |= 0b0001;
            }

            if (flags === 0 && this.selection_rect.is_point_inside(tv))
                flags = 0b10000; // move cursor
        }

        if (flags & 0b1000) {
            if (flags & 0b0010) {
                // top left
                this.set_cursor("nw-resize");
            } else if (flags & 0b0001) {
                // bottom left
                this.set_cursor("sw-resize");
            } else {
                // left
                this.set_cursor("w-resize");
            }
        } else if (flags & 0b0100) {
            if (flags & 0b0010) {
                // top right
                this.set_cursor("ne-resize");
            } else if (flags & 0b0001) {
                // bottom right
                this.set_cursor("se-resize");
            } else {
                // right
                this.set_cursor("e-resize");
            }
        } else if (flags & 0b0001) {
            this.set_cursor("s-resize");
        } else if (flags & 0b0010) {
            this.set_cursor("n-resize");
        } else if (flags & 0b10000) {
            this.set_cursor("move");
        } else {
            if (cs.dragging) {
                this.set_cursor("grabbing");
            } else {
                if (this.mouse_over)
                    this.set_cursor("crosshair");
                else
                    this.set_cursor("auto");
            }
        }
        this.move_flags = flags;
    }

    mouseup(_event, _cs) { this.selecting = false; }

    update_selection_values()
    {
        $("#editor-element-u").val(this.selection_rect.x);
        $("#editor-element-v").val(this.selection_rect.y);
        $("#editor-element-w").val(this.selection_rect.w);
        $("#editor-element-h").val(this.selection_rect.h);
    }

    mousedown(event, cs)
    {
        if (event.button == 0 && this.mouse_over) {
            let tv = cs.translate_point_to_cs(event.offsetX, event.offsetY);
            this.drag_offset.x = tv.x - this.selection_rect.x;
            this.drag_offset.y = tv.y - this.selection_rect.y;
            this.drag_start = tv;
            this.selecting = true;
        }
    }

    draw(painter)
    {
        if (atlas === null)
            // Don't draw if image hasn't loaded yet
            return;
        let ctx = painter.get_context();
        let cs = painter.cs();

        ctx.save();
        ctx.rect(cs.origin.x, cs.origin.y, cs.dimensions.w, cs.dimensions.h);
        ctx.clip();
        painter.image_crop(atlas, cs.origin.x - cs.offset.x, cs.origin.y - cs.offset.y, atlas.width * cs.scale,
                           atlas.height * cs.scale, 0, 0, atlas.width, atlas.height);

        // Draw selection
        let r = cs.translate_rect_to_screen(this.selection_rect);
        painter.rect_outline(r.x + 0.5, r.y + 0.5, r.w - 1, r.h - 1, 1, "#ff0000ff");

        if (this.mouse_over && !this.shift_pressed) {
            if (this.move_flags === 0) {
                // draw help lines at mouse pos
                painter.dashed_line(this.mouse_pos.x - 0.5, cs.origin.y, this.mouse_pos.x - 0.5,
                                    cs.origin.y + cs.dimensions.h, 1);
                painter.dashed_line(cs.origin.x, this.mouse_pos.y - 0.5, cs.origin.x + cs.dimensions.w,
                                    this.mouse_pos.y - 0.5, 1);
            } else {
                // draw help lines around selection
                painter.dashed_line(r.x - 0.5, cs.origin.y, r.x - 0.5, cs.origin.y + cs.dimensions.h, 1);
                painter.dashed_line(r.x + r.w - 0.5, cs.origin.y, r.x + r.w - 0.5, cs.origin.y + cs.dimensions.h, 1);
                painter.dashed_line(cs.origin.x, r.y - 0.5, cs.origin.x + cs.dimensions.w, r.y - 0.5, 1);
                painter.dashed_line(cs.origin.x, r.y + r.h - 0.5, cs.origin.x + cs.dimensions.w, r.y + r.h - 0.5, 1);
            }
        }
        ctx.restore();
    }
}

```

`docs/cct/js/elements.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

let element_types = {
    TEXTURE: 0,
    KEYBOARD_KEY: 1,
    GAMEPAD_BUTTON: 2,
    MOUSE_BUTTON: 3,
    WHEEL: 4,
    ANALOG_STICK: 5,
    TRIGGER: 6,
    /* Shows game pad number 1 through 4 */
    GAMEPAD_ID: 7,
    DPAD_STICK: 8,
    MOUSE_MOVEMENT: 9,
};

let overlay_flags = {
    LEFT_STICK: 1 << 0,
    RIGHT_STICK: 1 << 1,
    GAMEPAD: 1 << 2,
    MOUSE: 1 << 3,
};

let constants = {texture_space: 3};

let element_map = new Map();

function type_from_string(type)
{
    switch (type) {
    case "mouse_button":
        return element_types.MOUSE_BUTTON;
    case "keyboard_button":
        return element_types.KEYBOARD_KEY;
    case "texture":
        return element_types.TEXTURE;
    case "gamepad_button":
        return element_types.GAMEPAD_BUTTON;
    case "analog_stick":
        return element_types.ANALOG_STICK;
    case "trigger":
        return element_types.TRIGGER;
    case "mouse_movement":
        return element_types.MOUSE_MOVEMENT;
    case "mouse_wheel":
        return element_types.WHEEL;
    case "player_id":
        return element_types.GAMEPAD_ID;
    case "dpad":
        return element_types.DPAD_STICK;
    case "mouse_movement":
        return element_types.MOUSE_MOVEMENT;
    default:
        return -1;
    }
}

function type_from_id(type)
{
    switch (type) {
    case element_types.MOUSE_BUTTON:
        return "mouse_button";
    case element_types.KEYBOARD_KEY:
        return "keyboard_button";
    case element_types.TEXTURE:
        return "texture";
    case element_types.GAMEPAD_BUTTON:
        return "gamepad_button";
    case element_types.ANALOG_STICK:
        return "analog_stick";
    case element_types.TRIGGER:
        return "trigger";
    case element_types.MOUSE_MOVEMENT:
        return "mouse_movement";
    case element_types.WHEEL:
        return "mouse_wheel";
    case element_types.GAMEPAD_ID:
        return "player_id";
    default:
        return "";
    }
}

class element {
    constructor(json) { this.data = json; }

    draw(painter) {}
    on_keyboard_input(vc, state) {}
    on_mouse_input(vc, state) {}
    on_gamepad_input(pad) {}
    on_scroll_input(event) {}

    tick() {}

    scaled_dim(cs)
    {
        return new r4(cs.origin.x - cs.offset.x + this.x() * cs.scale, cs.origin.y - cs.offset.y + this.y() * cs.scale,
                      this.w() * cs.scale, this.h() * cs.scale);
    }

    read_data_from_gui()
    {
        this.data.id = $("#editor-element-id").val();
        this.data.z_level = parseInt($("#editor-element-layer").val());
    }

    write_data_to_gui()
    {
        $("#editor-element-id").val(this.data.id);
        $("#editor-element-layer").val(this.data.z_level);
    }

    dim() { return new r4(this.x(), this.y(), this.w(), this.h()); }

    set_dim(pos, uvwh)
    {
        this.data.pos[0] = pos.x;
        this.data.pos[1] = pos.y;
        this.data.mapping[0] = uvwh.x;
        this.data.mapping[1] = uvwh.y;
        this.data.mapping[2] = uvwh.w;
        this.data.mapping[3] = uvwh.h;
    }

    type() { return this.data.type; }
    id() { return this.data.id; }
    x() { return this.data.pos[0]; }
    y() { return this.data.pos[1]; }
    u() { return this.data.mapping[0]; }
    v() { return this.data.mapping[1]; }
    w() { return this.data.mapping[2]; }
    h() { return this.data.mapping[3]; }
    set_id(id) { this.data.id = id; }

    set_pos(x, y)
    {
        this.data.pos[0] = x;
        this.data.pos[1] = y;
    }

    layer() { return this.data.z_level; }
    set_layer(layer) { this.data.z_level = layer; }
}

class texture extends element {
    draw(painter)
    {
        // default draw handling
        let cs = painter.cs();
        painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                           cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale, this.h() * cs.scale,
                           this.u(), this.v(), this.w(), this.h());
    }

    read_data_from_gui()
    {
        super.read_data_from_gui();
        this.data.mapping = [
            parseInt($("#editor-element-u").val()),
            parseInt($("#editor-element-v").val()),
            parseInt($("#editor-element-w").val()),
            parseInt($("#editor-element-h").val()),
        ];
    }

    write_data_to_gui()
    {
        super.write_data_to_gui();
        $("#editor-element-u").val(this.u());
        $("#editor-element-v").val(this.v());
        $("#editor-element-w").val(this.w());
        $("#editor-element-h").val(this.h());
    }
}

class button extends texture {
    constructor(json)
    {
        super(json);
        this.pressed = false;
    }

    draw(painter)
    {
        if (this.pressed) {
            let cs = painter.cs();
            painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                               cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale,
                               this.h() * cs.scale, this.u(), this.v() + constants.texture_space + this.h(), this.w(),
                               this.h());
        } else {
            super.draw(painter, cs);
        }
    }

    read_data_from_gui()
    {
        super.read_data_from_gui();
        this.data.code = parseInt($("#editor-element-keycode").val(), 16);
    }

    write_data_to_gui()
    {
        super.write_data_to_gui();
        $("#editor-element-keycode").val("0x" + this.data.code.toString(16).toUpperCase());
    }
}

class keyboard_button extends button {
    on_keyboard_input(vc, state)
    {
        if (vc === this.data.code)
            this.pressed = state;
    }
}

class mouse_button extends button {
    on_mouse_input(vc, state)
    {
        if (vc === this.data.code)
            this.pressed = state;
    }
}

class gamepad_button extends button {
    on_gamepad_input(pad)
    {
        let btn = gamepad_from_vc(this.data.code);

        if (btn < pad.buttons.length)
            this.pressed = pad.buttons[btn].pressed;
    }
}

class mouse_wheel extends texture {
    constructor(json)
    {
        super(json);
        this.direction = 0;
        this.pressed = false;
        this.lastWheelInput = Date.now();
    }

    on_mouse_input(vc, state)
    {
        if (vc === 3)
            this.pressed = state;
    }

    on_scroll_input(event)
    {
        if (event.originalEvent.deltaY < 0) {
            this.direction = -1;
        } else {
            this.direction = 1;
        }
        this.lastWheelInput = Date.now();
    }

    tick()
    {
        if (Date.now() - this.lastWheelInput > 250)
            this.direction = 0;
    }

    draw(painter)
    {
        let cs = painter.cs();
        super.draw(painter, cs);
        if (this.pressed) {
            painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                               cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale,
                               this.h() * cs.scale, this.u() + constants.texture_space + this.w(), this.v(), this.w(),
                               this.h());
        }

        if (this.direction === 1) {
            painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                               cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale,
                               this.h() * cs.scale, this.u() + (constants.texture_space + this.w()) * 2, this.v(),
                               this.w(), this.h());
        } else if (this.direction === -1) {
            painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                               cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale,
                               this.h() * cs.scale, this.u() + (constants.texture_space + this.w()) * 3, this.v(),
                               this.w(), this.h());
        }
    }
}

class analog_stick extends texture {
    draw(painter)
    {
        let cs = painter.cs();
        let xPos = 0;
        let yPos = 0;
        let pressed = false;
        if (pad.lastInput) {
            if (this.data.side === 0) {
                // left
                xPos = pad.lastInput.axes[0] * this.data.stick_radius;
                yPos = pad.lastInput.axes[1] * this.data.stick_radius;
                pressed = pad.lastInput.buttons[10].pressed;
            } else {
                // right
                xPos = pad.lastInput.axes[2] * this.data.stick_radius;
                yPos = pad.lastInput.axes[3] * this.data.stick_radius;
                pressed = pad.lastInput.buttons[11].pressed;
            }

            if (pressed) {
                painter.image_crop(atlas, cs.origin.x - cs.offset.x + (this.x() + xPos) * cs.scale,
                                   cs.origin.y - cs.offset.y + (this.y() + yPos) * cs.scale, this.w() * cs.scale,
                                   this.h() * cs.scale, this.u(), this.v() + constants.texture_space + this.h(),
                                   this.w(), this.h());
            } else {
                painter.image_crop(atlas, cs.origin.x - cs.offset.x + (this.x() + xPos) * cs.scale,
                                   cs.origin.y - cs.offset.y + (this.y() + yPos) * cs.scale, this.w() * cs.scale,
                                   this.h() * cs.scale, this.u(), this.v(), this.w(), this.h());
            }
        } else {
            super.draw(painter);
        }
    }

    read_data_from_gui()
    {
        super.read_data_from_gui();
        this.data.stick_radius = parseInt($("#editor-element-analog-stick-radius").val());
        this.data.side = parseInt($("#editor-element-analog-stick-side").val());
    }

    write_data_to_gui()
    {
        super.write_data_to_gui();
        $("#editor-element-analog-stick-radius").val(this.data.stick_radius);
        $("#editor-element-analog-stick-side").val(this.data.side);
    }

    is_left_stick() { return this.side === 0; }
}

class gamepad_id extends texture {
    constructor(json)
    {
        super(json);
        this.pressed = false;
    }

    on_gamepad_input(pad)
    {
        let btn = gamepad_from_vc(this.data.code);

        if (pad.buttons.length > 16)
            this.pressed = pad.buttons[16].pressed;
    }

    draw(painter)
    {
        let cs = painter.cs();
        if (pad.lastInput) {
            if (this.pressed) {
                painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                                   cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale,
                                   this.h() * cs.scale, this.u() + (constants.texture_space + this.w()) * 4, this.v(),
                                   this.w(), this.h());
            }
            painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                               cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale,
                               this.h() * cs.scale,
                               this.u() + (constants.texture_space + this.w()) * pad.lastInput.index, this.v(),
                               this.w(), this.h());
        } else {
            painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                               cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale,
                               this.h() * cs.scale, this.u(), this.v(), this.w(), this.h());
        }
    }
}

class trigger extends texture {
    draw(painter)
    {
        let cs = painter.cs();
        let progress = 0;
        let pressed = false;

        if (pad.lastInput) {
            if (this.data.side === 0) {
                // left
                progress = pad.lastInput.buttons[6].value;
                pressed = pad.lastInput.buttons[6].pressed;
            } else {
                // right
                progress = pad.lastInput.buttons[7].value;
                pressed = pad.lastInput.buttons[7].pressed;
            }

            if (this.data.trigger_mode) {
                if (pressed) {
                    painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                                       cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale,
                                       this.h() * cs.scale, this.u(), this.v() + constants.texture_space + this.h(),
                                       this.w(), this.h());
                } else {
                    painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                                       cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale,
                                       this.h() * cs.scale, this.u(), this.v(), this.w(), this.h());
                }
            } else {
                super.draw(painter);
                if (this.data.direction === 1) {
                    // fill upwards
                    let offset = (1 - progress) * this.h();
                    painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                                       cs.origin.y - cs.offset.y + (this.y() + offset) * cs.scale, this.w() * cs.scale,
                                       this.h() * progress * cs.scale, this.u(),
                                       this.v() + this.h() + constants.texture_space + offset, this.w(),
                                       this.h() * progress);
                } else if (this.data.direction === 2) {
                    // fill downwards
                    painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                                       cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale,
                                       this.h() * progress * cs.scale, this.u(),
                                       this.v() + constants.texture_space + this.h(), this.w(), this.h() * progress);
                } else if (this.data.direction === 3) {
                    // fill to the left
                    let offset = (1 - progress) * this.w();
                    painter.image_crop(atlas, cs.origin.x - cs.offset.x + (this.x() + offset) * cs.scale,
                                       cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * progress * cs.scale,
                                       this.h() * cs.scale, this.u() + offset,
                                       this.v() + constants.texture_space + this.h(), this.w() * progress, this.h());
                } else if (this.data.direction === 4) {
                    // fill to the right
                    painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                                       cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * progress * cs.scale,
                                       this.h() * cs.scale, this.u(), this.v() + constants.texture_space + this.h(),
                                       this.w() * progress, this.h());
                }
            }
        } else {
            super.draw(painter);
        }
    }

    read_data_from_gui()
    {
        super.read_data_from_gui();
        this.data.direction = parseInt($("#editor-element-trigger-direction-side").val());
        this.data.trigger_mode = $("#editor-element-trigger-button")[0].checked;
        this.data.side = parseInt($("#editor-element-analog-stick-side").val());
    }

    write_data_to_gui()
    {
        super.write_data_to_gui();
        $("#editor-element-trigger-direction-side").val(this.data.direction);
        $("#editor-element-trigger-button")[0].checked = this.data.trigger_mode ? true : false;
        $("#editor-element-analog-stick-side").val(this.data.side);
    }
}

class dpad extends texture {
    constructor(json)
    {
        super(json);
        this.offset = 0;
    }
    on_gamepad_input(pad)
    {
        let up = pad.buttons[12].pressed;
        let down = pad.buttons[13].pressed;
        let left = pad.buttons[14].pressed;
        let right = pad.buttons[15].pressed;

        if (left) {
            if (up)
                this.offset = 5;
            else if (down)
                this.offset = 7;
            else
                this.offset = 1;
        } else if (right) {
            if (up)
                this.offset = 6;
            else if (down)
                this.offset = 8;
            else
                this.offset = 2;
        } else if (up) {
            if (left)
                this.offset = 5;
            else if (right)
                this.offset = 6;
            else
                this.offset = 3;
        } else if (down) {
            if (left)
                this.offset = 7;
            else if (right)
                this.offset = 8;
            else
                this.offset = 4;
        } else {
            this.offset = 0;
        }
    }

    draw(painter)
    {
        let cs = painter.cs();
        painter.image_crop(atlas, cs.origin.x - cs.offset.x + this.x() * cs.scale,
                           cs.origin.y - cs.offset.y + this.y() * cs.scale, this.w() * cs.scale, this.h() * cs.scale,
                           this.u() + (constants.texture_space + this.w()) * this.offset, this.v(), this.w(), this.h());
    }
}
class mouse_movement extends texture {
    // TODO: Actually visualize this in the editor
    read_data_from_gui()
    {
        super.read_data_from_gui();
        this.data.mouse_type = parseInt($("#editor-element-movement-type").val());
    }

    write_data_to_gui()
    {
        super.write_data_to_gui();
        $("#editor-element-movement-type").val(this.data.mouse_type);
    }
}
element_map.set(element_types.KEYBOARD_KEY, (json) => { return new keyboard_button(json); });
element_map.set(element_types.MOUSE_BUTTON, (json) => { return new mouse_button(json); });
element_map.set(element_types.TEXTURE, (json) => { return new texture(json); });
element_map.set(element_types.GAMEPAD_BUTTON, (json) => { return new gamepad_button(json); });
element_map.set(element_types.WHEEL, (json) => { return new mouse_wheel(json); });
element_map.set(element_types.ANALOG_STICK, (json) => { return new analog_stick(json); });
element_map.set(element_types.TRIGGER, (json) => { return new trigger(json); });
element_map.set(element_types.GAMEPAD_ID, (json) => { return new gamepad_id(json); });
element_map.set(element_types.DPAD_STICK, (json) => { return new dpad(json); });
element_map.set(element_types.MOUSE_MOVEMENT, (json) => { return new mouse_movement(json); });

function create_element(json)
{
    if (element_map.has(json.type))
        return element_map.get(json.type)(json);
    return null;
}

```

`docs/cct/js/file.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

var drop_areas = new Map();

function preventDefaults(e)
{
    e.preventDefault();
    e.stopPropagation();
}

function handle_file_selected(files, id)
{
    if (drop_areas.has(id))
        drop_areas.get(id).on_select(files);
}

class drop_area {
    constructor(id, type = "application/json", label = "Select or drag file here")
    {
        drop_areas.set(id, this);
        this.area = document.getElementById(id);
        // Prevent default drag behaviors
        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
            this.area.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        // Highlight drop area when item is dragged over it
        ["dragenter", "dragover"].forEach(
            (eventName) => { this.area.addEventListener(eventName, (e) => this.highlight(e), false); });
        ["dragleave", "drop"].forEach(
            (eventName) => { this.area.addEventListener(eventName, (e) => this.unhighlight(e), false); });

        // Handle dropped files
        this.area.addEventListener("drop", (e) => this.handle_drop(e), false);

        // Handle file select
        this.area.innerHTML = `
    <form>
    <input type="file" id="${id}-input" accept="${type}" onchange="handle_file_selected(this.files, '${id}')">
    <label class="button" id="${id}-label" for="${id}-input">${label}</label>
    <p style="display: inline" id="${id}-file-label"></p>
    </form>
    `;
        this.label = document.getElementById(id + "-file-label");
        this.handlers = [];
    }

    on_select(files)
    {
        this.handlers.forEach((h) => h(files));
        this.label.innerText = files[0].name;
    }

    highlight(e) { this.area.classList.add("highlight"); }

    unhighlight(e) { this.area.classList.remove("highlight"); }

    handle_drop(e)
    {
        var dt = e.dataTransfer;
        var files = dt.files;

        this.on_select(files);
    }
}

```

`docs/cct/js/gamepad.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

class gamepad {
    constructor(interval = 25)
    {
        this.lastTimestamp = new Map();
        this.lastState = new Map();
        this.lastInput = null;
        this.connect = [];
        this.disconnect = [];
        this.button = [];       // (gamepad, button index, button)
        this.axis = [];         // (gamepad, axis index, new axis value)
        this.event = [];        // (gamepad)
        this.threshold = 0.001; // If the value delta is higher than this we consider the value changed
        window.addEventListener('gamepadconnected', (event) => this.onConnect(event));
        window.addEventListener('gamepaddisconnected', (event) => this.onConnect(event));
        this.handle = setInterval(() => this.tick(), interval);
    }

    tick()
    {
        let pads = navigator.getGamepads();
        for (let i = 0; i < pads.length; pads++) {
            let pad = pads[i];
            if (!pad)
                continue;
            let lastTimeStamp = 0;
            let lastState = null;

            if (this.lastTimestamp.has(pad.index))
                lastTimeStamp = this.lastTimestamp.get(pad.index);
            if (this.lastState.has(pad.index))
                lastState = this.lastState.get(pad.index);

            if (pad && pad.timestamp > lastTimeStamp) {
                this.lastTimestamp.set(pad.index, pad.timestamp);
                if (lastState) {
                    for (let j = 0; j < pad.axes.length; j++) {
                        if (Math.abs(lastState.axes[j] - pad.axes[j]) > this.threshold)
                            this.onAxis(pad, j);
                    }

                    for (let j = 0; j < pad.buttons.length; j++) {
                        if (Math.abs(lastState.buttons[j].value - pad.buttons[j].value) > this.threshold)
                            this.onButton(pad, j);
                    }
                } else {
                    for (let j = 0; j < pad.axes.length; j++)
                        this.onAxis(pad, j);
                    for (let j = 0; j < pad.buttons.length; j++)
                        this.onButton(pad, j);
                }
                this.lastState.set(pad.index, pad);
            }
        }
    }

    onAxis(pad, index)
    {
        this.axis.forEach(h => h(pad, index, pad.axes[index]));
        this.event.forEach(h => h(pad));
        this.lastInput = pad;
    }

    onButton(pad, index)
    {
        this.button.forEach(h => h(pad, index, pad.buttons[index]));
        this.event.forEach(h => h(pad));
        this.lastInput = pad;
    }

    on(id, handler)
    {
        switch (id.toLowerCase()) {
        case 'connect':
            this.connect.push(handler);
            break;
        case 'disconnect':
            this.disconnect.push(handler);
            break;
        case 'button':
            this.button.push(handler);
            break;
        case 'move':
            this.axis.push(handler);
            break;
        case 'input':
            this.event.push(handler);
            break;
        };
    }

    onConnect(event) { this.connect.forEach(h => h(event)); }

    onDisconnect(event) { this.disconnect.forEach(h => h(event)); }
};
```

`docs/cct/js/gui.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

var current_type = -1;
var is_editing_element = false;
var selected_element = null;

function apply_settings()
{
    if (cfg !== null && cfg.selected_elements.length > 0) {

        if (!cfg.is_name_unique($("#selected-element-id").val(), cfg.selected_elements[0])) {
            alert('The element id is not unique.');
            return;
        }

        if (cfg.selected_elements.length === 1) {
            // We only apply these settings if a single element is selected
            let pos = new vec2($("#selected-element-x").val(), $("#selected-element-y").val());
            let dim = new r4($("#selected-element-u").val(), $("#selected-element-v").val(),
                             $("#selected-element-w").val(), $("#selected-element-h").val());

            dim.validate();
            pos.validate();

            cfg.selected_elements[0].set_dim(pos, dim);
            cfg.selected_elements[0].set_layer($("#selected-element-layer").val());
            cfg.selected_elements[0].set_id($("#selected-element-id").val());
            cfg.set_selection(cfg.selected_elements[0]);
        } else {
            // Only set the layer if there's multiple elements selected
            cfg.selected_elements.forEach(element => { element.set_layer($("#selected-element-layer").val()); });
        }
    }
}

function new_type_dropdown()
{
    document.getElementById("type-dropdown").classList.toggle("show");
}

function show_property(prop)
{
    prop.label.css({"display": "flex"});
    if (prop.div)
        prop.div.css({"display": "flex"});
}

function hide_property(prop)
{
    if (prop.div)
        prop.label.css({"display": "none"});
    if (prop.div)
        prop.div.css({"display": "none"});
}

function set_description(desc_element, text)
{
    desc_element.label[0].innerHTML = '<p>' + text + '</p>';
    show_property(desc_element)
}

function get_property(type)
{
    return { label: $('#editor-element-' + type + '-label'), div: $('#editor-element-' + type + '-container') }
}

function setup_editor(type)
{
    let analog_stick_side = get_property('analog-stick-side');
    let analog_stick_radius = get_property('analog-stick-radius');
    let keycode = get_property('keycode');
    let trigger_dir = get_property('trigger-direction');
    let movement_type = get_property('movement-type');
    let description = get_property('description');
    let button = get_property('trigger-button');
    let record = get_property('record-code');

    current_type = type_from_string(type);
    // First hide all optional settings
    hide_property(analog_stick_side);
    hide_property(analog_stick_radius);
    hide_property(trigger_dir);
    hide_property(keycode);
    hide_property(movement_type);
    hide_property(description);
    hide_property(button);
    hide_property(record);

    switch (type) {
    case 'gamepad_button':
    case 'mouse_button':
    case 'keyboard_button': {
        show_property(keycode);
        show_property(record);
        break;
    }
    case 'analog_stick': {
        show_property(analog_stick_radius);
        show_property(analog_stick_side);
        break;
    }
    case 'trigger': {
        show_property(trigger_dir);
        show_property(analog_stick_side);
        show_property(button);
        set_description(description, `The trigger can either be a button, meaning that it'll
                only be either on or off, or it can display the position it is in by filling up
                in a direction.`);
        break;
    }
    case 'mouse_wheel': {
        set_description(description, `The mouse wheel expects the following three textures 
                to be next to eachother in the atlas:<br>
                &nbsp;- neutral<br>
                &nbsp;- clicked<br>
                &nbsp;- scrolling up<br>
                &nbsp;- scrolling down<br>You only have to select the first one.`);
        break;
    }
    case 'dpad': {
        set_description(description, `The dpad stick expects the following textures
        to be next to eachother in the atlas:<br>
        &nbsp;- neutral<br>
        &nbsp;- moved to the left<br>
        &nbsp;- moved to the right<br>
        &nbsp;- moved up<br>
        &nbsp;- moved down<br>
        &nbsp;- moved to the top left<br>
        &nbsp;- moved to the top right<br>
        &nbsp;- moved to bottom left<br>
        &nbsp;- moved to bottom right<br>
        You only have to select the first one.`);
        break;
    }
    case 'mouse_movement': {
        show_property(movement_type);
        set_description(
            description,
            `Mouse movement can be visualized in two ways. Either through 'Point' which will rotate an image
        in the direction the mouse is moved, for example an arrow which points up if you move the mouse up. 'Move' move an image in the direction
        the mouse is moved within a certain radius.`);
        break;
    }
    case 'player_id': {
        set_description(description, `Displays the controller id from one to four. Usually in the order they
            were connected in. The following textures have to be next to eachother in the atlas:<br>
            &nbsp;- Player 1<br>
            &nbsp;- Player 2<br>
            &nbsp;- Player 3<br>
            &nbsp;- Player 4<br>
            &nbsp;- <a href="https://i.imgur.com/LdH3nnz.png" target="_tab">Guide</a> pressed<br>
            You only have to select the first one.<br>`);
        break;
    }
    }
}

function setup()
{
    if (!atlas) {
        alert("Please load a texture first");
        return;
    }

    cfg.data.default_width = parseInt($('#default-width').val());
    cfg.data.default_height = parseInt($('#default-height').val());
    cfg.data.space_h = parseInt($('#horizontal-offset').val());
    cfg.data.space_v = parseInt($('#vertical-offset').val());
    cfg.grid.x = cfg.data.default_width + cfg.data.space_h;
    cfg.grid.y = cfg.data.default_height + cfg.data.space_v;

    let d = $("#setup-dialog")[0];
    let c = $('#main-canvas-container')[0];
    let e = $('#element-dialog')[0];

    if (d !== null) {
        d.style.opacity = 0;
        d.style.pointerEvents = "none";
        c.style.pointerEvents = "all";
        c.classList.remove("blurred");
        e.classList.remove("blurred");
        e.style.pointerEvents = "all";
    }
    main_painter.enabled = true;
    cfg.enabled = true;
}

function open_editor(element_type, is_editing)
{
    let d = $("#edit-element-dialog")[0];
    let c = $('#main-canvas-container')[0];
    let e = $('#element-dialog')[0];
    let title = $('#editor-title')[0];
    is_editing_element = is_editing;

    if (is_editing) {
        if (cfg.selected_elements.length > 0) {
            title.innerText = 'Edit ' + cfg.selected_elements[0].id();
            selected_element = cfg.selected_elements[0];
            selected_element.write_data_to_gui();
            element_type = type_from_id(selected_element.type());
            edit.selection_rect =
                new r4(selected_element.u(), selected_element.v(), selected_element.w(), selected_element.h());
        } else {
            alert('Please select an element first');
            return;
        }
    } else {
        let id = element_type.replace('_', ' ');
        title.innerText = 'Create new ' + id;
        $('#editor-element-id').val(id + cfg.elements.length);
    }

    setup_editor(element_type);
    if (cfg.data.default_width + cfg.data.default_height > 0) {
        edit.selection_rect = new r4(1, 1, cfg.data.default_width, cfg.data.default_height);
        edit.update_selection_values();
    }
    if (d !== null) {
        d.style.opacity = 1;
        d.style.pointerEvents = "all";
        d.style.display = "block";
        c.style.pointerEvents = "none";
        c.classList.add("blurred");
        e.style.pointerEvents = "none";
        e.classList.add("blurred");
    }
    main_painter.enabled = false;
    cfg.enabled = false;
    editor_painter.resize_canvas();
}

function close_editor(handler)
{
    main_painter.enabled = true;
    cfg.enabled = true;

    let d = $("#edit-element-dialog")[0];
    let c = $('#main-canvas-container')[0];
    let e = $('#element-dialog')[0];

    if (handler !== undefined)
        handler();
    if (d !== null) {
        d.style.opacity = 0;
        d.style.pointerEvents = "none";
        c.style.pointerEvents = "all";
        c.classList.remove("blurred");
        e.classList.remove("blurred");
        e.style.pointerEvents = "all";
    }
}

function apply_editor()
{
    if (!cfg.is_name_unique($("#editor-element-id").val(), selected_element)) {
        alert("Element id isn't unique");
        return;
    }

    if (is_editing_element) {
        selected_element.read_data_from_gui();
    } else {
        // basic json
        let json = {type: current_type, pos: [0, 0]};

        let new_element = create_element(json);
        new_element.read_data_from_gui();
        cfg.elements.push(new_element);
    }
    close_editor();
}

function download_config()
{
    download_json(cfg_name, cfg.write_to_json());
}

$(function() {
    $(".coord").on("keydown", e => {
        if (!e)
            var e = window.event;
        if (e.keyCode == 13) {
            apply_settings();
            e.preventDefault();
        }
    });
    $("#ok").on("click", e => apply_settings());
    $("#del").on("click", e => {
        if (cfg.selected_elements.length > 1) {
            // Ask for comfirmation when deleting more than one element
            if (confirm("You are about to delete " + cfg.selected_elements.length + " elements. Are you sure?")) {
                cfg.delete_selection();
            }
        } else {
            cfg.delete_selection();
        }
    });

    $(window).on("click", e => {
        if (!e.target.matches('.dropbtn')) {
            let dropdowns = document.getElementsByClassName("dropdown-content");
            let i;
            for (i = 0; i < dropdowns.length; i++) {
                let openDropdown = dropdowns[i];
                if (openDropdown.classList.contains('show')) {
                    openDropdown.classList.remove('show');
                }
            }
        }
    });

    // setup numeric textboxes
    let numerics = $('.numeric');

    for (let i = 0; i < numerics.length; i++) {
        let e = numerics[i];
        $(e).on('keydown', e => {
            let k = e.which;
            console.log(k);
            /* numeric inputs can come from the keypad or the numeric row at the top
             * also arrows, home & end and backspace
             */
            if (!((k >= 48 && k <= 57) || (k >= 96 && k <= 105) || k === 109 || k === 9 || (k >= 35 && k <= 40) ||
                  k === 8)) {
                e.preventDefault();
                return false;
            }
        });
    }
});
```

`docs/cct/js/jquery-3.5.1.min.js`:

```js
/*! jQuery v3.5.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.5.1",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),"function"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S="sizzle"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",F=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",B=new RegExp(M+"+","g"),$=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp(F),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+xe(l[o]);c=l.join(",")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return g(t.replace($,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement("div")),"undefined"!=typeof e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML="<a id='"+S+"'></a><select id='"+S+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+S+"-]").length||v.push("~="),(t=C.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||v.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+S+"+*").length||v.push(".#.+[+~]"),e.querySelectorAll("\\\f"),v.push("[\\r\\n\\f]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",F)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&m(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(B," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,"$1"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace($,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split("").sort(D).join("")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[":"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function D(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):"string"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(D(this,e||[],!1))},not:function(e){return this.pushStack(D(this,e||[],!0))},is:function(e){return!!D(this,"string"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var j,q=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||j,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,j=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,"parentNode")},parentsUntil:function(e,t,n){return h(e,"parentNode",n)},next:function(e){return O(e,"nextSibling")},prev:function(e){return O(e,"previousSibling")},nextAll:function(e){return h(e,"nextSibling")},prevAll:function(e){return h(e,"previousSibling")},nextUntil:function(e,t,n){return h(e,"nextSibling",n)},prevUntil:function(e,t,n){return h(e,"previousSibling",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,"template")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\x20\t\r\n\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[["notify","progress",S.Callbacks("memory"),S.Callbacks("memory"),2],["resolve","done",S.Callbacks("once memory"),S.Callbacks("once memory"),0,"resolved"],["reject","fail",S.Callbacks("once memory"),S.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),S.ready()}S.fn.ready=function(e){return F.then(e)["catch"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,"ms-").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(K,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks("once memory").add(function(){Y.remove(e,[t+"queue",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Y.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,te=new RegExp("^(?:([+-])=|)("+ee+")([a-z%]*)$","i"),ne=["Top","Right","Bottom","Left"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&ie(e)&&"none"===S.css(e,"display")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,"")},u=s(),l=n&&n[3]||(S.cssNumber[t]?"":"px"),c=e.nodeType&&(S.cssNumber[t]||"px"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Y.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ue[s]=u)))):"none"!==n&&(l[c]="none",Y.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement("div")),(fe=E.createElement("input")).setAttribute("type","radio"),fe.setAttribute("checked","checked"),fe.setAttribute("name","t"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML="<option></option>",y.option=!!ce.lastChild;var ge={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],"globalEval",!t||Y.get(t[n],"globalEval"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,"<select multiple='multiple'>","</select>"]);var me=/<|&#?\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}var be=/^key/,we=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Te=/^([^.]*)(?:\.(.+)|)/;function Ce(){return!0}function Ee(){return!1}function Se(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function ke(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)ke(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Ee;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Ae(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,Ce)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(P)||[""]).length;while(l--)d=g=(s=Te.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(P)||[""]).length;while(l--)if(d=g=(s=Te.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,"events")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click",Ce),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Y.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ce:Ee,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Ee,isPropagationStopped:Ee,isImmediatePropagationStopped:Ee,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ce,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ce,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ce,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&be.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&we.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},S.event.addProp),S.each({focus:"focusin",blur:"focusout"},function(e,t){S.event.special[e]={setup:function(){return Ae(this,e,Se),!1},trigger:function(){return Ae(this,e),!0},delegateType:t}}),S.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return ke(this,e,t,n,r)},one:function(e,t,n,r){return ke(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Ee),this.each(function(){S.event.remove(this,e,n,t)})}});var Ne=/<script|<style|<link/i,De=/checked\s*(?:[^=]|=\s*.checked.)/i,je=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function qe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&S(e).children("tbody")[0]||e}function Le(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function He(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Oe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function Pe(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&De.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Pe(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,"script"),Le)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,He),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Y.access(u,"globalEval")&&S.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):b(u.textContent.replace(je,""),u,l))}return n}function Re(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Oe(o[r],a[r]);else Oe(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Re(this,e,!0)},remove:function(e){return Re(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Pe(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||qe(this,e).appendChild(e)})},prepend:function(){return Pe(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=qe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Ne.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Pe(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Me=new RegExp("^("+ee+")(?!px)[a-z%]+$","i"),Ie=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},We=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Fe=new RegExp(ne.join("|"),"i");function Be(e,t,n){var r,i,o,a,s=e.style;return(n=n||Ie(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Me.test(a)&&Fe.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function $e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement("div"),l=E.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement("table"),t=E.createElement("tr"),n=E.createElement("div"),e.style.cssText="position:absolute;left:-11111px",t.style.height="1px",n.style.height="9px",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=3<parseInt(r.height),re.removeChild(e)),a}}))}();var _e=["Webkit","Moz","ms"],ze=E.createElement("div").style,Ue={};function Xe(e){var t=S.cssProps[e]||Ue[e];return t||(e in ze?e:Ue[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=_e.length;while(n--)if((e=_e[n]+t)in ze)return e}(e)||e)}var Ve=/^(none|table(?!-c[ea]).+)/,Ge=/^--/,Ye={position:"absolute",visibility:"hidden",display:"block"},Qe={letterSpacing:"0",fontWeight:"400"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Ke(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?("content"===n&&(u-=S.css(e,"padding"+ne[a],!0,i)),"margin"!==n&&(u-=S.css(e,"border"+ne[a]+"Width",!0,i))):(u+=S.css(e,"padding"+ne[a],!0,i),"padding"!==n?u+=S.css(e,"border"+ne[a]+"Width",!0,i):s+=S.css(e,"border"+ne[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Ie(e),i=(!y.boxSizingReliable()||n)&&"border-box"===S.css(e,"boxSizing",!1,r),o=i,a=Be(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(Me.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===S.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===S.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?"border":"content"),o,r,a)+"px"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Ge.test(t),l=e.style;if(u||(t=Xe(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Ge.test(t)||(t=Xe(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),"normal"===i&&t in Qe&&(i=Qe[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each(["height","width"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ve.test(S.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):We(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Ie(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===S.css(e,"boxSizing",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,"border",!1,i)-.5)),s&&(r=te.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=$e(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,"marginLeft"))||e.getBoundingClientRect().left-We(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),S.each({margin:"",padding:"",border:"Width"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Ie(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?"":"px")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Xe(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=/^(?:toggle|show|hide)$/,at=/queueHooks$/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=ne[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,"fxshow");for(r in n.queue||(null==(a=S._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,"display")),"none"===(c=S.css(e,"display"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,"display"),le([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===S.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Y.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,"fxshow"),d)S.style(e,r,d[r])})),u=ct(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&"object"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Y.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each(["toggle","show","hide"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt("show"),slideUp:lt("hide"),slideToggle:lt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement("input"),it=E.createElement("select").appendChild(E.createElement("option")),rt.type="checkbox",y.checkOn=""!==rt.value,y.optSelected=it.selected,(rt=E.createElement("input")).value="t",rt.type="radio",y.radioValue="t"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\w+/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=/^(?:input|select|textarea|button)$/i,gt=/^(?:a|area)$/i;function vt(e){return(e.match(P)||[]).join(" ")}function yt(e){return e.getAttribute&&e.getAttribute("class")||""}function mt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,"tabindex");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,yt(this)))});if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,yt(this)))});if(!arguments.length)return this.attr("class","");if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,yt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=mt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=yt(this))&&Y.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Y.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+vt(yt(n))+" ").indexOf(t))return!0;return!1}});var xt=/\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?"":e+""})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(xt,""):null==e?"":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,"value");return null!=t?t:vt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each(["radio","checkbox"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var bt=/^(?:focusinfocus|focusoutblur)$/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[S.expando]?e:new S.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,"events")||Object.create(null))[e.type]&&Y.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=/\?/;S.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||S.error("Invalid XML: "+e),t};var St=/\[\]$/,kt=/\r?\n/g,At=/^(?:submit|button|image|reset|file)$/i,Nt=/^(?:input|select|textarea|keygen)/i;function Dt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):Dt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)Dt(n+"["+t+"]",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)Dt(n,e[n],t,i);return r.join("&")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,"elements");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(":disabled")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,"\r\n")}}):{name:t.name,value:n.replace(kt,"\r\n")}}).get()}});var jt=/%20/g,qt=/#.*$/,Lt=/([?&])_=[^&]*/,Ht=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ot=/^(?:GET|HEAD)$/,Pt=/^\/\//,Rt={},Mt={},It="*/".concat("*"),Wt=E.createElement("a");function Ft(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Bt(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function $t(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":It,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?$t($t(e,S.ajaxSettings),t):$t(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Tt.href)+"").replace(Pt,Tt.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(P)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Wt.protocol+"//"+Wt.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Bt(Rt,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Ot.test(v.type),f=v.url.replace(qt,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(jt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(Et.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Lt,"$1"),o=(Et.test(f)?"&":"?")+"_="+Ct.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader("If-Modified-Since",S.lastModified[f]),S.etag[f]&&T.setRequestHeader("If-None-Match",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+It+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Bt(Mt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray("script",v.dataTypes)&&(v.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(S.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(S.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--S.active||S.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,"json")},getScript:function(e,t){return S.get(e,void 0,t,"script")}}),S.each(["get","post"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();y.cors=!!zt&&"withCredentials"in zt,y.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(y.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),S.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=/(=)\?(?=&|$)|\?\?/;S.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Xt.pop()||S.expando+"_"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Vt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,"$1"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||S.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Ut=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=vt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&S.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?S("<div>").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,"position"),c=S(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=S.css(e,"top"),u=S.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):("number"==typeof f.top&&(f.top+="px"),"number"==typeof f.left&&(f.left+="px"),c.css(f))}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===S.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===S.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,"borderTopWidth",!0),i.left+=S.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-S.css(r,"marginTop",!0),left:t.left-i.left-S.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===S.css(e,"position"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each(["top","left"],function(e,n){S.cssHooks[n]=$e(y.pixelPosition,function(e,t){if(t)return t=Be(e,n),Me.test(t)?S(e).position()[n]+"px":t})}),S.each({Height:"height",Width:"width"},function(a,s){S.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?"":(e+"").replace(Gt,"")},"function"==typeof define&&define.amd&&define("jquery",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},"undefined"==typeof e&&(C.jQuery=C.$=S),S});

```

`docs/cct/js/main.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

var cfg_name = "overlay.json";
var atlas = null;
var cfg = null;
var edit = null;
var main_painter = null;
var editor_painter = null;
var pad = null;

$(function() {
    main_painter = new painter("main-canvas", (p, c) => cfg.draw(p, c));
    editor_painter = new painter("editor-canvas", (p, c) => edit.draw(p, c));
    pad = new gamepad();
    cfg = new config("#main-canvas", main_painter);
    edit = new editor("#editor-canvas", editor_painter);

    cfg.add_load_callback(() => edit.on_config_load());

    main_painter.get_context().imageSmoothingEnabled = false;
    editor_painter.get_context().imageSmoothingEnabled = false;

    new drop_area("config-drop-area").handlers.push((files) => {
        if (files && files.length > 0) {
            let reader = new FileReader();
            reader.readAsDataURL(files[0]);
            reader.onloadend = function() {
                let split = reader.result.split(',');
                if (split.length < 1)
                    return;
                let b64 = split[1];
                let str = atob(b64);
                let j = JSON.parse(str);
                if (j) {
                    cfg_name = files[0].name;
                    cfg.load_from_json(j);
                    $('#default-width').val(j.default_width);
                    $('#default-height').val(j.default_height);
                    $('#horizontal-offset').val(j.space_h);
                    $('#vertical-offset').val(j.space_v);
                }
            };
        }
    });

    new drop_area("texture-drop-area", "image/*").handlers.push((files) => {
        if (files && files.length > 0) {
            let reader = new FileReader();
            reader.readAsDataURL(files[0]);
            reader.onloadend = function() {
                atlas = new Image();
                atlas.src = reader.result;
            };
        }
    });

    setTimeout(() => {
        main_painter.resize_canvas(); // Run once to get correct window size
        editor_painter.resize_canvas();
    }, 100);

    setTimeout(() => {
        let c = $('#main-canvas-container')[0];
        let e = $('#element-dialog')[0];
        c.style.pointerEvents = "none";
        c.classList.add("blurred");
        e.style.pointerEvents = "none";
        e.classList.add("blurred");
        main_painter.enabled = false;
        cfg.enabled = false;
    }, 200);
});

```

`docs/cct/js/math.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

function parseIntSafe(val, fallback = 0)
{
    let parsed = parseInt(val);
    return isNaN(parsed) ? fallback : parsed;
}

class vec2 {
    constructor(x = 0, y = 0)
    {
        this.x = x;
        this.y = y;
    }

    addv(other) { return new vec2(this.x + other.x, this.y + other.y); }

    add(x, y) { return new vec2(this.x + x, this.y + y); }

    subv(other) { return new vec2(this.x - other.x, this.y - other.y); }

    sub(x, y) { return new vec2(this.x - x, this.y - y); }

    lt(x, y) { return this.x < x && this.y < y; }
    ltv(v) { return this.x < v.x && this.y < v.y; }

    scale(s) { return new vec2(this.x * s, this.y * s); }

    limit(min_x = 0, min_y = 0, max_x = 3000, max_y = 3000)
    {
        this.x = Math.min(Math.max(this.x, min_x), max_x);
        this.y = Math.min(Math.max(this.y, min_y), max_y);
    }

    validate()
    {
        this.x = parseIntSafe(this.x);
        this.y = parseIntSafe(this.y);
    }
}

class r4 {

    constructor(x = 0, y = 0, w = 0, h = 0)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    from_points(a, b)
    {
        this.x = Math.min(a.x, b.x);
        this.y = Math.min(a.y, b.y);
        this.w = Math.max(a.x, b.x) - this.x;
        this.h = Math.max(a.y, b.y) - this.y;
    }

    validate()
    {
        this.x = parseIntSafe(this.x);
        this.y = parseIntSafe(this.y);
        this.w = parseIntSafe(this.w);
        this.h = parseIntSafe(this.h);
    }

    reset()
    {
        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;
    }

    copy() { return new r4(this.x, this.y, this.w, this.h); }

    get_left() { return this.w < 0 ? this.x + this.w : this.x; }

    get_right() { return this.w >= 0 ? this.x + this.w : this.x; }

    get_top() { return this.h < 0 ? this.y + this.h : this.y; }

    get_bottom() { return this.h >= 0 ? this.y + this.h : this.y; }

    is_coord_inside(x, y)
    {
        return x >= this.get_left() && x <= this.get_right() && y >= this.get_top() && y <= this.get_bottom();
    }

    is_point_inside(v)
    {
        return v.x >= this.get_left() && v.x <= this.get_right() && v.y >= this.get_top() && v.y <= this.get_bottom();
    }

    /* true when this is inside other */
    is_inside(other)
    {
        return other.get_left() <= this.get_left() && other.get_right() >= this.get_right() &&
               other.get_top() <= this.get_top() && other.get_bottom() >= this.get_bottom();
    }

    union(other)
    {
        if (this.is_empty() && other.is_empty())
            return;

        if (this.is_empty()) {
            this.x = other.x;
            this.y = other.y;
            this.w = other.w;
            this.h = other.h;
        }

        if (other.is_empty())
            return;

        let tmin, tmax, omin, omax;

        /* Horizontal union */
        tmin = this.get_left();
        tmax = this.get_right();
        omin = other.get_left();
        omax = other.get_right();

        if (omin < tmin)
            tmin = omin;

        this.x = tmin;
        if (omax > tmax)
            tmax = omax;
        this.w = tmax - tmin;

        /* Vertical union */
        tmin = this.get_top();
        tmax = this.get_bottom();
        omin = other.get_top();
        omax = other.get_bottom();

        if (omin < tmin)
            tmin = omin;
        this.y = tmin;
        if (omax > tmax)
            tmax = omax;
        this.h = tmax - tmin;
    }

    grow(i) { return new r4(this.x - i, this.y - i, this.w + i * 2, this.h + i * 2); }

    max(x = 0, y = 0)
    {
        this.x = Math.max(this.x, x);
        this.y = Math.max(this.y, y);
    }

    maxw(w = 0, h = 0)
    {
        this.w = Math.max(this.w, w);
        this.h = Math.max(this.h, h);
    }

    is_empty() { return this.w === 0 && this.h === 0; }
}

class r2 {
    constructor(w = 0, h = 0)
    {
        this.w = w;
        this.h = h;
    }
}
```

`docs/cct/js/select.js`:

```js
/* Mostly from https://www.w3schools.com/howto/howto_custom_select.asp */
var dropDowns, i, j, dropDownsCount, dropDownOptions;

/* Look for any elements with the class "custom-select": */
$(() => {
    dropDowns = document.getElementsByClassName("custom-select");
    dropDownsCount = dropDowns.length;
    for (i = 0; i < dropDownsCount; i++) {
        dropDownOptions = dropDowns[i].getElementsByTagName("select")[0];
        let dropDownOptionsCount = dropDownOptions.length;

        /* For each element, create a new DIV that will act as the selected item: */
        let a = document.createElement("DIV");
        a.setAttribute("class", "select-selected");
        a.innerHTML = dropDownOptions.options[dropDownOptions.selectedIndex].innerHTML;
        dropDowns[i].appendChild(a);

        /* For each element, create a new DIV that will contain the option list: */
        let optionProxyContainerDiv = document.createElement("DIV");
        optionProxyContainerDiv.setAttribute("class", "select-items select-hide");

        for (j = 1; j < dropDownOptionsCount; j++) {
            /* For each option in the original select element,
            create a new DIV that will act as an option item: */
            let optionProxy = document.createElement("DIV");
            optionProxy.innerHTML = dropDownOptions.options[j].innerHTML;
            optionProxy.addEventListener("click", function(e) {
                /* When an item is clicked, update the original select box,
                and the selected item: */
                var y, i, k, s, h, sl, yl;
                s = this.parentNode.parentNode.getElementsByTagName("select")[0];
                sl = s.length;
                h = this.parentNode.previousSibling;
                for (i = 0; i < sl; i++) {
                    if (s.options[i].innerHTML == this.innerHTML) {
                        s.selectedIndex = i;
                        h.innerHTML = this.innerHTML;
                        y = this.parentNode.getElementsByClassName("same-as-selected");
                        yl = y.length;
                        for (k = 0; k < yl; k++) {
                            y[k].removeAttribute("class");
                        }
                        this.setAttribute("class", "same-as-selected");
                        break;
                    }
                }
                h.click();
            });
            optionProxyContainerDiv.appendChild(optionProxy);
        }
        dropDowns[i].appendChild(optionProxyContainerDiv);
        a.addEventListener("click", function(e) {
            /* When the select box is clicked, close any other select boxes,
            and open/close the current select box: */
            e.stopPropagation();
            closeAllSelect(this);
            this.nextSibling.classList.toggle("select-hide");
            this.classList.toggle("select-arrow-active");
        });
    }
});

function closeAllSelect(elmnt)
{
    /* A function that will close all select boxes in the document,
    except the current select box: */
    var x, y, i, xl, yl, arrNo = [];
    x = document.getElementsByClassName("select-items");
    y = document.getElementsByClassName("select-selected");
    xl = x.length;
    yl = y.length;
    for (i = 0; i < yl; i++) {
        if (elmnt == y[i]) {
            arrNo.push(i)
        } else {
            y[i].classList.remove("select-arrow-active");
        }
    }
    for (i = 0; i < xl; i++) {
        if (arrNo.indexOf(i)) {
            x[i].classList.add("select-hide");
        }
    }
}

/* If the user clicks anywhere outside the select box,
then close all select boxes: */
document.addEventListener("click", closeAllSelect);
```

`docs/cct/js/vc.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

var key2vc = new Map();
var mouse2vc = new Map();
var gamepad2vc = new Map();
var vc2gamepad = new Map();

$(function() {
    let vc = (id, vc) => key2vc.set(id, vc);
    let gp = (id, vc) => {
        gamepad2vc.set(id, vc);
        vc2gamepad.set(vc, id);
    };

    // some keys are postfixed with their DOM3 location
    // No postfix = location 0
    // 1 = Left, 2 = Right, 3 = Numpad
    vc("KeyA", 0x001E);
    vc("KeyB", 0x0030);
    vc("KeyC", 0x002E);
    vc("KeyD", 0x0020);
    vc("KeyE", 0x0012);
    vc("KeyF", 0x0021);
    vc("KeyG", 0x0022);
    vc("KeyH", 0x0023);
    vc("KeyI", 0x0017);
    vc("KeyJ", 0x0024);
    vc("KeyK", 0x0025);
    vc("KeyL", 0x0026);
    vc("KeyM", 0x0032);
    vc("KeyN", 0x0031);
    vc("KeyO", 0x0018);
    vc("KeyP", 0x0019);
    vc("KeyQ", 0x0010);
    vc("KeyR", 0x0013);
    vc("KeyS", 0x001F);
    vc("KeyT", 0x0014);
    vc("KeyU", 0x0016);
    vc("KeyV", 0x002F);
    vc("KeyW", 0x0011);
    vc("KeyX", 0x002D);
    vc("KeyY", 0x0015);
    vc("KeyZ", 0x002C);
    vc("Digit1", 0x0002);
    vc("Digit2", 0x0003);
    vc("Digit3", 0x0004);
    vc("Digit4", 0x0005);
    vc("Digit5", 0x0006);
    vc("Digit6", 0x0007);
    vc("Digit7", 0x0008);
    vc("Digit8", 0x0009);
    vc("Digit9", 0x000A);
    vc("Digit0", 0x000B);
    vc("Backquote", 0x0029);
    vc("F1", 0x003B);
    vc("F2", 0x003C);
    vc("F3", 0x003D);
    vc("F4", 0x003E);
    vc("F5", 0x003F);
    vc("F6", 0x0040);
    vc("F7", 0x0041);
    vc("F8", 0x0042);
    vc("F9", 0x0043);
    vc("F10", 0x0044);
    vc("F11", 0x0057);
    vc("F12", 0x0058);
    vc("F13", 0x005B);
    vc("F14", 0x005C);
    vc("F15", 0x005D);
    vc("F16", 0x0063);
    vc("F17", 0x0064);
    vc("F18", 0x0065);
    vc("F19", 0x0066);
    vc("F20", 0x0067);
    vc("F21", 0x0068);
    vc("F22", 0x0069);
    vc("F23", 0x006A);
    vc("F24", 0x006B);
    vc("Escape", 0x0001);
    vc("Minus", 0x000C);
    vc("Equal", 0x000D);
    vc("Backspace", 0x000E);
    vc("Tab", 0x000F);
    vc("CapsLock", 0x003A);
    vc("BracketRight", 0x001B);
    vc("BracketLeft", 0x001A);
    vc("Backslash", 0x002B);
    vc("Semicolon", 0x0027);
    vc("Quote", 0x0028);
    vc("Enter", 0x001C);
    vc("Comma", 0x0033);
    vc("Period", 0x0034);
    vc("Slash", 0x0035);
    vc("Space", 0x0039);
    vc("PrintScreen", 0x0E37);
    vc("ScrolLock", 0x0046);
    vc("Pause", 0x0E45);
    vc("IntlBackslash", 0x0E46);
    vc("Insert", 0x0E52);
    vc("Delete", 0x0E53);
    vc("Home", 0x0E47);
    vc("End", 0x0E4F);
    vc("PageUp", 0x0E49);
    vc("PageDown", 0x0E51);
    /* The arrow codes are labeled wrong in uiohook, these are /technically/ for the 
     * arrows on the numpad when numlock is disabled, but libuiook returns them when 
     * the normal arrows are pressed. */
    vc("ArrowUp", 0xEE48);
    vc("ArrowLeft", 0xEE4B);
    vc("Clear", 0xE04C);
    vc("ArrowRight", 0xEE4D);
    vc("ArrowDown", 0xEE50);

    vc("NumpadEquals", 0x0E0D);
    vc("NumLock", 0x0045);
    vc("NumpadSubtract", 0x0E35);
    vc("NumpadMultiply", 0x0037);
    vc("NumpadSubtract", 0x004A);
    vc("NumpadAdd", 0x004E);
    vc("NumpadEnter", 0x0E1C);
    vc("NumpadDecimal", 0x0053);

    vc("Numpad1", 0x004F);
    vc("Numpad2", 0x0050);
    vc("Numpad3", 0x0051);
    vc("Numpad4", 0x004B);
    vc("Numpad5", 0x004C);
    vc("Numpad6", 0x004D);
    vc("Numpad7", 0x0047);
    vc("Numpad8", 0x0048);
    vc("Numpad9", 0x0049);
    vc("Numpad0", 0x0052);

    vc("NumpadEnd", 0xEE4F);
    vc("NumpadArrowDown", 0xEE50);
    vc("NumpadPageDown", 0xEE51);
    vc("NumpadArrowLeft", 0xEE4B);
    vc("NumpadClear", 0xEE4C);
    vc("NumpadArrowRight", 0xEE4D);
    vc("NumpadHome", 0xEE47);
    vc("NumpadArrowUp", 0xEE48);
    vc("NumpadPageUp", 0xEE49);
    vc("NumpadInsert", 0xEE52);
    vc("NumpadDelete", 0xEE53);

    vc("ShiftLeft", 0x002A);
    vc("ShiftRight", 0x0036);
    vc("ControlLeft", 0x001D);
    vc("ControlRight", 0x0E1D);
    vc("AltLeft", 0x0038);
    vc("AltRight", 0x0E38);
    vc("MetaLeft", 0x0E5B);
    vc("MetaRight", 0x0E5C);
    vc("ContextMenu", 0x0E5D);

    mouse2vc.set(0, 1);
    mouse2vc.set(1, 3);
    mouse2vc.set(2, 2);
    mouse2vc.set(3, 4);
    mouse2vc.set(4, 5);

    gp(0, 0xEC00);
    gp(1, 0xEC01);
    gp(2, 0xEC02);
    gp(3, 0xEC03);
    gp(4, 0xEC04);
    gp(5, 0xEC05);
    gp(8, 0xEC06);
    gp(9, 0xEC07);
    gp(10, 0xEC09);
    gp(11, 0xEC10);
    gp(12, 0xEC13);
    gp(13, 0xEC14);
    gp(14, 0xEC11);
    gp(15, 0xEC12);
    gp(16, 0xEC08);
});

function gamepad_to_vc(button)
{
    if (gamepad2vc.has(button))
        return gamepad2vc.get(button);
    return 0;
}

function gamepad_from_vc(vc)
{
    if (vc2gamepad.has(vc))
        return vc2gamepad.get(vc);
    return 0;
}

function mouse_to_vc(e)
{
    let button = e.button;

    if (mouse2vc.has(button))
        return mouse2vc.get(button);
    return 0;
}

function key_to_vc(e)
{
    let key = e.code;

    if (key.indexOf("Numpad") >= 0 && /^[0-9]$/g.test(key.slice(-1))) {
        // Numpad has special handling
        // all keys Numpad1 through Numpad9 should use the key
        // so that we can tell numpad buttons with numlock on apart from
        // numpad buttons with numpad off
        key = key.slice(0, -1) + e.key;
    }

    if (key === "NumpadDecimal" && e.keyCode === 46)
        key = "NumpadDelete";

    if (key2vc.has(key))
        return key2vc.get(key);
    return 0;
}
```

`format.sh`:

```sh
#!/bin/bash
#grep -rl 'Copyright 2021' ./projects | xargs sed -i 's/Copyright 2021/Copyright 2022/g'
#grep -rl 'uni@vrsal.de' ./projects | xargs sed -i 's/uni@vrsal.de/uni@vrsal.xyz/g'
#grep -rl 'Copyright 2021' ./docs | xargs sed -i 's/Copyright 2021/Copyright 2022/g'
#grep -rl 'uni@vrsal.de' ./docs | xargs sed -i 's/uni@vrsal.de/uni@vrsal.xyz/g'

find ./deps/common -iname *.h* -o -iname *.c* | xargs clang-format -i -verbose
find ./projects -iname *.h* -o -iname *.c* | xargs clang-format -i -verbose
find ./docs -type f ! -iname "jquery-3.5.1.min.js" -name "*.js" -o -name "*.html" ! -path "css" | xargs clang-format -i -verbose


```

`package/installer.iss.in`:

```in
 
#define MyAppName "input-overlay"
#define MyAppVersion "@CMAKE_PROJECT_VERSION@"
#define MyAppPublisher "@PLUGIN_AUTHOR@"
#define MyAppURL "https://github.com/univrsal/@PLUGIN_GIT@"

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{7fe1c9de-d8c4-4e84-85bf-e7d61661ff58}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={code:GetDirName}
DefaultGroupName={#MyAppName}
OutputBaseFilename={#MyAppName}-{#MyAppVersion}-Windows-Installer
Compression=lzma
SolidCompression=yes

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Files]
Source: "..\build-package\plugin\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs
Source: "..\COPYING.txt"; Flags: dontcopy
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Icons]
Name: "{group}\{cm:ProgramOnTheWeb,{#MyAppName}}"; Filename: "{#MyAppURL}"
Name: "{group}\{cm:UninstallProgram,{#MyAppName}}"; Filename: "{uninstallexe}"

[Code]
procedure InitializeWizard();
var
  GPLText: AnsiString;
  Page: TOutputMsgMemoWizardPage;
begin
  ExtractTemporaryFile('COPYING.txt');
  LoadStringFromFile(ExpandConstant('{tmp}\COPYING.txt'), GPLText);
  Page := CreateOutputMsgMemoPage(wpWelcome,
    'License Information', 'Please review the license terms before installing {#MyAppName}',
    'Press Page Down to see the rest of the agreement. Once you are aware of your rights, click Next to continue.',
    String(GPLText)
  );
end;

// credit where it's due :
// following function come from https://github.com/Xaymar/obs-studio_amf-encoder-plugin/blob/master/%23Resources/Installer.in.iss#L45
function GetDirName(Value: string): string;
var
  InstallPath: string;
begin
  // initialize default path, which will be returned when the following registry
  // key queries fail due to missing keys or for some different reason
  Result := '{pf}\obs-studio';
  // query the first registry value; if this succeeds, return the obtained value
  if RegQueryStringValue(HKLM32, 'SOFTWARE\OBS Studio', '', InstallPath) then
    Result := InstallPath
end;


```

`projects/client/CMakeLists.txt`:

```txt
project(io_client)

string(TIMESTAMP TODAY "%Y.%m.%d %H:%M")
add_compile_definitions(TIMESTAMP="${TODAY}")

find_path(UIOHOOK_INCLUDE_DIR uiohook.h)
find_library(UIOHOOK_LIBRARY uiohook)

if ("${CMAKE_SYSTEM_NAME}" MATCHES "Linux")
    add_definitions(-DUNIX=1)
    add_definitions(-DLINUX=1)
    set(client_PLATFORM_DEPS
            pthread)
endif()


set(io_client_SOURCES
    src/io_client.cpp
    src/client_util.cpp
    src/client_util.hpp
    src/network.cpp
    src/network.hpp
    src/gamepad_helper.cpp
    src/gamepad_helper.hpp
    src/uiohook_helper.cpp
    src/uiohook_helper.hpp)

add_executable(client ${io_client_SOURCES})

target_link_libraries(client
    uiohook_static
    netlib_static
    gamepad_static
    ${client_PLATFORM_DEPS})

include_directories(
    ${COMMON_HEADERS}
    ${JSON_11_HEADER}
    ${GAMEPAD_INCLUDE_DIR}
    ${UIOHOOK_INCLUDE_DIR}
    ${NETLIB_INCLUDE_DIR}
    )

install(TARGETS client DESTINATION client)

```

`projects/client/README.md`:

```md
## input-overlay client
headless application which runs in the background and sends
input events to obs over the network.

Traffic is NOT encrypted, do not use this on untrusted networks.

```

`projects/client/src/client_util.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "client_util.hpp"
#include "gamepad_helper.hpp"
#include "network.hpp"
#include "uiohook_helper.hpp"
#include <cstdio>
#include <cstdlib>
#include <string>
#include <chrono>
#include <thread>

#ifdef _WIN32
#include <Windows.h>
#else
#include <cstring>
#include <math.h>
#include <stdio.h>
#include <time.h>
#include <uiohook.h>
#endif

using namespace std::chrono;

namespace util {
config cfg;

bool parse_arguments(int argc, char **args)
{
    if (argc < 3) {
        DEBUG_LOG("io_client usage: [ip] [name] {port} {other options}");
        DEBUG_LOG(" [] => required {} => optional");
        DEBUG_LOG(" [ip]          can be ipv4 or hostname");
        DEBUG_LOG(" [name]        unique name to identify client (max. 64 characters)");
        DEBUG_LOG(" {port}        default is 1608 [1025 - %ui]", 0xffff);
        DEBUG_LOG(" --gamepad=1   enable/disable gamepad monitoring. Off by default");
        DEBUG_LOG(" --mouse=1     enable/disable mouse monitoring.  Off by default");
        DEBUG_LOG(" --keyboard=1  enable/disable keyboard monitoring. On by default");
        DEBUG_LOG(" --dinput      use direct input on windows. XInput is default");
        return false;
    }

    cfg.monitor_gamepad = false;
    cfg.monitor_keyboard = true;
    cfg.monitor_mouse = false;
    cfg.port = 1608;

    auto const s = sizeof(cfg.username);
    strncpy(cfg.username, args[2], s);
    cfg.username[s - 1] = '\0';

    if (argc > 3 && std::string(args[3]).find("--") == std::string::npos) {
        auto newport = uint16_t(strtol(args[3], nullptr, 0));
        if (newport > 1024) /* No system ports pls */
            cfg.port = newport;
        else
            DEBUG_LOG("%hu is outside the valid port range [1024 - %ui]", newport, 0xffff);
    }

    /* Resolve ip */
    if (netlib_resolve_host(&cfg.ip, args[1], cfg.port) == -1) {
        DEBUG_LOG("netlib_resolve_host failed: %s", netlib_get_error());
        DEBUG_LOG("Make sure obs studio is running with the remote connection enabled and configured");
        return false;
    }

    /* Parse additional arguments */
    std::string arg;
    for (auto i = 4; i < argc; i++) {
        arg = args[i];
        if (arg.find("--gamepad") != std::string::npos)
            cfg.monitor_gamepad = arg.find('1') != std::string::npos;
        else if (arg.find("--mouse") != std::string::npos)
            cfg.monitor_mouse = arg.find('1') != std::string::npos;
        else if (arg.find("--keyboard") != std::string::npos)
            cfg.monitor_keyboard = arg.find('1') != std::string::npos;
    }

    DEBUG_LOG("io_client configuration:");
    DEBUG_LOG(" Host : %s:%hu", args[1], cfg.port);
    DEBUG_LOG(" Name:     %s", args[2]);
    DEBUG_LOG(" Keyboard: %s", cfg.monitor_keyboard ? "Yes" : "No");
    DEBUG_LOG(" Mouse:    %s", cfg.monitor_mouse ? "Yes" : "No");
    DEBUG_LOG(" Gamepad:  %s", cfg.monitor_gamepad ? "Yes" : "No");

    return true;
}

/* https://www.libsdl.org/projects/SDL_net/docs/demos/tcputil.h */
int send_text(char *buf)
{
    uint32_t len, result;

    if (!buf || !strlen(buf))
        return 1;

    len = strlen(buf) + 1;
    len = netlib_swap_BE32(len);

    result = netlib_tcp_send(network::sock, &len, sizeof(len));
    if (result < sizeof(len)) {
        if (netlib_get_error() && strlen(netlib_get_error())) {
            DEBUG_LOG("netlib_tcp_send failed: %s", netlib_get_error());
            return 0;
        }
    }

    len = netlib_swap_BE32(len);

    result = netlib_tcp_send(network::sock, buf, len);
    if (result < len) {
        if (netlib_get_error() && strlen(netlib_get_error())) {
            DEBUG_LOG("netlib_tcp_send failed: %s", netlib_get_error());
            return 0;
        }
    }

    return result;
}

void sleep_ms(uint32_t ms)
{
    std::this_thread::sleep_for(milliseconds(ms));
}

uint32_t get_ticks()
{
#ifdef _WIN32
    SYSTEMTIME time;
    GetSystemTime(&time);
    return (time.wSecond * 1000) + time.wMilliseconds;
#else
    struct timespec spec;
    clock_gettime(CLOCK_MONOTONIC, &spec);
    return round(spec.tv_nsec / 1.0e6);
#endif
}

network::message recv_msg()
{
    uint8_t msg_id;

    const uint32_t read_length = netlib_tcp_recv(network::sock, &msg_id, sizeof(msg_id));

    if (read_length < sizeof(msg_id)) {
        if (netlib_get_error() && strlen(netlib_get_error()))
            DEBUG_LOG("netlib_tcp_recv: %s", netlib_get_error());
        return network::MSG_READ_ERROR;
    }

    if (msg_id < network::MSG_LAST)
        return network::message(msg_id);

    DEBUG_LOG("Received message with invalid id (%i).", msg_id);
    return network::MSG_INVALID;
}

void close_all()
{
    libgamepad::stop();
    network::close();
    uiohook::stop();
}
}

```

`projects/client/src/client_util.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once
#ifdef _WIN32
#include <cstdint>
#endif

#include <netlib.h>
#include <messages.hpp>
#include <gamepad/hook.hpp>

#define DEBUG_LOG(fmt, ...) printf("[%25.25s:%03d]: " fmt "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__)
#define DEBUG_LOGN(fmt, ...) printf("[%25.25s:%03d]: " fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__)

namespace util {
typedef struct {
    bool monitor_gamepad;
    bool monitor_mouse;
    bool monitor_keyboard;
    char username[64];
    gamepad::hook_type::type gamepad_hook_type;
    uint16_t port;
    ip_address ip;
} config;

extern config cfg;

enum return_codes {
    RET_NETWORK_INIT,
    RET_ARGUMENT_PARSING,
    RET_NO_HOOKS,
    RET_CONNECTION,
    RET_GAMEPAD_INIT,
    RET_UIOHOOK_INIT
};

void sleep_ms(uint32_t ms);

/* Get config values and print help */
bool parse_arguments(int argc, char **args);

int send_text(char *buf);

uint32_t get_ticks();

network::message recv_msg();

void close_all();

}

```

`projects/client/src/gamepad_helper.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#define NOMINMAX /* Some windows header defines min/max */
#include "gamepad_helper.hpp"
#include "network.hpp"
#include "client_util.hpp"
#include <messages.hpp>

namespace libgamepad {

std::shared_ptr<gamepad::hook> hook_instance;
std::mutex buffer_mutex;
buffer buf;

bool start(uint16_t flags)
{
    /* Make sure that the network is established, otherwise we might send device connections too early */
    ::util::sleep_ms(1000);
    hook_instance = gamepad::hook::make(flags);
    hook_instance->set_plug_and_play(true, gamepad::ms(1000));
    hook_instance->set_sleep_time(gamepad::mcs(600));

    // try to load bindings, currently the file has to be provided manually
    hook_instance->load_bindings(std::string("./bindings.json"));

    auto input_writer = [](const std::shared_ptr<gamepad::device> d) {
        std::lock_guard<std::mutex> lock(buffer_mutex);
        buf.write<uint8_t>(network::MSG_GAMEPAD_EVENT);
        buf.write<uint8_t>(d->get_index());
        buf.write<uint8_t>(d->get_buttons().size());
        for (const auto &btn : d->get_buttons()) {
            buf.write<uint16_t>(btn.first);
            buf.write<uint16_t>(btn.second);
        }

        buf.write<uint8_t>(d->get_axis().size());
        for (const auto &axis : d->get_axis()) {
            buf.write<uint16_t>(axis.first);
            buf.write<float>(axis.second);
        }

        buf.write<uint16_t>(d->last_axis_event()->vc);
        buf.write<float>(d->last_axis_event()->virtual_value);
        buf.write<uint64_t>(d->last_axis_event()->time);
        buf.write<uint16_t>(d->last_button_event()->vc);
        buf.write<float>(d->last_button_event()->virtual_value);
        buf.write<uint64_t>(d->last_button_event()->time);
    };

    auto event_writer = [](const std::shared_ptr<gamepad::device> &d, network::message m) {
        {
            std::lock_guard<std::mutex> lock(buffer_mutex);
            buf.write<uint8_t>(m);
            buf.write<uint8_t>(d->get_index());
            buf.write<uint16_t>(d->get_id().length());
            buf.write(d->get_id().c_str(), d->get_id().length());
        }

        const char *state;
        switch (m) {
        case network::MSG_GAMEPAD_DISCONNECTED:
            state = "disconnected";
            break;
        case network::MSG_GAMEPAD_RECONNECTED:
            state = "reconnected";
            break;
        default:
            state = "connected";
        }
        DEBUG_LOG("Device '%s' %s", d->get_id().c_str(), state);
    };

    hook_instance->set_axis_event_handler(input_writer);
    hook_instance->set_button_event_handler(input_writer);
    hook_instance->set_connect_event_handler(
        [event_writer](const std::shared_ptr<gamepad::device> &d) { event_writer(d, network::MSG_GAMEPAD_CONNECTED); });
    hook_instance->set_reconnect_event_handler([event_writer](const std::shared_ptr<gamepad::device> &d) {
        event_writer(d, network::MSG_GAMEPAD_RECONNECTED);
    });
    hook_instance->set_disconnect_event_handler([event_writer](const std::shared_ptr<gamepad::device> &d) {
        event_writer(d, network::MSG_GAMEPAD_DISCONNECTED);
    });
    return hook_instance->start();
}

void stop()
{
    if (hook_instance)
        hook_instance->stop();
}

}

```

`projects/client/src/gamepad_helper.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once
#include <libgamepad.hpp>
#include <buffer.hpp>

namespace libgamepad {
extern std::shared_ptr<gamepad::hook> hook_instance;
extern std::mutex buffer_mutex;
extern buffer buf;
extern bool start(uint16_t flags);
extern void stop();
}

```

`projects/client/src/io_client.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "network.hpp"
#include "uiohook_helper.hpp"
#include "gamepad_helper.hpp"
#include "client_util.hpp"
#include <signal.h>
#include <stdio.h>

#ifndef SIGBREAK
#define SIGBREAK SIGQUIT /* SIGBREAK only exists on Windows, so just use quit otherwise */
#endif

/* Catch Application closing */
void sig_int__handler(int)
{
    util::close_all();
}

void sig_break__handler(int)
{
    util::close_all();
}

int main(int argc, char **argv)
{
    signal(SIGINT, &sig_int__handler);
    signal(SIGBREAK, &sig_break__handler);

    if (!util::parse_arguments(argc, argv))
        return util::RET_ARGUMENT_PARSING; /* Invalid arguments */

    if (!network::init())
        return util::RET_NETWORK_INIT;

    DEBUG_LOG("Network init done.");

    if (!util::cfg.monitor_keyboard && !util::cfg.monitor_mouse && !util::cfg.monitor_gamepad) {
        DEBUG_LOG("Nothing to monitor!");
        return util::RET_NO_HOOKS;
    }

    if (!network::start_connection()) /* Starts a separate network thread */
    {
        network::close();
        return util::RET_CONNECTION;
    }

    if (util::cfg.monitor_gamepad) {
        if (!libgamepad::start(util::cfg.gamepad_hook_type)) {
            DEBUG_LOG("Gamepad hook initialization failed!");
            return util::RET_GAMEPAD_INIT;
        }
    }

    if ((util::cfg.monitor_keyboard || util::cfg.monitor_mouse) && !uiohook::start()) {
        DEBUG_LOG("uiohook init failed");
        return util::RET_UIOHOOK_INIT;
    }

    if ((!util::cfg.monitor_mouse && !util::cfg.monitor_keyboard)) {
        /* If uiohook isn't used, we need to block here until we're told to quit */
        while (network::network_loop)
            util::sleep_ms(500);
    }

    util::close_all();

    return 0;
}

```

`projects/client/src/network.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "network.hpp"
#include "uiohook_helper.hpp"
#include "client_util.hpp"
#include <cstdio>

#include "gamepad_helper.hpp"

namespace network {
tcp_socket sock = nullptr;
netlib_socket_set set = nullptr;
buffer buf;
std::atomic<bool> network_loop;
bool connected = false;

std::thread network_thread;

bool start_connection()
{
    DEBUG_LOGN("Allocating socket... ");
    set = netlib_alloc_socket_set(1);

    if (!set) {
        printf(" netlib_alloc_socket_set failed: %s\n", netlib_get_error());
        return false;
    }
    printf("Done.\n");

    DEBUG_LOGN("Opening socket... ");

    sock = netlib_tcp_open(&util::cfg.ip);

    if (!sock) {
        printf("netlib_tcp_open failed: %s\n", netlib_get_error());
        return false;
    }

    printf("Done.\n");

    if (netlib_tcp_add_socket(set, sock) == -1) {
        DEBUG_LOG("netlib_tcp_add_socket failed: %s", netlib_get_error());
        return false;
    }

    DEBUG_LOG("Connection successful!");

    /* Send client name */
    if (!util::send_text(util::cfg.username)) {
        DEBUG_LOG("Failed to send username (%s): %s", util::cfg.username, netlib_get_error());
        return false;
    }
    network_loop = true;
    start_thread();
    connected = true;
    return true;
}

void start_thread()
{
    network_thread = std::thread(network_thread_method);
}

void network_thread_method()
{
    int listen_counter = 0;

    while (network_loop) {
        if (++listen_counter >= 10000) {
            listen_counter = 0;
            if (!listen()) /* Has a timeout of 1ms*/
            {
                DEBUG_LOG("Received quit signal");
                network_loop = false; // The rest will be taken care of in the main thread
                break;
            }
        }

        /* Copy buffered data from hooks */
        if (util::cfg.monitor_gamepad) {
            std::lock_guard<std::mutex> lock(libgamepad::buffer_mutex);
            if (libgamepad::buf.write_pos() > 0) {
                buf.write(libgamepad::buf.get(), libgamepad::buf.write_pos());
                libgamepad::buf.reset();
            }
        }

        if (util::cfg.monitor_keyboard || util::cfg.monitor_mouse) {
            std::lock_guard<std::mutex> lock(uiohook::buffer_mutex);
            if (uiohook::buf.write_pos() > 0) {
                buf.write(uiohook::buf.get(), uiohook::buf.write_pos());
                uiohook::buf.reset();
            }
        }

        /* Reset scroll wheel if no scroll event happened for a bit */
        if (uiohook::last_scroll_time > 0 && util::get_ticks() - uiohook::last_scroll_time >= SCROLL_TIMEOUT) {
            buf.write<uint8_t>(MSG_MOUSE_WHEEL_RESET);
            uiohook::last_scroll_time = 0;
        }

        /* Send any data written to the buffer */
        if (buf.write_pos() > 0) {
            if (!netlib_tcp_send(sock, buf.get(), buf.write_pos())) {
                DEBUG_LOG("netlib_tcp_send: %s", netlib_get_error());
                break;
            }
            buf.reset();
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }

    DEBUG_LOG("Network loop exited");
    if (util::cfg.monitor_keyboard || util::cfg.monitor_mouse) {
        // We have to stop the hook here since the main thread is blocked by uiohook
        uiohook::stop();
    }
}

int numready = 0;
bool listen()
{
    numready = netlib_check_socket_set(set, 0);

    if (numready == -1) {
        DEBUG_LOG("netlib_check_socket_set failed: %s", netlib_get_error());
        return false;
    }

    if (numready && netlib_socket_ready(sock)) {
        auto msg = util::recv_msg();

        switch (msg) {
        case MSG_NAME_NOT_UNIQUE:
            DEBUG_LOG("Nickname is already in use. Disconnecting...");
            return false;
        case MSG_NAME_INVALID:
            DEBUG_LOG("Nickname is not valid. Disconnecting...");
            return false;
        case MSG_SERVER_SHUTDOWN:
            DEBUG_LOG("Server is shutting down.");
            return false;
        case MSG_READ_ERROR:
            DEBUG_LOG("Couldn't read message.");
            return false;
        case MSG_REFRESH:;    /* fallthrough */
        case MSG_PING_CLIENT: /* NO-OP needed */
            return true;
        default:
        case MSG_INVALID:
            return false;
        }
    }
    return true;
}

bool init()
{
    if (netlib_init() == -1) {
        DEBUG_LOG("netlib_init failed: %s", netlib_get_error());
        return false;
    }
    return true;
}

void close()
{
    if (!network_loop)
        return;
    network_loop = false;

    /* Tell server we're disconnecting */
    if (connected) {
        buf.reset();
        buf.write<uint8_t>(MSG_CLIENT_DC);
        netlib_tcp_send(sock, buf.get(), buf.write_pos());
    }

    /* Give server time to process DC message */
    util::sleep_ms(100);
    network_thread.join();
    netlib_tcp_close(sock);
    netlib_quit();
}
}

```

`projects/client/src/network.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once
#include <netlib.h>
#include <thread>
#include <buffer.hpp>
#include <mutex>
#include <atomic>

namespace network {
extern tcp_socket sock;
extern netlib_socket_set set;
extern bool connected;
extern bool state;
extern std::atomic<bool> network_loop;
/* Set to true by other threads */
/* Set to true to prevent other threads from modifying data, which is about to be sent */
extern buffer buf;
extern std::thread network_thread;

bool init();
bool start_connection();
void start_thread();
bool listen();

void network_thread_method();

void close();
}

```

`projects/client/src/uiohook_helper.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "uiohook_helper.hpp"
#include "network.hpp"
#include "client_util.hpp"
#include <cstdarg>
#include <cstdio>
#include <util.hpp>

namespace uiohook {
uint32_t last_scroll_time;
std::atomic<bool> hook_state;
std::mutex buffer_mutex;
buffer buf;
static void logger_proc(unsigned int level, void *, const char *format, va_list args)

{
    switch (level) {
    default:
#ifdef USE_DEBUG

    case LOG_LEVEL_DEBUG:
    case LOG_LEVEL_INFO:
        va_start(args, format);
        vfprintf(stdout, format, args);
        va_end(args);
#endif
        break;
    case LOG_LEVEL_WARN:
    case LOG_LEVEL_ERROR:
        vfprintf(stderr, format, args);
        break;
    }
}

static void logger(unsigned int level, const char *format, ...)
{
    va_list args;
    va_start(args, format);
    logger_proc(level, nullptr, format, args);
    va_end(args);
}

void dispatch_proc(uiohook_event *const event, void *)
{
    std::lock_guard<std::mutex> lock(buffer_mutex);
    switch (event->type) {
    case EVENT_HOOK_ENABLED:
        DEBUG_LOG("uiohook started");
        hook_state = true;
        break;
    case EVENT_HOOK_DISABLED:
        DEBUG_LOG("uiohook exited");
        break;
    case EVENT_MOUSE_CLICKED:
    case EVENT_MOUSE_PRESSED:
    case EVENT_MOUSE_RELEASED:
        if (util::cfg.monitor_mouse) {
            buf.write<uint8_t>(network::MSG_UIOHOOK_EVENT);
            buf.write<uiohook_event>(*event);
        }
        break;
    case EVENT_MOUSE_WHEEL:
        if (util::cfg.monitor_mouse) {
            last_scroll_time = util::get_ticks();
            buf.write<uint8_t>(network::MSG_UIOHOOK_EVENT);
            buf.write<uiohook_event>(*event);
        }
        break;
    case EVENT_MOUSE_MOVED:
    case EVENT_MOUSE_DRAGGED:
        if (util::cfg.monitor_mouse) {
            buf.write<uint8_t>(network::MSG_UIOHOOK_EVENT);
            buf.write<uiohook_event>(*event);
        }
        break;
    case EVENT_KEY_TYPED:
    case EVENT_KEY_PRESSED:
    case EVENT_KEY_RELEASED:
        if (util::cfg.monitor_keyboard) {
            buf.write<uint8_t>(network::MSG_UIOHOOK_EVENT);
            buf.write<uiohook_event>(*event);
        }
        break;
    default:;
    }
}

bool start()
{
    hook_set_logger_proc(&logger_proc, nullptr);
    hook_set_dispatch_proc(&dispatch_proc, nullptr);

    const auto status = hook_run();

    switch (status) {
    case UIOHOOK_SUCCESS:
        hook_state = true;
        return true;
    case UIOHOOK_ERROR_OUT_OF_MEMORY:
        logger(LOG_LEVEL_ERROR, "[uiohook] Failed to allocate memory. (%#X)", status);
        return false;
    case UIOHOOK_ERROR_X_OPEN_DISPLAY:
        logger(LOG_LEVEL_ERROR, "[uiohook] Failed to open X11 display. (%#X)", status);
        return false;
    case UIOHOOK_ERROR_X_RECORD_NOT_FOUND:
        logger(LOG_LEVEL_ERROR, "[uiohook] Unable to locate XRecord extension. (%#X)", status);
        return false;
    case UIOHOOK_ERROR_X_RECORD_ALLOC_RANGE:
        logger(LOG_LEVEL_ERROR, "[uiohook] Unable to allocate XRecord range. (%#X)", status);
        return false;
    case UIOHOOK_ERROR_X_RECORD_CREATE_CONTEXT:
        logger(LOG_LEVEL_ERROR, "[uiohook] Unable to allocate XRecord context. (%#X)", status);
        return false;
    case UIOHOOK_ERROR_X_RECORD_ENABLE_CONTEXT:
        logger(LOG_LEVEL_ERROR, "[uiohook] Failed to enable XRecord context. (%#X)", status);
        return false;
    case UIOHOOK_ERROR_SET_WINDOWS_HOOK_EX:
        logger(LOG_LEVEL_ERROR, "[uiohook] Failed to register low level windows hook. (%#X)", status);
        return false;
    case UIOHOOK_ERROR_AXAPI_DISABLED:
        logger(LOG_LEVEL_ERROR, "[uiohook] Failed to enable access for assistive devices. (%#X)", status);
        return false;
    case UIOHOOK_ERROR_CREATE_EVENT_PORT:
        logger(LOG_LEVEL_ERROR, "[uiohook] Failed to create apple event port. (%#X)", status);
        return false;
    case UIOHOOK_ERROR_CREATE_RUN_LOOP_SOURCE:
        logger(LOG_LEVEL_ERROR, "[uiohook] Failed to create apple run loop source. (%#X)", status);
        return false;
    case UIOHOOK_ERROR_GET_RUNLOOP:
        logger(LOG_LEVEL_ERROR, "[uiohook] Failed to acquire apple run loop. (%#X)", status);
        return false;
    case UIOHOOK_ERROR_CREATE_OBSERVER:
        logger(LOG_LEVEL_ERROR, "[uiohook] Failed to create apple run loop observer. (%#X)", status);
        return false;
    case UIOHOOK_FAILURE:
        logger(LOG_LEVEL_ERROR, "[uiohook] An unknown hook error occurred. (%#X)", status);
        return false;
    default:;
        return true; /* Unknown error but we can still try */
    }
}

void stop()
{
    if (!hook_state)
        return;
    hook_state = false;
    const auto status = hook_stop();

    DEBUG_LOG("Closing hook");
    switch (status) {
    case UIOHOOK_ERROR_OUT_OF_MEMORY:
        logger(LOG_LEVEL_ERROR, "[uiohook] Failed to allocate memory. (%#X)", status);
        break;
    case UIOHOOK_ERROR_X_RECORD_GET_CONTEXT:
        logger(LOG_LEVEL_ERROR, "[uiohook] Failed to get XRecord context. (%#X)", status);
        break;
    case UIOHOOK_FAILURE:
        logger(LOG_LEVEL_ERROR, "[uiohook] An unknown hook error occurred. (%#X)", status);
        break;
    default:;
    }
}
}

```

`projects/client/src/uiohook_helper.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once
#include <uiohook.h>
#include <atomic>
#include <mutex>
#include <buffer.hpp>

#define SCROLL_TIMEOUT 120
namespace uiohook {
extern uint32_t last_scroll_time;

inline uint16_t util_mouse_fix(int m)
{
#ifndef _WIN32 /* Linux mixes right mouse and middle mouse or is windows getting it wrong? */
    if (m == 3)
        m = 2;
    else if (m == 2)
        m = 3;
#endif
    return m;
}

extern std::atomic<bool> hook_state;
extern std::mutex buffer_mutex;
extern buffer buf;

void dispatch_proc(uiohook_event *event, void *);
bool start();
void stop();
}

```

`projects/plugin/CMakeLists.txt`:

```txt
project(input-overlay)

set(CMAKE_PREFIX_PATH "${QTDIR}")
set(CMAKE_INCLUDE_CURRENT_DIR TRUE)
set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(input-overlay_UI
        src/gui/io_settings_dialog.ui)

option(LOCAL_INSTALLATION "Whether to install the obs plugin in the user config directory (default: OFF)" OFF)
option(DEB_INSTALLER "Whether to use the folder structure for a *.deb installer on linux (default: OFF)" OFF)

if (WIN32 OR APPLE)
    include(${CMAKE_SOURCE_DIR}/cmake/FindLibObs.cmake)
endif()

find_package(LibObs REQUIRED)
find_package(Qt5 REQUIRED COMPONENTS Core Widgets)

string(TIMESTAMP TODAY "%Y.%m.%d %H:%M")
add_definitions(-DBUILD_TIME="${TODAY}")
add_definitions(-DINPUT_OVERLAY_VERSION="${INPUT_OVERLAY_VERSION}")

if (WIN32)
   configure_file(${CMAKE_SOURCE_DIR}/package/installer.iss.in
       ${CMAKE_SOURCE_DIR}/package/installer.iss)
endif()

if (MSVC)
    set(input-overlay_PLATFORM_SOURCES
            src/util/window_helper_win.cpp
            src/hook/uiohook_helper_win.cpp)
    set(OBS_FRONTEND_INCLUDE "${LIBOBS_INCLUDE_DIR}/../UI/")
    set(input-overlay_PLATFORM_DEPS wsock32)
else()
    find_path(OBS_FRONTEND_INCLUDE obs-frontend-api.h)
endif ()

if ("${CMAKE_SYSTEM_NAME}" MATCHES "Linux")
    add_definitions(-DLINUX=1)
    add_definitions(-DUNIX=1)

    set(input-overlay_PLATFORM_SOURCES
        src/util/window_helper_nix.cpp
        src/hook/uiohook_helper_linux.cpp)
endif ()

if (APPLE)
    # TODO: macOS stuff
endif ()

if (NOT Qt5Widgets_FOUND)
    message(FATAL_ERROR "Failed to find Qt5")
endif ()

set(input-overlay_SOURCES
        src/input_overlay.cpp
        src/sources/input_source.cpp
        src/sources/input_source.hpp
        src/sources/input_source.cpp
        src/hook/uiohook_helper.hpp
        src/hook/gamepad_hook_helper.hpp
        src/hook/gamepad_hook_helper.cpp
        src/gui/io_settings_dialog.cpp
        src/gui/io_settings_dialog.hpp
        src/util/obs_util.cpp
        src/util/obs_util.hpp
        src/util/overlay.cpp
        src/util/overlay.hpp
        src/util/element/element.cpp
        src/util/element/element.hpp
        src/util/element/element_texture.cpp
        src/util/element/element_texture.hpp
        src/util/element/element_button.cpp
        src/util/element/element_button.hpp
        src/util/element/element_mouse_wheel.cpp
        src/util/element/element_mouse_wheel.hpp
        src/util/element/element_trigger.cpp
        src/util/element/element_trigger.hpp
        src/util/element/element_analog_stick.cpp
        src/util/element/element_analog_stick.hpp
        src/util/element/element_gamepad_id.cpp
        src/util/element/element_gamepad_id.hpp
        src/util/element/element_mouse_movement.cpp
        src/util/element/element_mouse_movement.hpp
        src/util/element/element_dpad.cpp
        src/util/element/element_dpad.hpp
        src/util/input_data.hpp
        src/util/input_data.cpp
        src/network/remote_connection.cpp
        src/network/remote_connection.hpp
        src/network/io_server.cpp
        src/network/io_server.hpp
        src/network/io_client.cpp
        src/network/io_client.hpp
        src/network/mg.cpp
        src/network/mg.hpp
        src/util/config.cpp
        src/util/config.hpp
        src/util/input_filter.cpp
        src/util/input_filter.hpp
        src/util/log.h
        src/util/settings.h
        src/util/lang.h src/network/websocket_server.hpp
        src/network/websocket_server.cpp
        ${MONGOOSE_SOURCE})

add_library(input-overlay MODULE
        ${input-overlay_SOURCES}
        ${input-overlay_UI}
        ${input-overlay_PLATFORM_SOURCES})

if (OBS_FRONTEND_INCLUDE)
    include_directories(${OBS_FRONTEND_INCLUDE})
endif()

target_include_directories(
    input-overlay
    PUBLIC
    ${COMMON_HEADERS}
    ${JSON_11_HEADER}
    ${GAMEPAD_INCLUDE_DIR}
    ${UIOHOOK_INCLUDE_DIR}
    ${MONGOOSE_INCLUDE_DIR}
    "${LIBOBS_INCLUDE_DIR}/../UI/obs-frontend-api"
    ${NETLIB_INCLUDE_DIR}
    ${Qt5Core_INCLUDES}
    ${Qt5Widgets_INCLUDES}
)

target_link_libraries(input-overlay
        ${input-overlay_PLATFORM_DEPS}
        Qt5::Core
        Qt5::Widgets
        libobs
        uiohook_static
        netlib_static
        gamepad_static)

if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(ARCH_NAME "64bit")
    set(OBS_BUILDDIR_ARCH "build64")
else()
    set(ARCH_NAME "32bit")
    set(OBS_BUILDDIR_ARCH "build32")
endif()

# --- Windows-specific build settings and tasks ---
if(WIN32)
    if(NOT DEFINED OBS_FRONTEND_LIB)
        set(OBS_FRONTEND_LIB "OBS_FRONTEND_LIB-NOTFOUND" CACHE FILEPATH "OBS frontend library")
        message(FATAL_ERROR "Could not find OBS Frontend API\'s library !")
    endif()

    # Enable Multicore Builds and disable FH4 (to not depend on VCRUNTIME140_1.DLL when building with VS2019)
    if (MSVC)
        add_definitions(/MP /d2FH4-)
    endif()

    include_directories(
        "${LIBOBS_INCLUDE_DIR}"
    )

    target_link_libraries(input-overlay
        "${OBS_FRONTEND_LIB}"
    )

    get_filename_component(LibOBS_DIR ${LIBOBS_LIB} DIRECTORY)

    add_custom_command(TARGET input-overlay POST_BUILD
        # Copy to obs-studio dev environment for immediate testing
        COMMAND if $<CONFIG:Debug>==1 (
            "${CMAKE_COMMAND}" -E copy
                "$<TARGET_FILE:input-overlay>"
                "${LibOBS_DIR}/../../rundir/$<CONFIG>/obs-plugins/${ARCH_NAME}")

        COMMAND if $<CONFIG:Debug>==1 (
            "${CMAKE_COMMAND}" -E copy
                "$<TARGET_PDB_FILE:input-overlay>"
                "${LibOBS_DIR}/../../rundir/$<CONFIG>/obs-plugins/${ARCH_NAME}")

        COMMAND if $<CONFIG:Debug>==1 (
            "${CMAKE_COMMAND}" -E make_directory
                "${LibOBS_DIR}/../../rundir/$<CONFIG>/data/obs-plugins/${CMAKE_PROJECT_NAME}")

        COMMAND if $<CONFIG:Debug>==1 (
            "${CMAKE_COMMAND}" -E copy_directory
                "${PROJECT_SOURCE_DIR}/data"
                "${LibOBS_DIR}/../../rundir/$<CONFIG>/data/obs-plugins/input-overlay")
    )
endif()

if(UNIX AND NOT APPLE)
    include(GNUInstallDirs)
    set_target_properties(input-overlay PROPERTIES PREFIX "")
    target_link_libraries(input-overlay obs-frontend-api)

    if (LOCAL_INSTALLATION)
        # Installs into home directory
        install(TARGETS input-overlay
            LIBRARY DESTINATION "$ENV{HOME}/.config/obs-studio/plugins/input-overlay/bin/${ARCH_NAME}")

        install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/data
            DESTINATION "$ENV{HOME}/.config/obs-studio/plugins/input-overlay/")
    elseif(DEB_INSTALLER)
        # For *.deb installer
        install(TARGETS input-overlay
            LIBRARY DESTINATION "${CMAKE_INSTALL_FULL_LIBDIR}/obs-plugins")
        install(TARGETS input-overlay
            LIBRARY DESTINATION "/usr/lib/obs-plugins") # Ubuntu apparently doesn't know the correct path

        install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/data
            DESTINATION "${CMAKE_INSTALL_FULL_DATAROOTDIR}/obs/obs-plugins/input-overlay")
    else()
        # For *.zip binary
        install(TARGETS input-overlay
            LIBRARY DESTINATION "input-overlay/bin/${ARCH_NAME}")

        install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/data
            DESTINATION "input-overlay")
    endif()
endif()

```

`projects/plugin/README.md`:

```md
## This is the sourcecode for the OBS studio plugin
See [Compiling](https://github.com/univrsal/input-overlay/wiki/Contributing#developing) for additional information.

```

`projects/plugin/data/example.html`:

```html
<!DOCTYPE html>
<html>
    <!-- Example program to receive data from input overlay via the websocket server
         This can be used to visualize inputs through css or html5 canvas methods
         instead of the builtin overlay source.
    -->
    <head>
        <meta charset="utf-8" />
        <title>input-overlay websocket example</title>
    </head>
    <body>
        <ul id="log" style="list-style-type: none"></ul>
    </body>
    <script>
        var l = document.getElementById("log");
        var require_clear = false;
        var count = 0;

        function on_data(e) {
            console.log(e.data);
            l.insertAdjacentHTML("beforeend", `<li>${e.data}</li>`);
            // Only keep last 50 entries
            if (!require_clear) {
                count++;
                if (count > 50) require_clear = true;
            } else {
                l.children[0].remove();
            }
        }

        function start_websocket() {
            var ws = new WebSocket("ws://localhost:16899/");

            ws.onmessage = on_data;
            ws.onmessage = on_data;
            ws.onerror = (e) => console.log('WebSocket error: ' + e);

            ws.onclose = () => {
                // connection closed, discard old websocket and create a new one in 2 seconds
                ws = null;
                setTimeout(start_websocket, 2000);
            };
        }
        
        start_websocket();
    </script>
</html>

```

`projects/plugin/data/locale/de-DE.ini`:

```ini
InputOverlay="Input Overlay"
InputHistory="Input History"

Filter.ImageFiles="Bilddateien"
Filter.TextFiles="Textdateien"
Filter.AllFiles="Alle Dateitypen"

Overlay.Path.Texture="Texturdatei"
Overlay.Path.Layout="Layoutdatei"
Overlay.FontSettings="Zeige Schrifteinstellungen"

Mouse.Sensitivity="Mausempfindlichkeit"
Mouse.Deadzone="Maus Sperrbereich"
Mouse.UseCenter="Benutze Monitormitte (Wenn ein Spiel die Maus festhällt)"
Monitor.CenterX="Monitor horizontale Mitte"
Monitor.CenterY="Monitor vertikale Mitte"

Gamepad.Reload="Lade Controller neu von /dev/input"
Gamepad.Id="Controller Nummer"
Gamepad.LeftDeadZone="Linker Analogsticksperrbereich"
Gamepad.RightDeadZone="Rechter Analogsticksperrbereich"

History.Mode="Overlaymodus"
History.Mode.Text="Ausgeschriebene Tasten"
History.Mode.Icons="Tastensymbole"

History.Direction="Richtung"
History.Direction.Up="Hoch"
History.Direction.Down="Runter"
History.Direction.Left="Links"
History.Direction.Right="Rechts"

History.KeyIconPath="Tastensymbole"
History.KeyIconConfigPath="Tastensymbol einstellungen"
History.KeyIconVSpace="Vertikaler Abstand"
History.KeyIconHSpace="Horizontaler Abstand"

History.Font="Schriftart"
History.Font.Color="Schriftfarbe"
History.Font.Outline="Rand"
History.Font.Outline.Size="Randgröße"
History.Font.Outline.Color="Randfarbe"
History.Font.Outline.Opacity="Randsichtbarkeit"

History.Size="Verlaufsgröße"
History.Path.KeyNames="Tastennamen"
History.UseFallbackNames="Bentutze eingebaute Namen, wenn nicht definiert"
History.IncludeMouse="Beinhalte Maus"
History.IncludePad="Beinhalte Controller"
History.FixCutting="Verhindere abgeschnittene Buchstaben"
History.Update.Interval="Aktualisierungen (Alle x Frames)"
History.ClearHistory="Leere Verlauf"
History.Opacity="Sichtbarkeit"
History.Enable.RepeatKeys="Erlaube Tastenwiederholungen"
History.Enable.AutoClear="Automatische Verlaufsleerung"
History.AutoClear.Interval="Automatische Leerung (Alle x Sekunden)"
History.Commandmode="Kommandomodus (Zeigt alle Eingaben!)"

Source.InputSource="Eingabequelle"
Source.InputSource.Reload="Aktualisieren"
Source.InputSource.Local="Dieser Computer"

Dialog.InputOverlay.Title="input-overlay Einstellungen"
Dialog.InputOverlay.LocalFeatures="Lokale Funktionen"
Dialog.InputOverlay.LocalFeatures.Label="Die meisten Veränderungen funktionieren erst nach einem Neustart!"
Dialog.InputOverlay.EnableUiohook="Maus und Tastatur Abfragen"
Dialog.InputOverlay.EnableGamepadHook="Controller Abfragen"
Dialog.InputOverlay.EnableInputOverlay="Input Overlay Quelle"
Dialog.InputOverlay.EnableInputHistory="Input History Quelle"
Dialog.InputOverlay.RemoteConnection="Netzwerkübertragung""
Dialog.InputOverlay.EnableRemoteConnection="Aktiviere Netzwerkübertragung"
Dialog.InputOverlay.RemoteConnection.Logging="Benutze Log"
Dialog.InputOverlay.RemoteConnection.Status="Server Status: %s"
Dialog.InputOverlay.RemoteConnection.Port="Port:"
Dialog.InputOverlay.RemoteConnection.Connections="Aktive Verbindungen:"
Menu.InputOverlay.OpenSettings="input-overlay Einstellungen
```

`projects/plugin/data/locale/en-US.ini`:

```ini
InputOverlay="Input Overlay"
InputHistory="Input History"

Filter.ImageFiles="Image Files"
Filter.TextFiles="Text Files"
Filter.AllFiles="All Files"

Overlay.Path.Texture="Overlay image file"
Overlay.Path.Layout="Overlay config file"
Overlay.FontSettings="Show font settings"

Mouse.Sensitivity="Mouse sensitivity"
Mouse.Deadzone="Mouse deadzone"
Mouse.UseCenter="Use monitor center (For games that lock the mouse)"
Monitor.CenterX="Monitor horizontal center"
Monitor.CenterY="Monitor vertical center"

Gamepad.Reload="Reload gamepads"
Gamepad.IsGamepad="Gamepad overlay"
Gamepad.Id="Gamepad id"
Gamepad.Path="Device path"
Gamepad.LeftDeadZone="Left stick deadzone"
Gamepad.RightDeadZone="Right stick deadzone"

Source.InputSource="Input source"
Source.InputSource.Reload="Refresh"
Source.InputSource.Local="This computer"

Dialog.Title="input-overlay configuration"
Dialog.LocalFeatures="Local features"
Dialog.LocalFeatures.Info="Most of these settings will require a restart!"
Dialog.Uiohook.Enable="Enable mouse and keyboard hook"
Dialog.Wss="Forward events through websocket server with port "
Dialog.GamepadHook.Enable="Enable gamepad hook"
Dialog.InputOverlay.Enable="Enable Input Overlay Source"
Dialog.InputHistory.Enable="Enable Input History Source"
Dialog.InputControl.Enable="Enable Input Control"
Dialog.InputControl.Regex.Enable="Enable regex for window titles"
Dialog.InputControl.Mode="Filter mode:"
Dialog.InputControl.Mode.Whitelist="Whitelist"
Dialog.InputControl.Mode.Blacklist="Blacklist"
Dialog.InputControl.NewEntry="Window title for filter:"
Dialog.InputControl.Add="Add new filter"
Dialog.InputControl.List="Current filters:"
Dialog.InputControl.Remove="Remove selected filter"
Dialog.GamepadHook.Xinput="Use XInput (recommended)"
Dialog.GamepadHook.Dinput="Use DInput (if XInput doesn't work)"
Dialog.GamepadHook.Js="Use /dev/input/js (Better compatibility)"
Dialog.GamepadHook.ById="Use /dev/by-id/ (Better identification if you use multiple gamepads)"

Dialog.Gamepad="Gamepad bindings"
Dialog.Gamepad.Info="Focus the text area and press the according button"
Dialog.Gamepad.Device="Device"
Dialog.Gamepad.Binding="Binding config"
Dialog.Gamepad.Binding.A="A"
Dialog.Gamepad.Binding.B="B"
Dialog.Gamepad.Binding.X="X"
Dialog.Gamepad.Binding.Y="Y"
Dialog.Gamepad.Binding.Start="Start"
Dialog.Gamepad.Binding.Back="Back"
Dialog.Gamepad.Binding.RB="RB"
Dialog.Gamepad.Binding.LB="LB"
Dialog.Gamepad.Binding.RT="RT"
Dialog.Gamepad.Binding.LT="LT"
Dialog.Gamepad.Binding.Dpad.Up="Dpad up"
Dialog.Gamepad.Binding.Dpad.Down="Dpad down"
Dialog.Gamepad.Binding.Dpad.Left="Dpad left"
Dialog.Gamepad.Binding.Dpad.Right="Dpad right"
Dialog.Gamepad.Binding.Analog.Left="Left stick pressed"
Dialog.Gamepad.Binding.Analog.Right="Right stick pressed"
Dialog.Gamepad.Binding.Analog.RX="Right stick X-Axis"
Dialog.Gamepad.Binding.Analog.RY="Right stick Y-Axis"
Dialog.Gamepad.Binding.Analog.LX="Left stick X-Axis"
Dialog.Gamepad.Binding.Analog.LY="Left stick Y-Axis"
Dialog.Gamepad.Binding.Guide="Guide"

Dialog.About="About"
Dialog.About.Button.Github="Open GitHub"
Dialog.About.Button.Forums="Open OBS Forums"

Dialog.RemoteConnection="Remote connection"
Dialog.Remote.Enable="Enable remote connection"
Dialog.Remote.Logging="Enable logging"
Dialog.Remote.Status="Server status: %s, IP: %s"
Dialog.Remote.Port="Port:"
Dialog.Remote.Connections="Active connections:"
Dialog.Remote.RefreshRate="Client refresh rate:"
Dialog.Remote.RefreshRate.Tooltip="The interval in which the server will request updates from all clients. Lower = more fluent transmission"
Menu.InputOverlay.OpenSettings="input-overlay settings"
```

`projects/plugin/data/locale/ko-KR.ini`:

```ini
InputOverlay="입력 오버레이"
InputHistory="입력 내역"

Filter.ImageFiles="이미지 파일"
Filter.TextFiles="텍스트 파일"
Filter.AllFiles="모든 파일"

Overlay.Path.Texture="오버레이 이미지 파일"
Overlay.Path.Layout="레이아웃 설정 파일"

Mouse.Sensitivity="마우스 감도"
Mouse.Deadzone="마우스 데드존"
Mouse.UseCenter="모니터 중앙 사용 (마우스를 잠그는 게임일 경우)"
Monitor.CenterX="모니터 가로 중앙"
Monitor.CenterY="모니터 세로 중앙"

Gamepad.Id="게임패드 ID"
Gamepad.Path="장치 경로"
Gamepad.LeftDeadZone="왼쪽 스틱 데드존"
Gamepad.RightDeadZone="오른쪽 스틱 데드존"

History.Mode="오버레이 모드"
History.Mode.Text="일반 텍스트"
History.Mode.Icons="키 아이콘"

History.Direction="방향"
History.Direction.Up="상"
History.Direction.Down="하"
History.Direction.Left="좌"
History.Direction.Right="우"

History.Path.Icons.Texture="키 아이콘 텍스쳐"
History.Path.Icons.Config="키 아이콘 설정"
History.Icons.Space.Vertical="가로 공간"
History.Icons.Space.Horizontal="세로 공간"

History.Font="오버레이 글꼴"
History.Font.Color="색상"
History.Font.Outline="윤곽선"
History.Font.Outline.Size="윤곽선 크기"
History.Font.Outline.Color="윤곽선 색상"
History.Font.Outline.Opacity="윤곽선 불투명도"

History.Size="기록 크기"
History.Path.KeyNames="키 이름 설정"
History.UseFallbackNames="파일에 정의되어 있지 않으면 내장 명칭 사용"
History.IncludeMouse="마우스 포함"
History.IncludePad="게임패드 포함"
History.FixCutting="단락 문자 수정"
History.Update.Interval="새로고침 주기 (매 x 프레임)"
History.ClearHistory="기록 삭제"
History.Opacity="불투명도"
History.Enable.RepeatKeys="반복된 키 사용"
History.Enable.AutoClear="자동 삭제 활성화"
History.AutoClear.Interval="자동 삭제 주기 (매초)"
History.Commandmode="명령어모드 (입력 전체 기록)"

```

`projects/plugin/data/locale/ru-RU.ini`:

```ini
InputOverlay="Входной оверлей"
InputHistory="История ввода"

Filter.ImageFiles="Файлы изображении"
Filter.TextFiles="Текстовые файлы"
Filter.AllFiles="Все файлы"

Overlay.Path.Texture="Наложение файла изображения"
Overlay.Path.Layout="Файл конфигурации .ini"

Mouse.Sensitivity="Чувствительность мыши"
Mouse.Deadzone="Мышь мертвая зона"
Mouse.UseCenter="Используйте центр мониторинга (для игр, которые блокируют мышь)"
Monitor.CenterX="Мониторинг горизонтального центра"
Monitor.CenterY="Монитор вертикального центра"

Gamepad.Id="Идентификатор панели управления, id"
Gamepad.LeftDeadZone="Левая мертвая зона"
Gamepad.RightDeadZone="Правая ручка мертвой зоны"

History.Mode="Режим наложения"
History.Mode.Text="Простой текст"
History.Mode.Icons="Значки клавиш"

History.Direction="Направление"
History.Direction.Up="Вверх"
History.Direction.Down="Вниз"
History.Direction.Left="Влево"
History.Direction.Right="Вправо"

History.Path.Icons.Texture="Текстура ключевых значков"
History.Path.Icons.Config="Конфигурация значка ключа"
History.Icons.Space.Vertical="Вертикальное пространство"
History.Icons.Space.Horizontal="Горизонтальное пространство"

History.Font="Оверлейный шрифт"
History.Font.Color="Цвет"
History.Font.Outline="Контур"
History.Font.Outline.Size="Размер контура"
History.Font.Outline.Color="Цвет контура"
History.Font.Outline.Opacity="Прозрачность контура"

History.Size="Размер истории"
History.Path.KeyNames="Конфигурация имени ключа"
History.UseFallbackNames="Использовать встроенные имена, если они не определены в файле"
History.IncludeMouse="Включить мышь"
History.FixCutting="Исправить отрезанные буквы"
History.Update.Interval="Интервал обновления (каждый х кадров)"
History.ClearHistory="Чистая история"
History.Opacity="Помутнение"
History.Enable.RepeatKeys="Включение повторных ключей"
History.Enable.AutoClear="Включить автоматическую очистку"
History.AutoClear.Interval="Интервал автоматической очистки (в секундах)"
```

`projects/plugin/data/locale/zh-CN.ini`:

```ini
InputOverlay="按键显示"
InputHistory="按键历史"

Filter.ImageFiles="贴图文件"
Filter.TextFiles="配置文件"
Filter.AllFiles="所有文件"

Overlay.Path.Texture="贴图文件"
Overlay.Path.Layout="配置文件"
Overlay.FontSettings="显示字体设定"

Mouse.Sensitivity="鼠标灵敏度"
Mouse.Deadzone="鼠标盲区"
Mouse.UseCenter="使用屏幕中心 （若游戏锁定了鼠标位置）"
Monitor.CenterX="中心水平偏移"
Monitor.CenterY="中心垂直偏移"

Gamepad.Reload="重新载入手柄"
Gamepad.IsGamepad="手柄显示"
Gamepad.Id="手柄 ID"
Gamepad.Path="设备路径"
Gamepad.LeftDeadZone="左摇杆盲区"
Gamepad.RightDeadZone="右摇杆盲区"

Source.InputSource="输入源"
Source.InputSource.Reload="刷新"
Source.InputSource.Local="此电脑"

Dialog.Title="配置按键显示"
Dialog.LocalFeatures="本地功能"
Dialog.LocalFeatures.Info="绝大部分设置需要重启才能生效！"
Dialog.Uiohook.Enable="启用鼠标键盘监控钩子"
Dialog.Wss="通过 Websocket 服务器转发事件。设定端口为"
Dialog.GamepadHook.Enable="启用手柄监控钩子"
Dialog.InputOverlay.Enable="启用按键显示源"
Dialog.InputHistory.Enable="启用按键历史源"
Dialog.InputControl.Enable="启用输入控制"
Dialog.InputControl.Regex.Enable="启用窗口标题正则表达式"
Dialog.InputControl.Mode="过滤模式："
Dialog.InputControl.Mode.Whitelist="白名单"
Dialog.InputControl.Mode.Blacklist="黑名单"
Dialog.InputControl.NewEntry="过滤窗口标题："
Dialog.InputControl.Add="添加至过滤列表"
Dialog.InputControl.List="当前过滤列表："
Dialog.InputControl.Remove="移除选定的过滤选项"
Dialog.GamepadHook.Xinput="使用 XInput （推荐）"
Dialog.GamepadHook.Dinput="使用 DInput （若 XInput 不可用）"
Dialog.GamepadHook.Js="使用 /dev/input/js （兼容性更好）"
Dialog.GamepadHook.ById="使用 /dev/by-id/ （识别多手柄更方便）"

Dialog.Gamepad="手柄键位绑定"
Dialog.Gamepad.Info="选定文本区域并按下相应的按键"
Dialog.Gamepad.Device="设备"
Dialog.Gamepad.Binding="绑定配置"
Dialog.Gamepad.Binding.A="A"
Dialog.Gamepad.Binding.B="B"
Dialog.Gamepad.Binding.X="X"
Dialog.Gamepad.Binding.Y="Y"
Dialog.Gamepad.Binding.Start="开始键"
Dialog.Gamepad.Binding.Back="返回键"
Dialog.Gamepad.Binding.RB="RB"
Dialog.Gamepad.Binding.LB="LB"
Dialog.Gamepad.Binding.RT="RT"
Dialog.Gamepad.Binding.LT="LT"
Dialog.Gamepad.Binding.Dpad.Up="触摸板上滑"
Dialog.Gamepad.Binding.Dpad.Down="触摸板下滑"
Dialog.Gamepad.Binding.Dpad.Left="触摸板左滑"
Dialog.Gamepad.Binding.Dpad.Right="触摸板右滑"
Dialog.Gamepad.Binding.Analog.Left="左摇杆按下"
Dialog.Gamepad.Binding.Analog.Right="右摇杆按下"
Dialog.Gamepad.Binding.Analog.RX="右摇杆 X 轴"
Dialog.Gamepad.Binding.Analog.RY="右摇杆 Y 轴"
Dialog.Gamepad.Binding.Analog.LX="左摇杆 X 轴"
Dialog.Gamepad.Binding.Analog.LY="左摇杆 Y 轴"
Dialog.Gamepad.Binding.Guide="导航键"

Dialog.About="关于"
Dialog.About.Button.Github="访问 GitHub"
Dialog.About.Button.Forums="访问 OBS 论坛"

Dialog.RemoteConnection="远程连接"
Dialog.Remote.Enable="启用远程连接"
Dialog.Remote.Logging="启用日志"
Dialog.Remote.Status="服务器状态： %s, IP 地址： %s"
Dialog.Remote.Port="端口："
Dialog.Remote.Connections="已激活的连接："
Dialog.Remote.RefreshRate="客户端刷新率："
Dialog.Remote.RefreshRate.Tooltip="服务器向所有客户端请求数据更新的时间间隔。更低=传输更流畅"
Menu.InputOverlay.OpenSettings="配置按键显示"

```

`projects/plugin/data/mouse_highlight.html`:

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Page Title</title>
    </head>
    <body>
        <span id="dot"></span>
    </body>
    <style>
        #dot {
            height: 60px;
            width: 60px;
            background-color: rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            position: absolute;
            left: 0px;
            top: 0px;
        }
        body {
            margin: 0;
        }
    </style>

    <script>
        var dot = document.getElementById('dot');
        function on_data(e) {
            let json = JSON.parse(e.data);
            let t = json.event_type;
            if (t === 'mouse_moved') {
                // I needed a  little offset to center the circle
                dot.style.left = (json.x - 30) + "px";
                dot.style.top = (json.y - 50) + "px";
            }
        }

        function start_websocket() {
            var ws = new WebSocket("ws://localhost:16899/");

            ws.onmessage = on_data;            ws.onmessage = on_data;
            ws.onerror = (e) => console.log("WebSocket error: " + e);

            ws.onclose = () => {
                // connection closed, discard old websocket and create a new one in 2s
                ws = null;
                setTimeout(startWebsocket, 2000);
            };
        }

        start_websocket();
    </script>
</html>

```

`projects/plugin/data/overlay_render/js/config.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

class config {

    constructor(canvas_id, painter)
    {
        this.data = {};
        this.elements = [];
        this.painter = painter;
        this.is_ctrl_down = false;
        this.internal_clipboard = null;
        this.enabled = true; // false when a dialog is open
        //$(canvas_id).on('mousemove', e => this.move(e, this.painter.cs()));
        $(canvas_id).on('mouseup', e => this.mouseup(e, this.painter.cs()));
        $(canvas_id).on('mousedown', e => this.mousedown(e, this.painter.cs()));
        $(canvas_id).on('wheel', e => this.on_scroll(e));
        $(window).on('keydown', e => this.on_button(e, true));
        $(window).on('keyup', e => this.on_button(e, false));
        pad.on('input', p => this.gamepad_input(p));
        this.load_callbacks = [];
        setInterval(() => this.tick(), 250);
    }

    tick() { this.elements.forEach(e => e.tick()); }

    on_scroll(e) { this.elements.forEach(element => element.on_scroll_input(e)); }

    add_elements(j)
    {
        if (j) {
            if (j.length > 0)
                this.selected_elements = [];
            j.forEach(e => {
                let orig_id = e.id.replace(/\d+$/, "");
                let counter = 0;
                let id = orig_id + counter;
                e.pos[1] += 4; // offset so you can see the pasted elements
                while (!this.is_name_unique(id))
                    id = orig_id + counter++;
                e.id = id;
                let new_element = create_element(e);
                this.elements.push(new_element);
                this.selected_elements.push(new_element);
            });
        }
    }

    add_load_callback(cb) { this.load_callbacks.push(cb); }

    load_from_json(json)
    {
        this.data = json;
        this.data["elements"].forEach(data => {
            let new_element = create_element(data);
            if (new_element !== null)
                this.elements.push(new_element);
        });
        this.sort_elements();
        this.load_callbacks.forEach(cb => cb());
    }

    sort_elements()
    {
        this.elements.sort((a, b) => { return a.layer() - b.layer(); });
    }

    draw(painter)
    {
        if (atlas === null) // Don't draw if image hasn't loaded yet
            return;

        this.elements.forEach(element => element.draw(painter));
    }

    delete_selection()
    {
        let new_elements = this.elements.filter(function(to_filter) {
            return this.selected_elements.find(function(to_find) { return to_filter.id() === to_find.id(); }) ===
                   undefined;
        }, this);
        this.elements = new_elements;
        this.deselect();
    }

    is_name_unique(name, editing_element)
    {
        let unique = true;
        this.elements.some(e => {
            if (e.id() === name) {
                if (!editing_element || e !== editing_element) {
                    unique = false;
                    return true;
                }
            }
            return false;
        });
        return unique;
    }

    gamepad_input(pad) { this.elements.forEach(e => e.on_gamepad_input(pad)); }

    on_button(event, state)
    {
        if (!this.enabled)
            return;
        if (event.key == 'Control')
            this.is_ctrl_down = state;

        let vc = key_to_vc(event);
        this.elements.forEach(element => element.on_keyboard_input(vc, state));
    }

    mouseup(event, cs)
    {
        this.selecting = false;
        this.dragging = false;
        let vc = mouse_to_vc(event);
        this.elements.forEach(element => element.on_mouse_input(vc, false));
    }

    mousedown(event, cs)
    {
        let vc = mouse_to_vc(event);
        this.elements.forEach(element => element.on_mouse_input(vc, true));
    }
}

```

`projects/plugin/data/overlay_render/js/draw.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

var backgroundColor = "#00000000";
var lineColor = "#ffffffff";
var darkLineColor = "#555555";
var brightLineColor = "#f055559c"

class painter {

    constructor(canvas_id, draw_callback)
    {
        this.enabled = true;
        this.scale = 1; // HiDPI support at some point maybe
        this.canvas_id = '#' + canvas_id;
        this.canvas_container_id = '#' + canvas_id + '-container';
        this.draw_callback = draw_callback;
        $(window).on('resize', () => this.resize_canvas());

        requestAnimationFrame(seconds => this.update(seconds)); // start animation
    }

    cs() { return this.coordinate_system; }

    load_image(url)
    {
        return new Promise(r => {
            let i = new Image();
            i.onload = (() => r(i));
            i.src = url;
        });
    }

    get_context() { return $(this.canvas_id)[0].getContext('2d'); }

    fill(w, h, color) { this.rect(0, 0, w, h, color); }

    rect(x, y, w, h, color)
    {
        let context = this.get_context();
        context.beginPath();
        context.rect(x, y, w, h);
        context.fillStyle = color;
        context.fill();
    }

    rect_outline(x, y, w, h, width = 1, color = lineColor)
    {
        let context = this.get_context();
        context.beginPath();
        context.rect(x, y, w, h);
        context.strokeStyle = color;
        context.lineWidth = width;
        context.stroke();
    }

    text(str, x, y, rotate = 0, align = "right", color = lineColor, size = 13, font = "Arial")
    {
        let ctx = this.get_context();
        ctx.save();
        ctx.translate(x, y);
        if (rotate > 0)
            ctx.rotate(rotate * Math.PI / 180);
        ctx.textAlign = align;
        ctx.font = size + "px " + font;
        ctx.fillStyle = color;
        ctx.fillText(str, 0, 0);
        ctx.restore();
    }

    line(x1, y1, x2, y2, width = 2, color = lineColor)
    {
        let ctx = this.get_context();
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
    }

    dashed_line(x1, y1, x2, y2, width = 2, color = lineColor, dash = 5, space = 3)
    {
        let ctx = this.get_context();
        ctx.setLineDash([dash, space]);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
    }

    image(i, x, y)
    {
        let context = this.get_context();
        context.drawImage(i, x, y);
    }

    image_crop(i, x, y, w, h, cx, cy, cw, ch)
    {
        let context = this.get_context();
        context.drawImage(i, cx, cy, cw, ch, x * this.scale, y * this.scale, w * this.scale, h * this.scale);
    }

    resize_canvas()
    {
        let w = $(this.canvas_container_id).innerWidth();
        let h = $(this.canvas_container_id).innerHeight();
        $(this.canvas_id).css({"height": h, "width": w});
        $(this.canvas_id).attr("width", w);
        $(this.canvas_id).attr("height", h);
        this.fill(w, h, backgroundColor);
        this.get_context().imageSmoothingEnabled = false;
    }

    update(time)
    {
        if (this.enabled) {
            let c = $(this.canvas_id)[0];
            this.get_context().clearRect(0, 0, c.width, c.height);
            if (this.draw_callback !== null)
                this.draw_callback(this, null);
        }
        requestAnimationFrame(seconds => this.update(seconds)); // get next frame
    }
}

```

`projects/plugin/data/overlay_render/js/elements.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

let element_types = {
    TEXTURE: 0,
    KEYBOARD_KEY: 1,
    GAMEPAD_BUTTON: 2,
    MOUSE_BUTTON: 3,
    WHEEL: 4,
    ANALOG_STICK: 5,
    TRIGGER: 6,
    /* Shows game pad number 1 through 4 */
    GAMEPAD_ID: 7,
    DPAD_STICK: 8,
    MOUSE_MOVEMENT: 9,
};

let overlay_flags = {
    LEFT_STICK: 1 << 0,
    RIGHT_STICK: 1 << 1,
    GAMEPAD: 1 << 2,
    MOUSE: 1 << 3,
};

let constants = { texture_space: 3 };

let element_map = new Map();

function type_from_string(type) {
    switch (type) {
        case "mouse_button":
            return element_types.MOUSE_BUTTON;
        case "keyboard_button":
            return element_types.KEYBOARD_KEY;
        case "texture":
            return element_types.TEXTURE;
        case "gamepad_button":
            return element_types.GAMEPAD_BUTTON;
        case "analog_stick":
            return element_types.ANALOG_STICK;
        case "trigger":
            return element_types.TRIGGER;
        case "mouse_movement":
            return element_types.MOUSE_MOVEMENT;
        case "mouse_wheel":
            return element_types.WHEEL;
        case "player_id":
            return element_types.GAMEPAD_ID;
        case "dpad":
            return element_types.DPAD_STICK;
        case "mouse_movement":
            return element_types.MOUSE_MOVEMENT;
        default:
            return -1;
    }
}

function type_from_id(type) {
    switch (type) {
        case element_types.MOUSE_BUTTON:
            return "mouse_button";
        case element_types.KEYBOARD_KEY:
            return "keyboard_button";
        case element_types.TEXTURE:
            return "texture";
        case element_types.GAMEPAD_BUTTON:
            return "gamepad_button";
        case element_types.ANALOG_STICK:
            return "analog_stick";
        case element_types.TRIGGER:
            return "trigger";
        case element_types.MOUSE_MOVEMENT:
            return "mouse_movement";
        case element_types.WHEEL:
            return "mouse_wheel";
        case element_types.GAMEPAD_ID:
            return "player_id";
        default:
            return "";
    }
}

class element {
    constructor(json) { this.data = json; }

    draw(painter) { }
    on_keyboard_input(vc, state) { }
    on_mouse_input(vc, state) { }
    on_gamepad_input(pad) { }
    on_scroll_input(event) { }

    tick() { }

    read_data_from_gui() {
        this.data.id = $("#editor-element-id").val();
        this.data.z_level = parseInt($("#editor-element-layer").val());
    }

    write_data_to_gui() {
        $("#editor-element-id").val(this.data.id);
        $("#editor-element-layer").val(this.data.z_level);
    }

    dim() { return new r4(this.x(), this.y(), this.w(), this.h()); }

    set_dim(pos, uvwh) {
        this.data.pos[0] = pos.x;
        this.data.pos[1] = pos.y;
        this.data.mapping[0] = uvwh.x;
        this.data.mapping[1] = uvwh.y;
        this.data.mapping[2] = uvwh.w;
        this.data.mapping[3] = uvwh.h;
    }

    type() { return this.data.type; }
    id() { return this.data.id; }
    x() { return this.data.pos[0]; }
    y() { return this.data.pos[1]; }
    u() { return this.data.mapping[0]; }
    v() { return this.data.mapping[1]; }
    w() { return this.data.mapping[2]; }
    h() { return this.data.mapping[3]; }
    set_id(id) { this.data.id = id; }

    set_pos(x, y) {
        this.data.pos[0] = x;
        this.data.pos[1] = y;
    }

    layer() { return this.data.z_level; }
    set_layer(layer) { this.data.z_level = layer; }
}

class texture extends element {
    draw(painter) {
        // default draw handling

        painter.image_crop(atlas, this.x(),
            this.y(), this.w(), this.h(),
            this.u(), this.v(), this.w(), this.h());
    }

    read_data_from_gui() {
        super.read_data_from_gui();
        this.data.mapping = [
            parseInt($("#editor-element-u").val()),
            parseInt($("#editor-element-v").val()),
            parseInt($("#editor-element-w").val()),
            parseInt($("#editor-element-h").val()),
        ];
    }

    write_data_to_gui() {
        super.write_data_to_gui();
        $("#editor-element-u").val(this.u());
        $("#editor-element-v").val(this.v());
        $("#editor-element-w").val(this.w());
        $("#editor-element-h").val(this.h());
    }
}

class button extends texture {
    constructor(json) {
        super(json);
        this.pressed = false;
    }

    draw(painter) {
        if (this.pressed) {
            painter.image_crop(atlas, this.x(),
                this.y(), this.w(),
                this.h(), this.u(), this.v() + constants.texture_space + this.h(), this.w(),
                this.h());
        } else {
            super.draw(painter);
        }
    }

    read_data_from_gui() {
        super.read_data_from_gui();
        this.data.code = parseInt($("#editor-element-keycode").val(), 16);
    }

    write_data_to_gui() {
        super.write_data_to_gui();
        $("#editor-element-keycode").val("0x" + this.data.code.toString(16).toUpperCase());
    }
}

class keyboard_button extends button {
    on_keyboard_input(vc, state) {
        if (vc === this.data.code)
            this.pressed = state;
    }
}

class mouse_button extends button {
    on_mouse_input(vc, state) {
        if (vc === this.data.code)
            this.pressed = state;
    }
}

class gamepad_button extends button {
    on_gamepad_input(pad) {
        let btn = gamepad_from_vc(this.data.code);

        if (btn < pad.buttons.length)
            this.pressed = pad.buttons[btn].pressed;
    }
}

class mouse_wheel extends texture {
    constructor(json) {
        super(json);
        this.direction = 0;
        this.pressed = false;
        this.lastWheelInput = Date.now();
    }

    on_mouse_input(vc, state) {
        if (vc === 3)
            this.pressed = state;
    }

    on_scroll_input(event) {
        if (event.originalEvent.deltaY < 0) {
            this.direction = -1;
        } else {
            this.direction = 1;
        }
        this.lastWheelInput = Date.now();
    }

    tick() {
        if (Date.now() - this.lastWheelInput > 250)
            this.direction = 0;
    }

    draw(painter) {

        super.draw(painter);
        if (this.pressed) {
            painter.image_crop(atlas, this.x(),
                this.y(), this.w(),
                this.h(), this.u() + constants.texture_space + this.w(), this.v(), this.w(),
                this.h());
        }

        if (this.direction === 1) {
            painter.image_crop(atlas, this.x(),
                this.y(), this.w(),
                this.h(), this.u() + (constants.texture_space + this.w()) * 2, this.v(),
                this.w(), this.h());
        } else if (this.direction === -1) {
            painter.image_crop(atlas, this.x(),
                this.y(), this.w(),
                this.h(), this.u() + (constants.texture_space + this.w()) * 3, this.v(),
                this.w(), this.h());
        }
    }
}

class analog_stick extends texture {
    draw(painter) {

        let xPos = 0;
        let yPos = 0;
        let pressed = false;
        if (pad.lastInput) {
            if (this.data.side === 0) {
                // left
                xPos = pad.lastInput.axes[0] * this.data.stick_radius;
                yPos = pad.lastInput.axes[1] * this.data.stick_radius;
                pressed = pad.lastInput.buttons[10].pressed;
            } else {
                // right
                xPos = pad.lastInput.axes[2] * this.data.stick_radius;
                yPos = pad.lastInput.axes[3] * this.data.stick_radius;
                pressed = pad.lastInput.buttons[11].pressed;
            }

            if (pressed) {
                painter.image_crop(atlas, (this.x() + xPos),
                    (this.y() + yPos), this.w(),
                    this.h(), this.u(), this.v() + constants.texture_space + this.h(),
                    this.w(), this.h());
            } else {
                painter.image_crop(atlas, (this.x() + xPos),
                    (this.y() + yPos), this.w(),
                    this.h(), this.u(), this.v(), this.w(), this.h());
            }
        } else {
            super.draw(painter);
        }
    }

    read_data_from_gui() {
        super.read_data_from_gui();
        this.data.stick_radius = parseInt($("#editor-element-analog-stick-radius").val());
        this.data.side = parseInt($("#editor-element-analog-stick-side").val());
    }

    write_data_to_gui() {
        super.write_data_to_gui();
        $("#editor-element-analog-stick-radius").val(this.data.stick_radius);
        $("#editor-element-analog-stick-side").val(this.data.side);
    }

    is_left_stick() { return this.side === 0; }
}

class gamepad_id extends texture {
    constructor(json) {
        super(json);
        this.pressed = false;
    }

    on_gamepad_input(pad) {
        let btn = gamepad_from_vc(this.data.code);

        if (pad.buttons.length > 16)
            this.pressed = pad.buttons[16].pressed;
    }

    draw(painter) {

        if (pad.lastInput) {
            if (this.pressed) {
                painter.image_crop(atlas, this.x(),
                    this.y(), this.w(),
                    this.h(), this.u() + (constants.texture_space + this.w()) * 4, this.v(),
                    this.w(), this.h());
            }
            painter.image_crop(atlas, this.x(),
                this.y(), this.w(),
                this.h(),
                this.u() + (constants.texture_space + this.w()) * pad.lastInput.index, this.v(),
                this.w(), this.h());
        } else {
            painter.image_crop(atlas, this.x(),
                this.y(), this.w(),
                this.h(), this.u(), this.v(), this.w(), this.h());
        }
    }
}

class trigger extends texture {
    draw(painter) {

        let progress = 0;
        let pressed = false;

        if (pad.lastInput) {
            if (this.data.side === 0) {
                // left
                progress = pad.lastInput.buttons[6].value;
                pressed = pad.lastInput.buttons[6].pressed;
            } else {
                // right
                progress = pad.lastInput.buttons[7].value;
                pressed = pad.lastInput.buttons[7].pressed;
            }

            if (this.data.trigger_mode) {
                if (pressed) {
                    painter.image_crop(atlas, this.x(),
                        this.y(), this.w(),
                        this.h(), this.u(), this.v() + constants.texture_space + this.h(),
                        this.w(), this.h());
                } else {
                    painter.image_crop(atlas, this.x(),
                        this.y(), this.w(),
                        this.h(), this.u(), this.v(), this.w(), this.h());
                }
            } else {
                super.draw(painter);
                if (this.data.direction === 1) {
                    // fill upwards
                    let offset = (1 - progress) * this.h();
                    painter.image_crop(atlas, this.x(),
                        (this.y() + offset), this.w(),
                        this.h() * progress, this.u(),
                        this.v() + this.h() + constants.texture_space + offset, this.w(),
                        this.h() * progress);
                } else if (this.data.direction === 2) {
                    // fill downwards
                    painter.image_crop(atlas, this.x(),
                        this.y(), this.w(),
                        this.h() * progress, this.u(),
                        this.v() + constants.texture_space + this.h(), this.w(), this.h() * progress);
                } else if (this.data.direction === 3) {
                    // fill to the left
                    let offset = (1 - progress) * this.w();
                    painter.image_crop(atlas, (this.x() + offset),
                        this.y(), this.w() * progress,
                        this.h(), this.u() + offset,
                        this.v() + constants.texture_space + this.h(), this.w() * progress, this.h());
                } else if (this.data.direction === 4) {
                    // fill to the right
                    painter.image_crop(atlas, this.x(),
                        this.y(), this.w() * progress,
                        this.h(), this.u(), this.v() + constants.texture_space + this.h(),
                        this.w() * progress, this.h());
                }
            }
        } else {
            super.draw(painter);
        }
    }

    read_data_from_gui() {
        super.read_data_from_gui();
        this.data.direction = parseInt($("#editor-element-trigger-direction-side").val());
        this.data.trigger_mode = $("#editor-element-trigger-button")[0].checked;
        this.data.side = parseInt($("#editor-element-analog-stick-side").val());
    }

    write_data_to_gui() {
        super.write_data_to_gui();
        $("#editor-element-trigger-direction-side").val(this.data.direction);
        $("#editor-element-trigger-button")[0].checked = this.data.trigger_mode ? true : false;
        $("#editor-element-analog-stick-side").val(this.data.side);
    }
}

class dpad extends texture {
    constructor(json) {
        super(json);
        this.offset = 0;
    }
    on_gamepad_input(pad) {
        let up = pad.buttons[12].pressed;
        let down = pad.buttons[13].pressed;
        let left = pad.buttons[14].pressed;
        let right = pad.buttons[15].pressed;

        if (left) {
            if (up)
                this.offset = 5;
            else if (down)
                this.offset = 7;
            else
                this.offset = 1;
        } else if (right) {
            if (up)
                this.offset = 6;
            else if (down)
                this.offset = 8;
            else
                this.offset = 2;
        } else if (up) {
            if (left)
                this.offset = 5;
            else if (right)
                this.offset = 6;
            else
                this.offset = 3;
        } else if (down) {
            if (left)
                this.offset = 7;
            else if (right)
                this.offset = 8;
            else
                this.offset = 4;
        } else {
            this.offset = 0;
        }
    }

    draw(painter) {

        painter.image_crop(atlas, this.x(),
            this.y(), this.w(), this.h(),
            this.u() + (constants.texture_space + this.w()) * this.offset, this.v(), this.w(), this.h());
    }
}
class mouse_movement extends texture {
    // TODO: Actually visualize this in the editor
    read_data_from_gui() {
        super.read_data_from_gui();
        this.data.mouse_type = parseInt($("#editor-element-movement-type").val());
    }

    write_data_to_gui() {
        super.write_data_to_gui();
        $("#editor-element-movement-type").val(this.data.mouse_type);
    }
}
element_map.set(element_types.KEYBOARD_KEY, (json) => { return new keyboard_button(json); });
element_map.set(element_types.MOUSE_BUTTON, (json) => { return new mouse_button(json); });
element_map.set(element_types.TEXTURE, (json) => { return new texture(json); });
element_map.set(element_types.GAMEPAD_BUTTON, (json) => { return new gamepad_button(json); });
element_map.set(element_types.WHEEL, (json) => { return new mouse_wheel(json); });
element_map.set(element_types.ANALOG_STICK, (json) => { return new analog_stick(json); });
element_map.set(element_types.TRIGGER, (json) => { return new trigger(json); });
element_map.set(element_types.GAMEPAD_ID, (json) => { return new gamepad_id(json); });
element_map.set(element_types.DPAD_STICK, (json) => { return new dpad(json); });
element_map.set(element_types.MOUSE_MOVEMENT, (json) => { return new mouse_movement(json); });

function create_element(json) {
    if (element_map.has(json.type))
        return element_map.get(json.type)(json);
    return null;
}

```

`projects/plugin/data/overlay_render/js/gamepad.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

class gamepad {
    constructor(interval = 25)
    {
        this.lastTimestamp = new Map();
        this.lastState = new Map();
        this.lastInput = null;
        this.connect = [];
        this.disconnect = [];
        this.button = [];       // (gamepad, button index, button)
        this.axis = [];         // (gamepad, axis index, new axis value)
        this.event = [];        // (gamepad)
        this.threshold = 0.001; // If the value delta is higher than this we consider the value changed
        window.addEventListener('gamepadconnected', (event) => this.onConnect(event));
        window.addEventListener('gamepaddisconnected', (event) => this.onConnect(event));
        this.handle = setInterval(() => this.tick(), interval);
    }

    tick()
    {
        let pads = navigator.getGamepads();
        for (let i = 0; i < pads.length; pads++) {
            let pad = pads[i];
            if (!pad)
                continue;
            let lastTimeStamp = 0;
            let lastState = null;

            if (this.lastTimestamp.has(pad.index))
                lastTimeStamp = this.lastTimestamp.get(pad.index);
            if (this.lastState.has(pad.index))
                lastState = this.lastState.get(pad.index);

            if (pad && pad.timestamp > lastTimeStamp) {
                this.lastTimestamp.set(pad.index, pad.timestamp);
                if (lastState) {
                    for (let j = 0; j < pad.axes.length; j++) {
                        if (Math.abs(lastState.axes[j] - pad.axes[j]) > this.threshold)
                            this.onAxis(pad, j);
                    }

                    for (let j = 0; j < pad.buttons.length; j++) {
                        if (Math.abs(lastState.buttons[j].value - pad.buttons[j].value) > this.threshold)
                            this.onButton(pad, j);
                    }
                } else {
                    for (let j = 0; j < pad.axes.length; j++)
                        this.onAxis(pad, j);
                    for (let j = 0; j < pad.buttons.length; j++)
                        this.onButton(pad, j);
                }
                this.lastState.set(pad.index, pad);
            }
        }
    }

    onAxis(pad, index)
    {
        this.axis.forEach(h => h(pad, index, pad.axes[index]));
        this.event.forEach(h => h(pad));
        this.lastInput = pad;
    }

    onButton(pad, index)
    {
        this.button.forEach(h => h(pad, index, pad.buttons[index]));
        this.event.forEach(h => h(pad));
        this.lastInput = pad;
    }

    on(id, handler)
    {
        switch (id.toLowerCase()) {
        case 'connect':
            this.connect.push(handler);
            break;
        case 'disconnect':
            this.disconnect.push(handler);
            break;
        case 'button':
            this.button.push(handler);
            break;
        case 'move':
            this.axis.push(handler);
            break;
        case 'input':
            this.event.push(handler);
            break;
        };
    }

    onConnect(event) { this.connect.forEach(h => h(event)); }

    onDisconnect(event) { this.disconnect.forEach(h => h(event)); }
};
```

`projects/plugin/data/overlay_render/js/jquery-3.5.1.min.js`:

```js
/*! jQuery v3.5.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.5.1",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),"function"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S="sizzle"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",F=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",B=new RegExp(M+"+","g"),$=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp(F),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+xe(l[o]);c=l.join(",")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return g(t.replace($,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement("div")),"undefined"!=typeof e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML="<a id='"+S+"'></a><select id='"+S+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+S+"-]").length||v.push("~="),(t=C.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||v.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+S+"+*").length||v.push(".#.+[+~]"),e.querySelectorAll("\\\f"),v.push("[\\r\\n\\f]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",F)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&m(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(B," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,"$1"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace($,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split("").sort(D).join("")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[":"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function D(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):"string"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(D(this,e||[],!1))},not:function(e){return this.pushStack(D(this,e||[],!0))},is:function(e){return!!D(this,"string"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var j,q=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||j,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,j=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,"parentNode")},parentsUntil:function(e,t,n){return h(e,"parentNode",n)},next:function(e){return O(e,"nextSibling")},prev:function(e){return O(e,"previousSibling")},nextAll:function(e){return h(e,"nextSibling")},prevAll:function(e){return h(e,"previousSibling")},nextUntil:function(e,t,n){return h(e,"nextSibling",n)},prevUntil:function(e,t,n){return h(e,"previousSibling",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,"template")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\x20\t\r\n\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[["notify","progress",S.Callbacks("memory"),S.Callbacks("memory"),2],["resolve","done",S.Callbacks("once memory"),S.Callbacks("once memory"),0,"resolved"],["reject","fail",S.Callbacks("once memory"),S.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),S.ready()}S.fn.ready=function(e){return F.then(e)["catch"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,"ms-").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(K,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks("once memory").add(function(){Y.remove(e,[t+"queue",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Y.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,te=new RegExp("^(?:([+-])=|)("+ee+")([a-z%]*)$","i"),ne=["Top","Right","Bottom","Left"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&ie(e)&&"none"===S.css(e,"display")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,"")},u=s(),l=n&&n[3]||(S.cssNumber[t]?"":"px"),c=e.nodeType&&(S.cssNumber[t]||"px"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Y.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ue[s]=u)))):"none"!==n&&(l[c]="none",Y.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement("div")),(fe=E.createElement("input")).setAttribute("type","radio"),fe.setAttribute("checked","checked"),fe.setAttribute("name","t"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML="<option></option>",y.option=!!ce.lastChild;var ge={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],"globalEval",!t||Y.get(t[n],"globalEval"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,"<select multiple='multiple'>","</select>"]);var me=/<|&#?\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}var be=/^key/,we=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Te=/^([^.]*)(?:\.(.+)|)/;function Ce(){return!0}function Ee(){return!1}function Se(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function ke(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)ke(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Ee;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Ae(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,Ce)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(P)||[""]).length;while(l--)d=g=(s=Te.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(P)||[""]).length;while(l--)if(d=g=(s=Te.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,"events")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click",Ce),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Y.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ce:Ee,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Ee,isPropagationStopped:Ee,isImmediatePropagationStopped:Ee,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ce,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ce,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ce,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&be.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&we.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},S.event.addProp),S.each({focus:"focusin",blur:"focusout"},function(e,t){S.event.special[e]={setup:function(){return Ae(this,e,Se),!1},trigger:function(){return Ae(this,e),!0},delegateType:t}}),S.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return ke(this,e,t,n,r)},one:function(e,t,n,r){return ke(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Ee),this.each(function(){S.event.remove(this,e,n,t)})}});var Ne=/<script|<style|<link/i,De=/checked\s*(?:[^=]|=\s*.checked.)/i,je=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function qe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&S(e).children("tbody")[0]||e}function Le(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function He(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Oe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function Pe(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&De.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Pe(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,"script"),Le)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,He),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Y.access(u,"globalEval")&&S.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):b(u.textContent.replace(je,""),u,l))}return n}function Re(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Oe(o[r],a[r]);else Oe(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Re(this,e,!0)},remove:function(e){return Re(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Pe(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||qe(this,e).appendChild(e)})},prepend:function(){return Pe(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=qe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Ne.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Pe(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Me=new RegExp("^("+ee+")(?!px)[a-z%]+$","i"),Ie=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},We=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Fe=new RegExp(ne.join("|"),"i");function Be(e,t,n){var r,i,o,a,s=e.style;return(n=n||Ie(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Me.test(a)&&Fe.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function $e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement("div"),l=E.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement("table"),t=E.createElement("tr"),n=E.createElement("div"),e.style.cssText="position:absolute;left:-11111px",t.style.height="1px",n.style.height="9px",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=3<parseInt(r.height),re.removeChild(e)),a}}))}();var _e=["Webkit","Moz","ms"],ze=E.createElement("div").style,Ue={};function Xe(e){var t=S.cssProps[e]||Ue[e];return t||(e in ze?e:Ue[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=_e.length;while(n--)if((e=_e[n]+t)in ze)return e}(e)||e)}var Ve=/^(none|table(?!-c[ea]).+)/,Ge=/^--/,Ye={position:"absolute",visibility:"hidden",display:"block"},Qe={letterSpacing:"0",fontWeight:"400"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Ke(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?("content"===n&&(u-=S.css(e,"padding"+ne[a],!0,i)),"margin"!==n&&(u-=S.css(e,"border"+ne[a]+"Width",!0,i))):(u+=S.css(e,"padding"+ne[a],!0,i),"padding"!==n?u+=S.css(e,"border"+ne[a]+"Width",!0,i):s+=S.css(e,"border"+ne[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Ie(e),i=(!y.boxSizingReliable()||n)&&"border-box"===S.css(e,"boxSizing",!1,r),o=i,a=Be(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(Me.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===S.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===S.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?"border":"content"),o,r,a)+"px"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Ge.test(t),l=e.style;if(u||(t=Xe(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Ge.test(t)||(t=Xe(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),"normal"===i&&t in Qe&&(i=Qe[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each(["height","width"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ve.test(S.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):We(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Ie(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===S.css(e,"boxSizing",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,"border",!1,i)-.5)),s&&(r=te.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=$e(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,"marginLeft"))||e.getBoundingClientRect().left-We(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),S.each({margin:"",padding:"",border:"Width"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Ie(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?"":"px")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Xe(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=/^(?:toggle|show|hide)$/,at=/queueHooks$/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=ne[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,"fxshow");for(r in n.queue||(null==(a=S._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,"display")),"none"===(c=S.css(e,"display"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,"display"),le([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===S.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Y.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,"fxshow"),d)S.style(e,r,d[r])})),u=ct(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&"object"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Y.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each(["toggle","show","hide"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt("show"),slideUp:lt("hide"),slideToggle:lt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement("input"),it=E.createElement("select").appendChild(E.createElement("option")),rt.type="checkbox",y.checkOn=""!==rt.value,y.optSelected=it.selected,(rt=E.createElement("input")).value="t",rt.type="radio",y.radioValue="t"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\w+/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=/^(?:input|select|textarea|button)$/i,gt=/^(?:a|area)$/i;function vt(e){return(e.match(P)||[]).join(" ")}function yt(e){return e.getAttribute&&e.getAttribute("class")||""}function mt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,"tabindex");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,yt(this)))});if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,yt(this)))});if(!arguments.length)return this.attr("class","");if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,yt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=mt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=yt(this))&&Y.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Y.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+vt(yt(n))+" ").indexOf(t))return!0;return!1}});var xt=/\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?"":e+""})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(xt,""):null==e?"":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,"value");return null!=t?t:vt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each(["radio","checkbox"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var bt=/^(?:focusinfocus|focusoutblur)$/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[S.expando]?e:new S.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,"events")||Object.create(null))[e.type]&&Y.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=/\?/;S.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||S.error("Invalid XML: "+e),t};var St=/\[\]$/,kt=/\r?\n/g,At=/^(?:submit|button|image|reset|file)$/i,Nt=/^(?:input|select|textarea|keygen)/i;function Dt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):Dt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)Dt(n+"["+t+"]",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)Dt(n,e[n],t,i);return r.join("&")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,"elements");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(":disabled")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,"\r\n")}}):{name:t.name,value:n.replace(kt,"\r\n")}}).get()}});var jt=/%20/g,qt=/#.*$/,Lt=/([?&])_=[^&]*/,Ht=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ot=/^(?:GET|HEAD)$/,Pt=/^\/\//,Rt={},Mt={},It="*/".concat("*"),Wt=E.createElement("a");function Ft(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Bt(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function $t(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":It,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?$t($t(e,S.ajaxSettings),t):$t(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Tt.href)+"").replace(Pt,Tt.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(P)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Wt.protocol+"//"+Wt.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Bt(Rt,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Ot.test(v.type),f=v.url.replace(qt,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(jt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(Et.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Lt,"$1"),o=(Et.test(f)?"&":"?")+"_="+Ct.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader("If-Modified-Since",S.lastModified[f]),S.etag[f]&&T.setRequestHeader("If-None-Match",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+It+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Bt(Mt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray("script",v.dataTypes)&&(v.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(S.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(S.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--S.active||S.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,"json")},getScript:function(e,t){return S.get(e,void 0,t,"script")}}),S.each(["get","post"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();y.cors=!!zt&&"withCredentials"in zt,y.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(y.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),S.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=/(=)\?(?=&|$)|\?\?/;S.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Xt.pop()||S.expando+"_"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Vt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,"$1"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||S.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Ut=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=vt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&S.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?S("<div>").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,"position"),c=S(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=S.css(e,"top"),u=S.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):("number"==typeof f.top&&(f.top+="px"),"number"==typeof f.left&&(f.left+="px"),c.css(f))}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===S.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===S.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,"borderTopWidth",!0),i.left+=S.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-S.css(r,"marginTop",!0),left:t.left-i.left-S.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===S.css(e,"position"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each(["top","left"],function(e,n){S.cssHooks[n]=$e(y.pixelPosition,function(e,t){if(t)return t=Be(e,n),Me.test(t)?S(e).position()[n]+"px":t})}),S.each({Height:"height",Width:"width"},function(a,s){S.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?"":(e+"").replace(Gt,"")},"function"==typeof define&&define.amd&&define("jquery",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},"undefined"==typeof e&&(C.jQuery=C.$=S),S});

```

`projects/plugin/data/overlay_render/js/main.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

var cfg_name = "overlay.json";
var atlas = null;
var cfg = null;
var main_painter = null;
var pad = null;

$(function() {
    main_painter = new painter("canvas", (p, c) => cfg.draw(p, c));
    pad = new gamepad();
    cfg = new config("#canvas", main_painter);
    main_painter.load_image("./texture.png").then(function(img) { atlas = img; });
    cfg.load_from_json(JSON.parse(preset));

    main_painter.get_context().imageSmoothingEnabled = false;
    setTimeout(() => {
        main_painter.resize_canvas(); // Run once to get correct window size
    }, 100);
});

```

`projects/plugin/data/overlay_render/js/vc.js`:

```js
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

var key2vc = new Map();
var mouse2vc = new Map();
var gamepad2vc = new Map();
var vc2gamepad = new Map();

$(function() {
    let vc = (id, vc) => key2vc.set(id, vc);
    let gp = (id, vc) => {
        gamepad2vc.set(id, vc);
        vc2gamepad.set(vc, id);
    };

    // some keys are postfixed with their DOM3 location
    // No postfix = location 0
    // 1 = Left, 2 = Right, 3 = Numpad
    vc("KeyA", 0x001E);
    vc("KeyB", 0x0030);
    vc("KeyC", 0x002E);
    vc("KeyD", 0x0020);
    vc("KeyE", 0x0012);
    vc("KeyF", 0x0021);
    vc("KeyG", 0x0022);
    vc("KeyH", 0x0023);
    vc("KeyI", 0x0017);
    vc("KeyJ", 0x0024);
    vc("KeyK", 0x0025);
    vc("KeyL", 0x0026);
    vc("KeyM", 0x0032);
    vc("KeyN", 0x0031);
    vc("KeyO", 0x0018);
    vc("KeyP", 0x0019);
    vc("KeyQ", 0x0010);
    vc("KeyR", 0x0013);
    vc("KeyS", 0x001F);
    vc("KeyT", 0x0014);
    vc("KeyU", 0x0016);
    vc("KeyV", 0x002F);
    vc("KeyW", 0x0011);
    vc("KeyX", 0x002D);
    vc("KeyY", 0x0015);
    vc("KeyZ", 0x002C);
    vc("Digit1", 0x0002);
    vc("Digit2", 0x0003);
    vc("Digit3", 0x0004);
    vc("Digit4", 0x0005);
    vc("Digit5", 0x0006);
    vc("Digit6", 0x0007);
    vc("Digit7", 0x0008);
    vc("Digit8", 0x0009);
    vc("Digit9", 0x000A);
    vc("Digit0", 0x000B);
    vc("F1", 0x003B);
    vc("F2", 0x003C);
    vc("F3", 0x003D);
    vc("F4", 0x003E);
    vc("F5", 0x003F);
    vc("F6", 0x0040);
    vc("F7", 0x0041);
    vc("F8", 0x0042);
    vc("F9", 0x0043);
    vc("F10", 0x0044);
    vc("F11", 0x0057);
    vc("F12", 0x0058);
    vc("F13", 0x005B);
    vc("F14", 0x005C);
    vc("F15", 0x005D);
    vc("F16", 0x0063);
    vc("F17", 0x0064);
    vc("F18", 0x0065);
    vc("F19", 0x0066);
    vc("F20", 0x0067);
    vc("F21", 0x0068);
    vc("F22", 0x0069);
    vc("F23", 0x006A);
    vc("F24", 0x006B);
    vc("Escape", 0x0001);
    vc("Minus", 0x000C);
    vc("Equal", 0x000D);
    vc("Backspace", 0x000E);
    vc("Tab", 0x000F);
    vc("CapsLock", 0x003A);
    vc("BracketRight", 0x001A);
    vc("BracketLeft", 0x001B);
    vc("Backslash", 0x002B);
    vc("Semicolon", 0x0027);
    vc("Quote", 0x0028);
    vc("Enter", 0x001C);
    vc("Comma", 0x0033);
    vc("Period", 0x0034);
    vc("Slash", 0x0035);
    vc("Space", 0x0039);
    vc("PrintScreen", 0x0E37);
    vc("ScrolLock", 0x0046);
    vc("Pause", 0x0E45);
    vc("IntlBackslash", 0x0E46);
    vc("Insert", 0x0E52);
    vc("Delete", 0x0E53);
    vc("Home", 0x0E47);
    vc("End", 0x0E4F);
    vc("PageUp", 0x0E49);
    vc("PageDown", 0x0E51);
    vc("ArrowUp", 0xE048);
    vc("ArrowLeft", 0xE04B);
    vc("Clear", 0xE04C);
    vc("ArrowRight", 0xE04D);
    vc("ArrowDown", 0xE050);

    vc("NumpadEquals", 0x0E0D);
    vc("NumLock", 0x0045);
    vc("NumpadSubtract", 0x0E35);
    vc("NumpadMultiply", 0x0037);
    vc("NumpadSubtract", 0x004A);
    vc("NumpadAdd", 0x004E);
    vc("NumpadEnter", 0x0E1C);
    vc("NumpadDecimal", 0x0053);

    vc("Numpad1", 0x004F);
    vc("Numpad2", 0x0050);
    vc("Numpad3", 0x0051);
    vc("Numpad4", 0x004B);
    vc("Numpad5", 0x004C);
    vc("Numpad6", 0x004D);
    vc("Numpad7", 0x0047);
    vc("Numpad8", 0x0048);
    vc("Numpad9", 0x0049);
    vc("Numpad0", 0x0052);

    vc("NumpadEnd", 0xEE4F);
    vc("NumpadArrowDown", 0xEE50);
    vc("NumpadPageDown", 0xEE51);
    vc("NumpadArrowLeft", 0xEE4B);
    vc("NumpadClear", 0xEE4C);
    vc("NumpadArrowRight", 0xEE4D);
    vc("NumpadHome", 0xEE47);
    vc("NumpadArrowUp", 0xEE48);
    vc("NumpadPageUp", 0xEE49);
    vc("NumpadInsert", 0xEE52);
    vc("NumpadDelete", 0xEE53);

    vc("ShiftLeft", 0x002A);
    vc("ShiftRight", 0x0036);
    vc("ControlLeft", 0x001D);
    vc("ControlRight", 0x0E1D);
    vc("AltLeft", 0x0038);
    vc("AltRight", 0x0E38);
    vc("MetaLeft", 0x0E5B);
    vc("MetaRight", 0x0E5C);
    vc("ContextMenu", 0x0E5D);

    mouse2vc.set(0, 1);
    mouse2vc.set(1, 3);
    mouse2vc.set(2, 2);
    mouse2vc.set(3, 4);
    mouse2vc.set(4, 5);

    gp(0, 0xEC00);
    gp(1, 0xEC01);
    gp(2, 0xEC02);
    gp(3, 0xEC03);
    gp(4, 0xEC04);
    gp(5, 0xEC05);
    gp(8, 0xEC06);
    gp(9, 0xEC07);
    gp(10, 0xEC09);
    gp(11, 0xEC10);
    gp(12, 0xEC13);
    gp(13, 0xEC14);
    gp(14, 0xEC11);
    gp(15, 0xEC12);
    gp(16, 0xEC08);
});

function gamepad_to_vc(button)
{
    if (gamepad2vc.has(button))
        return gamepad2vc.get(button);
    return 0;
}

function gamepad_from_vc(vc)
{
    if (vc2gamepad.has(vc))
        return vc2gamepad.get(vc);
    return 0;
}

function mouse_to_vc(e)
{
    let button = e.button;

    if (mouse2vc.has(button))
        return mouse2vc.get(button);
    return 0;
}

function key_to_vc(e)
{
    let key = e.code;

    if (key.indexOf("Numpad") >= 0 && /^[0-9]$/g.test(key.slice(-1))) {
        // Numpad has special handling
        // all keys Numpad1 through Numpad9 should use the key
        // so that we can tell numpad buttons with numlock on apart from
        // numpad buttons with numpad off
        key = key.slice(0, -1) + e.key;
    }

    if (key === "NumpadDecimal" && e.keyCode === 46)
        key = "NumpadDelete";

    if (key2vc.has(key))
        return key2vc.get(key);
    return 0;
}
```

`projects/plugin/data/overlay_render/renderer.html`:

```html
<!DOCTYPE html>
<html>
<!-- 
        This HTML can render presets in a browser source
        The recommended way is to use the input-overlay source,
        but if you require additional felxibility (eg. gamepads work better
        in the browser source) you can use this.
    -->

<head>
    <script>
        /* 
            PUT YOUR PRESET JSON INSIDE THE "``" Quotes
        */
        var preset =
            `
            {"default_height":0,"default_width":0,"elements":[{"id":"body","mapping":[1,1,1280,926],"pos":[0,0],"type":0,"z_level":0},{"code":60416,"id":"a","mapping":[838,930,94,94],"pos":[953,311],"type":2,"z_level":1},{"code":60417,"id":"b","mapping":[741,930,94,94],"pos":[1051,213],"type":2,"z_level":1},{"code":60419,"id":"y","mapping":[644,930,94,94],"pos":[953,116],"type":2,"z_level":1},{"code":60418,"id":"x","mapping":[547,930,94,94],"pos":[856,214],"type":2,"z_level":1},{"code":60422,"id":"select","mapping":[389,930,76,63],"pos":[466,185],"type":2,"z_level":1},{"code":60423,"id":"start","mapping":[468,930,76,63],"pos":[737,185],"type":2,"z_level":1},{"code":60420,"id":"ls","mapping":[1,930,148,70],"pos":[170,14],"type":2,"z_level":1},{"code":60421,"id":"rs","mapping":[152,930,148,70],"pos":[962,13],"type":2,"z_level":1},{"code":60435,"id":"dpad_up","mapping":[717,1134,43,42],"pos":[430,376],"type":2,"z_level":1},{"code":60436,"id":"dpad_down","mapping":[717,1134,42,42],"pos":[430,515],"type":2,"z_level":1},{"code":60433,"id":"dpad_left","mapping":[717,1134,42,42],"pos":[360,445],"type":2,"z_level":1},{"code":60434,"id":"dpad_right","mapping":[717,1134,42,42],"pos":[498,444],"type":2,"z_level":1},{"direction":1,"id":"lt","mapping":[303,930,40,44],"pos":[224,0],"side":0,"trigger_mode":false,"type":6,"z_level":1},{"direction":1,"id":"rt","mapping":[346,930,40,44],"pos":[1016,0],"side":1,"trigger_mode":false,"type":6,"z_level":1},{"id":"left_analog_stick","mapping":[938,930,128,128],"pos":[210,164],"side":0,"stick_radius":40,"type":5,"z_level":1},{"id":"right_analog_stick","mapping":[938,930,128,128],"pos":[763,396],"side":1,"stick_radius":40,"type":5,"z_level":1},{"id":"guide","mapping":[1,1134,140,141],"pos":[570,163],"type":7,"z_level":1}],"flags":6,"overlay_height":926,"overlay_width":1280,"space_h":0,"space_v":0}
            `;
    </script>
    <meta charset="utf-8" />
    <title>input-overlay layout renderer</title>
    <style>
        #canvas-container {
            /* IE, only works on <img> tags */
            -ms-interpolation-mode: nearest-neighbor;
            /* Firefox */
            image-rendering: crisp-edges;
            /* Chromium + Safari */
            image-rendering: pixelated;
        }

        .canvas-container {
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        body,
        html {
            height: 100%;
        }
    </style>
    <script src="./js/jquery-3.5.1.min.js"></script>
    <script src="./js/gamepad.js"></script>
    <script src="./js/vc.js"></script>
    <script src="./js/elements.js"></script>
    <script src="./js/config.js"></script>
    <script src="./js/draw.js"></script>
    <script src="./js/main.js"></script>
</head>

<body style="margin: 0px; overflow: hidden;">
    <div class="canvas-container" id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
</body>
<script>
    var l = document.getElementById("log");
    var require_clear = false;
    var count = 0;

    function on_data(e) {
        console.log(e.data);
    }

    function start_websocket() {
        var ws = new WebSocket("ws://localhost:16899/");

        ws.onmessage = on_data;
        ws.onmessage = on_data;
        ws.onerror = (e) => console.log('WebSocket error: ' + e);

        ws.onclose = () => {
            // connection closed, discard old websocket and create a new one in 5s
            ws = null;
            setTimeout(start_websocket, 2000);
        };
    }

        //start_websocket();
</script>

</html>
```

`projects/plugin/src/gui/io_settings_dialog.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "io_settings_dialog.hpp"
#include "../network/io_server.hpp"
#include "../network/remote_connection.hpp"
#include "ui_io_settings_dialog.h"
#include "../util/config.hpp"
#include "../util/lang.h"
#include "../util/obs_util.hpp"
#include "../hook/gamepad_hook_helper.hpp"
#include <libgamepad.hpp>
#include <QDesktopServices>
#include <QTimer>
#include <QPair>
#include <obs-module.h>
#include <string>
#include <QMessageBox>

static QPair<const char *, uint16_t> button_map[] = {{"txt_a", gamepad::button::A},
                                                     {"txt_b", gamepad::button::B},
                                                     {"txt_x", gamepad::button::X},
                                                     {"txt_y", gamepad::button::Y},
                                                     {"txt_rb", gamepad::button::RB},
                                                     {"txt_lb", gamepad::button::LB},
                                                     {"txt_guide", gamepad::button::GUIDE},
                                                     {"txt_analog_left", gamepad::button::L_THUMB},
                                                     {"txt_analog_right", gamepad::button::R_THUMB},
                                                     {"txt_back", gamepad::button::BACK},
                                                     {"txt_start", gamepad::button::START},
                                                     {"txt_dpad_up", gamepad::button::DPAD_UP},
                                                     {"txt_dpad_down", gamepad::button::DPAD_DOWN},
                                                     {"txt_dpad_left", gamepad::button::DPAD_LEFT},
                                                     {"txt_dpad_right", gamepad::button::DPAD_RIGHT}};
static QPair<const char *, uint16_t> axis_map[] = {
    {"txt_lx", gamepad::axis::LEFT_STICK_X},  {"txt_ly", gamepad::axis::LEFT_STICK_Y},
    {"txt_rx", gamepad::axis::RIGHT_STICK_X}, {"txt_ry", gamepad::axis::RIGHT_STICK_Y},
    {"txt_lt", gamepad::axis::LEFT_TRIGGER},  {"txt_rt", gamepad::axis::RIGHT_TRIGGER}};

io_settings_dialog *settings_dialog = nullptr;

io_settings_dialog::io_settings_dialog(QWidget *parent) : QDialog(parent, Qt::Dialog), ui(new Ui::io_config_dialog)
{
    ui->setupUi(this);

    /* Connect QSlots */
    connect(ui->btn_github, &QPushButton::clicked, this, &io_settings_dialog::OpenGitHub);
    connect(ui->btn_forums, &QPushButton::clicked, this, &io_settings_dialog::OpenForums);
    connect(ui->button_box, &QDialogButtonBox::accepted, this, &io_settings_dialog::FormAccepted);
    connect(ui->cb_enable_remote, &QCheckBox::stateChanged, this, &io_settings_dialog::CbRemoteStateChanged);
    connect(ui->btn_refresh, &QPushButton::clicked, this, &io_settings_dialog::PingClients);
    connect(ui->cb_enable_control, &QCheckBox::stateChanged, this, &io_settings_dialog::CbInputControlStateChanged);
    connect(ui->btn_refresh_cb, &QPushButton::clicked, this, &io_settings_dialog::RefreshWindowList);
    connect(ui->btn_add, &QPushButton::clicked, this, &io_settings_dialog::AddFilter);
    connect(ui->btn_remove, &QPushButton::clicked, this, &io_settings_dialog::RemoveFilter);
    connect(ui->cb_gamepad_hook, &QCheckBox::stateChanged, this, &io_settings_dialog::CbEnableGamepadChanged);
    connect(ui->cb_enable_wss, &QCheckBox::stateChanged, this, &io_settings_dialog::CbWssStateChanged);

    /* Load values */
    ui->cb_iohook->setChecked(io_config::enable_uiohook);
    ui->cb_gamepad_hook->setChecked(io_config::enable_gamepad_hook);
    ui->cb_enable_overlay->setChecked(io_config::enable_overlay_source);
    ui->cb_enable_control->setChecked(io_config::enable_input_control);
    ui->cb_enable_remote->setChecked(io_config::enable_remote_connections);
    ui->cb_enable_wss->setChecked(io_config::enable_websocket_server);
    ui->cb_log->setChecked(io_config::log_flag);
    ui->box_port->setValue(io_config::server_port);

    load_bindings();

    /* Tooltips aren't translated by obs */
    ui->box_refresh_rate->setToolTip(T_REFRESH_RATE_TOOLTIP);
    ui->lbl_refresh_rate->setToolTip(T_REFRESH_RATE_TOOLTIP);

    CbRemoteStateChanged(io_config::enable_remote_connections);
    CbInputControlStateChanged(io_config::enable_input_control);

    /* Sets up remote connection status label */
    auto text = ui->lbl_status->text().toStdString();
    auto pos = text.find("%s");
    if (pos != std::string::npos)
        text.replace(pos, strlen("%s"), network::get_status());
    pos = text.find("%s");
    if (pos != std::string::npos)
        text.replace(pos, strlen("%s"), network::local_ip);
    ui->lbl_status->setText(text.c_str());

    /* Check for new connections every 250ms */
    m_refresh = new QTimer(this);
    connect(m_refresh, SIGNAL(timeout()), SLOT(RefreshUi()));
    m_refresh->start(250);

    /* Add current open windows to filter list */
    if (io_config::enable_input_control)
        RefreshWindowList();

    for (const auto &filter : io_config::io_window_filters.filters()) {
        ui->list_filters->addItem(filter);
    }

    /* Set red color on label so people don't miss it */
    ui->lbl_local_features->setStyleSheet("QLabel { color: red; "
                                          "font-weight: bold;}");

    ui->rb_js->setEnabled(io_config::enable_gamepad_hook);
    ui->rb_by_id->setEnabled(io_config::enable_gamepad_hook);
    ui->rb_xinput->setEnabled(io_config::enable_gamepad_hook);
    ui->rb_dinput->setEnabled(io_config::enable_gamepad_hook);

#ifdef _WIN32
    ui->rb_dinput->setChecked(io_config::use_dinput);
    ui->rb_xinput->setChecked(!ui->rb_dinput->isChecked());
#endif

    // If we set these on all platforms they'll deselect the other radio buttons
#ifdef __linux__
    ui->rb_js->setChecked(io_config::use_js);
    ui->rb_by_id->setChecked(!ui->rb_js->isChecked());
#endif

#ifndef _WIN32
    ui->rb_dinput->setVisible(false);
    ui->rb_xinput->setVisible(false);
#endif
#ifndef __linux__
    ui->rb_js->setVisible(false);
    ui->rb_by_id->setVisible(false);
#endif

    // Load first binding to ui
    if (libgamepad::hook_instance) {
        libgamepad::hook_instance->get_mutex()->lock();
        if (!libgamepad::hook_instance->get_bindings().empty())
            load_binding_to_ui(libgamepad::hook_instance->get_bindings()[0]);
        libgamepad::hook_instance->get_mutex()->unlock();
    }
}

void io_settings_dialog::showEvent(QShowEvent *event)
{
    Q_UNUSED(event)
    RefreshUi();
}

void io_settings_dialog::toggleShowHide()
{
    setVisible(!isVisible());
    load_bindings();
}

void io_settings_dialog::RefreshUi()
{
    /* Populate client list */
    if (network::network_flag && network::server_instance) {
        std::lock_guard<std::mutex> lock(network::mutex);
        if (network::server_instance->clients_changed()) {
            ui->box_connections->clear();
            QStringList list;
            std::vector<const char *> names;
            /* I'd do it differently, but including Qt headers and obs headers
         * creates conflicts with LOG_WARNING...
         */
            network::server_instance->get_clients(names);

            for (auto &name : names)
                list.append(name);
            ui->box_connections->addItems(list);
        }
    }

    if (libgamepad::state) {
        gamepad::device_list devs;
        {
            auto &mutex = *libgamepad::hook_instance->get_mutex();
            std::lock_guard<std::mutex> lock(mutex);
            devs = libgamepad::hook_instance->get_devices();
        }

        /* Fill device list */
        if (int(devs.size()) != ui->cb_device->count()) {
            auto selected = ui->cb_device->currentIndex();
            ui->cb_device->clear();
            for (const auto &dev : devs) {
                ui->cb_device->addItem(utf8_to_qt(dev->get_name().c_str()),
                                       QVariant::fromValue(utf8_to_qt(dev->get_id().c_str())));
            }
            ui->cb_device->setCurrentIndex(selected);
        }

        // Select something if nothing is selected
        if (ui->cb_device->currentText().isEmpty() && !devs.empty()) {
            ui->cb_device->setCurrentIndex(0);
        }

        libgamepad::last_input_mutex.lock();
        if (m_last_gamepad_input < libgamepad::last_input_time) {
            m_last_gamepad_input = libgamepad::last_input_time;
            auto mylineEdits = ui->scrollArea->findChildren<QWidget *>();
            QListIterator<QWidget *> it(mylineEdits);
            QWidget *lineEditField;
            while (it.hasNext()) {
                lineEditField = it.next();
                if (auto lineE = qobject_cast<QLineEdit *>(lineEditField)) {
                    if (lineE->hasFocus()) {
                        // LT and RT are the same axis in DInput, so we save the polarity here
                        if (libgamepad::flags & gamepad::hook_type::DIRECT_INPUT &&
                            (lineE->objectName() == "txt_lt" || lineE->objectName() == "txt_rt")) {
                            /* Set the binding of this textbox */
                            if (libgamepad::last_input_value != 0) { // 0 is both left and right trigger
                                lineE->setText((libgamepad::last_input_value < 0 ? "-" : "+") +
                                               QString::number(libgamepad::last_input));
                            }
                        } else {
                            /* Set the binding of this textbox */
                            lineE->setText(QString::number(libgamepad::last_input));
                        }

                        break;
                    }
                }
            }
        }
        libgamepad::last_input_mutex.unlock();
    }
}

void io_settings_dialog::CbRemoteStateChanged(int state)
{
    ui->cb_log->setEnabled(state);
    ui->box_port->setEnabled(state);
    ui->box_connections->setEnabled(state);
    ui->btn_refresh->setEnabled(state);
    ui->box_refresh_rate->setEnabled(state);
    ui->cb_regex->setEnabled(state);
}

void io_settings_dialog::CbInputControlStateChanged(int state)
{
    ui->cb_list_mode->setEnabled(state);
    ui->cb_text->setEnabled(state);
    ui->btn_add->setEnabled(state);
    ui->btn_remove->setEnabled(state);
    ui->list_filters->setEnabled(state);
    ui->btn_refresh_cb->setEnabled(state);
    ui->cb_regex->setEnabled(state);
}

void io_settings_dialog::PingClients()
{
    if (network::server_instance)
        network::server_instance->ping_clients();
}

void io_settings_dialog::RefreshWindowList()
{
    std::vector<std::string> windows;
    GetWindowList(windows);
    ui->cb_text->clear();

    for (const auto &window : windows)
        ui->cb_text->addItem(window.c_str());
}

void io_settings_dialog::AddFilter()
{
    for (int i = 0; i < ui->list_filters->count(); i++)
        if (ui->list_filters->itemAt(0, i)->text() == ui->cb_text->currentText())
            return; /* Filter already exists */

    ui->list_filters->addItem(ui->cb_text->currentText());
    io_config::io_window_filters.add_filter(ui->cb_text->currentText().toStdString().c_str());
}

void io_settings_dialog::RemoveFilter()
{
    if (!ui->list_filters->selectedItems().empty()) {
        auto selected_count = ui->list_filters->selectedItems().size();
        for (int i = 0; i < selected_count; i++)
            io_config::io_window_filters.remove_filter(i);

        qDeleteAll(ui->list_filters->selectedItems());
    }
}

void io_settings_dialog::FormAccepted()
{
    io_config::enable_uiohook = ui->cb_iohook->isChecked();
    io_config::enable_gamepad_hook = ui->cb_gamepad_hook->isChecked();
    io_config::enable_overlay_source = ui->cb_enable_overlay->isChecked();

    io_config::enable_remote_connections = ui->cb_enable_remote->isChecked();
    io_config::log_flag = ui->cb_log->isChecked();
    io_config::server_port = ui->box_port->value();

    io_config::enable_input_control = ui->cb_enable_control->isChecked();
    io_config::filter_mode = ui->cb_list_mode->currentIndex();

    io_config::io_window_filters.set_regex(ui->cb_regex->isChecked());
    io_config::io_window_filters.set_whitelist(ui->cb_list_mode->currentIndex() == 0);
    io_config::io_window_filters.write_to_config();

    io_config::enable_websocket_server = ui->cb_enable_wss->isChecked();
    io_config::use_dinput = ui->rb_dinput->isChecked();
    io_config::save();

    if (libgamepad::hook_instance) {
        libgamepad::hook_instance->get_mutex()->lock();
        auto &binds = libgamepad::hook_instance->get_bindings();
        const auto it = std::remove_if(binds.begin(), binds.end(), [&](std::shared_ptr<gamepad::cfg::binding> b) {
            for (const auto &bind : m_bindings_to_remove) {
                if (b->get_name() == bind)
                    return true;
            }
            return false;
        });

        auto &map = libgamepad::hook_instance->get_binding_map();
        for (auto it2 = map.begin(); it2 != map.end();) {
            for (const auto &bind_name : m_bindings_to_remove) {
                if (it2->second == bind_name) {
                    it2 = map.erase(it2);
                    break;
                }
            }
            if (map.empty())
                break;
            ++it2;
        }
        m_bindings_to_remove.clear();

        // Make sure that every device has at least the default binding
        auto devs = libgamepad::hook_instance->get_devices();
        for (auto &dev : devs) {
            if (!dev->get_binding())
                dev->set_binding(libgamepad::hook_instance->make_native_binding());
        }

        binds.erase(it, binds.end());
        libgamepad::hook_instance->get_mutex()->unlock();
    }
}

io_settings_dialog::~io_settings_dialog()
{
    delete ui;
    m_refresh->stop();
    delete m_refresh;
}

void io_settings_dialog::OpenGitHub()
{
    QDesktopServices::openUrl(QUrl("https://github.com/univrsal/input-overlay"));
}

void io_settings_dialog::OpenForums()
{
    QDesktopServices::openUrl(QUrl("https://obsproject.com/forum/resources/input-overlay.552/"));
}

void io_settings_dialog::load_bindings()
{
    if (!libgamepad::hook_instance)
        return;
    gamepad::bindings_list bindings;
    {
        auto &mutex = *libgamepad::hook_instance->get_mutex();
        std::lock_guard<std::mutex> lock(mutex);
        bindings = libgamepad::hook_instance->get_bindings();
    }
    ui->cb_bindings->clear();
    for (const auto &binding : bindings) {
        ui->cb_bindings->addItem(utf8_to_qt(binding->get_name().c_str()));
    }
}

int find_by_code(const QPair<const char *, uint16_t> &needle, const gamepad::cfg::mappings &haystack)
{
    for (const auto &p : haystack) {
        if (p.second == needle.second)
            return p.first;
    }
    return -1;
}

void io_settings_dialog::load_binding_to_ui(const std::shared_ptr<gamepad::cfg::binding> &binding)
{
    auto dinput_binding = dynamic_cast<gamepad::cfg::binding_dinput *>(binding.get());

    for (const auto &pair : button_map) {
        // transfer binds to textboxes
        auto text_box = findChild<QLineEdit *>(pair.first);
        if (text_box) {
            auto native_value = find_by_code(pair, binding->get_button_mappings());
            if (native_value > -1)
                text_box->setText(QString::number(native_value));
        }
    }

    for (const auto &pair : axis_map) {
        // transfer binds to textboxes
        auto text_box = findChild<QLineEdit *>(pair.first);
        if (text_box) {
            auto native_value = find_by_code(pair, binding->get_axis_mappings());
            // if we didn't find anything and this is a DirectInput binding
            // we'll search for the other trigger side
            // quite the cluster fuck, but once again DirectInput is trash
            if (dinput_binding && native_value == -1) {
                if (pair.second == gamepad::axis::RIGHT_TRIGGER) {
                    QPair<const char *, uint16_t> lt = {"txt_lt", gamepad::axis::LEFT_TRIGGER};
                    native_value = find_by_code(lt, binding->get_axis_mappings());
                } else {
                    QPair<const char *, uint16_t> lt = {"txt_lt", gamepad::axis::RIGHT_TRIGGER};
                    native_value = find_by_code(lt, binding->get_axis_mappings());
                }
            }

            if (native_value > -1) {
                QString val = QString::number(native_value);

                // This is bad, but so is DirectInput
                if (dinput_binding) {
                    if (text_box->objectName() == "txt_lt")
                        val = val.prepend(dinput_binding->left_trigger_polarity() > 0 ? "+" : "-");
                    else if (text_box->objectName() == "txt_rt")
                        val = val.prepend(dinput_binding->right_trigger_polarity() > 0 ? "+" : "-");
                }
                text_box->setText(val);
            }
        }
    }

    /* Select it if the binding exists */
    auto idx = ui->cb_bindings->findText(utf8_to_qt(binding->get_name().c_str()));
    if (idx > -1)
        ui->cb_bindings->setCurrentIndex(idx);
}

void io_settings_dialog::on_btn_add_bind_clicked()
{
    if (!libgamepad::hook_instance)
        return;
    if (ui->txt_new_binding_name->text().isEmpty())
        return;
    if (ui->cb_bindings->findText(ui->txt_new_binding_name->text()) != -1) {
        QMessageBox::information(this, "Error", "Binding name must be unique");
        return;
    }

    /* The callback locks the mutex so we cant lock it here */
    auto *mutex = libgamepad::hook_instance->get_mutex();

    auto dev = get_selected_device();
    if (dev) {
        mutex->lock();
        auto has_custom_binding = libgamepad::hook_instance->get_binding_by_name(dev->get_binding()->get_name()) !=
                                  nullptr;
        /* If this device has a custom set binding, we load it, otherwise
         * we keep whatever is already set by the user in the UI and set the binding
         * for the device
         */
        auto binding = libgamepad::hook_instance->make_native_binding();
        binding->set_name(qt_to_utf8(ui->txt_new_binding_name->text()));
        libgamepad::hook_instance->add_binding(binding);
        if (has_custom_binding)
            load_binding_from_ui(binding);
        mutex->unlock();
        ui->cb_bindings->addItem(ui->txt_new_binding_name->text());
    }
    ui->txt_new_binding_name->clear();
}

void io_settings_dialog::on_btn_remove_bind_clicked()
{
    if (ui->cb_bindings->currentIndex() > -1) {
        m_bindings_to_remove.emplace_back(qt_to_utf8(ui->cb_bindings->currentText()));
        ui->cb_bindings->removeItem(ui->cb_bindings->currentIndex());
    }
}

void io_settings_dialog::on_cb_device_currentIndexChanged(int)
{
    if (!libgamepad::hook_instance)
        return;
    std::shared_ptr<gamepad::device> dev;
    {
        auto &mutex = *libgamepad::hook_instance->get_mutex();
        std::lock_guard<std::mutex> lock(mutex);
        dev = get_selected_device();
    }
    if (dev)
        load_binding_to_ui(dev->get_binding());
}

void io_settings_dialog::on_cb_bindings_currentIndexChanged(int)
{
    if (!libgamepad::hook_instance)
        return;
    auto &mutex = *libgamepad::hook_instance->get_mutex();
    std::lock_guard<std::mutex> lock(mutex);
    auto binding = get_selected_binding();
    auto dev = get_selected_device();

    if (dev)
        dev->set_binding(binding);
    if (binding)
        load_binding_to_ui(binding);
}

void io_settings_dialog::on_box_binding_accepted()
{
    if (!libgamepad::hook_instance)
        return;
    auto &mutex = *libgamepad::hook_instance->get_mutex();
    std::lock_guard<std::mutex> lock(mutex);
    auto binding = get_selected_binding();

    if (!binding) {
        /* No binding exists with this name so we create it */
        binding = libgamepad::hook_instance->make_native_binding();
        binding->set_name(qt_to_utf8(ui->cb_bindings->currentText()));
        libgamepad::hook_instance->add_binding(binding);
    }

    auto dinput_binding = dynamic_cast<gamepad::cfg::binding_dinput *>(binding.get());
    /* Read bindings from UI and set them to the current device bindings */
    for (const auto &pair : button_map) {
        // transfer binds from ui
        auto text_box = findChild<QLineEdit *>(pair.first);
        if (text_box) {
            bool ok = false;
            auto i = text_box->text().toInt(&ok);
            if (ok)
                binding->get_button_mappings()[i] = pair.second;
        }
    }

    for (const auto &pair : axis_map) {
        // transfer binds from ui
        auto text_box = findChild<QLineEdit *>(pair.first);
        if (text_box) {
            bool ok = false;
            auto i = abs(text_box->text().toInt(&ok)); // ignore -/+ used for direct input
            if (ok) {
                binding->get_axis_mappings()[i] = pair.second;

                // This is bad, but so is DirectInput
                if (dinput_binding) {
                    if (text_box->objectName() == "txt_lt")
                        dinput_binding->left_trigger_polarity() = text_box->text().contains("-") ? -1 : 1;
                    else if (text_box->objectName() == "txt_rt")
                        dinput_binding->right_trigger_polarity() = text_box->text().contains("-") ? -1 : 1;
                }
            }
        }
    }

    // This is usually already the case, since it'll be done if the selected
    // device changes or the selected binding changes, but if we only have
    // one device and one binding the comboboxes can't be changed so we do it
    // here as well
    if (auto dev = get_selected_device())
        dev->set_binding(binding);
}

std::shared_ptr<gamepad::device> io_settings_dialog::get_selected_device() const
{
    if (!libgamepad::hook_instance)
        return nullptr;
    return libgamepad::hook_instance->get_device_by_id(qt_to_utf8(ui->cb_device->currentData().toString()));
}

std::shared_ptr<gamepad::cfg::binding> io_settings_dialog::get_selected_binding() const
{
    if (!libgamepad::hook_instance)
        return nullptr;
    return libgamepad::hook_instance->get_binding_by_name(qt_to_utf8(ui->cb_bindings->currentText()));
}

void io_settings_dialog::CbEnableGamepadChanged(int)
{
    auto enabled = ui->cb_gamepad_hook->isChecked();
    ui->rb_dinput->setEnabled(enabled);
    ui->rb_xinput->setEnabled(enabled);
    ui->rb_js->setEnabled(enabled);
    ui->rb_by_id->setEnabled(enabled);
}

void io_settings_dialog::CbWssStateChanged(int state)
{
    ui->sb_wss_port->setEnabled(ui->cb_enable_wss->isChecked());
}

void io_settings_dialog::load_binding_from_ui(std::shared_ptr<gamepad::cfg::binding> binding)
{
    auto dinput_binding = dynamic_cast<gamepad::cfg::binding_dinput *>(binding.get());

    for (const auto &pair : button_map) {
        // transfer textbox value to bind
        auto text_box = findChild<QLineEdit *>(pair.first);
        if (text_box) {
            bool ok = false;
            auto i = abs(text_box->text().toInt(&ok)); // ignore -/+ used for direct input
            if (ok)
                binding->get_button_mappings()[i] = pair.second;
        }
    }

    for (const auto &pair : axis_map) {
        // transfer binds to textboxes
        auto text_box = findChild<QLineEdit *>(pair.first);
        if (text_box) {
            bool ok = false;
            auto i = text_box->text().toInt(&ok); // ignore -/+ used for direct input
            if (ok)
                binding->get_button_mappings()[abs(i)] = pair.second;

            if (dinput_binding) {
                if (text_box->objectName() == "txt_lt")
                    dinput_binding->left_trigger_polarity() = i > 0 ? 1 : -1;
                else if (text_box->objectName() == "txt_rt")
                    dinput_binding->right_trigger_polarity() = i > 0 ? 1 : -1;
            }
        }
    }
}

```

`projects/plugin/src/gui/io_settings_dialog.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include <QDialog>
#include <mutex>
#include <memory>

namespace gamepad {
namespace cfg {
class binding;
}
class device;
}

namespace Ui {
class io_config_dialog;
}
class io_settings_dialog : public QDialog {
    Q_OBJECT

public:
    explicit io_settings_dialog(QWidget *parent = nullptr);

    ~io_settings_dialog();

    void showEvent(QShowEvent *event) override;

    void toggleShowHide();

private Q_SLOTS:

    void RefreshUi();

    void FormAccepted();

    void CbRemoteStateChanged(int state);

    void CbInputControlStateChanged(int state);

    void CbWssStateChanged(int state);

    void PingClients();

    void RefreshWindowList();

    void AddFilter();

    void CbEnableGamepadChanged(int state);

    void RemoveFilter();

    static void OpenGitHub();

    static void OpenForums();

    void on_btn_add_bind_clicked();

    void on_btn_remove_bind_clicked();

    void on_cb_device_currentIndexChanged(int index);

    void on_cb_bindings_currentIndexChanged(int index);

    void on_box_binding_accepted();

private:
    std::shared_ptr<gamepad::device> get_selected_device() const;
    std::shared_ptr<gamepad::cfg::binding> get_selected_binding() const;
    void load_bindings();
    void load_binding_to_ui(const std::shared_ptr<gamepad::cfg::binding> &binding);
    void load_binding_from_ui(std::shared_ptr<gamepad::cfg::binding> binding);
    uint64_t m_last_gamepad_input = 0;
    Ui::io_config_dialog *ui;
    QTimer *m_refresh = nullptr;
    std::vector<std::string> m_bindings_to_remove;
};

extern io_settings_dialog *settings_dialog;

```

`projects/plugin/src/gui/io_settings_dialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>io_config_dialog</class>
 <widget class="QDialog" name="io_config_dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>487</width>
    <height>821</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Fixed" vsizetype="Preferred">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>340</width>
    <height>575</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Dialog.Title</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_2">
   <item>
    <widget class="QTabWidget" name="tabs">
     <property name="tabPosition">
      <enum>QTabWidget::North</enum>
     </property>
     <property name="tabShape">
      <enum>QTabWidget::Rounded</enum>
     </property>
     <property name="currentIndex">
      <number>0</number>
     </property>
     <property name="elideMode">
      <enum>Qt::ElideRight</enum>
     </property>
     <property name="documentMode">
      <bool>false</bool>
     </property>
     <property name="tabsClosable">
      <bool>false</bool>
     </property>
     <property name="movable">
      <bool>false</bool>
     </property>
     <property name="tabBarAutoHide">
      <bool>false</bool>
     </property>
     <widget class="QWidget" name="tab_local">
      <attribute name="title">
       <string>Dialog.LocalFeatures</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <widget class="QLabel" name="lbl_local_features">
         <property name="text">
          <string>Dialog.LocalFeatures.Info</string>
         </property>
         <property name="textFormat">
          <enum>Qt::RichText</enum>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="cb_iohook">
         <property name="text">
          <string>Dialog.Uiohook.Enable</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="cb_gamepad_hook">
         <property name="text">
          <string>Dialog.GamepadHook.Enable</string>
         </property>
        </widget>
       </item>
       <item>
        <layout class="QHBoxLayout" name="layout_hook_type">
         <item>
          <widget class="QRadioButton" name="rb_xinput">
           <property name="text">
            <string>Dialog.GamepadHook.Xinput</string>
           </property>
           <property name="checked">
            <bool>true</bool>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QRadioButton" name="rb_dinput">
           <property name="text">
            <string>Dialog.GamepadHook.DInput</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_26">
         <item>
          <widget class="QCheckBox" name="cb_enable_wss">
           <property name="text">
            <string>Dialog.Wss</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QSpinBox" name="sb_wss_port">
           <property name="enabled">
            <bool>false</bool>
           </property>
           <property name="minimum">
            <number>1025</number>
           </property>
           <property name="maximum">
            <number>65534</number>
           </property>
           <property name="value">
            <number>16899</number>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QRadioButton" name="rb_js">
         <property name="text">
          <string>Dialog.GamepadHook.Js</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QRadioButton" name="rb_by_id">
         <property name="text">
          <string>Dialog.GamepadHook.ById</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="cb_enable_overlay">
         <property name="text">
          <string>Dialog.InputOverlay.Enable</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="cb_enable_control">
         <property name="text">
          <string>Dialog.InputControl.Enable</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="cb_regex">
         <property name="text">
          <string>Dialog.InputControl.Regex.Enable</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="lbl_mode">
         <property name="text">
          <string>Dialog.InputControl.Mode</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QComboBox" name="cb_list_mode">
         <property name="currentText">
          <string>Dialog.InputControl.Mode.Whitelist</string>
         </property>
         <property name="currentIndex">
          <number>0</number>
         </property>
         <item>
          <property name="text">
           <string>Dialog.InputControl.Mode.Whitelist</string>
          </property>
         </item>
         <item>
          <property name="text">
           <string>Dialog.InputControl.Mode.Blacklist</string>
          </property>
         </item>
        </widget>
       </item>
       <item>
        <widget class="QFrame" name="frame_entry">
         <property name="frameShape">
          <enum>QFrame::NoFrame</enum>
         </property>
         <layout class="QHBoxLayout" name="horizontalLayout">
          <property name="spacing">
           <number>4</number>
          </property>
          <property name="leftMargin">
           <number>2</number>
          </property>
          <property name="topMargin">
           <number>0</number>
          </property>
          <property name="rightMargin">
           <number>2</number>
          </property>
          <property name="bottomMargin">
           <number>0</number>
          </property>
         </layout>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="lbl_new_entry">
         <property name="text">
          <string>Dialog.InputControl.NewEntry</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="btn_refresh_cb">
         <property name="text">
          <string>Source.InputSource.Reload</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QComboBox" name="cb_text">
         <property name="sizePolicy">
          <sizepolicy hsizetype="MinimumExpanding" vsizetype="Fixed">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="editable">
          <bool>true</bool>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="btn_add">
         <property name="text">
          <string>Dialog.InputControl.Add</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="lbl_list">
         <property name="text">
          <string>Dialog.InputControl.List</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QListWidget" name="list_filters"/>
       </item>
       <item>
        <widget class="QPushButton" name="btn_remove">
         <property name="text">
          <string>Dialog.InputControl.Remove</string>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_gamepad">
      <attribute name="title">
       <string>Dialog.Gamepad</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout_3">
       <item>
        <widget class="QLabel" name="lbl_bindings">
         <property name="text">
          <string>Dialog.Gamepad.Info</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>Dialog.Gamepad.Device</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QComboBox" name="cb_device"/>
       </item>
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>Dialog.Gamepad.Binding</string>
         </property>
        </widget>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_25">
         <item>
          <widget class="QLineEdit" name="txt_new_binding_name"/>
         </item>
         <item>
          <widget class="QPushButton" name="btn_add_bind">
           <property name="sizePolicy">
            <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
           <property name="minimumSize">
            <size>
             <width>15</width>
             <height>15</height>
            </size>
           </property>
           <property name="text">
            <string>+</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_24">
         <item>
          <widget class="QComboBox" name="cb_bindings">
           <property name="sizePolicy">
            <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="btn_remove_bind">
           <property name="sizePolicy">
            <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
           <property name="minimumSize">
            <size>
             <width>15</width>
             <height>15</height>
            </size>
           </property>
           <property name="text">
            <string>-</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QScrollArea" name="scrollArea">
         <property name="frameShape">
          <enum>QFrame::NoFrame</enum>
         </property>
         <property name="widgetResizable">
          <bool>true</bool>
         </property>
         <widget class="QWidget" name="scrollAreaWidgetContents">
          <property name="geometry">
           <rect>
            <x>0</x>
            <y>0</y>
            <width>433</width>
            <height>630</height>
           </rect>
          </property>
          <layout class="QVBoxLayout" name="verticalLayout_5">
           <property name="spacing">
            <number>0</number>
           </property>
           <property name="leftMargin">
            <number>0</number>
           </property>
           <property name="topMargin">
            <number>0</number>
           </property>
           <property name="rightMargin">
            <number>0</number>
           </property>
           <property name="bottomMargin">
            <number>0</number>
           </property>
           <item>
            <widget class="QFrame" name="a">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_2">
              <property name="spacing">
               <number>4</number>
              </property>
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_a">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.A</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_a">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="b">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_3">
              <property name="spacing">
               <number>4</number>
              </property>
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_b">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.B</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_b">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="x">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_4">
              <property name="spacing">
               <number>4</number>
              </property>
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_x">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.X</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_x">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="y">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_5">
              <property name="spacing">
               <number>4</number>
              </property>
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_y">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Y</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_y">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="lb">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_9">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_lb">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.LB</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_lb">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="rb">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_8">
              <property name="spacing">
               <number>4</number>
              </property>
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_rb">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.RB</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_rb">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="back">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_7">
              <property name="spacing">
               <number>4</number>
              </property>
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_back">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Back</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_back">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="start">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_6">
              <property name="spacing">
               <number>4</number>
              </property>
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_start">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Start</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_start">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="guide">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_22">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_guide">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Guide</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_guide">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="analog_left">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_16">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_analog_left">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Analog.Left</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_analog_left">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="analog_right">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_17">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_analog_right">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Analog.Right</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_analog_right">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="dpad_left">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_14">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_dpad_left">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Dpad.Left</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_dpad_left">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="dpad_right">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_15">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_dpad_right">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Dpad.Right</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_dpad_right">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="dpad_down">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_13">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_dpad_down">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Dpad.Down</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_dpad_down">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="dpad_up">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_12">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_dpad_up">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Dpad.Up</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_dpad_up">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="lx">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_20">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_lx">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Analog.LX</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_lx">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="ly">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_21">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_ly">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Analog.LY</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_ly">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="lt">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_10">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_lt">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.LT</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_lt">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="rx">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_18">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_rx">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Analog.RX</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_rx">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="ry">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_19">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_ry">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.Analog.RY</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_ry">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QFrame" name="rt">
             <property name="frameShape">
              <enum>QFrame::NoFrame</enum>
             </property>
             <property name="frameShadow">
              <enum>QFrame::Raised</enum>
             </property>
             <layout class="QHBoxLayout" name="horizontalLayout_11">
              <property name="leftMargin">
               <number>4</number>
              </property>
              <property name="topMargin">
               <number>2</number>
              </property>
              <property name="rightMargin">
               <number>4</number>
              </property>
              <property name="bottomMargin">
               <number>2</number>
              </property>
              <item>
               <widget class="QLabel" name="lbl_rt">
                <property name="text">
                 <string>Dialog.Gamepad.Binding.RT</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QLineEdit" name="txt_rt">
                <property name="sizePolicy">
                 <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                  <horstretch>0</horstretch>
                  <verstretch>0</verstretch>
                 </sizepolicy>
                </property>
                <property name="inputMask">
                 <string>#00009</string>
                </property>
                <property name="readOnly">
                 <bool>false</bool>
                </property>
               </widget>
              </item>
             </layout>
            </widget>
           </item>
          </layout>
         </widget>
        </widget>
       </item>
       <item>
        <widget class="QDialogButtonBox" name="box_binding">
         <property name="standardButtons">
          <set>QDialogButtonBox::Save</set>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_remote">
      <property name="sizePolicy">
       <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
        <horstretch>0</horstretch>
        <verstretch>0</verstretch>
       </sizepolicy>
      </property>
      <property name="maximumSize">
       <size>
        <width>16777215</width>
        <height>16777215</height>
       </size>
      </property>
      <attribute name="title">
       <string>Dialog.RemoteConnection</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout_4">
       <item>
        <widget class="QCheckBox" name="cb_enable_remote">
         <property name="text">
          <string>Dialog.Remote.Enable</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="cb_log">
         <property name="text">
          <string>Dialog.Remote.Logging</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="lbl_status">
         <property name="text">
          <string>Dialog.Remote.Status</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="lbl_port">
         <property name="text">
          <string>Dialog.Remote.Port</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QSpinBox" name="box_port">
         <property name="buttonSymbols">
          <enum>QAbstractSpinBox::NoButtons</enum>
         </property>
         <property name="showGroupSeparator" stdset="0">
          <bool>false</bool>
         </property>
         <property name="maximum">
          <number>65535</number>
         </property>
         <property name="value">
          <number>1608</number>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="lbl_refresh_rate">
         <property name="toolTip">
          <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Dialog.InputOverlay.RemoteRefreshRate.Tooltip&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
         </property>
         <property name="text">
          <string>Dialog.Remote.RefreshRate</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QSpinBox" name="box_refresh_rate">
         <property name="toolTip">
          <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Dialog.InputOverlay.RemoteRefreshRate.Tooltip&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
         </property>
         <property name="suffix">
          <string notr="true"> ms</string>
         </property>
         <property name="minimum">
          <number>5</number>
         </property>
         <property name="maximum">
          <number>5000</number>
         </property>
         <property name="value">
          <number>25</number>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="lbl_connections">
         <property name="text">
          <string>Dialog.Remote.Connections</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QListWidget" name="box_connections">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="btn_refresh">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="text">
          <string>Source.InputSource.Reload</string>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_about">
      <attribute name="title">
       <string>Dialog.About</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout_6">
       <item>
        <widget class="QTextEdit" name="txt_about">
         <property name="readOnly">
          <bool>true</bool>
         </property>
         <property name="html">
          <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Arial'; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:14pt; font-weight:600;&quot;&gt;input-overlay&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;licensed under the GPL v2.0&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;created by univrsal &amp;lt;uni@vrsal.xyz&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt; font-weight:600;&quot;&gt;Credits:&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;libuiohook licensed under the GPL v3.0 by&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;Alex Barker &amp;lt;alex@1stleg.com&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;SDL_net 2.0 (ported as netlib) licensed under the zlib license by&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;Sam Lantinga &amp;lt;slouken@libsdl.org&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;Roy Wood &amp;lt;roy@centricsystems.ca&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;Masahiro Minami &amp;lt;elsur@aaa.letter.co.jp&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt; font-weight:600;&quot;&gt;Translators:&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;- JellyBrick (Korean)&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;- hyrious (Chinese)&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'Noto Sans'; font-size:10pt;&quot;&gt;- rashid (Russian)&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QFrame" name="frame_about">
         <property name="frameShape">
          <enum>QFrame::NoFrame</enum>
         </property>
         <property name="frameShadow">
          <enum>QFrame::Plain</enum>
         </property>
         <layout class="QHBoxLayout" name="horizontalLayout_23">
          <property name="leftMargin">
           <number>0</number>
          </property>
          <property name="topMargin">
           <number>0</number>
          </property>
          <property name="rightMargin">
           <number>0</number>
          </property>
          <property name="bottomMargin">
           <number>0</number>
          </property>
          <item>
           <widget class="QPushButton" name="btn_github">
            <property name="text">
             <string>Dialog.About.Button.Github</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="btn_forums">
            <property name="text">
             <string>Dialog.About.Button.Forums</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="button_box">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
       <horstretch>1</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="acceptDrops">
      <bool>false</bool>
     </property>
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>button_box</sender>
   <signal>accepted()</signal>
   <receiver>io_config_dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>button_box</sender>
   <signal>rejected()</signal>
   <receiver>io_config_dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`projects/plugin/src/hook/gamepad_hook_helper.cpp`:

```cpp
#include "gamepad_hook_helper.hpp"
#include <libgamepad.hpp>
#include "../network/websocket_server.hpp"
#include "../util/obs_util.hpp"
#include "../util/log.h"
#include "../util/config.hpp"

namespace libgamepad {

std::shared_ptr<gamepad::hook> hook_instance = nullptr;
bool state;
uint16_t last_input;
int last_input_value;
uint64_t last_input_time;
uint16_t flags;
std::mutex last_input_mutex;

void start_pad_hook()
{
    if (state)
        return;
    flags = io_config::use_js ? gamepad::hook_type::JS : gamepad::hook_type::BY_ID;
    flags |= io_config::use_dinput ? gamepad::hook_type::DIRECT_INPUT : gamepad::hook_type::NATIVE_DEFAULT;
    hook_instance = gamepad::hook::make(flags);
    hook_instance->set_plug_and_play(true, gamepad::ms(1000));
    hook_instance->set_sleep_time(gamepad::mcs(1000)); // todo: maybe change to 0.1 ms

#if defined(WIN32)
    binfo("Using '%s' gamepad backend", flags & gamepad::hook_type::DIRECT_INPUT ? "Direct Input" : "XInput");
#else
    binfo("Using '%s' for gamepad discovery", flags & gamepad::hook_type::JS ? "/dev/js*" : "/dev/input/by-id");
#endif

    /* Pipe gamepad log to obs log */
    auto log_pipe = [](int level, const char *msg, va_list args, void *) {
        std::string message = "[input-overlay::libgamepad] ";
        message += msg;
        switch (level) {
        case gamepad::LOG_DEBUG:
            blogva(LOG_DEBUG, message.c_str(), args);
            break;
        case gamepad::LOG_ERROR:
            blogva(LOG_ERROR, message.c_str(), args);
            break;
        case gamepad::LOG_INFO:
            blogva(LOG_INFO, message.c_str(), args);
            break;
        case gamepad::LOG_WARNING:
            blogva(LOG_WARNING, message.c_str(), args);
            break;
        default:;
        }
    };
    gamepad::set_logger(log_pipe, nullptr);

    hook_instance->set_axis_event_handler([](const std::shared_ptr<gamepad::device> &d) {
        std::lock_guard<std::mutex> lock(last_input_mutex);
        last_input = d->last_axis_event()->native_id;
        last_input_value = d->last_axis_event()->value;
        last_input_time = d->last_axis_event()->time;
        wss::dispatch_gamepad_event(d->last_axis_event(), d, true, "local");
    });
    hook_instance->set_button_event_handler([](const std::shared_ptr<gamepad::device> &d) {
        std::lock_guard<std::mutex> lock(last_input_mutex);
        last_input = d->last_button_event()->native_id;
        last_input_time = d->last_button_event()->time;
        wss::dispatch_gamepad_event(d->last_button_event(), d, false, "local");
    });

    hook_instance->set_connect_event_handler([](const std::shared_ptr<gamepad::device> &d) {
        binfo("'%s' connected", d->get_name().c_str());
        wss::dispatch_gamepad_event(d, WSS_PAD_CONNECTED, "local");
    });
    hook_instance->set_disconnect_event_handler([](const std::shared_ptr<gamepad::device> &d) {
        binfo("'%s' disconnected", d->get_name().c_str());
        wss::dispatch_gamepad_event(d, WSS_PAD_DISCONNECTED, "local");
    });
    hook_instance->set_reconnect_event_handler([](const std::shared_ptr<gamepad::device> &d) {
        binfo("'%s' reconnected", d->get_name().c_str());
        wss::dispatch_gamepad_event(d, WSS_PAD_RECONNECTED, "local");
    });

    hook_instance->load_bindings(std::string(qt_to_utf8(util_get_data_file("gamepad_bindings.json"))));

    if (hook_instance->start()) {
        binfo("gamepad hook started");
        state = true;
    } else {
        bwarn("gamepad hook couldn't be started");
    }
}

void end_pad_hook()
{
    if (state) {
        hook_instance->save_bindings(std::string(qt_to_utf8(util_get_data_file("gamepad_bindings.json"))));
        hook_instance->stop();
    }
    state = false;
}

}

```

`projects/plugin/src/hook/gamepad_hook_helper.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include <mutex>
#include <memory>

namespace gamepad {
class hook;
}

namespace libgamepad {
extern uint16_t flags;
extern uint16_t last_input;
extern int last_input_value;
extern uint64_t last_input_time;
extern std::mutex last_input_mutex;
extern std::shared_ptr<gamepad::hook> hook_instance;
extern bool state;

void start_pad_hook();
void end_pad_hook();

}

```

`projects/plugin/src/hook/uiohook_helper.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once
#include "../util/input_data.hpp"
#include "../network/websocket_server.hpp"
#include <mutex>
#include <netlib.h>
#include <uiohook.h>
#include <util/platform.h>
#define SCROLL_TIMEOUT 120000000

namespace uiohook {
extern uint64_t last_scroll_time;
extern bool state;

inline void check_wheel()
{
    if (last_scroll_time && os_gettime_ns() - last_scroll_time >= SCROLL_TIMEOUT) {
        last_scroll_time = 0;
        local_data::data.last_wheel_event = {};
    }
}

inline void process_event(uiohook_event *event)
{
    std::lock_guard<std::mutex> lock(local_data::data_mutex);
    local_data::data.dispatch_uiohook_event(event);
    if (event->type == EVENT_MOUSE_WHEEL)
        last_scroll_time = os_gettime_ns();
    wss::dispatch_uiohook_event(event, "local");
}

void start();

void stop();

}

```

`projects/plugin/src/hook/uiohook_helper_linux.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "uiohook_helper.hpp"
#include <cstdarg>
#include <obs-module.h>
#include <uiohook.h>
#include <netlib.h>

namespace uiohook {
/*
        Hook process stuff
        Source:
        https://github.com/kwhat/libuiohook/blob/master/src/demo_hook_async.c
*/

uint64_t last_scroll_time = 0; /* System time at last scroll event */
bool state = false;
std::mutex data_mutex;

static pthread_t hook_thread;
static pthread_mutex_t hook_running_mutex;
static pthread_mutex_t hook_control_mutex;
static pthread_cond_t hook_control_cond;

void *hook_thread_proc(void *arg)
{
    int status = hook_run();
    if (status != UIOHOOK_SUCCESS) {
        *(int *)arg = status;
    }
    pthread_cond_signal(&hook_control_cond);
    pthread_mutex_unlock(&hook_control_mutex);

    return arg;
}

extern "C" {
static void logger_proc(unsigned int level, void *user_data, const char *format, va_list args)
{
    //    std::string f;
    switch (level) {
    case LOG_LEVEL_WARN:
    case LOG_LEVEL_ERROR:
        //        f = std::string(format);
        //        f.insert(0, "[input-overlay::uiohook] ");
        //        blog(LOG_WARNING, f.c_str(), args);
    default:;
    }
}
}

void dispatch_proc(uiohook_event *event, void *)
{
    switch (event->type) {
    case EVENT_HOOK_ENABLED:
        pthread_mutex_lock(&hook_running_mutex);

        pthread_cond_signal(&hook_control_cond);
        pthread_mutex_unlock(&hook_control_mutex);
        break;
    case EVENT_HOOK_DISABLED:
        pthread_mutex_lock(&hook_control_mutex);
        pthread_mutex_unlock(&hook_running_mutex);
    default:; /* Prevent missing case error */
    }
    process_event(event);
}

int hook_enable()
{
    /* Lock the thread control mutex.  This will be unlocked when the
       thread has finished starting, or when it has fully stopped. */
    pthread_mutex_lock(&hook_control_mutex);

    /* Set the initial status. */
    int status = UIOHOOK_FAILURE;

    /* Create the thread attribute. */
    pthread_attr_t hook_thread_attr;
    pthread_attr_init(&hook_thread_attr);

    /* Get the policy and priority for the thread attr. */
    int policy;
    pthread_attr_getschedpolicy(&hook_thread_attr, &policy);
    int priority = sched_get_priority_max(policy);

    int *hook_thread_status = (int *)malloc(sizeof(int));
    if (pthread_create(&hook_thread, &hook_thread_attr, hook_thread_proc, hook_thread_status) == 0) {
        /* Some POSIX revisions do not support pthread_setschedprio so we will
         * use pthread_setschedparam instead. */
        struct sched_param param = {.sched_priority = priority};
        if (pthread_setschedparam(hook_thread, SCHED_OTHER, &param) != 0) {
            blog(LOG_WARNING, "[input-overlay] %s [%u]: Could not set thread priority %i for thread 0x%lX!",
                 __FUNCTION__, __LINE__, priority, (unsigned long)hook_thread);
        }
        /* Wait for the thread to indicate that it has passed the
           initialization portion by blocking until either a EVENT_HOOK_ENABLED
           event is received or the thread terminates.
           NOTE This unlocks the hook_control_mutex while we wait.*/

        pthread_cond_wait(&hook_control_cond, &hook_control_mutex);

        if (pthread_mutex_trylock(&hook_running_mutex) == 0) {
            /* Lock Successful; The hook is not running but the hook_control_cond
               was signaled!  This indicates that there was a startup problem!
               Get the status back from the thread. */
            pthread_join(hook_thread, (void **)&hook_thread_status);
            status = *hook_thread_status;
        } else {
            /* Lock Failure; The hook is currently running and wait was signaled
                   indicating that we have passed all possible start checks.  We can
                   always assume a successful startup at this point. */
            status = UIOHOOK_SUCCESS;
        }

        free(hook_thread_status);

        blog(LOG_DEBUG, "[input-overlay] uiohook thread result: %#X", status);
    } else {
        status = -1;
    }

    /* Make sure the control mutex is unlocked. */
    pthread_mutex_unlock(&hook_control_mutex);

    return status;
}

void stop()
{
    pthread_mutex_destroy(&hook_running_mutex);
    pthread_mutex_destroy(&hook_control_mutex);
    pthread_cond_destroy(&hook_control_cond);
}

void start()
{
    pthread_mutex_init(&hook_running_mutex, nullptr);
    pthread_mutex_init(&hook_control_mutex, nullptr);
    pthread_cond_init(&hook_control_cond, nullptr);

    /* Set the logger callback for library output. */
    hook_set_logger_proc(&logger_proc, nullptr);

    /* Set the event callback for uiohook events. */
    hook_set_dispatch_proc(&dispatch_proc, nullptr);

    const auto status = hook_enable();
    switch (status) {
    case UIOHOOK_SUCCESS:
        /* We no longer block, so we need to explicitly wait for the thread to die. */
        state = true;
        break;
    case UIOHOOK_ERROR_OUT_OF_MEMORY:
        blog(LOG_ERROR, "[input-overlay] Failed to allocate memory. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_X_OPEN_DISPLAY:
        blog(LOG_ERROR, "[input-overlay] Failed to open X11 display. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_X_RECORD_NOT_FOUND:
        blog(LOG_ERROR, "[input-overlay] Unable to locate XRecord extension. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_X_RECORD_ALLOC_RANGE:
        blog(LOG_ERROR, "[input-overlay] Unable to allocate XRecord range. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_X_RECORD_CREATE_CONTEXT:
        blog(LOG_ERROR, "[input-overlay] Unable to allocate XRecord context. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_X_RECORD_ENABLE_CONTEXT:
        blog(LOG_ERROR, "[input-overlay] Failed to enable XRecord context. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_SET_WINDOWS_HOOK_EX:
        blog(LOG_ERROR, "[input-overlay] Failed to register low level windows hook. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_CREATE_EVENT_PORT:
        blog(LOG_ERROR, "[input-overlay] Failed to create apple event port. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_CREATE_RUN_LOOP_SOURCE:
        blog(LOG_ERROR, "[input-overlay] Failed to create apple run loop source. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_GET_RUNLOOP:
        blog(LOG_ERROR, "[input-overlay] Failed to acquire apple run loop. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_CREATE_OBSERVER:
        blog(LOG_ERROR, "[input-overlay] Failed to create apple run loop observer. (%#X)\n", status);
        break;
    case UIOHOOK_FAILURE:
    default:
        blog(LOG_ERROR, "[input-overlay] An unknown hook error occurred. (%#X)\n", status);
        break;
    }
}

}

```

`projects/plugin/src/hook/uiohook_helper_win.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "uiohook_helper.hpp"
#include <cstdarg>
#include <obs-module.h>

namespace uiohook {
/*
    Hook process stuff
    Source:
    https://github.com/kwhat/libuiohook/blob/master/src/demo_hook_async.c
*/

uint64_t last_scroll_time = 0; /* System time at last scroll event */
bool state = false;
std::mutex data_mutex;

static HANDLE hook_thread;
static HANDLE hook_running_mutex;
static HANDLE hook_control_mutex;
static HANDLE hook_control_cond;

void dispatch_proc(uiohook_event *const event, void *)
{
    switch (event->type) {
    case EVENT_HOOK_ENABLED:

        WaitForSingleObject(hook_running_mutex, INFINITE);
        SetEvent(hook_control_cond);
        break;
    case EVENT_HOOK_DISABLED:
        WaitForSingleObject(hook_control_mutex, INFINITE);
        ReleaseMutex(hook_running_mutex);
        ResetEvent(hook_control_cond);
    default:; /* Prevent missing case error */
    }
    process_event(event);
}

DWORD WINAPI hook_thread_proc(const LPVOID arg)
{
    /* Set the hook status. */
    const auto status = hook_run();
    if (status != UIOHOOK_SUCCESS) {
        *static_cast<DWORD *>(arg) = status;
        *static_cast<int *>(arg) = status;
    }

    SetEvent(hook_control_cond);
    return status;
}

extern "C" {
static void logger_proc(unsigned int level, void *user_data, const char *format, va_list args)
{
    switch (level) {
    case LOG_LEVEL_INFO:
        blogva(LOG_INFO, "[input-overlay::uiohook]", args);
        break;
    case LOG_LEVEL_WARN:
    case LOG_LEVEL_ERROR:
        blogva(LOG_WARNING, "[input-overlay::uiohook]", args);
    default:;
    }
}
}

void stop()
{
    CloseHandle(hook_thread);
    CloseHandle(hook_running_mutex);
    CloseHandle(hook_control_mutex);
    CloseHandle(hook_control_cond);
}

int hook_enable()
{
    /* Lock the thread control mutex.  This will be unlocked when the
       thread has finished starting, or when it has fully stopped. */

    WaitForSingleObject(hook_control_mutex, INFINITE);

    /* Set the initial status. */
    int status = UIOHOOK_FAILURE;

    DWORD hook_thread_id;
    DWORD *hook_thread_status = (DWORD *)malloc(sizeof(DWORD));
    hook_thread =
        CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)hook_thread_proc, hook_thread_status, 0, &hook_thread_id);
    if (hook_thread != INVALID_HANDLE_VALUE) {

        /* Attempt to set the thread priority to time critical. */
        if (SetThreadPriority(hook_thread, THREAD_PRIORITY_TIME_CRITICAL) == 0) {
            blog(LOG_WARNING,
                 "[input-overlay] %s [%u]: Could not set thread priority %li for hook thread %#p! (%#lX)\n",
                 __FUNCTION__, __LINE__, (long)THREAD_PRIORITY_TIME_CRITICAL, hook_thread,
                 (unsigned long)GetLastError());
        }

        /* Wait for the thread to indicate that it has passed the
         * initialization portion by blocking until either a EVENT_HOOK_ENABLED
         * event is received or the thread terminates.
         * NOTE This unlocks the hook_control_mutex while we wait.*/

        WaitForSingleObject(hook_control_cond, INFINITE);

        if (WaitForSingleObject(hook_running_mutex, 0) != WAIT_TIMEOUT) {

            /* Lock Successful; The hook is not running but the hook_control_cond
             * was signaled!  This indicates that there was a startup problem!
             * Get the status back from the thread. */
            WaitForSingleObject(hook_thread, INFINITE);
            GetExitCodeThread(hook_thread, hook_thread_status);

        } else {
            /* Lock Failure; The hook is currently running and wait was signaled
             * indicating that we have passed all possible start checks.  We can
             * always assume a successful startup at this point. */
            status = UIOHOOK_SUCCESS;
        }

        free(hook_thread_status);

        blog(LOG_DEBUG, "[input-overlay] %s [%u]: Thread Result: (%#X).\n", __FUNCTION__, __LINE__, status);
    } else {
        status = -1;
    }

    /* Make sure the control mutex is unlocked. */
    ReleaseMutex(hook_control_mutex);
    return status;
}

void start()
{
    hook_running_mutex = CreateMutex(nullptr, FALSE, TEXT("hook_running_mutex"));
    hook_control_mutex = CreateMutex(nullptr, FALSE, TEXT("hook_control_mutex"));
    hook_control_cond = CreateEvent(nullptr, TRUE, FALSE, TEXT("hook_control_cond"));

    /* Set the logger callback for library output. */
    hook_set_logger_proc(&logger_proc, nullptr);

    /* Set the event callback for uiohook events. */
    hook_set_dispatch_proc(&dispatch_proc, nullptr);

    const auto status = hook_enable();
    switch (status) {
    case UIOHOOK_SUCCESS:
        /* We no longer block, so we need to explicitly wait for the thread to die. */
        state = true;
        break;
    case UIOHOOK_ERROR_OUT_OF_MEMORY:
        blog(LOG_ERROR, "[input-overlay] Failed to allocate memory. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_X_OPEN_DISPLAY:
        blog(LOG_ERROR, "[input-overlay] Failed to open X11 display. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_X_RECORD_NOT_FOUND:
        blog(LOG_ERROR, "[input-overlay] Unable to locate XRecord extension. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_X_RECORD_ALLOC_RANGE:
        blog(LOG_ERROR, "[input-overlay] Unable to allocate XRecord range. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_X_RECORD_CREATE_CONTEXT:
        blog(LOG_ERROR, "[input-overlay] Unable to allocate XRecord context. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_X_RECORD_ENABLE_CONTEXT:
        blog(LOG_ERROR, "[input-overlay] Failed to enable XRecord context. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_SET_WINDOWS_HOOK_EX:
        blog(LOG_ERROR, "[input-overlay] Failed to register low level windows hook. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_CREATE_EVENT_PORT:
        blog(LOG_ERROR, "[input-overlay] Failed to create apple event port. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_CREATE_RUN_LOOP_SOURCE:
        blog(LOG_ERROR, "[input-overlay] Failed to create apple run loop source. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_GET_RUNLOOP:
        blog(LOG_ERROR, "[input-overlay] Failed to acquire apple run loop. (%#X)\n", status);
        break;
    case UIOHOOK_ERROR_CREATE_OBSERVER:
        blog(LOG_ERROR, "[input-overlay] Failed to create apple run loop observer. (%#X)\n", status);
        break;
    case UIOHOOK_FAILURE:
    default:
        blog(LOG_ERROR, "[input-overlay] An unknown hook error occurred. (%#X)\n", status);
        break;
    }
}
}

```

`projects/plugin/src/input_overlay.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include <QAction>
#include <QMainWindow>
#include <obs-frontend-api.h>
#include <obs-module.h>
#include <util/config-file.h>

#include "gui/io_settings_dialog.hpp"
#include "hook/gamepad_hook_helper.hpp"
#include "hook/uiohook_helper.hpp"
#include "network/remote_connection.hpp"
#include "network/websocket_server.hpp"
#include "sources/input_source.hpp"
#include "util/config.hpp"
#include "util/lang.h"
#include "util/log.h"

#ifdef LINUX

extern void cleanupDisplay();

#endif

OBS_DECLARE_MODULE()
OBS_MODULE_USE_DEFAULT_LOCALE("input-overlay", "en-US")

bool obs_module_load()
{
    binfo("Loading v%s build time %s", INPUT_OVERLAY_VERSION, BUILD_TIME);
    io_config::set_defaults();
    io_config::load();

    if (io_config::enable_overlay_source)
        sources::register_overlay_source();

    if (io_config::enable_uiohook)
        uiohook::start();

    if (io_config::enable_gamepad_hook)
        libgamepad::start_pad_hook();

    if (io_config::enable_websocket_server)
        wss::start();

    if (io_config::enable_remote_connections) {
        network::local_input = io_config::enable_gamepad_hook || io_config::enable_uiohook;
        network::start_network(io_config::server_port);
    }

    /* Input filtering via focused window title */
    if (io_config::enable_input_control)
        io_config::io_window_filters.read_from_config();

    /* UI registration from
     * https://github.com/Palakis/obs-websocket/
     */
    const auto menu_action = static_cast<QAction *>(obs_frontend_add_tools_menu_qaction(T_MENU_OPEN_SETTINGS));
    obs_frontend_push_ui_translation(obs_module_get_string);
    const auto main_window = static_cast<QMainWindow *>(obs_frontend_get_main_window());
    settings_dialog = new io_settings_dialog(main_window);
    obs_frontend_pop_ui_translation();

    const auto menu_cb = [] { settings_dialog->toggleShowHide(); };
    QAction::connect(menu_action, &QAction::triggered, menu_cb);

    return true;
}

void obs_module_unload()
{
    /* Save config values again */
    io_config::save();

    libgamepad::end_pad_hook();
    uiohook::stop();
    network::close_network();
    wss::stop();

#ifdef LINUX
    cleanupDisplay();
#endif
}

```

`projects/plugin/src/network/io_client.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "io_client.hpp"
#include "../util/log.h"
#include "websocket_server.hpp"

namespace network {
io_client::io_client(const std::string &name, tcp_socket socket) : m_holder()
{
    m_name = name;
    m_socket = socket;
    m_valid = true;
}

io_client::~io_client()
{
    netlib_tcp_close(m_socket);
    for (auto &pad : m_gamepads)
        pad.second->invalidate();
}

tcp_socket io_client::socket() const
{
    return m_socket;
}

const char *io_client::name() const
{
    return m_name.c_str();
}

input_data *io_client::get_data()
{
    return &m_holder;
}

bool io_client::read_event(buffer &buf, const message msg)
{
    auto flag = true;
    auto read_string = [](buffer &buf) {
        std::string result;
        auto *len = buf.read<uint16_t>();
        if (len) {
            result.reserve(*len);
            void *str = nullptr;
            buf.read(&str, result.length());
            if (str)
                result.insert(0, static_cast<char *>(str), *len);
        }
        return result;
    };

    if (msg == MSG_UIOHOOK_EVENT) {
        auto *event = buf.read<uiohook_event>();
        if (event) {
            m_holder.dispatch_uiohook_event(event);
            wss::dispatch_uiohook_event(event, m_name);
        } else {
            flag = false;
        }
    } else if (msg == MSG_GAMEPAD_EVENT) {
        flag = dispatch_gamepad_input(buf);
    } else if (msg == MSG_GAMEPAD_CONNECTED) {
        auto *index = buf.read<uint8_t>();
        auto name = read_string(buf);

        if (!index) {
            flag = false;
            berr("Couldn't read gamepad device index");
        } else if (auto existing_pad = get_pad(name)) {
            binfo("'%s' (id %i) reconnected to '%s'", name.c_str(), *index, m_name.c_str());
            existing_pad->set_index(*index);
            existing_pad->set_id(name);
            existing_pad->set_valid();
            wss::dispatch_gamepad_event(existing_pad, WSS_PAD_RECONNECTED, m_name);
        } else {
            binfo("'%s' (id %i) connected to '%s'", name.c_str(), *index, m_name.c_str());
            auto new_pad = std::make_shared<gamepad::device>();
            new_pad->set_index(*index);
            new_pad->set_id(name);
            new_pad->set_valid();
            m_gamepads[*index] = new_pad;
            wss::dispatch_gamepad_event(new_pad, WSS_PAD_CONNECTED, m_name);
        }
    } else if (msg == MSG_GAMEPAD_RECONNECTED) {
        auto *index = buf.read<uint8_t>();
        auto name = read_string(buf);
        if (index) {
            auto pad = get_pad(name);
            if (pad) {
                // We just keep devices in the list so we don't have to do anything here
                binfo("'%s' (id %i) reconnected to '%s'", name.c_str(), *index, m_name.c_str());
                pad->set_valid();
                wss::dispatch_gamepad_event(pad, WSS_PAD_CONNECTED, m_name);
            } else {
                berr("Received reconnect event from '%s' with invalid gamepad name '%s' (id %i)", m_name.c_str(),
                     name.c_str(), *index);
            }
        } else {
            flag = false;
            berr("Couldn't read gamepad device index");
        }
    } else if (msg == MSG_GAMEPAD_DISCONNECTED) {
        auto *index = buf.read<uint8_t>();
        auto name = read_string(buf);
        if (index) {
            auto pad = get_pad(name);
            if (pad) {
                // We just keep devices in the list so we don't have to do anything here
                pad->invalidate();
                binfo("'%s' (id %i) disconnected from '%s'", name.c_str(), *index, m_name.c_str());
                wss::dispatch_gamepad_event(pad, WSS_PAD_DISCONNECTED, m_name);
            } else {
                berr("Received disconnect event from '%s' with invalid gamepad name '%s' (id %i)", m_name.c_str(),
                     name.c_str(), *index);
            }
        } else {
            flag = false;
            berr("Couldn't read gamepad device index");
        }
    } else if (msg == MSG_MOUSE_WHEEL_RESET) {
        m_holder.m_mutex.lock();
        m_holder.last_wheel_event = {};
        m_holder.m_mutex.unlock();
    }

    if (!flag)
        berr("Couldn't read event for client %s. Error: %s", name(), netlib_get_error());

    return flag;
}

bool io_client::valid() const
{
    return m_valid;
}

void io_client::mark_invalid()
{
    m_valid = false;
}

std::shared_ptr<gamepad::device> io_client::get_pad(const std::string &id)
{
    for (auto &pad : m_gamepads) {
        if (pad.second->get_id() == id)
            return pad.second;
    }
    return nullptr;
}

bool io_client::dispatch_gamepad_input(buffer &buf)
{
    auto *index = buf.read<uint8_t>();
    if (!index) {
        berr("Failed to read gamepad index");
        return false;
    }
    auto pad = m_gamepads.find(*index);

    auto read_buttons = [&] {
        auto *count = buf.read<uint8_t>();
        auto &buttons = pad->second->get_buttons();
        bool result = true;
        if (count) {
            for (int i = 0; i < *count; i++) {
                auto *vc = buf.read<uint16_t>();
                auto *vv = buf.read<uint16_t>();
                if (vc && vv) {
                    buttons[*vc] = *vv;
                } else {
                    result = false;
                    break;
                }
            }
        }
        return result;
    };

    auto read_axis = [&] {
        auto *count = buf.read<uint8_t>();
        auto &axis = pad->second->get_axis();
        bool result = true;
        if (count) {
            for (int i = 0; i < *count; i++) {
                auto *vc = buf.read<uint16_t>();
                auto *vv = buf.read<float>();
                if (vc && vv) {
                    axis[*vc] = *vv;
                } else {
                    result = false;
                    break;
                }
            }
        }
        return result;
    };

    auto handle_last_event = [&](gamepad::input_event *output, bool is_axis) {
        auto *vc = buf.read<uint16_t>();
        auto *vv = buf.read<float>();
        auto *time = buf.read<uint64_t>();

        if (vc && vv && time) {
            if (*time > output->time) {
                output->virtual_value = *vv;
                output->vc = *vc;
                output->time = *time;
                wss::dispatch_gamepad_event(output, pad->second, is_axis, m_name.c_str());
            }
            return true;
        }
        return false;
    };

    if (pad == m_gamepads.end()) {
        berr("'%s' received gamepad input events for non existing gamepad (id %i)", m_name.c_str(), *index);
        return false;
    }

    gamepad::input_event *output;
    if (!read_buttons() || !read_axis()) {
        berr("'%s' received invalid gamepad package (id %i)", m_name.c_str(), *index);
        return false;
    }

    if (handle_last_event(pad->second->last_axis_event(), true) &&
        handle_last_event(pad->second->last_button_event(), false)) {
        return true;
    }

    berr("Couldn't read gamepad last events.");
    return false;
}
}

```

`projects/plugin/src/network/io_client.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "../util/input_data.hpp"
#include <buffer.hpp>
#include <messages.hpp>
#include <netlib.h>
#include <map>

namespace network {
class io_client {
public:
    io_client(const std::string &name, tcp_socket socket);

    ~io_client();

    tcp_socket socket() const;
    const char *name() const;
    input_data *get_data();
    bool read_event(buffer &buf, message msg);
    void mark_invalid();
    bool valid() const;

    std::map<uint8_t, std::shared_ptr<gamepad::device>> &gamepads() { return m_gamepads; }
    std::shared_ptr<gamepad::device> get_pad(const std::string &id);

private:
    bool dispatch_gamepad_input(buffer &buf);
    input_data m_holder;
    tcp_socket m_socket;
    /* Set to false if this client should be disconnected on next round_trip */
    bool m_valid;
    std::string m_name;

    /* Manually managed */
    std::map<uint8_t, std::shared_ptr<gamepad::device>> m_gamepads;
};
}

```

`projects/plugin/src/network/io_server.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "io_server.hpp"
#include "remote_connection.hpp"
#include "../util/config.hpp"
#include "../util/lang.h"
#include <algorithm>
#include <obs-module.h>
#include <util/platform.h>

#include "src/util/log.h"

static netlib_socket_set sockets = nullptr;

namespace network {
std::mutex mutex;

io_server::io_server(const uint16_t port) : m_server(nullptr)
{
    sockets = nullptr;
    m_ip.port = port;
    m_last_refresh = os_gettime_ns();
}

io_server::~io_server()
{
    m_clients.clear();
}

bool io_server::init()
{
    auto flag = true;

    if (netlib_resolve_host(&m_ip, nullptr, m_ip.port) == -1) {
        berr("netlib_resolve_host failed: %s.", netlib_get_error());
        flag = false;
    } else {
        const auto ipaddr = netlib_swap_BE32(m_ip.host);
        binfo("Remote connection open on %d.%d.%d.%d:%hu", ipaddr >> 24, ipaddr >> 16 & 0xff, ipaddr >> 8 & 0xff,
              ipaddr & 0xff, m_ip.port);

        m_server = netlib_tcp_open(&m_ip);
        m_buffer.resize(1024); // Most likely will never need more than 1K
        if (!m_server) {
            berr("netlib_tcp_open failed: %s", netlib_get_error());
            flag = false;
        }
    }
    return flag;
}

void io_server::listen(int &numready)
{
    if (create_sockets())
        numready = netlib_check_socket_set(sockets, LISTEN_TIMEOUT);
}

tcp_socket io_server::socket() const
{
    return m_server;
}

void io_server::update_clients()
{
    std::lock_guard<std::mutex> lock(mutex);

    for (const auto &client : m_clients) {
        if (netlib_socket_ready(client->socket())) {
            /* Receive input data */
            m_buffer.reset();
            const int read = netlib_tcp_recv(client->socket(), static_cast<void *>(m_buffer.get()), m_buffer.length());

            if (read < 0) {
                berr("Failed to receive buffer from %s. Closed connection", client->name());
                client->mark_invalid();
                continue;
            }

            auto msg = read_msg_from_buffer(m_buffer);
            while (msg != MSG_INVALID) {
                switch (msg) {
                case MSG_UIOHOOK_EVENT:
                case MSG_GAMEPAD_EVENT:
                case MSG_GAMEPAD_CONNECTED:
                case MSG_GAMEPAD_RECONNECTED:
                case MSG_GAMEPAD_DISCONNECTED:
                case MSG_MOUSE_WHEEL_RESET:
                    if (!client->read_event(m_buffer, msg))
                        berr("Failed to receive event data from %s.", client->name());
                    break;
                case MSG_CLIENT_DC:
                    client->mark_invalid();
                    break;
                default:
                case MSG_END_BUFFER:
                case MSG_INVALID:
                    break;
                }
                if (m_buffer.read_pos() < read)
                    break;
                msg = read_msg_from_buffer(m_buffer);
            }
        }
    }
}

void io_server::get_clients(std::vector<const char *> &v)
{
    for (const auto &client : m_clients) {
        v.emplace_back(client->name());
    }
    m_clients_changed = false;
}

void io_server::get_clients(obs_property_t *prop, const bool enable_local)
{
    obs_property_list_clear(prop);

    if (enable_local)
        obs_property_list_add_string(prop, T_LOCAL_SOURCE, "");

    for (const auto &client : m_clients)
        obs_property_list_add_string(prop, client->name(), client->name());
}

bool io_server::clients_changed() const
{
    return m_clients_changed;
}

void io_server::ping_clients()
{
    for (auto &client : m_clients) {
        if (!send_message(client->socket(), MSG_PING_CLIENT))
            client->mark_invalid(); /* Can't send data -> Connection is dead */
    }
}

void io_server::round_trip()
{
    mutex.lock();

    if (!m_clients.empty()) {
        const auto old = server_instance->num_clients();
        const auto it = std::remove_if(m_clients.begin(), m_clients.end(), [](const std::shared_ptr<io_client> &o) {
            if (!o->valid()) {
                binfo("%s disconnected.", o->name());
                return true;
            }
            return false;
        });
        m_clients.erase(it, m_clients.end());

        if ((os_gettime_ns() - m_last_refresh) / (1000 * 1000) > io_config::server_refresh_rate) {
            for (auto &client : m_clients) {
                if (!send_message(client->socket(), MSG_REFRESH))
                    client->mark_invalid();
            }
            m_last_refresh = os_gettime_ns();
        }

        if (old != server_instance->num_clients())
            m_clients_changed = true;
    }

    mutex.unlock();
}

std::shared_ptr<io_client> io_server::get_client(const std::string &id)
{
    for (auto &client : m_clients) {
        if (client->name() == id)
            return client;
    }
    return nullptr;
}

void io_server::add_client(tcp_socket socket, char *name)
{
    std::lock_guard<std::mutex> lock(mutex);

    fix_name(name);

    if (!strlen(name)) {
        binfo("Disconnected %s: Invalid name", name);
        send_message(socket, MSG_NAME_INVALID);
        netlib_tcp_close(socket);
        return;
    }

    if (!unique_name(name)) {
        binfo("Disconnected %s: Name already in use", name);
        send_message(socket, MSG_NAME_NOT_UNIQUE);
        netlib_tcp_close(socket);
        return;
    }

    bdebug("Received connection from '%s'.", name);

    m_clients_changed = true;
    m_clients.emplace_back(new io_client(name, socket));
}

bool io_server::unique_name(char *name)
{
    if (!name)
        return false;
    auto flag = true;
    for (auto &client : m_clients) {
        if (!strcmp(name, client->name())) {
            flag = false;
            break;
        }
    }
    return flag;
}

/* Only works with pre-allocated char arrays */
void io_server::fix_name(char *name)
{
    static auto accepted = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-0123456789";
    size_t pos;
    const auto len = strlen(name);
    while ((pos = strspn(name, accepted)) != len) {
        name[pos] = '_';
    }
}

bool io_server::create_sockets()
{
    if (sockets && m_last_client_count == num_clients())
        return true; // No reason to reallocate
    if (sockets)
        netlib_free_socket_set(sockets);

    sockets = netlib_alloc_socket_set(num_clients() + 1);
    m_last_client_count = num_clients();
    if (!sockets) {
        berr("netlib_alloc_socket_set failed with %i clients.", num_clients() + 1);
        network_flag = false;
        return false;
    }

    netlib_tcp_add_socket(sockets, m_server);

    for (const auto &client : m_clients)
        netlib_tcp_add_socket(sockets, client->socket());

    return true;
}
std::shared_ptr<gamepad::device> io_server::get_client_device_by_id(const std::string &client_id,
                                                                    const std::string &device_id)
{
    auto client = get_client(client_id);
    if (client)
        return client->get_pad(device_id);
    return nullptr;
}
}

```

`projects/plugin/src/network/io_server.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "io_client.hpp"
#include <memory>
#include <mutex>
#include <netlib.h>
#include <obs-module.h>
#include <vector>
#include <buffer.hpp>

#ifdef _WIN32
#endif
#define LISTEN_TIMEOUT 25

namespace network {
extern std::mutex mutex;

class io_server {
public:
    io_server(uint16_t port);

    ~io_server();

    bool init();

    void listen(int &numready);

    tcp_socket socket() const;
    void add_client(tcp_socket socket, char *name);
    void update_clients();
    void get_clients(std::vector<const char *> &v);
    void get_clients(obs_property_t *prop, bool enable_local);
    bool clients_changed() const;
    void ping_clients();

    /* Checks clients and removes them
     * if necessary
     */
    void round_trip();

    std::shared_ptr<io_client> get_client(const std::string &id);

    int num_clients() { return static_cast<int>(m_clients.size()); }

    std::vector<std::shared_ptr<io_client>> &clients() { return m_clients; }

    std::shared_ptr<gamepad::device> get_client_device_by_id(const std::string &client_id,
                                                             const std::string &device_id);

private:
    bool unique_name(char *name);

    static void fix_name(char *name);

    bool create_sockets();

    uint64_t m_last_refresh = 0;
    buffer m_buffer;                /* Used for temporarily storing sent data */
    bool m_clients_changed = false; /* Set to true on connection/disconnect and false after get_clients() */
    ip_address m_ip{};
    tcp_socket m_server;
    std::vector<std::shared_ptr<io_client>> m_clients; /* map client name to client instance */
    size_t m_last_client_count = 0;
};
}

```

`projects/plugin/src/network/mg.cpp`:

```cpp
#include "mg.hpp"

#include <atomic>
#include <deque>
#include <mutex>
#include <thread>
#include <vector>
#include <util/threading.h>
#include "src/util/config.hpp"
#include "src/util/log.h"
#include "src/util/settings.h"

extern "C" {
#include <mongoose.h>
}

namespace mg {
struct mg_mgr mgr {
};
std::vector<struct mg_connection *> web_sockets;
std::deque<std::string> message_queue;
std::mutex poll_mutex;
std::thread thread_handle;
std::atomic<bool> thread_flag;

void event_handler(struct mg_connection *c, int ev, void *ev_data, void *fn_data)
{
    if (ev == MG_EV_HTTP_MSG) {
        auto *hm = (struct mg_http_message *)ev_data;
        if (mg_http_match_uri(hm, "/")) {
            // Upgrade to websocket. From now on, a connection is a full-duplex
            // Websocket connection, which will receive MG_EV_WS_MSG events.
            mg_ws_upgrade(c, hm, nullptr);

            if (web_sockets.empty()) // we don't want stale events
                message_queue.clear();
            web_sockets.emplace_back(c);
        }
    } else if (ev == MG_EV_WS_MSG) {
        // Just echo data
        auto *wm = (struct mg_ws_message *)ev_data;
        mg_ws_send(c, wm->data.ptr, wm->data.len, WEBSOCKET_OP_TEXT);
    }
}

void thread_method()
{
    os_set_thread_name("inputovrly-mg");

    while (thread_flag) {
        mg_mgr_poll(&mgr, 5);
        poll_mutex.lock();
        while (!message_queue.empty()) {
            auto &msg = message_queue.back();
            for (auto socket : web_sockets) {
                if (!socket->is_draining && !socket->is_closing)
                    mg_ws_send(socket, msg.c_str(), msg.length(), WEBSOCKET_OP_TEXT);
            }
            message_queue.pop_back();
        }
        poll_mutex.unlock();
        const auto it = std::remove_if(web_sockets.begin(), web_sockets.end(),
                                       [](const struct mg_connection *o) { return o->is_closing || o->is_draining; });
        web_sockets.erase(it, web_sockets.end());
    }
}

bool start(const std::string &addr)
{
    if (thread_flag)
        return true;
    thread_flag = true;
    mg_log_set_callback(
        [](const void *buf, size_t length, void *) {
            std::string str(static_cast<const char *>(buf), length);
            if (str != "\n")
                bdebug("%s", str.c_str());
        },
        nullptr);
    mg_mgr_init(&mgr);
    auto *nc = mg_http_listen(&mgr, addr.c_str(), event_handler, nullptr);
    if (!nc) {
        berr("Failed to start mongoose listener");
        return false;
    }

    thread_handle = std::thread(thread_method);
    return true;
}

void stop()
{
    if (!thread_flag)
        return;
    binfo("Stopping web socket server running on %ld", CGET_INT(S_WSS_PORT));
    thread_flag = false;
    if (thread_handle.joinable())
        thread_handle.join();
    mg_mgr_free(&mgr);
}

void queue_message(const std::string &msg)
{
    if (!msg.empty())
        message_queue.emplace_back(msg);
}

bool can_queue_message()
{
    return thread_flag && !web_sockets.empty();
}
}

```

`projects/plugin/src/network/mg.hpp`:

```hpp
#pragma once
#include <mutex>
#include <string>

// Separate mongoose interface as it seems to clash with libgamepad headers
// probably some directinput stuff
namespace mg {
extern std::mutex poll_mutex;
bool start(const std::string &addr);
void stop();
void queue_message(const std::string &msg);
bool can_queue_message();
}
```

`projects/plugin/src/network/remote_connection.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "remote_connection.hpp"
#include "io_server.hpp"
#include "../util/config.hpp"
#include <obs-module.h>
#include <util/platform.h>
#include <thread>

#include "src/util/log.h"

#if __linux__
#include <ifaddrs.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#endif
namespace network {
std::atomic<bool> network_flag;
bool local_input = false; /* True if either of the local hooks is running */
char local_ip[16] = "127.0.0.1\0";

io_server *server_instance = nullptr;
std::thread network_thread;

const char *get_status()
{
    return network_flag ? "UP" : "DOWN";
}

void start_network(uint16_t port)
{
    if (network_flag)
        return;

        /* Get ip of first interface */
#if _WIN32
    ip_address addresses[2];
    if (netlib_get_local_addresses(addresses, 2) > 0) {
        snprintf(local_ip, sizeof(local_ip), "%d.%d.%d.%d", (addresses[0].host >> 0) & 0xFF,
                 (addresses[0].host >> 8) & 0xFF, (addresses[0].host >> 16) & 0xFF, (addresses[0].host >> 24) & 0xFF);
    }
#elif __linux__
    struct ifaddrs *addrs;
    getifaddrs(&addrs);
    struct ifaddrs *tmp = addrs;
    while (tmp) {
        if (tmp->ifa_addr && tmp->ifa_addr->sa_family == AF_INET) {
            struct sockaddr_in *p_addr = (struct sockaddr_in *)tmp->ifa_addr;
            if (tmp->ifa_name != std::string("lo")) {
                snprintf(local_ip, sizeof(local_ip), "%s", inet_ntoa(p_addr->sin_addr));
                break;
            }
        }
        tmp = tmp->ifa_next;
    }
#endif
    auto failed = false;

    if (netlib_init() == 0) {
        server_instance = new io_server(port);

        if (server_instance->init()) {
            auto error = 0;
            network_flag = true;
            network_thread = std::thread(network_handler);
        } else {
            berr("Server init failed");
            failed = true;
        }
    } else {
        berr("netlib_init failed: %s", netlib_get_error());
        failed = true;
    }

    if (failed) {
        berr("Remote connection disabled due to errors");
        close_network();
    }
}

void close_network()
{
    if (network_flag) {
        network_flag = false;
        network_thread.join();
        delete server_instance;
        netlib_quit();
    }
}

void network_handler()
{
    tcp_socket sock;

    while (network_flag) {
        int numready;
        server_instance->round_trip();
        server_instance->listen(numready);

        if (numready == -1) {
            berr("netlib_check_sockets failed: %s", netlib_get_error());
            break;
        }

        if (!numready) {
            os_sleepto_ns(100000); /* Should be fast enough */
            continue;
        }

        if (netlib_socket_ready(server_instance->socket())) {
            numready--;
            binfo("Received connection...");

            sock = netlib_tcp_accept(server_instance->socket());

            if (sock) {
                char *name = nullptr;
                binfo("Accepted connection...");

                if (read_text(sock, &name)) {
                    server_instance->add_client(sock, name);
                } else {
                    berr("Failed to receive client name.");
                    netlib_tcp_close(sock);
                }
                free(name);
            }
        }

        if (numready)
            server_instance->update_clients();
    }
}

int send_message(tcp_socket sock, message msg)
{
    auto msg_id = uint8_t(msg);

    const uint32_t result = netlib_tcp_send(sock, &msg_id, sizeof(msg_id));

    if (result < sizeof(msg_id)) {
        berr("netlib_tcp_send: %s\n", netlib_get_error());
        return 0;
    }

    return result;
}

/* https://www.libsdl.org/projects/SDL_net/docs/demos/tcputil.h */
char *read_text(tcp_socket sock, char **buf)
{
    uint32_t len, result;

    if (*buf)
        free(*buf);
    *buf = nullptr;

    result = netlib_tcp_recv(sock, &len, sizeof(len));
    if (result < sizeof(len)) {
        berr("netlib_tcp_recv: %s\n", netlib_get_error());
        return nullptr;
    }

    len = netlib_swap_BE32(len);
    if (!len)
        return nullptr;

    *buf = static_cast<char *>(malloc(len));
    if (!(*buf))
        return nullptr;

    result = netlib_tcp_recv(sock, *buf, len);
    if (result < len) {
        berr("netlib_tcp_recv: %s\n", netlib_get_error());
        free(*buf);
        buf = nullptr;
    }

    return *buf;
}

message read_msg_from_buffer(buffer &buf)
{
    auto id = buf.read<uint8_t>();

    if (id && *id <= MSG_LAST)
        return message(*id);
    return MSG_INVALID;
}
}

```

`projects/plugin/src/network/remote_connection.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "messages.hpp"
#include <atomic>
#include <buffer.hpp>
#include <netlib.h>

#define TIMEOUT_NS (1000 * 1000 * 1000)
namespace network {
class io_server;
extern std::atomic<bool> network_flag; /* Running state */
/* Set in obs_module_load */
extern bool local_input;
extern char local_ip[16];

const char *get_status();

void start_network(uint16_t port);

void close_network();

void network_handler();

char *read_text(tcp_socket sock, char **buf);

message read_msg_from_buffer(buffer &buf);

int send_message(tcp_socket sock, message msg);

extern io_server *server_instance;
}

```

`projects/plugin/src/network/websocket_server.cpp`:

```cpp
#include "websocket_server.hpp"
#include "../util/config.hpp"
#include "../util/settings.h"
#include "../util/obs_util.hpp"
#include "mg.hpp"
#include <QJsonObject>
#include <QJsonDocument>

namespace wss {
bool start()
{
    const auto port = CGET_INT(S_WSS_PORT);
    std::string url = "ws://localhost:";
    url = url.append(std::to_string(port));
    return mg::start(url);
}

void stop()
{
    mg::stop();
}

QString serialize_uiohook(const uiohook_event *e, const std::string &source_name)
{
    QJsonObject obj;
    auto ev_to_str = [](int e) {
        switch (e) {
        case EVENT_KEY_TYPED:
            return "key_typed";
        case EVENT_KEY_PRESSED:
            return "key_pressed";
        case EVENT_KEY_RELEASED:
            return "key_released";
        case EVENT_MOUSE_CLICKED:
            return "mouse_clicked";
        case EVENT_MOUSE_PRESSED:
            return "mouse_pressed";
        case EVENT_MOUSE_RELEASED:
            return "mouse_released";
        case EVENT_MOUSE_MOVED:
            return "mouse_moved";
        case EVENT_MOUSE_DRAGGED:
            return "mouse_dragged";
        case EVENT_MOUSE_WHEEL:
            return "mouse_wheel";
        default:
            return "";
        }
    };

    switch (e->type) {
    case EVENT_KEY_TYPED:
        obj["char"] = QString(e->data.keyboard.keychar);
        /* fallthrough */
    case EVENT_KEY_PRESSED:
    case EVENT_KEY_RELEASED:
        obj["event_source"] = utf8_to_qt(source_name.c_str());
        obj["event_type"] = QString(ev_to_str(e->type));
        obj["time"] = int(e->time);
        obj["mask"] = e->mask;
        obj["keycode"] = e->data.keyboard.keycode;
        obj["rawcode"] = e->data.keyboard.rawcode;
        break;
    case EVENT_MOUSE_CLICKED:
    case EVENT_MOUSE_PRESSED:
    case EVENT_MOUSE_RELEASED:
    case EVENT_MOUSE_MOVED:
    case EVENT_MOUSE_DRAGGED:
        obj["event_source"] = utf8_to_qt(source_name.c_str());
        obj["event_type"] = QString(ev_to_str(e->type));
        obj["time"] = int(e->time);
        obj["mask"] = e->mask;
        obj["button"] = e->data.mouse.button;
        obj["clicks"] = e->data.mouse.clicks;
        obj["x"] = e->data.mouse.x;
        obj["y"] = e->data.mouse.y;
        break;
    case EVENT_MOUSE_WHEEL:
        obj["event_source"] = utf8_to_qt(source_name.c_str());
        obj["event_type"] = QString(ev_to_str(e->type));
        obj["time"] = int(e->time);
        obj["mask"] = e->mask;
        obj["clicks"] = e->data.wheel.clicks;
        obj["type"] = e->data.wheel.type;
        obj["amount"] = e->data.wheel.amount;
        obj["rotation"] = e->data.wheel.rotation;
        obj["direction"] = e->data.wheel.direction;
        obj["x"] = e->data.wheel.x;
        obj["y"] = e->data.wheel.y;
        break;
    default:;
    }
    QJsonDocument doc(obj);
    return QString(doc.toJson(QJsonDocument::Compact));
}

void dispatch_uiohook_event(const uiohook_event *e, const std::string &source_name)
{
    std::lock_guard<std::mutex> lock(mg::poll_mutex);
    if (mg::can_queue_message())
        mg::queue_message(qt_to_utf8(serialize_uiohook(e, source_name)));
}

void dispatch_gamepad_event(const gamepad::input_event *e, const std::shared_ptr<gamepad::device> &device, bool is_axis,
                            const std::string &source_name)
{
    std::lock_guard<std::mutex> lock(mg::poll_mutex);
    if (!mg::can_queue_message())
        return;
    QJsonObject obj;
    obj["event_source"] = source_name.c_str();
    obj["event_type"] = is_axis ? "gamepad_axis" : "gamepad_button";
    obj["device_name"] = utf8_to_qt(device->get_id().c_str());
    obj["device_index"] = device->get_index();
    obj["time"] = int(e->time);
    obj["virtual_code"] = e->vc;
    obj["virtual_value"] = e->virtual_value;
    obj["native_code"] = e->native_id;
    obj["native_value"] = e->value;

    QJsonDocument doc(obj);
    QString str(doc.toJson(QJsonDocument::Compact));

    mg::queue_message(qt_to_utf8(str));
}

void dispatch_gamepad_event(const std::shared_ptr<gamepad::device> &device, const char *state,
                            const std::string &source_name)
{
    std::lock_guard<std::mutex> lock(mg::poll_mutex);
    if (!mg::can_queue_message())
        return;
    QJsonObject obj;
    obj["event_source"] = source_name.c_str();
    obj["event_type"] = state;
    obj["device_name"] = utf8_to_qt(device->get_id().c_str());
    obj["time"] = int(gamepad::hook::ms_ticks());

    QJsonDocument doc(obj);
    QString str(doc.toJson(QJsonDocument::Compact));

    mg::queue_message(qt_to_utf8(str));
}

}
```

`projects/plugin/src/network/websocket_server.hpp`:

```hpp
#pragma once
#include <uiohook.h>
#include <string>
#include <libgamepad.hpp>

#define WSS_PAD_CONNECTED "gamepad_connected"
#define WSS_PAD_DISCONNECTED "gamepad_disconnected"
#define WSS_PAD_RECONNECTED "gamepad_reconnected"

namespace wss {
bool start();
void stop();

void dispatch_uiohook_event(const uiohook_event *, const std::string &source_name);
void dispatch_gamepad_event(const gamepad::input_event *e, const std::shared_ptr<gamepad::device> &device, bool is_axis,
                            const std::string &source_name);
void dispatch_gamepad_event(const std::shared_ptr<gamepad::device> &device, const char *state,
                            const std::string &source_name);
}
```

`projects/plugin/src/sources/input_source.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "input_source.hpp"
#include "../hook/gamepad_hook_helper.hpp"
#include "../util/lang.h"
#include "../util/obs_util.hpp"
#include "../util/settings.h"
#include "../util/config.hpp"
#include "../network/io_server.hpp"
#include "../network/remote_connection.hpp"
#include <QFile>
#include <obs-frontend-api.h>

namespace sources {
bool overlay_settings::use_local_input()
{
    return selected_source.empty() || selected_source == T_LOCAL_SOURCE;
}

input_source::input_source(obs_source_t *source, obs_data_t *settings) : m_source(source)
{
    m_overlay = std::make_unique<overlay>(&m_settings);
    obs_source_update(m_source, settings);
    m_settings.image_file = obs_data_get_string(settings, S_OVERLAY_FILE);
    m_settings.layout_file = obs_data_get_string(settings, S_LAYOUT_FILE);
    m_overlay->load();

    // Fix sources that used to use a remote connection but can't now because
    // remote connections are disabled
    if (!io_config::enable_remote_connections) {
        m_settings.selected_source = T_LOCAL_SOURCE;
        obs_data_set_string(settings, S_INPUT_SOURCE, T_LOCAL_SOURCE);
    }
}

input_source::~input_source() = default;

inline void input_source::update(obs_data_t *settings)
{
    m_settings.selected_source = obs_data_get_string(settings, S_INPUT_SOURCE);

    m_settings.gamepad_id = obs_data_get_string(settings, S_CONTROLLER_ID);
    if (m_settings.use_local_input() && libgamepad::hook_instance) {
        libgamepad::hook_instance->get_mutex()->lock();
        m_settings.gamepad = libgamepad::hook_instance->get_device_by_id(m_settings.gamepad_id);
        libgamepad::hook_instance->get_mutex()->unlock();
    } else if (io_config::enable_remote_connections) {
        std::lock_guard<std::mutex> lock(network::mutex);
        m_settings.gamepad =
            network::server_instance->get_client_device_by_id(m_settings.selected_source, m_settings.gamepad_id);
    }

    m_settings.mouse_sens = obs_data_get_int(settings, S_MOUSE_SENS);

    if ((m_settings.use_center = obs_data_get_bool(settings, S_MONITOR_USE_CENTER))) {
        m_settings.monitor_h = obs_data_get_int(settings, S_MONITOR_H_CENTER);
        m_settings.monitor_w = obs_data_get_int(settings, S_MONITOR_V_CENTER);
        m_settings.mouse_deadzone = obs_data_get_int(settings, S_MOUSE_DEAD_ZONE);
    }
}

inline void input_source::tick(float seconds)
{
    if (m_overlay->is_loaded()) {
        m_overlay->refresh_data();
        m_overlay->tick(seconds);
    }

    // If we don't have a gamepad check periodically to see if it has been connected
    if (m_settings.layout_flags & OF_GAMEPAD) {
        if (m_settings.gamepad && !m_settings.gamepad->is_valid()) {
            m_settings.gamepad = nullptr; // don't hold onto invalid references
        } else {
            m_settings.gamepad_check_timer += seconds;
            if (m_settings.gamepad_check_timer >= 1) {
                if (m_settings.use_local_input() && libgamepad::hook_instance) {
                    libgamepad::hook_instance->get_mutex()->lock();
                    m_settings.gamepad = libgamepad::hook_instance->get_device_by_id(m_settings.gamepad_id);
                    libgamepad::hook_instance->get_mutex()->unlock();
                } else if (network::network_flag) {
                    std::lock_guard<std::mutex> lock(network::mutex);
                    m_settings.gamepad = network::server_instance->get_client_device_by_id(m_settings.selected_source,
                                                                                           m_settings.gamepad_id);
                }
                m_settings.gamepad_check_timer = 0.0f;
            }
        }
    }
}

inline void input_source::render(gs_effect_t *effect) const
{
    if (!m_overlay->get_texture() || !m_overlay->get_texture()->texture)
        return;

    if (m_settings.layout_file.empty() || !m_overlay->is_loaded()) {
        gs_effect_set_texture(gs_effect_get_param_by_name(effect, "image"), m_overlay->get_texture()->texture);
        gs_draw_sprite(m_overlay->get_texture()->texture, 0, cx, cy);
    } else {
        m_overlay->draw(effect);
    }
}

bool use_monitor_center_changed(obs_properties_t *props, obs_property_t *, obs_data_t *data)
{
    const auto use_center = obs_data_get_bool(data, S_MONITOR_USE_CENTER);
    obs_property_set_visible(GET_PROPS(S_MONITOR_H_CENTER), use_center);
    obs_property_set_visible(GET_PROPS(S_MONITOR_V_CENTER), use_center);
    return true;
}

bool reload_pads(obs_properties_t *props, obs_property_t *property, void *data)
{
    auto *src = static_cast<input_source *>(data);
    obs_property_list_clear(property);

    if (src->m_settings.use_local_input() && libgamepad::hook_instance) {
        libgamepad::hook_instance->get_mutex()->lock();
        for (const auto &pad : libgamepad::hook_instance->get_devices())
            obs_property_list_add_string(property, pad->get_id().c_str(), pad->get_id().c_str());
        libgamepad::hook_instance->get_mutex()->unlock();
    } else if (io_config::enable_remote_connections) {
        // Add remote gamepads
        std::lock_guard<std::mutex> lock(network::mutex);
        auto client = network::server_instance->get_client(src->m_settings.selected_source);
        if (client) {
            for (const auto &pad : client->gamepads())
                obs_property_list_add_string(property, pad.second->get_id().c_str(), pad.second->get_id().c_str());
        }
    }

    return true;
}

bool file_changed(void *d, obs_properties_t *props, obs_property_t *, obs_data_t *data)
{
    auto *src = static_cast<input_source *>(d);
    const auto *config = obs_data_get_string(data, S_LAYOUT_FILE);
    auto old_image_file = src->m_settings.image_file;
    src->m_settings.image_file = obs_data_get_string(data, S_OVERLAY_FILE);

    /* Only reload config file if path changed */
    if (src->m_settings.layout_file != config || src->m_settings.image_file != old_image_file) {
        src->m_settings.layout_file = config;
        if (!src->m_overlay->load()) {
            src->m_settings.layout_flags = 0;
        }
    }

    auto const &flags = src->m_settings.layout_flags;
    obs_property_set_visible(GET_PROPS(S_CONTROLLER_L_DEAD_ZONE), flags & OF_LEFT_STICK);
    obs_property_set_visible(GET_PROPS(S_CONTROLLER_R_DEAD_ZONE), flags & OF_RIGHT_STICK);
    obs_property_set_visible(GET_PROPS(S_CONTROLLER_ID),
                             flags & OF_GAMEPAD || (flags & OF_LEFT_STICK || flags & OF_RIGHT_STICK));
    obs_property_set_visible(GET_PROPS(S_MOUSE_SENS), flags & OF_MOUSE);
    obs_property_set_visible(GET_PROPS(S_MONITOR_USE_CENTER), flags & OF_MOUSE);
    obs_property_set_visible(GET_PROPS(S_MOUSE_DEAD_ZONE), flags & OF_MOUSE);
    obs_property_set_visible(GET_PROPS(S_RELOAD_PAD_DEVICES), flags & OF_GAMEPAD);
    reload_pads(nullptr, GET_PROPS(S_CONTROLLER_ID), src);

    return true;
}

bool reload_connections(obs_properties_t *, obs_property_t *property, void *)
{
    std::lock_guard<std::mutex> lock(network::mutex);
    network::server_instance->get_clients(property, network::local_input);
    return true;
}

obs_properties_t *get_properties_for_overlay(void *data)
{
    auto *src = static_cast<input_source *>(data);

    QString img_path, layout_path;
    auto *const props = obs_properties_create();
    const int flags = src->m_settings.layout_flags;

    const auto filter_img = util_file_filter(T_FILTER_IMAGE_FILES, "*.jpg *.png *.bmp");
    const auto filter_text = util_file_filter(T_FILTER_TEXT_FILES, "*.json");

    /* Config and texture file path */
    auto *texture = obs_properties_add_path(props, S_OVERLAY_FILE, T_TEXTURE_FILE, OBS_PATH_FILE,
                                            qt_to_utf8(filter_img), qt_to_utf8(img_path));
    auto *cfg = obs_properties_add_path(props, S_LAYOUT_FILE, T_LAYOUT_FILE, OBS_PATH_FILE, qt_to_utf8(filter_text),
                                        qt_to_utf8(layout_path));

    obs_property_set_modified_callback2(cfg, file_changed, data);
    obs_property_set_modified_callback2(texture, file_changed, data);

    /* If enabled add dropdown to select input source */
    if (CGET_BOOL(S_REMOTE)) {
        auto *list = obs_properties_add_list(props, S_INPUT_SOURCE, T_INPUT_SOURCE, OBS_COMBO_TYPE_EDITABLE,
                                             OBS_COMBO_FORMAT_STRING);
        obs_properties_add_button(props, S_RELOAD_CONNECTIONS, T_RELOAD_CONNECTIONS, reload_connections);
        if (network::network_flag) {
            network::server_instance->get_clients(list, network::local_input);
        }
    }
    /* Mouse stuff */
    obs_properties_add_int_slider(props, S_MOUSE_SENS, T_MOUSE_SENS, 1, 500, 1);

    const auto use_center = obs_properties_add_bool(props, S_MONITOR_USE_CENTER, T_MONITOR_USE_CENTER);
    obs_property_set_modified_callback(use_center, use_monitor_center_changed);

    obs_properties_add_int(props, S_MONITOR_H_CENTER, T_MONITOR_H_CENTER, -9999, 9999, 1);
    obs_properties_add_int(props, S_MONITOR_V_CENTER, T_MONITOR_V_CENTER, -9999, 9999, 1);
    obs_properties_add_int_slider(props, S_MOUSE_DEAD_ZONE, T_MOUSE_DEAD_ZONE, 0, 500, 1);

    /* Gamepad stuff */
    obs_property_set_visible(obs_properties_add_list(props, S_CONTROLLER_ID, T_CONTROLLER_ID, OBS_COMBO_TYPE_EDITABLE,
                                                     OBS_COMBO_FORMAT_STRING),
                             false);

    auto *btn = obs_properties_add_button2(props, S_RELOAD_PAD_DEVICES, T_RELOAD_PAD_DEVICES, reload_pads, src);
    obs_property_set_visible(btn, false);

    obs_property_set_visible(GET_PROPS(S_CONTROLLER_L_DEAD_ZONE), flags & OF_LEFT_STICK);
    obs_property_set_visible(GET_PROPS(S_CONTROLLER_R_DEAD_ZONE), flags & OF_RIGHT_STICK);
    obs_property_set_visible(GET_PROPS(S_CONTROLLER_ID),
                             flags & OF_GAMEPAD || (flags & OF_LEFT_STICK || flags & OF_RIGHT_STICK));
    obs_property_set_visible(GET_PROPS(S_MOUSE_SENS), flags & OF_MOUSE);
    obs_property_set_visible(GET_PROPS(S_MONITOR_USE_CENTER), flags & OF_MOUSE);
    obs_property_set_visible(GET_PROPS(S_MOUSE_DEAD_ZONE), flags & OF_MOUSE);
    obs_property_set_visible(GET_PROPS(S_RELOAD_PAD_DEVICES), flags & OF_GAMEPAD);
    reload_pads(nullptr, GET_PROPS(S_CONTROLLER_ID), src);
    return props;
}

void register_overlay_source()
{
    /* Input Overlay */
    obs_source_info si = {};
    si.id = "input-overlay";
    si.type = OBS_SOURCE_TYPE_INPUT;
    si.output_flags = OBS_SOURCE_VIDEO;
    si.get_properties = get_properties_for_overlay;
    si.icon_type = OBS_ICON_TYPE_GAME_CAPTURE;
    si.get_name = [](void *) { return obs_module_text("InputOverlay"); };
    si.create = [](obs_data_t *settings, obs_source_t *source) {
        return static_cast<void *>(new input_source(source, settings));
    };
    si.destroy = [](void *data) { delete static_cast<input_source *>(data); };
    si.get_width = [](void *data) { return static_cast<input_source *>(data)->m_settings.cx; };
    si.get_height = [](void *data) { return static_cast<input_source *>(data)->m_settings.cy; };
    si.get_defaults = [](obs_data_t *settings) { UNUSED_PARAMETER(settings); };
    si.update = [](void *data, obs_data_t *settings) { static_cast<input_source *>(data)->update(settings); };
    si.video_tick = [](void *data, float seconds) { static_cast<input_source *>(data)->tick(seconds); };
    si.video_render = [](void *data, gs_effect_t *effect) { static_cast<input_source *>(data)->render(effect); };
    obs_register_source(&si);
}
}

```

`projects/plugin/src/sources/input_source.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "../util/overlay.hpp"
#include "../util/input_data.hpp"
#include <obs-module.h>
#include <string>

extern "C" {
#include <graphics/image-file.h>
}

typedef struct obs_data obs_data_t;

namespace sources {
class overlay_settings {
public:
    /* clang-format: off */
    std::string image_file;
    std::string layout_file;

    input_data data{};                        /* Copy of input data used for visualization          */
    uint32_t cx = 0, cy = 0;                  /* Source width/height                                */
    bool use_center = false;                  /* true if monitor center is used for mouse movement	*/
    uint32_t monitor_w = 0, monitor_h = 0;    /* Monitor size used for mouse movement               */
    uint8_t mouse_deadzone = 0;               /* Region in which to ignore mouse movements          */
    uint16_t mouse_sens = 0;                  /* mouse_delta / mouse_sens = mouse movement			*/
    std::shared_ptr<gamepad::device> gamepad; /* selected gamepad                                   */

    std::string selected_source;      /* Name of client or empty for local computer         */
    uint8_t layout_flags = 0;         /* See overlay_flags in layout_constants.hpp          */
    float gamepad_check_timer = 0.0f; /* Counter to check if selected game pad is connected */
    std::string gamepad_id;
    /* clang-format: on */

    bool use_local_input();
};

class input_source {
public:
    obs_source_t *m_source = nullptr;

    uint32_t cx = 0, cy = 0;
    std::unique_ptr<overlay> m_overlay{};
    overlay_settings m_settings;

    input_source(obs_source_t *source, obs_data_t *settings);

    ~input_source();

    inline void update(obs_data_t *settings);

    inline void tick(float seconds);

    inline void render(gs_effect_t *effect) const;
};

/* Event handlers */
static bool use_monitor_center_changed(obs_properties_t *props, obs_property_t *p, obs_data_t *data);

static bool file_changed(void *d, obs_properties_t *props, obs_property_t *, obs_data_t *data);

static bool reload_connections(obs_properties_t *props, obs_property_t *property, void *data);

/* For registering */
static obs_properties_t *get_properties_for_overlay(void *data);

void register_overlay_source();
}

```

`projects/plugin/src/util/config.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "config.hpp"
#include "settings.h"
#include "log.h"
#include <QDir>
#include <obs-frontend-api.h>

namespace io_config {
config_t *instance = nullptr;
input_filter io_window_filters; /* Global filters */
std::mutex filter_mutex;        /* Thread safety for writing/reading filters */
bool use_dinput = false;
bool use_js = true;
bool enable_input_control = false;
bool enable_websocket_server = false;
bool enable_remote_connections = false;
bool enable_gamepad_hook = true;
bool enable_uiohook = true;
bool enable_overlay_source = true;
bool regex = false;
bool log_flag = false;
int filter_mode = 0;
uint16_t server_refresh_rate = 250;
uint16_t server_port = 1608;
uint16_t wss_port = 16899;

void set_defaults()
{
    instance = obs_frontend_get_global_config();
    CDEF_BOOL(S_UIOHOOK, enable_uiohook);
    CDEF_BOOL(S_GAMEPAD, enable_gamepad_hook);
    CDEF_BOOL(S_OVERLAY, enable_overlay_source);

    CDEF_BOOL(S_REMOTE, enable_remote_connections);
    CDEF_BOOL(S_LOGGING, log_flag);
    CDEF_INT(S_PORT, server_port);
    CDEF_INT(S_WSS_PORT, wss_port);
    CDEF_BOOL(S_ENABLE_WSS, enable_websocket_server);
    CDEF_INT(S_REFRESH, server_refresh_rate);
    CDEF_INT(S_REFRESH, filter_mode);
    CDEF_BOOL(S_USE_DINPUT, use_dinput);
    CDEF_BOOL(S_USE_JS, use_dinput);
}

void load()
{
    /* Assure that ~/.config folder exists */
    if (!QDir::home().exists(".config") && !QDir::home().mkdir(".config"))
        berr("Couldn't create ~/.config, configuration files won't be saved");

    enable_uiohook = CGET_BOOL(S_UIOHOOK);
    enable_gamepad_hook = CGET_BOOL(S_GAMEPAD);
    enable_remote_connections = CGET_BOOL(S_REMOTE);
    enable_websocket_server = CGET_BOOL(S_ENABLE_WSS);
    enable_input_control = CGET_BOOL(S_CONTROL);
    filter_mode = CGET_INT(S_FILTER_MODE);

    server_port = CGET_INT(S_PORT);
    wss_port = CGET_INT(S_WSS_PORT);
    log_flag = CGET_BOOL(S_LOGGING);
    server_refresh_rate = CGET_INT(S_REFRESH);
    use_dinput = CGET_BOOL(S_USE_DINPUT);
    use_js = CGET_BOOL(S_USE_JS);
}

void save()
{
    /* Window filters are directly saved in formAccept */
    CSET_BOOL(S_UIOHOOK, enable_uiohook);
    CSET_BOOL(S_GAMEPAD, enable_gamepad_hook);
    CSET_BOOL(S_REMOTE, enable_remote_connections);
    CSET_BOOL(S_CONTROL, enable_input_control);
    CSET_BOOL(S_OVERLAY, enable_overlay_source);
    CSET_INT(S_PORT, server_port);
    CSET_INT(S_REFRESH, server_refresh_rate);
    CSET_BOOL(S_LOGGING, log_flag);
    CSET_BOOL(S_REGEX, regex);
    CSET_BOOL(S_USE_DINPUT, use_dinput);
    CSET_BOOL(S_USE_JS, use_js);
    CSET_INT(S_WSS_PORT, wss_port);
    CSET_BOOL(S_ENABLE_WSS, enable_websocket_server);
}

}

```

`projects/plugin/src/util/config.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "input_filter.hpp"
#include <mutex>
#include <util/config-file.h>

#define CDEF_STR(id, value) config_set_default_string(io_config::instance, S_REGION, id, value)
#define CDEF_INT(id, value) config_set_default_int(io_config::instance, S_REGION, id, value)
#define CDEF_UINT(id, value) config_set_default_uint(io_config::instance, S_REGION, id, value)
#define CDEF_BOOL(id, value) config_set_default_bool(io_config::instance, S_REGION, id, value)

#define CGET_STR(id) config_get_string(io_config::instance, S_REGION, id)
#define CGET_INT(id) config_get_int(io_config::instance, S_REGION, id)
#define CGET_UINT(id) config_get_uint(io_config::instance, S_REGION, id)
#define CGET_BOOL(id) config_get_bool(io_config::instance, S_REGION, id)

#define CSET_STR(id, value) config_set_string(io_config::instance, S_REGION, id, value)
#define CSET_INT(id, value) config_set_int(io_config::instance, S_REGION, id, value)
#define CSET_UINT(id, value) config_set_uint(io_config::instance, S_REGION, id, value)
#define CSET_BOOL(id, value) config_set_bool(io_config::instance, S_REGION, id, value)

namespace io_config {
extern config_t *instance;

extern input_filter io_window_filters;
extern std::mutex filter_mutex;

/* Global boolean config values */
extern bool use_dinput;
extern bool use_js;
extern bool enable_input_control;
extern bool enable_remote_connections;
extern bool enable_gamepad_hook;
extern bool enable_uiohook;
extern bool enable_overlay_source;
extern bool enable_websocket_server;
extern bool regex;
extern int filter_mode;
/* Netowork config */
extern bool log_flag;
extern uint16_t server_refresh_rate;
extern uint16_t server_port;
extern uint16_t wss_port;

extern void set_defaults();

extern void load();

extern void save();
}

```

`projects/plugin/src/util/element/element.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "element.hpp"
#include <QJsonArray>

element::element() : m_keycode(0)
{
    m_type = ET_INVALID;
}

element::element(const element_type type) : m_keycode(0), m_type(type) {}

element_type element::get_type() const
{
    return m_type;
}

uint16_t element::get_keycode() const
{
    return m_keycode;
}

void element::read_mapping(const QJsonObject &obj)
{
    auto map = obj[CFG_MAPPING].toArray();
    m_mapping.x = map[0].toInt();
    m_mapping.y = map[1].toInt();
    m_mapping.cx = map[2].toInt();
    m_mapping.cy = map[3].toInt();
}

void element::read_pos(const QJsonObject &obj)
{
    const auto p = obj[CFG_POS].toArray();
    m_pos.x = p[0].toInt();
    m_pos.y = p[1].toInt();
}

```

`projects/plugin/src/util/element/element.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include <graphics/graphics.h>
#include <graphics/vec2.h>
#include <QJsonObject>
#include <layout_constants.h>

typedef struct gs_image_file gs_image_file_t;

namespace sources {
class overlay_settings;
}

class element {
public:
    virtual ~element() = default;

    element();

    element(element_type type);

    virtual void load(const QJsonObject &obj) = 0;

    virtual void draw(gs_effect_t *effect, gs_image_file_t *m_image, sources::overlay_settings *settings) = 0;

    element_type get_type() const;

    uint16_t get_keycode() const;

    virtual void tick(float seconds, sources::overlay_settings *settings) {}

protected:
    void read_mapping(const QJsonObject &obj);

    void read_pos(const QJsonObject &obj);

    vec2 m_pos = {};
    gs_rect m_mapping = {};

    element_type m_type;
    uint16_t m_keycode;
};

```

`projects/plugin/src/util/element/element_analog_stick.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "element_analog_stick.hpp"
#include <keycodes.h>

#include "src/sources/input_source.hpp"

void element_analog_stick::load(const QJsonObject &obj)
{
    element_texture::load(obj);
    m_side = static_cast<element_side>(obj[CFG_SIDE].toInt());
    m_radius = static_cast<uint8_t>(obj[CFG_STICK_RADIUS].toInt());
    m_keycode = VC_STICK_DATA;
    m_pressed = m_mapping;
    m_pressed.y = m_mapping.y + m_mapping.cy + CFG_INNER_BORDER;
}

void element_analog_stick::draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings)
{
    auto pos = m_pos;
    gs_rect *temp;

    if (m_side == element_side::LEFT) {
        pos.y += (settings->data.gamepad_axis[gamepad::axis::LEFT_STICK_Y]) * m_radius * 2;
        pos.x += (settings->data.gamepad_axis[gamepad::axis::LEFT_STICK_X]) * m_radius * 2;
        temp = settings->data.gamepad_buttons[gamepad::button::L_THUMB] ? &m_pressed : &m_mapping;
    } else {
        pos.y += (settings->data.gamepad_axis[gamepad::axis::RIGHT_STICK_Y]) * m_radius * 2;
        pos.x += (settings->data.gamepad_axis[gamepad::axis::RIGHT_STICK_X]) * m_radius * 2;
        temp = settings->data.gamepad_buttons[gamepad::button::R_THUMB] ? &m_pressed : &m_mapping;
    }
    element_texture::draw(effect, image, temp, &pos);
}

```

`projects/plugin/src/util/element/element_analog_stick.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "element_texture.hpp"

enum stick_data_type {
    SD_BOTH,
    SD_PRESSED_STATE_LEFT,
    SD_PRESSED_STATE_RIGHT,
    SD_LEFT_X,
    SD_LEFT_Y,
    SD_RIGHT_X,
    SD_RIGHT_Y
};

class element_analog_stick : public element_texture {
public:
    element_analog_stick() : element_texture(ET_ANALOG_STICK), m_side() {}

    void load(const QJsonObject &obj) override;

    void draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings) override;

private:
    void calc_position(vec2 &v);

    gs_rect m_pressed{};
    element_side m_side;
    uint8_t m_radius = 0;
};

```

`projects/plugin/src/util/element/element_button.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "element_button.hpp"

#include "src/sources/input_source.hpp"

void element_button::load(const QJsonObject &obj)
{
    element_texture::load(obj);
    m_keycode = static_cast<uint16_t>(obj[CFG_KEY_CODE].toInt());
    m_pressed = m_mapping;
    m_pressed.y = m_mapping.y + m_mapping.cy + CFG_INNER_BORDER;
}

void element_keyboard_key::draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings)
{
    if (settings->data.keyboard[m_keycode])
        element_texture::draw(effect, image, &m_pressed);
    else
        element_button::draw(effect, image, nullptr);
}

void element_mouse_button::draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings)
{
    if (settings->data.mouse[m_keycode])
        element_texture::draw(effect, image, &m_pressed);
    else
        element_button::draw(effect, image, nullptr);
}

void element_gamepad_button::draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings)
{
    if (settings->data.gamepad_buttons[m_keycode])
        element_texture::draw(effect, image, &m_pressed);
    else
        element_button::draw(effect, image, nullptr);
}

```

`projects/plugin/src/util/element/element_button.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "element_texture.hpp"
#include <layout_constants.h>

class element_button : public element_texture {
public:
    explicit element_button(element_type t) : element_texture(t), m_pressed() {}

    void load(const QJsonObject &objc) override;
    void draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings) override
    {
        element_texture::draw(effect, image, settings);
    }

protected:
    gs_rect m_pressed;
};

class element_keyboard_key : public element_button {
public:
    element_keyboard_key() : element_button(ET_KEYBOARD_KEY) {}

    void draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings) override;
};

class element_mouse_button : public element_button {
public:
    element_mouse_button() : element_button(ET_MOUSE_BUTTON) {}

    void draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings) override;
};

class element_gamepad_button : public element_button {
public:
    element_gamepad_button() : element_button(ET_GAMEPAD_BUTTON) {}

    void draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings) override;
};

```

`projects/plugin/src/util/element/element_dpad.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "../../sources/input_source.hpp"
#include "element_dpad.hpp"
#include <keycodes.h>

element_dpad::element_dpad() : element_texture(ET_DPAD_STICK) {}

void element_dpad::load(const QJsonObject &obj)
{
    element_texture::load(obj);
    auto i = 1;
    for (auto &map : m_mappings) {
        map = m_mapping;
        map.x += i * (m_mapping.cx + CFG_INNER_BORDER);
        i++;
    }
    m_keycode = VC_DPAD_DATA;
}

inline int get_direction(std::map<uint16_t, bool> &buttons)
{
    if (buttons[gamepad::button::DPAD_UP]) {
        if (buttons[gamepad::button::DPAD_LEFT])
            return element_dpad::TEXTURE_TOP_LEFT;
        if (buttons[gamepad::button::DPAD_RIGHT])
            return element_dpad::TEXTURE_TOP_RIGHT;
        return element_dpad::TEXTURE_UP;
    } else if (buttons[gamepad::button::DPAD_DOWN]) {
        if (buttons[gamepad::button::DPAD_LEFT])
            return element_dpad::TEXTURE_BOTTOM_LEFT;
        if (buttons[gamepad::button::DPAD_RIGHT])
            return element_dpad::TEXTURE_BOTTOM_RIGHT;
        return element_dpad::TEXTURE_DOWN;
    } else if (buttons[gamepad::button::DPAD_RIGHT]) {
        if (buttons[gamepad::button::DPAD_UP])
            return element_dpad::TEXTURE_TOP_RIGHT;
        if (buttons[gamepad::button::DPAD_DOWN])
            return element_dpad::TEXTURE_BOTTOM_RIGHT;
        return element_dpad::TEXTURE_RIGHT;
    } else if (buttons[gamepad::button::DPAD_LEFT]) {
        if (buttons[gamepad::button::DPAD_UP])
            return element_dpad::TEXTURE_TOP_LEFT;
        if (buttons[gamepad::button::DPAD_DOWN])
            return element_dpad::TEXTURE_BOTTOM_LEFT;
        return element_dpad::TEXTURE_LEFT;
    }
    return -1;
}

void element_dpad::draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings)
{
    const auto dir = get_direction(settings->data.gamepad_buttons);

    if (dir >= 0) {
        /* Enum starts at one (Center doesn't count)*/
        const auto map = &m_mappings[dir];
        element_texture::draw(effect, image, map);
    } else {
        element_texture::draw(effect, image, nullptr);
    }
}

```

`projects/plugin/src/util/element/element_dpad.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "element_texture.hpp"

class element_dpad : public element_texture {
public:
    element_dpad();

    void load(const QJsonObject &obj) override;

    void draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings) override;

    enum {
        TEXTURE_LEFT,
        TEXTURE_RIGHT,
        TEXTURE_UP,
        TEXTURE_DOWN,
        TEXTURE_TOP_LEFT,
        TEXTURE_TOP_RIGHT,
        TEXTURE_BOTTOM_LEFT,
        TEXTURE_BOTTOM_RIGHT
    };

private:
    /* Center is in m_mapping */
    gs_rect m_mappings[8]; /* Left, Right, Up, Down, Top Left, Top Right, Bottom Left, Bottom Right */
};

```

`projects/plugin/src/util/element/element_gamepad_id.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "element_gamepad_id.hpp"
#include "element_button.hpp"
#include "../../sources/input_source.hpp"
#include "../../hook/gamepad_hook_helper.hpp"
#include <libgamepad.hpp>

element_gamepad_id::element_gamepad_id() : element_texture(ET_GAMEPAD_ID), m_mappings{}
{
    m_keycode = gamepad::button::GUIDE;
}

void element_gamepad_id::load(const QJsonObject &obj)
{
    element_texture::load(obj);
    auto i = 1;
    for (auto &map : m_mappings) {
        map = m_mapping;
        map.x += i++ * (m_mapping.cx + CFG_INNER_BORDER);
    }
}

void element_gamepad_id::draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings)
{
    if (settings->data.gamepad_buttons[m_keycode])
        element_texture::draw(effect, image, &m_mappings[ID_PRESSED]);

    if (settings->gamepad) {
        if (settings->gamepad->is_valid()) {
            int index = settings->gamepad->get_index() < 4 ? settings->gamepad->get_index() : 0;
            element_texture::draw(effect, image, &m_mappings[index]);
        }
    }
}

```

`projects/plugin/src/util/element/element_gamepad_id.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "element_texture.hpp"

#define ID_PRESSED 3

class element_gamepad_id : public element_texture {
public:
    element_gamepad_id();

    void load(const QJsonObject &obj) override;

    void draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings) override;

private:
    /* 0 - 2 Player 2 - 4 (Player 1 is default)
     * 3     Middle pressed down
     */
    gs_rect m_mappings[4];
};

```

`projects/plugin/src/util/element/element_mouse_movement.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "element_mouse_movement.hpp"
#include "../../sources/input_source.hpp"
#include <keycodes.h>
#include <util.hpp>

element_mouse_movement::element_mouse_movement() : element_texture(ET_MOUSE_MOVEMENT) {}

void element_mouse_movement::load(const QJsonObject &obj)
{
    element_texture::load(obj);
    m_radius = static_cast<uint8_t>(obj[CFG_MOUSE_RADIUS].toInt());
    m_movement_type = obj[CFG_MOUSE_TYPE].toInt() == 1 ? MM_ARROW : MM_DOT;
}

void element_mouse_movement::draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings)
{
    /* TODO: this should probably be two separate classes */
    if (m_movement_type == MM_ARROW) {
        element_texture::draw(effect, image, &m_mapping, &m_pos, m_angle);
    } else {
        element_texture::draw(effect, image, &m_mapping, &m_offset_pos);
    }
}

void element_mouse_movement::tick(float, sources::overlay_settings *settings)
{
    if (m_movement_type == MM_ARROW) {
        m_angle = get_mouse_angle(settings);
    } else {
        get_mouse_offset(settings, m_pos, m_offset_pos, m_radius);
    }
    m_last_x = settings->data.last_mouse_movement.x;
    m_last_y = settings->data.last_mouse_movement.y;
}

float element_mouse_movement::get_mouse_angle(sources::overlay_settings *settings)
{
    auto d_x = 0, d_y = 0;

    if (settings->use_center) {
        d_x = settings->data.last_mouse_movement.x - settings->monitor_h;
        d_y = settings->data.last_mouse_movement.y - settings->monitor_w;
    } else {
        d_x = settings->data.last_mouse_movement.x - m_last_x;
        d_y = settings->data.last_mouse_movement.y - m_last_y;
    }

    const float new_angle = (0.5 * M_PI) + (atan2f(d_y, d_x));
    if (abs(d_x) < settings->mouse_deadzone || abs(d_y) < settings->mouse_deadzone) {
        /* Draw old angle (new movement was to minor) */
        return m_last_angle;
    }

    m_last_angle = new_angle;
    return new_angle;
}

void element_mouse_movement::get_mouse_offset(sources::overlay_settings *settings, const vec2 &center, vec2 &out,
                                              const uint8_t radius) const
{
    auto d_x = 0, d_y = 0;

    if (settings->use_center) {
        d_x = settings->data.last_mouse_movement.x - settings->monitor_h;
        d_y = settings->data.last_mouse_movement.y - settings->monitor_w;
    } else {
        d_x = settings->data.last_mouse_movement.x - m_last_x;
        d_y = settings->data.last_mouse_movement.y - m_last_y;

        if (abs(d_x) < settings->mouse_deadzone)
            d_x = 0;
        if (abs(d_y) < settings->mouse_deadzone)
            d_y = 0;
    }

    const auto factor_x = UTIL_CLAMP(-1, ((double)d_x / settings->mouse_sens), 1);
    const auto factor_y = UTIL_CLAMP(-1, ((double)d_y / settings->mouse_sens), 1);

    out.x = center.x + radius * factor_x;
    out.y = center.y + radius * factor_y;
}

```

`projects/plugin/src/util/element/element_mouse_movement.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "element_texture.hpp"
#include <layout_constants.h>

class element_mouse_movement : public element_texture {
public:
    element_mouse_movement();

    void load(const QJsonObject &obj) override;

    void draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings) override;

    void tick(float seconds, sources::overlay_settings *settings) override;

private:
    float get_mouse_angle(sources::overlay_settings *settings);
    void get_mouse_offset(sources::overlay_settings *settings, const vec2 &center, vec2 &out,
                          const uint8_t radius) const;
    mouse_movement m_movement_type;
    vec2 m_offset_pos = {};
    uint8_t m_radius = 0;
    int m_last_x{}, m_last_y{};
    float m_angle{}, m_last_angle = 0.0f;
};

```

`projects/plugin/src/util/element/element_mouse_wheel.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "element_mouse_wheel.hpp"
#include "src/sources/input_source.hpp"
#include <keycodes.h>

element_wheel::element_wheel() : element_texture(ET_WHEEL), m_mappings{}
{
    /* NO-OP */
}

void element_wheel::load(const QJsonObject &obj)
{
    element_texture::load(obj);
    auto i = 1;
    for (auto &map : m_mappings) {
        map = m_mapping;
        map.x += i * (m_mapping.cx + CFG_INNER_BORDER);
        i++;
    }
}

void element_wheel::draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings)
{
    /* Keep this in order:
     * - first the default state
     * - then the pressed state
     * - and finally on top either up or down
     * this should make sure that all necessary information is visible
     */
    element_texture::draw(effect, image, settings);
    if (settings->data.mouse[MOUSE_BUTTON3])
        element_texture::draw(effect, image, &m_mappings[WHEEL_MAP_MIDDLE]);
    switch (settings->data.last_wheel_event.rotation) {
    case WHEEL_UP:
        element_texture::draw(effect, image, &m_mappings[WHEEL_MAP_UP]);
        break;
    case WHEEL_DOWN:
        element_texture::draw(effect, image, &m_mappings[WHEEL_MAP_DOWN]);
        break;
    default:;
    }
}

```

`projects/plugin/src/util/element/element_mouse_wheel.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "element_texture.hpp"

#define WHEEL_MAP_MIDDLE 0
#define WHEEL_MAP_UP 1
#define WHEEL_MAP_DOWN 2

class element_wheel : public element_texture {
public:
    element_wheel();

    void load(const QJsonObject &obj) override;

    void draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings) override;

private:
    /* Middle, Up, Down */
    gs_rect m_mappings[3];
};

```

`projects/plugin/src/util/element/element_texture.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "element_texture.hpp"

extern "C" {
#include <graphics/image-file.h>
}

element_texture::element_texture() : element(ET_TEXTURE)
{
    /* NO-OP */
}

element_texture::element_texture(const element_type type) : element(type)
{
    /* NO-OP */
}

void element_texture::load(const QJsonObject &obj)
{
    read_pos(obj);
    read_mapping(obj);
}

void element_texture::draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings)
{
    UNUSED_PARAMETER(settings);
    draw(effect, image, &m_mapping, &m_pos);
}

void element_texture::draw(gs_effect_t *effect, gs_image_file_t *image, const gs_rect *rect) const
{
    draw(effect, image, rect ? rect : &m_mapping, &m_pos);
}

void element_texture::draw(gs_effect_t *effect, gs_image_file_t *image, const gs_rect *rect, const vec2 *pos)
{
    gs_matrix_push();
    gs_effect_set_texture(gs_effect_get_param_by_name(effect, "image"), image->texture);
    gs_matrix_translate3f(pos->x, pos->y, 1.f);
    gs_draw_sprite_subregion(image->texture, 0, rect->x, rect->y, rect->cx, rect->cy);
    gs_matrix_pop();
}

void element_texture::draw(gs_effect *effect, gs_image_file_t *image, const gs_rect *rect, const vec2 *pos,
                           const float angle)
{
    gs_effect_set_texture(gs_effect_get_param_by_name(effect, "image"), image->texture);

    gs_matrix_push();
    {
        /* Put into position */
        gs_matrix_translate3f(pos->x, pos->y + rect->cy, 1.f);

        /* Offset to rotation center (I think :P, rotations are tricky) */
        gs_matrix_translate3f(-(rect->cx / 2.f), -(rect->cy / 2.f), 1.f);
        gs_matrix_rotaa4f(0.f, 0.f, 1.f, angle);

        /* Offset back */
        gs_matrix_translate3f(-(rect->cx / 2.f), -(rect->cy / 2.f), 1.f);

        gs_draw_sprite_subregion(image->texture, 0, rect->x, rect->y, rect->cx, rect->cy);
    }
    gs_matrix_pop();
}
```

`projects/plugin/src/util/element/element_texture.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "element.hpp"

class element_texture : public element {
public:
    element_texture();

    explicit element_texture(element_type type);

    void load(const QJsonObject &obj) override;
    void draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings) override;
    void draw(gs_effect_t *effect, gs_image_file_t *image, const gs_rect *rect) const;
    static void draw(gs_effect_t *effect, gs_image_file_t *image, const gs_rect *rect, const vec2 *pos);
    static void draw(gs_effect *effect, gs_image_file_t *image, const gs_rect *rect, const vec2 *pos, float angle);
};

```

`projects/plugin/src/util/element/element_trigger.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "element_trigger.hpp"
#include <keycodes.h>

#include "src/sources/input_source.hpp"

element_trigger::element_trigger() : element_texture(ET_TRIGGER) {}

void element_trigger::load(const QJsonObject &obj)
{
    element_texture::load(obj);
    m_button_mode = obj[CFG_TRIGGER_MODE].toBool();
    m_side = static_cast<element_side>(obj[CFG_SIDE].toInt());
    m_keycode = VC_TRIGGER_DATA;
    m_pressed = m_mapping;
    m_pressed.y = m_mapping.y + m_mapping.cy + CFG_INNER_BORDER;
    if (!m_button_mode)
        m_direction = static_cast<direction>(obj[CFG_DIRECTION].toInt());
}

void element_trigger::draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings)
{
    auto progress = 0.f;

    switch (m_side) {
    case element_side::LEFT:
        progress = settings->data.gamepad_axis[gamepad::axis::LEFT_TRIGGER];
        break;
    case element_side::RIGHT:
        progress = settings->data.gamepad_axis[gamepad::axis::RIGHT_TRIGGER];
        break;
    default:;
    }

    if (m_button_mode) {
        if (progress >= 0.1)
            element_texture::draw(effect, image, &m_pressed);
        else
            element_texture::draw(effect, image, &m_mapping);
    } else {
        auto crop = m_pressed;
        auto new_pos = m_pos;
        calculate_mapping(&crop, &new_pos, progress);
        element_texture::draw(effect, image, &m_mapping); /* Draw unpressed first */
        element_texture::draw(effect, image, &crop, &new_pos);
    }
}

void element_trigger::calculate_mapping(gs_rect *pressed, vec2 *pos, const float progress) const
{
    switch (m_direction) {
    case DIR_UP:
        pressed->cy = static_cast<int>(m_mapping.cy * progress);
        pressed->y = m_pressed.y + (m_mapping.cy - pressed->cy);
        pos->y += m_mapping.cy - pressed->cy;
        break;
    case DIR_DOWN:
        pressed->cy = static_cast<int>(m_mapping.cy * progress);
        break;
    case DIR_LEFT:
        pressed->cx = static_cast<int>(m_mapping.cx * progress);
        pressed->x = m_mapping.x + (m_mapping.cx - pressed->cx);
        pos->x += (m_mapping.cx - pressed->cx);
        break;
    case DIR_RIGHT:
        pressed->cx = static_cast<int>(m_mapping.cx * progress);
        break;
    case DIR_MAX:
    case DIR_NONE:;
    }
}

```

`projects/plugin/src/util/element/element_trigger.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include "element_texture.hpp"

class element_trigger : public element_texture {
public:
    element_trigger();

    void load(const QJsonObject &obj) override;

    void draw(gs_effect_t *effect, gs_image_file_t *image, sources::overlay_settings *settings) override;

private:
    void calculate_mapping(gs_rect *pressed, vec2 *pos, float progress) const;
    gs_rect m_pressed;
    element_side m_side;
    direction m_direction;
    bool m_button_mode = false;
};

```

`projects/plugin/src/util/input_data.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "input_data.hpp"
#include "log.h"

namespace local_data {
std::mutex data_mutex;
input_data data;
}

void input_data::copy(const input_data *other)
{
    keyboard = other->keyboard;
    mouse = other->mouse;
    gamepad_buttons = other->gamepad_buttons;
    gamepad_axis = other->gamepad_axis;
    last_key_pressed = other->last_key_pressed;
    last_key_released = other->last_key_released;
    last_key_typed = other->last_key_typed;
    last_mouse_pressed = other->last_mouse_pressed;
    last_mouse_dragged = other->last_mouse_dragged;
    last_mouse_movement = other->last_mouse_movement;
    last_wheel_event = other->last_wheel_event;
    last_mouse_released = other->last_mouse_released;
    last_axis_event = other->last_axis_event;
    last_button_event = other->last_button_event;
}

void input_data::dispatch_uiohook_event(const uiohook_event *event)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    last_event = *event;

    switch (event->type) {
    case EVENT_KEY_PRESSED:
        last_key_pressed = event->data.keyboard;
        keyboard[event->data.keyboard.keycode] = true;
        break;
    case EVENT_KEY_RELEASED:
        last_key_released = event->data.keyboard;
        keyboard[event->data.keyboard.keycode] = false;
        break;
    case EVENT_KEY_TYPED:
        last_key_typed = event->data.keyboard;
        break;
    case EVENT_MOUSE_WHEEL:
        last_wheel_event = event->data.wheel;
        break;
    case EVENT_MOUSE_PRESSED:
        last_mouse_pressed = event->data.mouse;
        mouse[event->data.mouse.button] = true;
        break;
    case EVENT_MOUSE_RELEASED:
        last_mouse_released = event->data.mouse;
        mouse[event->data.mouse.button] = false;
        break;
    case EVENT_MOUSE_CLICKED:
        last_mouse_clicked = event->data.mouse;
        break;
    case EVENT_MOUSE_DRAGGED:
        last_mouse_dragged = event->data.mouse;
        break;
    case EVENT_MOUSE_MOVED:
        last_mouse_movement = event->data.mouse;
        break;
    default:;
    }
}

```

`projects/plugin/src/util/input_data.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include <map>
#include <mutex>
#include <uiohook.h>
#include <libgamepad.hpp>

/* Holds all input data for a computer, local or remote */
struct input_data {
    std::mutex m_mutex;

    /* State of all keyboard keys*/
    std::map<uint16_t, bool> keyboard{};

    /* State of all mouse buttons */
    std::map<uint16_t, bool> mouse{};

    /* Last uiohook events */
    keyboard_event_data last_key_pressed{}, last_key_released{}, last_key_typed{};
    mouse_event_data last_mouse_pressed{}, last_mouse_released{}, last_mouse_clicked{}, last_mouse_movement{},
        last_mouse_dragged{};
    mouse_wheel_event_data last_wheel_event{};
    uiohook_event last_event{};

    /* Gamepad data */
    std::map<uint16_t, float> gamepad_axis{};
    std::map<uint16_t, bool> gamepad_buttons{};
    gamepad::input_event last_axis_event{};
    gamepad::input_event last_button_event{};

    /* Mutex needs to be locked */
    void copy(const input_data *other);

    void dispatch_uiohook_event(const uiohook_event *event);
};

namespace local_data {
extern std::mutex data_mutex;
extern input_data data;
}

```

`projects/plugin/src/util/input_filter.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "input_filter.hpp"
#include "config.hpp"
#include "obs_util.hpp"
#include "log.h"
#include "settings.h"
#include <QJsonArray>
#include <util/config-file.h>

void input_filter::read_from_config()
{
    io_config::filter_mutex.lock();
    m_filters.clear();
    m_regex = CGET_BOOL(S_REGEX);
    m_whitelist = CGET_INT(S_FILTER_MODE) == 0;
    QJsonDocument j;
    if (!util_open_json(util_get_data_file("filters.json"), j)) {
        berr("Couldn't load filters.json");
        return;
    }

    if (j.isArray()) {
        for (const auto &item : j.array()) {
            if (item.isString()) {
                m_filters.append(item.toString());
            }
        }
    }
    io_config::filter_mutex.unlock();
}

void input_filter::write_to_config()
{
    io_config::filter_mutex.lock();

    QJsonDocument j;
    QJsonArray arr;

    for (const auto &filter : m_filters)
        arr.append(filter);
    j.setArray(arr);
    util_write_json(util_get_data_file("filters.json"), j);
    io_config::filter_mutex.unlock();
}

void input_filter::add_filter(const char *filter)
{
    io_config::filter_mutex.lock();
    m_filters.append(filter);
    io_config::filter_mutex.unlock();
}

void input_filter::remove_filter(const int index)
{
    if (index >= 0 && index < m_filters.size())
        m_filters.removeAt(index);
}

void input_filter::set_regex(bool enabled)
{
    m_regex = enabled;
}

void input_filter::set_whitelist(bool wl)
{
    m_whitelist = wl;
}

bool input_filter::input_blocked()
{
    if (!io_config::enable_input_control)
        return false;

    io_config::filter_mutex.lock();
    std::string current_window;
    auto flag = m_whitelist;
    GetCurrentWindowTitle(current_window);
    const char *window_str = current_window.c_str();

    for (const auto &filter : m_filters) {
        if (filter == window_str) {
            flag = !m_whitelist;
            break;
        }

        if (m_regex) {
            QRegExp regex(filter);
            if (regex.isValid() && regex.exactMatch(current_window.c_str())) {
                flag = !m_whitelist;
                break;
            }
        }
    }
    io_config::filter_mutex.unlock();
    return flag;
}

QStringList &input_filter::filters()
{
    return m_filters;
}

input_filter::~input_filter()
{
    m_filters.clear();
}

```

`projects/plugin/src/util/input_filter.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include <QStringList>

class input_filter {
    QStringList m_filters;
    bool m_regex = false;
    bool m_whitelist = false;

public:
    ~input_filter();

    void read_from_config();

    void write_to_config();

    void add_filter(const char *filter);

    void remove_filter(int index);

    void set_regex(bool enabled);

    void set_whitelist(bool wl);

    bool input_blocked();

    QStringList &filters();
};

```

`projects/plugin/src/util/lang.h`:

```h
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once
/* clang-format off */

/* Misc */
#define T_(v)                           obs_module_text(v)
#define T_LOCAL_SOURCE                  T_("Source.InputSource.Local")
#define T_INPUT_SOURCE                  T_("Source.InputSource")
#define T_RELOAD_CONNECTIONS            T_("Source.InputSource.Reload")
#define T_MENU_OPEN_SETTINGS            T_("Menu.InputOverlay.OpenSettings")
#define T_REFRESH_RATE_TOOLTIP          T_("Dialog.InputOverlay.RemoteRefreshRate.Tooltip")

/* Lang Input Overlay */
#define T_TEXTURE_FILE                  T_("Overlay.Path.Texture")
#define T_LAYOUT_FILE                   T_("Overlay.Path.Layout")
#define T_FILTER_IMAGE_FILES            T_("Filter.ImageFiles")
#define T_FILTER_TEXT_FILES             T_("Filter.TextFiles")
#define T_FILTER_ALL_FILES              T_("Filter.AllFiles")
#define T_RELOAD_PAD_DEVICES            T_("Gamepad.Reload")
#define T_CONTROLLER_ID                 T_("Gamepad.Id")
#define T_CONROLLER_L_DEADZONE          T_("Gamepad.LeftDeadZone")
#define T_CONROLLER_R_DEADZONE          T_("Gamepad.RightDeadZone")
#define T_MOUSE_SENS                    T_("Mouse.Sensitivity")
#define T_MOUSE_DEAD_ZONE               T_("Mouse.Deadzone")
#define T_MONITOR_USE_CENTER            T_("Mouse.UseCenter")
#define T_MONITOR_H_CENTER              T_("Monitor.CenterX")
#define T_MONITOR_V_CENTER              T_("Monitor.CenterY")

/* Lang Input History */
#define T_HISTORY_USE_FALLBACK_NAMES    T_("History.UseFallbackNames")
#define T_HISTORY_KEY_NAME_PATH         T_("History.Path.KeyNames")
#define T_HISTORY_KEY_ICON_PATH         T_("History.Path.Icons.Texture")
#define T_HISTORY_KEY_ICON_CONFIG_PATH  T_("History.Path.Icons.Config")
#define T_HISTORY_ICON_V_SPACE          T_("History.Icons.Space.Vertical")
#define T_HISTORY_ICON_H_SPACE          T_("History.Icons.Space.Horizontal")

#define T_HISTORY_MODE                  T_("History.Mode")
#define T_HISTORY_MODE_TEXT             T_("History.Mode.Text")
#define T_HISTORY_MODE_ICON             T_("History.Mode.Icons")
#define T_HISTORY_COMMAND_MODE          T_("History.Mode.Commands") /* TODO: reimplement? */
#define T_HISTORY_DIRECTION             T_("History.Direction")
#define T_HISTORY_DIRECTION_UP          T_("History.Direction.Up")
#define T_HISTORY_DIRECTION_DOWN        T_("History.Direction.Down")
#define T_HISTORY_DIRECTION_LEFT        T_("History.Direction.Left")
#define T_HISTORY_DIRECTION_RIGHT       T_("History.Direction.Right")

#define T_HISTORY_SHOW_FONT             T_("History.Font.Show")

#define T_HISTORY_DIRECTION             T_("History.Direction")
#define T_HISTORY_HISTORY_SIZE          T_("History.Size")
#define T_HISTORY_FIX_CUTTING           T_("History.FixCutting")
#define T_HISTORY_INCLUDE_MOUSE         T_("History.IncludeMouse")
#define T_HISTORY_INCLUDE_PAD           T_("History.IncludePad")
#define T_HISTORY_CLEAR_HISTORY         T_("History.ClearHistory")

#define T_HISTORY_INTERVAL              T_("History.Update.Interval")
#define T_HISTORY_ENABLE_REPEAT_KEYS    T_("History.Enable.RepeatKeys")
#define T_HISTORY_ENABLE_AUTO_CLEAR     T_("History.Enable.AutoClear")
#define T_HISTORY_AUTO_CLEAR_INTERVAL   T_("History.AutoClear.Interval")

/* clang-format on */

```

`projects/plugin/src/util/log.h`:

```h
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once
#include <obs-module.h>

#define write_log(log_level, format, ...) blog(log_level, "[input-overlay] " format, ##__VA_ARGS__)

#define bdebug(format, ...) write_log(LOG_DEBUG, format, ##__VA_ARGS__)
#define binfo(format, ...) write_log(LOG_INFO, format, ##__VA_ARGS__)
#define bwarn(format, ...) write_log(LOG_WARNING, format, ##__VA_ARGS__)
#define berr(format, ...) write_log(LOG_ERROR, format, ##__VA_ARGS__)

```

`projects/plugin/src/util/obs_util.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "obs_util.hpp"
#include "log.h"
#include "lang.h"
#include <QDir>

QString util_get_data_file(const QString &file_name)
{
    QDir home = QDir::homePath();
#if UNIX
    if (!home.mkpath(".config/input-overlay")) {
        berr("Couldn't create .config/input-overlay directory!");
    }
    home.cd(".config");
    home.cd("input-overlay");
#else
    if (!home.mkpath("input-overlay")) {
        berr("Couldn't create ~/input-overlay directory!");
    }
    home.cd("input-overlay");
#endif
    bdebug("Getting data file in %s", qt_to_utf8(QDir::toNativeSeparators(home.absoluteFilePath(file_name))));
    return QDir::toNativeSeparators(home.absoluteFilePath(file_name));
}

QString util_file_filter(const char *display, const char *formats)
{
    QString filter = display;
    filter += " (";
    filter += formats;
    filter += ");;";
    filter += T_FILTER_ALL_FILES;
    filter += " (*.*)";

    return filter;
}

void util_format_path(QString &path)
{
    path.replace('\\', '/');
    if (path.endsWith('/'))
        path.chop(1);
}

bool util_open_json(const QString &path, QJsonDocument &doc)
{
    QFile file(path);

    if (!file.open(QIODevice::ReadOnly)) {
        berr("couldn't open %s", qt_to_utf8(path));
        return false;
    }

    QJsonParseError err;
    bool result = true;
    doc = QJsonDocument::fromJson(file.readAll(), &err);

    if (err.error != QJsonParseError::NoError) {
        result = false;
        berr("Json parse error for %s: %s", qt_to_utf8(path), qt_to_utf8(err.errorString()));
    }
    return result;
}

bool util_write_json(const QString &path, const QJsonDocument &doc)
{
    QFile file(path);

    if (!file.open(QIODevice::WriteOnly)) {
        berr("couldn't open %s", qt_to_utf8(path));
        return false;
    }

    bool result = true;
    auto data = doc.toJson(QJsonDocument::Indented);
    auto wrote = file.write(data);
    if (wrote != data.length()) {
        berr("Only write %llx out of %i bytes", wrote, data.length());
        result = false;
    }
    return result;
}

```

`projects/plugin/src/util/obs_util.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#include <QJsonDocument>
#include <vector>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* clang-format off */
#define GET_PROPS(S)                    (obs_properties_get(props, S))
#define GET_BOOL(X)                     (obs_data_get_bool(s, X))
/* clang-format on */

#define utf8_to_qt(_str) QString::fromUtf8(_str)
#define qt_to_utf8(_str) _str.toUtf8().constData()

/* Creates string for obs to use as accepted files for a file dialog */
QString util_file_filter(const char *display, const char *formats);

/* Changes slashes in path to fit Unix formatting */
void util_format_path(QString &path);

bool util_open_json(const QString &path, QJsonDocument &doc);

bool util_write_json(const QString &path, const QJsonDocument &doc);

/* Get file path to /home/user/.config/*
 * or C:\Users\user\*
 */
QString util_get_data_file(const QString &file_name);

/* Source:
 * github.com/obsproject/obs-studio/blob/master/UI/frontend-plugins/frontend-tools/auto-scene-switcher-win.cpp
 * github.com/obsproject/obs-studio/blob/master/UI/frontend-plugins/frontend-tools/auto-scene-switcher-nix.cpp
 * github.com/obsproject/obs-studio/blob/master/UI/frontend-plugins/frontend-tools/auto-scene-switcher-osx.mm
 */
extern void GetWindowList(std::vector<std::string> &windows);

extern void GetCurrentWindowTitle(std::string &title);

```

`projects/plugin/src/util/overlay.cpp`:

```cpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#include "overlay.hpp"
#include "../sources/input_source.hpp"
#include "config.hpp"
#include "element/element.hpp"
#include "element/element_analog_stick.hpp"
#include "element/element_button.hpp"
#include "element/element_dpad.hpp"
#include "element/element_gamepad_id.hpp"
#include "element/element_mouse_movement.hpp"
#include "element/element_mouse_wheel.hpp"
#include "element/element_trigger.hpp"
#include "../gui/io_settings_dialog.hpp"
#include "../hook/gamepad_hook_helper.hpp"
#include "log.h"
#include "../network/io_server.hpp"
#include "../network/remote_connection.hpp"
#include "obs_util.hpp"
#include "lang.h"
#include <QFile>
#include <QJsonArray>
#include <QJsonDocument>
#include <layout_constants.h>
extern "C" {
#include <graphics/image-file.h>
}

namespace sources {
class overlay_settings;
}

overlay::~overlay()
{
    unload();
}

overlay::overlay(sources::overlay_settings *settings)
{
    m_settings = settings;
    m_is_loaded = load();
}

bool overlay::load()
{
    unload();
    const auto image_loaded = load_texture();
    m_is_loaded = image_loaded && load_cfg();

    if (!m_is_loaded) {
        m_settings->gamepad = 0;
        if (!image_loaded) {
            m_settings->cx = 100; /* Default size */
            m_settings->cy = 100;
        }
    }

    return m_is_loaded;
}

void overlay::unload()
{
    unload_texture();
    unload_elements();
    m_settings->cx = 100;
    m_settings->cy = 100;
}

bool overlay::load_cfg()
{
    if (!m_settings || m_settings->layout_file.empty())
        return false;

    QFile file(m_settings->layout_file.c_str());

    if (!file.open(QIODevice::ReadOnly)) {
        blog(LOG_ERROR, "[input-overlay] couldn't open config file");
        return false;
    }

    QJsonParseError err;
    const auto cfg_doc = QJsonDocument::fromJson(file.readAll(), &err);
    auto cfg_obj = cfg_doc.object();
    const auto flag = true;

    if (err.error == QJsonParseError::NoError) {
        m_settings->cx = static_cast<uint32_t>(cfg_obj[CFG_TOTAL_WIDTH].toInt());
        m_settings->cy = static_cast<uint32_t>(cfg_obj[CFG_TOTAL_HEIGHT].toInt());
        m_settings->layout_flags = static_cast<uint8_t>(cfg_obj[CFG_FLAGS].toInt());

        const auto debug_mode = cfg_obj[CFG_DEBUG_FLAG].toBool();

#ifndef _DEBUG
        if (debug_mode) {
#else
        {
#endif
            binfo("Started loading of %s", m_settings->layout_file.c_str());
        }

        auto arr = cfg_obj[CFG_ELEMENTS].toArray();

        for (const auto element : arr)
            load_element(element.toObject(), debug_mode);
    } else {
        berr("Couldn't load layout from %s. Error: %s", m_settings->layout_file.c_str(), qt_to_utf8(err.errorString()));
    }

    return flag;
}

bool overlay::load_texture()
{
    if (!m_settings || m_settings->image_file.empty())
        return false;

    auto flag = true;

    if (m_image == nullptr) {
        m_image = new gs_image_file_t();
    }

    gs_image_file_init(m_image, m_settings->image_file.c_str());

    obs_enter_graphics();
    gs_image_file_init_texture(m_image);
    obs_leave_graphics();

    if (!m_image->loaded) {
        bwarn("Error: failed to load texture %s", m_settings->image_file.c_str());
        flag = false;
    } else {
        m_settings->cx = m_image->cx;
        m_settings->cy = m_image->cy;
    }

    return flag;
}

void overlay::unload_texture() const
{
    obs_enter_graphics();
    gs_image_file_free(m_image);
    obs_leave_graphics();
}

void overlay::unload_elements()
{
    m_elements.clear();
}

void overlay::draw(gs_effect_t *effect)
{
    if (m_is_loaded) {
        for (auto const &element : m_elements) {
            element->draw(effect, m_image, m_settings);
        }
    }
}

void overlay::tick(float seconds)
{
    if (m_is_loaded) {
        for (auto const &element : m_elements) {
            element->tick(seconds, m_settings);
        }
    }
}

void overlay::refresh_data()
{
    /* This copies over necessary input data information
     * to make sure the overlay always has data available to
     * draw the overlay. If the data was directly accessed in the render
     * method, the overlay can start to flicker if the frame is rendered
     * while the data is currently inaccessible, because it is being written
     * to by the input thread, resulting in all buttons being unpressed
     */
    if (io_config::io_window_filters.input_blocked())
        return;
    input_data *source = nullptr;
    std::mutex *m = nullptr;
    std::shared_ptr<network::io_client> client = nullptr; // Holds the reference until we've copied the data
    if (uiohook::state || network::network_flag || libgamepad::state) {
        if (network::server_instance && !m_settings->use_local_input()) {
            client = network::server_instance->get_client(m_settings->selected_source);
            if (client && client->valid()) {
                source = client->get_data();
                m = &network::mutex;
            }
        } else {
            source = &local_data::data;
            m = &local_data::data_mutex;
        }
    }

    if (m && source) {
        // copy over data from gamepad into the input data structure
        auto copy = [](input_data *source, std::shared_ptr<gamepad::device> d) {
            source->last_axis_event = *d->last_axis_event();
            source->last_button_event = *d->last_button_event();
            source->gamepad_axis = d->get_axis();
            source->gamepad_buttons = d->get_buttons();
        };

        if (m_settings->use_local_input()) {
            if (libgamepad::hook_instance && m_settings->gamepad) {
                libgamepad::hook_instance->get_mutex()->lock();
                copy(source, m_settings->gamepad);
                libgamepad::hook_instance->get_mutex()->unlock();
            }
            m->lock();
            m_settings->data.copy(source);
            if (uiohook::state)
                uiohook::check_wheel();
            m->unlock();
        } else {
            m->lock();
            if (m_settings->gamepad)
                copy(source, m_settings->gamepad);
            m_settings->data.copy(source);
            m->unlock();
        }
    }
}

void overlay::load_element(const QJsonObject &obj, const bool debug)
{
    const auto type = obj[CFG_TYPE].toInt();
    element *new_element = nullptr;

    switch (type) {
    case ET_TEXTURE:
        new_element = new element_texture;
        break;
    case ET_GAMEPAD_ID:
        new_element = new element_gamepad_id;
        break;
    case ET_KEYBOARD_KEY:
        new_element = new element_keyboard_key;
        break;
    case ET_MOUSE_BUTTON:
        new_element = new element_mouse_button;
        break;
    case ET_GAMEPAD_BUTTON:
        new_element = new element_gamepad_button;
        break;
    case ET_WHEEL:
        new_element = new element_wheel;
        break;
    case ET_TRIGGER:
        new_element = new element_trigger;
        break;
    case ET_ANALOG_STICK:
        new_element = new element_analog_stick;
        break;
    case ET_DPAD_STICK:
        new_element = new element_dpad;
        break;
    case ET_MOUSE_MOVEMENT:
        new_element = new element_mouse_movement;
        break;
    default:
        if (debug)
            binfo("Invalid element type %i for %s", type, qt_to_utf8(obj[CFG_ID].toString()));
    }

    if (new_element) {
        new_element->load(obj);
        m_elements.emplace_back(new_element);

#ifndef _DEBUG
        if (debug) {
#else
        {
#endif
            binfo("Type: %14s, KEYCODE: 0x%04X ID: %s", element_type_to_string(static_cast<element_type>(type)),
                  new_element->get_keycode(), qt_to_utf8(obj[CFG_ID].toString()));
        }
    }
}

const char *overlay::element_type_to_string(const element_type t)
{
    switch (t) {
    case ET_TEXTURE:
        return "Texture";
    case ET_KEYBOARD_KEY:
        return "Keyboard key";
    case ET_MOUSE_BUTTON:
        return "Mouse button";
    case ET_GAMEPAD_BUTTON:
        return "Gamepad button";
    case ET_ANALOG_STICK:
        return "Analog stick";
    case ET_WHEEL:
        return "Scroll wheel";
    case ET_MOUSE_MOVEMENT:
        return "Mouse movement";
    case ET_TRIGGER:
        return "Trigger";
    case ET_GAMEPAD_ID:
        return "Gamepad ID";
    case ET_DPAD_STICK:
        return "DPad";
    default:
    case ET_INVALID:
        return "Invalid";
    }
}

```

`projects/plugin/src/util/overlay.hpp`:

```hpp
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once

#ifdef LINUX
#include <stdint.h>
#endif

#include "../hook/uiohook_helper.hpp"
#include "element/element.hpp"
#include <memory>
#include <vector>

class ccl_config;

typedef struct gs_image_file gs_image_file_t;

class overlay {
public:
    overlay() = default;
    ~overlay();
    explicit overlay(sources::overlay_settings *settings);
    bool load();
    void unload();
    void draw(gs_effect_t *effect);
    void tick(float seconds);
    void refresh_data();
    bool is_loaded() const { return m_is_loaded; }
    gs_image_file_t *get_texture() const { return m_image; }

private:
    bool load_cfg();
    bool load_texture();
    void unload_texture() const;
    void unload_elements();
    void load_element(const QJsonObject &obj, bool debug);

    static const char *element_type_to_string(element_type t);

    gs_image_file_t *m_image = nullptr;
    sources::overlay_settings *m_settings = nullptr;
    bool m_is_loaded = false;
    std::vector<std::unique_ptr<element>> m_elements;
    uint16_t m_track_radius{};
    uint16_t m_max_mouse_movement{};
    float m_arrow_rot = 0.f;
};

```

`projects/plugin/src/util/settings.h`:

```h
/*************************************************************************
 * This file is part of input-overlay
 * github.con/univrsal/input-overlay
 * Copyright 2022 univrsal <uni@vrsal.xyz>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************/

#pragma once
/* clang-format off */

/* Settings values*/
#define S_REGION                        "input-overlay"
#define S_UIOHOOK                       "iohook"
#define S_USE_DINPUT                    "use_dinput"
#define S_USE_JS                        "use_js"
#define S_GAMEPAD                       "gamepad"
#define S_OVERLAY                       "overlay"
#define S_HISTORY                       "history"
#define S_REMOTE                        "remote"
#define S_LOGGING                       "logging"
#define S_PORT                          "server_port"
#define S_WSS_PORT                      "wss_port"
#define S_ENABLE_WSS                    "enable_wss"
#define S_REFRESH                       "server_refresh_rate"
#define S_CONTROL                       "control"
#define S_REGEX                         "regex"
#define S_FILTER_MODE                   "filter_mode"

/* Misc values */
#define S_INPUT_SOURCE                  "io.input_source"
#define S_RELOAD_CONNECTIONS            "io.reload_connections"

/* overlay source */
#define S_OVERLAY_FILE                  "io.overlay_image"
#define S_LAYOUT_FILE                   "io.layout_file"
#define S_CONTROLLER_ID                 "io.controller_id"
#define S_CONTROLLER_L_DEAD_ZONE        "io.controller_l_deadzone"
#define S_CONTROLLER_R_DEAD_ZONE        "io.controller_r_deadzone"
#define S_MOUSE_SENS                    "io.mouse_sens"
#define S_MOUSE_DEAD_ZONE               "io.mouse_deadzone"
#define S_MONITOR_USE_CENTER            "io.monitor_use_center"
#define S_MONITOR_H_CENTER              "io.monitor_h_center"
#define S_MONITOR_V_CENTER              "io.monitor_v_center"
#define S_RELOAD_PAD_DEVICES            "io.reload_pads"

/* History source */
#define S_HISTORY_SIZE                  "io.history_size"
#define S_HISTORY_FIX_CUTTING           "io.fix_cutting"
#define S_HISTORY_INCLUDE_MOUSE         "io.include_mouse"
#define S_HISTORY_INCLUDE_PAD           "io.include_pad"
#define S_HISTORY_INTERVAL              "io.interval"
#define S_HISTORY_CLEAR_HISTORY         "io.clear_history"
#define S_HISTORY_ENABLE_REPEAT_KEYS    "io.repeat_keys"
#define S_HISTORY_ENABLE_AUTO_CLEAR     "io.auto_clear"
#define S_HISTORY_AUTO_CLEAR_INTERVAL   "io.auto_clear_interval"
#define S_HISTORY_ICON_V_SPACE          "io.icon_v_space"
#define S_HISTORY_ICON_H_SPACE          "io.icon_h_space"

#define S_HISTORY_MODE                  "io.mode"
#define S_HISTORY_KEY_NAME_PATH         "io.key_name_path"
#define S_HISTORY_USE_FALLBACK_NAME     "io.use_fallback_names"
#define S_HISTORY_DIRECTION             "io.direction"
#define S_HISTORY_DIRECTION_UP          "io.up"
#define S_HISTORY_DIRECTION_DOWN        "io.down"
#define S_HISTORY_DIRECTION_LEFT        "io.left"
#define S_HISTORY_DIRECTION_RIGHT       "io.right"

#define S_HISTORY_KEY_ICON_PATH         "io.key_icon_path"
#define S_HISTORY_KEY_ICON_CONFIG_PATH  "io.key_icon_config"

#define S_HISTORY_SHOW_FONT             "io.show_font"
/* Linux gamepad bindings TODO: Maybe for windows as well? */
#define S_BINDING_A                     "binding_a"
#define S_BINDING_B                     "binding_b"
#define S_BINDING_X                     "binding_x"
#define S_BINDING_Y                     "binding_y"
#define S_BINDING_START                 "binding_start"
#define S_BINDING_BACK                  "binding_back"
#define S_BINDING_GUIDE                 "binding_guide"
#define S_BINDING_RB                    "binding_rb"
#define S_BINDING_LB                    "binding_lb"
#define S_BINDING_RT                    "binding_rt"
#define S_BINDING_LT                    "binding_lt"
#define S_BINDING_DPAD_UP               "binding_dpad_up"
#define S_BINDING_DPAD_DOWN             "binding_dpad_down"
#define S_BINDING_DPAD_LEFT             "binding_dpad_left"
#define S_BINDING_DPAD_RIGHT            "binding_dpad_right"
#define S_BINDING_ANALOG_L              "binding_analog_l"
#define S_BINDING_ANALOG_R              "binding_analog_r"
#define S_BINDING_ANALOG_LX             "binding_analog_lx"
#define S_BINDING_ANALOG_LY             "binding_analog_ly"
#define S_BINDING_ANALOG_RX             "binding_analog_rx"
#define S_BINDING_ANALOG_RY             "binding_analog_ry"

/* clang-format on */

```

`projects/plugin/src/util/window_helper.hpp`:

```hpp
/**
 * This file is part of obs-studio
 * which is licensed under the GPL 2.0
 * See COPYING or https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
 * https://github.com/obsproject/obs-studio/blob/master/UI/frontend-plugins/frontend-tools/auto-scene-switcher.hpp
 */

#pragma once

#include <string>
#include <vector>

void GetWindowList(std::vector<std::string> &windows);

void GetCurrentWindowTitle(std::string &title);

```

`projects/plugin/src/util/window_helper_nix.cpp`:

```cpp
/**
 * This file is part of obs-studio
 * which is licensed under the GPL 2.0
 * See COPYING or https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
 * https://github.com/obsproject/obs-studio/blob/master/UI/frontend-plugins/frontend-tools/auto-scene-switcher-nix.cpp
 */

#include "window_helper.hpp"
#include <X11/Xatom.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <util/platform.h>

#undef Bool
#undef CursorShape
#undef Expose
#undef KeyPress
#undef KeyRelease
#undef FocusIn
#undef FocusOut
#undef FontChange
#undef None
#undef Status
#undef Unsorted

using namespace std;

static Display *xdisplay = nullptr;

Display *disp()
{
    if (!xdisplay)
        xdisplay = XOpenDisplay(nullptr);

    return xdisplay;
}

void cleanupDisplay()
{
    if (!xdisplay)
        return;

    XCloseDisplay(xdisplay);
    xdisplay = nullptr;
}

static bool ewmhIsSupported()
{
    Display *display = disp();
    Atom netSupportingWmCheck = XInternAtom(display, "_NET_SUPPORTING_WM_CHECK", true);
    Atom actualType;
    int format = 0;
    unsigned long num = 0, bytes = 0;
    unsigned char *data = nullptr;
    Window ewmh_window = 0;

    int status = XGetWindowProperty(display, DefaultRootWindow(display), netSupportingWmCheck, 0L, 1L, false, XA_WINDOW,
                                    &actualType, &format, &num, &bytes, &data);

    if (status == Success) {
        if (num > 0) {
            ewmh_window = ((Window *)data)[0];
        }
        if (data) {
            XFree(data);
            data = nullptr;
        }
    }

    if (ewmh_window) {
        status = XGetWindowProperty(display, ewmh_window, netSupportingWmCheck, 0L, 1L, false, XA_WINDOW, &actualType,
                                    &format, &num, &bytes, &data);
        if (status != Success || num == 0 || ewmh_window != ((Window *)data)[0]) {
            ewmh_window = 0;
        }
        if (status == Success && data) {
            XFree(data);
        }
    }

    return ewmh_window != 0;
}

static std::vector<Window> getTopLevelWindows()
{
    std::vector<Window> res;

    res.resize(0);

    if (!ewmhIsSupported()) {
        return res;
    }

    Atom netClList = XInternAtom(disp(), "_NET_CLIENT_LIST", true);
    Atom actualType;
    int format;
    unsigned long num, bytes;
    Window *data = 0;

    for (int i = 0; i < ScreenCount(disp()); ++i) {
        Window rootWin = RootWindow(disp(), i);

        int status = XGetWindowProperty(disp(), rootWin, netClList, 0L, ~0L, false, AnyPropertyType, &actualType,
                                        &format, &num, &bytes, (uint8_t **)&data);

        if (status != Success) {
            continue;
        }

        for (unsigned long i = 0; i < num; ++i)
            res.emplace_back(data[i]);

        XFree(data);
    }

    return res;
}

static std::string GetWindowTitle(size_t i)
{
    Window w = getTopLevelWindows().at(i);
    std::string windowTitle;
    char *name;

    int status = XFetchName(disp(), w, &name);
    if (status >= Success && name != nullptr) {
        std::string str(name);
        windowTitle = str;
    }

    XFree(name);

    return windowTitle;
}

void GetWindowList(vector<string> &windows)
{
    windows.resize(0);

    for (size_t i = 0; i < getTopLevelWindows().size(); ++i) {
        if (!GetWindowTitle(i).empty())
            windows.emplace_back(GetWindowTitle(i));
    }
}

void GetCurrentWindowTitle(string &title)
{
    if (!ewmhIsSupported()) {
        return;
    }

    Atom active = XInternAtom(disp(), "_NET_ACTIVE_WINDOW", true);
    Atom actualType;
    int format;
    unsigned long num, bytes;
    Window *data = 0;
    char *name;

    Window rootWin = RootWindow(disp(), 0);

    XGetWindowProperty(disp(), rootWin, active, 0L, ~0L, false, AnyPropertyType, &actualType, &format, &num, &bytes,
                       (uint8_t **)&data);

    int status = XFetchName(disp(), data[0], &name);

    if (status >= Success && name != nullptr) {
        std::string str(name);
        title = str;
    }

    XFree(name);
}

```

`projects/plugin/src/util/window_helper_win.cpp`:

```cpp
/**
 * This file is part of obs-studio
 * which is licensed under the GPL 2.0
 * See COPYING or https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
 * https://github.com/obsproject/obs-studio/blob/master/UI/frontend-plugins/frontend-tools/auto-scene-switcher-win.cpp
 */

#include "window_helper.hpp"
#include <util/platform.h>
#include <windows.h>

using namespace std;

static bool GetWindowTitle(HWND window, string &title)
{
    size_t len = (size_t)GetWindowTextLengthW(window);
    wstring wtitle;

    wtitle.resize(len);
    if (!GetWindowTextW(window, &wtitle[0], (int)len + 1))
        return false;

    len = os_wcs_to_utf8(wtitle.c_str(), 0, nullptr, 0);
    title.resize(len);
    os_wcs_to_utf8(wtitle.c_str(), 0, &title[0], len + 1);
    return true;
}

static bool WindowValid(HWND window)
{
    LONG_PTR styles, ex_styles;
    RECT rect;
    DWORD id;

    if (!IsWindowVisible(window))
        return false;
    GetWindowThreadProcessId(window, &id);
    if (id == GetCurrentProcessId())
        return false;

    GetClientRect(window, &rect);
    styles = GetWindowLongPtr(window, GWL_STYLE);
    ex_styles = GetWindowLongPtr(window, GWL_EXSTYLE);

    if (ex_styles & WS_EX_TOOLWINDOW)
        return false;
    if (styles & WS_CHILD)
        return false;

    return true;
}

void GetWindowList(vector<string> &windows)
{
    HWND window = GetWindow(GetDesktopWindow(), GW_CHILD);

    while (window) {
        string title;
        if (WindowValid(window) && GetWindowTitle(window, title))
            windows.emplace_back(title);
        window = GetNextWindow(window, GW_HWNDNEXT);
    }
}

void GetCurrentWindowTitle(string &title)
{
    HWND window = GetForegroundWindow();
    DWORD id;

    GetWindowThreadProcessId(window, &id);
    if (id == GetCurrentProcessId()) {
        title = "";
        return;
    }
    GetWindowTitle(window, title);
}

```

`projects/presets/README.md`:

```md
# These are the presets made for version 5.0 and up

These are only the latest preset versions.
You should always use the presets shipped with the version you downloaded.

```

`projects/presets/arcade-stick/arcade-stick.json`:

```json
{
    "default_height": 256,
    "default_width": 256,
    "elements": [
        {
            "id": "dpad",
            "mapping": [
                1,
                1,
                256,
                256
            ],
            "pos": [
                0,
                0
            ],
            "type": 8,
            "z_level": 1
        }
    ],
    "flags": 4,
    "overlay_height": 256,
    "overlay_width": 256,
    "space_h": 0,
    "space_v": 0
}
```

`projects/presets/dualsense/CREDITS.md`:

```md
# Credits
Original images from xelu's free controller and key prompt pack available in
the public domain under Creative Commons 0 (CC0) at
https://thoseawesomeguys.com/prompts/ 

Preset by Caro

```

`projects/presets/dualsense/dualsense.json`:

```json
{
    "default_width": 0,
    "default_height": 0,
    "space_h": 0,
    "space_v": 0,
    "flags": 6,
    "overlay_width": 1344,
    "overlay_height": 788,
    "elements": [
        {
            "type": 5,
            "pos": [
                389,
                517
            ],
            "id": "analog stick1",
            "z_level": 1,
            "mapping": [
                1359,
                1,
                157,
                156
            ],
            "stick_radius": 30,
            "side": 0
        },
        {
            "type": 5,
            "pos": [
                810,
                516
            ],
            "id": "analog stick2",
            "z_level": "5",
            "mapping": [
                1359,
                1,
                157,
                156
            ],
            "stick_radius": 30,
            "side": 1
        },
        {
            "type": 2,
            "pos": [
                1047,
                431
            ],
            "id": "gamepad button3",
            "z_level": 1,
            "mapping": [
                0,
                792,
                99,
                91
            ],
            "code": 60416
        },
        {
            "type": 2,
            "pos": [
                946,
                349
            ],
            "id": "gamepad button4",
            "z_level": "1",
            "mapping": [
                102,
                793,
                98,
                90
            ],
            "code": 60418
        },
        {
            "type": 8,
            "pos": [
                136,
                281
            ],
            "id": "dpad5",
            "z_level": "1",
            "mapping": [
                1,
                1013,
                229,
                220
            ]
        },
        {
            "type": 2,
            "pos": [
                1050,
                257
            ],
            "id": "gamepad button6",
            "z_level": "1",
            "mapping": [
                203,
                792,
                99,
                91
            ],
            "code": 60419
        },
        {
            "type": 2,
            "pos": [
                1150,
                345
            ],
            "id": "gamepad button7",
            "z_level": "1",
            "mapping": [
                305,
                792,
                98,
                90
            ],
            "code": 60417
        },
        {
            "type": 0,
            "pos": [
                0,
                0
            ],
            "id": "texture0",
            "z_level": "0",
            "mapping": [
                1,
                1,
                1344,
                788
            ]
        },
        {
            "type": 2,
            "pos": [
                146,
                75
            ],
            "id": "gamepad button8",
            "z_level": "1",
            "mapping": [
                409,
                792,
                206,
                108
            ],
            "code": 60420
        },
        {
            "type": 2,
            "pos": [
                992,
                75
            ],
            "id": "gamepad button9",
            "z_level": "1",
            "mapping": [
                618,
                792,
                206,
                108
            ],
            "code": 60421
        },
        {
            "type": 2,
            "pos": [
                332,
                225
            ],
            "id": "gamepad button10",
            "z_level": "1",
            "mapping": [
                874,
                792,
                45,
                66
            ],
            "code": 60422
        },
        {
            "type": 2,
            "pos": [
                968,
                225
            ],
            "id": "gamepad button11",
            "z_level": "1",
            "mapping": [
                827,
                792,
                44,
                66
            ],
            "code": 60423
        },
        {
            "type": 6,
            "pos": [
                990,
                0
            ],
            "id": "trigger12",
            "z_level": 1,
            "mapping": [
                922,
                792,
                187,
                104
            ],
            "direction": 1,
            "trigger_mode": false,
            "side": 1
        },
        {
            "type": 6,
            "pos": [
                167,
                0
            ],
            "id": "trigger13",
            "z_level": "1",
            "mapping": [
                1112,
                792,
                187,
                104
            ],
            "direction": 1,
            "trigger_mode": false,
            "side": 0
        }
    ]
}
```

`projects/presets/gamecube/CREDITS.md`:

```md
# Credits

The gamecube button textures used for this layout were borrowed from [m-overlay](https://github.com/bkacjios/m-overlay). Copyright and courtesy of Bkacjios, 2020.

```

`projects/presets/gamecube/gamecube.json`:

```json
{
    "default_width": 355,
    "default_height": 285,
    "space_h": 1,
    "space_v": 1,
    "flags": 6,
    "overlay_width": 356,
    "overlay_height": 286,
    "elements": [
        {
            "type": 0,
            "pos": [
                1,
                1
            ],
            "id": "gamepad",
            "z_level": "0",
            "mapping": [
                0,
                0,
                355,
                285
            ]
        },
        {
            "type": 2,
            "pos": [
                290,
                97
            ],
            "id": "x",
            "z_level": 1,
            "mapping": [
                256,
                291,
                38,
                62
            ],
            "code": 1
        },
        {
            "type": 2,
            "pos": [
                211,
                103
            ],
            "id": "a",
            "z_level": 1,
            "mapping": [
                96,
                291,
                84,
                84
            ],
            "code": 2
        },
        {
            "type": 2,
            "pos": [
                193,
                181
            ],
            "id": "b",
            "z_level": 1,
            "mapping": [
                303,
                291,
                42,
                42
            ],
            "code": 3
        },
        {
            "type": 2,
            "pos": [
                206,
                69
            ],
            "id": "y",
            "z_level": 1,
            "mapping": [
                353,
                366,
                62,
                39
            ],
            "code": 4
        },
        {
            "type": 6,
            "pos": [
                7,
                40
            ],
            "id": "l-trigger",
            "z_level": 1,
            "mapping": [
                93,
                476,
                104,
                16
            ],
            "direction": 3,
            "trigger_mode": false,
            "side": 0
        },
        {
            "type": 6,
            "pos": [
                209,
                40
            ],
            "id": "r-trigger",
            "z_level": 1,
            "mapping": [
                93,
                476,
                104,
                16
            ],
            "direction": 4,
            "trigger_mode": false,
            "side": 1
        },
        {
            "type": 2,
            "pos": [
                238,
                3
            ],
            "id": "z",
            "z_level": 1,
            "mapping": [
                303,
                386,
                43,
                33
            ],
            "code": 8
        },
        {
            "type": 2,
            "pos": [
                150,
                119
            ],
            "id": "start",
            "z_level": 1,
            "mapping": [
                354,
                291,
                32,
                32
            ],
            "code": 16
        },
        {
            "type": 8,
            "pos": [
                67,
                196
            ],
            "id": "d-pad",
            "z_level": 1,
            "mapping": [
                2,
                554,
                76,
                76
            ]
        },
        {
            "type": 5,
            "pos": [
                25,
                88
            ],
            "id": "analog",
            "z_level": 1,
            "mapping": [
                3,
                291,
                84,
                84
            ],
            "stick_radius": 20,
            "side": 0
        },
        {
            "type": 5,
            "pos": [
                277,
                206
            ],
            "id": "c-stick",
            "z_level": 1,
            "mapping": [
                188,
                291,
                58,
                58
            ],
            "stick_radius": 20,
            "side": 1
        }
    ]
}
```

`projects/presets/gamepad/game-pad.json`:

```json
{
    "default_height": 0,
    "default_width": 0,
    "elements": [
        {
            "id": "body",
            "mapping": [
                1,
                1,
                1280,
                926
            ],
            "pos": [
                0,
                0
            ],
            "type": 0,
            "z_level": 0
        },
        {
            "code": 60416,
            "id": "a",
            "mapping": [
                838,
                930,
                94,
                94
            ],
            "pos": [
                953,
                311
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "code": 60417,
            "id": "b",
            "mapping": [
                741,
                930,
                94,
                94
            ],
            "pos": [
                1051,
                213
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "code": 60419,
            "id": "y",
            "mapping": [
                644,
                930,
                94,
                94
            ],
            "pos": [
                953,
                116
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "code": 60418,
            "id": "x",
            "mapping": [
                547,
                930,
                94,
                94
            ],
            "pos": [
                856,
                214
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "code": 60422,
            "id": "select",
            "mapping": [
                389,
                930,
                76,
                63
            ],
            "pos": [
                466,
                185
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "code": 60423,
            "id": "start",
            "mapping": [
                468,
                930,
                76,
                63
            ],
            "pos": [
                737,
                185
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "code": 60420,
            "id": "ls",
            "mapping": [
                1,
                930,
                148,
                70
            ],
            "pos": [
                170,
                14
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "code": 60421,
            "id": "rs",
            "mapping": [
                152,
                930,
                148,
                70
            ],
            "pos": [
                962,
                13
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "code": 60435,
            "id": "dpad_up",
            "mapping": [
                717,
                1134,
                43,
                42
            ],
            "pos": [
                430,
                376
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "code": 60436,
            "id": "dpad_down",
            "mapping": [
                717,
                1134,
                42,
                42
            ],
            "pos": [
                430,
                515
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "code": 60433,
            "id": "dpad_left",
            "mapping": [
                717,
                1134,
                42,
                42
            ],
            "pos": [
                360,
                445
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "code": 60434,
            "id": "dpad_right",
            "mapping": [
                717,
                1134,
                42,
                42
            ],
            "pos": [
                498,
                444
            ],
            "type": 2,
            "z_level": 1
        },
        {
            "direction": 1,
            "id": "lt",
            "mapping": [
                303,
                930,
                40,
                44
            ],
            "pos": [
                224,
                0
            ],
            "side": 0,
            "trigger_mode": false,
            "type": 6,
            "z_level": 1
        },
        {
            "direction": 1,
            "id": "rt",
            "mapping": [
                346,
                930,
                40,
                44
            ],
            "pos": [
                1016,
                0
            ],
            "side": 1,
            "trigger_mode": false,
            "type": 6,
            "z_level": 1
        },
        {
            "id": "left_analog_stick",
            "mapping": [
                938,
                930,
                128,
                128
            ],
            "pos": [
                210,
                164
            ],
            "side": 0,
            "stick_radius": 40,
            "type": 5,
            "z_level": 1
        },
        {
            "id": "right_analog_stick",
            "mapping": [
                938,
                930,
                128,
                128
            ],
            "pos": [
                763,
                396
            ],
            "side": 1,
            "stick_radius": 40,
            "type": 5,
            "z_level": 1
        },
        {
            "id": "guide",
            "mapping": [
                1,
                1134,
                140,
                141
            ],
            "pos": [
                570,
                163
            ],
            "type": 7,
            "z_level": 1
        }
    ],
    "flags": 6,
    "overlay_height": 926,
    "overlay_width": 1280,
    "space_h": 0,
    "space_v": 0
}
```

`projects/presets/input-history-windows/README.md`:

```md
# input-history-windows-keyboard
By: [@christiankyle-ching](https://github.com/christiankyle-ching)

A simple input-history HTML file that can be used with browser source. **Currently only shows keyboard events.**

## How to Use?

1. [Download the HTML file](input-history-windows.html).
2. Add a **Browser Source**.
3. Check **Local File**, then **locate the downloaded HTML file**.
4. **Adjust width and height** relative to your scene's pixel size.
5. (Optional) Customize using **by editing the HTML directly (recommended)** or **Custom CSS**. 

**Make sure that forwarding events to websocket is enabled.**

![Websocket Forwarding](img/websocket-forwarding.png)

## Customization
**You must know basic [HTML](https://developer.mozilla.org/en-US/docs/Web/CSS), [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS), and [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) to easily customize the template.**

### Basic Styling
In OBS, you can add styles in **Custom CSS** to override the styles in the HTML.

**But I recommend you to edit the HTML file directly instead, so the styling persists even after removing the browser source.**

![Custom CSS](img/custom-css.png)

In the example above:
- The `body { ... }` CSS selector: means that all the styles indicated inside the braces are applied to **the whole HTML `<body>`**.
  - `color: skyblue;` - Sets the font color to skyblue.
  - `text-align: center;` - Sets the text align (either left, center or right).
  - `font-size: 32px;` - Sets the font size in pixels. Adjust based on your screen pixel size.
  - `font-family: "Lucida Sans";` - Sets the font family. **Make sure the font is installed in your system, otherwise it won't work.**
  - `font-weight: bold;` - Sets text to bold.
  - `font-style: italic;` - Sets text to italic.
  - `background-color: rgba(0, 0, 0, 0);` - Represents red, green, blue, and alpha. Makes the browser's background transparent (which is what you mostly want in the scene).
- The `.key { ... }` CSS selector: means that all the styles indicated inside the braces are applied to **all elements that has `class="key" in HTML` (the rounded rectangle container for keys)**.
  - Note the `!important` after the value of `background-color`. This is sometimes required to override the styles applied within the HTML, and to use this value instead.

### Hide Specific Keys
Just comment out the lines in `var KEYCODES = {...}` of keys you don't want to show. Just add `//` on beginning of the line to "comment" lines.

```js
// In HTML <script>
var KEYCODES = {
      /* Begin Virtual Key Codes */
      0x0001: ["VC_ESCAPE", "ESC"],

      // Begin Function Keys
      // 0x003b: ["VC_F1", "F1"], This key will be hidden
      0x003c: ["VC_F2", "F2"],

      ...
}
```

### Replace Keys with Icons
1. Get an SVG code of the icon and paste it inside `<div id="icons-container">`. (I used [FontAwesome](https://fontawesome.com/icons)).
2. Assign it an `id`.

```html
<!-- In HTML <body> -->

<!-- Windows Key - VC_META_L / VC_META_R -->
<svg id="SVG_VC_META">
    ...
</svg>
```

It's better to follow my naming convention for ease of use:
```
SVG_<KEYNAME>
```
Where `<KEYNAME>` can be found in `var KEYCODES = {...};`.

```js
// In HTML <script>
var KEYCODES = {
    ...
    // the KEYNAME is the first one, "VC_META"
    // "WIN" is an optional alias that will show if there are no icons set for 0x0e5b
    0x0e5b: ["VC_META_L", "WIN"],
}
```
3. Add it to the list of `var KEYICONS;`
```js
// In HTML <script>
var KEYICONS = {
    ...
    // replace "SVG_VC_META" is the id you assigned the <svg> in step 2
    0x0e5b: document.getElementById("SVG_VC_META"),
}
```

### Enable / Disable Timeout Fade
To enable / disable this feature:
```js
// In HTML <script>
var HISTORY_TIMEOUT_ACTIVE = true; // or false
```

To adjust timeout before a key combination fades out:
```js
// In HTML <script>
var HISTORY_TIMEOUT = 3500; // this is in milliseconds
```

To adjust the duration of fade animation:
```css
/* Animation for hide timeout */
p.key-combination.hidden {
    ...
    
    /* Change this value in HTML <style> */
    transition-duration: 1s;
}
```

### Adjust Line Height
Change the value of margin.
```css
p.key-combination > * {
    /* Change this value in HTML <style>*/
    margin-top: 0.5em;

    ...
}
```
In the example above, `0.5em` is `48px(body:font-size) * 0.5`. Think of it like percentage of the font-size.

### Customize the background of keys
As stated in the [Basic Styling](#basic-styling), use the `.key` selector to select and style the container of the keys.

### Change separator character
Change the character used in between keys.
```js
var SEPARATOR = "+"; // Change this value in HTML <script>
```

```

`projects/presets/input-history-windows/input-history-windows.html`:

```html
<!DOCTYPE html>
<html>
  <!-- A usable HTML template for input-history overlay using Browser Source and Websocket -->
  <!-- ONLY KEYBOARD INPUT AS OF NOW -->

  <!-- By: https://github.com/christiankyle-ching/ -->
  <head>
    <meta charset="utf-8" />
    <title>input-history Windows</title>

    <style>
      /* Zero out default values */
      * {
        margin: 0;
        padding: 0;
      }

      body {
        font-family: Arial, Helvetica, sans-serif;
        font-size: 48px;
        color: white;

        overflow: hidden;
      }

      /* #region History List */

      div#history {
        /* Apply padding top to place first keys on the bottom part */
        padding-top: 100vh;

        list-style-type: none;
      }

      /* Animation for hide timeout */
      p.key-combination.hidden {
        opacity: 0;

        transition-property: opacity;
        transition-timing-function: ease-out;
        transition-duration: 1s;
      }

      p.key-combination > * {
        /* For line-height */
        margin-top: 0.5em;

        vertical-align: middle;
      }

      p.key-combination > .separator {
        display: inline-block;

        /* Spacing on sides of separator */
        margin-left: 0.25em;
        margin-right: 0.25em;
      }

      span.key {
        display: inline-flex;
        border-radius: 0.25em;

        padding: 0.25em;

        background-color: rgba(0, 0, 0, 0.75);
        white-space: nowrap;
      }

      /* #endregion */

      /* #region Icons */

      #icons-container {
        visibility: collapse;
      }

      .icon-sm {
        width: 1em;
        height: 1em;

        display: block;
        margin: auto;
      }

      /* #endregion */
    </style>
  </head>

  <body>
    <!-- #region Icons -->
    <div id="icons-container">
      <!-- Get Icons from FontAwesome -->
      <!-- Copy SVG Code -->

      <!-- Windows Key - VC_META_L / VC_META_R -->
      <svg
        id="SVG_VC_META"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 448 512"
      >
        <!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
        <path
          d="M0 93.7l183.6-25.3v177.4H0V93.7zm0 324.6l183.6 25.3V268.4H0v149.9zm203.8 28L448 480V268.4H203.8v177.9zm0-380.6v180.1H448V32L203.8 65.7z"
        />
      </svg>

      <!-- Arrow Left -->
      <svg
        id="SVG_VC_LEFT"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 512 512"
      >
        <!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
        <path
          d="M512 256C512 273.7 497.7 288 480 288H160.1l0 72c0 9.547-5.66 18.19-14.42 22c-8.754 3.812-18.95 2.077-25.94-4.407l-112.1-104c-10.24-9.5-10.24-25.69 0-35.19l112.1-104c6.992-6.484 17.18-8.218 25.94-4.406C154.4 133.8 160.1 142.5 160.1 151.1L160.1 224H480C497.7 224 512 238.3 512 256z"
        />
      </svg>

      <!-- Arrow Right -->
      <svg
        id="SVG_VC_RIGHT"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 512 512"
      >
        <!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
        <path
          d="M504.3 273.6l-112.1 104c-6.992 6.484-17.18 8.218-25.94 4.406c-8.758-3.812-14.42-12.45-14.42-21.1L351.9 288H32C14.33 288 .0002 273.7 .0002 255.1S14.33 224 32 224h319.9l0-72c0-9.547 5.66-18.19 14.42-22c8.754-3.809 18.95-2.075 25.94 4.41l112.1 104C514.6 247.9 514.6 264.1 504.3 273.6z"
        />
      </svg>

      <!-- Arrow Up -->
      <svg
        id="SVG_VC_UP"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 320 512"
      >
        <!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
        <path
          d="M285.1 145.7c-3.81 8.758-12.45 14.42-21.1 14.42L192 160.1V480c0 17.69-14.33 32-32 32s-32-14.31-32-32V160.1L55.1 160.1c-9.547 0-18.19-5.658-22-14.42c-3.811-8.758-2.076-18.95 4.408-25.94l104-112.1c9.498-10.24 25.69-10.24 35.19 0l104 112.1C288.1 126.7 289.8 136.9 285.1 145.7z"
        />
      </svg>

      <!-- Arrow Down -->
      <svg
        id="SVG_VC_DOWN"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 320 512"
      >
        <!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
        <path
          d="M281.6 392.3l-104 112.1c-9.498 10.24-25.69 10.24-35.19 0l-104-112.1c-6.484-6.992-8.219-17.18-4.404-25.94c3.811-8.758 12.45-14.42 21.1-14.42H128V32c0-17.69 14.33-32 32-32S192 14.31 192 32v319.9h72c9.547 0 18.19 5.66 22 14.42C289.8 375.1 288.1 385.3 281.6 392.3z"
        />
      </svg>
    </div>
    <!-- #endregion -->

    <div id="history"></div>
  </body>

  <script>
    /**
     * Keycodes from: https://github.com/kwhat/libuiohook/blob/1.2/include/uiohook.h
     * [0] -> libuiohook key
     * [1] -> optional alias
     *
     * Comment out keys that you don't want to show
     */
    var KEYCODES = {
      /* Begin Virtual Key Codes */
      0x0001: ["VC_ESCAPE", "ESC"],

      // Begin Function Keys
      0x003b: ["VC_F1", "F1"],
      0x003c: ["VC_F2", "F2"],
      0x003d: ["VC_F3", "F3"],
      0x003e: ["VC_F4", "F4"],
      0x003f: ["VC_F5", "F5"],
      0x0040: ["VC_F6", "F6"],
      0x0041: ["VC_F7", "F7"],
      0x0042: ["VC_F8", "F8"],
      0x0043: ["VC_F9", "F9"],
      0x0044: ["VC_F10", "F10"],
      0x0057: ["VC_F11", "F11"],
      0x0058: ["VC_F12", "F12"],

      0x005b: ["VC_F13", "F13"],
      0x005c: ["VC_F14", "F14"],
      0x005d: ["VC_F15", "F15"],
      0x0063: ["VC_F16", "F16"],
      0x0064: ["VC_F17", "F17"],
      0x0065: ["VC_F18", "F18"],
      0x0066: ["VC_F19", "F19"],
      0x0067: ["VC_F20", "F20"],
      0x0068: ["VC_F21", "F21"],
      0x0069: ["VC_F22", "F22"],
      0x006a: ["VC_F23", "F23"],
      0x006b: ["VC_F24", "F24"],
      // End Function Keys

      // Begin Alphanumeric Zone
      0x0029: ["VC_BACKQUOTE", "`"],

      0x0002: ["VC_1", "1"],
      0x0003: ["VC_2", "2"],
      0x0004: ["VC_3", "3"],
      0x0005: ["VC_4", "4"],
      0x0006: ["VC_5", "5"],
      0x0007: ["VC_6", "6"],
      0x0008: ["VC_7", "7"],
      0x0009: ["VC_8", "8"],
      0x000a: ["VC_9", "9"],
      0x000b: ["VC_0", "0"],

      0x000c: ["VC_MINUS", "-"], // '-'
      0x000d: ["VC_EQUALS", "="], // '='
      0x000e: ["VC_BACKSPACE", "BACKSPACE"],

      0x000f: ["VC_TAB", "TAB"],
      0x003a: ["VC_CAPS_LOCK", "CAPS LOCK"],

      0x001e: ["VC_A", "A"],
      0x0030: ["VC_B", "B"],
      0x002e: ["VC_C", "C"],
      0x0020: ["VC_D", "D"],
      0x0012: ["VC_E", "E"],
      0x0021: ["VC_F", "F"],
      0x0022: ["VC_G", "G"],
      0x0023: ["VC_H", "H"],
      0x0017: ["VC_I", "I"],
      0x0024: ["VC_J", "J"],
      0x0025: ["VC_K", "K"],
      0x0026: ["VC_L", "L"],
      0x0032: ["VC_M", "M"],
      0x0031: ["VC_N", "N"],
      0x0018: ["VC_O", "O"],
      0x0019: ["VC_P", "P"],
      0x0010: ["VC_Q", "Q"],
      0x0013: ["VC_R", "R"],
      0x001f: ["VC_S", "S"],
      0x0014: ["VC_T", "T"],
      0x0016: ["VC_U", "U"],
      0x002f: ["VC_V", "V"],
      0x0011: ["VC_W", "W"],
      0x002d: ["VC_X", "X"],
      0x0015: ["VC_Y", "Y"],
      0x002c: ["VC_Z", "Z"],

      0x001a: ["VC_OPEN_BRACKET", "["], // '['
      0x001b: ["VC_CLOSE_BRACKET", "]"], // ']'
      0x002b: ["VC_BACK_SLASH", "\\"], // '\'

      0x0027: ["VC_SEMICOLON", ";"], // ';'
      0x0028: ["VC_QUOTE", "'"],
      0x001c: ["VC_ENTER", "ENTER"],

      0x0033: ["VC_COMMA", ","], // ', ""],'
      0x0034: ["VC_PERIOD", "."], // '.'
      0x0035: ["VC_SLASH", "/"], // '/'

      0x0039: ["VC_SPACE", "SPACE"],
      //  Alphanumeric Zone End

      0x0e37: ["VC_PRINTSCREEN", "PrtSc"],
      0x0046: ["VC_SCROLL_LOCK", "SCROLL LOCK"],
      0x0e45: ["VC_PAUSE", "PAUSE"],

      0x0e46: ["VC_LESSER_GREATER", "|"], // '<', ""], '>', ""], '|' on qwertz layout

      //  Edit Key Zone Begin
      0x0e52: ["VC_INSERT", "INSERT"],
      0x0e53: ["VC_DELETE", "DELETE"],
      0x0e47: ["VC_HOME", "HOME"],
      0x0e4f: ["VC_END", "END"],
      0x0e49: ["VC_PAGE_UP", "PAGE UP"],
      0x0e51: ["VC_PAGE_DOWN", "PAGE DOWN"],

      /* https://github.com/univrsal/input-overlay/issues/174 */
      0xee52: ["VC_INSERT", "INSERT"], // 0x0e52
      0xee53: ["VC_DELETE", "DELETE"], // 0x0e53
      0xee47: ["VC_HOME", "HOME"], // 0x0e47
      0xee4f: ["VC_END", "END"], // 0x0e4f
      0xee49: ["VC_PAGE_UP", "PAGE UP"], // 0x0e49
      0xee51: ["VC_PAGE_DOWN", "PAGE DOWN"], // 0x0e51
      //  Edit Key Zone End

      //  Cursor Key Zone Begin
      0x0e48: ["VC_UP", "ARROW UP"],
      0x0e4b: ["VC_LEFT", "ARROW LEFT"],
      0x0e4c: ["VC_CLEAR", ""],
      0x0e4d: ["VC_RIGHT", "ARROW RIGHT"],
      0x0e50: ["VC_DOWN", "ARROW DOWN"],

      /* https://github.com/univrsal/input-overlay/issues/174 */
      0xee48: ["VC_UP", "ARROW UP"], // 0x0e48
      0xee4b: ["VC_LEFT", "ARROW LEFT"], // 0x0e4b
      0xee4c: ["VC_CLEAR", ""], // 0x0e4c
      0xee4d: ["VC_RIGHT", "ARROW RIGHT"], // 0x0e4d
      0xee50: ["VC_DOWN", "ARROW DOWN"], // 0x0e50
      //  Cursor Key Zone End

      //  Numeric Zone Begin
      0x0045: ["VC_NUM_LOCK", "NUM LOCK"],
      0x0e35: ["VC_KP_DIVIDE", "NUM /"],
      0x0037: ["VC_KP_MULTIPLY", "NUM *"],
      0x004a: ["VC_KP_SUBTRACT", "NUM -"],
      0x0e0d: ["VC_KP_EQUALS", "NUM ="],
      0x004e: ["VC_KP_ADD", "NUM +"],
      0x0e1c: ["VC_KP_ENTER", "NUM ENTER"],
      0x0053: ["VC_KP_SEPARATOR", "NUM ."],

      0x004f: ["VC_KP_1", "NUM 1"],
      0x0050: ["VC_KP_2", "NUM 2"],
      0x0051: ["VC_KP_3", "NUM 3"],
      0x004b: ["VC_KP_4", "NUM 4"],
      0x004c: ["VC_KP_5", "NUM 5"],
      0x004d: ["VC_KP_6", "NUM 6"],
      0x0047: ["VC_KP_7", "NUM 7"],
      0x0048: ["VC_KP_8", "NUM 8"],
      0x0049: ["VC_KP_9", "NUM 9"],
      0x0052: ["VC_KP_0", "NUM 0"],

      0xee00: ["VC_KP_END", ""], // VC_KP_1, ""],
      0xee00: ["VC_KP_DOWN", ""], // VC_KP_2, ""],
      0xee00: ["VC_KP_PAGE_DOWN", ""], // VC_KP_3, ""],
      0xee00: ["VC_KP_LEFT", ""], // VC_KP_4, ""],
      0xee00: ["VC_KP_CLEAR", ""], // VC_KP_5, ""],
      0xee00: ["VC_KP_RIGHT", ""], // VC_KP_6, ""],
      0xee00: ["VC_KP_HOME", ""], // VC_KP_7, ""],
      0xee00: ["VC_KP_UP", ""], // VC_KP_8, ""],
      0xee00: ["VC_KP_PAGE_UP", ""], // VC_KP_9, ""],
      0xee00: ["VC_KP_INSERT", ""], // VC_KP_0, ""],
      0xee00: ["VC_KP_DELETE", ""], // VC_KP_SEPARATOR, ""],
      //  Numeric Zone End

      //  Modifier and Control Keys Begin
      0x002a: ["VC_SHIFT_L", "L SHIFT"],
      0x0036: ["VC_SHIFT_R", "R SHIFT"],
      0x001d: ["VC_CONTROL_L", "L CTRL"],
      0x0e1d: ["VC_CONTROL_R", "R CTRL"],
      0x0038: ["VC_ALT_L", "L ALT"], // Option or Alt Key
      0x0e38: ["VC_ALT_R", "R ALT"], // Option or Alt Key
      0x0e5b: ["VC_META_L", "WIN"], // Windows or Command Key
      0x0e5c: ["VC_META_R", "WIN"], // Windows or Command Key
      0x0e5d: ["VC_CONTEXT_MENU", "CONTEXT MENU"],
      //  Modifier and Control Keys End

      //  Media Control Keys Begin
      0xe05e: ["VC_POWER", "POWER"],
      0xe05f: ["VC_SLEEP", "SLEEP"],
      0xe063: ["VC_WAKE", "WAKE"],

      0xe022: ["VC_MEDIA_PLAY", "MEDIA PLAY"],
      0xe024: ["VC_MEDIA_STOP", "MEDIA STOP"],
      0xe010: ["VC_MEDIA_PREVIOUS", "MEDIA PREVIOUS"],
      0xe019: ["VC_MEDIA_NEXT", "MEDIA NEXT"],
      0xe06d: ["VC_MEDIA_SELECT", "MEDIA SELECT"],
      0xe02c: ["VC_MEDIA_EJECT", "MEDIA EJECT"],

      0xe020: ["VC_VOLUME_MUTE", "VOLUME MUTE"],
      0xe030: ["VC_VOLUME_UP", "VOLUME UP"],
      0xe02e: ["VC_VOLUME_DOWN", "VOLUME DOWN"],

      0xe06c: ["VC_APP_MAIL", "APP MAIL"],
      0xe021: ["VC_APP_CALCULATOR", "APP CALCULATOR"],
      0xe03c: ["VC_APP_MUSIC", "APP MUSIC"],
      0xe064: ["VC_APP_PICTURES", "APP PICTURES"],

      0xe065: ["VC_BROWSER_SEARCH", "BROWSER SEARCH"],
      0xe032: ["VC_BROWSER_HOME", "BROWSER HOME"],
      0xe06a: ["VC_BROWSER_BACK", "BROWSER BACK"],
      0xe069: ["VC_BROWSER_FORWARD", "BROWSER FORWARD"],
      0xe068: ["VC_BROWSER_STOP", "BROWSER STOP"],
      0xe067: ["VC_BROWSER_REFRESH", "BROWSER REFRESH"],
      0xe066: ["VC_BROWSER_FAVORITES", "BROWSER FAVORITES"],
      // End Media Control Keys

      // Begin Japanese Language Keys
      0x0070: ["VC_KATAKANA", ""],
      0x0073: ["VC_UNDERSCORE", ""],
      0x0077: ["VC_FURIGANA", ""],
      0x0079: ["VC_KANJI", ""],
      0x007b: ["VC_HIRAGANA", ""],
      0x007d: ["VC_YEN", ""],
      0x007e: ["VC_KP_COMMA", ""],
      // End Japanese Language Keys

      // Begin Sun keyboards
      0xff75: ["VC_SUN_HELP", ""],

      0xff78: ["VC_SUN_STOP", ""],
      0xff76: ["VC_SUN_PROPS", ""],
      0xff77: ["VC_SUN_FRONT", ""],
      0xff74: ["VC_SUN_OPEN", ""],
      0xff7e: ["VC_SUN_FIND", ""],
      0xff79: ["VC_SUN_AGAIN", ""],
      0xff7a: ["VC_SUN_UNDO", ""],
      0xff7c: ["VC_SUN_COPY", ""],
      0xff7d: ["VC_SUN_INSERT", ""],
      0xff7b: ["VC_SUN_CUT", ""],
      // End Sun keyboards

      0x0000: ["VC_UNDEFINED", ""], // KeyCode Unknown

      0xffff: ["CHAR_UNDEFINED", ""], // CharCode Unknown
      /* End Virtual Key Codes */

      /* Begin Virtual Modifier Masks */
      // MASK_SHIFT_L                             1 << 0
      // MASK_CTRL_L                              1 << 1
      // MASK_META_L                              1 << 2
      // MASK_ALT_L                               1 << 3

      // MASK_SHIFT_R                             1 << 4
      // MASK_CTRL_R                              1 << 5
      // MASK_META_R                              1 << 6
      // MASK_ALT_R                               1 << 7

      // MASK_SHIFT                               MASK_SHIFT_L | MASK_SHIFT_R
      // MASK_CTRL                                MASK_CTRL_L  | MASK_CTRL_R
      // MASK_META                                MASK_META_L  | MASK_META_R
      // MASK_ALT                                 MASK_ALT_L   | MASK_ALT_R

      // MASK_BUTTON1                             1 << 8
      // MASK_BUTTON2                             1 << 9
      // MASK_BUTTON3                             1 << 10
      // MASK_BUTTON4                             1 << 11
      // MASK_BUTTON5                             1 << 12

      // MASK_NUM_LOCK                            1 << 13
      // MASK_CAPS_LOCK                           1 << 14
      // MASK_SCROLL_LOCK                         1 << 15
      /* End Virtual Modifier Masks */
    };

    /**
     * This will either return an HTML string (icon)
     * Or a plain string (libuiohook key name)
     *
     * @param {string} keycode - keycode from libuiohook
     *
     * @returns {string} Inline innerHTML equivalent of key
     */
    function getKeyHTML(keycode) {
      var key = KEYCODES[parseInt(keycode)];

      if (!!key) {
        var icon = KEYICONS[parseInt(keycode)];

        if (!!icon) {
          return icon.cloneNode(true).outerHTML;
        } else {
          // return alias if present
          return key[1] !== "" ? key[1] : key[0];
        }
      } else {
        return "";
      }
    }

    // #region Keys with Icons

    /* Init SVG Icons */
    document
      .querySelectorAll("#icons-container > svg")
      .forEach((i) => i.classList.add("icon-sm"));
    document
      .querySelectorAll("#icons-container > svg > path")
      .forEach((p) => p.setAttribute("fill", "currentColor"));

    /**
     * For Keys to replace with Icons
     * Key: libuihook keycode
     * Value: <svg> icon element
     */
    var KEYICONS = {
      0x0e5b: document.getElementById("SVG_VC_META"), // VC_META_L Windows or Command Key
      0x0e5c: document.getElementById("SVG_VC_META"), // VC_META_R Windows or Command Key

      // Arrow Keys
      0x0e48: document.getElementById("SVG_VC_UP"), // ARROW UP
      0x0e4b: document.getElementById("SVG_VC_LEFT"), // ARROW LEFT
      0x0e4d: document.getElementById("SVG_VC_RIGHT"), // ARROW RIGHT
      0x0e50: document.getElementById("SVG_VC_DOWN"), // ARROW DOWN
      /* https://github.com/univrsal/input-overlay/issues/174 */
      0xee48: document.getElementById("SVG_VC_UP"), // ARROW UP
      0xee4b: document.getElementById("SVG_VC_LEFT"), // ARROW LEFT
      0xee4d: document.getElementById("SVG_VC_RIGHT"), // ARROW RIGHT
      0xee50: document.getElementById("SVG_VC_DOWN"), // ARROW DOWN

      0x001c: document.getElementById("SVG_VC_ENTER"),
    };

    // #endregion

    // #region DOM Utils

    /**
     * Gets a {Set} of keycodes, wraps each item in span.key, and joins them by a + (separator)
     *
     * @returns {HTMLElement} <p> element of key combination
     */
    function getKeyCombinationElement(setOfKeycodes = new Set()) {
      try {
        var innerHTMLofKeys = Array.from(setOfKeycodes)
          .map((keycode) => getKeyHTML(keycode))
          // Filter out non-existing keys in KEYCODES
          .filter((html) => html !== "");

        // Build innerHTMl for the key combination
        var innerHTMLOfKeyCombination = innerHTMLofKeys
          .map(
            (innerHTML) =>
              createElementWithClass("span", innerHTML, ["key"]).outerHTML
          )
          .join(
            createElementWithClass("span", SEPARATOR, ["separator"]).outerHTML
          );

        return createElementWithClass("p", innerHTMLOfKeyCombination, [
          "key-combination",
        ]);
      } catch (e) {
        console.error(e);
        return "";
      }
    }

    /**
     * Wraps an HTML string of a key with span
     *
     * @returns {HTMLElement} HTML Element created with classes
     */
    function createElementWithClass(element, innerHTML = "", classList = []) {
      var el = document.createElement(element);
      el.innerHTML = innerHTML;
      el.classList.add(...classList);
      return el;
    }

    // #endregion

    // #region ----- YOU CAN CHANGE THESE VALUES -----

    /**
     * Max count of history shown. Lower = better performance.
     * @type {number}
     */
    var HISTORY_MAX = 10;
    /**
     * Enable / Disable timeout for key combinations
     * @type {boolean}
     */
    var HISTORY_TIMEOUT_ACTIVE = true;
    /**
     * Time delay in ms before the key is hidden.
     * @type {number}
     */
    var HISTORY_TIMEOUT = 3500;
    /**
     * Separator between keys
     * @type {string}
     */
    var SEPARATOR = "+";

    // #endregion

    // History
    var _historyDiv = document.getElementById("history");
    var _historyCurrentlyPressed = new Set();
    var _isHistoryPressing = false;

    function onKeyEvent(data) {
      if (
        data.event_type.startsWith("mouse") ||
        data.event_type === "key_typed"
      )
        return;

      // console.log(data);

      // Update Set to current key combination
      if (data.event_type === "key_pressed") {
        _historyCurrentlyPressed.add(data.keycode);
        _isHistoryPressing = true;
      } else if (data.event_type === "key_released") {
        _historyCurrentlyPressed.delete(data.keycode);
        _isHistoryPressing = false;
      }

      // console.log(_historyCurrentlyPressed);

      updateUI();
    }

    function updateUI() {
      var lastChildInnerHTML =
        _historyDiv.lastElementChild == null
          ? ""
          : _historyDiv.lastElementChild.innerHTML;

      var isLastChildEmpty = lastChildInnerHTML === "";

      if (_isHistoryPressing) {
        // If starting key combination, set last item text
        if (_historyDiv.childElementCount > 0) {
          _historyDiv.lastElementChild.innerHTML = getKeyCombinationElement(
            _historyCurrentlyPressed
          ).innerHTML;
        }
        // OR add an element if this is first combination
        else {
          _historyDiv.appendChild(
            getKeyCombinationElement(_historyCurrentlyPressed)
          );
        }
      }
      // If done pressing key combination,
      else {
        if (!isLastChildEmpty) {
          if (HISTORY_TIMEOUT_ACTIVE) {
            // Add removing class of last key combination
            var elementToHide = _historyDiv.lastElementChild;
            setTimeout(() => {
              elementToHide.classList.add("hidden");
            }, HISTORY_TIMEOUT);
          }

          // Then add a empty slot
          _historyDiv.appendChild(getKeyCombinationElement());
        }
      }

      // Remove first element
      if (_historyDiv.children.length > HISTORY_MAX)
        _historyDiv.firstChild.remove();

      // Scroll down
      scrollTo({
        top: document.body.scrollHeight,
      });
    }

    function on_data(e) {
      // Since data is in string, parse first
      var data = JSON.parse(e.data);

      // Show for browser source
      onKeyEvent(data);
    }

    function start_websocket() {
      var ws = new WebSocket("ws://localhost:16899/");

      ws.onmessage = on_data;

      ws.onerror = (e) => {
        console.log("WebSocket error: ");
        console.error(e);
      };

      ws.onclose = () => {
        // connection closed, discard old websocket and create a new one in 5s
        ws = null;
        setTimeout(start_websocket, 2000);
      };
    }

    start_websocket();
  </script>
</html>

```

`projects/presets/mouse/alternative/FAT9L/mouse_pink_no_movement_FAT9L.json`:

```json
{
    "default_height": 0,
    "default_width": 0,
    "elements": [
        {
            "type": 1,
            "pos": [
                247,
                210
            ],
            "id": "keyboard button6",
            "z_level": 0,
            "mapping": [
                648,
                212,
                40,
                62
            ],
            "code": 51
        },
        {
            "type": 1,
            "pos": [
                235,
                273
            ],
            "id": "keyboard button7",
            "z_level": 0,
            "mapping": [
                648,
                212,
                40,
                62
            ],
            "code": 52
        },
        {
            "id": "body",
            "mapping": [
                328,
                1,
                283,
                242
            ],
            "pos": [
                2,
                179
            ],
            "type": 0,
            "z_level": 1
        },
        {
            "code": 1,
            "id": "lmb",
            "mapping": [
                1,
                1,
                139,
                174
            ],
            "pos": [
                2,
                0
            ],
            "type": 3,
            "z_level": 1
        },
        {
            "code": 2,
            "id": "rmb",
            "mapping": [
                143,
                1,
                139,
                174
            ],
            "pos": [
                146,
                0
            ],
            "type": 3,
            "z_level": 1
        },
        {
            "id": "wheel",
            "mapping": [
                285,
                246,
                48,
                95
            ],
            "pos": [
                117,
                79
            ],
            "type": 4,
            "z_level": 1
        },
        {
            "code": 5,
            "id": "smb1",
            "mapping": [
                285,
                1,
                40,
                62
            ],
            "pos": [
                0,
                210
            ],
            "type": 3,
            "z_level": 1
        },
        {
            "code": 4,
            "id": "smb2",
            "mapping": [
                284,
                1,
                41,
                62
            ],
            "pos": [
                11,
                273
            ],
            "type": 3,
            "z_level": 1
        }
    ],
    "flags": 8,
    "overlay_height": 421,
    "overlay_width": 287,
    "space_h": 0,
    "space_v": 0
}
```

`projects/presets/mouse/alternative/FAT9L/wasd_pink_FAT9L.json`:

```json
{
    "default_height": 128,
    "default_width": 157,
    "elements": [
        {
            "type": 1,
            "pos": [
                271,
                532
            ],
            "id": "alt",
            "z_level": 0,
            "mapping": [
                961,
                525,
                158,
                129
            ],
            "code": 56
        },
        {
            "type": 1,
            "pos": [
                135,
                0
            ],
            "id": "keyboard button13",
            "z_level": 0,
            "mapping": [
                161,
                526,
                157,
                128
            ],
            "code": 2
        },
        {
            "type": 1,
            "pos": [
                271,
                0
            ],
            "id": "keyboard button14",
            "z_level": 0,
            "mapping": [
                321,
                525,
                157,
                128
            ],
            "code": 3
        },
        {
            "type": 1,
            "pos": [
                407,
                0
            ],
            "id": "keyboard button15",
            "z_level": 0,
            "mapping": [
                481,
                525,
                158,
                127
            ],
            "code": 4
        },
        {
            "type": 1,
            "pos": [
                543,
                0
            ],
            "id": "keyboard button16",
            "z_level": 0,
            "mapping": [
                642,
                525,
                156,
                128
            ],
            "code": 5
        },
        {
            "type": 1,
            "pos": [
                678,
                0
            ],
            "id": "keyboard button17",
            "z_level": 0,
            "mapping": [
                800,
                525,
                159,
                128
            ],
            "code": 6
        },
        {
            "type": 1,
            "pos": [
                135,
                399
            ],
            "id": "keyboard button18",
            "z_level": 0,
            "mapping": [
                481,
                263,
                157,
                128
            ],
            "code": 44
        },
        {
            "type": 1,
            "pos": [
                271,
                399
            ],
            "id": "keyboard button19",
            "z_level": 0,
            "mapping": [
                641,
                263,
                157,
                128
            ],
            "code": 45
        },
        {
            "type": 1,
            "pos": [
                407,
                399
            ],
            "id": "keyboard button20",
            "z_level": 0,
            "mapping": [
                801,
                263,
                157,
                128
            ],
            "code": 46
        },
        {
            "type": 1,
            "pos": [
                543,
                399
            ],
            "id": "keyboard button21",
            "z_level": "0",
            "mapping": [
                961,
                263,
                157,
                128
            ],
            "code": 47
        },
        {
            "type": 1,
            "pos": [
                679,
                133
            ],
            "id": "keyboard button22",
            "z_level": 0,
            "mapping": [
                1121,
                263,
                157,
                128
            ],
            "code": 20
        },
        {
            "type": 1,
            "pos": [
                679,
                266
            ],
            "id": "keyboard button23",
            "z_level": 0,
            "mapping": [
                1281,
                263,
                157,
                128
            ],
            "code": 34
        },
        {
            "type": 1,
            "pos": [
                679,
                399
            ],
            "id": "keyboard button27",
            "z_level": 0,
            "mapping": [
                1,
                525,
                157,
                129
            ],
            "code": 48
        },
        {
            "type": 1,
            "pos": [
                0,
                266
            ],
            "id": "keyboard button28",
            "z_level": 0,
            "mapping": [
                961,
                788,
                157,
                128
            ],
            "code": 58
        },
        {
            "code": 16,
            "id": "q",
            "mapping": [
                1,
                1,
                157,
                128
            ],
            "pos": [
                135,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 17,
            "id": "w",
            "mapping": [
                161,
                1,
                157,
                128
            ],
            "pos": [
                271,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 18,
            "id": "e",
            "mapping": [
                321,
                1,
                157,
                128
            ],
            "pos": [
                407,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 42,
            "id": "shift",
            "mapping": [
                481,
                1,
                157,
                128
            ],
            "pos": [
                0,
                399
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 30,
            "id": "a",
            "mapping": [
                641,
                1,
                157,
                128
            ],
            "pos": [
                135,
                266
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 31,
            "id": "s",
            "mapping": [
                801,
                1,
                157,
                128
            ],
            "pos": [
                271,
                266
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 32,
            "id": "d",
            "mapping": [
                961,
                1,
                157,
                128
            ],
            "pos": [
                407,
                266
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 29,
            "id": "ctrl",
            "mapping": [
                1121,
                1,
                157,
                128
            ],
            "pos": [
                0,
                532
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 57,
            "id": "space",
            "mapping": [
                1301,
                1,
                421,
                128
            ],
            "pos": [
                407,
                532
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 15,
            "id": "tab",
            "mapping": [
                1,
                263,
                157,
                128
            ],
            "pos": [
                0,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 19,
            "id": "r",
            "mapping": [
                161,
                263,
                157,
                128
            ],
            "pos": [
                543,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 33,
            "id": "f",
            "mapping": [
                321,
                263,
                157,
                128
            ],
            "pos": [
                543,
                266
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "type": 1,
            "pos": [
                0,
                0
            ],
            "id": "keyboard button29",
            "z_level": 0,
            "mapping": [
                1281,
                525,
                157,
                128
            ],
            "code": 0
        },
        {
            "type": 1,
            "pos": [
                135,
                532
            ],
            "id": "keyboard button26",
            "z_level": 0,
            "mapping": [
                1121,
                525,
                157,
                128
            ],
            "code": 3675
        }
    ],
    "flags": 0,
    "overlay_height": 661,
    "overlay_width": 837,
    "space_h": -20,
    "space_v": 5
}
```

`projects/presets/mouse/mouse-arrow.json`:

```json
{
    "default_height": 0,
    "default_width": 0,
    "elements": [
        {
            "id": "body",
            "mapping": [
                328,
                1,
                283,
                242
            ],
            "pos": [
                2,
                179
            ],
            "type": 0,
            "z_level": 1
        },
        {
            "code": 1,
            "id": "lmb",
            "mapping": [
                1,
                1,
                139,
                174
            ],
            "pos": [
                2,
                0
            ],
            "type": 3,
            "z_level": 1
        },
        {
            "code": 2,
            "id": "rmb",
            "mapping": [
                143,
                1,
                139,
                174
            ],
            "pos": [
                146,
                0
            ],
            "type": 3,
            "z_level": 1
        },
        {
            "id": "wheel",
            "mapping": [
                285,
                246,
                48,
                95
            ],
            "pos": [
                117,
                79
            ],
            "type": 4,
            "z_level": 1
        },
        {
            "code": 5,
            "id": "smb1",
            "mapping": [
                285,
                1,
                40,
                62
            ],
            "pos": [
                0,
                210
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 4,
            "id": "smb2",
            "mapping": [
                284,
                1,
                41,
                62
            ],
            "pos": [
                11,
                273
            ],
            "type": 3,
            "z_level": 1
        },
        {
            "id": "arrow",
            "mapping": [
                614,
                1,
                100,
                100
            ],
            "mouse_type": 1,
            "pos": [
                94,
                235
            ],
            "type": 9,
            "z_level": 1
        }
    ],
    "flags": 8,
    "overlay_height": 421,
    "overlay_width": 285,
    "space_h": 0,
    "space_v": 0
}
```

`projects/presets/mouse/mouse-dot.json`:

```json
{
    "default_height": 0,
    "default_width": 0,
    "elements": [
        {
            "id": "body",
            "mapping": [
                328,
                1,
                283,
                242
            ],
            "pos": [
                1,
                179
            ],
            "type": 0,
            "z_level": 0
        },
        {
            "code": 1,
            "id": "lmb",
            "mapping": [
                1,
                1,
                139,
                174
            ],
            "pos": [
                0,
                0
            ],
            "type": 3,
            "z_level": 1
        },
        {
            "code": 2,
            "id": "rmb",
            "mapping": [
                143,
                1,
                139,
                174
            ],
            "pos": [
                146,
                0
            ],
            "type": 3,
            "z_level": 1
        },
        {
            "id": "wheel",
            "mapping": [
                285,
                246,
                48,
                95
            ],
            "pos": [
                117,
                79
            ],
            "type": 4,
            "z_level": 1
        },
        {
            "code": 5,
            "id": "smb1",
            "mapping": [
                285,
                1,
                40,
                62
            ],
            "pos": [
                0,
                210
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 4,
            "id": "smb2",
            "mapping": [
                284,
                1,
                41,
                62
            ],
            "pos": [
                11,
                273
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "id": "area",
            "mapping": [
                614,
                104,
                100,
                100
            ],
            "pos": [
                91,
                245
            ],
            "type": 0,
            "z_level": 0
        },
        {
            "id": "dot",
            "mapping": [
                614,
                207,
                20,
                20
            ],
            "mouse_radius": 50,
            "mouse_type": 0,
            "pos": [
                132,
                284
            ],
            "type": 9,
            "z_level": 1
        }
    ],
    "flags": 8,
    "overlay_height": 421,
    "overlay_width": 285,
    "space_h": 0,
    "space_v": 0
}
```

`projects/presets/mouse/mouse-no-movement.json`:

```json
{
    "default_height": 0,
    "default_width": 0,
    "elements": [
        {
            "id": "body",
            "mapping": [
                328,
                1,
                283,
                242
            ],
            "pos": [
                2,
                179
            ],
            "type": 0,
            "z_level": 1
        },
        {
            "code": 1,
            "id": "lmb",
            "mapping": [
                1,
                1,
                139,
                174
            ],
            "pos": [
                2,
                0
            ],
            "type": 3,
            "z_level": 1
        },
        {
            "code": 2,
            "id": "rmb",
            "mapping": [
                143,
                1,
                139,
                174
            ],
            "pos": [
                146,
                0
            ],
            "type": 3,
            "z_level": 1
        },
        {
            "id": "wheel",
            "mapping": [
                285,
                246,
                48,
                95
            ],
            "pos": [
                117,
                79
            ],
            "type": 4,
            "z_level": 1
        },
        {
            "code": 5,
            "id": "smb1",
            "mapping": [
                285,
                1,
                40,
                62
            ],
            "pos": [
                0,
                210
            ],
            "type": 3,
            "z_level": 1
        },
        {
            "code": 4,
            "id": "smb2",
            "mapping": [
                284,
                1,
                41,
                62
            ],
            "pos": [
                11,
                273
            ],
            "type": 3,
            "z_level": 1
        }
    ],
    "flags": 0,
    "overlay_height": 421,
    "overlay_width": 285,
    "space_h": 0,
    "space_v": 0
}
```

`projects/presets/qwerty/qwerty.json`:

```json
{
    "default_width": 128,
    "default_height": 128,
    "space_h": 3,
    "space_v": 3,
    "flags": 0,
    "overlay_width": 1831,
    "overlay_height": 783,
    "elements": [
        {
            "type": 1,
            "pos": [
                0,
                0
            ],
            "id": "esc",
            "z_level": 0,
            "mapping": [
                1,
                1,
                128,
                128
            ],
            "code": 1
        },
        {
            "type": 1,
            "pos": [
                131,
                0
            ],
            "id": "f1",
            "z_level": 0,
            "mapping": [
                132,
                1,
                128,
                128
            ],
            "code": 59
        },
        {
            "type": 1,
            "pos": [
                262,
                0
            ],
            "id": "f2",
            "z_level": 0,
            "mapping": [
                263,
                1,
                128,
                128
            ],
            "code": 60
        },
        {
            "type": 1,
            "pos": [
                393,
                0
            ],
            "id": "f3",
            "z_level": 0,
            "mapping": [
                394,
                1,
                128,
                128
            ],
            "code": 61
        },
        {
            "type": 1,
            "pos": [
                524,
                0
            ],
            "id": "f4",
            "z_level": 0,
            "mapping": [
                525,
                1,
                128,
                128
            ],
            "code": 62
        },
        {
            "type": 1,
            "pos": [
                655,
                0
            ],
            "id": "f5",
            "z_level": 0,
            "mapping": [
                656,
                1,
                128,
                128
            ],
            "code": 63
        },
        {
            "type": 1,
            "pos": [
                786,
                0
            ],
            "id": "f6",
            "z_level": 0,
            "mapping": [
                787,
                1,
                128,
                128
            ],
            "code": 64
        },
        {
            "type": 1,
            "pos": [
                917,
                0
            ],
            "id": "f7",
            "z_level": 0,
            "mapping": [
                918,
                1,
                128,
                128
            ],
            "code": 65
        },
        {
            "type": 1,
            "pos": [
                1048,
                0
            ],
            "id": "f8",
            "z_level": 0,
            "mapping": [
                1049,
                1,
                128,
                128
            ],
            "code": 66
        },
        {
            "type": 1,
            "pos": [
                1179,
                0
            ],
            "id": "f9",
            "z_level": 0,
            "mapping": [
                1180,
                1,
                128,
                128
            ],
            "code": 67
        },
        {
            "type": 1,
            "pos": [
                1310,
                0
            ],
            "id": "f10",
            "z_level": 0,
            "mapping": [
                1311,
                1,
                128,
                128
            ],
            "code": 68
        },
        {
            "type": 1,
            "pos": [
                1441,
                0
            ],
            "id": "f11",
            "z_level": 0,
            "mapping": [
                1442,
                1,
                128,
                128
            ],
            "code": 87
        },
        {
            "type": 1,
            "pos": [
                1572,
                0
            ],
            "id": "f12",
            "z_level": 0,
            "mapping": [
                1573,
                1,
                128,
                128
            ],
            "code": 88
        },
        {
            "type": 1,
            "pos": [
                0,
                131
            ],
            "id": "~",
            "z_level": 0,
            "mapping": [
                1,
                263,
                128,
                128
            ],
            "code": 41
        },
        {
            "type": 1,
            "pos": [
                131,
                131
            ],
            "id": "1",
            "z_level": 0,
            "mapping": [
                132,
                263,
                128,
                128
            ],
            "code": 2
        },
        {
            "type": 1,
            "pos": [
                262,
                131
            ],
            "id": "2",
            "z_level": 0,
            "mapping": [
                263,
                263,
                128,
                128
            ],
            "code": 3
        },
        {
            "type": 1,
            "pos": [
                393,
                131
            ],
            "id": "3",
            "z_level": 0,
            "mapping": [
                394,
                263,
                128,
                128
            ],
            "code": 4
        },
        {
            "type": 1,
            "pos": [
                524,
                131
            ],
            "id": "4",
            "z_level": 0,
            "mapping": [
                525,
                263,
                128,
                128
            ],
            "code": 5
        },
        {
            "type": 1,
            "pos": [
                655,
                131
            ],
            "id": "5",
            "z_level": 0,
            "mapping": [
                656,
                263,
                128,
                128
            ],
            "code": 6
        },
        {
            "type": 1,
            "pos": [
                786,
                131
            ],
            "id": "6",
            "z_level": 0,
            "mapping": [
                787,
                263,
                128,
                128
            ],
            "code": 7
        },
        {
            "type": 1,
            "pos": [
                917,
                131
            ],
            "id": "7",
            "z_level": 0,
            "mapping": [
                918,
                263,
                128,
                128
            ],
            "code": 8
        },
        {
            "type": 1,
            "pos": [
                1048,
                131
            ],
            "id": "8",
            "z_level": 0,
            "mapping": [
                1049,
                263,
                128,
                128
            ],
            "code": 9
        },
        {
            "type": 1,
            "pos": [
                1179,
                131
            ],
            "id": "9",
            "z_level": 0,
            "mapping": [
                1180,
                263,
                128,
                128
            ],
            "code": 10
        },
        {
            "type": 1,
            "pos": [
                1310,
                131
            ],
            "id": "0",
            "z_level": 0,
            "mapping": [
                1311,
                263,
                128,
                128
            ],
            "code": 11
        },
        {
            "type": 1,
            "pos": [
                1441,
                131
            ],
            "id": "-",
            "z_level": 0,
            "mapping": [
                1442,
                263,
                128,
                128
            ],
            "code": 12
        },
        {
            "type": 1,
            "pos": [
                1572,
                131
            ],
            "id": "=",
            "z_level": 0,
            "mapping": [
                1573,
                263,
                128,
                128
            ],
            "code": 13
        },
        {
            "type": 1,
            "pos": [
                1703,
                131
            ],
            "id": "backspace",
            "z_level": 0,
            "mapping": [
                1,
                525,
                128,
                128
            ],
            "code": 14
        },
        {
            "type": 1,
            "pos": [
                0,
                262
            ],
            "id": "tab",
            "z_level": 0,
            "mapping": [
                132,
                525,
                128,
                128
            ],
            "code": 15
        },
        {
            "type": 1,
            "pos": [
                131,
                262
            ],
            "id": "q",
            "z_level": 0,
            "mapping": [
                263,
                525,
                128,
                128
            ],
            "code": 16
        },
        {
            "type": 1,
            "pos": [
                262,
                262
            ],
            "id": "w",
            "z_level": 0,
            "mapping": [
                394,
                525,
                128,
                128
            ],
            "code": 17
        },
        {
            "type": 1,
            "pos": [
                393,
                262
            ],
            "id": "e",
            "z_level": 0,
            "mapping": [
                525,
                525,
                128,
                128
            ],
            "code": 18
        },
        {
            "type": 1,
            "pos": [
                524,
                262
            ],
            "id": "r",
            "z_level": 0,
            "mapping": [
                656,
                525,
                128,
                128
            ],
            "code": 19
        },
        {
            "type": 1,
            "pos": [
                655,
                262
            ],
            "id": "t",
            "z_level": 0,
            "mapping": [
                787,
                525,
                128,
                128
            ],
            "code": 20
        },
        {
            "type": 1,
            "pos": [
                786,
                262
            ],
            "id": "y",
            "z_level": 0,
            "mapping": [
                918,
                525,
                128,
                128
            ],
            "code": 21
        },
        {
            "type": 1,
            "pos": [
                917,
                262
            ],
            "id": "u",
            "z_level": 0,
            "mapping": [
                1049,
                525,
                128,
                128
            ],
            "code": 22
        },
        {
            "type": 1,
            "pos": [
                1048,
                262
            ],
            "id": "i",
            "z_level": 0,
            "mapping": [
                1180,
                525,
                128,
                128
            ],
            "code": 23
        },
        {
            "type": 1,
            "pos": [
                1179,
                262
            ],
            "id": "o",
            "z_level": 0,
            "mapping": [
                1311,
                525,
                128,
                128
            ],
            "code": 24
        },
        {
            "type": 1,
            "pos": [
                1310,
                262
            ],
            "id": "p",
            "z_level": 0,
            "mapping": [
                1442,
                525,
                128,
                128
            ],
            "code": 25
        },
        {
            "type": 1,
            "pos": [
                1441,
                262
            ],
            "id": "[",
            "z_level": 0,
            "mapping": [
                1573,
                525,
                128,
                128
            ],
            "code": 26
        },
        {
            "type": 1,
            "pos": [
                1572,
                262
            ],
            "id": "]",
            "z_level": 0,
            "mapping": [
                1,
                787,
                128,
                128
            ],
            "code": 27
        },
        {
            "type": 1,
            "pos": [
                1703,
                262
            ],
            "id": "\\",
            "z_level": 0,
            "mapping": [
                132,
                787,
                128,
                128
            ],
            "code": 43
        },
        {
            "type": 1,
            "pos": [
                0,
                393
            ],
            "id": "caps",
            "z_level": 0,
            "mapping": [
                263,
                787,
                128,
                128
            ],
            "code": 58
        },
        {
            "type": 1,
            "pos": [
                131,
                393
            ],
            "id": "a",
            "z_level": 0,
            "mapping": [
                394,
                787,
                128,
                128
            ],
            "code": 30
        },
        {
            "type": 1,
            "pos": [
                262,
                393
            ],
            "id": "s",
            "z_level": 0,
            "mapping": [
                525,
                787,
                128,
                128
            ],
            "code": 31
        },
        {
            "type": 1,
            "pos": [
                393,
                393
            ],
            "id": "d",
            "z_level": 0,
            "mapping": [
                656,
                787,
                128,
                128
            ],
            "code": 32
        },
        {
            "type": 1,
            "pos": [
                524,
                393
            ],
            "id": "f",
            "z_level": 0,
            "mapping": [
                787,
                787,
                128,
                128
            ],
            "code": 33
        },
        {
            "type": 1,
            "pos": [
                655,
                393
            ],
            "id": "g",
            "z_level": 0,
            "mapping": [
                918,
                787,
                128,
                128
            ],
            "code": 34
        },
        {
            "type": 1,
            "pos": [
                786,
                393
            ],
            "id": "h",
            "z_level": 0,
            "mapping": [
                1049,
                787,
                128,
                128
            ],
            "code": 35
        },
        {
            "type": 1,
            "pos": [
                917,
                393
            ],
            "id": "j",
            "z_level": 0,
            "mapping": [
                1180,
                787,
                128,
                128
            ],
            "code": 36
        },
        {
            "type": 1,
            "pos": [
                1048,
                393
            ],
            "id": "k",
            "z_level": 0,
            "mapping": [
                1311,
                787,
                128,
                128
            ],
            "code": 37
        },
        {
            "type": 1,
            "pos": [
                1179,
                393
            ],
            "id": "l",
            "z_level": 0,
            "mapping": [
                1442,
                787,
                128,
                128
            ],
            "code": 38
        },
        {
            "type": 1,
            "pos": [
                1310,
                393
            ],
            "id": ";",
            "z_level": 0,
            "mapping": [
                1573,
                787,
                128,
                128
            ],
            "code": 39
        },
        {
            "type": 1,
            "pos": [
                1441,
                393
            ],
            "id": "'",
            "z_level": 0,
            "mapping": [
                1,
                1049,
                128,
                128
            ],
            "code": 40
        },
        {
            "type": 1,
            "pos": [
                1703,
                393
            ],
            "id": "enter",
            "z_level": 0,
            "mapping": [
                132,
                1049,
                128,
                128
            ],
            "code": 28
        },
        {
            "type": 1,
            "pos": [
                0,
                524
            ],
            "id": "lshift",
            "z_level": 0,
            "mapping": [
                263,
                1049,
                128,
                128
            ],
            "code": 42
        },
        {
            "type": 1,
            "pos": [
                131,
                524
            ],
            "id": "z",
            "z_level": 0,
            "mapping": [
                394,
                1049,
                128,
                128
            ],
            "code": 44
        },
        {
            "type": 1,
            "pos": [
                262,
                524
            ],
            "id": "x",
            "z_level": 0,
            "mapping": [
                525,
                1049,
                128,
                128
            ],
            "code": 45
        },
        {
            "type": 1,
            "pos": [
                393,
                524
            ],
            "id": "c",
            "z_level": 0,
            "mapping": [
                656,
                1049,
                128,
                128
            ],
            "code": 46
        },
        {
            "type": 1,
            "pos": [
                524,
                524
            ],
            "id": "v",
            "z_level": 0,
            "mapping": [
                787,
                1049,
                128,
                128
            ],
            "code": 47
        },
        {
            "type": 1,
            "pos": [
                655,
                524
            ],
            "id": "b",
            "z_level": 0,
            "mapping": [
                918,
                1049,
                128,
                128
            ],
            "code": 48
        },
        {
            "type": 1,
            "pos": [
                786,
                524
            ],
            "id": "n",
            "z_level": 0,
            "mapping": [
                1049,
                1049,
                128,
                128
            ],
            "code": 49
        },
        {
            "type": 1,
            "pos": [
                917,
                524
            ],
            "id": "m",
            "z_level": 0,
            "mapping": [
                1180,
                1049,
                128,
                128
            ],
            "code": 50
        },
        {
            "type": 1,
            "pos": [
                1048,
                524
            ],
            "id": ",",
            "z_level": 0,
            "mapping": [
                1311,
                1049,
                128,
                128
            ],
            "code": 51
        },
        {
            "type": 1,
            "pos": [
                1179,
                524
            ],
            "id": ".",
            "z_level": 0,
            "mapping": [
                1442,
                1049,
                128,
                128
            ],
            "code": 52
        },
        {
            "type": 1,
            "pos": [
                1310,
                524
            ],
            "id": "/",
            "z_level": 0,
            "mapping": [
                1573,
                1049,
                128,
                128
            ],
            "code": 53
        },
        {
            "type": 1,
            "pos": [
                1703,
                524
            ],
            "id": "rshift",
            "z_level": 0,
            "mapping": [
                1,
                1311,
                128,
                128
            ],
            "code": 54
        },
        {
            "type": 1,
            "pos": [
                0,
                655
            ],
            "id": "lctrl",
            "z_level": 0,
            "mapping": [
                132,
                1311,
                128,
                128
            ],
            "code": 29
        },
        {
            "type": 1,
            "pos": [
                131,
                655
            ],
            "id": "lwin",
            "z_level": 0,
            "mapping": [
                263,
                1311,
                128,
                128
            ],
            "code": 3675
        },
        {
            "type": 1,
            "pos": [
                262,
                655
            ],
            "id": "lalt",
            "z_level": 0,
            "mapping": [
                394,
                1311,
                128,
                128
            ],
            "code": 56
        },
        {
            "type": 1,
            "pos": [
                404,
                655
            ],
            "id": "space",
            "z_level": 0,
            "mapping": [
                525,
                1311,
                1023,
                128
            ],
            "code": 57
        },
        {
            "type": 1,
            "pos": [
                1441,
                655
            ],
            "id": "ralt",
            "z_level": 0,
            "mapping": [
                1573,
                1311,
                128,
                128
            ],
            "code": 3640
        },
        {
            "type": 1,
            "pos": [
                1572,
                655
            ],
            "id": "rwin",
            "z_level": 0,
            "mapping": [
                1,
                1573,
                128,
                128
            ],
            "code": 3676
        },
        {
            "type": 1,
            "pos": [
                1703,
                655
            ],
            "id": "rctrl",
            "z_level": 0,
            "mapping": [
                132,
                1311,
                128,
                128
            ],
            "code": 3613
        }
    ]
}

```

`projects/presets/wasd/wasd-full.json`:

```json
{
    "default_height": 128,
    "default_width": 157,
    "elements": [
        {
            "code": 16,
            "id": "q",
            "mapping": [
                1,
                1,
                157,
                128
            ],
            "pos": [
                137,
                0
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 17,
            "id": "w",
            "mapping": [
                161,
                1,
                157,
                128
            ],
            "pos": [
                274,
                0
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 18,
            "id": "e",
            "mapping": [
                321,
                1,
                157,
                128
            ],
            "pos": [
                411,
                0
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 42,
            "id": "shift",
            "mapping": [
                481,
                1,
                157,
                128
            ],
            "pos": [
                0,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 30,
            "id": "a",
            "mapping": [
                641,
                1,
                157,
                128
            ],
            "pos": [
                137,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 31,
            "id": "s",
            "mapping": [
                801,
                1,
                157,
                128
            ],
            "pos": [
                274,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 32,
            "id": "d",
            "mapping": [
                961,
                1,
                157,
                128
            ],
            "pos": [
                411,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 29,
            "id": "ctrl",
            "mapping": [
                1121,
                1,
                157,
                128
            ],
            "pos": [
                0,
                266
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 57,
            "id": "space",
            "mapping": [
                1301,
                1,
                421,
                128
            ],
            "pos": [
                137,
                266
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 15,
            "id": "tab",
            "mapping": [
                1,
                263,
                157,
                128
            ],
            "pos": [
                0,
                0
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 19,
            "id": "r",
            "mapping": [
                161,
                263,
                157,
                128
            ],
            "pos": [
                548,
                0
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 33,
            "id": "f",
            "mapping": [
                321,
                263,
                157,
                128
            ],
            "pos": [
                548,
                133
            ],
            "type": 1,
            "z_level": 1
        }
    ],
    "flags": 0,
    "overlay_height": 394,
    "overlay_width": 705,
    "space_h": -20,
    "space_v": 5
}
```

`projects/presets/wasd/wasd-minimal.json`:

```json
{
    "default_height": 128,
    "default_width": 157,
    "elements": [
        {
            "code": 16,
            "id": "q",
            "mapping": [
                1,
                1,
                157,
                128
            ],
            "pos": [
                137,
                0
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 17,
            "id": "w",
            "mapping": [
                161,
                1,
                157,
                128
            ],
            "pos": [
                274,
                0
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 18,
            "id": "e",
            "mapping": [
                321,
                1,
                157,
                128
            ],
            "pos": [
                411,
                0
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 42,
            "id": "shift",
            "mapping": [
                481,
                1,
                157,
                128
            ],
            "pos": [
                0,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 30,
            "id": "a",
            "mapping": [
                641,
                1,
                157,
                128
            ],
            "pos": [
                137,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 31,
            "id": "s",
            "mapping": [
                801,
                1,
                157,
                128
            ],
            "pos": [
                274,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 32,
            "id": "d",
            "mapping": [
                961,
                1,
                157,
                128
            ],
            "pos": [
                411,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 29,
            "id": "ctrl",
            "mapping": [
                1121,
                1,
                157,
                128
            ],
            "pos": [
                0,
                266
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 57,
            "id": "space",
            "mapping": [
                1301,
                1,
                421,
                128
            ],
            "pos": [
                137,
                266
            ],
            "type": 1,
            "z_level": 1
        }
    ],
    "flags": 0,
    "overlay_height": 394,
    "overlay_width": 568,
    "space_h": -20,
    "space_v": 5
}
```

`projects/presets/yghj/yghj-minimal.json`:

```json
{
    "default_height": 128,
    "default_width": 157,
    "elements": [
        {
            "code": 20,
            "id": "t",
            "mapping": [
                1,
                1,
                157,
                128
            ],
            "pos": [
                137,
                0
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 21,
            "id": "y",
            "mapping": [
                161,
                1,
                157,
                128
            ],
            "pos": [
                274,
                0
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 22,
            "id": "u",
            "mapping": [
                321,
                1,
                157,
                128
            ],
            "pos": [
                411,
                0
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 33,
            "id": "f",
            "mapping": [
                481,
                1,
                157,
                128
            ],
            "pos": [
                0,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 34,
            "id": "g",
            "mapping": [
                641,
                1,
                157,
                128
            ],
            "pos": [
                137,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 35,
            "id": "h",
            "mapping": [
                801,
                1,
                157,
                128
            ],
            "pos": [
                274,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 36,
            "id": "j",
            "mapping": [
                961,
                1,
                157,
                128
            ],
            "pos": [
                411,
                133
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 46,
            "id": "c",
            "mapping": [
                1121,
                1,
                157,
                128
            ],
            "pos": [
                0,
                266
            ],
            "type": 1,
            "z_level": 1
        },
        {
            "code": 57,
            "id": "space",
            "mapping": [
                1301,
                1,
                421,
                128
            ],
            "pos": [
                137,
                266
            ],
            "type": 1,
            "z_level": 1
        }
    ],
    "flags": 0,
    "overlay_height": 394,
    "overlay_width": 568,
    "space_h": -20,
    "space_v": 5
}
```