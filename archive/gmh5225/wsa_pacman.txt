Project Path: arc_gmh5225_wsa_pacman_sz6gv0h_

Source Tree:

```txt
arc_gmh5225_wsa_pacman_sz6gv0h_
├── LICENSE
├── README
│   └── screenshots
│       ├── downgrade.png
│       ├── installed.png
│       ├── installer.png
│       ├── installing.png
│       ├── main_screen.png
│       └── settings_screen.png
├── README.md
├── analysis_options.yaml
├── assets
│   ├── icons
│   │   ├── missing_icon_background.si
│   │   ├── missing_icon_background.xml
│   │   ├── missing_icon_foreground.si
│   │   ├── missing_icon_foreground.xml
│   │   ├── missing_icon_legacy.si
│   │   └── missing_icon_legacy.svg
│   └── images
│       └── logo.png
├── embedded-tools
│   ├── AdbWinApi.dll
│   ├── AdbWinUsbApi.dll
│   ├── aapt.exe
│   ├── aapt2.exe
│   ├── adb.exe
│   └── axmldec.exe
├── installer
│   ├── installer.iss
│   └── redist
│       └── VC_redist.x64.exe
├── l10n.yaml
├── lib
│   ├── android
│   │   ├── android_utils.dart
│   │   ├── permissions.dart
│   │   ├── reader_apk.dart
│   │   └── reader_xapk.dart
│   ├── apk_installer.dart
│   ├── global_state.dart
│   ├── io
│   │   ├── aapt_input_parse.dart
│   │   └── isolate_runner.dart
│   ├── main.dart
│   ├── proto
│   │   ├── manifest_xapk.pb.dart
│   │   ├── manifest_xapk.pbenum.dart
│   │   ├── manifest_xapk.pbjson.dart
│   │   ├── manifest_xapk.pbserver.dart
│   │   ├── options.pb.dart
│   │   ├── options.pbenum.dart
│   │   ├── options.pbjson.dart
│   │   └── options.pbserver.dart
│   ├── screens
│   │   ├── settings.dart
│   │   └── wsa.dart
│   ├── theme.dart
│   ├── utils
│   │   ├── int_utils.dart
│   │   ├── locale_utils.dart
│   │   ├── misc_utils.dart
│   │   ├── regexp_utils.dart
│   │   ├── string_utils.dart
│   │   └── wsa_utils.dart
│   ├── widget
│   │   ├── adaptive_icon.dart
│   │   ├── flexible_info_bar.dart
│   │   ├── fluent_card.dart
│   │   ├── fluent_combo_box.dart
│   │   ├── fluent_expander.dart
│   │   ├── fluent_info_bar.dart
│   │   ├── fluent_text_box.dart
│   │   ├── move_window_nomax.dart
│   │   └── themed_pane_item.dart
│   └── windows
│       ├── nt_io.dart
│       ├── win_info.dart
│       ├── win_io.dart
│       ├── win_path.dart
│       ├── win_pkg.dart
│       ├── win_reg.dart
│       ├── win_wmi.dart
│       └── wsa_status.dart
├── locale
│   ├── ar.arb
│   ├── de.arb
│   ├── en.arb
│   ├── es.arb
│   ├── fa-IR.arb
│   ├── fr.arb
│   ├── he.arb
│   ├── id.arb
│   ├── it.arb
│   ├── ja.arb
│   ├── ko.arb
│   ├── pl.arb
│   ├── pt.arb
│   ├── ru.arb
│   ├── zh-Hant.arb
│   └── zh.arb
├── proto
│   ├── manifest_xapk.proto
│   ├── options.proto
│   └── protoc-generate.bat
├── pubspec.lock
├── pubspec.yaml
├── test
│   └── widget_test.dart
├── windows
│   ├── CMakeLists.txt
│   ├── flutter
│   │   ├── CMakeLists.txt
│   │   ├── generated_plugin_registrant.cc
│   │   ├── generated_plugin_registrant.h
│   │   └── generated_plugins.cmake
│   └── runner
│       ├── CMakeLists.txt
│       ├── Runner.rc
│       ├── flutter_window.cpp
│       ├── flutter_window.h
│       ├── main.cpp
│       ├── resource.h
│       ├── resources
│       │   └── app_icon.ico
│       ├── run_loop.cpp
│       ├── run_loop.h
│       ├── runner.exe.manifest
│       ├── utils.cpp
│       ├── utils.h
│       ├── win32_window.cpp
│       └── win32_window.h
└── winuwp
    ├── CMakeLists.txt
    ├── flutter
    │   ├── CMakeLists.txt
    │   ├── generated_plugin_registrant.cc
    │   ├── generated_plugin_registrant.h
    │   └── generated_plugins.cmake
    ├── project_version
    └── runner_uwp
        ├── Assets
        │   ├── LargeTile.scale-100.png
        │   ├── LargeTile.scale-125.png
        │   ├── LargeTile.scale-150.png
        │   ├── LargeTile.scale-200.png
        │   ├── LargeTile.scale-400.png
        │   ├── LockScreenLogo.scale-200.png
        │   ├── SmallTile.scale-100.png
        │   ├── SmallTile.scale-125.png
        │   ├── SmallTile.scale-150.png
        │   ├── SmallTile.scale-200.png
        │   ├── SmallTile.scale-400.png
        │   ├── SplashScreen.scale-100.png
        │   ├── SplashScreen.scale-125.png
        │   ├── SplashScreen.scale-150.png
        │   ├── SplashScreen.scale-200.png
        │   ├── SplashScreen.scale-400.png
        │   ├── Square150x150Logo.scale-100.png
        │   ├── Square150x150Logo.scale-125.png
        │   ├── Square150x150Logo.scale-150.png
        │   ├── Square150x150Logo.scale-200.png
        │   ├── Square150x150Logo.scale-400.png
        │   ├── Square44x44Logo.altform-unplated_targetsize-16.png
        │   ├── Square44x44Logo.altform-unplated_targetsize-256.png
        │   ├── Square44x44Logo.altform-unplated_targetsize-32.png
        │   ├── Square44x44Logo.altform-unplated_targetsize-48.png
        │   ├── Square44x44Logo.scale-100.png
        │   ├── Square44x44Logo.scale-125.png
        │   ├── Square44x44Logo.scale-150.png
        │   ├── Square44x44Logo.scale-200.png
        │   ├── Square44x44Logo.scale-400.png
        │   ├── Square44x44Logo.targetsize-16.png
        │   ├── Square44x44Logo.targetsize-24.png
        │   ├── Square44x44Logo.targetsize-24_altform-unplated.png
        │   ├── Square44x44Logo.targetsize-256.png
        │   ├── Square44x44Logo.targetsize-32.png
        │   ├── Square44x44Logo.targetsize-48.png
        │   ├── StoreLogo.png
        │   ├── StoreLogo.scale-100.png
        │   ├── StoreLogo.scale-125.png
        │   ├── StoreLogo.scale-150.png
        │   ├── StoreLogo.scale-200.png
        │   ├── StoreLogo.scale-400.png
        │   ├── Wide310x150Logo.scale-200.png
        │   ├── WideTile.scale-100.png
        │   ├── WideTile.scale-125.png
        │   ├── WideTile.scale-150.png
        │   ├── WideTile.scale-200.png
        │   └── WideTile.scale-400.png
        ├── CMakeLists.txt
        ├── CMakeSettings.json
        ├── Windows_TemporaryKey.pfx
        ├── appxmanifest.in
        ├── flutter_frameworkview.cpp
        ├── main.cpp
        └── resources.pri

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# wsa_pacman

![Installer](README/screenshots/installer.png?raw=true "Installer")

A GUI package manager and package installer for Windows Subsystem for Android (WSA).

Currently provides a double-click GUI installer for .apk and .xapk files that shows app information (package, icon, version and permissions), allows normal installations as well as upgrades and downgrades.

The app additionally provides a button to open Android settings and one to open the "Manage Applications" Android settings page, from which you can uninstall or disable applications and grant or revoke permissions

## Settings

- Autostart WSA
  - on/off
- Android port
  - Default: 58526
- Language
  - [All options](./locale/)
- Theme mode 
  - System
  - Dark
  - Light
- Window transparency (mica)
  - Full
  - Partial
  - Disabled
- Adaptive icon shape
  - Squircle
  - Circle
  - Rounded square
  - Disabled

<details>
  <summary>
  <ruby><p></ruby>
  
## More screenshots
  </p>
  </summary>

  ![Installing](README/screenshots/installing.png?raw=true "Installing")
  ![Installed](README/screenshots/installed.png?raw=true "Installed")
  ![Downgrade](README/screenshots/downgrade.png?raw=true "Downgrade")
  ![Main screen](README/screenshots/main_screen.png?raw=true "Main screen")
  ![Settings](README/screenshots/settings_screen.png?raw=true "Settings")
</details>

```

`analysis_options.yaml`:

```yaml
include: package:flutter_lints/flutter.yaml
```

`assets/icons/missing_icon_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#008476"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>

```

`assets/icons/missing_icon_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>
```

`assets/icons/missing_icon_legacy.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   viewBox="0 0 1024 1024"
   version="1.1"
   id="svg74">
  <defs
     id="defs78">
    <linearGradient
       id="linearGradient907">
      <stop
         style="stop-color:#739b4e;stop-opacity:1;"
         offset="0"
         id="stop903" />
      <stop
         style="stop-color:#81ad54;stop-opacity:1"
         offset="1"
         id="stop905" />
    </linearGradient>
    <linearGradient
       id="linearGradient986">
      <stop
         style="stop-color:#81ac53;stop-opacity:1"
         offset="0"
         id="stop982" />
      <stop
         style="stop-color:#8bc550;stop-opacity:1"
         offset="1"
         id="stop984" />
    </linearGradient>
    <linearGradient
       xlink:href="#linearGradient986"
       id="linearGradient974"
       gradientUnits="userSpaceOnUse"
       x1="917.03003"
       y1="511.82999"
       x2="916.26007"
       y2="883.28125" />
    <linearGradient
       xlink:href="#linearGradient907"
       id="linearGradient909"
       x1="106.7"
       y1="511.85193"
       x2="106.70095"
       y2="517.01154"
       gradientUnits="userSpaceOnUse" />
  </defs>
  <g
     id="#aad37aff"
     transform="translate(0,22.499957)">
    <path
       fill="#aad37a"
       opacity="1"
       d="m 226.42,44.42 c 9.17,-4.07 20.84,-0.43 26.1,8.12 21.54,34.7 42.95,69.49 64.54,104.17 50.33,-27.71 106.64,-44.47 163.93,-48.77 37.05,-2.74 74.48,-0.6 110.91,6.75 40.18,8.02 79.08,22.29 114.99,41.99 21.6,-34.7 43.04,-69.51 64.61,-104.24 4.11,-6.41 11.82,-10.31 19.44,-9.58 10.69,0.49 19.65,10.27 19.58,20.92 -2.41,-3.62 -3.96,-8.03 -7.56,-10.7 -4.53,-3.35 -10.19,-5.85 -15.93,-4.93 -6.1,0.92 -11.98,4.21 -15.31,9.5 -21.62,34.82 -43.07,69.76 -64.84,104.49 -15.88,-9.2 -32.81,-16.42 -49.85,-23.17 -37.13,-14.3 -76.39,-23.01 -116.07,-25.79 -7.65,-0.09 -15.24,-1.38 -22.9,-1.04 -69.81,-1.04 -139.82,16.31 -200.97,50.04 -8.09,-12.13 -15.3,-24.84 -23.25,-37.08 -13.75,-22.53 -27.79,-44.88 -41.6,-67.37 -3.48,-5.54 -9.78,-8.87 -16.19,-9.57 -5.44,-0.6 -10.65,1.89 -14.94,5.01 -3.68,2.68 -5.16,7.2 -7.76,10.76 0.08,-8.34 5.26,-16.42 13.07,-19.51 z"
       id="path46" />
    <path
       fill="#aad37a"
       opacity="1"
       d="M 119.55,411.44 C 142.77,318.04 201.56,234.3 280.5,179.47 l 0.45,0.36 c 0.22,1.41 0.37,2.84 0.43,4.28 -5.29,4.55 -11.37,8.08 -16.64,12.67 -10.52,7.69 -20.04,16.6 -29.79,25.21 -7.41,7.55 -15.22,14.73 -22.25,22.64 -42.45,46.68 -74.22,103.21 -90.95,164.11 -0.49,1.05 -0.46,2.87 -1.85,3.18 z"
       id="path48" />
    <path
       fill="#aad37a"
       opacity="1"
       d="m 743.02,179.9 0.41,-0.4 c 57.73,40.16 104.77,95.62 134.85,159.22 11.16,23.53 20.08,48.15 26.43,73.42 l -0.59,-0.31 c -1.34,-0.41 -1.32,-2.06 -1.76,-3.12 -24.37,-88.79 -80.6,-168.24 -155.69,-221.41 -2.71,-1.52 -4.81,-4.11 -3.65,-7.4 z"
       id="path50" />
  </g>
  <g
     id="#94c858ff"
     transform="translate(0,22.499957)"
     style="fill-rule:nonzero">
    <path
       id="path53"
       style="fill-rule:nonzero;fill:#94c858;fill-opacity:1"
       d="M 789.17578 70.460938 C 788.46283 70.474081 787.7468 70.535391 787.0293 70.650391 C 780.9293 71.570391 775.0507 74.860391 771.7207 80.150391 C 750.1007 114.97039 728.65086 149.91063 706.88086 184.64062 C 691.00086 175.44063 674.0693 168.2207 657.0293 161.4707 C 619.8993 147.1707 580.64094 138.45969 540.96094 135.67969 C 533.31094 135.58969 525.72055 134.30062 518.06055 134.64062 C 448.25055 133.60062 378.23984 150.94969 317.08984 184.67969 C 308.99984 172.54969 301.78984 159.83961 293.83984 147.59961 C 280.08984 125.06961 266.05023 102.72047 252.24023 80.230469 C 248.76023 74.690469 242.46078 71.360156 236.05078 70.660156 C 230.61078 70.060156 225.39937 72.549922 221.10938 75.669922 C 217.42937 78.349922 215.94961 82.869687 213.34961 86.429688 C 213.55961 90.429688 214.5007 94.430312 216.7207 97.820312 C 237.3507 131.19031 257.99992 164.54063 278.66992 197.89062 C 279.45992 199.34062 280.71922 200.63008 280.94922 202.33008 C 281.16922 203.74008 281.32086 205.16938 281.38086 206.60938 C 276.09086 211.15937 270.01023 214.6893 264.74023 219.2793 C 254.22023 226.9693 244.69922 235.88023 234.94922 244.49023 C 227.53922 252.04023 219.72922 259.22086 212.69922 267.13086 C 170.24922 313.81086 138.48 370.34023 121.75 431.24023 C 121.26 432.29023 121.29039 434.10992 119.90039 434.41992 L 119.21094 434.69922 C 110.78094 467.22922 106.91922 500.86945 106.69922 534.43945 C 376.80922 534.39945 646.9193 534.36008 917.0293 534.33008 C 917.3393 500.78008 912.9593 467.21922 904.7793 434.69922 L 904.11914 434.33008 C 902.77914 433.92008 902.79938 432.26898 902.35938 431.20898 C 877.98937 342.41898 821.75992 262.97078 746.66992 209.80078 C 743.95992 208.28078 741.85953 205.69039 743.01953 202.40039 C 743.11953 202.01039 743.31992 201.22008 743.41992 200.83008 C 764.70992 166.46008 785.99023 132.08898 807.24023 97.708984 C 809.44023 94.298984 810.37953 90.289297 810.51953 86.279297 C 808.10953 82.659297 806.56094 78.250078 802.96094 75.580078 C 798.99719 72.648828 794.16643 70.368926 789.17578 70.460938 z "
       transform="translate(0,-22.499957)" />
    <path
       opacity="1"
       d="m 106.7,511.94 c 1.50109,1.52056 3.71312,3.41007 4.96125,5.0325 131.7,131.49 286.17875,264.295 417.79875,395.865 -112.73,-0.37 -248.34225,1.01124 -361.07225,0.86124 -23.18,-3.02132 -47.6943,-16.64066 -56.11589,-38.49874 -1.4,-3.03 -1.35186,-6.52 -4.05186,-8.73 -0.01,-0.02 -0.03,-0.05 -0.04,-0.07 -1.93,-8.35 -1.16,-16.95 -1.31,-25.44 0.08,-109.43 -0.45,-219.59 -0.17,-329.02 z"
       id="path55"
       style="fill:#8fc550;fill-opacity:1;fill-rule:nonzero" />
  </g>
  <g
     id="#f2f2f2ff"
     transform="translate(0,22.499957)">
    <path
       fill="#f2f2f2"
       opacity="1"
       d="m 333.42,288.59 c 13.93,-2.13 28.65,1.53 39.88,10.06 12.11,9.01 20.1,23.36 21.16,38.44 0.97,11.78 -2.1,23.85 -8.69,33.68 -8.79,13.4 -23.91,22.46 -39.91,23.66 -13.49,1.21 -27.36,-2.96 -37.88,-11.5 -10.99,-8.73 -18.3,-21.98 -19.67,-35.96 -1.46,-13.2 2.25,-26.88 10.23,-37.5 8.28,-11.18 21.09,-18.92 34.88,-20.88 z"
       id="path58" />
    <path
       fill="#f2f2f2"
       opacity="1"
       d="m 674.4,288.67 c 12.78,-2.06 26.28,0.79 37.13,7.85 12.05,7.72 20.77,20.47 23.43,34.54 2.93,14.39 -0.55,29.91 -9.27,41.71 -9.34,12.91 -24.73,21.22 -40.67,21.78 -13.6,0.69 -27.34,-4.14 -37.53,-13.17 -10.76,-9.36 -17.5,-23.2 -18.06,-37.47 -0.76,-13.79 4.16,-27.76 13.4,-38.02 8.11,-9.17 19.47,-15.4 31.57,-17.22 z"
       id="path60" />
  </g>
  <g
     id="#ff1500ff"
     style="opacity:1;fill:#80ac52;fill-opacity:1"
     transform="translate(0,22.499957)">
    <path
       opacity="1"
       d="m 111.38,517.16 c 51.19,-0.37 102.39,-0.05 153.59,-0.16 H 917 c -0.04,112.44 0.08,224.88 -0.06,337.32 -1.5,14.5425 -6.395,25.0675 -13.6,35.9425 -4.9,6.15 -13.1375,12.3575 -19.7975,16.4275 -10.13,6.03 -24.4975,6.595 -36.2075,6.365 -54.64,0.17 -106.655,1.145 -161.295,1.205 C 626.1,914.19 563.9,914.5675 506.21,911.9 374.59,780.33 243.08,648.65 111.38,517.16 Z"
       id="path66"
       style="fill:url(#linearGradient974);fill-opacity:1" />
  </g>
  <g
     id="#739b4eff"
     transform="matrix(0.99999999,0,0,5.6421089,5.5815621e-7,-2353.4843)">
    <path
       d="m 106.7,511.85192 c 270.11,-0.04 540.22,-0.08 810.33,-0.11 -0.04,1.72 -0.0478,3.45385 -0.0378,5.18385 L 264.97,516.91192 c -51.2,0.11 -77.97244,0.007 -130.2231,0.0323 -6.72269,-1.19298 -17.77179,-3.12416 -24.59844,-4.41005 z"
       id="path63"
       style="fill:url(#linearGradient909);fill-opacity:1" />
  </g>
  <g
     id="#7ba94bff"
     transform="translate(0,22.499957)">
    <path
       fill="#7ba94b"
       opacity="1"
       d="m 901.84,888.95 c 8.33,-9.75 12.85,-22.15 15.1,-34.63 0.82,26.73 -18.59,51.97 -43.86,59.88 -8.69,3.03 -17.97,3.2 -27.08,3.04 -225.99,-0.27 -451.98,0.02 -677.98,-0.14 -31.96973,0.84841 -62.04968,-31.824 -61.14773,-62.77024 0.15022,7.82889 4.64176,17.42876 6.41975,20.93653 C 123.96085,895.68067 144.81,910.81 167.99,911.71 c 112.73,0.15 225.49,-0.18 338.22,0.19 59.94,0.23 119.89,0.04 179.83,0.11 54.64,-0.06 109.28,0.09 163.92,-0.08 11.71,0.23 23.64,-2.21 33.77,-8.24 6.66,-4.07 13.21,-8.59 18.11,-14.74 z"
       id="path69" />
    <path
       fill="#7ba94b"
       opacity="1"
       d="m 108.18,866.4 c 0.01,0.02 0.03,0.05 0.04,0.07 -0.01,-0.02 -0.03,-0.05 -0.04,-0.07 z"
       id="path71" />
  </g>
</svg>

```

`installer/installer.iss`:

```iss
; -- installer.iss --
; Generates an installer with Inno Setup.

#define tools_dir_name "embedded-tools"
#define releasedir "..\build\windows\runner\Release\"
#define instbuilddir "..\build\installer"
#define toolsdir "..\"+tools_dir_name

#define vcredist_version "14.31.31103.00"

#define executable "WSA-pacman.exe"
#define app_name "WSA Package Manager"
#define dist_appname "WSA-pacman"
#define reg_appname "wsa-pacman"
#define reg_name_installer "Package installer"

#define reg_assoc_xapk reg_appname + ".xapk"
#define reg_assoc_apk reg_appname + ".apk"

#define path_classes "SOFTWARE\Classes\"
#define path_assoc_user "Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\"
#define path_assoc_default ".DEFAULT\"+path_assoc_user 

[Setup]
AppVersion=1.3.6
PrivilegesRequired=admin
AppName=WSA PacMan
AppPublisher=alesimula
ArchitecturesInstallIn64BitMode=x64
WizardStyle=modern
DefaultDirName={autopf}\WSA PacMan
DefaultGroupName=WSA PacMan
UninstallDisplayIcon={app}\{#executable}
Compression=lzma2
SolidCompression=yes
ChangesAssociations=yes
ChangesEnvironment=yes
OutputBaseFilename={#dist_appname}-v{#SetupSetting("AppVersion")}-installer
OutputDir={#instbuilddir}

[Tasks]
Name: fileassoc_apk; Description: "{cm:AssocFileExtension,{#app_name},.apk}";
Name: fileassoc_xapk; Description: "{cm:AssocFileExtension,{#app_name},.xapk}";

[Registry]
Root: HKA; Subkey: "SYSTEM\CurrentControlSet\Control\Session Manager\Environment"; ValueType: string; ValueName: "WSA_PACMAN_HOME"; ValueData: "{app}"; Flags: createvalueifdoesntexist preservestringtype uninsdeletevalue
; File association: apk
Root: HKA; Subkey: "{#path_classes}\.apk"; ValueData: "{#reg_assoc_apk}"; Flags: uninsdeletevalue; ValueType: string; ValueName: ""
Root: HKA; Subkey: "{#path_classes}\.apk\OpenWithProgids"; ValueType: string; ValueName: "{#reg_assoc_apk}"; ValueData: ""; Flags: uninsdeletevalue
Root: HKA; Subkey: "{#path_classes}\{#reg_assoc_apk}"; ValueData: "{#reg_name_installer}"; Flags: uninsdeletekey; ValueType: string; ValueName: ""
Root: HKA; Subkey: "{#path_classes}\{#reg_assoc_apk}\DefaultIcon"; ValueData: "%WSA_PACMAN_HOME%\{#executable},0"; ValueType: expandsz;  ValueName: ""
Root: HKA; Subkey: "{#path_classes}\{#reg_assoc_apk}\shell\open\command";  ValueData: """%WSA_PACMAN_HOME%\{#executable}"" ""%1""";  ValueType: expandsz;  ValueName: ""
Root: HKU; Subkey: "{#path_assoc_default}\.apk\UserChoice"; ValueType: none; Flags: deletekey; Tasks: fileassoc_apk
Root: HKCU; Subkey: "{#path_assoc_user}\.apk\UserChoice"; ValueType: none; Flags: deletekey; Tasks: fileassoc_apk
; File association: xapk
Root: HKA; Subkey: "{#path_classes}\.xapk"; ValueData: "{#reg_assoc_xapk}"; Flags: uninsdeletevalue; ValueType: string; ValueName: ""
Root: HKA; Subkey: "{#path_classes}\.xapk\OpenWithProgids"; ValueType: string; ValueName: "{#reg_assoc_xapk}"; ValueData: ""; Flags: uninsdeletevalue
Root: HKA; Subkey: "{#path_classes}\{#reg_assoc_xapk}"; ValueData: "{#reg_name_installer}"; Flags: uninsdeletekey; ValueType: string; ValueName: ""
Root: HKA; Subkey: "{#path_classes}\{#reg_assoc_xapk}\DefaultIcon"; ValueData: "%WSA_PACMAN_HOME%\{#executable},0"; ValueType: expandsz;  ValueName: ""
Root: HKA; Subkey: "{#path_classes}\{#reg_assoc_xapk}\shell\open\command";  ValueData: """%WSA_PACMAN_HOME%\{#executable}"" ""%1""";  ValueType: expandsz;  ValueName: ""
Root: HKU; Subkey: "{#path_assoc_default}\.xapk\UserChoice"; ValueType: none; Flags: deletekey; Tasks: fileassoc_xapk
Root: HKCU; Subkey: "{#path_assoc_user}\.xapk\UserChoice"; ValueType: none; Flags: deletekey; Tasks: fileassoc_xapk

[Files]
Source: "{#releasedir}\*"; Excludes: "\*.lib,\*.exp,\{#tools_dir_name}"; DestDir: "{app}"; Flags: recursesubdirs
Source: "{#toolsdir}\*"; DestDir: "{app}\{#tools_dir_name}"; Flags: recursesubdirs
Source: ".\redist\VC_redist.x64.exe"; DestDir: {tmp}; Flags: dontcopy

[Run]
Filename: "{tmp}\VC_redist.x64.exe"; StatusMsg: "Installing Visual C++ Redistributable..."; \
  Parameters: "/quiet /norestart /install"; Check: ShouldInstallVCRedist; Flags: waituntilterminated

[Icons]
Name: "{group}\WSA PacMan"; Filename: "{app}\{#executable}"

[Code]
function ShouldInstallVCRedist: Boolean;
var 
  Version: String;
begin
  if RegQueryStringValue(HKEY_LOCAL_MACHINE, 'SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\x64', 'Version', Version) then
  begin 
    Log('VC Redist Version check : found ' + Version);
    //Check if the installed version is lower than the version included in the installer
    Result := (CompareStr(Version, 'v{#vcredist_version}')<0);
  end
  else 
  begin
    // Not even an old version installed
    Result := True;
  end;
  if (Result) then
  begin
    ExtractTemporaryFile('VC_redist.x64.exe');
  end;
end;

```

`l10n.yaml`:

```yaml
arb-dir: locale
template-arb-file: en.arb
output-class: AppLocalizations
output-localization-file: app_localizations.dart
```

`lib/android/android_utils.dart`:

```dart
// ignore_for_file: constant_identifier_names

import 'package:wsa_pacman/android/reader_apk.dart';
import 'package:wsa_pacman/android/reader_xapk.dart';
import 'package:wsa_pacman/io/isolate_runner.dart';
import 'package:wsa_pacman/utils/locale_utils.dart';

class Resource {
  ResType type;
  Iterable<String> values;
  Resource(this.values, [this.type = ResType.FILE]);
}

/// Flags passed to the apk reader isolates
enum APK_READER_FLAGS {
  UI_LOADED, LEGACY_ICON
}

enum InstallState {
  PROMPT, INSTALLING, SUCCESS, ERROR
}
enum InstallType {
  UNKNOWN, INSTALL, REINSTALL, UPDATE, DOWNGRADE
}
enum ResType {
  COLOR, FILE
}
enum AppPackage {
  NONE, APK, XAPK
}

extension AppPackageType on AppPackage {
  static AppPackage fromArguments(List<String> args) => args.isEmpty ? AppPackage.NONE : fromFilename(args.first);
  static AppPackage fromFilename(String? name) => name == null || name.isEmpty ? AppPackage.NONE : 
      name.endsWith(".xapk") ? AppPackage.XAPK : AppPackage.APK;
  IsolateRef<String, APK_READER_FLAGS>? Function(String) get read { switch (this) {
    case AppPackage.APK: return ApkReader().start;
    case AppPackage.XAPK: return XapkReader().start;
    case AppPackage.NONE: return (_)=>null;
  }}
  bool get directInstall => this == AppPackage.APK;
}

extension InstallTypeExt on InstallType {
  String buttonText(AppLocalizations locale) {switch (this) {
    case InstallType.UNKNOWN: return locale.installer_btn_install;
    case InstallType.INSTALL: return locale.installer_btn_install;
    case InstallType.REINSTALL: return locale.installer_btn_reinstall;
    case InstallType.UPDATE: return locale.installer_btn_update;
    case InstallType.DOWNGRADE: return locale.installer_btn_downgrade;
  }}
}
ResType getResType(String typeId) {switch (typeId) {
  case "1d": return ResType.COLOR;
  case "1c": return ResType.COLOR;
  default: return ResType.FILE;
}}
Map<String, String> fillType = {
  "0": "winding",
  "1": "evenOdd",
  "2": "inverseWinding",
  "3": "inverseEvenOdd",
};
Map<String, String> gradientType = {
  "0": "linear",
  "1": "radial",
  "2": "sweep"
};
```

`lib/android/permissions.dart`:

```dart
// All permissions available at https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/AndroidManifest.xml

import 'dart:collection';
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter/cupertino.dart';
import 'package:mdi/mdi.dart';
import 'package:wsa_pacman/utils/locale_utils.dart';
import 'package:collection/collection.dart';

enum AndroidPermission {
  NONE,
  X_ADMIN_BRICK,
  X_ADMIN_LOCK,
  ADMIN,
  STORAGE,
  MICROPHONE,
  CAMERA,
  LOCATION,
  PHONE,
  CALL_LOG,
  SMS,
  CONTACTS,
  CALENDAR,
  ACTIVITY_RECOGNITION,
  X_SENSORS_BODY,
  SENSORS,
  NEARBY_DEVICES, // ?
}

extension AndroidPermissionList on AndroidPermission {

  static Set<AndroidPermission> fromNames(Iterable<String> names) {
    final permissions = SplayTreeSet<AndroidPermission>((a,b)=> a.index - b.index)
        ..addAll(names.map((perm) => AndroidPermissionList.get(perm)).whereNotNull());
    if (permissions.isEmpty) permissions.add(AndroidPermission.NONE);
    return permissions;
  }

  static AndroidPermission? get(String name) => _permissions[name];


  Icon get icon {switch (this) {
    case AndroidPermission.NONE: return const Icon(Mdi.gitlab);
    case AndroidPermission.X_ADMIN_BRICK: return const Icon(Mdi.bugOutline);
    case AndroidPermission.X_ADMIN_LOCK: return const Icon(Mdi.shieldLockOutline);
    case AndroidPermission.ADMIN: return const Icon(Mdi.shieldAccountOutline);
    case AndroidPermission.STORAGE: return const Icon(Mdi.folderOutline);
    case AndroidPermission.MICROPHONE: return const Icon(Mdi.microphoneOutline);
    case AndroidPermission.CAMERA: return const Icon(Mdi.cameraOutline);
    case AndroidPermission.LOCATION: return const Icon(Mdi.mapMarkerOutline);
    case AndroidPermission.PHONE: return const Icon(Mdi.phoneOutline);
    case AndroidPermission.CALL_LOG: return const Icon(Mdi.phoneLogOutline);
    case AndroidPermission.SMS: return const Icon(Mdi.messageProcessingOutline);
    case AndroidPermission.CONTACTS: return const Icon(Mdi.contactsOutline);
    case AndroidPermission.CALENDAR: return const Icon(Mdi.calendarMonthOutline);
    case AndroidPermission.ACTIVITY_RECOGNITION: return const Icon(Mdi.run);
    case AndroidPermission.X_SENSORS_BODY: return const Icon(Mdi.heartSettingsOutline);
    case AndroidPermission.SENSORS: return const Icon(Mdi.fingerprint);
    case AndroidPermission.NEARBY_DEVICES: return const Icon(Mdi.accessPointNetwork);
  }}

  String description(AppLocalizations lang) {switch (this) {
    case AndroidPermission.NONE: return lang.android_permission_none;
    case AndroidPermission.X_ADMIN_BRICK: return lang.android_permission_admin_brick;
    case AndroidPermission.X_ADMIN_LOCK: return lang.android_permission_admin_lock;
    case AndroidPermission.ADMIN: return lang.android_permission_admin;
    case AndroidPermission.STORAGE: return lang.android_permission_storage;
    case AndroidPermission.MICROPHONE: return lang.android_permission_microphone;
    case AndroidPermission.CAMERA: return lang.android_permission_camera;
    case AndroidPermission.LOCATION: return lang.android_permission_location;
    case AndroidPermission.PHONE: return lang.android_permission_phone;
    case AndroidPermission.CALL_LOG: return lang.android_permission_call_log;
    case AndroidPermission.SMS: return lang.android_permission_sms;
    case AndroidPermission.CONTACTS: return lang.android_permission_contacts;
    case AndroidPermission.CALENDAR: return lang.android_permission_calendar;
    case AndroidPermission.ACTIVITY_RECOGNITION: return lang.android_permission_activity_recognition;
    case AndroidPermission.X_SENSORS_BODY: return lang.android_permission_sensors_body;
    case AndroidPermission.SENSORS: return lang.android_permission_sensors;
    case AndroidPermission.NEARBY_DEVICES: return lang.android_permission_nearby_devices;
  }}
 
  static final _permissions = {
    "android.permission.BRICK": AndroidPermission.X_ADMIN_BRICK,
    "android.permission.LOCK_DEVICE": AndroidPermission.X_ADMIN_LOCK,
    "android.permission.BIND_DEVICE_ADMIN": AndroidPermission.ADMIN,
    "android.permission.MANAGE_DEVICE_ADMINS": AndroidPermission.ADMIN,
    "android.permission.RESET_PASSWORD": AndroidPermission.ADMIN,

    "android.permission.READ_CONTACTS": AndroidPermission.CONTACTS,
    "android.permission.WRITE_CONTACTS": AndroidPermission.CONTACTS,

    "android.permission.READ_CALENDAR": AndroidPermission.CALENDAR,
    "android.permission.WRITE_CALENDAR": AndroidPermission.CALENDAR,

    "android.permission.ACCESS_MESSAGES_ON_ICC": AndroidPermission.SMS,
    "android.permission.SEND_SMS": AndroidPermission.SMS,
    "android.permission.RECEIVE_SMS": AndroidPermission.SMS,
    "android.permission.READ_SMS": AndroidPermission.SMS,
    "android.permission.RECEIVE_WAP_PUSH": AndroidPermission.SMS,
    "android.permission.RECEIVE_MMS": AndroidPermission.SMS,
    "android.permission.BIND_CELL_BROADCAST_SERVICE": AndroidPermission.SMS,
    "android.permission.READ_CELL_BROADCASTS": AndroidPermission.SMS,
    "android.permission.WRITE_SMS": AndroidPermission.SMS,
    "android.permission.SEND_RESPOND_VIA_MESSAGE": AndroidPermission.SMS,
    "android.permission.SEND_SMS_NO_CONFIRMATION": AndroidPermission.SMS,
    "android.permission.CARRIER_FILTER_SMS": AndroidPermission.SMS,
    "android.permission.RECEIVE_EMERGENCY_BROADCAST": AndroidPermission.SMS,
    "android.permission.MODIFY_CELL_BROADCASTS": AndroidPermission.SMS,

    "android.permission.READ_EXTERNAL_STORAGE": AndroidPermission.STORAGE,
    "android.permission.WRITE_EXTERNAL_STORAGE": AndroidPermission.STORAGE,
    "android.permission.ACCESS_MEDIA_LOCATION": AndroidPermission.STORAGE,
    "android.permission.WRITE_OBB": AndroidPermission.STORAGE,
    "android.permission.MANAGE_EXTERNAL_STORAGE": AndroidPermission.STORAGE,
    "android.permission.MANAGE_MEDIA": AndroidPermission.STORAGE,
    "android.permission.WRITE_MEDIA_STORAGE": AndroidPermission.STORAGE,
    "android.permission.MANAGE_DOCUMENTS": AndroidPermission.STORAGE,

    "android.permission.ACCESS_FINE_LOCATION": AndroidPermission.LOCATION,
    "android.permission.ACCESS_COARSE_LOCATION": AndroidPermission.LOCATION,
    "android.permission.ACCESS_BACKGROUND_LOCATION": AndroidPermission.LOCATION,
    "android.permission.ACCESS_LOCATION_EXTRA_COMMANDS": AndroidPermission.LOCATION,
    "android.permission.INSTALL_LOCATION_PROVIDER": AndroidPermission.LOCATION,
    "android.permission.INSTALL_LOCATION_TIME_ZONE_PROVIDER_SERVICE": AndroidPermission.LOCATION,
    "android.permission.BIND_TIME_ZONE_PROVIDER_SERVICE": AndroidPermission.LOCATION,
    "android.permission.LOCATION_HARDWARE": AndroidPermission.LOCATION,

    "android.permission.ACCESS_IMS_CALL_SERVICE": AndroidPermission.CALL_LOG,
    "android.permission.PERFORM_IMS_SINGLE_REGISTRATION": AndroidPermission.CALL_LOG,
    "android.permission.READ_CALL_LOG": AndroidPermission.CALL_LOG,
    "android.permission.WRITE_CALL_LOG": AndroidPermission.CALL_LOG,
    "android.permission.PROCESS_OUTGOING_CALLS": AndroidPermission.CALL_LOG,

    "android.permission.READ_PHONE_STATE": AndroidPermission.PHONE,
    "android.permission.READ_PHONE_NUMBERS": AndroidPermission.PHONE,
    "android.permission.CALL_PHONE": AndroidPermission.PHONE,
    "com.android.voicemail.permission.ADD_VOICEMAIL": AndroidPermission.PHONE,
    "android.permission.USE_SIP": AndroidPermission.PHONE,
    "android.permission.ANSWER_PHONE_CALLS": AndroidPermission.PHONE,
    "android.permission.MANAGE_OWN_CALLS": AndroidPermission.PHONE,
    "android.permission.CALL_COMPANION_APP": AndroidPermission.PHONE,
    "android.permission.EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS": AndroidPermission.PHONE,
    "android.permission.ACCEPT_HANDOVER": AndroidPermission.PHONE,
    "com.android.voicemail.permission.WRITE_VOICEMAIL": AndroidPermission.PHONE,
    "com.android.voicemail.permission.READ_VOICEMAIL": AndroidPermission.PHONE,

    "android.permission.RECORD_AUDIO": AndroidPermission.MICROPHONE,
    "android.permission.RECORD_BACKGROUND_AUDIO": AndroidPermission.MICROPHONE,

    "android.permission.ACTIVITY_RECOGNITION": AndroidPermission.ACTIVITY_RECOGNITION,

    "android.permission.CAMERA": AndroidPermission.CAMERA,
    "android.permission.BACKGROUND_CAMERA": AndroidPermission.CAMERA,
    "android.permission.SYSTEM_CAMERA": AndroidPermission.CAMERA,
    "android.permission.CAMERA_OPEN_CLOSE_LISTENER": AndroidPermission.CAMERA,

    "android.permission.HIGH_SAMPLING_RATE_SENSORS": AndroidPermission.SENSORS,
    "android.permission.BODY_SENSORS": AndroidPermission.X_SENSORS_BODY,
    "android.permission.USE_FINGERPRINT": AndroidPermission.SENSORS,
    "android.permission.USE_BIOMETRIC": AndroidPermission.SENSORS,
  };
}
```

`lib/android/reader_apk.dart`:

```dart
// ignore_for_file: non_constant_identifier_names, curly_braces_in_flow_control_structures, constant_identifier_names

import 'dart:async';
import 'dart:collection';
import 'dart:io';
import 'dart:typed_data';

import 'package:archive/archive_io.dart';
import 'package:shared_value/shared_value.dart';
import 'package:wsa_pacman/io/isolate_runner.dart';
import 'package:wsa_pacman/windows/nt_io.dart';
import 'package:wsa_pacman/windows/win_io.dart';
import 'package:wsa_pacman/windows/win_path.dart';

import 'android_utils.dart';
import 'permissions.dart';
import 'package:wsa_pacman/global_state.dart';
import 'package:wsa_pacman/main.dart';
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter/foundation.dart';
import 'package:archive/archive.dart';
import 'package:flutter/services.dart';

import 'dart:developer';
import 'dart:convert';
import 'package:jovial_svg/jovial_svg.dart';
import '../utils/regexp_utils.dart';
import '../utils/string_utils.dart';
import '../utils/misc_utils.dart';

extension on int {
  String get asResId => "0x"+toRadixString(16).padLeft(8, '0');
}

/// Reads apk file data on a different process and updates global state
/// Must call [ApkReader.start] to start the process
class ApkReader extends IsolateRunner<String, APK_READER_FLAGS> {
  //I just put '&& true' there so I could conveniently switch it off
  static bool DEBUG = !kReleaseMode && true;
  static String APK_FILE = '';
  static late Future<Map<String, Resource>> _resourceDump;
  static late Future<Map<int, String>> _stringDump;
  static late Future<Archive> _apkArchive;
  static int _versionCode = 0;

  static const String REGEX_QUOTED_TYPE = r'["'']type[0-9]+/([0-9]*)["'']';

  /// Run operation on UI thread
  /// Local variables should never be called
  void setInUIThread<T>(T value, Function(T val) setter) => executeInUi(() {
    setter(value);
  });

  /// Changes shared value on UI thread
  /// Local variables should never be called
  void updateState<T>(SharedValue<T> Function() valGetter, T dataIn) => executeInUi(() {
    valGetter().$ = dataIn;
  });

  /// Changes shared value on UI thread via a callback
  /// Local variables should never be called
  void updateStateWith<T, E>(SharedValue<T> Function() valGetter, E dataIn, [T Function(E data)? provider]) => executeInUi(() {
    final sharedValue = valGetter();
    provider != null ? sharedValue.$ = provider(dataIn) : sharedValue.$ = dataIn as T;
  });

  static Future<Archive> _initArchiveFile(File file) async {
    //var stream = InputFileStream(file.absolute.path);
    return ZipDecoder().decodeBytes(file.readAsBytesSync());
  }
  static void _initArchive() {
    //Maintain a lock on the file
    File file = File(APK_FILE)..open();
    _apkArchive = _initArchiveFile(file);
  }

  /// Decodes a binary xml
  static Future<Uint8List> _decodeXml(List<int> encoded) async {
    var axmldec = await Process.start('${Env.TOOLS_DIR}\\axmldec.exe', []);
    axmldec.stdin.add(encoded);
    //For some reason i need this
    axmldec.stdin.writeln();
    await axmldec.stdin.flush();
    await axmldec.stdin.close();
    var builder = BytesBuilder();
    //Encoded is just there not to create a new empty list
    await axmldec.stdout.fold(encoded, (prev, newv){builder.add(newv); return prev;});
    return builder.takeBytes();
  }

  /// Returns the gradient as an aapt xml element
  static Future<String> getGradient(String gradientId) async {
    Resource? gradientRes = await getResources(gradientId);
    if (gradientRes == null || !gradientRes.values.first.endsWith(".xml")) return "";
    Archive apkFile = await _apkArchive;
    ArchiveFile? gradientFile = apkFile.findFile(gradientRes.values.first);
    if (gradientFile == null) return "";
    String gradient = RegExp("<gradient.*", multiLine: true, dotAll: true).firstMatch(await decodeXml(gradientFile.content, true))?.group(0) ?? "";
    return '<aapt:attr name="android:fillColor">$gradient</aapt:attr>';
  }

  /// Starts asyncronous task to retrieve the gradient xml, returns a placeholder string containing gradent ID
  static String _getGradientPlaceholder(Map<String, Future<String>> gradients, String gradientId) {
    String placeholder = "@@FUTURE_GRADIENT_$gradientId@@";
    if (gradients.containsKey(gradientId)) return placeholder;
    else gradients[gradientId] = getGradient(gradientId);
    return placeholder;
  }

  /// Returns xml string, clears errors and normalizes fields
  static Future<String> decodeXml(Uint8List encoded, [bool isGradient = false]) async {
    Map<String, Future<String>>? futureGradients = isGradient ? null : {};
    var xml = utf8.decode(await _decodeXml(encoded), allowMalformed: true);
    if (!isGradient) xml = xml.replaceAllMapped(RegExp('([\\s\\n]android:pathData=[\'"])[^M]*(M\\s*-?[0-9])'), (m) => m.group(1)!+m.group(2)! )
      .replaceAllMapped(RegExp('<(([a-zA-Z0-9]*)\\s+$REGEX_XML_NOCLOSE)(android:fillColor=[\'"])(type1/([0-9]*)[\'"])($REGEX_XML_NOCLOSE)>', multiLine: true, dotAll: true), 
        (m) => '<${m.group(1)!}${m.group(7)!.endsWith("/") ? m.group(7)!.substring(0, m.group(7)!.length-1) : m.group(7)!}>\n${_getGradientPlaceholder(futureGradients!, "0x"+int.parse(m.group(6)!).toRadixString(16).padLeft(8, '0'))}${m.group(7)!.endsWith("/") ? "\n</${m.group(2)}>" : "\n"}')
      .replaceAllMapped(RegExp('([cC]olor=[\'"])(type([0-9])+/([0-9]*))'), (m) => m.group(1)!+'#'+(int.parse(m.group(4)!).toRadixString(16).padLeft(8, '0')) )
      .replaceAllMapped(RegExp('([\\s\\n]android:fillType=[\'"])([0-9]*)'), (m) => m.group(1)!+ (fillType[m.group(2)!] ?? "winding") );
    else xml = xml.replaceAllMapped(RegExp('([cC]olor=[\'"])(type([0-9])+/([0-9]*))'), (m) => m.group(1)!+'#'+(int.parse(m.group(4)!).toRadixString(16).padLeft(8, '0')) )
      .replaceAll(RegExp("(xmlns:[^=\\s]*|android:angle)\\s*=\\s*$REGEX_XML_QUOTED"), "")
      .replaceAllMapped(RegExp('(android:type\\s*=\\s*[\'"])([0-9]*)'), (m) => m.group(1)! + (gradientType[m.group(2)!] ?? "linear"));
    
    if (!isGradient) {
      var gradientList = await Future.wait(futureGradients!.values);
      Map<String, String> gradientMap = {}; int i = 0;
      for (var gradient in futureGradients.keys) gradientMap[gradient] = gradientList[i++];
      xml = xml.replaceAllMapped(RegExp("@@FUTURE_GRADIENT_([a-zA-Z0-9]*)@@"), (m) => gradientMap[m.group(1)] ?? "");
    }
    return xml;
  }

  /// Retrieves a resource from the resource ID
  static Future<Resource?> getResources(String resId) async {
    Map<String, Resource> resources = await _resourceDump;
    if (DEBUG) log("checking RES-ID: $resId");
    var resource = resources[resId];
    if (resource != null) {
      if (DEBUG) log("found RES-VALUES: ${resource.values} of RES-TYPE: ${resource.type} for RES-ID: $resId");
      if (resource.type == ResType.COLOR) return resource;
      Map<int, String> strings = await _stringDump;
      Iterable<String> files = strings.getAll(resource.values.map((e) => int.parse(e, radix: 16)));
      if (DEBUG) log("found RES-FILES: $files of RES-TYPE: ${resource.type} for RES-ID: $resId");
      return files.isNotEmpty ? Resource(files, resource.type) : null;
    }
    else return null;
  }

  /// Retrieves non-adaptive icon image
  Future _getIconFile(String fileName) async {
    bool isXml = fileName.endsWith(".xml");
    Archive apkFile = await _apkArchive;
    ArchiveFile IconFile = apkFile.findFile(fileName)!;
    
    Uint8List image = IconFile.content;
    String xmlData = isXml ? await decodeXml(image) : "";
    Widget? widget = isXml ? null : Image.memory(image);
    updateStateWith(()=>GState.apkIcon, isXml ? xmlData : widget, !isXml ? null : (data)=>ScalableImageWidget(si: ScalableImage.fromAvdString(data as String)));
  }

  /// Retrieves adaptive icon background and foreground images
  Future _getAdaptiveIconFiles(String? backgroundId, String foregroundId) async {
    Future<Resource?>? futureBackground = backgroundId != null ? getResources(backgroundId) : null;
    Future<Resource?> futureForeground = getResources(foregroundId);
    Resource? background = futureBackground != null ? await futureBackground : null;
    Resource foreground = (await futureForeground)!;
    bool isBackColor = background?.type == ResType.COLOR;
    bool isBackXml = !isBackColor && (background?.values.isNotEmpty ?? false) && background!.values.first.endsWith(".xml");
    bool isForeXml = foreground.values.isNotEmpty && foreground.values.first.endsWith(".xml");
    
    Archive apkFile = await _apkArchive;
    List<ArchiveFile>? backFiles = isBackColor ? [] : apkFile.getFiles(background?.values);
    List<ArchiveFile> foreFiles = apkFile.getFiles(foreground.values);
    
    Uint8List foreImg = isForeXml ? foreFiles.first.content : foreFiles.last.content;
    Uint8List? backImg = (backFiles.isEmpty) ? null : isBackXml ? backFiles.first.content : backFiles.last.content;
    var foreXml = isForeXml ? decodeXml(foreImg) : null;
    var backXml = isBackXml && backImg != null ? decodeXml(backImg) : null;
    Widget? backWidget;
    Widget? foreWidget;

    
    if (!isForeXml) foreWidget = Image.memory(foreImg);
    if (!isBackXml) backWidget = isBackColor ? null : (backImg != null) ? Image.memory(backImg) : null;

    String backXmlData = isBackXml && backXml != null ? await backXml : "";
    String foreXmlData = isForeXml ? await foreXml! : "";

    if (isBackColor) {
      final color = Color(int.parse(background!.values.first, radix: 16));
      updateState(()=>GState.apkBackgroundColor, color);
    }
    else if (backWidget != null || backXml != null) updateStateWith(()=>GState.apkBackgroundIcon, isBackXml ? backXmlData : backWidget, !isBackXml ? null : (data)=>ScalableImageWidget(si: ScalableImage.fromAvdString(data as String)));
    updateStateWith(()=>GState.apkForegroundIcon, isForeXml ? foreXmlData : foreWidget, !isForeXml ? null : (data)=>ScalableImageWidget(si: ScalableImage.fromAvdString(data as String)));
  }

  /// Retrieves installation type (whether installing for the first time, reinstalling the same version, upgrading or downgrading)
  static Future loadInstallType(String package, int versionCode) async {if (package.isNotEmpty) {
    String ipAddress = await GState.ipAddress.whenReady();
    int port = await GState.androidPort.whenReady();

    return await Process.run('${Env.TOOLS_DIR}\\adb.exe', ['-s', '$ipAddress:$port', 'shell', 'dumpsys package $package']).then((result) {
      //cmd package dump
      var verMatch = RegExp(r'(\n|\s|^)versionCode=([0-9]*)[^\n]*(\n([^\s\n]*\s)*versionName=([^\n\s_$]*))?').firstMatch(result.stdout.toString());
      int? oldVersionCode = int.tryParse(verMatch?.group(2) ?? "");
      if (result.exitCode != 0) GState.apkInstallType.update((_) => InstallType.UNKNOWN);
      else if (oldVersionCode != null) {
        GState.apkInstallType.update((_) => (oldVersionCode < versionCode) ? InstallType.UPDATE : 
            (oldVersionCode > versionCode) ? InstallType.DOWNGRADE : InstallType.REINSTALL);
        String oldVersion = verMatch!.group(5) ?? "???";
        GState.oldVersion.update((_) => oldVersion);
      }
      else GState.apkInstallType.update((_) => InstallType.INSTALL);
    }).onError((_, __) {GState.apkInstallType.update((_) => InstallType.UNKNOWN);});
  } else return null;}

  void loadInstallInfoOnUIThread(String package, int versionCode) => package.isNotEmpty ? executeInUi(() {
    GState.package.update((_) => package);
    loadInstallType(package, versionCode);
  }) : null;

  /// Retrieves APK information
  @override
  void run() async {
    File _APK_FILE_F = File(APK_FILE = data);
    bool ntSymlinkCreated = false;
    String APK_DIRECORY = _APK_FILE_F.parent.path;
    String APK_NAME = _APK_FILE_F.basename;
    
    if (!APK_NAME.isASCII) {
      String? shortName =  _APK_FILE_F.shortBaseName;
      if (shortName != null && shortName.isASCII) APK_NAME = shortName;
      else {
        String? ntSymlink = NtIO.createTempShortcut(_APK_FILE_F.absolute.path, "install-symlink@$pid.apk");
        if (ntSymlink != null) {
          ntSymlinkCreated = true;
          APK_NAME = ntSymlink;
          APK_DIRECORY = WinPath.tempSubdir;
        }
      }
    }

    _resourceDump = Process.run('${Env.TOOLS_DIR}\\aapt.exe', ['dump', 'resources', APK_NAME], workingDirectory: APK_DIRECORY).then((p) => 
      p.stdout.toString().foldToMap(r'(^|\n)\s*resource\s+(0x[0-9a-zA-Z]*)[\s]+.*\st=0x0*([^\s\n]*).*\sd=0x0*([^\s\n]*)[\s|\n]', (m) => m.group(2)!, 
      (m,old) => Resource((old != null) ? ((old.values as ListQueue<String>)..addAll([m.group(4)!])) : ListQueue<String>.from([m.group(4)!]), old?.type ?? getResType(m.group(3)!)) )
    );
    //strings.findAll('(^|\\n|\\s)*String\\s+#(${resCodes.join("|")})\\s*:\\s*([^\\s\\n]*)', 3);
    _stringDump = Process.run('${Env.TOOLS_DIR}\\aapt.exe', ['dump', 'strings', APK_NAME], workingDirectory: APK_DIRECORY).then((p) => 
      p.stdout.toString().toMap(r'(^|\n)\s*String\s+#([0-9]*)\s*:\s*([^\s\n]*)', (m) => int.parse(m.group(2)!), (m) => m.group(3)!)
    );
    _initArchive();

    bool legacyIcon = await waitFlag(APK_READER_FLAGS.LEGACY_ICON);
    Future<bool> legacyIconFound = (legacyIcon) ? Process.run('${Env.TOOLS_DIR}\\axmldec.exe', ['-i', APK_FILE], stdoutEncoding: null).then((value) async {
      String manifest = utf8.decode(await _decodeXml(value.stdout), allowMalformed: true);
      String? icon = RegExp('<application\\s+${REGEX_XML_NOCLOSE}android:icon\\s*=\\s*$REGEX_QUOTED_TYPE', multiLine: true, dotAll: true).firstMatch(manifest)?.group(2);

      Resource? resource = icon != null ? await getResources(int.parse(icon).asResId) : null;
      // first: smaller - last: bigger ? (taking the second one)
      Iterator<String>? legacyIconFiles = resource?.values.where((e) => !e.endsWith('.xml')).iterator;
      String? iconFile = (legacyIconFiles?.moveNext() ?? false) ? legacyIconFiles!.current : null;
      if (legacyIconFiles?.moveNext() ?? false) iconFile = legacyIconFiles!.current;
      if (iconFile != null) await _getIconFile(iconFile);
      return iconFile != null;
    }).onError((_,__) => false) : Future.value(false);

    Future? iconUpdThread;
    Future<ProcessResult>? inner;
    var process = Process.run('${Env.TOOLS_DIR}\\aapt.exe', ['dump', 'badging', APK_NAME], stdoutEncoding: utf8, workingDirectory: APK_DIRECORY).then((value) async {
      if (ntSymlinkCreated) NtIO.deleteNtTempDirJunction();
      if (value.exitCode == 0) {
        String dump = value.stdout;
        String? info = dump.find(r'(^|\n)package:.*');

        int versionCode = int.parse(info?.find(r"(^|\n|\s)versionCode=\s*'([^'\n\s$]*)", 2) ?? "0");
        setInUIThread(versionCode, (int v)=>ApkReader._versionCode = v);

        String package = info?.find(r"(^|\n|\s)name=\s*'([^'\n\s$]*)", 2) ?? "";
        loadInstallInfoOnUIThread(package, versionCode);

        updateStateWith(()=>GState.version, info, (String? v)=>v?.find(r"(^|\n|\s)versionName=\s*'([^'\n\s_$]*)", 2) ?? "");
        updateStateWith(()=>GState.activity, dump, (String v)=>v.find(r"(^|\n)(leanback-)?launchable-activity:.*name='([^'\n\s$]*)", 3) ?? "");

        String? application = dump.find(r'(^|\n)application:\s*(.*)');
        String? title = application?.find(r"(^|\n|\s)label='([^']*)'", 2);
        String? icon = application?.find(r"(^|\n|\s)icon='([^']*)'", 2);
        updateState(()=>GState.apkTitle, title ?? "UNKNOWN_TITLE");

        Set<AndroidPermission> permissions = dump.toSet("(^|\\n)\\s*uses-permission(-[^:]*)?:\\s+name=[\"']([^\"'\\n]*)", 
          (m) => AndroidPermissionList.get(m.group(3)!), (a,b)=> a.index - b.index);
        if (permissions.isEmpty) permissions.add(AndroidPermission.NONE);
        updateState(()=>GState.permissions, permissions);
        
        if (legacyIcon && await legacyIconFound) return;
        else if (icon?.endsWith(".xml") ?? false) inner = Process.run('${Env.TOOLS_DIR}\\aapt2.exe', ['dump', 'xmltree', '--file', icon!, APK_FILE])..then((value) {
          if (value.exitCode != 0) {log("XML ICON ERROR"); return;}
          String iconData = value.stdout.toString();
          String? background = iconData.find(r'(^|\n|\s)*E:[\s]?background\s[^\n]*\n\s*A:.*=@([^\s\n]*)', 2);
          String? foreground = iconData.find(r'(^|\n|\s)*E:[\s]?foreground\s[^\n]*\n\s*A:.*=@([^\s\n]*)', 2);
          
          if (DEBUG) log("APK-ICON-IDS: background_id=$background, foreground_id=$foreground");

          //then is apparently not called immediately
          /*resourceDump.then((value){
            String resources = value.stdout.toString();
            log(resources.findAll('(^|\\s|\\n)*$background[\\s]+.*\\sd=0x0*([^\\s\\n]*)[\\s|\\n]', 2).map((s)=>'#$s').toString());
          });*/
          if (foreground != null) iconUpdThread = _getAdaptiveIconFiles(background, foreground);
          else iconUpdThread= _getIconFile(icon);
        }); else if (icon != null && icon.isNotEmpty) {
          //Probably a png
          iconUpdThread = _getIconFile(icon);
        }
        if (DEBUG) log("APK-INFO:  title='$title', icon='$icon'");
      }
      else {
        log("ERROR");
      }
    }).onError((error, stackTrace) {
      //data.pipe.send("WEEEERROR: $stackTrace");
    });
    await process;
    if (inner != null) await inner;
    if (iconUpdThread != null) await iconUpdThread;
    setInUIThread(legacyIcon, (bool v) => setDefaultIcon(v));
    //(await _apkArchive).clear();
  }

  /// Uses the default application icon if no icon has been found
  /// Has to be called in the UI thread
  static void setDefaultIcon(bool legacyIcon) async {
    if (GState.apkForegroundIcon.$ == null && GState.apkIcon.$ == null) {
      if (legacyIcon) {
        final legacy = await ScalableImage.fromSIAsset(rootBundle, "assets/icons/missing_icon_legacy.si");
        GState.apkIcon.update((p0) => (ScalableImageWidget(si: legacy)));
      }
      else {
        final fBackground = ScalableImage.fromSIAsset(rootBundle, "assets/icons/missing_icon_background.si");
        final fForeground = ScalableImage.fromSIAsset(rootBundle, "assets/icons/missing_icon_foreground.si");
        final background = await fBackground, foreground = await fForeground;
        GState.apkBackgroundIcon.update((p0) => (ScalableImageWidget(si: background)));
        GState.apkForegroundIcon.update((p0) => (ScalableImageWidget(si: foreground)));
      }
    }
  }

  FutureOr<R> computeOrDebug<Q, R>(ComputeCallback<Q, R> callback, Q message, {String? debugLabel}) => (DEBUG) ? 
      callback(message) : compute(callback, message, debugLabel: debugLabel);

  @override
  FutureOr<void> postStartCallback(IsolateRef<String, APK_READER_FLAGS> isolate) {
    GState.legacyIcons.doWhenReady((value) {
      isolate.sendFlag(APK_READER_FLAGS.LEGACY_ICON, value);
    });
    late StreamSubscription sub; sub = GState.connectionStatus.stream.listen((event) async {
      String package = GState.package.$;
      InstallType? installType = GState.apkInstallType.$;
      if (GState.apkInstallType.$ == InstallType.UNKNOWN) {
        await loadInstallType(GState.package.$, _versionCode);
        if (GState.apkInstallType.$ != InstallType.UNKNOWN) sub.cancel();
      }
      else if (installType != null) sub.cancel();
    });
  }
}
```

`lib/android/reader_xapk.dart`:

```dart
// ignore_for_file: non_constant_identifier_names, curly_braces_in_flow_control_structures, constant_identifier_names

import 'dart:async';
import 'dart:convert';
import 'dart:developer';
import 'dart:io';
import 'package:archive/archive_io.dart';
import 'package:collection/collection.dart';

import 'package:flutter/cupertino.dart';
import 'package:wsa_pacman/android/android_utils.dart';
import 'package:wsa_pacman/android/permissions.dart';
import 'package:wsa_pacman/android/reader_apk.dart';
import 'package:wsa_pacman/global_state.dart';
import 'package:wsa_pacman/io/isolate_runner.dart';
import 'package:wsa_pacman/main.dart';
import 'package:wsa_pacman/utils/misc_utils.dart';
import 'package:wsa_pacman/proto/manifest_xapk.pb.dart';
import 'package:wsa_pacman/windows/win_io.dart';
import 'package:wsa_pacman/windows/win_path.dart';
import 'package:path/path.dart' as path;

enum Architecture {
  amd64, i386, aarch64, arm, ppc64, ppc
}

extension Architectures on Architecture {
  static late final fullRegex = '(${[for (final arch in Architecture.values) for (final label in arch.labels) label].join('|')})';
  get regex => '(${[for (final label in labels) label].join('|')})';
  List<String> get labels => (){switch (this) {
    case Architecture.i386: return ["i386", "i686", "i586", "i486", "x86"];
    case Architecture.amd64: return ["x86_64", "amd64"];
    case Architecture.arm: return ["aarch32", "arm"];
    case Architecture.aarch64: return ["arm64", "aarch64"];
    case Architecture.ppc: return ["powerpc", "ppc"];
    case Architecture.ppc64: return ["powerpc64", "ppc64"];
  }}();
}

class XapkReader extends IsolateRunner<String, APK_READER_FLAGS> {
  static int _versionCode = 0;
  static late Future<Archive> _xapkArchive;
  static late final Directory _xapkTempDir = Directory(WinPath.tempSubdir).createTempSync("XAPK-Extracted@$pid@");

  Future<Archive> _initArchiveFile(File file) async => ZipDecoder().decodeBuffer(InputFileStream(file.path));
  void _initArchive() {
    //Maintain a lock on the file
    File file = File(data)..open();
    _xapkArchive = _initArchiveFile(file);
  }

  static ManifestXapk _decodeManifest(List<int> bytes) => ManifestXapk.create()
    ..mergeFromProto3Json(utf8.decoder.fuse(json.decoder).convert(bytes));

  static Future<List<ProcessResult>> copyApkResources(List<ManifestXapk_ApkExpansion> expansions, String workingDir, String ipAddress, int port) => Future.wait(() sync* {
    int index = 0;
    for (ManifestXapk_ApkExpansion exp in expansions) {
      if (exp.installPath.isEmpty) exp.installPath = exp.file;
      final tempName = '${path.basename(workingDir)}@${index++}';
      final resourceName = path.basename(exp.installPath);
      final resourceDir = '${exp.installPath.startsWith('/') ? '' : '/sdcard/'}${path.dirname(exp.installPath)}';
      yield Process.run('${Env.TOOLS_DIR}\\adb.exe', ['-s', '$ipAddress:$port', 'push', exp.file, '/sdcard/$tempName'], workingDirectory: workingDir)
          .timeout(const Duration(seconds: 30)).then((_) =>
          Process.run('${Env.TOOLS_DIR}\\adb.exe', ['-s', '$ipAddress:$port', 'shell',
              'mkdir -p "$resourceDir"; cd "$resourceDir"; mv /sdcard/$tempName ./$resourceName'], workingDirectory: workingDir)
              .timeout(const Duration(seconds: 30)));
    }
  }());

  static void installXApk(String workingDir /* tempDir */, List<String> apkFiles, List<ManifestXapk_ApkExpansion> expansions, String ipAddress, int port, AppLocalizations lang, FileDisposeQueue disposeLock, [bool downgrade = false]) async {
    if (apkFiles.isNotEmpty) log("INSTALLING \"${apkFiles.first}\" on on $ipAddress:$port...");
    disposeLock.clear();
    var installation = Process.run('${Env.TOOLS_DIR}\\adb.exe', ['-s', '$ipAddress:$port', 'install-multiple', if (downgrade) '-r', if (downgrade) '-d', ...apkFiles], workingDirectory: workingDir)
      .timeout(const Duration(seconds: 30)).onError((error, stackTrace) => ProcessResult(-1, -1, null, null));
    final resources = copyApkResources(expansions, workingDir, ipAddress, port);
    GState.apkInstallState.update((_) => InstallState.INSTALLING);

    final result = await installation;
    await resources;

    Directory(workingDir).deleteSync(recursive: true);
    log("EXIT CODE: ${result.exitCode}");
    String error = result.stderr.toString();
    log("OUTPUT: ${result.stdout}");
    log("ERROR: $error");
    if (result.exitCode == 0) GState.apkInstallState.update((_) => InstallState.SUCCESS);
    else {
      GState.apkInstallState.update((_) => InstallState.ERROR);
      //TODO add cause
      RegExpMatch? errorMatch = RegExp(r'(^|\n)\s*adb:\s+failed\s+to\s+install\s+.*:\s+Failure\s+\[([^:]*):\s*([^\s].*[^\s])\s*\]').firstMatch(error);
      String errorCode = errorMatch?.group(2) ?? "";
      GState.errorCode.update((_) => errorCode.isNotEmpty ? errorCode : "UNKNOWN_ERROR");
      String errorDesc = errorMatch?.group(3) ?? "";
      GState.errorDesc.update((_) => errorDesc.isNotEmpty ? errorDesc : lang.installer_error_nomsg);
    }
  }

  static List<String> _getApkList(ManifestXapk manifest) {
    final archRegex = RegExp('^config\\.${Architectures.fullRegex}.*');
    final String defaultBaseName = '${manifest.packageName}.apk';
    Iterable<String> apkList;
    if (manifest.splitApks.isNotEmpty) {
      bool isBaseApk(ManifestXapk_ApkFile fileInfo) => fileInfo.id == 'base' || fileInfo.file == defaultBaseName;
      ManifestXapk_ApkFile? baseApk = manifest.splitApks.firstWhereOrNull(isBaseApk);
      if (manifest.splitApks.first == baseApk || baseApk == null) apkList = manifest.splitApks.map((e) => e.file);
      else apkList = [baseApk.file].followedBy(manifest.splitApks.whereNot(isBaseApk).map((e) => e.file));
    }
    else if (manifest.splitConfigs.isNotEmpty) {
      Iterable<String> configFiles = manifest.splitConfigs.map((e) => '$e.apk');
      apkList = manifest.splitConfigs.contains(manifest.packageName) ? configFiles : [defaultBaseName].followedBy(configFiles);
    }
    else apkList = [defaultBaseName];

    final List<String> archApkList = apkList.where((file) => archRegex.hasMatch(file)).toList();
    if (archApkList.isEmpty || archApkList.length == 1) return apkList.toList();
    apkList = apkList.whereNot((file) => archRegex.hasMatch(file));
    for (final arch in Architecture.values) {
      final regex = RegExp('^config\\.${arch.regex}.*');
      for (final file in archApkList) if (regex.hasMatch(file)) return apkList.followedBy([file]).toList();
    }
    return apkList.followedBy([apkList.first]).toList();
  }
  
  void updateManifest(ManifestXapk manifest, Set<AndroidPermission> permissions) {
    executeInUi(() {
      _versionCode = manifest.versionCode;
      GState.apkTitle.$ = manifest.name;
      GState.version.$ = manifest.versionName;
      GState.package.$ = manifest.packageName;
      GState.permissions.$ = permissions;
    });
  }

  void updateIcon(Image? image) {
    executeInUi(() async {
      if (image != null) {
        GState.apkAdaptiveNoScale.$ = true;
        GState.apkBackgroundIcon.$ = image;
        GState.apkForegroundIcon.$ = const SizedBox();
      }
      else ApkReader.setDefaultIcon(await GState.legacyIcons.whenReady());
    });
  }

  void updateInstallInfo(ManifestXapk manifest, String installDir, List<String> apkList, FileDisposeQueue disposeLock) {
    executeInUi(() {
      if (manifest.packageName.isNotEmpty) ApkReader.loadInstallType(manifest.packageName, manifest.versionCode);
      GState.installCallback.$ = (ipAddress, port, lang, [downgrade = false]) => installXApk(installDir, apkList, manifest.expansions, ipAddress, port, lang, disposeLock, downgrade);
    });
  }

  @override
  void run() async { try {
    _initArchive();
    final archive = (await _xapkArchive);
    log("LOADING MANIFEST");
    final manifestFile = archive.findFile('manifest.json');
    if (manifestFile == null) return;
    log("READING MANIFEST");
    final manifest = _decodeManifest(manifestFile.content as List<int>);
    final permissions = AndroidPermissionList.fromNames(manifest.permissions);
    updateManifest(manifest, permissions);
    String iconFile = manifest.icon.isNotEmpty ? manifest.icon : "icon.png";
    final icon = archive.findFile(iconFile);
    final image = icon != null ? Image.memory(icon.content) : null;
    updateIcon(image);

    final apkList = _getApkList(manifest);
    String installDir = _xapkTempDir.absolute.path;
    final disposeLock = FileDisposeQueue();
    
    await waitFlag(APK_READER_FLAGS.UI_LOADED);
    archive.extractAllSync(_xapkTempDir, disposeLock: disposeLock);
    updateInstallInfo(manifest, installDir, apkList, disposeLock);

    log("DIRECTORY: ${_xapkTempDir.path}");
  } catch (e) {
    _xapkTempDir.deleteSync(recursive: true);
    //(await _xapkArchive).clear();
  }}

  @override
  FutureOr<void> postStartCallback(IsolateRef<String, APK_READER_FLAGS> isolate) {
    late StreamSubscription sub; sub = GState.connectionStatus.stream.listen((event) async {
      String package = GState.package.$;
      InstallType? installType = GState.apkInstallType.$;
      if (GState.apkInstallType.$ == InstallType.UNKNOWN) {
        await ApkReader.loadInstallType(GState.package.$, _versionCode);
        if (GState.apkInstallType.$ != InstallType.UNKNOWN) sub.cancel();
      }
      else if (installType != null) sub.cancel();
    });
  }
}
```

`lib/apk_installer.dart`:

```dart
// ignore_for_file: non_constant_identifier_names, curly_braces_in_flow_control_structures

import 'dart:async';
import 'dart:io';

import 'package:wsa_pacman/android/android_utils.dart';
import 'package:wsa_pacman/android/permissions.dart';
import 'package:wsa_pacman/android/reader_apk.dart';
import 'package:wsa_pacman/global_state.dart';
import 'package:wsa_pacman/main.dart';
import 'package:wsa_pacman/utils/wsa_utils.dart';
import 'package:wsa_pacman/widget/themed_pane_item.dart';
import 'package:wsa_pacman/windows/win_io.dart';
import 'package:wsa_pacman/widget/adaptive_icon.dart';
import 'package:wsa_pacman/widget/flexible_info_bar.dart';
import 'package:wsa_pacman/widget/move_window_nomax.dart';
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter/material.dart' as material;

import 'package:bitsdojo_window/bitsdojo_window.dart';
import 'package:wsa_pacman/windows/win_path.dart';

import 'dart:developer';


class ApkInstaller extends StatefulWidget {
  const ApkInstaller({Key? key}) : super(key: key);

  static void createLaunchIcon(String package, String appName) {
    WinIO.createShortcut(
      "%LOCALAPPDATA%\\Microsoft\\WindowsApps\\${Env.WSA_INFO.familyName}\\WsaClient.exe", 
      "${WinPath.desktop}\\$appName", 
      args: "/launch wsa://$package",
      icon: '%LOCALAPPDATA%\\Packages\\${Env.WSA_INFO.familyName}\\LocalState\\$package.ico');
  }

  static void installApk(String apkFile, String ipAddress, int port, AppLocalizations lang, [bool downgrade = false]) async {
    log("INSTALLING \"$apkFile\" on on $ipAddress:$port...");
    var installation = Process.run('${Env.TOOLS_DIR}\\adb.exe', ['-s', '$ipAddress:$port', 'install', if (downgrade) '-r', if (downgrade) '-d', apkFile])
      .timeout(const Duration(seconds: 30)).onError((error, stackTrace) => ProcessResult(-1, -1, null, null));
    GState.apkInstallState.update((_) => InstallState.INSTALLING);
    var result = await installation;
    log("EXIT CODE: ${result.exitCode}");
    String error = result.stderr.toString();
    log("OUTPUT: ${result.stdout}");
    log("ERROR: ${error}");
    if (result.exitCode == 0) GState.apkInstallState.update((_) => InstallState.SUCCESS);
    else {
      GState.apkInstallState.update((_) => InstallState.ERROR);
      //TODO add cause
      RegExpMatch? errorMatch = RegExp(r'(^|\n)\s*adb:\s+failed\s+to\s+install\s+.*:\s+Failure\s+\[([^:]*):\s*([^\s].*[^\s])\s*\]').firstMatch(error);
      String errorCode = errorMatch?.group(2) ?? "";
      GState.errorCode.update((_) => errorCode.isNotEmpty ? errorCode : "UNKNOWN_ERROR");
      String errorDesc = errorMatch?.group(3) ?? "";
      GState.errorDesc.update((_) => errorDesc.isNotEmpty ? errorDesc : lang.installer_error_nomsg);
    }
  }

  @override
  _ApkInstallerState createState() => _ApkInstallerState();
}

class _ApkInstallerState extends State<ApkInstaller> {
  int index = 0;
  ToggleButtonThemeData? warningButtonTheme;
  bool createShortcut = false;
  bool startingWSA = false;
  
  @override
  Widget build(BuildContext context) {
    final lang = AppLocalizations.of(context)!;
    final isLtr = Directionality.of(context) == TextDirection.ltr;
    Widget icon;
    String appTitle = GState.apkTitle.of(context);
    Widget? aForeground = GState.apkForegroundIcon.of(context);
    bool adaptiveNoScale = GState.apkAdaptiveNoScale.of(context);
    Widget? lIcon = GState.apkIcon.of(context);
    WSAStatusAlert connectionStatus = GState.connectionStatus.of(context);
    bool isConnected = connectionStatus.isConnected;
    InstallType? installType = GState.apkInstallType.of(context);
    bool canInstall = isConnected && installType != null && installType != InstallType.UNKNOWN;
    InstallState installState = GState.apkInstallState.of(context);
    final mica = GState.mica.of(context);
    final theme = FluentTheme.of(context);
    if (startingWSA && isConnected) startingWSA = false;
    final autostartWSA = !startingWSA && !isConnected && GState.autostartWSA.of(context);

    if (autostartWSA) {
      startingWSA = true;
      if (!WSAUtils.launch()) setState(() {startingWSA = false;});
    }

    if (installType == InstallType.DOWNGRADE && warningButtonTheme == null) warningButtonTheme = ToggleButtonThemeData.standard(theme.copyWith(accentColor: Colors.orange));

    String package = GState.package.of(context);
    String version = GState.version.of(context);
    String activity = GState.activity.of(context);
    bool isLaunchable = package.isNotEmpty && activity.isNotEmpty;

    String oldVersion = GState.oldVersion.of(context);

    String ipAddress = GState.ipAddress.of(context);
    int port = GState.androidPort.of(context);

    if (aForeground != null) icon = AdaptiveIcon(noScale: adaptiveNoScale, backColor: GState.apkBackgroundColor.of(context), background: GState.apkBackgroundIcon.of(context), foreground: aForeground, radius: GState.iconShape.of(context).radius);
    else if (lIcon != null) icon = FittedBox(child: lIcon);
    else icon = const ProgressRing();

    Widget titleWidget = Row (
      crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Flexible(child: SizedBox(width: 30.00, height: 30.00, child: icon)), const Flexible(child: SizedBox(width: 20)), Text(appTitle, style: theme.typography.bodyLarge), 
                //Spacer(), WindowButtons()
      ]
    );

    return Mica(child: moveWindow(Padding(
      padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 20),
      child: Column (
        crossAxisAlignment: CrossAxisAlignment.start,
        children: ((){switch(installState) {case InstallState.PROMPT: return [
          titleWidget,
          Column (
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 10),
              Text(lang.installer_message),
              const SizedBox(height: 10),
              Text((oldVersion.isNotEmpty ? lang.installer_info_version_change(oldVersion, version) : lang.installer_info_version(version)).replaceAll(' ', '\u00A0'), style: TextStyle(color: theme.disabledColor), overflow: TextOverflow.ellipsis, maxLines: 1),
              Text(lang.installer_info_package(package).replaceAll(' ', '\u00A0'), style: TextStyle(color: theme.disabledColor), overflow: TextOverflow.ellipsis, maxLines: 1),
              /*ListView(
                padding: EdgeInsets.only(
                  bottom: kPageDefaultVerticalPadding,
                  left: PageHeader.horizontalPadding(context),
                  right: PageHeader.horizontalPadding(context),
                ),
                //controller: controller,
                children: [const Text("Hello darkness my old friend", )]
              )*/
            ]
          ),
          const SizedBox(height: 10),
          Expanded(child: ClipRRect(borderRadius: BorderRadius.circular(10), child: Container(
            //decoration: ChipTheme.of(context).decoration?.resolve({ButtonStates.focused})?.lerpTo(SnackbarTheme.of(context).decoration, 0.07),
            color: mica.disabled || theme.brightness.isDark ? theme.inactiveBackgroundColor.lerpWith(theme.scaffoldBackgroundColor, 0.65)
              : theme.scaffoldBackgroundColor.lerpWith(theme.inactiveBackgroundColor, 0.038),
            padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 10),
            //color: Colors.red, 
            child: ListView(
            //padding: const EdgeInsets.all(5),
            children: [
              for (var permission in GState.permissions.of(context)) Container(
                padding: EdgeInsets.only(right: isLtr ? 10 : 0, left: isLtr ? 0 : 10),
                child: ThemablePaneItem(
                  title: Text(permission.description(lang)),
                  icon: permission.icon,
                  translucent: mica.enabled
                ).build(
                  context,
                  false,
                  (){1;},
                  displayMode: PaneDisplayMode.open,
                )
              )
            ],
          )))),
          const SizedBox(height: 20),
          //const Spacer(),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              noMoveWindow(Button(
                child: Text(lang.installer_btn_cancel),
                onPressed: false ? null : (){appWindow.close();},
              )),
              const SizedBox(width: 15),
              noMoveWindow(ToggleButton(
                child: Text(startingWSA ? lang.installer_btn_starting : installType?.buttonText(lang) ?? lang.installer_btn_loading),
                checked: true,
                style: installType == InstallType.DOWNGRADE ? warningButtonTheme : null,
                onChanged: !canInstall ? null : (_){
                  if (Constants.packageType.directInstall) ApkInstaller.installApk(Constants.packageFile, ipAddress, port, lang, installType == InstallType.DOWNGRADE);
                  else GState.installCallback.$?.call(ipAddress, port, lang, installType == InstallType.DOWNGRADE);
                },
              )),
              /*const SizedBox(width: 15),noMoveWindow(ToggleButton(
                child: const Text('TEST-ICON'),
                checked: true,
                onChanged: (_){ApkReader.init();},
              ))*/
            ]
          )
        ];
        case InstallState.INSTALLING: return [
          titleWidget,
          const SizedBox(height: 10),
          Text(lang.installer_installing(appTitle)),
          const Spacer(),
          Row(children: const [Expanded(child: ProgressBar(strokeWidth: 6))]),
        ];
        case InstallState.SUCCESS: return [
          titleWidget,
          const SizedBox(height: 10),
          Text(lang.installer_installed(appTitle)),
          if (installType == InstallType.INSTALL) const SizedBox(height: 10),
          if (installType == InstallType.INSTALL) Checkbox(
            checked: createShortcut,
            content: Text(lang.installer_btn_checkbox_shortcut),
            onChanged: (value) => setState(() => createShortcut = value!),
          ),
          const Spacer(),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              noMoveWindow(Button(
                child: Text(lang.installer_btn_dismiss),
                onPressed: (){if (createShortcut) ApkInstaller.createLaunchIcon(package, appTitle); appWindow.close();},
              )),
              (){return isLaunchable ? const SizedBox(width: 15) : const SizedBox.shrink();}(),
              (){return isLaunchable ? noMoveWindow(ToggleButton(
                child: Text(lang.installer_btn_open),
                checked: true,
                onChanged: (_){if (createShortcut) ApkInstaller.createLaunchIcon(package, appTitle); WSAUtils.launchApp(package); appWindow.close();},
              )) : const SizedBox.shrink();}()
            ]
          )
        ];
        case InstallState.ERROR: return [
          titleWidget,
          const SizedBox(height: 10),
          Text(lang.installer_fail(appTitle)),
          const SizedBox(height: 10),
          FlexibleInfoBar(
            title: noMoveWindow(material.SelectableText(GState.errorCode.of(context))),
            content: noMoveWindow(material.SelectableText(GState.errorDesc.of(context))),
            severity: InfoBarSeverity.error
          ),
          const SizedBox(height: 20),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              noMoveWindow(Button(
                child: Text(lang.installer_btn_dismiss),
                onPressed: (){appWindow.close();},
              ))
            ]
          )
        ];
        default: return [] as List<Widget> ;
        }})(),
      ),
    )));
  }
}
```

`lib/global_state.dart`:

```dart
// ignore_for_file: non_constant_identifier_names, constant_identifier_names, curly_braces_in_flow_control_structures, camel_case_extensions

import 'dart:async';
import 'dart:developer';
import 'dart:io';
import 'dart:typed_data';

import 'package:flutter_gen/gen_l10n/app_localizations.dart';
export 'package:flutter_gen/gen_l10n/app_localizations.dart';
import 'package:intl/intl.dart' as intl;
import 'package:protobuf/protobuf.dart';
import 'package:wsa_pacman/android/android_utils.dart';
import 'package:wsa_pacman/android/permissions.dart';
import 'package:wsa_pacman/main.dart';
import 'package:shared_value/shared_value.dart';
import 'package:synchronized/synchronized.dart';
import 'package:wsa_pacman/utils/locale_utils.dart';
import 'package:wsa_pacman/utils/misc_utils.dart';
import 'package:wsa_pacman/windows/win_info.dart';
import 'package:wsa_pacman/windows/win_io.dart';
import 'package:fixnum/fixnum.dart' as $fixnum;

import 'proto/options.pb.dart';
import 'utils/string_utils.dart';
import 'utils/int_utils.dart';
import 'package:fluent_ui/fluent_ui.dart';

class GState {
  // App options
  static final connectionStatus = SharedValue(value: WSAPeriodicConnector.alertStatus);
  static final ipAddress = PersistableValue(value: "127.0.0.1", loader: (o)=>o.ipAddress.asIpv4, setter:  (o,e)=>o.ipAddress = e.ipv4AsInt ?? IntUtils.LOCALHOST);
  static final androidPort = PersistableValue(value: 58526, loader: (o)=>o.port, setter: (o,e)=>o.port = e);
  static final androidPortPending = SharedValue(value: androidPort.$.toString());
  // Interface options
  static final locale = PersistableValue<NamedLocale>(value: LocaleUtils.SYSTEM_LOCALE, loader: (o)=>LocaleUtils.fromLCIDOrDefault(o.locale), setter: (o,e)=> o.locale = e.lcid);
  // Theme options
  static final theme = PersistableValue(value: Options_Theme.SYSTEM, loader: (o)=>o.theme, setter: (o,e)=> o.theme = e); 
  static final iconShape = PersistableValue(value: Options_IconShape.SQUIRCLE, loader: (o)=>o.iconShape, setter: (o,e)=> o.iconShape = e);
  static final legacyIcons = PersistableValue(value: false, loader: (o)=>o.legacyIcons, setter: (o,e)=> o.legacyIcons = e);
  static final mica = PersistableValue(value: Options_Mica.FULL, loader: (o)=>o.mica, setter: (o,e)=> o.mica = e);
  static final autostartWSA = PersistableValue(value: false, loader: (o)=>o.autostart, setter: (o,e)=> o.autostart = e);
  // APK Info
  static final apkTitle = SharedValue<String>(value: "");
  static final package = SharedValue<String>(value: "");
  static final activity = SharedValue<String>(value: "");
  static final version = SharedValue<String>(value: "");
  static final oldVersion = SharedValue<String>(value: "");
  static final permissions = SharedValue<Set<AndroidPermission>>(value: {});
  static final apkInstallType = SharedValue<InstallType?>(value: null);
  static final apkInstallState = SharedValue<InstallState>(value: InstallState.PROMPT);
  static final apkIcon = SharedValue<Widget?>(value: null);
  static final apkBackgroundIcon = SharedValue<Widget?>(value: null);
  static final apkForegroundIcon = SharedValue<Widget?>(value: null);
  static final apkAdaptiveNoScale = SharedValue<bool>(value: false);
  static final apkBackgroundColor = SharedValue<Color?>(value: null);
  static final installCallback = SharedValue<Function(String ipAddress, int port, AppLocalizations lang, [bool downgrade])?>(value: null);
  // Installation info
  static final errorCode = SharedValue<String>(value: "");
  static final errorDesc = SharedValue<String>(value: "");
}

const String UNLOCALIZED_OPTION = "UNLOCALIZED_OPTION";

extension Options_Micas_Ext on Options_Mica {
  static late final bool isSupported = WinVer.isWindows11OrGreater;
  bool get supported => isSupported;
  bool get disabled => this == Options_Mica.DISABLED || !isSupported;
  bool get enabled => this != Options_Mica.DISABLED && isSupported;
  bool get full => this == Options_Mica.FULL && isSupported;
  bool get partial => this == Options_Mica.PARTIAL && isSupported;

  String description(AppLocalizations lang) {switch (this) {
    case Options_Mica.FULL: return lang.theme_mica_full;
    case Options_Mica.PARTIAL: return lang.theme_mica_partial;
    case Options_Mica.DISABLED: return lang.settings_option_generic_disabled;
    default: return UNLOCALIZED_OPTION;
  }}
}

extension Options_IconShape_Ext on Options_IconShape? {
  double get radius {switch (this) {
    case Options_IconShape.SQUIRCLE: return 0.6;
    case Options_IconShape.CIRCLE: return 1;
    case Options_IconShape.ROUNDED_SQUARE: return 0.35;
    default: return 0.6;
  }}

  String description(AppLocalizations lang) {switch (this) {
    case Options_IconShape.SQUIRCLE: return lang.theme_icon_adaptive_squircle;
    case Options_IconShape.CIRCLE: return lang.theme_icon_adaptive_circle;
    case Options_IconShape.ROUNDED_SQUARE: return lang.theme_icon_adaptive_rounded_square;
    default: return UNLOCALIZED_OPTION;
  }}
}

extension Options_Theme_Mode on Options_Theme? {
  ThemeMode get mode {switch (this) {
    case Options_Theme.SYSTEM: return ThemeMode.system;
    case Options_Theme.LIGHT: return ThemeMode.light;
    case Options_Theme.DARK: return ThemeMode.dark;
    default: return ThemeMode.system;
  }}

  String description(AppLocalizations lang) {switch (this) {
    case Options_Theme.SYSTEM: return lang.settings_option_generic_system;
    case Options_Theme.LIGHT: return lang.theme_mode_light;
    case Options_Theme.DARK: return lang.theme_mode_dark;
    default: return UNLOCALIZED_OPTION;
  }}
}

class AppOptions {
  static const PERIODIC_FILE_CHECK_TIMER = Duration(seconds: 2);
  static final _fileLock = Lock();
  static final _protoLock = Lock();
  static Options? _options;
  static File? _optionsFile;
  static late Future<DateTime> _lastModified;
  static Future<Options> _optionsFuture = () async {
    // TODO options file migration; remove eventually
    final oldDirectory = Directory("${Env.USER_PROFILE}${RegExp(r'.*[/\\]$').hasMatch(Env.USER_PROFILE) ? '' : r'\'}.wsamanager\\");
    // TODO options file migration; remove eventually
    final _oldOtionsFile = File("${oldDirectory.path}\\options.bin");
    final directory = Directory("${Env.USER_PROFILE}${RegExp(r'.*[/\\]$').hasMatch(Env.USER_PROFILE) ? '' : r'\'}.wsa-pacman\\")..createSync();
    // TODO options file migration; remove eventually
    if (oldDirectory.existsSync()) {
      if (_oldOtionsFile.existsSync()) {
        if (!File("${directory.path}\\options.bin").existsSync()) _oldOtionsFile.copySync("${directory.path}\\options.bin");
        _oldOtionsFile.deleteSync();
      }
      oldDirectory.delete(recursive: false);
    }
    _optionsFile = File("${directory.path}\\options.bin")..createSync()..openSync();
    _lastModified = _optionsFile!.lastModified();
    directory.watch().listen((event) {
      if (event.path.endsWith('\\options.bin')) _checkSettingsFileChange();
    });
    try {return (_options = Options.fromBuffer(_optionsFile!.readAsBytesSync()));}
    on InvalidProtocolBufferException catch(_) {return Options();}
  }();

  static void _checkSettingsFileChange() async {
    late final bool shouldUpdate;
    await AppOptions._fileLock.synchronized(() async {
      final newLastModified = _optionsFile!.lastModifiedAccurate() ?? await _optionsFile!.lastModified();
      shouldUpdate = (newLastModified.isAfter(await _lastModified));
      if (shouldUpdate) _lastModified = Future.value(newLastModified);
    });
    if (shouldUpdate) {
      _options = null;
      _optionsFuture = () async {
        Options options;
        try {options = (_options = Options.fromBuffer(_optionsFile!.readAsBytesSync()));}
        on InvalidProtocolBufferException catch(_) {options = (_options = Options());}
        PersistableValue.reinitializeAll();
        return options;
      }();
    }
  }

  //Call to initialize reading options as soon as possible
  static void init() {}

  static Future withOptions(Function(Options options) setter) {return _protoLock.synchronized(() async {
    setter(_options ?? await _optionsFuture);
  });}
}

class PersistableValue<T> extends SharedValue<T> {

  final Function(Options options, T value) _setter;
  Future? _initializer;
  static final List<Function(Options options)> _reinitializers = [];
  static void reinitializeAll() => AppOptions.withOptions((options) {for (final reinitializer in _reinitializers) reinitializer(options);});

  PersistableValue({String? key, required T value, required T Function(Options options) loader, required Function(Options options, T value) setter, bool autosave = false})
      : _setter = setter, super(key: key, value: value, autosave: autosave){
    reinitializer(Options options) {super.setIfChanged(loader(options)); _initializer = null;}
    _initializer = AppOptions.withOptions(reinitializer);
    _reinitializers.add(reinitializer);
  }

  static Future persistOptions() {return AppOptions._fileLock.synchronized(() async {
    File optionsFile;
    if (AppOptions._optionsFile != null) optionsFile = AppOptions._optionsFile!;
    else {
      await AppOptions._optionsFuture;
      optionsFile = AppOptions._optionsFile!;
    }
    //optionsFile.writeAsBytesSync((_options ?? await _optionsFuture).writeToBuffer());
    Uint8List? optionBytes;
    await AppOptions.withOptions((options) => optionBytes = options.writeToBuffer());
    optionsFile.writeAsBytesSync(optionBytes!);
    AppOptions._lastModified = Future.value(DateTime.now());
  });}

  Future persist() => persistOptions();

  void _saveOptions() => AppOptions.withOptions((options) => _setter(options, $));

  void doWhenReady(void Function(T value) callback, [BuildContext? context]) {
    final initializer = _initializer;
    if (initializer != null) initializer.then((_)=>callback(context == null ? $ : of(context)));
    else callback(context == null ? $ : of(context));
  }

  Future<T> whenReady([BuildContext? context]) async {
    final initializer = _initializer;
    if (initializer != null) await initializer;
    return context == null ? $ : of(context);
  }

  @override
  T of(BuildContext? context) {
    // TODO: implement of
    return super.of(context);
  }

  @override
  set $(T newValue) {
    super.$ = newValue;
    _saveOptions();
  }
}
```

`lib/io/aapt_input_parse.dart`:

```dart

// ignore_for_file: curly_braces_in_flow_control_structures

class Node {
  int _hIndex;
  Node? parent;
  final List<String> values;
  final Map<String, Node> children = {};

  bool get hasValues => values.isNotEmpty;
  bool get hasChildren => children.isNotEmpty;
  String? get value => values.isNotEmpty ? values[0] : null;

  Node(this._hIndex, this.values, {this.parent});
  Node.single(String value) : this(0, [value]);
  Node.empty() : this(0, []);
}

//Missing grouping and kind of janky
//Using regular expressions for now
Map<String, Node> read(String output) {
  bool inThisNode = true;
  int? substrIndex = 0;
  int? lastNodePos = 0;
  Node? lastNode;
  Node? newNode;
  Map<String, Node> map = {};
  for (var e in output.split('\n')) {
    substrIndex = e.indexOf(':');
    if (substrIndex == -1) {newNode = null; continue;}
    inThisNode = true;
    int nodePos = e.indexOf(RegExp(r'[^\s]'));
    int _lastPos = (lastNodePos ?? nodePos);

    String key = e.substring(0,substrIndex).trim();
    String value = e.substring(substrIndex+1).trim();

    var parent = lastNode?.parent;
    if (_lastPos != nodePos || parent != null) {
      inThisNode = false;
      if (_lastPos < nodePos) {
        newNode = Node(nodePos, [value], parent: lastNode);
        lastNode!.children[key] = newNode;
        lastNode = newNode;
      }
      else {
        while (lastNode!._hIndex != nodePos) lastNode = lastNode.parent;
        var parent = lastNode.parent;
        if (parent == null) inThisNode = true;
        else parent.children[key] = (lastNode = Node(nodePos, [value], parent: parent));
      }
    }
    lastNodePos = nodePos;
    //log("NODE: ${nodePos}");
    if (inThisNode) lastNode = (newNode = Node(nodePos, [value]));
    if(key.isNotEmpty && inThisNode) map[key] = newNode!;
  }
  return map;
}

```

`lib/io/isolate_runner.dart`:

```dart
// ignore_for_file: curly_braces_in_flow_control_structures

import 'dart:async';
import 'dart:isolate';

import 'package:flutter/foundation.dart';
import 'package:synchronized/synchronized.dart';
import 'package:meta/meta.dart';

class _IsolateMessage<E extends Enum> {
  final E flag;
  final bool value;
  _IsolateMessage(this.flag, this.value);
}

class _IsolateData<O, FLAGS extends Enum> {
  O? data;
  final Completer<SendPort> _uiToIsolatePortCompleter;
  SendPort? _uiToIsolatePort;
  final SendPort _isolateToUiPort;
  
  _IsolateData._withCompleter(this.data, final Completer<SendPort> portCompleter) : _uiToIsolatePortCompleter = portCompleter, _isolateToUiPort = (ReceivePort()..listen((message) {
    if (message is VoidCallback) {message();}
    else if (message is SendPort) {portCompleter.complete(message);}
  })).sendPort;

  _IsolateData(O data) : this._withCompleter(data, Completer());

  //Listener has to execute this in the main thread
  void _executeInUi(VoidCallback callback) {
    _isolateToUiPort.send(callback);
  }
  void _sendToIsolate(_IsolateMessage<FLAGS> a) async {
    (_uiToIsolatePort ?? (_uiToIsolatePort = await _uiToIsolatePortCompleter.future)).send(a);
  }
}

class IsolateRef<O, FLAGS extends Enum> {
  final _IsolateData<O, FLAGS> _data;
  IsolateRef._(this._data);

  void sendFlag(FLAGS flag, bool value) => _data._sendToIsolate(_IsolateMessage(flag, value));
}

/// Simplifies running an isolate
/// Allows running a callback in the UI thread
/// Allows waiting for a signal from the UI thread
/// Most fields are static not to be caught up in the executeInUi method
abstract class IsolateRunner<O, FLAGS extends Enum> {
  static late final _flags = <Enum, Completer<bool>>{};
  static late final _flagsLock = Lock();
  static late final dynamic _data;
  static late final _IsolateData _pData;

  /// Data passed to the start method
  @nonVirtual O get data => _data;
  /// Main runner, must be overridden
  @visibleForOverriding FutureOr<void> run();
  /// Executed in the UI thread after starting the isolate
  FutureOr<void> postStartCallback(IsolateRef<O, FLAGS> isolate) {}
  /// Waits for a flag from the UI thread, may stay locked indefinitely
  @nonVirtual Future<bool> waitFlag(FLAGS flag) async => await (await _flagsLock.synchronized(()=>_flags.putIfAbsent(flag, ()=>Completer()))).future;
  /// Executes a callback in the UI thread
  /// Will load all local variables in the current scope if one is referenced, therefore use carefully
  @nonVirtual void executeInUi(VoidCallback callback) => _pData._executeInUi(callback);

  void _runInitIsolate(_IsolateData<O, FLAGS> pData) async {
    (_pData = pData)._isolateToUiPort.send((ReceivePort()..listen((message) {
      if (message is _IsolateMessage<FLAGS>) _flagsLock.synchronized(() {
        _flags.putIfAbsent(message.flag, ()=>Completer()).complete(message.value);
      });
    })).sendPort);
    _data = pData.data;
    // Should prevent this data from beins sent when launching executeInUi
    pData.data = null;
    await run();
  }

  @nonVirtual
  IsolateRef<O, FLAGS> start(O data) => IsolateRunner._start(this, data);

  /// Starts a process to read apk data
  static IsolateRef<O, FLAGS> _start<O, FLAGS extends Enum>(IsolateRunner<O, FLAGS> runner, O data) {
    //APK_FILE = fileName;
    //Recheck installation type when connected
    final isolateRef = IsolateRef._(_IsolateData<O, FLAGS>(data));
    compute(runner._runInitIsolate, isolateRef._data);
    runner.postStartCallback(isolateRef);
    return isolateRef;
  }
}
```

`lib/main.dart`:

```dart
// ignore_for_file: constant_identifier_names, curly_braces_in_flow_control_structures, non_constant_identifier_names



import 'dart:ui';

import 'package:flutter/material.dart' as material;
import 'package:mdi/mdi.dart';
import 'package:flutter_localizations/flutter_localizations.dart' as locale;
import 'package:wsa_pacman/android/android_utils.dart';
import 'package:wsa_pacman/apk_installer.dart';
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter/foundation.dart';
//import 'package:flutter/material.dart' hide showDialog;
import 'package:shared_value/shared_value.dart';
import 'package:wsa_pacman/io/isolate_runner.dart';
import 'package:wsa_pacman/utils/misc_utils.dart';
import 'package:wsa_pacman/utils/wsa_utils.dart';
import 'package:wsa_pacman/utils/locale_utils.dart';
import 'package:wsa_pacman/widget/themed_pane_item.dart';
import 'package:wsa_pacman/windows/win_info.dart';
import 'package:wsa_pacman/windows/win_reg.dart';
import 'package:wsa_pacman/windows/wsa_status.dart';
import 'global_state.dart';

import 'package:provider/provider.dart';
import 'package:system_theme/system_theme.dart';
import 'package:bitsdojo_window/bitsdojo_window.dart';
import 'package:flutter_acrylic/flutter_acrylic.dart' as flutter_acrylic;
import 'package:url_strategy/url_strategy.dart';

import 'screens/wsa.dart';
import 'screens/settings.dart';
import 'utils/string_utils.dart';

import 'dart:io';
import 'dart:developer';
import 'dart:async';

import 'theme.dart';

const String appTitle = 'WSA Package Manager';
const String appVersion = '1.3.6';

late bool darkMode;

class WSAStatusAlert {
  WSAStatusAlert(this.type, this.severity, this.title, this.desc);

  final ConnectionStatus type;
  final InfoBarSeverity severity;
  final String Function(AppLocalizations lang) title;
  final String Function(AppLocalizations lang) desc;

  bool get isConnected => type == ConnectionStatus.CONNECTED;
  bool get isDisconnected => type != ConnectionStatus.CONNECTED;
}

enum ConnectionStatus {
  UNSUPPORTED, MISSING, UNKNOWN, ARRESTED, STARTING, OFFLINE, DISCONNECTED, CONNECTED
}
extension on ConnectionStatus {
  static final Map<ConnectionStatus, WSAStatusAlert> _statusAlers = {
    ConnectionStatus.UNSUPPORTED: WSAStatusAlert(ConnectionStatus.UNSUPPORTED, InfoBarSeverity.error, (l)=>l.status_unsupported, 
      (l)=>l.status_unsupported_desc(WinVer.isWindows10OrGreater ? l.status_subtext_winver_10 : l.status_subtext_winver_older)),
    ConnectionStatus.MISSING: WSAStatusAlert(ConnectionStatus.MISSING, InfoBarSeverity.error, (l)=>l.status_missing, (l)=>l.status_missing_desc),
    ConnectionStatus.UNKNOWN: WSAStatusAlert(ConnectionStatus.UNKNOWN, InfoBarSeverity.info, (l)=>l.status_unknown, (l)=>l.status_unknown_desc),
    ConnectionStatus.STARTING: WSAStatusAlert(ConnectionStatus.STARTING, InfoBarSeverity.info, (l)=>l.status_starting, (l)=>l.status_starting_desc),
    ConnectionStatus.ARRESTED: WSAStatusAlert(ConnectionStatus.ARRESTED, InfoBarSeverity.warning, (l)=>l.status_arrested, (l)=>l.status_arrested_desc),
    ConnectionStatus.OFFLINE: WSAStatusAlert(ConnectionStatus.OFFLINE, InfoBarSeverity.warning, (l)=>l.status_offline, (l)=>l.status_offline_desc),
    ConnectionStatus.DISCONNECTED: WSAStatusAlert(ConnectionStatus.DISCONNECTED, InfoBarSeverity.error, (l)=>l.status_disconnected, (l)=>l.status_disconnected_desc),
    ConnectionStatus.CONNECTED: WSAStatusAlert(ConnectionStatus.CONNECTED, InfoBarSeverity.success, (l)=>l.status_connected, (l)=>l.status_connected_desc),
  };

  WSAStatusAlert get statusAlert => _statusAlers[this] ?? WSAStatusAlert(this, InfoBarSeverity.error, (l)=>"Unmapped status",
    (l)=>"Encountered WSA connection status $this, the status is missing an alert message");
}

extension __EnumExtension on Enum {
  String name() {
    return toString().split('.').last.toLowerCase();
  }
}

class Env {
  static final String SYSTEM_ROOT = Platform.environment["SystemRoot"] ?? "";
  static final String USER_PROFILE = Platform.environment["UserProfile"] ?? "";
  static final String EXEC_DIR = Platform.resolvedExecutable.replaceFirst(RegExp(r'[/\\][^/\\]*$'), r'\');
  static final String TOOLS_DIR = "${EXEC_DIR}embedded-tools\\";
  static late final String POWERSHELL = WinReg.getString(RegHKey.HKEY_LOCAL_MACHINE, r'SOFTWARE\Microsoft\PowerShell\1\ShellIds\Microsoft.PowerShell', 'Path')?.value ?? '$SYSTEM_ROOT\\System32\\WindowsPowerShell\v1.0\\powershell.exe';
  static late final String WSA_SYSTEM_PATH = RegExp(r'^(.*)[\\/]+[^\\/]*[\\/]+[^\\/]*$').firstMatch(
      WinReg.getString(RegHKey.HKEY_LOCAL_MACHINE, r'SYSTEM\CurrentControlSet\Services\WsaService', 'ImagePath')?.value.unquoted ??
      WinReg.getString(RegHKey.HKEY_CURRENT_USER, r'Software\Microsoft\Windows\CurrentVersion\App Paths\WsaClient.exe', null)?.value ?? ''
    )?.group(1) ?? '';
  static late final String WSA_EXECUTABLE = '$WSA_SYSTEM_PATH\\WsaClient\\WsaClient.exe';
  static late final bool WSA_INSTALLED = File('$WSA_SYSTEM_PATH\\AppxManifest.xml').existsSync();
  static late final WSA_INFO = WSAPkgInfo.fromSystemPath(WSA_SYSTEM_PATH);
}

class WSAPeriodicConnector {
  static const PERIODIC_CHECK_BOOT_DURATION = Duration(milliseconds: 500);
  static const PERIODIC_CHECK_CONNECT_DURATION = Duration(seconds: 5);
  static int lastStart = 0;
  static bool get shouldWaitStart => DateTime.now().millisecondsSinceEpoch - lastStart < 15000;
  static final DynamicTimer timer = DynamicTimer((Timer t) => WSAPeriodicConnector._checkConnectionStatus());
  static ConnectionStatus status = ConnectionStatus.UNKNOWN;
  static WSAStatusAlert alertStatus = ConnectionStatus.UNKNOWN.statusAlert;
  static bool _statusInitialized = false;

  static void _checkConnectionStatus() async {
    if (_statusInitialized) {
      Process.run('${Env.SYSTEM_ROOT}\\System32\\tasklist.exe', []).then((result){
        if (!result.stdout.toString().contains(RegExp(r'(^|\n)adb.exe\s+'))) {
          status = ConnectionStatus.UNKNOWN;
          GState.connectionStatus.update((p0) => status.statusAlert);
        }
      });
    }

    if (!WSAStatus.isBooted) {
      timer.setDuration(PERIODIC_CHECK_BOOT_DURATION);
      ConnectionStatus newStatus = Env.WSA_INSTALLED ? ConnectionStatus.ARRESTED : WinVer.isWindows11OrGreater ? ConnectionStatus.MISSING : ConnectionStatus.UNSUPPORTED;
      if (status != newStatus) GState.connectionStatus.$ = (status = newStatus).statusAlert;
      return;
    }
    else {
      timer.setDuration(PERIODIC_CHECK_CONNECT_DURATION);
      if (status == ConnectionStatus.ARRESTED || status == ConnectionStatus.MISSING || status == ConnectionStatus.UNSUPPORTED)
          lastStart = DateTime.now().millisecondsSinceEpoch;
    }

    final prevStatus = status;
    final process = await Process.run('${Env.TOOLS_DIR}\\adb.exe', ['devices']);
    final output = process.stdout.toString();
    if (output.contains(RegExp('(^|\\n)(localhost|127.0.0.1):${GState.androidPort.$}\\s+'))) {
      if (output.contains(RegExp('(^|\\n)(localhost|127.0.0.1):${GState.androidPort.$}\\s+offline(\$|\\n|\\s)')))
        status = (status == ConnectionStatus.ARRESTED || status == ConnectionStatus.STARTING) && shouldWaitStart ? 
            ConnectionStatus.STARTING : ConnectionStatus.OFFLINE;
      else if (output.contains(RegExp('(^|\\n)(localhost|127.0.0.1):${GState.androidPort.$}\\s+host(\$|\\n|\\s)'))) {
        await Process.run('${Env.TOOLS_DIR}\\adb.exe', ['disconnect', '127.0.0.1:${GState.androidPort.$}']);
        _tryConnect();
      }
      else {
        status = ConnectionStatus.CONNECTED;
        if (output.contains(RegExp('(^|\\n)127.0.0.1:${GState.androidPort.$}\\s+'))) {
          if (GState.ipAddress.$ != "127.0.0.1") GState.ipAddress.update((old) => "127.0.0.1");
        }
        else if (GState.ipAddress.$ != "localhost") GState.ipAddress.update((old) => "localhost");
      }
    }
    //else status = ConnectionStatus.DISCONNECTED;
    /*if (status != prevStatus) {
      (alert.title as Text).data = ""
    }*/
    else await _tryConnect();
    if (status != prevStatus) GState.connectionStatus.update((p0) => status.statusAlert);
    _statusInitialized = false;
    log("Connection status: ${status.name()}");
  }

  static Future<void> _tryConnect() async {
    ProcessResult? process = await Process.run('${Env.TOOLS_DIR}\\adb.exe', ['connect', '127.0.0.1:${GState.androidPort.$}'])
      .timeout(const Duration(milliseconds:200), onTimeout: () => Future.value(ProcessResult(-1, -1, null, null)));
    if (process.stdout?.toString().contains(RegExp(r'(^|\n)(cannot|failed to) connect\s.*')) ?? true) 
      status = Env.WSA_INSTALLED ? (status == ConnectionStatus.ARRESTED || status == ConnectionStatus.STARTING) && shouldWaitStart ? 
          ConnectionStatus.STARTING : ConnectionStatus.OFFLINE : ConnectionStatus.DISCONNECTED;
    else status = ConnectionStatus.CONNECTED;
  }
}

/// Checks if the current environment is a desktop environment.
bool get isDesktop {
  if (kIsWeb) return false;
  return [
    TargetPlatform.windows,
    TargetPlatform.linux,
    TargetPlatform.macOS,
  ].contains(defaultTargetPlatform);
}

class Constants {
  //static late final List<String> args;
  static late final String packageFile;
  static late final AppPackage packageType;
  static late final bool installMode;
  static late final IsolateRef<dynamic, APK_READER_FLAGS>? isolate;
}

void main(List<String> arguments) async {
  //int prevTime = DateTime.now().millisecondsSinceEpoch;
  //arguments = [r'C:\Users\Alex\Downloads\com.google.android.googlequicksearchbox_12.41.16.23.x86_64-301172250_minAPI23(x86_64)(nodpi)_apkmirror.com.apk'];
  //arguments = [r'C:\Users\Alex\Downloads\PUBG MOBILE Aftermath_v1.8.0_apkpure.com.xapk'];
  

  WidgetsFlutterBinding.ensureInitialized();
  final darkModeFuture = SystemTheme.darkMode;
  const app = MyApp();
  final wrappedApp = SharedValue.wrapApp(app);
  darkMode = await darkModeFuture;
  runApp(wrappedApp);

  AppOptions.init();
  Constants.installMode = arguments.isNotEmpty;
  Constants.packageFile = Constants.installMode ? arguments.first : '';
  Constants.packageType = AppPackageType.fromArguments(arguments);
  Constants.isolate = Constants.installMode ? Constants.packageType.read(arguments.first) : null;

  //await SystemTheme.accentInstance.load();
  await flutter_acrylic.Window.initialize();

  WSAPeriodicConnector._checkConnectionStatus();

  flutter_acrylic.Window.hideWindowControls();
  //flutter_acrylic.Window.setEffect(effect: flutter_acrylic.WindowEffect.mica);

  if (isDesktop) {
    doWhenWindowReady(() {
      //log("UI started after ${DateTime.now().millisecondsSinceEpoch - prevTime}");
      final win = appWindow;
      if (!Constants.installMode) {
        win.minSize = const Size(640, 500);
        win.size = const Size(740, 540);
        win.title = appTitle;
      }
      else {
        win.minSize = win.maxSize = win.size = const Size(500, 335);
      }
      win.alignment = Alignment.center;
      win.show();
      late final _SET_VISIBLE = Constants.isolate?.sendFlag(APK_READER_FLAGS.UI_LOADED, true);
      late final Timer uiTimer; uiTimer = Timer.periodic(const Duration(milliseconds: 100), (t) {if (win.isVisible) {
        _SET_VISIBLE;
        uiTimer.cancel();
      }});
    });
  }
}

class _FluentLocalizationsEnglish extends LocalizationsDelegate<FluentLocalizations> {
  const _FluentLocalizationsEnglish();

  @override bool isSupported(Locale locale) => true;
  @override bool shouldReload(_FluentLocalizationsEnglish old) => false;
  @override Future<FluentLocalizations> load(Locale locale) => DefaultFluentLocalizations.load(locale);
  @override String toString() => 'DefaultFluentLocalizations.delegate(en_US)';
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  void setMicaEffect(bool micaEnabled, [bool dark = true]) {
    if (WinVer.isWindows11OrGreater)
      flutter_acrylic.Window.setEffect(effect: micaEnabled ? flutter_acrylic.WindowEffect.mica : flutter_acrylic.WindowEffect.disabled, dark: dark);
  }

  @override
  Widget build(BuildContext context) {
    final theme = GState.theme.of(context).mode;
    final mica = GState.mica.of(context);

    final bool isDark = theme == ThemeMode.system ? darkMode : theme == ThemeMode.dark;
    setMicaEffect(mica.enabled, isDark);
    final bool isMicaInstall = Constants.installMode && mica.enabled;
    final bool IsFullMicaOrInstall = mica.full || isMicaInstall;
    
    return ChangeNotifierProvider(
      create: (_) => AppTheme(),
      builder: (context, _) {
        final appTheme = context.watch<AppTheme>();
        return FluentApp(
          title: appTitle,
          themeMode: theme,
          debugShowCheckedModeBanner: false,
          initialRoute: '/',
          locale: GState.locale.of(context),
          localizationsDelegates: const [
            AppLocalizations.delegate,
            locale.GlobalMaterialLocalizations.delegate,
            locale.GlobalWidgetsLocalizations.delegate,
            //locale.GlobalCupertinoLocalizations.delegate,
            _FluentLocalizationsEnglish(),
          ],
          supportedLocales: LocaleUtils.supportedLocales,
          localeResolutionCallback: LocaleUtils.localeResolutionCallback,
          routes: {'/': (_) => Constants.installMode ? const ApkInstaller() : const MyHomePage()},
          theme: ThemeData(
            buttonTheme: ButtonThemeData(
              defaultButtonStyle: ButtonStyle(
                shadowColor: ButtonState.all(Colors.transparent),
                border: ButtonState.resolveWith((states) {
                  if (isDark) {
                    if (states.isDisabled) return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0xf0f0f0, 0.05));
                    if (states.isNone || (states.isHovering && !states.isPressing)) return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0xf0f0f0, 0.035));
                    else return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0xf0f0f0, 0.07));
                  }
                  else {
                    if (states.isDisabled) return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0x212121, 0.12));
                    if (states.isNone || (states.isHovering && !states.isDisabled && !states.isPressing)) return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0x212121, 0.22));
                    else return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0x212121, 0.07));
                  }
                }),
                backgroundColor: ButtonState.resolveWith((states) {
                  if (isDark) {
                    if (states.isDisabled) return const ColorConst.withOpacity(0xFFFFFF, 0.045);
                    if (states.isPressing) return const ColorConst.withOpacity(0xFFFFFF, 0.03);
                    if (states.isHovering) return const ColorConst.withOpacity(0xFFFFFF, 0.08);
                    return const ColorConst.withOpacity(0xFFFFFF, 0.055);
                  }
                  else {
                    if (states.isDisabled) return const ColorConst.withOpacity(0xf9f9f9, 0.045);
                    if (states.isPressing) return const ColorConst.withOpacity(0xf0f0f0, 0.4);
                    if (states.isHovering) return const ColorConst.withOpacity(0xf9f9f9, 0.65);
                    return const ColorConst.withOpacity(0xFFFFFF, 0.8);
                  }
                })
              ) ,
            ),
            scaffoldBackgroundColor: IsFullMicaOrInstall ? Colors.transparent : isDark ? const Color(0xFF272727) : const Color(0xFFf9f9f9),
            micaBackgroundColor: mica.enabled ? Colors.transparent : isDark ? const Color(0xFF202020) : const Color(0xFFf3f3f3),
            accentColor: appTheme.getColor(isDark),
            brightness: isDark ? Brightness.dark : Brightness.light,
            visualDensity: VisualDensity.standard,
            focusTheme: FocusThemeData(
              glowFactor: is10footScreen() ? 2.0 : 0.0,
            ),
          ),
        );
      },
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({Key? key}) : super(key: key);

  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  bool value = false;

  int index = 0;

  final colorsController = ScrollController();
  final settingsController = ScrollController();

  @override
  void dispose() {
    colorsController.dispose();
    settingsController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    // TODO: implement initState
    /*flutter_acrylic.Acrylic.setEffect(
     effect: flutter_acrylic.AcrylicEffect.acrylic,
     gradientColor: Colors.black.withOpacity(0.2)
    );*/
  }

  @override
  Widget build(BuildContext context) {
    final lang = AppLocalizations.of(context)!;
    final appTheme = context.watch<AppTheme>();
    final mica = GState.mica.of(context);
    final theme = FluentTheme.of(context);

    return NavigationView(
      contentShape: RoundedRectangleBorder(
        side: BorderSide(width: 0.3, color: theme.micaBackgroundColor.lerpWith(Colors.black, 0.25)),
        borderRadius: const BorderRadius.only(),
      ),
      appBar: NavigationAppBar(
        // height: !kIsWeb ? appWindow.titleBarHeight : 31.0,
        /*title: () {
          if (kIsWeb) return const Text(appTitle);
          return MoveWindow(
            child: const Align(
              alignment: Alignment.centerLeft,
              child: Text(appTitle),
            ),
          );
        }(),*/
        actions: kIsWeb
            ? null
            : Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Expanded(flex: 1,child: MoveWindow(child: Padding(
                      padding: const EdgeInsets.only(top: 9, left: 13, right: 13), 
                      child: Row(crossAxisAlignment: CrossAxisAlignment.start, children: [
                        Text(lang.screen_wsa, style: theme.typography.caption),
                        const SizedBox(width: 10),
                        Text('v$appVersion', style: theme.typography.caption?.copyWith(color: theme.inactiveColor.withAlpha(theme.brightness.isLight ? 0x3F : 0x1B))),
                      ])
                    ))), 
                    const WindowButtons()
                  ],
                )
            /*MoveWindow(
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: const [Spacer(), WindowButtons()],
                ),
              ),*/
      ),
      pane: NavigationPane(
        selected: index,
        onChanged: (i) => setState(() => index = i),
        header: Container(
          height: kOneLineTileHeight,
          padding: const EdgeInsets.symmetric(horizontal: 10.0),
          child: material.Row(children: [AnimatedContainer(
            width: 28,
            height: 28,
            duration: const Duration(milliseconds: 750),
            curve: Curves.fastOutSlowIn,
            decoration: const BoxDecoration (
              image: DecorationImage(image:  AssetImage("assets/images/logo.png"))
            ),
          ), const SizedBox(width: 10), Text("WSA PacMan", style: theme.typography.bodyLarge)]),
        ),
        displayMode: appTheme.displayMode,
        indicatorBuilder: ({
          required BuildContext context,
          required NavigationPane pane,
          Axis? axis,
          required Widget child,
        }) {
          if (pane.selected == null) return child;
          axis ??= Axis.horizontal;
          assert(debugCheckHasFluentTheme(context));
          final theme = NavigationPaneTheme.of(context);
          switch (appTheme.indicator) {
            case NavigationIndicators.end:
              return EndNavigationIndicator(
                index: pane.selected!,
                offsets: () =>
                    pane.effectiveItems.getPaneItemsOffsets(pane.paneKey),
                sizes: pane.effectiveItems.getPaneItemsSizes,
                child: child,
                color: theme.highlightColor,
                curve: theme.animationCurve ?? Curves.linear,
                axis: axis,
              );
            case NavigationIndicators.sticky:
              return NavigationPane.defaultNavigationIndicator(
                context: context,
                axis: axis,
                pane: pane,
                child: child,
              );
            default:
              return NavigationIndicator(
                index: pane.selected!,
                offsets: () =>
                    pane.effectiveItems.getPaneItemsOffsets(pane.paneKey),
                sizes: pane.effectiveItems.getPaneItemsSizes,
                child: child,
                color: theme.highlightColor,
                curve: theme.animationCurve ?? Curves.linear,
                axis: axis,
              );
          }
        },
        items: [
          // It doesn't look good when resizing from compact to open
          // PaneItemHeader(header: Text('User Interaction')),
          ThemablePaneItem(
            icon: const Icon(Mdi.androidDebugBridge),
            title: const Text('WSA'),
            translucent: mica.enabled,
            forceDisplayMode: appTheme.displayMode
          )
          /*PaneItem(
            icon: Icon(
              appTheme.displayMode == PaneDisplayMode.top
                  ? FluentIcons.more
                  : FluentIcons.more_vertical,
            ),
            title: const Text('Others'),
          ),*/
        ],
        footerItems: [
          PaneItemSeparator(),
          ThemablePaneItem(
            icon: const Icon(FluentIcons.settings),
            title: Text(lang.screen_settings),
            translucent: mica.enabled,
            forceDisplayMode: appTheme.displayMode
          ),
        ],
      ),
      content: NavigationBody(index: index, children: [
        const ScreenWSA(),
        //const Others(),
        ScreenSettings(controller: settingsController),
      ]),
    );
  }
}

class WindowButtons extends StatelessWidget {
  const WindowButtons({Key? key}) : super(key: key);
  static Color windowButtonAlphaColor(ThemeData style, Set<ButtonStates> states) {
    if (style.brightness == Brightness.light) {
      if (states.isPressing) return Colors.black.withOpacity(0.075);
      if (states.isHovering) return Colors.black.withOpacity(0.11);
      return Colors.transparent;
    } else {
      if (states.isPressing) return Colors.white.withOpacity(0.03);
      if (states.isHovering) return Colors.white.withOpacity(0.06);
      return Colors.transparent;
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasFluentTheme(context));
    assert(debugCheckHasFluentLocalizations(context));
    final ThemeData theme = FluentTheme.of(context);
    final mica = GState.mica.of(context);

    final buttonColors = WindowButtonColors(
      iconNormal: theme.inactiveColor,
      iconMouseDown: theme.inactiveColor,
      iconMouseOver: theme.inactiveColor,
      //Fixed button colors
      mouseOver: mica.enabled ? windowButtonAlphaColor(theme, {ButtonStates.hovering}) : ButtonThemeData.buttonColor(
          theme.brightness, {ButtonStates.hovering}).lerpWith(Colors.black, 0.12),
      mouseDown: mica.enabled ? windowButtonAlphaColor(theme, {ButtonStates.pressing}) : ButtonThemeData.buttonColor(
          theme.brightness, {ButtonStates.pressing}).lerpWith(theme.shadowColor, 0.12).withAlpha(150),
    );
    final closeButtonColors = WindowButtonColors(
      mouseOver: Colors.red,
      mouseDown: Colors.red.dark,
      iconNormal: theme.inactiveColor,
      iconMouseOver: Colors.red.basedOnLuminance(),
      iconMouseDown: Colors.red.dark.basedOnLuminance(),
    );
    return Row(children: [
      Tooltip(
        message: FluentLocalizations.of(context).minimizeWindowTooltip,
        child: MinimizeWindowButton(colors: buttonColors),
      ),
      Tooltip(
        message: FluentLocalizations.of(context).restoreWindowTooltip,
        child: WindowButton(
          colors: buttonColors,
          iconBuilder: (context) {
            if (appWindow.isMaximized) {
              return RestoreIcon(color: context.iconColor);
            }
            return MaximizeIcon(color: context.iconColor);
          },
          onPressed: appWindow.maximizeOrRestore,
        ),
      ),
      Tooltip(
        message: FluentLocalizations.of(context).closeWindowTooltip,
        child: CloseWindowButton(colors: closeButtonColors),
      ),
    ]);
  }
}

```

`lib/proto/manifest_xapk.pb.dart`:

```dart
///
//  Generated code. Do not modify.
//  source: manifest_xapk.proto
//
// @dart = 2.12
// ignore_for_file: annotate_overrides,camel_case_types,unnecessary_const,non_constant_identifier_names,library_prefixes,unused_import,unused_shown_name,return_of_invalid_type,unnecessary_this,prefer_final_fields

import 'dart:core' as $core;

import 'package:protobuf/protobuf.dart' as $pb;

import 'manifest_xapk.pbenum.dart';

export 'manifest_xapk.pbenum.dart';

class ManifestXapk_ApkFile extends $pb.GeneratedMessage {
  static final $pb.BuilderInfo _i = $pb.BuilderInfo(const $core.bool.fromEnvironment('protobuf.omit_message_names') ? '' : 'ManifestXapk.ApkFile', package: const $pb.PackageName(const $core.bool.fromEnvironment('protobuf.omit_message_names') ? '' : 'proto'), createEmptyInstance: create)
    ..aOS(1, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'id')
    ..aOS(2, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'file')
    ..hasRequiredFields = false
  ;

  ManifestXapk_ApkFile._() : super();
  factory ManifestXapk_ApkFile({
    $core.String? id,
    $core.String? file,
  }) {
    final _result = create();
    if (id != null) {
      _result.id = id;
    }
    if (file != null) {
      _result.file = file;
    }
    return _result;
  }
  factory ManifestXapk_ApkFile.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ManifestXapk_ApkFile.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ManifestXapk_ApkFile clone() => ManifestXapk_ApkFile()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ManifestXapk_ApkFile copyWith(void Function(ManifestXapk_ApkFile) updates) => super.copyWith((message) => updates(message as ManifestXapk_ApkFile)) as ManifestXapk_ApkFile; // ignore: deprecated_member_use
  $pb.BuilderInfo get info_ => _i;
  @$core.pragma('dart2js:noInline')
  static ManifestXapk_ApkFile create() => ManifestXapk_ApkFile._();
  ManifestXapk_ApkFile createEmptyInstance() => create();
  static $pb.PbList<ManifestXapk_ApkFile> createRepeated() => $pb.PbList<ManifestXapk_ApkFile>();
  @$core.pragma('dart2js:noInline')
  static ManifestXapk_ApkFile getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ManifestXapk_ApkFile>(create);
  static ManifestXapk_ApkFile? _defaultInstance;

  @$pb.TagNumber(1)
  $core.String get id => $_getSZ(0);
  @$pb.TagNumber(1)
  set id($core.String v) { $_setString(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasId() => $_has(0);
  @$pb.TagNumber(1)
  void clearId() => clearField(1);

  @$pb.TagNumber(2)
  $core.String get file => $_getSZ(1);
  @$pb.TagNumber(2)
  set file($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFile() => $_has(1);
  @$pb.TagNumber(2)
  void clearFile() => clearField(2);
}

class ManifestXapk_ApkExpansion extends $pb.GeneratedMessage {
  static final $pb.BuilderInfo _i = $pb.BuilderInfo(const $core.bool.fromEnvironment('protobuf.omit_message_names') ? '' : 'ManifestXapk.ApkExpansion', package: const $pb.PackageName(const $core.bool.fromEnvironment('protobuf.omit_message_names') ? '' : 'proto'), createEmptyInstance: create)
    ..e<ManifestXapk_InstallDir>(1, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'installLocation', $pb.PbFieldType.OE, defaultOrMaker: ManifestXapk_InstallDir.EXTERNAL_STORAGE, valueOf: ManifestXapk_InstallDir.valueOf, enumValues: ManifestXapk_InstallDir.values)
    ..aOS(2, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'file')
    ..aOS(3, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'installPath')
    ..hasRequiredFields = false
  ;

  ManifestXapk_ApkExpansion._() : super();
  factory ManifestXapk_ApkExpansion({
    ManifestXapk_InstallDir? installLocation,
    $core.String? file,
    $core.String? installPath,
  }) {
    final _result = create();
    if (installLocation != null) {
      _result.installLocation = installLocation;
    }
    if (file != null) {
      _result.file = file;
    }
    if (installPath != null) {
      _result.installPath = installPath;
    }
    return _result;
  }
  factory ManifestXapk_ApkExpansion.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ManifestXapk_ApkExpansion.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ManifestXapk_ApkExpansion clone() => ManifestXapk_ApkExpansion()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ManifestXapk_ApkExpansion copyWith(void Function(ManifestXapk_ApkExpansion) updates) => super.copyWith((message) => updates(message as ManifestXapk_ApkExpansion)) as ManifestXapk_ApkExpansion; // ignore: deprecated_member_use
  $pb.BuilderInfo get info_ => _i;
  @$core.pragma('dart2js:noInline')
  static ManifestXapk_ApkExpansion create() => ManifestXapk_ApkExpansion._();
  ManifestXapk_ApkExpansion createEmptyInstance() => create();
  static $pb.PbList<ManifestXapk_ApkExpansion> createRepeated() => $pb.PbList<ManifestXapk_ApkExpansion>();
  @$core.pragma('dart2js:noInline')
  static ManifestXapk_ApkExpansion getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ManifestXapk_ApkExpansion>(create);
  static ManifestXapk_ApkExpansion? _defaultInstance;

  @$pb.TagNumber(1)
  ManifestXapk_InstallDir get installLocation => $_getN(0);
  @$pb.TagNumber(1)
  set installLocation(ManifestXapk_InstallDir v) { setField(1, v); }
  @$pb.TagNumber(1)
  $core.bool hasInstallLocation() => $_has(0);
  @$pb.TagNumber(1)
  void clearInstallLocation() => clearField(1);

  @$pb.TagNumber(2)
  $core.String get file => $_getSZ(1);
  @$pb.TagNumber(2)
  set file($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasFile() => $_has(1);
  @$pb.TagNumber(2)
  void clearFile() => clearField(2);

  @$pb.TagNumber(3)
  $core.String get installPath => $_getSZ(2);
  @$pb.TagNumber(3)
  set installPath($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasInstallPath() => $_has(2);
  @$pb.TagNumber(3)
  void clearInstallPath() => clearField(3);
}

class ManifestXapk extends $pb.GeneratedMessage {
  static final $pb.BuilderInfo _i = $pb.BuilderInfo(const $core.bool.fromEnvironment('protobuf.omit_message_names') ? '' : 'ManifestXapk', package: const $pb.PackageName(const $core.bool.fromEnvironment('protobuf.omit_message_names') ? '' : 'proto'), createEmptyInstance: create)
    ..a<$core.int>(1, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'xapkVersion', $pb.PbFieldType.OU3, defaultOrMaker: 1)
    ..aOS(2, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'packageName')
    ..aOS(3, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'name')
    ..m<$core.String, $core.String>(4, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'localesName', entryClassName: 'ManifestXapk.LocalesNameEntry', keyFieldType: $pb.PbFieldType.OS, valueFieldType: $pb.PbFieldType.OS, packageName: const $pb.PackageName('proto'))
    ..a<$core.int>(5, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'versionCode', $pb.PbFieldType.OU3)
    ..aOS(6, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'versionName')
    ..a<$core.int>(7, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'minSdkVersion', $pb.PbFieldType.OU3)
    ..a<$core.int>(8, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'targetSdkVersion', $pb.PbFieldType.OU3)
    ..pPS(9, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'permissions')
    ..pPS(10, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'splitConfigs')
    ..a<$core.int>(11, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'totalSize', $pb.PbFieldType.OU3)
    ..aOS(12, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'icon')
    ..pc<ManifestXapk_ApkFile>(13, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'splitApks', $pb.PbFieldType.PM, subBuilder: ManifestXapk_ApkFile.create)
    ..pc<ManifestXapk_ApkExpansion>(14, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'expansions', $pb.PbFieldType.PM, subBuilder: ManifestXapk_ApkExpansion.create)
    ..hasRequiredFields = false
  ;

  ManifestXapk._() : super();
  factory ManifestXapk({
    $core.int? xapkVersion,
    $core.String? packageName,
    $core.String? name,
    $core.Map<$core.String, $core.String>? localesName,
    $core.int? versionCode,
    $core.String? versionName,
    $core.int? minSdkVersion,
    $core.int? targetSdkVersion,
    $core.Iterable<$core.String>? permissions,
    $core.Iterable<$core.String>? splitConfigs,
    $core.int? totalSize,
    $core.String? icon,
    $core.Iterable<ManifestXapk_ApkFile>? splitApks,
    $core.Iterable<ManifestXapk_ApkExpansion>? expansions,
  }) {
    final _result = create();
    if (xapkVersion != null) {
      _result.xapkVersion = xapkVersion;
    }
    if (packageName != null) {
      _result.packageName = packageName;
    }
    if (name != null) {
      _result.name = name;
    }
    if (localesName != null) {
      _result.localesName.addAll(localesName);
    }
    if (versionCode != null) {
      _result.versionCode = versionCode;
    }
    if (versionName != null) {
      _result.versionName = versionName;
    }
    if (minSdkVersion != null) {
      _result.minSdkVersion = minSdkVersion;
    }
    if (targetSdkVersion != null) {
      _result.targetSdkVersion = targetSdkVersion;
    }
    if (permissions != null) {
      _result.permissions.addAll(permissions);
    }
    if (splitConfigs != null) {
      _result.splitConfigs.addAll(splitConfigs);
    }
    if (totalSize != null) {
      _result.totalSize = totalSize;
    }
    if (icon != null) {
      _result.icon = icon;
    }
    if (splitApks != null) {
      _result.splitApks.addAll(splitApks);
    }
    if (expansions != null) {
      _result.expansions.addAll(expansions);
    }
    return _result;
  }
  factory ManifestXapk.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory ManifestXapk.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  ManifestXapk clone() => ManifestXapk()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  ManifestXapk copyWith(void Function(ManifestXapk) updates) => super.copyWith((message) => updates(message as ManifestXapk)) as ManifestXapk; // ignore: deprecated_member_use
  $pb.BuilderInfo get info_ => _i;
  @$core.pragma('dart2js:noInline')
  static ManifestXapk create() => ManifestXapk._();
  ManifestXapk createEmptyInstance() => create();
  static $pb.PbList<ManifestXapk> createRepeated() => $pb.PbList<ManifestXapk>();
  @$core.pragma('dart2js:noInline')
  static ManifestXapk getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<ManifestXapk>(create);
  static ManifestXapk? _defaultInstance;

  @$pb.TagNumber(1)
  $core.int get xapkVersion => $_getI(0, 1);
  @$pb.TagNumber(1)
  set xapkVersion($core.int v) { $_setUnsignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasXapkVersion() => $_has(0);
  @$pb.TagNumber(1)
  void clearXapkVersion() => clearField(1);

  @$pb.TagNumber(2)
  $core.String get packageName => $_getSZ(1);
  @$pb.TagNumber(2)
  set packageName($core.String v) { $_setString(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasPackageName() => $_has(1);
  @$pb.TagNumber(2)
  void clearPackageName() => clearField(2);

  @$pb.TagNumber(3)
  $core.String get name => $_getSZ(2);
  @$pb.TagNumber(3)
  set name($core.String v) { $_setString(2, v); }
  @$pb.TagNumber(3)
  $core.bool hasName() => $_has(2);
  @$pb.TagNumber(3)
  void clearName() => clearField(3);

  @$pb.TagNumber(4)
  $core.Map<$core.String, $core.String> get localesName => $_getMap(3);

  @$pb.TagNumber(5)
  $core.int get versionCode => $_getIZ(4);
  @$pb.TagNumber(5)
  set versionCode($core.int v) { $_setUnsignedInt32(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasVersionCode() => $_has(4);
  @$pb.TagNumber(5)
  void clearVersionCode() => clearField(5);

  @$pb.TagNumber(6)
  $core.String get versionName => $_getSZ(5);
  @$pb.TagNumber(6)
  set versionName($core.String v) { $_setString(5, v); }
  @$pb.TagNumber(6)
  $core.bool hasVersionName() => $_has(5);
  @$pb.TagNumber(6)
  void clearVersionName() => clearField(6);

  @$pb.TagNumber(7)
  $core.int get minSdkVersion => $_getIZ(6);
  @$pb.TagNumber(7)
  set minSdkVersion($core.int v) { $_setUnsignedInt32(6, v); }
  @$pb.TagNumber(7)
  $core.bool hasMinSdkVersion() => $_has(6);
  @$pb.TagNumber(7)
  void clearMinSdkVersion() => clearField(7);

  @$pb.TagNumber(8)
  $core.int get targetSdkVersion => $_getIZ(7);
  @$pb.TagNumber(8)
  set targetSdkVersion($core.int v) { $_setUnsignedInt32(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasTargetSdkVersion() => $_has(7);
  @$pb.TagNumber(8)
  void clearTargetSdkVersion() => clearField(8);

  @$pb.TagNumber(9)
  $core.List<$core.String> get permissions => $_getList(8);

  @$pb.TagNumber(10)
  $core.List<$core.String> get splitConfigs => $_getList(9);

  @$pb.TagNumber(11)
  $core.int get totalSize => $_getIZ(10);
  @$pb.TagNumber(11)
  set totalSize($core.int v) { $_setUnsignedInt32(10, v); }
  @$pb.TagNumber(11)
  $core.bool hasTotalSize() => $_has(10);
  @$pb.TagNumber(11)
  void clearTotalSize() => clearField(11);

  @$pb.TagNumber(12)
  $core.String get icon => $_getSZ(11);
  @$pb.TagNumber(12)
  set icon($core.String v) { $_setString(11, v); }
  @$pb.TagNumber(12)
  $core.bool hasIcon() => $_has(11);
  @$pb.TagNumber(12)
  void clearIcon() => clearField(12);

  @$pb.TagNumber(13)
  $core.List<ManifestXapk_ApkFile> get splitApks => $_getList(12);

  @$pb.TagNumber(14)
  $core.List<ManifestXapk_ApkExpansion> get expansions => $_getList(13);
}


```

`lib/proto/manifest_xapk.pbenum.dart`:

```dart
///
//  Generated code. Do not modify.
//  source: manifest_xapk.proto
//
// @dart = 2.12
// ignore_for_file: annotate_overrides,camel_case_types,unnecessary_const,non_constant_identifier_names,library_prefixes,unused_import,unused_shown_name,return_of_invalid_type,unnecessary_this,prefer_final_fields

// ignore_for_file: UNDEFINED_SHOWN_NAME
import 'dart:core' as $core;
import 'package:protobuf/protobuf.dart' as $pb;

class ManifestXapk_InstallDir extends $pb.ProtobufEnum {
  static const ManifestXapk_InstallDir EXTERNAL_STORAGE = ManifestXapk_InstallDir._(0, const $core.bool.fromEnvironment('protobuf.omit_enum_names') ? '' : 'EXTERNAL_STORAGE');
  static const ManifestXapk_InstallDir INTERNAL_STORAGE = ManifestXapk_InstallDir._(1, const $core.bool.fromEnvironment('protobuf.omit_enum_names') ? '' : 'INTERNAL_STORAGE');

  static const $core.List<ManifestXapk_InstallDir> values = <ManifestXapk_InstallDir> [
    EXTERNAL_STORAGE,
    INTERNAL_STORAGE,
  ];

  static final $core.Map<$core.int, ManifestXapk_InstallDir> _byValue = $pb.ProtobufEnum.initByValue(values);
  static ManifestXapk_InstallDir? valueOf($core.int value) => _byValue[value];

  const ManifestXapk_InstallDir._($core.int v, $core.String n) : super(v, n);
}


```

`lib/proto/manifest_xapk.pbjson.dart`:

```dart
///
//  Generated code. Do not modify.
//  source: manifest_xapk.proto
//
// @dart = 2.12
// ignore_for_file: annotate_overrides,camel_case_types,unnecessary_const,non_constant_identifier_names,library_prefixes,unused_import,unused_shown_name,return_of_invalid_type,unnecessary_this,prefer_final_fields,deprecated_member_use_from_same_package

import 'dart:core' as $core;
import 'dart:convert' as $convert;
import 'dart:typed_data' as $typed_data;
@$core.Deprecated('Use manifestXapkDescriptor instead')
const ManifestXapk$json = const {
  '1': 'ManifestXapk',
  '2': const [
    const {'1': 'xapk_version', '3': 1, '4': 1, '5': 13, '7': '1', '10': 'xapkVersion'},
    const {'1': 'package_name', '3': 2, '4': 1, '5': 9, '10': 'packageName'},
    const {'1': 'name', '3': 3, '4': 1, '5': 9, '10': 'name'},
    const {'1': 'locales_name', '3': 4, '4': 3, '5': 11, '6': '.proto.ManifestXapk.LocalesNameEntry', '10': 'localesName'},
    const {'1': 'version_code', '3': 5, '4': 1, '5': 13, '10': 'versionCode'},
    const {'1': 'version_name', '3': 6, '4': 1, '5': 9, '10': 'versionName'},
    const {'1': 'min_sdk_version', '3': 7, '4': 1, '5': 13, '10': 'minSdkVersion'},
    const {'1': 'target_sdk_version', '3': 8, '4': 1, '5': 13, '10': 'targetSdkVersion'},
    const {'1': 'permissions', '3': 9, '4': 3, '5': 9, '10': 'permissions'},
    const {'1': 'split_configs', '3': 10, '4': 3, '5': 9, '10': 'splitConfigs'},
    const {'1': 'total_size', '3': 11, '4': 1, '5': 13, '10': 'totalSize'},
    const {'1': 'icon', '3': 12, '4': 1, '5': 9, '10': 'icon'},
    const {'1': 'split_apks', '3': 13, '4': 3, '5': 11, '6': '.proto.ManifestXapk.ApkFile', '10': 'splitApks'},
    const {'1': 'expansions', '3': 14, '4': 3, '5': 11, '6': '.proto.ManifestXapk.ApkExpansion', '10': 'expansions'},
  ],
  '3': const [ManifestXapk_LocalesNameEntry$json, ManifestXapk_ApkFile$json, ManifestXapk_ApkExpansion$json],
  '4': const [ManifestXapk_InstallDir$json],
};

@$core.Deprecated('Use manifestXapkDescriptor instead')
const ManifestXapk_LocalesNameEntry$json = const {
  '1': 'LocalesNameEntry',
  '2': const [
    const {'1': 'key', '3': 1, '4': 1, '5': 9, '10': 'key'},
    const {'1': 'value', '3': 2, '4': 1, '5': 9, '10': 'value'},
  ],
  '7': const {'7': true},
};

@$core.Deprecated('Use manifestXapkDescriptor instead')
const ManifestXapk_ApkFile$json = const {
  '1': 'ApkFile',
  '2': const [
    const {'1': 'id', '3': 1, '4': 1, '5': 9, '10': 'id'},
    const {'1': 'file', '3': 2, '4': 1, '5': 9, '10': 'file'},
  ],
};

@$core.Deprecated('Use manifestXapkDescriptor instead')
const ManifestXapk_ApkExpansion$json = const {
  '1': 'ApkExpansion',
  '2': const [
    const {'1': 'install_location', '3': 1, '4': 1, '5': 14, '6': '.proto.ManifestXapk.InstallDir', '10': 'installLocation'},
    const {'1': 'file', '3': 2, '4': 1, '5': 9, '10': 'file'},
    const {'1': 'install_path', '3': 3, '4': 1, '5': 9, '10': 'installPath'},
  ],
};

@$core.Deprecated('Use manifestXapkDescriptor instead')
const ManifestXapk_InstallDir$json = const {
  '1': 'InstallDir',
  '2': const [
    const {'1': 'EXTERNAL_STORAGE', '2': 0},
    const {'1': 'INTERNAL_STORAGE', '2': 1},
  ],
};

/// Descriptor for `ManifestXapk`. Decode as a `google.protobuf.DescriptorProto`.
final $typed_data.Uint8List manifestXapkDescriptor = $convert.base64Decode('CgxNYW5pZmVzdFhhcGsSJAoMeGFwa192ZXJzaW9uGAEgASgNOgExUgt4YXBrVmVyc2lvbhIhCgxwYWNrYWdlX25hbWUYAiABKAlSC3BhY2thZ2VOYW1lEhIKBG5hbWUYAyABKAlSBG5hbWUSRwoMbG9jYWxlc19uYW1lGAQgAygLMiQucHJvdG8uTWFuaWZlc3RYYXBrLkxvY2FsZXNOYW1lRW50cnlSC2xvY2FsZXNOYW1lEiEKDHZlcnNpb25fY29kZRgFIAEoDVILdmVyc2lvbkNvZGUSIQoMdmVyc2lvbl9uYW1lGAYgASgJUgt2ZXJzaW9uTmFtZRImCg9taW5fc2RrX3ZlcnNpb24YByABKA1SDW1pblNka1ZlcnNpb24SLAoSdGFyZ2V0X3Nka192ZXJzaW9uGAggASgNUhB0YXJnZXRTZGtWZXJzaW9uEiAKC3Blcm1pc3Npb25zGAkgAygJUgtwZXJtaXNzaW9ucxIjCg1zcGxpdF9jb25maWdzGAogAygJUgxzcGxpdENvbmZpZ3MSHQoKdG90YWxfc2l6ZRgLIAEoDVIJdG90YWxTaXplEhIKBGljb24YDCABKAlSBGljb24SOgoKc3BsaXRfYXBrcxgNIAMoCzIbLnByb3RvLk1hbmlmZXN0WGFway5BcGtGaWxlUglzcGxpdEFwa3MSQAoKZXhwYW5zaW9ucxgOIAMoCzIgLnByb3RvLk1hbmlmZXN0WGFway5BcGtFeHBhbnNpb25SCmV4cGFuc2lvbnMaPgoQTG9jYWxlc05hbWVFbnRyeRIQCgNrZXkYASABKAlSA2tleRIUCgV2YWx1ZRgCIAEoCVIFdmFsdWU6AjgBGi0KB0Fwa0ZpbGUSDgoCaWQYASABKAlSAmlkEhIKBGZpbGUYAiABKAlSBGZpbGUakAEKDEFwa0V4cGFuc2lvbhJJChBpbnN0YWxsX2xvY2F0aW9uGAEgASgOMh4ucHJvdG8uTWFuaWZlc3RYYXBrLkluc3RhbGxEaXJSD2luc3RhbGxMb2NhdGlvbhISCgRmaWxlGAIgASgJUgRmaWxlEiEKDGluc3RhbGxfcGF0aBgDIAEoCVILaW5zdGFsbFBhdGgiOAoKSW5zdGFsbERpchIUChBFWFRFUk5BTF9TVE9SQUdFEAASFAoQSU5URVJOQUxfU1RPUkFHRRAB');

```

`lib/proto/manifest_xapk.pbserver.dart`:

```dart
///
//  Generated code. Do not modify.
//  source: manifest_xapk.proto
//
// @dart = 2.12
// ignore_for_file: annotate_overrides,camel_case_types,unnecessary_const,non_constant_identifier_names,library_prefixes,unused_import,unused_shown_name,return_of_invalid_type,unnecessary_this,prefer_final_fields,deprecated_member_use_from_same_package

export 'manifest_xapk.pb.dart';


```

`lib/proto/options.pb.dart`:

```dart
///
//  Generated code. Do not modify.
//  source: options.proto
//
// @dart = 2.12
// ignore_for_file: annotate_overrides,camel_case_types,unnecessary_const,non_constant_identifier_names,library_prefixes,unused_import,unused_shown_name,return_of_invalid_type,unnecessary_this,prefer_final_fields

import 'dart:core' as $core;

import 'package:protobuf/protobuf.dart' as $pb;

import 'options.pbenum.dart';

export 'options.pbenum.dart';

class Options extends $pb.GeneratedMessage {
  static final $pb.BuilderInfo _i = $pb.BuilderInfo(const $core.bool.fromEnvironment('protobuf.omit_message_names') ? '' : 'Options', package: const $pb.PackageName(const $core.bool.fromEnvironment('protobuf.omit_message_names') ? '' : 'proto'), createEmptyInstance: create)
    ..a<$core.int>(1, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'ipAddress', $pb.PbFieldType.OU3, protoName: 'ipAddress', defaultOrMaker: 2130706433)
    ..a<$core.int>(2, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'port', $pb.PbFieldType.OU3, defaultOrMaker: 58526)
    ..e<Options_Theme>(3, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'theme', $pb.PbFieldType.OE, defaultOrMaker: Options_Theme.SYSTEM, valueOf: Options_Theme.valueOf, enumValues: Options_Theme.values)
    ..aOB(4, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'legacyIcons', protoName: 'legacyIcons')
    ..aOB(5, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'systemAccent', protoName: 'systemAccent')
    ..e<Options_IconShape>(6, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'iconShape', $pb.PbFieldType.OE, protoName: 'iconShape', defaultOrMaker: Options_IconShape.SQUIRCLE, valueOf: Options_IconShape.valueOf, enumValues: Options_IconShape.values)
    ..e<Options_Mica>(7, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'mica', $pb.PbFieldType.OE, defaultOrMaker: Options_Mica.FULL, valueOf: Options_Mica.valueOf, enumValues: Options_Mica.values)
    ..aOB(8, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'autostart')
    ..a<$core.int>(9, const $core.bool.fromEnvironment('protobuf.omit_field_names') ? '' : 'locale', $pb.PbFieldType.OU3)
    ..hasRequiredFields = false
  ;

  Options._() : super();
  factory Options({
    $core.int? ipAddress,
    $core.int? port,
    Options_Theme? theme,
    $core.bool? legacyIcons,
    $core.bool? systemAccent,
    Options_IconShape? iconShape,
    Options_Mica? mica,
    $core.bool? autostart,
    $core.int? locale,
  }) {
    final _result = create();
    if (ipAddress != null) {
      _result.ipAddress = ipAddress;
    }
    if (port != null) {
      _result.port = port;
    }
    if (theme != null) {
      _result.theme = theme;
    }
    if (legacyIcons != null) {
      _result.legacyIcons = legacyIcons;
    }
    if (systemAccent != null) {
      _result.systemAccent = systemAccent;
    }
    if (iconShape != null) {
      _result.iconShape = iconShape;
    }
    if (mica != null) {
      _result.mica = mica;
    }
    if (autostart != null) {
      _result.autostart = autostart;
    }
    if (locale != null) {
      _result.locale = locale;
    }
    return _result;
  }
  factory Options.fromBuffer($core.List<$core.int> i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromBuffer(i, r);
  factory Options.fromJson($core.String i, [$pb.ExtensionRegistry r = $pb.ExtensionRegistry.EMPTY]) => create()..mergeFromJson(i, r);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.deepCopy] instead. '
  'Will be removed in next major version')
  Options clone() => Options()..mergeFromMessage(this);
  @$core.Deprecated(
  'Using this can add significant overhead to your binary. '
  'Use [GeneratedMessageGenericExtensions.rebuild] instead. '
  'Will be removed in next major version')
  Options copyWith(void Function(Options) updates) => super.copyWith((message) => updates(message as Options)) as Options; // ignore: deprecated_member_use
  $pb.BuilderInfo get info_ => _i;
  @$core.pragma('dart2js:noInline')
  static Options create() => Options._();
  Options createEmptyInstance() => create();
  static $pb.PbList<Options> createRepeated() => $pb.PbList<Options>();
  @$core.pragma('dart2js:noInline')
  static Options getDefault() => _defaultInstance ??= $pb.GeneratedMessage.$_defaultFor<Options>(create);
  static Options? _defaultInstance;

  @$pb.TagNumber(1)
  $core.int get ipAddress => $_getI(0, 2130706433);
  @$pb.TagNumber(1)
  set ipAddress($core.int v) { $_setUnsignedInt32(0, v); }
  @$pb.TagNumber(1)
  $core.bool hasIpAddress() => $_has(0);
  @$pb.TagNumber(1)
  void clearIpAddress() => clearField(1);

  @$pb.TagNumber(2)
  $core.int get port => $_getI(1, 58526);
  @$pb.TagNumber(2)
  set port($core.int v) { $_setUnsignedInt32(1, v); }
  @$pb.TagNumber(2)
  $core.bool hasPort() => $_has(1);
  @$pb.TagNumber(2)
  void clearPort() => clearField(2);

  @$pb.TagNumber(3)
  Options_Theme get theme => $_getN(2);
  @$pb.TagNumber(3)
  set theme(Options_Theme v) { setField(3, v); }
  @$pb.TagNumber(3)
  $core.bool hasTheme() => $_has(2);
  @$pb.TagNumber(3)
  void clearTheme() => clearField(3);

  @$pb.TagNumber(4)
  $core.bool get legacyIcons => $_getBF(3);
  @$pb.TagNumber(4)
  set legacyIcons($core.bool v) { $_setBool(3, v); }
  @$pb.TagNumber(4)
  $core.bool hasLegacyIcons() => $_has(3);
  @$pb.TagNumber(4)
  void clearLegacyIcons() => clearField(4);

  @$pb.TagNumber(5)
  $core.bool get systemAccent => $_getBF(4);
  @$pb.TagNumber(5)
  set systemAccent($core.bool v) { $_setBool(4, v); }
  @$pb.TagNumber(5)
  $core.bool hasSystemAccent() => $_has(4);
  @$pb.TagNumber(5)
  void clearSystemAccent() => clearField(5);

  @$pb.TagNumber(6)
  Options_IconShape get iconShape => $_getN(5);
  @$pb.TagNumber(6)
  set iconShape(Options_IconShape v) { setField(6, v); }
  @$pb.TagNumber(6)
  $core.bool hasIconShape() => $_has(5);
  @$pb.TagNumber(6)
  void clearIconShape() => clearField(6);

  @$pb.TagNumber(7)
  Options_Mica get mica => $_getN(6);
  @$pb.TagNumber(7)
  set mica(Options_Mica v) { setField(7, v); }
  @$pb.TagNumber(7)
  $core.bool hasMica() => $_has(6);
  @$pb.TagNumber(7)
  void clearMica() => clearField(7);

  @$pb.TagNumber(8)
  $core.bool get autostart => $_getBF(7);
  @$pb.TagNumber(8)
  set autostart($core.bool v) { $_setBool(7, v); }
  @$pb.TagNumber(8)
  $core.bool hasAutostart() => $_has(7);
  @$pb.TagNumber(8)
  void clearAutostart() => clearField(8);

  @$pb.TagNumber(9)
  $core.int get locale => $_getIZ(8);
  @$pb.TagNumber(9)
  set locale($core.int v) { $_setUnsignedInt32(8, v); }
  @$pb.TagNumber(9)
  $core.bool hasLocale() => $_has(8);
  @$pb.TagNumber(9)
  void clearLocale() => clearField(9);
}


```

`lib/proto/options.pbenum.dart`:

```dart
///
//  Generated code. Do not modify.
//  source: options.proto
//
// @dart = 2.12
// ignore_for_file: annotate_overrides,camel_case_types,unnecessary_const,non_constant_identifier_names,library_prefixes,unused_import,unused_shown_name,return_of_invalid_type,unnecessary_this,prefer_final_fields

// ignore_for_file: UNDEFINED_SHOWN_NAME
import 'dart:core' as $core;
import 'package:protobuf/protobuf.dart' as $pb;

class Options_Theme extends $pb.ProtobufEnum {
  static const Options_Theme SYSTEM = Options_Theme._(0, const $core.bool.fromEnvironment('protobuf.omit_enum_names') ? '' : 'SYSTEM');
  static const Options_Theme LIGHT = Options_Theme._(1, const $core.bool.fromEnvironment('protobuf.omit_enum_names') ? '' : 'LIGHT');
  static const Options_Theme DARK = Options_Theme._(2, const $core.bool.fromEnvironment('protobuf.omit_enum_names') ? '' : 'DARK');

  static const $core.List<Options_Theme> values = <Options_Theme> [
    SYSTEM,
    LIGHT,
    DARK,
  ];

  static final $core.Map<$core.int, Options_Theme> _byValue = $pb.ProtobufEnum.initByValue(values);
  static Options_Theme? valueOf($core.int value) => _byValue[value];

  const Options_Theme._($core.int v, $core.String n) : super(v, n);
}

class Options_IconShape extends $pb.ProtobufEnum {
  static const Options_IconShape SQUIRCLE = Options_IconShape._(0, const $core.bool.fromEnvironment('protobuf.omit_enum_names') ? '' : 'SQUIRCLE');
  static const Options_IconShape CIRCLE = Options_IconShape._(1, const $core.bool.fromEnvironment('protobuf.omit_enum_names') ? '' : 'CIRCLE');
  static const Options_IconShape ROUNDED_SQUARE = Options_IconShape._(2, const $core.bool.fromEnvironment('protobuf.omit_enum_names') ? '' : 'ROUNDED_SQUARE');

  static const $core.List<Options_IconShape> values = <Options_IconShape> [
    SQUIRCLE,
    CIRCLE,
    ROUNDED_SQUARE,
  ];

  static final $core.Map<$core.int, Options_IconShape> _byValue = $pb.ProtobufEnum.initByValue(values);
  static Options_IconShape? valueOf($core.int value) => _byValue[value];

  const Options_IconShape._($core.int v, $core.String n) : super(v, n);
}

class Options_Mica extends $pb.ProtobufEnum {
  static const Options_Mica FULL = Options_Mica._(0, const $core.bool.fromEnvironment('protobuf.omit_enum_names') ? '' : 'FULL');
  static const Options_Mica PARTIAL = Options_Mica._(1, const $core.bool.fromEnvironment('protobuf.omit_enum_names') ? '' : 'PARTIAL');
  static const Options_Mica DISABLED = Options_Mica._(2, const $core.bool.fromEnvironment('protobuf.omit_enum_names') ? '' : 'DISABLED');

  static const $core.List<Options_Mica> values = <Options_Mica> [
    FULL,
    PARTIAL,
    DISABLED,
  ];

  static final $core.Map<$core.int, Options_Mica> _byValue = $pb.ProtobufEnum.initByValue(values);
  static Options_Mica? valueOf($core.int value) => _byValue[value];

  const Options_Mica._($core.int v, $core.String n) : super(v, n);
}


```

`lib/proto/options.pbjson.dart`:

```dart
///
//  Generated code. Do not modify.
//  source: options.proto
//
// @dart = 2.12
// ignore_for_file: annotate_overrides,camel_case_types,unnecessary_const,non_constant_identifier_names,library_prefixes,unused_import,unused_shown_name,return_of_invalid_type,unnecessary_this,prefer_final_fields,deprecated_member_use_from_same_package

import 'dart:core' as $core;
import 'dart:convert' as $convert;
import 'dart:typed_data' as $typed_data;
@$core.Deprecated('Use optionsDescriptor instead')
const Options$json = const {
  '1': 'Options',
  '2': const [
    const {'1': 'ipAddress', '3': 1, '4': 1, '5': 13, '7': '2130706433', '10': 'ipAddress'},
    const {'1': 'port', '3': 2, '4': 1, '5': 13, '7': '58526', '10': 'port'},
    const {'1': 'autostart', '3': 8, '4': 1, '5': 8, '10': 'autostart'},
    const {'1': 'locale', '3': 9, '4': 1, '5': 13, '10': 'locale'},
    const {'1': 'theme', '3': 3, '4': 1, '5': 14, '6': '.proto.Options.Theme', '10': 'theme'},
    const {'1': 'legacyIcons', '3': 4, '4': 1, '5': 8, '10': 'legacyIcons'},
    const {'1': 'systemAccent', '3': 5, '4': 1, '5': 8, '10': 'systemAccent'},
    const {'1': 'iconShape', '3': 6, '4': 1, '5': 14, '6': '.proto.Options.IconShape', '10': 'iconShape'},
    const {'1': 'mica', '3': 7, '4': 1, '5': 14, '6': '.proto.Options.Mica', '7': 'FULL', '10': 'mica'},
  ],
  '4': const [Options_Theme$json, Options_IconShape$json, Options_Mica$json],
};

@$core.Deprecated('Use optionsDescriptor instead')
const Options_Theme$json = const {
  '1': 'Theme',
  '2': const [
    const {'1': 'SYSTEM', '2': 0},
    const {'1': 'LIGHT', '2': 1},
    const {'1': 'DARK', '2': 2},
  ],
};

@$core.Deprecated('Use optionsDescriptor instead')
const Options_IconShape$json = const {
  '1': 'IconShape',
  '2': const [
    const {'1': 'SQUIRCLE', '2': 0},
    const {'1': 'CIRCLE', '2': 1},
    const {'1': 'ROUNDED_SQUARE', '2': 2},
  ],
};

@$core.Deprecated('Use optionsDescriptor instead')
const Options_Mica$json = const {
  '1': 'Mica',
  '2': const [
    const {'1': 'FULL', '2': 0},
    const {'1': 'PARTIAL', '2': 1},
    const {'1': 'DISABLED', '2': 2},
  ],
};

/// Descriptor for `Options`. Decode as a `google.protobuf.DescriptorProto`.
final $typed_data.Uint8List optionsDescriptor = $convert.base64Decode('CgdPcHRpb25zEigKCWlwQWRkcmVzcxgBIAEoDToKMjEzMDcwNjQzM1IJaXBBZGRyZXNzEhkKBHBvcnQYAiABKA06BTU4NTI2UgRwb3J0EhwKCWF1dG9zdGFydBgIIAEoCFIJYXV0b3N0YXJ0EhYKBmxvY2FsZRgJIAEoDVIGbG9jYWxlEioKBXRoZW1lGAMgASgOMhQucHJvdG8uT3B0aW9ucy5UaGVtZVIFdGhlbWUSIAoLbGVnYWN5SWNvbnMYBCABKAhSC2xlZ2FjeUljb25zEiIKDHN5c3RlbUFjY2VudBgFIAEoCFIMc3lzdGVtQWNjZW50EjYKCWljb25TaGFwZRgGIAEoDjIYLnByb3RvLk9wdGlvbnMuSWNvblNoYXBlUglpY29uU2hhcGUSLQoEbWljYRgHIAEoDjITLnByb3RvLk9wdGlvbnMuTWljYToERlVMTFIEbWljYSIoCgVUaGVtZRIKCgZTWVNURU0QABIJCgVMSUdIVBABEggKBERBUksQAiI5CglJY29uU2hhcGUSDAoIU1FVSVJDTEUQABIKCgZDSVJDTEUQARISCg5ST1VOREVEX1NRVUFSRRACIisKBE1pY2ESCAoERlVMTBAAEgsKB1BBUlRJQUwQARIMCghESVNBQkxFRBAC');

```

`lib/proto/options.pbserver.dart`:

```dart
///
//  Generated code. Do not modify.
//  source: options.proto
//
// @dart = 2.12
// ignore_for_file: annotate_overrides,camel_case_types,unnecessary_const,non_constant_identifier_names,library_prefixes,unused_import,unused_shown_name,return_of_invalid_type,unnecessary_this,prefer_final_fields,deprecated_member_use_from_same_package

export 'options.pb.dart';


```

`lib/screens/settings.dart`:

```dart
// ignore_for_file: non_constant_identifier_names, constant_identifier_names

import 'dart:async';
import 'dart:developer';

import 'package:jovial_svg/jovial_svg.dart';
import 'package:mdi/mdi.dart';
import 'package:protobuf/protobuf.dart';
import 'package:wsa_pacman/global_state.dart';
import 'package:wsa_pacman/proto/options.pb.dart';
import 'package:wsa_pacman/utils/locale_utils.dart';
import 'package:wsa_pacman/widget/adaptive_icon.dart';
import 'package:wsa_pacman/widget/fluent_card.dart';
import 'package:wsa_pacman/widget/fluent_combo_box.dart';
import 'package:wsa_pacman/widget/fluent_expander.dart';
import 'package:wsa_pacman/widget/fluent_text_box.dart';
import 'package:wsa_pacman/windows/win_info.dart';

import '/utils/string_utils.dart';
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';

import '../theme.dart';

const List<String> accentColorNames = [
  'System',
  'Yellow',
  'Orange',
  'Red',
  'Magenta',
  'Purple',
  'Blue',
  'Teal',
  'Green',
];

class LateUpdater<E> {
  static const SETTINGS_UPDATE_TIMER = Duration(seconds:3);
  E initialValue;
  Timer? timer;
  Function(E value) callback;

  LateUpdater(this.initialValue, this.callback);
  update(E newValue) {
    initialValue = newValue;
    timer?.cancel();
    timer = Timer(SETTINGS_UPDATE_TIMER, (){if (initialValue == newValue) callback(initialValue);});
  }

  cancel() => timer?.cancel();

  instant(E newValue) {
    timer?.cancel();
    callback(newValue);
  }
}

class ScreenSettings extends StatefulWidget {
  ScreenSettings({Key? key, this.controller}) : super(key: key);
  final ScrollController? controller;

  @override
  State<StatefulWidget> createState() => ScreenSettingsState(controller: this.controller);
}

late final androidPortUpdater = LateUpdater<int>(GState.androidPort.$, (value){
  GState.androidPort..update((p0) => value)..persist();
  log("AGGIORNATO: ${GState.androidPort.$}");
});

class ScreenSettingsState extends State<ScreenSettings> {
  static const SETTINGS_UPDATE_TIMER = Duration(seconds:3);
  ScreenSettingsState({this.controller});
  final ScrollController? controller;

  static late final _exBackground = _loadIcon("assets/icons/missing_icon_background.si");
  static late final _exForeground = _loadIcon("assets/icons/missing_icon_foreground.si");
  static late final _exLegacyIcon = _loadIcon("assets/icons/missing_icon_legacy.si");

  static Future<ScalableImageWidget> _loadIcon(String asset) async {
    var scalable = ScalableImage.fromSIAsset(rootBundle, asset);
    return ScalableImageWidget(si: await scalable);
  }

  static List<Widget> optionsListDeferred<E extends ProtobufEnum, V>(List<E> values, String Function(E)? title, V Function(E e) getter, bool Function(V v) checked, Function(E e, V v) updater) => List.generate(values.length, (index) {
    final modeOpt = values[index];
    final mode = getter(modeOpt);
    return Padding(
      padding: index != values.length - 1 ? const EdgeInsets.only(bottom: 8.0) : EdgeInsets.zero,
      child: RadioButton(
        checked: checked(mode),
        onChanged: (value) {
          if (value) {
            updater(modeOpt, mode);
            //GState.theme..update((p0) => modeOpt)..persist();
            //themeMode = mode;
          }
        },
        content: Text(title != null ? title(modeOpt) : modeOpt.toString().normalized),
      ),
    );
  });

  static List<Widget> optionsList<E extends ProtobufEnum>(List<E> values, String Function(E)? title, bool Function(E e) checked, Function(E e) updater) =>
      optionsListDeferred<E, E>(values, title, (e) => e, checked, (e, v) => updater(e));
  
  static late final _localeItems = <NamedLocale>[LocaleUtils.SYSTEM_LOCALE].followedBy(LocaleUtils.supportedLocales).map((l)=>ComboboxItem(child: Text(l.name), value: l)).toList();

  @override
  Widget build(BuildContext context) {
    final appTheme = context.watch<AppTheme>();
    final theme = FluentTheme.of(context);
    final locale_lang = GState.locale.of(context);
    final lang = AppLocalizations.of(context)!;
    
    final tooltipThemeData = TooltipThemeData(decoration: () {
      const radius = BorderRadius.zero;
      final shadow = [
        BoxShadow(
          color: Colors.black.withOpacity(0.2),
          offset: const Offset(1, 1),
          blurRadius: 10.0,
        ),
      ];
      final border = Border.all(color: Colors.grey[100], width: 0.5);
      if (theme.brightness == Brightness.light) {
        return BoxDecoration(
          color: Colors.white,
          borderRadius: radius,
          border: border,
          boxShadow: shadow,
        );
      } else {
        return BoxDecoration(
          color: Colors.grey,
          borderRadius: radius,
          border: border,
          boxShadow: shadow,
        );
      }
    }());

    const empty = SizedBox.shrink();
    const hSpacer = SizedBox(width: 10.0);
    const smallSpacer = SizedBox(height: 5.0);
    const spacer = SizedBox(height: 10.0);
    const biggerSpacer = SizedBox(height: 40.0);

    final themeMode = GState.theme.of(context).mode;
    final iconShape = GState.iconShape.of(context);
    final mica = GState.mica.of(context);
    final legacyIcons = GState.legacyIcons.of(context);
    final autostartWSA = GState.autostartWSA.of(context);
    final locale = AppLocalizations.of(context);

    final OFF = lang.btn_switch_off;
    final ON = lang.btn_switch_on;

    final exampleIcon = FutureBuilder(
      future: legacyIcons ? _exLegacyIcon : (() async =>AdaptiveIcon(background: await _exBackground, foreground: await _exForeground, radius: iconShape.radius))(), 
      builder: (context, AsyncSnapshot<Widget> snapshot) => snapshot.data ?? empty
    );

    return ScaffoldPage(
      header: PageHeader(title: Text(lang.screen_settings)),
      content: ListView(
        padding: EdgeInsets.only(
          bottom: kPageDefaultVerticalPadding,
          left: PageHeader.horizontalPadding(context),
          right: PageHeader.horizontalPadding(context),
        ),
        controller: controller,
        children: [
          spacer,
          FluentCard(
            leading: const Icon(Mdi.networkOutline , size: 23),
            content: Text(lang.settings_port),
            trailing: SizedBox(width: 300, height: 32, child: FluentTextBox(
              inputFormatters: [
                TextInputFormatter.withFunction((oldValue, newValue) {
                  var androidPortVal = (newValue.text.isNumeric()) ? (newValue.text.length > 5 || (newValue.text.isEmpty ? 58526 : int.parse(newValue.text)) <= 65535 ? newValue : TextEditingValue(text: "65535", selection: newValue.selection)) : 
                  (oldValue.text.isNumeric() ? oldValue : TextEditingValue.empty);
                  GState.androidPortPending.$ = androidPortVal.text.isEmpty ? 58526.toString() : androidPortVal.text;
                  return androidPortVal;
                })
              ],
              maxLength: 5,
              maxLines: 1,
              maxLengthEnforced: true,
              controller: TextEditingController.fromValue(TextEditingValue(text: GState.androidPortPending.$)),
              autofocus: false,
              onChanged: (value)=>androidPortUpdater.update(value.isEmpty ? 58526 : int.parse(value)),
              enableSuggestions: false,
              keyboardType: const TextInputType.numberWithOptions(signed: true, decimal: true),
              prefix: const Padding(padding: EdgeInsetsDirectional.only(start: 10), child: Text("127.0.0.1 :")),
              suffix: IconButton (
                iconButtonMode: IconButtonMode.small,
                icon: const Icon(FluentIcons.reset),
                onPressed: () {GState.androidPortPending.update((_) => 58526.toString()); androidPortUpdater.instant(58526); setState((){});},
              )
            )),
          ),
          smallSpacer,
          FluentCard(
            leading: const Icon(Mdi.powerStandby , size: 23),
            content: Text(lang.settings_autostart),
            trailing: Row(children: [ConstrainedBox(constraints: const BoxConstraints(minWidth: 28.5), child: Text(autostartWSA ? ON : OFF)), ToggleSwitch(
              checked: autostartWSA,
              onChanged: (v) => GState.autostartWSA..$ = v..persist()
            )]),
          ),
          smallSpacer,
          FluentCard(
            leading: const Icon(Mdi.translate , size: 23),
            content: Text(lang.settings_language),
            trailing: SizedBox(width: 300, height: 32, child: FluentCombobox<NamedLocale>(
              allowUnknown: true,
              onTap: (){}, placeholder: Text(locale_lang.name), 
              isExpanded: true,
              value: locale_lang,
              onChanged: (l){if (l != null) GState.locale..$=l..persist();},
              items: _localeItems,
            )),
          ),
          smallSpacer,
          ExpanderWin11(
            leading: const Icon(Mdi.themeLightDark, size: 23),
            header: Text(lang.theme_mode),
            content: Column(crossAxisAlignment: CrossAxisAlignment.start, children: 
                optionsListDeferred<Options_Theme, ThemeMode>(Options_Theme.values, (e)=>e.description(lang), (e) => e.mode, (v) => themeMode == v, (e, v) => GState.theme..update((p0) => e)..persist())
            ),
            //headerBackgroundColor: ThemablePaneItem.uncheckedInputAlphaColor(theme, states),
            direction: ExpanderDirection.down, // (optional). Defaults to ExpanderDirection.down
            initiallyExpanded: false, // (false). Defaults to false
          ),
          smallSpacer,
          if (WinVer.isWindows11OrGreater) ExpanderWin11(
            leading: const Icon(Mdi.blur, size: 23),
            header: Text(lang.theme_mica),
            content: Column(crossAxisAlignment: CrossAxisAlignment.start, children: 
                optionsList<Options_Mica>(Options_Mica.values, (e)=>e.description(lang), (e) => mica == e, (e) => GState.mica..update((_) => e)..persist())
            ),
            //headerBackgroundColor: ThemablePaneItem.uncheckedInputAlphaColor(theme, states),
            direction: ExpanderDirection.down, // (optional). Defaults to ExpanderDirection.down
            initiallyExpanded: false, // (false). Defaults to false
          ),
          if (WinVer.isWindows11OrGreater) smallSpacer,
          ExpanderWin11(
            leading: SizedBox(width: 23.00, height: 23.00, child: exampleIcon),
            header: Text(lang.theme_icon_adaptive),
            content: Column(crossAxisAlignment: CrossAxisAlignment.start, children: 
                optionsList<Options_IconShape>(Options_IconShape.values, (e)=>e.description(lang), (e) => iconShape == e, (e) => GState.iconShape..update((_) => e)..persist())
            ),
            trailing: Row(children: [ConstrainedBox(constraints: const BoxConstraints(minWidth: 28.5), child: Text(legacyIcons ? OFF : ON)), ToggleSwitch(
              checked: !legacyIcons,
              onChanged: (v) => GState.legacyIcons..$ = !v..persist()
            )]),
            //headerBackgroundColor: ThemablePaneItem.uncheckedInputAlphaColor(theme, states),
            direction: ExpanderDirection.down, // (optional). Defaults to ExpanderDirection.down
            initiallyExpanded: false, // (false). Defaults to false
          )
        ],
      ),
    );
  }
  
}

```

`lib/screens/wsa.dart`:

```dart
// ignore_for_file: avoid_print

import 'dart:io';

import 'package:fluent_ui/fluent_ui.dart';
import 'package:mdi/mdi.dart';
import 'package:wsa_pacman/utils/wsa_utils.dart';
import 'package:wsa_pacman/widget/fluent_card.dart';
import 'package:wsa_pacman/widget/fluent_info_bar.dart';
import '../main.dart';
import '../global_state.dart';

class ScreenWSA extends StatefulWidget {
  const ScreenWSA({Key? key}) : super(key: key);

  @override
  _ScreenWSAState createState() => _ScreenWSAState();
}

class EmptyElement extends Element {
  EmptyElement(Empty widget) : super(widget);
  @override
  void performRebuild() {}
  @override
  bool get debugDoingBuild => false;
  @override
  Empty get widget => super.widget as Empty;
}
class Empty extends Widget {
  const Empty();

  @override
  Element createElement() => EmptyElement(this);
}
Expanded EMPTY = Expanded(child: Column());

class _ScreenWSAState extends State<ScreenWSA> {
  //_FormsState(this.gsmap);

  //final GSMap<Object, dynamic> gsmap;
  final autoSuggestBox = TextEditingController();

  final _clearController = TextEditingController();
  bool _showPassword = false;
  final values = ['Blue', 'Green', 'Yellow', 'Red'];
  String? comboBoxValue;

  DateTime date = DateTime.now();

  @override
  Widget build(BuildContext context) {
    var connectionStatus = GState.connectionStatus.of(context);
    final lang = AppLocalizations.of(context)!;

    const smallSpacer = SizedBox(height: 5.0);

    return ScaffoldPage(
      header: PageHeader(title: Text(lang.screen_wsa)),
      content: ListView(
        padding: EdgeInsets.only(
          bottom: kPageDefaultVerticalPadding,
          left: PageHeader.horizontalPadding(context),
          right: PageHeader.horizontalPadding(context),
        ),
        children: [
          Padding(
            padding: const EdgeInsets.only(bottom: 8.0),
            child: FluentInfoBar(
              title: Text(connectionStatus.title(lang)),
              content: Wrap(crossAxisAlignment: WrapCrossAlignment.center, children: [
                Text(connectionStatus.desc(lang)),
                const SizedBox(width: 15.0),
                if (connectionStatus.type == ConnectionStatus.ARRESTED) Button(child: Text(lang.btn_boot), onPressed: () => WSAUtils.launch())
              ]),
              isLong: true,
              severity: connectionStatus.severity,
              action: () {
                // Do nothing for now
              }(),
            )
          ),
          const SizedBox(height: 20),
          Text(lang.wsa_manage, style: FluentTheme.of(context).typography.bodyLarge),
          const SizedBox(height: 20),
          FluentCard(
            leading: const Icon(Mdi.android , size: 23),
            content: Text(lang.wsa_manage_app),
            isButton: true,
            onPressed: connectionStatus.isDisconnected ? 
                null : () => Process.run('${Env.TOOLS_DIR}\\adb.exe', ['-s', '${GState.ipAddress.of(context)}:${GState.androidPort.of(context)}', 
                  'shell', r'am start com.android.settings/.Settings\$ManageApplicationsActivity']),
          ),
          smallSpacer,
          FluentCard(
            leading: const Icon(Mdi.cogs, size: 23),
            content: Text(lang.wsa_manage_settings),
            isButton: true,
            onPressed: connectionStatus.isDisconnected ?
                null : () => Process.run('${Env.TOOLS_DIR}\\adb.exe', ['-s', '${GState.ipAddress.of(context)}:${GState.androidPort.of(context)}', 
                  'shell', r'am start com.android.settings/.Settings']),
          )

        ],
      ),
    );
  }
}

```

`lib/theme.dart`:

```dart
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter/foundation.dart';
import 'package:system_theme/system_theme.dart';
import 'package:flutter_acrylic/flutter_acrylic.dart' as flutter_acrylic;

enum NavigationIndicators { sticky, end }

class AppTheme extends ChangeNotifier {
  static final AccentColor alpineLandingDark = AccentColor('normal', const <String, Color>{
    'darkest': Color(0xff126568),
    'darker': Color(0xff146D70),
    'dark': Color(0xff157477),
    'normal': Color(0xff167C80),
    'light': Color(0xff188387),
    'lighter': Color(0xff198A8E),
    'lightest': Color(0xff1B9296),
  });
  static final AccentColor alpineLandingLight = AccentColor('normal', const <String, Color>{
    'darkest': Color(0xff167C80),
    'darker': Color(0xff188387),
    'dark': Color(0xff198A8E),
    'normal': Color(0xff1C9EA0),
    'light': Color(0xff1DA5A5),
    'lighter': Color(0xff20B2B2),
    'lightest': Color(0xff21B7B7),
  });
  AccentColor? _color; //Alpine landing FTW
  AccentColor getColor(bool darkMode) => _color ?? (darkMode ? alpineLandingDark : alpineLandingLight);
  void setColor(AccentColor color) {
    _color = (identical(color, alpineLandingDark) || identical(color, alpineLandingLight)) ? null : color;
    notifyListeners();
  }

  PaneDisplayMode _displayMode = PaneDisplayMode.top;
  PaneDisplayMode get displayMode => _displayMode;
  set displayMode(PaneDisplayMode displayMode) {
    _displayMode = displayMode;
    notifyListeners();
  }

  NavigationIndicators _indicator = NavigationIndicators.sticky;
  NavigationIndicators get indicator => _indicator;
  set indicator(NavigationIndicators indicator) {
    _indicator = indicator;
    notifyListeners();
  }

  /*flutter_acrylic.AcrylicEffect _acrylicEffect =
      flutter_acrylic.AcrylicEffect.disabled;
  flutter_acrylic.AcrylicEffect get acrylicEffect => _acrylicEffect;
  set acrylicEffect(flutter_acrylic.AcrylicEffect acrylicEffect) {
    _acrylicEffect = acrylicEffect;
    notifyListeners();
  }*/
}

AccentColor get systemAccentColor {
  if (defaultTargetPlatform == TargetPlatform.windows ||
      defaultTargetPlatform == TargetPlatform.android ||
      kIsWeb) {
    return AccentColor('normal', {
      'darkest': SystemTheme.accentInstance.darkest,
      'darker': SystemTheme.accentInstance.darker,
      'dark': SystemTheme.accentInstance.dark,
      'normal': SystemTheme.accentInstance.accent,
      'light': SystemTheme.accentInstance.light,
      'lighter': SystemTheme.accentInstance.lighter,
      'lightest': SystemTheme.accentInstance.lightest,
    });
  }
  return Colors.blue;
}

```

`lib/utils/int_utils.dart`:

```dart
// ignore_for_file: constant_identifier_names

import 'dart:io';

import 'dart:typed_data';

extension IntUtils on int {
  static const int LOCALHOST = 2130706433;

  String get asIpv4 => InternetAddress.fromRawAddress(Uint8List(4)..buffer.asByteData().setInt32(0, this)).address;
}
```

`lib/utils/locale_utils.dart`:

```dart
// ignore_for_file: non_constant_identifier_names, constant_identifier_names, curly_braces_in_flow_control_structures

import 'dart:collection';
import 'dart:ffi';
import 'dart:io';
import 'dart:ui';
import 'package:ffi/ffi.dart';
import 'package:win32/win32.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
export 'package:flutter_gen/gen_l10n/app_localizations.dart';
import 'package:intl/intl.dart' as intl;
import 'package:wsa_pacman/windows/win_io.dart';
import 'string_utils.dart';

extension LocaleUtils on Locale {
  _NamedLocale _asNamedLocale([int? lcid]) => lcid == null ? _NamedLocale(languageCode, countryCode, scriptCode) : _NamedLocaleLCID(lcid, languageCode, countryCode);
  _SystemLocale get _asSystemLocale => _SystemLocale(languageCode, countryCode, scriptCode);
  static late final NamedLocale _DEFAULT_SYSTEM_LOCALE = _SystemLocale("en");
  static late final _DEFAULT_LOCALIZATION = lookupAppLocalizations(_DEFAULT_SYSTEM_LOCALE);
  //static late final _LOCALE = {for (final l in supportedLocales) l.lcid : l};
  static late final NamedLocale SYSTEM_LOCALE = (() {
    try {return (intl.Intl.systemLocale = intl.Intl.canonicalizedLocale(Platform.localeName)).asLocale?._asSystemLocale ?? _DEFAULT_SYSTEM_LOCALE;}
    catch (e) {return intl.Intl.systemLocale.asLocale?._asSystemLocale ?? _DEFAULT_SYSTEM_LOCALE;}
  })();

  static late final supportedLocales = SplayTreeSet<NamedLocale>.from(AppLocalizations.supportedLocales.map<NamedLocale>((l) => _NamedLocale(l.languageCode, l.countryCode, l.scriptCode)), (a, b) => a.name.compareTo(b.name));
  int? toLCID() => _WinLocale.localeToLCID(toLanguageTag());
  static NamedLocale? fromLCID(int lcid) => lcid == 0 ? SYSTEM_LOCALE : _WinLocale.localeFromLCID(lcid);
  static NamedLocale fromLCIDOrDefault(int lcid) => fromLCID(lcid) ?? SYSTEM_LOCALE;
  bool get isSystemLocale => identical(this, SYSTEM_LOCALE);
  AppLocalizations get _localizationOrDefault {
    try {return lookupAppLocalizations(this);}
    catch(_) {return _DEFAULT_LOCALIZATION;}
  }

  static Locale? _SYSTEM_MATCH;
  static Locale localeResolutionCallback(Locale? locale, Iterable<Locale> list) {
    Locale? bestMatch;
    int confidence = 0;
    if (locale != null) {
      if (locale is _NamedLocale && list is Iterable<NamedLocale>) {
        if (locale._isValid == true) return locale;
        else if (locale._isValid == null) for (final lc in list) if (locale == lc) {locale._isValid = true; return lc;}
        locale._isValid = false;
      }
      else if (locale is! _SystemLocale || _SYSTEM_MATCH == null) for (final lc in list) if (locale.languageCode == lc.languageCode) {
        int newConfidence = locale.scriptCode == lc.scriptCode ? locale.countryCode == lc.countryCode ? 8 : lc.countryCode == null ? 7 : 6 : 
            locale.countryCode == lc.countryCode ? 5 : lc.scriptCode == null ? lc.countryCode == null ? 4 : 3 : lc.countryCode == null ? 2 : 1;
        if (newConfidence > confidence) {
          confidence = newConfidence;
          bestMatch = lc;
          if (confidence == 8) break;
        }
      }
    }
    bestMatch = bestMatch ?? const Locale("en");
    return (locale is _SystemLocale) ? _SYSTEM_MATCH ??= bestMatch : bestMatch;
  }
}


class _WinLocale {
  static const int LOCALE_NAME_MAX_LENGTH = 85;
  //static const int LOCALE_SSCRIPTS = 108;
  static const int LOCALE_SPARENT = 109;

  static final _LocaleNameToLCID = kernel32.lookupFunction<
    Uint32 Function(Pointer<Utf16> lpName, Uint32 dwFlags), 
    int Function(Pointer<Utf16> lpName, int dwFlags)>('LocaleNameToLCID');
  static final _LCIDToLocaleName = kernel32.lookupFunction<
    Uint32 Function(Uint32 locale, Pointer<Utf16> lpName, Int32 cchName, Uint32 dwFlags), 
    int Function(int locale, Pointer<Utf16> lpName, int cchName, int dwFlags)>('LCIDToLocaleName');

  static String parentScriptCode(Locale locale) {
    final lpLocaleName = '${locale.languageCode}${locale.countryCode != null ? "-${locale.countryCode}" : ""}'.toNativeUtf16();
    final lpLCData = malloc<WCHAR>(LOCALE_NAME_MAX_LENGTH).cast<Utf16>();
    try {
      int result = GetLocaleInfoEx(lpLocaleName, LOCALE_SPARENT, lpLCData, LOCALE_NAME_MAX_LENGTH);
      return (result != 0 ? lpLCData.toDartString() : '').find('^[^_-]*[_-]([^_-]+)', 1) ?? '';
    }
    finally {
      free(lpLocaleName);
      free(lpLCData);
    }
  }

  static int? localeToLCID(String locale) {
    final lpName = locale.toNativeUtf16();
    try {
      final int lcid = _LocaleNameToLCID(lpName, 0);
      switch (lcid) {
        case 0: case 0x1000: case 0x0C00: return null;
        default: return lcid;
      }
    }
    finally {free(lpName);}
  }

  static NamedLocale? localeFromLCID(int lcid) {
    LPWSTR? lpName = malloc<WCHAR>(LOCALE_NAME_MAX_LENGTH).cast<Utf16>();
    try {
      int result = _LCIDToLocaleName(lcid, lpName, LOCALE_NAME_MAX_LENGTH, 0);
      return result != 0 ? lpName.toDartString().asLocale?._asNamedLocale(lcid) : null;
    }
    finally {free(lpName);}
  }
}


abstract class NamedLocale extends Locale {
  const NamedLocale._(String _languageCode, [String? _countryCode, String? _scriptCode]) : 
      super.fromSubtags(languageCode: _languageCode, countryCode: _countryCode, scriptCode: _scriptCode);
  String get name;
  int get lcid;
}

class _NamedLocale extends NamedLocale {
  bool? _isValid;
  _NamedLocale(String _languageCode, [String? _countryCode, String? _scriptCode]) : super._(_languageCode, _countryCode, _scriptCode);
  @override late final String name = lookupAppLocalizations(this).locale_desc;
  @override late final int lcid = toLCID() ?? (){throw ArgumentError("Unknown language tag: ${toLanguageTag()}");}();
  @override int get hashCode => lcid;
  @override bool operator ==(Object other) => other is! _SystemLocale && (other is NamedLocale ? other.languageCode == languageCode && other.lcid == lcid : super==other);
}

class _NamedLocaleLCID extends _NamedLocale {
  _NamedLocaleLCID(this.lcid, String _languageCode, [String? _countryCode, String? _scriptCode]) : super(_languageCode, _countryCode, _scriptCode);
  // ignore: overridden_fields 
  @override late final String name = (){try {return super.name;} catch (e) {return "Unknown";}}();
  // ignore: overridden_fields 
  @override final int lcid;
}

class _SystemLocale extends NamedLocale {
  _SystemLocale(String _languageCode, [String? _countryCode, String? _scriptCode]) : super._(_languageCode, _countryCode) {
    if (_scriptCode != null) scriptCode = _scriptCode;
  }
  // ignore: overridden_fields
  @override late String? scriptCode = _WinLocale.parentScriptCode(this);
  @override late final String name = _localizationOrDefault.locale_system;
  @override final int lcid = 0;
  @override final int hashCode = 0;
  @override bool operator ==(Object other) => other is _SystemLocale;
}
```

`lib/utils/misc_utils.dart`:

```dart
// ignore_for_file: curly_braces_in_flow_control_structures

import 'dart:async';
import 'dart:io';
import 'package:path/path.dart' as lib_path;
import 'package:archive/archive.dart';
import '../windows/win_io.dart';
import 'package:fluent_ui/fluent_ui.dart';

class DynamicTimer {
  int _durationUs;
  int _tick = 0;
  final void Function(Timer timer) _callback;
  Timer? _timer;

  DynamicTimer(this._callback) : _durationUs = -1;
  DynamicTimer.periodic(Duration _duration, this._callback) : _durationUs = _duration.inMicroseconds, _timer = Timer.periodic(_duration, _callback);

  void cancel() => _timer?.cancel();
  int get tick => _tick + (_timer?.tick ?? 0);
  bool get isActive => _timer?.isActive ?? false;

  /// Starts or restarts the timer with a new duration
  void setDuration(Duration duration) {
    if (duration.inMicroseconds == _durationUs) return;
    _timer?.cancel();
    _tick += _timer?.tick ?? 0;
    _durationUs = duration.inMicroseconds;
    _timer = Timer.periodic(duration, _callback);
  }
}

class ColorConst extends Color {
  const ColorConst.withOpacity(int value, double opacity) : super(
    ( (((opacity * 0xff ~/ 1) & 0xff) << 24) | ((0x00ffffff & value)) ) & 0xFFFFFFFF);
}

extension EdgeInsetsUtils on EdgeInsets {
  EdgeInsetsDirectional directional() => this is EdgeInsetsDirectional ? this as EdgeInsetsDirectional : EdgeInsetsDirectional.fromSTEB(left, top, right, bottom);
}

extension FileUtils<K,V> on FileSystemEntity {
  String get basename => lib_path.basename(path);
}

extension MapUtils<K,V> on Map<K,V> {
  List<V> getAll(Iterable<K> keys) {
    List<V> list = [];
    for (var key in keys) {
      final value = this[key];
      if (value!=null) list.add(value);
    }
    return list;
  }
}

extension ArchiveUtils on Archive {
  List<ArchiveFile> getFiles(Iterable<String>? names) {
    List<ArchiveFile> files = [];
    if (names == null || names.isEmpty) return files;
    var regex = RegExp('^(${names.join("|")})\$');
    for (var file in this.files) {
      if (regex.hasMatch(file.name)) files.add(file);
    }
    return files;
  }

  Future<bool> extractAll(Directory directory, {bool replaceExisting = false, FileDisposeQueue? disposeLock}) async => extractAllSync(directory, replaceExisting: replaceExisting, disposeLock: disposeLock);
  bool extractAllSync(Directory directory, {bool replaceExisting = false, FileDisposeQueue? disposeLock }) {
    bool success = true;
    Future.wait([for (final file in files) () async {if (file.extractSync(directory, replaceExisting: replaceExisting, disposeLock: disposeLock)) success = false;}()]);
    return success;
  }
}

extension ArchiveFileUtils on ArchiveFile {
  Future<bool> extract(Directory directory, {bool replaceExisting = false, FileDisposeQueue? disposeLock}) async => extractSync(directory, replaceExisting: replaceExisting, disposeLock: disposeLock);
  bool extractSync(Directory directory, {bool replaceExisting = false, FileDisposeQueue? disposeLock}) {
    final file = File("${directory.absolute.path}\\$name");
    bool confirmExist = false;
    if (!replaceExisting && (confirmExist = file.existsSync())) return false;
    if (!confirmExist) file..createSync(recursive: true)..writeAsBytesSync(content);
    disposeLock?.add(file);
    return true;
  }
}
```

`lib/utils/regexp_utils.dart`:

```dart
const String REGEX_XML_NOCLOSE = '[^\'">]*("[^"]*"[^">]*|\'[^\']*\'[^\'">]*)*';
const String REGEX_XML_QUOTED = "[\"][^\"]*[\"]|['][^']*[']";
String REGEX_QUOTED_PATTERN(String Function(String quoteChar) regex) => '("${regex('"')}"|\'${regex("'")}\')';
```

`lib/utils/string_utils.dart`:

```dart
// ignore_for_file: curly_braces_in_flow_control_structures

import 'dart:collection';
import 'dart:ui';
import 'dart:io';

extension StringUtils on String {
  Locale? get asLocale => findAnd<Locale?>(r"^([a-z]*)([_-]([A-Za-z][a-z]{2,3}))?([_-]([A-Z]*))?", (m) => m.group(1)?.isNotEmpty ?? false ? 
      Locale.fromSubtags(languageCode: m.group(1)!, countryCode: m.group(5)?.isNotEmpty ?? false ? m.group(5)! : null,
      scriptCode: m.group(3)?.isNotEmpty ?? false ? m.group(3)! : null) : null);
  int? get ipv4AsInt => InternetAddress.tryParse(this)?.rawAddress.buffer.asByteData().getInt32(0);

  String get capitalized => '${this[0].toUpperCase()}${substring(1)}';
  String get normalized => '${this[0].toUpperCase()}${replaceAll('_', ' ').substring(1).toLowerCase()}';
  String get unquoted => RegExp('^["\']?([^\'"]*([\'"][^\$])*)["\']?\$', multiLine: true).firstMatch(this)?.group(1) ?? this;

  /// Is 7-bit ASCII only
  bool get isASCII => RegExp(r'^[\x00-\x7F]+$', multiLine: true, dotAll: true).hasMatch(this);
  bool isNumeric() => contains(RegExp(r'^[0-9]*$'));
  bool isSignedNumeric() => contains(RegExp(r'^[+-]?[0-9]*$'));

  String? find(String regexp, [int group = 0]) {
    var matches = RegExp(regexp).firstMatch(this);
      return matches?.group(group);
  }

  /// Maps folding repeated entries per key
  Map<K, V> foldToMap<K,V>(String regexp, K Function(RegExpMatch match) key, V Function(RegExpMatch match, V? prev) value) {
    Map<K,V> map = {};
    for (var m in RegExp(regexp).allMatches(this)) map.update(key(m), (v) => value(m, v), ifAbsent: () => value(m, null));
    return map;
  }

  /// Maps the string, assumes a single match per key
  Map<K, V> toMap<K,V>(String regexp, K Function(RegExpMatch match) key, V Function(RegExpMatch match) value) {
    return {for (var m in RegExp(regexp).allMatches(this)) key(m) : value(m)};
  }

  /// Maps the string, assumes a single match per key
  Set<E> toSet<E>(String regexp, E? Function(RegExpMatch match) value, [int Function(E key1, E key2)? compare]) {
    final Set<E> set = compare != null ? SplayTreeSet(compare) : <E>{};
    for (var m in RegExp(regexp).allMatches(this)) {
      var nv = value(m);
      if (nv != null) set.add(nv);
      else if (null is E) (set as Set<E?>).add(nv);
    }
    return set;
  }

  Iterable<String> findAll(String regexp, [int group = 0]) {
    return RegExp(regexp).allMatches(this).map((m) => m.group(group)!);
  }

  Iterable<R> findAllAnd<R>(String regexp, R Function(RegExpMatch match) provider) {
    return RegExp(regexp).allMatches(this).map((m) => provider(m));
  }

  R? findAnd<R>(String regexp, R Function(RegExpMatch match) provider) {
    final match = RegExp(regexp).firstMatch(this);
    return match != null ? provider(match) : null;
  }
}
```

`lib/utils/wsa_utils.dart`:

```dart
import 'package:wsa_pacman/main.dart';
import 'package:wsa_pacman/windows/win_io.dart';
import 'package:wsa_pacman/windows/win_pkg.dart';
import '../utils/string_utils.dart';
import '../utils/regexp_utils.dart';

class WSAUtils {
  static bool launch([String? param]) => WinIO.run(ShellOp.OPEN, "shell:appsFolder\\${Env.WSA_INFO.familyName}!${Env.WSA_INFO.clientID}", param);
  static bool launchApp(String package) => launch("/launch wsa://$package");
}

class WSAPkgInfo extends WinPkgInfo {
  late final String clientID;

  WSAPkgInfo.fromSystemPath(String systemPath) : super.fromSystemPath(systemPath);

  @override void parseManifestExtras(String manifest) {
    String? clientInfo = RegExp('<\\s*Application${REGEX_XML_NOCLOSE}Executable\\s*=\\s*${REGEX_QUOTED_PATTERN((c)=>"[^$c>]*WsaClient.exe")}$REGEX_XML_NOCLOSE', caseSensitive: false, multiLine: true, dotAll: true)
      .firstMatch(manifest)?.group(0);
    clientID = clientInfo?.find('Id\\s*=\\s*($REGEX_XML_QUOTED)', 1)?.unquoted ?? "App";
  }
}
```

`lib/widget/adaptive_icon.dart`:

```dart
import 'dart:math' hide log;
import 'package:fluent_ui/fluent_ui.dart';

//Display an Android adaptive icon
//TODO not immutable
class AdaptiveIcon extends StatelessWidget {
  final double _scale;
  final double radius;
  Color? backColor;
  Widget? background;
  Widget? foreground;

  AdaptiveIcon({Key? key, this.radius = 0.6, this.background, this.foreground, this.backColor, bool noScale = false}) : _scale = noScale ? 1 : 1.5 ,super(key: key);

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      child: FractionallySizedBox(
        heightFactor: 1,
        widthFactor: 1,
        child: LayoutBuilder(
          builder: (context, BoxConstraints constraints) {
            final borderRadius = min(constraints.maxWidth, constraints.maxHeight) * radius/2;
            return Center(
              child: AspectRatio (
                aspectRatio: 1,
                child:  ClipRRect(
                  clipBehavior: Clip.antiAliasWithSaveLayer,
                  borderRadius: BorderRadius.circular(borderRadius),
                  child: Transform.scale(scale: _scale, child: Stack(fit: StackFit.expand, children: [
                    background ?? DecoratedBox(decoration: BoxDecoration(color: backColor ?? Colors.white)),
                    foreground ?? const SizedBox(width: 0)
                  ],))
                ),
              )
            );
          }
        ),
      )
    );
  }
}
```

`lib/widget/flexible_info_bar.dart`:

```dart
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter/material.dart' as material;
import 'package:wsa_pacman/widget/fluent_info_bar.dart';

class FlexibleInfoBar extends StatelessWidget {

  const FlexibleInfoBar({
    Key? key,
    required this.title,
    this.content,
    this.action,
    this.severity = InfoBarSeverity.info,
    this.style,
    this.onClose,
  }) : super(key: key);

  final InfoBarSeverity severity;
  final InfoBarThemeData? style;
  final Widget title;
  final Widget? content;
  final Widget? action;
  final void Function()? onClose;

  @override
  Widget build(BuildContext context) {
    return Flexible(child: LayoutBuilder(
      builder: (context, BoxConstraints constraints) {
        return FluentInfoBar(
          title: SizedBox(
            height: (constraints.maxHeight-25),// - (constraints.maxHeight-constr.maxHeight),
            child: material.Scaffold(
              backgroundColor: Colors.transparent,
              appBar: _PaddedTitle(DefaultTextStyle(
                style: FluentTheme.of(context).typography.bodyStrong ?? const TextStyle(),
                child: title,
              )),
              body: (content != null) ? ListView(children: [DefaultTextStyle(
                style: FluentTheme.of(context).typography.body ?? const TextStyle(),
                child: content!,
                softWrap: true,
              )]) : null
            )
          ),
          isLong: true,
          severity: severity,
          style: style,
          action: action,
          onClose: onClose,
        );
      }
    ));
  }
}


class _PaddedTitle extends StatelessWidget implements PreferredSizeWidget {
  final Widget child;

  const _PaddedTitle(this.child);

  @override
  Widget build(BuildContext context) {
    double? infoBarPadding = InfoBarTheme.of(context).padding?.vertical;
    if (infoBarPadding != null) infoBarPadding /= 2;
    return Padding(padding: EdgeInsets.only(bottom: infoBarPadding ?? 10), child: child);
  }

  @override
  Size get preferredSize => const Size.fromHeight(double.maxFinite);
}
```

`lib/widget/fluent_card.dart`:

```dart
import 'package:fluent_ui/fluent_ui.dart';
import 'package:wsa_pacman/utils/misc_utils.dart';

class FluentCard extends StatefulWidget {
  /// Creates an expander
  const FluentCard({
    Key? key,
    this.leading,
    required this.content,
    this.icon,
    this.trailing,
    this.animationCurve,
    this.animationDuration,
    this.onPressed,
    this.onStateChanged,
    this.isButton = false,
    this.headerHeight = 68.5,
    this.headerBackgroundColor,
    this.contentBackgroundColor,
  }) : super(key: key);

  static Color backgroundColor(ThemeData style, Set<ButtonStates> states, [bool isClickable = true]) {
    if (style.brightness == Brightness.light) {
      if (!states.isDisabled && isClickable) {
        if (states.isPressing) return const ColorConst.withOpacity(0xf9f9f9, 0.2);
        if (states.isHovering) return const ColorConst.withOpacity(0xf9f9f9, 0.4);
      }
      return const ColorConst.withOpacity(0xFFFFFF, 0.7);
    } else {
      if (!states.isDisabled && isClickable) {
        if (states.isPressing) return const ColorConst.withOpacity(0xFFFFFF, 0.03);
        if (states.isHovering) return const ColorConst.withOpacity(0xFFFFFF, 0.082);
      }
      return const ColorConst.withOpacity(0xFFFFFF, 0.05);
    }
  }

  static Color borderColor(ThemeData style, Set<ButtonStates> states, [bool isClickable = true]) {
    if (style.brightness == Brightness.light) {
      if (isClickable && states.isHovering && !states.isPressing) return const Color(0xFF212121).withOpacity(0.22);
      return const Color(0xFF212121).withOpacity(0.17);
    } else {
      if (isClickable && states.isPressing) return Colors.white.withOpacity(0.062);
      if (isClickable && states.isHovering) return Colors.white.withOpacity(0.02);
      return Colors.black.withOpacity(0.52);
    }
  }

  /// The leading widget.
  ///
  /// See also:
  ///
  ///  * [Icon]
  ///  * [RadioButton]
  ///  * [Checkbox]
  final Widget? leading;

  /// The card content
  ///
  /// Usually a [Text]
  final Widget content;

  /// The icon of the toggle button.
  final Widget? icon;

  /// Disable when onPressed is null, always show chevron icon in the right
  final bool isButton;

  /// The trailing widget. It's positioned at the right of [content]
  /// and at the left of [icon].
  ///
  /// See also:
  ///
  ///  * [ToggleSwitch]
  final Widget? trailing;

  /// Makes the card clickable
  /// is null by default
  final VoidCallback? onPressed;

  /// The expand-collapse animation duration. If null, defaults to
  /// [FluentTheme.fastAnimationDuration]
  final Duration? animationDuration;

  /// The expand-collapse animation curve. If null, defaults to
  /// [FluentTheme.animationCurve]
  final Curve? animationCurve;

  /// A callback called when the current state is changed. `true` when
  /// open and `false` when closed.
  final ValueChanged<bool>? onStateChanged;

  /// The height of the header.
  /// 
  /// Defaults to 48.0
  final double headerHeight;

  /// The background color of the header. If null, [ThemeData.scaffoldBackgroundColor]
  /// is used
  final Color? headerBackgroundColor;
  
  /// The content color of the header. If null, [ThemeData.acrylicBackgroundColor]
  /// is used
  final Color? contentBackgroundColor;

  @override
  FluentCardState createState() => FluentCardState();
}

class FluentCardState extends State<FluentCard>
    with SingleTickerProviderStateMixin {
  late ThemeData theme;

  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: widget.animationDuration ?? const Duration(milliseconds: 150),
    );
  }

  static void emptyPressMethod() {}
  static const double borderSize = 0.5;
  static final Color darkBorderColor = Colors.black.withOpacity(0.8);

  static const Duration expanderAnimationDuration = Duration(milliseconds: 70);

  /// If this widget acts as a button and is disabled, gray out all text and icons
  Widget buttonStyled(Widget child) => !widget.isButton || widget.onPressed != null ? child : IconTheme.merge(
    data: IconThemeData(color: theme.disabledColor), 
    child: DefaultTextStyle.merge(style: TextStyle(color: theme.disabledColor), child: child)
  );

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasFluentTheme(context));
    final isLtr = Directionality.of(context) == TextDirection.ltr;
    theme = FluentTheme.of(context);
    bool isDark = theme.brightness == Brightness.dark;

    return buttonStyled(HoverButton(
      onPressed: widget.onPressed ?? (widget.isButton ? null : emptyPressMethod),
      builder: (context, states) {
        return AnimatedContainer(
          duration: expanderAnimationDuration,
          height: widget.headerHeight,
          decoration: BoxDecoration(
            color: FluentCard.backgroundColor(theme, states, widget.onPressed != null),
            border: Border.all(
              width: borderSize,
              color: FluentCard.borderColor(theme, states, widget.onPressed != null),
            ),
            borderRadius: const BorderRadius.all(Radius.circular(4.0)),
          ),
          padding: const EdgeInsetsDirectional.only(start: 16.0),
          alignment: Alignment.centerLeft,
          child: Row(mainAxisSize: MainAxisSize.min, children: [
            if (widget.leading != null) Padding(
              padding: const EdgeInsetsDirectional.only(end: 17.0),
              child: widget.leading!,
            ),
            Expanded(child: widget.content),
            if (widget.trailing != null) Padding(
              padding: const EdgeInsetsDirectional.only(start: 20.0, end: 13.5),
              child: widget.trailing!,
            ),
            if (widget.icon != null || widget.isButton) Container(
              margin: EdgeInsetsDirectional.only(
                start: widget.trailing != null ? 8.0 : 20.0,
                end: 8.0,
                top: 8.0,
                bottom: 8.0,
              ),
              padding: const EdgeInsets.symmetric(horizontal: 10.0),
              alignment: Alignment.center,
              child: widget.icon ?? Icon(isLtr ? isDark ? FluentIcons.chevron_right : FluentIcons.chevron_right_med :
                  isDark ? FluentIcons.chevron_left : FluentIcons.chevron_left_med, size: 11),
            ),
          ]),
        );
      },
    ));
  }
}

```

`lib/widget/fluent_combo_box.dart`:

```dart
// ignore_for_file: curly_braces_in_flow_control_structures

import 'dart:math' as math;
import 'dart:ui' show window;

import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';

import 'package:fluent_ui/fluent_ui.dart';
// ignore: implementation_imports
import 'package:fluent_ui/src/controls/form/pickers/pickers.dart';
import 'package:wsa_pacman/utils/misc_utils.dart';

const Duration _kComboboxMenuDuration = Duration(milliseconds: 300);
const double _kMenuItemHeight = kPickerHeight;
const EdgeInsets _kMenuItemPadding = EdgeInsets.symmetric(horizontal: 12.0);
const EdgeInsetsGeometry _kAlignedButtonPadding = EdgeInsets.only(
  top: 4.0,
  bottom: 4.0,
  right: 8.0,
  left: 12.0,
);
const EdgeInsets _kAlignedMenuMargin = EdgeInsets.zero;
const EdgeInsets _kListPadding = EdgeInsets.symmetric(vertical: 8.0);
const double kMinInteractiveDimension = 48.0;
typedef FluentComboboxBuilder = List<Widget> Function(BuildContext context);

class _ComboboxMenuPainter extends CustomPainter {
  _ComboboxMenuPainter({
    this.selectedIndex,
    required this.resize,
    required this.getSelectedItemOffset,
  })  : _painter = BoxDecoration(
          borderRadius: BorderRadius.circular(6.0),
          border: Border.all(width: 0.5, color: const ColorConst.withOpacity(0x000000, 0.5)),
        ).createBoxPainter(),
        super(repaint: resize);

  final int? selectedIndex;
  final Animation<double> resize;
  final ValueGetter<double> getSelectedItemOffset;
  final BoxPainter _painter;

  @override
  void paint(Canvas canvas, Size size) {
    final double selectedItemOffset = getSelectedItemOffset();
    final Tween<double> top = Tween<double>(
      begin: selectedItemOffset.clamp(0.0, size.height - _kMenuItemHeight),
      end: 0.0,
    );

    final Tween<double> bottom = Tween<double>(
      begin:
          (top.begin! + _kMenuItemHeight).clamp(_kMenuItemHeight, size.height),
      end: size.height,
    );

    final Rect rect = Rect.fromLTRB(
        0.0, top.evaluate(resize), size.width, bottom.evaluate(resize));

    _painter.paint(canvas, rect.topLeft, ImageConfiguration(size: rect.size));
  }

  @override
  bool shouldRepaint(_ComboboxMenuPainter oldPainter) {
    return oldPainter.selectedIndex != selectedIndex ||
        oldPainter.resize != resize;
  }
}

class _ComboboxScrollBehavior extends ScrollBehavior {
  const _ComboboxScrollBehavior();

  @override
  TargetPlatform getPlatform(BuildContext context) => defaultTargetPlatform;

  @override
  Widget buildViewportChrome(
          BuildContext context, Widget child, AxisDirection axisDirection) =>
      child;

  @override
  ScrollPhysics getScrollPhysics(BuildContext context) =>
      const ClampingScrollPhysics();
}

class _ComboboxItemButton<T> extends StatefulWidget {
  const _ComboboxItemButton({
    Key? key,
    this.padding,
    required this.route,
    required this.buttonRect,
    required this.constraints,
    required this.itemIndex,
  }) : super(key: key);

  final _ComboboxRoute<T> route;
  final EdgeInsets? padding;
  final Rect buttonRect;
  final BoxConstraints constraints;
  final int itemIndex;

  @override
  _ComboboxItemButtonState<T> createState() => _ComboboxItemButtonState<T>();
}

class _ComboboxItemButtonState<T> extends State<_ComboboxItemButton<T>> {
  void _handleFocusChange(bool focused) {
    final bool inTraditionalMode;
    switch (FocusManager.instance.highlightMode) {
      case FocusHighlightMode.touch:
        inTraditionalMode = false;
        break;
      case FocusHighlightMode.traditional:
        inTraditionalMode = true;
        break;
    }

    if (focused && inTraditionalMode) {
      final _MenuLimits menuLimits = widget.route.getMenuLimits(
          widget.buttonRect, widget.constraints.maxHeight, widget.itemIndex);
      widget.route.scrollController!.animateTo(
        menuLimits.scrollOffset,
        curve: Curves.easeInOut,
        duration: const Duration(milliseconds: 100),
      );
    }
  }

  void _handleOnTap() {
    final ComboboxItem<T> comboboxMenuItem =
        widget.route.items[widget.itemIndex].item!;

    if (comboboxMenuItem.onTap != null) {
      comboboxMenuItem.onTap!();
    }

    Navigator.pop(
      context,
      _ComboboxRouteResult<T>(comboboxMenuItem.value),
    );
  }

  static final Map<LogicalKeySet, Intent> _webShortcuts =
      <LogicalKeySet, Intent>{
    LogicalKeySet(LogicalKeyboardKey.enter): const ActivateIntent(),
  };

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasFluentTheme(context));
    final CurvedAnimation opacity;
    final double unit = 0.5 / (widget.route.items.length + 1.5);
    if (widget.itemIndex == widget.route.selectedIndex) {
      opacity = CurvedAnimation(
          parent: widget.route.animation!, curve: const Threshold(0.0));
    } else {
      final double start =
          (0.5 + (widget.itemIndex + 1) * unit).clamp(0.0, 1.0);
      final double end = (start + 1.5 * unit).clamp(0.0, 1.0);
      opacity = CurvedAnimation(
          parent: widget.route.animation!, curve: Interval(start, end));
    }
    Widget child = FadeTransition(
      opacity: opacity,
      child: HoverButton(
        autofocus: widget.itemIndex == widget.route.selectedIndex,
        builder: (context, states) {
          final theme = FluentTheme.of(context);
          return Padding(
            padding: const EdgeInsets.only(right: 6.0, left: 6.0, bottom: 4.0),
            child: Stack(fit: StackFit.loose, children: [
              Container(
                decoration: BoxDecoration(
                  color: () {
                    if (states.isFocused) {
                      return ButtonThemeData.uncheckedInputColor(
                        theme,
                        {ButtonStates.hovering},
                      );
                    }
                    return ButtonThemeData.uncheckedInputColor(theme, states);
                  }(),
                  borderRadius: BorderRadius.circular(4.0),
                ),
                padding: widget.padding,
                child: widget.route.items[widget.itemIndex],
              ),
              if (states.isFocused)
                AnimatedPositioned(
                  duration: theme.fastAnimationDuration,
                  curve: theme.animationCurve,
                  top: states.isPressing ? 10.0 : 8.0,
                  bottom: states.isPressing ? 10.0 : 8.0,
                  child: Container(
                    width: 3.0,
                    decoration: BoxDecoration(
                      color: theme.accentColor
                          .resolveFromReverseBrightness(theme.brightness),
                      borderRadius: BorderRadius.circular(50.0),
                    ),
                  ),
                ),
            ]),
          );
        },
        onPressed: _handleOnTap,
        onFocusChange: _handleFocusChange,
      ),
    );
    if (kIsWeb) {
      child = Shortcuts(
        shortcuts: _webShortcuts,
        child: child,
      );
    }
    return child;
  }
}

class _ComboboxMenu<T> extends StatefulWidget {
  const _ComboboxMenu({
    Key? key,
    this.padding,
    required this.route,
    required this.buttonRect,
    required this.constraints,
    this.comboboxColor,
  }) : super(key: key);

  final _ComboboxRoute<T> route;
  final EdgeInsets? padding;
  final Rect buttonRect;
  final BoxConstraints constraints;
  final Color? comboboxColor;

  @override
  _ComboboxMenuState<T> createState() => _ComboboxMenuState<T>();
}

class _ComboboxMenuState<T> extends State<_ComboboxMenu<T>> {
  late CurvedAnimation _fadeOpacity;
  late CurvedAnimation _resize;

  @override
  void initState() {
    super.initState();
    _fadeOpacity = CurvedAnimation(
      parent: widget.route.animation!,
      curve: const Interval(0.0, 0.25),
      reverseCurve: const Interval(0.75, 1.0),
    );
    _resize = CurvedAnimation(
      parent: widget.route.animation!,
      curve: const Interval(0.25, 0.5),
      reverseCurve: const Threshold(0.0),
    );
  }

  @override
  Widget build(BuildContext context) {
    final _ComboboxRoute<T> route = widget.route;
    final List<Widget> children = <Widget>[
      for (int itemIndex = 0; itemIndex < route.items.length; ++itemIndex)
        _ComboboxItemButton<T>(
          route: widget.route,
          padding: widget.padding,
          buttonRect: widget.buttonRect,
          constraints: widget.constraints,
          itemIndex: itemIndex,
        ),
    ];

    return FadeTransition(
      opacity: _fadeOpacity,
      child: Acrylic(
        shape: const RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(6.0))),
        elevation: route.elevation.toDouble(),
        child: CustomPaint(
          painter: _ComboboxMenuPainter(
            selectedIndex: route.selectedIndex,
            resize: _resize,
            getSelectedItemOffset: () =>
                route.getItemOffset(route.selectedIndex),
          ),
          child: Semantics(
            scopesRoute: true,
            namesRoute: true,
            explicitChildNodes: true,
            child: DefaultTextStyle(
              style: route.style,
              child: ScrollConfiguration(
                behavior: const _ComboboxScrollBehavior(),
                child: PrimaryScrollController(
                  controller: widget.route.scrollController!,
                  child: LayoutBuilder(
                    builder:
                        (BuildContext context, BoxConstraints constraints) {
                      final double menuTotalHeight = widget.route.itemHeights
                          .reduce(
                              (double total, double height) => total + height);
                      final bool isScrollable =
                          _kListPadding.vertical + menuTotalHeight >
                              constraints.maxHeight;
                      return Scrollbar(
                        isAlwaysShown: isScrollable,
                        child: ListView(
                          padding: _kListPadding,
                          shrinkWrap: true,
                          children: children,
                        ),
                      );
                    },
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _ComboboxMenuRouteLayout<T> extends SingleChildLayoutDelegate {
  _ComboboxMenuRouteLayout({
    required this.buttonRect,
    required this.route,
    required this.textDirection,
  });

  final Rect buttonRect;
  final _ComboboxRoute<T> route;
  final TextDirection? textDirection;

  @override
  BoxConstraints getConstraintsForChild(BoxConstraints constraints) {
    final double maxHeight =
        math.max(0.0, constraints.maxHeight - 2 * _kMenuItemHeight);
    final double width = math.min(constraints.maxWidth, buttonRect.width);
    return BoxConstraints(
      minWidth: width,
      maxWidth: width,
      minHeight: 0.0,
      maxHeight: maxHeight,
    );
  }

  @override
  Offset getPositionForChild(Size size, Size childSize) {
    final _MenuLimits menuLimits =
        route.getMenuLimits(buttonRect, size.height, route.selectedIndex);

    assert(() {
      final Rect container = Offset.zero & size;
      if (container.intersect(buttonRect) == buttonRect) {
        assert(menuLimits.top >= 0.0);
        assert(menuLimits.top + menuLimits.height <= size.height);
      }
      return true;
    }());
    assert(textDirection != null);
    final double left;
    switch (textDirection!) {
      case TextDirection.rtl:
        left = buttonRect.right.clamp(0.0, size.width) - childSize.width;
        break;
      case TextDirection.ltr:
        left = buttonRect.left.clamp(0.0, size.width - childSize.width);
        break;
    }

    return Offset(left, menuLimits.top);
  }

  @override
  bool shouldRelayout(_ComboboxMenuRouteLayout<T> oldDelegate) {
    return buttonRect != oldDelegate.buttonRect ||
        textDirection != oldDelegate.textDirection;
  }
}

@immutable
class _ComboboxRouteResult<T> {
  const _ComboboxRouteResult(this.result);

  final T? result;

  @override
  bool operator ==(Object other) {
    return other is _ComboboxRouteResult<T> && other.result == result;
  }

  @override
  int get hashCode => result.hashCode;
}

class _MenuLimits {
  const _MenuLimits(this.top, this.bottom, this.height, this.scrollOffset);
  final double top;
  final double bottom;
  final double height;
  final double scrollOffset;
}

class _ComboboxRoute<T> extends PopupRoute<_ComboboxRouteResult<T>> {
  _ComboboxRoute({required this.items, required this.padding, required this.buttonRect, required this.selectedIndex, this.elevation = 16,
    required this.capturedThemes, required this.style, required this.acrylicEnabled, this.barrierLabel, this.itemHeight, this.comboboxColor}) 
      : itemHeights = List<double>.filled(items.length, itemHeight ?? kMinInteractiveDimension);

  final List<_MenuItem<T>> items;
  final EdgeInsetsGeometry padding;
  final Rect buttonRect;
  final int selectedIndex;
  final int elevation;
  final CapturedThemes capturedThemes;
  final TextStyle style;
  final double? itemHeight;
  final Color? comboboxColor;
  final bool acrylicEnabled;

  final List<double> itemHeights;
  ScrollController? scrollController;

  @override Duration get transitionDuration => _kComboboxMenuDuration;
  @override bool get barrierDismissible => true;
  @override Color? get barrierColor => null;
  @override final String? barrierLabel;

  @override
  Widget buildPage(context, animation, secondaryAnimation) {
    return LayoutBuilder(builder: (context, constraints) {
      final page = _ComboboxRoutePage<T>(route: this, constraints: constraints, items: items, padding: padding, buttonRect: buttonRect,
        selectedIndex: selectedIndex, elevation: elevation, capturedThemes: capturedThemes, style: style, comboboxColor: comboboxColor);
      if (acrylicEnabled) return page;
      return DisableAcrylic(child: page);
    });
  }

  void _dismiss() {
    if (isActive) {
      navigator?.removeRoute(this);
    }
  }

  double getItemOffset(int index) {
    double offset = _kListPadding.top;
    if (items.isNotEmpty && index > 0) {
      assert(items.length == itemHeights.length);
      offset += itemHeights
          .sublist(0, index)
          .reduce((double total, double height) => total + height);
    }
    return offset;
  }
  
  _MenuLimits getMenuLimits(
      Rect buttonRect, double availableHeight, int index) {
    final double maxMenuHeight = availableHeight - 2.0 * _kMenuItemHeight;
    final double buttonTop = buttonRect.top;
    final double buttonBottom = math.min(buttonRect.bottom, availableHeight);
    final double selectedItemOffset = getItemOffset(index);
    final double topLimit = math.min(_kMenuItemHeight, buttonTop);
    final double bottomLimit =
        math.max(availableHeight - _kMenuItemHeight, buttonBottom);

    double menuTop = (buttonTop - selectedItemOffset) -
        (itemHeights[selectedIndex] - buttonRect.height) / 2.0;
    double preferredMenuHeight = _kListPadding.vertical;
    if (items.isNotEmpty) {
      preferredMenuHeight +=
          itemHeights.reduce((double total, double height) => total + height);
    }

    final double menuHeight = math.min(maxMenuHeight, preferredMenuHeight);
    double menuBottom = menuTop + menuHeight;

    if (menuTop < topLimit) menuTop = math.min(buttonTop, topLimit);

    if (menuBottom > bottomLimit) {
      menuBottom = math.max(buttonBottom, bottomLimit);
      menuTop = menuBottom - menuHeight;
    }

    double scrollOffset = 0;

    if (preferredMenuHeight > maxMenuHeight) {
      scrollOffset = math.max(0.0, selectedItemOffset - (buttonTop - menuTop));
      scrollOffset = math.min(scrollOffset, preferredMenuHeight - menuHeight);
    }

    return _MenuLimits(menuTop, menuBottom, menuHeight, scrollOffset);
  }
}

class _ComboboxRoutePage<T> extends StatelessWidget {
  const _ComboboxRoutePage({
    Key? key,
    required this.route,
    required this.constraints,
    this.items,
    required this.padding,
    required this.buttonRect,
    required this.selectedIndex,
    this.elevation = 8,
    required this.capturedThemes,
    this.style,
    required this.comboboxColor,
  }) : super(key: key);

  final _ComboboxRoute<T> route;
  final BoxConstraints constraints;
  final List<_MenuItem<T>>? items;
  final EdgeInsetsGeometry padding;
  final Rect buttonRect;
  final int selectedIndex;
  final int elevation;
  final CapturedThemes capturedThemes;
  final TextStyle? style;
  final Color? comboboxColor;

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));

    if (route.scrollController == null) {
      final _MenuLimits menuLimits =
          route.getMenuLimits(buttonRect, constraints.maxHeight, selectedIndex);
      route.scrollController =
          ScrollController(initialScrollOffset: menuLimits.scrollOffset);
    }

    final TextDirection? textDirection = Directionality.maybeOf(context);
    final Widget menu = _ComboboxMenu<T>(
      route: route,
      padding: padding.resolve(textDirection),
      buttonRect: buttonRect,
      constraints: constraints,
      comboboxColor: comboboxColor,
    );

    return MediaQuery.removePadding(
      context: context,
      removeTop: true,
      removeBottom: true,
      removeLeft: true,
      removeRight: true,
      child: Builder(
        builder: (BuildContext context) {
          return CustomSingleChildLayout(
            delegate: _ComboboxMenuRouteLayout<T>(
              buttonRect: buttonRect,
              route: route,
              textDirection: textDirection,
            ),
            child: capturedThemes.wrap(menu),
          );
        },
      ),
    );
  }
}

class _MenuItem<T> extends SingleChildRenderObjectWidget {
  const _MenuItem({
    Key? key,
    required this.onLayout,
    required this.item,
  }) : super(key: key, child: item);

  final ValueChanged<Size> onLayout;
  final ComboboxItem<T>? item;

  @override
  RenderObject createRenderObject(BuildContext context) {
    return _RenderMenuItem(onLayout);
  }

  @override
  void updateRenderObject(
      BuildContext context, covariant _RenderMenuItem renderObject) {
    renderObject.onLayout = onLayout;
  }
}

class _RenderMenuItem extends RenderProxyBox {
  _RenderMenuItem(this.onLayout, [RenderBox? child]) : super(child);

  ValueChanged<Size> onLayout;

  @override
  void performLayout() {
    super.performLayout();
    onLayout(size);
  }
}

// The container widget for a menu item created by a [Combobox]. It
// provides the default configuration for [ComboboxItem]s, as well as a
// [Combobox]'s placeholder and disabledHint widgets.
class _ComboboxItemContainer extends StatelessWidget {
  /// Creates an item for a combobox menu.
  ///
  /// The [child] argument is required.
  const _ComboboxItemContainer({
    Key? key,
    required this.child,
  }) : super(key: key);

  /// The widget below this widget in the tree.
  ///
  /// Typically a [Text] widget.
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return Container(
      constraints: const BoxConstraints(minHeight: _kMenuItemHeight),
      alignment: AlignmentDirectional.centerStart,
      child: child,
    );
  }
}

class FluentCombobox<T> extends StatefulWidget {
  FluentCombobox({
    Key? key,
    required this.items,
    this.allowUnknown = false,
    this.selectedItemBuilder,
    this.value,
    this.placeholder,
    this.disabledHint,
    this.onChanged,
    this.onTap,
    this.elevation = 8,
    this.style,
    this.icon,
    this.iconDisabledColor,
    this.iconEnabledColor,
    this.iconSize = 10.0,
    this.isExpanded = false,
    this.itemHeight = kMinInteractiveDimension,
    this.focusColor,
    this.focusNode,
    this.autofocus = false,
    this.comboboxColor,
  }) : assert(allowUnknown || items == null || items.isEmpty || value == null || items.where((item) => item.value == value).length == 1,
          "There should be exactly one item with [Combobox]'s value: $value. \n"
          'Either zero or 2 or more [ComboboxItem]s were detected with the same value'),
        assert(itemHeight == null || itemHeight >= kMinInteractiveDimension),
        super(key: key);

  final bool allowUnknown;
  final List<ComboboxItem<T>>? items;
  final T? value;
  final Widget? placeholder;
  final Widget? disabledHint;
  final ValueChanged<T?>? onChanged;
  final VoidCallback? onTap;
  final FluentComboboxBuilder? selectedItemBuilder;
  final int elevation;
  final TextStyle? style;
  final Widget? icon;
  final Color? iconDisabledColor;
  final Color? iconEnabledColor;
  final double iconSize;
  final bool isExpanded;
  final double? itemHeight;
  final Color? focusColor;
  final FocusNode? focusNode;
  final bool autofocus;
  final Color? comboboxColor;

  @override
  _FluentComboboxState<T> createState() => _FluentComboboxState<T>();
}

class _FluentComboboxState<T> extends State<FluentCombobox<T>> with WidgetsBindingObserver {
  int? _selectedIndex;
  _ComboboxRoute<T>? _comboboxRoute;
  Orientation? _lastOrientation;
  FocusNode? _internalNode;
  FocusNode? get focusNode => widget.focusNode ?? _internalNode;
  bool _hasPrimaryFocus = false;
  late Map<Type, Action<Intent>> _actionMap;
  late FocusHighlightMode _focusHighlightMode;

  // Only used if needed to create _internalNode.
  FocusNode _createFocusNode() {
    return FocusNode(debugLabel: '${widget.runtimeType}');
  }

  @override
  void initState() {
    super.initState();
    _updateSelectedIndex();
    if (widget.focusNode == null) {
      _internalNode ??= _createFocusNode();
    }
    _actionMap = <Type, Action<Intent>>{
      ActivateIntent: CallbackAction<ActivateIntent>(
        onInvoke: (ActivateIntent intent) => _handleTap(),
      ),
      ButtonActivateIntent: CallbackAction<ButtonActivateIntent>(
        onInvoke: (ButtonActivateIntent intent) => _handleTap(),
      ),
    };
    focusNode!.addListener(_handleFocusChanged);
    final FocusManager focusManager = WidgetsBinding.instance!.focusManager;
    _focusHighlightMode = focusManager.highlightMode;
    focusManager.addHighlightModeListener(_handleFocusHighlightModeChange);
  }

  @override
  void dispose() {
    WidgetsBinding.instance!.removeObserver(this);
    _removeComboboxRoute();
    WidgetsBinding.instance!.focusManager
        .removeHighlightModeListener(_handleFocusHighlightModeChange);
    focusNode!.removeListener(_handleFocusChanged);
    _internalNode?.dispose();
    super.dispose();
  }

  void _removeComboboxRoute() {
    _comboboxRoute?._dismiss();
    _comboboxRoute = null;
    _lastOrientation = null;
  }

  void _handleFocusChanged() {
    if (_hasPrimaryFocus != focusNode!.hasPrimaryFocus) {
      setState(() {
        _hasPrimaryFocus = focusNode!.hasPrimaryFocus;
      });
    }
  }

  void _handleFocusHighlightModeChange(FocusHighlightMode mode) {
    if (!mounted) {
      return;
    }
    setState(() {
      _focusHighlightMode = mode;
    });
  }

  @override
  void didUpdateWidget(FluentCombobox<T> oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.focusNode != oldWidget.focusNode) {
      oldWidget.focusNode?.removeListener(_handleFocusChanged);
      if (widget.focusNode == null) {
        _internalNode ??= _createFocusNode();
      }
      _hasPrimaryFocus = focusNode!.hasPrimaryFocus;
      focusNode!.addListener(_handleFocusChanged);
    }
    _updateSelectedIndex();
  }

  void _updateSelectedIndex() {
    if (widget.value == null || widget.items == null || widget.items!.isEmpty) {
      _selectedIndex = null;
      return;
    }
    
    for (int itemIndex = 0; itemIndex < widget.items!.length; itemIndex++) {
      if (widget.items![itemIndex].value == widget.value) {
        _selectedIndex = itemIndex;
        return;
      }
    }
    assert(widget.allowUnknown);
    _selectedIndex = null;
  }

  TextStyle? get _textStyle =>
      widget.style ?? FluentTheme.of(context).typography.body;

  void _handleTap() {
    final TextDirection? textDirection = Directionality.maybeOf(context);
    const EdgeInsetsGeometry menuMargin = _kAlignedMenuMargin;

    final List<_MenuItem<T>> menuItems = <_MenuItem<T>>[
      for (int index = 0; index < widget.items!.length; index += 1)
        _MenuItem<T>(
          item: widget.items![index],
          onLayout: (Size size) {
            if (_comboboxRoute == null) return;

            _comboboxRoute!.itemHeights[index] = size.height;
          },
        )
    ];

    final NavigatorState navigator = Navigator.of(context);
    assert(_comboboxRoute == null);
    final RenderBox itemBox = context.findRenderObject()! as RenderBox;
    final Rect itemRect = itemBox.localToGlobal(Offset.zero,
            ancestor: navigator.context.findRenderObject()) &
        itemBox.size;
    _comboboxRoute = _ComboboxRoute<T>(
      acrylicEnabled: DisableAcrylic.of(context) != null,
      items: menuItems,
      buttonRect: menuMargin.resolve(textDirection).inflateRect(itemRect),
      padding: _kMenuItemPadding.resolve(textDirection),
      selectedIndex: _selectedIndex ?? 0,
      elevation: widget.elevation,
      capturedThemes:
          InheritedTheme.capture(from: context, to: navigator.context),
      style: _textStyle!,
      barrierLabel: FluentLocalizations.of(context).modalBarrierDismissLabel,
      itemHeight: widget.itemHeight,
      comboboxColor: widget.comboboxColor,
    );

    navigator
        .push(_comboboxRoute!)
        .then<void>((_ComboboxRouteResult<T>? newValue) {
      _removeComboboxRoute();
      if (!mounted || newValue == null) return;
      if (widget.onChanged != null) widget.onChanged!(newValue.result);
    });

    if (widget.onTap != null) {
      widget.onTap!();
    }
  }

  Color get _iconColor {
    // These colors are not defined in the Material Design spec.
    if (_enabled) {
      if (widget.iconEnabledColor != null) return widget.iconEnabledColor!;

      switch (FluentTheme.of(context).brightness) {
        case Brightness.light:
          return Colors.grey[190];
        case Brightness.dark:
          return Colors.white.withOpacity(0.7);
      }
    } else {
      if (widget.iconDisabledColor != null) return widget.iconDisabledColor!;

      switch (FluentTheme.of(context).brightness) {
        case Brightness.light:
          return Colors.grey[150];
        case Brightness.dark:
          return Colors.white.withOpacity(0.10);
      }
    }
  }

  bool get _enabled =>
      widget.items != null &&
      widget.items!.isNotEmpty &&
      widget.onChanged != null;

  Orientation _getOrientation(BuildContext context) {
    Orientation? result = MediaQuery.maybeOf(context)?.orientation;
    if (result == null) {
      // If there's no MediaQuery, then use the window aspect to determine
      // orientation.
      final Size size = window.physicalSize;
      result = size.width > size.height
          ? Orientation.landscape
          : Orientation.portrait;
    }
    return result;
  }

  bool get _showHighlight {
    switch (_focusHighlightMode) {
      case FocusHighlightMode.touch:
        return false;
      case FocusHighlightMode.traditional:
        return _hasPrimaryFocus;
    }
  }

  @override
  Widget build(BuildContext context) {
    final Orientation newOrientation = _getOrientation(context);
    _lastOrientation ??= newOrientation;
    if (newOrientation != _lastOrientation) {
      _removeComboboxRoute();
      _lastOrientation = newOrientation;
    }
    
    final List<Widget> items = widget.selectedItemBuilder == null
        ? (widget.items != null ? List<Widget>.from(widget.items!) : <Widget>[])
        : List<Widget>.from(widget.selectedItemBuilder!(context));

    int? placeholderIndex;
    if (widget.placeholder != null ||
        (!_enabled && widget.disabledHint != null)) {
      Widget displayedHint = _enabled
          ? widget.placeholder!
          : widget.disabledHint ?? widget.placeholder!;
      if (widget.selectedItemBuilder == null) {
        displayedHint = _ComboboxItemContainer(child: displayedHint);
      }

      placeholderIndex = items.length;
      items.add(DefaultTextStyle(
        style:
            _textStyle!.copyWith(color: FluentTheme.of(context).disabledColor),
        child: IgnorePointer(
          ignoringSemantics: false,
          child: displayedHint,
        ),
      ));
    }

    const EdgeInsetsGeometry padding = _kAlignedButtonPadding;

    // If value is null (then _selectedIndex is null) then we
    // display the placeholder or nothing at all.
    final Widget innerItemsWidget;
    if (items.isEmpty) {
      innerItemsWidget = Container();
    } else {
      innerItemsWidget = IndexedStack(
        index: _selectedIndex ?? placeholderIndex,
        alignment: AlignmentDirectional.centerStart,
        children: items.map((Widget item) {
          return widget.itemHeight != null
              ? SizedBox(height: widget.itemHeight, child: item)
              : Column(
                  mainAxisSize: MainAxisSize.min,
                  children: <Widget>[item],
                );
        }).toList(),
      );
    }

    const Icon defaultIcon = Icon(FluentIcons.chevron_down);

    Widget result = DefaultTextStyle(
      style: _enabled
          ? _textStyle!
          : _textStyle!.copyWith(color: FluentTheme.of(context).disabledColor),
      child: Container(
        padding: padding.resolve(Directionality.of(context)),
        height: kPickerHeight,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          mainAxisSize: MainAxisSize.min,
          children: <Widget>[
            if (widget.isExpanded)
              Expanded(child: innerItemsWidget)
            else
              innerItemsWidget,
            IconTheme.merge(
              data: IconThemeData(color: _iconColor, size: widget.iconSize),
              child: widget.icon ?? defaultIcon,
            ),
          ],
        ),
      ),
    );

    return Semantics(
      button: true,
      child: Actions(
        actions: _actionMap,
        child: HoverButton(
          focusNode: focusNode,
          autofocus: widget.autofocus,
          onPressed: _enabled ? _handleTap : null,
          builder: (context, states) {
            return Container(
              decoration: fluentComboBoxDecorationBuilder(context, () {
                if (_showHighlight) {
                  return {ButtonStates.focused};
                } else if (states.isFocused) {
                  return <ButtonStates>{};
                }
                return states;
              }()),
              child: result,
            );
          },
        ),
      ),
    );
  }
}

BorderSide fluentComboBoxBorderColor(bool isDark, Set<ButtonStates> states) {
  if (isDark) {
    if (states.isDisabled) return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0xf0f0f0, 0.05));
    if (states.isNone || (states.isHovering && !states.isPressing)) return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0xf0f0f0, 0.035));
    else return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0xf0f0f0, 0.07));
  }
  else {
    if (states.isDisabled) return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0x212121, 0.12));
    if (states.isNone || (states.isHovering && !states.isDisabled && !states.isPressing)) return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0x212121, 0.22));
    else return const BorderSide(width: 0.5, color: ColorConst.withOpacity(0x212121, 0.07));
  }
}

Color fluentComboBoxColor(bool isDark, Set<ButtonStates> states) {
  if (isDark) {
    if (states.isDisabled) return const ColorConst.withOpacity(0xFFFFFF, 0.045);
    if (states.isPressing) return const ColorConst.withOpacity(0xFFFFFF, 0.03);
    if (states.isHovering) return const ColorConst.withOpacity(0xFFFFFF, 0.08);
    return const ColorConst.withOpacity(0xFFFFFF, 0.055);
  }
  else {
    if (states.isDisabled) return const ColorConst.withOpacity(0xf9f9f9, 0.045);
    if (states.isPressing) return const ColorConst.withOpacity(0xf0f0f0, 0.4);
    if (states.isHovering) return const ColorConst.withOpacity(0xf9f9f9, 0.65);
    return const ColorConst.withOpacity(0xFFFFFF, 0.8);
  }
}

Decoration fluentComboBoxDecorationBuilder(
    BuildContext context, Set<ButtonStates> states) {
  assert(debugCheckHasFluentTheme(context));
  final theme = FluentTheme.of(context);
  return BoxDecoration(
    borderRadius: BorderRadius.circular(4.0),
    border: Border.fromBorderSide(fluentComboBoxBorderColor(theme.brightness.isDark, states)),
    color: fluentComboBoxColor(theme.brightness.isDark, states),
  );
}

```

`lib/widget/fluent_expander.dart`:

```dart
import 'package:fluent_ui/fluent_ui.dart';
import 'package:wsa_pacman/widget/fluent_card.dart';
import 'package:wsa_pacman/widget/themed_pane_item.dart';

class ExpanderWin11 extends StatefulWidget {
  /// Creates an expander
  const ExpanderWin11({
    Key? key,
    this.leading,
    required this.header,
    required this.content,
    this.icon,
    this.trailing,
    this.animationCurve,
    this.animationDuration,
    this.direction = ExpanderDirection.down,
    this.initiallyExpanded = false,
    this.onStateChanged,
    this.headerHeight = 68.5,
    this.headerBackgroundColor,
    this.contentBackgroundColor,
  }) : super(key: key);

  /// The leading widget.
  ///
  /// See also:
  ///
  ///  * [Icon]
  ///  * [RadioButton]
  ///  * [Checkbox]
  final Widget? leading;

  /// The expander header
  ///
  /// Usually a [Text]
  final Widget header;

  /// The expander content
  ///
  /// You can use complex, interactive UI as the content of the
  /// Expander, including nested Expander controls in the content
  /// of a parent Expander as shown here.
  ///
  /// ![Expander Nested Content](https://docs.microsoft.com/en-us/windows/apps/design/controls/images/expander-nested.png)
  final Widget content;

  /// The icon of the toggle button.
  final Widget? icon;

  /// The trailing widget. It's positioned at the right of [header]
  /// and at the left of [icon].
  ///
  /// See also:
  ///
  ///  * [ToggleSwitch]
  final Widget? trailing;

  /// The expand-collapse animation duration. If null, defaults to
  /// [FluentTheme.fastAnimationDuration]
  final Duration? animationDuration;

  /// The expand-collapse animation curve. If null, defaults to
  /// [FluentTheme.animationCurve]
  final Curve? animationCurve;

  /// The expand direction. Defaults to [ExpanderDirection.down]
  final ExpanderDirection direction;

  /// Whether the [ExpanderWin11] is initially expanded. Defaults to `false`
  final bool initiallyExpanded;

  /// A callback called when the current state is changed. `true` when
  /// open and `false` when closed.
  final ValueChanged<bool>? onStateChanged;

  /// The height of the header.
  /// 
  /// Defaults to 48.0
  final double headerHeight;

  /// The background color of the header. If null, [ThemeData.scaffoldBackgroundColor]
  /// is used
  final Color? headerBackgroundColor;
  
  /// The content color of the header. If null, [ThemeData.acrylicBackgroundColor]
  /// is used
  final Color? contentBackgroundColor;

  @override
  ExpanderWin11State createState() => ExpanderWin11State();
}

class ExpanderWin11State extends State<ExpanderWin11>
    with SingleTickerProviderStateMixin {
  late ThemeData theme;

  late bool _open;
  bool get open => _open;
  set open(bool value) {
    if (_open != value) _handlePressed();
  }

  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _open = widget.initiallyExpanded;
    _controller = AnimationController(
      vsync: this,
      duration: widget.animationDuration ?? const Duration(milliseconds: 150),
    );
  }

  void _handlePressed() {
    if (open) {
      _controller.animateTo(
        0.0,
        duration: widget.animationDuration ?? theme.fastAnimationDuration,
        curve: widget.animationCurve ?? theme.animationCurve,
      );
      _open = false;
    } else {
      _controller.animateTo(
        1.0,
        duration: widget.animationDuration ?? theme.fastAnimationDuration,
        curve: widget.animationCurve ?? theme.animationCurve,
      );
      _open = true;
    }
    widget.onStateChanged?.call(open);
    if (mounted) setState(() {});
  }

  bool get _isDown => widget.direction == ExpanderDirection.down;

  static const double borderSize = 0.5;
  static final Color darkBorderColor = Colors.black.withOpacity(0.8);

  static const Duration expanderAnimationDuration = Duration(milliseconds: 70);

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasFluentTheme(context));
    theme = FluentTheme.of(context);
    bool isDark = theme.brightness == Brightness.dark;

    final children = [
      HoverButton(
        onPressed: _handlePressed,
        builder: (context, states) {
          return AnimatedContainer(
            duration: expanderAnimationDuration,
            height: widget.headerHeight,
            decoration: BoxDecoration(
              color: FluentCard.backgroundColor(theme, states, true),
              border: Border.all(
                width: borderSize,
                color: FluentCard.borderColor(theme, states, true),
              ),
              borderRadius: BorderRadius.vertical(
                top: const Radius.circular(4.0),
                bottom: Radius.circular(open ? 0.0 : 4.0),
              ),
            ),
            padding: const EdgeInsetsDirectional.only(start: 16.0),
            alignment: Alignment.centerLeft,
            child: Row(mainAxisSize: MainAxisSize.min, children: [
              if (widget.leading != null)
                Padding(
                  padding: const EdgeInsetsDirectional.only(end: 17.0),
                  child: widget.leading!,
                ),
              Expanded(child: widget.header),
              if (widget.trailing != null)
                Padding(
                  padding: const EdgeInsetsDirectional.only(start: 20.0),
                  child: widget.trailing!,
                ),
              Container(
                margin: EdgeInsetsDirectional.only(
                  start: widget.trailing != null ? 8.0 : 20.0,
                  end: 8.0,
                  top: 8.0,
                  bottom: 8.0,
                ),
                padding: const EdgeInsets.symmetric(horizontal: 10.0),
                /*decoration: BoxDecoration(
                  color: ButtonThemeData.uncheckedInputColor(theme, states),
                  borderRadius: BorderRadius.circular(4.0),
                ),*/
                alignment: Alignment.center,
                child: widget.icon ??
                    RotationTransition(
                      turns: Tween<double>(begin: 0, end: 0.5)
                          .animate(_controller),
                      child: Icon(
                        _isDown
                            ? isDark ? FluentIcons.chevron_down : FluentIcons.chevron_down_med
                            : isDark ? FluentIcons.chevron_up : FluentIcons.chevron_up_med,
                        size: 11,
                      ),
                    ),
              ),
            ]),
          );
        },
      ),
      SizeTransition(
        sizeFactor: _controller,
        // Eliminates double border
        // this is not possible by only setting left, right and bottom borders if borderRadius is enabled
        // see issue https://github.com/flutter/flutter/issues/12583
        child: Transform.translate(offset: const Offset(0, -borderSize), child: Container(
          width: double.infinity,
          padding: const EdgeInsets.all(16.0),
          decoration: BoxDecoration(
            border: Border.all(width: borderSize, color: FluentCard.borderColor(theme, {ButtonStates.none}, false)),
            color: FluentCard.backgroundColor(theme, {ButtonStates.none}, false),
            borderRadius: const BorderRadius.vertical(bottom: Radius.circular(4.0)),
          ),
          child: widget.content,
        )),
      ),
    ];
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: _isDown ? children : children.reversed.toList(),
    );
  }
}

```

`lib/widget/fluent_info_bar.dart`:

```dart
import 'dart:ui';
import 'package:fluent_ui/fluent_ui.dart';
import 'package:flutter/foundation.dart';

class FluentInfoBar extends StatelessWidget {
  /// Creates an info bar.
  const FluentInfoBar({
    Key? key,
    required this.title,
    this.content,
    this.action,
    this.severity = InfoBarSeverity.info,
    this.style,
    this.isLong = false,
    this.onClose,
  }) : super(key: key);

  /// The severity of this InfoBar. Defaults to [InfoBarSeverity.info]
  final InfoBarSeverity severity;

  /// The style applied to this info bar. If non-null, it's
  /// mescled with [ThemeData.infoBarThemeData]
  final InfoBarThemeData? style;

  final Widget title;
  final Widget? content;
  final Widget? action;

  /// Called when the close button is pressed. If this is null,
  /// there will be no close button
  final void Function()? onClose;

  /// If `true`, the info bar will be treated as long.
  ///
  /// ![Long InfoBar](https://docs.microsoft.com/en-us/windows/uwp/design/controls-and-patterns/images/infobar-success-content-wrapping.png)
  final bool isLong;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(FlagProperty('long', value: isLong, ifFalse: 'short'))
      ..add(EnumProperty('severity', severity))
      ..add(ObjectFlagProperty.has('onClose', onClose))
      ..add(DiagnosticsProperty('style', style, ifNull: 'no style'));
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasFluentTheme(context));
    assert(debugCheckHasFluentLocalizations(context));
    final localizations = FluentLocalizations.of(context);
    final style = InfoBarTheme.of(context).merge(this.style);
    final icon = style.icon?.call(severity);
    final closeIcon = style.closeIcon;
    final title = DefaultTextStyle(
      style: FluentTheme.of(context).typography.bodyStrong ?? const TextStyle(),
      child: this.title,
    );
    final content = () {
      if (this.content == null) return null;
      return DefaultTextStyle(
        style: FluentTheme.of(context).typography.body ?? const TextStyle(),
        child: this.content!,
        softWrap: true,
      );
    }();
    final action = () {
      if (this.action == null) return null;
      return ButtonTheme.merge(
        child: this.action!,
        data: ButtonThemeData.all(style.actionStyle),
      );
    }();
    return Container(
      decoration: style.decoration?.call(severity),
      padding: style.padding ?? const EdgeInsets.all(10),
      alignment: AlignmentDirectional.centerStart,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment:
            isLong ? CrossAxisAlignment.start : CrossAxisAlignment.center,
        children: [
          if (icon != null)
            Padding(
              padding: const EdgeInsetsDirectional.only(end: 6.0),
              child: Icon(icon, color: style.iconColor?.call(severity)),
            ),
          if (isLong)
            Flexible(
              fit: FlexFit.loose,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  title,
                  if (content != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 6.0),
                      child: content,
                    ),
                  if (action != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 6.0),
                      child: action,
                    ),
                ],
              ),
            )
          else
            Flexible(
              fit: FlexFit.loose,
              child: Wrap(
                crossAxisAlignment: WrapCrossAlignment.center,
                spacing: 6,
                children: [
                  title,
                  if (content != null) content,
                  if (action != null) action,
                ],
              ),
            ),
          if (closeIcon != null && onClose != null)
            Padding(
              padding: const EdgeInsetsDirectional.only(start: 10.0),
              child: Tooltip(
                message: localizations.closeButtonLabel,
                child: IconButton(
                  icon: Icon(closeIcon, size: style.closeIconSize),
                  onPressed: onClose,
                  style: style.closeButtonStyle,
                ),
              ),
            ),
        ],
      ),
    );
  }
}
```

`lib/widget/fluent_text_box.dart`:

```dart
import 'dart:ui' as ui;

import 'package:fluent_ui/fluent_ui.dart';
import 'package:fluent_ui/src/controls/form/selection_controls.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';

import 'package:flutter/services.dart';
import 'package:wsa_pacman/utils/misc_utils.dart';


class _TextBoxSelectionGestureDetectorBuilder extends TextSelectionGestureDetectorBuilder {
  _TextBoxSelectionGestureDetectorBuilder({required _TextBoxState state})  : _state = state, super(delegate: state);
  final _TextBoxState _state;

  @override void onDragSelectionEnd(DragEndDetails details) => _state._requestKeyboard();
  @override void onSingleTapUp(TapUpDetails details) {
    if (_state._clearGlobalKey.currentContext != null) {
      final RenderBox renderBox = _state._clearGlobalKey.currentContext!.findRenderObject() as RenderBox;
      final Offset localOffset = renderBox.globalToLocal(details.globalPosition);
      if (renderBox.hitTest(BoxHitTestResult(), position: localOffset)) return;
    }
    super.onSingleTapUp(details);
    _state._requestKeyboard();
    if (_state.widget.onTap != null) _state.widget.onTap!();
  }
}

class FluentTextBox extends StatefulWidget {
  const FluentTextBox({Key? key, this.controller, this.focusNode, this.padding = kTextBoxPadding, this.clipBehavior = Clip.antiAlias,
    this.placeholder, this.placeholderStyle, this.prefix, this.outsidePrefix, this.prefixMode = OverlayVisibilityMode.always,
    this.outsidePrefixMode = OverlayVisibilityMode.always, this.suffix, this.outsideSuffix, this.suffixMode = OverlayVisibilityMode.always,
    this.outsideSuffixMode = OverlayVisibilityMode.always, TextInputType? keyboardType, this.textInputAction, this.style, this.strutStyle,
    this.textAlign = TextAlign.start, this.textAlignVertical, this.readOnly = false, ToolbarOptions? toolbarOptions, this.showCursor,
    this.autofocus = false, this.obscuringCharacter = '•', this.obscureText = false, this.autocorrect = true, SmartDashesType? smartDashesType,
    SmartQuotesType? smartQuotesType, this.enableSuggestions = true, this.maxLines = 1, this.minLines, this.minHeight, this.expands = false,
    this.maxLength, this.maxLengthEnforced = true, this.onChanged, this.onEditingComplete, this.onSubmitted, this.inputFormatters, this.enabled,
    this.cursorWidth = 1.5, this.cursorHeight, this.cursorRadius = const Radius.circular(2.0), this.cursorColor,
    this.selectionHeightStyle = ui.BoxHeightStyle.tight, this.selectionWidthStyle = ui.BoxWidthStyle.tight, this.keyboardAppearance,
    this.scrollPadding = const EdgeInsets.all(20.0), this.dragStartBehavior = DragStartBehavior.start, this.enableInteractiveSelection = true,
    this.onTap, this.scrollController, this.scrollPhysics, this.autofillHints, this.restorationId,
    this.textCapitalization = TextCapitalization.none, this.header, this.headerStyle, this.iconButtonThemeData,
  }) : assert(obscuringCharacter.length == 1),
        smartDashesType = smartDashesType ?? (obscureText ? SmartDashesType.disabled : SmartDashesType.enabled),
        smartQuotesType = smartQuotesType ?? (obscureText ? SmartQuotesType.disabled : SmartQuotesType.enabled),
        assert(maxLines == null || maxLines > 0),
        assert(minLines == null || minLines > 0),
        assert((maxLines == null) || (minLines == null) || (maxLines >= minLines), "minLines can't be greater than maxLines"),
        assert(!expands || (maxLines == null && minLines == null), 'minLines and maxLines must be null when expands is true.'),
        assert(!obscureText || maxLines == 1, 'Obscured fields cannot be multiline.'),
        assert(maxLength == null || maxLength > 0),
        assert(!identical(textInputAction, TextInputAction.newline) || maxLines == 1 || !identical(keyboardType, TextInputType.text),
            'Use keyboardType TextInputType.multiline when using TextInputAction.newline on a multiline TextField.'),
        keyboardType = keyboardType ?? (maxLines == 1 ? TextInputType.text : TextInputType.multiline),
        toolbarOptions = toolbarOptions ?? (obscureText ? const ToolbarOptions(selectAll: true, paste: true)
            : const ToolbarOptions(copy: true, cut: true, selectAll: true, paste: true)),
        super(key: key);

  final TextEditingController? controller;
  final FocusNode? focusNode;
  final EdgeInsetsGeometry padding;
  final Clip clipBehavior;
  final String? placeholder;
  final TextStyle? placeholderStyle;
  final String? header;
  final TextStyle? headerStyle;
  final Widget? outsidePrefix;
  final Widget? prefix;
  final OverlayVisibilityMode prefixMode;
  final OverlayVisibilityMode outsidePrefixMode;
  final Widget? outsideSuffix;
  final Widget? suffix;
  final OverlayVisibilityMode suffixMode;
  final OverlayVisibilityMode outsideSuffixMode;
  final TextInputType keyboardType;
  final TextInputAction? textInputAction;
  final TextCapitalization textCapitalization;
  final TextStyle? style;
  final StrutStyle? strutStyle;
  final TextAlign textAlign;
  final ToolbarOptions toolbarOptions;
  final TextAlignVertical? textAlignVertical;
  final bool readOnly;
  final bool? showCursor;
  final bool autofocus;
  final String obscuringCharacter;
  final bool obscureText;
  final bool autocorrect;
  final SmartDashesType smartDashesType;
  final SmartQuotesType smartQuotesType;
  final bool enableSuggestions;
  final int? maxLines;
  final int? minLines;
  final double? minHeight;
  final bool expands;
  final int? maxLength;
  final bool maxLengthEnforced;
  final ValueChanged<String>? onChanged;
  final VoidCallback? onEditingComplete;
  final ValueChanged<String>? onSubmitted;
  final List<TextInputFormatter>? inputFormatters;
  final bool? enabled;
  final double cursorWidth;
  final double? cursorHeight;
  final Radius cursorRadius;
  final Color? cursorColor;
  final ui.BoxHeightStyle selectionHeightStyle;
  final ui.BoxWidthStyle selectionWidthStyle;
  final Brightness? keyboardAppearance;
  final EdgeInsets scrollPadding;
  final bool enableInteractiveSelection;
  final DragStartBehavior dragStartBehavior;
  final ScrollController? scrollController;
  final ScrollPhysics? scrollPhysics;
  bool get selectionEnabled => enableInteractiveSelection;
  final GestureTapCallback? onTap;
  final Iterable<String>? autofillHints;
  final String? restorationId;
  final ButtonThemeData? iconButtonThemeData;

  @override _TextBoxState createState() => _TextBoxState();
  @override void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty<TextEditingController>('controller', controller,
          defaultValue: null))
      ..add(DiagnosticsProperty<FocusNode>('focusNode', focusNode,
          defaultValue: null))
      ..add(DiagnosticsProperty<EdgeInsetsGeometry>('padding', padding))
      ..add(StringProperty('placeholder', placeholder))
      ..add(
          DiagnosticsProperty<TextStyle>('placeholderStyle', placeholderStyle))
      ..add(DiagnosticsProperty<OverlayVisibilityMode>(
          'prefix', prefix == null ? null : prefixMode))
      ..add(DiagnosticsProperty<OverlayVisibilityMode>(
          'suffix', suffix == null ? null : suffixMode))
      ..add(DiagnosticsProperty<TextInputType>('keyboardType', keyboardType,
          defaultValue: TextInputType.text))
      ..add(DiagnosticsProperty<TextStyle>('style', style, defaultValue: null))
      ..add(FlagProperty('autofocus',
          value: autofocus, ifFalse: 'manual focus', defaultValue: false))
      ..add(StringProperty('obscuringCharacter', obscuringCharacter,
          defaultValue: '•'))
      ..add(DiagnosticsProperty<bool>('obscureText', obscureText,
          defaultValue: false))
      ..add(DiagnosticsProperty<bool>('autocorrect', autocorrect,
          defaultValue: true))
      ..add(EnumProperty<SmartDashesType>('smartDashesType', smartDashesType,
          defaultValue:
              obscureText ? SmartDashesType.disabled : SmartDashesType.enabled))
      ..add(EnumProperty<SmartQuotesType>('smartQuotesType', smartQuotesType,
          defaultValue:
              obscureText ? SmartQuotesType.disabled : SmartQuotesType.enabled))
      ..add(DiagnosticsProperty<bool>('enableSuggestions', enableSuggestions,
          defaultValue: true))
      ..add(IntProperty('maxLines', maxLines, defaultValue: 1))
      ..add(IntProperty('minLines', minLines, defaultValue: null))
      ..add(DiagnosticsProperty<bool>('expands', expands, defaultValue: false))
      ..add(IntProperty('maxLength', maxLength, defaultValue: null))
      ..add(FlagProperty('maxLengthEnforced',
          value: maxLengthEnforced, ifTrue: 'max length enforced'))
      ..add(DoubleProperty('cursorWidth', cursorWidth, defaultValue: 2.0))
      ..add(DoubleProperty('cursorHeight', cursorHeight, defaultValue: null))
      ..add(DiagnosticsProperty<Radius>('cursorRadius', cursorRadius,
          defaultValue: null))
      ..add(FlagProperty(
        'selectionEnabled',
        value: selectionEnabled,
        defaultValue: true,
        ifFalse: 'selection disabled',
      ))
      ..add(DiagnosticsProperty<ScrollController>(
        'scrollController',
        scrollController,
        defaultValue: null,
      ))
      ..add(DiagnosticsProperty<ScrollPhysics>(
        'scrollPhysics',
        scrollPhysics,
        defaultValue: null,
      ))
      ..add(EnumProperty<TextAlign>('textAlign', textAlign,
          defaultValue: TextAlign.start))
      ..add(DiagnosticsProperty<TextAlignVertical>(
        'textAlignVertical',
        textAlignVertical,
        defaultValue: null,
      ));
  }
}

class _TextBoxState extends State<FluentTextBox>
    with RestorationMixin, AutomaticKeepAliveClientMixin
    implements TextSelectionGestureDetectorBuilderDelegate {
  final GlobalKey _clearGlobalKey = GlobalKey();

  RestorableTextEditingController? _controller;
  TextEditingController get _effectiveController =>
      widget.controller ?? _controller!.value;

  FocusNode? _focusNode;
  FocusNode get _effectiveFocusNode =>
      widget.focusNode ?? (_focusNode ??= FocusNode());

  bool _showSelectionHandles = false;

  late _TextBoxSelectionGestureDetectorBuilder _selectionGestureDetectorBuilder;

  @override
  bool get forcePressEnabled => true;

  @override
  final GlobalKey<EditableTextState> editableTextKey =
      GlobalKey<EditableTextState>();

  @override
  bool get selectionEnabled => widget.selectionEnabled;

  bool get enabled => widget.enabled ?? true;

  @override
  void initState() {
    super.initState();
    _selectionGestureDetectorBuilder =
        _TextBoxSelectionGestureDetectorBuilder(state: this);
    if (widget.controller == null) {
      _createLocalController();
    }
    _effectiveFocusNode.addListener(_handleFocusChanged);
  }

  void _handleFocusChanged() {
    if (!enabled && _effectiveFocusNode.hasPrimaryFocus) {
      _effectiveFocusNode.nextFocus();
    }
    setState(() {});
  }

  @override
  void didUpdateWidget(FluentTextBox oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.controller == null && oldWidget.controller != null) {
      _createLocalController(oldWidget.controller!.value);
    } else if (widget.controller != null && oldWidget.controller == null) {
      unregisterFromRestoration(_controller!);
      _controller!.dispose();
      _controller = null;
    }
    final bool isEnabled = widget.enabled ?? true;
    final bool wasEnabled = oldWidget.enabled ?? true;
    if (wasEnabled && !isEnabled) {
      _effectiveFocusNode.unfocus();
    }
  }

  @override
  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {
    if (_controller != null) {
      _registerController();
    }
  }

  void _registerController() {
    assert(_controller != null);
    registerForRestoration(_controller!, 'controller');
    _controller!.value.addListener(updateKeepAlive);
  }

  void _createLocalController([TextEditingValue? value]) {
    assert(_controller == null);
    _controller = value == null
        ? RestorableTextEditingController()
        : RestorableTextEditingController.fromValue(value);
    if (!restorePending) {
      _registerController();
    }
  }

  @override
  String? get restorationId => widget.restorationId;

  bool get showActiveBorder => _effectiveFocusNode.hasFocus;

  @override
  void dispose() {
    _effectiveFocusNode.removeListener(_handleFocusChanged);
    _focusNode?.dispose();
    _controller?.dispose();
    super.dispose();
  }

  EditableTextState? get _editableText => editableTextKey.currentState;

  void _requestKeyboard() {
    _editableText?.requestKeyboard();
  }

  bool _shouldShowSelectionHandles(SelectionChangedCause? cause) {
    if (!_selectionGestureDetectorBuilder.shouldShowSelectionToolbar) {
      return false;
    }

    if (_effectiveController.selection.isCollapsed) return false;

    if (cause == SelectionChangedCause.keyboard) return false;

    if (_effectiveController.text.isNotEmpty) return true;

    return false;
  }

  void _handleSelectionChanged(
      TextSelection selection, SelectionChangedCause? cause) {
    if (cause == SelectionChangedCause.longPress) {
      _editableText?.bringIntoView(selection.base);
    }
    final bool willShowSelectionHandles = _shouldShowSelectionHandles(cause);
    if (willShowSelectionHandles != _showSelectionHandles) {
      setState(() {
        _showSelectionHandles = willShowSelectionHandles;
      });
    }
  }

  @override
  bool get wantKeepAlive => _controller?.value.text.isNotEmpty == true;

  bool _shouldShowAttachment({
    required OverlayVisibilityMode attachment,
    required bool hasText,
  }) {
    switch (attachment) {
      case OverlayVisibilityMode.never:
        return false;
      case OverlayVisibilityMode.always:
        return true;
      case OverlayVisibilityMode.editing:
        return hasText;
      case OverlayVisibilityMode.notEditing:
        return !hasText;
    }
  }

  bool _showOutsidePrefixWidget(TextEditingValue text) {
    return widget.outsidePrefix != null &&
        _shouldShowAttachment(
          attachment: widget.outsidePrefixMode,
          hasText: text.text.isNotEmpty,
        );
  }

  bool _showPrefixWidget(TextEditingValue text) {
    return widget.prefix != null &&
        _shouldShowAttachment(
          attachment: widget.prefixMode,
          hasText: text.text.isNotEmpty,
        );
  }

  bool _showSuffixWidget(TextEditingValue text) {
    return widget.suffix != null &&
        _shouldShowAttachment(
          attachment: widget.suffixMode,
          hasText: text.text.isNotEmpty,
        );
  }

  bool _showOutsideSuffixWidget(TextEditingValue text) {
    return widget.outsideSuffix != null &&
        _shouldShowAttachment(
          attachment: widget.outsideSuffixMode,
          hasText: text.text.isNotEmpty,
        );
  }

  bool get _hasDecoration {
    return widget.placeholder != null ||
        widget.prefix != null ||
        widget.suffix != null;
  }

  TextAlignVertical get _textAlignVertical {
    return widget.textAlignVertical ?? TextAlignVertical.top;
  }

  Widget _addTextDependentAttachments(
    Widget editableText,
    TextStyle textStyle,
    TextStyle placeholderStyle,
  ) {
    if (!_hasDecoration) {
      return editableText;
    }

    return ValueListenableBuilder<TextEditingValue>(
      valueListenable: _effectiveController,
      child: editableText,
      builder: (BuildContext context, TextEditingValue text, Widget? child) {
        final result = Stack(children: <Widget>[
          if (widget.placeholder != null && text.text.isEmpty)
            Container(
              width: double.infinity,
              padding: widget.padding,
              child: Text(
                widget.placeholder!,
                maxLines: widget.maxLines,
                overflow: TextOverflow.ellipsis,
                style: placeholderStyle,
                textAlign: widget.textAlign,
              ),
            ),
          if (child != null) child,
        ]);
        // if (!_showPrefixWidget(text) && !_showSuffixWidget(text)) return result;
        return Row(children: <Widget>[
          if (_showPrefixWidget(text)) widget.prefix!,
          Expanded(child: result),
          if (_showSuffixWidget(text))
            Padding(
              padding: const EdgeInsets.all(4.0),
              child: widget.suffix!,
            ),
        ]);
      },
    );
  }

  static Color fluentComboBoxColor(bool isDark, bool focus) => isDark ? 
      focus ? const ColorConst.withOpacity(0x202020, 0.4) : const ColorConst.withOpacity(0x888888, 0.1) :
      focus ? const ColorConst.withOpacity(0xFFFFFF, 0.8) : const ColorConst.withOpacity(0xfafafa, 0.2);

  @override
  Widget build(BuildContext context) {
    super.build(context);
    assert(debugCheckHasDirectionality(context));
    assert(debugCheckHasFluentTheme(context));
    final ThemeData theme = FluentTheme.of(context);
    final TextEditingController controller = _effectiveController;
    final List<TextInputFormatter> formatters =
        widget.inputFormatters ?? <TextInputFormatter>[];
    const Offset cursorOffset = Offset(0, -1);
    if (widget.maxLength != null && widget.maxLengthEnforced) {
      formatters.add(LengthLimitingTextInputFormatter(widget.maxLength));
    }

    final TextStyle textStyle = TextStyle(
      color: enabled ? theme.inactiveColor : theme.disabledColor,
    );

    final Brightness keyboardAppearance =
        widget.keyboardAppearance ?? theme.brightness;
    final Color cursorColor = theme.inactiveColor;
    final Color disabledColor = theme.disabledColor;
    final Color backgroundColor = fluentComboBoxColor(theme.brightness.isDark, _effectiveFocusNode.hasFocus);

    final TextStyle placeholderStyle = widget.placeholderStyle ??
        textStyle.copyWith(
          color: !enabled
              ? theme.brightness.isLight
                  ? const Color.fromRGBO(0, 0, 0, 0.3614)
                  : const Color.fromRGBO(255, 255, 255, 0.3628)
              : theme.brightness.isLight
                  ? const Color.fromRGBO(0, 0, 0, 0.6063)
                  : const Color.fromRGBO(255, 255, 255, 0.786),
          fontWeight: FontWeight.w400,
        );

    final Color selectionColor = theme.accentColor.withOpacity(0.2);

    final Widget paddedEditable = Padding(
      padding: widget.padding,
      child: RepaintBoundary(
        child: UnmanagedRestorationScope(
          bucket: bucket,
          child: EditableText(
            key: editableTextKey,
            controller: controller,
            readOnly: widget.readOnly,
            toolbarOptions: widget.toolbarOptions,
            showCursor: widget.showCursor,
            showSelectionHandles: _showSelectionHandles,
            focusNode: _effectiveFocusNode,
            keyboardType: widget.keyboardType,
            textInputAction: widget.textInputAction,
            textCapitalization: widget.textCapitalization,
            style: textStyle,
            strutStyle: widget.strutStyle,
            textAlign: widget.textAlign,
            autofocus: widget.autofocus,
            obscuringCharacter: widget.obscuringCharacter,
            obscureText: widget.obscureText,
            autocorrect: widget.autocorrect,
            smartDashesType: widget.smartDashesType,
            smartQuotesType: widget.smartQuotesType,
            enableSuggestions: widget.enableSuggestions,
            maxLines: widget.maxLines,
            minLines: widget.minLines,
            expands: widget.expands,
            selectionColor: selectionColor,
            onChanged: widget.onChanged,
            onSelectionChanged: _handleSelectionChanged,
            onEditingComplete: widget.onEditingComplete,
            onSubmitted: widget.onSubmitted,
            inputFormatters: formatters,
            rendererIgnoresPointer: true,
            cursorWidth: widget.cursorWidth,
            cursorHeight: widget.cursorHeight,
            cursorRadius: widget.cursorRadius,
            cursorColor: cursorColor,
            cursorOpacityAnimates: true,
            cursorOffset: cursorOffset,
            paintCursorAboveText: false,
            autocorrectionTextRectColor: selectionColor,
            backgroundCursorColor: disabledColor,
            selectionHeightStyle: widget.selectionHeightStyle,
            selectionWidthStyle: widget.selectionWidthStyle,
            scrollPadding: widget.scrollPadding,
            keyboardAppearance: keyboardAppearance,
            dragStartBehavior: widget.dragStartBehavior,
            scrollController: widget.scrollController,
            scrollPhysics: widget.scrollPhysics,
            enableInteractiveSelection: widget.enableInteractiveSelection,
            autofillHints: widget.autofillHints,
            restorationId: 'editable',
            selectionControls: fluentTextSelectionControls,
          ),
        ),
      ),
    );

    final radius = BorderRadius.circular(4.0);
    final child = Semantics(
      enabled: enabled,
      onTap: !enabled
          ? null
          : () {
              if (!controller.selection.isValid) {
                controller.selection =
                    TextSelection.collapsed(offset: controller.text.length);
              }
              _requestKeyboard();
            },
      child: IgnorePointer(
        ignoring: !enabled,
        child: AnimatedContainer(
          duration: theme.fasterAnimationDuration,
          curve: theme.animationCurve,
          decoration: BoxDecoration(
            borderRadius: radius,
            border: Border.all(
                width: 1,
                color: theme.brightness.isLight
                    ? const Color.fromRGBO(0, 0, 0, 0.08)
                    : const Color.fromRGBO(255, 255, 255, 0.07)),
            color: enabled
                ? backgroundColor
                : theme.brightness.isLight
                    ? const Color.fromRGBO(249, 249, 249, 0.3)
                    : const Color.fromRGBO(255, 255, 255, 0.04),
          ),
          foregroundDecoration: BoxDecoration(
            border: Border(
              bottom: BorderSide(
                color: _effectiveFocusNode.hasFocus
                    ? theme.accentColor
                    : !enabled
                        ? Colors.transparent
                        : theme.brightness.isLight
                            ? const Color.fromRGBO(0, 0, 0, 0.45)
                            : const Color.fromRGBO(255, 255, 255, 0.54),
                width: _effectiveFocusNode.hasFocus ? 2 : 0,
              ),
            ),
          ),
          constraints: BoxConstraints(minHeight: widget.minHeight ?? 0),
          child: _selectionGestureDetectorBuilder.buildGestureDetector(
            behavior: HitTestBehavior.translucent,
            child: Align(
              alignment: AlignmentDirectional(-1.0, _textAlignVertical.y),
              widthFactor: 1.0,
              heightFactor: 1.0,
              child: _addTextDependentAttachments(
                paddedEditable,
                textStyle,
                placeholderStyle,
              ),
            ),
          ),
        ),
      ),
    );

    Widget listener = ValueListenableBuilder<TextEditingValue>(
      valueListenable: _effectiveController,
      child: () {
        /// This has to be done this way because [ClipRRect] doesn't allow
        /// [Clip.none] as a value to [clipBehavior]
        if (widget.clipBehavior == Clip.none) return child;
        return ClipRRect(
          clipBehavior: widget.clipBehavior,
          borderRadius: radius,
          child: child,
        );
      }(),
      builder: (context, text, child) {
        if (!_showOutsidePrefixWidget(text) &&
            !_showOutsideSuffixWidget(text)) {
          return child!;
        }
        return Row(children: [
          if (_showOutsidePrefixWidget(text)) widget.outsidePrefix!,
          Expanded(child: child!),
          if (_showOutsideSuffixWidget(text)) widget.outsideSuffix!,
        ]);
      },
    );

    return ButtonTheme.merge(
      data: widget.iconButtonThemeData ?? const ButtonThemeData(),
      child: IconTheme.merge(
        data: const IconThemeData(size: 14),
        child: SmallIconButton(
          child: () {
            if (widget.header != null) {
              return InfoLabel(
                child: listener,
                label: widget.header!,
                labelStyle: widget.headerStyle,
              );
            }
            return listener;
          }(),
        ),
      ),
    );
  }
}
```

`lib/widget/move_window_nomax.dart`:

```dart
// ignore_for_file: camel_case_types

import 'package:bitsdojo_window/bitsdojo_window.dart';
import 'package:flutter/widgets.dart';

///The double click gesture detector adds a time overhead on any widget's click actions, this class only implements window dragging
class _MoveWindowNoMaximize extends StatelessWidget {
  final bool dragBlocker;
  final Widget child;
  const _MoveWindowNoMaximize(this.dragBlocker, {Key? key, required this.child}) : super(key: key);
  @override
  Widget build(BuildContext context) => GestureDetector(
    child: child,
    behavior: dragBlocker ? HitTestBehavior.opaque : HitTestBehavior.translucent, 
    onPanStart: dragBlocker ? (_){} : (_){appWindow.startDragging();}
  );
}

class moveWindow extends _MoveWindowNoMaximize {
  ///Makes the window draggable on dragging the child view
  const moveWindow(Widget child, {Key? key}) : super(false, child: child, key: key);
}

class noMoveWindow extends _MoveWindowNoMaximize {
  ///Creates a non-draggable zone inside a draggable window
  const noMoveWindow(Widget child, {Key? key}) : super(true, child: child, key: key);
}

```

`lib/widget/themed_pane_item.dart`:

```dart
import 'dart:ui' as ui;
import 'package:fluent_ui/fluent_ui.dart';
import '../utils/misc_utils.dart';

const double _kCompactNavigationPanelWidth = 50.0;

class ThemablePaneItem extends PaneItem {

  final MouseCursor? mouseCursor;
  final PaneDisplayMode? forceDisplayMode;
  final bool translucent;
  final bool topHoverEffect;

  /// Creates a pane item.
  ThemablePaneItem({
    required Widget icon,
    Widget? title,
    InfoBadge? infoBadge,
    FocusNode? focusNode,
    this.forceDisplayMode,
    bool autofocus = false,
    this.mouseCursor,
    this.topHoverEffect = true,
    this.translucent = false
  }) : super(icon: icon, title: title, infoBadge: infoBadge, focusNode: focusNode, autofocus: autofocus, mouseCursor: mouseCursor);

  static Color uncheckedInputAlphaColor(ThemeData style, Set<ButtonStates> states) {
    // The opacity is 0 because, when transitioning between [Colors.transparent]
    // and the actual color gives a weird effect
    if (style.brightness == Brightness.light) {
      if (states.isDisabled) return style.disabledColor;
      if (states.isPressing) return const Color(0xFF221D08).withOpacity(0.255);
      if (states.isHovering) return const Color(0xFF221D08).withOpacity(0.075);
      return Colors.transparent;
    } else {
      if (states.isDisabled) return style.disabledColor;
      if (states.isPressing) return const Color(0xFFFFF3E8).withOpacity(0.285);
      if (states.isHovering) return const Color(0xFFFFF3E8).withOpacity(0.12);
      return Colors.transparent;
    }
  }
  
  @override
  Widget build(
    BuildContext context,
    bool selected,
    VoidCallback? onPressed, {
    PaneDisplayMode? displayMode,
    bool showTextOnTop = true,
    bool? autofocus,
  }) {
    final PaneDisplayMode mode = forceDisplayMode ?? displayMode ??
        //_NavigationBody.maybeOf(context)?.displayMode ??
        PaneDisplayMode.minimal;
    assert(displayMode != PaneDisplayMode.auto);
    final bool isTop = mode == PaneDisplayMode.top;
    final bool isCompact = mode == PaneDisplayMode.compact;
    final bool isOpen =
        [PaneDisplayMode.open, PaneDisplayMode.minimal].contains(mode);
    final NavigationPaneThemeData theme = NavigationPaneTheme.of(context);

    final String titleText =
        title != null && title is Text ? (title! as Text).data ?? '' : '';

    return Container(
      key: itemKey,
      height: !isTop ? 36.0 : null,
      width: isCompact ? _kCompactNavigationPanelWidth : null,
      margin: const EdgeInsets.only(right: 6.0, left: 6.0, bottom: 4.0),
      alignment: Alignment.center,
      child: HoverButton(
        autofocus: autofocus ?? this.autofocus,
        focusNode: focusNode,
        onPressed: onPressed,
        cursor: mouseCursor,
        builder: (context, states) {
          final isLtr = Directionality.of(context) == TextDirection.ltr;
          final textStyle = selected
              ? theme.selectedTextStyle?.resolve(states)
              : theme.unselectedTextStyle?.resolve(states);
          final textResult = titleText.isNotEmpty
              ? Padding(
                  padding: theme.labelPadding?.directional() ?? EdgeInsets.zero,
                  child: Text(titleText, style: textStyle),
                )
              : const SizedBox.shrink();
          
          final icon = Padding(
            padding: theme.iconPadding?.directional() ?? EdgeInsets.zero,
            child: IconTheme.merge(
              data: IconThemeData(
                color: (selected ? theme.selectedIconColor?.resolve(states) : theme.unselectedIconColor?.resolve(states)) ?? textStyle?.color,
                size: 16.0,
              ),
              child: Center(
                child: Stack(clipBehavior: Clip.none, children: [
                  this.icon,
                  // Show here if it's not on top and not open
                  if (infoBadge != null && !isTop && !isOpen) Positioned(right: -8, top: -8, child: infoBadge!),
                ]),
              ),
            ),
          );
          
          Widget child = Flex(
            direction: isTop ? Axis.vertical : Axis.horizontal,
            textDirection: isTop ? ui.TextDirection.ltr : ui.TextDirection.rtl,
            mainAxisAlignment: isTop || !isOpen
                ? MainAxisAlignment.center
                : MainAxisAlignment.end,
            children: [
              if (isOpen && infoBadge != null) Padding(
                padding: const EdgeInsetsDirectional.only(end: 6.0),
                child: infoBadge!,
              ),
              if (!isLtr) icon,
              if (isOpen) Expanded(child: textResult),
              if (isLtr) icon,
            ],
          );
          if (isTop && showTextOnTop) {
            child = Row(mainAxisSize: MainAxisSize.min, children: [
              child,
              textResult,
            ]);
          }
          if (isTop && infoBadge != null) {
            child = Stack(children: [
              child,
              Positioned(
                top: 0,
                right: 0,
                child: infoBadge!,
              ),
            ]);
          }
          child = AnimatedContainer(
            duration: theme.animationDuration ?? Duration.zero,
            curve: theme.animationCurve ?? standartCurve,
            decoration: BoxDecoration(
              color: () {
                final ButtonState<Color?> tileColor = theme.tileColor ??
                    ButtonState.resolveWith((states) {
                      if (isTop && !topHoverEffect) return Colors.transparent;
                      return translucent ? uncheckedInputAlphaColor(FluentTheme.of(context), states) :
                        ButtonThemeData.uncheckedInputColor(FluentTheme.of(context), states);
                    });
                final newStates = states.toSet()..remove(ButtonStates.disabled);
                return tileColor.resolve(
                  (selected && !isTop) ? {ButtonStates.hovering} : newStates,
                );
              }(),
              borderRadius: BorderRadius.circular(4.0),
            ),
            child: child,
          );
          child = Semantics(
            label: title == null ? null : titleText,
            selected: selected,
            child: FocusBorder(
              child: child,
              focused: states.isFocused,
              renderOutside: false,
            ),
          );
          if (((isTop && !showTextOnTop) || isCompact) &&
              titleText.isNotEmpty &&
              !states.isDisabled) {
            return Tooltip(
              message: titleText,
              style: TooltipThemeData(
                textStyle: title is Text ? (title as Text).style : null,
              ),
              child: child,
            );
          }
          return child;
        },
      ),
    );
  }
}
```

`lib/windows/nt_io.dart`:

```dart
// ignore_for_file: camel_case_types, constant_identifier_names, non_constant_identifier_names, curly_braces_in_flow_control_structures

import 'dart:developer';
import 'dart:ffi';
import 'dart:io';
import 'dart:typed_data';
import '../utils/misc_utils.dart';
import 'package:wsa_pacman/windows/win_path.dart';

import 'win_io.dart';
import 'package:ffi/ffi.dart';
import 'package:win32/win32.dart';
import 'package:path/path.dart' as lib_path;

final ntdll = DynamicLibrary.open('ntdll.dll');
final advapi32 = DynamicLibrary.open('advapi32.dll');
const _ANYSYZE_ARRAY = 1;

class UNICODE_STRING extends Struct {
  @USHORT() external int length;
  @USHORT() external int maximumLength;
  external LPWSTR buffer;
  void free() => calloc.free(buffer);
}

class OBJECT_ATTRIBUTES extends Struct {
  @ULONG() external int length;
  @HANDLE() external int rootDirectory;
  external Pointer<UNICODE_STRING> objectName;
  @ULONG() external int attributes;
  external Pointer securityDescriptor;
  external Pointer securityQualityOfService;
}

class REPARSE_MOUNTPOINT_DATA_BUFFER extends Struct {
  @DWORD() external int reparseTag;
  @DWORD() external int reparseDataLength;
  @WORD() external int reserved;
  @WORD() external int reparseTargetLength;
  @WORD() external int reparseTargetMaximumLength;
  @WORD() external int reserved1;
  @Array(_ANYSYZE_ARRAY) external Array<WCHAR> reparseTarget;
}

class _TOKEN_PRIVILEGES extends Struct {
  @DWORD() external int privilegeCount;
  @Array(_ANYSYZE_ARRAY) external Array<_LUID_AND_ATTRIBUTES> privileges;
}

class _LUID_AND_ATTRIBUTES extends Struct {
  external LUID luid;
  @DWORD() external int attributes;
}

final _NtCreateSymbolicLinkObject = ntdll.lookupFunction<
      Uint32 Function(Pointer<IntPtr> linkHandle, Uint32 desiredAccess, Pointer<OBJECT_ATTRIBUTES> objectAttributes, Pointer<UNICODE_STRING> linkTarget),
      int Function(Pointer<IntPtr> linkHandle, int desiredAccess, Pointer<OBJECT_ATTRIBUTES> objectAttributes, Pointer<UNICODE_STRING> linkTarget)>('NtCreateSymbolicLinkObject');
final _NtStatusToDosError = ntdll.lookupFunction<Uint32 Function(Int32 status), int Function(int status)>('RtlNtStatusToDosError');
final _CreateDirectoryObject = ntdll.lookupFunction<
    Uint32 Function(Pointer<IntPtr> lpHandle, Uint32 desiredAccess, Pointer<OBJECT_ATTRIBUTES> obj_attr, HANDLE shadowDirectoryHandle, Uint32 flags), 
    int Function(Pointer<IntPtr> lpHandle, int desiredAccess, Pointer<OBJECT_ATTRIBUTES> obj_attr, int shadowDirectoryHandle, int flags)>('NtCreateDirectoryObjectEx');

/*final _DefineDosDevice = kernel32.lookupFunction<
    Uint32 Function(Uint32 dwFlags, Pointer<Utf16> lpDeviceName, Pointer<Utf16> lpTargetPath),
    int Function(int dwFlags, Pointer<Utf16> lpDeviceName, Pointer<Utf16> lpTargetPath)>('DefineDosDeviceW');*/

final _LookupPrivilegeValue = advapi32.lookupFunction<
    Uint32 Function(LPWSTR lpSystemName, LPWSTR lpName, Pointer<LUID> lpLuid),
    int Function(LPWSTR lpSystemName, LPWSTR lpName, Pointer<LUID> lpLuid)>('LookupPrivilegeValueW');
final _AdjustTokenPrivileges = advapi32.lookupFunction<
    Uint32 Function(HANDLE tokenHandle, BOOL disableAllPrivileges, Pointer<_TOKEN_PRIVILEGES> newState, DWORD bufferLength, Pointer<_TOKEN_PRIVILEGES> previousState, Pointer<DWORD> returnLength),
    int Function(int tokenHandle, int disableAllPrivileges, Pointer<_TOKEN_PRIVILEGES> newState, int bufferLength, Pointer<_TOKEN_PRIVILEGES> previousState, Pointer<DWORD> returnLength)>('AdjustTokenPrivileges');

extension on LPWSTR {
  Pointer<UNICODE_STRING> toUnicodeString([int? knownLength]) {
    final lpUnicodeString = malloc<UNICODE_STRING>();
    final unicodeString = lpUnicodeString.ref;
    unicodeString.buffer = this;
    unicodeString.length = (knownLength ?? length) * 2; // Expressed in bytes
    unicodeString.maximumLength = unicodeString.length + 2;
    return lpUnicodeString;
  }
}

extension WinDir on Directory {
  int? toNativeDir() {
    final lpPath = absolute.path.toNativeUtf16();
    HANDLE hToken;

    try {
      final handle = CreateFile(lpPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 
          nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
      return handle != INVALID_HANDLE_VALUE ? handle : null;
    }
    finally {
      free(lpPath);
    }
  }
}

extension on String {
  static const _IO_REPARSE_TAG_MOUNT_POINT = 0xA0000003;
  
  Pointer<UNICODE_STRING> toUnicodeString({Allocator allocator = malloc}) {
    final units = codeUnits;
    final Pointer<Uint16> result = allocator<Uint16>(units.length + 1);
    final Uint16List nativeString = result.asTypedList(units.length + 1);
    nativeString.setRange(0, units.length, units);
    nativeString[units.length] = 0;
    return result.cast<Utf16>().toUnicodeString(units.length);
  }
  
  Pointer<REPARSE_MOUNTPOINT_DATA_BUFFER> toReparseMountpoint() {
    final rTargetUnits = codeUnits;
    final lpReparseBuffer = calloc.allocate<REPARSE_MOUNTPOINT_DATA_BUFFER>(sizeOf<REPARSE_MOUNTPOINT_DATA_BUFFER>() + (rTargetUnits.length + 1) * sizeOf<WCHAR>());
    final reparseBuffer = lpReparseBuffer.ref;

    final Pointer<Uint16> lpTarget = lpReparseBuffer.cast<BYTE>().elementAt(2 * sizeOf<DWORD>() + 4 * sizeOf<WORD>()).cast<Uint16>();
    final Uint16List nativeString = lpTarget.asTypedList(rTargetUnits.length + 1);
    nativeString.setRange(0, rTargetUnits.length, rTargetUnits);
    nativeString[rTargetUnits.length] = 0;
    
    reparseBuffer.reparseTag = _IO_REPARSE_TAG_MOUNT_POINT;
    reparseBuffer.reparseTargetMaximumLength = (rTargetUnits.length + 1) * sizeOf<WCHAR>();
    reparseBuffer.reparseTargetLength = rTargetUnits.length * sizeOf<WCHAR>();
    reparseBuffer.reparseDataLength = reparseBuffer.reparseTargetLength + 12;
    return lpReparseBuffer;
  }
}

extension DOSUnicodeStringPtrUtils on Pointer<UNICODE_STRING> {
  void free() {
    ref.free();
    calloc.free(this);
  }
}

class NtIO {
  static const _REPARSE_MOUNTPOINT_HEADER_SIZE = 8;

  static const DDD_NO_BROADCAST_SYSTEM = 0x00000008;
  static const DDD_RAW_TARGET_PATH = 0x00000001;
  static const DDD_REMOVE_DEFINITION = 0x00000002;
  static const DIRECTORY_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | 0xF;
  static const OBJ_CASE_INSENSITIVE = 0x00000040;
  static const SYMBOLIC_LINK_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | 0x1;

  static late final NT_TEMP_DIR_NAME = Directory(WinPath.tempSubdir).createTempSync("WSA-PacMan-DOS@$pid@").basename;
  static late final String? _DOS_DIRECTORY = (){
    String dirName = "\\BaseNamedObjects\\$NT_TEMP_DIR_NAME";
    return createNativeDirectory(dirName) != null ? dirName : null;
  }();
  
  static const _SE_PRIVILEGE_ENABLED = 0x00000002;
  static late final _SE_RESTORE_NAME = TEXT("SeRestorePrivilege");
  static late final _SE_BACKUP_NAME = TEXT("SeBackupPrivilege");

  static late final int? _NT_JUNCTION_HANDLE = (_DOS_DIRECTORY != null) ? createJunction(_DOS_DIRECTORY!, "${WinPath.tempSubdir}\\$NT_TEMP_DIR_NAME", true) : null;

  /// Creates a temporary shortcut inside the object manager and links it inside %TEMP%
  /// Returns the relative path starting from WinPath.tempSubdir to access it
  static String? createTempShortcut(String target, String shortcutName) {
    String? directory = _DOS_DIRECTORY;
    if (directory != null) {
      NtIO.createNativeSymlink(0, "\\??\\$target", "$_DOS_DIRECTORY\\$shortcutName");
      _NT_JUNCTION_HANDLE;
      return "$NT_TEMP_DIR_NAME\\$shortcutName";
    }
  }

  /// Deletes the junction to the NT directory
  static void deleteNtTempDirJunction() => (_NT_JUNCTION_HANDLE != null) ? CloseHandle(_NT_JUNCTION_HANDLE!) != 0 : false;
  

  /// Opens a directory, returns its handle
  static int? openDirectory(String path, bool bReadWrite, [bool deleteOnClose = false]) {
    final lpToken = malloc<HANDLE>();
    final pszPath = path.toNativeUtf16();
    final lpTp = malloc<_TOKEN_PRIVILEGES>();
    final tp = lpTp.ref;
    
    try {
      OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, lpToken);
      _LookupPrivilegeValue(nullptr, bReadWrite ? _SE_RESTORE_NAME : _SE_BACKUP_NAME, lpTp.cast<DWORD>().elementAt(1).cast<LUID>());
      tp.privilegeCount = 1;
      tp.privileges[0].attributes = _SE_PRIVILEGE_ENABLED;
      final hToken = lpToken.value;
      _AdjustTokenPrivileges(hToken, FALSE, lpTp, sizeOf<_TOKEN_PRIVILEGES>(), nullptr, nullptr);
      CloseHandle(hToken);

      // Open the directory
      int dwAccess = bReadWrite ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ;
      int hDir = CreateFile(pszPath, dwAccess, 0, nullptr, OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS | (deleteOnClose ? FILE_FLAG_DELETE_ON_CLOSE : 0), 0);
      return hDir != INVALID_HANDLE_VALUE ? hDir : null;
    }
    finally {
      free(lpToken);
      free(pszPath);
      free(lpTp);
    }
  }

  /// Creates a junction of the target directory using the symlink directory and returns the handle
  /// The symlink directory must be empty
  /// TODO parse targetDir and append "\??\" if necessary?
  static int? createJunction(String targetDir, String symlinkDir, [bool deleteOnClose = true]) {
    final lpReparseBuffer = targetDir.toReparseMountpoint();
    int? dirHandle = openDirectory(symlinkDir, true, deleteOnClose);
    final lpBytesReturned = malloc<Uint32>();
    try {
      int result = dirHandle != null ? DeviceIoControl(dirHandle, FSCTL_SET_REPARSE_POINT, lpReparseBuffer,
            lpReparseBuffer.ref.reparseDataLength + _REPARSE_MOUNTPOINT_HEADER_SIZE, nullptr, 0, lpBytesReturned, nullptr) : 0;
      if (result == 0) log("\x1B[91mJunction point creation failed: ${getMessageDOS(GetLastError())}");
      if (result == 0 && dirHandle != null && deleteOnClose) CloseHandle(dirHandle);
      return result != 0 ? dirHandle : null;
    }
    finally {
      free(lpReparseBuffer);
      free(lpBytesReturned);
      //if (dirHandle != null) CloseHandle(dirHandle);
    }
  }

  /// Like createJunction, but returns a boolean (created) and is always permanent
  static bool createJunctionPerm(String targetDir, String symlinkDir) {
    int? handle = createJunction(targetDir, symlinkDir, false);
    if (handle != null) CloseHandle(handle);
    return handle != null;
  }

  static Pointer<OBJECT_ATTRIBUTES> _InitializeObjectAttributes(Pointer<UNICODE_STRING> name, int flags, int rootDirHandle, Pointer<SECURITY_DESCRIPTOR> securityDescriptor) {
    final lpAttributes = malloc<OBJECT_ATTRIBUTES>();
    final attributes = lpAttributes.ref;
    attributes.length = sizeOf<OBJECT_ATTRIBUTES>();
    attributes.objectName = name;
    attributes.attributes = flags;
    attributes.rootDirectory = rootDirHandle;
    attributes.securityDescriptor = securityDescriptor;
    attributes.securityQualityOfService = nullptr;
    return lpAttributes;
  }

  /*static void defineDosDevice() {
    log("DIRNAME: \\${NT_TEMP_DIR_NAME}");
    log("${_CreateDirectoryObject}");
    final lpTargetPath = "Global\\GLOBALROOT\\$NT_TEMP_DIR_NAME".toNativeUtf16();
    final lpDeviceName = r"C:\Users\Alex\Downloads\lolktestk".toNativeUtf16();
    int dosDevice = _DefineDosDevice(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH, lpDeviceName, lpTargetPath);
    log("DOS_CREATE: ${dosDevice}");
  }*/

  /// Converts NT status code to an error message
  static String getMessageNt(int code) => getMessageDOS(_NtStatusToDosError(code));
  /// Converts DOS code to an error message
  static String getMessageDOS(int code) {
    const _FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100;
    const LANGID_EN = 0x0409;
    final lpLpBuffer = calloc<Pointer<Utf16>>();
    try {
      int result = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ARGUMENT_ARRAY | _FORMAT_MESSAGE_ALLOCATE_BUFFER, nullptr, code, LANGID_EN, lpLpBuffer.cast(), 1024, nullptr);
      return result != ERROR_MORE_DATA ? result != 0 ? lpLpBuffer.value.toDartString().replaceFirst(RegExp(r'\.?[\n\s]*$'), '') : "Unknown error" : "Error message too long";
    }
    finally {
      free(lpLpBuffer.value);
      free(lpLpBuffer);
    }
  }

  /// Creates a directory inside the object manager
  static int? createNativeDirectory(String nativePath) {
    final objectName = nativePath.toUnicodeString();
    final objAttrs = _InitializeObjectAttributes(objectName, OBJ_CASE_INSENSITIVE, 0, nullptr);
    final lpHandle = calloc<IntPtr>();
    try {
      int result = _CreateDirectoryObject(lpHandle, DIRECTORY_ALL_ACCESS, objAttrs, 0, 0);
      if (result != 0) log("\x1B[91mNative directory cration failed: ${getMessageNt(result)}", level: 1000);
      else return lpHandle.value;
    }
    finally {
      objectName.free();
      free(objAttrs);
      free(lpHandle);
    }
  }

  /// Creates a shortcut inside the object manager
  static int? createNativeSymlink(int rootDirHandle, String target, String symlink) {
    final lpTarget = target.toUnicodeString();
    final lpSymlink = symlink.toUnicodeString();
    final attributes = _InitializeObjectAttributes(lpSymlink, OBJ_CASE_INSENSITIVE, rootDirHandle, nullptr);
    final lpHandle = calloc<IntPtr>();
    try {
      int result = _NtCreateSymbolicLinkObject(lpHandle, SYMBOLIC_LINK_ALL_ACCESS, attributes, lpTarget);
      if (result != 0) log("\x1B[91mNative symlink creation failed: ${getMessageNt(result)}", level: 1000);
      else return lpHandle.value;
    }
    finally {
      lpTarget.free();
      lpSymlink.free();
      free(attributes);
      free(lpHandle);
    }
  }
}
```

`lib/windows/win_info.dart`:

```dart
// ignore_for_file: non_constant_identifier_names

import 'dart:ffi';

import 'package:ffi/ffi.dart';
import 'package:win32/win32.dart';
import 'package:wsa_pacman/windows/win_wmi.dart';

bool testFlag(int value, int attribute) => value & attribute == attribute;

/// Represents the version number (e.g. 10.0)
class WinVer {
  int major;
  int minor;
  WinVer._(this.major, this.minor);

  static late final String WIN_CAPTION = WinWMI.queryString('Caption', 'Win32_OperatingSystem') ?? '';

  @override String toString() => '$major.$minor';

  static late final WinVer version = (){
    final versionInfo = calloc<OSVERSIONINFO>();
    versionInfo.ref.dwOSVersionInfoSize = sizeOf<OSVERSIONINFO>();

    try {
      final result = GetVersionEx(versionInfo);
      return (result != 0) ? WinVer._(versionInfo.ref.dwMajorVersion, versionInfo.ref.dwMinorVersion) : WinVer._(0, 0);
    } finally {free(versionInfo);}
  }();

  static bool isAtLeast(int major, int minor) => version.major > major || version.major == major && version.minor >= minor;

  static late final bool isWindowsXPOrGreater = isAtLeast(5, 1);
  static late final bool isWindowsVistaOrGreater = isAtLeast(6, 0);
  static late final bool isWindows7OrGreater = isAtLeast(6, 1);
  static late final bool isWindows8OrGreater = isAtLeast(6, 2);
  static late final bool isWindows10OrGreater = isAtLeast(10, 0);
  static late final bool isWindows11OrGreater = isAtLeast(10, 1) || 
      (isAtLeast(10, 0) && !WIN_CAPTION.contains(RegExp(r'(^|\s)(Windows 10x?|Server 2016)($|\s)', caseSensitive: false)) );
}
```

`lib/windows/win_io.dart`:

```dart
// ignore_for_file: non_constant_identifier_names, curly_braces_in_flow_control_structures, constant_identifier_names

import 'dart:ffi';
import 'dart:io';
import 'package:ffi/ffi.dart';
import 'package:win32/win32.dart';
import 'package:path/path.dart' as lib_path;

final kernel32 = DynamicLibrary.open('kernel32.dll');
final _CreateMutex = kernel32.lookupFunction<
      IntPtr Function(Pointer<SECURITY_ATTRIBUTES> lpMutexAttributes, Pointer<Utf16> lpName, Uint32 dwFlags, Uint32 dwDesiredAccess),
      int Function(Pointer<SECURITY_ATTRIBUTES> lpMutexAttributes, Pointer<Utf16> lpName, int dwFlags, int dwDesiredAccess)>('CreateMutexExW');
final _OpenMutex = kernel32.lookupFunction<
      IntPtr Function(Uint32 dwDesiredAccess, Int32 bInheritHandle, Pointer<Utf16> lpName),
      int Function(int dwDesiredAccess, int bInheritHandle, Pointer<Utf16> lpName)>('OpenMutexW');
final _WaitForSingleObjectEx = kernel32.lookupFunction<
      Uint32 Function(Uint32 hHandle, Uint32 dwMilliseconds, Int32 bAlertable),
      int Function(int hHandle, int dwMilliseconds, int bAlertable)>('WaitForSingleObjectEx');
final _ReleaseMutex = kernel32.lookupFunction<
      Int32 Function(Uint32 hHandle),
      int Function(int hHandle)>('ReleaseMutex');
final _GetShortPathName = kernel32.lookupFunction<
      Uint32 Function(Pointer<Utf16> lpszLongPath, Pointer<Utf16> lpszShortPath, Uint32 cchBuffer),
      int Function(Pointer<Utf16> lpszLongPath, Pointer<Utf16> lpszShortPath, int cchBuffer)>('GetShortPathNameW');
final _SetFileInformationByHandle = kernel32.lookupFunction<
      Uint32 Function(Uint32 hFile, Uint32 fileInformationClass,Pointer lpFileInformation, DWORD dwBufferSize),
      int Function(int hFile, int fileInformationClass, Pointer lpFileInformation, int dwBufferSize)>('SetFileInformationByHandle');

enum _FILE_INFO_BY_HANDLE_CLASS {
  FileBasicInfo, FileStandardInfo, FileNameInfo, FileRenameInfo, FileDispositionInfo, FileAllocationInfo,
  FileEndOfFileInfo, FileStreamInfo, FileCompressionInfo, FileAttributeTagInfo, FileIdBothDirectoryInfo,
  FileIdBothDirectoryRestartInfo, FileIoPriorityHintInfo, FileRemoteProtocolInfo, FileFullDirectoryInfo,
  FileFullDirectoryRestartInfo, FileStorageInfo, FileAlignmentInfo, FileIdInfo, FileIdExtdDirectoryInfo,
  FileIdExtdDirectoryRestartInfo, FileDispositionInfoEx, FileRenameInfoEx, FileCaseSensitiveInfo,
  FileNormalizedNameInfo, MaximumFileInfoByHandleClass
}

class RegistryKeyValuePair {
  final String key;
  final String value;

  const RegistryKeyValuePair(this.key, this.value);
}

/// Locks files and marks them for deletion
/// The files will be deleted if the application is closed or by calling dispose()
/// The files cannot be opened unless unflagged by calling clear()
class FileDisposeQueue {
  final _handles = <int>{};

  /// Adds a file to the deletion queue
  /// File will be locked
  bool add(File file) {
    int? handle = _lockFile(file);
    if (handle != null) _handles.add(handle);
    return handle != null;
  }

  /// Unlock all, remove delete flag and clear collection
  /// Returns true if all files are cleared successfully, false otherwise
  bool clear() {
    final failed = <int>[];
    for (int handle in _handles) {
      if (_setLock(handle, false)) CloseHandle(handle);
      else failed.add(handle);
    }
    failed.isEmpty ? _handles.clear() : _handles.retainAll(failed);
    return failed.isEmpty;
  }

  /// Dispose of all files immediately and clear collection
  void dispose() {
    for (int handle in _handles) CloseHandle(handle);
    _handles.clear();
  }

  bool _setLock(int handle, bool lock) {
    Pointer<BOOL> lpBool = malloc<BOOL>()..value = lock ? TRUE : FALSE;
    try {
      int res1 = _SetFileInformationByHandle(handle, _FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfo.index, lpBool, sizeOf<BOOL>());
      int res2 = _SetFileInformationByHandle(handle, _FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfoEx.index, lpBool, sizeOf<BOOL>());
      return res1 != 0 || res2 != 0;
    }
    finally {
      free(lpBool);
    }
  }

  int? _lockFile(File file) {
    final lpToken = malloc<HANDLE>();
    final pszPath = file.absolute.path.toNativeUtf16();
    
    try {
      int handle = CreateFile(pszPath, DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, nullptr, 
          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
      bool locked = _setLock(handle, true);
      if (!locked) CloseHandle(handle);
      return handle != INVALID_HANDLE_VALUE && locked ? handle : null;
    }
    finally {
      free(lpToken);
      free(pszPath);
    }
  }
}

extension WinFile on File {
  static const int _EPOCH_NT_DELTA_MICROSECONDS = 11644473600100000;

  static String? getShortName(String path) {
    final lpFilePath = TEXT(path);
    LPWSTR? lpShortFilePath;
    try {
      int result = _GetShortPathName(lpFilePath, nullptr, 0);
      if (result == 0) return null;
      result = _GetShortPathName(lpFilePath, lpShortFilePath = malloc<WCHAR>(result).cast<Utf16>(), result);
      if (result == 0) return null;
      return lpShortFilePath.toDartString();
    }
    finally {
      free(lpFilePath);
      if (lpShortFilePath != null) free(lpShortFilePath);
    }
  }

  static String? getShortBaseName(String path) {
    String? shortName = getShortName(path);
    return (shortName != null) ? lib_path.basename(shortName) : null;
  }
  
  String? get shortName => getShortName(absolute.path);
  String? get shortBaseName => getShortBaseName(absolute.path);
  
  /// Converts Flutter file to native file handle;
  /// Must call [CloseHandle] to release it
  int? toNativeFile() {
    final lpPath = absolute.path.toNativeUtf16();
    try {
      final handle = CreateFile(lpPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 
          nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
      return handle != INVALID_HANDLE_VALUE ? handle : null;
    }
    finally {
      free(lpPath);
    }
  }

  /// Returns a more accurate modified date (microseconds precision as opposed to seconds)
  DateTime? lastModifiedAccurate() {
    int? handle = toNativeFile();
    if (handle != null) {
      final info = malloc<BY_HANDLE_FILE_INFORMATION>();
      try {
        int code = GetFileInformationByHandle(handle, info);
        if (code == 0) return null;
        FILETIME lastWrite = info.ref.ftLastWriteTime;
        int microseconds = (lastWrite.dwHighDateTime << 32 | lastWrite.dwLowDateTime) ~/ 10 - _EPOCH_NT_DELTA_MICROSECONDS;
        return DateTime.fromMicrosecondsSinceEpoch(microseconds);
      }
      finally {
        CloseHandle(handle);
        free(info);
      }
    }
  }
}

enum ShellOp {
  EDIT, EXPLORE, FIND, OPEN, PRINT, PROPERTIES, RUNAS
}

extension on ShellOp {
  LPWSTR getOperation() {switch (this) {
    case ShellOp.EDIT: return "edit".toNativeUtf16();
    case ShellOp.EXPLORE: return "explore".toNativeUtf16();
    case ShellOp.FIND: return "find".toNativeUtf16();
    case ShellOp.OPEN: return "open".toNativeUtf16();
    case ShellOp.PRINT: return "print".toNativeUtf16();
    case ShellOp.PROPERTIES: return "properties".toNativeUtf16();
    case ShellOp.RUNAS: return "runas".toNativeUtf16();
  }}
}

class WinIO {
  static bool run(ShellOp operation, String file, String? param) {
    if (file.isEmpty) return false;
    LPWSTR lpOperation = operation.getOperation();
    LPWSTR lpFile = file.toNativeUtf16();
    LPWSTR lpParameters = param != null && param.isNotEmpty ? param.toNativeUtf16() : nullptr;
    try {
      return ShellExecute(0, lpOperation, lpFile, lpParameters, nullptr, SW_HIDE) > 32;
    } 
    finally {
      free(lpOperation);
      free(lpFile);
      free(lpParameters);
    }
  }

  static bool findMutexWstr(LPWSTR lpMutexName) {
    int mutexHandle = _OpenMutex(0x00100000, 0, lpMutexName);
    if (mutexHandle != 0) {CloseHandle(mutexHandle); return true;}
    else return false;
  }

  static bool findMutex(String mutexName) {
    final lpMutexName = TEXT(mutexName);
    //int mutexHandle = _CreateMutex(nullptr, TEXT(r"{42CEB0DF-325A-4FBE-BBB6-C259A6C3F0BB}"), 0, 0x001F0001);
    try {return findMutexWstr(lpMutexName);}
    finally {free(lpMutexName);}
  }

  /// Creates a Windows shortcut (.lnk);
  static void createShortcut(String filePath, String linkPath, {String? description, String? args, String? icon}) {
    final shellLink = ShellLink.createInstance();
    final lpPath = filePath.toNativeUtf16();
    final lpArgs = args?.toNativeUtf16();
    final lpIcon = icon?.toNativeUtf16();
    final lpLinkPath = "$linkPath.lnk".toNativeUtf16();
    final lpDescription = description?.toNativeUtf16() ?? nullptr;
    final ptrIID_IPersistFile = convertToCLSID(IID_IPersistFile);
    final ppf = calloc<COMObject>();

    try {
      shellLink.SetPath(lpPath);
      if (lpArgs != null) shellLink.SetArguments(lpArgs);
      if (description != null) shellLink.SetDescription(lpDescription);
      if (lpIcon != null) shellLink.SetIconLocation(lpIcon, 0);

      final hr = shellLink.QueryInterface(ptrIID_IPersistFile, ppf.cast());
      if (SUCCEEDED(hr)) {
        final persistFile = IPersistFile(ppf);
        persistFile.Save(lpLinkPath, TRUE);
        persistFile.Release();
      }
      shellLink.Release();
    } finally {
      free(lpPath);
      if (lpArgs != null) free(lpArgs);
      if (lpIcon != null) free(lpIcon);
      free(lpLinkPath);
      if (lpDescription != nullptr) free(lpDescription);
      free(ptrIID_IPersistFile);
      free(ppf);
    }
  }
}
```

`lib/windows/win_path.dart`:

```dart
// Copyright (c) 2020, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Demonstrates usage of various shell APIs to retrieve known folder locations

import 'dart:ffi';
import 'dart:io';
import 'package:ffi/ffi.dart';
import 'package:win32/win32.dart';

class WinPath {
  /// Get the path of the temporary directory (typically %TEMP%)
  static late String temp = Directory.systemTemp.absolute.path;

  /// Sub-directory inside %TEMP% to use by the application
  static late String tempSubdir = Directory.systemTemp.createTempSync("WSA-PacMan-").absolute.path;

  /// Get the desktop path
  static late String desktop = (){
    final appsFolder = GUIDFromString(FOLDERID_Desktop);
    final ppszPath = calloc<PWSTR>();

    try {
      final hr =
          SHGetKnownFolderPath(appsFolder, KF_FLAG_DEFAULT, NULL, ppszPath);

      if (FAILED(hr)) {
        throw WindowsException(hr);
      }

      final path = ppszPath.value.toDartString();
      return path;
    } finally {
      free(appsFolder);
      free(ppszPath);
    }
  }();
}

```

`lib/windows/win_pkg.dart`:

```dart
// ignore_for_file: constant_identifier_names, non_constant_identifier_names

import 'dart:ffi';
import 'dart:io';
import 'dart:typed_data';
import 'package:base32/encodings.dart';
import 'package:charset/charset.dart';
import 'package:crypto/crypto.dart';

import 'package:base32/base32.dart';
import 'package:ffi/ffi.dart';
import 'package:win32/win32.dart';

import '../utils/string_utils.dart';


const _INITIAL_OUTPUT_BUFFER_CHARS = 256;

class WinPkg {
  static String getPublisherId(String publisher) {
    return base32.encode(Uint8List.fromList(sha256.convert((utf16.encoder as Utf16Encoder).encodeUtf16Le(publisher)).bytes.sublist(0, 8)), encoding: Encoding.crockford).toLowerCase();
  }

  static String? getPackageFamilyName(String fullName) {
    final lpName = fullName.toNativeUtf16();
    var lpFamilyName = malloc<WCHAR>(_INITIAL_OUTPUT_BUFFER_CHARS).cast<Utf16>();
    final lpBufferLenght = malloc<DWORD>()..value = _INITIAL_OUTPUT_BUFFER_CHARS;
    
    try {
      int exitCode = PackageFamilyNameFromFullName(lpName, lpBufferLenght, lpFamilyName);
      if (exitCode == ERROR_INSUFFICIENT_BUFFER) {
        free(lpFamilyName);
        lpFamilyName = malloc<WCHAR>(lpBufferLenght.value).cast<Utf16>();
        PackageFamilyNameFromFullName(lpName, lpBufferLenght, lpFamilyName);
      }
      return lpFamilyName.toDartString();
    }
    finally {
      free(lpName);
      free(lpFamilyName);
      free(lpBufferLenght);
    }
  }
}


class WinPkgInfo {
  late final String name;
  late final String publisherId;
  late final String version;
  late final String architecture;

  String get fullName => "${name}_${version}_${architecture}__$publisherId"; 
  String get familyName => "${name}_$publisherId";
  void parseManifestExtras(String manifest) {}

  WinPkgInfo(String manifest) {
    try {
      String? identity = RegExp(r'<\s*Identity[^">]*("[^"]*"[^">]*)*>', multiLine: true).firstMatch(manifest)?.group(0)?.replaceAll('\n', ' ');
      name = identity?.find(r'\s+Name\s*=\s*"([^"]*)', 1) ?? 'UNKNOWN_APP_NAME';
      String? publisher = identity?.find(r'\s+Publisher\s*=\s*"([^"]*)', 1);
      publisherId = (publisher != null) ? WinPkg.getPublisherId(publisher) : 'UNKNOWN_PUBLISHER_ID';
      version = identity?.find(r'\s+Version\s*=\s*"([^"]*)', 1) ?? 'UNKNOWN_VERSION';
      architecture = identity?.find(r'\s+ProcessorArchitecture\s*=\s*"([^"]*)', 1) ?? 'UNKNOWN_ARCHITECTURE';
      parseManifestExtras(manifest);
    }
    catch(e) {/**/}
  }

  WinPkgInfo.fromSystemPath(String systemPath) : this(_tryReadManifest("$systemPath\\AppxManifest.xml"));

  static String _tryReadManifest(String manifestFile) {
    try {return File(manifestFile).readAsStringSync();}
    catch(_) {return "";}
  }
}
```

`lib/windows/win_reg.dart`:

```dart
// ignore_for_file: constant_identifier_names, non_constant_identifier_names

import 'dart:developer';
import 'dart:ffi';

import 'package:ffi/ffi.dart';
import 'package:win32/win32.dart';

const _MAX_ITEMLENGTH = 1024;

extension on String {
  static final RegExp _KEY_PATH_NORMALIZER = RegExp(r'[\\]*(.*)');
  String? get normalizedRegKey => _KEY_PATH_NORMALIZER.firstMatch(this)?.group(1);
}

enum RegHKey {
  HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_PERFORMANCE_TEXT,
  HKEY_PERFORMANCE_NLSTEXT, HKEY_CURRENT_CONFIG, HKEY_DYN_DATA, HKEY_CURRENT_USER_LOCAL_SETTINGS
}

extension on RegHKey {
  int get value {switch(this) {
    case RegHKey.HKEY_CLASSES_ROOT: return HKEY_CLASSES_ROOT;
    case RegHKey.HKEY_CURRENT_USER: return HKEY_CURRENT_USER;
    case RegHKey.HKEY_LOCAL_MACHINE: return HKEY_LOCAL_MACHINE;
    case RegHKey.HKEY_USERS: return HKEY_USERS;
    case RegHKey.HKEY_PERFORMANCE_DATA: return HKEY_PERFORMANCE_DATA;
    case RegHKey.HKEY_PERFORMANCE_TEXT: return HKEY_PERFORMANCE_TEXT;
    case RegHKey.HKEY_PERFORMANCE_NLSTEXT: return HKEY_PERFORMANCE_NLSTEXT;
    case RegHKey.HKEY_CURRENT_CONFIG: return HKEY_CURRENT_CONFIG;
    case RegHKey.HKEY_DYN_DATA: return HKEY_DYN_DATA;
    case RegHKey.HKEY_CURRENT_USER_LOCAL_SETTINGS: return HKEY_CURRENT_USER_LOCAL_SETTINGS;
  }}
}

class RegValue {
  RegValue._create(this.type, this.value);
  String value;
  int type;
}

class WinReg {
  static RegValue? getString(RegHKey hKey, String keyPath, String? valName, {bool noExpand = false}) {
    String? keyPathN = keyPath.normalizedRegKey;
    if (keyPathN == null) return null;

    final lpKey = keyPathN.toNativeUtf16();
    final lpValue = (valName != null && valName.isNotEmpty) ? valName.toNativeUtf16() : nullptr;
    final lpType = calloc<DWORD>();
    final lpData = calloc<BYTE>(_MAX_ITEMLENGTH);
    final lpcbData = calloc<DWORD>()..value = _MAX_ITEMLENGTH;

    int flags = RRF_RT_ANY;
    if (noExpand) flags |= RRF_NOEXPAND;

    try {
      final status = RegGetValue(hKey.value, lpKey, lpValue, flags, lpType, lpData, lpcbData);

      switch (status) {
        case ERROR_SUCCESS:
          int type = lpType.value;
          if (type != REG_SZ && type != REG_EXPAND_SZ && type != REG_MULTI_SZ) {
            log('win_reg: Non-string content; type: $type');
            return null;
          }
          log('win_reg: value type: $type');
          return RegValue._create(type, lpData.cast<Utf16>().toDartString());

        case ERROR_MORE_DATA:
          log('win_reg: An item required more than $_MAX_ITEMLENGTH bytes');
          return null;
          //throw Exception('An item required more than $_MAX_ITEMLENGTH bytes.');

        case ERROR_NO_MORE_ITEMS:
          return null;

        default:
          log('win_reg: Unknown error');
          return null;
          //throw Exception('unknown error');
      }
    } finally {
      free(lpKey);
      free(lpValue);
      free(lpType);
      free(lpData);
      free(lpcbData);
    }
  }
}

```

`lib/windows/win_wmi.dart`:

```dart
// ignore_for_file: constant_identifier_names, non_constant_identifier_names

import 'dart:developer';
import 'dart:ffi';

import 'package:ffi/ffi.dart';
import 'package:win32/win32.dart';

/// Call WMI queries
/// The COM library is never closed (TODO should change?)
class WinWMI {

  static const String _namespace = r'ROOT\CIMV2';
  static int _failPoint = 0;

  static String? queryString(String valName, String wmiClass) {
    IWbemServices? service = _service;
    if (service == null) return null;

    final pEnumerator = calloc<Pointer<COMObject>>();
    IEnumWbemClassObject? enumerator;

    try {
      // For example, query for all the running processes
      int hr = service.ExecQuery(TEXT('WQL'), TEXT('SELECT $valName FROM $wmiClass'),
          WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_FORWARD_ONLY | WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY, nullptr, pEnumerator);

      if (FAILED(hr)) {
        log(WindowsException(hr).toString(), level: 1000);
        free(pEnumerator);
        return null;
      } else {
        enumerator = IEnumWbemClassObject(pEnumerator.cast());

        final uReturn = calloc<Uint32>();

        if (enumerator.ptr.address > 0) {
          final pClsObj = calloc<IntPtr>();
          hr = enumerator.Next(WBEM_TIMEOUT_TYPE.WBEM_INFINITE, 1, pClsObj.cast(), uReturn);

          // Break out of the while loop if we've run out of processes to inspect
          if (uReturn.value == 0) {
            free(pClsObj);
            return null;
          }

          final clsObj = IWbemClassObject(pClsObj.cast());

          final vtProp = calloc<VARIANT>();
          hr = clsObj.Get(TEXT(valName), 0, vtProp, nullptr, nullptr);
          String? value = SUCCEEDED(hr) ? vtProp.ref.bstrVal.toDartString() : null;
          
          VariantClear(vtProp);
          free(vtProp);
          clsObj.Release();

          return value;
        }
      }
    }
    finally {
      enumerator?.Release() ?? free(pEnumerator);
    }
  }

  static IWbemServices? get _service => __serviceResult ?? _initService();
  static IWbemServices? __serviceResult;
  
  static IWbemServices? _initService() {
    if (__serviceResult != null) return __serviceResult;
    int hr = 0;

    if (_failPoint < 1) {
      hr = CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);
      if (FAILED(hr)) {
        log(WindowsException(hr).toString(), level: 1000);
        return null;
      }
    }

    if (_failPoint < 1) _failPoint = 1;

    // Initialize security model
    if (_failPoint < 2) {
      hr = CoInitializeSecurity(nullptr, -1, nullptr, nullptr, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, // Impersonation
          nullptr, EOLE_AUTHENTICATION_CAPABILITIES.EOAC_NONE, nullptr);

      if (FAILED(hr)) {
        log(WindowsException(hr).toString(), level: 1000);
        CoUninitialize();
        return null;
      }
    }

    if (_failPoint < 2) _failPoint = 2;

    // Obtain the initial locator to Windows Management
    // on a particular host computer.
    final pLoc = IWbemLocator(calloc<COMObject>());

    final clsid = malloc<GUID>()..ref.setGUID(CLSID_WbemLocator);
    final iid = malloc<GUID>()..ref.setGUID(IID_IWbemLocator);

    hr = CoCreateInstance(clsid, nullptr, CLSCTX_INPROC_SERVER, iid, pLoc.ptr.cast());

    if (FAILED(hr)) {
      log(WindowsException(hr).toString(), level: 1000);

      pLoc.Release();
      free(clsid);
      free(iid);
      CoUninitialize();
      return null;
    }

    final proxy = calloc<Pointer<COMObject>>();

    // Connect to the root\cimv2 namespace with the
    // current user and obtain pointer pSvc
    // to make IWbemServices calls.
    hr = pLoc.ConnectServer(TEXT(_namespace), nullptr, nullptr, nullptr, NULL, nullptr, nullptr, proxy);

    if (FAILED(hr)) {
      log(WindowsException(hr).toString(), level: 1000);

      pLoc.Release();
      free(clsid);
      free(iid);
      free(proxy);
      CoUninitialize();
      return null; // Program has failed.
    }

    log(r'Connected to ROOT\CIMV2 WMI namespace');

    return __serviceResult = IWbemServices(proxy.cast());

    // Set the IWbemServices proxy so that impersonation
    // of the user (client) occurs.
    /*hr = CoSetProxyBlanket(
        proxy.value, // the proxy to set
        RPC_C_AUTHN_WINNT, // authentication service
        RPC_C_AUTHZ_NONE, // authorization service
        nullptr, // Server principal name
        RPC_C_AUTHN_LEVEL_CALL, // authentication level
        RPC_C_IMP_LEVEL_IMPERSONATE, // impersonation level
        nullptr, // client identity
        EOLE_AUTHENTICATION_CAPABILITIES.EOAC_NONE // proxy capabilities
        );

    if (FAILED(hr)) {
      final exception = WindowsException(hr);
      print(exception.toString());
      pSvc.Release();
      pLoc.Release();
      CoUninitialize();
      throw exception; // Program has failed.
    }*/
  }
}
```

`lib/windows/wsa_status.dart`:

```dart
import 'package:win32/win32.dart';
import 'package:wsa_pacman/windows/win_io.dart';

class WSAStatus {
  static late final _WSA_CLIENT_MUTEX = TEXT(r"{42CEB0DF-325A-4FBE-BBB6-C259A6C3F0BB}");

  static bool get isBooted => WinIO.findMutexWstr(_WSA_CLIENT_MUTEX);
}
```

`locale/ar.arb`:

```arb
{
    "@@locale": "ar",
    "@locale_desc": {"description": "Arabic [ar_EG]"},
    "locale_desc": "العربية",
    "@locale_system": {"description": "Describes the system locale"},
    "locale_system": "النظام",


    "btn_boot": "تشغيل",
    "btn_switch_on": "مفعل",
    "btn_switch_off": "مغلق",


    "status_subtext_winver_10": "ويندوز 10",
    "status_subtext_winver_older": "إصدار ويندوز أقدم",


    "status_unsupported": "حزمة WSA غير مثبتة",
    "status_unsupported_desc": "تم العثور على إصدار {windowsVersion} و لم يثبت WSA ; و هذا التطبيق يعتمد على WSA, و التي تثبت على ويندوز 11 فقط",
    "status_missing": "حزمة WSA غير مثبتة",
    "status_missing_desc": "حزمة WSA غير موجودة; و هذا التطبيق يعتمد على WSA, برجاء تحميل نظام اندرويد لويندوز او متجر امازون من متجر مايكروسوفت",
    "status_unknown": "جاري الاتصال",
    "status_unknown_desc": "في انتظار الاتصال بWSA",
    "status_starting": "جاري التشغيل",
    "status_starting_desc": "جاري تشغيل WSA, برجاء الانتظار",
    "status_arrested": "غير مفعل",
    "status_arrested_desc": "WSA غير مفعل",
    "status_offline": "غير متصل",
    "status_offline_desc": "لم يمكن الاتصال بWSA: يمكن ان يكون وضع المطور غير مفعل, او تم تحديد المخرج الخاطىء",
    "status_disconnected": "لا يمكن الاتصال",
    "status_disconnected_desc": "لا يمكن عمل اتصال لWSA لاسباب غير معلومه",
    "status_connected": "متصل",
    "status_connected_desc": "تم الاتصال بنجاح",


    "screen_wsa": "مدير حزم الWSA",
    "screen_settings": "الضبط",


    "wsa_manage": "إدارة الاندرويد",
    "wsa_manage_app": "إدارة التطبيقات",
    "wsa_manage_settings": "إدارة الضبط",

    
    "settings_port": "مدخل الWSA",
    "settings_ip": "عنوان الIP الخاص بWSA",
    "settings_autostart": "تفعبل تلقائي لWSA قبل التثبيت",
    "settings_language": "اللغة",
    "settings_option_generic_system": "النظام",
    "settings_option_generic_disabled": "غير مفعل",


    "theme_mode": "وضع السمات",
    "theme_mode_dark": "داكن",
    "theme_mode_light": "ساطع",
    "theme_mica": "شفافية النافذة",
    "theme_mica_full": "كامل",
    "theme_mica_partial": "جزئي",
    "theme_icon_adaptive": "ايقونات متكيفة",
    "theme_icon_adaptive_squircle": "مربع منحني",
    "theme_icon_adaptive_circle": "دائري",
    "theme_icon_adaptive_rounded_square": "مربع مستدير",


    "installer_message": "هل تريد تثبيت هذا التطبيق؟",
    "installer_info_version": "الإصدار: {appVersion}",
    "installer_info_version_change": "الإصدار: {appVersionOld} => {appVersionNew}",
    "installer_info_package": "الحزمة: {appPackage}",
    "installer_installing": "جاري تثبيث {appTitle}...",
    "installer_installed": "تم تثبيت {appTitle} بنجاح",
    "installer_fail": "لم يتم تثبيت {appTitle}",
    "installer_error_nomsg": "فشل التثبيت, لكن بلا أخطاء",
    "installer_btn_starting": "يتم التشغيل...",
    "installer_btn_loading": "تحميل...",
    "installer_btn_cancel": "إلغاء",
    "installer_btn_install": "تثبيت",
    "installer_btn_reinstall": "إعادة التثبيت",
    "installer_btn_update": "تحديث",
    "installer_btn_downgrade": "الرجوع إلى إصدار قديم(غير آمن)",
    "installer_btn_dismiss": "تم",
    "installer_btn_open": "فتح التطبيق",
    "installer_btn_checkbox_shortcut": "عمل اختصار على سطح المكتب",


    "android_permission_none": "لا يطلب اي اذونات",
    "android_permission_admin": "يدير الجهاز كمشرف",
    "android_permission_admin_brick": "يلغي تفعيل الجهاز او يعيد ضبطه عن بعد",
    "android_permission_admin_lock": "قفل الجهاز عن بعد",
    "android_permission_storage": "الملفات و الوسائط",
    "android_permission_microphone": "الميكروفون",
    "android_permission_camera": "الكاميرا",
    "android_permission_location": "الموقع",
    "android_permission_phone": "الهاتف",
    "android_permission_call_log": "سجلات المكالمات",
    "android_permission_sms": "الرسائل",
    "android_permission_contacts": "جهات الاتصال",
    "android_permission_calendar": "التقويم",
    "android_permission_activity_recognition": "الانشطة البدنية",
    "android_permission_sensors": "مستشعرات الجهاز",
    "android_permission_sensors_body": "مستشعرات البدن",
    "android_permission_nearby_devices": "تحديد الاجهزة القريبة"
}

```

`locale/de.arb`:

```arb
{
    "@@README_1": "The en.arb file is a template for other files",
    "@@README_2": "For other languages, entries starting with @ and @@ are not needed, except @@locale",
    "@@README_3": "Country-specific locales (eg. 'en_GB') need a fallback locale (eg. 'en') to exist",


    "@@locale": "de",
    "@locale_desc": {"description": "German [de-DE]"},
    "locale_desc": "Deutsch",
    "locale_system": "System",


    "btn_boot": "Starten",
    "btn_switch_on": "An",
    "btn_switch_off": "Aus",


    "status_subtext_winver_10": "Windows 10",
    "status_subtext_winver_older": "Frühere Windows Version",


    "status_unsupported": "WSA ist nicht installiert.",
    "status_unsupported_desc": "{windowsVersion} wurde erkannt und WSA nicht gefunden; diese Anwendung benötigt WSA welche nur auf Windows 11 offiziell verfügbar ist.",
    "status_missing": "WSA ist nicht installiert.",
    "status_missing_desc": "WSA wurde nicht gefunden; diese Anwendung benötigt WSA, Windows Subsystem für Android (oder der Amazon AppStore) kann vom Microsoft Store bezogen werden.",
    "status_unknown": "Verbinde",
    "status_unknown_desc": "Warte auf die Verbindung zu WSA...",
    "status_starting": "Starte",
    "status_starting_desc": "WSA wird gestartet, bitte warten...",
    "status_arrested": "Gestoppt",
    "status_arrested_desc": "WSA läuft nicht.",
    "status_offline": "Offline",
    "status_offline_desc": "Es konnte keine Verbindung zu WSA hergestellt werden: entweder ist der Entwicklermodus deaktiviert oder USB-Debugging nicht aktiv bzw. ein falscher Port angegeben.",
    "status_disconnected": "Getrennt",
    "status_disconnected_desc": "Es konnte aus unbekannten Gründen keine Verbindung zu WSA hergestellt werden.",
    "status_connected": "Verbunden",
    "status_connected_desc": "Erfolgreich verbunden.",


    "screen_wsa": "WSA Paketmanager",
    "screen_settings": "Einstellungen",


    "wsa_manage": "Android Einstellungen",
    "wsa_manage_app": "Apps",
    "wsa_manage_settings": "System",


    "settings_port": "WSA-Debugging Port",
    "settings_ip": "WSA IP Adresse",
    "settings_autostart": "Starte WSA automatisch",
    "settings_language": "Sprache",
    "settings_option_generic_system": "System",
    "settings_option_generic_disabled": "Deaktiviert",


    "theme_mode": "Design",
    "theme_mode_dark": "Dunkel",
    "theme_mode_light": "Hell",
	"theme_mica": "Transparenz",
    "theme_mica_full": "Vollständig",
    "theme_mica_partial": "Teilweise",
    "theme_icon_adaptive": "Angepasste Icons",
	"theme_icon_adaptive_squircle": "Superkreis",
    "theme_icon_adaptive_circle": "Kreis",
    "theme_icon_adaptive_rounded_square": "Runde Ecken",


    "installer_message": "Soll diese App installiert werden?",
    "installer_info_version": "Version: {appVersion}",
    "installer_info_version_change": "Version: {appVersionOld} => {appVersionNew}",
    "installer_info_package": "Paketname: {appPackage}",
	"installer_installing": "Installiere {appTitle}...",
    "installer_installed": "{appTitle} wurde erfolgreich installiert.",
    "installer_fail": "{appTitle} wurde nicht installiert.",
    "installer_error_nomsg": "Installation ohne Angabe von Gründen fehlgeschlagen.",
    "installer_btn_starting": "Starte WSA...",
    "installer_btn_loading": "Lade App...",
    "installer_btn_cancel": "Abbrechen",
    "installer_btn_install": "Installieren",
    "installer_btn_reinstall": "Neu installieren",
    "installer_btn_update": "Update",
    "installer_btn_downgrade": "Downgrade (unsicher)",
    "installer_btn_dismiss": "Schließen",
    "installer_btn_open": "Öffnen",
    "installer_btn_checkbox_shortcut": "Erstelle eine Desktop Verknüpfung",


    "android_permission_none": "Keine Berechtigungen erforderlich",
    "android_permission_admin": "Gerät als Administrator verwalten",
    "android_permission_admin_brick": "Gerät aus der Ferne sperren oder zurücksetzen",
    "android_permission_admin_lock": "Gerät aus der Ferne sperren",
    "android_permission_storage": "Speicher",
    "android_permission_microphone": "Mikrofon",
    "android_permission_camera": "Kamera",
    "android_permission_location": "Standort",
    "android_permission_phone": "Telefon",
    "android_permission_call_log": "Anrufliste",
    "android_permission_sms": "Nachrichten",
    "android_permission_contacts": "Kontakte",
    "android_permission_calendar": "Kalender",
    "android_permission_activity_recognition": "Aktivitätserkennung",
    "android_permission_sensors": "Gerätesensoren",
    "android_permission_sensors_body": "Körpersensoren",
    "android_permission_nearby_devices": "Geräte in der Nähe"
}
```

`locale/en.arb`:

```arb
{
    "@@README_1": "The en.arb file is a template for other files",
    "@@README_2": "For other languages, entries starting with @ and @@ are not needed, except @@locale",
    "@@README_3": "Country-specific locales (eg. 'en_GB') need a fallback locale (eg. 'en') to exist",


    "@@locale": "en",
    "@locale_desc": {"description": "English (US) [en_US]"},
    "locale_desc": "English",
    "@locale_system": {"description": "Describes the system locale"},
    "locale_system": "System",


    "btn_boot": "Turn on",
    "btn_switch_on": "On",
    "btn_switch_off": "Off",


    "@status_subtext_winver_10": {"description": "Only used inside 'status_unsupported_desc', modify taking this in consideration"},
    "status_subtext_winver_10": "Windows 10",
    "@status_subtext_winver_older": {"description": "Only used inside 'status_unsupported_desc', modify taking this in consideration"},
    "status_subtext_winver_older": "Older Windows Version",


    "status_unsupported": "WSA not installed",
    "status_unsupported_desc": "{windowsVersion} detected and WSA not found; this application depends on WSA, which is only officially supported on Windows 11",
    "@status_unsupported_desc" : {"placeholders": {"windowsVersion": {"type": "String"}}},
    "status_missing": "WSA not installed",
    "status_missing_desc": "WSA not found; this application depends on WSA, please install Windows Subsystem for Android (or the Amazon Appstore) from the Microsoft Store",
    "status_unknown": "Connecting",
    "status_unknown_desc": "Waiting for a WSA connection to be established...",
    "status_starting": "Starting",
    "status_starting_desc": "WSA is starting, please stand by...",
    "status_arrested": "Arrested",
    "status_arrested_desc": "WSA is turned off",
    "status_offline": "Offline",
    "status_offline_desc": "Could not establish a connection with WSA: either developer mode and USB debugging are disabled or a wrong port is specified",
    "status_disconnected": "Disconnected",
    "status_disconnected_desc": "A WSA connection could not be enstablished for unknown reasons",
    "status_connected": "Connected",
    "status_connected_desc": "Successfully connected to WSA, all systems go",


    "screen_wsa": "WSA Package Manager",
    "screen_settings": "Settings",


    "wsa_manage": "Android Management",
    "wsa_manage_app": "Manage Applications",
    "wsa_manage_settings": "Manage Settings",

    
    "settings_port": "WSA Port",
    "settings_ip": "WSA IP address",
    "settings_autostart": "Autostart WSA before installation",
    "settings_language": "Language",
    "settings_option_generic_system": "System",
    "settings_option_generic_disabled": "Disabled",


    "theme_mode": "Theme mode",
    "theme_mode_dark": "Dark",
    "theme_mode_light": "Light",
    "theme_mica": "Window transparency",
    "theme_mica_full": "Full",
    "theme_mica_partial": "Partial",
    "theme_icon_adaptive": "Adaptive icons Shape",
    "theme_icon_adaptive_squircle": "Squircle",
    "theme_icon_adaptive_circle": "Circle",
    "theme_icon_adaptive_rounded_square": "Rounded Square",


    "installer_message": "Do you want to install this application?",
    "installer_info_version": "Version: {appVersion}",
    "@installer_info_version" : {"placeholders": {"appVersion": {"type": "String"}}},
    "installer_info_version_change": "Version: {appVersionOld} => {appVersionNew}",
    "@installer_info_version_change" : {"placeholders": {"appVersionOld": {"type": "String"}, "appVersionNew": {"type": "String"}}},
    "installer_info_package": "Package: {appPackage}",
    "@installer_info_package" : {"placeholders": {"appPackage": {"type": "String"}}},
    "installer_installing": "Installing application {appTitle}...",
    "@installer_installing" : {"placeholders": {"appTitle": {"type": "String"}}},
    "installer_installed": "The application {appTitle} was successifully installed",
    "@installer_installed" : {"placeholders": {"appTitle": {"type": "String"}}},
    "installer_fail": "The application {appTitle} was not installed",
    "@installer_fail" : {"placeholders": {"appTitle": {"type": "String"}}},
    "installer_error_nomsg": "The installation has failed, but no error was thrown",
    "installer_btn_starting": "Starting...",
    "installer_btn_loading": "Loading...",
    "installer_btn_cancel": "Cancel",
    "installer_btn_install": "Install",
    "installer_btn_reinstall": "Reinstall",
    "installer_btn_update": "Update",
    "installer_btn_downgrade": "Downgrade (unsafe)",
    "installer_btn_dismiss": "Dismiss",
    "installer_btn_open": "Open app",
    "installer_btn_checkbox_shortcut": "Create desktop shortcut",


    "android_permission_none": "No permissions required",
    "android_permission_admin": "Manage device as administrator",
    "android_permission_admin_brick": "Remotely disable or reset device",
    "android_permission_admin_lock": "Remotely lock device",
    "android_permission_storage": "Files and media",
    "android_permission_microphone": "Microphone",
    "android_permission_camera": "Camera",
    "android_permission_location": "Location",
    "android_permission_phone": "Phone",
    "android_permission_call_log": "Call logs",
    "android_permission_sms": "Messages",
    "android_permission_contacts": "Contacts",
    "android_permission_calendar": "Calendar",
    "android_permission_activity_recognition": "Physical activity",
    "android_permission_sensors": "Device sensors",
    "android_permission_sensors_body": "Body sensors",
    "android_permission_nearby_devices": "Locate nearby devices"
}

```

`locale/es.arb`:

```arb
{
    "@@README_1": "El archivo en.arb es una plantilla para otros archivos",
    "@@README_2": "Para otros idiomas, no se necesitan entradas que comiencen con @ y @@, excepto @@locale",
    "@@README_3": "Los idiomas específicos de un país (ej. 'en_GB') necesitan un idioma de respaldo existente (ej. 'en')",


    "@@locale": "es",
    "@locale_desc": {"description": "Spanish (Spain) [es_ES]"},
    "locale_desc": "Español",
    "locale_system": "Sistema",


    "btn_boot": "Encender",
    "btn_switch_on": "On",
    "btn_switch_off": "Off",


    "status_subtext_winver_10": "Windows 10 detectado",
    "status_subtext_winver_older": "Versión anterior de Windows detectada",


    "status_unsupported": "WSA no instalado",
    "status_unsupported_desc": "{windowsVersion} y WSA no encontrado; esta aplicación depende de WSA, que solo es oficialmente compatible con Windows 11",
    "status_missing": "WSA no instalado",
    "status_missing_desc": "WSA no encontrado; esta aplicación depende de WSA, instale Windows Subsystem para Android (o Amazon Appstore) desde Microsoft Store",
    "status_unknown": "Conectando",
    "status_unknown_desc": "Esperando a que se establezca la conexión con WSA...",
    "status_starting": "Iniciando",
    "status_starting_desc": "WSA se está iniciando, por favor espere...",
    "status_arrested": "Arrestado",
    "status_arrested_desc": "WSA esta apagado",
    "status_offline": "Desconectado",
    "status_offline_desc": "No se pudo establecer una conexión con WSA: el modo desarrollador y la depuración USB están deshabilitados o se especifica un puerto incorrecto",
    "status_disconnected": "Desconectado",
    "status_disconnected_desc": "No se pudo establecer una conexión a WSA por razones desconocidas",
    "status_connected": "Conectado",
    "status_connected_desc": "Conectado con éxito a WSA, todo está bien",


    "screen_wsa": "Gestor de paquetes WSA",
    "screen_settings": "Configuración",


    "wsa_manage": "Gestión de Android",
    "wsa_manage_app": "Administrar aplicaciones",
    "wsa_manage_settings": "Administrar configuraciones",

    
    "settings_port": "Puerto WSA",
    "settings_ip": "Dirección IP de WSA",
    "settings_autostart": "Inicio automático de WSA antes de la instalación",
    "settings_language": "Idioma",
    "settings_option_generic_system": "Sistema",
    "settings_option_generic_disabled": "Deshabilitado",


    "theme_mode": "Modo de tema",
    "theme_mode_dark": "Oscuro",
    "theme_mode_light": "Claro",
    "theme_mica": "Transparencia de ventana",
    "theme_mica_full": "Total",
    "theme_mica_partial": "Parcial",
    "theme_icon_adaptive": "Forma de iconos adaptativos",
    "theme_icon_adaptive_squircle": "Super círculo",
    "theme_icon_adaptive_circle": "Circulo",
    "theme_icon_adaptive_rounded_square": "Cuadrado redondeado",


    "installer_message": "¿Quieres instalar esta aplicación?",
    "installer_info_version": "Versión: {appVersion}",
    "installer_info_version_change": "Versión: {appVersionOld} => {appVersionNew}",
    "installer_info_package": "Paquete: {appPackage}",
    "installer_installing": "Instalación de la aplicación {appTitle}...",
    "installer_installed": "La aplicación {appTitle} se instaló correctamente",
    "installer_fail": "Aplicación {appTitle} noinstalada",
    "installer_error_nomsg": "La instalación ha fallado, pero no se ha producido ningún error",
    "installer_btn_starting": "Iniciando...",
    "installer_btn_loading": "Loading...",
    "installer_btn_cancel": "Cancelar",
    "installer_btn_install": "Instalar",
    "installer_btn_reinstall": "Reinstalar",
    "installer_btn_update": "Actualizar",
    "installer_btn_downgrade": "Degradar (inseguro)",
    "installer_btn_dismiss": "Terminar",
    "installer_btn_open": "Abrir la app",
    "installer_btn_checkbox_shortcut": "Crear acceso directo del escritorio",


    "android_permission_none": "Sin permisos necesarios",
    "android_permission_admin": "Gestionar dispositivo como administrador",
    "android_permission_admin_brick": "Deshabilitar o restablecer el dispositivo",
    "android_permission_admin_lock": "Bloquear dispositivo de forma remota",
    "android_permission_storage": "Archivos y multimedia",
    "android_permission_microphone": "Micrófono",
    "android_permission_camera": "Cámara",
    "android_permission_location": "Localización",
    "android_permission_phone": "Teléfono",
    "android_permission_call_log": "Registros de llamadas",
    "android_permission_sms": "Mensajes",
    "android_permission_contacts": "Contactos",
    "android_permission_calendar": "Calendario",
    "android_permission_activity_recognition": "Actividad física",
    "android_permission_sensors": "Sensores del dispositivo",
    "android_permission_sensors_body": "Sensores del cuerpo",
    "android_permission_nearby_devices": "Buscar dispositivos cercanos"
}

```

`locale/fa-IR.arb`:

```arb
{
    "@@locale": "fa",
    "@locale_desc": {"description": "Farsi (Persian) [fa_IR]"},
    "locale_desc": "فارسی",
    "@locale_system": {"description": "Describes the system locale"},
    "locale_system": "سیستم",


    "btn_boot": "روشن کردن",
    "btn_switch_on": "روشن",
    "btn_switch_off": "خاموش",


    "status_subtext_winver_10": "ویندوز 10",
    "status_subtext_winver_older": "نسخه قدیمی ویندوز",


    "status_unsupported": "WSA نصب نشده",
    "status_unsupported_desc": "{windowsVersion} شناسایی شد و یافت نشد. این برنامه به WSA وابسته است که به طور رسمی فقط  در ویندوز 11 پشتیبانی می شود",
    "status_missing": "WSA نصب نشده",
    "status_missing_desc": "WSA یافت نشد. این برنامه وابسته به WSA است، لطفا زیرسیستم ویندوز را برای اندروید (یا اپ استور آمازون) از Microsoft Store را نصب کنید",
    "status_unknown": "در حال اتصال",
    "status_unknown_desc": "در انتظار برقراری اتصال WSA...",
    "status_starting": "شروع ...",
    "status_starting_desc": "WSA در حال شروع است، لطفا منتظر بمانید...",
    "status_arrested": "دستگیر شد",
    "status_arrested_desc": "WSA خاموش شد",
    "status_offline": "آفلاین",
    "status_offline_desc": "اتصال با WSA امکان‌پذیر نیست: یا حالت برنامه‌نویس و اشکال‌زدایی USB غیرفعال هستند یا پورت اشتباهی مشخص شده است.",
    "status_disconnected": "قطع شده",
    "status_disconnected_desc": "اتصال WSA به دلایل نامعلومی برقرار نشد",
    "status_connected": "وصل شده",
    "status_connected_desc": "با موفقیت به WSA متصل شد، سیستم ها کار میکند",


    "screen_wsa": "مدیریت بسته WSA",
    "screen_settings": "تنظیمان",


    "wsa_manage": "مدیریت اندروید",
    "wsa_manage_app": "مدیریت برنامه ها",
    "wsa_manage_settings": "مدیریت تنظیمات",

    
    "settings_port": "پورت WSA",
    "settings_ip": "آدری آی پی WSA",
    "settings_autostart": "قبل از نصب WSA را به صورت خودکار راه اندازی شود",
    "settings_language": "زبان",
    "settings_option_generic_system": "سیستم",
    "settings_option_generic_disabled": "غیرفعال",


    "theme_mode": "نوع زمینه",
    "theme_mode_dark": "تاریک",
    "theme_mode_light": "روشن",
    "theme_mica": "شفافیت پنجره ها",
    "theme_mica_full": "کامل",
    "theme_mica_partial": "جزئي",
    "theme_icon_adaptive": "سازگارسازی آیکون",
    "theme_icon_adaptive_squircle": "مربع",
    "theme_icon_adaptive_circle": "دایره",
    "theme_icon_adaptive_rounded_square": "گوشه های کرد",


    "installer_message": "آیا از نصب این برنامه اطمینان دارید؟",
    "installer_info_version": "تسخه: {appVersion}",
    "installer_info_version_change": "نسخه: {appVersionOld} => {appVersionNew}",
    "installer_info_package": "بسته: {appPackage}",
    "installer_installing": "در حال نصب {appTitle}...",
    "installer_installed": "برنامه {appTitle} نصب شد",
    "installer_fail": "برنامه {appTitle} نصب نشد.",
    "installer_error_nomsg": "نصب انجام نشد، اما خطایی هم رخ نداد",
    "installer_btn_starting": "شروع...",
    "installer_btn_loading": "بارگذاری...",
    "installer_btn_cancel": "لغو",
    "installer_btn_install": "نصب",
    "installer_btn_reinstall": "نصب مجدد",
    "installer_btn_update": "بروزرسانی",
    "installer_btn_downgrade": "Downgrade (امن نیست)",
    "installer_btn_dismiss": "رد کردن",
    "installer_btn_open": "باز کردن",
    "installer_btn_checkbox_shortcut": "ساخت میانبر در دسکتاپ",


    "android_permission_none": "هیچ مجوزی لازم نیست",
    "android_permission_admin": "مدیریت دستگاه",
    "android_permission_admin_brick": "غیرفعال یا بازنشانی دستگاه از راه دور",
    "android_permission_admin_lock": "قفل دستگاه از راه دور",
    "android_permission_storage": "فایل ها و رسانه ها",
    "android_permission_microphone": "میکروفون",
    "android_permission_camera": "دوربین",
    "android_permission_location": "موقعیت مکانی",
    "android_permission_phone": "تلفن",
    "android_permission_call_log": "تماس ها",
    "android_permission_sms": "پیام ها",
    "android_permission_contacts": "مخاطبین",
    "android_permission_calendar": "تقویم",
    "android_permission_activity_recognition": "فعالیت های بدنی",
    "android_permission_sensors": "سنسور دستگاه",
    "android_permission_sensors_body": "سنسور بدن",
    "android_permission_nearby_devices": "پیدا کردن دستگاه های نزدیک"
}
```

`locale/fr.arb`:

```arb
{
    "@@README_1": "Le fichier en.arb est un modèle pour d'autres fichiers",
    "@@README_2": "Pour les autres langues, les entrées commençant par @ et @@ ne sont pas nécessaires, sauf @@locale",
    "@@README_3": "Locales spécifiques à un pays (ex. 'en_GB') ont besoin d'un locale de secours existant (ex. 'en')",


    "@@locale": "fr",
    "@locale_desc": {"description": "French [fr_FR]"},
    "locale_desc": "Français",
    "@locale_system": {"description": "Définit la langue du système"},
    "locale_system": "Système",


    "btn_boot": "Démarrer",
    "btn_switch_on": "On",
    "btn_switch_off": "Off",


    "status_subtext_winver_10": "Windows 10",
    "status_subtext_winver_older": "Version antérieure de Windows",


    "status_unsupported": "WSA pas installé",
    "status_unsupported_desc": "{windowsVersion} détectée et WSA non trouvé; cette application dépend de WSA, qui n'est officiellement pris en charge que sur Windows 11",
    "status_missing": "WSA pas installé",
    "status_missing_desc": "WSA non trouvé; cette application dépend de WSA, veuillez installer Windows Subsystem pour Android (ou l'Amazon Appstore) à partir du Microsoft Store",
    "status_unknown": "Connecting",
    "status_unknown_desc": "Attente de l'établissement d'une connexion à WSA...",
    "status_starting": "Démarrage",
    "status_starting_desc": "WSA démarre, veuillez patienter...",
    "status_arrested": "Arrêté",
    "status_arrested_desc": "WSA est éteint",
    "status_offline": "Hors-ligne",
    "status_offline_desc": "Impossible d'établir une connexion avec WSA: le mode développeur et le débogage USB sont désactivés, ou un port incorrect a été spécifié",
    "status_disconnected": "Déconnecté",
    "status_disconnected_desc": "Une connexion au WSA n'a pas pu être établie pour des raisons inconnues",
    "status_connected": "Connecté",
    "status_connected_desc": "Connecté avec succès à WSA, tout est prêt",


    "screen_wsa": "Gestionnaire de paquets WSA",
    "screen_settings": "Paramètres",


    "wsa_manage": "Gestion Android",
    "wsa_manage_app": "Gérer des applications",
    "wsa_manage_settings": "Gestion des paramètres",

    
    "settings_port": "Port WSA",
    "settings_ip": "Adresse IP WSA",
    "settings_autostart": "Démarrage automatique de WSA avant l'installation",
    "settings_language": "Langue",
    "settings_option_generic_system": "Système",
    "settings_option_generic_disabled": "Désactivée",


    "theme_mode": "Mode thème",
    "theme_mode_dark": "Sombre",
    "theme_mode_light": "Clair",
    "theme_mica": "Transparence de la fenêtre",
    "theme_mica_full": "Totale",
    "theme_mica_partial": "Partielle",
    "theme_icon_adaptive": "Forme adaptative des icones",
    "theme_icon_adaptive_squircle": "Supercercle",
    "theme_icon_adaptive_circle": "Cercle",
    "theme_icon_adaptive_rounded_square": "Carré arrondi",


    "installer_message": "Voulez-vous installer cette application ?",
    "installer_info_version": "Version: {appVersion}",
    "installer_info_version_change": "Version: {appVersionOld} => {appVersionNew}",
    "installer_info_package": "Paquet: {appPackage}",
    "installer_installing": "Installation de l'application {appTitle}...",
    "installer_installed": "L'application {appTitle} a été installée avec succès",
    "installer_fail": "The application {appTitle} n'a pas été installée",
    "installer_error_nomsg": "L'installation a échoué, mais aucune erreur n'a été renvoyée",
    "installer_btn_starting": "Démarrage...",
    "installer_btn_loading": "Chargement...",
    "installer_btn_cancel": "Annuler",
    "installer_btn_install": "Installer",
    "installer_btn_reinstall": "Réinstaller",
    "installer_btn_update": "Mettre à jour",
    "installer_btn_downgrade": "Rétrograder (non sécuritaire)",
    "installer_btn_dismiss": "Ignorer",
    "installer_btn_open": "Ouvrir l'app",
    "installer_btn_checkbox_shortcut": "Créer un raccourci sur le bureau",


    "android_permission_none": "Aucune autorisation requise",
    "android_permission_admin": "Gérer appareil en tant qu'administrateur",
    "android_permission_admin_brick": "Désactiver ou réinitialiser l'appareil",
    "android_permission_admin_lock": "Verrouiller l'appareil à distance",
    "android_permission_storage": "Fichiers et contenus multimédias",
    "android_permission_microphone": "Microphone",
    "android_permission_camera": "Caméra",
    "android_permission_location": "Localisation",
    "android_permission_phone": "Téléphone",
    "android_permission_call_log": "Journaux d'appels",
    "android_permission_sms": "Messages",
    "android_permission_contacts": "Contacts",
    "android_permission_calendar": "Calendrier",
    "android_permission_activity_recognition": "Activité physique",
    "android_permission_sensors": "Capteurs de l'appareil",
    "android_permission_sensors_body": "Capteurs corporels",
    "android_permission_nearby_devices": "Localiser appareils à proximité"
}

```

`locale/he.arb`:

```arb
{
    "@@README_1": "The en.arb file is a template for other files",
    "@@README_2": "For other languages, entries starting with @ and @@ are not needed, except @@locale",
    "@@README_3": "Country-specific locales (eg. 'en_GB') need a fallback locale (eg. 'en') to exist",


    "@@locale": "he",
    "@locale_desc": {"description": "Hebrew [he_IL]"},
    "locale_desc": "עברית",
    "locale_system": "מערכת",


    "btn_boot": "הפעל",
    "btn_switch_on": "פועל",
    "btn_switch_off": "כבוי",

    "status_subtext_winver_10": "Windows 10",
    "status_subtext_winver_older": "גרסת Windows ישנה יותר",


    "status_unsupported": "WSA לא מותקן",
    "status_unsupported_desc": "זוהתה מערכת הפעלה {windowsVersion} WSA ולא נמצא; תוכנה זו תלויה ב WSA, אשר נתמך רשמית רק ב-Windows 11.",
    "status_missing": "WSA לא מותקן",
    "status_missing_desc": "WSA לא נמצא; תוכנה זו תלויה ב-WSA, התקן את תת-המערכת של וינדוס עבור Android (לדוגמה מ-Microsoft Store)",
    "status_unknown": "מתחבר",
    "status_unknown_desc": "ממתין ליצירת חיבור עם WSA...",
    "status_starting": "מפעיל",
    "status_starting_desc": "מפעיל את WSA, אנא המתן...",
    "status_arrested": "נעצר",
    "status_arrested_desc": "WSA כבוי",
    "status_offline": "Offline",
    "status_offline_desc": "לא ניתן להתחבר אל WSA: מצב מפתח ואיתור באגים ב-USB מושבתים או שצויין Port שגוי",
    "status_disconnected": "מנותק",
    "status_disconnected_desc": "לא ניתן היה ליצור חיבור עם WSA מסיבה לא ידועה",
    "status_connected": "מחובר",
    "status_connected_desc": "מחובר בהצלחה ל-WSA, כל המערכות עוברות.",


    "screen_wsa": "WSA PacMan - מנהל חבילות ל-WSA",
    "screen_settings": "הגדרות",


    "wsa_manage": "ניהול הגדרות האנדרואיד",
    "wsa_manage_app": "נהל אפליקציות",
    "wsa_manage_settings": "נהל הגדרות",

    
    "settings_port": "WSA Port",
    "settings_ip": "כתובת ה-IP של ה-WSA",
    "settings_autostart": "הפעל אוטומטית את WSA לפני ההתקנה",
    "settings_language": "שפה",
    "settings_option_generic_system": "מערכת",
    "settings_option_generic_disabled": "כבוי",


    "theme_mode": "ערכת נושא",
    "theme_mode_dark": "כהה",
    "theme_mode_light": "בהיר",
    "theme_mica": "שקיפות חלון",
    "theme_mica_full": "מלא",
    "theme_mica_partial": "חלקי",
    "theme_icon_adaptive": "צורת אייקונים מותאמת",
    "theme_icon_adaptive_squircle": "Squircle (צורה בין ריבוע לעיגול)",
    "theme_icon_adaptive_circle": "עגול",
    "theme_icon_adaptive_rounded_square": "ריבוע עם פינות מעוגלות",


    "installer_message": "האם ברצונך להתקין את היישום הזה?",
    "installer_info_version": "גרסה: {appVersion}",
    "installer_info_version_change": "גרסה ישנה: {appVersionOld} גרסה חדשה: {appVersionNew}",
    "installer_info_package": "חתימה: {appPackage}",
    "installer_installing": "מתקין את האפליקציה {appTitle}...",
    "installer_installed": "האפליקציה {appTitle} הותקנה בהצלחה",
    "installer_fail": "האפליקציה {appTitle} לא הותקנה",
    "installer_error_nomsg": "ההתקנה נכשלה, אבל לא זוהתה השגיאה.",
    "installer_btn_starting": "WSA מפעיל את...",
    "installer_btn_loading": "טוען...",
    "installer_btn_cancel": "ביטול",
    "installer_btn_install": "התקן",
    "installer_btn_reinstall": "התקן מחדש",
    "installer_btn_update": "עדכון",
    "installer_btn_downgrade": "שדרוג גרסה לאחור (לא בטוח)",
    "installer_btn_dismiss": "סגור",
    "installer_btn_open": "פתח אפליקציה",
    "installer_btn_checkbox_shortcut": "צור קיצור דרך בשולחן העבודה",


    "android_permission_none": "אין צורך בהרשאות",
    "android_permission_admin": "נהל את המכשיר כמנהל",
    "android_permission_admin_brick": "השבת או אפס את המכשיר מרחוק",
    "android_permission_admin_lock": "נעל את המכשיר מרחוק",
    "android_permission_storage": "קבצים ומדיה",
    "android_permission_microphone": "מיקרופון",
    "android_permission_camera": "מצלמה",
    "android_permission_location": "מיקום",
    "android_permission_phone": "טלפון",
    "android_permission_call_log": "יומן שיחות",
    "android_permission_sms": "הודעות",
    "android_permission_contacts": "אנשי קשר",
    "android_permission_calendar": "לוח שנה",
    "android_permission_activity_recognition": "פעילות גופנית",
    "android_permission_sensors": "חיישני מכשיר",
    "android_permission_sensors_body": "חיישני גוף",
    "android_permission_nearby_devices": "אתר מכשירים קרובים"
}

```

`locale/id.arb`:

```arb
{
    "@@README_1": "The en.arb file is a template for other files",
    "@@README_2": "For other languages, entries starting with @ and @@ are not needed, except @@locale",
    "@@README_3": "Country-specific locales (eg. 'en_GB') need a fallback locale (eg. 'en') to exist",


    "@@locale": "id",
    "@locale_desc": {"description": "Bahasa Indonesia (Indonesian) [id_ID]"},
    "locale_desc": "Bahasa Indonesia",
    "@locale_system": {"description": "Menjelaskan lokal sistem"},
    "locale_system": "Sistem",


    "btn_boot": "Nyalakan",
    "btn_switch_on": "Nyala",
    "btn_switch_off": "Mati",


    "@status_subtext_winver_10": {"description": "Hanya digunakan di dalam 'status_unsupported_desc', modifikasi dengan mempertimbangkan ini"},
    "status_subtext_winver_10": "Windows 10",
    "@status_subtext_winver_older": {"description": "Hanya digunakan di dalam 'status_unsupported_desc', modifikasi dengan mempertimbangkan ini"},
    "status_subtext_winver_older": "Versi Lama Windows",


    "status_unsupported": "WSA belum terinstal",
    "status_unsupported_desc": "{windowsVersion} terdeteksi dan WSA tidak ditemukan; aplikasi ini tergantung pada WSA, yang hanya didukung secara resmi di Windows 11",
    "@status_unsupported_desc" : {"placeholders": {"windowsVersion": {"type": "String"}}},
    "status_missing": "WSA tidak ditemukan",
    "status_missing_desc": "WSA tidak ditemukan; aplikasi ini bergantung pada WSA, silakan instal Subsistem Windows untuk Android (atau Amazon Appstore) dari Microsoft Store",
    "status_unknown": "Menghubungkan",
    "status_unknown_desc": "Menunggu koneksi WSA dibuat...",
    "status_starting": "Memulai",
    "status_starting_desc": "WSA dimulai, harap bersiap-siap...",
    "status_arrested": "Ditangkap",
    "status_arrested_desc": "WSA dimatikan",
    "status_offline": "Luring",
    "status_offline_desc": "Tidak dapat membuat koneksi dengan WSA: mode pengembang dan debugging USB dinonaktifkan atau port yang salah ditentukan",
    "status_disconnected": "Terputus",
    "status_disconnected_desc": "Koneksi WSA tidak dapat dibuat karena alasan yang tidak diketahui",
    "status_connected": "Terhubung",
    "status_connected_desc": "Berhasil terhubung ke WSA, semua sistem berjalan",


    "screen_wsa": "Manajer Paket WSA",
    "screen_settings": "Pengaturan",


    "wsa_manage": "Manajemen Android",
    "wsa_manage_app": "Kelola Aplikasi",
    "wsa_manage_settings": "Kelola Pengaturan",

    
    "settings_port": "Port WSA",
    "settings_ip": "Alamat IP WSA",
    "settings_autostart": "Otomatis mulai WSA sebelum instalasi",
    "settings_language": "Bahasa",
    "settings_option_generic_system": "Sistem",
    "settings_option_generic_disabled": "Dimatikan",


    "theme_mode": "Mode tema",
    "theme_mode_dark": "Gelap",
    "theme_mode_light": "Terang",
    "theme_mica": "Transparan Windows",
    "theme_mica_full": "Penuh",
    "theme_mica_partial": "Sebagian",
    "theme_icon_adaptive": "Ikon adaptif Bentuk",
    "theme_icon_adaptive_squircle": "Kerucut",
    "theme_icon_adaptive_circle": "Lingkaran",
    "theme_icon_adaptive_rounded_square": "Persegi Bulat",


    "installer_message": "Apakah Anda ingin menginstal aplikasi ini?",
    "installer_info_version": "Versi: {appVersion}",
    "@installer_info_version" : {"placeholders": {"appVersion": {"type": "String"}}},
    "installer_info_version_change": "Versi: {appVersionOld} => {appVersionNew}",
    "@installer_info_version_change" : {"placeholders": {"appVersionOld": {"type": "String"}, "appVersionNew": {"type": "String"}}},
    "installer_info_package": "Paket: {appPackage}",
    "@installer_info_package" : {"placeholders": {"appPackage": {"type": "String"}}},
    "installer_installing": "Menginstal aplikasi {appTitle}...",
    "@installer_installing" : {"placeholders": {"appTitle": {"type": "String"}}},
    "installer_installed": "Aplikasi {appTitle} berhasil diinstal",
    "@installer_installed" : {"placeholders": {"appTitle": {"type": "String"}}},
    "installer_fail": "Aplikasi {appTitle} tidak dipasang",
    "@installer_fail" : {"placeholders": {"appTitle": {"type": "String"}}},
    "installer_error_nomsg": "Instalasi telah gagal, tetapi tidak ada kesalahan yang terjadi",
    "installer_btn_starting": "Memulai...",
    "installer_btn_loading": "Memuat...",
    "installer_btn_cancel": "Batal",
    "installer_btn_install": "Instal",
    "installer_btn_reinstall": "Instal ulang",
    "installer_btn_update": "Perbarui",
    "installer_btn_downgrade": "Turunkan versi (tidak aman)",
    "installer_btn_dismiss": "Memberhentikan",
    "installer_btn_open": "Buka aplikasi",
    "installer_btn_checkbox_shortcut": "Buat pintasan desktop",


    "android_permission_none": "Tidak diperlukan izin",
    "android_permission_admin": "Atur perangkat sebagai administrator",
    "android_permission_admin_brick": "Nonaktifkan atau setel ulang perangkat dari jarak jauh",
    "android_permission_admin_lock": "Mengunci perangkat dari jarak jauh",
    "android_permission_storage": "File dan media",
    "android_permission_microphone": "Mikropon",
    "android_permission_camera": "Kamera",
    "android_permission_location": "Lokasi",
    "android_permission_phone": "Telepon",
    "android_permission_call_log": "Log panggilan",
    "android_permission_sms": "Pesan",
    "android_permission_contacts": "Kontak",
    "android_permission_calendar": "Kalender",
    "android_permission_activity_recognition": "Aktivitas fisik",
    "android_permission_sensors": "Sensor perangkat",
    "android_permission_sensors_body": "Sensor tubuh",
    "android_permission_nearby_devices": "Temukan perangkat terdekat"
}

```

`locale/it.arb`:

```arb
{
    "@@locale": "it",
    "@locale_desc": {"description": "Italian (Italia) [it_IT]"},
    "locale_desc": "Italiano",
    "locale_system": "Sistema",


    "btn_boot": "Avvia",
    "btn_switch_on": "On",
    "btn_switch_off": "Off",


    "status_subtext_winver_10": "rilevato Windows 10",
    "status_subtext_winver_older": "rilevata una vecchia versione di Windows",


    "status_unsupported": "WSA non installato",
    "status_unsupported_desc": "WSA non trovato e {windowsVersion}; l'applicazione necessita WSA, che è ufficialmente supportato soltanto su Windows 11",
    "status_missing": "WSA non installato",
    "status_missing_desc": "WSA non trovato; l'applicazione necessita WSA, per favore installa il Sottosistema Windows per Android (o l'Amazon Appstore) dallo Store di Microsoft",
    "status_unknown": "Connessione",
    "status_unknown_desc": "In attesa di una connessione con WSA...",
    "status_starting": "Avvio",
    "status_starting_desc": "WSA è in fase di avvio, per favore attendi...",
    "status_arrested": "Arrestato",
    "status_arrested_desc": "WSA è spento",
    "status_offline": "Offline",
    "status_offline_desc": "Non è stato possibile connettersi a WSA: controlla che la modalità sviluppatore e il debug USB siano attivi, e di aver specificato la porta corretta",
    "status_disconnected": "Disconnesso",
    "status_disconnected_desc": "Non è stato possibile connettersi a WSA per ragioni sconosciute",
    "status_connected": "Connesso",
    "status_connected_desc": "Connesso correttamente a WSA, applicazione pronta",


    "screen_wsa": "WSA Package Manager",
    "screen_settings": "Impostazioni",


    "wsa_manage": "Gestione Android",
    "wsa_manage_app": "Gestione Applicazioni",
    "wsa_manage_settings": "Gestione Impostazioni",


    "settings_port": "Porta WSA",
    "settings_ip": "Indirizzo IP WSA",
    "settings_autostart": "Avvia WSA automaticamente prima di un'installazione",
    "settings_language": "Lingua",
    "settings_option_generic_system": "Sistema",
    "settings_option_generic_disabled": "Disabilitato",


    "theme_mode": "Modalità tema",
    "theme_mode_dark": "Scuro",
    "theme_mode_light": "Chiaro",
    "theme_mica": "Trasparenza finestra",
    "theme_mica_full": "Completa",
    "theme_mica_partial": "Parziale",
    "theme_icon_adaptive": "Forma icone adattive",
    "theme_icon_adaptive_squircle": "Supercerchio",
    "theme_icon_adaptive_circle": "Cerchio",
    "theme_icon_adaptive_rounded_square": "Quadrato arrotondato",


    "installer_message": "Vuoi installare questa applicazione?",
    "installer_info_version": "Versione: {appVersion}",
    "installer_info_version_change": "Versione: {appVersionOld} => {appVersionNew}",
    "installer_info_package": "Pacchetto: {appPackage}",
    "installer_installing": "Installazione di {appTitle} in corso...",
    "installer_installed": "Applicazione {appTitle} installata correttamente",
    "installer_fail": "L'applicazione {appTitle} non è stata installata",
    "installer_error_nomsg": "Installazione fallita senza lanciare alcun errore",
    "installer_btn_starting": "Avvio...",
    "installer_btn_loading": "Caricamento...",
    "installer_btn_cancel": "Annulla",
    "installer_btn_install": "Installa",
    "installer_btn_reinstall": "Reinstalla",
    "installer_btn_update": "Aggiorna",
    "installer_btn_downgrade": "Downgrade (non sicuro)",
    "installer_btn_dismiss": "Termina",
    "installer_btn_open": "Apri l'app",
    "installer_btn_checkbox_shortcut": "Aggiungi icona sul desktop",


    "android_permission_none": "Nessun permesso necessario",
    "android_permission_admin": "Gestisci dispositivo come amministratore",
    "android_permission_admin_brick": "Disabilita o ripristina dispositivo a distanza",
    "android_permission_admin_lock": "Blocca dispositivo a distanza",
    "android_permission_storage": "File e contenuti multimediali",
    "android_permission_microphone": "Microfono",
    "android_permission_camera": "Camera",
    "android_permission_location": "Posizione",
    "android_permission_phone": "Telefono",
    "android_permission_call_log": "Registri chiamate",
    "android_permission_sms": "Messaggi",
    "android_permission_contacts": "Contatti",
    "android_permission_calendar": "Calendario",
    "android_permission_activity_recognition": "Attività fisica",
    "android_permission_sensors": "Sensori del dispositivo",
    "android_permission_sensors_body": "Sensori corporei",
    "android_permission_nearby_devices": "Localizza dispositivi vicini"
}
```

`locale/ja.arb`:

```arb
{
    "@@locale": "ja",
    "@locale_desc": {"description": "Japanese [ja_JP]"},
    "locale_desc": "日本語",
    "@locale_system": {"description": "システム ロケールを記述します"},
    "locale_system": "システム",


    "btn_boot": "オンにする",
    "btn_switch_on": "オン",
    "btn_switch_off": "オフ",


    "status_subtext_winver_10": "Windows 10",
    "status_subtext_winver_older": "古い Windows のバージョン",


    "status_unsupported": "WSA がインストールされていません。",
    "status_unsupported_desc": "{windowsVersion} を使用しています。Windows にWSA がインストールされていません。このアプリケーションを使用するには WSA が必要で、Windows 11 のみ正式にサポートされています。",
    "status_missing": "WSA がインストールされていません。",
    "status_missing_desc": "WSA が見つかりません。このアプリケーションを使用するにはWSAが必要です。Microsoft StoreからAndroid™️ 用 Windows サブシステムをインストールしてください。",
    "status_unknown": "接続中",
    "status_unknown_desc": "WSA との接続が確立されるのを待っています...",
    "status_starting": "起動中",
    "status_starting_desc": "WSA が起動しています。しばらくお待ちください...",
    "status_arrested": "停止",
    "status_arrested_desc": "WSA が停止しています。",
    "status_offline": "オフライン",
    "status_offline_desc": "WSA の接続を確立できませんでした: 開発者モードや USB デバッグが無効になっているか、間違ったポートが指定されています。",
    "status_disconnected": "切断",
    "status_disconnected_desc": "WSA の接続が不明な理由で確率できませんでした。",
    "status_connected": "接続完了",
    "status_connected_desc": "WSA の接続ができました。現在、待機中です。",


    "screen_wsa": "WSA Package Manager",
    "screen_settings": "設定",


    "wsa_manage": "Android の管理",
    "wsa_manage_app": "WSA のアプリケーション設定を開く",
    "wsa_manage_settings": "WSA の設定を開く",

    
    "settings_port": "WSA ポート",
    "settings_ip": "WSA IP アドレス",
    "settings_autostart": "インストール前に WSA を自動起動する",
    "settings_language": "言語",
    "settings_option_generic_system": "システム",
    "settings_option_generic_disabled": "非アクティブ",


    "theme_mode": "テーマモード",
    "theme_mode_dark": "ダーク",
    "theme_mode_light": "ライト",
    "theme_mica": "ウィンドウの透明度",
    "theme_mica_full": "全体",
    "theme_mica_partial": "一部",
    "theme_icon_adaptive": "アダプティブアイコンのスタイル",
    "theme_icon_adaptive_squircle": "半円",
    "theme_icon_adaptive_circle": "円",
    "theme_icon_adaptive_rounded_square": "丸み正方形",


    "installer_message": "このアプリケーションをインストールしますか?",
    "installer_info_version": "バージョン: {appVersion}",
    "installer_info_version_change": "バージョン: {appVersionOld} ⇒ {appVersionNew}",
    "installer_info_package": "パッケージ: {appPackage}",
    "installer_installing": "アプリ「{appTitle}」をインストールしています...",
    "installer_installed": "アプリ「{appTitle}」がインストールされました。",
    "installer_fail": "アプリ「{appTitle}」をインストールできませんでした。",
    "installer_error_nomsg": "インストールに失敗しました。",
    "installer_btn_starting": "起動中です...",
    "installer_btn_loading": "読み込んでいます...",
    "installer_btn_cancel": "キャンセル",
    "installer_btn_install": "インストール",
    "installer_btn_reinstall": "再インストール",
    "installer_btn_update": "アップデート",
    "installer_btn_downgrade": "ダウングレード(非推奨)",
    "installer_btn_dismiss": "閉じる",
    "installer_btn_open": "アプリを開く",
    "installer_btn_checkbox_shortcut": "デスクトップにショートカットを作成する",


    "android_permission_none": "権限は必要ありません",
    "android_permission_admin": "管理者としてデバイスを管理",
    "android_permission_admin_brick": "デバイスをリモートで無効にする",
    "android_permission_admin_lock": "デバイスをリモートでロックする",
    "android_permission_storage": "ファイルとメディア",
    "android_permission_microphone": "マイク",
    "android_permission_camera": "カメラ",
    "android_permission_location": "位置情報",
    "android_permission_phone": "電話",
    "android_permission_call_log": "通話ログ",
    "android_permission_sms": "メッセージ",
    "android_permission_contacts": "連絡先",
    "android_permission_calendar": "カレンダー",
    "android_permission_activity_recognition": "身体活動",
    "android_permission_sensors": "デバイスセンサー",
    "android_permission_sensors_body": "ボディセンサー",
    "android_permission_nearby_devices": "近くのデバイスを探す"
}

```

`locale/ko.arb`:

```arb
{
    "@@README_1": "The en.arb file is a template for other files",
    "@@README_2": "For other languages, entries starting with @ and @@ are not needed, except @@locale",
    "@@README_3": "Country-specific locales (eg. 'en_GB') need a fallback locale (eg. 'en') to exist",


    "@@locale": "ko",
    "@locale_desc": {"description": "Korean [ko_KR]"},
    "locale_desc": "한국어",
    "@locale_system": {"description": "시스템 언어를 지칭합니다"},
    "locale_system": "시스템",


    "btn_boot": "켜기",
    "btn_switch_on": "켬",
    "btn_switch_off": "끔",
    

    "status_subtext_winver_10": "Windows 10",
    "status_subtext_winver_older": "구형 Windows",


    "status_unsupported": "WSA가 설치되지 않음",
    "status_unsupported_desc": "운영 체제가 {windowsVersion}인 것으로 보이며 WSA를 찾을 수 없습니다. 본 프로그램은 WSA에 종속되어 있으며, Windows 11에서만 이용할 수 있습니다.",
    "status_missing": "WSA가 설치되지 않음",
    "status_missing_desc": "WSA를 찾을 수 없습니다. 본 프로그램은 WSA에 종속되어 있으므로, Microsoft Store에서 Windows Subsystem for Android (또는 Amazon 앱스토어)를 설치하십시오.",
    "status_unknown": "연결 중",
    "status_unknown_desc": "WSA에 연결되기를 기다리고 있습니다...",
    "status_starting": "시작 중",
    "status_starting_desc": "WSA를 시작하고 있습니다, 잠시 기다려주십시오...",
    "status_arrested": "정지됨",
    "status_arrested_desc": "WSA가 꺼졌습니다",
    "status_offline": "오프라인",
    "status_offline_desc": "WSA에 연결할 수 없습니다: 개발자 모드 및 USB 디버깅이 꺼져 있거나 포트가 잘못 지정되었습니다",
    "status_disconnected": "연결 끊김",
    "status_disconnected_desc": "알 수 없는 이유로 WSA에 연결할 수 없습니다",
    "status_connected": "연결됨",
    "status_connected_desc": "WSA에 성공적으로 연결했으며, 모든 시스템이 구동되고 있습니다",


    "screen_wsa": "WSA 패키지 관리자",
    "screen_settings": "설정",


    "wsa_manage": "Android 관리",
    "wsa_manage_app": "애플리케이션 관리",
    "wsa_manage_settings": "설정 관리",

    
    "settings_port": "WSA 포트",
    "settings_ip": "WSA IP 주소",
    "settings_autostart": "설치 전 WSA 자동 실행",
    "settings_language": "언어",
    "settings_option_generic_system": "시스템",
    "settings_option_generic_disabled": "꺼짐",


    "theme_mode": "테마",
    "theme_mode_dark": "어둡게",
    "theme_mode_light": "밝게",
    "theme_mica": "투명 창",
    "theme_mica_full": "전체",
    "theme_mica_partial": "일부",
    "theme_icon_adaptive": "적응형 아이콘 모양",
    "theme_icon_adaptive_squircle": "스퀘어클",
    "theme_icon_adaptive_circle": "원형",
    "theme_icon_adaptive_rounded_square": "모서리가 둥근 사각형",


    "installer_message": "이 애플리케이션을 설치하시겠습니까?",
    "installer_info_version": "버전: {appVersion}",
    "installer_info_version_change": "버전: {appVersionOld} => {appVersionNew}",
    "installer_info_package": "패키지: {appPackage}",
    "installer_installing": "{appTitle} 앱을 설치하고 있습니다...",
    "installer_installed": "{appTitle} 앱이 성공적으로 설치되었습니다",
    "installer_fail": "{appTitle} 앱이 설치되지 않았습니다",
    "installer_error_nomsg": "설치에 실패하였으나, 오류를 확인할 수 없습니다",
    "installer_btn_starting": "시작하는 중...",
    "installer_btn_loading": "불러오는 중...",
    "installer_btn_cancel": "취소",
    "installer_btn_install": "설치",
    "installer_btn_reinstall": "재설치",
    "installer_btn_update": "업데이트",
    "installer_btn_downgrade": "다운그레이드 (불안정)",
    "installer_btn_dismiss": "다시는 알리지 않음",
    "installer_btn_open": "앱 열기",
    "installer_btn_checkbox_shortcut": "바탕화면 바로가기 생성",


    "android_permission_none": "권한 필요 없음",
    "android_permission_admin": "관리자 권한으로 기기 관리",
    "android_permission_admin_brick": "기기 원격 비활성화 및 초기화",
    "android_permission_admin_lock": "기기 원격 잠금",
    "android_permission_storage": "파일 및 미디어",
    "android_permission_microphone": "마이크",
    "android_permission_camera": "카메라",
    "android_permission_location": "위치",
    "android_permission_phone": "전화",
    "android_permission_call_log": "통화 기록",
    "android_permission_sms": "메시지",
    "android_permission_contacts": "주소록",
    "android_permission_calendar": "일정",
    "android_permission_activity_recognition": "신체 활동",
    "android_permission_sensors": "기기 센서",
    "android_permission_sensors_body": "신체 센서",
    "android_permission_nearby_devices": "근처 장치 찾기"
}

```

`locale/pl.arb`:

```arb
{
    "@@locale": "pl",
    "@locale_desc": {"description": "Polish (PL) [pl_PL]"},
    "locale_desc": "Polski",
    "locale_system": "Systemowy",


    "btn_boot": "Włącz",
    "btn_switch_on": "Wł.",
    "btn_switch_off": "Wył.",

    
    "status_subtext_winver_10": "Windows 10",
    "status_subtext_winver_older": "Starsza wersja systemu Windows",


    "status_unsupported": "WSA nie jest zainstalowany",
    "status_unsupported_desc": "Wykryto {windowsVersion} i nie znaleziono WSA; ta aplikacja jest zależna od WSA, który jest oficjalnie wspierany tylko w systemie Windows 11",
    "status_missing": "WSA nie jest zainstalowany",
    "status_missing_desc": "Nie znaleziono WSA; ta aplikacja jest zależna od WSA, zainstaluj Podsystem Windows dla systemu Android (lub Amazon Appstore) ze sklepu Microsoft Store",
    "status_unknown": "Łączenie",
    "status_unknown_desc": "Oczekiwanie na nawiązanie połączenia z WSA...",
    "status_starting": "Uruchamianie",
    "status_starting_desc": "WSA uruchamia się, proszę czekać...",
    "status_arrested": "Zatrzymany",
    "status_arrested_desc": "WSA jest wyłączony",
    "status_offline": "Offline",
    "status_offline_desc": "Nie można nawiązać połączenia z WSA: tryb programisty i debugowanie USB są wyłączone lub podano niewłaściwy port",
    "status_disconnected": "Odłączony",
    "status_disconnected_desc": "Z nieznanych przyczyn nie udało się nawiązać połączenia z WSA",
    "status_connected": "Połączony",
    "status_connected_desc": "Pomyślnie połączono z WSA, wszystkie systemy działają",


    "screen_wsa": "Menedżer pakietów WSA",
    "screen_settings": "Ustawienia",


    "wsa_manage": "Zarządzanie Androidem",
    "wsa_manage_app": "Aplikacje",
    "wsa_manage_settings": "Ustawienia",

    
    "settings_port": "Port WSA",
    "settings_ip": "Adres IP WSA",
    "settings_autostart": "Autostart WSA przed instalacją",
    "settings_language": "Język",
    "settings_option_generic_system": "Systemowy",
    "settings_option_generic_disabled": "Wyłączone",


    "theme_mode": "Motyw",
    "theme_mode_dark": "Ciemny",
    "theme_mode_light": "Jasny",
    "theme_mica": "Przezroczystość okna",
    "theme_mica_full": "Pełna",
    "theme_mica_partial": "Częściowa",
    "theme_icon_adaptive": "Adaptacyjny kształt ikon",
    "theme_icon_adaptive_squircle": "Domyślny",
    "theme_icon_adaptive_circle": "Okrągły",
    "theme_icon_adaptive_rounded_square": "Zaokrąglony kwadrat",


    "installer_message": "Czy chcesz zainstalować tą aplikację?",
    "installer_info_version": "Wersja: {appVersion}",
    "installer_info_version_change": "Wersja: {appVersionOld} => {appVersionNew}",
    "installer_info_package": "Pakiet: {appPackage}",
    "installer_installing": "Instalowanie aplikacji {appTitle}...",
    "installer_installed": "Aplikacja {appTitle} została pomyślnie zainstalowana",
    "installer_fail": "Aplikacja {appTitle} nie została zainstalowana",
    "installer_error_nomsg": "Instalacja nie powiodła się, ale nie zgłoszono żadnego błędu",
    "installer_btn_starting": "Rozpoczynanie...",
    "installer_btn_loading": "Wczytywanie...",
    "installer_btn_cancel": "Anuluj",
    "installer_btn_install": "Zainstaluj",
    "installer_btn_reinstall": "Zainstaluj ponownie",
    "installer_btn_update": "Aktualizuj",
    "installer_btn_downgrade": "Downgrade (niebezpieczny)",
    "installer_btn_dismiss": "Gotowe",
    "installer_btn_open": "Otwórz",
    "installer_btn_checkbox_shortcut": "Utwórz skrót na pulpicie",


    "android_permission_none": "Nie wymaga żadnych uprawnień",
    "android_permission_admin": "Zarządzanie urządzeniem jako administrator",
    "android_permission_admin_brick": "Zdalne wyłączenie lub reset urządzenia",
    "android_permission_admin_lock": "Zdalne zablokowanie urządzenia",
    "android_permission_storage": "Pliki i multimedia",
    "android_permission_microphone": "Mikrofon",
    "android_permission_camera": "Aparat",
    "android_permission_location": "Lokalizacja",
    "android_permission_phone": "Telefon",
    "android_permission_call_log": "Rejestry połączeń",
    "android_permission_sms": "Wiadomości",
    "android_permission_contacts": "Kontakty",
    "android_permission_calendar": "Kalendarz",
    "android_permission_activity_recognition": "Aktywność fizyczna",
    "android_permission_sensors": "Czujniki urządzenia",
    "android_permission_sensors_body": "Czujniki na ciele",
    "android_permission_nearby_devices": "Wykrywanie urządzeń w pobliżu"
}

```

`locale/pt.arb`:

```arb
{
    "@@locale": "pt",
    "@locale_desc": {"description": "Portuguese (Brasil) [pt_BR]"},
    "locale_desc": "Português (Brasil)",
    "locale_system": "Sistema",


    "btn_boot": "Ativar",
    "btn_switch_on": "Lig",
    "btn_switch_off": "Desl",


    "status_subtext_winver_10": "Windows 10",
    "status_subtext_winver_older": "Versão antiga do Windows",


    "status_unsupported": "WSA não instalado",
    "status_unsupported_desc": "{windowsVersion} detectado e WSA não encontrado. Este aplicativo depende do WSA, que é suportado oficialmente no Windows 11",
    "status_missing": "WSA não instalado",
    "status_missing_desc": "WSA não encontrado. Este aplicativo depende do WSA, instale o Windows Subsystem for Android (ou Amazon Appstore) da Microsoft Store",
    "status_unknown": "Conectando",
    "status_unknown_desc": "Aguardando que uma conexão WSA seja estabelecida...",
    "status_starting": "Iniciando",
    "status_starting_desc": "WSA iniciando, aguarde...",
    "status_arrested": "Suspenso",
    "status_arrested_desc": "WSA está desativado",
    "status_offline": "Offline",
    "status_offline_desc": "Não foi estabelecer uma conexão com o WSA. O modo de desenvolvedor e a depuração USB estão desabilitados ou uma porta errada foi especificada",
    "status_disconnected": "Desconectado",
    "status_disconnected_desc": "Uma conexão WSA não pôde ser estabelecido por razões desconhecidas",
    "status_connected": "Conectado",
    "status_connected_desc": "Conectado com sucesso no WSA, todos os sistemas ativos",


    "screen_wsa": "Gerenciador de pacotes WSA ",
    "screen_settings": "Configurações",


    "wsa_manage": "Gerenciamento do Android",
    "wsa_manage_app": "Gerenciar aplicativos",
    "wsa_manage_settings": "Gerenciar configurações",


    "settings_port": "Porta da WSA",
    "settings_ip": "Endereço IP do WSA",
    "settings_autostart": "Iniciar WSA antes da instalação",
    "settings_language": "Idioma",
    "settings_option_generic_system": "Sistema",
    "settings_option_generic_disabled": "Desativado",


    "theme_mode": "Tema",
    "theme_mode_dark": "Escuro",
    "theme_mode_light": "Claro",
    "theme_mica": "Transparência da janela",
    "theme_mica_full": "Cheia",
    "theme_mica_partial": "Parcial",
    "theme_icon_adaptive": "Forma de ícones adaptáveis",
    "theme_icon_adaptive_squircle": "Quadrado-círculo",
    "theme_icon_adaptive_circle": "Círculo",
    "theme_icon_adaptive_rounded_square": "Quadrado arredondado",


    "installer_message": "Deseja instalar este aplicativo?",
    "installer_info_version": "Versão: {appVersion}",
    "installer_info_version_change": "Versão: {appVersionOld} => {appVersionNew}",
    "installer_info_package": "Pacote: {appPackage}",
    "installer_installing": "Instalando aplicativo {appTitle}...",
    "installer_installed": "O aplicativo {appTitle} foi instalado com sucesso",
    "installer_fail": "O aplicativo {appTitle} não foi instalado",
    "installer_error_nomsg": "A instalação falhou, mas nenhum erro foi emitido",
    "installer_btn_starting": "Iniciando...",
    "installer_btn_loading": "Carregando...",
    "installer_btn_cancel": "Cancelar",
    "installer_btn_install": "Instalar",
    "installer_btn_reinstall": "Reinstalar",
    "installer_btn_update": "Atualizar",
    "installer_btn_downgrade": "Downgrade (não seguro)",
    "installer_btn_dismiss": "Dispensar",
    "installer_btn_open": "Abrir aplicativo",
    "installer_btn_checkbox_shortcut": "Criar ícone na Área de Trabalho",


    "android_permission_none": "Nenhuma permissão necessária",
    "android_permission_admin": "Gerenciar dispositivo como administrador",
    "android_permission_admin_brick": "Desativar ou redefinir dispositivo remotamente",
    "android_permission_admin_lock": "Bloquear dispositivo remotamente",
    "android_permission_storage": "Arquivos e mídia",
    "android_permission_microphone": "Microfone",
    "android_permission_camera": "Câmera",
    "android_permission_location": "Local",
    "android_permission_phone": "Telefone",
    "android_permission_call_log": "Registro de chamadas",
    "android_permission_sms": "Mensagens",
    "android_permission_contacts": "Contatos",
    "android_permission_calendar": "Calendário",
    "android_permission_activity_recognition": "Atividade física",
    "android_permission_sensors": "Sensores do dispositivo",
    "android_permission_sensors_body": "Sensores corporais",
    "android_permission_nearby_devices": "Localizar dispositivos próximos"
}

```

`locale/ru.arb`:

```arb
{
    "@@locale": "ru",
    "@locale_desc": {"description": "Russian [ru_RU]"},
    "locale_desc": "Русский",
    "locale_system": "Как в системе",


    "btn_boot": "Запустить",
    "btn_switch_on": "Вкл.",
    "btn_switch_off": "Выкл.",


    "status_subtext_winver_10": "Windows 10",
    "status_subtext_winver_older": "Устаревшая версия Windows",


    "status_unsupported": "Подсистема Windows под Android не поддерживается",
    "status_unsupported_desc": "{windowsVersion} detected and WSA not found; this application depends on WSA, which is only officially supported on Windows 11",
    "status_missing": "Подсистема Windows под Android не установлена",
    "status_missing_desc": "Подсистема Windows под Android не найдена: это приложение зависит от WSA, установите подсистему Windows для Android (или Магазин приложений Amazon) из магазина Microsoft Store",
    "status_unknown": "Подключение",
    "status_unknown_desc": "Ожидание соединения с подсистема Windows под Android",
    "status_starting": "Запуск",
    "status_starting_desc": "Подсистема Windows под Android запускается, подождите...",
    "status_arrested": "Удержано",
    "status_arrested_desc": "Подсистема Windows под Android выключена",
    "status_offline": "Не в сети",
    "status_offline_desc": "Не удалось установить соединение с WSA: либо режим разработчика и отладка по USB отключены, либо указан неверный порт",
    "status_disconnected": "Отсоединен",
    "status_disconnected_desc": "Соединение с подсистемой Windows под Android не удалось установить по неизвестным причинам",
    "status_connected": "Подключено",
    "status_connected_desc": "Успешно подключено к подсистеме Windows под Android, все службы запущены",


    "screen_wsa": "Менеджер пакетов для подсистемы Windows под Android",
    "screen_settings": "Настройки",


    "wsa_manage": "Управление системой Android",
    "wsa_manage_app": "Управление приложениями",
    "wsa_manage_settings": "Управление настройками системы",

    
    "settings_port": "Порт",
    "settings_ip": "IP-адрес",
    "settings_autostart": "Автоматически запускать подсистему Windows под Android перед установкой",
    "settings_language": "Язык",
    "settings_option_generic_system": "Как в системе",
    "settings_option_generic_disabled": "Отключено",


    "theme_mode": "Тема интерфейса",
    "theme_mode_dark": "Темная",
    "theme_mode_light": "Светлая",
    "theme_mica": "Прозрачность окна",
    "theme_mica_full": "Полная",
    "theme_mica_partial": "Частичная",
    "theme_icon_adaptive": "Форма адаптивных значков",
    "theme_icon_adaptive_squircle": "Квадратокружность",
    "theme_icon_adaptive_circle": "Кружок",
    "theme_icon_adaptive_rounded_square": "Скругленный квадрат",


    "installer_message": "Вы хотите установить это приложение?",
    "installer_info_version": "Версия: {appVersion}",
    "installer_info_version_change": "Версия: {appVersionOld} => {appVersionNew}",
    "installer_info_package": "Имя пакета: {appPackage}",
    "installer_installing": "Установка приложения {appTitle}...",
    "installer_installed": "Приложение {appTitle} было успешно установлено",
    "installer_fail": "Приложение {appTitle} не было установлено",
    "installer_error_nomsg": "Установка не удалась, но ошибок не было обнаружено",
    "installer_btn_starting": "Запуск...",
    "installer_btn_loading": "Загрузка...",
    "installer_btn_cancel": "Отмена",
    "installer_btn_install": "Установить",
    "installer_btn_reinstall": "Переустановить",
    "installer_btn_update": "Обновить",
    "installer_btn_downgrade": "Понизить версию (не безопасно)",
    "installer_btn_dismiss": "Отклонить",
    "installer_btn_open": "Открыть приложение",
    "installer_btn_checkbox_shortcut": "Создать ярлык на рабочем столе",


    "android_permission_none": "Разрешения не требуются",
    "android_permission_admin": "Управлять устройством как администратор",
    "android_permission_admin_brick": "Удаленно отключить или перезагрузить устройство",
    "android_permission_admin_lock": "Удаленно блокировать устройство",
    "android_permission_storage": "Файлы и медиаконтент",
    "android_permission_microphone": "Микрофон",
    "android_permission_camera": "Камера",
    "android_permission_location": "Местоположение",
    "android_permission_phone": "Телефон",
    "android_permission_call_log": "Список вызовов",
    "android_permission_sms": "Сообщения",
    "android_permission_contacts": "Контакты",
    "android_permission_calendar": "Календарь",
    "android_permission_activity_recognition": "Физическая активность",
    "android_permission_sensors": "Датчики устройства",
    "android_permission_sensors_body": "Датчики на теле",
    "android_permission_nearby_devices": "Устройства поблизости"
}

```

`locale/zh-Hant.arb`:

```arb
{
    "@@README_1": "The en.arb file is a template for other files",
    "@@README_2": "For other languages, entries starting with @ and @@ are not needed, except @@locale",
    "@@README_3": "Country-specific locales (eg. 'en_GB') need a fallback locale (eg. 'en') to exist",


    "@@locale": "zh_Hant",
    "@locale_desc": {"description": "Chinese (traditional) [zh_TW] < [zh_Hant]"},
    "locale_desc": "中文 (繁體)",
    "@locale_system": {"description": "描述系統區域設定"},
    "locale_system": "系統",


    "btn_boot": "啟動",
    "btn_switch_on": "開",
    "btn_switch_off": "關",


    "@status_subtext_winver_10": {"description": "Only used inside 'status_unsupported_desc', modify taking this in consideration"},
    "status_subtext_winver_10": "Windows 10",
    "@status_subtext_winver_older": {"description": "Only used inside 'status_unsupported_desc', modify taking this in consideration"},
    "status_subtext_winver_older": "舊 Windows 版本",


    "status_unsupported": "尚未安裝 WSA ",
    "status_unsupported_desc": "檢測到 {windowsVersion} 但未找到 Android 子系統；此應用程式僅在 Windows 11 正式支援。",
    "@status_unsupported_desc" : {"placeholders": {"windowsVersion": {"type": "String"}}},
    "status_missing": "未安裝 Android 子系統",
    "status_missing_desc": "未找到 Android 子系統；請從 Microsoft Store 安裝適用於 Windows 的 Android 子系統（或 Amazon Appstore）。",
    "status_unknown": "正在連接",
    "status_unknown_desc": "正在等待建立 WSA 連接...",
    "status_starting": "正在啟動",
    "status_starting_desc": "WSA 正在啟動，請稍候...",
    "status_arrested": "已停滯",
    "status_arrested_desc": "WSA 已關閉",
    "status_offline": "離線",
    "status_offline_desc": "無法與 Android 子系統建立連接：可能的原因是未開啟開發者模式或 USB 調試被關閉或被指定了錯誤的端口。",
    "status_disconnected": "已斷開連接",
    "status_disconnected_desc": "由於未知原因，無法建立 WSA 連線",
    "status_connected": "已連接",
    "status_connected_desc": "成功連接到 WSA，所有系統正常執行",


    "screen_wsa": "WSA 包管理器",
    "screen_settings": "設定",


    "wsa_manage": "Android 管理",
    "wsa_manage_app": "管理應用程式",
    "wsa_manage_settings": "管理設定",

    
    "settings_port": "WSA 端口",
    "settings_ip": "WSA 的 IP 位址",
    "settings_autostart": "在安裝之前自動啟動 WSA",
    "settings_language": "語言",
    "settings_option_generic_system": "系統",
    "settings_option_generic_disabled": "已關閉",


    "theme_mode": "主題模式",
    "theme_mode_dark": "深色模式",
    "theme_mode_light": "淺色模式",
    "theme_mica": "視窗透明度",
    "theme_mica_full": "完整",
    "theme_mica_partial": "部分",
    "theme_icon_adaptive": "自適應圖標形狀",
    "theme_icon_adaptive_squircle": "方圓形",
    "theme_icon_adaptive_circle": "圓形",
    "theme_icon_adaptive_rounded_square": "圓角方形",


    "installer_message": "您要安裝此應用程式嗎？",
    "installer_info_version": "版本：{appVersion}",
    "@installer_info_version" : {"placeholders": {"appVersion": {"type": "String"}}},
    "installer_info_version_change": "版本：{appVersionOld} => {appVersionNew}",
    "@installer_info_version_change" : {"placeholders": {"appVersionOld": {"type": "String"}, "appVersionNew": {"type": "String"}}},
    "installer_info_package": "包名：{appPackage}",
    "@installer_info_package" : {"placeholders": {"appPackage": {"type": "String"}}},
    "installer_installing": "正在安裝 {appTitle} 應用程式...",
    "@installer_installing" : {"placeholders": {"appTitle": {"type": "String"}}},
    "installer_installed": "應用程式 {appTitle} 已成功安裝",
    "@installer_installed" : {"placeholders": {"appTitle": {"type": "String"}}},
    "installer_fail": "應用程式 {appTitle} 未安裝",
    "@installer_fail" : {"placeholders": {"appTitle": {"type": "String"}}},
    "installer_error_nomsg": "安裝失敗，但未拋出錯誤",
    "installer_btn_starting": "Android 子系統啟動中...",
    "installer_btn_loading": "應用程式加載中...",
    "installer_btn_cancel": "取消",
    "installer_btn_install": "安裝",
    "installer_btn_reinstall": "重新安裝",
    "installer_btn_update": "更新",
    "installer_btn_downgrade": "降級（不安全）",
    "installer_btn_dismiss": "完成",
    "installer_btn_open": "開啟應用程式",
    "installer_btn_checkbox_shortcut": "建立桌面快捷方式",


    "android_permission_none": "不需要任何權限",
    "android_permission_admin": "以管理員身份管理裝置",
    "android_permission_admin_brick": "遠程停用或重設裝置",
    "android_permission_admin_lock": "遠程鎖定裝置",
    "android_permission_storage": "多媒體檔案",
    "android_permission_microphone": "麥克風",
    "android_permission_camera": "相機",
    "android_permission_location": "位置",
    "android_permission_phone": "電話",
    "android_permission_call_log": "通訊記錄",
    "android_permission_sms": "訊息",
    "android_permission_contacts": "聯絡人",
    "android_permission_calendar": "日曆",
    "android_permission_activity_recognition": "體育活動",
    "android_permission_sensors": "裝置傳感器",
    "android_permission_sensors_body": "身體傳感器",
    "android_permission_nearby_devices": "查找附近的裝置"
}

```

`locale/zh.arb`:

```arb
{
    "@@README_1": "en.arb 文件是其他文件的模板",
    "@@README_2": "对于其他语言，不需要翻译 @ 和 @@ 开头的条目，除外 @@locale",
    "@@README_3": "特定于国家/地区的语言环境（例如“en_GB”）需要一个备用语言环境（例如“en”）才能使用",


    "@@locale": "zh",
    "@locale_desc": {"description": "Chinese (simplified) [zh_CN] < [zh_Hans]"},
    "locale_desc": "中文 (简体)",
    "@locale_system": {"description": "描述系统区域设置"},
    "locale_system": "系统",


    "btn_boot": "启动",
    "btn_switch_on": "打开",
    "btn_switch_off": "关闭",


    "@status_subtext_winver_10": {"description": "仅在 'status_unsupported_desc' 中使用，修改时考虑到这一点"},
    "status_subtext_winver_10": "Windows 10",
    "@status_subtext_winver_older": {"description": "仅在 'status_unsupported_desc' 中使用，修改时考虑到这一点"},
    "status_subtext_winver_older": "旧 Windows 版本",


    "status_unsupported": "WSA 未安装",
    "status_unsupported_desc": "{windowsVersion} 检测到但未找到 WSA； 此应用程序依赖于 WSA，仅在 Windows 11 上正式支持",
    "status_missing": "WSA 未安装",
    "status_missing_desc": "未找到 WSA； 此应用程序依赖 WSA，请从 Microsoft Store 安装适用于 Android 的 Windows 子系统（或 Amazon Appstore）",
    "status_unknown": "正在连接",
    "status_unknown_desc": "正在等待建立 WSA 连接...",
    "status_starting": "正在启动",
    "status_starting_desc": "WSA 正在启动，请稍候...",
    "status_arrested": "已停滞",
    "status_arrested_desc": "WSA 已关闭",
    "status_offline": "离线",
    "status_offline_desc": "无法与 WSA 建立连接：开发者模式和 USB 调试被禁用或指定了错误的端口",
    "status_disconnected": "已断开连接",
    "status_disconnected_desc": "由于未知原因，无法建立 WSA 连接",
    "status_connected": "已连接",
    "status_connected_desc": "成功连接到 WSA，所有系统正常运行",


    "screen_wsa": "WSA 包管理器",
    "screen_settings": "设置",


    "wsa_manage": "Android 管理",
    "wsa_manage_app": "管理应用程序",
    "wsa_manage_settings": "管理设置",

    
    "settings_port": "WSA 端口",
    "settings_ip": "WSA IP 地址",
    "settings_autostart": "在安装之前自动启动 WSA",
    "settings_language": "语言",
    "settings_option_generic_system": "系统",
    "settings_option_generic_disabled": "已禁用",


    "theme_mode": "主题模式",
    "theme_mode_dark": "深色模式",
    "theme_mode_light": "浅色模式",
    "theme_mica": "窗口透明度",
    "theme_mica_full": "完整",
    "theme_mica_partial": "部分",
    "theme_icon_adaptive": "自适应图标形状",
    "theme_icon_adaptive_squircle": "超圆角圆形",
    "theme_icon_adaptive_circle": "圆形",
    "theme_icon_adaptive_rounded_square": "圆角方形",


    "installer_message": "您要安装此应用程序吗？",
    "installer_info_version": "版本：{appVersion}",
    "installer_info_version_change": "版本：{appVersionOld} => {appVersionNew}",
    "installer_info_package": "包名：{appPackage}",
    "installer_installing": "正在安装 {appTitle} 应用程序...",
    "installer_installed": "应用程序 {appTitle} 已成功安装",
    "installer_fail": "应用程序 {appTitle} 未安装",
    "installer_error_nomsg": "安装失败，但没有抛出错误",
    "installer_btn_starting": "正在启动...",
    "installer_btn_loading": "加载中...",
    "installer_btn_cancel": "取消",
    "installer_btn_install": "安装",
    "installer_btn_reinstall": "重新安装",
    "installer_btn_update": "更新",
    "installer_btn_downgrade": "降级（不安全）",
    "installer_btn_dismiss": "完成",
    "installer_btn_open": "打开应用程序",
    "installer_btn_checkbox_shortcut": "创建桌面快捷方式",


    "android_permission_none": "不需要任何权限",
    "android_permission_admin": "以管理员身份管理设备",
    "android_permission_admin_brick": "远程禁用或重置设备",
    "android_permission_admin_lock": "远程锁定设备",
    "android_permission_storage": "文件和媒体",
    "android_permission_microphone": "麦克风",
    "android_permission_camera": "相机",
    "android_permission_location": "位置",
    "android_permission_phone": "电话",
    "android_permission_call_log": "通话记录",
    "android_permission_sms": "信息",
    "android_permission_contacts": "联系人",
    "android_permission_calendar": "日历",
    "android_permission_activity_recognition": "体育活动",
    "android_permission_sensors": "设备传感器",
    "android_permission_sensors_body": "身体传感器",
    "android_permission_nearby_devices": "查找附近的设备"
}

```

`proto/manifest_xapk.proto`:

```proto
syntax = "proto2";

package proto;
option optimize_for = SPEED;

message ManifestXapk {
    // App options
    optional uint32 xapk_version = 1 [default = 1];
    optional string package_name = 2;
    optional string name = 3;
    map<string, string> locales_name = 4;
    optional uint32 version_code = 5;
    optional string version_name = 6;
    optional uint32 min_sdk_version = 7;
    optional uint32 target_sdk_version = 8;
    repeated string permissions = 9;
    repeated string split_configs = 10;
    optional uint32 total_size = 11;
    optional string icon = 12;
    repeated ApkFile split_apks = 13;
    repeated ApkExpansion expansions = 14;

    message ApkFile {
        optional string id = 1;
        optional string file = 2;
    }

    message ApkExpansion {
        optional InstallDir install_location = 1;
        optional string file = 2;
        optional string install_path = 3;
    }

    enum InstallDir {
        EXTERNAL_STORAGE = 0;
        INTERNAL_STORAGE = 1;
    }
}
```

`proto/options.proto`:

```proto
syntax = "proto2";

package proto;
option optimize_for = SPEED;

message Options {
    // App options
    optional uint32 ipAddress = 1 [default = 2130706433];
    optional uint32 port = 2 [default = 58526];
    optional bool autostart = 8;
    // Interface options
    optional uint32 locale = 9;
    // Theme options
    optional Theme theme = 3;
    optional bool legacyIcons = 4;
    optional bool systemAccent = 5;
    optional IconShape iconShape = 6;
    optional Mica mica = 7 [default = FULL];

    enum Theme {
        SYSTEM = 0;
        LIGHT = 1;
        DARK = 2;
    }

    enum IconShape {
        SQUIRCLE = 0;
        CIRCLE = 1;
        ROUNDED_SQUARE = 2;
    }

    enum Mica {
        FULL = 0;
        PARTIAL = 1;
        DISABLED = 2;
    }
}
```

`proto/protoc-generate.bat`:

```bat
@echo off
if not exist "..\lib\proto\" mkdir ..\lib\proto
protoc --dart_out=../lib/proto/ *.proto
```

`pubspec.lock`:

```lock
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  archive:
    dependency: "direct main"
    description:
      path: "."
      ref: HEAD
      resolved-ref: dc323145cd3440995c7d1512ac4ee39f381adb22
      url: "https://github.com/brendan-duncan/archive.git"
    source: git
    version: "3.3.0"
  args:
    dependency: transitive
    description:
      name: args
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.3.0"
  async:
    dependency: transitive
    description:
      name: async
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.8.2"
  base32:
    dependency: "direct main"
    description:
      name: base32
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.1.1"
  bitsdojo_window:
    dependency: "direct main"
    description:
      path: bitsdojo_window
      ref: master
      resolved-ref: "7e8d5b25e68915a80499edd50f4bc11a9c42ffc4"
      url: "https://github.com/alesimula/bitsdojo_window.git"
    source: git
    version: "0.1.1+1"
  bitsdojo_window_linux:
    dependency: transitive
    description:
      path: bitsdojo_window_linux
      ref: master
      resolved-ref: "7e8d5b25e68915a80499edd50f4bc11a9c42ffc4"
      url: "https://github.com/alesimula/bitsdojo_window.git"
    source: git
    version: "0.1.1"
  bitsdojo_window_macos:
    dependency: transitive
    description:
      path: bitsdojo_window_macos
      ref: master
      resolved-ref: "7e8d5b25e68915a80499edd50f4bc11a9c42ffc4"
      url: "https://github.com/alesimula/bitsdojo_window.git"
    source: git
    version: "0.1.0"
  bitsdojo_window_platform_interface:
    dependency: transitive
    description:
      path: bitsdojo_window_platform_interface
      ref: master
      resolved-ref: "7e8d5b25e68915a80499edd50f4bc11a9c42ffc4"
      url: "https://github.com/alesimula/bitsdojo_window.git"
    source: git
    version: "0.1.0"
  bitsdojo_window_windows:
    dependency: transitive
    description:
      path: bitsdojo_window_windows
      ref: master
      resolved-ref: "7e8d5b25e68915a80499edd50f4bc11a9c42ffc4"
      url: "https://github.com/alesimula/bitsdojo_window.git"
    source: git
    version: "0.1.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.1.0"
  characters:
    dependency: transitive
    description:
      name: characters
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.2.0"
  charcode:
    dependency: transitive
    description:
      name: charcode
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.3.1"
  charset:
    dependency: "direct main"
    description:
      name: charset
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.1.2"
  clock:
    dependency: transitive
    description:
      name: clock
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.1.0"
  collection:
    dependency: transitive
    description:
      name: collection
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.15.0"
  convert:
    dependency: transitive
    description:
      name: convert
      url: "https://pub.dartlang.org"
    source: hosted
    version: "3.0.1"
  crypto:
    dependency: transitive
    description:
      name: crypto
      url: "https://pub.dartlang.org"
    source: hosted
    version: "3.0.1"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.2.0"
  ffi:
    dependency: transitive
    description:
      name: ffi
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.1.2"
  file:
    dependency: transitive
    description:
      name: file
      url: "https://pub.dartlang.org"
    source: hosted
    version: "6.1.2"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.0.0"
  fluent_ui:
    dependency: "direct main"
    description:
      name: fluent_ui
      url: "https://pub.dartlang.org"
    source: hosted
    version: "3.7.0"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_acrylic:
    dependency: "direct main"
    description:
      name: flutter_acrylic
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.0.0+2"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.0.4"
  flutter_localizations:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  http:
    dependency: transitive
    description:
      name: http
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.13.4"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      url: "https://pub.dartlang.org"
    source: hosted
    version: "4.0.0"
  intl:
    dependency: transitive
    description:
      name: intl
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.17.0"
  jovial_misc:
    dependency: transitive
    description:
      name: jovial_misc
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.8.4"
  jovial_svg:
    dependency: "direct main"
    description:
      name: jovial_svg
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.1.1"
  js:
    dependency: transitive
    description:
      name: js
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.6.3"
  lints:
    dependency: transitive
    description:
      name: lints
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.0.1"
  matcher:
    dependency: transitive
    description:
      name: matcher
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.12.11"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.1.3"
  mdi:
    dependency: "direct main"
    description:
      name: mdi
      url: "https://pub.dartlang.org"
    source: hosted
    version: "5.0.0-nullsafety.0"
  meta:
    dependency: transitive
    description:
      name: meta
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.7.0"
  nested:
    dependency: transitive
    description:
      name: nested
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.0.0"
  path:
    dependency: transitive
    description:
      name: path
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.8.0"
  path_provider_linux:
    dependency: transitive
    description:
      name: path_provider_linux
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.1.5"
  path_provider_platform_interface:
    dependency: transitive
    description:
      name: path_provider_platform_interface
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.0.3"
  path_provider_windows:
    dependency: transitive
    description:
      name: path_provider_windows
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.0.5"
  petitparser:
    dependency: transitive
    description:
      name: petitparser
      url: "https://pub.dartlang.org"
    source: hosted
    version: "4.4.0"
  platform:
    dependency: transitive
    description:
      name: platform
      url: "https://pub.dartlang.org"
    source: hosted
    version: "3.1.0"
  plugin_platform_interface:
    dependency: transitive
    description:
      name: plugin_platform_interface
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.1.2"
  pointycastle:
    dependency: transitive
    description:
      name: pointycastle
      url: "https://pub.dartlang.org"
    source: hosted
    version: "3.5.2"
  process:
    dependency: transitive
    description:
      name: process
      url: "https://pub.dartlang.org"
    source: hosted
    version: "4.2.4"
  protobuf:
    dependency: "direct main"
    description:
      name: protobuf
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.0.1"
  provider:
    dependency: "direct main"
    description:
      name: provider
      url: "https://pub.dartlang.org"
    source: hosted
    version: "6.0.2"
  quiver:
    dependency: transitive
    description:
      name: quiver
      url: "https://pub.dartlang.org"
    source: hosted
    version: "3.0.1+1"
  recase:
    dependency: transitive
    description:
      name: recase
      url: "https://pub.dartlang.org"
    source: hosted
    version: "4.0.0"
  scroll_pos:
    dependency: transitive
    description:
      name: scroll_pos
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.3.0"
  shared_preferences:
    dependency: transitive
    description:
      name: shared_preferences
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.0.13"
  shared_preferences_android:
    dependency: transitive
    description:
      name: shared_preferences_android
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.0.11"
  shared_preferences_ios:
    dependency: transitive
    description:
      name: shared_preferences_ios
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.1.0"
  shared_preferences_linux:
    dependency: transitive
    description:
      name: shared_preferences_linux
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.1.0"
  shared_preferences_macos:
    dependency: transitive
    description:
      name: shared_preferences_macos
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.0.3"
  shared_preferences_platform_interface:
    dependency: transitive
    description:
      name: shared_preferences_platform_interface
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.0.0"
  shared_preferences_web:
    dependency: transitive
    description:
      name: shared_preferences_web
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.0.3"
  shared_preferences_windows:
    dependency: transitive
    description:
      name: shared_preferences_windows
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.1.0"
  shared_value:
    dependency: "direct main"
    description:
      name: shared_value
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.1.2"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.99"
  source_span:
    dependency: transitive
    description:
      name: source_span
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.8.1"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.10.0"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.1.0"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.1.0"
  synchronized:
    dependency: "direct main"
    description:
      name: synchronized
      url: "https://pub.dartlang.org"
    source: hosted
    version: "3.0.0+2"
  system_theme:
    dependency: "direct main"
    description:
      name: system_theme
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.0.1"
  system_theme_web:
    dependency: transitive
    description:
      name: system_theme_web
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.0.2"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.2.0"
  test_api:
    dependency: transitive
    description:
      name: test_api
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.4.8"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      url: "https://pub.dartlang.org"
    source: hosted
    version: "1.3.0"
  url_strategy:
    dependency: "direct main"
    description:
      name: url_strategy
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.2.0"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.1.1"
  win32:
    dependency: "direct main"
    description:
      name: win32
      url: "https://pub.dartlang.org"
    source: hosted
    version: "2.4.4"
  xdg_directories:
    dependency: transitive
    description:
      name: xdg_directories
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.2.0+1"
  xml:
    dependency: transitive
    description:
      name: xml
      url: "https://pub.dartlang.org"
    source: hosted
    version: "5.3.1"
  yaml:
    dependency: "direct main"
    description:
      name: yaml
      url: "https://pub.dartlang.org"
    source: hosted
    version: "3.1.0"
sdks:
  dart: ">=2.15.0 <3.0.0"
  flutter: ">=2.8.0"

```

`pubspec.yaml`:

```yaml
name: wsa_pacman
description: A GUI package manager and package installer for Windows Subsystem for Android (WSA).

publish_to: 'none' # Remove this line if you wish to publish to pub.dev

version: 1.0.0+1

environment:
  sdk: '>=2.12.0 <3.0.0'

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  fluent_ui: 3.7.0
    #git: https://github.com/bdlukaa/fluent_ui.git
  shared_value: ^2.1.2
  synchronized: ^3.0.0
  provider: ^6.0.0
  system_theme: ^1.0.1
  bitsdojo_window: #^0.1.1+1
    git:
      # Credits to bufan22 for fixing errors with new Windows versions
      url: https://github.com/alesimula/bitsdojo_window.git
      path: bitsdojo_window
      ref: master
  flutter_acrylic: ^1.0.0+1
  url_strategy: ^0.2.0
  yaml: ^3.1.0
  #transparent_pointer: ^1.0.0
  archive: #3.1.11
    git: https://github.com/brendan-duncan/archive.git
  #flutter_svg: ^0.23.0+1
  jovial_svg: ^1.0.8
  protobuf: ^2.0.0
  #path_provider: ^2.0.6
  mdi: ^5.0.0-nullsafety.0
  win32: ^2.3.0
  base32: ^2.1.1
  charset: ^0.1.1
  

dev_dependencies:
  flutter_test:
    sdk: flutter
  #flutter_native_splash: ^2.0.1+1
  flutter_lints: ^1.0.4

flutter:
  generate: true
  uses-material-design: true
  assets:
    - assets/icons/missing_icon_background.si
    - assets/icons/missing_icon_foreground.si
    - assets/icons/missing_icon_legacy.si
    - assets/images/logo.png

#flutter_native_splash:
  #color: "#42a5f5"
  #image: web/assets/flutter_logo.png


```

`test/widget_test.dart`:

```dart
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility that Flutter provides. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:wsa_pacman/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

```

`windows/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.15)
project(wsa_pacman LANGUAGES CXX)

set(BINARY_NAME "WSA-pacman")

cmake_policy(SET CMP0063 NEW)

set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Configure build options.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()

set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")

# Flutter library and tool build rules.
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build
add_subdirectory("runner")

# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)

```

`windows/flutter/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.15)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      windows-x64 $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)

```

`windows/flutter/generated_plugin_registrant.cc`:

```cc
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <bitsdojo_window_windows/bitsdojo_window_plugin.h>
#include <flutter_acrylic/flutter_acrylic_plugin.h>
#include <system_theme/system_theme_plugin.h>

void RegisterPlugins(flutter::PluginRegistry* registry) {
  BitsdojoWindowPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("BitsdojoWindowPlugin"));
  FlutterAcrylicPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FlutterAcrylicPlugin"));
  SystemThemePluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("SystemThemePlugin"));
}

```

`windows/flutter/generated_plugin_registrant.h`:

```h
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_

```

`windows/flutter/generated_plugins.cmake`:

```cmake
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  bitsdojo_window_windows
  flutter_acrylic
  system_theme
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

```

`windows/runner/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.15)
project(runner LANGUAGES CXX)

add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

apply_standard_settings(${BINARY_NAME})
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")
add_dependencies(${BINARY_NAME} flutter_assemble)

```

`windows/runner/Runner.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#ifdef FLUTTER_BUILD_NUMBER
#define VERSION_AS_NUMBER FLUTTER_BUILD_NUMBER
#else
#define VERSION_AS_NUMBER 1,0,0,2
#endif

#ifdef FLUTTER_BUILD_NAME
#define VERSION_AS_STRING #FLUTTER_BUILD_NAME
#else
#define VERSION_AS_STRING "1.0.0.2"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.wsa_pacman" "\0"
            VALUE "FileDescription", "WSA Package Manager" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "wsa_pacman" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2021 com.wsa_pacman. All rights reserved." "\0"
            VALUE "OriginalFilename", "WSA-pacman.exe" "\0"
            VALUE "ProductName", "WSA Package Manager" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

`windows/runner/flutter_window.cpp`:

```cpp
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());
  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}

```

`windows/runner/flutter_window.h`:

```h
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_

```

`windows/runner/main.cpp`:

```cpp
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

#include <bitsdojo_window_windows/bitsdojo_window_plugin.h>
auto bdw = bitsdojo_window_configure(BDW_CUSTOM_FRAME | BDW_HIDE_ON_STARTUP);

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  
  //Prevent conosole instances from popping up when running a process with Process.run after launching the executable
  //Solution: https://github.com/flutter/flutter/issues/47891#issuecomment-708850435
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {CreateAndAttachConsole();} else {
    STARTUPINFO si = { 0 };
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;

    PROCESS_INFORMATION pi = { 0 };
    WCHAR lpszCmd[MAX_PATH] = L"cmd.exe";
    if (::CreateProcess(NULL, lpszCmd, NULL, NULL, FALSE, CREATE_NEW_CONSOLE | CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {
      do {
        if (::AttachConsole(pi.dwProcessId)) {
          ::TerminateProcess(pi.hProcess, 0);
          break;
        }
      } while (ERROR_INVALID_HANDLE == GetLastError());
      ::CloseHandle(pi.hProcess);
      ::CloseHandle(pi.hThread);
    }
  }
  
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.CreateAndShow(L"wsa_pacman", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

```

`windows/runner/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`windows/runner/run_loop.cpp`:

```cpp
#include "run_loop.h"

#include <windows.h>

#include <algorithm>

RunLoop::RunLoop() {}

RunLoop::~RunLoop() {}

void RunLoop::Run() {
  bool keep_running = true;
  TimePoint next_flutter_event_time = TimePoint::clock::now();
  while (keep_running) {
    std::chrono::nanoseconds wait_duration =
        std::max(std::chrono::nanoseconds(0),
                 next_flutter_event_time - TimePoint::clock::now());
    ::MsgWaitForMultipleObjects(
        0, nullptr, FALSE, static_cast<DWORD>(wait_duration.count() / 1000),
        QS_ALLINPUT);
    bool processed_events = false;
    MSG message;
    // All pending Windows messages must be processed; MsgWaitForMultipleObjects
    // won't return again for items left in the queue after PeekMessage.
    while (::PeekMessage(&message, nullptr, 0, 0, PM_REMOVE)) {
      processed_events = true;
      if (message.message == WM_QUIT) {
        keep_running = false;
        break;
      }
      ::TranslateMessage(&message);
      ::DispatchMessage(&message);
      // Allow Flutter to process messages each time a Windows message is
      // processed, to prevent starvation.
      next_flutter_event_time =
          std::min(next_flutter_event_time, ProcessFlutterMessages());
    }
    // If the PeekMessage loop didn't run, process Flutter messages.
    if (!processed_events) {
      next_flutter_event_time =
          std::min(next_flutter_event_time, ProcessFlutterMessages());
    }
  }
}

void RunLoop::RegisterFlutterInstance(
    flutter::FlutterEngine* flutter_instance) {
  flutter_instances_.insert(flutter_instance);
}

void RunLoop::UnregisterFlutterInstance(
    flutter::FlutterEngine* flutter_instance) {
  flutter_instances_.erase(flutter_instance);
}

RunLoop::TimePoint RunLoop::ProcessFlutterMessages() {
  TimePoint next_event_time = TimePoint::max();
  for (auto instance : flutter_instances_) {
    std::chrono::nanoseconds wait_duration = instance->ProcessMessages();
    if (wait_duration != std::chrono::nanoseconds::max()) {
      next_event_time =
          std::min(next_event_time, TimePoint::clock::now() + wait_duration);
    }
  }
  return next_event_time;
}

```

`windows/runner/run_loop.h`:

```h
#ifndef RUNNER_RUN_LOOP_H_
#define RUNNER_RUN_LOOP_H_

#include <flutter/flutter_engine.h>

#include <chrono>
#include <set>

// A runloop that will service events for Flutter instances as well
// as native messages.
class RunLoop {
 public:
  RunLoop();
  ~RunLoop();

  // Prevent copying
  RunLoop(RunLoop const&) = delete;
  RunLoop& operator=(RunLoop const&) = delete;

  // Runs the run loop until the application quits.
  void Run();

  // Registers the given Flutter instance for event servicing.
  void RegisterFlutterInstance(
      flutter::FlutterEngine* flutter_instance);

  // Unregisters the given Flutter instance from event servicing.
  void UnregisterFlutterInstance(
      flutter::FlutterEngine* flutter_instance);

 private:
  using TimePoint = std::chrono::steady_clock::time_point;

  // Processes all currently pending messages for registered Flutter instances.
  TimePoint ProcessFlutterMessages();

  std::set<flutter::FlutterEngine*> flutter_instances_;
};

#endif  // RUNNER_RUN_LOOP_H_

```

`windows/runner/runner.exe.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
    </application>
  </compatibility>
</assembly>

```

`windows/runner/utils.cpp`:

```cpp
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr);
  if (target_length == 0) {
    return std::string();
  }
  std::string utf8_string;
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, utf8_string.data(),
      target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}

```

`windows/runner/utils.h`:

```h
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_

```

`windows/runner/win32_window.cpp`:

```cpp
#include "win32_window.h"

#include <flutter_windows.h>

#include "resource.h"

namespace {

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
    FreeLibrary(user32_module);
  }
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::CreateAndShow(const std::wstring& title,
                                const Point& origin,
                                const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW | WS_VISIBLE,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  return OnCreate();
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

```

`windows/runner/win32_window.h`:

```h
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates and shows a win32 window with |title| and position and size using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size to will treat the width height passed in to this function
  // as logical pixels and scale to appropriate for the default monitor. Returns
  // true if the window was created successfully.
  bool CreateAndShow(const std::wstring& title,
                     const Point& origin,
                     const Size& size);

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responsponds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_

```

`winuwp/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.8)
set(CMAKE_SYSTEM_NAME WindowsStore)
set(CMAKE_SYSTEM_VERSION 10.0)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED YES)

project(wsa_pacman LANGUAGES CXX)

cmake_policy(SET CMP0079 NEW)

set(BINARY_NAME "wsa_pacman")

# Configure build options.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()

set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100" /await)
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
  target_compile_definitions(${TARGET} PRIVATE WINUWP)
  set_target_properties(${TARGET} PROPERTIES VS_WINDOWS_TARGET_PLATFORM_MIN_VERSION 10.0.18362.0)
endfunction()

set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")

# Flutter library and tool build rules.
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build
add_subdirectory("runner_uwp")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)

```

`winuwp/flutter/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.8)
set(CMAKE_SYSTEM_NAME WindowsStore)
set(CMAKE_SYSTEM_VERSION 10.0)
set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

include(CMakePrintHelpers)

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows_winuwp.dll")

# === Assets ===
set(CMAKE_INSTALL_MANIFEST "${EPHEMERAL_DIR}/install_manifest")
file(STRINGS ${CMAKE_INSTALL_MANIFEST} INSTALL_MANIFEST_CONTENT)

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(INSTALL_MANIFEST_CONTENT ${INSTALL_MANIFEST_CONTENT} PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)

```

`winuwp/flutter/generated_plugin_registrant.cc`:

```cc
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"


void RegisterPlugins(flutter::PluginRegistry* registry) {
}

```

`winuwp/flutter/generated_plugin_registrant.h`:

```h
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_

```

`winuwp/flutter/generated_plugins.cmake`:

```cmake
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

```

`winuwp/project_version`:

```
0
```

`winuwp/runner_uwp/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.8)
set(CMAKE_SYSTEM_NAME WindowsStore)
set(CMAKE_SYSTEM_VERSION 10.0)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED YES)

include(CMakePrintHelpers)

project (runner LANGUAGES CXX)

# UWP tile and icon assets.
set(ASSET_FILES ${ASSET_FILES}
	Assets/LargeTile.scale-100.png
	Assets/LargeTile.scale-125.png
	Assets/LargeTile.scale-150.png
	Assets/LargeTile.scale-200.png
	Assets/LargeTile.scale-400.png
	Assets/LockScreenLogo.scale-200.png
	Assets/SmallTile.scale-100.png
	Assets/SmallTile.scale-125.png
	Assets/SmallTile.scale-150.png
	Assets/SmallTile.scale-200.png
	Assets/SmallTile.scale-400.png
	Assets/SplashScreen.scale-100.png
	Assets/SplashScreen.scale-125.png
	Assets/SplashScreen.scale-150.png
	Assets/SplashScreen.scale-200.png
	Assets/SplashScreen.scale-400.png
	Assets/Square44x44Logo.altform-unplated_targetsize-16.png
	Assets/Square44x44Logo.altform-unplated_targetsize-32.png
	Assets/Square44x44Logo.altform-unplated_targetsize-48.png
	Assets/Square44x44Logo.altform-unplated_targetsize-256.png
	Assets/Square44x44Logo.scale-100.png
	Assets/Square44x44Logo.scale-125.png
	Assets/Square44x44Logo.scale-150.png
	Assets/Square44x44Logo.scale-200.png
	Assets/Square44x44Logo.scale-400.png
	Assets/Square44x44Logo.targetsize-16.png
	Assets/Square44x44Logo.targetsize-24.png
	Assets/Square44x44Logo.targetsize-24_altform-unplated.png
	Assets/Square44x44Logo.targetsize-32.png
	Assets/Square44x44Logo.targetsize-48.png
	Assets/Square44x44Logo.targetsize-256.png
	Assets/Square150x150Logo.scale-100.png
	Assets/Square150x150Logo.scale-125.png
	Assets/Square150x150Logo.scale-150.png
	Assets/Square150x150Logo.scale-200.png
	Assets/Square150x150Logo.scale-400.png
	Assets/StoreLogo.png
	Assets/StoreLogo.scale-100.png
	Assets/StoreLogo.scale-125.png
	Assets/StoreLogo.scale-150.png
	Assets/StoreLogo.scale-200.png
	Assets/StoreLogo.scale-400.png
	Assets/Wide310x150Logo.scale-200.png
	Assets/WideTile.scale-100.png
	Assets/WideTile.scale-125.png
	Assets/WideTile.scale-150.png
	Assets/WideTile.scale-200.png
	Assets/WideTile.scale-400.png
)

# Configure package manifest file.
set(APP_MANIFEST_NAME Package.appxmanifest)
set(APP_MANIFEST_TARGET_LOCATION ${CMAKE_CURRENT_BINARY_DIR}/${APP_MANIFEST_NAME})
set(SHORT_NAME ${BINARY_NAME})
set(PACKAGE_GUID "D8EBD069-504B-4B0C-AA2B-7C0172F61791")

configure_file(
	appxmanifest.in
	${APP_MANIFEST_TARGET_LOCATION}
	@ONLY)

set(CONTENT_FILES ${APP_MANIFEST_TARGET_LOCATION})

# Configure package content files.
set_property(SOURCE ${CONTENT_FILES} PROPERTY VS_DEPLOYMENT_CONTENT 1)

set(RESOURCE_FILES ${ASSET_FILES} ${CONTENT_FILES} Windows_TemporaryKey.pfx)
set_property(SOURCE ${ASSET_FILES} PROPERTY VS_DEPLOYMENT_CONTENT 1)
set_property(SOURCE ${ASSET_FILES} PROPERTY VS_DEPLOYMENT_LOCATION "Assets")

set(STRING_FILES Resources.pri)
set_property(SOURCE ${STRING_FILES} PROPERTY VS_TOOL_OVERRIDE "PRIResource")

source_group("Resource Files" FILES ${RESOURCE_FILES} ${CONTENT_FILES} ${STRING_FILES})

# Configure Flutter assets using tool generated install manifest
foreach(ITEM ${INSTALL_MANIFEST_CONTENT})
	get_filename_component(ITEM_REL ${CMAKE_BINARY_DIR} DIRECTORY)
	file(RELATIVE_PATH RELPATH ${ITEM_REL} ${ITEM})

	get_filename_component(RELPATH ${RELPATH} DIRECTORY)
	get_filename_component(ITEMEXT ${ITEM} LAST_EXT)

	if("${ITEMEXT}" STREQUAL ".dll" OR "${ITEMEXT}" STREQUAL ".pdb")
		string(CONCAT RELPATH "")
	elseif ("${ITEMEXT}" STREQUAL ".so")
		file(RELATIVE_PATH RELPATH "${ITEM_REL}/winuwp" ${ITEM})
		string(REGEX REPLACE "/" "\\\\" RELPATH ${RELPATH})
		string(CONCAT RELPATH "Assets\\Data")
	elseif("${ITEMEXT}" STREQUAL ".dat")
		string(CONCAT RELPATH "Assets\\Data")
	else()
		string(REGEX REPLACE "/" "\\\\" RELPATH ${RELPATH})
		string(CONCAT RELPATH "Assets\\Data\\" ${RELPATH})
	endif()

	cmake_print_variables(${RELPATH})

	set_property(SOURCE ${ITEM} PROPERTY VS_DEPLOYMENT_CONTENT 1)
	set_property(SOURCE ${ITEM} PROPERTY VS_DEPLOYMENT_LOCATION ${RELPATH})
endforeach()

add_executable (${BINARY_NAME} WIN32
	main.cpp
	flutter_frameworkview.cpp
	"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
	${RESOURCE_FILES}
	${INSTALL_MANIFEST_CONTENT}
)
apply_standard_settings(${BINARY_NAME})
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")
target_link_libraries(${BINARY_NAME} PRIVATE WindowsApp flutter flutter_wrapper_app)
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

add_dependencies(${BINARY_NAME} flutter_assemble)

```

`winuwp/runner_uwp/CMakeSettings.json`:

```json
{
	// See https://go.microsoft.com//fwlink//?linkid=834763 for more information about this file.
	"configurations": [
		{
			"name": "Debug",
			"generator": "Visual Studio 15 2017 Win64",
			"configurationType": "Debug",
			"inheritEnvironments": [ "msvc_x64_x64" ],
			"buildRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\build\\${name}",
			"installRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\install\\${name}",
			"cmakeCommandArgs": "",
			"buildCommandArgs": "",
			"ctestCommandArgs": ""
		},
		{
			"name": "Release",
			"generator": "Visual Studio 15 2017 Win64",
			"configurationType": "Release",
			"inheritEnvironments": [ "msvc_x64_x64" ],
			"buildRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\build\\${name}",
			"installRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\install\\${name}",
			"cmakeCommandArgs": "",
			"buildCommandArgs": "",
			"ctestCommandArgs": ""
		}
	]
}

```

`winuwp/runner_uwp/Windows_TemporaryKey.pfx`:

```pfx
0‚	ü0‚	¸	*†H†÷ ‚	©‚	¥0‚	¡0‚	*†H†÷ ‚ù‚õ0‚ñ0‚í*†H†÷
 ‚þ0‚ú0
*†H†÷0ü–£a¿ èºÐ‚Ø{îc	Û7‘›¢åçàäy•# ·Y»²K&˜qG_ûù'|òµÐMy
’¿µ ëb÷Å
Ûè»õþHÚ®žAVøu²ÔÂ ×†
ÕEeuäŒ¾‡wj	Cr¼‚Ú¹“’ƒU~?â<ÀoÄruPsn¹£a|(/Þü‘”Æò Ï÷–ØÔà¾Ñ†ÆÁ·¢ü°úË;}T¤¤‡SrŸu/Å<S¡'”‡%W~ÃLuBŒ”ßO‘ŒÒ¤È<Ê•}~ÏI‡T 1Ds%…7+×$¯•ëÒÙßˆ¹œÇïÝ‹xoÙXËRýŽDÈÛ.Ã#ê´úßï­½Ä£š—n1PÙò¨fû]¡Oá&Œt‹»\–‚tqUç*š ôxÚ9ÝCs5%„mï\»ØYvCÞðÓºÐE|uÛÇó­6V2­ýþ,{kSeÆ)Ô	å9oæYÐÊ¼71nc•ýË¢h!ÇþŒGèH”ˆÀjíöÒ¶ÍÆeuÒ÷üyl»iœì"£5W}m8È;“æ¦b©ŽŠg6–ß$… í×ÊñwÖÐ7Û!<ÂöýM§Æ[We–;^”6!Âq6÷HÑwWQ/³HÖQÝ¸“’LQ³ßÛ‚zà¬Ï]U³Ð^	uµbv<P0Œål€½ã§O(÷(yÃã¶ÓÄíuWøä[»i? t_
áED-Ì7PÖ·M‰œl•?QÁuˆì­	w‘&ãÆ¿È¸™3SQöŒ8<v„Fg›\PÈmö¹“fÖ&…hRa:V:{¡U4518-½mÒ4õ^Ä¿àkÕaƒoaCå¡ÔózX1È	ÈJÒ
œi˜ý4Ê¤Ç4 hµm…øí–Ù]EKÙ"Î¹µ[e½AãÙXbe.æT‰à¢†–ëpËJW!šY”Sù P‘c–Þ>“Yr«7H­ÄÃ-:á"´²“¿é°£Ã¤rÜ*­RÆS¢äö!ÔSVcÎ%ú×È_8îÎ“¯¼>hnBUÄe÷À¹ÌÕ÷ÌÈ6WÄ#b©ÅìË}0Nf—Gz+è£"¼J~´4(Ñ]O2%F~Ä—ÐÅFD[u5sbäœ
ñ[Š¥KÖ™OæÁßYÏ˜M¿"»?›?b¦†
3ˆ;“êÏŸ¡tÝäÝDÍ›úa¡#â»ˆ#ÿ—÷~Æÿwì( ðÕéýÙŒîö÷¢Ñp¨í9é~þµ[²ËÒ„â÷Ê¥“ût	gë«LÝ²åLÃaHh1®¿mñPÆæ·)•¹R…O?adý0‡é•”Ô_µÝQe·µõ+¹žWñ$¶>u>„clKëI£(;¦ti«Èv‡AªÜ:½ë:8«¦´w…nEuñg»,=¨»-ªÇ&¹åÀº'½ÚSÅó\xÂ=PÎ3(%~‘Ç.æ–]ü‹©Ê}3ZÑË‹þU€*V‘sU¦À?“Ô#»Ù-Ì,ÁŠyÖ9F^ð~A_p*	àp5B—\­ûÎxŒ.5J²QC¶b	[©-äFªÍyøLš÷Ž)»*Nb„|€]Õ¡mg³S:˜ºÇY~Ðos7e\.L»{ï°FÌñ6X‡¸hê×jÍ1Û0	*†H†÷	1   0]	+‚71PN M i c r o s o f t   S t r o n g   C r y p t o g r a p h i c   P r o v i d e r0e	*†H†÷	1XV P v k T m p : 7 7 0 8 e 7 5 6 - d d 3 f - 4 3 9 9 - b b 0 7 - f 0 b 5 b 4 f 4 1 c 1 b0‚‘	*†H†÷ ‚‚‚~0‚z0‚v*†H†÷
 ‚N0‚J
*†H†÷	 ‚:‚60‚20‚ ®º=»å¬Bx'5ðü0	*†H†÷ 010UCMake Test Cert0 140101070000Z21000101070000Z010UCMake Test Cert0‚"0	*†H†÷ ‚ 0‚
‚ ËñœX¨ýÜs¾Õ,¥9C K¢¡$´+NùöBÇ&›¥óEÆaQ<OXÂ«¦/7{˜›ºˆ½ô0êpO|+Ù Hä˜aE“Ý	—4¿R‹†øKa,H§é`V÷é±=$C‹<TyX®´PO4HÂ.‘Úÿ©œ]7µ»…;Óö«i,aHdjœ9c¶{œä*Bžž[>5R0á \¨;¤AœÜ8w4 Aåx#ýG@nÔú-j¨½…ƒä] Tùæ›±µ–
Ì	~#¶x Fd9eEÚÛ„y\E…—½89~Àüï¦BÙEÑÆ²©Ÿ?¥C¡>®Èkhãz‘ù¥ù”¦eÍ £r0p0Uÿ0 0U%0
+0KUD0B€tøS!}vc›Ø²câ‰e¡010UCMake Test Cert‚®º=»å¬Bx'5ðü0	*†H†÷ ‚ 7þ XÕw±„zh·œ\AdØŸTŽbùX=¦éSi€—xÕ!^²Xê5<.êªN'^ª¬¯bxÛN”·„V¶sÝy[®Âê;Ã5è$›gŽÃP¶(Ï8.üüpdƒ+»×¿}xV&y]—ç!+kîÈ©-·×¿Þic“˜	/§¶õbóR¼íIX¶#í)œú…£j}ô9	3™s._ðË%ßÕ@úäwâÏ0QC^0'ÚË¯ašžp š4X&Š}îÿs Ü:#´XLý{‹­½%q—è &õqfQ\ÄÞ™âj¸GÝq0—~È†”ÚŸ¨y¼ï¥ÞnF10	*†H†÷	1   0;00+?â÷ÛCX2ÉÚ§<•Ø‰ÃÈ_UU”JÎñ(†œ°ô’È®)ÖÐ
```

`winuwp/runner_uwp/appxmanifest.in`:

```in
<?xml version="1.0" encoding="utf-8"?>
<Package
  xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
  xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest"
  xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
  IgnorableNamespaces="uap mp">

  <Identity Name="@PACKAGE_GUID@" Publisher="CN=CMake Test Cert" Version="1.1.0.0" />
  <mp:PhoneIdentity PhoneProductId="@PACKAGE_GUID@" PhonePublisherId="00000000-0000-0000-0000-000000000000"/>

  <Properties>
    <DisplayName>@SHORT_NAME@</DisplayName>
    <PublisherDisplayName>CMake Test Cert</PublisherDisplayName>
    <Logo>Assets/StoreLogo.png</Logo>
  </Properties>

  <Dependencies>
    <TargetDeviceFamily Name="Windows.Universal" MinVersion="10.0.0.0" MaxVersionTested="10.0.65535.65535" />
  </Dependencies>

  <Resources>
    <Resource Language="x-generate" />
  </Resources>
  <Applications>
    <Application Id="App" Executable="$targetnametoken$.exe" EntryPoint="@SHORT_NAME@.App">
      <uap:VisualElements
        DisplayName="@SHORT_NAME@"
        Description="@SHORT_NAME@"
        BackgroundColor="#336699"
        Square150x150Logo="Assets/Square150x150Logo.png"
        Square44x44Logo="Assets/Square44x44Logo.png"
        >
        <uap:SplashScreen Image="Assets/SplashScreen.png" />
      </uap:VisualElements>
    </Application>
  </Applications>
   <Capabilities>
    <Capability Name="internetClientServer"/>
    <Capability Name="internetClient"/>
    <Capability Name="privateNetworkClientServer"/>
    <Capability Name="codeGeneration"/></Capabilities>
</Package>

```

`winuwp/runner_uwp/flutter_frameworkview.cpp`:

```cpp
#include "winrt/Windows.ApplicationModel.Core.h"
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.System.Profile.h"
#include "winrt/Windows.System.Threading.h"
#include "winrt/Windows.UI.Core.h"
#include <winrt/Windows.Foundation.Collections.h>
#include <winrt/Windows.Graphics.Display.h>
#include <winrt/Windows.Storage.h>
#include <winrt/Windows.UI.Popups.h>
#include <winrt/Windows.UI.ViewManagement.Core.h>
#include <winrt/Windows.UI.ViewManagement.h>

#include <chrono>
#include <memory>
#include <thread>

#include <flutter/flutter_view_controller.h>
#include <flutter/flutter_windows.h>
#include <flutter/generated_plugin_registrant.h>
#include <flutter/plugin_registry.h>

struct FlutterFrameworkView
    : winrt::implements<
          FlutterFrameworkView,
          winrt::Windows::ApplicationModel::Core::IFrameworkView> {
  // |winrt::Windows::ApplicationModel::Core::IFrameworkView|
  void
  Initialize(winrt::Windows::ApplicationModel::Core::CoreApplicationView const
                 &applicationView) {

    // Layout scaling must be disabled in the appinitialization phase in order
    // to take effect correctly.
    if (winrt::Windows::System::Profile::AnalyticsInfo::VersionInfo()
            .DeviceFamily() == L"Windows.Xbox") {

      bool result = winrt::Windows::UI::ViewManagement::ApplicationViewScaling::
          TrySetDisableLayoutScaling(true);
      if (!result) {
        OutputDebugString(L"Couldn't disable layout scaling");
      }
    }

    main_view_ = applicationView;
    main_view_.Activated({this, &FlutterFrameworkView::OnActivated});
  }

  // |winrt::Windows::ApplicationModel::Core::IFrameworkView|
  void Uninitialize() {
    main_view_.Activated(nullptr);
    main_view_ = nullptr;
  }

  // |winrt::Windows::ApplicationModel::Core::IFrameworkView|
  void Load(winrt::hstring const &) {}

  // |winrt::Windows::ApplicationModel::Core::IFrameworkView|
  void Run() {
    winrt::Windows::UI::Core::CoreWindow window =
        winrt::Windows::UI::Core::CoreWindow::GetForCurrentThread();

    winrt::Windows::UI::Core::CoreDispatcher dispatcher = window.Dispatcher();
    dispatcher.ProcessEvents(
        winrt::Windows::UI::Core::CoreProcessEventsOption::ProcessUntilQuit);
  }

  // |winrt::Windows::ApplicationModel::Core::IFrameworkView|
  winrt::Windows::Foundation::IAsyncAction
  SetWindow(winrt::Windows::UI::Core::CoreWindow const &window) {

    // Capture reference to window.
    window_ = window;

    // Lay out the window's content within the region occupied by the
    // CoreWindow.
    auto appView = winrt::Windows::UI::ViewManagement::ApplicationView::
        GetForCurrentView();

    appView.SetDesiredBoundsMode(winrt::Windows::UI::ViewManagement::
                                     ApplicationViewBoundsMode::UseCoreWindow);

    // Configure folder paths.
    try {
      winrt::Windows::Storage::StorageFolder folder =
          winrt::Windows::ApplicationModel::Package::Current()
              .InstalledLocation();

      winrt::Windows::Storage::StorageFolder assets =
          co_await folder.GetFolderAsync(L"Assets");
      winrt::Windows::Storage::StorageFolder data =
          co_await assets.GetFolderAsync(L"data");
      winrt::Windows::Storage::StorageFolder flutter_assets =
          co_await data.GetFolderAsync(L"flutter_assets");
      winrt::Windows::Storage::StorageFile icu_data =
          co_await data.GetFileAsync(L"icudtl.dat");

#if NDEBUG
      winrt::Windows::Storage::StorageFile aot_data =
          co_await data.GetFileAsync(L"app.so");
#endif

      std::wstring flutter_assets_path{flutter_assets.Path()};
      std::wstring icu_data_path{icu_data.Path()};
      std::wstring aot_data_path {
#if NDEBUG
        aot_data.Path()
#endif
      };

      flutter::DartProject project(flutter_assets_path, icu_data_path,
                                   aot_data_path);

      // Construct viewcontroller using the Window and project
            flutter_view_controller_ = std::make_unique<flutter::FlutterViewController>(
                static_cast<ABI::Windows::ApplicationModel::Core::CoreApplicationView*>(winrt::get_abi(main_view_)),
                static_cast<ABI::Windows::ApplicationModel::Activation::IActivatedEventArgs*>(winrt::get_abi(launch_args_)),
                project);

      // If plugins present, register them.
      RegisterPlugins(flutter_view_controller_.get()->engine());
    } catch (winrt::hresult_error &err) {
      winrt::Windows::UI::Popups::MessageDialog md =
          winrt::Windows::UI::Popups::MessageDialog::MessageDialog(
              L"There was a problem starting the engine: " + err.message());
      md.ShowAsync();
    }
  }

  void OnActivated(
      winrt::Windows::ApplicationModel::Core::CoreApplicationView const
          &applicationView,
      winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs const
          &args) {
    // Activate the application window, making it visible and enabling it to
    // receive events.
    applicationView.CoreWindow().Activate();

    // Capture launch args to later pass to Flutter.
    launch_args_ = args;
  }

  // Current CoreApplicationView.
  winrt::Windows::ApplicationModel::Core::CoreApplicationView main_view_{
      nullptr};

  // Current CoreWindow.
  winrt::Windows::UI::Core::CoreWindow window_{nullptr};

  // Current FlutterViewController.
  std::unique_ptr<flutter::FlutterViewController> flutter_view_controller_{
      nullptr};

  // Launch args that were passed in on activation.
  winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs
      launch_args_;
};

```

`winuwp/runner_uwp/main.cpp`:

```cpp

#include <windows.h>

#include "winrt/Windows.ApplicationModel.Core.h"
#include "winrt/Windows.Foundation.h"
#include <winrt/Windows.Foundation.Collections.h>
#include <winrt/Windows.UI.ViewManagement.Core.h>
#include <winrt/Windows.UI.ViewManagement.h>

#include <memory>

#include "flutter_frameworkview.cpp"

struct App
    : winrt::implements<
          App, winrt::Windows::ApplicationModel::Core::IFrameworkViewSource> {
  App() { view_ = winrt::make_self<FlutterFrameworkView>(); }

  // |winrt::Windows::ApplicationModel::Core::IFrameworkViewSource|
  winrt::Windows::ApplicationModel::Core::IFrameworkView CreateView() {
    return view_.as<winrt::Windows::ApplicationModel::Core::IFrameworkView>();
  }

  winrt::com_ptr<FlutterFrameworkView> view_;
};

int __stdcall wWinMain(HINSTANCE, HINSTANCE, PWSTR, int) {
  winrt::Windows::ApplicationModel::Core::CoreApplication::Run(
      winrt::make<App>());
}

```