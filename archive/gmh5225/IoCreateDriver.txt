Project Path: arc_gmh5225_IoCreateDriver_v42mmdw7

Source Tree:

```txt
arc_gmh5225_IoCreateDriver_v42mmdw7
├── CreateDriver.h
├── Example
│   ├── Example.sln
│   └── Test
│       ├── Driver.c
│       ├── IoCreateDriver
│       │   ├── CreateDriver.h
│       │   └── definitions.h
│       ├── Test.vcxproj
│       ├── Test.vcxproj.filters
│       └── Test.vcxproj.user
├── README.md
└── definitions.h

```

`CreateDriver.h`:

```h
/*
	***************************************************
	*  Author: Th3Spl                                 *
	*  Lang: C++ | Usable in C as well                *
	*  Date: 27/12/2023                               *
	*  Purpose: IoCreateDriver Implementation         *
	***************************************************
*/

#pragma once

//
// Inclusions
//
#include <ntifs.h>
#include <ntstrsafe.h>
#include <windef.h>
#include "definitions.h"


//
// Dummy function used as default function for the IRP_MJ functions
//
NTSTATUS NTAPI IopInvalidDeviceRequest( _In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_INVALID_DEVICE_REQUEST;
}


//
// Custom IoCreateDriver in order to bypass PsLoadedModule and EtwTiLogDriverObjectLoad 
// it makes easier tohe usage of IOCTL if you're using KdMapper
// 
NTSTATUS __fastcall IoCreateDriver( _In_ NTSTATUS(__fastcall* EntryPoint)(_In_ PDRIVER_OBJECT, _In_ PUNICODE_STRING))
{
	//
	// Variables
	//
	HANDLE drv_handle;
	USHORT name_length;
	WCHAR name_buffer[100];
	PDRIVER_OBJECT drv_obj;
	OBJECT_ATTRIBUTES obj_attribs;
	UNICODE_STRING local_drv_name;
	UNICODE_STRING service_key_name;
	NTSTATUS status = STATUS_SUCCESS;
	ULONG obj_size = sizeof(DRIVER_OBJECT) + sizeof(EXTENDED_DRIVER_EXTENSION);

	
	//
	// We meed to create a UNICODE_STRING which contains the (randomic) name of the driver (we're not interested in that)
	//
	name_length = (USHORT)swprintf(name_buffer, L"\\Driver\\%08u", (ULONG)KeQueryUnbiasedInterruptTime());
	local_drv_name.Length = name_length * sizeof(WCHAR);
	local_drv_name.MaximumLength = local_drv_name.Length + sizeof(UNICODE_NULL);
	local_drv_name.Buffer = name_buffer;


	//
	// Initializing the object attributes [PERMANENT, CASE_SENSITIVE, KERNEL_HANLE]
	//
	InitializeObjectAttributes(&obj_attribs, &local_drv_name, OBJ_PERMANENT | OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);


	//
	// Creating the driver object itself [ObCreateObject exported by ntoskrnl.exe]
	//
	status = ObCreateObject(KernelMode, IoDriverObjectType, &obj_attribs, KernelMode, NULL, obj_size, 0, 0, (PVOID*)&drv_obj);
	if (!NT_SUCCESS(status))
		return status;


	//
	// Setting up the driver object
	// 
	RtlZeroMemory(drv_obj, obj_size);				// Cleaning up
	drv_obj->Type	= IO_TYPE_DRIVER;				// Specifying the driver type
	drv_obj->Size	= sizeof(DRIVER_OBJECT);			// Setting its size
	drv_obj->Flags	= DRVO_BUILTIN_DRIVER;				// Setting it as a BUILTIN_DRIVER					
	drv_obj->DriverExtension = (PDRIVER_EXTENSION)(drv_obj + 1);	// Setting up the driver extension
	drv_obj->DriverExtension->DriverObject = drv_obj;		// Assigning the driver 
	drv_obj->DriverInit = EntryPoint;				// Setting the driver entry point


	//
	// We need to set the IRPP_MJ functions to IopInvalidDeviceRequest
	//
	for (int i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
	{
		drv_obj->MajorFunction[i] = IopInvalidDeviceRequest;
	}


	//
	// Setting up the service key for the driver
	//
	service_key_name.MaximumLength = local_drv_name.Length + sizeof(UNICODE_NULL);
	service_key_name.Buffer = (PWCH)ExAllocatePool2(POOL_FLAG_PAGED, local_drv_name.MaximumLength, (ULONG)KeQueryUnbiasedInterruptTime());
	if (!service_key_name.Buffer)
	{
		ObMakeTemporaryObject(drv_obj);
		ObfDereferenceObject(drv_obj);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlCopyUnicodeString(&service_key_name, &local_drv_name);
	service_key_name.Buffer[service_key_name.Length / sizeof(WCHAR)] = UNICODE_NULL;
	drv_obj->DriverExtension->ServiceKeyName = service_key_name;


	//
	// Saving the driver name within the driver object
	//
	drv_obj->DriverName.MaximumLength = local_drv_name.Length;
	drv_obj->DriverName.Buffer = (PWCH)ExAllocatePool2(POOL_FLAG_PAGED, drv_obj->DriverName.MaximumLength, (ULONG)KeQueryUnbiasedInterruptTime());
	if (!drv_obj->DriverName.Buffer)
	{
		ObMakeTemporaryObject(drv_obj);
		ObfDereferenceObject(drv_obj);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlCopyUnicodeString(&drv_obj->DriverName, &local_drv_name);

	
	//
	// Creating the kernel object (DRIVER_OBJECT) so we can get its handle
	// 
	status = ObInsertObject(drv_obj, NULL, FILE_READ_DATA, 0, NULL, &drv_handle);
	ZwClose(drv_handle);
	if (!NT_SUCCESS(status))
	{
		ObMakeTemporaryObject(drv_obj);
		ObfDereferenceObject(drv_obj);
		return status;
	}


	//
	// Actually starting the driver's entry point (passing the driver object)
	// 
	status = EntryPoint(drv_obj, NULL);
	if (!NT_SUCCESS(status))
	{
		ObMakeTemporaryObject(drv_obj);
		ObDereferenceObject(drv_obj);
		return status;
	}


	//
	// Since having the IRP_MJ functions set to null it's illegal
	// we gotta set them to IopInvalidDeviceRequest
	// 
	for (int i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
	{
		if (!drv_obj->MajorFunction[i])
		{
			drv_obj->MajorFunction[i] = IopInvalidDeviceRequest;
		}
	}

	return status; // If everything went correctly this will return the driver's result
}

```

`Example/Example.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34728.123
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Test", "Test\Test.vcxproj", "{E655C6DF-9749-4334-BCB0-3A114D977A4A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Debug|ARM64.Build.0 = Debug|ARM64
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Debug|x64.ActiveCfg = Debug|x64
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Debug|x64.Build.0 = Debug|x64
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Debug|x64.Deploy.0 = Debug|x64
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Release|ARM64.ActiveCfg = Release|ARM64
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Release|ARM64.Build.0 = Release|ARM64
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Release|ARM64.Deploy.0 = Release|ARM64
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Release|x64.ActiveCfg = Release|x64
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Release|x64.Build.0 = Release|x64
		{E655C6DF-9749-4334-BCB0-3A114D977A4A}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {53EE3A09-F352-4D55-8772-1B619561D17C}
	EndGlobalSection
EndGlobal

```

`Example/Test/Driver.c`:

```c
/*
	******************************************************
	*  Author: Th3Spl                                    *
	*  Lang: C++ | Usable in C as well                   *
	*  Date: 27/12/2023                                  * 
	*  Purpose: IoCreateDriver Implementation Example    *
	******************************************************
*/


//
// Inclusions
//
#include <ntifs.h>

// Include CreateDriver header
#include "IoCreateDriver/CreateDriver.h"


//
// Our custom entry point in which our DriverObject field will be a valid pointer
// 
NTSTATUS CustomDriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath )
{
	// Unreferenced parameter
	UNREFERENCED_PARAMETER( RegistryPath );


	//
	// Showing in DebugView the DriverObject's ptr which now will be valid
	//
	DbgPrintEx( 0, 0, "[+] DriverObject: %p", DriverObject );


	//
	// Returning normally
	//  
	return STATUS_SUCCESS;
}


//
// Real entry point
// 
// - Assuming that we're manual mapping the DriverObject field will be invalid
// therefore we're gonna use IoCreateDriver implementation to get a valid DriverObject
// 
// REMEMBER: 
// if you're manual mapping:
//		- Go in C/C++ in settings and disable "Security Check"
//		- Go in linker and set the entry point to "DriverEntry"
//
NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath )
{
	// Unreferenced parameters (Both invalid because we're manual mapping)
	UNREFERENCED_PARAMETER( DriverObject );
	UNREFERENCED_PARAMETER( RegistryPath );


	//
	// Now we just have to pass the custom entry point as parameter so that the IoCreateDriver function 
	// can provide a valid DriverObject pointer
	//
	return IoCreateDriver( CustomDriverEntry );
}

```

`Example/Test/IoCreateDriver/CreateDriver.h`:

```h
/*
	***************************************************
	*  Author: Th3Spl                                 *
	*  Lang: C++ | Usable in C as well                *
	*  Date: 27/12/2023                               *
	*  Purpose: IoCreateDriver Implementation         *
	***************************************************
*/

#pragma once

//
// Inclusions
//
#include <ntifs.h>
#include <ntstrsafe.h>
#include <windef.h>
#include "definitions.h"


//
// Dummy function used as default function for the IRP_MJ functions
//
NTSTATUS NTAPI IopInvalidDeviceRequest( _In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp )
{
	UNREFERENCED_PARAMETER( DeviceObject );
	Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return STATUS_INVALID_DEVICE_REQUEST;
}


//
// Custom IoCreateDriver in order to bypass PsLoadedModule and EtwTiLogDriverObjectLoad 
// it makes easier tohe usage of IOCTL if you're using KdMapper
// 
NTSTATUS __fastcall IoCreateDriver( _In_ NTSTATUS( __fastcall* EntryPoint )( _In_ PDRIVER_OBJECT, _In_ PUNICODE_STRING ) )
{
	//
	// Variables
	//
	HANDLE drv_handle;
	USHORT name_length;
	WCHAR name_buffer[100];
	PDRIVER_OBJECT drv_obj;
	OBJECT_ATTRIBUTES obj_attribs;
	UNICODE_STRING local_drv_name;
	UNICODE_STRING service_key_name;
	NTSTATUS status = STATUS_SUCCESS;
	ULONG obj_size = sizeof( DRIVER_OBJECT ) + sizeof( EXTENDED_DRIVER_EXTENSION );


	//
	// We meed to create a UNICODE_STRING which contains the (randomic) name of the driver (we're not interested in that)
	//
	name_length = ( USHORT )swprintf( name_buffer, L"\\Driver\\%08u", ( ULONG )KeQueryUnbiasedInterruptTime() );
	local_drv_name.Length = name_length * sizeof( WCHAR );
	local_drv_name.MaximumLength = local_drv_name.Length + sizeof( UNICODE_NULL );
	local_drv_name.Buffer = name_buffer;


	//
	// Initializing the object attributes [PERMANENT, CASE_SENSITIVE, KERNEL_HANLE]
	//
	InitializeObjectAttributes( &obj_attribs, &local_drv_name, OBJ_PERMANENT | OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL );


	//
	// Creating the driver object itself [ObCreateObject exported by ntoskrnl.exe]
	//
	status = ObCreateObject( KernelMode, IoDriverObjectType, &obj_attribs, KernelMode, NULL, obj_size, 0, 0, ( PVOID* )&drv_obj );
	if( !NT_SUCCESS( status ) )
		return status;


	//
	// Setting up the driver object
	// 
	RtlZeroMemory( drv_obj, obj_size );				// Cleaning up
	drv_obj->Type = IO_TYPE_DRIVER;				// Specifying the driver type
	drv_obj->Size = sizeof( DRIVER_OBJECT );			// Setting its size
	drv_obj->Flags = DRVO_BUILTIN_DRIVER;				// Setting it as a BUILTIN_DRIVER					
	drv_obj->DriverExtension = ( PDRIVER_EXTENSION )( drv_obj + 1 );	// Setting up the driver extension
	drv_obj->DriverExtension->DriverObject = drv_obj;		// Assigning the driver 
	drv_obj->DriverInit = EntryPoint;				// Setting the driver entry point


	//
	// We need to set the IRPP_MJ functions to IopInvalidDeviceRequest
	//
	for( int i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++ )
	{
		drv_obj->MajorFunction[i] = IopInvalidDeviceRequest;
	}


	//
	// Setting up the service key for the driver
	//
	service_key_name.MaximumLength = local_drv_name.Length + sizeof( UNICODE_NULL );
	service_key_name.Buffer = ( PWCH )ExAllocatePool2( POOL_FLAG_PAGED, local_drv_name.MaximumLength, ( ULONG )KeQueryUnbiasedInterruptTime() );
	if( !service_key_name.Buffer )
	{
		ObMakeTemporaryObject( drv_obj );
		ObfDereferenceObject( drv_obj );
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlCopyUnicodeString( &service_key_name, &local_drv_name );
	service_key_name.Buffer[service_key_name.Length / sizeof( WCHAR )] = UNICODE_NULL;
	drv_obj->DriverExtension->ServiceKeyName = service_key_name;


	//
	// Saving the driver name within the driver object
	//
	drv_obj->DriverName.MaximumLength = local_drv_name.Length;
	drv_obj->DriverName.Buffer = ( PWCH )ExAllocatePool2( POOL_FLAG_PAGED, drv_obj->DriverName.MaximumLength, ( ULONG )KeQueryUnbiasedInterruptTime() );
	if( !drv_obj->DriverName.Buffer )
	{
		ObMakeTemporaryObject( drv_obj );
		ObfDereferenceObject( drv_obj );
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlCopyUnicodeString( &drv_obj->DriverName, &local_drv_name );


	//
	// Creating the kernel object (DRIVER_OBJECT) so we can get its handle
	// 
	status = ObInsertObject( drv_obj, NULL, FILE_READ_DATA, 0, NULL, &drv_handle );
	ZwClose( drv_handle );
	if( !NT_SUCCESS( status ) )
	{
		ObMakeTemporaryObject( drv_obj );
		ObfDereferenceObject( drv_obj );
		return status;
	}


	//
	// Actually starting the driver's entry point (passing the driver object)
	// 
	status = EntryPoint( drv_obj, NULL );
	if( !NT_SUCCESS( status ) )
	{
		ObMakeTemporaryObject( drv_obj );
		ObDereferenceObject( drv_obj );
		return status;
	}


	//
	// Since having the IRP_MJ functions set to null it's illegal
	// we gotta set them to IopInvalidDeviceRequest
	// 
	for( int i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++ )
	{
		if( !drv_obj->MajorFunction[i] )
		{
			drv_obj->MajorFunction[i] = IopInvalidDeviceRequest;
		}
	}

	return status; // If everything went correctly this will return the driver's result
}
```

`Example/Test/IoCreateDriver/definitions.h`:

```h
#pragma once

// Inclusions
#include <ntifs.h>
#include <ntstrsafe.h>
#include <windef.h>

/* Definitions */
__declspec( dllimport ) POBJECT_TYPE IoDriverObjectType;		// IoDriverObjectType

// ObCreateObject
NTSTATUS NTAPI ObCreateObject( IN KPROCESSOR_MODE ProbeMode 	OPTIONAL,
	IN POBJECT_TYPE 	Type,
	IN POBJECT_ATTRIBUTES ObjectAttributes 	OPTIONAL,
	IN KPROCESSOR_MODE 	AccessMode,
	IN OUT PVOID ParseContext 	OPTIONAL,
	IN ULONG 	ObjectSize,
	IN ULONG PagedPoolCharge 	OPTIONAL,
	IN ULONG NonPagedPoolCharge 	OPTIONAL,
	OUT PVOID* Object
);

typedef struct _IO_CLIENT_EXTENSION
{
	struct _IO_CLIENT_EXTENSION* NextExtension;
	PVOID ClientIdentificationAddress;
} IO_CLIENT_EXTENSION, * PIO_CLIENT_EXTENSION;

typedef struct _EXTENDED_DRIVER_EXTENSION
{
	struct _DRIVER_OBJECT* DriverObject;
	PDRIVER_ADD_DEVICE AddDevice;
	ULONG Count;
	UNICODE_STRING ServiceKeyName;
	PIO_CLIENT_EXTENSION ClientDriverExtension;
	PFS_FILTER_CALLBACKS FsFilterCallbacks;
} EXTENDED_DRIVER_EXTENSION, * PEXTENDED_DRIVER_EXTENSION;
```

`Example/Test/Test.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E655C6DF-9749-4334-BCB0-3A114D977A4A}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>Test</RootNamespace>
    <ProjectName>Example</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="IoCreateDriver\CreateDriver.h" />
    <ClInclude Include="IoCreateDriver\definitions.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Example/Test/Test.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="IoCreateDriver\definitions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IoCreateDriver\CreateDriver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Example/Test/Test.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`README.md`:

```md
# IoCreateDriver

I am just sharing an implementation of IoCreateDriver (which can be found in ntoskrnl.exe)
it doesn't log the driver within `PsLoadedModuleList` and it bypasses `EtwTiLogDriverObjectLoad`
<br />
### Build example:
Within the repository is preset an example that must be compiled using VisualStudio in combination
<br />
with the WDK provided by microsoft.
<br />
### If you're manual mapping:
Remember that if you're manual mapping:
 - You must turn off the security check in `ProjectSettings -> C/C++ -> Security Check`
 - You also have to change the entry point from `FxDriverEntry` to `DriverEntry` <br /> which you can find in `ProjectSetting -> Linker -> Entry Point`
<br />
 - Th3Spl

```

`definitions.h`:

```h
#pragma once

// Inclusions
#include <ntifs.h>
#include <ntstrsafe.h>
#include <windef.h>

/* Definitions */
__declspec(dllimport) POBJECT_TYPE IoDriverObjectType;		// IoDriverObjectType

// ObCreateObject
NTSTATUS NTAPI ObCreateObject(IN KPROCESSOR_MODE ProbeMode 	OPTIONAL,
	IN POBJECT_TYPE 	Type,
	IN POBJECT_ATTRIBUTES ObjectAttributes 	OPTIONAL,
	IN KPROCESSOR_MODE 	AccessMode,
	IN OUT PVOID ParseContext 	OPTIONAL,
	IN ULONG 	ObjectSize,
	IN ULONG PagedPoolCharge 	OPTIONAL,
	IN ULONG NonPagedPoolCharge 	OPTIONAL,
	OUT PVOID * Object
);

typedef struct _IO_CLIENT_EXTENSION
{
	struct _IO_CLIENT_EXTENSION* NextExtension;
	PVOID ClientIdentificationAddress;
} IO_CLIENT_EXTENSION, * PIO_CLIENT_EXTENSION;

typedef struct _EXTENDED_DRIVER_EXTENSION
{
	struct _DRIVER_OBJECT* DriverObject;
	PDRIVER_ADD_DEVICE AddDevice;
	ULONG Count;
	UNICODE_STRING ServiceKeyName;
	PIO_CLIENT_EXTENSION ClientDriverExtension;
	PFS_FILTER_CALLBACKS FsFilterCallbacks;
} EXTENDED_DRIVER_EXTENSION, * PEXTENDED_DRIVER_EXTENSION;

```